[
  {
    "start": "0",
    "end": "266000"
  },
  {
    "text": "thank you so much for the intro um yeah so I'm I'm Erin teron uh I'm an employee at Mozilla research and I'm really",
    "start": "11040",
    "end": "17720"
  },
  {
    "text": "excited to tell you about uh our our rust project which is you know been an",
    "start": "17720",
    "end": "22920"
  },
  {
    "text": "ongoing research project for the last uh sort of four or five years in terms of having a lot of Manpower behind it and",
    "start": "22920",
    "end": "28840"
  },
  {
    "text": "is just on the cusp of actually being introduced in 1.0 sort of to the world to use as as a more serious uh product",
    "start": "28840",
    "end": "36600"
  },
  {
    "text": "so um so my background is in programming languages I did research in programming",
    "start": "36600",
    "end": "43000"
  },
  {
    "text": "languages um and it's it's kind of an interesting time to be a person working in programming languages because for for",
    "start": "43000",
    "end": "49719"
  },
  {
    "text": "a long time it had been considered a sort of dead area everybody was happy with C or Java or what have you but in",
    "start": "49719",
    "end": "57120"
  },
  {
    "text": "the last few years there's been this kind of resurgence of Interest in new programming languages with lots of different uh industry groups coming out",
    "start": "57120",
    "end": "63680"
  },
  {
    "text": "with languages uh including Facebook and of course Mozilla so with all these languages uh coming out you might ask",
    "start": "63680",
    "end": "70159"
  },
  {
    "text": "okay what you know what is sort of special about rust why rust why is Mozilla building rust um so the the kind",
    "start": "70159",
    "end": "76840"
  },
  {
    "text": "of headline for rust is Safe Systems programming I'm I'm going to explain what I mean by that in the next few",
    "start": "76840",
    "end": "82799"
  },
  {
    "text": "slides but in terms of sort of the the lineage going into rust you have traditional systems programming",
    "start": "82799",
    "end": "88960"
  },
  {
    "text": "languages like CNC C++ which I'm sure all of you are familiar with and then languages that might be a little less",
    "start": "88960",
    "end": "94479"
  },
  {
    "text": "familiar like ML and has actually I'm curious are who in the room is familiar with either of those languages okay so",
    "start": "94479",
    "end": "101920"
  },
  {
    "text": "quite a few people that's great um so rust is is sort of trying to blend the",
    "start": "101920",
    "end": "107040"
  },
  {
    "text": "best of both of these languages uh to get at this problem of Safe Systems programming what's that avoiding the bo",
    "start": "107040",
    "end": "115240"
  },
  {
    "text": "yes exactly um okay so so one question you might wonder is why is Mozilla",
    "start": "115240",
    "end": "122560"
  },
  {
    "text": "interested in creating a programming language so you probably all of you know that Mozilla is the organization that created",
    "start": "122560",
    "end": "129959"
  },
  {
    "text": "the Firefox web browser um which is currently written in C++ and it turns out actually that web",
    "start": "129959",
    "end": "136120"
  },
  {
    "text": "browsers have a a sort of need for a combination of things that are in deep",
    "start": "136120",
    "end": "142560"
  },
  {
    "text": "tension so on the one hand web browsers need a high degree of control over the machine um they're they're sort of asked",
    "start": "142560",
    "end": "149560"
  },
  {
    "text": "to do do very complex tasks very quickly they're asked to display media they're asked to have you know all of these tabs",
    "start": "149560",
    "end": "155720"
  },
  {
    "text": "uh running simultaneously um running code that's untrusted uh you know that's been downloaded from the internet and then on",
    "start": "155720",
    "end": "163159"
  },
  {
    "text": "the other hand they need safety because they're running this untrusted code from the internet right and everybody's out",
    "start": "163159",
    "end": "168480"
  },
  {
    "text": "there trying to break into your machine and these two are sort of at odds because languages like C and C++ that",
    "start": "168480",
    "end": "174920"
  },
  {
    "text": "give you the kind of control you need uh to get the performance for a competitive browser also leave you open to all kinds",
    "start": "174920",
    "end": "181720"
  },
  {
    "text": "of security vulnerabilities right and so you're constantly hearing this uh you know Firefox has been patched or Chrome",
    "start": "181720",
    "end": "187720"
  },
  {
    "text": "has been patched you know somebody can break into your machine uh through a website so the idea is we want to build",
    "start": "187720",
    "end": "195080"
  },
  {
    "text": "the Next Generation web browser which is a project called Servo and we want to do it in a new language that tries to do",
    "start": "195080",
    "end": "201280"
  },
  {
    "text": "better at giving you safety and control at the same time okay and so rust and",
    "start": "201280",
    "end": "207200"
  },
  {
    "text": "Sero are kind of the symbiotic pair of research projects okay so that's that's the really high Lev picture now I want to spend a little",
    "start": "207200",
    "end": "214280"
  },
  {
    "text": "bit of time going into more detail about exactly what I mean by control and what I mean by safety so let's start with",
    "start": "214280",
    "end": "220519"
  },
  {
    "text": "control so C++ is is sort of the best uh existing language in this respect um and",
    "start": "220519",
    "end": "227840"
  },
  {
    "text": "even in just a small snippit of code we can start to see the kind of control that you get over the machine so for example if we declare a",
    "start": "227840",
    "end": "235439"
  },
  {
    "text": "vector in C++ we know exactly how that's going to be laid out in terms of uh you",
    "start": "235439",
    "end": "241640"
  },
  {
    "text": "know the the memory so in particular there are some fields of the vector uh including a pointer to the actual data",
    "start": "241640",
    "end": "248000"
  },
  {
    "text": "and some metadata about it that all live on the stack and it's very important that that data is allocated on the stack",
    "start": "248000",
    "end": "253799"
  },
  {
    "text": "and then there's a pointer that goes directly to the Heap on the and in this particular case we're we have a vector",
    "start": "253799",
    "end": "259799"
  },
  {
    "text": "that's containing a string and we sort of have the same pattern again where the string is itself another vector and the",
    "start": "259799",
    "end": "266960"
  },
  {
    "start": "266000",
    "end": "367000"
  },
  {
    "text": "relevant uh sort of uh pointer and metadata is stored in line in the array so to actually get at a piece of string",
    "start": "266960",
    "end": "273800"
  },
  {
    "text": "data you follow these two IND directions one to get into the the vector itself on the on the Heap and then one more to get",
    "start": "273800",
    "end": "279759"
  },
  {
    "text": "into the string and we'll contrast that with some other languages in a second but the the high level Point here is you",
    "start": "279759",
    "end": "285479"
  },
  {
    "text": "have you know exactly what things are going to look like in memory and you you have a lot of control over that",
    "start": "285479",
    "end": "291840"
  },
  {
    "text": "layout uh in addition C++ gives you various kinds of",
    "start": "291840",
    "end": "297160"
  },
  {
    "text": "pointers including things like these lightweight references which can point into the Heap and they can point into the stack and there's",
    "start": "297160",
    "end": "303320"
  },
  {
    "text": "there's no overhead for doing so you have sort of all of the Power you're you're normally used to with",
    "start": "303320",
    "end": "308759"
  },
  {
    "text": "pointers and then finally there's something implicit here which if you know C++ is sort of obvious um so at the",
    "start": "308759",
    "end": "315280"
  },
  {
    "text": "end of this function the vector goes out of scope and as a result its Destructor",
    "start": "315280",
    "end": "320319"
  },
  {
    "text": "is run and its memory is freed um you didn't have to say anything for that to happen so that's a nice convenience but",
    "start": "320319",
    "end": "325800"
  },
  {
    "text": "on the other hand you know exactly when it's going to happen by reasoning about the scope so that's in contrast to something like garbage collection where",
    "start": "325800",
    "end": "332520"
  },
  {
    "text": "the data might be freed at some point in the future but you don't know exactly when you can't control it it might be",
    "start": "332520",
    "end": "338720"
  },
  {
    "text": "inconvenient okay one of the principles that you get out of C++ is something",
    "start": "339240",
    "end": "344840"
  },
  {
    "text": "often called zero cost abstraction and what this means is that you can build up libraries like vectors and strings that",
    "start": "344840",
    "end": "351800"
  },
  {
    "text": "are reasonably convenient to use they give you a nice abstraction but when you compile it down it's nothing different",
    "start": "351800",
    "end": "358639"
  },
  {
    "text": "than you know something you could have written by hand in assembly you you're sort of not giving up any performance in",
    "start": "358639",
    "end": "364000"
  },
  {
    "text": "in doing this okay now if you look at it a language that is safe but doesn't give",
    "start": "364000",
    "end": "370720"
  },
  {
    "start": "367000",
    "end": "435000"
  },
  {
    "text": "you control like Java the story is very different so in Java if we tried to sort",
    "start": "370720",
    "end": "375840"
  },
  {
    "text": "of set up the same scenario where we have a vector containing strings we have layers and layers of indirection because",
    "start": "375840",
    "end": "381919"
  },
  {
    "text": "Java enforces a kind of uniform representation on everything it doesn't give you control over stack layout",
    "start": "381919",
    "end": "388120"
  },
  {
    "text": "versus Heap layout and so on and so forth right and so in Java any abstraction comes at a",
    "start": "388120",
    "end": "395039"
  },
  {
    "text": "cost and I want to I want to be clear here I've been focusing on memory layout as a relatively simple example but this",
    "start": "395039",
    "end": "401639"
  },
  {
    "text": "applies to many many things um so being able to choose between static dispatch",
    "start": "401639",
    "end": "406880"
  },
  {
    "text": "and dynamic dispatch again in Java basically everything is dynamically dispatched everything is going through objects in C++ you have the choice um",
    "start": "406880",
    "end": "414000"
  },
  {
    "text": "template expansion is related to that and there there are many more examples so what we what we want",
    "start": "414000",
    "end": "420199"
  },
  {
    "text": "is this to retain this notion of zero cost abstractions and control from C++",
    "start": "420199",
    "end": "425319"
  },
  {
    "text": "but to somehow get the kind of safety uh that languages like Java ml hascal uh",
    "start": "425319",
    "end": "431520"
  },
  {
    "text": "and so on provide okay so so now what do I mean by safety so let's go back to this example",
    "start": "431520",
    "end": "437720"
  },
  {
    "start": "435000",
    "end": "670000"
  },
  {
    "text": "in C++ where we've we've set up a vector we have a pointer into that vector and",
    "start": "437720",
    "end": "443680"
  },
  {
    "text": "let's let's just say for the sake of argument the vector has one element and a capacity of one right now if if we",
    "start": "443680",
    "end": "450080"
  },
  {
    "text": "then uh try to push an element onto the vector well it's out of capacity so it's",
    "start": "450080",
    "end": "455960"
  },
  {
    "text": "going to have to allocate a new chunk of memory and copy over the data and at that point it'll swing the",
    "start": "455960",
    "end": "462560"
  },
  {
    "text": "data pointer right to that new location on the Heap problem is we're left here with the",
    "start": "462560",
    "end": "470520"
  },
  {
    "text": "existing reference Lum to the old location on the Heap right that hasn't been updated so this is the classic",
    "start": "470520",
    "end": "475840"
  },
  {
    "text": "dangling pointer problem and of course if you then go on to D reference that pointer bad things can happen people can",
    "start": "475840",
    "end": "482400"
  },
  {
    "text": "break into your machine right this is this is the source of security exploits like a very simple example",
    "start": "482400",
    "end": "488680"
  },
  {
    "text": "okay so I want to sort of take a closer look at exactly what went wrong here",
    "start": "488680",
    "end": "494879"
  },
  {
    "text": "what are the ingredients we need to create this kind of security problem so basically I want to say we",
    "start": "494879",
    "end": "502199"
  },
  {
    "text": "need two things happening at the same time one of them is aliasing that is we have two pointers to the same or",
    "start": "502199",
    "end": "508080"
  },
  {
    "text": "multiple pointers to the same memory application right so we had the data pointer which was being updated and then",
    "start": "508080",
    "end": "513680"
  },
  {
    "text": "this LM pointer which sort of didn't know about the update that happened so alas thing is one thing and then",
    "start": "513680",
    "end": "518959"
  },
  {
    "text": "mutation is the other right if if you weren't allowed to change the data then this problem wouldn't happen so it's",
    "start": "518959",
    "end": "524159"
  },
  {
    "text": "this combination of having multiple pointers and being able to change the data under under those pointers that can",
    "start": "524159",
    "end": "530120"
  },
  {
    "text": "cause things to get out of sync and then you can read unallocated memory and by the way please ask",
    "start": "530120",
    "end": "536680"
  },
  {
    "text": "questions throughout um are there any questions up to this Point yeah what architectures right now",
    "start": "536680",
    "end": "544600"
  },
  {
    "text": "have you implemented your language on so the um rust uses llvm as a backend um so",
    "start": "544600",
    "end": "553360"
  },
  {
    "text": "basically it supports all of the architectures that llvm does um we on the other hand you know I sort of that's",
    "start": "553360",
    "end": "559880"
  },
  {
    "text": "that's the in principle answer um you know there's there's a lot of work to make different things like the standard",
    "start": "559880",
    "end": "565200"
  },
  {
    "text": "Library work on on those architectures um but we work on uh you know uh x86",
    "start": "565200",
    "end": "571600"
  },
  {
    "text": "machines we work on arm um Power and and a few others I mean it's mostly major",
    "start": "571600",
    "end": "576720"
  },
  {
    "text": "architectures at this point yeah so how much do you depend on the safety of lvm",
    "start": "576720",
    "end": "582120"
  },
  {
    "text": "lvm makes Transformations on the abstract syntax Tre and eventually walks to generate code yeah produces uh",
    "start": "582120",
    "end": "590279"
  },
  {
    "text": "various optimizations it makes assumptions about the safety of those Transformations right so that's that's a",
    "start": "590279",
    "end": "597000"
  },
  {
    "text": "that's a really great question um so you know one interesting thing about targeting llvm is that we inherit a lot",
    "start": "597000",
    "end": "605279"
  },
  {
    "text": "from CN C++ because that's sort of where lvm is targeted and as we'll see later",
    "start": "605279",
    "end": "610959"
  },
  {
    "text": "in the talk in CN C++ there's this notion of undefined behavior um",
    "start": "610959",
    "end": "616200"
  },
  {
    "text": "something like re D referencing a pointer like this and part of the idea of undefined behavior is it's a contract",
    "start": "616200",
    "end": "622040"
  },
  {
    "text": "between you and the compiler if you do something like this the compiler is free to optimize it in crazy ways I mean",
    "start": "622040",
    "end": "628200"
  },
  {
    "text": "basically you have no guarant about the semantics of your program right on the other hand if you don't have undefined",
    "start": "628200",
    "end": "634720"
  },
  {
    "text": "Behavior everything is supposed to work out hunky dory right and so part of part of the idea with rust is that it gives",
    "start": "634720",
    "end": "641480"
  },
  {
    "text": "you a lot of tools where basically if you if you follow the discipline I'll be showing you in Rust um and the compiler",
    "start": "641480",
    "end": "647600"
  },
  {
    "text": "enforces that then you never introduce undefined Behavior right it's only if",
    "start": "647600",
    "end": "653000"
  },
  {
    "text": "you sort of break out of the rules you haven't mentioned anything about multithreading and the problems that",
    "start": "653000",
    "end": "658600"
  },
  {
    "text": "will come from that right so I'll spend about half of the talk talking about",
    "start": "658600",
    "end": "663680"
  },
  {
    "text": "concurrency any other questions all right um so one thing you",
    "start": "663680",
    "end": "669760"
  },
  {
    "text": "might be wondering is uh you know doesn't garbage collection solve certainly the safety problem um well as",
    "start": "669760",
    "end": "677360"
  },
  {
    "start": "670000",
    "end": "746000"
  },
  {
    "text": "I sort of already mentioned garbage collection gives up a lot of control in particular you you lose that",
    "start": "677360",
    "end": "682920"
  },
  {
    "text": "deterministic destruction um where resources are freed and it also requires a runtime um which is a sort of",
    "start": "682920",
    "end": "690800"
  },
  {
    "text": "substantial abstraction penalty that you're paying but there's sort of a more interesting reason that garbage",
    "start": "690800",
    "end": "696360"
  },
  {
    "text": "collection isn't the whole answer here which is that you know garbage collection solves a certain category of",
    "start": "696360",
    "end": "702680"
  },
  {
    "text": "problems like memory safety problems like the dangling pointer problem I showed you but there are many other classes of bugs that garbage collection",
    "start": "702680",
    "end": "709440"
  },
  {
    "text": "doesn't give you any help with um such as iterator invalidation where you have a piece of code that's uh iterating over",
    "start": "709440",
    "end": "716480"
  },
  {
    "text": "some data structure and makes a call that updates that data structure therefore sort of invalidating the",
    "start": "716480",
    "end": "721720"
  },
  {
    "text": "iterator right that's garbage collection is completely orthogonal to that um and there's also something called Data races",
    "start": "721720",
    "end": "727880"
  },
  {
    "text": "which come up with concurrency and I'll spend a while talking about that later so I just want to say garbage collection",
    "start": "727880",
    "end": "732920"
  },
  {
    "text": "is even if you willing to give up some control it still doesn't solve all the problems you might want to solve um but",
    "start": "732920",
    "end": "739320"
  },
  {
    "text": "rust will actually help you with with all of these problems okay so that's that's the problem space those are the goals so",
    "start": "739320",
    "end": "746040"
  },
  {
    "start": "746000",
    "end": "843000"
  },
  {
    "text": "what is rust um so at heart rust is about",
    "start": "746040",
    "end": "751880"
  },
  {
    "text": "ownership um there's there's a a discipline built deep into the type system that enforces a notion of",
    "start": "751880",
    "end": "758079"
  },
  {
    "text": "ownership and a sort of related notion of borrowing so the idea is that every resource in the language always has an",
    "start": "758079",
    "end": "765839"
  },
  {
    "text": "owner at all times and by resource I I mean things like a vector but I also mean things like a file or a lock it can",
    "start": "765839",
    "end": "773240"
  },
  {
    "text": "it can mean a wide variety of things um when once you have some resource you can",
    "start": "773240",
    "end": "779320"
  },
  {
    "text": "lend it out on a sort of temporary basis that's that's what we call borrowing and when a resource is",
    "start": "779320",
    "end": "787040"
  },
  {
    "text": "borrowed then it you know certain restrictions apply uh so for example it might not be mutable or it certainly",
    "start": "787040",
    "end": "793519"
  },
  {
    "text": "can't be freed until the owner actually says I'm done with the object okay that that's owners at a very high level I'm",
    "start": "793519",
    "end": "799440"
  },
  {
    "text": "going to be explaining this at sort of increasing levels of detail but that's that's the the core",
    "start": "799440",
    "end": "804480"
  },
  {
    "text": "solution so sort of in graphical form how does this help well B basically it",
    "start": "804480",
    "end": "810079"
  },
  {
    "text": "solves all of the problems that I've mentioned you don't need a runtime um to",
    "start": "810079",
    "end": "815120"
  },
  {
    "text": "follow this discipline it's totally done at compile time in the type system so that puts you sort of in the ballpark of",
    "start": "815120",
    "end": "821839"
  },
  {
    "text": "a language like C++ giving you the control that you wanted you get memory safety which was one of the benefits of",
    "start": "821839",
    "end": "827720"
  },
  {
    "text": "garbage collection but then you also get data race Freedom which there aren't really mainstream techniques that that",
    "start": "827720",
    "end": "834199"
  },
  {
    "text": "give you that kind of guarantee and again I I'll come back and explain exactly what I mean by data race freedom but it has to do with concurrency",
    "start": "834199",
    "end": "841600"
  },
  {
    "text": "bugs um okay and then I just want to briefly say you know I I'm going to spend the rest of the talk basically",
    "start": "841600",
    "end": "847560"
  },
  {
    "start": "843000",
    "end": "1196000"
  },
  {
    "text": "focusing on this notion of ownership and borrowing because that is really the heart of rust but the fact that rust is",
    "start": "847560",
    "end": "854639"
  },
  {
    "text": "as successful as as it has been uh sort of as an early project has to do with a lot of other things as well um so rust",
    "start": "854639",
    "end": "861199"
  },
  {
    "text": "feels like a very modern language it inherit it borrows a lot of ideas from languages like ML and has that make it",
    "start": "861199",
    "end": "867639"
  },
  {
    "text": "feel very nice to program in despite the fact that you're sort of dealing at this",
    "start": "867639",
    "end": "872839"
  },
  {
    "text": "low level of abstraction and exercising this kind of control and then finally I have to I",
    "start": "872839",
    "end": "878440"
  },
  {
    "text": "just have to give credit to the open source Community around rust um part I want to I I introduced this slide both",
    "start": "878440",
    "end": "885759"
  },
  {
    "text": "to give credit but also to say to invite all of you to join this community it's very open um you know very welcoming if",
    "start": "885759",
    "end": "892399"
  },
  {
    "text": "if you're interested in this stuff it's it's very easy to get plugged in okay so",
    "start": "892399",
    "end": "897880"
  },
  {
    "text": "now let's actually dive into some of the details so I'm going to start by talking about the core concept of ownership",
    "start": "897880",
    "end": "903839"
  },
  {
    "text": "which is very simple and then we'll move on to borrowing okay so at the stick figure",
    "start": "903839",
    "end": "912120"
  },
  {
    "text": "level um imagine you have some resource like a book so as I said these resources",
    "start": "912120",
    "end": "918600"
  },
  {
    "text": "always have a clear owner at all times so right now we have an owner on the left ownership can be transferred to a",
    "start": "918600",
    "end": "926800"
  },
  {
    "text": "different party and at that point the original owner is irrelevant um so you can think of owners here as threads you",
    "start": "926800",
    "end": "933440"
  },
  {
    "text": "can think of them as functions pieces of code um but basically ownership transfer",
    "start": "933440",
    "end": "938720"
  },
  {
    "text": "makes the original owner irrelevant and when the final owner says I'm I'm done",
    "start": "938720",
    "end": "944160"
  },
  {
    "text": "with this resource uh the resource is destroyed in the same way that the you",
    "start": "944160",
    "end": "949600"
  },
  {
    "text": "know we saw the vector example before the destructor is run so it's only when the final owner just drops it on the",
    "start": "949600",
    "end": "955360"
  },
  {
    "text": "floor that the destructor is run just like it is in C++ okay that's it very very simple",
    "start": "955360",
    "end": "961120"
  },
  {
    "text": "discipline so in terms of you know remember we we looked at this problem of",
    "start": "961120",
    "end": "966160"
  },
  {
    "text": "uh memory unsafety and said you sort of need these two things aliasing and mutation at the same time to cause this",
    "start": "966160",
    "end": "971639"
  },
  {
    "text": "problem so ownership chooses basically to forbid aliasing there's always",
    "start": "971639",
    "end": "977120"
  },
  {
    "text": "exactly one owner there's basically only one Alias that can be used at any time U",
    "start": "977120",
    "end": "982319"
  },
  {
    "text": "for an owned resource but the owner can do anything they like to the object so they can certainly mutate it okay that's",
    "start": "982319",
    "end": "989040"
  },
  {
    "text": "the stick figure version now let's see the same thing with some",
    "start": "989040",
    "end": "994279"
  },
  {
    "text": "code oh yeah question uh ownership is a property that",
    "start": "994279",
    "end": "1000279"
  },
  {
    "text": "exists only compli yes and",
    "start": "1000279",
    "end": "1005399"
  },
  {
    "text": "so uh is it true that there are not algorithms where ownership is mutable",
    "start": "1005399",
    "end": "1013680"
  },
  {
    "text": "and usable at execution time and then the actually have a representation for",
    "start": "1013680",
    "end": "1021800"
  },
  {
    "text": "type of type right um uh again great question that you you keep sort of looking",
    "start": "1021800",
    "end": "1028079"
  },
  {
    "text": "forward ahead to some stuff I'll cover later in the talk um so yes I mean th so",
    "start": "1028079",
    "end": "1034120"
  },
  {
    "text": "certainly this basic ownership discipline before we get to borrowing is way too restrictive to to write many",
    "start": "1034120",
    "end": "1040720"
  },
  {
    "text": "algorithms it's actually surprising it it gets you surprisingly far for programming applications that just use",
    "start": "1040720",
    "end": "1047760"
  },
  {
    "text": "libraries of existing dat structures and so on but if you wanted to implement a dou link list you'd be in trouble with",
    "start": "1047760",
    "end": "1055320"
  },
  {
    "text": "this approach right and that's a pretty core data structure so I'm going to come back to this point there are various",
    "start": "1055320",
    "end": "1061200"
  },
  {
    "text": "ways to bend the rules um but it's it's all carefully encapsulated other other questions",
    "start": "1061200",
    "end": "1068080"
  },
  {
    "text": "before we move on okay so so so I want to come back now",
    "start": "1068080",
    "end": "1073799"
  },
  {
    "text": "this is an example now now we're looking at rust but it's sort of similar to what we saw uh with C++ earlier so um we you",
    "start": "1073799",
    "end": "1082240"
  },
  {
    "text": "know introduce a vector it's laid out on the stock exactly as it was in C++ um when when we create the vector",
    "start": "1082240",
    "end": "1089720"
  },
  {
    "text": "it's owned by this piece of code on the left um so that owner can go ahead and mutate it it can push elements onto the",
    "start": "1089720",
    "end": "1096840"
  },
  {
    "text": "vector that's totally fine um and then at some point it can",
    "start": "1096840",
    "end": "1103240"
  },
  {
    "text": "pass that Vector to another function and notice this function take is just writing the type VEC",
    "start": "1103240",
    "end": "1110640"
  },
  {
    "text": "directly no no sort of incantations or anything else by default if you if you",
    "start": "1110640",
    "end": "1117159"
  },
  {
    "text": "just write a plain type what you're saying is that when you pass me this argument you are actually passing ownership of that value okay so this",
    "start": "1117159",
    "end": "1124559"
  },
  {
    "text": "borrowing stuff is is something you will annotate as we'll see later but by default if you if you don't say anything",
    "start": "1124559",
    "end": "1130159"
  },
  {
    "text": "else you're transferring ownership and so that means um uh after this function",
    "start": "1130159",
    "end": "1136039"
  },
  {
    "text": "call to take the original function give no longer has ownership of the vector basically it's completely",
    "start": "1136039",
    "end": "1143159"
  },
  {
    "text": "irrelevant okay and in terms of what this actually looks like uh sort of at runtime when you make the call right",
    "start": "1143159",
    "end": "1150280"
  },
  {
    "text": "you're going to copy the stack data into the stack frame of take and then at that point the original",
    "start": "1150280",
    "end": "1156400"
  },
  {
    "text": "stack data is still there but it's sort of unusable and the type system is going to enforce that as we'll see in a",
    "start": "1156400",
    "end": "1163400"
  },
  {
    "text": "second then take executes and here's a key point if take",
    "start": "1163400",
    "end": "1169240"
  },
  {
    "text": "didn't pass ownership of vector somewhere else we're back into the same situation we saw with the original C++",
    "start": "1169240",
    "end": "1174679"
  },
  {
    "text": "code at the end it's going to free the vector and so now you have what looks",
    "start": "1174679",
    "end": "1180080"
  },
  {
    "text": "like a dangling pointer here but it's great out okay and I'll show you I'll show you what that means at the compiler",
    "start": "1180080",
    "end": "1186159"
  },
  {
    "text": "level right so you might worry what what's to prevent give now from going on",
    "start": "1186159",
    "end": "1192240"
  },
  {
    "text": "and using this Vector which has been deallocated so this is where the type",
    "start": "1192240",
    "end": "1197520"
  },
  {
    "start": "1196000",
    "end": "1499000"
  },
  {
    "text": "system actually comes in and and does some checking for you the type system understands that you've transferred",
    "start": "1197520",
    "end": "1202799"
  },
  {
    "text": "ownership of the vector after this call and so if you then try to use the vector",
    "start": "1202799",
    "end": "1207960"
  },
  {
    "text": "in any way Say by pushing more elements you'll get a compile error that says this Vector has been moved you don't own",
    "start": "1207960",
    "end": "1213840"
  },
  {
    "text": "it anymore you don't have access to it so even though even though there's a dangling pointer in the stack frame it's",
    "start": "1213840",
    "end": "1219880"
  },
  {
    "text": "not usable so it's not causing any trouble right that's that's kind of the point here and eventually that stack",
    "start": "1219880",
    "end": "1225280"
  },
  {
    "text": "frame will be popped of course okay and this this kind of checking uh you know certainly covers",
    "start": "1225280",
    "end": "1232360"
  },
  {
    "text": "basic errors like use after free as we just saw or double moves where you're claiming to transfer ownership to",
    "start": "1232360",
    "end": "1237559"
  },
  {
    "text": "multiple places and we'll see some more examples of of other things that it uh addresses later on any questions about",
    "start": "1237559",
    "end": "1243760"
  },
  {
    "text": "just the basic ownership discipline yeah do um stype like in and",
    "start": "1243760",
    "end": "1252960"
  },
  {
    "text": "everything also are moved this way uh good question um",
    "start": "1252960",
    "end": "1259120"
  },
  {
    "text": "so there's a notion of um uh what what we call Copy types um so thing scalar",
    "start": "1259120",
    "end": "1267640"
  },
  {
    "text": "values like integers are considered copy and what that means is that when you do something like this this function call",
    "start": "1267640",
    "end": "1274200"
  },
  {
    "text": "where it looks like you're moving ownership you still retain access to the original value because basically you're",
    "start": "1274200",
    "end": "1281679"
  },
  {
    "text": "saying that you've just copied the value when when passing it in some sense um and in particular that the the compiler",
    "start": "1281679",
    "end": "1289200"
  },
  {
    "text": "checks whether copy is a valid thing to apply to a type and you can't use it for types that involve the Heap in any way",
    "start": "1289200",
    "end": "1295559"
  },
  {
    "text": "um so it's always shallow scalar types but yeah if you had to follow this discipline for just basic programming",
    "start": "1295559",
    "end": "1301039"
  },
  {
    "text": "with integers you'd be in trouble integers are not resources right they're they're just uh you know values that you",
    "start": "1301039",
    "end": "1307360"
  },
  {
    "text": "can easily copy around anything else okay so now let's look at the other",
    "start": "1307360",
    "end": "1315559"
  },
  {
    "text": "aspect of the ownership system which is borrowing um now there are two forms of borrowing",
    "start": "1315559",
    "end": "1321520"
  },
  {
    "text": "and rust and we'll we'll look at at both of them in turn so the first is uh what",
    "start": "1321520",
    "end": "1327440"
  },
  {
    "text": "we call shared borrowing and it's a little hard to imagine the right physical metaphor here",
    "start": "1327440",
    "end": "1334240"
  },
  {
    "text": "um but it's as if the original owner is able to simultaneously give access to a",
    "start": "1334240",
    "end": "1340679"
  },
  {
    "text": "resource to some shared group of other parties and for that to solve the the",
    "start": "1340679",
    "end": "1348919"
  },
  {
    "text": "safety problems of course we've created aliasing therefore we must rule out mutation while this while this is",
    "start": "1348919",
    "end": "1354760"
  },
  {
    "text": "happening right so so you can share pointers to this thing with all of your",
    "start": "1354760",
    "end": "1360279"
  },
  {
    "text": "friends but none of them are allowed to actually mutate the data through their aliases okay then in contrast there's",
    "start": "1360279",
    "end": "1368360"
  },
  {
    "text": "also a notion of mutable borrowing and in this case um you're sort of lending it out to one party who could for",
    "start": "1368360",
    "end": "1375760"
  },
  {
    "text": "example subsequently lend it out to another party um but there's still only one borrower",
    "start": "1375760",
    "end": "1383400"
  },
  {
    "text": "active at a time right so here we're we're ruling out the uh aliasing but allowing mutation and unlike the",
    "start": "1383400",
    "end": "1390240"
  },
  {
    "text": "ownership transfer sit situation I described before the original owner is sort of still important here there's a a",
    "start": "1390240",
    "end": "1397080"
  },
  {
    "text": "stack discipline basically where ownership is getting returned um from party to party until it goes back to the",
    "start": "1397080",
    "end": "1402840"
  },
  {
    "text": "original owner okay right and as I said this this",
    "start": "1402840",
    "end": "1409400"
  },
  {
    "text": "approach M uh prevents aliasing um and allows mutation okay so that's the stick figure",
    "start": "1409400",
    "end": "1416000"
  },
  {
    "text": "version here's the code version I'll start with shared borrowing okay so the code on the left",
    "start": "1416000",
    "end": "1421640"
  },
  {
    "text": "is pretty similar to what we saw before really the only difference is that there's now this Amper sand in front of",
    "start": "1421640",
    "end": "1428440"
  },
  {
    "text": "the VEC and the code on the right has an Amper sand in front of the type right and that as as we saw in the previous",
    "start": "1428440",
    "end": "1433880"
  },
  {
    "text": "slide that designates a shared burrow right so initially the code on the left owns the vector it can mutate",
    "start": "1433880",
    "end": "1441960"
  },
  {
    "text": "the vector push pushing some contents and then it hands out a borrow of the vector to the code on the right or",
    "start": "1441960",
    "end": "1449360"
  },
  {
    "text": "shared a shared reference um what this looks like at",
    "start": "1449360",
    "end": "1455120"
  },
  {
    "text": "runtime is a little different than what we saw before because these references are just pointers right so this is also",
    "start": "1455120",
    "end": "1462400"
  },
  {
    "text": "reference in the sort of C++ sense okay and then the function on the",
    "start": "1462400",
    "end": "1468159"
  },
  {
    "text": "right can do whatever it does but unlike the case we saw before when it finishes",
    "start": "1468159",
    "end": "1474520"
  },
  {
    "text": "right it's relinquishing ownership not of the vector but of the borrow it's",
    "start": "1474520",
    "end": "1480240"
  },
  {
    "text": "saying basically the the loan has expired and so that pops uh you know the",
    "start": "1480240",
    "end": "1485880"
  },
  {
    "text": "reference off the stack but the original Vector is still available and that means that uh the original code could go on to",
    "start": "1485880",
    "end": "1493120"
  },
  {
    "text": "to mutate it or transfer ownership or do whatever else okay",
    "start": "1493120",
    "end": "1499320"
  },
  {
    "start": "1499000",
    "end": "1539000"
  },
  {
    "text": "now remember I said for this to actually solve the safety problems you can't allow mutation while this is going on so",
    "start": "1499320",
    "end": "1505760"
  },
  {
    "text": "there are certain things you won't be allowed to write in the function in the use function right you can't push things",
    "start": "1505760",
    "end": "1512120"
  },
  {
    "text": "onto the vector you can't mutate the contents of the vector basically it's it's a frozen object from your",
    "start": "1512120",
    "end": "1518480"
  },
  {
    "text": "perspective you can read from it but you cannot modify it in any way and that's all again enforced at compile time by",
    "start": "1518480",
    "end": "1525440"
  },
  {
    "text": "rust type system okay and I'll put an asterisk here",
    "start": "1525440",
    "end": "1531320"
  },
  {
    "text": "because you as I said you can bend the rules in various ways we'll see that a little bit more later okay so that's",
    "start": "1531320",
    "end": "1538679"
  },
  {
    "text": "that was shared references shared barrowing here's an example with mutable references so this is a function that's",
    "start": "1538679",
    "end": "1545799"
  },
  {
    "start": "1539000",
    "end": "1569000"
  },
  {
    "text": "just pushing all the contents of one vector onto another so the source Vector is taken as an immutable Barrow because",
    "start": "1545799",
    "end": "1552399"
  },
  {
    "text": "it doesn't need to be updated and the target ve Vector is taking as a mutable Barrow",
    "start": "1552399",
    "end": "1559159"
  },
  {
    "text": "um and then internally you are allowed excuse me to to call M mutable methods",
    "start": "1559159",
    "end": "1565159"
  },
  {
    "text": "like push on the target Vector because it's a mutable Barrow um and I'm going to skip the",
    "start": "1565159",
    "end": "1572200"
  },
  {
    "start": "1569000",
    "end": "1607000"
  },
  {
    "text": "details here but basically although you're writing this for loop at what seems like a high level using these",
    "start": "1572200",
    "end": "1577559"
  },
  {
    "text": "iterators and so on uh it compiles down to the same kind of code that C++ gives",
    "start": "1577559",
    "end": "1582640"
  },
  {
    "text": "you so there's some zero cost abstraction going on here but that's not super important um",
    "start": "1582640",
    "end": "1589480"
  },
  {
    "text": "um right so in terms of what's going on in the",
    "start": "1589480",
    "end": "1595159"
  },
  {
    "text": "layout as you're iterating over this Vector you're getting references onto the Heap in the form of this Elum and",
    "start": "1595159",
    "end": "1600640"
  },
  {
    "text": "then you're you're pushing copies of those references over onto the other [Music]",
    "start": "1600640",
    "end": "1607440"
  },
  {
    "start": "1607000",
    "end": "1861000"
  },
  {
    "text": "Vector okay now here's an interesting question one thing that can go wrong",
    "start": "1607440",
    "end": "1613720"
  },
  {
    "text": "with this kind of code is if you happen to pass the same Vector as source and destination right let's step through and",
    "start": "1613720",
    "end": "1619039"
  },
  {
    "text": "see exactly what happened so so suppose we've started the loop right we have an",
    "start": "1619039",
    "end": "1624159"
  },
  {
    "text": "LM pointer like this and the next thing we're going to do is push that onto the vector but now we have the same kind of",
    "start": "1624159",
    "end": "1629679"
  },
  {
    "text": "problem we had before if the vector is out of capacity that's going to involve",
    "start": "1629679",
    "end": "1634799"
  },
  {
    "text": "allocating each some new memory and copying over the contents and now we have a dangling pointer again right and",
    "start": "1634799",
    "end": "1641080"
  },
  {
    "text": "so if we continue iterating we're going to try to read a dangling pointer we're going to have the same kind of safety",
    "start": "1641080",
    "end": "1646360"
  },
  {
    "text": "violation parameters uh by value uh or by reference they are",
    "start": "1646360",
    "end": "1652960"
  },
  {
    "text": "something else they are by value but these you know a parameter like this is",
    "start": "1652960",
    "end": "1659919"
  },
  {
    "text": "taking a reference right so it's a little hard to answer that question I guess um",
    "start": "1659919",
    "end": "1666279"
  },
  {
    "text": "yes so you you can think of it as as by value but then you have reference types",
    "start": "1666279",
    "end": "1671880"
  },
  {
    "text": "right yeah yeah um okay so so it would be bad if",
    "start": "1671880",
    "end": "1678960"
  },
  {
    "text": "rust allowed this but it doesn't um so",
    "start": "1678960",
    "end": "1684000"
  },
  {
    "text": "how is this ruled out well we have this this function signature right that says it's taking on the one hand a shared",
    "start": "1684000",
    "end": "1690240"
  },
  {
    "text": "burrow of a vector and on the other hand a mutable burrow of a vector right and then at at the call site we're trying",
    "start": "1690240",
    "end": "1697840"
  },
  {
    "text": "we're taking this borrow right Ampersand you can think of as a sort of request alone right request to borrow this",
    "start": "1697840",
    "end": "1704720"
  },
  {
    "text": "value and the problem is that this we can't have both of these borrows simultaneously so rust is actually",
    "start": "1704720",
    "end": "1711159"
  },
  {
    "text": "tracking which values have been borrowed in what way and it can see that you're trying to borrow the same",
    "start": "1711159",
    "end": "1717600"
  },
  {
    "text": "Vector as a shared borrow and a mutable borrow which would introduce aliasing and mutation and so you get an error",
    "start": "1717600",
    "end": "1724200"
  },
  {
    "text": "that's rolled out okay so so this is another kind of bug that R can catch for",
    "start": "1724200",
    "end": "1729399"
  },
  {
    "text": "you another way of thinking about this is that when you have your hands on uh",
    "start": "1729399",
    "end": "1734600"
  },
  {
    "text": "an ampersand mute value that is the only active Alias of that of the underlying memory",
    "start": "1734600",
    "end": "1741840"
  },
  {
    "text": "at that point right that's the only way to do anything um just to spell this out a",
    "start": "1741840",
    "end": "1749640"
  },
  {
    "text": "little more graphically in an example like this um when we write Ampersand VEC",
    "start": "1749640",
    "end": "1755399"
  },
  {
    "text": "in that let Elum line that introduces a burrow that lasts for the whole scope so",
    "start": "1755399",
    "end": "1760880"
  },
  {
    "text": "if we try to push later on in that scope we we get the same kind of error we got before in the previous example that",
    "start": "1760880",
    "end": "1768200"
  },
  {
    "text": "Vector is burrowed you can't try to you can't mutate it right but once the scope ends the loan is complete and then you",
    "start": "1768200",
    "end": "1774679"
  },
  {
    "text": "can go on and push on the vector right so there's this kind of Stack discipline to borrowing and this fine grain",
    "start": "1774679",
    "end": "1780720"
  },
  {
    "text": "tracking of which values have been borrowed that lets rust catch these kinds of bugs okay so that's the end of",
    "start": "1780720",
    "end": "1787679"
  },
  {
    "text": "the basic ownership and borrowing story um I'm going to talk about concurrency next but before I switch topics I just",
    "start": "1787679",
    "end": "1793279"
  },
  {
    "text": "want to make sure this part was clear yeah so I assume the compiler can do",
    "start": "1793279",
    "end": "1798399"
  },
  {
    "text": "optimizations around a borrow knowing that a non-mutable borrow I should say",
    "start": "1798399",
    "end": "1803919"
  },
  {
    "text": "knowing that that can't be changed so so might actually improve the code over what you might find in other places",
    "start": "1803919",
    "end": "1810480"
  },
  {
    "text": "absolutely and that's something we're not taking as much advantage of right now as we could um because we just use",
    "start": "1810480",
    "end": "1818600"
  },
  {
    "text": "the llvm tool chain and it doesn't it doesn't know this stuff so there we can communicate some of it but I think",
    "start": "1818600",
    "end": "1824799"
  },
  {
    "text": "there's a lot of Avenue for actually getting faster than C+ plus this way because you know so much",
    "start": "1824799",
    "end": "1831120"
  },
  {
    "text": "more any other questions comments before we move",
    "start": "1831120",
    "end": "1836159"
  },
  {
    "text": "on okay so now I want to switch gears and talk about concurrency um which is",
    "start": "1836159",
    "end": "1841519"
  },
  {
    "text": "another enormous source of bugs um that a lot of recent languages are targeting in various ways um and this is I I'm",
    "start": "1841519",
    "end": "1850240"
  },
  {
    "text": "going to sort of go through a Litany of different kinds of approaches to concurrency and the way that that you",
    "start": "1850240",
    "end": "1855320"
  },
  {
    "text": "can model them in Rust and how they help you catch bugs um so let me start with one particularly",
    "start": "1855320",
    "end": "1863200"
  },
  {
    "start": "1861000",
    "end": "2491000"
  },
  {
    "text": "pernicious bug um that comes up in concurrency which is the notion of a data Race So a data race um is defined",
    "start": "1863200",
    "end": "1871320"
  },
  {
    "text": "as having two threads that are accessing a piece of memory where at least one of",
    "start": "1871320",
    "end": "1878279"
  },
  {
    "text": "the threads is doing a right and those accesses are not synchronized in some way",
    "start": "1878279",
    "end": "1884320"
  },
  {
    "text": "um what synchronized means here is is actually quite flexible um there are",
    "start": "1884320",
    "end": "1890120"
  },
  {
    "text": "just simple reads and writes where you just say to the compiler this is considered synchronized and that has certain implications about optimizations",
    "start": "1890120",
    "end": "1896679"
  },
  {
    "text": "so I don't necessarily mean locks or something like that it could be much lower level but this goes back to what I",
    "start": "1896679",
    "end": "1902840"
  },
  {
    "text": "mentioned before if you have a datab race in a c or C++ program the compiler",
    "start": "1902840",
    "end": "1908200"
  },
  {
    "text": "can do anything basically your program has no meaning if you have this kind of bug um because the the optimizer can can",
    "start": "1908200",
    "end": "1915720"
  },
  {
    "text": "sort of break your code arbitrarily but this kind of bug is very very very easy to create by accident okay um and so so",
    "start": "1915720",
    "end": "1925960"
  },
  {
    "text": "and it can because of that undefined Behavior aspect basically this is as problematic for safety as the dangling",
    "start": "1925960",
    "end": "1931880"
  },
  {
    "text": "pointer problems that we were seeing before so if you want a safe language you just can't allow data races at",
    "start": "1931880",
    "end": "1938480"
  },
  {
    "text": "all so the ingredients of data races basically come down to aliasing because",
    "start": "1938600",
    "end": "1945200"
  },
  {
    "text": "you have to have two threads mutation cuz at least one has to be writing and then no ordering which is another way of",
    "start": "1945200",
    "end": "1950679"
  },
  {
    "text": "saying lack of synchronization and of course those first two bullets are familiar from you know what we've seen so far with the",
    "start": "1950679",
    "end": "1956679"
  },
  {
    "text": "ownership and borrowing uh so you might you might expect that we could sort of reuse some",
    "start": "1956679",
    "end": "1962120"
  },
  {
    "text": "of the tools that we've seen already and that turns out actually to be the case um right so I sort of mentioned",
    "start": "1962120",
    "end": "1970200"
  },
  {
    "text": "that there are a lot of languages trying to tackle concurrency bugs in various ways and many of them propose specific",
    "start": "1970200",
    "end": "1975240"
  },
  {
    "text": "models of concurrency um so there's the actor model which is uh a spouse by",
    "start": "1975240",
    "end": "1980440"
  },
  {
    "text": "languages like llang for example um and there in principle you're you're forbidding aliasing so you're passing",
    "start": "1980440",
    "end": "1986880"
  },
  {
    "text": "around owned values between different actors and on the other hand there are functional languages like hasle which",
    "start": "1986880",
    "end": "1993159"
  },
  {
    "text": "let you Alias all you want but dis aot mutation and rust's approach is sort of all of the above in the sense that you",
    "start": "1993159",
    "end": "1999720"
  },
  {
    "text": "can do either of these you can you know as we saw with different kinds of references you could allow or disallow mutation or aliasing and do so at",
    "start": "1999720",
    "end": "2006600"
  },
  {
    "text": "different times okay so that leads to sort of many different concurrency models that you",
    "start": "2006600",
    "end": "2011679"
  },
  {
    "text": "can build up in Rust and all of this is done in Rust libraries it's not built into the language in any way okay so let",
    "start": "2011679",
    "end": "2017919"
  },
  {
    "text": "me start with a really simple discipline which is basically the actor model yeah that's disturbing uh why is not built",
    "start": "2017919",
    "end": "2024559"
  },
  {
    "text": "into the language at some level uh because why is it not built into the language so I actually take this it says",
    "start": "2024559",
    "end": "2030799"
  },
  {
    "text": "that your implementation takes all the concurrency from the very low level of the machine and pushes it up level or",
    "start": "2030799",
    "end": "2038360"
  },
  {
    "text": "two so that you can do things underneath uh between rust and the Machine to",
    "start": "2038360",
    "end": "2045600"
  },
  {
    "text": "accomplish magic right that doesn't seem to be the right thing to do so it's it's",
    "start": "2045600",
    "end": "2051200"
  },
  {
    "text": "it's pretty interesting um when Russ started it was taking a very different",
    "start": "2051200",
    "end": "2056398"
  },
  {
    "text": "approach where concurrency was baked very deeply into the language um and it sort of followed the actor model but",
    "start": "2056399",
    "end": "2061960"
  },
  {
    "text": "over time what we realized was that these kinds of disciplines of concurrency actually just fall out of",
    "start": "2061960",
    "end": "2069679"
  },
  {
    "text": "the ownership system that is and I'm going to show you what that looks like but basically you can build in a library",
    "start": "2069679",
    "end": "2074960"
  },
  {
    "text": "something that gives you the guarantees you want but by not by making it a library and rather than the language",
    "start": "2074960",
    "end": "2081240"
  },
  {
    "text": "it's open-ended anyone can build new libraries you know you can keep adding new concurrency constructs without",
    "start": "2081240",
    "end": "2086520"
  },
  {
    "text": "actually changing the whole language right so I I think it's actually a huge benefit just to add what Dennis was to",
    "start": "2086520",
    "end": "2091599"
  },
  {
    "text": "say getting ready to ask who question about Mage passing of the like you this time right slide but Mr actor",
    "start": "2091599",
    "end": "2098359"
  },
  {
    "text": "sneaker otherwise so he's not throwing snowballs at you okay good I'm",
    "start": "2098359",
    "end": "2105280"
  },
  {
    "text": "safe cool okay well I mean one of the things I want to say is that rust can do the actor model very nicely and in the",
    "start": "2105280",
    "end": "2111599"
  },
  {
    "text": "following way um so so now I'm going to sort of go back to stick figures for a moment and think about these stick",
    "start": "2111599",
    "end": "2118640"
  },
  {
    "text": "figures instead of being different functions that are calling each other different threads that are communicating",
    "start": "2118640",
    "end": "2124119"
  },
  {
    "text": "right and so in the actor model a thread has own of some data and that becomes a",
    "start": "2124119",
    "end": "2129800"
  },
  {
    "text": "message that's passed to another thread and that message passing is supposed to",
    "start": "2129800",
    "end": "2134839"
  },
  {
    "text": "designate ownership transfer um right and then that other thread might form some other message and transfer",
    "start": "2134839",
    "end": "2140200"
  },
  {
    "text": "ownership back over and the key thing is that because it's ownership there can't be aliases so all communication between",
    "start": "2140200",
    "end": "2147920"
  },
  {
    "text": "threads has to go through this message passing okay stick going from stick figures to code here's what this",
    "start": "2147920",
    "end": "2154520"
  },
  {
    "text": "actually looks like in Rust and I'll I'll go through this fairly quickly L but um so we first of all set up a",
    "start": "2154520",
    "end": "2161599"
  },
  {
    "text": "channel and a channel has two ends a transmission end and a receive end in Rust at least in the particular Library",
    "start": "2161599",
    "end": "2167480"
  },
  {
    "text": "we offer um and that looks like sort of this diagram uh in terms of the memory",
    "start": "2167480",
    "end": "2174240"
  },
  {
    "text": "layout so those two ends are sitting there on the stack and then they point to some data on the Heap the actual data",
    "start": "2174240",
    "end": "2179520"
  },
  {
    "text": "is not so important then we spawn some child thread okay and this double pipe syntax",
    "start": "2179520",
    "end": "2186960"
  },
  {
    "text": "don't don't worry about it too much it's basically expands out to we have some piece of code we're writing a function",
    "start": "2186960",
    "end": "2193319"
  },
  {
    "text": "just an anonymous function um that is going to be the body of the child thread we want to run um okay and notice that",
    "start": "2193319",
    "end": "2203800"
  },
  {
    "text": "in that child thread we're mentioning the transmission side okay and there's also this funny keyword move going on",
    "start": "2203800",
    "end": "2209880"
  },
  {
    "text": "right so there there's a lot going on here but the point is by writing move",
    "start": "2209880",
    "end": "2215160"
  },
  {
    "text": "and mentioning the transmission side we're saying this child thread is going to take ownership of the transmission",
    "start": "2215160",
    "end": "2221400"
  },
  {
    "text": "side of the channel okay so after after this spawn",
    "start": "2221400",
    "end": "2226480"
  },
  {
    "text": "the parent thread is not going to be allowed to use TX anymore just as if it had been passed in a",
    "start": "2226480",
    "end": "2232920"
  },
  {
    "text": "function okay and then when the child thread executes it's it allocates a new Vector it does some stuff with that",
    "start": "2232920",
    "end": "2239760"
  },
  {
    "text": "Vector maybe pushes some data into it and then at some point it sends that Vector back across the",
    "start": "2239760",
    "end": "2245760"
  },
  {
    "text": "channel um now this send only involves the stack data basically just just like",
    "start": "2245760",
    "end": "2252200"
  },
  {
    "text": "every other ownership transfer we've seen um which is fairly small right that's just just a few words of data",
    "start": "2252200",
    "end": "2258520"
  },
  {
    "text": "that's being transferred from one thread to the other the bulk of the data which is sitting in the Heap didn't move at all right and and that way you're you're",
    "start": "2258520",
    "end": "2265560"
  },
  {
    "text": "basically you're passing pointers back and forth between threads but you're getting a lot of help from the language to make sure that nothing goes wrong in",
    "start": "2265560",
    "end": "2271560"
  },
  {
    "text": "terms of dangling pointers or aliasing mutation like I've shown you but this is all just using the existing ownership",
    "start": "2271560",
    "end": "2277520"
  },
  {
    "text": "discipline not even any borrowing it's just pure ownership to transfer these between threads is that fairly clear",
    "start": "2277520",
    "end": "2285079"
  },
  {
    "text": "getting something well it seems to me it seems to me that there are two issues",
    "start": "2285079",
    "end": "2290400"
  },
  {
    "text": "here on the one hand you have the the physical representation the data structure on the other hand you have the",
    "start": "2290400",
    "end": "2298760"
  },
  {
    "text": "uh abstract information which may be passed along or copied or moved or",
    "start": "2298760",
    "end": "2304839"
  },
  {
    "text": "mutated and then put back into data structure yes and does the language",
    "start": "2304839",
    "end": "2311480"
  },
  {
    "text": "differentiate strongly between that or is it basically really talking about the",
    "start": "2311480",
    "end": "2318720"
  },
  {
    "text": "representation of the uh of the data in memory and Deals more with the physical",
    "start": "2318720",
    "end": "2326319"
  },
  {
    "text": "layout of that data and its addresses right okay yeah so so basically okay so",
    "start": "2326319",
    "end": "2332800"
  },
  {
    "text": "the question is essentially does there's potentially a distinction",
    "start": "2332800",
    "end": "2338240"
  },
  {
    "text": "between ownership transfer in some abstract sense and the actual physical layout that's involved and how does that",
    "start": "2338240",
    "end": "2344359"
  },
  {
    "text": "look to the language so by default the language unifies the two essentially",
    "start": "2344359",
    "end": "2350560"
  },
  {
    "text": "like when you write a data type there's a sort of you're you're assuming everything in it is owned and and so if",
    "start": "2350560",
    "end": "2357160"
  },
  {
    "text": "you if you pass it along you're passing that stack representation but there are various ways to say to the language you",
    "start": "2357160",
    "end": "2364960"
  },
  {
    "text": "that you want some more abstract notion of ownership and when you do that you're that generally involves breaking out of the",
    "start": "2364960",
    "end": "2371040"
  },
  {
    "text": "ownership system in some way and I'm going to talk about that that little that escape hatch bit at the end but uh",
    "start": "2371040",
    "end": "2379000"
  },
  {
    "text": "so you have the flexibility to do that and that's very important um anything equivalent to a promise uh yes yes there",
    "start": "2379000",
    "end": "2386640"
  },
  {
    "text": "is umu yes and that's also built up as a",
    "start": "2386640",
    "end": "2393200"
  },
  {
    "text": "library okay um here's another different another",
    "start": "2393599",
    "end": "2400000"
  },
  {
    "text": "example of concurrency so we saw the actor model here we're seeing the sort of pure functional model where we're",
    "start": "2400000",
    "end": "2405119"
  },
  {
    "text": "just passing some data to a bunch of threads so that they can read from it right this is a really simple model uh",
    "start": "2405119",
    "end": "2410280"
  },
  {
    "text": "for concurrency and in this case um the thing is we have a bunch of threads that",
    "start": "2410280",
    "end": "2418720"
  },
  {
    "text": "all have access to a vector and it's it may not be clear um at what point the",
    "start": "2418720",
    "end": "2425440"
  },
  {
    "text": "they're done with the vector in some sense right there may not be any single thread that clearly owns the vector or",
    "start": "2425440",
    "end": "2430680"
  },
  {
    "text": "is going to outlive the rest and so there's this notion of Arc which stands for Atomic reference count um which is a",
    "start": "2430680",
    "end": "2437800"
  },
  {
    "text": "smart pointer if you know C++ so it's it's a kind of pointer that does some interesting stuff uh when you work with",
    "start": "2437800",
    "end": "2443119"
  },
  {
    "text": "it and basically it's just maintaining a reference count how many threads are actively looking at this object and when",
    "start": "2443119",
    "end": "2450079"
  },
  {
    "text": "the last thread destroys its Arc basically then the vector itself is destroyed so in some sense The Arc",
    "start": "2450079",
    "end": "2456599"
  },
  {
    "text": "itself owns the vector that's one way of thinking about this but then again you can reason about",
    "start": "2456599",
    "end": "2462000"
  },
  {
    "text": "the layout inside the arc you have the vector just laid out directly exactly as we saw",
    "start": "2462000",
    "end": "2468119"
  },
  {
    "text": "before um and because that is stored uh inside the arc there are no like aliases",
    "start": "2468119",
    "end": "2475079"
  },
  {
    "text": "to the vector itself everything has to go through the Arc in particular The Arc only allows",
    "start": "2475079",
    "end": "2480560"
  },
  {
    "text": "you to get out a shared reference to the vector as you'd expect because it's the whole point is to allow aliasing between",
    "start": "2480560",
    "end": "2487040"
  },
  {
    "text": "different threads okay so that that's pretty simple there's kind of an interesting",
    "start": "2487040",
    "end": "2493319"
  },
  {
    "start": "2491000",
    "end": "3153000"
  },
  {
    "text": "aspect to this though so going back for a second to send like you might use with",
    "start": "2493319",
    "end": "2498400"
  },
  {
    "text": "a channel um it's the library is set up so",
    "start": "2498400",
    "end": "2503520"
  },
  {
    "text": "that when you're sending a type that type has to be marked send what does",
    "start": "2503520",
    "end": "2508960"
  },
  {
    "text": "send mean basically you it means thread safe okay in",
    "start": "2508960",
    "end": "2514640"
  },
  {
    "text": "particular there are two forms of of reference counting that are commonly used in practice there's Atomic",
    "start": "2514640",
    "end": "2519960"
  },
  {
    "text": "reference counting which uses synchronized accesses to change the reference count and then there's sort of",
    "start": "2519960",
    "end": "2525560"
  },
  {
    "text": "non-atomic reference counting which is much faster but it's not safe for use",
    "start": "2525560",
    "end": "2531280"
  },
  {
    "text": "concurrently um so the key thing is that those two types are marked send and not",
    "start": "2531280",
    "end": "2536520"
  },
  {
    "text": "send respectively and therefore you know if you're using the non-atomic version",
    "start": "2536520",
    "end": "2542200"
  },
  {
    "text": "there's no chance that it will ever migrate to another thread and create a thread safety problem so rust is",
    "start": "2542200",
    "end": "2547559"
  },
  {
    "text": "checking that when you pass data between threads that data is actually thread safe to use right and that rolls out",
    "start": "2547559",
    "end": "2553880"
  },
  {
    "text": "another class of of concurrency bugs um",
    "start": "2553880",
    "end": "2560319"
  },
  {
    "text": "okay let's look at some a few other um concurrency models so of course uh we",
    "start": "2560319",
    "end": "2566880"
  },
  {
    "text": "have to talk about locks um rust can do Locks and it has a sort of interesting story there as",
    "start": "2566880",
    "end": "2572760"
  },
  {
    "text": "well um so with with locks right normally you just have some type mutex",
    "start": "2572760",
    "end": "2578040"
  },
  {
    "text": "that represents a lock and you have the ability to acquire the lock or release it at",
    "start": "2578040",
    "end": "2583400"
  },
  {
    "text": "some point but in in Rust the mutex type actually takes another type as an argument and that other type represents",
    "start": "2583400",
    "end": "2590280"
  },
  {
    "text": "the data that the lock protects and so what's kind of interesting about this is the mutex",
    "start": "2590280",
    "end": "2597760"
  },
  {
    "text": "never gives you direct ownership or access to that data instead it gives you",
    "start": "2597760",
    "end": "2604680"
  },
  {
    "text": "a kind of um uh what's what's known known as a guard in C++ so it's a it's a",
    "start": "2604680",
    "end": "2610240"
  },
  {
    "text": "value that points to the data but doesn't give you full ownership um and",
    "start": "2610240",
    "end": "2617720"
  },
  {
    "text": "this is a bit subtle but you'll notice that in this function call I have a lock and I don't say unlock which might seem",
    "start": "2617720",
    "end": "2623440"
  },
  {
    "text": "strange but actually what's going on is that um the",
    "start": "2623440",
    "end": "2629839"
  },
  {
    "text": "guard that I get back when I ask for lock will do the unlock when it's destroyed so I get back this value I can",
    "start": "2629839",
    "end": "2636640"
  },
  {
    "text": "this value data I can use data to to mutate or otherwise access the data protected by the lock and in fact I",
    "start": "2636640",
    "end": "2644280"
  },
  {
    "text": "that's the only way I have of getting to that data and the only way I have of releasing the lock is by destroying my",
    "start": "2644280",
    "end": "2651559"
  },
  {
    "text": "guard data okay and so if you put this all together what this means is there's no",
    "start": "2651559",
    "end": "2658640"
  },
  {
    "text": "way to access data that's supposed to be protected by the lock when you don't own",
    "start": "2658640",
    "end": "2664000"
  },
  {
    "text": "the lock right when when you're not actually in a critical section rolling out yet another classic uh class of",
    "start": "2664000",
    "end": "2670599"
  },
  {
    "text": "concurrency bugs okay that that's maybe a little subtle to see but hopefully the gist is",
    "start": "2670599",
    "end": "2676240"
  },
  {
    "text": "clear yeah to doesn't have to Yes um and that's right so this is a",
    "start": "2676240",
    "end": "2685240"
  },
  {
    "text": "point this is a place where the rules are being bent slightly because obviously locking the mutex does involve mutation under the hood um but you don't",
    "start": "2685240",
    "end": "2694240"
  },
  {
    "text": "want to require a mutable borrow of the mutex because then only one thread could own the mutex right the whole point of a",
    "start": "2694240",
    "end": "2699960"
  },
  {
    "text": "mutex is to allow aliasing across threads so actually what's going on here is very interesting because you know",
    "start": "2699960",
    "end": "2707680"
  },
  {
    "text": "like I just said part of the reason to have aex at all is that you want lots of aliases to some data and for those",
    "start": "2707680",
    "end": "2713599"
  },
  {
    "text": "aliases to be usable for mutation which sounds like a problem from what I've been telling you but the other aspect of",
    "start": "2713599",
    "end": "2719640"
  },
  {
    "text": "mutex is mutual exclusion so it's a mutex is ensuring at runtime that you",
    "start": "2719640",
    "end": "2725200"
  },
  {
    "text": "never have multiple threads mutating at the same time right and so the overall discipline is still followed it's just",
    "start": "2725200",
    "end": "2731920"
  },
  {
    "text": "being performed sort of dynamically um through the synchronization of the mutex rather than completely at compile time",
    "start": "2731920",
    "end": "2738839"
  },
  {
    "text": "okay but that's again just built up as a library does that does that make sense there's a lot going on here it's a",
    "start": "2738839",
    "end": "2744359"
  },
  {
    "text": "little hard to get but so you're using mutex mutex to",
    "start": "2744359",
    "end": "2750720"
  },
  {
    "text": "protect the block and but uh that's a as",
    "start": "2750720",
    "end": "2756200"
  },
  {
    "text": "a uh synchronization mechanism rather rather simple minding you provide as",
    "start": "2756200",
    "end": "2762359"
  },
  {
    "text": "well absolutely um and because this is all built as a library it's sort of",
    "start": "2762359",
    "end": "2767400"
  },
  {
    "text": "completely open-ended what synchronization mechanisms you build um but we have lock free data structures",
    "start": "2767400",
    "end": "2772559"
  },
  {
    "text": "for example and many other forms of more sophisticated like barriers semaphor all",
    "start": "2772559",
    "end": "2777760"
  },
  {
    "text": "kinds of stuff okay um now I want to give one one",
    "start": "2777760",
    "end": "2783800"
  },
  {
    "text": "last example Switching gears from focusing on concurrency and concurrency bugs to parallelism which is closely",
    "start": "2783800",
    "end": "2790480"
  },
  {
    "text": "related but not exactly the same thing right so classic example of an",
    "start": "2790480",
    "end": "2796319"
  },
  {
    "text": "algorithm you might want to parallelize is something like quicksort right a divide and conquer style algorithm so",
    "start": "2796319",
    "end": "2802400"
  },
  {
    "text": "here's sequential quick sort written in Rust um where we're giving we're given",
    "start": "2802400",
    "end": "2808839"
  },
  {
    "text": "access to um uh what's called a slice so I guess I I haven't introduced this",
    "start": "2808839",
    "end": "2813960"
  },
  {
    "text": "notation at the top where it says ve and has these These Bars basically or the the square brackets you can think of",
    "start": "2813960",
    "end": "2820119"
  },
  {
    "text": "that as a sort of fixed size window into a vector so it's not the whole Vector it's just a window into it and that's",
    "start": "2820119",
    "end": "2826559"
  },
  {
    "text": "kind of key for what's going on here because in particular right we we start",
    "start": "2826559",
    "end": "2832160"
  },
  {
    "text": "with this whole slice and we're going to pick a a pivot point",
    "start": "2832160",
    "end": "2837240"
  },
  {
    "text": "um and then once once we've done that we're going to actually partition uh the",
    "start": "2837240",
    "end": "2843200"
  },
  {
    "text": "slice into two independent slices and there's a a function in the library",
    "start": "2843200",
    "end": "2850599"
  },
  {
    "text": "called split at mute and what what that's doing is it's saying you have a reference to some whole slice of a",
    "start": "2850599",
    "end": "2857559"
  },
  {
    "text": "vector a mutable reference and you want to turn it into two mutable references to disjoint Subs slices right and so",
    "start": "2857559",
    "end": "2865400"
  },
  {
    "text": "that's safe even though they're both talking about the same underlying Vector because they're disjoint you can't",
    "start": "2865400",
    "end": "2872200"
  },
  {
    "text": "actually get into any trouble um through by using these to to mutate the underlying data okay um and then we go",
    "start": "2872200",
    "end": "2880079"
  },
  {
    "text": "on to to actually do the sort so so that was the sequential version we can do the",
    "start": "2880079",
    "end": "2885839"
  },
  {
    "text": "same thing um in the in the parallel version basically the code looks almost exactly the same um so we we do the",
    "start": "2885839",
    "end": "2892800"
  },
  {
    "text": "partitioning we get these two sub slices only this time uh we are actually um",
    "start": "2892800",
    "end": "2898079"
  },
  {
    "text": "sort of asking to uh U to do the recursive calls on",
    "start": "2898079",
    "end": "2903559"
  },
  {
    "text": "some child threads right using this parallel join thing now something very interesting is going",
    "start": "2903559",
    "end": "2909040"
  },
  {
    "text": "on here because we have the parent thread the initial call to parallel Q sort and we have two children threads",
    "start": "2909040",
    "end": "2916599"
  },
  {
    "text": "which are actually being given pointers onto the parent thread stack which is a very dangerous thing to do because those",
    "start": "2916599",
    "end": "2923880"
  },
  {
    "text": "pointers must not outlive that stack frame or you're going to be in in real",
    "start": "2923880",
    "end": "2929319"
  },
  {
    "text": "trouble this is yet another kind of bug that that is very easy to make in C++ the key point is rust only let you do",
    "start": "2929319",
    "end": "2937319"
  },
  {
    "text": "this if you're doing something like a join right and the type system can actually talk about whether you you are",
    "start": "2937319",
    "end": "2944119"
  },
  {
    "text": "accessing stack data or not and in order to to give out stack data to Children",
    "start": "2944119",
    "end": "2949599"
  },
  {
    "text": "threads you have to be joining on those threads and that's important because it prevents that stack frame from being",
    "start": "2949599",
    "end": "2956240"
  },
  {
    "text": "popped while the children threads are running right you're waiting for the children threads to finish before you continue and pop the frame yes how can a",
    "start": "2956240",
    "end": "2963520"
  },
  {
    "text": "library do that that's a global check that a compiler would have to make",
    "start": "2963520",
    "end": "2968720"
  },
  {
    "text": "the sorry which check do you mean about the you said that if if you split you must join yes if you if you so what",
    "start": "2968760",
    "end": "2978599"
  },
  {
    "text": "happens is um when all all data in Rust um has",
    "start": "2978599",
    "end": "2985599"
  },
  {
    "text": "something called a lifetime associated with it which I haven't talked about at all here but it's sort of implicit and",
    "start": "2985599",
    "end": "2991359"
  },
  {
    "text": "that that lifetime refers to the borrows that are active in that data and there's",
    "start": "2991359",
    "end": "2996760"
  },
  {
    "text": "a way of saying that the lifetime has to be static which means there are no borrows inside and that's a way of",
    "start": "2996760",
    "end": "3003040"
  },
  {
    "text": "ruling out stack data basically um or sort of pointers onto stack data so in",
    "start": "3003040",
    "end": "3009720"
  },
  {
    "text": "the libraries what I'm saying is that there's one way to spawn a thread just the spawn keyword that I or the spawn",
    "start": "3009720",
    "end": "3016400"
  },
  {
    "text": "function that I showed you that requires that the child thread have a",
    "start": "3016400",
    "end": "3021640"
  },
  {
    "text": "static lifetime basically that you're saying the data that's being passed cannot uh uh have any Burrows into the",
    "start": "3021640",
    "end": "3029200"
  },
  {
    "text": "stack but then this join function can take any lifetime so basically the type",
    "start": "3029200",
    "end": "3034400"
  },
  {
    "text": "system allows you to say whether stack data is allowed or not and then the libraries themselves uh build different",
    "start": "3034400",
    "end": "3041359"
  },
  {
    "text": "apis where they're tying this together with things like joining does that does that",
    "start": "3041359",
    "end": "3047040"
  },
  {
    "text": "help not quite but because there's nothing in up there that impli it has to",
    "start": "3047040",
    "end": "3052559"
  },
  {
    "text": "be static unless it's a reir split it mute so so in this case it doesn't have to be",
    "start": "3052559",
    "end": "3058880"
  },
  {
    "text": "static right that's the point because the join function is allowed to take non-static closures as an argument um be",
    "start": "3058880",
    "end": "3067160"
  },
  {
    "text": "precisely because you know that the semantics is it it will join those two threads at the end so the stack frame",
    "start": "3067160",
    "end": "3072440"
  },
  {
    "text": "will be valid for their entire duration but the spawn function that we saw before that has a static constraint and",
    "start": "3072440",
    "end": "3080839"
  },
  {
    "text": "so if you tried to do this with spawn you'd get a compiler error like if I if I just spawn twice",
    "start": "3080839",
    "end": "3088480"
  },
  {
    "text": "for the two children that would not compile because of the type signature so the question is how does",
    "start": "3088480",
    "end": "3095480"
  },
  {
    "text": "join and spawn get the information that some portion of the data structure must",
    "start": "3095480",
    "end": "3101119"
  },
  {
    "text": "be stacked so they get it by so I'm not showing I haven't shown you their type signature so I'm sort of like alluding",
    "start": "3101119",
    "end": "3108000"
  },
  {
    "text": "to this thing that I don't have on a slide unfortunately but basically if you were to put their type signatures side",
    "start": "3108000",
    "end": "3113079"
  },
  {
    "text": "by side spawn has a says static in part",
    "start": "3113079",
    "end": "3119000"
  },
  {
    "text": "of its type for the closure and join does not and then so then you're you're sort of hooking into the compiler so the",
    "start": "3119000",
    "end": "3125319"
  },
  {
    "text": "compiler knows whether stack data is involved or not and this gives you a way to to ask for it and that's into the",
    "start": "3125319",
    "end": "3131480"
  },
  {
    "text": "language and not into the that's right that's right so the the notion of",
    "start": "3131480",
    "end": "3136839"
  },
  {
    "text": "lifetimes and static that's a language feature this is an example of the libraries taking advantage of",
    "start": "3136839",
    "end": "3143160"
  },
  {
    "text": "it okay I guess I should probably move on just to to wrap up fun time here um",
    "start": "3143160",
    "end": "3149160"
  },
  {
    "text": "okay I sort of walked through there so okay at this point I'm basically going to uh just conclude the talk so you know",
    "start": "3149160",
    "end": "3157319"
  },
  {
    "start": "3153000",
    "end": "3382000"
  },
  {
    "text": "I've shown you several different um models of you know typical models of concurrency how you can support them in",
    "start": "3157319",
    "end": "3165359"
  },
  {
    "text": "Rust and the kind of strong guarantees that you get that rule out classic bugs for each uh kind of model but as I said",
    "start": "3165359",
    "end": "3173240"
  },
  {
    "text": "because this is all being done with the libraries it's very open-ended um and it's under very active development so",
    "start": "3173240",
    "end": "3180359"
  },
  {
    "text": "you know futures or promises are are one thing we have some uh you know small support for but we want to do a lot more",
    "start": "3180359",
    "end": "3187400"
  },
  {
    "text": "um and I mean this is just an endless list but one key point is that all of",
    "start": "3187400",
    "end": "3193200"
  },
  {
    "text": "these um sort of approaches to concurrency and when you build them in Rust are are data Race Free by by",
    "start": "3193200",
    "end": "3200119"
  },
  {
    "text": "construction okay and now I I sort of pull back the Cur",
    "start": "3200119",
    "end": "3207160"
  },
  {
    "text": "right so I've been sort of alluding to this all throughout the talk that the discipline can be too strict you need to",
    "start": "3207160",
    "end": "3212920"
  },
  {
    "text": "bend the rules in certain ways right which you know should make you uncomfortable um it certainly makes me",
    "start": "3212920",
    "end": "3218680"
  },
  {
    "text": "uncomfortable so one of the key things that makes Russ work or sort of workable is the notion of unsafe",
    "start": "3218680",
    "end": "3225680"
  },
  {
    "text": "code um so there's a keyword in Russ called unsafe and basically within an unsafe block you are allowed to break",
    "start": "3225680",
    "end": "3234079"
  },
  {
    "text": "certain rules that are normally in play um which may sound like you're just",
    "start": "3234079",
    "end": "3239680"
  },
  {
    "text": "throwing all of these great guarantees I mentioned out the window right I mean that's that's the the typical First Response like if you have this what's",
    "start": "3239680",
    "end": "3246400"
  },
  {
    "text": "the point um and you know from a from a sort of purely theoretical point of view",
    "start": "3246400",
    "end": "3252000"
  },
  {
    "text": "that's totally true as soon as you have one unsafe there are no guarantees but the key is in practice you actually need",
    "start": "3252000",
    "end": "3260079"
  },
  {
    "text": "unsafe relatively rarely usually in data structure libraries or like concurrency",
    "start": "3260079",
    "end": "3265280"
  },
  {
    "text": "libraries and you can use it in a in a constrained way um and in particular you can hide uses of it behind an",
    "start": "3265280",
    "end": "3271960"
  },
  {
    "text": "abstraction boundary so that you can say if you build a mutex for example under the hood that uses unsafe that breaks",
    "start": "3271960",
    "end": "3277480"
  },
  {
    "text": "the rules in certain ways but it guarantees at the public API level the things you can actually do with a mutex",
    "start": "3277480",
    "end": "3283000"
  },
  {
    "text": "are perfectly safe and in fact every use of unsafe has to make that guarantee it has to be hidden behind a boundary so",
    "start": "3283000",
    "end": "3289599"
  },
  {
    "text": "that users of that Library get all the guarantees of R back so it's encapsulation of safety yeah how do you",
    "start": "3289599",
    "end": "3295720"
  },
  {
    "text": "prove that so that is proved on the side right so this is not something this is",
    "start": "3295720",
    "end": "3302160"
  },
  {
    "text": "not something that the compiler at least today can give you help with right but you can search for uses of unsafe in",
    "start": "3302160",
    "end": "3308680"
  },
  {
    "text": "your code right you've sort of you can find the places where you might be breaking the rules and there's a strong",
    "start": "3308680",
    "end": "3314559"
  },
  {
    "text": "sort of culture in Rust uh and its ecosystem to avoid unsafe whenever possible right so it's much easier to",
    "start": "3314559",
    "end": "3321079"
  },
  {
    "text": "audit your code and uh actually there uh is ongoing work in academ emia to try to",
    "start": "3321079",
    "end": "3328119"
  },
  {
    "text": "go push this further and actually understand what it would take to prove unsafe abstractions safe right and maybe",
    "start": "3328119",
    "end": "3334160"
  },
  {
    "text": "build some additional tools to help you do that um liting the",
    "start": "3334160",
    "end": "3340000"
  },
  {
    "text": "potential yeah yeah I mean that's exactly it like in the at the end of the day you know if this is going to work it",
    "start": "3342559",
    "end": "3349440"
  },
  {
    "text": "has to be practical and you can't you can't have a completely rigid set of of rules like the ones I showed you and",
    "start": "3349440",
    "end": "3355359"
  },
  {
    "text": "scale all the way up to web browser but our experience so far says you can get a really long way using unsafe quite",
    "start": "3355359",
    "end": "3364039"
  },
  {
    "text": "minimally you really only need one unsafe yeah that's right",
    "start": "3364039",
    "end": "3371799"
  },
  {
    "text": "we total Outer Outer parentheses yeah exactly so um okay and",
    "start": "3371799",
    "end": "3379599"
  },
  {
    "text": "then just just sort of information about where rust is right now so we are deeply in the midst of of a sort of final push",
    "start": "3379599",
    "end": "3386920"
  },
  {
    "start": "3382000",
    "end": "3915000"
  },
  {
    "text": "toward a 1.0 release so at the end of this month we'll put out a beta and then 6 weeks later we'll put out the actual",
    "start": "3386920",
    "end": "3393400"
  },
  {
    "text": "1.0 final and um one of the thing up to this point we've been breaking code on a",
    "start": "3393400",
    "end": "3399680"
  },
  {
    "text": "daily basis um so it's been very hard for people to use rust in a production way but that's going to change with 1.0",
    "start": "3399680",
    "end": "3405599"
  },
  {
    "text": "so this is the point where it switches from research project to Something Real that people can build on so obviously",
    "start": "3405599",
    "end": "3410920"
  },
  {
    "text": "I'm very excited about that um great well I think I'll just leave these conclusions up here and take any final",
    "start": "3410920",
    "end": "3419000"
  },
  {
    "text": "questions so got a browser running we do um you should download it and try it out",
    "start": "3422079",
    "end": "3427960"
  },
  {
    "text": "so it seg fults very rarely um uh yeah",
    "start": "3427960",
    "end": "3433119"
  },
  {
    "text": "so we have Servo Servo uh runs you can uh browse the rust GitHub repository on",
    "start": "3433119",
    "end": "3440280"
  },
  {
    "text": "Servo you can actually do quite a bit um uh it runs on phones and in fact this",
    "start": "3440280",
    "end": "3447160"
  },
  {
    "text": "year one of our goals uh is to have a component a module of code that's shared",
    "start": "3447160",
    "end": "3453559"
  },
  {
    "text": "between the servo browser and also Firefox um so we're sort of trying all",
    "start": "3453559",
    "end": "3459039"
  },
  {
    "text": "avenues for getting rust actually in use in the organization I think once we're shipping one module then they're stuck",
    "start": "3459039",
    "end": "3464520"
  },
  {
    "text": "with it then Mozilla has to deal with rest forever that's our that's our secret",
    "start": "3464520",
    "end": "3469880"
  },
  {
    "text": "hope yeah what do you think is the biggest challenge moving forward what keeps you up at night",
    "start": "3469880",
    "end": "3477039"
  },
  {
    "text": "oh man what doesn't um so uh that's actually that's a really",
    "start": "3477039",
    "end": "3484160"
  },
  {
    "text": "interesting question um I I do I worry that yeah well you",
    "start": "3484160",
    "end": "3491200"
  },
  {
    "text": "said besides the unsafe but I think I mean un whether whether this Vision about unsafe being constrained enough",
    "start": "3491200",
    "end": "3497520"
  },
  {
    "text": "will actually succeed is is one thing that keeps me up at night and the fact that right now to program even a simple",
    "start": "3497520",
    "end": "3504079"
  },
  {
    "text": "data structure like a w link list that inv involves aliasing IM mutation requires a little bit of unsafe code um",
    "start": "3504079",
    "end": "3510559"
  },
  {
    "text": "that worries me but I think we have a lot of ideas for how to push the boundary further to give you building",
    "start": "3510559",
    "end": "3515799"
  },
  {
    "text": "blocks that are safe that you can use to build things like link lists um but I",
    "start": "3515799",
    "end": "3521039"
  },
  {
    "text": "don't know I mean we we're sort of doing the best we can to you know make all these promises",
    "start": "3521039",
    "end": "3527000"
  },
  {
    "text": "like I said we're not going to break any code after 1.0 and so the other thing that keeps me awake at night is like what if we made some of those decision",
    "start": "3527000",
    "end": "3533559"
  },
  {
    "text": "wrong and you know we haven't had enough time for feedback lots of digits after the zero point",
    "start": "3533559",
    "end": "3539440"
  },
  {
    "text": "yes yes indeed so what's what's your competition that's an interesting",
    "start": "3539440",
    "end": "3545799"
  },
  {
    "text": "question um I don't there aren't a lot of languages that are targeting this",
    "start": "3545799",
    "end": "3552960"
  },
  {
    "text": "combination of safety and control um in in a way I I think we're the only game",
    "start": "3552960",
    "end": "3558839"
  },
  {
    "text": "in town there certainly most most other languages that are trying to give you that level of control at least require a",
    "start": "3558839",
    "end": "3565400"
  },
  {
    "text": "garbage collector but um I think rust is often compared to go in part because go is also by you",
    "start": "3565400",
    "end": "3574559"
  },
  {
    "text": "know a company that makes a web browser and it's a recent language you know people are sort of looking for a new thing I I think those are I think go and",
    "start": "3574559",
    "end": "3581880"
  },
  {
    "text": "rust are targeting pretty different niches honestly um so I I mean C++",
    "start": "3581880",
    "end": "3588520"
  },
  {
    "text": "actually if I was to be honest I think C++ is the biggest competitor to rust um and part of the reason I say that is",
    "start": "3588520",
    "end": "3595480"
  },
  {
    "text": "rust well C C++ has come a really long way and a lot of the ownership stuff I'm I'm",
    "start": "3595480",
    "end": "3602039"
  },
  {
    "text": "showing you in Rust resembles what it's like to write C++ code these these days it's just that",
    "start": "3602039",
    "end": "3608000"
  },
  {
    "text": "C++ doesn't actually check it for you and a lot a lot of it is done at runtime right and there's a lot of CR in C++",
    "start": "3608000",
    "end": "3614880"
  },
  {
    "text": "it's an old language right um but I think that's the biggest risk is that C++ might get good enough that rust just",
    "start": "3614880",
    "end": "3621039"
  },
  {
    "text": "never has a chance to take off what what's going to happen when uh",
    "start": "3621039",
    "end": "3626799"
  },
  {
    "text": "the programming model changes and some of",
    "start": "3626799",
    "end": "3631960"
  },
  {
    "text": "the stuff that's being experment with where you move memory referencing and",
    "start": "3631960",
    "end": "3637000"
  },
  {
    "text": "the mmu up into the lowlevel code uh and",
    "start": "3637000",
    "end": "3642480"
  },
  {
    "text": "try to do memory synchronized accesses that sort of thing how's that going to",
    "start": "3642480",
    "end": "3648240"
  },
  {
    "text": "fit into the rest framework so I that's a that's an interesting question um I",
    "start": "3648240",
    "end": "3654400"
  },
  {
    "text": "think that at you know there are sort of two answers to that one is a theoretical",
    "start": "3654400",
    "end": "3660200"
  },
  {
    "text": "answer and one is a practical answer so in theory the core discipline of ownership and borrowing I think is very",
    "start": "3660200",
    "end": "3665720"
  },
  {
    "text": "widely applicable to many different architectures and styles of programming so I think you know even if you know",
    "start": "3665720",
    "end": "3673000"
  },
  {
    "text": "cash coherence goes out the window for example I think that ownership will still be an important aspect of",
    "start": "3673000",
    "end": "3678400"
  },
  {
    "text": "programming and something that the type system can offer you on the other hand practically we're very tied to lvm right",
    "start": "3678400",
    "end": "3684400"
  },
  {
    "text": "now um and and who knows how long that will last you know hopefully someday there will be a rust standard in many",
    "start": "3684400",
    "end": "3689920"
  },
  {
    "text": "rust implementations but that's a long way off yeah I don't think you said so but",
    "start": "3689920",
    "end": "3696079"
  },
  {
    "text": "I'm assuming that in Rust you can't manipulate pointers in the sense of incrementing not the pointers I showed",
    "start": "3696079",
    "end": "3702359"
  },
  {
    "text": "you there's a there is a kind of unsafe pointer that you can only manipulate in unsafe code but that's that's used very",
    "start": "3702359",
    "end": "3709520"
  },
  {
    "text": "rarely it's an unsafe only feature exactly exactly y what's with the name",
    "start": "3709520",
    "end": "3717839"
  },
  {
    "text": "oxidized look it up online okay anybody",
    "start": "3718440",
    "end": "3726079"
  },
  {
    "text": "else so have you thought about writing an OS in this uh people have um we I",
    "start": "3726079",
    "end": "3731960"
  },
  {
    "text": "mean h hobbi hobbyists have nothing too serious um but that's definitely",
    "start": "3731960",
    "end": "3737440"
  },
  {
    "text": "something you could imagine doing there's a lot of work needed to I mean right now like",
    "start": "3737440",
    "end": "3745039"
  },
  {
    "text": "rust works relatively smoothly because you can assume an allocator and the libraries are sort of shaped around that",
    "start": "3745039",
    "end": "3750640"
  },
  {
    "text": "and for an OS things are a little bit different so I think the standard Library would have to change quite a bit to write a serious OS um but there are",
    "start": "3750640",
    "end": "3757760"
  },
  {
    "text": "lots of hobby projects doing it already easy to link it to existing C",
    "start": "3757760",
    "end": "3764520"
  },
  {
    "text": "library or maybe C++ so it's very easy to link it to C libraries and that that was that actually drove a lot of the",
    "start": "3764520",
    "end": "3770799"
  },
  {
    "text": "recent design um so that in comparison to go for example it's much easier um Russ just just looks like C uh",
    "start": "3770799",
    "end": "3778359"
  },
  {
    "text": "C++ it's uh the story is not as good except that c and C++ are relatively",
    "start": "3778359",
    "end": "3784079"
  },
  {
    "text": "easy to interface together so you at least have that starting point but Russ doesn't have anything like classes right now it has other features that give you",
    "start": "3784079",
    "end": "3790520"
  },
  {
    "text": "parts of what classes do so that that story will evolve over time I think anybody",
    "start": "3790520",
    "end": "3798960"
  },
  {
    "text": "else you you get quot it's essentially social comment uh",
    "start": "3799200",
    "end": "3805400"
  },
  {
    "text": "essentially explanation why I said limiting damage I have to go my back to my grandfather used to borrow tools but",
    "start": "3805400",
    "end": "3812640"
  },
  {
    "text": "yet had this very strict rule whenever you turn your tool you bring it back in",
    "start": "3812640",
    "end": "3818400"
  },
  {
    "text": "the same state or better no damage in other",
    "start": "3818400",
    "end": "3823480"
  },
  {
    "text": "words and I accept that I mean it's sort of obvious right courtesy and when I came",
    "start": "3823480",
    "end": "3831319"
  },
  {
    "text": "born in Switzer uh when I came to us this young lady in professor in mechanical",
    "start": "3831319",
    "end": "3838760"
  },
  {
    "text": "engineering at this thing about designing bikes mhm and I was very pleased the first rule she had well",
    "start": "3838760",
    "end": "3845720"
  },
  {
    "text": "you're getting these old bikes and you have to return them at the end of the court in a better State Bingo well",
    "start": "3845720",
    "end": "3852799"
  },
  {
    "text": "unfortunately she didn't adhar to that but that's not the main point it's",
    "start": "3852799",
    "end": "3859359"
  },
  {
    "text": "it's yeah it's a social thing basically I accept it the way I grew up she sort",
    "start": "3859359",
    "end": "3866160"
  },
  {
    "text": "of thought it was cute I mean in the US or California different rules right and",
    "start": "3866160",
    "end": "3871640"
  },
  {
    "text": "she abandoned it and yeah but that's what you pay for that's why your systems are unsafe if",
    "start": "3871640",
    "end": "3878680"
  },
  {
    "text": "you would of borrow nicely right right then you wouldn't have a problem right",
    "start": "3878680",
    "end": "3884359"
  },
  {
    "text": "so anyway yeah it's I just shocked in some sense that's why I asked probing questions to you because I knew where I",
    "start": "3884359",
    "end": "3891440"
  },
  {
    "text": "wanted to go and you gave me the answers yes keep BR it with yeah I'm glad you",
    "start": "3891440",
    "end": "3898960"
  },
  {
    "text": "discovered it thank you very much thank you all",
    "start": "3898960",
    "end": "3904798"
  }
]