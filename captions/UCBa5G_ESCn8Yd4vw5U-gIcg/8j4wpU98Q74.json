[
  {
    "text": " SPEAKER: All right.",
    "start": "0",
    "end": "6069"
  },
  {
    "text": "Hi, everyone. Welcome to the 224N\nPython review session. The goal of the\nsession really will",
    "start": "6070",
    "end": "12280"
  },
  {
    "text": "be to give you the basics of\nPython and NumPy in particular",
    "start": "12280",
    "end": "18130"
  },
  {
    "text": "that you'll be using a lot\nin your second homework and the homeworks that will\ncome after that as well.",
    "start": "18130",
    "end": "23860"
  },
  {
    "text": "We're sort of\ntaking this tutorial from the background of anyone\nwho hasn't touched programming",
    "start": "23860",
    "end": "29410"
  },
  {
    "text": "languages to some extent,\nbut also for people who have. We'll be sort of going\nthrough a lot of that material very quickly, and we'll be\nprogressing to NumPy as well.",
    "start": "29410",
    "end": "37005"
  },
  {
    "text": "And as I mentioned, first\nand foremost, the session is really meant for the\npeople who are here in person. So if you'd like me to slow\ndown, speed up at any point,",
    "start": "37005",
    "end": "44950"
  },
  {
    "text": "need time for clarifications,\nfeel free to ask. It's really meant\nfor you first here. And I really would like it to be\nsort of an interactive session",
    "start": "44950",
    "end": "52360"
  },
  {
    "text": "as well. All right. So this is a topic--\nthese are the topics we'll be covering today. Going through, first\nof all, why Python",
    "start": "52360",
    "end": "58630"
  },
  {
    "text": "is a language, why\nwe have chosen it for sort of this course and\nin general, why do people prefer it to some extent\nfor machine learning",
    "start": "58630",
    "end": "64628"
  },
  {
    "text": "and natural language processing. Some basics of the\nlanguage itself-- common data structures and\nthen getting to the meat of it",
    "start": "64629",
    "end": "72500"
  },
  {
    "text": "through NumPy which\nas I mentioned, you'll be extensively using in\nyour homeworks going forward. And then some practical\ntips about how",
    "start": "72500",
    "end": "77810"
  },
  {
    "text": "to use things in Python. All right. So first thing, why Python?",
    "start": "77810",
    "end": "83510"
  },
  {
    "text": "So a lot of you who might\nhave been first introduced to programming might\nhave done Java before.",
    "start": "83510",
    "end": "89720"
  },
  {
    "text": "A lot of people use Matlab\nin other fields as well. So why Python?",
    "start": "89720",
    "end": "95540"
  },
  {
    "text": "Python is generally\nused for one, because it's a very\nhigh level language. It can look very, very\nEnglish like and so",
    "start": "95540",
    "end": "101210"
  },
  {
    "text": "it's really easy to work\nwith for people, especially when they get started out. It has a lot of scientific\ncomputational functionality",
    "start": "101210",
    "end": "107720"
  },
  {
    "text": "as well, similar to Matlab. So when you talk\nabout NumPy, you'll see that it has a lot of\nframeworks that are very, very quick and efficient operations\ninvolving math or matrices.",
    "start": "107720",
    "end": "115550"
  },
  {
    "text": "And that's very, very\nuseful in applications such as deep learning. And for deep learning\nin particular,",
    "start": "115550",
    "end": "120740"
  },
  {
    "text": "a lot of frameworks that\npeople use, particularly for example, PyTorch\nand TensorFlow, interface directly with Python.",
    "start": "120740",
    "end": "126500"
  },
  {
    "text": "And so for those main\nreasons, people generally tend to use Python\nthan deep learning.",
    "start": "126500",
    "end": "132209"
  },
  {
    "text": "OK. So the setup information\nis in the slides if you'd like to\nlook at them offline. I will be sort of\njumping over that for now",
    "start": "132210",
    "end": "139130"
  },
  {
    "text": "because I want to get\nto the introduction to the language itself and\nthen if we have time, come back to the setup information.",
    "start": "139130",
    "end": "145040"
  },
  {
    "text": "A lot of it's pretty direct. You can walk through it. It gives you steps for how\nto install packages, what",
    "start": "145040",
    "end": "151190"
  },
  {
    "text": "is a Conda environment,\nfor example, and gets you set up with\nyour first working Python environment.",
    "start": "151190",
    "end": "156450"
  },
  {
    "text": "So you can sort of run\nsimple and basic commands to get used to the language. But for now, I'm going\nto be skipping over this",
    "start": "156450",
    "end": "161937"
  },
  {
    "text": "and coming back to\nit if we have time. All right. Language basics. So in Python, you have\nvariables and these variables",
    "start": "161938",
    "end": "170270"
  },
  {
    "text": "can take on multiple values. The assignment operation\nor the equal sign will allow you to assign a\nparticular value to a variable.",
    "start": "170270",
    "end": "177500"
  },
  {
    "text": "A nice thing with\nPython is you don't have to instantiate the\ntype of the variable to begin with, and\nthen only instantiate--",
    "start": "177500",
    "end": "183380"
  },
  {
    "text": "and only assign\nvalues of that type. So for example, in\ncertain languages, we first say that this\nvariable x is only",
    "start": "183380",
    "end": "189920"
  },
  {
    "text": "going to be of type\nint and any value aside from that that's assigned\nto it will throw an error. Python is pretty flexible.",
    "start": "189920",
    "end": "195720"
  },
  {
    "text": "So if I want to,\nI can reassign-- I can start with\nx is equal to 10. And then later on--\nfive lines later, I can say x is equal\nto high as a string",
    "start": "195720",
    "end": "203480"
  },
  {
    "text": "and there would be no issue. You can do simple mathematical\noperations such as the plus",
    "start": "203480",
    "end": "209000"
  },
  {
    "text": "and division signs. You can do exponentiation\nwhich is raising one value to another value.",
    "start": "209000",
    "end": "215610"
  },
  {
    "text": "So x to the power\nof y for example, using the double asterisk. You can do type casting\nfor float division.",
    "start": "215610",
    "end": "222210"
  },
  {
    "text": "So if you want to ensure that\nyour values are being divided resulting in a float value and\nnot just dividing two integers,",
    "start": "222210",
    "end": "227303"
  },
  {
    "text": "you can cast two different\ntypes like float. If you want something\nto be explicitly an int, you can also just\nput an int instead",
    "start": "227303",
    "end": "233060"
  },
  {
    "text": "of the float with\nbrackets around the result and that will give\nyou an integer value.",
    "start": "233060",
    "end": "238099"
  },
  {
    "text": "And then you can also do\ntype casting to, for example, convert from\nintegers to strings.",
    "start": "238100",
    "end": "243390"
  },
  {
    "text": "So in this case, if I wanted\nto instead of doing 10 plus 3 as a mathematical\noperation, I just",
    "start": "243390",
    "end": "249140"
  },
  {
    "text": "want to write out\n10 plus 3, then I can convert the\nx and y values, for example, to\nstrings and then add",
    "start": "249140",
    "end": "255920"
  },
  {
    "text": "the plus sign as a character\nas well to create a string. And so a lot of these common\noperations you can look online",
    "start": "255920",
    "end": "262250"
  },
  {
    "text": "as well-- people\nhave lists for them-- and just see how they're\nsort of done in Python.",
    "start": "262250",
    "end": "267620"
  },
  {
    "text": "All right. Some other quick things. So Boolean values, the\ntrue and the false, they're always used\nwith capital letters",
    "start": "267620",
    "end": "274160"
  },
  {
    "text": "and some other languages,\nthey might be lowercase so just one thing to know. Python also doesn't\nhave a null value.",
    "start": "274160",
    "end": "279289"
  },
  {
    "text": "The equivalent of a\nnull value is none. So sometimes when you want\nto say that this value-- you want to return none\nsaying that I'm not really",
    "start": "279290",
    "end": "286370"
  },
  {
    "text": "doing anything here. You want to do checks, for\nexample, in if statements to say that this\ndoesn't have a value,",
    "start": "286370",
    "end": "293640"
  },
  {
    "text": "then you can assign it to none. So none, sort of, functions\nas a null equivalent.",
    "start": "293640",
    "end": "298653"
  },
  {
    "text": "So you're not really\nreturning anything. It doesn't have a value. Not the same as 0. And another nice\nthing about Python",
    "start": "298653",
    "end": "305780"
  },
  {
    "text": "is lists which are,\nsort of, mutable-- we'll come to that\na little bit later-- but sort of mutable lists\nof objects and means",
    "start": "305780",
    "end": "313550"
  },
  {
    "text": "that you can change them. They can be of any type. So you can have a mixture\nof integers, non- values",
    "start": "313550",
    "end": "319669"
  },
  {
    "text": "strings, et cetera. And yeah, functions can\nreturn the non-value as well.",
    "start": "319670",
    "end": "326350"
  },
  {
    "text": "And another quick\nthing, instead of using the double and, and in some\nother languages as people",
    "start": "326350",
    "end": "331740"
  },
  {
    "text": "might do, with Python,\nI mentioned earlier, it's very English like so you\ncan actually just write out if x is equal to 3\nand, and in English y",
    "start": "331740",
    "end": "340620"
  },
  {
    "text": "is equal to 4 then\nreturn true or something. It's quite nice that way. So you can use and/or and not.",
    "start": "340620",
    "end": "347580"
  },
  {
    "text": "And then just the comparison,\noperators of equal equals to and not\nequals to will check for equality and inequality.",
    "start": "347580",
    "end": "354449"
  },
  {
    "text": "This one is pretty standard,\nI feel, across many languages and you can use them\nin Python as well.",
    "start": "354450",
    "end": "359577"
  },
  {
    "text": "And yeah, remember\njust a quick thing. The equal, equal to sine is\ndifferent from the assignment operator. This one checks for equality.",
    "start": "359577",
    "end": "364690"
  },
  {
    "text": "That one is just\nassigning a value. So a single equal sign\nversus two of them.",
    "start": "364690",
    "end": "370150"
  },
  {
    "text": "All right. And then also in Python,\nyou don't use brackets. So Python-- you can use\nbasically spaces or tabs.",
    "start": "370150",
    "end": "377740"
  },
  {
    "text": "So either indents\nof 2 or 4 to be able to break up what is\ncontained within the function",
    "start": "377740",
    "end": "383290"
  },
  {
    "text": "or contained within like an\nif statement, a for statement or any loops for example. And so the main thing is you\ncan choose whether to do 2 or 4.",
    "start": "383290",
    "end": "390910"
  },
  {
    "text": "You just have to be consistent\nthroughout your entire code base. Otherwise, they\nwill throw an error.",
    "start": "390910",
    "end": "397900"
  },
  {
    "text": "Now go to some common\ndata structures, and for this, we'll\ntransition to the Colab.",
    "start": "397900",
    "end": "403860"
  },
  {
    "text": "So this one will sort of\nshow you in real time. This is by the way, a Colab. A Colab is basically a Jupyter\nNotebook for those of you",
    "start": "403860",
    "end": "411000"
  },
  {
    "text": "who are familiar with those\nthat you can use that it's hosted on Google's servers. The really nice thing\nabout Jupyter Notebooks",
    "start": "411000",
    "end": "417690"
  },
  {
    "text": "is you don't have to run\nan entire file altogether. You can run it step by step into\nwhat are these called cells.",
    "start": "417690",
    "end": "424065"
  },
  {
    "text": "So if you want to see\nan intermediate output, you can see that pretty\neasily, and that way-- and you",
    "start": "424065",
    "end": "429150"
  },
  {
    "text": "can also write, for example, a\nlot of descriptions pertaining to cells, which is really,\nreally nice to have as well.",
    "start": "429150",
    "end": "435820"
  },
  {
    "text": "So a lot of people tend\nto use these when they're sort of starting out\nwith their project and want to debug things. And Colab allows you to use\nthese Jupyter Notebook type",
    "start": "435820",
    "end": "444539"
  },
  {
    "text": "applications hosted on their\nservers for free basically. So anyone can create one of\nthese and run their code.",
    "start": "444540",
    "end": "452139"
  },
  {
    "text": "All right. So lists are mutable arrays. Mutable means that\nyou can change them so that once you declare\nthem, you can add to them,",
    "start": "452140",
    "end": "459130"
  },
  {
    "text": "you can delete them and they're\noptimized for that purpose. So they expect to be\nchanged very often. We'll come to what are\ncalled NumPy arrays later",
    "start": "459130",
    "end": "465790"
  },
  {
    "text": "and those tend to be\npretty much fixed. When you create a new one, you'd\nhave-- when you change one, you actually have to create\na new array, which will have",
    "start": "465790",
    "end": "472870"
  },
  {
    "text": "the additional information. So this is highly optimized\nfor changing things. If you know, for example,\nif you're in a loop,",
    "start": "472870",
    "end": "478090"
  },
  {
    "text": "you're adding\ndifferent elements to, let's say, a bigger\nentity, you'd want to use\nsomething like a list",
    "start": "478090",
    "end": "483190"
  },
  {
    "text": "because you're going to be\nchanging that very often. So let's see how they work. So we start off with a\nnames array with Zach and J.",
    "start": "483190",
    "end": "491319"
  },
  {
    "text": "You can index into the list by-- so what is this? Index into the list\nby index, which",
    "start": "491320",
    "end": "496888"
  },
  {
    "text": "means that you can list out\nthe elements in the list depending on what's\ncalled the index.",
    "start": "496888",
    "end": "502300"
  },
  {
    "text": "So it's what place that\nvalue is at within the list. So 0 refers to\nthe first element. So Python's what's\ncalled 0 indexed which",
    "start": "502300",
    "end": "509470"
  },
  {
    "text": "means it starts with 0\nand then it goes to 1. So here, 0 will be Zach.",
    "start": "509470",
    "end": "514539"
  },
  {
    "text": "And then let's say I want to\nappend something to the end. So to add something to\nthe end of the list,",
    "start": "514539",
    "end": "519890"
  },
  {
    "text": "the term is append not add. And so if I want to\nappend, I can now",
    "start": "519890",
    "end": "525547"
  },
  {
    "text": "create a separate list which\nis the original list itself with the added last element. And what would currently\nbe the length of this?",
    "start": "525547",
    "end": "532079"
  },
  {
    "text": "It would be 3 because\nyou have three elements. And you can just quickly get\nthat by using the len function. Not length.",
    "start": "532080",
    "end": "537240"
  },
  {
    "text": "Just three letters-- L-E-N. All right. It's also really\nnice because Python",
    "start": "537240",
    "end": "543209"
  },
  {
    "text": "has overloaded the\nplus operation to be able to concatenate lists.",
    "start": "543210",
    "end": "549120"
  },
  {
    "text": "So here, I have a\nseparate list, right? And all you need for a list\ndefinition is just brackets. So this is a separate\nlist altogether,",
    "start": "549120",
    "end": "555555"
  },
  {
    "text": "even though I haven't\nsaved it in a variable. Just Abby and Kevin. And I can just do\na plus equal to,",
    "start": "555555",
    "end": "561250"
  },
  {
    "text": "which means that names is equal\nto names plus Abby and Kevin and this should\noutput this full list.",
    "start": "561250",
    "end": "567879"
  },
  {
    "text": "You can create lists by just\nputting the plain brackets or an existing list. And then as I mentioned\nearlier, your list",
    "start": "567880",
    "end": "574020"
  },
  {
    "text": "can have a variety\nof types within them. So here this list contains an\ninteger value, a list value--",
    "start": "574020",
    "end": "579340"
  },
  {
    "text": "so you can have a list of lists,\nas many sort of sublists as you like-- a float value and a none value.",
    "start": "579340",
    "end": "585240"
  },
  {
    "text": "And this is completely\nvalid within Python. Slicing refers to how you can\naccess only parts of the list.",
    "start": "585240",
    "end": "592540"
  },
  {
    "text": "So if I only want, for\nexample, in this numbers array, I only want 0, 1, 2, slicing is\na way that you can extract only",
    "start": "592540",
    "end": "601260"
  },
  {
    "text": "those parts. So the way slicing works is\nthe first element is included, and the last\nelement is excluded.",
    "start": "601260",
    "end": "607000"
  },
  {
    "text": "So here I start with 0, 1, 2, 3. So 3 is not included. And so 0, 1, 2 will\nbe printed out.",
    "start": "607000",
    "end": "614760"
  },
  {
    "text": "There's also shorthands. So if you know that\nyou're going to be starting with the first element\nof the array so if you know--",
    "start": "614760",
    "end": "620235"
  },
  {
    "text": "I want 0, 1, 2 and\nit starts with 0, then you don't need to even\ninclude the first index. You can just leave that\nand include the last index",
    "start": "620235",
    "end": "627850"
  },
  {
    "text": "that would be excluded. So that would be blank semicolon\n3 and same deal with the end.",
    "start": "627850",
    "end": "634150"
  },
  {
    "text": "If you know that you want\nto take everything, let's say, from like 5 and 6\ntill the end of the array,",
    "start": "634150",
    "end": "640630"
  },
  {
    "text": "you can start with\nwhat you would like. So 0, 1, 2, 3, 4, 5 till\nthe end and leave that.",
    "start": "640630",
    "end": "646615"
  },
  {
    "text": " Fun fact-- so this\nsemicolon, when you take just the semicolon,\nit will take everything",
    "start": "646615",
    "end": "653589"
  },
  {
    "text": "in the list, but it will also\ncreate a duplicate in memory. That's a very slight,\nvery useful thing",
    "start": "653590",
    "end": "659440"
  },
  {
    "text": "to know, because sometimes\nwhen you pass lists an array-- in Python, which is out\nof scope of this tutorial,",
    "start": "659440",
    "end": "666657"
  },
  {
    "text": "you can only pass\nthe reference to it. So if you change the\narray, that gets changed. This will create an entirely\nseparate copy in memory",
    "start": "666657",
    "end": "672760"
  },
  {
    "text": "of the exact same array. So if you make\nany changes to it, it won't affect\nyour original array. So this is a very-- pretty\nneat way to do that.",
    "start": "672760",
    "end": "680057"
  },
  {
    "text": "And then another fun\nthing that Python has which is pretty unique\nis you can index negatively. So negative indexing\nmeans you index",
    "start": "680057",
    "end": "686560"
  },
  {
    "text": "from the back of the array. So minus 1 refers to the\nlast element of the array. Minus 3 will refer to\nthe third last element.",
    "start": "686560",
    "end": "695079"
  },
  {
    "text": "And so what minus 1 will give\nyou will be 6 in this case. 1 minus 3 will give\nyou-- will be everything",
    "start": "695080",
    "end": "700477"
  },
  {
    "text": "because you're starting\nwith the minus 3 elements. So minus 1, minus 2,\nminus 3 till the end.",
    "start": "700477",
    "end": "706240"
  },
  {
    "text": "And then this one seems\nkind of confusing, right? 3 to minus 2. So what this will do is\nit'll give you 0, 1, 2, 3.",
    "start": "706240",
    "end": "712510"
  },
  {
    "text": "So you start with 3. And then minus 1, minus 2. So you leave off the last--",
    "start": "712510",
    "end": "718390"
  },
  {
    "text": "because you exclude\nit within the list, you would only get 3 and 4. So that's what this is.",
    "start": "718390",
    "end": "724570"
  },
  {
    "text": "OK. That's about lists. Tuples are immutable arrays. So once you declare\nthe values of these,",
    "start": "724570",
    "end": "731210"
  },
  {
    "text": "they cannot be changed. So I start with-- you\nremember we started with the list of Zach and Jay. Tuples, you start\nwith Zach and J",
    "start": "731210",
    "end": "739130"
  },
  {
    "text": "and you can still access them. I can still print out names,\nzero, same as I did with lists.",
    "start": "739130",
    "end": "744230"
  },
  {
    "text": "But if I try to change\nit, in this case, it'll throw an error. So tuples, once you've\ninstantiated them,",
    "start": "744230",
    "end": "749560"
  },
  {
    "text": "they cannot be changed. And to create an\nempty tuple, you just create-- you can either\nuse just a tuple sign",
    "start": "749560",
    "end": "755500"
  },
  {
    "text": "or oftentimes, you can just\nuse the parentheses, brackets. So you can just\nsay, for example, as you did here,\njust parentheses",
    "start": "755500",
    "end": "762550"
  },
  {
    "text": "to instantiate something. All right. And yeah, this one we'll\ncome to a little bit later in",
    "start": "762550",
    "end": "769380"
  },
  {
    "text": "shapes, but you can also have\na tuple of a single value. And all you have to do\nthere is just put the value",
    "start": "769380",
    "end": "774420"
  },
  {
    "text": "and put a comma. So that just shows that have\na tuple which is basically like an immutable array. So you can't change it.",
    "start": "774420",
    "end": "780360"
  },
  {
    "text": "It's a list but\nonly of one item. And that's here. OK. I'll quickly move\nto dictionaries.",
    "start": "780360",
    "end": "786780"
  },
  {
    "text": "For those of you who might be\nfamiliar with other languages, this is the equivalent of like\na hash map or a hash table.",
    "start": "786780",
    "end": "793241"
  },
  {
    "text": "What this is useful\nfor essentially is mapping one value to another\nin a really, really quick way. So if I want to\nmap, for example,",
    "start": "793242",
    "end": "799480"
  },
  {
    "text": "a string to an index,\nwhich you will happen to do a lot of in\nyour homeworks, this is a really, really\nuseful way to do that.",
    "start": "799480",
    "end": "805990"
  },
  {
    "text": "And so what it does is you can\ninstantiate this dictionary, and it says,\ncorresponding, that Zach",
    "start": "805990",
    "end": "811500"
  },
  {
    "text": "is going to correspond to this\nstring value, whatever it is. And so anytime I want to\nretrieve the string value,",
    "start": "811500",
    "end": "817530"
  },
  {
    "text": "I just use this dictionary. I index by it, which\nis what I do here, and then it outputs the\ncorresponding value.",
    "start": "817530",
    "end": "824350"
  },
  {
    "text": "And it does that\nreally, really quickly. And yeah, it's really useful.",
    "start": "824350",
    "end": "829690"
  },
  {
    "text": "Very, very commonly\nused, especially when you, for example, you\nhave a list of strings, or a list of items and you want\nto have a corresponding index",
    "start": "829690",
    "end": "838570"
  },
  {
    "text": "for them, because and\nas you'll see in NLP, oftentimes you're working\nwith indices and numbers",
    "start": "838570",
    "end": "844030"
  },
  {
    "text": "in particular. So it's a really\ngreat way to, sort of, move from like string formats\nto just like numerical index",
    "start": "844030",
    "end": "850870"
  },
  {
    "text": "values. There's some other things\nyou can do for dictionaries. You can check whether certain\nelements are in there.",
    "start": "850870",
    "end": "856457"
  },
  {
    "text": "So if you, for example,\ntry to index phonebook is equal to Muncy,\nit'll throw an error because there's no string that\nsays Muncy in that phonebook",
    "start": "856457",
    "end": "863440"
  },
  {
    "text": "dictionary. And so sometimes you might\nbe wanting to do checks before you extract a value. And so this will just\ncheck, for example,",
    "start": "863440",
    "end": "869750"
  },
  {
    "text": "if I do print Muncy in\nphonebook, it should say false. Or for example here, Kevin in\nphonebook, it should say false. While something that's\nactually in that dictionary,",
    "start": "869750",
    "end": "877149"
  },
  {
    "text": "Zach will be true. OK. And then if you'd like to delete\nan entry from the dictionary,",
    "start": "877150",
    "end": "883810"
  },
  {
    "text": "you can just do that\nusing the del command. All right. Let's move to loops quickly.",
    "start": "883810",
    "end": "891550"
  },
  {
    "text": "So loops are a really great way\nto optimize for the same kind",
    "start": "891550",
    "end": "896820"
  },
  {
    "text": "of operation you're doing. It's also a great way to\nstart to sequentially go over",
    "start": "896820",
    "end": "903000"
  },
  {
    "text": "those list type or\narray type objects we were talking about earlier. You have a list of names, right?",
    "start": "903000",
    "end": "908519"
  },
  {
    "text": "How do you access all of them? So loops are a really\ngreat way to do that. In Python, they've\nabstracted away",
    "start": "908520",
    "end": "914550"
  },
  {
    "text": "a lot of the confusing parts and\nother languages that might be. You can really, for example,\nfirst index on numbers.",
    "start": "914550",
    "end": "921460"
  },
  {
    "text": "So what you do is you have a\nrange function that you call. So here you say range. And the range of the\nlast number you'd want.",
    "start": "921460",
    "end": "928480"
  },
  {
    "text": "So what this range function\nwill return is 0, 1, 2, 3, 4. And that's what will be\nstored in this i value.",
    "start": "928480",
    "end": "933810"
  },
  {
    "text": "And here it's just\nprinting out that i value. So if I want to,\nfor example, loop over the length of\na list of size 10,",
    "start": "933810",
    "end": "940470"
  },
  {
    "text": "I just have to do for i\nin range 10 and then index that corresponding\npart of the list. You technically\ndon't even have to do",
    "start": "940470",
    "end": "947010"
  },
  {
    "text": "that because in Python,\nyou can just directly get the element of the list. So here I have a\nlist of names where",
    "start": "947010",
    "end": "954490"
  },
  {
    "text": "I have Zach, J and Richard. Instead of saying first\nthe length of the list, and then doing this\nrange operation,",
    "start": "954490",
    "end": "960790"
  },
  {
    "text": "I can just directly\nsay for name in names and then print out the names,\nand it will just directly get",
    "start": "960790",
    "end": "965830"
  },
  {
    "text": "the element in each list. But sometimes you\nmight want both. You might both want this element\nZach as well as its position",
    "start": "965830",
    "end": "973990"
  },
  {
    "text": "in the array. And for that, you can actually\nuse this really helpful function called enumerate. And so enumerate will basically\npair those two values,",
    "start": "973990",
    "end": "981850"
  },
  {
    "text": "and it'll give you both the\nvalue, which is here in name, for example, and its\ncorresponding index",
    "start": "981850",
    "end": "986890"
  },
  {
    "text": "within the array-- both together so that's\nreally, really convenient. Versus, for example,\nhaving to do",
    "start": "986890",
    "end": "992260"
  },
  {
    "text": "this a little bit more\ncomplicated range operation where you first take the range,\nand then you index the list.",
    "start": "992260",
    "end": "998290"
  },
  {
    "text": "How do you iterate\nover a dictionary? So for dictionaries, if\nyou want to iterate over",
    "start": "998290",
    "end": "1004140"
  },
  {
    "text": "what's called the keys, so\nall of these first items that you first put\ninto the dictionary, you can just iterate the\nsame way you would a list.",
    "start": "1004140",
    "end": "1011260"
  },
  {
    "text": "You just say for name and\nfor example, phonebook and you can output the keys. If you want to iterate over what\nis stored in the list, which",
    "start": "1011260",
    "end": "1018360"
  },
  {
    "text": "is called a value, you'd have\nto do the dictionary dot values. And if you want both, you\nuse the dot items function.",
    "start": "1018360",
    "end": "1025900"
  },
  {
    "text": "And so that will print\nout both of these. All right.",
    "start": "1025900",
    "end": "1031730"
  },
  {
    "text": "So this is sort of covering\nthe overarching, most commonly used sort of structures lists,\ndictionaries and then loops",
    "start": "1031730",
    "end": "1040040"
  },
  {
    "text": "and how to efficiently\nuse them within your code. We'll quickly be moving to the\nmeat of what is really, really",
    "start": "1040040",
    "end": "1047480"
  },
  {
    "text": "strong about Python\nand what you'll be using a lot for\nyour coming homeworks, especially homework\n2 which is NumPy.",
    "start": "1047480",
    "end": "1054240"
  },
  {
    "text": "OK. So for NumPy, also, I'm going\nto be going to the Colab but just quickly wanted\nto mention what NumPy is.",
    "start": "1054240",
    "end": "1061040"
  },
  {
    "text": "So NumPy is basically\nan optimized library for mathematical operations. People tend to like Matlab\nbecause it's very, very",
    "start": "1061040",
    "end": "1068030"
  },
  {
    "text": "useful for these mathematical\noperations which people use in their research. Python's sort of solution to\nthat is to have a separate",
    "start": "1068030",
    "end": "1074870"
  },
  {
    "text": "library entirely where they make\nuse of subroutines which are, sort of, like\nsublanguages-- sorry,",
    "start": "1074870",
    "end": "1081320"
  },
  {
    "text": "subscripts that are written in\na different language called C or C++ that are highly\noptimized for efficiency.",
    "start": "1081320",
    "end": "1088350"
  },
  {
    "text": "So the reason C and C++ are\nmuch faster than Python is because they're closer to\nwhat's called machine language, which is what the\ncomputer will read.",
    "start": "1088350",
    "end": "1094946"
  },
  {
    "text": "I mentioned earlier, one of\nthe nice things about Python is it's kind of high level. It looks like English\nto some extent. We say, literally, like if x is\nequal to 1, or x is equal to 2,",
    "start": "1094947",
    "end": "1104340"
  },
  {
    "text": "right? But that also means that there's\na lot more translation required on the computer's part before\nit understands what you mean.",
    "start": "1104340",
    "end": "1111630"
  },
  {
    "text": "And that's useful\nwhen we're writing out code, where we want\nto understand it, but it's a little\nbit less useful when you're sort of\nrunning a lot of operations",
    "start": "1111630",
    "end": "1118560"
  },
  {
    "text": "on a lot of data. So the real benefit of\nsomething like NumPy is that if you have your\nmemory and your data",
    "start": "1118560",
    "end": "1124410"
  },
  {
    "text": "in a particular format, it will\ncall these basically scripts or what are called subroutines\nin a different language,",
    "start": "1124410",
    "end": "1130020"
  },
  {
    "text": "and it'll make them\nvery, very fast. And so that's the real\nbenefit of using NumPy. And almost everyone\nin sort of NLP",
    "start": "1130020",
    "end": "1136221"
  },
  {
    "text": "is very, very familiar\nwith this because you'll be running a lot of\noperations on, for example, a co-occurrence matrices,\nwhich are really, really big",
    "start": "1136222",
    "end": "1142860"
  },
  {
    "text": "and it's very useful to have\nthem optimized for time. So that's really the\nbenefit of using NumPy.",
    "start": "1142860",
    "end": "1148470"
  },
  {
    "text": "And NumPy, basically,\nit's involved for all these math and matrix\nand vector calculations.",
    "start": "1148470",
    "end": "1153478"
  },
  {
    "text": "And it's different than a list. Although you can\neasily translate between a list\nand a NumPy array, NumPy arrays are\nspecifically, as I",
    "start": "1153478",
    "end": "1159720"
  },
  {
    "text": "mentioned, designed to be\nused in these subroutines. So they have a specific format. They're instantiated\ndifferently,",
    "start": "1159720",
    "end": "1165720"
  },
  {
    "text": "and you can translate\nbetween this and sort of your standard list\neasily but to know that you can only do NumPy\noperations on NumPy arrays.",
    "start": "1165720",
    "end": "1172290"
  },
  {
    "text": "You can't do NumPy\noperations on lists directly. You first have to convert\nthem, which is really simple.",
    "start": "1172290",
    "end": "1177310"
  },
  {
    "text": "You just use this\nNumPy.array function. But just know that they\noperate only on NumPy arrays.",
    "start": "1177310",
    "end": "1182610"
  },
  {
    "text": "OK. So for NumPy, we're going to\nbe going back to the Colab. And then as I mentioned earlier,\nthe real strength of NumPy",
    "start": "1182610",
    "end": "1190159"
  },
  {
    "text": "is it supports these large\nmulti-dimensional arrays and matrices for\nvery, very optimized",
    "start": "1190160",
    "end": "1195470"
  },
  {
    "text": "high level\nmathematical functions. And just to go step back for a\nquick second, what is a matrix?",
    "start": "1195470",
    "end": "1201630"
  },
  {
    "text": "Matrices are basically\nlike rectangular structures of numbers that are used,\nand you can treat them",
    "start": "1201630",
    "end": "1208130"
  },
  {
    "text": "with specific rules\nfor operations between different\nkinds of things. So if you have a lot of\ndata, instead of individually",
    "start": "1208130",
    "end": "1215582"
  },
  {
    "text": "potentially multiplying\nthings, if you can store them in this rectangular format,\nyou have specific rules",
    "start": "1215582",
    "end": "1220820"
  },
  {
    "text": "about how this\nmatrix for example will interact with\nthe different one. And by doing that, which is\nmatrix multiplication or matrix",
    "start": "1220820",
    "end": "1226550"
  },
  {
    "text": "math, you can do a wide variety\nof mathematical operations. A vector is generally--\nthis is conventional.",
    "start": "1226550",
    "end": "1234037"
  },
  {
    "text": "None of these are\nhard and fast rules. But conventionally, a vector\nis a matrix in one dimension.",
    "start": "1234037",
    "end": "1239520"
  },
  {
    "text": "So it's usually like a\nrow vector or a column vector, which usually just\nmeans that it's a list of values",
    "start": "1239520",
    "end": "1246433"
  },
  {
    "text": "in only one dimension. So it's like, for example, here,\nwhen I come down to x is equal to NumPy array of 1, 2, 3,\nthat's a list in only one",
    "start": "1246433",
    "end": "1254789"
  },
  {
    "text": "dimension versus, for example,\nZ-- when this is Z down here-- that is what's called\na two dimensional",
    "start": "1254790",
    "end": "1262289"
  },
  {
    "text": "array, because you have both\nrows, for example, like 6, 7 and then you have 8, 9.",
    "start": "1262290",
    "end": "1269190"
  },
  {
    "text": "Versus, in this\nfirst one, you only have three values\nin one dimension. So that's the conventional\ndifference between the two.",
    "start": "1269190",
    "end": "1276658"
  },
  {
    "text": "Another convention is\nmatrices generally referred to two dimensional objects. So as I mentioned, is like\nZ, this is two dimensional.",
    "start": "1276658",
    "end": "1283230"
  },
  {
    "text": "You might have heard\nthe word tensor also. Tensor is by convention,\nusually like higher dimensional objects.",
    "start": "1283230",
    "end": "1288970"
  },
  {
    "text": "So instead of having two\ndimensions, 2 comma 2, you can have n dimensions. You can have 2, comma 2,\ncomma 2, comma 2, comma 2,",
    "start": "1288970",
    "end": "1295860"
  },
  {
    "text": "comma 2 for like five\nor six dimensions. And those are very valid to\ndo mathematical operations on.",
    "start": "1295860",
    "end": "1301650"
  },
  {
    "text": "And those are often\ncolloquially called tensors. In addition, and this will be\ncovered in the next tutorial,",
    "start": "1301650",
    "end": "1308130"
  },
  {
    "text": "in PyTorch, those\nlarger, sort of, tensors are also optimized for\nefficiency to be used on GPUs",
    "start": "1308130",
    "end": "1315960"
  },
  {
    "text": "and so they're called tensor\nin a more concrete way because you're using\nthese tensors with PyTorch and other sort of packages to\ndirectly do those quicker GPU",
    "start": "1315960",
    "end": "1324150"
  },
  {
    "text": "operations on for deep learning. So those are, sort of--\nthat's a quick, sort of, terminology difference\nbetween the three.",
    "start": "1324150",
    "end": "1330700"
  },
  {
    "text": "OK. So now let's start off\nwith just some quick sort of representations of how are\nthese matrices and vectors",
    "start": "1330700",
    "end": "1336480"
  },
  {
    "text": "represented in NumPy. This, sort of, goes\nback to your question about what is the difference\nbetween 3 comma versus like 1,",
    "start": "1336480",
    "end": "1344700"
  },
  {
    "text": "3. So usually 3 comma\nin NumPy arrays usually just means that you have\none list of 1 to 3 for example,",
    "start": "1344700",
    "end": "1353390"
  },
  {
    "text": "or three values. Versus if you add another\nlist on top of that, this one",
    "start": "1353390",
    "end": "1358470"
  },
  {
    "text": "comma 3 essentially\nrefers to the fact that there's a list of lists. So any time you\nhave two dimensions,",
    "start": "1358470",
    "end": "1364200"
  },
  {
    "text": "it always means that\nthere's a list of lists and that being like a list of\nlists or for example, a row.",
    "start": "1364200",
    "end": "1369710"
  },
  {
    "text": "So here, 1, 3 means that there's\none row and then three columns. So it's saying there's one\nrow of 3, 4, 5, essentially,",
    "start": "1369710",
    "end": "1378230"
  },
  {
    "text": "and then each of those is\nlike a column separately. You can easily reshape them.",
    "start": "1378230",
    "end": "1383310"
  },
  {
    "text": "So these are basically\nthe same format but from NumPy's perspective,\nyou'll see a little bit later for operations such\nas broadcasting,",
    "start": "1383310",
    "end": "1390350"
  },
  {
    "text": "you need to have it, for\nexample, sometimes in this 1, 3 format or 3, 1 format.",
    "start": "1390350",
    "end": "1395450"
  },
  {
    "text": "And also like as I\nsaid, 3 is basically just like it represents\nthree numbers. 1, 3 means like one\nrow of three elements.",
    "start": "1395450",
    "end": "1403460"
  },
  {
    "text": "3, 1 will mean you have--\nessentially in each column, you'll have a separate array.",
    "start": "1403460",
    "end": "1408980"
  },
  {
    "text": "So you'll see boxes\naround each of them. There's an example\nthat comes a little bit later in this Colab which\nwill make it a little bit more",
    "start": "1408980",
    "end": "1414200"
  },
  {
    "text": "clearer. So here, if you can see the\ndifference between x and y, one of them has\nonly one bracket,",
    "start": "1414200",
    "end": "1419750"
  },
  {
    "text": "which just says it's one list,\nonly one list of 1, 2, 3. The second one is\ntwo brackets, which",
    "start": "1419750",
    "end": "1426320"
  },
  {
    "text": "says it's a list with\nonly one list in it. So it's a list of a list. That's really the main\ndifference between these sort",
    "start": "1426320",
    "end": "1433140"
  },
  {
    "text": "of two representations. So I could have, let's\nsay, a separate one.",
    "start": "1433140",
    "end": "1439900"
  },
  {
    "text": "I'm going to call this\na and I just do this. So it's the same\nsort of elements",
    "start": "1439900",
    "end": "1446650"
  },
  {
    "text": "but this will be 1, 3 because\nit's showing that there's one outer list\nwhich shows the rows",
    "start": "1446650",
    "end": "1452650"
  },
  {
    "text": "and then one inner list which\nwill have each of those values. So the benefit\nwill come when I'm",
    "start": "1452650",
    "end": "1457730"
  },
  {
    "text": "coming to, a little bit\nlater, which is broadcasting. And so essentially it\nwill help you determine what dimensions you want to\nmatch against because sometimes",
    "start": "1457730",
    "end": "1465080"
  },
  {
    "text": "you'd want to have 1, 3--\nlike, 1, 2, 3 applied only",
    "start": "1465080",
    "end": "1470269"
  },
  {
    "text": "to rows in some other matrix. We'll come to that\na little bit later. But sometimes you might want to\nhave it only apply to columns.",
    "start": "1470270",
    "end": "1476930"
  },
  {
    "text": "And so if I have a separate\nmatrix, for example, of 00000000 and I want the\nresulting matrix to be,",
    "start": "1476930",
    "end": "1484320"
  },
  {
    "text": "for example, 123123123\nalong the rows-- let me actually draw this out. It might be easier.",
    "start": "1484320",
    "end": "1489930"
  },
  {
    "text": "So let's say I have the 00000000\nand if I want to have a matrix",
    "start": "1489930",
    "end": "1499170"
  },
  {
    "text": "that does 123123123\nversus 123123123,",
    "start": "1499170",
    "end": "1510780"
  },
  {
    "text": "the difference in how to\ngenerate these two will be the difference in how you\nrepresent their shape.",
    "start": "1510780",
    "end": "1516490"
  },
  {
    "text": "It's the same 123 but\nthe resulting array you're generating by\nrepeating the 1, 2, 3 values",
    "start": "1516490",
    "end": "1523140"
  },
  {
    "text": "requires a difference in shape. And so we'll come\nto that a little bit later, because\nthis process of how do you generate these arrays\nis called broadcasting.",
    "start": "1523140",
    "end": "1528720"
  },
  {
    "text": "But that's the real\nbenefit of having an understanding of the shapes. The same 1, 2, 3\nvalues are the same. It's just how they're\nsort of used with regards",
    "start": "1528720",
    "end": "1535200"
  },
  {
    "text": "to other arrays. All right. So yeah, vectors can be\nrepresented as, sort of-- this is what I talked about earlier,\nas like n dimensions, n by 1,",
    "start": "1535200",
    "end": "1542810"
  },
  {
    "text": "or 1 by n dimensions,\nand they can result in this different\nbehavior kind of like this that I talked about.",
    "start": "1542810",
    "end": "1548250"
  },
  {
    "text": "Matrices are usually in two\ndimensions represented as m by n. These are just two examples. For example, I generate, let's\nsay-- and you can also reshape.",
    "start": "1548250",
    "end": "1555643"
  },
  {
    "text": "So I start with, for\nexample, this array, which is a list of 10. Oh, sorry. Let me import NumPy quickly.",
    "start": "1555643",
    "end": "1561495"
  },
  {
    "text": " So I started off\nwith this matrix a",
    "start": "1561495",
    "end": "1566630"
  },
  {
    "text": "which is basically a one\ndimensional list of 10 values. I can reshape it\ninto a 5 by 2 matrix.",
    "start": "1566630",
    "end": "1571884"
  },
  {
    "text": "So you just have to make sure\nthat your dimensions match, which means that you can\nmultiply them together and get",
    "start": "1571885",
    "end": "1577400"
  },
  {
    "text": "the original size. So if I start off with the\n10 matrix, I can make a 2 by 5 matrix. I can make a 5 by 2 matrix.",
    "start": "1577400",
    "end": "1583520"
  },
  {
    "text": "I can make a 10 by 1, 1 by 10. I can't make a, for\nexample, 3 and 5 because it wouldn't fit\ninto the original size.",
    "start": "1583520",
    "end": "1589880"
  },
  {
    "text": "And for that, this\noperation called reshape is really useful. You might be wondering, why\nis there two parentheses?",
    "start": "1589880",
    "end": "1595940"
  },
  {
    "text": "The way that reshape\nworks is essentially it will take in a tuple. So remember what I talked\nabout earlier with tuples",
    "start": "1595940",
    "end": "1601310"
  },
  {
    "text": "is that these-- they\nare immutable objects and they're defined\nby parentheses. So the outer parentheses\nis representing",
    "start": "1601310",
    "end": "1606757"
  },
  {
    "text": "what you're inputting\nto the function and what you're\ninputting is a tuple. So it uses a second\nset of parentheses.",
    "start": "1606758",
    "end": "1613000"
  },
  {
    "text": "So now let's go to\nsome array operations. So I started off\nwith this array x.",
    "start": "1613000",
    "end": "1619440"
  },
  {
    "text": "When you apply\nsimple operations, for example, a max\noperation, sometimes you might want the max\nof the entire array.",
    "start": "1619440",
    "end": "1625120"
  },
  {
    "text": "So if I do the max of\nan the entire array-- what's the max value of the\nentire array by the way? Just the entire thing.",
    "start": "1625120",
    "end": "1630490"
  },
  {
    "text": "Yes, 6, right? So if I just do np.max of\nx, it'll return one value. It'll return 6.",
    "start": "1630490",
    "end": "1636309"
  },
  {
    "text": "Well, let's say I want\nthe max of every row. In each of these rows,\nI say I want, let's say,",
    "start": "1636310",
    "end": "1642017"
  },
  {
    "text": "the max of each row. I want 2 and then 4 and then 6. How do you do that? And so NumPy always\nhas, like usually",
    "start": "1642017",
    "end": "1648669"
  },
  {
    "text": "in most of their functions,\nan axis variable. And what the axis\nvariable will do is it'll tell you which\nof these dimensions",
    "start": "1648670",
    "end": "1655090"
  },
  {
    "text": "do you want to\ntake the max over. And the way to\nthink about it is-- this is going to be\na little bit tricky,",
    "start": "1655090",
    "end": "1660670"
  },
  {
    "text": "but the way people\ndescribe it is the axis is what you want to\napply your function over.",
    "start": "1660670",
    "end": "1666160"
  },
  {
    "text": "What you want to reduce over. And what that means\nis I print out the shape of the original array.",
    "start": "1666160",
    "end": "1671320"
  },
  {
    "text": "It's 3 by 2. I want to apply axis 1. As I remember, NumPy is 0 index.",
    "start": "1671320",
    "end": "1677259"
  },
  {
    "text": "It'll be 0, 1. So I want to apply the max\nover the second dimension. The second dimension means that\nfor each of these, essentially,",
    "start": "1677260",
    "end": "1687340"
  },
  {
    "text": "the row dimension is\nthe first dimension. So it's all along the rows. I'm going to be\ncomparing columns.",
    "start": "1687340",
    "end": "1692559"
  },
  {
    "text": "And so compare this entire\ncolumn to this entire column. And so just remember for\naxes, usually the axis 0",
    "start": "1692560",
    "end": "1700750"
  },
  {
    "text": "refers to the row axis\nand the axis 1 refers to the column axis. If you don't even\nwant to remember that,",
    "start": "1700750",
    "end": "1705940"
  },
  {
    "text": "you can just remember that from\nthe original dimension, which of these it's referring to and\nthat's the dimension you want",
    "start": "1705940",
    "end": "1712510"
  },
  {
    "text": "to compare over or reduce over. So it can be a little bit\nharder to grasp around it.",
    "start": "1712510",
    "end": "1718503"
  },
  {
    "text": "Usually the best\nway to get around is to just play with a bunch\nof operations of min, max",
    "start": "1718503",
    "end": "1723610"
  },
  {
    "text": "and things like that. But just remember\nlike the axis is what you want to compare\nover not the resulting thing.",
    "start": "1723610",
    "end": "1729250"
  },
  {
    "text": "So axis 1 means your column. I want to compare\nbetween the columns. I want to get-- for example,\ncompare 1 to 2, 3 to 4, 5 to 6.",
    "start": "1729250",
    "end": "1737900"
  },
  {
    "text": "Does that make sense? OK. And what this will do is\nif I just do np.axis axis,",
    "start": "1737900",
    "end": "1745230"
  },
  {
    "text": "it'll just return-- basically since I'm\ncomparing these columns, it'll just return\na result in column. And so as I mentioned,\nfor over the axis 1,",
    "start": "1745230",
    "end": "1752880"
  },
  {
    "text": "you get three values,\nbecause you're comparing over these\ncolumns, and each column has three values. I'm comparing over\nrows, as we mentioned,",
    "start": "1752880",
    "end": "1759330"
  },
  {
    "text": "I get two values, right? And so this will just\nbe the tuple comma which is just indicating\nthat it's just a list.",
    "start": "1759330",
    "end": "1765218"
  },
  {
    "text": "It's not a list of lists. It's just a list. But let's say I want\na list of lists. Maybe I want to do\nthose operations I talked about earlier.",
    "start": "1765218",
    "end": "1771750"
  },
  {
    "text": "Instead of reshaping\nwhich is always there, it's always an\noption, you can also use this feature\ncalled keepdims.",
    "start": "1771750",
    "end": "1778290"
  },
  {
    "text": "And what that will do is it'll\ntake the original dimensions, which is two dimensions\nbecause you have 3, 2,",
    "start": "1778290",
    "end": "1784200"
  },
  {
    "text": "there's two of them, and\nit'll keep that consistent. So it'll be 3, 1.",
    "start": "1784200",
    "end": "1789480"
  },
  {
    "text": "But it just means that\ninstead of returning just the extracted column,\nwhich is just a list,",
    "start": "1789480",
    "end": "1794669"
  },
  {
    "text": "it'll basically keep the\ncolumn in the context of the original\nsort of x and it'll",
    "start": "1794670",
    "end": "1800140"
  },
  {
    "text": "keep it as like a two\ndimensional value. All right.",
    "start": "1800140",
    "end": "1806610"
  },
  {
    "text": "Now these are just\nsome operations. So in NumPy, you can use\nan asterisk as an element",
    "start": "1806610",
    "end": "1812850"
  },
  {
    "text": "wise multiplication. So an asterisk\nmeans that I'm going to be comparing\nevery single value to every single corresponding\nvalue in another matrix",
    "start": "1812850",
    "end": "1820170"
  },
  {
    "text": "and you need your\nmatrices to also be the same size for this one. So this one, it's basically\nan element wise matrix.",
    "start": "1820170",
    "end": "1825480"
  },
  {
    "text": "It's not a matrix\nmultiplication so you need to have them be\nthe exact same size. So this will compare, for\nexample, 1 into 3, 2 into 3,",
    "start": "1825480",
    "end": "1831809"
  },
  {
    "text": "3 into 3 and 4 into 3. All right. You can also do\nmatrix multiplication,",
    "start": "1831810",
    "end": "1837490"
  },
  {
    "text": "which is a different\noperation entirely. For those of you who\naren't familiar with matrix multiplication,\nyou would basically",
    "start": "1837490",
    "end": "1844679"
  },
  {
    "text": "be multiplying a\nrow of one matrix with a column of another matrix\nand for that to be necessary,",
    "start": "1844680",
    "end": "1850870"
  },
  {
    "text": "you need to have the second\ndimension of the first array be equal to the first\ndimension of the second array.",
    "start": "1850870",
    "end": "1855960"
  },
  {
    "text": "So for matrix multiplication\nif I have an A into B, B",
    "start": "1855960",
    "end": "1864059"
  },
  {
    "text": "into C shaped\nmatrices, these two have to be equal for\nmatrix multiplication.",
    "start": "1864060",
    "end": "1870150"
  },
  {
    "text": "Just something to keep in\nmind because oftentimes if you're doing matrix\nmultiplication, you need--",
    "start": "1870150",
    "end": "1875805"
  },
  {
    "text": "you have to make sure that these\ndimensions are the same, which means that, for example,\nthis is a valid operation,",
    "start": "1875805",
    "end": "1886560"
  },
  {
    "text": "but this can sometimes\nthrow an error.  Sometimes.",
    "start": "1886560",
    "end": "1892170"
  },
  {
    "text": "So it's just\nimportant to make sure that sometimes you\nwant to make sure that these are exactly equal. You can actually just\nprint out the shapes",
    "start": "1892170",
    "end": "1897809"
  },
  {
    "text": "and make sure that\nthese are equal to be doing matrix multiplication. And then for matrix\nmultiplication,",
    "start": "1897810",
    "end": "1903010"
  },
  {
    "text": "there's a couple of\nfunctions you can use. The first one is just np.matmul\nwhich is NP dot matrix",
    "start": "1903010",
    "end": "1909750"
  },
  {
    "text": "multiplication. You can also just use\nthe add operation. And both of those\nare overloaded.",
    "start": "1909750",
    "end": "1915472"
  },
  {
    "text": "You can choose whichever one. They'll result in the\nsame exact operation. And just a quick\nsearch-- let me show.",
    "start": "1915472",
    "end": "1920970"
  },
  {
    "text": "You can-- to show what this will\ndo is it'll multiply 1 into 2, so it'll come like\n1, 2 versus 3, 4.",
    "start": "1920970",
    "end": "1927269"
  },
  {
    "text": "So it'll do 1 into 3, 2 into\n3 and add those two values. So that's what matrix\nmultiplication will do.",
    "start": "1927270",
    "end": "1935130"
  },
  {
    "text": "OK. And then dot products will-- what a dot product is\nthat it takes two vectors.",
    "start": "1935130",
    "end": "1940510"
  },
  {
    "text": "So usually it\noperates on vectors. And a vector, as I\nmentioned, is just like a one dimensional matrix.",
    "start": "1940510",
    "end": "1946179"
  },
  {
    "text": "So it's just basically 3 cross\n1 for example or 4 cross 1. It'll element wise multiply\nbetween two different vectors,",
    "start": "1946180",
    "end": "1951840"
  },
  {
    "text": "and it'll sum up those values. And so here, what a\ndot product would do would be like 1 into 1 plus\n2 into 10 plus 3 into 100.",
    "start": "1951840",
    "end": "1959009"
  },
  {
    "text": "And for a NumPy, you can\njust do NP dot and then both of those vectors.",
    "start": "1959010",
    "end": "1965370"
  },
  {
    "text": "This one is just\na side on how you would want the structure\nof the dot product to be.",
    "start": "1965370",
    "end": "1971040"
  },
  {
    "text": "For arrays that are more-- OK. So to phrase this the best way.",
    "start": "1971040",
    "end": "1976710"
  },
  {
    "text": "For single dimensional vectors,\nthis operation works directly. Anytime it's a multiple\ndimensional matrix,",
    "start": "1976710",
    "end": "1985420"
  },
  {
    "text": "then it treats it as a\nmatrix multiplication. The NP dot, dot function. So for 2 by 2 matrix versus\na 2 by 2 matrix dot product,",
    "start": "1985420",
    "end": "1992820"
  },
  {
    "text": "it's not going to\nreturn the sum. It's going to return the\nmatrix multiplication. That's just something\nto keep in mind.",
    "start": "1992820",
    "end": "1999120"
  },
  {
    "text": "If you want to make sure that\nyour dot product is happening in the correct\nway, you would want",
    "start": "1999120",
    "end": "2006140"
  },
  {
    "text": "to make sure that\nsort of similar to what I was talking\nabout earlier, that--",
    "start": "2006140",
    "end": "2011840"
  },
  {
    "text": "here. I think the best way to show it.",
    "start": "2011840",
    "end": "2016899"
  },
  {
    "text": "OK. So you would want the second,\nlike what I mentioned, like the last dimension\nof the first one",
    "start": "2016900",
    "end": "2023158"
  },
  {
    "text": "to match with the first\ndimension of the next one because it's treating it\nas a matrix multiplication. Here, the error\nthat it's throwing",
    "start": "2023158",
    "end": "2030330"
  },
  {
    "text": "is 3, 2 combined with 3 and\nso the way to sort of like fix that would be to have\nthis be like, for example,",
    "start": "2030330",
    "end": "2039660"
  },
  {
    "text": "switch the two so you'd\nhave 2, 3 and then 3 comma. It's really a dimension\nmatching thing at this point.",
    "start": "2039660",
    "end": "2046870"
  },
  {
    "text": "So it can be a little bit\nconfusing, but when you-- the main thing to keep in mind\nis like for single dimensional",
    "start": "2046870",
    "end": "2052500"
  },
  {
    "text": "vectors, you can just do np.. directly and it'll give\nyou the dot product value. For higher dimensional\nmatrices, it treats it",
    "start": "2052500",
    "end": "2058215"
  },
  {
    "text": "as a matrix multiplication. And so if you still want to--\nfor those higher dimensional",
    "start": "2058215",
    "end": "2063899"
  },
  {
    "text": "values to ensure that you're\ngetting a dot product, you'd have to make sure\nthat the dimensions are aligned similar to these.",
    "start": "2063900",
    "end": "2070239"
  },
  {
    "text": "So anything that's 2\nby 2 plus for both-- any matrix that doesn't have\na single dimension in any",
    "start": "2070239",
    "end": "2077230"
  },
  {
    "text": "of them, yes, it would\ntreat it as matrix matmul. The same thing.",
    "start": "2077230",
    "end": "2083219"
  },
  {
    "text": "OK. All right. OK. I'm going to move to indexing.",
    "start": "2083219",
    "end": "2088290"
  },
  {
    "text": "So similar to what I was\ntalking about earlier, remember with lists I was saying if\nyou just do the semicolon, it'll create the same array?",
    "start": "2088290",
    "end": "2095119"
  },
  {
    "text": "Same deal here. The semicolon just means\nyou take everything from the original array. In fact, it returns a copy. So it returns a deep copy.",
    "start": "2095120",
    "end": "2101810"
  },
  {
    "text": "Means you have a complete\nseparate copy in memory. OK. Now I'm going to sort of\nmore details about how",
    "start": "2101810",
    "end": "2107420"
  },
  {
    "text": "do you want to index quickly. So if I, for example, have,\nlet's say, this 3 by 4 matrix",
    "start": "2107420",
    "end": "2113510"
  },
  {
    "text": "and I only want to select\nthe 0 and the second rows, how would I do that? So what's useful is that you\ncan sort of treat a NumPy,",
    "start": "2113510",
    "end": "2120680"
  },
  {
    "text": "you can treat different\ndimensions differently for indexing. So a semicolon means\nyou select everything",
    "start": "2120680",
    "end": "2125947"
  },
  {
    "text": "in that dimension, which\nfor example, here there's a semicolon in the\nsecond dimension, which means I'm taking all\nof the column values.",
    "start": "2125947",
    "end": "2133400"
  },
  {
    "text": "Versus what's in the\nfirst dimension here it's saying a NumPy\narray of 0 and 2. So it's saying only the 0\nindex and only the 2 index,",
    "start": "2133400",
    "end": "2141270"
  },
  {
    "text": "which means only the zeroth\nrow and only the second row. So what this would look\nlike would be something",
    "start": "2141270",
    "end": "2147780"
  },
  {
    "text": "like I have a matrix. ",
    "start": "2147780",
    "end": "2155430"
  },
  {
    "text": "OK. I have a matrix and I only\nwant to select the zeroth row and I only want to select\nthe column-- the second row.",
    "start": "2155430",
    "end": "2161990"
  },
  {
    "text": "Zero and second. And everything in the columns. ",
    "start": "2161990",
    "end": "2167080"
  },
  {
    "text": "All right. And then similarly,\nfor example, if I want to select in\nthe column dimension,",
    "start": "2167080",
    "end": "2172960"
  },
  {
    "text": "I want to select the first\nand second rows and only the first row, I can do that. So you can basically\ntreat them separately.",
    "start": "2172960",
    "end": "2178990"
  },
  {
    "text": "You can think, how\nmany columns do I want? How many rows do I want? And then index those separately. And that goes for\nas many dimensions",
    "start": "2178990",
    "end": "2184990"
  },
  {
    "text": "as you want in\nyour entire tensor. Some nice things also, if I\nwanted, for example, take--",
    "start": "2184990",
    "end": "2191460"
  },
  {
    "text": "I have this-- let me print\nthat actually x here. I'll just generate the x.",
    "start": "2191460",
    "end": "2197039"
  },
  {
    "text": "OK. So this is x. So if I want to take\nall the values of x that are above\n0.5, for example, I",
    "start": "2197040",
    "end": "2203360"
  },
  {
    "text": "can do that by using what's\ncalled Boolean indexing. So I just basically will\nsay x indexed by everything",
    "start": "2203360",
    "end": "2211280"
  },
  {
    "text": "in x that's bigger than 0.5. So it's pretty direct and it'll\njust output all the values in this entire array\nthat are bigger than 0.5.",
    "start": "2211280",
    "end": "2220230"
  },
  {
    "text": "All right. This one is also another\nway to do reshaping. So I kind of mentioned\nearlier, sometimes you",
    "start": "2220230",
    "end": "2226560"
  },
  {
    "text": "have this list of three elements\nand you want to reshape it to a 3 by 1 array, for example.",
    "start": "2226560",
    "end": "2232570"
  },
  {
    "text": "You can also use what's\ncalled NumPy.mulaxis. This will essentially\nadd another axis",
    "start": "2232570",
    "end": "2238290"
  },
  {
    "text": "in whatever dimension you want. So if I want to go from like\nthis 3 by 4 array to a 3",
    "start": "2238290",
    "end": "2244020"
  },
  {
    "text": "by 4 to 3 by 4 by 1, then I can\njust add a NumPy.mulaxis there.",
    "start": "2244020",
    "end": "2251598"
  },
  {
    "text": "An even simpler way\nto think about it would be like a 2\ncomma to a 2, 1.",
    "start": "2251598",
    "end": "2258131"
  },
  {
    "text": "And so it's just--\nit's another way to do what\nessentially what would be the reshaping operation.",
    "start": "2258132",
    "end": "2265150"
  },
  {
    "text": "Does that make sense? Also what this would\nlook like for example-- let me just make it a\nlittle bit more concrete. ",
    "start": "2265150",
    "end": "2278260"
  },
  {
    "text": "So you see, I have this list. I have a singular list\nand then in that list,",
    "start": "2278260",
    "end": "2283331"
  },
  {
    "text": "I have a list of lists. So I have a list with element\n1 and list of element 2. So this is what that\nreshape operation will do.",
    "start": "2283332",
    "end": "2290680"
  },
  {
    "text": "And what NumPy.mulaxis will\nenable you to do as well. All right.",
    "start": "2290680",
    "end": "2296900"
  },
  {
    "text": "I think we are good for time. So the last main topic we'll\nbe covering is broadcasting.",
    "start": "2296900",
    "end": "2304250"
  },
  {
    "text": "And what's really great\nabout broadcasting is it'll allow you to operate\nwith NumPy arrays that",
    "start": "2304250",
    "end": "2310250"
  },
  {
    "text": "are of different shapes,\nbut can be, sort of-- if many operations in\nthem can be repeated,",
    "start": "2310250",
    "end": "2315869"
  },
  {
    "text": "it allows for that in a\nvery efficient manner. And this is actually one\nof the most, I would say, useful things about NumPy and\none of its defining features.",
    "start": "2315870",
    "end": "2321980"
  },
  {
    "text": "And what that means is if for\nexample in this case, right? If we go back to this\nexample that I had with--",
    "start": "2321980",
    "end": "2329180"
  },
  {
    "text": "I start off with the 000 array. How do I generate this\narray versus how do",
    "start": "2329180",
    "end": "2335539"
  },
  {
    "text": "I generate this array, right? Instead of me saying,\nOK, element 00 plus 1,",
    "start": "2335540",
    "end": "2342800"
  },
  {
    "text": "element 01 plus 2, all\nof that stuff, right? Instead of doing that one by\none, what broadcasting allows",
    "start": "2342800",
    "end": "2349040"
  },
  {
    "text": "me to do is I can have only\none vector of size 1, 2, 3 and depending on how I do the\nbroadcasting which I'll come to",
    "start": "2349040",
    "end": "2357990"
  },
  {
    "text": "in a second, I can duplicate\nit along the row dimension or I can duplicate it\nalong the column dimension.",
    "start": "2357990",
    "end": "2364170"
  },
  {
    "text": "And NumPy allows for that. It'll do that on its\nown in the back end. And so that's really\nwhat broadcasting means",
    "start": "2364170",
    "end": "2369390"
  },
  {
    "text": "is I don't need to, for\nexample, create a new array saying I want to create a\nnew array to begin with,",
    "start": "2369390",
    "end": "2376029"
  },
  {
    "text": "which is already like this and\nthen add those two together. I can just duplicate\nthis and get this.",
    "start": "2376030",
    "end": "2381270"
  },
  {
    "text": "All right. So now some rules\nfor broadcasting. And let me just quickly\nvisually also just show what broadcasting will do.",
    "start": "2381270",
    "end": "2387740"
  },
  {
    "text": "Oh, sorry. So broadcasting-- this is a\npretty good visual analogy.",
    "start": "2387740",
    "end": "2394030"
  },
  {
    "text": "I have this 1 by 1 1,\n2, 3 vector, right, and I want to basically\nadd, let's say,",
    "start": "2394030",
    "end": "2402010"
  },
  {
    "text": "only the columns with\nthis 1, 2, 3 vector. So what broadcasting\nallows you to do",
    "start": "2402010",
    "end": "2407890"
  },
  {
    "text": "is you only pass these two\nvalues in and on the back end, it will duplicate this\nalong the column dimension.",
    "start": "2407890",
    "end": "2413619"
  },
  {
    "text": "So let's say, I have 123123123\nand then it'll do the addition. Similarly, if I pass\nit a vector 1, 2, 3, 4",
    "start": "2413620",
    "end": "2423010"
  },
  {
    "text": "and I want it to be added\nto each of the rows instead of each of the columns,\nit'll be able to do that by sort of duplicating\nit on the back end.",
    "start": "2423010",
    "end": "2429440"
  },
  {
    "text": "So this is visually what's\nhappening with broadcasting. All right.",
    "start": "2429440",
    "end": "2434680"
  },
  {
    "text": "Now some rules. So how does NumPy know when\nand how to do broadcasting?",
    "start": "2434680",
    "end": "2439960"
  },
  {
    "text": "So the main two rules to keep\nin mind for broadcasting is one, it can only happen if\nall of the dimensions,",
    "start": "2439960",
    "end": "2446859"
  },
  {
    "text": "every single dimension between\ntwo arrays are compatible. And when they say\nwhat is compatible?",
    "start": "2446860",
    "end": "2452170"
  },
  {
    "text": "Either the dimension values\nare equal or one of them is equal to 1. And that is the\nonly rule required.",
    "start": "2452170",
    "end": "2458570"
  },
  {
    "text": "So for example, I start\noff with this x array. I have this 3 by 4 x array.",
    "start": "2458570",
    "end": "2465070"
  },
  {
    "text": "Will y is equal to 3\ncomma 1 be compatible? Yes, it will be.",
    "start": "2465070",
    "end": "2470359"
  },
  {
    "text": "Why? Because you have 3 in the first\ndimension between the two, which are the same and in the\nsecond dimension, you have 4",
    "start": "2470360",
    "end": "2475790"
  },
  {
    "text": "and you have 1. So those are compatible values. And so what this tells\nNumPy on the back end is I'm doing, for example, an\naddition operation x plus y.",
    "start": "2475790",
    "end": "2483980"
  },
  {
    "text": "It knows that OK, 3\nand 3 are the same but 4 and 1 are not the same. One of them has one dimension.",
    "start": "2483980",
    "end": "2490369"
  },
  {
    "text": "So I need to duplicate this\ny along the second dimension, which means I need to duplicate\nit along the column dimension.",
    "start": "2490370",
    "end": "2497330"
  },
  {
    "text": "And once it does that,\nit duplicates it. It'll get 3 comma 4 an array\nand then it can do the addition.",
    "start": "2497330",
    "end": "2502610"
  },
  {
    "text": "And it does that really fast. So it's better to use\nbroadcasting in this way then for you to create\na separate array already",
    "start": "2502610",
    "end": "2508760"
  },
  {
    "text": "duplicated and then add them. Similarly, I have this\nz array, which is 1, 4.",
    "start": "2508760",
    "end": "2515690"
  },
  {
    "text": "What x into z will do is\nfirst it'll check OK, 3, 1. OK, is that compatible?",
    "start": "2515690",
    "end": "2521512"
  },
  {
    "text": "Yes, because you have\n3 in one dimension, and you have one in the second\nand 4 and 4 are compatible. OK.",
    "start": "2521512",
    "end": "2526730"
  },
  {
    "text": "So let's say I know that\nthese two are compatible. In the second dimension, I\ndon't need to change anything. In the first\ndimension, it'll know to duplicate them, basically.",
    "start": "2526730",
    "end": "2533300"
  },
  {
    "text": "So it'll know to\nduplicate z and so add it three times\nin the row dimension.",
    "start": "2533300",
    "end": "2538910"
  },
  {
    "text": "Create a separate array and\nthen multiply those two. So this is giving you an example\nof saying I started off with x.",
    "start": "2538910",
    "end": "2545340"
  },
  {
    "text": "I have y and then the\nfinal shape will be 3, 4. So a lot of times\nin deep learning you",
    "start": "2545340",
    "end": "2551160"
  },
  {
    "text": "will have the same-- you'll have different batches\nof different images coming in,",
    "start": "2551160",
    "end": "2557130"
  },
  {
    "text": "but you want to\napply, let's say, the same weight\nmatrix to all of them. And instead of duplicating that\nweight matrix a hundred or even",
    "start": "2557130",
    "end": "2564613"
  },
  {
    "text": "like potentially, depending\non the size of your batch size like 1,000 times and then\nadding those together,",
    "start": "2564613",
    "end": "2570000"
  },
  {
    "text": "you use the same\nmatrix, and it'll know OK, if I'm going to be\nduplicating over the batch dimension, it'll do that\nfor you on the back end.",
    "start": "2570000",
    "end": "2576277"
  },
  {
    "text": "So it's used a lot of times in\ndeep learning because of this. And basically in\nyour second homework, that's basically\nwhat you'll be doing.",
    "start": "2576278",
    "end": "2582100"
  },
  {
    "text": "You'll be implementing a\nfeed forward network in NumPy and it'll say you\nhave this W matrix,",
    "start": "2582100",
    "end": "2587670"
  },
  {
    "text": "you have this B matrix\nwhich is a bias-- we'll come to those in class-- and it'll ask you to\nimplement that in NumPy",
    "start": "2587670",
    "end": "2593520"
  },
  {
    "text": "because that's basically\nwhat you're doing. Is that you have\nthis input image, you have a weight matrix,\nwhich will somehow scale it",
    "start": "2593520",
    "end": "2598800"
  },
  {
    "text": "to an output and\nthat weight matrix will be applied to multiple\nimages in your batch. And those images\ncan be different,",
    "start": "2598800",
    "end": "2604660"
  },
  {
    "text": "but their sizes will be the same\nand it's optimized for that. OK.",
    "start": "2604660",
    "end": "2611070"
  },
  {
    "text": "So this is just more\nexamples of the same thing. Your final thing that you'll be\ncoming to is the size of 3, 4.",
    "start": "2611070",
    "end": "2617780"
  },
  {
    "text": "Let's see. This one's the\nexample that I showed right here, which is that I have\nthis array of let's say zeros.",
    "start": "2617780",
    "end": "2624650"
  },
  {
    "text": "I have this NumPy,\nthis B array of size-- what size would this be? Yes, good.",
    "start": "2624650",
    "end": "2629900"
  },
  {
    "text": "Because you have one outer\nlist and inside this, you have one inner list. So it's just basically one row\nand then three values inside",
    "start": "2629900",
    "end": "2636860"
  },
  {
    "text": "so yes. And so would this be compatible? Yes, and so it'll know basically\nto duplicate over the row",
    "start": "2636860",
    "end": "2643020"
  },
  {
    "text": "dimension. And so you're going\nto get duplicates in the row dimensions. You're going to get\n123123123, and that's",
    "start": "2643020",
    "end": "2648080"
  },
  {
    "text": "what's happening here. So these are, for example,\na little bit-- sometimes it says more complex behavior.",
    "start": "2648080",
    "end": "2655005"
  },
  {
    "text": "What this basically\njust means is that if I have this B\nvector, which is 3, 1.",
    "start": "2655005",
    "end": "2660579"
  },
  {
    "text": "If I'm doing this B plus B\ndot transpose-- by the way, transpose is just\nchanging the dimensions.",
    "start": "2660580",
    "end": "2665800"
  },
  {
    "text": "It's switching them. So if I have a 2 by 3 matrix,\na transpose will be a 3 by 2 matrix. What that means\nvisually is something",
    "start": "2665800",
    "end": "2672340"
  },
  {
    "text": "like your row and rows\nand like column dimensions will get switched.",
    "start": "2672340",
    "end": "2678549"
  },
  {
    "text": "6 goes to, I believe, it's\nlike 1, 2, 3, 4, 5, 6.",
    "start": "2678550",
    "end": "2684850"
  },
  {
    "text": "So like three rows versus\nlike three columns. And what this is just saying\nis that a 3 by 1 and a 1 by 3--",
    "start": "2684850",
    "end": "2694442"
  },
  {
    "text": "both of those vectors\nwill be compatible because remember\nin each dimension, it's either the same or a 1.",
    "start": "2694443",
    "end": "2699619"
  },
  {
    "text": "And so it knows to duplicate\nover both of those dimensions, and that's what's\nhappening here.",
    "start": "2699620",
    "end": "2706770"
  },
  {
    "text": "OK. So I think we are right at time. And what I would\nrecommend is basically playing with variations of this\nfor broadcasting and see-- just",
    "start": "2706770",
    "end": "2714800"
  },
  {
    "text": "remember, the two\nrules for broadcasting is just if it's compatible,\nit's either the same value or it's 1.",
    "start": "2714800",
    "end": "2720500"
  },
  {
    "text": "And whatever is\nthe 1 dimension is what's going to be duplicated\nover on the back end. So yeah, it's not going to\nbe compatible if they're",
    "start": "2720500",
    "end": "2726080"
  },
  {
    "text": "divisible for example. So if you have let's say 6\nand 3, that's not compatible.",
    "start": "2726080",
    "end": "2731090"
  },
  {
    "text": "You can reshape it and then see\nif you would like to have 1-- there's tricks you\ncan use where you're",
    "start": "2731090",
    "end": "2737177"
  },
  {
    "text": "thinking like on the\nback end, how do I want this data to be multiplied? You can maybe reshape\neverything into a 1 by 18 matrix",
    "start": "2737177",
    "end": "2744080"
  },
  {
    "text": "and then multiply everything\nand then reshape it back. That's what you can do, but\nyou can never just directly, for example, 6 by 3--\nmake that compatible.",
    "start": "2744080",
    "end": "2751940"
  },
  {
    "text": "OK. So I think let's wrap up. This was just a quick example of\nanother use of efficient NumPy",
    "start": "2751940",
    "end": "2757760"
  },
  {
    "text": "code. Quick note, never--\npreferably, don't use loops whenever you're dealing\nwith large data matrices.",
    "start": "2757760",
    "end": "2765170"
  },
  {
    "text": "Mostly because loops are almost\nalways about 100 times slower. NumPy is usually\nvery, very efficient.",
    "start": "2765170",
    "end": "2771667"
  },
  {
    "text": "And so this is just\nan example of what you can accomplish with NumPy\nand the same thing using loops.",
    "start": "2771667",
    "end": "2776820"
  },
  {
    "text": "So what this is saying is that\nI have an x matrix of size 1,000 by 1,000 and I want to apply--",
    "start": "2776820",
    "end": "2782820"
  },
  {
    "text": "let's say, I want to add\neverything from row 100 onwards with plus 5.",
    "start": "2782820",
    "end": "2788100"
  },
  {
    "text": "So visually what that will\nlook like is something like I have this full matrix\nand I want everything here",
    "start": "2788100",
    "end": "2796800"
  },
  {
    "text": "basically to be add with\nplus-- added with plus 5. Then in a loop format,\nI can basically",
    "start": "2796800",
    "end": "2803490"
  },
  {
    "text": "loop over the first\ndimension of 100 plus and do that or in\nNumPy, I can basically do what's called NumPy.arrange,\nwhich will generate integers",
    "start": "2803490",
    "end": "2811440"
  },
  {
    "text": "in basically 1, 2, 3,\n4, 5, 6, all the way up to that 100 value. In this case, it's\nbetween 100 and 1,000.",
    "start": "2811440",
    "end": "2817050"
  },
  {
    "text": "So it'll start with 100,\n101, 102 all the way to 1,000 in the first dimension,\nand then just add that with 5.",
    "start": "2817050",
    "end": "2822940"
  },
  {
    "text": "So this is just\nan example of how you would switch from\nusing loops to using NumPy and it's a lot, lot faster.",
    "start": "2822940",
    "end": "2828809"
  },
  {
    "start": "2828810",
    "end": "2833000"
  }
]