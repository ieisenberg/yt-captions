[
  {
    "start": "0",
    "end": "80000"
  },
  {
    "text": "thank you thanks Andy for the introduction and thanks for inviting ya so today we're going to talk about my",
    "start": "11740",
    "end": "19710"
  },
  {
    "text": "attempt at building a superscalar out-of-order processor Burnett no it's it's really I wanted to",
    "start": "19710",
    "end": "30520"
  },
  {
    "text": "build a processor and the FPGA is kind of an excuse to do so so first of all",
    "start": "30520",
    "end": "35649"
  },
  {
    "text": "myself so I'm currently a CP Architect at Intel in Hillsboro I started there about a year ago and I did my PhD at the",
    "start": "35649",
    "end": "42940"
  },
  {
    "text": "University of Toronto before that so today's talk is going to be about the work done at U of T during my PhD so",
    "start": "42940",
    "end": "51129"
  },
  {
    "text": "this I'm going to split this talk into basically two major parts I'm going to first start with some motivation you",
    "start": "51129",
    "end": "57249"
  },
  {
    "text": "know why we want to build this processor why I chose x86 and then go through you",
    "start": "57249",
    "end": "62320"
  },
  {
    "text": "know just the high-level overview of what I did and what the final results were and then I'm going to jump into a",
    "start": "62320",
    "end": "68080"
  },
  {
    "text": "second part of the talk that goes into more details about the actual like architectural decisions how the",
    "start": "68080",
    "end": "74350"
  },
  {
    "text": "microarchitecture of the processor actually looks so I'm gonna split up into two of the two sections all right",
    "start": "74350",
    "end": "81070"
  },
  {
    "start": "80000",
    "end": "213000"
  },
  {
    "text": "so let's I'm I'm assuming most people here know what an FPGA is already but",
    "start": "81070",
    "end": "86409"
  },
  {
    "text": "just in case I'm going to give a very brief overview of the way ICD in a Fiji so when FPGA is a digital circuit like",
    "start": "86409",
    "end": "93939"
  },
  {
    "text": "all in the digital circuits it is basically a collection of logic gates coked-up with why the nice thing about",
    "start": "93939",
    "end": "101229"
  },
  {
    "text": "FPGA is is that they are field programmable which means you don't have to fabricate them in the factory the",
    "start": "101229",
    "end": "106960"
  },
  {
    "text": "circuit actually doesn't get written until powerup so how do they do that they basically prefabricate everything",
    "start": "106960",
    "end": "113560"
  },
  {
    "text": "you will ever need on the chip and then put in a bunch of switches and then you'd get to choose what to connect but",
    "start": "113560",
    "end": "120700"
  },
  {
    "text": "at the end of the day it is still it gates and wires you just choose whether to use a wire or not instead of choosing",
    "start": "120700",
    "end": "127119"
  },
  {
    "text": "whether to put the wire on the chip or not as you'd imagine prefabricating",
    "start": "127119",
    "end": "132700"
  },
  {
    "text": "everything has a pretty big cost so a PGA's for an equivalent circuit is somewhere around 20 times bigger and 20",
    "start": "132700",
    "end": "139030"
  },
  {
    "text": "times slower than a highly-tuned custom circuit built directly on silicon",
    "start": "139030",
    "end": "144450"
  },
  {
    "text": "another inch so if you look at the diagram you know the left I have you know what you wanted to build is it",
    "start": "144450",
    "end": "150310"
  },
  {
    "text": "logic gates and a few wires on an FPGA you prefabricate all the wires with whole bunch of switches and now you have to pack your circuit on to that FPGA",
    "start": "150310",
    "end": "158500"
  },
  {
    "text": "being constrained to whatever the resources the FPGA gives you so wires",
    "start": "158500",
    "end": "163959"
  },
  {
    "text": "are prefabricated there are switches the logic gates are somewhat more coarse-grained they use lookup tables",
    "start": "163959",
    "end": "170079"
  },
  {
    "text": "which is basically a truth table so now instead of having an Gates or gates you have this flexible logic gate that can",
    "start": "170079",
    "end": "176829"
  },
  {
    "text": "become any logic function of a certain number of inputs six inputs being very common so on modern FPGA is typically",
    "start": "176829",
    "end": "184120"
  },
  {
    "text": "it's six in so from the perspective of",
    "start": "184120",
    "end": "189129"
  },
  {
    "text": "how you design things for the FPGA one it's slower - you now have to be careful",
    "start": "189129",
    "end": "195459"
  },
  {
    "text": "about whether your circuit to the coarse grained look-up tables that they if they",
    "start": "195459",
    "end": "200920"
  },
  {
    "text": "don't your circuit will still work it's just less efficient so you don't have as quite as much flexibility as if you had",
    "start": "200920",
    "end": "207910"
  },
  {
    "text": "a broad piece of silicon okay so an FPGA",
    "start": "207910",
    "end": "214750"
  },
  {
    "start": "213000",
    "end": "361000"
  },
  {
    "text": "is a circuit it can build anything that includes processors and may not always be the most appropriate but it's able to",
    "start": "214750",
    "end": "222310"
  },
  {
    "text": "do it so what do people use FPGAs for usually they don't use it to build a processor and they usually have a big",
    "start": "222310",
    "end": "229299"
  },
  {
    "text": "digital system you know data paths other things but they often do still want a",
    "start": "229299",
    "end": "235299"
  },
  {
    "text": "processor to do control logic or something like that something that's flexible and not easily put into a block",
    "start": "235299",
    "end": "241419"
  },
  {
    "text": "of hardware so mainly for laziness so that means you might want a processor as",
    "start": "241419",
    "end": "248440"
  },
  {
    "text": "part of an FPGA as the entire FPGA and sometimes that would be a soft processor so if you need more performance on an",
    "start": "248440",
    "end": "258130"
  },
  {
    "text": "FPGA the classical way of doing things would be okay I'm going to build more custom hardware make my system go faster",
    "start": "258130",
    "end": "264310"
  },
  {
    "text": "um but if you really have to be lazy if we made the processor go faster you",
    "start": "264310",
    "end": "270010"
  },
  {
    "text": "could get an improvement in system performance without or with going through less effort",
    "start": "270010",
    "end": "275460"
  },
  {
    "text": "and designing custom logic you might be able to get away with less of this logic if your processor was magically faster",
    "start": "275460",
    "end": "282650"
  },
  {
    "text": "so that's the motivation for why we might want a faster soft processor",
    "start": "282650",
    "end": "288889"
  },
  {
    "text": "all right so a few GA vendors actually provides some fairly well optimized soft",
    "start": "288960",
    "end": "294630"
  },
  {
    "text": "processors but currently they tend to be small in order single-issue pipelines so you know they they are",
    "start": "294630",
    "end": "303060"
  },
  {
    "text": "small but they also tend to be very fairly well optimized so they actually run at fairly high clock rate for an",
    "start": "303060",
    "end": "309960"
  },
  {
    "text": "FPGA circuit so at the bottom I have some other examples of soft processors that weren't from the FPGA vendors and",
    "start": "309960",
    "end": "316860"
  },
  {
    "text": "the general trend you see is that those that weren't highly tuned tend to have a fairly low clock rate and you know",
    "start": "316860",
    "end": "325110"
  },
  {
    "text": "regardless of what microarchitecture you use if you're giving up 50% of your clock rate you're not really going to be",
    "start": "325110",
    "end": "330539"
  },
  {
    "text": "competitive so they do yes they",
    "start": "330539",
    "end": "342690"
  },
  {
    "text": "certainly do so that's a separate topic and it is a I would say it is a",
    "start": "342690",
    "end": "347699"
  },
  {
    "text": "competitor to soft processors so if you have a hard processor you may be less willing to use a soft processor",
    "start": "347699",
    "end": "357380"
  },
  {
    "start": "361000",
    "end": "558000"
  },
  {
    "text": "okay so um let's suppose you do want a faster softcore Scizor given that the",
    "start": "362540",
    "end": "369199"
  },
  {
    "text": "vendor provided processors are already very fast in clock speed the only way",
    "start": "369199",
    "end": "375000"
  },
  {
    "text": "you're going to get more performance out of it is to get parallelism you're not really going to be able to improve on the clock speed so there are many ways",
    "start": "375000",
    "end": "381780"
  },
  {
    "text": "of getting parallelism thread and data level parallelism have been tried in soft cursors before but I like",
    "start": "381780",
    "end": "389820"
  },
  {
    "text": "instruction level parallelism because the user doesn't have to do anything it just magically works but on the other",
    "start": "389820",
    "end": "395820"
  },
  {
    "text": "side the processor designer has to spend a lot more effort than on the other two styles of parallelism so I'm going to go",
    "start": "395820",
    "end": "402449"
  },
  {
    "text": "down the instruction level parallelism root so the challenge for me is can I",
    "start": "402449",
    "end": "408090"
  },
  {
    "text": "design a microarchitecture and the circuit the FPGA circuit to implement that microarchitecture so that I can get",
    "start": "408090",
    "end": "414570"
  },
  {
    "text": "a significantly higher number of instructions per cycle without it's",
    "start": "414570",
    "end": "419820"
  },
  {
    "text": "significant decrease in clock speed so that I get an overall in performance improvement at an affordable hardware",
    "start": "419820",
    "end": "427500"
  },
  {
    "text": "cost and without getting the user to rewrite their software so I believe the",
    "start": "427500",
    "end": "432840"
  },
  {
    "text": "answer is yes and if you look back in history the first out of order hard processors typically got somewhere",
    "start": "432840",
    "end": "438270"
  },
  {
    "text": "about 50 percent improvement in IPC with basically no change in frequency so this is the first out of order versus the",
    "start": "438270",
    "end": "444660"
  },
  {
    "text": "previous generation so you know I'm hoping I can get this on in FPGA as well",
    "start": "444660",
    "end": "451160"
  },
  {
    "text": "so now if we're going to build a processor well let's first decide on an instruction set so you already know the",
    "start": "451160",
    "end": "456690"
  },
  {
    "text": "answer I decided to do x86 but now why wouldn't you want to do an x86 the most",
    "start": "456690",
    "end": "461789"
  },
  {
    "text": "obvious reason is some of these x86 features are really hard to implement",
    "start": "461789",
    "end": "467900"
  },
  {
    "text": "variable length instructions need length decoding and x86 encoding is really hard",
    "start": "467900",
    "end": "473580"
  },
  {
    "text": "to find out the length of the instruction so you know it's doubly bad",
    "start": "473580",
    "end": "478699"
  },
  {
    "text": "self-modifying code is surprisingly hard to get correct there are a few",
    "start": "478699",
    "end": "483720"
  },
  {
    "text": "instructions that have to destination operands and just make things complicated but as it turns out when you're building a processor for",
    "start": "483720",
    "end": "489840"
  },
  {
    "text": "high-performance turns out most of the really hard features actually aren't x86 specific",
    "start": "489840",
    "end": "496139"
  },
  {
    "text": "so another problem with using an existing instruction set is that if you happened to come across a feature you",
    "start": "496139",
    "end": "502559"
  },
  {
    "text": "don't like you don't have the option of saying will change software to work around it so one example that I suffered through",
    "start": "502559",
    "end": "510599"
  },
  {
    "text": "was the floating-point unit I didn't want to build a floating-point unit but I also couldn't change the existing",
    "start": "510599",
    "end": "516000"
  },
  {
    "text": "operating systems to get them to emulate the floating-point so that means I have to design in a emulation system that was",
    "start": "516000",
    "end": "523018"
  },
  {
    "text": "completely transparent from the operating system that was very painful so this isn't quite x86 it's when you",
    "start": "523019",
    "end": "529379"
  },
  {
    "text": "can't change the instruction set there's some pain you're going to have to go through of course a lot of people not",
    "start": "529379",
    "end": "536579"
  },
  {
    "text": "too far from here are going to be asking why not just five it didn't exist when I started this project that's my excuse",
    "start": "536579",
    "end": "542759"
  },
  {
    "text": "but I also question whether risk is even the right design even if you had to",
    "start": "542759",
    "end": "549420"
  },
  {
    "text": "start over I'm not really going to talk about at this point in this presentation",
    "start": "549420",
    "end": "555149"
  },
  {
    "text": "but you know I have some thoughts on it okay so why would you want to implement",
    "start": "555149",
    "end": "561000"
  },
  {
    "start": "558000",
    "end": "634000"
  },
  {
    "text": "x86 my answer is it's very easy to implement not the hardware but compared",
    "start": "561000",
    "end": "566790"
  },
  {
    "text": "to implementing all of the software that goes along with it so I found a quote",
    "start": "566790",
    "end": "572459"
  },
  {
    "text": "from when the risk five people is saying that they were suffering through a lot of pain trying to get benchmarks and I",
    "start": "572459",
    "end": "578430"
  },
  {
    "text": "was like I will just use the rebuild by anyways because it works so you know",
    "start": "578430",
    "end": "584180"
  },
  {
    "text": "there's a lot of legacy software out there benchmarks operating systems you",
    "start": "584180",
    "end": "589410"
  },
  {
    "text": "know web browsers are really complex pieces of software then our instructions",
    "start": "589410",
    "end": "594750"
  },
  {
    "text": "that's specific because of the JavaScript chid so these are really really hard to port to a different",
    "start": "594750",
    "end": "601519"
  },
  {
    "text": "instruction set there's even software and some really unexpected places like your VGA card",
    "start": "601519",
    "end": "607019"
  },
  {
    "text": "BIOS the alpha systems actually has to do x86 emulation just to be able to use",
    "start": "607019",
    "end": "612029"
  },
  {
    "text": "commodity graphics cards because there's a little bit of x86 software in the firmware so it's really the software",
    "start": "612029",
    "end": "619889"
  },
  {
    "text": "legacy that motivates x86 and you know even after going through all of this you",
    "start": "619889",
    "end": "625290"
  },
  {
    "text": "know I still can't do any of this large software thing I can implement x86 which is easier than implementing any other",
    "start": "625290",
    "end": "631300"
  },
  {
    "text": "software my opinion okay so if we're",
    "start": "631300",
    "end": "636730"
  },
  {
    "start": "634000",
    "end": "706000"
  },
  {
    "text": "gonna build stuff versus here so we've decided we're going to build ass off for us to say this is the goals that I set",
    "start": "636730",
    "end": "643270"
  },
  {
    "text": "out to achieve I wanted to build a to issue out of order processor just so I",
    "start": "643270",
    "end": "649300"
  },
  {
    "text": "could call that superscalar I wanted good improvement in IPC so and when did",
    "start": "649300",
    "end": "655720"
  },
  {
    "text": "that say let's aim for 2x what Altera's single-issue in order software so I",
    "start": "655720",
    "end": "662170"
  },
  {
    "text": "could do let's try and improve a little bit on the frequency but I didn't",
    "start": "662170",
    "end": "669910"
  },
  {
    "text": "actually managed to achieve that so that's a goal that was not achieved I also I chose the x86 instruction set and",
    "start": "669910",
    "end": "677920"
  },
  {
    "text": "made sure that I didn't have to rewrite any of the software so it should be binary compatible with all the existing",
    "start": "677920",
    "end": "683320"
  },
  {
    "text": "operating systems and programs and so on including system mode so I ended up actually testing with 16 different",
    "start": "683320",
    "end": "689410"
  },
  {
    "text": "operating systems and a whole bunch of user level of benchmarks right so I was",
    "start": "689410",
    "end": "699820"
  },
  {
    "text": "targeting the p6 instruction set Pentium Pro 64-bit is another huge block of the",
    "start": "699820",
    "end": "708790"
  },
  {
    "start": "706000",
    "end": "991000"
  },
  {
    "text": "instruction set because it requires all the vector extensions and so on 32-bit",
    "start": "708790",
    "end": "715839"
  },
  {
    "text": "for now okay so um all right so let's design the processor so the first thing",
    "start": "715839",
    "end": "722529"
  },
  {
    "text": "you want to do is I'm building a processor for an FPGA there is a whole",
    "start": "722529",
    "end": "727779"
  },
  {
    "text": "bunch of literature on how you're supposed to build processors how is an FPGA different from what everyone else",
    "start": "727779",
    "end": "733120"
  },
  {
    "text": "is doing you know if the FPGA looks exactly the same as regular silicon well we'll just build the same processor and",
    "start": "733120",
    "end": "738970"
  },
  {
    "text": "call it a day so let's start with looking at how FPGAs are actually different from custom logic on silicon",
    "start": "738970",
    "end": "748020"
  },
  {
    "text": "so this is a study where I compared basically it's basically literature",
    "start": "748020",
    "end": "753579"
  },
  {
    "text": "literature search on published papers and custom silicon versus what I can build on that VGA and I compared the",
    "start": "753579",
    "end": "758980"
  },
  {
    "text": "area and delay clock speed of various circuit parts and also of some open-source",
    "start": "758980",
    "end": "764860"
  },
  {
    "text": "processors that have commercial implementations so if you compared whole",
    "start": "764860",
    "end": "771370"
  },
  {
    "text": "processors I think I compared the k√∂ppen SPARC there was a Pentium that was also",
    "start": "771370",
    "end": "776710"
  },
  {
    "text": "synthesized and in the PGA so on average all processors are about 22 times bigger",
    "start": "776710",
    "end": "783880"
  },
  {
    "text": "and 22 times slower when synthesized for an FPGA than their original custom",
    "start": "783880",
    "end": "790360"
  },
  {
    "text": "commercial implementation so if it's just bigger and slower that doesn't tell",
    "start": "790360",
    "end": "795610"
  },
  {
    "text": "you how you might need to adapt your design to fit the FPGA so I broke that down into let's take some common circuit",
    "start": "795610",
    "end": "802029"
  },
  {
    "text": "styles and see which ones are particularly bad and which ones are particularly good and that might",
    "start": "802029",
    "end": "807339"
  },
  {
    "text": "influence what I might want to design so it turns out that for the various",
    "start": "807339",
    "end": "814240"
  },
  {
    "text": "circuit types the delay didn't really vary that much FPGAs were slower but you",
    "start": "814240",
    "end": "819700"
  },
  {
    "text": "know more or less uniformly slower except for SRAM des armes were particularly a little bit faster but the",
    "start": "819700",
    "end": "824890"
  },
  {
    "text": "big difference was in area so things like random logic multiplexers were",
    "start": "824890",
    "end": "830380"
  },
  {
    "text": "particularly inefficient multi ported memories were inefficient cams but",
    "start": "830380",
    "end": "837430"
  },
  {
    "text": "circuits that have hard block support on FPGA so FPGAs have hard RAM blocks they",
    "start": "837430",
    "end": "844839"
  },
  {
    "text": "have hard adder carry chains the circuits that use these blocks tend to",
    "start": "844839",
    "end": "851170"
  },
  {
    "text": "be particularly area efficient so my",
    "start": "851170",
    "end": "856720"
  },
  {
    "text": "conclusion just from looking at this is at a high level because the delay",
    "start": "856720",
    "end": "862209"
  },
  {
    "text": "variation wasn't all that big my my conclusion was you can probably get away with a fairly conventional process or",
    "start": "862209",
    "end": "868630"
  },
  {
    "text": "microarchitecture you just have to be a little bit careful to avoid or reduce the size of the expensive components and",
    "start": "868630",
    "end": "875459"
  },
  {
    "text": "use a little bit more of the cheaper components so that made a few influenced",
    "start": "875459",
    "end": "882730"
  },
  {
    "text": "a few micro architectural decisions for example it was decided to use a physical register file instead of a reorder",
    "start": "882730",
    "end": "889630"
  },
  {
    "text": "buffer that stored data with reservation stations oh sorry are you talking about area",
    "start": "889630",
    "end": "910580"
  },
  {
    "text": "until they are we talking about the area today no no these three are high but",
    "start": "910580",
    "end": "921350"
  },
  {
    "text": "these three are low so multiplexer is",
    "start": "921350",
    "end": "928640"
  },
  {
    "text": "multi ported Rams and cams are very high in area the red buys this this is 2.2 22",
    "start": "928640",
    "end": "937130"
  },
  {
    "text": "in the middle yes oh yeah it's a log type factors of 10 22 in the middle okay",
    "start": "937130",
    "end": "947450"
  },
  {
    "text": "so it was decided to use this physical intro file instead of storing the data in the in the reservation stations",
    "start": "947450",
    "end": "954170"
  },
  {
    "text": "because that keeps the data in grams rather than in a cam so that's more efficient it also makes more sense to",
    "start": "954170",
    "end": "961220"
  },
  {
    "text": "have low associative low associativity caches because that requires rams rather than a big cam so you know the cost of",
    "start": "961220",
    "end": "969860"
  },
  {
    "text": "cams influences some of the mic architectural decisions both like all of these choices have been used",
    "start": "969860",
    "end": "975890"
  },
  {
    "text": "successfully in commercial processors but I think on an FPGA certain choices",
    "start": "975890",
    "end": "981470"
  },
  {
    "text": "are more preferred so these aren't particularly strange decisions they're",
    "start": "981470",
    "end": "988640"
  },
  {
    "text": "also used in commercial processors okay so now that we know how the fpd is",
    "start": "988640",
    "end": "996980"
  },
  {
    "start": "991000",
    "end": "1100000"
  },
  {
    "text": "different let's start designing the processor so this is the methodology I followed when I just designed the processor so I started off with a",
    "start": "996980",
    "end": "1004650"
  },
  {
    "text": "functional simulator box are all of you familiar with box roughly it's an open",
    "start": "1004650",
    "end": "1011980"
  },
  {
    "text": "source x86 functional simulator so again",
    "start": "1011980",
    "end": "1017290"
  },
  {
    "text": "because it's x86 I can use this as a golden reference model and I didn't have to read it myself",
    "start": "1017290",
    "end": "1022770"
  },
  {
    "text": "so I so I started off with a functional",
    "start": "1022770",
    "end": "1028089"
  },
  {
    "text": "simulator I then went and replaced the CPUs model inside the simulator with a",
    "start": "1028089",
    "end": "1035339"
  },
  {
    "text": "detailed timing model and functional so replace the entire CPU and now it has",
    "start": "1035339",
    "end": "1041319"
  },
  {
    "text": "timing models so I know how fast it goes but it continues to use the simulation",
    "start": "1041319",
    "end": "1046600"
  },
  {
    "text": "of display disks everything else around the system so I was focusing just on the",
    "start": "1046600",
    "end": "1052000"
  },
  {
    "text": "processor and the detailed CPU model was informed by the FPGA architecture that I",
    "start": "1052000",
    "end": "1058299"
  },
  {
    "text": "just talked about and then I took another copy of box rendered in parallel",
    "start": "1058299",
    "end": "1065379"
  },
  {
    "text": "and now use this as verification as the golden reference model so now my functional model functional and timing",
    "start": "1065379",
    "end": "1071590"
  },
  {
    "text": "model needs to retire the same instructions with the same results as the functional reference model so I run",
    "start": "1071590",
    "end": "1078909"
  },
  {
    "text": "a whole bunch of workloads boot a whole bunch of OSS in parallel and I compare the results and I make sure my",
    "start": "1078909",
    "end": "1085049"
  },
  {
    "text": "microarchitecture actually produces the correct results and when I'm satisfied with that I will then take the detailed",
    "start": "1085049",
    "end": "1094210"
  },
  {
    "text": "model and start building circuits based on the microarchitecture that I came up with so final answer the microprocessor",
    "start": "1094210",
    "end": "1104620"
  },
  {
    "start": "1100000",
    "end": "1249000"
  },
  {
    "text": "that I ended up with is a fairly typical x86 pipeline so you know it starts with",
    "start": "1104620",
    "end": "1111970"
  },
  {
    "text": "instruction fetch it fetches eight instruction bytes per cycle it doesn't know what the instructions are just fetches eight bytes then it goes through",
    "start": "1111970",
    "end": "1118870"
  },
  {
    "text": "a whole bunch of lengths decode stages that tries to figure out where the instructions start and split them up into the instructions in this case there",
    "start": "1118870",
    "end": "1125080"
  },
  {
    "text": "are three instructions in this eight byte block it then sends chops up the",
    "start": "1125080",
    "end": "1130149"
  },
  {
    "text": "bytes and sends them to decoders each decoder handles each instruction and now you can do them in parallel and the",
    "start": "1130149",
    "end": "1137440"
  },
  {
    "text": "decoder decodes the instructions until my crops the micro ops are then go",
    "start": "1137440",
    "end": "1143740"
  },
  {
    "text": "through two fairly typical register rename or it just replaces all of the logical register numbers with physical",
    "start": "1143740",
    "end": "1149049"
  },
  {
    "text": "register numbers and now it goes through a scheduler which schedules instructions",
    "start": "1149049",
    "end": "1155740"
  },
  {
    "text": "based on whether the operands are available and then after they execute the",
    "start": "1155740",
    "end": "1162220"
  },
  {
    "text": "instructions are committed in program order so it's you know very very classical x86 pipeline yes so you you",
    "start": "1162220",
    "end": "1175150"
  },
  {
    "text": "can't avoid it but there are things like I will try and reduce the size I will not put the data in the cam they are",
    "start": "1175150",
    "end": "1183520"
  },
  {
    "text": "there I I have seen some papers where you avoid it but you pay an IPC and it's also really hard to design and you know",
    "start": "1183520",
    "end": "1191159"
  },
  {
    "text": "not quite worth the effort okay so you know the summary of all is going through",
    "start": "1192600",
    "end": "1198850"
  },
  {
    "text": "all of this is that the main challenge of every single stage was you know let's trade the circuit complexity and delay",
    "start": "1198850",
    "end": "1204280"
  },
  {
    "text": "in size with various other things and in the front end it's mainly I need to",
    "start": "1204280",
    "end": "1209740"
  },
  {
    "text": "support the common case fast without spending too much hardware to support all the corner cases the scheduler its",
    "start": "1209740",
    "end": "1217570"
  },
  {
    "text": "trading off circuit complexity with capacity execution units is trading it",
    "start": "1217570",
    "end": "1223419"
  },
  {
    "text": "off with latency so it all boils down to you know how fast can you make your circuits go you can come up with an",
    "start": "1223419",
    "end": "1230530"
  },
  {
    "text": "architecture but you have to spend a lot of effort making these circuits fast so later on in you'll see a lot of effort",
    "start": "1230530",
    "end": "1238750"
  },
  {
    "text": "on the circuit design then the second half of the talk",
    "start": "1238750",
    "end": "1243390"
  },
  {
    "start": "1249000",
    "end": "1508000"
  },
  {
    "text": "I didn't try too hard to reduce the area but the end result is it's you know like",
    "start": "1251900",
    "end": "1257500"
  },
  {
    "text": "7% of a 40 nanometer FPGA it's like 1% of 1 now it's tiny so yeah so so I just",
    "start": "1257500",
    "end": "1267800"
  },
  {
    "text": "got to the result slide where I will be talking about this so here is the final result so I didn't quite get the",
    "start": "1267800",
    "end": "1275360"
  },
  {
    "text": "processor to finished so you know it's it's a collection of parts and some projections on what I think the final",
    "start": "1275360",
    "end": "1280580"
  },
  {
    "text": "processor would probably take up so this is a caveat these numbers are not take",
    "start": "1280580",
    "end": "1287660"
  },
  {
    "text": "these with a grain of salt so at the end the all this area adds up to something",
    "start": "1287660",
    "end": "1294200"
  },
  {
    "text": "like twenty twenty-nine thousand LMS which is Altera's logic unit if you",
    "start": "1294200",
    "end": "1299510"
  },
  {
    "text": "compare it to Altera's processor configured with you know fairly large caches and so on you know typical what",
    "start": "1299510",
    "end": "1305150"
  },
  {
    "text": "you might want from a higher end version of the Altera just to make my number not",
    "start": "1305150",
    "end": "1310220"
  },
  {
    "text": "look so bad it's just like six or seven times bigger an area and about 20",
    "start": "1310220",
    "end": "1316940"
  },
  {
    "text": "percent slower in clock speed but because the existing software sisters are so tiny it is really only you know",
    "start": "1316940",
    "end": "1324410"
  },
  {
    "text": "seven percent of a statics for which is I think three generations back at this",
    "start": "1324410",
    "end": "1330320"
  },
  {
    "text": "point where we're at statics 10 right now and I think it's about one and a half percent of a strat extend 64 bits",
    "start": "1330320",
    "end": "1345860"
  },
  {
    "text": "or 64 bits x86 I I expected as much much",
    "start": "1345860",
    "end": "1353690"
  },
  {
    "text": "bigger next it's not the 64 bit that's big 64 bit would double your data path",
    "start": "1353690",
    "end": "1360410"
  },
  {
    "text": "and so on but 64 bit also requires 128 bit vector operation yes and a whole",
    "start": "1360410",
    "end": "1365870"
  },
  {
    "text": "bunch of floating-point stuff so I expected much bigger",
    "start": "1365870",
    "end": "1372100"
  },
  {
    "text": "I would say somewhere about you know five to ten times there's there's also a bunch of like architecture decisions",
    "start": "1373820",
    "end": "1380600"
  },
  {
    "text": "that won't work in x86 in 64-bit for example I tuned my front-end to decode",
    "start": "1380600",
    "end": "1386019"
  },
  {
    "text": "say up to one prefix byte and assumed you know most instructions were about three or four bytes long and eight bytes",
    "start": "1386019",
    "end": "1393019"
  },
  {
    "text": "and longer were very rare but 64-bit adds more prefix bytes to the beginning",
    "start": "1393019",
    "end": "1398059"
  },
  {
    "text": "so I would have to redesign the decoder to handle you know one prefect to prefix bytes is now a common case instead of a",
    "start": "1398059",
    "end": "1404029"
  },
  {
    "text": "rare case so there's a whole bunch of other things that you would have to change yes I think it would very easily",
    "start": "1404029",
    "end": "1417259"
  },
  {
    "text": "fit but I think my main concern is how much clock speed are you giving up",
    "start": "1417259",
    "end": "1424539"
  },
  {
    "text": "because I when I was designing this I was actually focusing much more on clock speed than area because I think clock",
    "start": "1424539",
    "end": "1431359"
  },
  {
    "text": "speed is much harder to get and we have a lot of area so if the area is not the constrained resource here so I don't",
    "start": "1431359",
    "end": "1440509"
  },
  {
    "text": "have a good estimate of how fast you can clock a 64-bit version of this or what",
    "start": "1440509",
    "end": "1445700"
  },
  {
    "text": "kind of changes you might need to various places to make it work alright",
    "start": "1445700",
    "end": "1452419"
  },
  {
    "text": "so area is seven times bigger but still small frequency it is currently limited",
    "start": "1452419",
    "end": "1460879"
  },
  {
    "text": "by the memory system memory system was the most painful thing to design in this processor but it is currently the F max",
    "start": "1460879",
    "end": "1470720"
  },
  {
    "text": "limit but I think it should be fairly straightforward to repipe line this to get to a trade more clock speed for an",
    "start": "1470720",
    "end": "1478279"
  },
  {
    "text": "extra cycle of l1 hit latency so it is possible to get more frequency here also",
    "start": "1478279",
    "end": "1486320"
  },
  {
    "text": "interesting is that the stuff you would normally associate with out of order they register rename or in the scheduler",
    "start": "1486320",
    "end": "1492109"
  },
  {
    "text": "those are actually the fastest units that I had so if you're thinking of",
    "start": "1492109",
    "end": "1497659"
  },
  {
    "text": "building a out of order an on x86 processor this kind of suggests to you that maybe it's not such a bad idea so",
    "start": "1497659",
    "end": "1505220"
  },
  {
    "text": "we're losing an area we're losing on see I'm hoping to gain on IPC so here is",
    "start": "1505220",
    "end": "1512330"
  },
  {
    "start": "1508000",
    "end": "1751000"
  },
  {
    "text": "a plot of specint mm only those components that don't use much",
    "start": "1512330",
    "end": "1518720"
  },
  {
    "text": "floating-point because I didn't have a floating-point unit so this is just the integer portion of the spec int I so in",
    "start": "1518720",
    "end": "1527420"
  },
  {
    "text": "yellow is the IPC or the per clock",
    "start": "1527420",
    "end": "1532850"
  },
  {
    "text": "performance I had to normalize have to per clock performance because there's me off and there's arm here so IPC doesn't",
    "start": "1532850",
    "end": "1538550"
  },
  {
    "text": "work all right there are three different instruction sets in here so in yellow is",
    "start": "1538550",
    "end": "1543590"
  },
  {
    "text": "I'm making everything relative to my processor and well first thing is the",
    "start": "1543590",
    "end": "1550070"
  },
  {
    "text": "reason I have so many processors to compare to here is because all of them are x86 and I could just copy the binaries and run them it took very",
    "start": "1550070",
    "end": "1555590"
  },
  {
    "text": "little effort if these are all so so the nias data point and the arm data point",
    "start": "1555590",
    "end": "1561170"
  },
  {
    "text": "took much more effort to get because I had to port the benchmarks over so this is another advantage of using a popular",
    "start": "1561170",
    "end": "1568280"
  },
  {
    "text": "and existing instruction set there was a",
    "start": "1568280",
    "end": "1579530"
  },
  {
    "text": "paper on synthesizing the atom but that was after the fact so it wasn't prototype to is they built",
    "start": "1579530",
    "end": "1585650"
  },
  {
    "text": "the atom they've released it and then okay we'll take the RTL and we'll try and fit it on our FPGA",
    "start": "1585650",
    "end": "1592510"
  },
  {
    "text": "not that part I didn't know it",
    "start": "1601960",
    "end": "1606070"
  },
  {
    "text": "so I'm only aware of the published paper on a demand that was an after-the-fact",
    "start": "1613130",
    "end": "1619299"
  },
  {
    "text": "okay so in this chart I also listed the clock speed of the processors because this is per clock performance I only",
    "start": "1623900",
    "end": "1632600"
  },
  {
    "text": "list that the clock speed so to give you an idea of what the expected memory latency would be so for example a",
    "start": "1632600",
    "end": "1638809"
  },
  {
    "text": "processor with the native clock speed of 100 megahertz sees a very different memory latency than a processor at 3",
    "start": "1638809",
    "end": "1644870"
  },
  {
    "text": "gigahertz so given all these processors",
    "start": "1644870",
    "end": "1653120"
  },
  {
    "text": "I chose 3 interesting comparison points the first comparison point is with nias that's our you know that's our stated",
    "start": "1653120",
    "end": "1659300"
  },
  {
    "text": "competitor here let's compare to the existing soft processor we're getting fairly good improvement in per clock",
    "start": "1659300",
    "end": "1667370"
  },
  {
    "text": "performance about 2.7 X and if you multiply that with the loss in frequency",
    "start": "1667370",
    "end": "1672679"
  },
  {
    "text": "we're still more than 2 times faster than in the US another interesting",
    "start": "1672679",
    "end": "1681170"
  },
  {
    "text": "comparison point is the Pentium Pro because it turns out at the high level of Pentium Pro actually looks a lot like",
    "start": "1681170",
    "end": "1686300"
  },
  {
    "text": "the processor I'm designing it's also Pentium Pro is three wide mine is too wide it has basically the same cache",
    "start": "1686300",
    "end": "1693140"
  },
  {
    "text": "size is 8 K 256 K I chose the same cache sizes as well and the IPC is actually",
    "start": "1693140",
    "end": "1699980"
  },
  {
    "text": "not too far not not too different so and then another interesting design point is",
    "start": "1699980",
    "end": "1706970"
  },
  {
    "text": "the more recent atom out-of-order silvermont I think it's the first out of",
    "start": "1706970",
    "end": "1712100"
  },
  {
    "text": "order atom and I get basically the same IPC but i think the atom is actually a",
    "start": "1712100",
    "end": "1717770"
  },
  {
    "text": "better microarchitecture than mine because it is seeing a much higher memory latency so it has much bigger",
    "start": "1717770",
    "end": "1723890"
  },
  {
    "text": "caches and it has to deal with hundreds of clocks of memory latency instead of 20 or 30 but the end result is the IPC",
    "start": "1723890",
    "end": "1730940"
  },
  {
    "text": "looks pretty much the same so you know I think I can conclude that you know by",
    "start": "1730940",
    "end": "1736600"
  },
  {
    "text": "microarchitecture my microarchitecture design wasn't all too bad it's reasonable compared to the Intel mic",
    "start": "1736600",
    "end": "1743090"
  },
  {
    "text": "architecture and it's a fairly big gain of over neo so I think I will declare",
    "start": "1743090",
    "end": "1748670"
  },
  {
    "text": "success here all right so here's the summary of the",
    "start": "1748670",
    "end": "1755369"
  },
  {
    "start": "1751000",
    "end": "1800000"
  },
  {
    "text": "first part of the tuck so I designed a micro architecture and a bunch of circuits for another water processor it",
    "start": "1755369",
    "end": "1761610"
  },
  {
    "text": "supports both system and user modes it's much bigger than an EOS but it's also actually pretty small relative to an",
    "start": "1761610",
    "end": "1768330"
  },
  {
    "text": "FPGA because FPGA is keep growing exponentially and the us really hasn't changed in 20 years and it does get a",
    "start": "1768330",
    "end": "1779820"
  },
  {
    "text": "significant performance boost so I think I'm demonstrating that out-of-order can",
    "start": "1779820",
    "end": "1785669"
  },
  {
    "text": "work on FPGA and even x86 is feasible I",
    "start": "1785669",
    "end": "1791570"
  },
  {
    "text": "did not look at power consumption at all",
    "start": "1793279",
    "end": "1797389"
  },
  {
    "text": "so FF max is my primary design Google and I just observed area alright so in",
    "start": "1799070",
    "end": "1808139"
  },
  {
    "start": "1800000",
    "end": "1856000"
  },
  {
    "text": "the second part of the talk I'm basically going to go through the processor pipeline from fetch down to",
    "start": "1808139",
    "end": "1813929"
  },
  {
    "text": "commit and talk about the what I think are the interesting designs at each",
    "start": "1813929",
    "end": "1820590"
  },
  {
    "text": "stage something to keep in mind is that my timing budget is basically five logic",
    "start": "1820590",
    "end": "1826169"
  },
  {
    "text": "levels which is about 3 and 1/2 milliseconds so so you'll see that a lot",
    "start": "1826169",
    "end": "1831389"
  },
  {
    "text": "of the circuit designs were very carefully designed to try not to exceed 4 or 5 logic levels just to hit my",
    "start": "1831389",
    "end": "1838889"
  },
  {
    "text": "frequency target and a lot of the circuits were designed bottom up instead",
    "start": "1838889",
    "end": "1845009"
  },
  {
    "text": "of top down so I started with little building blocks and tried to make them bigger instead of let's use this giant",
    "start": "1845009",
    "end": "1850860"
  },
  {
    "text": "piece of RTL let's synthesized it - ok",
    "start": "1850860",
    "end": "1857330"
  },
  {
    "start": "1856000",
    "end": "2066000"
  },
  {
    "text": "so let's start with it at the beginning so the front end of the processor use",
    "start": "1857330",
    "end": "1863429"
  },
  {
    "text": "instruction fetch and decode in 32-bit x86 code on the benchmarks I ran on it",
    "start": "1863429",
    "end": "1872279"
  },
  {
    "text": "the average instruction links is about 3.4 bytes so if I wanted to sustain 2",
    "start": "1872279",
    "end": "1878369"
  },
  {
    "text": "instructions per cycle I think fetching 8 per cycle is probably good enough so I decided on fetching",
    "start": "1878369",
    "end": "1883859"
  },
  {
    "text": "eight bytes per cycle",
    "start": "1883859",
    "end": "1886730"
  },
  {
    "text": "x86 is really annoying in that you don't really know the instruction link until you've read the instruction and x86 has",
    "start": "1889090",
    "end": "1896860"
  },
  {
    "text": "these things called prefix bytes where you have an instruction but you can add bytes before the instruction to change",
    "start": "1896860",
    "end": "1901990"
  },
  {
    "text": "the meaning of the instruction so there is if you just follow this rule there is actually no limit to the length of an",
    "start": "1901990",
    "end": "1908140"
  },
  {
    "text": "x86 instruction because you're allowed to have repeated prefixes there is a rule that says if you exceed 15 15 bytes",
    "start": "1908140",
    "end": "1915760"
  },
  {
    "text": "it's just considered wrong but other than that there is no length limit so you you have to conceptually you have to",
    "start": "1915760",
    "end": "1923380"
  },
  {
    "text": "sequentially scan through every byte of the instruction to find out all the prefixes before you figure out the length of the instruction and width and",
    "start": "1923380",
    "end": "1929410"
  },
  {
    "text": "then you can start reading the next instruction so it's really hard to parallel eyes instruction decode if you",
    "start": "1929410",
    "end": "1934780"
  },
  {
    "text": "don't know the instruction length so the observation here is that on 32-bit x86",
    "start": "1934780",
    "end": "1940210"
  },
  {
    "text": "code eighty-six percent of instructions have no prefix bytes and fourteen",
    "start": "1940210",
    "end": "1945220"
  },
  {
    "text": "percent have one prefix bytes and almost no instructions have more prefix place",
    "start": "1945220",
    "end": "1951810"
  },
  {
    "text": "SS I've seen seven prefix bytes but it is extremely rare so that means that I",
    "start": "1951810",
    "end": "1959530"
  },
  {
    "text": "chose to design the decoder so that it would be able to handle up to one prefix byte with no penalty so that means it's",
    "start": "1959530",
    "end": "1966400"
  },
  {
    "text": "really looking at two cases there is either no prefix byte or one prefix play will handle both cases in parallel if it",
    "start": "1966400",
    "end": "1971650"
  },
  {
    "text": "satisfies this it can decode two instructions per cycle there's a penalty",
    "start": "1971650",
    "end": "1977130"
  },
  {
    "text": "if you exceed the number of free fixed bytes but it still must handle this correctly so it sequentially scans",
    "start": "1977130",
    "end": "1983110"
  },
  {
    "text": "through the prefix bytes if you exceed one prefix but if you won't go 64 bits",
    "start": "1983110",
    "end": "1988810"
  },
  {
    "text": "this will have to change because the number of prefix bytes actually goes up a lot so three becomes fairly common",
    "start": "1988810",
    "end": "1994510"
  },
  {
    "text": "either or to prefix points becomes fairly common",
    "start": "1994510",
    "end": "1998580"
  },
  {
    "text": "next stage once you decode the instructions you have to decode them into microwaves in my particular design",
    "start": "2000330",
    "end": "2006899"
  },
  {
    "text": "my my crafts were actually fairly powerful in that they both contained a operation arithmetic operation and a",
    "start": "2006899",
    "end": "2013860"
  },
  {
    "text": "memory operation so they looked a lot like regular eyes x86 instructions they don't look like risk instructions so as",
    "start": "2013860",
    "end": "2020610"
  },
  {
    "text": "a result the number of micro ops is actually very small near ninety four percent of the time one instruction maps",
    "start": "2020610",
    "end": "2027360"
  },
  {
    "text": "to one microwave so this handles all of the register memory addressing modes in",
    "start": "2027360",
    "end": "2033480"
  },
  {
    "text": "a single microbe they are scheduled and executed separately but they are treated as one microbe in the front end and more",
    "start": "2033480",
    "end": "2041429"
  },
  {
    "text": "than one my carp is quite rare so you know we'll put a cap of your will this",
    "start": "2041429",
    "end": "2046440"
  },
  {
    "text": "will be able to sustain the full decode throughput if your instruction decode into two or fewer microbes there's a",
    "start": "2046440",
    "end": "2054060"
  },
  {
    "text": "penalty if you exceed that so next 86 the worst case is pretty difficult to deal with but the common",
    "start": "2054060",
    "end": "2060480"
  },
  {
    "text": "case is actually quite straightforward okay so now that we have micro ops the",
    "start": "2060480",
    "end": "2068580"
  },
  {
    "start": "2066000",
    "end": "2216000"
  },
  {
    "text": "next stage is register renaming so register renaming takes all of the logical register numbers so in x86",
    "start": "2068580",
    "end": "2075810"
  },
  {
    "text": "there's things like EAX EBX ECX and maps them to the physical register number",
    "start": "2075810",
    "end": "2082368"
  },
  {
    "text": "that's actually on the in the microarchitecture so it turns out we",
    "start": "2082369",
    "end": "2087658"
  },
  {
    "text": "have to map a lot of registers per clock in the worst case a instruction can have",
    "start": "2087659",
    "end": "2095250"
  },
  {
    "text": "seven registers referenced so that means",
    "start": "2095250",
    "end": "2100349"
  },
  {
    "text": "I have to rename 14 source operands per clock so that's not just general purpose",
    "start": "2100349",
    "end": "2105480"
  },
  {
    "text": "registers so because there's a memory operation there are there's arithmetic which takes some sources the address can",
    "start": "2105480",
    "end": "2112920"
  },
  {
    "text": "take some sources there's also segmentation in x86 so you have to rename that as well there's condition",
    "start": "2112920",
    "end": "2119160"
  },
  {
    "text": "codes in x86 so that's yet another news source so it comes up to a lot of",
    "start": "2119160",
    "end": "2124790"
  },
  {
    "text": "sources but you can pretty much do them all in parallel",
    "start": "2124790",
    "end": "2130960"
  },
  {
    "text": "so another interesting design here is that I decided to have to give each",
    "start": "2130960",
    "end": "2136930"
  },
  {
    "text": "execution unit its own physical register file so this is not a centralized register file the reason is if you",
    "start": "2136930",
    "end": "2144590"
  },
  {
    "text": "remember way back earlier multi ported Rams are very expensive its multi ported",
    "start": "2144590",
    "end": "2149900"
  },
  {
    "text": "write ports that were very expensive so in this design if each arithmetic unit has its own register file each",
    "start": "2149900",
    "end": "2156620"
  },
  {
    "text": "register file only needs one write port because it can only be written by that execution unit but now the trade off is",
    "start": "2156620",
    "end": "2163490"
  },
  {
    "text": "you your registry name room now has to track which register file is my operand",
    "start": "2163490",
    "end": "2169970"
  },
  {
    "text": "in and it also makes it's also somewhat unbalanced in that if you execute a lot",
    "start": "2169970",
    "end": "2175910"
  },
  {
    "text": "of operations on one execution unit then all the operands end up being in that",
    "start": "2175910",
    "end": "2181340"
  },
  {
    "text": "register file leaving the other register files underutilized so the trade-off here is you save multi ported Rams in",
    "start": "2181340",
    "end": "2189620"
  },
  {
    "text": "exchange for wasting register file capacity but cam's multi ported Rams are",
    "start": "2189620",
    "end": "2199550"
  },
  {
    "text": "expensive but single photographs are cheap on an FPGA so this is a good trade-off here and the way we do this is",
    "start": "2199550",
    "end": "2206090"
  },
  {
    "text": "by hacking the register rename where to track where the operands are",
    "start": "2206090",
    "end": "2211300"
  },
  {
    "start": "2216000",
    "end": "2280000"
  },
  {
    "text": "so this is the renamer circuit I ended up with its pipelined over two stages",
    "start": "2216570",
    "end": "2222790"
  },
  {
    "text": "the first stage basically checks all the dependencies between the two yeah my",
    "start": "2222790",
    "end": "2229390"
  },
  {
    "text": "crops being renamed in that clock cycle and that decides all of the MUX select signals and in the second stage is just",
    "start": "2229390",
    "end": "2235900"
  },
  {
    "text": "a whole pile of muxes so what else do I",
    "start": "2235900",
    "end": "2242080"
  },
  {
    "text": "have to say here it's fairly fast it's not all that big x86 actually makes the",
    "start": "2242080",
    "end": "2247420"
  },
  {
    "text": "register rename are easier to design because it has so few registers so",
    "start": "2247420",
    "end": "2253090"
  },
  {
    "text": "there's only 8 general-purpose registers I think it expanded it to 11 including temporaries so it was cheap enough that",
    "start": "2253090",
    "end": "2259570"
  },
  {
    "text": "I could make the entire register rename her out of lookup tables I didn't have to go through make a SRAM block to store",
    "start": "2259570",
    "end": "2268090"
  },
  {
    "text": "the renaming table so if I had to do this on a RISC like architecture with 32",
    "start": "2268090",
    "end": "2274150"
  },
  {
    "text": "registers the rename it would actually be much more expensive so after renaming",
    "start": "2274150",
    "end": "2281890"
  },
  {
    "start": "2280000",
    "end": "2312000"
  },
  {
    "text": "the microbes get sent to an instruction scheduler so the instruction scheduler",
    "start": "2281890",
    "end": "2287369"
  },
  {
    "text": "stores all of the operands and tracks whether the operands are ready so all it's doing is saying it will pick the",
    "start": "2287369",
    "end": "2294790"
  },
  {
    "text": "earliest ready instruction and send it off for execution once it's executed",
    "start": "2294790",
    "end": "2299920"
  },
  {
    "text": "it'll track that the destination has been produced and some new instructions",
    "start": "2299920",
    "end": "2305500"
  },
  {
    "text": "might become buddies so this is just tracking the data flow of the instructions that are in the scheduler and it just keeps doing that",
    "start": "2305500",
    "end": "2311740"
  },
  {
    "text": "repeatedly so scheduler size traded with circuit cost the scheduler size affects",
    "start": "2311740",
    "end": "2322240"
  },
  {
    "start": "2312000",
    "end": "2360000"
  },
  {
    "text": "how much parallelism you can extract if you have a large scheduler you can look further ahead in the instruction stream",
    "start": "2322240",
    "end": "2328000"
  },
  {
    "text": "and that gets you more instructions per cycle so here is a plot of achieved",
    "start": "2328000",
    "end": "2335230"
  },
  {
    "text": "instructions per cycle versus the size of the scheduler and I was kind of greedy and I chose to use a 32 by 32",
    "start": "2335230",
    "end": "2342040"
  },
  {
    "text": "scheduler although you might say now you could probably get away with 24 without giving up too much performance",
    "start": "2342040",
    "end": "2347900"
  },
  {
    "text": "so we're training off capacity for F max",
    "start": "2347900",
    "end": "2353940"
  },
  {
    "text": "an area here and 32 gets me 275 megahertz so that's good enough so I'm going to take that",
    "start": "2353940",
    "end": "2359760"
  },
  {
    "text": "so the scheduler circuit looks like this",
    "start": "2359760",
    "end": "2365000"
  },
  {
    "start": "2360000",
    "end": "2531000"
  },
  {
    "text": "it's a four-way distributed matrix scheduler so four-way distributed means",
    "start": "2365000",
    "end": "2372109"
  },
  {
    "text": "there are four execution units in my processor each person each execution",
    "start": "2372109",
    "end": "2377940"
  },
  {
    "text": "unit has its own slice of the scheduler which means my crops that are executed",
    "start": "2377940",
    "end": "2383250"
  },
  {
    "text": "on a particular execution unit must go in that scheduler so that means that",
    "start": "2383250",
    "end": "2390329"
  },
  {
    "text": "it's more easily to get imbalance in the scheduler in a unified scheduler which I",
    "start": "2390329",
    "end": "2395369"
  },
  {
    "text": "think Intel likes to use all my crops go into the same pool so it's less likely to overflow but the trade-off is that",
    "start": "2395369",
    "end": "2403650"
  },
  {
    "text": "with distributed schedulers each slice of the scheduler smaller so you can make it faster but you get less efficient",
    "start": "2403650",
    "end": "2410700"
  },
  {
    "text": "utilization of the entries so I decided with four-way distributed it's a matrix",
    "start": "2410700",
    "end": "2416910"
  },
  {
    "text": "scheduler so matrix schedulers are kind of interesting they matrix schedules so normally when you think of a scheduler",
    "start": "2416910",
    "end": "2423390"
  },
  {
    "text": "you think of a micro op and it has operands and you check whether the operands are ready or not you will",
    "start": "2423390",
    "end": "2429359"
  },
  {
    "text": "compare tags when you execute an instruction you broadcast the tag and the tag says this operand operand number",
    "start": "2429359",
    "end": "2436140"
  },
  {
    "text": "3 is now ready a matrix scheduler doesn't track operands it actually",
    "start": "2436140",
    "end": "2441930"
  },
  {
    "text": "tracks dependencies between instructions directly so instead of storing this instruction requires operands 3 and 5 it",
    "start": "2441930",
    "end": "2448829"
  },
  {
    "text": "says this instruction is dependent on previous instructions number 6 and 8 so",
    "start": "2448829",
    "end": "2454740"
  },
  {
    "text": "it tracks whether the instruction is completed rather than whether the operand is available and that it's a",
    "start": "2454740",
    "end": "2461069"
  },
  {
    "text": "matrix because if you draw it out the circuit it actually looks like a grid of wires with a single flip-flop and a NAND",
    "start": "2461069",
    "end": "2467700"
  },
  {
    "text": "gate at each intersection point so matrix schedulers are faster when",
    "start": "2467700",
    "end": "2474119"
  },
  {
    "text": "they're small but they grow quadratically in",
    "start": "2474119",
    "end": "2479510"
  },
  {
    "text": "sighs they're basically in big matrix so for smaller schedulers matrix schedulers",
    "start": "2479510",
    "end": "2485809"
  },
  {
    "text": "are faster so at 32 entries that still consider small so I went the matrix",
    "start": "2485809",
    "end": "2490910"
  },
  {
    "text": "route if the scheduler were to grow significantly I might choose to go back",
    "start": "2490910",
    "end": "2496579"
  },
  {
    "text": "to the more traditional camera because it scales better so I chose 32",
    "start": "2496579",
    "end": "2503089"
  },
  {
    "text": "instructions that's I chose the size 32 scheduler for comparison the Pentium Pro at 20 and skylake which is fairly recent",
    "start": "2503089",
    "end": "2512180"
  },
  {
    "text": "Intel processor is 97 so it gives you an idea of roughly where where my design",
    "start": "2512180",
    "end": "2517549"
  },
  {
    "text": "sits all right so we're going to look a little bit more closely at the one of",
    "start": "2517549",
    "end": "2522920"
  },
  {
    "text": "the picker circuits for scheduling okay",
    "start": "2522920",
    "end": "2531770"
  },
  {
    "start": "2531000",
    "end": "2707000"
  },
  {
    "text": "so the purpose of the picker circuit the job is I have a bunch of instructions my",
    "start": "2531770",
    "end": "2539089"
  },
  {
    "text": "co-ops some of them are ready to be executed this circuits job is simply to pick the first one that's ready and send",
    "start": "2539089",
    "end": "2545000"
  },
  {
    "text": "it off for execution unit it's a very simple circuit so you know in this",
    "start": "2545000",
    "end": "2550069"
  },
  {
    "text": "diagram I have a bunch of zeros and ones ones means ready and the output of this circuit is I just want the earliest one",
    "start": "2550069",
    "end": "2556309"
  },
  {
    "text": "that's all it has to do turns out this circuits actually kind of slow in an FPGA because FPGA don't have",
    "start": "2556309",
    "end": "2563299"
  },
  {
    "text": "really wide logic gates and it can only do six inputs so the circuit that I came",
    "start": "2563299",
    "end": "2572000"
  },
  {
    "text": "up with is based on some past work on adders it's a prefix tree that's",
    "start": "2572000",
    "end": "2579920"
  },
  {
    "text": "logarithmic in depth so",
    "start": "2579920",
    "end": "2584650"
  },
  {
    "text": "I forgot how to explain this anyway if Callahan Carlson prefix tree it's used",
    "start": "2587660",
    "end": "2593270"
  },
  {
    "text": "in adders the end result is basically at this structure instead of being linear",
    "start": "2593270",
    "end": "2598850"
  },
  {
    "text": "in delay it becomes logarithmic and delay because it's an FPGA with six",
    "start": "2598850",
    "end": "2605810"
  },
  {
    "text": "input look-up tables I chose to use a radix six prefix tree I think most if",
    "start": "2605810",
    "end": "2611840"
  },
  {
    "text": "you'd built this on silicon most people choose radix two so FP is a little special because six is not really more",
    "start": "2611840",
    "end": "2619220"
  },
  {
    "text": "expensive than two and one difficult thing that I encountered was",
    "start": "2619220",
    "end": "2626090"
  },
  {
    "text": "the logic synthesizer actually wants to tear up my radix six tree and make it",
    "start": "2626090",
    "end": "2631550"
  },
  {
    "text": "linear again so I had to spend a lot of a hurt fighting with the synthesis tool",
    "start": "2631550",
    "end": "2637120"
  },
  {
    "text": "yes yes it's it's linear uses less area",
    "start": "2637330",
    "end": "2648880"
  },
  {
    "text": "so I think it was doing something like that common sub-expression elimination",
    "start": "2648880",
    "end": "2654070"
  },
  {
    "text": "it often makes things slower",
    "start": "2654070",
    "end": "2657850"
  },
  {
    "text": "okay so after scheduling the microbes that executed my processor has three",
    "start": "2664190",
    "end": "2671740"
  },
  {
    "text": "different execution units the aju is for memory operations that computes the",
    "start": "2671740",
    "end": "2677359"
  },
  {
    "text": "addresses there's a simple ALU and shifter that executes in single cycle",
    "start": "2677359",
    "end": "2683270"
  },
  {
    "text": "and only for the simple instructions and then there's a longer three cycle execution unit for all the other things",
    "start": "2683270",
    "end": "2691160"
  },
  {
    "text": "I couldn't fit in a single cycle so I",
    "start": "2691160",
    "end": "2698180"
  },
  {
    "text": "think the single cycle ALU is probably the most interesting from a circuit perspective so we're gonna look more",
    "start": "2698180",
    "end": "2703970"
  },
  {
    "text": "closely at that so the single cycle ALU is actually composed of three separate",
    "start": "2703970",
    "end": "2710390"
  },
  {
    "start": "2707000",
    "end": "2724000"
  },
  {
    "text": "parts there's a shifter there's an adder and there's bitwise logic for things",
    "start": "2710390",
    "end": "2716000"
  },
  {
    "text": "like or and and and so on good weiss so we're gonna look at the shifter and the adder circuits so let's",
    "start": "2716000",
    "end": "2722900"
  },
  {
    "text": "start with the shifter so shifters on FPGAs are rather inefficient as we saw",
    "start": "2722900",
    "end": "2729500"
  },
  {
    "start": "2724000",
    "end": "2848000"
  },
  {
    "text": "before multiplexers are inefficient on the feejee a and the shifter is really just a whole pile of multiplexers so we",
    "start": "2729500",
    "end": "2735500"
  },
  {
    "text": "have to spend a lot of effort to figure out what's the most efficient way to build a shifter so this is probably if",
    "start": "2735500",
    "end": "2742700"
  },
  {
    "text": "you had to shift a 32-bit operand this is probably pretty close to optimal a6",
    "start": "2742700",
    "end": "2748579"
  },
  {
    "text": "input lookup table can implement a 4 to 1 multiplexer which means you need three",
    "start": "2748579",
    "end": "2753589"
  },
  {
    "text": "levels of logic in order to do a shift I don't think you can improve on this so",
    "start": "2753589",
    "end": "2761799"
  },
  {
    "text": "what I did was starting off with that data path I added a whole bunch of",
    "start": "2761799",
    "end": "2768529"
  },
  {
    "text": "control logic to make the shifter be able to do left and right shift at three",
    "start": "2768529",
    "end": "2776180"
  },
  {
    "text": "different operand sizes and rotations and a whole bunch of very other variations like vite swap and sign",
    "start": "2776180",
    "end": "2781970"
  },
  {
    "text": "extension everything that looks kind of like a shift and crammed it all into a data path that was three levels of logic",
    "start": "2781970",
    "end": "2788990"
  },
  {
    "text": "except for a few small control pests so",
    "start": "2788990",
    "end": "2794029"
  },
  {
    "text": "the critical path was still on the three a three logic levels so as you can see the interesting part",
    "start": "2794029",
    "end": "2799460"
  },
  {
    "text": "is only if you look at the control side on the left the control was designed",
    "start": "2799460",
    "end": "2804980"
  },
  {
    "text": "such that the first level of muxes have zero levels of logic for the control and",
    "start": "2804980",
    "end": "2810380"
  },
  {
    "text": "there's more and more control for the later levels of the data path so I",
    "start": "2810380",
    "end": "2816800"
  },
  {
    "text": "managed to pack a lot of different x86 specific shift operations into the basic",
    "start": "2816800",
    "end": "2821960"
  },
  {
    "text": "data path without really extending the critical path by very much so the end",
    "start": "2821960",
    "end": "2827780"
  },
  {
    "text": "result here is that this particular shifter circuit is 50 50 percent faster and 46 percent smaller then if I simply",
    "start": "2827780",
    "end": "2836150"
  },
  {
    "text": "wrote the same operations in HDL and let cordis synthesize whatever light so",
    "start": "2836150",
    "end": "2842150"
  },
  {
    "text": "basically you can quote a case statement and say I need to do all of this alright",
    "start": "2842150",
    "end": "2850099"
  },
  {
    "start": "2848000",
    "end": "2960000"
  },
  {
    "text": "so now we're gonna look at the adder so on an FPGA there are hard carry chains",
    "start": "2850099",
    "end": "2855380"
  },
  {
    "text": "for adders and it's really really hard to improve on that unless your adders are you know thousands of bits long so",
    "start": "2855380",
    "end": "2863260"
  },
  {
    "text": "the hard adder is pretty much you know you can't improve on it it's basically optimal for 32 bits but what we can",
    "start": "2863260",
    "end": "2870230"
  },
  {
    "text": "improve is x86 says we need to do an addition but there's also a zero flag and the zero flag says is the results",
    "start": "2870230",
    "end": "2877700"
  },
  {
    "text": "zero or not and on an FPGA you don't have wide gates so a zero flag is",
    "start": "2877700",
    "end": "2884240"
  },
  {
    "text": "basically a nor gate with 32 inputs and that requires three levels of logic so",
    "start": "2884240",
    "end": "2892040"
  },
  {
    "text": "now that we have is the zero flag computation cost just as much as the Attic but it's also in series with the",
    "start": "2892040",
    "end": "2897920"
  },
  {
    "text": "adder because you need the result so we don't like that so it turns out that you",
    "start": "2897920",
    "end": "2903740"
  },
  {
    "text": "can actually compute whether the sum of two numbers is equal to a constant without using a carry chain and this was",
    "start": "2903740",
    "end": "2911089"
  },
  {
    "text": "done many many years ago using some addressed caches and things like that so this is an existing technique but hey we",
    "start": "2911089",
    "end": "2918230"
  },
  {
    "text": "can apply it here as well and now we can compute the addition in parallel with",
    "start": "2918230",
    "end": "2924680"
  },
  {
    "text": "computing whether the addition is equal to zero now in parallel instead of in series so it's still three",
    "start": "2924680",
    "end": "2930840"
  },
  {
    "text": "levels but now they're in hello so this circuit is you know 24 percent faster",
    "start": "2930840",
    "end": "2937170"
  },
  {
    "text": "it's not quite as impressive it's also bigger because you now come the zero",
    "start": "2937170",
    "end": "2942930"
  },
  {
    "text": "flag computation is more complex but you know it's 55 percent area increased but",
    "start": "2942930",
    "end": "2948870"
  },
  {
    "text": "it's really only 30 logic elements you know out of 27,000 it's not much of a",
    "start": "2948870",
    "end": "2955140"
  },
  {
    "text": "price to pay I think so we're gaining some speed okay next section now I'm",
    "start": "2955140",
    "end": "2966360"
  },
  {
    "start": "2960000",
    "end": "3028000"
  },
  {
    "text": "going to talk about the memory system so the memory system is basically the whole system that does loads and stores for",
    "start": "2966360",
    "end": "2973320"
  },
  {
    "text": "memory and from my experience this is probably the single hardest component of",
    "start": "2973320",
    "end": "2978840"
  },
  {
    "text": "the processor I think I spent about two years on this part alone it's kind of",
    "start": "2978840",
    "end": "2984480"
  },
  {
    "text": "ridiculous and it's not really x86 specific so memory operations are",
    "start": "2984480",
    "end": "2990480"
  },
  {
    "text": "basically loads and stores in next 86 this case we decode them into my crops and my crops basically our loads in",
    "start": "2990480",
    "end": "2996780"
  },
  {
    "text": "storage so the designs basically the same regardless of whether it's x86 or risk its loads and stores so it's not",
    "start": "2996780",
    "end": "3005870"
  },
  {
    "text": "just a unit that goes to memory for performance reasons we need caches and there are a lot of caches there's data",
    "start": "3005870",
    "end": "3012920"
  },
  {
    "text": "caches there's instruction caches there's also caches of a page table so",
    "start": "3012920",
    "end": "3018500"
  },
  {
    "text": "you know you end up with something like two TLB eese - data caches and an l2",
    "start": "3018500",
    "end": "3024740"
  },
  {
    "text": "cache so you've got a whole bunch of caches in the system so when you have",
    "start": "3024740",
    "end": "3029780"
  },
  {
    "start": "3028000",
    "end": "3094000"
  },
  {
    "text": "caches you have the very classical cache trade-offs in this plot I show two of my",
    "start": "3029780",
    "end": "3036380"
  },
  {
    "text": "benchmarks dry stone on the Left specint on the right I showed these two because",
    "start": "3036380",
    "end": "3042920"
  },
  {
    "text": "dry stone basically doesn't touch memory at all so it's not very sensitive spec in touch with memory a lot so these are",
    "start": "3042920",
    "end": "3048290"
  },
  {
    "text": "basically the two extremes just to show you two types of extreme workloads what happens when I play with the memory",
    "start": "3048290",
    "end": "3053660"
  },
  {
    "text": "system so very classic result is as you increase the cache size your performance",
    "start": "3053660",
    "end": "3059240"
  },
  {
    "text": "improves dry stone doesn't touch memory therefore it doesn't care so performance doesn't change when you change the sighs l1 caches have to be small because",
    "start": "3059240",
    "end": "3071060"
  },
  {
    "text": "we had we we have to be able to build them so we ended up choosing a kilobytes",
    "start": "3071060",
    "end": "3077750"
  },
  {
    "text": "which is quite small and we're giving up quite a bit of performance about using something this small but it turns out",
    "start": "3077750",
    "end": "3083390"
  },
  {
    "text": "you can get most of this back by having a no to cache so we also added an l2",
    "start": "3083390",
    "end": "3089780"
  },
  {
    "text": "cache and of course dry stone doesn't care either but in addition to the very",
    "start": "3089780",
    "end": "3097160"
  },
  {
    "start": "3094000",
    "end": "3170000"
  },
  {
    "text": "classical just cache size trade-offs there's when you do out of order there's a whole bunch of other fancy things you",
    "start": "3097160",
    "end": "3104210"
  },
  {
    "text": "can do them to the memory system things like how many concurrent misses can you",
    "start": "3104210",
    "end": "3110480"
  },
  {
    "text": "support if you are handling a cache miss can you keep executing independent instructions and execute more cache",
    "start": "3110480",
    "end": "3117050"
  },
  {
    "text": "misses in parallel so now you can get memory level parallelism can your memory system support out of order execution a",
    "start": "3117050",
    "end": "3123470"
  },
  {
    "text": "lot of earlier out of order processors did not execute memory operations out of",
    "start": "3123470",
    "end": "3129500"
  },
  {
    "text": "order because it was very difficult to track dependencies between memory",
    "start": "3129500",
    "end": "3134630"
  },
  {
    "text": "operations so yeah if you have a store followed by a load is this load dependent on the store it's hard to figure that out",
    "start": "3134630",
    "end": "3140590"
  },
  {
    "text": "so it turns out for at least for my processor these other techniques also",
    "start": "3140590",
    "end": "3148400"
  },
  {
    "text": "get you some fairly big performance gains so I ended up choosing the far",
    "start": "3148400",
    "end": "3155300"
  },
  {
    "text": "right data point so my memory system is out of order it also does memory dependence speculations so it will",
    "start": "3155300",
    "end": "3161780"
  },
  {
    "text": "speculate whether loads are dependent on stores and then flush the pipeline if",
    "start": "3161780",
    "end": "3167060"
  },
  {
    "text": "they were and I thought they went how",
    "start": "3167060",
    "end": "3172430"
  },
  {
    "start": "3170000",
    "end": "3264000"
  },
  {
    "text": "much time do you have okay we don't have much time okay so here's a summary of",
    "start": "3172430",
    "end": "3179810"
  },
  {
    "text": "the l1 memory system the data side only so we have data cache and tags we have a",
    "start": "3179810",
    "end": "3189650"
  },
  {
    "text": "TLB the MS HR is Miss status handling register this is for tracking the",
    "start": "3189650",
    "end": "3196520"
  },
  {
    "text": "outstanding cache misses and then we have a store queue for stores so the",
    "start": "3196520",
    "end": "3204270"
  },
  {
    "text": "critical path of this is whenever you do a memory access for example load you",
    "start": "3204270",
    "end": "3209850"
  },
  {
    "text": "first have to do an address translation and then after you get the translated address you have to compare it to the",
    "start": "3209850",
    "end": "3216570"
  },
  {
    "text": "cache tags to see whether you've hit in the l1 cache and then if it does you",
    "start": "3216570",
    "end": "3221670"
  },
  {
    "text": "have to select out which bytes of the data you actually want to load so just",
    "start": "3221670",
    "end": "3227730"
  },
  {
    "text": "to remind you x86 does not require aligned accesses so you do need a",
    "start": "3227730",
    "end": "3233400"
  },
  {
    "text": "rotator after the data array so one",
    "start": "3233400",
    "end": "3239010"
  },
  {
    "text": "optimization I did here was this is a fairly long critical path if you replicated some of the logic it turns",
    "start": "3239010",
    "end": "3244650"
  },
  {
    "text": "out this critical path can be made shorter by pre computing you know both so it's a two-way TLB so we pre compute",
    "start": "3244650",
    "end": "3251820"
  },
  {
    "text": "both answers assuming it hits in one way or hit in the other and then we select the correct answer of the elbe so this",
    "start": "3251820",
    "end": "3258960"
  },
  {
    "text": "is a trade-off of we spend more area in order to decrease delay so I'm going to",
    "start": "3258960",
    "end": "3265320"
  },
  {
    "start": "3264000",
    "end": "3279000"
  },
  {
    "text": "skip over this this is the horrifying version of the previous slide it goes",
    "start": "3265320",
    "end": "3270870"
  },
  {
    "text": "through all of the many ways a single load could fail and how you handle it",
    "start": "3270870",
    "end": "3277400"
  },
  {
    "text": "okay so this is the final circuit level diagram of the same circuit I showed you",
    "start": "3278660",
    "end": "3284130"
  },
  {
    "start": "3279000",
    "end": "3361000"
  },
  {
    "text": "in the previous slide it's a very complicated diagram and I don't think",
    "start": "3284130",
    "end": "3289700"
  },
  {
    "text": "it's clear exactly what you're looking at so the important thing to notice here is that the critical path is through the",
    "start": "3289700",
    "end": "3299490"
  },
  {
    "text": "TLB and translations it's four point three nanoseconds it's interesting to note that there are a lot of other",
    "start": "3299490",
    "end": "3305280"
  },
  {
    "text": "critical paths that are very close and delay so this is a very highly optimized and tuned circuit such that a whole",
    "start": "3305280",
    "end": "3312210"
  },
  {
    "text": "bunch of different paths have very similar delay so the blue boxes are look",
    "start": "3312210",
    "end": "3319800"
  },
  {
    "text": "six input look-up tables so basically all of this circuit was all hand map to lookup tables and there was all designed",
    "start": "3319800",
    "end": "3325740"
  },
  {
    "text": "so that all of the critical paths go through exactly five look-up tables",
    "start": "3325740",
    "end": "3330650"
  },
  {
    "text": "so the end result is that the whole memory system is about 4.3 nanoseconds and delay and she compared it to the",
    "start": "3331140",
    "end": "3337779"
  },
  {
    "text": "same memory stages on the Neos on the Altera soft processor then he actually have a",
    "start": "3337779",
    "end": "3344019"
  },
  {
    "text": "much simpler memory system and they take longer they fix 6 nanoseconds to do the",
    "start": "3344019",
    "end": "3349839"
  },
  {
    "text": "translation and cache access but they split it over one and a half cycles whereas I pack it all into a single",
    "start": "3349839",
    "end": "3355449"
  },
  {
    "text": "cycle so I'm training a lot of hardware for increased delay alright so we've",
    "start": "3355449",
    "end": "3363640"
  },
  {
    "start": "3361000",
    "end": "3452000"
  },
  {
    "text": "reached the end of the second part of my talk so I'm concluding that out of order processors are useful and feasible they",
    "start": "3363640",
    "end": "3370299"
  },
  {
    "text": "are big but they can get your performance but only if you pay a lot of attention to the circuit level design",
    "start": "3370299",
    "end": "3376809"
  },
  {
    "text": "and not give up 50% of your clock speed so you can do that either by making",
    "start": "3376809",
    "end": "3382989"
  },
  {
    "text": "microarchitecture choices that suit the substrate that you're building on or you can spend a lot of effort designing",
    "start": "3382989",
    "end": "3389289"
  },
  {
    "text": "these circuits to implement your microarchitecture and I found that level",
    "start": "3389289",
    "end": "3394509"
  },
  {
    "text": "design is actually often quite useful but also painful because the logic synthesizers are often undos your",
    "start": "3394509",
    "end": "3400390"
  },
  {
    "text": "optimizations so I unfortunately the",
    "start": "3400390",
    "end": "3405999"
  },
  {
    "text": "processor isn't actually finished so it's still a collection of pieces right now some pieces still missing I think",
    "start": "3405999",
    "end": "3414910"
  },
  {
    "text": "there's still some hope that the memory system could be optimized for further frequency by adding an extra cycle and",
    "start": "3414910",
    "end": "3421440"
  },
  {
    "text": "the fact that this processor was missing a floating-point unit was extremely painful so I certainly hope to add a",
    "start": "3421440",
    "end": "3426999"
  },
  {
    "text": "floating-point unit some time of any performance level the emulation mechanism for the FPU is much more",
    "start": "3426999",
    "end": "3433930"
  },
  {
    "text": "painful than actually having enough to you that's that that's my conclusion here alright so at the end of my talk",
    "start": "3433930",
    "end": "3440799"
  },
  {
    "text": "there are questions you",
    "start": "3440799",
    "end": "3444810"
  }
]