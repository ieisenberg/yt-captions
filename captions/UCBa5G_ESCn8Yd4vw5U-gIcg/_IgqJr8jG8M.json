[
  {
    "start": "0",
    "end": "135000"
  },
  {
    "text": "name of this talk which has just disappeared is concatenate programming",
    "start": "10700",
    "end": "18780"
  },
  {
    "text": "from ivory to metal so what I want to talk about is concatenate programming as a paradigm what theoretical interesting",
    "start": "18780",
    "end": "29279"
  },
  {
    "text": "things about it there are and also how you how you implement it on real hardware what the advantages are",
    "start": "29279",
    "end": "36060"
  },
  {
    "text": "disadvantages and things I like about it things I found interesting so Who am I",
    "start": "36060",
    "end": "41700"
  },
  {
    "text": "why why should you care what I have to say I am known to some people as the",
    "start": "41700",
    "end": "49050"
  },
  {
    "text": "article of this as the author of this article called why concatenate program matters in which I failed to explain",
    "start": "49050",
    "end": "57780"
  },
  {
    "text": "exactly why Concannon of programming matters but I did give sort of an introduction to the paradigm similar to",
    "start": "57780",
    "end": "63990"
  },
  {
    "text": "what I'm gonna do today so you can check that out I've worked in industry for",
    "start": "63990",
    "end": "69540"
  },
  {
    "text": "just a few years five years and my first",
    "start": "69540",
    "end": "74609"
  },
  {
    "text": "job in California was as a compiler engineer I was writing a compiler from",
    "start": "74609",
    "end": "79939"
  },
  {
    "text": "ActionScript 3 to JavaScript in Haskell and so I got familiar with what you have",
    "start": "79939",
    "end": "88740"
  },
  {
    "text": "to do in terms of programming language engineering when you're working with existing legacy systems and then we got",
    "start": "88740",
    "end": "97679"
  },
  {
    "text": "acquired by Facebook I worked on site integrity infrastructure project that you also may or may not have heard of",
    "start": "97679",
    "end": "103710"
  },
  {
    "text": "called hexyl which was with Simon Marlowe we were working on spam",
    "start": "103710",
    "end": "109799"
  },
  {
    "text": "classification machine learning high performance stuff in in Haskell and we did a paper for ICF P and then I was at",
    "start": "109799",
    "end": "118039"
  },
  {
    "text": "xamarin and then we were acquired by Microsoft where I was working on the mono runtime which is a net",
    "start": "118039",
    "end": "123889"
  },
  {
    "text": "implementation and there I was working on performance engineering and GC so this is my background this is why this",
    "start": "123889",
    "end": "132270"
  },
  {
    "text": "is what I've been exposed to and why I care about the things I care about and over this this period of time I have",
    "start": "132270",
    "end": "138240"
  },
  {
    "start": "135000",
    "end": "338000"
  },
  {
    "text": "developed a list of things that I care about in a programming language things that I want",
    "start": "138240",
    "end": "143489"
  },
  {
    "text": "so for example because code is read much more often than it's written and",
    "start": "143489",
    "end": "148980"
  },
  {
    "text": "modified much more often then it's written from whole cloth I want to prioritize languages that are",
    "start": "148980",
    "end": "155909"
  },
  {
    "text": "good for reading and modifying code I want a language that's expressive and what I mean by that concretely is the",
    "start": "155909",
    "end": "164189"
  },
  {
    "text": "syntax closely corresponds to the semantics and also the semantics are high very high level they let you say a",
    "start": "164189",
    "end": "170189"
  },
  {
    "text": "lot conceptually with very little code I like languages that encourage good",
    "start": "170189",
    "end": "176579"
  },
  {
    "text": "practices and good is obviously very subjective there are some broad broad",
    "start": "176579",
    "end": "183150"
  },
  {
    "text": "things on which people agree like reusability refactor ability testability and that kind of thing and I like",
    "start": "183150",
    "end": "189299"
  },
  {
    "text": "languages that make me do the things that I want to do anyway and static types are a good example of that where I",
    "start": "189299",
    "end": "195420"
  },
  {
    "text": "don't want to write type incorrect code so having the compiler just tell me hey you're doing this inconsistent thing is",
    "start": "195420",
    "end": "202579"
  },
  {
    "text": "convenient it makes me guided in the right direction I like things that have",
    "start": "202579",
    "end": "208980"
  },
  {
    "text": "an obvious mapping to real Hardware meaning for example when I write C code",
    "start": "208980",
    "end": "215760"
  },
  {
    "text": "I I can mentally compile it at no optimization level and see you know how",
    "start": "215760",
    "end": "222659"
  },
  {
    "text": "they correspond how the the instructions in the language correspond to the code that's going to be generated more or",
    "start": "222659",
    "end": "229199"
  },
  {
    "text": "less right if if you did it if you did it that way the generated code would not be terrible right",
    "start": "229199",
    "end": "236370"
  },
  {
    "text": "obviously the compiler does a lot more I like languages that are small and easy",
    "start": "236370",
    "end": "241590"
  },
  {
    "text": "to understand because that means that it's easy to implement tools for them right I can't write a C++ compiler I",
    "start": "241590",
    "end": "248040"
  },
  {
    "text": "can't do it I'm one person it is too much right it's too complex of a language it's too large of a language",
    "start": "248040",
    "end": "253859"
  },
  {
    "text": "there are too many edge cases and that also means that it's hard for me to write tools that work with C++ so if I",
    "start": "253859",
    "end": "261750"
  },
  {
    "text": "want to write some refactoring application that operates on C++ code I can't easily do that because it involves",
    "start": "261750",
    "end": "269159"
  },
  {
    "text": "writing all of the C+ put parsing and like unless that stuff is available as a library for example with Lib clang like",
    "start": "269159",
    "end": "275610"
  },
  {
    "text": "you really it's very difficult to do whereas with simpler languages I can just go and",
    "start": "275610",
    "end": "281980"
  },
  {
    "text": "freely do it right it doesn't feel as daunting I like languages that are good",
    "start": "281980",
    "end": "287710"
  },
  {
    "text": "citizens meaning they interoperate well with other languages either being able to use libraries written in other",
    "start": "287710",
    "end": "293200"
  },
  {
    "text": "languages or being able to embed them embed this this language in applications",
    "start": "293200",
    "end": "299950"
  },
  {
    "text": "written in other languages I like languages that don't assume that they're the world alright there are these",
    "start": "299950",
    "end": "306180"
  },
  {
    "text": "languages like managed code like Haskell Java C sharp and even languages like C++",
    "start": "306180",
    "end": "315610"
  },
  {
    "text": "they assume that your application is written in this language and you may call out to other things but you're",
    "start": "315610",
    "end": "322630"
  },
  {
    "text": "generally not going to be embedding this in other systems without first wrapping it in some kind of C interface or like",
    "start": "322630",
    "end": "330040"
  },
  {
    "text": "it starts to get awkward they assume that you know this is the language that you're using so they're not very good",
    "start": "330040",
    "end": "336400"
  },
  {
    "text": "citizens in terms of cooperating with a lot other languages so some notable",
    "start": "336400",
    "end": "343710"
  },
  {
    "start": "338000",
    "end": "450000"
  },
  {
    "text": "concatenative languages if you haven't heard of any of these before fourth was",
    "start": "343710",
    "end": "352630"
  },
  {
    "text": "the first language that is now called concatenative it didn't call itself that at the time and as you may know it's a",
    "start": "352630",
    "end": "360790"
  },
  {
    "text": "stack-based low-level language untyped essentially a high-level assembly and we",
    "start": "360790",
    "end": "369310"
  },
  {
    "text": "go through go through the 80s there was there was PostScript which was",
    "start": "369310",
    "end": "375820"
  },
  {
    "text": "dynamically typed there was joy which was the first language to call itself concatenative where manfred von Thun the",
    "start": "375820",
    "end": "386080"
  },
  {
    "text": "guy who invented this this term concatenative programming he was a",
    "start": "386080",
    "end": "392920"
  },
  {
    "text": "philosophy of professor at Latrobe University in Australia and he wanted to",
    "start": "392920",
    "end": "398590"
  },
  {
    "text": "investigate how you how you do philosophy when you you only have unary",
    "start": "398590",
    "end": "406870"
  },
  {
    "text": "predicate so ver over certain things and he arrived",
    "start": "406870",
    "end": "412349"
  },
  {
    "text": "eventually at a programming language by investigating this philosophical application of combinatory logic and",
    "start": "412349",
    "end": "419379"
  },
  {
    "text": "from there in the early 2000s there was factor which is a dynamically typed object-oriented Concannon of language",
    "start": "419379",
    "end": "425439"
  },
  {
    "text": "cat which was the first statically typed catnip language kitten which is a project of mine which was designed to",
    "start": "425439",
    "end": "432580"
  },
  {
    "text": "essentially replace cat because no one is working on that anymore and there's also popper which is the the",
    "start": "432580",
    "end": "439389"
  },
  {
    "text": "first lazy Concannon of language so these are the terms that I'll be talking",
    "start": "439389",
    "end": "446199"
  },
  {
    "text": "about and the the languages from from which I'll be drawing examples so to",
    "start": "446199",
    "end": "453550"
  },
  {
    "start": "450000",
    "end": "610000"
  },
  {
    "text": "give you an idea of how we arrived at this paradigm I'm going to go into just",
    "start": "453550",
    "end": "458770"
  },
  {
    "text": "very quick history so in the 1930s there were these suddenly three formal systems",
    "start": "458770",
    "end": "465490"
  },
  {
    "text": "of computation that we arrived at lambda calculus Turing machines and general",
    "start": "465490",
    "end": "470919"
  },
  {
    "text": "recursive functions lambda calculus obviously you have variables functions",
    "start": "470919",
    "end": "476889"
  },
  {
    "text": "and applications of functions and a couple of rules for how you rename variables and how you substitute values",
    "start": "476889",
    "end": "483580"
  },
  {
    "text": "into expressions so you have this notion of alpha equivalence and beta",
    "start": "483580",
    "end": "489219"
  },
  {
    "text": "equivalence where you can rewrite expressions by substituting values into variables and making sure that you avoid",
    "start": "489219",
    "end": "496779"
  },
  {
    "text": "name capture and things like that so here's just a very complicated way to write the identity function you have",
    "start": "496779",
    "end": "504610"
  },
  {
    "text": "Turing machines which are a more operational way of talking about computation and you basically describe",
    "start": "504610",
    "end": "511180"
  },
  {
    "text": "this machine that has a tape a read ahead and a state-transition function that can move the head and change",
    "start": "511180",
    "end": "517750"
  },
  {
    "text": "symbols on the tape and do that all that kind of stuff and you have general recursive functions which I honestly",
    "start": "517750",
    "end": "523959"
  },
  {
    "text": "don't know that much about but it's a different angle mathematical angle and all of these systems are equivalent",
    "start": "523959",
    "end": "529329"
  },
  {
    "text": "they're all Turing complete but it hasn't been like a hundred years and",
    "start": "529329",
    "end": "534339"
  },
  {
    "text": "we've come up with nothing else new isn't like there are no other formal",
    "start": "534339",
    "end": "539949"
  },
  {
    "text": "systems of computing in the 1950s an important result was combinatory logic just worked on by",
    "start": "539949",
    "end": "547450"
  },
  {
    "text": "Shawn Finkel and curry and in commerce or logic the idea is you can do much",
    "start": "547450",
    "end": "555279"
  },
  {
    "text": "like what you do in lambda calculus but you don't need all the variable binding you don't need lambda abstraction you",
    "start": "555279",
    "end": "562540"
  },
  {
    "text": "just have Combinator's and applications of Combinator's to other Combinator's so",
    "start": "562540",
    "end": "567910"
  },
  {
    "text": "it's it's functional programming with only functions right and the basis of",
    "start": "567910",
    "end": "574899"
  },
  {
    "text": "this system are these two combinators s and K s basically lets you apply a function to an argument within some",
    "start": "574899",
    "end": "582100"
  },
  {
    "text": "environment and K lets you select one of two arguments and from that you can",
    "start": "582100",
    "end": "588160"
  },
  {
    "text": "build all these other combinators like the identity function these other",
    "start": "588160",
    "end": "593769"
  },
  {
    "text": "combinators like function composition flipping and duplicating arguments and",
    "start": "593769",
    "end": "600399"
  },
  {
    "text": "things like that and here is look just a quick proof that it's turning complete you can express the Y Combinator the",
    "start": "600399",
    "end": "607000"
  },
  {
    "text": "famous Y Combinator so so with that bit",
    "start": "607000",
    "end": "616029"
  },
  {
    "start": "610000",
    "end": "660000"
  },
  {
    "text": "of history now I can tell you what concatenate programming actually is and",
    "start": "616029",
    "end": "621250"
  },
  {
    "text": "I can just use the Wikipedia definition because it's it's good enough a concatenative language is a point free",
    "start": "621250",
    "end": "627779"
  },
  {
    "text": "computer programming language in which all expressions denote functions and the juxtaposition of expressions denotes",
    "start": "627779",
    "end": "633880"
  },
  {
    "text": "function composition so what does that mean I'll just unpack it but basically",
    "start": "633880",
    "end": "640320"
  },
  {
    "text": "we we got imperative programming from this operational model of computation of",
    "start": "640320",
    "end": "645910"
  },
  {
    "text": "Turing machines we got functional programming from this abstract model of",
    "start": "645910",
    "end": "650980"
  },
  {
    "text": "computation lambda calculus and we got concatenated programming indirectly from combinatorial logic so it's related",
    "start": "650980",
    "end": "660810"
  },
  {
    "start": "660000",
    "end": "737000"
  },
  {
    "text": "equal in power but from a different basis so what do I mean by a point free",
    "start": "660810",
    "end": "668500"
  },
  {
    "text": "computer programming language like well you you know shell pipelines you",
    "start": "668500",
    "end": "675880"
  },
  {
    "text": "probably use them quite often shale pipelines are based on composition of",
    "start": "675880",
    "end": "680950"
  },
  {
    "text": "programs so you have the output of one program sent to the input of another and so on and so on and you never talk about",
    "start": "680950",
    "end": "690060"
  },
  {
    "text": "names of the values that are flowing between these programs it's just standard input and standard output",
    "start": "690060",
    "end": "697990"
  },
  {
    "text": "similarly in functional languages you often do point free programming when you",
    "start": "697990",
    "end": "704470"
  },
  {
    "text": "work with compositions of functions so here for example as a function that computes a histogram of the characters",
    "start": "704470",
    "end": "710470"
  },
  {
    "text": "in a string except for the whitespace and there on the right is an example in",
    "start": "710470",
    "end": "717340"
  },
  {
    "text": "concatenative language it's very similar to the Haskell code in which you also",
    "start": "717340",
    "end": "723960"
  },
  {
    "text": "are computing this histogram but note that it's written in reverse order so all of the operations are written from",
    "start": "723960",
    "end": "730450"
  },
  {
    "text": "left to right in the same sort of pipeline style as you have with the shell so what does what does point free",
    "start": "730450",
    "end": "739900"
  },
  {
    "start": "737000",
    "end": "927000"
  },
  {
    "text": "programming mean what is it about basically in programming it means that",
    "start": "739900",
    "end": "745750"
  },
  {
    "text": "you have this dataflow style that uses Combinator's to avoid referencing variables or arguments of functions",
    "start": "745750",
    "end": "751870"
  },
  {
    "text": "you're combining behaviors purely the term comes in directly from topology",
    "start": "751870",
    "end": "758320"
  },
  {
    "text": "geometry in which you try to do reasoning about spaces without talking",
    "start": "758320",
    "end": "765400"
  },
  {
    "text": "about any specific set of points that would make up that space in this case the points refer to your variables and",
    "start": "765400",
    "end": "771700"
  },
  {
    "text": "your objects so the idea of the advantage of point free programming is that variables are go-to for data they",
    "start": "771700",
    "end": "780430"
  },
  {
    "text": "provide unstructured access to a value you can take a value from anywhere and",
    "start": "780430",
    "end": "788820"
  },
  {
    "text": "copy it or bring it to wherever you want which is very powerful and sometimes you",
    "start": "788820",
    "end": "795160"
  },
  {
    "text": "need that but we kind of accept it a long time ago that structured programming without goto is superior so",
    "start": "795160",
    "end": "803110"
  },
  {
    "text": "why not structured access to values as well and the",
    "start": "803110",
    "end": "808500"
  },
  {
    "text": "is that if you follow this maximum of name code not data then you often arrive",
    "start": "808500",
    "end": "816330"
  },
  {
    "text": "a code that is a simple and purely",
    "start": "816330",
    "end": "821550"
  },
  {
    "text": "functional representation of your problem that expresses your intent point",
    "start": "821550",
    "end": "827730"
  },
  {
    "text": "free programming comes from this idea of value level versus function level programming so in John Backus is Turing",
    "start": "827730",
    "end": "835530"
  },
  {
    "text": "Award lecture here he presented this paper can programming be liberated from",
    "start": "835530",
    "end": "842010"
  },
  {
    "text": "the von Neumann style so all of the machines you use day to day are what are",
    "start": "842010",
    "end": "848580"
  },
  {
    "text": "called von Neumann machines in which you have a CPU a store of memory and some",
    "start": "848580",
    "end": "855000"
  },
  {
    "text": "way of shuffling words of values between those two and this is sort of a",
    "start": "855000",
    "end": "862710"
  },
  {
    "text": "bottleneck right like any any value that you manipulate in the CPU has to be either generated there or fetched from",
    "start": "862710",
    "end": "869580"
  },
  {
    "text": "memory or stored to memory and this this gap between these two is only getting",
    "start": "869580",
    "end": "874650"
  },
  {
    "text": "greater and greater so we're trying to work around this by adding layers of caching and things like that but anyway",
    "start": "874650",
    "end": "881610"
  },
  {
    "text": "this is an example of value level programming which you've probably seen a bunch it computes the inner product of",
    "start": "881610",
    "end": "889260"
  },
  {
    "text": "two vectors and you can see that at each step were operating using primitives on",
    "start": "889260",
    "end": "896760"
  },
  {
    "text": "a single value at a time right each of these a high level so-called language",
    "start": "896760",
    "end": "903270"
  },
  {
    "text": "instructions corresponds to low level CPU instructions and in order to reason",
    "start": "903270",
    "end": "909180"
  },
  {
    "text": "about this code this value level code especially because it uses mutation we",
    "start": "909180",
    "end": "915120"
  },
  {
    "text": "need to mentally step through it right we need to determine what it's actually",
    "start": "915120",
    "end": "921630"
  },
  {
    "text": "doing operationally in order to understand what it's doing semantically and that sucks basically because the",
    "start": "921630",
    "end": "930600"
  },
  {
    "text": "semantics of the program are closely coupled to the state it's very low level the compiler has to do all of these",
    "start": "930600",
    "end": "937500"
  },
  {
    "text": "inferences to actually optimize the code for example to vectorize that loop",
    "start": "937500",
    "end": "942540"
  },
  {
    "text": "in order to debug it like if you've made a mistake you have to either mentally step through it or go through an ad",
    "start": "942540",
    "end": "948720"
  },
  {
    "text": "debug in a debugger everything is built up from primitives like integers and",
    "start": "948720",
    "end": "954750"
  },
  {
    "text": "conditional jumps there are no high-level ways of combining code and",
    "start": "954750",
    "end": "960420"
  },
  {
    "text": "this code doesn't have any useful algebraic properties right I can't take out any random expression from there and",
    "start": "960420",
    "end": "966209"
  },
  {
    "text": "put it in another function and have it just work I have to write these wrapper expressions that pass arguments along",
    "start": "966209",
    "end": "972540"
  },
  {
    "text": "and name values and essentially I can't reason about any sub part of a function",
    "start": "972540",
    "end": "978209"
  },
  {
    "text": "without also understanding the context which in an imperative language also",
    "start": "978209",
    "end": "983970"
  },
  {
    "text": "includes the entire history of every variable so what Beck has proposed",
    "start": "983970",
    "end": "990029"
  },
  {
    "text": "instead was that we do a more function oriented style of programming in which",
    "start": "990029",
    "end": "996600"
  },
  {
    "text": "we don't do things one single value at a time we use high-level combining forms",
    "start": "996600",
    "end": "1002420"
  },
  {
    "text": "to talk about operations over whole data structures so he provided this",
    "start": "1002420",
    "end": "1007490"
  },
  {
    "text": "definition of inner product which is it has a long form and an abbreviated form",
    "start": "1007490",
    "end": "1013279"
  },
  {
    "text": "but it essentially says fold with addition so some composed with apply to",
    "start": "1013279",
    "end": "1020180"
  },
  {
    "text": "all with the product so that's map of a product with transposition so the rough",
    "start": "1020180",
    "end": "1027829"
  },
  {
    "text": "equivalent of this in haskell if you're more familiar with the language like that would be some composed with map",
    "start": "1027829",
    "end": "1033500"
  },
  {
    "text": "product compose with transpose but the idea that he presented was that if you",
    "start": "1033500",
    "end": "1040790"
  },
  {
    "text": "have a language like this you get certain advantages namely if you have",
    "start": "1040790",
    "end": "1046390"
  },
  {
    "text": "the application of inner product to this pair of vectors a colon is function",
    "start": "1046390",
    "end": "1053600"
  },
  {
    "text": "application in his language called F P then you can reason about the program as",
    "start": "1053600",
    "end": "1060080"
  },
  {
    "text": "purely rewriting and substitution right so you rewrite the composition to application you apply a transposition",
    "start": "1060080",
    "end": "1067400"
  },
  {
    "text": "you apply the product you apply the sum and you get a results",
    "start": "1067400",
    "end": "1074230"
  },
  {
    "start": "1074000",
    "end": "1190000"
  },
  {
    "text": "this has some advantages right it's entirely stateless values have no",
    "start": "1074970",
    "end": "1080820"
  },
  {
    "text": "dependencies over time they only have data dependencies between each other and",
    "start": "1080820",
    "end": "1087049"
  },
  {
    "text": "all of those data dependencies are explicit they're written in the",
    "start": "1087049",
    "end": "1093030"
  },
  {
    "text": "combining form they use the composition operator its high-level it expresses",
    "start": "1093030",
    "end": "1098070"
  },
  {
    "text": "what you want to do the compiler knows the structure so it can optimize it well the programmer can reason about what",
    "start": "1098070",
    "end": "1104460"
  },
  {
    "text": "they actually mean to say instead of how to do it operationally it's made of only",
    "start": "1104460",
    "end": "1110340"
  },
  {
    "text": "combining primitive functions it has useful algebraic properties for example you can easily factor out sub",
    "start": "1110340",
    "end": "1116880"
  },
  {
    "text": "expressions so if I want to say like oh I I have I want to take the sum of the",
    "start": "1116880",
    "end": "1122370"
  },
  {
    "text": "product of something else where I can factor that out give it a name and everywhere I use that composition I can",
    "start": "1122370",
    "end": "1129120"
  },
  {
    "text": "replace it with the name I don't need to add any arguments I don't need to worry",
    "start": "1129120",
    "end": "1135510"
  },
  {
    "text": "about the structure of the program other than just substitution so sub programs",
    "start": "1135510",
    "end": "1141120"
  },
  {
    "text": "are all pure functions which makes all the context explicit and his ideas",
    "start": "1141120",
    "end": "1147809"
  },
  {
    "text": "inspired the APL family of languages which I know are not terribly popular but there's this language called J which",
    "start": "1147809",
    "end": "1155150"
  },
  {
    "text": "is derived from APL it doesn't use all the old the funny characters but it is a massive ASCII symbols but essentially",
    "start": "1155150",
    "end": "1162360"
  },
  {
    "text": "you can you can do the same thing that he wrote in FP in in J where you have",
    "start": "1162360",
    "end": "1170789"
  },
  {
    "text": "this definition of inner product the at colon is composition the plus slash and",
    "start": "1170789",
    "end": "1177720"
  },
  {
    "text": "star slash are the sum and product and the vertical bar colon is transposition",
    "start": "1177720",
    "end": "1183809"
  },
  {
    "text": "so if you give it this pair of vectors and you reason through the substitutions you come out with the same result you",
    "start": "1183809",
    "end": "1191789"
  },
  {
    "start": "1190000",
    "end": "1431000"
  },
  {
    "text": "can in APL family languages actually give proper names to things and make the program's readable they don't for",
    "start": "1191789",
    "end": "1200010"
  },
  {
    "text": "various reasons they like the density of it now but in summary it's a nice way of",
    "start": "1200010",
    "end": "1207120"
  },
  {
    "text": "working with code if you can just build up your program from combining primitive functions using",
    "start": "1207120",
    "end": "1213750"
  },
  {
    "text": "powerful combining tools and it enables this reasoning that doesn't require",
    "start": "1213750",
    "end": "1219530"
  },
  {
    "text": "operationally going through your program you can just substitute variables and",
    "start": "1219530",
    "end": "1225020"
  },
  {
    "text": "chug through the the substitution as the reductions and you can reuse the math",
    "start": "1225020",
    "end": "1232980"
  },
  {
    "text": "that you've already learned before you got into programming right like substituting variables and operating on",
    "start": "1232980",
    "end": "1242340"
  },
  {
    "text": "expressions these are things that you've already done for many years in mathematics before a lot of people start",
    "start": "1242340",
    "end": "1248130"
  },
  {
    "text": "studying programming so the thing that",
    "start": "1248130",
    "end": "1254429"
  },
  {
    "text": "happened between concatenated programming and combinatorial logic was",
    "start": "1254429",
    "end": "1260809"
  },
  {
    "text": "this related calculus called concatenative calculus which was the the",
    "start": "1260809",
    "end": "1269309"
  },
  {
    "text": "main explanation of it was this article called the theory of concatenate of Combinator's by Brent Kirby and it's",
    "start": "1269309",
    "end": "1275130"
  },
  {
    "text": "essentially a version of combinatory logic where you instead of application",
    "start": "1275130",
    "end": "1282240"
  },
  {
    "text": "of combinators to other Combinator's you have composition and quotation is a sort",
    "start": "1282240",
    "end": "1290340"
  },
  {
    "text": "of it's sort of similar to lambda abstraction where you can wrap something up in a function and manipulate it so",
    "start": "1290340",
    "end": "1296900"
  },
  {
    "text": "the idea here is you have these basic rules you have this basic set of Combinator's that let you copy rearrange",
    "start": "1296900",
    "end": "1304620"
  },
  {
    "text": "delete wrap compose and unwrap values and weirdly that's turning complete and",
    "start": "1304620",
    "end": "1313679"
  },
  {
    "text": "in fact there are smaller systems that are smaller systems of combinators that are that are also turing complete so",
    "start": "1313679",
    "end": "1325309"
  },
  {
    "text": "these these combinators like doop swap",
    "start": "1325309",
    "end": "1330809"
  },
  {
    "text": "drop quote catcalled all that forth sounding code those correspond to the",
    "start": "1330809",
    "end": "1337320"
  },
  {
    "text": "the familiar combinators from combinatory logic and the interesting thing that the",
    "start": "1337320",
    "end": "1345150"
  },
  {
    "text": "interesting thing about this these combinators is that yes they let you apply functions but they also let you do",
    "start": "1345150",
    "end": "1350850"
  },
  {
    "text": "all of the things that you do when you're manipulating proofs in logic so you can reorder delete and duplicate",
    "start": "1350850",
    "end": "1356850"
  },
  {
    "text": "values and those correspond to what are called sub structural rules in logic so",
    "start": "1356850",
    "end": "1362640"
  },
  {
    "text": "if you look on the right over there you can consider the first argument of each Combinator to be a continuation that you",
    "start": "1362640",
    "end": "1369660"
  },
  {
    "text": "pass on some values to after doing some operation so composition means apply a",
    "start": "1369660",
    "end": "1375600"
  },
  {
    "text": "function passed the result on to a continuation the the W Combinator is I",
    "start": "1375600",
    "end": "1382890"
  },
  {
    "text": "take an argument I pass two copies of that onto the continuation things like that and so it turns out that if you",
    "start": "1382890",
    "end": "1391860"
  },
  {
    "text": "give different subsets of these",
    "start": "1391860",
    "end": "1396929"
  },
  {
    "text": "combinators as your as your basis then what you arrive at are different systems",
    "start": "1396929",
    "end": "1402179"
  },
  {
    "text": "in which are allowed to do different things so if you just have B and I then",
    "start": "1402179",
    "end": "1407580"
  },
  {
    "text": "you get ordered linear lambda calculus where every value have to has to be used",
    "start": "1407580",
    "end": "1412860"
  },
  {
    "text": "exactly once in the order that it was introduced the curious thing about that is that it works in any category if",
    "start": "1412860",
    "end": "1420030"
  },
  {
    "text": "you're familiar with category theory and then you get these other systems as well",
    "start": "1420030",
    "end": "1426720"
  },
  {
    "text": "like whether you have to use a variable exactly once at most ones for at least ones and why that's important is why",
    "start": "1426720",
    "end": "1434309"
  },
  {
    "start": "1431000",
    "end": "1650000"
  },
  {
    "text": "these sub structural rules are important is that there have been advances lately in programming language research about",
    "start": "1434309",
    "end": "1441179"
  },
  {
    "text": "what are called sub structural type systems and those has were present in",
    "start": "1441179",
    "end": "1447630"
  },
  {
    "text": "languages like rust which is probably the most well known example also 80s and",
    "start": "1447630",
    "end": "1452850"
  },
  {
    "text": "clean soon haskell will have linear types rust has were called affine types",
    "start": "1452850",
    "end": "1458720"
  },
  {
    "text": "which it uses to say if a mutable reference exists to a value then it has",
    "start": "1458720",
    "end": "1465450"
  },
  {
    "text": "to be unique right and that rules out an entire class of concurrency errors",
    "start": "1465450",
    "end": "1471000"
  },
  {
    "text": "because you have no way to do shared mutation of a value that can overlap so you have no data",
    "start": "1471000",
    "end": "1477750"
  },
  {
    "text": "races you can eliminate the overhead of synchronizing your code in a lot of cases substructure all type systems also",
    "start": "1477750",
    "end": "1485910"
  },
  {
    "text": "let you avoid garbage collection so you can have these high-level functional",
    "start": "1485910",
    "end": "1491549"
  },
  {
    "text": "languages that don't require a GC you",
    "start": "1491549",
    "end": "1496860"
  },
  {
    "text": "can reason about not just memory but any resource you can use these type systems",
    "start": "1496860",
    "end": "1502350"
  },
  {
    "text": "to enforce protocols so you know that for example if you have a file once that",
    "start": "1502350",
    "end": "1510299"
  },
  {
    "text": "file is closed you want all operations on that handle to failed so you can just",
    "start": "1510299",
    "end": "1516450"
  },
  {
    "text": "say well the closed operation consumes the file and then because it's unique no one else had a reference to it so it's",
    "start": "1516450",
    "end": "1523500"
  },
  {
    "text": "just gone no one can do it the invalid thing it allows you to prevent invalid",
    "start": "1523500",
    "end": "1528870"
  },
  {
    "text": "state transitions in your programs and it's got interesting applications in",
    "start": "1528870",
    "end": "1536190"
  },
  {
    "text": "things like reversible computing where you can have extremely extremely low powered devices in terms of energy",
    "start": "1536190",
    "end": "1543600"
  },
  {
    "text": "consumption if you have the restriction that you never destroy information",
    "start": "1543600",
    "end": "1549890"
  },
  {
    "text": "because that increases entropy which is usually released as heat and things like",
    "start": "1549890",
    "end": "1555960"
  },
  {
    "text": "quantum computing where when you observe a value it it consumes it so you have",
    "start": "1555960",
    "end": "1566760"
  },
  {
    "text": "these this analogy between the sub structural rules in Combinator logic and",
    "start": "1566760",
    "end": "1573120"
  },
  {
    "text": "in cognitive programming and then you you realize that like continuations",
    "start": "1573120",
    "end": "1579390"
  },
  {
    "text": "aren't this like scary concept anymore it's just whatever comes after this",
    "start": "1579390",
    "end": "1584820"
  },
  {
    "text": "current point in the program so wherever I have this you know a dupe right I",
    "start": "1584820",
    "end": "1592679"
  },
  {
    "text": "replace it with two copies of whatever value a is and I continue with the continuation so and then operationally",
    "start": "1592679",
    "end": "1601980"
  },
  {
    "text": "when I want to save a continuation all I need to do is save the state of the stack in the instruction pointer",
    "start": "1601980",
    "end": "1608800"
  },
  {
    "text": "and I'm done right it's like it becomes very easy to reason about what a continuation is instead of saying you",
    "start": "1608800",
    "end": "1615250"
  },
  {
    "text": "know what this is this is too complicated so basically concatenative programming",
    "start": "1615250",
    "end": "1621130"
  },
  {
    "text": "is what you get when you combine combinatorial logic with this continuation passing style where you",
    "start": "1621130",
    "end": "1628560"
  },
  {
    "text": "like you can think about these these operations these Combinator's as",
    "start": "1628560",
    "end": "1634660"
  },
  {
    "text": "operating on a stack or you can think about them as being passed as arguments",
    "start": "1634660",
    "end": "1641530"
  },
  {
    "text": "as continuations to the one before it so you can think about it either way and it works either way if you're if you're",
    "start": "1641530",
    "end": "1647800"
  },
  {
    "text": "willing to turn your head inside have so the other thing about concatenate",
    "start": "1647800",
    "end": "1652930"
  },
  {
    "start": "1650000",
    "end": "2065000"
  },
  {
    "text": "programming is all expressions denote functions and putting an expression side by side juxtaposition means function",
    "start": "1652930",
    "end": "1659950"
  },
  {
    "text": "composition so first of all what are we composing functions of like what what",
    "start": "1659950",
    "end": "1666430"
  },
  {
    "text": "are we talking about what is our program state and we need some data structure where we can store values that we're",
    "start": "1666430",
    "end": "1672550"
  },
  {
    "text": "talking about and manipulating and as it turns out most competitive languages",
    "start": "1672550",
    "end": "1678420"
  },
  {
    "text": "just use a stack where you push arguments to a function onto the stack",
    "start": "1678420",
    "end": "1685920"
  },
  {
    "text": "they're consumed and then the results are pushed onto the stack so you have this chain of operations on a single",
    "start": "1685920",
    "end": "1693160"
  },
  {
    "text": "data structure so what do I mean by",
    "start": "1693160",
    "end": "1699760"
  },
  {
    "text": "everything denotes a function well this is one of those everything is a",
    "start": "1699760",
    "end": "1705760"
  },
  {
    "text": "languages right we're in in like a pure object-oriented language you have you",
    "start": "1705760",
    "end": "1712450"
  },
  {
    "text": "know everything it's an object in a pure Lisp like language you might have everything as a list here you have for",
    "start": "1712450",
    "end": "1719980"
  },
  {
    "text": "example literals are the they're functions that just push a value onto",
    "start": "1719980",
    "end": "1725380"
  },
  {
    "text": "the stack so we tend to refer to two",
    "start": "1725380",
    "end": "1731200"
  },
  {
    "text": "things in kind of programming with natural language terminology so literal is a noun it's a value so something like",
    "start": "1731200",
    "end": "1740290"
  },
  {
    "text": "to write it takes any stack it takes a stack it returns",
    "start": "1740290",
    "end": "1745539"
  },
  {
    "text": "that stack with an integer on top you know something like a string returns a string on top operators and functions",
    "start": "1745539",
    "end": "1751299"
  },
  {
    "text": "likewise they consume values from the top of the stack they return values onto",
    "start": "1751299",
    "end": "1756699"
  },
  {
    "text": "the top of the stack and so we have this differentiation between terms and values",
    "start": "1756699",
    "end": "1763779"
  },
  {
    "text": "where every term is a function but not every value is a function we have real things like integers and strings and",
    "start": "1763779",
    "end": "1770409"
  },
  {
    "text": "normal stuff that we like to work with but we can also put put functions on the",
    "start": "1770409",
    "end": "1777549"
  },
  {
    "text": "stack right we can we can put these blocks of code and then call them in",
    "start": "1777549",
    "end": "1782739"
  },
  {
    "text": "various ways with higher-order functions and that's what gives you a lot of power",
    "start": "1782739",
    "end": "1788339"
  },
  {
    "text": "so the first competitive language was",
    "start": "1788339",
    "end": "1794049"
  },
  {
    "text": "forth it was it was built around this concept",
    "start": "1794049",
    "end": "1800379"
  },
  {
    "text": "of you had you have these : definitions so : means define a function followed by the name and usually a",
    "start": "1800379",
    "end": "1806229"
  },
  {
    "text": "comment telling you what it does and it just says to square a number you copy a",
    "start": "1806229",
    "end": "1813219"
  },
  {
    "text": "value and then multiply it by itself so two squared we can reason about either",
    "start": "1813219",
    "end": "1818409"
  },
  {
    "text": "as an imperative sequence of operations or as a composition of pure functions all right we can reason about this as",
    "start": "1818409",
    "end": "1825339"
  },
  {
    "text": "substitution in a very high-level way or we can reason about it as operational",
    "start": "1825339",
    "end": "1830589"
  },
  {
    "text": "code on a stack in a very low-level way which is also very easy to translate efficiently to hardware and the",
    "start": "1830589",
    "end": "1838569"
  },
  {
    "text": "advantage is you can write your code in this beta flow style that often turns out to be very readable in practice so",
    "start": "1838569",
    "end": "1845289"
  },
  {
    "text": "if I want to write a repple I can literally say read eval print loop and",
    "start": "1845289",
    "end": "1850929"
  },
  {
    "text": "pipe the values that I need between these functions and everything just looks nice the problem arises when you",
    "start": "1850929",
    "end": "1859269"
  },
  {
    "text": "start trying to manipulate multiple values on the stack at once right how do you how do you do more than just this",
    "start": "1859269",
    "end": "1866469"
  },
  {
    "text": "trivial stuff and for that you often have these stack shuffling combinators",
    "start": "1866469",
    "end": "1872469"
  },
  {
    "text": "like swap and so here for example is a fourth",
    "start": "1872469",
    "end": "1878070"
  },
  {
    "text": "definition of max it returns the maximum of two numbers so in order to do that",
    "start": "1878070",
    "end": "1884910"
  },
  {
    "text": "first it copies both of them tests which one is lower if if they're in order",
    "start": "1884910",
    "end": "1896370"
  },
  {
    "text": "already then we swap them and drop the the one that was smaller otherwise we we know",
    "start": "1896370",
    "end": "1904320"
  },
  {
    "text": "that the one that was smaller is already on top so we just drop it",
    "start": "1904320",
    "end": "1908780"
  },
  {
    "text": "but you don't want to do that all time right you want to just get programming done so in practice people use local",
    "start": "1909680",
    "end": "1917760"
  },
  {
    "text": "variables it can be more readable the trade-off is that you lose some of the",
    "start": "1917760",
    "end": "1924570"
  },
  {
    "text": "advantages of purely compositional programming so instead of writing this",
    "start": "1924570",
    "end": "1932070"
  },
  {
    "text": "is an example in Khitan instead of writing duplicate these values and you",
    "start": "1932070",
    "end": "1937440"
  },
  {
    "text": "know if swap drop I can say like okay just give me x and y from the stack and if X is less than Y then Y is the max",
    "start": "1937440",
    "end": "1944550"
  },
  {
    "text": "otherwise X is like that let's you say what you mean sometimes you do mean to work with just values but the",
    "start": "1944550",
    "end": "1953460"
  },
  {
    "text": "interesting thing about locals is that they're just lambdas in disguise right we're composing them instead of applying",
    "start": "1953460",
    "end": "1958620"
  },
  {
    "text": "them but if we have we have a function and we have an introduction of a local",
    "start": "1958620",
    "end": "1965070"
  },
  {
    "text": "variable followed by some other code that uses that variable what that means is we have a function that's taking the",
    "start": "1965070",
    "end": "1972060"
  },
  {
    "text": "stack we're taking the top element of the stack and binding it to a variable and then proceeding with some code on",
    "start": "1972060",
    "end": "1979350"
  },
  {
    "text": "the remainder of the stack so this this",
    "start": "1979350",
    "end": "1985440"
  },
  {
    "text": "hints that there's a very simple translation from concatenative code to lambda calculus which you can use to",
    "start": "1985440",
    "end": "1992310"
  },
  {
    "text": "compile it efficiently as well if you want to have a functional sort of oriented language and similarly nobody",
    "start": "1992310",
    "end": "1998820"
  },
  {
    "text": "actually programs in pure like raw competitive calculus that would be like",
    "start": "1998820",
    "end": "2004850"
  },
  {
    "text": "programming and lambda calculus it's too low-level it's inconvenient you don't want to do it so akan Canada",
    "start": "2004850",
    "end": "2010549"
  },
  {
    "text": "programming language has a bunch of syntactic sugar on top of that to make programming actually convenient and has",
    "start": "2010549",
    "end": "2016130"
  },
  {
    "text": "different data types instant and so on so like in fix operators right you don't",
    "start": "2016130",
    "end": "2021650"
  },
  {
    "text": "want to necessarily write every every operator as a postfix function color you",
    "start": "2021650",
    "end": "2026960"
  },
  {
    "text": "want to be able to copy and paste math expressions from other languages similarly you want to be able to write",
    "start": "2026960",
    "end": "2033549"
  },
  {
    "text": "things you know basic straight line code like if-else session session because you",
    "start": "2033549",
    "end": "2041390"
  },
  {
    "text": "can translate everything from infix to postfix if you want but if you want to",
    "start": "2041390",
    "end": "2047210"
  },
  {
    "text": "start going and translating these local variables to pure stack shuffling Combinator's right unless you're very",
    "start": "2047210",
    "end": "2054050"
  },
  {
    "text": "familiar with doing that already some people are some people who work with fourth are it's not gonna be a good time",
    "start": "2054050",
    "end": "2061550"
  },
  {
    "text": "right you just want to be able to copy the code and do the thing so this this",
    "start": "2061550",
    "end": "2067638"
  },
  {
    "text": "has one of the properties that I want in a programming language right as a close mapping from syntax to semantics the",
    "start": "2067639",
    "end": "2074090"
  },
  {
    "text": "data flow in the program matches the order of stuff that I write in the program and we have these interesting",
    "start": "2074090",
    "end": "2081440"
  },
  {
    "text": "these algebraic properties of programs themselves and what they mean so they",
    "start": "2081440",
    "end": "2086510"
  },
  {
    "text": "form what's called a mono ID where we have this associative operation of concatenating programs and semantically",
    "start": "2086510",
    "end": "2094760"
  },
  {
    "text": "they also form a Mon I'm honored where you have this associative operation of",
    "start": "2094760",
    "end": "2100609"
  },
  {
    "text": "composing the functions that those programs mean so what that means is we have a homomorphism from the syntax to",
    "start": "2100609",
    "end": "2108410"
  },
  {
    "text": "the semantics where the the empty program is the identity function and if",
    "start": "2108410",
    "end": "2113900"
  },
  {
    "text": "you take if you take two programs and",
    "start": "2113900",
    "end": "2119450"
  },
  {
    "text": "compose them their meaning is the same as if you take the meaning of both",
    "start": "2119450",
    "end": "2125240"
  },
  {
    "text": "programs and compose those alright so you can freely interoperate between these different levels of syntax and",
    "start": "2125240",
    "end": "2130609"
  },
  {
    "text": "semantics alright there's this tight relationship there and count of",
    "start": "2130609",
    "end": "2136730"
  },
  {
    "text": "languages can be can have this property at any level it might be lexical we're like in 4th",
    "start": "2136730",
    "end": "2144170"
  },
  {
    "text": "and factor you can literally concatenate any programs with it possibly with a",
    "start": "2144170",
    "end": "2150260"
  },
  {
    "text": "space between them but and and it should work right we're like something like an",
    "start": "2150260",
    "end": "2156920"
  },
  {
    "text": "opening curly brace is a meaningful function on its own in these languages right so you can split a program at any",
    "start": "2156920",
    "end": "2164450"
  },
  {
    "text": "point or they can be competitive at the term level where every expression denotes a function but you can't",
    "start": "2164450",
    "end": "2171440"
  },
  {
    "text": "necessarily subdivide every expression so kitten is like that so one of the",
    "start": "2171440",
    "end": "2178010"
  },
  {
    "text": "advantages of competitive languages is being able to factor out any repetition you want if you notice some some",
    "start": "2178010",
    "end": "2188350"
  },
  {
    "text": "repetition of some operations you can always always abstract that out using what's called factoring and that's why",
    "start": "2188350",
    "end": "2194090"
  },
  {
    "text": "there's a programming language called factor which is a competitive language so I took this example from the",
    "start": "2194090",
    "end": "2201530"
  },
  {
    "text": "concatenative dog wiki it's an example of factoring in factor so in a C like",
    "start": "2201530",
    "end": "2207440"
  },
  {
    "text": "language if we wanted to get the price of the top order of some customer then",
    "start": "2207440",
    "end": "2213020"
  },
  {
    "text": "we can just do that we can extract each fields in turn and we can do the same",
    "start": "2213020",
    "end": "2218900"
  },
  {
    "text": "thing in factor weeds we say read the orders fields get the first value read the price fields but suddenly when any",
    "start": "2218900",
    "end": "2227690"
  },
  {
    "text": "of these things can become it can be null our code becomes hairier right",
    "start": "2227690",
    "end": "2233420"
  },
  {
    "text": "certain languages have special built-in operators to deal with what happens if you know if things are no like a",
    "start": "2233420",
    "end": "2240710"
  },
  {
    "text": "question mark dot but they usually don't abstract everything that way they don't",
    "start": "2240710",
    "end": "2246590"
  },
  {
    "text": "have like a question mark subscript so in practice you need to do things like this long so on the bottom is the",
    "start": "2246590",
    "end": "2253930"
  },
  {
    "text": "similar code in factor where we're explicitly saying ok take the customer",
    "start": "2253930",
    "end": "2259490"
  },
  {
    "text": "copy the reference to it when it's not null extract the orders and then proceed",
    "start": "2259490",
    "end": "2267680"
  },
  {
    "text": "with getting the first value from the orders if it's not now getting the price from the order if it's not known",
    "start": "2267680",
    "end": "2274130"
  },
  {
    "text": "but we have this repetitive pattern right and we can factor it out we just",
    "start": "2274130",
    "end": "2280200"
  },
  {
    "text": "introduced a macro that says okay I have this duplicate do a function when it's",
    "start": "2280200",
    "end": "2286890"
  },
  {
    "text": "true right when it's non null and I map those over a series of functions so now",
    "start": "2286890",
    "end": "2292380"
  },
  {
    "text": "I can write this straight line code it could actually even be written more simply than this but there's just a",
    "start": "2292380",
    "end": "2299190"
  },
  {
    "text": "high-level example where now this code have no repetition it just says what I",
    "start": "2299190",
    "end": "2304680"
  },
  {
    "text": "mean right I'm getting the orders and getting the first one I'm getting the price and",
    "start": "2304680",
    "end": "2310190"
  },
  {
    "text": "hey within that context any of those things might fail so the basic value",
    "start": "2310190",
    "end": "2318030"
  },
  {
    "start": "2315000",
    "end": "2360000"
  },
  {
    "text": "propositions of concatenate programming are pure functions are a pretty good",
    "start": "2318030",
    "end": "2323880"
  },
  {
    "text": "default unit of behavior for describing what programs do function composition is a good way of combining programs",
    "start": "2323880",
    "end": "2332210"
  },
  {
    "text": "juxtaposition just a single you know a space is turns out to be a convenient",
    "start": "2332210",
    "end": "2337800"
  },
  {
    "text": "notation for that and having a simple language with a strong mathematical",
    "start": "2337800",
    "end": "2344040"
  },
  {
    "text": "basis makes it easier to to develop",
    "start": "2344040",
    "end": "2349950"
  },
  {
    "text": "tools that are that we can have confidence are correct and for also",
    "start": "2349950",
    "end": "2355109"
  },
  {
    "text": "humans to reason about their code time",
    "start": "2355109",
    "end": "2361789"
  },
  {
    "start": "2360000",
    "end": "2532000"
  },
  {
    "text": "okay so time to get into implementation",
    "start": "2369960",
    "end": "2376500"
  },
  {
    "text": "of these languages how do they actually work on real hardware so in in fourth",
    "start": "2376500",
    "end": "2383810"
  },
  {
    "text": "typically what they do is what's called threaded code where each each",
    "start": "2383810",
    "end": "2390359"
  },
  {
    "text": "instruction in the program is compiled to a call instruction on the target hardware or compiled to an address of a",
    "start": "2390359",
    "end": "2402530"
  },
  {
    "text": "subroutine and then you have an interpretation loop that loads the",
    "start": "2402530",
    "end": "2407849"
  },
  {
    "text": "address jumps to that subroutine when the subroutine is complete it jumps back to the interpreter loop so you're basically abusing the the call",
    "start": "2407849",
    "end": "2417930"
  },
  {
    "text": "instruction on the CPU for interpreter dispatch and that works it's faster",
    "start": "2417930",
    "end": "2423510"
  },
  {
    "text": "generally than interpret than just interpretation but you can do better if you have more information so in fourth",
    "start": "2423510",
    "end": "2431700"
  },
  {
    "text": "the the stack is usually represented in memory when implemented on on register",
    "start": "2431700",
    "end": "2439020"
  },
  {
    "text": "machines and so there you have a lot of flexibility you can do dynamic",
    "start": "2439020",
    "end": "2444410"
  },
  {
    "text": "operations on the stack you can say this question mark doop function says copy",
    "start": "2444410",
    "end": "2449910"
  },
  {
    "text": "the value if it's nonzero so you have this it may or may not change the height",
    "start": "2449910",
    "end": "2456869"
  },
  {
    "text": "of the stack you have things like pick which takes a number on top of the stack",
    "start": "2456869",
    "end": "2462180"
  },
  {
    "text": "and copies the nth item on the stack but those are kind of frowned upon right you",
    "start": "2462180",
    "end": "2469980"
  },
  {
    "text": "want your code to have as much static data flow structure as you can so you can reason about it easily and so if you",
    "start": "2469980",
    "end": "2478680"
  },
  {
    "text": "have enough information about how many arguments functions take and return and",
    "start": "2478680",
    "end": "2484230"
  },
  {
    "text": "if you have type information then you can just do normal native compilation so",
    "start": "2484230",
    "end": "2490230"
  },
  {
    "text": "if even if you have functions like this which are it's just an if-then-else",
    "start": "2490230",
    "end": "2497359"
  },
  {
    "text": "function it's right it's an if then else expression but turned into a Combinator that takes",
    "start": "2497359",
    "end": "2503310"
  },
  {
    "text": "it takes a couple of blocks and takes an expression we we would need to compile",
    "start": "2503310",
    "end": "2511620"
  },
  {
    "text": "this differently based on the the stack effects of the functions that we pass to",
    "start": "2511620",
    "end": "2516990"
  },
  {
    "text": "it right because those could have different calling conventions they could expect values in different registers or",
    "start": "2516990",
    "end": "2522720"
  },
  {
    "text": "return values in in different places so we need like if we have enough type",
    "start": "2522720",
    "end": "2527970"
  },
  {
    "text": "information then we can generate those specializations and we can just do native compilation this is described in",
    "start": "2527970",
    "end": "2535550"
  },
  {
    "start": "2532000",
    "end": "3038000"
  },
  {
    "text": "the this this article by that's an ER ttle who he it basically goes over",
    "start": "2535550",
    "end": "2544580"
  },
  {
    "text": "there's there's this spectrum of representations between fully dynamic and fully static you can either have the",
    "start": "2544580",
    "end": "2551910"
  },
  {
    "text": "stack in memory entirely you can have the stack mostly in memory caching the",
    "start": "2551910",
    "end": "2557760"
  },
  {
    "text": "top value in register to reduce code size and improve performance you can",
    "start": "2557760",
    "end": "2563160"
  },
  {
    "text": "cache a bunch of values in registers but then you have to worry about what arrangement the values are in when you call functions so you have this finite",
    "start": "2563160",
    "end": "2570630"
  },
  {
    "text": "state machine of of possible calling conventions for each function or you can",
    "start": "2570630",
    "end": "2577440"
  },
  {
    "text": "convert to one of the usual native compilation techniques like single",
    "start": "2577440",
    "end": "2583140"
  },
  {
    "text": "static assignment static single information and continuation passing",
    "start": "2583140",
    "end": "2589920"
  },
  {
    "text": "style whatever you prefer whatever your compiler model is based on your language",
    "start": "2589920",
    "end": "2595310"
  },
  {
    "text": "and when you when you have enough information to do that essentially the",
    "start": "2595310",
    "end": "2600480"
  },
  {
    "text": "stack is just a way of reasoning about the program but it's not even an",
    "start": "2600480",
    "end": "2607260"
  },
  {
    "text": "implementation detail right it's just a notational idea where you write your",
    "start": "2607260",
    "end": "2613050"
  },
  {
    "text": "program as this flattened data flow graph but if you whether you stink what",
    "start": "2613050",
    "end": "2620190"
  },
  {
    "text": "do you whether you think about it as a stack or not it does it doesn't matter because it's not used as a stack",
    "start": "2620190",
    "end": "2626160"
  },
  {
    "text": "internally the restrictions on that are you can't have dynamic stack operations like copy if true you have to know",
    "start": "2626160",
    "end": "2636670"
  },
  {
    "text": "how many values things are consuming and producing statically so that you can",
    "start": "2636670",
    "end": "2642369"
  },
  {
    "text": "generate specializations as well but this just uses standard compilation",
    "start": "2642369",
    "end": "2647740"
  },
  {
    "text": "techniques right standard registered register allocation and the shuffling of items on the stack",
    "start": "2647740",
    "end": "2656049"
  },
  {
    "text": "if you represent that in memory you have a lot of memory traffic but if you have",
    "start": "2656049",
    "end": "2661450"
  },
  {
    "text": "entirely static data flow structure and that's stack shuffling is just statically arranging the data flow graph",
    "start": "2661450",
    "end": "2669040"
  },
  {
    "text": "so at runtime it might be a move but more likely than not it's just a no op",
    "start": "2669040",
    "end": "2676349"
  },
  {
    "text": "another source of implementation techniques is a linear Lisp from the",
    "start": "2677760",
    "end": "2682960"
  },
  {
    "text": "early 90s linear Elisabeth variety of Lisp where values are consumed when",
    "start": "2682960",
    "end": "2692680"
  },
  {
    "text": "they're used so variables are read once it's based on linear logic and Henry",
    "start": "2692680",
    "end": "2700359"
  },
  {
    "text": "Baker describes how it can be compiled efficiently to a stack machine architecture and in particular one of",
    "start": "2700359",
    "end": "2708069"
  },
  {
    "text": "his ideas was to reduce this von Neumann bottleneck of transferring values between the CPU and memory by keeping as",
    "start": "2708069",
    "end": "2716950"
  },
  {
    "text": "much as possible in this top of stack cache and he observed that this this",
    "start": "2716950",
    "end": "2724030"
  },
  {
    "text": "cache of values at the top of the stack uses the space on the chip design and",
    "start": "2724030",
    "end": "2729339"
  },
  {
    "text": "the memory bandwidth to main memory better than ordinary register and memory",
    "start": "2729339",
    "end": "2735549"
  },
  {
    "text": "machines von Neumann machines and the interesting thing about it is that the",
    "start": "2735549",
    "end": "2741390"
  },
  {
    "text": "this this cache of values on top of the stack is all live data as soon as",
    "start": "2741390",
    "end": "2746410"
  },
  {
    "text": "something is dropped it's gone it's freed and part of the reason for that is",
    "start": "2746410",
    "end": "2756280"
  },
  {
    "text": "that he goes on to describe most people say the the top of the fourth stack is a",
    "start": "2756280",
    "end": "2764680"
  },
  {
    "text": "set of locations where you can have where you can store values but in reality how you would implement it on",
    "start": "2764680",
    "end": "2770550"
  },
  {
    "text": "chip you you would never do it the same way that you that you do on a register machine you would just say okay I'm",
    "start": "2770550",
    "end": "2777060"
  },
  {
    "text": "going to connect the the ALU directly to the top of the stack I don't need any",
    "start": "2777060",
    "end": "2783840"
  },
  {
    "text": "addressing to read or write to those values and it also admits vectorization",
    "start": "2783840",
    "end": "2791700"
  },
  {
    "text": "and parallelization very easily you could just say well I've got you know",
    "start": "2791700",
    "end": "2798180"
  },
  {
    "text": "add all these all these values I've got multiplied I've got FFTs whatever did",
    "start": "2798180",
    "end": "2804570"
  },
  {
    "text": "you know signal processing operations and those are hooked up directly to the top of the stack which acts like a",
    "start": "2804570",
    "end": "2811800"
  },
  {
    "text": "register bank so you don't you don't need to vectorize your code it's already vectorized by the hardware so another",
    "start": "2811800",
    "end": "2823650"
  },
  {
    "text": "thing he observed was because the the call rate in these programs is so high right you factor everything into these",
    "start": "2823650",
    "end": "2829470"
  },
  {
    "text": "very small functions so you're constantly calling functions you you",
    "start": "2829470",
    "end": "2836790"
  },
  {
    "text": "benefit a lot from inlining first of all but also instead of using the call stack",
    "start": "2836790",
    "end": "2841950"
  },
  {
    "text": "to store the return address that you're going to return to you can just dump the contents of the function itself on the",
    "start": "2841950",
    "end": "2848100"
  },
  {
    "text": "return stack and use it as a queue of the next operations that you're going to",
    "start": "2848100",
    "end": "2853560"
  },
  {
    "text": "do and if you represent that as a cyclic shift register then what you get is this",
    "start": "2853560",
    "end": "2859740"
  },
  {
    "text": "interesting behavior at runtime where you for small loops you're essentially",
    "start": "2859740",
    "end": "2865200"
  },
  {
    "text": "just rotating this register and executing the operations in that buffer you're never going and decoding",
    "start": "2865200",
    "end": "2874080"
  },
  {
    "text": "instructions from memory and then jumping back and trying to do branch prediction and stuff and then there are",
    "start": "2874080",
    "end": "2884270"
  },
  {
    "text": "the other implementation details essentially depend on the language that",
    "start": "2884270",
    "end": "2889530"
  },
  {
    "text": "you want right you can you can box values which gives you a uniform",
    "start": "2889530",
    "end": "2899340"
  },
  {
    "text": "representation it it makes it easy to implement generic functions you don't need to generate type based",
    "start": "2899340",
    "end": "2906099"
  },
  {
    "text": "specializations of things and you can do separate compilation but the cons are everything is in indirection everything",
    "start": "2906099",
    "end": "2912910"
  },
  {
    "text": "has reference semantics you need a reference counting or a garbage collection if you can generate cycles so",
    "start": "2912910",
    "end": "2920190"
  },
  {
    "text": "the interesting thing about unboxing though is that it's easy as to do when",
    "start": "2920190",
    "end": "2925630"
  },
  {
    "text": "you have no types at all or very detailed static types because with no",
    "start": "2925630",
    "end": "2933339"
  },
  {
    "text": "types at all you can just say well I'm going to manipulate the stack directly and with fully static types you can say",
    "start": "2933339",
    "end": "2939549"
  },
  {
    "text": "well I can do that safely and you can",
    "start": "2939549",
    "end": "2944710"
  },
  {
    "text": "unbox things like arrays and closures you know you can put the elements directly on the stack and you could say",
    "start": "2944710",
    "end": "2950980"
  },
  {
    "text": "hey well when I've when I've got an array of four integers on the stack I",
    "start": "2950980",
    "end": "2957190"
  },
  {
    "text": "can always vectorize certain operations on that especially if you ensure that",
    "start": "2957190",
    "end": "2963190"
  },
  {
    "text": "it's aligned so like I said this this this vectorization instead of having to",
    "start": "2963190",
    "end": "2968230"
  },
  {
    "text": "incorporate it into your code it's something that's inherent in the structure that's available to the compiler so it can do very good",
    "start": "2968230",
    "end": "2975790"
  },
  {
    "text": "optimizations similarly with closures the vast majority of closures in in typical",
    "start": "2975790",
    "end": "2983799"
  },
  {
    "text": "programs are passed down the call stack they reference variables higher on the",
    "start": "2983799",
    "end": "2988960"
  },
  {
    "text": "call stack but they never they never escape so you never need to allocate",
    "start": "2988960",
    "end": "2995470"
  },
  {
    "text": "anything so if you can unbox closures that's that's a huge win for typical",
    "start": "2995470",
    "end": "3001140"
  },
  {
    "text": "functional programs so you just put the closure itself on the stack with a",
    "start": "3001140",
    "end": "3006390"
  },
  {
    "text": "function pointer and then when you want to call it you just coerce that and say okay now the values that are on the",
    "start": "3006390",
    "end": "3012930"
  },
  {
    "text": "stack are just on the stack and I pop the function pointer and jump and there",
    "start": "3012930",
    "end": "3017940"
  },
  {
    "text": "I go off to the races and if you can't if you do have to box things you can",
    "start": "3017940",
    "end": "3024420"
  },
  {
    "text": "often get away with copy-on-write or reference counting you don't need that if you don't have mutation you can't",
    "start": "3024420",
    "end": "3030569"
  },
  {
    "text": "generate cycles so that always suffices to reclaim all the garbage and you can",
    "start": "3030569",
    "end": "3036089"
  },
  {
    "text": "add GC on top that if you want so are we I'm just",
    "start": "3036089",
    "end": "3047070"
  },
  {
    "start": "3038000",
    "end": "3051000"
  },
  {
    "text": "gonna quickly go over static types and how they work in a concatenate language",
    "start": "3047070",
    "end": "3052670"
  },
  {
    "start": "3051000",
    "end": "3128000"
  },
  {
    "text": "most competitive languages are dynamically types or untyped so dynamic",
    "start": "3052670",
    "end": "3060450"
  },
  {
    "text": "typing means there's there's some kind of runtime type tag that describes how",
    "start": "3060450",
    "end": "3067230"
  },
  {
    "text": "operations work factor is is very dynamic in a sort of small talky way",
    "start": "3067230",
    "end": "3073200"
  },
  {
    "text": "where everything is an object and functions are actually messages on",
    "start": "3073200",
    "end": "3078420"
  },
  {
    "text": "objects PostScript you've got different stacks for different types of values",
    "start": "3078420",
    "end": "3085430"
  },
  {
    "text": "fourth is is untyped in sort of the same sense as an assembly language where you",
    "start": "3085430",
    "end": "3091560"
  },
  {
    "text": "can just freely reinterpret the the values in memory as whatever you",
    "start": "3091560",
    "end": "3096960"
  },
  {
    "text": "whatever you choose and it's your responsibility to get it right there have been a handful of forth",
    "start": "3096960",
    "end": "3104940"
  },
  {
    "text": "implementations that have static type checking but cat in 2006 was the first",
    "start": "3104940",
    "end": "3110720"
  },
  {
    "text": "container of language that actually had a full static type inference but nobody",
    "start": "3110720",
    "end": "3117000"
  },
  {
    "text": "else was working on cat after a while the website has gone away so I started",
    "start": "3117000",
    "end": "3124590"
  },
  {
    "text": "working on kitten a few years ago to sort of fill the void and sort of the",
    "start": "3124590",
    "end": "3131880"
  },
  {
    "text": "first thing that you try when you're doing static typing and concatenate language is to just say okay well every",
    "start": "3131880",
    "end": "3139470"
  },
  {
    "text": "function takes some number of inputs and it returns some number of outputs and I",
    "start": "3139470",
    "end": "3144750"
  },
  {
    "text": "can reason about the types in in terms of just that but then you realize that",
    "start": "3144750",
    "end": "3150110"
  },
  {
    "text": "you can't do any polymorphism over how many things there are how many things",
    "start": "3150110",
    "end": "3155430"
  },
  {
    "text": "you're talking about so instead of a single call instruction that says hey call this function and just do whatever",
    "start": "3155430",
    "end": "3161070"
  },
  {
    "text": "it does you have to have a whole family of functions says okay I'm calling a",
    "start": "3161070",
    "end": "3166140"
  },
  {
    "text": "function with one input one output or I wanted to put two outputs and so on and that sucks so we don't do that well",
    "start": "3166140",
    "end": "3185190"
  },
  {
    "start": "3174000",
    "end": "3246000"
  },
  {
    "text": "if you I mean if you want to give a static type to these operations right",
    "start": "3185190",
    "end": "3190200"
  },
  {
    "text": "and also fourth is generally not higher order like so yeah but if you had a",
    "start": "3190200",
    "end": "3198900"
  },
  {
    "text": "higher order fourth where you you're pushing functions onto the stack this",
    "start": "3198900",
    "end": "3205019"
  },
  {
    "text": "this call operator that that takes that function and calls it on the remainder",
    "start": "3205019",
    "end": "3211200"
  },
  {
    "text": "of the stack how do you give a static type to that it's like if you just say",
    "start": "3211200",
    "end": "3216930"
  },
  {
    "text": "well functions take some number of inputs and some number of outputs and",
    "start": "3216930",
    "end": "3222029"
  },
  {
    "text": "you don't have any way of talking about variable numbers of values not quite I'm",
    "start": "3222029",
    "end": "3240630"
  },
  {
    "text": "not quite sure we understand it took a figure we can talk after so the the next",
    "start": "3240630",
    "end": "3247999"
  },
  {
    "start": "3246000",
    "end": "3354000"
  },
  {
    "text": "the next logical step and and what what cat did and what kitten does is to",
    "start": "3247999",
    "end": "3255119"
  },
  {
    "text": "represent the stack as a product type which is a chain of nested tuples and",
    "start": "3255119",
    "end": "3260809"
  },
  {
    "text": "then you can talk about being polymorphic over the rest of the stack so like dupe for example it takes a",
    "start": "3260809",
    "end": "3271140"
  },
  {
    "text": "stack of some type it takes a value of some type and it returns that that same",
    "start": "3271140",
    "end": "3277319"
  },
  {
    "text": "stack with two copies of that value on top right and for call you have a stack",
    "start": "3277319",
    "end": "3285539"
  },
  {
    "text": "an input stack and output stack if you have an input stack with a closure that",
    "start": "3285539",
    "end": "3291809"
  },
  {
    "text": "tells you how to get from the input to the output then you can get to the output and one of the curious things",
    "start": "3291809",
    "end": "3298680"
  },
  {
    "text": "also about like examining kind of programming that I found is that",
    "start": "3298680",
    "end": "3304339"
  },
  {
    "text": "all of the basic operators are related to something that you do in logic or with proof so the call operator is is",
    "start": "3304339",
    "end": "3311630"
  },
  {
    "text": "modus ponens right you if you have a state and you have a proof that it",
    "start": "3311630",
    "end": "3316819"
  },
  {
    "text": "implies a new state in the form of a closure then you can get to the new state right and writing all of these",
    "start": "3316819",
    "end": "3327789"
  },
  {
    "text": "these stack variables in type signatures all the time is super unwieldy you don't",
    "start": "3327789",
    "end": "3332930"
  },
  {
    "text": "want to do it all the time especially because most functions don't need to have this polymorphism over the stack",
    "start": "3332930",
    "end": "3337940"
  },
  {
    "text": "they just ignore it entirely and only operate on a few inputs and outputs so",
    "start": "3337940",
    "end": "3344359"
  },
  {
    "text": "we can add some syntactic sugar and say well if you're not doing anything very interesting with the stack then we have",
    "start": "3344359",
    "end": "3351349"
  },
  {
    "text": "a way for you to elide these variables but some of the challenges of doing this",
    "start": "3351349",
    "end": "3358339"
  },
  {
    "start": "3354000",
    "end": "3476000"
  },
  {
    "text": "are every single function is polymorphic over the part of the stack that it",
    "start": "3358339",
    "end": "3363739"
  },
  {
    "text": "doesn't doesn't touch so that means that when you pass a function to another",
    "start": "3363739",
    "end": "3369769"
  },
  {
    "text": "function it needs to be generic over the stack there as well so here for example",
    "start": "3369769",
    "end": "3376249"
  },
  {
    "text": "with map you can't just say well it's it's got some stack and the the function",
    "start": "3376249",
    "end": "3383089"
  },
  {
    "text": "that it takes also takes that stack because you need to be able to call that function that you're mapping over the",
    "start": "3383089",
    "end": "3388460"
  },
  {
    "text": "list on different states of the stack at different times while you're mapping over the list so you need this this",
    "start": "3388460",
    "end": "3395900"
  },
  {
    "text": "functional argument to map to be generic as well which means that what you have",
    "start": "3395900",
    "end": "3401660"
  },
  {
    "text": "is a higher rank polymorphism higher rank polymorphic function type",
    "start": "3401660",
    "end": "3406749"
  },
  {
    "text": "fortunately we can we can type check this there's there's a great paper",
    "start": "3406749",
    "end": "3411950"
  },
  {
    "text": "complete and easy bi-directional type checking for higher rank polymorphism that goes over how to check these types",
    "start": "3411950",
    "end": "3417430"
  },
  {
    "text": "you can't do inference in the general case but in practice what I do in kitten",
    "start": "3417430",
    "end": "3424190"
  },
  {
    "text": "is just have a single type signature per function and then the entire body of the function can be inferred which is",
    "start": "3424190",
    "end": "3431660"
  },
  {
    "text": "something that most people are willing to accept and do I was I going with this",
    "start": "3431660",
    "end": "3443070"
  },
  {
    "text": "oh yeah so in order to to actually implement this one of the challenges is",
    "start": "3443070",
    "end": "3448680"
  },
  {
    "text": "that because you have this stack polymorphism you need to be able to generate specializations because when",
    "start": "3448680",
    "end": "3456060"
  },
  {
    "text": "you have you have a higher-order function the that operates on the stack",
    "start": "3456060",
    "end": "3461340"
  },
  {
    "text": "somehow you need to know statically what it's going to do in order to be able to say okay well this function is consuming",
    "start": "3461340",
    "end": "3468240"
  },
  {
    "text": "a value and not returning anything whereas this function is not consuming anything but it's it's returning something things like that",
    "start": "3468240",
    "end": "3477740"
  },
  {
    "text": "another finally I suppose is when you're",
    "start": "3478290",
    "end": "3485660"
  },
  {
    "text": "when you're reasoning about static types most most languages don't have any way",
    "start": "3485660",
    "end": "3492570"
  },
  {
    "text": "of talking about side effects in terms of a static type system Haskell is probably the most popular counter",
    "start": "3492570",
    "end": "3498990"
  },
  {
    "text": "example where they said well okay we have this pure functional programming",
    "start": "3498990",
    "end": "3504540"
  },
  {
    "text": "language but we can't do anything with only pure functions like you can do things but you can't do anything so do",
    "start": "3504540",
    "end": "3514200"
  },
  {
    "text": "you just give up and say well our languages in pure a lot of languages do high school solution was to use monads",
    "start": "3514200",
    "end": "3520830"
  },
  {
    "text": "where you say if I if I have some side effecting action then I represent it as",
    "start": "3520830",
    "end": "3525990"
  },
  {
    "text": "a data structure and I say well the runtime runs it right I am pure I just",
    "start": "3525990",
    "end": "3531240"
  },
  {
    "text": "build the value but the runtime runs the value and then when you compile it through some trickery and isomorphisms",
    "start": "3531240",
    "end": "3539790"
  },
  {
    "text": "you just say well I'm going to compile it as straight-line imperative code under the hood but one of the problems",
    "start": "3539790",
    "end": "3547740"
  },
  {
    "text": "with monads is that they don't compose right so you can't always easily mix different kinds of effects like I have",
    "start": "3547740",
    "end": "3555180"
  },
  {
    "text": "some state I have some reading from the environment I have some non-determinism and depending on the order or I have",
    "start": "3555180",
    "end": "3563490"
  },
  {
    "text": "some ability to fail and depending on the order in which you compose those things as monads using",
    "start": "3563490",
    "end": "3569640"
  },
  {
    "text": "transformers they might not work as you expected they might be dependent on",
    "start": "3569640",
    "end": "3576809"
  },
  {
    "text": "order and one of the solutions that has been developed in the Haskell community",
    "start": "3576809",
    "end": "3582269"
  },
  {
    "text": "is what are called algebraic effects which turn out to lend themselves very nicely to concatenate languages because",
    "start": "3582269",
    "end": "3588660"
  },
  {
    "text": "they're composable so in Khitan you have this new line function which is prints a",
    "start": "3588660",
    "end": "3596039"
  },
  {
    "text": "new line and it requires this i/o permission which just says I might have",
    "start": "3596039",
    "end": "3603420"
  },
  {
    "text": "different effects each time you call me I'm not referentially transparent and",
    "start": "3603420",
    "end": "3609319"
  },
  {
    "text": "similarly you have when you when you combine functions you get all the",
    "start": "3609319",
    "end": "3616349"
  },
  {
    "text": "effects of all the things that you might call so if you have a function that might print or it might fail then it",
    "start": "3616349",
    "end": "3622589"
  },
  {
    "text": "needs permission to both print and failed assuming that you know print requires i/o and fail requires fail so",
    "start": "3622589",
    "end": "3631019"
  },
  {
    "text": "like I said it's compositional if you have a function that needs one permission and another function that",
    "start": "3631019",
    "end": "3636869"
  },
  {
    "text": "needs another then their composition needs both and this is a set of permissions it's commutative doesn't",
    "start": "3636869",
    "end": "3643230"
  },
  {
    "text": "matter which order it goes in this was inspired by a language from Microsoft",
    "start": "3643230",
    "end": "3649289"
  },
  {
    "text": "research called coca by Don Lyon and it's also a higher order it's also",
    "start": "3649289",
    "end": "3656220"
  },
  {
    "text": "polymorphic so whereas in Haskell you have this problem of you you have a pure",
    "start": "3656220",
    "end": "3662970"
  },
  {
    "text": "function that you can map over a list but you can't I trying to say it if",
    "start": "3662970",
    "end": "3673109"
  },
  {
    "text": "you're mapping a pure function over a list you use map if you're mapping an impure function over a list you use a monadic map map m and that's the case",
    "start": "3673109",
    "end": "3681750"
  },
  {
    "text": "for every single operation that might be pure or it might be impure so even",
    "start": "3681750",
    "end": "3687329"
  },
  {
    "text": "though you can be polymorphic over which effect you're using by being polymorphic over some monad you can't be polymorphic",
    "start": "3687329",
    "end": "3693569"
  },
  {
    "text": "over whether you're using in effect right unless you explicitly say I'm using the null effect which is lame so",
    "start": "3693569",
    "end": "3703530"
  },
  {
    "text": "in this system you you can just have this this permission variable which",
    "start": "3703530",
    "end": "3709820"
  },
  {
    "text": "might be left fully polymorphic and in which case you can instantiate it to",
    "start": "3709820",
    "end": "3714840"
  },
  {
    "text": "know safely you can just default it to know so this system of permissions can",
    "start": "3714840",
    "end": "3723000"
  },
  {
    "text": "enforce effects not only what a function is allowed to do but also Co effects what the function is what constraints a",
    "start": "3723000",
    "end": "3731130"
  },
  {
    "text": "function can impose on its environment so for example constraints on what",
    "start": "3731130",
    "end": "3737700"
  },
  {
    "text": "platform or API version or something you're running on and then you have a",
    "start": "3737700",
    "end": "3743340"
  },
  {
    "text": "handler that that runs the permission and of course this can be used for",
    "start": "3743340",
    "end": "3749880"
  },
  {
    "text": "optimizations basically if I have you",
    "start": "3749880",
    "end": "3755220"
  },
  {
    "text": "know I map a function over a list I map another function over list if if both",
    "start": "3755220",
    "end": "3760830"
  },
  {
    "text": "those functions are pure then I can fuse those into a single pass whereas if they",
    "start": "3760830",
    "end": "3766830"
  },
  {
    "text": "have effects that don't commute like printing to the screen then I can't do",
    "start": "3766830",
    "end": "3772650"
  },
  {
    "text": "that fusion so in summary the catechol",
    "start": "3772650",
    "end": "3779490"
  },
  {
    "text": "programming is something that I like and think is cool and think that you should think is cool it's it's simple its",
    "start": "3779490",
    "end": "3787230"
  },
  {
    "text": "elegant and it has a bunch of surprising connections to all these deep areas of",
    "start": "3787230",
    "end": "3792330"
  },
  {
    "text": "computer science and I think it you know it must mean something right so it's",
    "start": "3792330",
    "end": "3799620"
  },
  {
    "text": "cool because the in addition to being elegant it also emits efficient",
    "start": "3799620",
    "end": "3804780"
  },
  {
    "text": "implementation not only on real hardware but also you can devise hard",
    "start": "3804780",
    "end": "3810870"
  },
  {
    "text": "hypothetical hardware that's even better for these languages it's it's immutable",
    "start": "3810870",
    "end": "3816960"
  },
  {
    "text": "to these exotic machines that we want to talk about like Stuckart architectures",
    "start": "3816960",
    "end": "3823920"
  },
  {
    "text": "like the green arrays highly concurrent processors or reversible and quantum",
    "start": "3823920",
    "end": "3830040"
  },
  {
    "text": "computers which we may see more of in the future as we as we care about power consumption and quantum computing",
    "start": "3830040",
    "end": "3837550"
  },
  {
    "text": "and and these languages are easy to use right they're easy to reason about what",
    "start": "3837550",
    "end": "3843670"
  },
  {
    "text": "code does to modify code and refactor programs and to write to write tools",
    "start": "3843670",
    "end": "3851560"
  },
  {
    "text": "that operate on programs with confidence that they're correct and it as I as I",
    "start": "3851560",
    "end": "3857500"
  },
  {
    "text": "briefly explained it naturally supports static typing and effect typing so if you care about static types you can have",
    "start": "3857500",
    "end": "3863620"
  },
  {
    "text": "them and it's it's pretty good you can do inference and things like that",
    "start": "3863620",
    "end": "3868830"
  },
  {
    "text": "hey I'm done [Applause]",
    "start": "3868830",
    "end": "3876790"
  },
  {
    "text": "you",
    "start": "3881390",
    "end": "3883450"
  }
]