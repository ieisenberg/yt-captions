[
  {
    "start": "0",
    "end": "5620"
  },
  {
    "text": "OK. I guess, let's start it. So welcome back. So today's lecture is going\nto be on asymmetric numeral",
    "start": "5620",
    "end": "13710"
  },
  {
    "text": "systems. So let's just go over\nthe quiz from last time. So last time, we learnt\nabout Arithmetic coding.",
    "start": "13710",
    "end": "20730"
  },
  {
    "text": "And the quiz question was\nagain around a Bernoulli random variable, which we have\nbeen now seeing quite a lot,",
    "start": "20730",
    "end": "27810"
  },
  {
    "text": "where probability of A is p\nand probability of B is just 1 minus p. And you were asked to consider\ntwo symbols AB and BA, both",
    "start": "27810",
    "end": "38010"
  },
  {
    "text": "of them to be encoded\nusing Arithmetic coding. And the first part was, do\nthe codewords for AB and BA",
    "start": "38010",
    "end": "46710"
  },
  {
    "text": "have the same code length?  Yeah. OK, I see a couple of nodding\nheads and that's indeed correct.",
    "start": "46710",
    "end": "56160"
  },
  {
    "text": "I think most of\nyou got this right. In our case, both probability\nof AB is going to be p times 1",
    "start": "56160",
    "end": "65349"
  },
  {
    "text": "minus p, which is same\nas probability of BA. This is if you want to write it.",
    "start": "65349",
    "end": "73420"
  },
  {
    "text": "And as Shubham discussed\nin last lecture, the codeword length just depends\non the interval length, which",
    "start": "73420",
    "end": "79450"
  },
  {
    "text": "depends on the probability. So in this case, both\nof them will have the exact same codeword length.",
    "start": "79450",
    "end": "85660"
  },
  {
    "text": "And then the follow-up\nquestion was like, does our Arithmetic coder\noutput the same codeword?",
    "start": "85660",
    "end": "92290"
  },
  {
    "text": "Yeah? The 1.1, the minor point is the\nupper bound of the code length",
    "start": "92290",
    "end": "98440"
  },
  {
    "text": "depends on the project. In practice, for a\nreal Arithmetic coder,",
    "start": "98440",
    "end": "103510"
  },
  {
    "text": "the code lengths might be\ndifferent by up to two-bits. So that's why in\nthe question I think",
    "start": "103510",
    "end": "108880"
  },
  {
    "text": "we added a statement\nthat you have to assume an idealized version\nof the Arithmetic coder. Otherwise, it's not\nactually strictly true.",
    "start": "108880",
    "end": "116590"
  },
  {
    "text": "Yeah. Thank you. Yeah, good point. Is that clear?",
    "start": "116590",
    "end": "122120"
  },
  {
    "text": "So what Shubham just said\nis like, in the actual-- if you remember like the\ncodeword length actually was--",
    "start": "122120",
    "end": "128764"
  },
  {
    "start": "128764",
    "end": "141270"
  },
  {
    "text": "so this was like the bound\nfor our codeword length. And so you'd actually need\nan idealized compressor,",
    "start": "141270",
    "end": "149010"
  },
  {
    "text": "which can do this. And in this particular\ncase, you can work out the exact probabilities.",
    "start": "149010",
    "end": "154770"
  },
  {
    "text": "OK. Yeah, continuing the\nsecond part was like, do they output\nthe same codeword.",
    "start": "154770",
    "end": "160950"
  },
  {
    "text": "And the answer there\nis obviously false. They are both-- if we look at\nthe zero-one line interval,",
    "start": "160950",
    "end": "168989"
  },
  {
    "text": "AB and BA would go for\nthe different regions.",
    "start": "168990",
    "end": "174520"
  },
  {
    "text": "Sorry, we just expanded out. So your BA would\nbe in this region,",
    "start": "174520",
    "end": "184580"
  },
  {
    "text": "whereas your AB\nwould be expanded out in this particular region.",
    "start": "184580",
    "end": "190070"
  },
  {
    "text": "And so they are just\ndifferent codewords. Quite straightforward.",
    "start": "190070",
    "end": "196750"
  },
  {
    "text": "Any doubts on that one? No. OK. So continuing on\nthe second part,",
    "start": "196750",
    "end": "202000"
  },
  {
    "text": "so then we basically gave you\nsome probability distribution over symbols and gave\nthe probabilities.",
    "start": "202000",
    "end": "210190"
  },
  {
    "text": "And then given an\ninput bitstream and an input of length 3, we\nask what's the decoded sequence.",
    "start": "210190",
    "end": "217320"
  },
  {
    "text": "So it's a very standard\nArithmetic decoding. You guys just had to go\nback and redo what we learnt",
    "start": "217320",
    "end": "222909"
  },
  {
    "text": "in the class. So in this case, I've already\nconverted this bitstream corresponds to 0.609375.",
    "start": "222910",
    "end": "231940"
  },
  {
    "text": "And so all you need\nto do is repeat-- sorry, repeat the\ndecoding procedure.",
    "start": "231940",
    "end": "239980"
  },
  {
    "text": "So A contains 0.5\nmass, B contains 0.25,",
    "start": "239980",
    "end": "247810"
  },
  {
    "text": "and similarly, C contains\n0.25, and your number is somewhere here.",
    "start": "247810",
    "end": "254180"
  },
  {
    "text": "So the first symbol\nyou will output is B. And then you zoom\nin and you repeat, again,",
    "start": "254180",
    "end": "260680"
  },
  {
    "text": "divided into-- for three intervals\nand find the point. And if you keep doing\nthat, you basically",
    "start": "260680",
    "end": "267370"
  },
  {
    "text": "get the BAC as your\noutput codeword. ",
    "start": "267370",
    "end": "275830"
  },
  {
    "text": "OK. Any questions on Arithmetic\ncoding before we get started with ANS?",
    "start": "275830",
    "end": "283169"
  },
  {
    "text": "Cool. Before we start, I just\nwant to give a shout out. Most of these slides are\nsimilar from the last year.",
    "start": "283170",
    "end": "290190"
  },
  {
    "text": "And so I just wanted\nto give him credit. OK. So last class, we learned\nabout Arithmetic coding.",
    "start": "290190",
    "end": "297120"
  },
  {
    "text": "And there, we learned about\nthat given any distribution p, your Arithmetic coder\nachieves optimal compression.",
    "start": "297120",
    "end": "304380"
  },
  {
    "text": "And one really\nimportant point there was what Arithmetic\ncoding allows is to separate the model\nand entropy coding part.",
    "start": "304380",
    "end": "311430"
  },
  {
    "text": "So you can come up with a best\nmodel for whatever distributed-- whatever system you have.",
    "start": "311430",
    "end": "318420"
  },
  {
    "text": "You can come up with the\nprobability for those blocks. And then the entropy\ncoding part takes care of ensuring that\nthe lengths basically",
    "start": "318420",
    "end": "325830"
  },
  {
    "text": "have this bound, which we\njust looked at in the class.",
    "start": "325830",
    "end": "331659"
  },
  {
    "text": "So basically, it allows you\nto come up with a good model separately, and then\njust use the code",
    "start": "331660",
    "end": "337950"
  },
  {
    "text": "as is, which was not something\nwe were able to do in Huffman or Shannon or any of\nthe previous codes,",
    "start": "337950",
    "end": "345300"
  },
  {
    "text": "which we looked at. This also meant that\nit can work very well with changing distribution p.",
    "start": "345300",
    "end": "351330"
  },
  {
    "text": "In fact, you can come up with\nadaptive algorithms, which adapt to your changing\ndata distribution using",
    "start": "351330",
    "end": "357390"
  },
  {
    "text": "Arithmetic coding. And that's going to be a\ntopic, which we'll learn in-- which we'll get to, I think,\nin two lectures from now.",
    "start": "357390",
    "end": "363330"
  },
  {
    "text": "We'll show some\nconcrete examples there.  Yeah, we had-- there are\nvarious variants of arithmetic",
    "start": "363330",
    "end": "371050"
  },
  {
    "text": "coding in practice, which\nyou will find mostly depends on how we break down\nthe ties, how we basically",
    "start": "371050",
    "end": "376990"
  },
  {
    "text": "have an efficient implementation\nof the encoder and decoder. ",
    "start": "376990",
    "end": "383620"
  },
  {
    "text": "And basically, Arithmetic\ncoders are used everywhere. So again, we'll see\nmore and more examples",
    "start": "383620",
    "end": "389560"
  },
  {
    "text": "of this in future lectures. But then what's the issue? So these were discovered\nsome time back in 1970s.",
    "start": "389560",
    "end": "397780"
  },
  {
    "text": "So are we done? Is lossless compression\na solved problem? Interestingly, no.",
    "start": "397780",
    "end": "403210"
  },
  {
    "text": "So again, I think Shubham talked\nabout it in the last lecture, but if you look at\nthe compression,",
    "start": "403210",
    "end": "408430"
  },
  {
    "text": "so this is bits per\nsymbol, lower is better, Arithmetic coding does much\nbetter than Huffman coding.",
    "start": "408430",
    "end": "413860"
  },
  {
    "text": "Again, it was because you can\nimagine the whole block length-- whole data is part\nof the block length.",
    "start": "413860",
    "end": "419320"
  },
  {
    "text": "But interestingly, when you\ncompare the speed of Arithmetic and Huffman, both\nthe encode speed",
    "start": "419320",
    "end": "425950"
  },
  {
    "text": "is lower, as well\nas the decode speed is lower, and\nactually quite lower. And dependent on\nthe application,",
    "start": "425950",
    "end": "432670"
  },
  {
    "text": "you might actually\nwant to trade off the compression you\ncan get with the speed because you might just have\nto deal with a lot of data",
    "start": "432670",
    "end": "438910"
  },
  {
    "text": "very fast. And these numbers are from\nCharles Bloom's blog, which",
    "start": "438910",
    "end": "444340"
  },
  {
    "text": "is very, very interesting. And so today, we'll learn\nabout rANS and tANS.",
    "start": "444340",
    "end": "451090"
  },
  {
    "text": "And if you look at the\ncompression for rANS and tANS, they have basically the same\nsimilar compression performance,",
    "start": "451090",
    "end": "458150"
  },
  {
    "text": "but they have much higher at\nleast decompression speed. We'll come to the encode speed.",
    "start": "458150",
    "end": "465110"
  },
  {
    "text": "But if you look at the\ndecompression speed, they have much higher magnitude. So if you were to compare\nsomething like tANS and Huffman,",
    "start": "465110",
    "end": "473240"
  },
  {
    "text": "they basically have very\nsimilar decode speed. tANS has much higher encode\nspeed than Arithmetic,",
    "start": "473240",
    "end": "480530"
  },
  {
    "text": "while it performs\nalmost similarly though with some slight\noverhead compared to Arithmetic",
    "start": "480530",
    "end": "486380"
  },
  {
    "text": "in this particular example. And this is the reason why we\nwant to even study these codes.",
    "start": "486380",
    "end": "492440"
  },
  {
    "text": "These are really efficient.  And basically-- so\nthese were discovered,",
    "start": "492440",
    "end": "498990"
  },
  {
    "text": "I think, around 2014. And if you look at\nany compressors today,",
    "start": "498990",
    "end": "504120"
  },
  {
    "text": "they basically use-- a lot of practical compressors\ntoday use some version of ANS.",
    "start": "504120",
    "end": "510509"
  },
  {
    "text": "So ANS is basically a class-- it's a class of compressors. It's not really a\nsingle compressor.",
    "start": "510510",
    "end": "516209"
  },
  {
    "text": "And for example, rANS\nis one version, tANS-- r stands for range,\nt stands for table.",
    "start": "516210",
    "end": "522178"
  },
  {
    "text": "These are like two extremes\nof this family of compressors, but there are various\nvariants of ANS out there.",
    "start": "522179",
    "end": "529740"
  },
  {
    "text": "And basically, they have\nreplaced Arithmetic coding and Huffman coding\nin various places",
    "start": "529740",
    "end": "535050"
  },
  {
    "text": "depending on the\napplication requirement. So for example,\nrANS is basically",
    "start": "535050",
    "end": "540060"
  },
  {
    "text": "just a drop in replacement\nfor Arithmetic, but it's going to be faster. So if you care about the\ncompression performance,",
    "start": "540060",
    "end": "546029"
  },
  {
    "text": "you might want to do\nthis while getting advantages over the speed. Similarly, tANS is actually a\ndrop in replacement for Huffman.",
    "start": "546030",
    "end": "554040"
  },
  {
    "text": "But now, in its case, it's\nalmost as fast as Huffman, but it gets much\nbetter compression.",
    "start": "554040",
    "end": "562180"
  },
  {
    "text": "So it's like depending\non your application, these algorithms are\ndirectly driven to be--",
    "start": "562180",
    "end": "568720"
  },
  {
    "text": "they have the best properties\nof Huffman or Arithmetic.",
    "start": "568720",
    "end": "574019"
  },
  {
    "text": "OK. So now that we\nunderstand like this-- there is something missing\nin the kind of code--",
    "start": "574020",
    "end": "581180"
  },
  {
    "text": "in kind of encoding strategies\nwhich we have learned and there exists\nsomething, let's try to understand it a little\nbetter like, how it works.",
    "start": "581180",
    "end": "588620"
  },
  {
    "text": "So this has a very funky name. It's called asymmetric\nnumeral system, which in itself is a good\nquestion, like why do you call",
    "start": "588620",
    "end": "595820"
  },
  {
    "text": "it asymmetric numeral system. But even before we start with\nasymmetric numeral system,",
    "start": "595820",
    "end": "601520"
  },
  {
    "text": "let's start with\nasymmetric numeral system example, which actually all\nof us have seen in real life.",
    "start": "601520",
    "end": "608690"
  },
  {
    "text": "So suppose you have\ninputs as digits, just single digits, 0 to 9.",
    "start": "608690",
    "end": "614510"
  },
  {
    "text": "And let's say you\nwant to encode this. So some data stream, which\ncomes from the alphabet 0 to 9.",
    "start": "614510",
    "end": "620810"
  },
  {
    "text": "So let's say your data\ninput is 3, 2, 4, 1, 5. OK.",
    "start": "620810",
    "end": "626089"
  },
  {
    "text": "Can you form a single\nnumber x, which represents this data input? ",
    "start": "626090",
    "end": "635259"
  },
  {
    "text": "I heard a yeah. Sorry. Yeah. How would you do that? ",
    "start": "635260",
    "end": "641570"
  },
  {
    "text": "How would you represent-- if\nyou knew these were just digits, how would you represent\nthis as a single state",
    "start": "641570",
    "end": "647600"
  },
  {
    "text": "and tell your friend\nyou would use this? So the answer, you would use\nit as a digit of one number.",
    "start": "647600",
    "end": "656279"
  },
  {
    "text": "Exactly. You can encode\nthis as just 32415.",
    "start": "656280",
    "end": "663090"
  },
  {
    "text": "And if you think about\nwhat this 32415 really is-- what was the encoding\noperation you did?",
    "start": "663090",
    "end": "669899"
  },
  {
    "text": "Can somebody answer that? ",
    "start": "669900",
    "end": "676745"
  },
  {
    "text": "Sorry?  Yeah. So the answer was use the base\n10, which is exactly the idea",
    "start": "676745",
    "end": "685250"
  },
  {
    "text": "here like, you will use\nbase 10, but now you have to think about your data\nwill be input as a stream rate.",
    "start": "685250",
    "end": "691699"
  },
  {
    "text": "So we are looking into a\nstreaming kind of code. So you would start with 3,\nbut exactly like you said,",
    "start": "691700",
    "end": "700070"
  },
  {
    "text": "we'll see how we can form this. So let's say you start with 3. So that was the only thing, you\nwould just represent it as 3.",
    "start": "700070",
    "end": "707660"
  },
  {
    "text": "Now let's say you received\nthe second symbol 3 comma 2. So the way you would do this is\njust multiply it with 10, add 2.",
    "start": "707660",
    "end": "717230"
  },
  {
    "text": "That's 32. That's exactly the decimal\n10 expansion of this thing.",
    "start": "717230",
    "end": "722360"
  },
  {
    "text": "Now let's say the third\nsymbol you receive is 4. So one way to think\nof it is, again,",
    "start": "722360",
    "end": "729230"
  },
  {
    "text": "like decimal expansion, 3\ntimes 100, 2 times 10 plus 4,",
    "start": "729230",
    "end": "734240"
  },
  {
    "text": "but you could have also\nthought of this as just 32 multiplied by 10 plus 4.",
    "start": "734240",
    "end": "741605"
  },
  {
    "text": " And does this give you an idea\nof basically forming a streaming",
    "start": "741605",
    "end": "749990"
  },
  {
    "text": "encoder for this thing? ",
    "start": "749990",
    "end": "755790"
  },
  {
    "text": "So the idea is very\nsimple, at each point, you maintain some initial state.",
    "start": "755790",
    "end": "761500"
  },
  {
    "text": "That's the only thing\nyou are maintaining. When you receive\nthe first input 3,",
    "start": "761500",
    "end": "766870"
  },
  {
    "text": "you just multiply the\nprevious state by 10 and add the new input. That's the only\nthing we were doing.",
    "start": "766870",
    "end": "773290"
  },
  {
    "text": "That's the decimal expansion\nof, so as to say, this thing. And you keep\nupdating your state. So when you receive 3,\nyour next state is 3.",
    "start": "773290",
    "end": "781450"
  },
  {
    "text": "After you receive 2, it's\n32 and so on and so forth. So 320 plus 4, 3240 plus 1.",
    "start": "781450",
    "end": "789040"
  },
  {
    "text": "And you keep doing that to\nget the final state, 32415.",
    "start": "789040",
    "end": "796199"
  },
  {
    "text": "Now suppose your friend comes\nto you and gives you this state and asks you, what\nwas the symbols",
    "start": "796200",
    "end": "803100"
  },
  {
    "text": "which were encoding-- encoded? Can you do that? ",
    "start": "803100",
    "end": "811370"
  },
  {
    "text": "Do exactly the next question. Yeah. ",
    "start": "811370",
    "end": "820430"
  },
  {
    "text": "Exactly. So the solution\nwhich he gave was-- I can start--",
    "start": "820430",
    "end": "826460"
  },
  {
    "text": "I'll start with this, sorry,\n32145, as my initial state.",
    "start": "826460",
    "end": "832920"
  },
  {
    "text": "I'll divide it by 10 and\ncalculate the modulus operand.",
    "start": "832920",
    "end": "840029"
  },
  {
    "text": "And this will give me-- sorry. This will give me 32145.",
    "start": "840030",
    "end": "848570"
  },
  {
    "text": "And then I can keep\nrepeating this operation. So in this particular\ncase, the by 10",
    "start": "848570",
    "end": "855530"
  },
  {
    "text": "operation gives you\nthe previous state. So this was the previous\nstate from which",
    "start": "855530",
    "end": "860779"
  },
  {
    "text": "you got your new state. And the modulus operand\ngives you the symbol. ",
    "start": "860780",
    "end": "868579"
  },
  {
    "text": "But now you see\nsomething interesting. When you do that, you will\nactually get 5 first, then 4,",
    "start": "868580",
    "end": "875589"
  },
  {
    "text": "then 1, then 2, then 3. So basically, your decoding runs\nin exactly the same fashion,",
    "start": "875590",
    "end": "884740"
  },
  {
    "text": "like we just talked about. ",
    "start": "884740",
    "end": "891310"
  },
  {
    "text": "OK, your decoding runs\nin the exact same fashion we just talked about. So you just do modulo 10.",
    "start": "891310",
    "end": "898210"
  },
  {
    "text": "Sorry, you just find the integer\npart as well as the remainder, and you keep recovering back\nthe state, which you had,",
    "start": "898210",
    "end": "905950"
  },
  {
    "text": "and the symbol, which\nwas encoded the last. So when you start with 32145,\nyou will first get a symbol as 5",
    "start": "905950",
    "end": "913570"
  },
  {
    "text": "and the previous state as 3214. Again, you divide\nthis by 10, 3214. You continue this.",
    "start": "913570",
    "end": "920170"
  },
  {
    "text": "And you know where to\nstop because either you were told the number of\nsymbol or you get back to some initial state\nwhere you started from.",
    "start": "920170",
    "end": "927400"
  },
  {
    "text": "So our encoding process started\nfrom s equals to 0, you recover that, and you can stop that, OK,\nI got back to my initial state.",
    "start": "927400",
    "end": "934240"
  },
  {
    "text": " OK, nice.",
    "start": "934240",
    "end": "939690"
  },
  {
    "text": "So now if we were to\nwrite this as a decoding step and an encoding\nstep, what did we do?",
    "start": "939690",
    "end": "948730"
  },
  {
    "text": "We actually did nothing. So you are maintaining a state,\nwhich you are going to output.",
    "start": "948730",
    "end": "956360"
  },
  {
    "text": "Yeah, we are\nmaintaining a state, which we are going to output. Whenever you encode a symbol,\nyou multiply the previous state",
    "start": "956360",
    "end": "961880"
  },
  {
    "text": "by 10, and then you\nadded the symbol. During decoding, you\nstart with some state x.",
    "start": "961880",
    "end": "969190"
  },
  {
    "text": "You decode the symbol by first\ntaking the modulo operand. And then you update the\nstate by just dividing it,",
    "start": "969190",
    "end": "976240"
  },
  {
    "text": "by taking the\ninteger part by 10. And then your decode\nstep kind of needs",
    "start": "976240",
    "end": "981970"
  },
  {
    "text": "to return both the symbol\nas well as the state so that you can\ncontinue this step.",
    "start": "981970",
    "end": "990149"
  },
  {
    "text": "Nice. And like we said,\nin this procedure,",
    "start": "990150",
    "end": "995490"
  },
  {
    "text": "the symbols which you get\nare in opposite order. So when you encode it, you\nwent from encoding 3 to 2 to 1",
    "start": "995490",
    "end": "1003140"
  },
  {
    "text": "to 4 to 5. But when you are decoding, you\nare coming in opposite order. ",
    "start": "1003140",
    "end": "1009630"
  },
  {
    "text": "And then each step,\nyou are able to recover the exact same state, which\nwere used during the encoding.",
    "start": "1009630",
    "end": "1016290"
  },
  {
    "text": "So when you went from\nencoding, you went from-- if you just look at the state,\nyou went from 0 to 3 to 32",
    "start": "1016290",
    "end": "1022440"
  },
  {
    "text": "to 3214 to 32145, but the\ndecoding was a reverse process.",
    "start": "1022440",
    "end": "1027959"
  },
  {
    "text": "You started with\n32145 and each step you recovered the same state. ",
    "start": "1027960",
    "end": "1035219"
  },
  {
    "text": "Are we clear? All right. ",
    "start": "1035219",
    "end": "1040530"
  },
  {
    "text": "So far, very simple,\nvery simple idea. All of us have used this in some\nfashion one way or the other.",
    "start": "1040530",
    "end": "1047699"
  },
  {
    "text": "So this is exactly like the\nsymmetric numeral system encoder. There is one last piece missing.",
    "start": "1047700",
    "end": "1054450"
  },
  {
    "text": "We never converted our\nthings to any bit arrays. We just left it at this\nnumber, this state to be.",
    "start": "1054450",
    "end": "1060210"
  },
  {
    "text": "Encoded So the last\nstep is basically just transmitting the final state\nx in binary using something",
    "start": "1060210",
    "end": "1068010"
  },
  {
    "text": "like ceil of log2 x plus 1 bits\nand like similar idea as what",
    "start": "1068010",
    "end": "1073500"
  },
  {
    "text": "Shubham discussed last time. And so if you now look at\nthe complete encoding step--",
    "start": "1073500",
    "end": "1078600"
  },
  {
    "text": "so remember this was\nour base encoding step, which was just multiplying\nby 10 and adding the symbol.",
    "start": "1078600",
    "end": "1084900"
  },
  {
    "text": "And then if you have a data\ninput, which you want to encode, you will start with some initial\nstate, which was 0 in our case,",
    "start": "1084900",
    "end": "1092309"
  },
  {
    "text": "like when we started. And then for each\nsymbol in data input, you just encode your symbol\nand you update your state.",
    "start": "1092310",
    "end": "1100290"
  },
  {
    "text": "And finally, you just\noutput the binary form",
    "start": "1100290",
    "end": "1105570"
  },
  {
    "text": "of whatever your state is. So at this point, we\nhave a complete encoder.",
    "start": "1105570",
    "end": "1111530"
  },
  {
    "text": "It gives you a bitstream\nout, and you can losslessly use to recover the\noriginal bitstream.",
    "start": "1111530",
    "end": "1116929"
  },
  {
    "text": " And then when you\nare decoding, you",
    "start": "1116930",
    "end": "1122870"
  },
  {
    "text": "are just reversing each step. Encoder and decoder are\nexact reverse of each other.",
    "start": "1122870",
    "end": "1128630"
  },
  {
    "text": "So the decode\nstep, first of all, you are converted into\nsome uint from the bits,",
    "start": "1128630",
    "end": "1133970"
  },
  {
    "text": "so that you get\nyour final state. And then, again, you\nhave your symbols. And for all your\nsymbols, you will",
    "start": "1133970",
    "end": "1139850"
  },
  {
    "text": "do this decode step\nover the state, returning your symbol\nand state, and you",
    "start": "1139850",
    "end": "1145429"
  },
  {
    "text": "will append the\nsymbols in a list, and you will keep doing that. It's occurring in a\nstreaming fashion.",
    "start": "1145430",
    "end": "1151130"
  },
  {
    "text": "Finally, the thing which\nyou need to be careful about is you need to\nreverse the symbols. Otherwise, the order of symbols\nin which you are returning",
    "start": "1151130",
    "end": "1157880"
  },
  {
    "text": "things would be wrong. And now in this case, we have\nan encoder and a decoder,",
    "start": "1157880",
    "end": "1164550"
  },
  {
    "text": "which are exactly mirror\nimage of each other. You can ensure that\nthey will always do lossless encoding decoding.",
    "start": "1164550",
    "end": "1171510"
  },
  {
    "text": " OK. So we have a\nlossless compressor.",
    "start": "1171510",
    "end": "1177279"
  },
  {
    "text": " OK. Even before we go there, even\nbefore we go to the next slide,",
    "start": "1177280",
    "end": "1186110"
  },
  {
    "text": "any ideas about what\nkind of compression rates is this compressor\nable to achieve?",
    "start": "1186110",
    "end": "1192395"
  },
  {
    "start": "1192395",
    "end": "1200290"
  },
  {
    "text": "So as a hint, let's just\nlook at the encoding step.",
    "start": "1200290",
    "end": "1206720"
  },
  {
    "text": "What are you doing? So your symbols are always in-- ",
    "start": "1206720",
    "end": "1215650"
  },
  {
    "text": "your symbols are always 1\nof 0, 1 to, whatever, 9, but what about x?",
    "start": "1215650",
    "end": "1222520"
  },
  {
    "text": "As you keep encoding more and\nmore and more and more symbols, what's happening to x? ",
    "start": "1222520",
    "end": "1236970"
  },
  {
    "text": "It's very simple, no tricks. It keeps on growing. It keeps on growing. By how much?",
    "start": "1236970",
    "end": "1242580"
  },
  {
    "text": " Approximately 10. Exactly.",
    "start": "1242580",
    "end": "1248160"
  },
  {
    "text": "So now what you're doing is your\nstate is going to 10 times state x at each step approximately.",
    "start": "1248160",
    "end": "1255720"
  },
  {
    "text": "And your state is\ncontinuously growing. So this number x is always--",
    "start": "1255720",
    "end": "1261840"
  },
  {
    "text": "after a point, it's always\ngoing to start dominating s.",
    "start": "1261840",
    "end": "1266960"
  },
  {
    "text": "So roughly, for each symbol,\nthe price you are paying",
    "start": "1266960",
    "end": "1273409"
  },
  {
    "text": "is to encode a number, which is\n10 times the previous number. ",
    "start": "1273410",
    "end": "1279890"
  },
  {
    "text": "And so you are\npaying roughly log 2 to the base 10 extra\nbits per symbol.",
    "start": "1279890",
    "end": "1288174"
  },
  {
    "text": " Now this only happens once you\nhave encoded a few of them.",
    "start": "1288175",
    "end": "1295240"
  },
  {
    "text": "The first few symbols,\nthis won't be true. But you'll reach that stage\nvery fast because your symbol is",
    "start": "1295240",
    "end": "1300320"
  },
  {
    "text": "just limited in 0 to 10, whereas\nremember, in our example, your state keeps on--",
    "start": "1300320",
    "end": "1305750"
  },
  {
    "text": "just keeps on growing. ",
    "start": "1305750",
    "end": "1310780"
  },
  {
    "text": "And this is exactly the idea. So at each step, your state\nx is just becoming 10 times",
    "start": "1310780",
    "end": "1316690"
  },
  {
    "text": "the previous. And so roughly per\nsymbol, you are paying these many extra bits.",
    "start": "1316690",
    "end": "1322165"
  },
  {
    "text": " Correct? ",
    "start": "1322165",
    "end": "1329170"
  },
  {
    "text": "And so in this particular\ncase, a compressor actually is an optimal compressor for\nsymbols, which are in 0 to 9,",
    "start": "1329170",
    "end": "1338200"
  },
  {
    "text": "if we assume that the symbols\nwere uniformly distributed. ",
    "start": "1338200",
    "end": "1344640"
  },
  {
    "text": "Because no matter\nwhat the symbol is you are paying roughly lock to-- lock 10 to the base two\nextra bits to encode it,",
    "start": "1344640",
    "end": "1352440"
  },
  {
    "text": "which will be the entropy\nin this particular case. ",
    "start": "1352440",
    "end": "1360030"
  },
  {
    "text": "Great. So in some sense,\nwe have already-- we have found a very\nnice compressor,",
    "start": "1360030",
    "end": "1366240"
  },
  {
    "text": "which works well for\nuniformly distributed symbols. You can think of how\nyou can generalize it",
    "start": "1366240",
    "end": "1373250"
  },
  {
    "text": "from 10 to something else, like\nit need not be just 0 to 9. Any other numeral\nsystem would do for you.",
    "start": "1373250",
    "end": "1380060"
  },
  {
    "text": " So yeah. So that's good. But this compressor is\nonly optimal if you have--",
    "start": "1380060",
    "end": "1389480"
  },
  {
    "text": "basically each of these\nsymbols have probability 0.1. It's uniformly distributed.",
    "start": "1389480",
    "end": "1397490"
  },
  {
    "text": "Does anyone have\nany guesses what we can do if let's say this\nwas a non-uniform distribution?",
    "start": "1397490",
    "end": "1405140"
  },
  {
    "start": "1405140",
    "end": "1421750"
  },
  {
    "text": "Any guesses? Why was this optimal? Let's just see this again. Let's leave it here.",
    "start": "1421750",
    "end": "1426850"
  },
  {
    "text": "So it was optimal\nbecause my state was being multiplied by 10\nat each step for each symbol,",
    "start": "1426850",
    "end": "1432850"
  },
  {
    "text": "no matter what the symbol was. Why 10?",
    "start": "1432850",
    "end": "1438730"
  },
  {
    "text": "Why does-- what does this imply? ",
    "start": "1438730",
    "end": "1447270"
  },
  {
    "text": "So another way to think about\nthis is the extra price I'm paying at each step was this.",
    "start": "1447270",
    "end": "1455460"
  },
  {
    "text": " And so far in the class,\nover almost every class",
    "start": "1455460",
    "end": "1463450"
  },
  {
    "text": "we have talked about, this is\nlike one thumb rule you live by. If you can get a compressor\nwhich gives you lens",
    "start": "1463450",
    "end": "1470860"
  },
  {
    "text": "around log 2 1 by p,\nyou have done the job. That's like the best thing you\ncan do with this compressor.",
    "start": "1470860",
    "end": "1478930"
  },
  {
    "text": "So now with this thing\nin mind, can somebody take a guess, what would you\ndo if these symbols were,",
    "start": "1478930",
    "end": "1486070"
  },
  {
    "text": "I don't know, coming with like\n0 was coming with probability 0 or p0, 1 was coming\nwith probability p1,",
    "start": "1486070",
    "end": "1495400"
  },
  {
    "text": "so on and so forth? ",
    "start": "1495400",
    "end": "1512950"
  },
  {
    "text": "Yeah, that's a good guess. So the guess which\nwas said here was",
    "start": "1512950",
    "end": "1518640"
  },
  {
    "text": "like, OK, maybe we want to\nmultiply by a smaller number. But why smaller why not bigger?",
    "start": "1518640",
    "end": "1524900"
  },
  {
    "text": "Let's start with--\nyes, I do want you to multiply\nby something else, but what was this\n10 really, right?",
    "start": "1524900",
    "end": "1531110"
  },
  {
    "text": "Again, it's not arbitrary. It's actually the value\nof log of 1 over p.",
    "start": "1531110",
    "end": "1538490"
  },
  {
    "text": "Sorry, it's value of 1 over p. So what you would\nwant to do for--",
    "start": "1538490",
    "end": "1544820"
  },
  {
    "text": "when you have\ndifferent probabilities really is somehow\nmultiply-- have some equation which can give\nyou maybe something like this.",
    "start": "1544820",
    "end": "1553100"
  },
  {
    "start": "1553100",
    "end": "1560350"
  },
  {
    "text": "And if you can do\nthat, then roughly whenever you get a symbol ps-- we'll discuss the details\nhow exactly to do that,",
    "start": "1560350",
    "end": "1567490"
  },
  {
    "text": "but let's see if we\nunderstand the idea. And if you can do\nthat, then no matter what symbol ps when\nit gets encoded,",
    "start": "1567490",
    "end": "1575440"
  },
  {
    "text": "you end up paying an extra\nprice of just log of 1",
    "start": "1575440",
    "end": "1581049"
  },
  {
    "text": "by p approximately, which is\nthe best thing you can do.",
    "start": "1581050",
    "end": "1587330"
  },
  {
    "start": "1587330",
    "end": "1595950"
  },
  {
    "text": "Is everyone with me? If we understand\nthis, we have at least",
    "start": "1595950",
    "end": "1601980"
  },
  {
    "text": "understood the basic idea of\nthe asymmetric numeral system and what we are trying to\ndesign, why it might work.",
    "start": "1601980",
    "end": "1609165"
  },
  {
    "text": " So again, instead of scaling\nx as 10 times x previous,",
    "start": "1609165",
    "end": "1616070"
  },
  {
    "text": "we want to scale it as something\nlike 1 over probability of s",
    "start": "1616070",
    "end": "1621220"
  },
  {
    "text": "at each step. ",
    "start": "1621220",
    "end": "1627510"
  },
  {
    "text": "OK. Is everyone with me? Cool. So now let's see how\nexactly rANS does this.",
    "start": "1627510",
    "end": "1635760"
  },
  {
    "text": "And to do that, let's\nintroduce some notations, which will be useful.",
    "start": "1635760",
    "end": "1641580"
  },
  {
    "text": "So we'll consider\nprobabilities which can be written in terms\nof integer frequencies.",
    "start": "1641580",
    "end": "1647075"
  },
  {
    "text": "What that means is like,\nif you have a probability, you can write it as frequency\nas by some integer m.",
    "start": "1647075",
    "end": "1653549"
  },
  {
    "text": "Let's take an example\njust to be clear. So let's say you\nhave alphabet, which is 0, 1, 2, and your\nprobabilities, which are 3 by 8,",
    "start": "1653550",
    "end": "1660990"
  },
  {
    "text": "3 by 8, 2 by 8. In this case, I'll\nrepresent this as a list of\nfrequencies, which is",
    "start": "1660990",
    "end": "1668250"
  },
  {
    "text": "3, 3, 2, which is just\ntaking the top terms here,",
    "start": "1668250",
    "end": "1677640"
  },
  {
    "text": "and M, which is the\ncommon denominator 8. ",
    "start": "1677640",
    "end": "1684360"
  },
  {
    "text": "And we'll also-- as we have\nseen I think even in Arithmetic",
    "start": "1684360",
    "end": "1690210"
  },
  {
    "text": "coding and before, something\nwhich is really nice is-- an object to keep track of\nis the cumulative probability",
    "start": "1690210",
    "end": "1698040"
  },
  {
    "text": "distribution. And we'll keep track of\nsomething parallel of that here. So we'll keep track of\nthe cumulative frequencies",
    "start": "1698040",
    "end": "1706289"
  },
  {
    "text": "essentially. OK. So the cumulative frequencies\nin our case is like--",
    "start": "1706290",
    "end": "1712500"
  },
  {
    "text": "so frequencies are\nfor A, 3, B, 3, C, 2.",
    "start": "1712500",
    "end": "1719580"
  },
  {
    "text": "And so our cumulative\nfrequency array-- is that visible? OK.",
    "start": "1719580",
    "end": "1724990"
  },
  {
    "text": "We'll start from\n0 plus you'll add the previous one, 3, plus\nyour add the previous one, 6.",
    "start": "1724990",
    "end": "1732150"
  },
  {
    "text": "So just summing the frequencies\nup until that point. So this object will\nbe useful as well.",
    "start": "1732150",
    "end": "1738840"
  },
  {
    "start": "1738840",
    "end": "1744950"
  },
  {
    "text": "And so this is-- so in code terms,\nsomebody was like,",
    "start": "1744950",
    "end": "1750100"
  },
  {
    "text": "they were not able to think how\ndo I write it in code terms. Like, OK, I understand. Approximately, I\nneed to multiply it",
    "start": "1750100",
    "end": "1756250"
  },
  {
    "text": "by 1 by probability s. But as we were seeing in\nsymmetrical numeral system,",
    "start": "1756250",
    "end": "1766450"
  },
  {
    "text": "we'll basically do\nthe exact same steps. So if you look at\nthe encode step, it's going to be\nthe exactly same.",
    "start": "1766450",
    "end": "1772780"
  },
  {
    "text": "You start with\nsome initial state for each symbol in data input. You run this base encode\nstep, which we are calling,",
    "start": "1772780",
    "end": "1779679"
  },
  {
    "text": "which takes in the previous\nstate and the symbol and updates the state. And finally, you are going to\nreturn the binary form of this.",
    "start": "1779680",
    "end": "1787045"
  },
  {
    "text": " And so the only thing\nwhich has changed",
    "start": "1787045",
    "end": "1792990"
  },
  {
    "text": "is this, base encode step,\nwhich was previously-- so previously, what was this?",
    "start": "1792990",
    "end": "1798890"
  },
  {
    "text": "So previously, it was just\n10 times x plus s return x.",
    "start": "1798890",
    "end": "1806275"
  },
  {
    "text": "Now we need to\nupdate this thing. ",
    "start": "1806275",
    "end": "1812740"
  },
  {
    "text": "So given this\nnotation, any ideas what we can do to get this?",
    "start": "1812740",
    "end": "1820419"
  },
  {
    "start": "1820420",
    "end": "1831690"
  },
  {
    "text": "It's not that hard. Yeah, go for it. Well, we can take the ceiling\nof one of a probability s",
    "start": "1831690",
    "end": "1838410"
  },
  {
    "text": "and then just apply the\nint, but I'm not sure how you would decode that. Perfect.",
    "start": "1838410",
    "end": "1843620"
  },
  {
    "text": "So the answer was we can maybe\ntake the ceiling of fs over m",
    "start": "1843620",
    "end": "1849080"
  },
  {
    "text": "instead of probably\ns, but we are not sure how do we decode that.",
    "start": "1849080",
    "end": "1854419"
  },
  {
    "text": "That's a great point,\nand we'll come to that. But this is the base encode\nstep in case of rANS.",
    "start": "1854420",
    "end": "1861919"
  },
  {
    "text": "And what I want you\nguys to-- so this is-- I'm giving it to you. I'm not, right now,\njustifying all parts of it.",
    "start": "1861920",
    "end": "1868590"
  },
  {
    "text": "But if you look at\nthe part which is just focusing on the x previous\none, what we are doing",
    "start": "1868590",
    "end": "1874820"
  },
  {
    "text": "is we are taking\nlike the modulo-- sorry, not modulo, the integer\ndivision with frequency",
    "start": "1874820",
    "end": "1880250"
  },
  {
    "text": "s and then multiplied by\nM, exactly what the student suggestion was.",
    "start": "1880250",
    "end": "1886389"
  },
  {
    "text": "I need to divide\nit by probability. Let me take a-- let me take the integer division\nby fs and then multiply it by M.",
    "start": "1886390",
    "end": "1894980"
  },
  {
    "text": "And then we add a bunch\nof other stuff, which we'll discuss in one second. ",
    "start": "1894980",
    "end": "1901850"
  },
  {
    "text": "But basically here, now you\nhave ensured your state roughly increases by 1 over\nps at each whenever",
    "start": "1901850",
    "end": "1910760"
  },
  {
    "text": "the symbol s is being encoded. ",
    "start": "1910760",
    "end": "1918200"
  },
  {
    "text": "Yeah. And so let's just\nfocus on this step now. Let's see.",
    "start": "1918200",
    "end": "1924060"
  },
  {
    "text": "Let's work it out together\nfor a few examples so that we really understand\nwhat just happened.",
    "start": "1924060",
    "end": "1929960"
  },
  {
    "text": "So this-- again, I'm repeating\nbecause I like to remember it.",
    "start": "1929960",
    "end": "1935240"
  },
  {
    "text": "Like this base step, it's\nalways good to go back to the symmetric numeral system\nto see how this is coming from.",
    "start": "1935240",
    "end": "1941330"
  },
  {
    "text": "So previously, it was x\nprevious times 10 plus symbol.",
    "start": "1941330",
    "end": "1948380"
  },
  {
    "text": "And so now this 10\npart, let's take-- this 10 part is being replaced\nby something like this,",
    "start": "1948380",
    "end": "1954679"
  },
  {
    "text": "and this plus symbol\npart has been replaced by something like this. ",
    "start": "1954680",
    "end": "1963639"
  },
  {
    "text": "Let's just work\nout some examples. And then we'll see\nif it makes sense, how we can use this to decode.",
    "start": "1963640",
    "end": "1968920"
  },
  {
    "text": " So let's work out the example\nfor this particular setting,",
    "start": "1968920",
    "end": "1975130"
  },
  {
    "text": "where let's say you had the\nalphabets, which we have been discussing, 0, 1, 2,\nand then your frequencies",
    "start": "1975130",
    "end": "1981429"
  },
  {
    "text": "were 3, 3, 2. M is 8. Cumulative\nprobabilities is this. And so let's try to work out the\nfinal encoding for 1, 0, 2, 1.",
    "start": "1981430",
    "end": "1992210"
  },
  {
    "text": "So let's start. So your initial state-- let me just see.",
    "start": "1992210",
    "end": "1998130"
  },
  {
    "text": "Yeah. OK, let's just do it. So your initial state is 0.",
    "start": "1998130",
    "end": "2003520"
  },
  {
    "text": "At next step, you want\nto encode input 1. So your-- let me use the same\nsymbols, which are used here.",
    "start": "2003520",
    "end": "2011679"
  },
  {
    "text": "So your initial state x is 0. S is symbol, x is the state.",
    "start": "2011680",
    "end": "2017409"
  },
  {
    "text": "So in the first step,\nlet's just-- when you are trying to encode\n1, so now you get symbol 1.",
    "start": "2017410",
    "end": "2023740"
  },
  {
    "text": "And so let's just work\nout the new state. So new state is going to be x\nprevious by frequency s, which",
    "start": "2023740",
    "end": "2030850"
  },
  {
    "text": "is just 3, in this case,\ntimes M plus cumulative of 1,",
    "start": "2030850",
    "end": "2037450"
  },
  {
    "text": "which in our case is 3, plus x\nprevious modulus of frequency s.",
    "start": "2037450",
    "end": "2046620"
  },
  {
    "text": "So just writing\ndown the operation not doing anything funky here,\njust like literally reading",
    "start": "2046620",
    "end": "2052687"
  },
  {
    "text": "all our symbols, which we\nhave formed, all our notations and just plugging it back. And so this gives your x as 3.",
    "start": "2052687",
    "end": "2059940"
  },
  {
    "text": "So after step one,\nyour new status is 3. So step zero, step one.",
    "start": "2059940",
    "end": "2067330"
  },
  {
    "text": "OK. Let's do step two now. So now the next symbol\nyou receive is 0. So your next symbol is 0.",
    "start": "2067330",
    "end": "2074489"
  },
  {
    "text": "Now you start from\nthe previous state. So your previous state is 3\nand your frequency is so far 0.",
    "start": "2074489",
    "end": "2082109"
  },
  {
    "text": "Let's just-- for 0, I'm going\nto pick the first element here. ",
    "start": "2082110",
    "end": "2090569"
  },
  {
    "text": "So for 0, the frequency is just\n3 times 8 plus my cumul s is 0.",
    "start": "2090570",
    "end": "2097980"
  },
  {
    "text": "And then again, it's 3\nmodulus 3, which is 0.",
    "start": "2097980",
    "end": "2103119"
  },
  {
    "text": "So this is 1, this is just 0,\nand so this gives your updated",
    "start": "2103120",
    "end": "2108340"
  },
  {
    "text": "state to be 8.  And then you can keep doing\nthis for each symbol, which",
    "start": "2108340",
    "end": "2115339"
  },
  {
    "text": "is being added. So at each step, you are\nupdating the previous state based on the new symbol,\nwhich is being received.",
    "start": "2115340",
    "end": "2121835"
  },
  {
    "text": " OK. So I'm working this\nout like for you,",
    "start": "2121835",
    "end": "2129530"
  },
  {
    "text": "but we have this worked out in\nthe slides in the neater format, if you like that, but yeah.",
    "start": "2129530",
    "end": "2135319"
  },
  {
    "text": "So this is just like going\nthrough the same operations, which we discussed just\nnow like, just each step.",
    "start": "2135320",
    "end": "2142580"
  },
  {
    "text": "And if you keep doing that,\nin this case, you'll get 101, let's say, as the final\nstate which is being encoded.",
    "start": "2142580",
    "end": "2151299"
  },
  {
    "text": "Before we go on,\nwe'll decode this, but let's try to see the same\nformula for something which",
    "start": "2151300",
    "end": "2157510"
  },
  {
    "text": "we have already seen, which is\nuniform distribution case over 0",
    "start": "2157510",
    "end": "2163450"
  },
  {
    "text": "to 10 or 0 to 9. Can someone work it out\nand tell me what it gives?",
    "start": "2163450",
    "end": "2170665"
  },
  {
    "start": "2170665",
    "end": "2194810"
  },
  {
    "text": "OK, I almost want to\nleave it as a homework. It's straight forward,\nputting down the numbers.",
    "start": "2194810",
    "end": "2201770"
  },
  {
    "text": "Actually, I'll do so. So you can just work it\nout once you go home. This will actually lead back\nto the exact thing, which",
    "start": "2201770",
    "end": "2208880"
  },
  {
    "text": "we have been seeing so far. This will lead down to x\nprevious times 10 plus s.",
    "start": "2208880",
    "end": "2217210"
  },
  {
    "text": "So this is-- and that basically\nwould happen because-- I'm giving away the answer.",
    "start": "2217210",
    "end": "2222520"
  },
  {
    "text": "This will always be 0, this will\nbe s, and this by frequency s",
    "start": "2222520",
    "end": "2227980"
  },
  {
    "text": "doesn't matter. So it's just multiplying by M. So I know this is fast.",
    "start": "2227980",
    "end": "2233220"
  },
  {
    "text": "Just work it out. It's very basic divisions. So whatever this\nbeast looking thing",
    "start": "2233220",
    "end": "2239339"
  },
  {
    "text": "we came up with, actually\nin the simpler case, leads to the exact\nsame thing, which where",
    "start": "2239340",
    "end": "2246600"
  },
  {
    "text": "we started our lecture from. ",
    "start": "2246600",
    "end": "2254250"
  },
  {
    "text": "OK. So far, so good, but now\nwe also have to figure out how to decode it uniquely.",
    "start": "2254250",
    "end": "2260790"
  },
  {
    "text": "I haven't really told\nyou how do we decode it. And before we start with that,\nlet's have some observation.",
    "start": "2260790",
    "end": "2267450"
  },
  {
    "text": "So this is our base\nencode step, again, something multiplied\nwith M, which",
    "start": "2267450",
    "end": "2275220"
  },
  {
    "text": "was 10 plus some other term. So let me just\nwrite it like that.",
    "start": "2275220",
    "end": "2281599"
  },
  {
    "text": "I'm going to call the first term\nblock ID and the second term slot. And so your block ID is\njust x previous modulo--",
    "start": "2281600",
    "end": "2290240"
  },
  {
    "text": "sorry, not modulo, integer\ndivision frequency s. So just this term, that's your\nblock ID, and everything else",
    "start": "2290240",
    "end": "2297710"
  },
  {
    "text": "is slot, this is called slot. So these are just\ntechnical term. You don't have to worry,\nbut this is a slot.",
    "start": "2297710",
    "end": "2305360"
  },
  {
    "text": "And so one way to think about\nwhat we just wrote like, the actual ANS formula, is\nwriting your state update",
    "start": "2305360",
    "end": "2311930"
  },
  {
    "text": "as block ID times\nM plus slot, which is very similar format of\nwhat we had previously.",
    "start": "2311930",
    "end": "2320430"
  },
  {
    "text": "But let's talk about this slot. What can you say\nabout this slot? ",
    "start": "2320430",
    "end": "2328593"
  },
  {
    "text": "It's between cumul s\nand cumul s plus 1. Excellent. So the suggestion I got was--\nso if you look at the slot,",
    "start": "2328593",
    "end": "2337580"
  },
  {
    "text": "so slot is just cumul s plus\nx previous mod of frequency s.",
    "start": "2337580",
    "end": "2346285"
  },
  {
    "text": " And so this term, since\nit's a modulus operation,",
    "start": "2346285",
    "end": "2352650"
  },
  {
    "text": "it's always going to be\nless than frequency s. ",
    "start": "2352650",
    "end": "2358460"
  },
  {
    "text": "And cumul s, also it's always\ngoing to be greater than 0.",
    "start": "2358460",
    "end": "2365500"
  },
  {
    "text": "So actually we got a nice tight\nlittle bound, which is-- sorry, it's always going to be\nless than frequency s.",
    "start": "2365500",
    "end": "2371110"
  },
  {
    "text": "And this term will always\nalso be greater than 0 because it's a\nmodulus operation.",
    "start": "2371110",
    "end": "2377760"
  },
  {
    "text": "So what we got was-- what we got\nright now is slot is always less",
    "start": "2377760",
    "end": "2383340"
  },
  {
    "text": "than-- actually, cumul\ns plus frequency, I can just write it as\ncumulative of the next symbol",
    "start": "2383340",
    "end": "2389340"
  },
  {
    "text": "because that's the\ndefinition of the cumulative. And it's always greater\nthan the cumulative of s.",
    "start": "2389340",
    "end": "2397230"
  },
  {
    "text": " Actually, there is\nan even looser bound",
    "start": "2397230",
    "end": "2403980"
  },
  {
    "text": "here, which you can follow,\nwhich is your cumul, the cumulative probabilities,\nwill always be less than M.",
    "start": "2403980",
    "end": "2413580"
  },
  {
    "text": "And the maximum value\nof the cumulative will always be less than the\ntotal sum of frequencies, which you have, because it's always\ngoing to miss the last symbol.",
    "start": "2413580",
    "end": "2422160"
  },
  {
    "text": "And it's always\ngoing to be greater than equals to 0 because your\ncumulative probability is",
    "start": "2422160",
    "end": "2427380"
  },
  {
    "text": "the sum of positive numbers. So these are strictly\nweaker than the one",
    "start": "2427380",
    "end": "2434960"
  },
  {
    "text": "which we worked out before. But now does this\ngive you a hint?",
    "start": "2434960",
    "end": "2440120"
  },
  {
    "text": "So now what we have\ngotten to combining 0.1",
    "start": "2440120",
    "end": "2445790"
  },
  {
    "text": "and 0.2 is that your x is block\nID times M plus slot, where",
    "start": "2445790",
    "end": "2458990"
  },
  {
    "text": "slot we know is always going\nto be between 0 and M. So",
    "start": "2458990",
    "end": "2470980"
  },
  {
    "text": "does this give a hint\nof what we can do next? How can we retrieve the\nslot versus block ID?",
    "start": "2470980",
    "end": "2476410"
  },
  {
    "text": " Exactly. So we'll divide by M.\nAnd so your slots--",
    "start": "2476410",
    "end": "2484990"
  },
  {
    "text": "OK. So again, all of\nthese are worked out in this slide, whatever we are\nworking together in the class.",
    "start": "2484990",
    "end": "2490330"
  },
  {
    "text": "So your slot is between\n0 and M. That basically tells that I can actually--",
    "start": "2490330",
    "end": "2497970"
  },
  {
    "text": "during the base decode step,\nwhich we now have to work out,",
    "start": "2497970",
    "end": "2503910"
  },
  {
    "text": "I can actually recover\nthe block ID and slot by just taking the modulo\noperation and the integer",
    "start": "2503910",
    "end": "2514200"
  },
  {
    "text": "part of division. And the only thing here\nwe used during decoding",
    "start": "2514200",
    "end": "2519890"
  },
  {
    "text": "was the fact that my\nslot is always between 0 and M and my encoding step was\nblock ID times M plus slot.",
    "start": "2519890",
    "end": "2527599"
  },
  {
    "text": " But we still haven't\nrecovered our symbol,",
    "start": "2527600",
    "end": "2533570"
  },
  {
    "text": "all the previous state. We just recovered\nslot, which was this whole big term,\ncumulative of something",
    "start": "2533570",
    "end": "2540410"
  },
  {
    "text": "plus state modulo operation\nwith some frequency.",
    "start": "2540410",
    "end": "2545910"
  },
  {
    "text": "So any idea once I\nknow the block id-- so now I know the block\nID and I know the slot.",
    "start": "2545910",
    "end": "2554119"
  },
  {
    "text": "How can I maybe recover\nthis symbol out of it? ",
    "start": "2554120",
    "end": "2562780"
  },
  {
    "text": "So I know the value of\nmy slot, which is also equals to cumulative of s\nplus this whole thing, x",
    "start": "2562780",
    "end": "2573390"
  },
  {
    "text": "previous modulo frequency s. ",
    "start": "2573390",
    "end": "2583700"
  },
  {
    "text": "Here's a hint.  We actually know\nsomething more about slot.",
    "start": "2583700",
    "end": "2589880"
  },
  {
    "text": "Slot is not only greater\nthan equals to 0 less than M,",
    "start": "2589880",
    "end": "2595069"
  },
  {
    "text": "but actually it's always greater\nthan equals to cumulative of s.",
    "start": "2595070",
    "end": "2601210"
  },
  {
    "text": "Sorry, let me just rewrite this. ",
    "start": "2601210",
    "end": "2610080"
  },
  {
    "text": "And less than equals\nto cumulative-- sorry, less than strictly\nof cumulative of s plus 1.",
    "start": "2610080",
    "end": "2616905"
  },
  {
    "text": " We just worked out\na tighter bound. ",
    "start": "2616905",
    "end": "2624740"
  },
  {
    "text": "Does this give you a hint\non how you can find the s? ",
    "start": "2624740",
    "end": "2636840"
  },
  {
    "text": "Again, none of these\nquestions are hard. Feel free to throw out\nwhatever the first thing comes in your mind.",
    "start": "2636840",
    "end": "2642040"
  },
  {
    "text": "It's OK. ",
    "start": "2642040",
    "end": "2649310"
  },
  {
    "text": "Yeah. OK. Anyone wants to build\nup on that answer? ",
    "start": "2649310",
    "end": "2658210"
  },
  {
    "text": "So for the first s, such that-- ",
    "start": "2658210",
    "end": "2664810"
  },
  {
    "text": "the last s, such that cumulative\ns is less than or equal to slot.",
    "start": "2664811",
    "end": "2671260"
  },
  {
    "text": "Cumulative s is-- exactly. So basically, the\npoint is your cumul",
    "start": "2671260",
    "end": "2677339"
  },
  {
    "text": "s is basically a monotonically\nincreasing array. So what I'm showing here\nis-- let's say this is--",
    "start": "2677340",
    "end": "2685730"
  },
  {
    "text": "actually, no, this is wrong. I need to start from 0.",
    "start": "2685730",
    "end": "2690930"
  },
  {
    "text": "OK. So your cumul s-- ",
    "start": "2690930",
    "end": "2697610"
  },
  {
    "text": "so this is, let's say,\nsymbol 0, symbol 1, symbol 2. At each point whenever\nyou encounter that symbol,",
    "start": "2697610",
    "end": "2704300"
  },
  {
    "text": "you are adding the\nfrequency of that symbol. And so once you know\nthat, I don't know,",
    "start": "2704300",
    "end": "2710960"
  },
  {
    "text": "slot basically is a number,\nwhich is always between cumul",
    "start": "2710960",
    "end": "2716839"
  },
  {
    "text": "of something, all\nyou need to find is the band in which\nthe slot lies really.",
    "start": "2716840",
    "end": "2723080"
  },
  {
    "text": "So we know that this is\nan increasing function, all you need to do is like find\nme the s, such that your slot is",
    "start": "2723080",
    "end": "2730970"
  },
  {
    "text": "actually greater than\nthe cumulative of that and less than the\ncumulative of next one. ",
    "start": "2730970",
    "end": "2738670"
  },
  {
    "text": "And cumulative actually\nis a sorted array. So this is where your computer\nscience search information",
    "start": "2738670",
    "end": "2746230"
  },
  {
    "text": "would also come into play. You can do this\nvery efficiently. But basically, the\nstep which you use is--",
    "start": "2746230",
    "end": "2753520"
  },
  {
    "text": "so again, you use this hint\nthat your cumul s between this and all you can do is\ndo a binary search.",
    "start": "2753520",
    "end": "2760990"
  },
  {
    "text": "All you need to do is like,\ndo a left biased binary search to find the symbol\ns, which is-- such",
    "start": "2760990",
    "end": "2768070"
  },
  {
    "text": "that cumul s is just less\nthan the slot, and then cumul s plus 1 is greater\nthan that slot.",
    "start": "2768070",
    "end": "2773664"
  },
  {
    "text": " And because of this exact\nproperty, which we worked out,",
    "start": "2773665",
    "end": "2781570"
  },
  {
    "text": "this is going to be unique. There's only going to\nbe one symbol, which is going to return that.",
    "start": "2781570",
    "end": "2786745"
  },
  {
    "start": "2786745",
    "end": "2792890"
  },
  {
    "text": "Are people with me? ",
    "start": "2792890",
    "end": "2797960"
  },
  {
    "text": "All right. So are we done? So now we know how to decode the\nsymbol, should we call it a day?",
    "start": "2797960",
    "end": "2806290"
  },
  {
    "text": " We need to know x_prev.",
    "start": "2806290",
    "end": "2812430"
  },
  {
    "text": "We need to know\nthe previous state. As we know, this is a\nsymbol by symbol operation. We recovered our s, but we\nalso need to uniquely determine",
    "start": "2812430",
    "end": "2820320"
  },
  {
    "text": "what our previous state was. Any ideas? So now by this point, by step\ntwo, we know what our s is.",
    "start": "2820320",
    "end": "2831130"
  },
  {
    "text": "Sorry. We know what our s is. We know the block ID,\nwhich is x previous integer",
    "start": "2831130",
    "end": "2842019"
  },
  {
    "text": "division of frequency s. And we also know our slot,\njust cumulative of s plus this.",
    "start": "2842020",
    "end": "2853869"
  },
  {
    "text": "I'm not going to rewrite\nthis, but you know the modulus at this point.",
    "start": "2853870",
    "end": "2860550"
  },
  {
    "text": "So can we work\nout the x previous",
    "start": "2860550",
    "end": "2865740"
  },
  {
    "text": "or do we need to\ndo something more?  if we multiply our\nblock ID by previous s,",
    "start": "2865740",
    "end": "2873528"
  },
  {
    "text": "we get back to where we\nwould [INAUDIBLE] for missing our reader. So [INAUDIBLE] remainders in\nour slot [INAUDIBLE] cumul",
    "start": "2873528",
    "end": "2882471"
  },
  {
    "text": "s to get that remainder part,\nget the whole [INAUDIBLE].. Exactly.",
    "start": "2882471",
    "end": "2887660"
  },
  {
    "text": "I'm not going to repeat. I'm going to-- actually,\nthis is where I'm just going to give you the answer. It's basically\ndirect manipulation",
    "start": "2887660",
    "end": "2895070"
  },
  {
    "text": "of terms at this point. All you need to do is\nrearrange your original term.",
    "start": "2895070",
    "end": "2902780"
  },
  {
    "text": "So remember, your\nencoding was x equals",
    "start": "2902780",
    "end": "2909960"
  },
  {
    "text": "to x previous by frequency s\nplus cumul s plus x previous mod",
    "start": "2909960",
    "end": "2923089"
  },
  {
    "text": "frequency s. ",
    "start": "2923090",
    "end": "2928565"
  },
  {
    "text": "You know this term because you\nhave figured out the symbol s. So you know exactly\nwhat cumul s is.",
    "start": "2928565",
    "end": "2934820"
  },
  {
    "text": "So at this point, you know the\nvalue of x previous modulus frequency is and you know the\nvalue of x previous integer",
    "start": "2934820",
    "end": "2943250"
  },
  {
    "text": "division of frequency is. So you can just rearrange\nthe terms to figure out what your x previous was.",
    "start": "2943250",
    "end": "2949740"
  },
  {
    "text": "And this is what\nit turns out to be. So just at this point, you\nare just rearranging the term",
    "start": "2949740",
    "end": "2956040"
  },
  {
    "text": "and using the fact\nthat you know the s, you know the exact\nvalue of cumul s and you're just using\nthe initial equation",
    "start": "2956040",
    "end": "2963269"
  },
  {
    "text": "to get back x previous. ",
    "start": "2963270",
    "end": "2970000"
  },
  {
    "text": "So great. So ideally, this should-- while we were working it out, it\nseems that it should work out.",
    "start": "2970000",
    "end": "2979240"
  },
  {
    "text": "In the sense, we should just-- we are just reversing\nthe steps very",
    "start": "2979240",
    "end": "2984670"
  },
  {
    "text": "similar to how we were doing in\nthe symmetric numeral systems. We are just reversing\nthe steps and recovering",
    "start": "2984670",
    "end": "2990039"
  },
  {
    "text": "symbols in opposite order\nand recovering the state. But let's work out an\nexample together just so",
    "start": "2990040",
    "end": "2996130"
  },
  {
    "text": "that I feel confident\nthat you guys understand, even though it's just redoing\nthe same maths operation.",
    "start": "2996130",
    "end": "3003990"
  },
  {
    "text": "Personally, I feel just redoing\nthese algorithms by hand give me a lot of intuitions on\nwhat's happening, even for maybe",
    "start": "3003990",
    "end": "3010440"
  },
  {
    "text": "simpler examples. So yeah, I encourage\nyou guys to do that.",
    "start": "3010440",
    "end": "3015820"
  },
  {
    "text": "So remember like in\nour previous case, we worked out the x final was\nthis corresponding to some bit",
    "start": "3015820",
    "end": "3022690"
  },
  {
    "text": "array. So it's like the\nsame running example we are working with, where\nI have three symbols A, B,",
    "start": "3022690",
    "end": "3028170"
  },
  {
    "text": "C with probability 3 by\n8, 3 by 8, and 2 by 8, and the cumulative frequencies\nfor them is 0, 3, 6.",
    "start": "3028170",
    "end": "3037610"
  },
  {
    "text": "And your final is 101. So let's try to work it out.",
    "start": "3037610",
    "end": "3042990"
  },
  {
    "text": "Let's just do maybe\none step together, and then I'll encourage\nyou guys to go home and do",
    "start": "3042990",
    "end": "3048210"
  },
  {
    "text": "the rest of them. OK, so step one,\nso x final is 101.",
    "start": "3048210",
    "end": "3058000"
  },
  {
    "text": "So again, we'll just repeat the\nsteps here, step one, step two, step three like, the three\nsteps we worked out together.",
    "start": "3058000",
    "end": "3065360"
  },
  {
    "text": "OK. So step one is getting\nthe block ID and slot. So your block ID and slot\nwill just be division by 8",
    "start": "3065360",
    "end": "3074560"
  },
  {
    "text": "because my M is 8. And let's see. So can somebody check that\nyour block ID would be 12",
    "start": "3074560",
    "end": "3082060"
  },
  {
    "text": "and slot will be 5? ",
    "start": "3082060",
    "end": "3087480"
  },
  {
    "text": "Yeah, seems about right. OK. So this is step one.",
    "start": "3087480",
    "end": "3092820"
  },
  {
    "text": "Now step two says find\nthe symbol s, such that my slot is in between\nthe cumul of the previous one,",
    "start": "3092820",
    "end": "3101280"
  },
  {
    "text": "and the next one. So our cumul s array is this. 5 belongs in between 3\nand 6, and so my symbol",
    "start": "3101280",
    "end": "3109860"
  },
  {
    "text": "would be this guy,\nthe second one. So my symbol is 1.",
    "start": "3109860",
    "end": "3116840"
  },
  {
    "text": "And that also means my cumul\ns, in this case, is just 3,",
    "start": "3116840",
    "end": "3122360"
  },
  {
    "text": "which is just the\ncumulative probability of 1. And then the step three is\njust working out this math.",
    "start": "3122360",
    "end": "3129920"
  },
  {
    "text": "So let's just do it. X previous is block ID, which\nis 12, times frequency of s,",
    "start": "3129920",
    "end": "3136700"
  },
  {
    "text": "3, plus slot. What's our slot? 5 minus cumul s 3.",
    "start": "3136700",
    "end": "3142610"
  },
  {
    "text": "So this gives 38. ",
    "start": "3142610",
    "end": "3149280"
  },
  {
    "text": "So the algorithm outputs-- so let me maybe rewrite it.",
    "start": "3149280",
    "end": "3154850"
  },
  {
    "text": " All right. So you return the symbol\nand previous state.",
    "start": "3154850",
    "end": "3161820"
  },
  {
    "text": "So your symbol return would be-- symbol is 1 and your\nprevious state is 38.",
    "start": "3161820",
    "end": "3168599"
  },
  {
    "text": " So now let's just--",
    "start": "3168600",
    "end": "3174819"
  },
  {
    "text": "OK, we can continue\ndoing this, and I encourage you guys to go\nhome and continue doing this.",
    "start": "3174820",
    "end": "3181829"
  },
  {
    "text": "But just as a reminder-- let's see where we\ndid the encoding. ",
    "start": "3181830",
    "end": "3193980"
  },
  {
    "text": "OK, so this is where\nwe did the encoding. We just worked out the first\nstep going back from 101.",
    "start": "3193980",
    "end": "3201720"
  },
  {
    "text": "And the symbol we\noutputted was one. And the previous state\nwe outputted was 38.",
    "start": "3201720",
    "end": "3208820"
  },
  {
    "text": "OK. So you see it's like\nthe exact backtracking. So the basic idea is, as\nyou keep adding symbols,",
    "start": "3208820",
    "end": "3215090"
  },
  {
    "text": "your state is increasing. And when you start decoding,\nyou start decreasing your state",
    "start": "3215090",
    "end": "3221720"
  },
  {
    "text": "and outputting back the\nsame symbol at each point. This was like, 1,\n0, or sorry, 1021.",
    "start": "3221720",
    "end": "3231430"
  },
  {
    "text": "And then while out\ncoming back, you will just output them\nin reverse order. ",
    "start": "3231430",
    "end": "3248430"
  },
  {
    "text": "So here I just\ndid only one step, but please go home, work out\nthis example, and ideally,",
    "start": "3248430",
    "end": "3254310"
  },
  {
    "text": "you should be able to recover\nall the previous steps. ",
    "start": "3254310",
    "end": "3262079"
  },
  {
    "text": "Any questions?  Asymmetric, as we said,\nit was [INAUDIBLE]..",
    "start": "3262080",
    "end": "3271170"
  },
  {
    "text": "Still, how is the encoding\nkey process so long to the exact same stage? So asymmetric was not for that.",
    "start": "3271170",
    "end": "3277609"
  },
  {
    "text": "It was because of\nnumeral systems. So symmetric numeral system is\nno matter what point you get,",
    "start": "3277610",
    "end": "3283520"
  },
  {
    "text": "they are multiplying it by 10. In our case, the\nthing which you are multiplying the previous\nstate with is very different.",
    "start": "3283520",
    "end": "3292160"
  },
  {
    "text": "It depends on the symbol,\nwhich is coming in. So if you were encoding 0\nto 10 with very different",
    "start": "3292160",
    "end": "3297822"
  },
  {
    "text": "probabilities, we'll be\nmultiplying each number by a very different amount. So that's kind of the\nasymmetricity part of it.",
    "start": "3297822",
    "end": "3304910"
  },
  {
    "text": "But actually, you need-- this is a very important\npoint, which you brought out. You need to ensure that\nas you are going forward",
    "start": "3304910",
    "end": "3311960"
  },
  {
    "text": "and backward, you reproduce\nthe exact same state because that's the\nreal point which",
    "start": "3311960",
    "end": "3317720"
  },
  {
    "text": "is ensuring the lawlessness. ",
    "start": "3317720",
    "end": "3329810"
  },
  {
    "text": "OK. And so this is just-- I've already opened it. This is just a link. So [INAUDIBLE],, whose name\nwe hear a lot, because he",
    "start": "3329810",
    "end": "3339130"
  },
  {
    "text": "co-designed the course\nwith us at past. He had written this\nblog post on ANS.",
    "start": "3339130",
    "end": "3345369"
  },
  {
    "text": "And this is just an interactive. So if you just want to play\nwith some symbol counts",
    "start": "3345370",
    "end": "3350560"
  },
  {
    "text": "and put string, see how\nthe state kind of expands, you can just go and play\nwith this kind of thing.",
    "start": "3350560",
    "end": "3356770"
  },
  {
    "text": "So I guess, in\nour case, it was-- I forgot. One second, let's\njust check it, 0102.",
    "start": "3356770",
    "end": "3369160"
  },
  {
    "text": "Can somebody remind me quickly\nwhat's the input string?",
    "start": "3369160",
    "end": "3374869"
  },
  {
    "text": " 1021.",
    "start": "3374870",
    "end": "3380680"
  },
  {
    "text": "Oh yeah, 1021. Thanks. So let's just put in 1021, comma\n0 comma 2 comma 1, and try it.",
    "start": "3380680",
    "end": "3391510"
  },
  {
    "text": "And you see we recover the\nstates which we were seeing. And you can play with different\nsymbols, different frequency.",
    "start": "3391510",
    "end": "3398020"
  },
  {
    "text": "I would encourage you guys to\nstill work by hand, so that-- but you can use this\ncode snippet interactive",
    "start": "3398020",
    "end": "3403990"
  },
  {
    "text": "to see if you are working\nout things right or not. And then when you decode it,\nyou start with some state.",
    "start": "3403990",
    "end": "3409840"
  },
  {
    "text": "So in our case-- why is this not opening up?",
    "start": "3409840",
    "end": "3415120"
  },
  {
    "start": "3415120",
    "end": "3421490"
  },
  {
    "text": "Interesting. For some reason, it's not\nallowing me to edit it. OK.",
    "start": "3421490",
    "end": "3426860"
  },
  {
    "text": "The point is you can\nchange the state here. I think I'm on iPad, so\nit's not allowing me.",
    "start": "3426860",
    "end": "3432050"
  },
  {
    "text": "And you can input the\nnumber of encoded symbols. And again, the output,\nwhich you'll start getting, is the states in reverse\norder and bits thrown out",
    "start": "3432050",
    "end": "3439997"
  },
  {
    "text": "in reverse order.  Yeah. So this is just a tool which\nyou guys can play with.",
    "start": "3439997",
    "end": "3448310"
  },
  {
    "text": "The link is in the slides. ",
    "start": "3448310",
    "end": "3456210"
  },
  {
    "text": "Let's see. OK. So this is now just a\ncombination of everything,",
    "start": "3456210",
    "end": "3461742"
  },
  {
    "text": "which we have learned so far. So just to summarize\nit one last time, the encoder works like this.",
    "start": "3461742",
    "end": "3468869"
  },
  {
    "text": "So you start with some\ninitial state for each symbol in the data input. You run some base encode step,\nwhich takes in state and symbol",
    "start": "3468870",
    "end": "3477830"
  },
  {
    "text": "and gives you updated state. And then the final\noutput of the encoder is this two binary, which just\nconverts it into a binary.",
    "start": "3477830",
    "end": "3486619"
  },
  {
    "text": "And the base encode step does\nthis block ID times M plus slot.",
    "start": "3486620",
    "end": "3493250"
  },
  {
    "text": "And then this is like\nthe combined decoder. And so at this\npoint, this is called",
    "start": "3493250",
    "end": "3498740"
  },
  {
    "text": "range ANS encoder and decoder. These are the operations. So during decoding, you\njust do the exact inverse.",
    "start": "3498740",
    "end": "3506329"
  },
  {
    "text": "So you convert bits\nto final state first. Then for the range in symbols,\nyou run the base encode step.",
    "start": "3506330",
    "end": "3513470"
  },
  {
    "text": "Your base encode\nstep has to return the symbol and the\nprevious state, and we just talked about\nhow we can recover that.",
    "start": "3513470",
    "end": "3520590"
  },
  {
    "text": "And finally, you need\nto return the reverse. This is important\nthat you are always",
    "start": "3520590",
    "end": "3525900"
  },
  {
    "text": "decoding in the reverse order.  OK.",
    "start": "3525900",
    "end": "3530930"
  },
  {
    "text": " So now if you think about--",
    "start": "3530930",
    "end": "3537240"
  },
  {
    "text": "how we motivated rANS? The first question\nwhich I asked you when we moved from\nsymmetric numeral systems",
    "start": "3537240",
    "end": "3543359"
  },
  {
    "text": "to asymmetric numeral\nsystems is, what's happening with the state?",
    "start": "3543360",
    "end": "3548970"
  },
  {
    "text": "So again, with same\nargument, your state now is increasing\nby approximately 1",
    "start": "3548970",
    "end": "3556290"
  },
  {
    "text": "over probability\nof your symbol s as your states keep increasing. And so the final state\ncan be represented",
    "start": "3556290",
    "end": "3563160"
  },
  {
    "text": "using approximately\nlog2 of x final bits.",
    "start": "3563160",
    "end": "3569140"
  },
  {
    "text": "Correct? And so the question\nfor you guys is, what's the approximate encode\nlength for an input sn?",
    "start": "3569140",
    "end": "3576000"
  },
  {
    "start": "3576000",
    "end": "3585090"
  },
  {
    "text": "So now suppose you have a\nstream of symbols, s1, s2, sn, which was like,\n1, 0, 2, 1 before,",
    "start": "3585090",
    "end": "3593520"
  },
  {
    "text": "what's the encode\nlength approximately? ",
    "start": "3593520",
    "end": "3604472"
  },
  {
    "text": "It would basically be the\nexpected value of 1, 2-- 1 over [? ps ?] [INAUDIBLE].",
    "start": "3604472",
    "end": "3612880"
  },
  {
    "text": "Exactly. Right. So now basically\nfor each symbol, as you are encoding sn\neven without block lengths,",
    "start": "3612880",
    "end": "3619690"
  },
  {
    "text": "so as to say involved like we\nwere seeing in Huffman code, you are basically\nmultiplying it--",
    "start": "3619690",
    "end": "3625660"
  },
  {
    "text": "let me write it with this. Yeah, you are\nmultiplying first symbol. When first symbol comes, you\nare multiplying x by 1 by ps1.",
    "start": "3625660",
    "end": "3634780"
  },
  {
    "text": "Second symbol comes, you are\nmultiplying it by ps2 roughly, given as 1 so on and so forth.",
    "start": "3634780",
    "end": "3640510"
  },
  {
    "text": "And so finally,\nthe rough length, which you get--\nwhich you will get,",
    "start": "3640510",
    "end": "3646089"
  },
  {
    "text": "is you are multiplying the whole\nsymbol by 1 over probability of the n-tuple of\nwhatever that symbol is,",
    "start": "3646090",
    "end": "3653440"
  },
  {
    "text": "and so your length is\njust log inverse of this. And again, tying back\nto our thumb rule,",
    "start": "3653440",
    "end": "3659849"
  },
  {
    "text": "this basically tells\nus, oh, we have suddenly found a very good\nencoder decoder",
    "start": "3659850",
    "end": "3666450"
  },
  {
    "text": "because it gives you something\nvery close to entropy. ",
    "start": "3666450",
    "end": "3671630"
  },
  {
    "text": "And so we are we are\nnot talking about-- so this is all a very\nhand-wavy argument, I know, but this is\nmore like, I guess,",
    "start": "3671630",
    "end": "3677990"
  },
  {
    "text": "in the spirit of the\ncourse for those of you who are like mathematically\nenthusiastic about how",
    "start": "3677990",
    "end": "3685960"
  },
  {
    "text": "to get very formal bounce for\nANS like, we have been doing",
    "start": "3685960",
    "end": "3691240"
  },
  {
    "text": "for arithmetic coding,\nwhere we saw that there was a two-bit overhead over whatever\nthe block length of your symbol",
    "start": "3691240",
    "end": "3696789"
  },
  {
    "text": "was or, in the case of\nHuffman, where it was 1. We can discuss it offline, but\nit's not trivial to analyze.",
    "start": "3696790",
    "end": "3705382"
  },
  {
    "text": "What I really want\nyou guys to take away from this whole discussion\nis that intuitively, it makes sense that this\ncompressor is somewhat optimal.",
    "start": "3705383",
    "end": "3715560"
  },
  {
    "text": "It can give you good\ncompression rates like Arithmetic\ncoding was giving. This was roughly the\nhand-wavy argument,",
    "start": "3715560",
    "end": "3721530"
  },
  {
    "text": "even in the case of\nArithmetic coding. ",
    "start": "3721530",
    "end": "3731840"
  },
  {
    "text": "OK. And something very interesting\nactually which we'll-- just to connect it to what you\nguys will see in future is--",
    "start": "3731840",
    "end": "3740750"
  },
  {
    "text": "so I think when I first saw it-- for most of the people I know,\nwhen they first saw rANS,",
    "start": "3740750",
    "end": "3746570"
  },
  {
    "text": "they had probably the same\nreaction as some of you like, where did\nthat equation come from, why does that cumul\ns plus mod blah, blah,",
    "start": "3746570",
    "end": "3755510"
  },
  {
    "text": "and then you somehow beautifully\ncome up with decoding mechanism where everything works out.",
    "start": "3755510",
    "end": "3760640"
  },
  {
    "text": "You just had those\nsomehow some bonds, which kind of solve everything.",
    "start": "3760640",
    "end": "3767240"
  },
  {
    "text": "In this discussion,\nwe went over-- I continuously gave\nyou hints, but now imagine you just somehow\nsurprisingly came up",
    "start": "3767240",
    "end": "3773450"
  },
  {
    "text": "with that one day to a\nfriend and say this works.",
    "start": "3773450",
    "end": "3778520"
  },
  {
    "text": "And historically, that's\nsomewhat how it happened. Somebody-- yeah, like\n[? Duda, ?] actually,",
    "start": "3778520",
    "end": "3784610"
  },
  {
    "text": "who's amazing, he came\nup with this approach. And it took people a lot of\ntime to really understand what's really happening.",
    "start": "3784610",
    "end": "3790880"
  },
  {
    "text": "But one actually very\ncute, I would say, way to connect back to\nwhat's really happening",
    "start": "3790880",
    "end": "3796260"
  },
  {
    "text": "is this idea of\nbits back coding. And we'll not\ndiscuss it right now.",
    "start": "3796260",
    "end": "3801390"
  },
  {
    "text": "It's just something I want\nyou guys to just know about. So this is like another\nway to think about rANS.",
    "start": "3801390",
    "end": "3809160"
  },
  {
    "text": "So we took one\napproach, but you could have taken a completely\ndifferent approach and would have basically\nlanded at very similar",
    "start": "3809160",
    "end": "3816150"
  },
  {
    "text": "looking equations,\nand it basically has connection with this\njoint entropy formula.",
    "start": "3816150",
    "end": "3823470"
  },
  {
    "text": "So if you were to\ncompress x ideally, one way to think about\nthis joint entropy formula,",
    "start": "3823470",
    "end": "3830700"
  },
  {
    "text": "so this is for any\nother random variable z. This is just an identity. This is a mathematical fact.",
    "start": "3830700",
    "end": "3836980"
  },
  {
    "text": "You can think of\nencoding and decoding x as like doing something with\njoint distribution of x and z,",
    "start": "3836980",
    "end": "3843900"
  },
  {
    "text": "and then doing something with\nthe conditional distribution of z and x.",
    "start": "3843900",
    "end": "3848990"
  },
  {
    "text": "And I know it's not\nmaking sense right now. But basically this\nminus sign, you",
    "start": "3848990",
    "end": "3855260"
  },
  {
    "text": "can encode a symbol x using\nsome encoder decoder pair one, and some encoder\ndecoder pair two,",
    "start": "3855260",
    "end": "3862790"
  },
  {
    "text": "where you have some minus\nsign, which we haven't really dealt with. Everywhere we have been\ndealing with positive lens,",
    "start": "3862790",
    "end": "3869000"
  },
  {
    "text": "positive everything. This kind of gives\nthe name bits back",
    "start": "3869000",
    "end": "3874430"
  },
  {
    "text": "just like you will\nencode something, but then you'll also\ngive some bits back to remain like close\nto very ideal thing.",
    "start": "3874430",
    "end": "3882390"
  },
  {
    "text": "And these all might\nsound mysterious, but go check out homework\n2 Q4 hopefully soon.",
    "start": "3882390",
    "end": "3890369"
  },
  {
    "text": "Less than 24 hours, you\nshould be able to see it. Work it out. And then for those of\nyou who are a bit--",
    "start": "3890370",
    "end": "3899340"
  },
  {
    "text": "didn't appreciate the\nfact like, what does it mean to have a conditional\nentropy deeply,",
    "start": "3899340",
    "end": "3905160"
  },
  {
    "text": "well, like next few lectures,\nas Shubham pointed out even in the next class,\nit's going to be--",
    "start": "3905160",
    "end": "3910890"
  },
  {
    "text": "like, now we are\ngoing to be talking about conditional entropy,\nconditional probability distributions because we'll\nstop assuming independence.",
    "start": "3910890",
    "end": "3919910"
  },
  {
    "text": "So basically, next few lectures\nand working through homework will really make you\nunderstand whatever we did today from another\nlight, independently.",
    "start": "3919910",
    "end": "3929400"
  },
  {
    "text": "OK. So at this point, I want to go\ninto some qualitative aspects",
    "start": "3929400",
    "end": "3935510"
  },
  {
    "text": "instead of everything. So some properties of\nrANS like, now where does rANS stand with respect\nto arithmetic coding.",
    "start": "3935510",
    "end": "3943670"
  },
  {
    "text": "So first of all, we understood\nthat the performance is optimal and actually very similar\nto Arithmetic coding,",
    "start": "3943670",
    "end": "3948770"
  },
  {
    "text": "goes back to our rule of thumb,\nwhich we just talked about. We are actually doing\nreverse decoding.",
    "start": "3948770",
    "end": "3954860"
  },
  {
    "text": "This can be a lot of problem\nfor streaming algorithms, if you think about it.",
    "start": "3954860",
    "end": "3960290"
  },
  {
    "text": "That's why I've been\nhighlighting like reverse decoding because it's no more--",
    "start": "3960290",
    "end": "3966950"
  },
  {
    "text": "the encoding is in\nstreaming fashion, let's say, but decoding\nnow will give you symbols in opposite direction,\nwhich might not be good",
    "start": "3966950",
    "end": "3974120"
  },
  {
    "text": "if a low latency or a high\nthroughput encoder decoder pair is your demand.",
    "start": "3974120",
    "end": "3979250"
  },
  {
    "text": "But you can see in work, there\nare schemes to work around it. And it actually has simpler\nencoding and decoding.",
    "start": "3979250",
    "end": "3986780"
  },
  {
    "text": "So this is something which\nwe didn't really talk about, but Shubham mentioned last\nclass like Arithmetic coding",
    "start": "3986780",
    "end": "3993620"
  },
  {
    "text": "is amazing, but it has\nthese floating point operations involved everywhere.",
    "start": "3993620",
    "end": "3999380"
  },
  {
    "text": "Whereas in our encoder--",
    "start": "3999380",
    "end": "4005380"
  },
  {
    "text": "I'm just going back\nto our rANS encoder. Actually, you have\nsome operations which",
    "start": "4005380",
    "end": "4010540"
  },
  {
    "text": "can be done very efficiently. So for example, even though\nyou have integer division,",
    "start": "4010540",
    "end": "4015730"
  },
  {
    "text": "you can pre-compute\n1 over frequency s. So you don't-- like this is just\nlike this can be cached and done",
    "start": "4015730",
    "end": "4021400"
  },
  {
    "text": "once. Similarly, you can just be\nintelligent about the choice of M. So if M is a power\nof two, multiplying by it",
    "start": "4021400",
    "end": "4030040"
  },
  {
    "text": "is just a left shift, which can\nbe done extremely efficiently in hardware. So basically choosing\nengineering choices",
    "start": "4030040",
    "end": "4037750"
  },
  {
    "text": "gives you a lot of\nefficiency in terms of how rANS can be implemented\nand is the reason why it",
    "start": "4037750",
    "end": "4043809"
  },
  {
    "text": "has encoding decoding faster. ",
    "start": "4043810",
    "end": "4050560"
  },
  {
    "text": "But there is actually one issue\nwhich we still haven't solved. So rANS sounds great.",
    "start": "4050560",
    "end": "4056590"
  },
  {
    "text": "Any guesses practically, what\nmight be one of the issues? ",
    "start": "4056590",
    "end": "4068720"
  },
  {
    "text": "Yeah? To define that that works\nwith the [INAUDIBLE]..",
    "start": "4068720",
    "end": "4075250"
  },
  {
    "text": "Yeah. So that's probably\na comment, which is coming after\nattempting homework 1.",
    "start": "4075250",
    "end": "4080430"
  },
  {
    "text": "Yes, you do have to find\nM, which works well. But I would say that\nisn't fundamental issue.",
    "start": "4080430",
    "end": "4086860"
  },
  {
    "text": "It can be worked out. Take M large enough for like-- probabilities are never exact.",
    "start": "4086860",
    "end": "4092490"
  },
  {
    "text": "Let's say, for\nwhatever precision you are working\nwith maybe it's OK, but there is actually\nthe fundamental issue.",
    "start": "4092490",
    "end": "4098519"
  },
  {
    "text": "So if you look at like\nthe input symbol string, as it keeps growing, your state\njust never stops increasing.",
    "start": "4098520",
    "end": "4108330"
  },
  {
    "text": "You are always\nincreasing your state, you are always multiplying\nit with something.",
    "start": "4108330",
    "end": "4114430"
  },
  {
    "text": "And so no matter what you\ndo after a few symbols, when I say a few,\nmaybe around 20 to 40,",
    "start": "4114430",
    "end": "4121660"
  },
  {
    "text": "you will already\nreach a state which will start overflowing\nno matter what you do.",
    "start": "4121660",
    "end": "4126790"
  },
  {
    "text": "And this is like-- I would say, this\nhas a parallel to-- OK.",
    "start": "4126790",
    "end": "4132040"
  },
  {
    "text": "Yeah, so this has a\nparallel to what we learned in Arithmetic coding also.",
    "start": "4132040",
    "end": "4137134"
  },
  {
    "text": "So as you keep\nmultiplying probability, your intervals keep\nbecoming small and small. And a lot of\npractical compressor",
    "start": "4137135",
    "end": "4143500"
  },
  {
    "text": "goes into a lot of depth\ninto solving these issues, because these are very\nimportant and practical issues.",
    "start": "4143500",
    "end": "4149065"
  },
  {
    "text": " And so yeah, basically after 30,\n40 symbols, you will go above.",
    "start": "4149065",
    "end": "4158229"
  },
  {
    "text": "OK. So one solution to avoid this\nis like you can restrict the x to be an interval L comma\nH. One thing which you",
    "start": "4158229",
    "end": "4165719"
  },
  {
    "text": "don't-- wouldn't want\nto do is like restart. You wouldn't want to be like,\nOK, whenever it overflows,",
    "start": "4165720",
    "end": "4171299"
  },
  {
    "text": "I reset my state and I\nstart from the beginning, because that's losing\nall the advantage.",
    "start": "4171300",
    "end": "4176310"
  },
  {
    "text": "It's losing the block advantage. It's losing the fact\nthat states need to be high enough\nto actually get",
    "start": "4176310",
    "end": "4181380"
  },
  {
    "text": "you a compression ratio\nnear the log probability, log 1 over probability.",
    "start": "4181380",
    "end": "4188000"
  },
  {
    "text": "And so one way to\nsolve this is-- so we'll not think--",
    "start": "4188000",
    "end": "4194489"
  },
  {
    "text": "I don't want to get into\nthe details given the time, but basically, now\nyou will try to keep",
    "start": "4194490",
    "end": "4201660"
  },
  {
    "text": "the state in between\nthis interval L comma H. And one way to do this is,\nwhen you do the encode step,",
    "start": "4201660",
    "end": "4210790"
  },
  {
    "text": "your first step is-- even your base\nencode step always",
    "start": "4210790",
    "end": "4216460"
  },
  {
    "text": "assumes the state, which you are\ngetting, is in between L and H. So before actually\ncalling this step,",
    "start": "4216460",
    "end": "4222830"
  },
  {
    "text": "you need to call a shrink\nstate step, which takes some x and returns the\nstate x shrunk, which",
    "start": "4222830",
    "end": "4230090"
  },
  {
    "text": "is in between some\npredefined window, L comma H. But obviously, this step will\nbe lossy if you don't actually",
    "start": "4230090",
    "end": "4238300"
  },
  {
    "text": "give out some bits with it. Because you're\nchanging the state, you're just dividing it and\nputting it to some other thing,",
    "start": "4238300",
    "end": "4244510"
  },
  {
    "text": "you are losing some information. So this step also\ngives out some bits. ",
    "start": "4244510",
    "end": "4254310"
  },
  {
    "text": "Yeah. Let's not go into the details. Let me just show you like\nhow this kind of function",
    "start": "4254310",
    "end": "4259369"
  },
  {
    "text": "looks like. So if you start with x previous\nsomething like 22 or 1011b,",
    "start": "4259370",
    "end": "4267930"
  },
  {
    "text": "one way to get this string state\nis to always divide this by 2 and output the last bit.",
    "start": "4267930",
    "end": "4275210"
  },
  {
    "text": "So for example, if you start\nwith 10110, at first step, you can do 1011, and then\nyou can out the last bit 0.",
    "start": "4275210",
    "end": "4284119"
  },
  {
    "text": "Next step, you can\noutput 1, you can take out 1 and add it\nto the list of out bits",
    "start": "4284120",
    "end": "4291440"
  },
  {
    "text": "and keep it to 101. And you keep doing this\nuntil your state basically",
    "start": "4291440",
    "end": "4296720"
  },
  {
    "text": "comes in the interval L comma\nH. And this is basically",
    "start": "4296720",
    "end": "4306790"
  },
  {
    "text": "your string state function,\nwhich is while your base encode step is not in this\ninterval, you just",
    "start": "4306790",
    "end": "4315639"
  },
  {
    "text": "maintain an out bits, which\nis just modulo base 2, and you keep shrinking\nyour original range.",
    "start": "4315640",
    "end": "4321880"
  },
  {
    "text": " OK. So what it's doing\nis that at each step,",
    "start": "4321880",
    "end": "4327810"
  },
  {
    "text": "I might output some bits. I'm not really waiting to encode\nthe whole state towards the end.",
    "start": "4327810",
    "end": "4333210"
  },
  {
    "text": "And at that point,\nI output some bit. That's really the\nkey difference. ",
    "start": "4333210",
    "end": "4341270"
  },
  {
    "text": "And then a really\nimportant question to think about is, how many\nbits do you have to stream out?",
    "start": "4341270",
    "end": "4347300"
  },
  {
    "text": "What is this L comma H? And in practice, you need\nto ensure two things.",
    "start": "4347300",
    "end": "4354810"
  },
  {
    "text": "Whenever you are\nshrinking this state, you need to ensure that\nthere is uniqueness involved.",
    "start": "4354810",
    "end": "4360480"
  },
  {
    "text": "There is only one-- there is one, first of\nall, and only one symbol, which is going to\nlie given no matter",
    "start": "4360480",
    "end": "4367800"
  },
  {
    "text": "what state you started with\nto get between this L comma H window. ",
    "start": "4367800",
    "end": "4374790"
  },
  {
    "text": "And don't worry about it,\nthat basically gives you some bound about what\nyour L comma H can be,",
    "start": "4374790",
    "end": "4381600"
  },
  {
    "text": "and this was like\nwhat was chosen in the original paper of ANS. And choosing something like\nthis satisfies these condition.",
    "start": "4381600",
    "end": "4389760"
  },
  {
    "text": " And I'm not going to\ncover it in class.",
    "start": "4389760",
    "end": "4396220"
  },
  {
    "text": "I think in the interest of\ntime, I don't want to go over. But all of these are also\npresent in the notes,",
    "start": "4396220",
    "end": "4401800"
  },
  {
    "text": "so I would encourage\nyou guys to read the notes to understand like\nthe basic idea, which we just",
    "start": "4401800",
    "end": "4406870"
  },
  {
    "text": "discussed.  But you might imagine\none thing which",
    "start": "4406870",
    "end": "4413060"
  },
  {
    "text": "I'll say since we have almost\ndiscussed the idea like, so-- ",
    "start": "4413060",
    "end": "4419510"
  },
  {
    "text": "come on.  OK.",
    "start": "4419510",
    "end": "4424960"
  },
  {
    "text": "So the full decoder\nnow will involve some expanding of state\nbecause right now you",
    "start": "4424960",
    "end": "4430989"
  },
  {
    "text": "are shrinking some state. So when you are\ndecoding, you need to somehow expand that state\nto get back the original thing,",
    "start": "4430990",
    "end": "4437650"
  },
  {
    "text": "and that will use the out\nbits, which were involved. So you will have some x\nshrunk, some encoded bit array,",
    "start": "4437650",
    "end": "4444220"
  },
  {
    "text": "and a reverse operation\nof whatever we saw. And so your decode\nstep would-- it's",
    "start": "4444220",
    "end": "4450550"
  },
  {
    "text": "going to be exact\nopposite, same spirit. So your first step would be best\ndecode step, which will give you",
    "start": "4450550",
    "end": "4457120"
  },
  {
    "text": "some state and shrunk\nstate, and then you will expand that state, which is\ngoing to do a reverse operation.",
    "start": "4457120",
    "end": "4463829"
  },
  {
    "text": "And combining\nthese two basically gives you a full streaming\nencoder and decoder.",
    "start": "4463830",
    "end": "4470400"
  },
  {
    "text": "OK. This is like the complete thing. A couple of things which\nhappens in practice again,",
    "start": "4470400",
    "end": "4475940"
  },
  {
    "text": "is like you'll take\nM to be power of two, you'll choose t to be\nas large as possible",
    "start": "4475940",
    "end": "4481100"
  },
  {
    "text": "when streaming\nout this bits, you might not want to do a\nsingle bit at a time, but bytes at a time.",
    "start": "4481100",
    "end": "4488659"
  },
  {
    "text": "And we have the-- so in SQL, we have\nthe rANS implemented.",
    "start": "4488660",
    "end": "4495740"
  },
  {
    "text": "And again, all the\nprevious lectures, I would encourage you\nguys to go over the code,",
    "start": "4495740",
    "end": "4501560"
  },
  {
    "text": "see if you understand it. Yeah. And we didn't really go\nover tANS in this lecture,",
    "start": "4501560",
    "end": "4509239"
  },
  {
    "text": "but that's really like-- the basic idea in tANS is\nhow can we speed this up.",
    "start": "4509240",
    "end": "4516810"
  },
  {
    "text": "So the name of\ntANS is table ANS. And so the question really\nis, what else can we cache?",
    "start": "4516810",
    "end": "4524670"
  },
  {
    "text": "How can we really\nspeed this rANS up? Any ideas given homework 1,\nwhat we have seen so far?",
    "start": "4524670",
    "end": "4532540"
  },
  {
    "text": "How do you like--\nwhat do you cache? How do you cache things? ",
    "start": "4532540",
    "end": "4541650"
  },
  {
    "text": "One recurring theme, which is-- which we have seen maybe\neven in three base codes",
    "start": "4541650",
    "end": "4547380"
  },
  {
    "text": "is threes are slow because\nyou have to take decisions.",
    "start": "4547380",
    "end": "4552659"
  },
  {
    "text": "And so whenever you have\nto speed up something, you might want to come up\nwith some lookup tables.",
    "start": "4552660",
    "end": "4559650"
  },
  {
    "text": "That's like a very,\nvery good rule of thumb when you are coding. If you can come up with\nsome lookup tables,",
    "start": "4559650",
    "end": "4565650"
  },
  {
    "text": "you can really\nspeed up your code. And that's basically the idea\nof caching rANS and tANS.",
    "start": "4565650",
    "end": "4574980"
  },
  {
    "text": "And it kind of\nrelies on the fact that in our rANS base\nencode step, when",
    "start": "4574980",
    "end": "4583380"
  },
  {
    "text": "you go from this state\nsymbol to a new state, you are always maintaining\nit between the same lower",
    "start": "4583380",
    "end": "4591420"
  },
  {
    "text": "and higher window. So you can basically\npre-compute given whatever your previous\nstate is going to be,",
    "start": "4591420",
    "end": "4598380"
  },
  {
    "text": "whatever new alphabet\nis going to be, what your new state ever can be. And so you actually never\neven have to compute that.",
    "start": "4598380",
    "end": "4606700"
  },
  {
    "text": "And that's called\ntANS and it basically takes some hit in\nterms of performance.",
    "start": "4606700",
    "end": "4613270"
  },
  {
    "text": "But the key idea really is that\nlookup tables are really fast, so use them for\nspeed trade-offs.",
    "start": "4613270",
    "end": "4622070"
  },
  {
    "text": "And so this is the last\nslide, but this was also",
    "start": "4622070",
    "end": "4627469"
  },
  {
    "text": "the first slide where\nwe started from. So again, combining all\nthe ideas which we learned,",
    "start": "4627470",
    "end": "4633349"
  },
  {
    "text": "so I hope now you\nguys understand exactly how rANS works. TANS we didn't go in details,\nbut we have some notes.",
    "start": "4633350",
    "end": "4640730"
  },
  {
    "text": "You are welcome to\ngo through the notes. You are welcome to go\nthrough the code in SCL and come talk to us if you\nwant to understand that better.",
    "start": "4640730",
    "end": "4648650"
  },
  {
    "text": "Variants of rANS\nand tANS could also be interesting project proposals\nand ideas to be implemented",
    "start": "4648650",
    "end": "4655460"
  },
  {
    "text": "for practical compressors. These have really replaced\nArithmetic and Huffman",
    "start": "4655460",
    "end": "4660619"
  },
  {
    "text": "coding in almost many new\nmodern compressors, which have come out.",
    "start": "4660620",
    "end": "4666640"
  },
  {
    "text": "And the things to,\nagain, notice is that the compression performance\nof rANS is very similar to tANS.",
    "start": "4666640",
    "end": "4674610"
  },
  {
    "text": "And that's because of\nthat rule of thumb, which we have been\nlooking into and which we were able to achieve with rANS.",
    "start": "4674610",
    "end": "4680490"
  },
  {
    "text": "tANS takes some hit\nbecause we cache and we don't do\nexact operations.",
    "start": "4680490",
    "end": "4685920"
  },
  {
    "text": "But on the other hand,\nif you look at speed, tANS has speeds, which are very\nlike-- at least decode speeds,",
    "start": "4685920",
    "end": "4693300"
  },
  {
    "text": "which are very close to\nHuffman and then encode, which is competitive\nat the very least. ",
    "start": "4693300",
    "end": "4703260"
  },
  {
    "text": "Yeah. This was, I would\nsay, the last lecture",
    "start": "4703260",
    "end": "4708900"
  },
  {
    "text": "in the series of\nwhere we started-- if we look back, we started this\nclass with very simple examples,",
    "start": "4708900",
    "end": "4715950"
  },
  {
    "text": "IID. We worked out how\nyou can encode them to how you can encode\nthem optimally,",
    "start": "4715950",
    "end": "4722520"
  },
  {
    "text": "like how you can encode them\nlosslessly to how you can encode them optimally losslessly. And then we learned various\ndifferent practical lossless",
    "start": "4722520",
    "end": "4730470"
  },
  {
    "text": "codecs, really like various\ndifferent approaches, Huffman coding, Shannon\ncoding, Huffman--",
    "start": "4730470",
    "end": "4736140"
  },
  {
    "text": "sorry, I repeated that,\nArithmetic coding, ANS. But so far, we have--",
    "start": "4736140",
    "end": "4741989"
  },
  {
    "text": "we really had a\nstrong assumption. Like we are talking\nabout entropy, but everywhere, we assume\nthat the symbols were IID.",
    "start": "4741990",
    "end": "4751270"
  },
  {
    "text": "But in real life,\nyou can have symbols which are highly correlated. The next symbol might not be\nindependent of the previous one.",
    "start": "4751270",
    "end": "4759880"
  },
  {
    "text": "Take anything, take\nlanguage, like the symbols are highly correlated.",
    "start": "4759880",
    "end": "4764920"
  },
  {
    "text": "In the next few lectures will\ngo into the details of how do you actually\nwork with real data which you see, how do you\ndeal with this correlation",
    "start": "4764920",
    "end": "4772210"
  },
  {
    "text": "while ensuring lossless\ncompression performance, and how do you do it\nadaptively, how do you like--",
    "start": "4772210",
    "end": "4778240"
  },
  {
    "text": "OK, some teaser trailer, how do\nyou use things like LLMs to get",
    "start": "4778240",
    "end": "4783910"
  },
  {
    "text": "your state-of-the-art\ncompressor. Yeah. So I think we are going\nto change the direction",
    "start": "4783910",
    "end": "4789850"
  },
  {
    "text": "a little bit, but whatever\nwe have been studying is going to keep building on that.",
    "start": "4789850",
    "end": "4795030"
  },
  {
    "text": "Yeah. Thank you. ",
    "start": "4795030",
    "end": "4802000"
  }
]