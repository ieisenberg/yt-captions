[
  {
    "text": "Okay, let's get started. So before I get into Logic, a few announcements.",
    "start": "4670",
    "end": "12075"
  },
  {
    "text": "The exam is tomorrow. Remember that. Next week is Thanksgiving break,",
    "start": "12075",
    "end": "19320"
  },
  {
    "text": "so we won't have, uh, any classes. There's no more sections. And after you guys come back from Thanksgiving break on the Monday there's going",
    "start": "19320",
    "end": "27860"
  },
  {
    "text": "to be a poster session from 2:30 to 5:30. So there's more details on the website and we'll post more details on Piazza as well.",
    "start": "27860",
    "end": "36125"
  },
  {
    "text": "And then finally the day after there is a logic homework due. So that's pretty much it aside from",
    "start": "36125",
    "end": "43579"
  },
  {
    "text": "the final report of things that you should keep track of, um, in this class.",
    "start": "43580",
    "end": "48845"
  },
  {
    "text": "Um, I want to take a few minutes to talk about CodaLab worksheets. So this is a platform that, uh,",
    "start": "48845",
    "end": "54800"
  },
  {
    "text": "we've been developing in our group to help, um, help people do research in a more efficient and reproducible way.",
    "start": "54800",
    "end": "61835"
  },
  {
    "text": "And the thing that's relevant for 221 is that, um, you will get, uh, an opportunity to get extra credit by, um,",
    "start": "61835",
    "end": "69080"
  },
  {
    "text": "using CodaLab worksheets and also it provides additional compute if you're running low on that as well.",
    "start": "69080",
    "end": "75560"
  },
  {
    "text": "I want to give a quick demo to give you an idea of how this works. So if you go over two worksheets that codalab.org you can register for an account.",
    "start": "75560",
    "end": "83150"
  },
  {
    "text": "Um, I'm going to demo a kind of a newer interface that you're actually going to see on a website, um, just because that's what's going to be rolled out soon.",
    "start": "83150",
    "end": "91105"
  },
  {
    "text": "Um, so let's create a- a worksheet, um, cs221-demo. Um, a worksheet is like a Jupyter Notebook if you are familiar with that.",
    "start": "91105",
    "end": "100325"
  },
  {
    "text": "Um, and you can do things like, um, write up, write text.",
    "start": "100325",
    "end": "106765"
  },
  {
    "text": "So I'm going to run some sentiment classification.",
    "start": "106765",
    "end": "112830"
  },
  {
    "text": "Um, let me try to at least spell this correctly. So let's suppose this, the title is CS221 Final Project.",
    "start": "116390",
    "end": "125020"
  },
  {
    "text": "Okay and then you can upload code or data. So I'm going to go ahead and upload,",
    "start": "125020",
    "end": "131365"
  },
  {
    "text": "um, the sentiment dataset. Hopefully this sounds familiar to some of you.",
    "start": "131365",
    "end": "136760"
  },
  {
    "text": "Um, and then I'm also gonna upload this textclass.py which is a source code.",
    "start": "136760",
    "end": "142849"
  },
  {
    "text": "So each of these, uh, resources, data, or code is called a bundle in",
    "start": "142850",
    "end": "148450"
  },
  {
    "text": "CodaLab and you can look at the contents of this bond or you can download it and- and so on. Um, it has a unique ID which specifies forever the precise version of this asset.",
    "start": "148450",
    "end": "158769"
  },
  {
    "text": "Um, and now the- the interesting thing you can do with this right now is you can run commands.",
    "start": "158770",
    "end": "164920"
  },
  {
    "text": "So CodaLab is pretty flexible. You can run basically any command you want. Um, you specify the dependencies,",
    "start": "164920",
    "end": "171970"
  },
  {
    "text": "um, that this command will dep- need to rely on. And then you can type in whatever textclass.py,",
    "start": "171970",
    "end": "180250"
  },
  {
    "text": "train polarity.train, test polarity.test. Um, and then you can confirm.",
    "start": "180250",
    "end": "187215"
  },
  {
    "text": "You can also see over here you can specify how much resources you want whether you want GPUs or you need to access the network, um, and so on.",
    "start": "187215",
    "end": "194270"
  },
  {
    "text": "So this goes and creates, um, a Docker image that's actually running, or a Docker container",
    "start": "194270",
    "end": "199940"
  },
  {
    "text": "that's actually running this command and you can, uh, visualize the standard output in kind of real time as the command is- is running.",
    "start": "199940",
    "end": "208405"
  },
  {
    "text": "Um, and you can see the files that are generated. Um, so for example one of these files is just a JSON file that has the test error in it.",
    "start": "208405",
    "end": "217670"
  },
  {
    "text": "So suppose you wanted to, um, visualize your experiments a little bit better because this is",
    "start": "217670",
    "end": "223760"
  },
  {
    "text": "kind of just the default information and how much, how big the bundle is and so on.",
    "start": "223760",
    "end": "228920"
  },
  {
    "text": "You can, um, go- this is a little bit more advanced but I want to show you how this works. You can define custom, um, schemas.",
    "start": "228920",
    "end": "236360"
  },
  {
    "text": "So if you define a schema which is called run, you add,",
    "start": "236360",
    "end": "241520"
  },
  {
    "text": "um, just some fields, you can actually specify test error as a custom field.",
    "start": "241520",
    "end": "250715"
  },
  {
    "text": "And you say go to stats.json, read it out. And- and then now you use that table to,",
    "start": "250715",
    "end": "258660"
  },
  {
    "text": "um, the schema to define this table. Um, you can see this is the test error. Let me make this a little bit nicer and format it to three decimal places.",
    "start": "258660",
    "end": "270169"
  },
  {
    "text": "Okay and then you can go and, um, you can modify this command. Um, and as you say rerun maybe I wanted to try some other parameters.",
    "start": "270170",
    "end": "280250"
  },
  {
    "text": "This eta is, um, the step size. Let's try some more.",
    "start": "280250",
    "end": "285440"
  },
  {
    "text": "You can rerun this 0.2 and so on. So you can fire a bunch of jobs,",
    "start": "285440",
    "end": "291650"
  },
  {
    "text": "um, and you can kind of monitor them. So this one's running, this one's created and you can monitor kind of various statistics that you want.",
    "start": "291650",
    "end": "297500"
  },
  {
    "text": "So this is generally a good way to, um, just launch jobs and kind of you know forget about",
    "start": "297500",
    "end": "303599"
  },
  {
    "text": "it and keep- keep track of all these things. Um, so then you can say, um,",
    "start": "303600",
    "end": "310110"
  },
  {
    "text": "larger step sizes are- are hurt accuracy or something.",
    "start": "310110",
    "end": "315919"
  },
  {
    "text": "So the idea behind a worksheet like in Jupyter is that you document your experiments as you go along.",
    "start": "315920",
    "end": "322235"
  },
  {
    "text": "And so every asset, data, code and bundles a- and the experiments are all kind of treated the same",
    "start": "322235",
    "end": "330139"
  },
  {
    "text": "way so that you can go in here and six months later and you know exactly what command you ran to get this result and the exact dependencies,",
    "start": "330140",
    "end": "338360"
  },
  {
    "text": "so there's kind of no question. So you should think about this as kind of a Git for, um, experiments. And if you go to the main side,",
    "start": "338360",
    "end": "344985"
  },
  {
    "text": "uh, you can actually fire up some jobs with GPUs in them and then there are depending on how many people are using or there might be a queue, or might not.",
    "start": "344985",
    "end": "352460"
  },
  {
    "text": "Um, so if you want some extra compute that's a good way to go as well. Question.",
    "start": "352460",
    "end": "358735"
  },
  {
    "text": "How much memory can you typically get? How much memory can you typically get. So there's um- so one thing that if you want to,",
    "start": "358735",
    "end": "369840"
  },
  {
    "text": "um, find out, uh, so it varies depending on what kind of- of resources are available.",
    "start": "369840",
    "end": "376040"
  },
  {
    "text": "But if you type, uh, any sort of command like free you",
    "start": "376040",
    "end": "382130"
  },
  {
    "text": "can actually see the exact environment that your job is running. Um, so I think, um,",
    "start": "382130",
    "end": "388490"
  },
  {
    "text": "you can get like maybe let's say 10 or 16 gigs of- of memory.",
    "start": "388490",
    "end": "394130"
  },
  {
    "text": "Okay. Yeah. Thank you. Any other questions about this? So there's, um, documentation here.",
    "start": "394130",
    "end": "402620"
  },
  {
    "text": "And if there's any issues that you run into, file a GitHub request or email me or something, Piazza, um,",
    "start": "402620",
    "end": "410280"
  },
  {
    "text": "won't have the highest of you know, you can post on Piazza too but, um, it'll probably faster if you, um,",
    "start": "410280",
    "end": "417020"
  },
  {
    "text": "um, submit a GitHub issue because I'll go directly to the team that's working on this. Yeah.",
    "start": "417020",
    "end": "422840"
  },
  {
    "text": "Does this only work with, uh, Python? Ah, does this work only with Python. You can run any command you want.",
    "start": "422840",
    "end": "428569"
  },
  {
    "text": "So you can C++, Java. Um, it's- it's- [inaudible]",
    "start": "428570",
    "end": "435570"
  },
  {
    "text": "Yeah you can run it on Julia. So the thing when you do a run, um, you specify that Docker image which is, basically contains your environment.",
    "start": "435570",
    "end": "445039"
  },
  {
    "text": "So if you have, uh Julia probably has Docker images available. We have a default one that has,",
    "start": "445040",
    "end": "450500"
  },
  {
    "text": "um, I don't- I'm not sure if it has Julia but it, um, but it has kind of the standard Python TensorFlow PyTorch libraries. Yeah.",
    "start": "450500",
    "end": "461090"
  },
  {
    "text": "[inaudible]",
    "start": "461090",
    "end": "466290"
  },
  {
    "text": "Yeah. So if you want to install some dependencies, um, there's two things you can do.",
    "start": "466290",
    "end": "471310"
  },
  {
    "text": "You can build your own Docker image which takes a little bit of work but it's not too hard or you can,",
    "start": "471310",
    "end": "476890"
  },
  {
    "text": "um, if you want to be lazy you can just do pip install here in the command.",
    "start": "476890",
    "end": "482485"
  },
  {
    "text": "And for that you have to make sure you turn on network access so you can actually download from PyPy.",
    "start": "482485",
    "end": "487510"
  },
  {
    "text": "[inaudible]. Yeah. Yeah you can have the requirements file.",
    "start": "487510",
    "end": "495289"
  },
  {
    "text": "Yeah. Does this support pop up windows? For example if you want to [inaudible] .",
    "start": "495960",
    "end": "502695"
  },
  {
    "text": "Does this support pop-up windows? No. This is more like a batch run. So the way there's, um,",
    "start": "502695",
    "end": "509835"
  },
  {
    "text": "there's several ways you can do this, there's, uh, you can actually expose, um,",
    "start": "509835",
    "end": "515579"
  },
  {
    "text": "like a port so you can connect if you're using TensorPort or something you can actually connect to your job on the fly,",
    "start": "515580",
    "end": "521115"
  },
  {
    "text": "or you can- actually, there's a way to mount the contents of your [inaudible] running to your local disk and you can run whatever scripts you want.",
    "start": "521115",
    "end": "529605"
  },
  {
    "text": "Maybe I'll hold off further questions, you come talk to me afterwards if you're- if you're interested and want to know more.",
    "start": "529605",
    "end": "536340"
  },
  {
    "text": "Okay. Just wanted to make that clear that that thing is available,",
    "start": "536340",
    "end": "541650"
  },
  {
    "text": "uh, go check it out, um. Okay. So back to, uh,",
    "start": "541650",
    "end": "548430"
  },
  {
    "text": "the topic that we've been discussing. Uh, so on- last Wednesday we introduced logic, uh,",
    "start": "548430",
    "end": "558779"
  },
  {
    "text": "and remember there's three ingredients of a logic, uh, there is the syntax which defines a set of valid formulas,",
    "start": "558780",
    "end": "566565"
  },
  {
    "text": "for example in propositional logic, it's rain and wet as a particular formula. So syntax is- formulas are just, uh, symbols, uh.",
    "start": "566565",
    "end": "574830"
  },
  {
    "text": "They have no intrinsic meaning to themselves. The way you define meaning is by specifying the semantics.",
    "start": "574830",
    "end": "583605"
  },
  {
    "text": "So we talked about the interpretation function which takes a formula and a model which represents state of the world and returns either true, or false.",
    "start": "583605",
    "end": "593055"
  },
  {
    "text": "And the way you should think more generally about a formula is that it carves out",
    "start": "593055",
    "end": "598080"
  },
  {
    "text": "a set of models which are configurations of the world where the formula is true.",
    "start": "598080",
    "end": "603210"
  },
  {
    "text": "So in this case, there are four possible models, uh,",
    "start": "603210",
    "end": "608385"
  },
  {
    "text": "and rain and wet corresponds to this set of models, which are in red here where it's raining and wet.",
    "start": "608385",
    "end": "617235"
  },
  {
    "text": "And finally, we talked about inference rules where, if you have a knowledge base which is a set of formulas,",
    "start": "617235",
    "end": "625305"
  },
  {
    "text": "what new formulas can be, you know, derived? So one important thing to remember is that",
    "start": "625305",
    "end": "631560"
  },
  {
    "text": "these formulas are not meant to kind of replace the knowledge base. These are things which are derived which could be very simple things as, you know,",
    "start": "631560",
    "end": "638279"
  },
  {
    "text": "you might- you have a lot of knowledge about the world but you might want on any given context you might know that it's- it's raining which is.",
    "start": "638280",
    "end": "647235"
  },
  {
    "text": "So F is much- generally much smaller than the knowledge base in terms of complexity.",
    "start": "647235",
    "end": "654180"
  },
  {
    "text": "So for rain and wet, you can derive rain. Okay. So, uh, in general, we run inference.",
    "start": "654180",
    "end": "663930"
  },
  {
    "text": "What does it mean to do logical inference? You have a knowledge base and then you have a set of inference rules that you",
    "start": "663930",
    "end": "669584"
  },
  {
    "text": "keep on turning and turning and then you see if you produce W, oh, oh sorry, ah, F. So an example,",
    "start": "669585",
    "end": "676680"
  },
  {
    "text": "what we saw last time was modus ponens, uh, which says if you have wet in weekday,",
    "start": "676680",
    "end": "681990"
  },
  {
    "text": "and wet and weekday implies traffic then you can derive traffic. So the things on the top are called premises and",
    "start": "681990",
    "end": "689850"
  },
  {
    "text": "the things on the bottom are called- is the conclusion. And more generally, you have this,",
    "start": "689850",
    "end": "695445"
  },
  {
    "text": "a modus ponens inference rule. Uh, so now the question is, what does this inference rule have to do with semantics?",
    "start": "695445",
    "end": "703320"
  },
  {
    "text": "Because th- this is just symbol manipulation. You just- you saw the symbols, you produce some other symbols.",
    "start": "703320",
    "end": "709050"
  },
  {
    "text": "And in order to anchor this in semantics, we talked about soundness and completeness.",
    "start": "709050",
    "end": "715395"
  },
  {
    "text": "So entailment is a property between, uh, a relationship between a knowledge base and a formula,",
    "start": "715395",
    "end": "723269"
  },
  {
    "text": "which is given by the models, right? So the models of F have to be a super set of models of KB,",
    "start": "723270",
    "end": "731535"
  },
  {
    "text": "that's a definition of entailment, and separately, we have the notion of derivation,",
    "start": "731535",
    "end": "736710"
  },
  {
    "text": "which is symbol manipulation. You can derive F given a set of inference rules from KB.",
    "start": "736710",
    "end": "742200"
  },
  {
    "text": "And, uh, soundness means that the set of formulas that you derive are always entailed,",
    "start": "742200",
    "end": "750195"
  },
  {
    "text": "and completeness means that you can derive all of entailed formulas. So remember this, uh, water glass analogy where this set of things in the glass are, uh,",
    "start": "750195",
    "end": "761025"
  },
  {
    "text": "true, uh, entailed formulas and you want to you know, stay within the glass but you don't want to spill over.",
    "start": "761025",
    "end": "769990"
  },
  {
    "text": "So, so far we've looked at propositional, uh, logic, uh,",
    "start": "770690",
    "end": "775905"
  },
  {
    "text": "which is any legal combination of symbols, propositional symbols, and their connectives.",
    "start": "775905",
    "end": "781830"
  },
  {
    "text": "Uh, we also looked at a subset of that called propositional logic with horn clauses where all the formulas look like this.",
    "start": "781830",
    "end": "790530"
  },
  {
    "text": "You have and, of a bunch of propositional symbols implies,um,",
    "start": "790530",
    "end": "796005"
  },
  {
    "text": "some other propositional symbol. And so there's a trade off here.",
    "start": "796005",
    "end": "802515"
  },
  {
    "text": "So we saw that propositional logic, um, is not- if you use a modus ponens in propositional logic,",
    "start": "802515",
    "end": "812195"
  },
  {
    "text": "you're- you're gonna be sound, but you're not gonna- going to be complete. There are certain types of formulas whic- which you won't be able to derive.",
    "start": "812195",
    "end": "819455"
  },
  {
    "text": "Um, so we could either restrict a propositional logic to only horn clauses,",
    "start": "819455",
    "end": "825900"
  },
  {
    "text": "and we showed last time that this indeed is complete, um, or we can say we really want propositional logic,",
    "start": "825900",
    "end": "835470"
  },
  {
    "text": "the full expressive power. And instead, we're gonna do is this thing called resolution, which we're gonna talk about in this lecture.",
    "start": "835470",
    "end": "844245"
  },
  {
    "text": "Okay. So this lecture has two parts, we're gonna talk about resolution for propositional logic",
    "start": "844245",
    "end": "849390"
  },
  {
    "text": "and then move on to first-order logic. Yeah. [inaudible] is complete,",
    "start": "849390",
    "end": "856589"
  },
  {
    "text": "does it mean that anything we could represent in the propositional logic is resolution, we can still represent it with horn clauses. Uh, so you were talking, asking about this last statement, or-",
    "start": "856590",
    "end": "867105"
  },
  {
    "text": "The last two together, are they effectively equivalent? Is there anything I could do with the last one, something I can do with the second last one?",
    "start": "867105",
    "end": "872865"
  },
  {
    "text": "Um, so is- the question is, is there anything I can do with the last one? Anything I can do with the previous second to the last one?",
    "start": "872865",
    "end": "880125"
  },
  {
    "text": "Uh, it depends on what you mean by do? So these are different statements about expressive power and inference rules.",
    "start": "880125",
    "end": "887384"
  },
  {
    "text": "Uh, propositional logic subsumes propositional logic with only horn clauses, uh.",
    "start": "887385",
    "end": "893595"
  },
  {
    "text": "So you could just say, I only care about propositional logic. But it's turned out this is going to be exponential time and this is going to be linear time.",
    "start": "893595",
    "end": "900990"
  },
  {
    "text": "So there's a trade-off there. Yeah. May I quickly ask for one second? Are we like saying like",
    "start": "900990",
    "end": "906690"
  },
  {
    "text": "complete- what kind of level of completeness are we in? So what is completeness? I'm using a very precise way to talk about,",
    "start": "906690",
    "end": "913320"
  },
  {
    "text": "uh, of a completeness of a logical system. Uh, a set of inference rules means that anything that is entailed by",
    "start": "913320",
    "end": "923130"
  },
  {
    "text": "the semantics of propositional logic is derivable via a set of rules.",
    "start": "923130",
    "end": "929280"
  },
  {
    "text": "And a particular set of rules here is modus ponens, for this case and then resolution for this case, yeah.",
    "start": "929280",
    "end": "936945"
  },
  {
    "text": "So the completeness is really a property of resolution- of",
    "start": "936945",
    "end": "942180"
  },
  {
    "text": "the inference rule with respect to a particular logic, [BACKGROUND] yeah.",
    "start": "942180",
    "end": "947880"
  },
  {
    "text": "Any other questions? [NOISE]",
    "start": "947880",
    "end": "954315"
  },
  {
    "text": "Okay. So let's dive into resolution now. So let's revisit horn clauses,",
    "start": "954315",
    "end": "961380"
  },
  {
    "text": "and try to grow them a little bit. Um, to do that, we're going to take this example,",
    "start": "961380",
    "end": "967830"
  },
  {
    "text": "horn clause A implies C, and we're going to write it with disjunction",
    "start": "967830",
    "end": "972855"
  },
  {
    "text": "for reasons that will become clear in, in a second. Um, I'm gonna write, uh,",
    "start": "972855",
    "end": "978375"
  },
  {
    "text": "some of these identities on, you know, the- on the board. Um, so these are things,",
    "start": "978375",
    "end": "987000"
  },
  {
    "text": "which are, um, hopefully, you, uh, you know.",
    "start": "987000",
    "end": "993240"
  },
  {
    "text": "Um, I also wrote this last time. This is just the,",
    "start": "993240",
    "end": "999120"
  },
  {
    "text": "um, just true, I guess. Um, because I wanna say definition,",
    "start": "999120",
    "end": "1004730"
  },
  {
    "text": "but it's not really a definition because the definition is the, um, the, the interpretation function.",
    "start": "1004730",
    "end": "1010264"
  },
  {
    "text": "But you can check the two-by-two truth table, and this is, you know, true. Intuitively, um, P implies Q,",
    "start": "1010265",
    "end": "1018470"
  },
  {
    "text": "really just, is the same as saying either P is false or Q is true.",
    "start": "1018470",
    "end": "1023615"
  },
  {
    "text": "If P is false, then the kind of the hypothesis is false, so it's irrelevant what Q is,",
    "start": "1023615",
    "end": "1028745"
  },
  {
    "text": "and if Q is true, then, um, then the whole statement is true, okay?",
    "start": "1028745",
    "end": "1034339"
  },
  {
    "text": "Um, so what about this? A and, and B implies C. So I can write it as not A",
    "start": "1034340",
    "end": "1042799"
  },
  {
    "text": "or not B or C. So this invokes another, um, identity.",
    "start": "1042800",
    "end": "1048875"
  },
  {
    "text": "So which is that if I have not of P, um, and Q, that's the same as not P or not Q.",
    "start": "1048875",
    "end": "1062285"
  },
  {
    "text": "Okay. So- and there's also another version, which is P or Q negated is the same as P,",
    "start": "1062285",
    "end": "1069950"
  },
  {
    "text": "uh, not P and not Q. So what I'm doing intuitively is pushing this negation, um,",
    "start": "1069950",
    "end": "1077885"
  },
  {
    "text": "pass the, the connective into the propositional symbols. And when I push it passed- on negation pass and it flips to an or,",
    "start": "1077885",
    "end": "1087169"
  },
  {
    "text": "and then when I push a pass on or, it flips to an and. Okay? And hopefully, you guys should be comfortable with",
    "start": "1087170",
    "end": "1093160"
  },
  {
    "text": "this because when you're doing programming and you're writing if statements, um, you should know about that. Yeah?",
    "start": "1093160",
    "end": "1098590"
  },
  {
    "text": "[inaudible]?",
    "start": "1098590",
    "end": "1104090"
  },
  {
    "text": "Yeah. So a good question. So the- what is the order of operations. It's here, it's A and B parentheses implies C. Okay?",
    "start": "1104090",
    "end": "1113190"
  },
  {
    "text": "So if you apply the second identity on the board here, you have A and B, is not A or not B.",
    "start": "1113860",
    "end": "1122315"
  },
  {
    "text": "And then you apply the, the first identity and that thing, um, or C",
    "start": "1122315",
    "end": "1128720"
  },
  {
    "text": "is this, this is the same thing over there. Okay. So now, I'm going to introduce some terminology.",
    "start": "1128720",
    "end": "1137075"
  },
  {
    "text": "Um, first is a literal. So this is going to be either a propositional symbol or its negation.",
    "start": "1137075",
    "end": "1147950"
  },
  {
    "text": "Um, there's a notion of a, uh,",
    "start": "1147950",
    "end": "1153544"
  },
  {
    "text": "clause, which is just a, you know, disjunction of literals.",
    "start": "1153545",
    "end": "1161570"
  },
  {
    "text": "So disjunction means or. So these things are all clauses. Um, and finally, there is, um,",
    "start": "1161570",
    "end": "1169145"
  },
  {
    "text": "a particular type of clause called a Horn clause, um, which I introduced last time.",
    "start": "1169145",
    "end": "1175490"
  },
  {
    "text": "But here, I'm defining a kind of a different light here which is clauses that have at most one positive literal.",
    "start": "1175490",
    "end": "1182975"
  },
  {
    "text": "Okay. So, um, in these clauses,",
    "start": "1182975",
    "end": "1188075"
  },
  {
    "text": "there is indeed only one, uh, positive literal. So these are Horn, Horn clauses.",
    "start": "1188075",
    "end": "1193684"
  },
  {
    "text": "And if you remember from last time, if you have snow or traffic all appearing on the right-hand side,",
    "start": "1193685",
    "end": "1199745"
  },
  {
    "text": "then that has two positive literals which is- which means it's not a Horn clause.",
    "start": "1199745",
    "end": "1205700"
  },
  {
    "text": "So now, I can write modus ponens the following way. So A, and A implies C,",
    "start": "1205700",
    "end": "1212690"
  },
  {
    "text": "which can be written as a disjunction, um, allows me to derive C. And here is",
    "start": "1212690",
    "end": "1220280"
  },
  {
    "text": "another intuition which is that I'm kind of effectively canceling out A and not A,",
    "start": "1220280",
    "end": "1226175"
  },
  {
    "text": "and I'm taking the, you know, the resulting things and putting them on, on the bottom.",
    "start": "1226175",
    "end": "1232800"
  },
  {
    "text": "Okay. All right. So now, let's, uh, introduce a resolution rule.",
    "start": "1233320",
    "end": "1238775"
  },
  {
    "text": "So general clauses could have any number of literals. So this is not a horn clause, but it is a clause.",
    "start": "1238775",
    "end": "1244174"
  },
  {
    "text": "And, um, the resolution rule for a particular- this particular example looks like this,",
    "start": "1244175",
    "end": "1250540"
  },
  {
    "text": "so rain or snow. And if you have not, um,",
    "start": "1250540",
    "end": "1255820"
  },
  {
    "text": "snow or traffic, allows you to derive rain or traffic. Okay. So this is not a Horn clause, right?",
    "start": "1255820",
    "end": "1267649"
  },
  {
    "text": "Because I have two positive literals. Um, and how do we intuitively understand what's going on?",
    "start": "1267650",
    "end": "1275165"
  },
  {
    "text": "So you could say, okay, it's either raining or snowing. And snow implies traffic,",
    "start": "1275165",
    "end": "1280715"
  },
  {
    "text": "which means that it was, it was- it's snowing that I can get traffic. There was not snowing. I still have rain here,",
    "start": "1280715",
    "end": "1285920"
  },
  {
    "text": "so I can, um, I can conclude it's either rainy or trafficking.",
    "start": "1285920",
    "end": "1291389"
  },
  {
    "text": "So in general, the resolution rule looks like this. So you have a clause up here,",
    "start": "1292420",
    "end": "1299419"
  },
  {
    "text": "um, with some P, a positional symbol, and then you have a second clause with",
    "start": "1299420",
    "end": "1306020"
  },
  {
    "text": "not P. And what you can do is you can cancel out P and not P, and then you can take everything else,",
    "start": "1306020",
    "end": "1312260"
  },
  {
    "text": "and then hook them up as a big, um, you know, clause.",
    "start": "1312260",
    "end": "1318780"
  },
  {
    "text": "Okay. So this is a rule.",
    "start": "1325330",
    "end": "1330679"
  },
  {
    "text": "I've kind of sketchily argued that it's a reasonable thing to do. Um, but to really formally verify that,",
    "start": "1330680",
    "end": "1337040"
  },
  {
    "text": "you have to check the soundness. And the way you do soundness, remember how do you check soundness?",
    "start": "1337040",
    "end": "1342710"
  },
  {
    "text": "You go back to the semantics and- of propositional logic, and you verify that that's consistent with what resolution is trying to do.",
    "start": "1342710",
    "end": "1351305"
  },
  {
    "text": "So in this rule, you have rain or snow. The set of models of rain or snow is,",
    "start": "1351305",
    "end": "1358130"
  },
  {
    "text": "um, everything that's not white here. Um, the set of models have not snow or traffic,",
    "start": "1358130",
    "end": "1365510"
  },
  {
    "text": "is everything that's not white over here. And when you, um, intersect them, you get the dark red.",
    "start": "1365510",
    "end": "1374000"
  },
  {
    "text": "And that, that represents your, um, where you think the save the world is if you only have the, the premises.",
    "start": "1374000",
    "end": "1383840"
  },
  {
    "text": "Um, and if you look at the models of the conclusion rain or traffic, it's this green area.",
    "start": "1383840",
    "end": "1390050"
  },
  {
    "text": "And you just have to check that, um, what you derived is a superset of what you know.",
    "start": "1390050",
    "end": "1397860"
  },
  {
    "text": "And again, this might be a little bit counterintuitive, but you should think about knowledge as restriction.",
    "start": "1398950",
    "end": "1407345"
  },
  {
    "text": "Knowledge means that you actually have pinpointed the state of the world to be smaller. So the fewer color boxes you have,",
    "start": "1407345",
    "end": "1415730"
  },
  {
    "text": "the more knowledge you have. [NOISE]",
    "start": "1415730",
    "end": "1421910"
  },
  {
    "text": "Okay? So this is sound. Um, completeness is, um,",
    "start": "1421910",
    "end": "1428090"
  },
  {
    "text": "another, uh, much harder thing to check. Yeah, question? So you mentioned that we wanted to have",
    "start": "1428090",
    "end": "1434179"
  },
  {
    "text": "a superset at the end but not a subset but there's the two top most [inaudible] for snow- allow for snow removing.",
    "start": "1434180",
    "end": "1441184"
  },
  {
    "text": "Yeah. That are not there. Is that because we've eliminated snow? This is, uh, so why are these there?",
    "start": "1441185",
    "end": "1448865"
  },
  {
    "text": "This is- so this, um, this square is only true in rain or snow.",
    "start": "1448865",
    "end": "1455645"
  },
  {
    "text": "Um, this is only true in, uh, not snow or traffics. But remember, the- the way to think about a knowledge base is that",
    "start": "1455645",
    "end": "1462610"
  },
  {
    "text": "semantics is the intersection of all the four- models of all the formulas. So when I have intersected the models of everything up here,",
    "start": "1462610",
    "end": "1469745"
  },
  {
    "text": "I'm only left with the dark red, here. Um, there's just one square in our final green cell,",
    "start": "1469745",
    "end": "1476720"
  },
  {
    "text": "that's not a part of the intersection [inaudible] [NOISE] Uh, there's, well, there's two, these two.",
    "start": "1476720",
    "end": "1483799"
  },
  {
    "text": "Yes. Yeah. Uh, are we allowing for those because of the fact that,",
    "start": "1483800",
    "end": "1488900"
  },
  {
    "text": "we're- that it's- our conclusion is rain or traffic. But I'm just sort of wondering when you're mentioning the super-set versus subset, um,",
    "start": "1488900",
    "end": "1497330"
  },
  {
    "text": "[NOISE] why then the other two squares up on the first row not included?",
    "start": "1497330",
    "end": "1503149"
  },
  {
    "text": "Um, so let's see. Why are the- the ones up here not included?",
    "start": "1503150",
    "end": "1510830"
  },
  {
    "text": "Because they're not part of the intersection. So is your question why are the squares not part of the intersection?",
    "start": "1510830",
    "end": "1516770"
  },
  {
    "text": "[inaudible] Um, so they're not- le- let me clarify.",
    "start": "1516770",
    "end": "1522799"
  },
  {
    "text": "So if you only look at the premises up here, the set of models is this square,",
    "start": "1522800",
    "end": "1529070"
  },
  {
    "text": "this square, this square, and this square. Then you look at the premises or, sorry, the conclusion,",
    "start": "1529070",
    "end": "1534455"
  },
  {
    "text": "and you look at the models, independently, of the premises and you get these six squares. I see. So those six squares are not related to the two that we have beforehand?",
    "start": "1534455",
    "end": "1544115"
  },
  {
    "text": "Yeah. So this is the green is just derived from the, the green here. All right, okay. Yeah. Okay. Good. All right.",
    "start": "1544115",
    "end": "1554075"
  },
  {
    "text": "So, um, it turns out that resolution is also complete and this is you know,",
    "start": "1554075",
    "end": "1560450"
  },
  {
    "text": "kind of the, the big result from the '60s that, um, demonstrated, I even, kind of a,",
    "start": "1560450",
    "end": "1566120"
  },
  {
    "text": "single rule can kind of rule all of propositional logic, um, but you might say, wait a minute,",
    "start": "1566120",
    "end": "1572750"
  },
  {
    "text": "wait a minute, um, there's clearly things that this resolution, uh, rule doesn't work on because it only works on clauses.",
    "start": "1572750",
    "end": "1581315"
  },
  {
    "text": "So what you have- what if you have formulas that aren't clauses at all? Um, so there's a kind of this trick that we're going to, um,",
    "start": "1581315",
    "end": "1589625"
  },
  {
    "text": "do is that we are going to reduce all formulas to clauses, okay? So another definition that is important here is,",
    "start": "1589625",
    "end": "1597470"
  },
  {
    "text": "um, CNF, so it stands for conjunctive normal form. So a CNF formula is just a conjunction of clauses, okay?",
    "start": "1597470",
    "end": "1605885"
  },
  {
    "text": "So here's an example of CNF formula. Um, here's a clause, here's a clause and you can join them.",
    "start": "1605885",
    "end": "1612515"
  },
  {
    "text": "So it's important to remember that, um, so j- just to refresh,",
    "start": "1612515",
    "end": "1618410"
  },
  {
    "text": "this is a CNF formula. It's a conjunction of clauses, each clause is a disjunction of literals,",
    "start": "1618410",
    "end": "1625160"
  },
  {
    "text": "and each literal is either a propositional symbol or its negation, okay?",
    "start": "1625160",
    "end": "1630320"
  },
  {
    "text": "So or is on the inside, um, and is on the outside,",
    "start": "1630320",
    "end": "1635405"
  },
  {
    "text": "and the one way to kind of, make sure you remember that is, a knowledge-base remember is, um,",
    "start": "1635405",
    "end": "1643340"
  },
  {
    "text": "a set of formulas but really it represents the conjunction of all those formulas because you know all the facts in your, um, knowledge base.",
    "start": "1643340",
    "end": "1652280"
  },
  {
    "text": "And, uh, so you can think about a CNF formula is just, um, of knowledge-base where each formula as a clause.",
    "start": "1652280",
    "end": "1660960"
  },
  {
    "text": "Okay. So we can actually, take any formula in",
    "start": "1662560",
    "end": "1669260"
  },
  {
    "text": "propositional logic and we can convert it into an equivalent CNF formula, which I'll show in the next slide.",
    "start": "1669260",
    "end": "1676625"
  },
  {
    "text": "And once we've done that, then, you know, we can use resolution, um, and life is good.",
    "start": "1676625",
    "end": "1683495"
  },
  {
    "text": "Okay. So the conversion, um, is going to be just a six step procedure, um,",
    "start": "1683495",
    "end": "1691654"
  },
  {
    "text": "and, uh, that- I mean, it's a little bit grungy but, um, but I just want to kind of highlight the- the general, you know, intuition.",
    "start": "1691655",
    "end": "1701875"
  },
  {
    "text": "So we have this formula. So this is not a CNF formula, but we're gonna make it one.",
    "start": "1701875",
    "end": "1707910"
  },
  {
    "text": "Okay, so the first thing w- we wanna do is we want to remove all the symbols that aren't, um,",
    "start": "1707910",
    "end": "1713795"
  },
  {
    "text": "ands or ors or negation because those definitely, don't show up in this, uh, in a clause, um, or a CNF formula.",
    "start": "1713795",
    "end": "1720470"
  },
  {
    "text": "So we can use the identity, the first identity on the board to, uh, convert implication into, um,",
    "start": "1720470",
    "end": "1727760"
  },
  {
    "text": "[NOISE] um, on a not and a or, um,",
    "start": "1727760",
    "end": "1733490"
  },
  {
    "text": "you do that for the inner, guy here, um, and now, you only have symbols that you're supposed to have.",
    "start": "1733490",
    "end": "1740385"
  },
  {
    "text": "Um, the second thing is, that remember, the order in which these connectives,",
    "start": "1740385",
    "end": "1745735"
  },
  {
    "text": "uh, is important for CNF. So negation is on the very inside, negation is only allowed to touch a propositional symbol.",
    "start": "1745735",
    "end": "1753235"
  },
  {
    "text": "Then you have, um, or disjunction, um, and then you have and.",
    "start": "1753235",
    "end": "1758990"
  },
  {
    "text": "So we want to change the order so that- that is- is true. So first, we want the push the negation,",
    "start": "1758990",
    "end": "1766895"
  },
  {
    "text": "all the way inside, um, and this is using the De Morgan's laws, so the first, uh, the second and third identities on the board,",
    "start": "1766895",
    "end": "1774080"
  },
  {
    "text": "um, and so we pushed this inside, um, so that now,",
    "start": "1774080",
    "end": "1779990"
  },
  {
    "text": "all the negation is on the- the on the inside, um, we can remove double negation, um, you can check,",
    "start": "1779990",
    "end": "1786680"
  },
  {
    "text": "v- very easy to check that- that's, uh, valid. Um, and finally, so this is not a C- a CNF formula,",
    "start": "1786680",
    "end": "1795485"
  },
  {
    "text": "it might look like one but it's not, um, if you turn your head upside down, it actually looks like a CNF formula.",
    "start": "1795485",
    "end": "1803015"
  },
  {
    "text": "Um, but the reason is that, um, and is on the inside but it really should be on the outside,",
    "start": "1803015",
    "end": "1809450"
  },
  {
    "text": "and to fix that, you can actually, distribute or over and which allows you to say this is summer or",
    "start": "1809450",
    "end": "1816289"
  },
  {
    "text": "biza- bizarre and not snow or bizarre, okay?",
    "start": "1816290",
    "end": "1821885"
  },
  {
    "text": "So now, this is a CNF formula, and then you're done. Um, this is a general set of rules, just to recap,",
    "start": "1821885",
    "end": "1830990"
  },
  {
    "text": "you eliminate bidirectional implication implication to get the symbol inventory, right?",
    "start": "1830990",
    "end": "1836495"
  },
  {
    "text": "and then you move negation all the way to the inside, um, and you're eliminating a spurious negation that you don't need,",
    "start": "1836495",
    "end": "1844505"
  },
  {
    "text": "and then you move any or from the outside to inside the,",
    "start": "1844505",
    "end": "1850205"
  },
  {
    "text": "um, the, the and, okay?",
    "start": "1850205",
    "end": "1857549"
  },
  {
    "text": "So long story short, take any propositional logical formula,",
    "start": "1858190",
    "end": "1864170"
  },
  {
    "text": "you can make it a CNF formula. So without laws of generality, we're just going to assume we have CNF formulas.",
    "start": "1864170",
    "end": "1869600"
  },
  {
    "text": "[NOISE] Okay? Um, another place that CNF- or you might have seen CNF formulas, uh,",
    "start": "1869600",
    "end": "1877910"
  },
  {
    "text": "come up is when you're talking about, um, in theoretical computer science when you're talking about, uh, 3SAT.",
    "start": "1877910",
    "end": "1884135"
  },
  {
    "text": "3SAT is, uh, a problem where you're given a CNF formula where every clause has three, um, uh,",
    "start": "1884135",
    "end": "1891140"
  },
  {
    "text": "s- symbols and, you know, three literals and you're trying to ts- determine if it's satisfiable,",
    "start": "1891140",
    "end": "1896149"
  },
  {
    "text": "and we know that to be, uh, a very hard problem.",
    "start": "1896150",
    "end": "1900150"
  },
  {
    "text": "Okay. So- so now let's, uh, talk about, um,",
    "start": "1901240",
    "end": "1906500"
  },
  {
    "text": "the resolution algorithm, um, remember, there is a relationship between entailment and contradiction.",
    "start": "1906500",
    "end": "1912650"
  },
  {
    "text": "So knowledge-based entails f is the same as saying knowledge base is incompatible with not f. Like,",
    "start": "1912650",
    "end": "1920105"
  },
  {
    "text": "f really, really must hold. It's- it's impossible that not f, you know, holds, okay?",
    "start": "1920105",
    "end": "1926270"
  },
  {
    "text": "So suppose we wanted to prove that,",
    "start": "1926270",
    "end": "1931310"
  },
  {
    "text": "um, f is derived from the knowledge base, um, what we're gonna do is,",
    "start": "1931310",
    "end": "1936500"
  },
  {
    "text": "do this proof by contradiction strategy, where we're going to say insert not f into the knowledge base,",
    "start": "1936500",
    "end": "1942590"
  },
  {
    "text": "and see if we can derive a contradiction, okay? So you add not f into the knowledge base,",
    "start": "1942590",
    "end": "1948875"
  },
  {
    "text": "convert all the formulas into CNF, and then you keep on re-applying the resolution rules and you, uh,",
    "start": "1948875",
    "end": "1956180"
  },
  {
    "text": "return entailment if you can derive false, okay?",
    "start": "1956180",
    "end": "1962360"
  },
  {
    "text": "So here's an example of what this looks like. So here's the knowledge base, and here's a particular formula,",
    "start": "1962360",
    "end": "1967910"
  },
  {
    "text": "and now we want to know whether KB entails, um, f or not, okay?",
    "start": "1967910",
    "end": "1973129"
  },
  {
    "text": "So you add it, um, add not f into knowledge base,",
    "start": "1973130",
    "end": "1978470"
  },
  {
    "text": "so that's not C, and, um, I'm going to convert this into a CNF. So that only affects the first formula here,",
    "start": "1978470",
    "end": "1986075"
  },
  {
    "text": "um, and then I'm going to repeatedly, apply the resolution rule. So I can take this, uh, clause.",
    "start": "1986075",
    "end": "1992225"
  },
  {
    "text": "Resolution says allows me to cancel not A with A, I get B or C, and then I take B and not B cancel it out,",
    "start": "1992225",
    "end": "1999950"
  },
  {
    "text": "C and I cancel out C or I mean, when you see C and not C, um,",
    "start": "1999950",
    "end": "2005200"
  },
  {
    "text": "that's clearly a contradiction and you can derive false. Which means that the knowledge base entails f,",
    "start": "2005200",
    "end": "2013270"
  },
  {
    "text": "in this particular example. [BACKGROUND]",
    "start": "2013270",
    "end": "2020795"
  },
  {
    "text": "Okay. This also maybe gives you a little bit intuition of the mysteries of",
    "start": "2020795",
    "end": "2026750"
  },
  {
    "text": "defining the goal clause and horn clauses as deriving of blah blah blah and implies false,",
    "start": "2026750",
    "end": "2033335"
  },
  {
    "text": "um, because you can add, um, something that you're trying to prove and you",
    "start": "2033335",
    "end": "2039620"
  },
  {
    "text": "can use modus ponens to see if you can derive false. And if you do derive false then it's, uh,",
    "start": "2039620",
    "end": "2045065"
  },
  {
    "text": "it's a contradiction. All right.",
    "start": "2045065",
    "end": "2050450"
  },
  {
    "text": "So as I alluded to before, um, there is a time complexity difference between modus ponens and, uh, resolution.",
    "start": "2050450",
    "end": "2059524"
  },
  {
    "text": "So for modus ponens, each rule application adds only- adds a clause with one propositional symbol.",
    "start": "2059525",
    "end": "2067399"
  },
  {
    "text": "So imagine you have n propositional symbols, you can really only apply modus ponens n times.",
    "start": "2067400",
    "end": "2073010"
  },
  {
    "text": "So that's a linear number of applications there. Whereas the thing with resolution is that,",
    "start": "2073010",
    "end": "2080405"
  },
  {
    "text": "you can add, uh, each row application can add a clause with many propositional symbols.",
    "start": "2080405",
    "end": "2086570"
  },
  {
    "text": "And in the worst case you can imagine any subset of the propositional symbols getting added and this results in an exponential time algorithm.",
    "start": "2086570",
    "end": "2095060"
  },
  {
    "text": "This should not be surprising because we know that 3-SAT is, you know, NP complete.",
    "start": "2095060",
    "end": "2101240"
  },
  {
    "text": "So, um, unless there was some magic here there's, there's no way to kind of circumvent that. Yeah.",
    "start": "2101240",
    "end": "2108380"
  },
  {
    "text": "[inaudible] preferred? So the question is why is resolution preferred?",
    "start": "2108380",
    "end": "2116270"
  },
  {
    "text": "Um, so you could just, uh, convert everything to CNF and check,",
    "start": "2116270",
    "end": "2121670"
  },
  {
    "text": "uh, do backtracking search or whatever on CNF. Resolution, turns out that all have generalizations, um,",
    "start": "2121670",
    "end": "2129260"
  },
  {
    "text": "to first-order logic which, um, model checking doesn't.",
    "start": "2129260",
    "end": "2134510"
  },
  {
    "text": "Right. So- so remember there's two ways you can go about, you can, um, do basically reduce things to CSPs and then you can solve it,",
    "start": "2134510",
    "end": "2141320"
  },
  {
    "text": "or you can try to use inference rules. So this inference rule doesn't, um, as far as I know,",
    "start": "2141320",
    "end": "2148039"
  },
  {
    "text": "people don't really reuse resolution in propositional logic, but in, uh, first-order logic you kind of have no choice.",
    "start": "2148040",
    "end": "2154940"
  },
  {
    "text": "So, um, I'm thinking that,",
    "start": "2154940",
    "end": "2160670"
  },
  {
    "text": "when you see modus ponens inference rules it's kind of like everything's going to be still down to n to relationships.",
    "start": "2160670",
    "end": "2166175"
  },
  {
    "text": "Yeah. Like sort of NAND and NOR are the universal gates. And so I'm thinking that resolution is like a more production,",
    "start": "2166175",
    "end": "2171500"
  },
  {
    "text": "and, um, more [inaudible]. So of the two can you prefer one to the other? Um, the the question is whether the two are,",
    "start": "2171500",
    "end": "2181475"
  },
  {
    "text": "um, resolution looks like kind of like NAND. Um, there's quite a bit of difference there.",
    "start": "2181475",
    "end": "2187655"
  },
  {
    "text": "Maybe you could talk about it offline. Um, okay, so to summarize,",
    "start": "2187655",
    "end": "2192755"
  },
  {
    "text": "there's two routes here. You can say, I am gonna use propositional logic with horn clauses and be using modus ponens.",
    "start": "2192755",
    "end": "2200720"
  },
  {
    "text": "This is fast but it's less expressive, or I can embrace the full complexity of a propositional logic and use resolution.",
    "start": "2200720",
    "end": "2208685"
  },
  {
    "text": "And this is exponential time, it's slow but it's more expressive. Yeah. [inaudible].",
    "start": "2208685",
    "end": "2222170"
  },
  {
    "text": "Right. What I mean by expressive? I mean the- the latter which is that there's simply some things you can't write down,",
    "start": "2222170",
    "end": "2228815"
  },
  {
    "text": "um, in- in- with proofs using horn clauses, like you can't write down rain or snow at all.",
    "start": "2228815",
    "end": "2237125"
  },
  {
    "text": "Any sort of branching or disjunction you can't do in horn clauses.",
    "start": "2237125",
    "end": "2243530"
  },
  {
    "text": "So in some applications horn clauses actually turns out to be, um, you know, quite en- enough.",
    "start": "2243530",
    "end": "2250505"
  },
  {
    "text": "Um, so these type of horn clauses show up in- in programming languages where you're just,",
    "start": "2250505",
    "end": "2255829"
  },
  {
    "text": "uh, you know, you see some premises and you're trying to, um, derive some other quantity. So unlike in program analysis this is actually quite useful and efficient, um.",
    "start": "2255830",
    "end": "2265290"
  },
  {
    "text": "Okay, so let's move to first-order logic. So what's wrong with propositional logic?",
    "start": "2265690",
    "end": "2271460"
  },
  {
    "text": "I mean, it's already exponential time so, um, you know, you better be pretty good.",
    "start": "2271460",
    "end": "2277190"
  },
  {
    "text": "Um, so remember the point of logic is to,",
    "start": "2277190",
    "end": "2282440"
  },
  {
    "text": "in general, from an AI perspective is to be able to represent and reason with knowledge in the world.",
    "start": "2282440",
    "end": "2288454"
  },
  {
    "text": "So there's a lot of things that, um, we want to represent but might be awkward in propositional logic.",
    "start": "2288455",
    "end": "2296060"
  },
  {
    "text": "So here's, uh, examples. So Alice and Bob both know arithmetic. So how would you do this in propositional logic?",
    "start": "2296060",
    "end": "2302825"
  },
  {
    "text": "Well, propositional logic is about propositions. So this has two propositions,",
    "start": "2302825",
    "end": "2308215"
  },
  {
    "text": "um, which are statements, uh, which are either true or false. AliceKnowsArithmetic and BobKnowsArithmetic, okay?",
    "start": "2308215",
    "end": "2315355"
  },
  {
    "text": "Fine. So what about all students know arithmetic? How would you represent that?",
    "start": "2315355",
    "end": "2320829"
  },
  {
    "text": "Well, um, you probably do something like this, where you say, okay if Alice is student than AliceKnowsArithmetic,",
    "start": "2320830",
    "end": "2327849"
  },
  {
    "text": "and Bob is student then BobKnowsArithmetic, and so on. Um, because all propositional logic can do is from reason about statements.",
    "start": "2327850",
    "end": "2335930"
  },
  {
    "text": "So what about this? There's Goldbach's conjecture. Every even integer greater than two, is a sum of two primes.",
    "start": "2335930",
    "end": "2342555"
  },
  {
    "text": "Um, so good luck with that. Um, you might have to write down all the integers which there are a lot of them.",
    "start": "2342555",
    "end": "2348950"
  },
  {
    "text": "So propositional logic is clunky at best and not expressive,",
    "start": "2348950",
    "end": "2355204"
  },
  {
    "text": "um, and worse, what's missing? Um, when we have knowledge in the wor- in the world,",
    "start": "2355205",
    "end": "2363694"
  },
  {
    "text": "it's often more natural to think about there as being objects and predicates on these objects,",
    "start": "2363695",
    "end": "2370220"
  },
  {
    "text": "um, rather than just, um, opaque propositions. So AliceKnowsArithmetic, actually, has more internal structure.",
    "start": "2370220",
    "end": "2379160"
  },
  {
    "text": "It's not just a single proposition that has nothing to do with anything else. It has notions of Alice,",
    "start": "2379160",
    "end": "2384200"
  },
  {
    "text": "and knows, and arithmetic in them. And finally, once you can decompose a proposition into parts,",
    "start": "2384200",
    "end": "2390800"
  },
  {
    "text": "you can do fancy things with them. You can use quantifiers and variables. For example, all is a quantifier that applies to each person and",
    "start": "2390800",
    "end": "2398390"
  },
  {
    "text": "we want to do that inference without enumerating over all the people, or all of the integers.",
    "start": "2398390",
    "end": "2404609"
  },
  {
    "text": "Okay, so I'm going to talk about first-order logic, going through our plan of first talking about the syntax,",
    "start": "2404740",
    "end": "2412130"
  },
  {
    "text": "then the semantics, and then inference rules. So I want to warm up with just, um, some examples.",
    "start": "2412130",
    "end": "2419615"
  },
  {
    "text": "I'm not gonna do as rigorous of a treatment of first-order logic as propositional logic because, um, it gets more complicated and I just wanna give you an idea of how it works.",
    "start": "2419615",
    "end": "2429740"
  },
  {
    "text": "So Alice and Bob both know arithmetic. This is going to be represented as, um,",
    "start": "2429740",
    "end": "2435410"
  },
  {
    "text": "Knows alice, arithmetic and Knows bob, arithmetic, okay? So this is, er,",
    "start": "2435410",
    "end": "2441140"
  },
  {
    "text": "there are some familiar symbols like and, and now the proposit- uh,",
    "start": "2441140",
    "end": "2446525"
  },
  {
    "text": "the propositional symbols have been replaced with these more structured objects.",
    "start": "2446525",
    "end": "2452255"
  },
  {
    "text": "And all students who know arithmetic gets mapped to this where now",
    "start": "2452255",
    "end": "2457609"
  },
  {
    "text": "have this quantifier for all x student of x implies knows x arithmetic.",
    "start": "2457610",
    "end": "2463470"
  },
  {
    "text": "Okay, so a bit more formally, so there's a bunch of definitions I'm gonna talk about.",
    "start": "2464320",
    "end": "2471230"
  },
  {
    "text": "So first-order logic. So I mean, in first-order logic there's two types of things.",
    "start": "2471230",
    "end": "2477725"
  },
  {
    "text": "There's terms, and then there's formulas. In propositional logic, there only formulas.",
    "start": "2477725",
    "end": "2484220"
  },
  {
    "text": "So terms are, uh, expressions that refer to objects. So it could be a constant symbol, um,",
    "start": "2484220",
    "end": "2493985"
  },
  {
    "text": "it could be a variable, or it could be a function applied to some other terms.",
    "start": "2493985",
    "end": "2501770"
  },
  {
    "text": "So for example, arithmetic is a- is just a constant, it's, um, let's think about it as a name.",
    "start": "2501770",
    "end": "2507020"
  },
  {
    "text": "Um, there are variables like x, um, which I'll explain later,",
    "start": "2507020",
    "end": "2513290"
  },
  {
    "text": "um, and there's functions of terms. So 3 plus, uh, x would be represented as sum of 3 of x, okay?",
    "start": "2513290",
    "end": "2522125"
  },
  {
    "text": "Remember these are just symbols. Um, and, uh, formulas refer to truth values,",
    "start": "2522125",
    "end": "2528440"
  },
  {
    "text": "so there's atomic formulas or atoms. Uh, so this, uh, atomic formula is a predicate applied to, um, terms.",
    "start": "2528440",
    "end": "2538580"
  },
  {
    "text": "So knows, x is a term, arithmetic is a term, therefore, a pre- and knows is a predicate,",
    "start": "2538580",
    "end": "2544900"
  },
  {
    "text": "so knows, x, arithmetic, is an atomic formula.",
    "start": "2544900",
    "end": "2548720"
  },
  {
    "text": "Um, so atoms are supposed to be indivisible but here there's a substructure here.",
    "start": "2552750",
    "end": "2560530"
  },
  {
    "text": "So maybe you can think about these subatomic particles of that, if that is useful.",
    "start": "2560530",
    "end": "2565960"
  },
  {
    "text": "Um, there's connectives as before. So what we're doing right now is,",
    "start": "2565960",
    "end": "2571550"
  },
  {
    "text": "you're taking these atomic formulas, atoms, and they behave like propositional symbols.",
    "start": "2571550",
    "end": "2578150"
  },
  {
    "text": "So given these atoms are generalizations of propositional symbols we can string them together using any number of connectives,",
    "start": "2578150",
    "end": "2585155"
  },
  {
    "text": "as we've done in propositional logic. And then finally, we have quantifiers applied to formulas.",
    "start": "2585155",
    "end": "2594065"
  },
  {
    "text": "Which means that, if you have a formula with a variable in it, um,",
    "start": "2594065",
    "end": "2599359"
  },
  {
    "text": "we can stick a quantifier over these variables to, uh, specify how the variable is meant to be interpreted.",
    "start": "2599360",
    "end": "2607760"
  },
  {
    "text": "Okay, so there's connectives, um, and, um, quantifiers.",
    "start": "2607760",
    "end": "2616860"
  },
  {
    "text": "All right. So let's talk about quantifiers.",
    "start": "2623090",
    "end": "2628320"
  },
  {
    "text": "Quantifiers are in some sense, the heart of why first-order logic is, you know, useful.",
    "start": "2628320",
    "end": "2634665"
  },
  {
    "text": "And there's two types of quantifiers; universal quantifiers and existential quantifiers. So universal quantifiers, you should think about as just glorified conjunction.",
    "start": "2634665",
    "end": "2644505"
  },
  {
    "text": "So when I have for all x P of x, that's really like saying P of A and P of B and P of C and for all the constant symbols.",
    "start": "2644505",
    "end": "2654540"
  },
  {
    "text": "And existential quantifiers are a glorified disjunction when I say there exists x such that p of x holds,",
    "start": "2654540",
    "end": "2661770"
  },
  {
    "text": "that's like saying P of A or P of B or and so on so on. So I'm cheating a little bit because I'm only- I'm still talking about the syntax of",
    "start": "2661770",
    "end": "2669869"
  },
  {
    "text": "first order logic but I can't resist but give you a little bit of intuition about what the syntax means. I'm not formally defining the,",
    "start": "2669870",
    "end": "2677745"
  },
  {
    "text": "the interpretation function here but I'm just trying to give you an idea of what the symbols, um, correspond to.",
    "start": "2677745",
    "end": "2685050"
  },
  {
    "text": "So here are some properties. Um, so if I push a negation through a universal quantification,",
    "start": "2685050",
    "end": "2693405"
  },
  {
    "text": "then that goes on the inside and the- for all becomes and exists.",
    "start": "2693405",
    "end": "2699640"
  },
  {
    "text": "Does this sound familiar to people? Wh- what is the name for this kind of thing?",
    "start": "2700340",
    "end": "2708585"
  },
  {
    "text": "Yeah, it's just the Morgan's law about applying to first-order logic as opposed to propositional logic.",
    "start": "2708585",
    "end": "2715320"
  },
  {
    "text": "And it's really important to remember that, um, the order of quantifiers matters. All right.",
    "start": "2715320",
    "end": "2722340"
  },
  {
    "text": "So for all exist is very different from exists for all. Okay. So, um, one more comment about quantifiers.",
    "start": "2722340",
    "end": "2732180"
  },
  {
    "text": "It will be useful to be able to convert natural language sentences into uh,",
    "start": "2732180",
    "end": "2738690"
  },
  {
    "text": "you know, first-order logic. Um, and on the assignment you're gonna do a bunch of this. But so this is kind of- there's an important distinction I want to make.",
    "start": "2738690",
    "end": "2748079"
  },
  {
    "text": "So in natural language, you talk, have, um, quantifiers in natural language are words like every, or some, or a.",
    "start": "2748080",
    "end": "2756645"
  },
  {
    "text": "And so how do these get represented in, um, in uh, formal logic?",
    "start": "2756645",
    "end": "2763350"
  },
  {
    "text": "Uh, every student knows arithmetic. Um, every generally refers to for all.",
    "start": "2763350",
    "end": "2771950"
  },
  {
    "text": "So you might write something like this, but this is wrong.",
    "start": "2771950",
    "end": "2778490"
  },
  {
    "text": "So what's wrong about this? [inaudible]",
    "start": "2778490",
    "end": "2784670"
  },
  {
    "text": "Sorry say again. Not every [inaudible] Yeah. So the problem is that what does this say?",
    "start": "2784670",
    "end": "2791790"
  },
  {
    "text": "This one says everyone's a student. For all X, X is a student and for all X,",
    "start": "2791790",
    "end": "2797460"
  },
  {
    "text": "um, X knows arithmetic. So it's basically saying everyone's a student and everyone knows arithmetic which is different.",
    "start": "2797460",
    "end": "2802964"
  },
  {
    "text": "So what it really should be is implication. All right. So for anyone that's not a student I don't,",
    "start": "2802965",
    "end": "2809940"
  },
  {
    "text": "I don't care in terms of this assessing the validity of this formula.",
    "start": "2809940",
    "end": "2815010"
  },
  {
    "text": "And only if someone's a student then I'm going to check whether that student knows arithmetic.",
    "start": "2815010",
    "end": "2820065"
  },
  {
    "text": "Okay. So what about existential quantification? Some knows student knows arithmetic. This is student of X and knows X arithmetic.",
    "start": "2820065",
    "end": "2828105"
  },
  {
    "text": "So those are different connectives. And a general rule of thumb is that whenever you have universal quantification,",
    "start": "2828105",
    "end": "2835365"
  },
  {
    "text": "it should be implication, and whenever you have existential quantification, it should be, um, an and.",
    "start": "2835365",
    "end": "2843075"
  },
  {
    "text": "So of course there's exceptions but this is a ge- this is a general rule.",
    "start": "2843075",
    "end": "2848980"
  },
  {
    "text": "Okay. So let me give you a few examples just to get you used to thinking about quantifiers.",
    "start": "2848990",
    "end": "2855540"
  },
  {
    "text": "So imagine you want to say there is some course that every student has taken. So what- how is that?",
    "start": "2855540",
    "end": "2862770"
  },
  {
    "text": "So there is, there is some course, so there should be exist Y or Y is a course that every student has taken.",
    "start": "2862770",
    "end": "2870690"
  },
  {
    "text": "So every is a for all X and, um, here I want student implies takes XY.",
    "start": "2870690",
    "end": "2877335"
  },
  {
    "text": "Okay. Remember, uh, exist has usually has and,",
    "start": "2877335",
    "end": "2882570"
  },
  {
    "text": "and for all has implies. Okay. What about um, Goldbach's conjecture?",
    "start": "2882570",
    "end": "2891645"
  },
  {
    "text": "Every integer is greater than, greater than 2 is the sum of two primes. This is every even integer, so",
    "start": "2891645",
    "end": "2898440"
  },
  {
    "text": "every even integer greater than 2 implies that what about these?",
    "start": "2898440",
    "end": "2904060"
  },
  {
    "text": "This is a sum of two primes. So notice that there are no maybe explicit hints that you need to use X essential.",
    "start": "2904060",
    "end": "2910890"
  },
  {
    "text": "But the fact that these two primes are kind of under-specified means that, um, there should be exist.",
    "start": "2910890",
    "end": "2917490"
  },
  {
    "text": "So there exists Y and Z such that both of them are prime and the sum of Y and Z is X.",
    "start": "2917490",
    "end": "2923895"
  },
  {
    "text": "Uh, and finally, here's a statement. If a student takes a course and the course covers",
    "start": "2923895",
    "end": "2929700"
  },
  {
    "text": "a concept then the student knows that concept. Uh, whether that's true or not uh,",
    "start": "2929700",
    "end": "2935369"
  },
  {
    "text": "is a different matter but this is a valid formula, and it's- can be represented as follows.",
    "start": "2935370",
    "end": "2941895"
  },
  {
    "text": "So one other, you know, piece of advice is that if you see the word if,",
    "start": "2941895",
    "end": "2947160"
  },
  {
    "text": "that generally suggests that there is a bunch of universal quantifications. Because if is kind of like saying there's a general rule and",
    "start": "2947160",
    "end": "2955125"
  },
  {
    "text": "universal quantification says like in general something, you know something happens. Um, so this is for all X, all Y, all Z. Um,",
    "start": "2955125",
    "end": "2964020"
  },
  {
    "text": "if you have a student and takes some course and that course covers um,",
    "start": "2964020",
    "end": "2970095"
  },
  {
    "text": "some uh, concept Z, then uh, that student knows that uh, concept.",
    "start": "2970095",
    "end": "2979005"
  },
  {
    "text": "Um, I guess technically, there should be uh, also and concept of Z in there.",
    "start": "2979005",
    "end": "2985005"
  },
  {
    "text": "But let's run into getting complicated.",
    "start": "2985005",
    "end": "2989890"
  },
  {
    "text": "Okay. Any questions about first-order logic,",
    "start": "2990170",
    "end": "2995700"
  },
  {
    "text": "what the syntax is and any of these intuitions that we're having for it? Yeah.",
    "start": "2995700",
    "end": "3002869"
  },
  {
    "text": "[inaudible] why you don't use equal sign instead of just equals or is that just to find [inaudible]",
    "start": "3002870",
    "end": "3013100"
  },
  {
    "text": "So the question is: Why don't we just use the equal sign? So I'm being a little bit uh,",
    "start": "3013100",
    "end": "3018140"
  },
  {
    "text": "I guess cautious and, you know, following the strict syntax where you have functions that just take or- it gives you,",
    "start": "3018140",
    "end": "3026090"
  },
  {
    "text": "it shows you the structure of the logical uh, expressions more. So now, in, in certain cases, you,",
    "start": "3026090",
    "end": "3032855"
  },
  {
    "text": "you can use syntactic sugar and you can write equals if you want. But remember the point of logic is not to be able to write",
    "start": "3032855",
    "end": "3042320"
  },
  {
    "text": "these things down manually and reason with them, um, but to have a very kind of primitively built system",
    "start": "3042320",
    "end": "3051709"
  },
  {
    "text": "of formulas that you have general rules like resolution that can operate on them.",
    "start": "3051709",
    "end": "3057030"
  },
  {
    "text": "Okay. So let's talk about the semantics of first-order logic. So in propositional logic,",
    "start": "3059500",
    "end": "3066890"
  },
  {
    "text": "um, a model with something that maps propositional symbols to truth values.",
    "start": "3066890",
    "end": "3072529"
  },
  {
    "text": "In other words, it's a complete assignment of truth values to propositional symbols. So what is this in first-order logic?",
    "start": "3072530",
    "end": "3078995"
  },
  {
    "text": "So still we're going to maintain the intuition that a model is supposed to represent a possible situation in the world.",
    "start": "3078995",
    "end": "3087619"
  },
  {
    "text": "Um, so I'm gonna give you of- kind of some gra- graphical intuition.",
    "start": "3087620",
    "end": "3092735"
  },
  {
    "text": "So imagine you only have unary and binary predicates. So these are, um,",
    "start": "3092735",
    "end": "3097895"
  },
  {
    "text": "predicates that only take one or two arguments. Then we can think about a model as being represented as a graph.",
    "start": "3097895",
    "end": "3104150"
  },
  {
    "text": "So imagine you have three nodes, these represent the objects in the world.",
    "start": "3104150",
    "end": "3110465"
  },
  {
    "text": "So objects are kind of first-class citizens in first-order logic. And these are labeled with constant symbols.",
    "start": "3110465",
    "end": "3117320"
  },
  {
    "text": "So you have Alice, you have Bob and Robert and you have arithmetic here. And then the directed edges are going to represent binary predicates.",
    "start": "3117320",
    "end": "3128150"
  },
  {
    "text": "Um, and, and these are going to be labeled with a predicate symbols. Um, so here I have a knows predicate that applies to 01, 03.",
    "start": "3128150",
    "end": "3138890"
  },
  {
    "text": "Another knows predicate that applies to 02 or 03, and a unary predicate here that applies to only 01.",
    "start": "3138890",
    "end": "3147539"
  },
  {
    "text": "Okay. So more formally, a model in first-order logic is a mapping that takes",
    "start": "3147640",
    "end": "3154355"
  },
  {
    "text": "any- every constant symbol to, um, an object. So Alice goes to 01,",
    "start": "3154355",
    "end": "3160204"
  },
  {
    "text": "Bob goes to 02, arithmetic goes to 03. And it maps predicate symbols to tuples of objects.",
    "start": "3160205",
    "end": "3169175"
  },
  {
    "text": "So knows is a set of pairs such that the first element of the pair knows the second element of the pair.",
    "start": "3169175",
    "end": "3177200"
  },
  {
    "text": "Um, I'm skipping function symbols just for simplicity but you would define them analogously as well.",
    "start": "3177200",
    "end": "3184950"
  },
  {
    "text": "Okay. So that is our model. It's a little bit more complicated than propositional logic",
    "start": "3185950",
    "end": "3191120"
  },
  {
    "text": "because you have to define something for both, um, the term, the, the constant symbols and the predicate symbols.",
    "start": "3191120",
    "end": "3198560"
  },
  {
    "text": "So now to make our lives a little bit easier, I'm going to introduce a restriction on model,",
    "start": "3198560",
    "end": "3205955"
  },
  {
    "text": "as motivated in the following example. So if I say John and Bob are students, um,",
    "start": "3205955",
    "end": "3212615"
  },
  {
    "text": "then in your head you might imagine, well, there's two people John and Bob and they're both students.",
    "start": "3212615",
    "end": "3218480"
  },
  {
    "text": "But there could be technically only one person whose name is both John and Bob or someone who's anonymous and doesn't have a name.",
    "start": "3218480",
    "end": "3228725"
  },
  {
    "text": "And there's two simplifications that'll rule out, um, W2 and W3.",
    "start": "3228725",
    "end": "3234215"
  },
  {
    "text": "So unique names assumption says that an object has most- each object has at most one constant symbol.",
    "start": "3234215",
    "end": "3241700"
  },
  {
    "text": "And domain closure says that each symbol has at least one constant symbol. So the point of this restriction means that constant symbols and objects are,",
    "start": "3241700",
    "end": "3253444"
  },
  {
    "text": "um, in a one-to-one relationship. And once you do that,",
    "start": "3253445",
    "end": "3258620"
  },
  {
    "text": "then we can do something called propositionalization. And in this case, a first-order logic is actually",
    "start": "3258620",
    "end": "3265505"
  },
  {
    "text": "just a syntactic sugar for our propositional logic. Um, so if you have this knowledge base in first-order logic,",
    "start": "3265505",
    "end": "3272840"
  },
  {
    "text": "um, student Alice and Bob- student of Bob for all,",
    "start": "3272840",
    "end": "3278705"
  },
  {
    "text": "all students are people and there's some creative student, um,",
    "start": "3278705",
    "end": "3283715"
  },
  {
    "text": "then you can actually convert very simply into propositional logic by kind of unrolling,",
    "start": "3283715",
    "end": "3289565"
  },
  {
    "text": "it's like unrolling your loops in some sense. So we just, um,",
    "start": "3289565",
    "end": "3295310"
  },
  {
    "text": "have student Alice implies person Alice. Student Bob implies person Bob. And because there is a finite set of pro- of",
    "start": "3295310",
    "end": "3303260"
  },
  {
    "text": "constant symbols it's not going to be like an infinite set of formulas.",
    "start": "3303260",
    "end": "3308630"
  },
  {
    "text": "There might be a lot of formulas but, um, it's not going to be an infinite set.",
    "start": "3308630",
    "end": "3313760"
  },
  {
    "text": "Okay. So the point of doing this is now you can use any inference algorithm for propositional logic for first-order logic.",
    "start": "3313760",
    "end": "3322654"
  },
  {
    "text": "Okay. So if you're willing to make this restriction,",
    "start": "3322655",
    "end": "3328325"
  },
  {
    "text": "unique names and domain closure, that means you kind of have direct access to all the objects in,",
    "start": "3328325",
    "end": "3335015"
  },
  {
    "text": "in the world via, via your um, constant symbols in which case",
    "start": "3335015",
    "end": "3340250"
  },
  {
    "text": "you've- you're just propositional- you just have propositional logic. Okay. So why might you want to do this?",
    "start": "3340250",
    "end": "3348095"
  },
  {
    "text": "Um, so first-order logic as, as a syntactic sugar still might be convenient.",
    "start": "3348095",
    "end": "3353270"
  },
  {
    "text": "You might still want to write down your expressions in first-order logic, um,",
    "start": "3353270",
    "end": "3359795"
  },
  {
    "text": "and have the benefits of actually having, um, you know, propositional logic where the inferences in some sense are much more developed.",
    "start": "3359795",
    "end": "3368660"
  },
  {
    "text": "Um, but later we'll see that, um, there are some cases where you won't be able to do this.",
    "start": "3368660",
    "end": "3377100"
  },
  {
    "text": "Okay. So that's all I'm gonna say about the semantics of, of first-order logic.",
    "start": "3377680",
    "end": "3384319"
  },
  {
    "text": "Um, so now let's talk about inference rules. Okay. So I'm gonna start by talking about first order logic with horn clauses.",
    "start": "3384320",
    "end": "3394805"
  },
  {
    "text": "And we're gonna use some generalization and modus ponens and then we're going to move to a full on first-order logic and talk about the,",
    "start": "3394805",
    "end": "3401990"
  },
  {
    "text": "um, generalization of resolution. Okay. So, um, let's begin by defining definite clauses for first-order logic.",
    "start": "3401990",
    "end": "3412474"
  },
  {
    "text": "So remember a definite clause in propositional logic was, uh, conjunction of propositional symbols implies some other propositional symbol.",
    "start": "3412475",
    "end": "3421490"
  },
  {
    "text": "And now the propositional symbols are now these atoms, atomic formulas. And furthermore, we have might have variables so we're going to have,",
    "start": "3421490",
    "end": "3431760"
  },
  {
    "text": "uh, universal quantifiers on outside. So intuitively you should think about this, uh,",
    "start": "3432040",
    "end": "3439460"
  },
  {
    "text": "as a single template that gets real if you were to propositionalize, it would be, uh,",
    "start": "3439460",
    "end": "3444740"
  },
  {
    "text": "a whole set of definite formulas in propositional logic.",
    "start": "3444740",
    "end": "3451920"
  },
  {
    "text": "So thi- another way to think about this is that",
    "start": "3453700",
    "end": "3459349"
  },
  {
    "text": "this single statement is a very compact way of writing down what would be very kind of cumbersome in,",
    "start": "3459350",
    "end": "3465950"
  },
  {
    "text": "uh, propositional logic because you would have to instantiate all of the possible symbols. Okay. So here's a formal definition.",
    "start": "3465950",
    "end": "3473585"
  },
  {
    "text": "So a definite clause has the following form. You start by a se- having a set of variables,",
    "start": "3473585",
    "end": "3479600"
  },
  {
    "text": "which are all universally quantified and then you have atomic formulas, which are all conjoined implies,",
    "start": "3479600",
    "end": "3487444"
  },
  {
    "text": "um, another atomic formula. And these atomic formulas can contain any of these variables.",
    "start": "3487445",
    "end": "3495060"
  },
  {
    "text": "Okay. So now let's do modus ponens. So here is a straightforward generalization of modus ponens.",
    "start": "3495310",
    "end": "3504050"
  },
  {
    "text": "You have some atomic formulas a_1 through a_k that you pick up and then you have a_1 through a_k implies b and then you use that to derive b.",
    "start": "3504050",
    "end": "3513875"
  },
  {
    "text": "Okay. So it says the first attempt, so you might, uh, see my catch on the fact that this actually won't work.",
    "start": "3513875",
    "end": "3520970"
  },
  {
    "text": "So why doesn't it work? So imagine you have P of Alice. And then you have for all x, P of x implies Q of x.",
    "start": "3520970",
    "end": "3530111"
  },
  {
    "text": "Um, so the problem is that you can't actually infer Q of Alice at all.",
    "start": "3530111",
    "end": "3539960"
  },
  {
    "text": "Because P of x here and P of Alice just don't match.",
    "start": "3539960",
    "end": "3546740"
  },
  {
    "text": "This is supposed to be a1. This is supposed to be a1 and P of x and P of Alice are not the same a1.",
    "start": "3546740",
    "end": "3554375"
  },
  {
    "text": "So this is kind of important lesson because remember these inference rules don't know anything.",
    "start": "3554375",
    "end": "3559790"
  },
  {
    "text": "They have no kind of intrinsic semantics. There's just pattern matching, right? So if you don't write your patterns right,",
    "start": "3559790",
    "end": "3565490"
  },
  {
    "text": "then it's just not going to work. But we can fix this. And the solution involves two ideas substitution and unification.",
    "start": "3565490",
    "end": "3574850"
  },
  {
    "text": "So substitution is taking a formula applying,",
    "start": "3574850",
    "end": "3580385"
  },
  {
    "text": "uh, find and replace to generate another formula. So if I want to replace x with Alice,",
    "start": "3580385",
    "end": "3588320"
  },
  {
    "text": "apply to P of x, I get P of Alice. I can do two find and replaces, x with Alice and y with z.",
    "start": "3588320",
    "end": "3596930"
  },
  {
    "text": "And I am going to replace x with Alice and y with z. Um, and so in general,",
    "start": "3596930",
    "end": "3603920"
  },
  {
    "text": "a substitution Theta is some mapping from variables to terms and substitution Theta of f",
    "start": "3603920",
    "end": "3613160"
  },
  {
    "text": "returns the result of just performing that substitution on f. So it generates another formula with these variables replaced with these terms.",
    "start": "3613160",
    "end": "3623405"
  },
  {
    "text": "So a pretty simple idea. Okay. Unification takes two formulas and tries to make them the same.",
    "start": "3623405",
    "end": "3632795"
  },
  {
    "text": "And to make them same you have to do some substitution, so it returns what substitution it needed to do that.",
    "start": "3632795",
    "end": "3639320"
  },
  {
    "text": "Okay. So here's an example. Knows Alice, arithmetic knows, x arithmetic. These expressions are not syntactically identical.",
    "start": "3639320",
    "end": "3648500"
  },
  {
    "text": "But if I replace x with Alice, then they are identical. So that's what unification does.",
    "start": "3648500",
    "end": "3655025"
  },
  {
    "text": "So what about this example, how do I make these two identical, I replace x with Alice and y with z.",
    "start": "3655025",
    "end": "3661280"
  },
  {
    "text": "And what about this one, I can't do anything because I can't- I can only remember substitution only can replace variables with other things.",
    "start": "3661280",
    "end": "3669560"
  },
  {
    "text": "It can't replace constant symbols. So it can't replace Alice with Bob, so that just fails. Um, and then things can get a little",
    "start": "3669560",
    "end": "3676820"
  },
  {
    "text": "bit more complicated when you have functional symbols. So here to make these the same I need to replace x with Alice",
    "start": "3676820",
    "end": "3683135"
  },
  {
    "text": "and then y with F of x but x has already been replaced with Alice. So I need to make this y goes to F of Alice.",
    "start": "3683135",
    "end": "3692095"
  },
  {
    "text": "Okay. So to summary- summarize our unification takes two formulas f and g and",
    "start": "3692095",
    "end": "3697990"
  },
  {
    "text": "returns a substitution which maps variables to terms,",
    "start": "3697990",
    "end": "3703110"
  },
  {
    "text": "um, and this is the most general unifier. Which means that if I unify x and x,",
    "start": "3703110",
    "end": "3710089"
  },
  {
    "text": "I could also replace x with Alice and that'd be fine, but that's not the most general thing.",
    "start": "3710090",
    "end": "3715430"
  },
  {
    "text": "I want to substitute as little as possible to make two things, um, equal.",
    "start": "3715430",
    "end": "3721535"
  },
  {
    "text": "Um, so unify returns a substitution such that. And here's an important property.",
    "start": "3721535",
    "end": "3728210"
  },
  {
    "text": "If I apply that substitution to f, I get identically the same expression as if I apply Theta",
    "start": "3728210",
    "end": "3733850"
  },
  {
    "text": "to g. And if I can't do it, then I just fail.",
    "start": "3733850",
    "end": "3738300"
  },
  {
    "text": "Okay. So now yeah, question Can we say that F of x,",
    "start": "3739690",
    "end": "3746150"
  },
  {
    "text": "like what should we say to F of x is it a variable or is it a formula? So is the question is f,",
    "start": "3746150",
    "end": "3752780"
  },
  {
    "text": "f of x, is this a variable or, uh, a formula? So f of x, f is a function, uh, symbol.",
    "start": "3752780",
    "end": "3760910"
  },
  {
    "text": "So it takes a term and returns a term. So the technical term f of x is a term,",
    "start": "3760910",
    "end": "3767585"
  },
  {
    "text": "uh, which represents an object in the world. Um, and you can check that,",
    "start": "3767585",
    "end": "3773494"
  },
  {
    "text": "um, knows is a, is a predicate, so it needs to take, uh, terms.",
    "start": "3773495",
    "end": "3779390"
  },
  {
    "text": "So f of x is a term. Okay. So now with substitution and unification,",
    "start": "3779390",
    "end": "3788150"
  },
  {
    "text": "we can now revise our modus ponens to make our work. So, um, I'm going to have a1 prime through",
    "start": "3788150",
    "end": "3795635"
  },
  {
    "text": "ak prime which are distinct syntactically from ath, a1 through ak.",
    "start": "3795635",
    "end": "3802130"
  },
  {
    "text": "And what are we going to do is try to unify the primes that are not primes into some substitution,",
    "start": "3802130",
    "end": "3808910"
  },
  {
    "text": "and once I have the substitution, I can apply this to b, uh, and derive b prime,",
    "start": "3808910",
    "end": "3815045"
  },
  {
    "text": "and that's what I'm going to write down. Okay. So let me do go through this example now.",
    "start": "3815045",
    "end": "3823070"
  },
  {
    "text": "So suppose Alice has taken 221, and 221 covers MDPs =, and I have this general rule that says",
    "start": "3823070",
    "end": "3829520"
  },
  {
    "text": "if a student takes a course and a course covers topics, then that student knows that topic. So I need to unify this, uh,",
    "start": "3829520",
    "end": "3839375"
  },
  {
    "text": "takes Alice 221, covers 221 MDP with this abstract version.",
    "start": "3839375",
    "end": "3845450"
  },
  {
    "text": "And when I unify, I get, um, the substitution to be x,",
    "start": "3845450",
    "end": "3851105"
  },
  {
    "text": "needs to be replaced with Alice, y with 221 and z with mdp, and, um, then I can derive,",
    "start": "3851105",
    "end": "3858710"
  },
  {
    "text": "uh, I'll- and then I take this, uh, Theta, and I apply that substitution to Knows x,",
    "start": "3858710",
    "end": "3867335"
  },
  {
    "text": "z, and I get, um, Knows Alice, mdp.",
    "start": "3867335",
    "end": "3872070"
  },
  {
    "text": "So intuitively, you can think about a1 prime and- to ak prime.",
    "start": "3872980",
    "end": "3878930"
  },
  {
    "text": "These are concrete- this is concrete knowledge. You have about the world. This is a general rule.",
    "start": "3878930",
    "end": "3885065"
  },
  {
    "text": "So what the substitution does is it specifies how",
    "start": "3885065",
    "end": "3890869"
  },
  {
    "text": "the general variables here are to be grounded in the concrete things that you're dealing with.",
    "start": "3890870",
    "end": "3898160"
  },
  {
    "text": "And now, um, this final substitution, uh, grounds it out, rounds this part into,",
    "start": "3898160",
    "end": "3906634"
  },
  {
    "text": "uh, the concrete symbols, in this case alice 221, mdp.",
    "start": "3906634",
    "end": "3911789"
  },
  {
    "text": "Okay. So what's the complexity of this? Um, so each application of modus ponens produces an atomic formula,",
    "start": "3913540",
    "end": "3924470"
  },
  {
    "text": "just one, not multiple ones. So that- that's the good news. And if you don't have any functions, uh, symbols, uh,",
    "start": "3924470",
    "end": "3931355"
  },
  {
    "text": "the number of the atomics formulas is, uh, most the number of constant symbols to the maximum-predicate-arity.",
    "start": "3931355",
    "end": "3939590"
  },
  {
    "text": "So in this case, if you have like 100 possible values of x, 100 possible values of y,",
    "start": "3939590",
    "end": "3945260"
  },
  {
    "text": "100 possible values of z, that will be the number of possible, um, formulas that you might produce is 100 to the 3rd.",
    "start": "3945260",
    "end": "3954420"
  },
  {
    "text": "So, um, you know. That, that could ima- you could imagine this being,",
    "start": "3954460",
    "end": "3961910"
  },
  {
    "text": "um, a very, very large number, so its exponential in the arity, but if arity is, you know, let's say 2, then you know,",
    "start": "3961910",
    "end": "3968300"
  },
  {
    "text": "this is not too bad. It's not exponential. Um, so that's, that's the good news.",
    "start": "3968300",
    "end": "3976580"
  },
  {
    "text": "The bad news from a complexity point of view is, if there are function symbols,",
    "start": "3976580",
    "end": "3981619"
  },
  {
    "text": "then actually, um, that's infinite.",
    "start": "3981620",
    "end": "3986750"
  },
  {
    "text": "I guess not just exponential time, it's like infinite, um, infinite time.",
    "start": "3986750",
    "end": "3992525"
  },
  {
    "text": "Because the number of possible formulas that you could produce is, uh, kind of unbounded.",
    "start": "3992525",
    "end": "3999869"
  },
  {
    "text": "And when you might have something like this, well, if you remember one of the functions could be sum.",
    "start": "4000300",
    "end": "4006970"
  },
  {
    "text": "So you could have like sum 1 and sum of 1, and sum of 1,",
    "start": "4006970",
    "end": "4012040"
  },
  {
    "text": "and, and so on. So you can kind of essentially encode arithmetic using this, uh, first-order logic.",
    "start": "4012040",
    "end": "4021170"
  },
  {
    "text": "Okay. So, so here's what we know. So modus ponens is complete for first order logic with only Horn clauses.",
    "start": "4022110",
    "end": "4033730"
  },
  {
    "text": "Right. So what is completeness mean? It means that anything that's actually true, that's entailed.",
    "start": "4033730",
    "end": "4040119"
  },
  {
    "text": "There exists a derivation, a way of apply modus ponens to get there.",
    "start": "4040120",
    "end": "4048220"
  },
  {
    "text": "But the bad news is that it's semi-decidable.",
    "start": "4048220",
    "end": "4053800"
  },
  {
    "text": "Um, this means- so first-order logic, even when you restrict it to Horn clauses is semi-decidable. This means what?",
    "start": "4053800",
    "end": "4062200"
  },
  {
    "text": "If f is entailed, forward inference, um, using,",
    "start": "4062200",
    "end": "4070225"
  },
  {
    "text": "um, uh, the complete inference rules, in this case a modus ponens,",
    "start": "4070225",
    "end": "4075805"
  },
  {
    "text": "will eventually prove or derive f in finite time, because it's complete, so eventually you'll get it.",
    "start": "4075805",
    "end": "4083260"
  },
  {
    "text": "But if, if it's not entailed, we don't know.",
    "start": "4083260",
    "end": "4089185"
  },
  {
    "text": "We don't know when to stop because it could go and just keep on going on and on, and actually no algorithm can,",
    "start": "4089185",
    "end": "4094420"
  },
  {
    "text": "uh, show this in finite time. So there's a complexity throughout the result that says, um, it's not just exponential time,",
    "start": "4094420",
    "end": "4100359"
  },
  {
    "text": "but it's actually, there's no algorithm. It's like the- if you're familiar with the halting problem, that's- this is very related to that.",
    "start": "4100360",
    "end": "4108080"
  },
  {
    "text": "Okay. So that's a bummer. Um, but you know, it's,",
    "start": "4109410",
    "end": "4116005"
  },
  {
    "text": "it's not the end of the world because you can still actually, uh, just run, um, of impro- inference,",
    "start": "4116005",
    "end": "4124210"
  },
  {
    "text": "and get a partial result. So you might succeed in which you know for sure because it's sound that,",
    "start": "4124210",
    "end": "4129580"
  },
  {
    "text": "um, it's, uh, the f is entailed. And after a while,",
    "start": "4129580",
    "end": "4135190"
  },
  {
    "text": "well, you just, uh, run out of CPU time and you stop, and then you say I don't know.",
    "start": "4135190",
    "end": "4141650"
  },
  {
    "text": "Okay. So now let's talk about resolution. So we've f- finished talking about first-order logic with, uh,",
    "start": "4142920",
    "end": "4151525"
  },
  {
    "text": "restricted to Horn clauses, and we saw that modus ponens is complete.",
    "start": "4151525",
    "end": "4157870"
  },
  {
    "text": "Um, there's a small wrinkle that you can actually compute everything that you hope for, but that's life.",
    "start": "4157870",
    "end": "4165069"
  },
  {
    "text": "Um, and now we're going to, um, go to resolution.",
    "start": "4165070",
    "end": "4170844"
  },
  {
    "text": "Uh, so remember that first-order logic includes a lot more clauses.",
    "start": "4170845",
    "end": "4177009"
  },
  {
    "text": "So here's an example. So this is all students know something. Um, and the fact that this exists here.",
    "start": "4177010",
    "end": "4185440"
  },
  {
    "text": "Remember existential quantification is like glorified disjunction. So this is like our example of snow- is snow or traffic.",
    "start": "4185440",
    "end": "4193765"
  },
  {
    "text": "Um, so what do we do with this? So we're going to follow the same strategy as what we did for propositional logic.",
    "start": "4193765",
    "end": "4200260"
  },
  {
    "text": "We're going to convert everything just CNF, and then we're going to repeatedly apply the resolution rule. And the main thing that's going to be different is now we have to handle",
    "start": "4200260",
    "end": "4207969"
  },
  {
    "text": "variables and quantifiers and use substitution and unification, but the structure is going to be the same.",
    "start": "4207970",
    "end": "4214795"
  },
  {
    "text": "So the conversion to CNF is, um, a bit, um, messy and gross and slightly non-intuitive.",
    "start": "4214795",
    "end": "4223165"
  },
  {
    "text": "Um, but I just want to present it so you know what it looks like. Um, so here is a example of,",
    "start": "4223165",
    "end": "4231880"
  },
  {
    "text": "um, not a CNF formula. Um, so what does this say,",
    "start": "4231880",
    "end": "4237550"
  },
  {
    "text": "just you know the practice, um, that says for all x, um,",
    "start": "4237550",
    "end": "4243715"
  },
  {
    "text": "so if anyone who loves all animals, um, is loved by someone. Okay?",
    "start": "4243715",
    "end": "4254500"
  },
  {
    "text": "And what we want to produce is the final output is this CNF formula, which again,",
    "start": "4254500",
    "end": "4262000"
  },
  {
    "text": "CNF means a conjunction of disjuncts, and each disjunct is,",
    "start": "4262000",
    "end": "4268720"
  },
  {
    "text": "um, uh, atomic formula or atomic formula that's been indicated.",
    "start": "4268720",
    "end": "4275770"
  },
  {
    "text": "Um, and here we see some, uh, functions that have emerged called Skolem functions which I'll explain later.",
    "start": "4275770",
    "end": "4286135"
  },
  {
    "text": "And that's- that's basically it. So we have to handle variables and we're going to have to handle somehow.",
    "start": "4286135",
    "end": "4297340"
  },
  {
    "text": "And the way we do this is we- remember there's no quantifiers that show up here. And by default, everything is going to be universally quantified.",
    "start": "4297340",
    "end": "4305740"
  },
  {
    "text": "Which means that the existential quantifiers have to go away and the existential quantifiers get converted into these functions.",
    "start": "4305740",
    "end": "4314695"
  },
  {
    "text": "Okay. All right. So part one.",
    "start": "4314695",
    "end": "4320559"
  },
  {
    "text": "So there's again, the six, or I can't remember, six to eight step procedure. We start with this input.",
    "start": "4320560",
    "end": "4326935"
  },
  {
    "text": "What is the first thing what I wanna do? We wanna remove all the symbols that don't- shouldn't show up.",
    "start": "4326935",
    "end": "4333070"
  },
  {
    "text": "Get our symbol inventory correct. So we eliminate implication. This is the same as, you know, before.",
    "start": "4333070",
    "end": "4342400"
  },
  {
    "text": "So here is this thing implies this thing, and we replace that with not the first thing or not the second thing.",
    "start": "4342400",
    "end": "4352585"
  },
  {
    "text": "So now, the expressions are more gross but it's really the same rule that we- identity that we were invoking before.",
    "start": "4352585",
    "end": "4361495"
  },
  {
    "text": "It would do that for the inner expression. We push the negation inwards so when it",
    "start": "4361495",
    "end": "4370015"
  },
  {
    "text": "touches the atomic formulas it eliminates double negation.",
    "start": "4370015",
    "end": "4375310"
  },
  {
    "text": "So this is all old news. And something new here is we're going to standardize the variables.",
    "start": "4375310",
    "end": "4384610"
  },
  {
    "text": "So this step is technically not necessary. By standardizing variables, I just mean that, you know, this Y- this Y are actually different.",
    "start": "4384610",
    "end": "4392620"
  },
  {
    "text": "It's like having two local variables in two different functions. They have nothing to do with each other. Because we're gonna remove quantification later,",
    "start": "4392620",
    "end": "4400255"
  },
  {
    "text": "I'm just gonna make them separate. So this y gets replaced with a z. Okay. So now I have this.",
    "start": "4400255",
    "end": "4408130"
  },
  {
    "text": "I'm going to replace existentially quantified variables with Skolem functions.",
    "start": "4408130",
    "end": "4415030"
  },
  {
    "text": "Okay. So this requires a little bit of explanation. So I have exist z loves z of x.",
    "start": "4415030",
    "end": "4424090"
  },
  {
    "text": "Okay. And this existential is on the inside here.",
    "start": "4424090",
    "end": "4431244"
  },
  {
    "text": "So of this universal quantifier.",
    "start": "4431245",
    "end": "4436735"
  },
  {
    "text": "So in a way, z depends on x, for every x I might have a different z.",
    "start": "4436735",
    "end": "4443200"
  },
  {
    "text": "So to capture this dependency, I can't just drop exist z.",
    "start": "4443200",
    "end": "4448495"
  },
  {
    "text": "What I'm gonna do is I'm going to capture the dependency by turning z into a function,",
    "start": "4448495",
    "end": "4455750"
  },
  {
    "text": "and the same thing happens over here. I have exist y and I replace this lowercase y with a big Y that",
    "start": "4456090",
    "end": "4465730"
  },
  {
    "text": "depends on the variables that are universally quantified outside the scope here. Yeah?",
    "start": "4465730",
    "end": "4472780"
  },
  {
    "text": "[inaudible]",
    "start": "4472780",
    "end": "4480969"
  },
  {
    "text": "So loves all animals is on the- in the I guess the first part.",
    "start": "4480970",
    "end": "4486370"
  },
  {
    "text": "So everyone who likes all animals is loved by someone. So this is the someone part.",
    "start": "4486370",
    "end": "4492969"
  },
  {
    "text": "[inaudible]",
    "start": "4492970",
    "end": "4501999"
  },
  {
    "text": "Because here I push the negation inside. Yeah. Yeah. So remember,",
    "start": "4501999",
    "end": "4507370"
  },
  {
    "text": "when I push negation past for all, it becomes a exists.",
    "start": "4507370",
    "end": "4512690"
  },
  {
    "text": "Okay. So now, I can distribute or over and to change the order",
    "start": "4513210",
    "end": "4522040"
  },
  {
    "text": "of the- of these connectives so that because in CNF I want a conjunction of disjuncts not disjunction of conjuncts.",
    "start": "4522040",
    "end": "4531410"
  },
  {
    "text": "And finally, I just ditch all the universal quantifiers.",
    "start": "4531960",
    "end": "4537620"
  },
  {
    "text": "Okay. Okay. So I don't expect you to follow all that in complete detail but this is just giving you a basic idea.",
    "start": "4537650",
    "end": "4547864"
  },
  {
    "text": "Okay. So now we're ready to state the resolution rule. And this should look very familiar.",
    "start": "4547865",
    "end": "4553860"
  },
  {
    "text": "It's the same resolution rule as before. But now all of these things are not propositional symbols but atomic formula.",
    "start": "4553860",
    "end": "4561170"
  },
  {
    "text": "And now, this is not p and not p, but p and not q.",
    "start": "4561170",
    "end": "4567475"
  },
  {
    "text": "And I- because these in general might be different and I need to unify them. And then I will take this substitution return by",
    "start": "4567475",
    "end": "4575410"
  },
  {
    "text": "unification and I'm going to apply it on the result. The same way we did for modus ponens.",
    "start": "4575410",
    "end": "4581770"
  },
  {
    "text": "So here's an example of this of animal or loves, and over here I have not loves or feeds.",
    "start": "4581770",
    "end": "4589780"
  },
  {
    "text": "And what do I do? I try to unify this loves with this not loves and I get this substitution.",
    "start": "4589780",
    "end": "4599050"
  },
  {
    "text": "So u has to be replaced with z of x, and v with x.",
    "start": "4599050",
    "end": "4604540"
  },
  {
    "text": "And that allows me to cancel these now. Now I've made them equal. And now I take the remaining parts and I apply the substitution.",
    "start": "4604540",
    "end": "4613870"
  },
  {
    "text": "So this feeds u of v becomes feeds z of x and x.",
    "start": "4613870",
    "end": "4620000"
  },
  {
    "text": "Okay. So there's a bit more intuition I can provide but this",
    "start": "4620490",
    "end": "4627925"
  },
  {
    "text": "does become a little bit abstract and you just kind of have to trust that resolution is doing its job.",
    "start": "4627925",
    "end": "4634930"
  },
  {
    "text": "I personally find it kind of difficult to look at intermediate stages of logical inference and really get any intuition about the individual pieces.",
    "start": "4634930",
    "end": "4644095"
  },
  {
    "text": "But- but that's why you define the principle, is to prove that they're right and then you trust that logical inference does the right thing.",
    "start": "4644095",
    "end": "4651295"
  },
  {
    "text": "Okay. To summarize, we've talked about propositional logic and first-order logic.",
    "start": "4651295",
    "end": "4656650"
  },
  {
    "text": "So for inference in propositional logic, you could just do model checking which means that convert it to a CSP and solve it.",
    "start": "4656650",
    "end": "4664284"
  },
  {
    "text": "In first-order logic, there's no way to enumerate all the possible infinite models. So you can't do that.",
    "start": "4664285",
    "end": "4670885"
  },
  {
    "text": "But in certain cases you can propositionalize and you can reduce first- order logic to propositional logic, in certain cases.",
    "start": "4670885",
    "end": "4678790"
  },
  {
    "text": "Or you can stick with inference rules. And if you stick with inference rules, you can use modus ponens on",
    "start": "4678790",
    "end": "4686080"
  },
  {
    "text": "the Horn clauses or you can- if you don't want to restrict your horn clauses,",
    "start": "4686080",
    "end": "4692200"
  },
  {
    "text": "you can use resolution. And the only thing that's different about",
    "start": "4692200",
    "end": "4697420"
  },
  {
    "text": "first-order logic here is the plus plus which means that you have to use unification and substitution.",
    "start": "4697420",
    "end": "4704380"
  },
  {
    "text": "Okay. Final takeaway is, you know, there's a lot of kind of symbol manipulation on",
    "start": "4704380",
    "end": "4711699"
  },
  {
    "text": "the details here but I wanted to kind of stress the importance of logic as expressive language to represent knowledge and reason with it.",
    "start": "4711700",
    "end": "4721990"
  },
  {
    "text": "And the key idea in first-order logic is the use of variables. So these are very not the same notion of variables as in,",
    "start": "4721990",
    "end": "4731755"
  },
  {
    "text": "in CSPs those variables are propositional symbols which are like the simplest thing and logic.",
    "start": "4731755",
    "end": "4737800"
  },
  {
    "text": "So in logic, first-order logic, we've kind of gone up of a kind of a layer in the expressive hierarchy.",
    "start": "4737800",
    "end": "4745795"
  },
  {
    "text": "And variables here allow you to, um, you know, give compact representations to a very, you know, rich thing.",
    "start": "4745795",
    "end": "4756550"
  },
  {
    "text": "So again, that kind of- if you don't remember anything, just remember the takeaway that logic allows you to express",
    "start": "4756550",
    "end": "4763600"
  },
  {
    "text": "very complicated and big things using kind of small formulas. Okay. So that's it. On Wednesday,",
    "start": "4763600",
    "end": "4771430"
  },
  {
    "text": "I'll be giving a lecture on deep learning and there is one and then we have the poster session after Thanksgiving.",
    "start": "4771430",
    "end": "4780070"
  },
  {
    "text": "And then the final lecture that I will give, that will sum everything up. So, okay.",
    "start": "4780070",
    "end": "4785230"
  },
  {
    "text": "I will see you at the poster session, and good luck on the exam.",
    "start": "4785230",
    "end": "4789470"
  }
]