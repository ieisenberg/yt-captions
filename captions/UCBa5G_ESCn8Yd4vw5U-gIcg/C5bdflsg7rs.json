[
  {
    "start": "0",
    "end": "120000"
  },
  {
    "text": "Today, we're gonna look at the topic of semantic parsing. And this is my favorite topic of the class,",
    "start": "4940",
    "end": "11200"
  },
  {
    "text": "and it's one of my favorite topics in NLP altogether. Um, when I was at Google,",
    "start": "11200",
    "end": "16740"
  },
  {
    "text": "my team was responsible for doing semantic query parsing for Google Search and for the Google Assistant.",
    "start": "16740",
    "end": "23925"
  },
  {
    "text": "So we applied the semantic parsing techniques that we're gonna look at today to billions of queries every day and in 40 major languages.",
    "start": "23925",
    "end": "32460"
  },
  {
    "text": "Um, now, I'm at Apple, and we use very similar techniques for query understanding for Siri.",
    "start": "32460",
    "end": "38670"
  },
  {
    "text": "So semantic parsing is highly strategic for Google, and Apple, and Amazon, and Microsoft.",
    "start": "38670",
    "end": "44000"
  },
  {
    "text": "Uh, and it's also been a very hot topic in academic research over the last five or ten years.",
    "start": "44000",
    "end": "49645"
  },
  {
    "text": "Now, semantic parsing is a big topic, it's a complex topic, uh, I think more than any of the other topics that we've covered,",
    "start": "49645",
    "end": "56440"
  },
  {
    "text": "it draws on concepts from linguistics and logic. Um, so I can't possibly do the topic justice in,",
    "start": "56440",
    "end": "65225"
  },
  {
    "text": "uh, just the next hour that we have. But fortunately, if this topic catches your interest,",
    "start": "65225",
    "end": "70470"
  },
  {
    "text": "we have an abundance of material on the website that can help you go deeper. Um, we have a series of four codebooks that",
    "start": "70470",
    "end": "77390"
  },
  {
    "text": "introduce a simple semantic parsing system called SippyCup. Um, Chris has made a few screencasts that",
    "start": "77390",
    "end": "84905"
  },
  {
    "text": "explained the main ideas in very simple and approachable terms. And there's also this terrific paper that Chris co-authored with Percy Liang in",
    "start": "84905",
    "end": "93830"
  },
  {
    "text": "2015 that I think conveys the main ideas of semantic parsing very clearly and very concisely.",
    "start": "93830",
    "end": "101380"
  },
  {
    "text": "For today's lecture, I think the best that I can do is, uh, first, to give you some high level motivation for why",
    "start": "101380",
    "end": "107885"
  },
  {
    "text": "this is a problem that you might care about, why this is an interesting and impactful problem. And second, to- to describe",
    "start": "107885",
    "end": "115099"
  },
  {
    "text": "the standard approach to semantic parsing in- in very high level terms.",
    "start": "115099",
    "end": "120030"
  },
  {
    "start": "120000",
    "end": "190000"
  },
  {
    "text": "So let me begin by talking a little bit about the motivation for semantic parsing. Um, at this point in the course,",
    "start": "122480",
    "end": "128270"
  },
  {
    "text": "you might be asking yourself, \"Wait, I thought we were supposed to be doing natural language understanding,",
    "start": "128270",
    "end": "133444"
  },
  {
    "text": "but I still don't know how to build C3PO. I still don't know how to build a robot that can really understand me.\"",
    "start": "133445",
    "end": "141230"
  },
  {
    "text": "Uh, the stuff that we've looked at so far, um, vector space models of meaning, sentiment analysis, relation extraction.",
    "start": "141230",
    "end": "148590"
  },
  {
    "text": "They seem to capture aspects of meaning or fragments of meaning. But there's still a lot that's missing.",
    "start": "148590",
    "end": "155585"
  },
  {
    "text": "We still don't know how to generate complete precise representations of the meanings of full sentences.",
    "start": "155585",
    "end": "162605"
  },
  {
    "text": "And there are still many aspects of meaning that we don't know how to capture. So for example, things like higher erroty relations,",
    "start": "162605",
    "end": "170795"
  },
  {
    "text": "or events with multiple participants, or temporal aspects, like this example, uh,",
    "start": "170795",
    "end": "176224"
  },
  {
    "text": "Barack and Michelle Obama got married in 1992 in Chicago. Or logical relationships as in,",
    "start": "176225",
    "end": "184485"
  },
  {
    "text": "no one may enter the building except policemen or firefighters.",
    "start": "184485",
    "end": "189360"
  },
  {
    "start": "190000",
    "end": "310000"
  },
  {
    "text": "As an example, try to imagine building a natural language understanding system that could answer logic puzzles like this one.",
    "start": "190430",
    "end": "198140"
  },
  {
    "text": "This was actually the very first project that I worked on when I was a young, eager PhD student became- before I became disillusioned.",
    "start": "198140",
    "end": "206060"
  },
  {
    "text": "Uh, this is a type of logic puzzle that appears on the LSAT exam,",
    "start": "206060",
    "end": "211145"
  },
  {
    "text": "and it used to appear on the GRE exam as well. Uh, this is a typical example, and this is basically a constraint satisfaction problem, a CSP.",
    "start": "211145",
    "end": "219560"
  },
  {
    "text": "So you have six sculptures which you need to assign to three rooms while respecting some constraints that are given there.",
    "start": "219560",
    "end": "227915"
  },
  {
    "text": "The interesting thing about this type of puzzle is, it's difficult for humans and it's difficult for computers.",
    "start": "227915",
    "end": "235970"
  },
  {
    "text": "But what makes it difficult is completely different for humans and for computers. For humans, understanding the language is easy.",
    "start": "235970",
    "end": "244675"
  },
  {
    "text": "And in fact, the authors, I guess ETS, uh, has taken great pains to ensure that the language is clear and unambiguous.",
    "start": "244675",
    "end": "255769"
  },
  {
    "text": "They really wanna avoid any misunderstandings, where like, the human readers just didn't get it.",
    "start": "255770",
    "end": "261200"
  },
  {
    "text": "So they work hard to make the language very clear and unambiguous. For humans, the language is easy, but solving CSPs,",
    "start": "261200",
    "end": "269925"
  },
  {
    "text": "doing the logic part of it is hard, and that's what this is supposed to be testing. For computers, it's the other way around.",
    "start": "269925",
    "end": "275780"
  },
  {
    "text": "For computers, solving CSPs is easy. In fact, it's trivial. For computers, understanding the language is hard.",
    "start": "275780",
    "end": "283910"
  },
  {
    "text": "If we could build a model that would automatically translate this text into formulas of formal logic,",
    "start": "283910",
    "end": "290960"
  },
  {
    "text": "then a theorem prover can do the rest. It'll be completely, uh, trivial for a theorem prover.",
    "start": "290960",
    "end": "296985"
  },
  {
    "text": "But that translation, translating this into formal logic is far more difficult than it might at first appear.",
    "start": "296985",
    "end": "303410"
  },
  {
    "text": "Uh, and to illustrate this, I wanna take a close look at just a few specific challenges that might arise.",
    "start": "303410",
    "end": "310045"
  },
  {
    "start": "310000",
    "end": "660000"
  },
  {
    "text": "So our challenge is, build a system that can translate these words into formulas of first-order logic.",
    "start": "310045",
    "end": "317120"
  },
  {
    "text": "Um, one challenge is that many words have semantic idiosyncrasies.",
    "start": "317120",
    "end": "323540"
  },
  {
    "text": "So an example is the word, same. So consider this sentence, \"Sculptures D and G must be exhibited in the same room.\"",
    "start": "323540",
    "end": "332130"
  },
  {
    "text": "If you translate this into formal logic, you're probably gonna get something like this.",
    "start": "332620",
    "end": "339040"
  },
  {
    "text": "So I've glossed over some details here like I didn't worry about existentially quantifying variables X and Y.",
    "start": "339040",
    "end": "347090"
  },
  {
    "text": "But I think it's enough to convey the- the basic idea. What this says is,",
    "start": "347090",
    "end": "352095"
  },
  {
    "text": "if D is in X, so D is a sculpture and X is a room. If D is in room X and G is in room Y,",
    "start": "352095",
    "end": "360120"
  },
  {
    "text": "then X and Y must be equal to each other. Okay. So that seems straightforward.",
    "start": "360120",
    "end": "365490"
  },
  {
    "text": "But the point I wanna make is that this adjective, same is a funny kind of adjective.",
    "start": "365490",
    "end": "372410"
  },
  {
    "text": "And to make that clear, let me compare it to some other adjectives. Let's instead look at this sentence,",
    "start": "372410",
    "end": "377759"
  },
  {
    "text": "\"Sculptures D and G must be exhibited in the red room.\" Think about what that logical form for that would look like.",
    "start": "377760",
    "end": "385730"
  },
  {
    "text": "It might look something like this, \"If it starts off the same way, if D is in X and G is in Y,",
    "start": "385730",
    "end": "391020"
  },
  {
    "text": "then X is red and Y is red.\" By the way, I'm using sort of a list be- list- like,",
    "start": "391020",
    "end": "397680"
  },
  {
    "text": "list- like syntax here rather than standard first-order logic syntax, but hopefully, it's still under it doesn't really",
    "start": "397680",
    "end": "404090"
  },
  {
    "text": "matter what the syntax is and hopefully it's still understandable. Uh, you might quibble with my logical form here because, well,",
    "start": "404090",
    "end": "411530"
  },
  {
    "text": "I didn't properly account for the semantics of the- the definite determiner which is a very rich topic in itself,",
    "start": "411530",
    "end": "417845"
  },
  {
    "text": "but I think that's, uh, an issue that we can safely put to the side, it's not really the main point here.",
    "start": "417845",
    "end": "422855"
  },
  {
    "text": "The real point is, when I say the red room or a red room, maybe it will be better, um,",
    "start": "422855",
    "end": "430100"
  },
  {
    "text": "I'm just, uh, asserting something about, uh, the rooms that D and G are in.",
    "start": "430100",
    "end": "437539"
  },
  {
    "text": "I'm saying whatever room D is in, it's gotta be a red room and whatever room, uh, G is in,",
    "start": "437540",
    "end": "443645"
  },
  {
    "text": "it's gotta be a red room as well. And if I look at other adjectives like if I change it to large room or smelly room,",
    "start": "443645",
    "end": "453255"
  },
  {
    "text": "it's gonna have the same kind of semantics. It's gonna be the same mapping into a logical form. Does everybody buy that?",
    "start": "453255",
    "end": "460730"
  },
  {
    "text": "Do these logical forms look more or less right putting aside issues like the- the definite determiner?",
    "start": "460730",
    "end": "467595"
  },
  {
    "text": "Red, and large, and smelly are ordinary adjectives, they're what's called intersective adjectives.",
    "start": "467595",
    "end": "474590"
  },
  {
    "text": "They have semantics which are intersective. Same is a funny kind of adjective,",
    "start": "474590",
    "end": "479720"
  },
  {
    "text": "it's called an anaphoric adjective. And it- it- that refers to the- to the idea that the semantics of same,",
    "start": "479720",
    "end": "487150"
  },
  {
    "text": "um, uh, refer back to something earlier in the sentence. The same room, it's not a specific room or even a room with a specific quality,",
    "start": "487150",
    "end": "494699"
  },
  {
    "text": "it's just whatever room D and G are in. If you build- let's say you've successfully built",
    "start": "494700",
    "end": "501560"
  },
  {
    "text": "machinery that can do semantic interpretation of this sentence, and this sentence, and this sentence,",
    "start": "501560",
    "end": "506690"
  },
  {
    "text": "it can successfully handle ordinary adjectives. That same machinery is gonna break down when it gets to an adjective like same,",
    "start": "506690",
    "end": "514745"
  },
  {
    "text": "which syntactically looks identical, but semantically behaves very differently.",
    "start": "514745",
    "end": "520260"
  },
  {
    "text": "And there are other examples too. If you're an eager young PhD student,",
    "start": "520380",
    "end": "525520"
  },
  {
    "text": "you might think, \"Oh, okay. I ran into a problem. No worries. I'll just fix it. I'll just make my model know about same.\"",
    "start": "525520",
    "end": "532420"
  },
  {
    "text": "But then you realize, there are more problems like that. There's other anaphoric adjectives like different,",
    "start": "532420",
    "end": "539455"
  },
  {
    "text": "which have similar properties and you might say, \"Okay, well, I'll just add another epicycle to my model and I can handle that one as well.\"",
    "start": "539455",
    "end": "545755"
  },
  {
    "text": "But then you start to encounter more and more and more quirky semantic phenomena that are not anaphoric adjectives,",
    "start": "545755",
    "end": "552100"
  },
  {
    "text": "but have other kinds of idiosyncrasies that you haven't accounted for in, ah, in advance.",
    "start": "552100",
    "end": "557605"
  },
  {
    "text": "Let me give you a different, ah, kind of challenge. The challenge of scope ambiguity. And to introduce this, I'm gonna use,",
    "start": "557605",
    "end": "564700"
  },
  {
    "text": "ah, a joke from Groucho Marx. It's not a very good joke, but it is a good example of scope ambiguity.",
    "start": "564700",
    "end": "570879"
  },
  {
    "text": "It starts off, \"In this country, a woman gives birth every 15 minutes.\" Okay. I didn't know that, but all right.",
    "start": "570880",
    "end": "578305"
  },
  {
    "text": "And then he continues, \"Our job is to find that woman and stop her.\" So this joke hinges on a semantic ambiguity.",
    "start": "578305",
    "end": "585910"
  },
  {
    "text": "When you read the first part, you're like, \"Okay. Every 15 minutes, there is some woman who gives birth.\"",
    "start": "585910",
    "end": "592660"
  },
  {
    "text": "But when you get to the second part, he's giving that first sentence a different reading instead,",
    "start": "592660",
    "end": "597855"
  },
  {
    "text": "there is a specific woman who gives birth every 15 minutes. That's the semantic ambiguity.",
    "start": "597855",
    "end": "604120"
  },
  {
    "text": "It's a question of whether the universal quantifier, every, or the existential quantifier, a, takes wider scope.",
    "start": "604120",
    "end": "611305"
  },
  {
    "text": "Um, because I'm a language nerd, I collect examples of scope ambiguities.",
    "start": "611305",
    "end": "617830"
  },
  {
    "text": "That's a perfectly normal thing to do, right? Uh, and I have another nice one which has exactly the same structure.",
    "start": "617830",
    "end": "623950"
  },
  {
    "text": "\"Children, there is a time and place for everything.\" You can see again it has the- the- the existential quantifier and universal quantifier.",
    "start": "623950",
    "end": "631870"
  },
  {
    "text": "So the, you know, the- the standard reading is, \"For everything, there exists some time and place for that thing.\"",
    "start": "631870",
    "end": "639775"
  },
  {
    "text": "But the alternate reading is, ah, \"There is one specific time and place which is the time for everything.\"",
    "start": "639775",
    "end": "649045"
  },
  {
    "text": "Right? and the joke continues, \"And it is called college.\" This is from South Park. I thought that",
    "start": "649045",
    "end": "655990"
  },
  {
    "text": "might resonate with you guys because you're at the university. Um, so this is the- this is- this is the idea of scope ambiguity.",
    "start": "655990",
    "end": "663460"
  },
  {
    "start": "660000",
    "end": "945000"
  },
  {
    "text": "How does it relate to the LSAT puzzle that I just showed you? Well, um, one part of that LSAT puzzle was this,",
    "start": "663460",
    "end": "670465"
  },
  {
    "text": "\"No more than three sculptures may be exhibited in any room.\" So this is interesting because",
    "start": "670465",
    "end": "678940"
  },
  {
    "text": "there's not just one possible reading here or even two possible readings, there is at least three possible readings here,",
    "start": "678940",
    "end": "686709"
  },
  {
    "text": "which if you render them as first-order logic, are quite different in terms of their logical form and their logical consequences.",
    "start": "686710",
    "end": "695305"
  },
  {
    "text": "But all are plausible readings of this sentence. And from a computer's perspective,",
    "start": "695305",
    "end": "701200"
  },
  {
    "text": "there is no way to know in advance which one is the correct reading. I think the most obvious one,",
    "start": "701200",
    "end": "706390"
  },
  {
    "text": "the one that the authors intended you to get was this one.",
    "start": "706390",
    "end": "713275"
  },
  {
    "text": "There cannot be a room that contains more than three sculptures. But there's some other possible readings here.",
    "start": "713275",
    "end": "721630"
  },
  {
    "text": "Can anybody think of another way of reading this sentence? No more than three sculptures may be exhibited in any room,",
    "start": "721630",
    "end": "728920"
  },
  {
    "text": "that has different- that would have a different logical form, that has different logical consequences? Yeah.",
    "start": "728920",
    "end": "735790"
  },
  {
    "text": "Do you consider, uh, no room should have more than three [NOISE] sculptures across?",
    "start": "735790",
    "end": "742959"
  },
  {
    "text": "You know, like, across a specified- like you can't have one and then take it out and then bring another one, take it out and then bring another one.",
    "start": "742960",
    "end": "749634"
  },
  {
    "text": "So in the end it has three but [OVERLAPPING]. Oh, that's interesting. I think that that says-",
    "start": "749635",
    "end": "754870"
  },
  {
    "text": "That's how- that's not one of the ones I was thinking of but, ah, you're- you're touching on, ah, something about whether we're talking about a single point in time or over time,",
    "start": "754870",
    "end": "765880"
  },
  {
    "text": "um, whether, ah, whether the assignment of sculptures to rooms could change over time.",
    "start": "765880",
    "end": "774400"
  },
  {
    "text": "Yeah. Yeah. Ah, is it that there cannot be any- no more than three sculptures,",
    "start": "774400",
    "end": "781464"
  },
  {
    "text": "as long as they present it again? As long as they what? They pres- they are in a room. So a sculpture is in a room?",
    "start": "781465",
    "end": "788095"
  },
  {
    "text": "Yeah. You could- you could read this as, \"No more th- no more than three sculptures may be exhibited in any room.\"",
    "start": "788095",
    "end": "796585"
  },
  {
    "text": "Like, it doesn't matter what room it is. No more than three sculptures maybe exhibited at all, in any room.",
    "start": "796585",
    "end": "803620"
  },
  {
    "text": "That reading of this sentence is maybe a little bit less obvious and a little bit less accessible than the first one.",
    "start": "803620",
    "end": "811465"
  },
  {
    "text": "But I think there are ways of contextualizing this that make that reading plausible.",
    "start": "811465",
    "end": "816865"
  },
  {
    "text": "Are there any differences between the first and the second in this case? Yeah. Yes, there are.",
    "start": "816865",
    "end": "822310"
  },
  {
    "text": "Because in the first one, a possible world- something- a possible configuration that's consistent",
    "start": "822310",
    "end": "830530"
  },
  {
    "text": "with the first sentence is you have two sculptures in this room and two sculptures in that room. But that is not consistent with the second reading,",
    "start": "830530",
    "end": "838915"
  },
  {
    "text": "which says, \"No more than three may be- may be exhibited at all.\" Totally at all.",
    "start": "838915",
    "end": "844420"
  },
  {
    "text": "Yeah. Exactly. So they have different logical consequences depending which one you're reading.",
    "start": "844420",
    "end": "851079"
  },
  {
    "text": "Um, there's actually a third reading which I think is even harder to get to but I- I claim is still a plausible reading of the first sentence.",
    "start": "851080",
    "end": "859615"
  },
  {
    "text": "And that one is, \"At most three sculptures have the property that they may be be- may be exhibited in any room.",
    "start": "859615",
    "end": "865840"
  },
  {
    "text": "For other sculptures, there are restrictions on allowable rooms.\" So go back to that first sentence now,",
    "start": "865840",
    "end": "870985"
  },
  {
    "text": "\"No more than three sculptures may- no more than three sculptures may be exhibited in any room.\"",
    "start": "870985",
    "end": "877165"
  },
  {
    "text": "The other ones have restrictions. Right? That's a plausible reading. It's not the most obvious reading,",
    "start": "877165",
    "end": "883360"
  },
  {
    "text": "but it's a plausible reading. And from the perspective of a computer algorithm, like computers don't have intuitions about",
    "start": "883360",
    "end": "890830"
  },
  {
    "text": "which one of these things is more plausible or less plausible. Um, so when you're building a system to- to map the sentences into logical forms,",
    "start": "890830",
    "end": "901015"
  },
  {
    "text": "your senten- your model probably needs to account for all of those possibilities. Because in different contexts,",
    "start": "901015",
    "end": "907180"
  },
  {
    "text": "any one of them might be the correct interpretation. Of course, you also hope that your model will be able to make",
    "start": "907180",
    "end": "913060"
  },
  {
    "text": "good predictions about which one is more likely and less likely, uh, and a little bit later we'll look at ways of,",
    "start": "913060",
    "end": "919810"
  },
  {
    "text": "um, building a scoring model which will help you, uh, choose among multiple possible parses,",
    "start": "919810",
    "end": "927070"
  },
  {
    "text": "multiple interpretations of a given input. Um, I'm not gonna say anything more about the LSAT puzzle but I could go on.",
    "start": "927070",
    "end": "936910"
  },
  {
    "text": "There are lots more challenges. I'll just mention one- one other off the top my head. Um, if you, um,",
    "start": "936910",
    "end": "944320"
  },
  {
    "text": "there's nothing in the problem itself. Let me go back to that problem. There's nothing in the problem that says,",
    "start": "944320",
    "end": "954999"
  },
  {
    "start": "945000",
    "end": "1360000"
  },
  {
    "text": "\"A sculpture can only be in one place at one time.\" There's nothing that says a sculpture can't be in two rooms at the same time.",
    "start": "954999",
    "end": "963895"
  },
  {
    "text": "But if you just map this into first order logic and then give it to a theorem prover, the theorem prover will happily put one sculpture in two different rooms.",
    "start": "963895",
    "end": "971905"
  },
  {
    "text": "Because that's common sense knowledge that a- that a sculpture can't be in two different places at the same time.",
    "start": "971905",
    "end": "976930"
  },
  {
    "text": "A human just fills that in automatically, without even thinking about it. But a computer doesn't know to do that.",
    "start": "976930",
    "end": "982690"
  },
  {
    "text": "So you ha- have to, ah, if you wanna make this work, you have to also supply all kinds of background knowledge which is kind of unstated in this problem.",
    "start": "982690",
    "end": "990610"
  },
  {
    "text": "So um, we started this problem, you know, ah, as I mentioned at the beginning of my PhD and we worked on",
    "start": "990610",
    "end": "997600"
  },
  {
    "text": "it for about like three months and the further we got into it, the more we realized we're not gonna solve this problem.",
    "start": "997600",
    "end": "1004500"
  },
  {
    "text": "And that was like 15 years ago. And as far as I know, this problem remains unsolved today. This is a really hard challenge.",
    "start": "1004500",
    "end": "1011025"
  },
  {
    "text": "But it looks, at first glance, like it should be achievable.",
    "start": "1011025",
    "end": "1015820"
  },
  {
    "text": "Okay. Here's a very different kind of example. Um, this, this is taken from a consulting project. Yeah.",
    "start": "1024230",
    "end": "1032220"
  },
  {
    "text": "It's like graduate students kind of perspective on it. Has anyone tried to do this with a more limited scope",
    "start": "1032220",
    "end": "1039240"
  },
  {
    "text": "and using something like a knowledge base for grounding, kind of similar to what we talked about on this lecture?",
    "start": "1039240",
    "end": "1044760"
  },
  {
    "text": "I'm not sure. Yeah. It's a good intuition though,",
    "start": "1044760",
    "end": "1052620"
  },
  {
    "text": "uh, that you could, it can give you a lot of constraints that I was talking about might come from the domain that you're in.",
    "start": "1052620",
    "end": "1059340"
  },
  {
    "text": "Uh, and that can be an interesting thing scientifically, uh, over trying to prove it. Thank you.",
    "start": "1059340",
    "end": "1067125"
  },
  {
    "text": "Um, so here's a very different kind of example. This is taken from a consulting project that I worked on when I was in grad school,",
    "start": "1067125",
    "end": "1073169"
  },
  {
    "text": "and I was working with a startup that wanted to build a natural language interface to a travel reservation system.",
    "start": "1073170",
    "end": "1079395"
  },
  {
    "text": "So they wanted to be able to understand and respond to natural language descriptions of travel needs like this.",
    "start": "1079395",
    "end": "1085350"
  },
  {
    "text": "The idea is you'd be able to, uh, send an email to this service and, um, they would automatically figure out some travel plans for you.",
    "start": "1085350",
    "end": "1093150"
  },
  {
    "text": "So what are some of the challenges to semantic interpretation that you see here?",
    "start": "1093150",
    "end": "1098920"
  },
  {
    "text": "There's lots of them. Yeah, what's,",
    "start": "1100640",
    "end": "1106230"
  },
  {
    "text": "what's an example of ambiguity here? Ambiguity in Oakland or SFO, you could use Sunday evening or Monday morning.",
    "start": "1106230",
    "end": "1112455"
  },
  {
    "text": "It's like we have to extract all of those and realize that they're on the same sort of fill in the blank blank that they made.",
    "start": "1112455",
    "end": "1118635"
  },
  {
    "text": "Yeah. One kind of ambiguity here, I mean, it refers to Oakland, but it doesn't actually make it clear whether Oakland is",
    "start": "1118635",
    "end": "1126210"
  },
  {
    "text": "an alternative to SFO or an alternative to Boston. Now as a human, you know that it's an alternative to SFO,",
    "start": "1126210",
    "end": "1134115"
  },
  {
    "text": "it wouldn't make sense to book a flight from SFO to Oakland. Uh, might be fun.",
    "start": "1134115",
    "end": "1140070"
  },
  {
    "text": "Um, but, uh, but an automated system, of course, you know, it, it, that relies on world knowledge",
    "start": "1140070",
    "end": "1146654"
  },
  {
    "text": "which might not be available to an automated system. What else could make this hard? Yeah.",
    "start": "1146655",
    "end": "1152355"
  },
  {
    "text": "I also just realized that the he later on, the first back to the husband about the different flight,",
    "start": "1152355",
    "end": "1158940"
  },
  {
    "text": "has to be,  the return flight has to be both of them. That's right, you have to, uh, resolve some anaphora here and figure out what that pronoun refers back to.",
    "start": "1158940",
    "end": "1168640"
  },
  {
    "text": "Um, and there's other, there's other, um, [NOISE] uh,",
    "start": "1169310",
    "end": "1176235"
  },
  {
    "text": "kinds of reference resolution here. Like, for example, Sunday evening or Monday morning,",
    "start": "1176235",
    "end": "1183324"
  },
  {
    "text": "we need to figure out that that refers to the Sunday that, presumably that refers to the Sunday that follows that Friday,",
    "start": "1183324",
    "end": "1191639"
  },
  {
    "text": "not the Sunday that precedes that Friday, right? So I guess we're talking about Sunday the 14th or Monday the 15th.",
    "start": "1191640",
    "end": "1198945"
  },
  {
    "text": "There's something else weird here which is that, if Friday is the 12th, then Wednesday can't be the 18th.",
    "start": "1198945",
    "end": "1207000"
  },
  {
    "text": "Like, mathematically that doesn't work. The human that, that Friday and Wednesday are five days apart,",
    "start": "1207000",
    "end": "1212430"
  },
  {
    "text": "but the 12th and the 18th are six days apart. The human made a mistake and the system has to deal with it somehow.",
    "start": "1212430",
    "end": "1218685"
  },
  {
    "text": "Like, a reasonable thing will be for the system to say, \"Did you mean Wednesday the 17th?\" Um, but unless you engineer that into the system,",
    "start": "1218685",
    "end": "1227190"
  },
  {
    "text": "it's not gonna be able to do it. What other, what other challenges do you see here? It seems like there's also some extraneous information like it,",
    "start": "1227190",
    "end": "1236070"
  },
  {
    "text": "uh, it's important that they don't want to fly on United, but it, this model probably doesn't need to care about why.",
    "start": "1236070",
    "end": "1241440"
  },
  {
    "text": "That's right. Or why has the husband is staying later. Yeah. So how to focus on what matters and what doesn't matter.",
    "start": "1241440",
    "end": "1249179"
  },
  {
    "text": "Hating their guts is an idiom. Um, so this, this gives you a,",
    "start": "1249180",
    "end": "1254490"
  },
  {
    "text": "a flavor of some of the kinds of things that you run into when you try to do complete and precise semantic interpretation on real-world problems.",
    "start": "1254490",
    "end": "1264150"
  },
  {
    "text": "This goal of seman- of complete and precise natural language understanding goes way back to the beginning.",
    "start": "1264150",
    "end": "1270075"
  },
  {
    "text": "Uh, last time Chris mentioned the SHRDLU system, which was developed almost 50 years ago by Terry Winograd when he was,",
    "start": "1270075",
    "end": "1277605"
  },
  {
    "text": "uh, a grad student, a PhD. Uh, he's now a professor here and he doesn't work on natural language understanding anymore.",
    "start": "1277605",
    "end": "1284070"
  },
  {
    "text": "But this was arguably the birthplace of natural language understanding. So SHRDLU is a blocks.",
    "start": "1284070",
    "end": "1289664"
  },
  {
    "text": "It's, it's an NLU system that's grounded in a blocks world. It parses the user's input. Uh, maps it to a logical form and then tries to interpret that logical form in its world,",
    "start": "1289665",
    "end": "1299405"
  },
  {
    "text": "and answer a question or take an appropriate action. Um, I give a you- link to a YouTube video here and it's worth checking out later.",
    "start": "1299405",
    "end": "1307040"
  },
  {
    "text": "The- these slides by the way are linked from the website, and from there you can find your way to this YouTube video. And it's kind of a fun video to watch.",
    "start": "1307040",
    "end": "1313250"
  },
  {
    "text": "Um, and so you can say, even quite complicated things, like find a block which is taller than the one you are holding and put it into the box.",
    "start": "1313250",
    "end": "1321415"
  },
  {
    "text": "And it understands and it just does the right thing. And at the time, people were totally wowed by this.",
    "start": "1321415",
    "end": "1328470"
  },
  {
    "text": "I mean, I think even half a century later, this kind of elicits a wow.",
    "start": "1328470",
    "end": "1333510"
  },
  {
    "text": "But certainly at that time, it really had people thinking that human level NLU was just around the corner.",
    "start": "1333510",
    "end": "1340710"
  },
  {
    "text": "But then, that excessive optimism crumbled when later systems, later systems tried to deal with",
    "start": "1340710",
    "end": "1347340"
  },
  {
    "text": "more realistic situations and with real-world ambiguity and complexity. Part of the reason this was achievable was that it was",
    "start": "1347340",
    "end": "1354000"
  },
  {
    "text": "this very constrained blocks world that, um, that we were operating within.",
    "start": "1354000",
    "end": "1359730"
  },
  {
    "text": "Another milestone for semantic parsing was the CHAT-80 system. Uh, this was developed around 1980 by Fernando Pereira,",
    "start": "1359730",
    "end": "1367004"
  },
  {
    "start": "1360000",
    "end": "1397000"
  },
  {
    "text": "who's now a research director at Google. So this was basically a natural language interface to a database of geographical facts.",
    "start": "1367004",
    "end": "1374010"
  },
  {
    "text": "So you could, uh, it could answer geographic queries like what's the capital of France, or how many countries are in Europe or things like that.",
    "start": "1374010",
    "end": "1381780"
  },
  {
    "text": "Uh, it was implemented in Prolog and it was, it used a hand built grammar,",
    "start": "1381780",
    "end": "1387360"
  },
  {
    "text": "uh, and a hand built lexicon. So there was no machine learning in sight,  it was just lots and lots of rules,",
    "start": "1387360",
    "end": "1393870"
  },
  {
    "text": "uh, that drove this, this semantic interpretation. Now, here's something astonishing.",
    "start": "1393870",
    "end": "1399705"
  },
  {
    "text": "It is still possible to run CHAT-80. Uh, even though this code is older than most of you,",
    "start": "1399705",
    "end": "1406755"
  },
  {
    "text": "you can still run it on the Stanford rice machines. Uh, and if you want to try it yourself, here's a recipe for getting started.",
    "start": "1406755",
    "end": "1413820"
  },
  {
    "text": "And it's actually really fun to, um, kick the tires and, and try it out and see what works and what doesn't work.",
    "start": "1413820",
    "end": "1421184"
  },
  {
    "text": "Um, in previous years, I've actually taken time in class to do this live in class, which is kind of fun,",
    "start": "1421185",
    "end": "1426915"
  },
  {
    "text": "but it's a little bit cumbersome and I feel like maybe the educational value of it isn't worth the, the cost.",
    "start": "1426915",
    "end": "1433770"
  },
  {
    "text": "So I'm not gonna do that this time. But, um, I want to show you some examples of, of some queries that, that it can handle.",
    "start": "1433770",
    "end": "1440549"
  },
  {
    "text": "So you can ask it, like, is there more than one country in each continent? By the way, what's the right, let's see how good you guys are at geography. No, why not.",
    "start": "1440550",
    "end": "1450840"
  },
  {
    "text": "In Antarctica and Australia. Yeah. Funny thing is, uh,",
    "start": "1450840",
    "end": "1455970"
  },
  {
    "text": "this system doesn't say, doesn't think that Australia is a continent. It thinks that Australasia is a continent.",
    "start": "1455970",
    "end": "1463740"
  },
  {
    "text": "So the reason it says, it does say no but the reason it says no is because of Antarctica and not because of Australia.",
    "start": "1463740",
    "end": "1468960"
  },
  {
    "text": "Uh, what countries border Denmark? It's a pretty easy question.",
    "start": "1468960",
    "end": "1474460"
  },
  {
    "text": "Yeah. Except, remember, it's 1980 [LAUGHTER].",
    "start": "1475490",
    "end": "1482880"
  },
  {
    "text": "Oh, the Soviet Union was there. No. East Germany? West Germany. West Germany, yeah.",
    "start": "1482880",
    "end": "1487890"
  },
  {
    "text": "It's- again, yeah, kinda, kinda, kinda funny to step into the time machine, back to the- back to the, um,",
    "start": "1487890",
    "end": "1495390"
  },
  {
    "text": "[NOISE] uh, Cold War and all that. Uh, I'll skip the next two,",
    "start": "1495390",
    "end": "1500640"
  },
  {
    "text": "but this- this one is really impressive. Which country bordering a Mediterranean- bordering the Mediterranean borders a country that is bordered by",
    "start": "1500640",
    "end": "1507540"
  },
  {
    "text": "a country whose population exceeds the population of India? CHAT-80 knows how to get this question right even",
    "start": "1507540",
    "end": "1514440"
  },
  {
    "text": "though it's incredibly syntactically complex. Can anybody get this one?",
    "start": "1514440",
    "end": "1519480"
  },
  {
    "text": "[NOISE]",
    "start": "1519480",
    "end": "1538380"
  },
  {
    "text": "All right. I'll let you guys think about that one. Its the country whose population makes [inaudible] the population [inaudible] is that Russia or?",
    "start": "1538380",
    "end": "1545294"
  },
  {
    "text": "China. China. So China is the only one. Is that the one? In 1980, I believe. [NOISE].",
    "start": "1545295",
    "end": "1554100"
  },
  {
    "text": "[inaudible]. I'll let you think about it. [LAUGHTER]. No, I'll let you go try CHAT-80 on the rice machines,",
    "start": "1554100",
    "end": "1559169"
  },
  {
    "text": "you can ask CHAT-80 [NOISE] and CHAT-80 will tell you the answer. Um, [NOISE] by the way, uh,",
    "start": "1559170",
    "end": "1565785"
  },
  {
    "text": "one of the things that I- that I- when I showed this slide, one of the things that I get out of it is trying out small variations.",
    "start": "1565785",
    "end": "1572909"
  },
  {
    "text": "So if, if instead of saying, what countries border Denmark, if I said what countries [NOISE] touch Denmark or what countries adjoin Denmark,",
    "start": "1572910",
    "end": "1581384"
  },
  {
    "text": "it frequently just says, \"I don't understand.\" You change one word and it just says I don't",
    "start": "1581384",
    "end": "1587580"
  },
  {
    "text": "understand because that other word or that other formulation, that other way of asking the question just wasn't in the hand-built grammar.",
    "start": "1587580",
    "end": "1594390"
  },
  {
    "text": "Uh, the last example kinda falls in the same bucket. How far is London from Paris? It feels like a question that has very similar flavor to all the other questions,",
    "start": "1594390",
    "end": "1603330"
  },
  {
    "text": "just another geographical question, but it turns out that no matter how you ask this question,",
    "start": "1603330",
    "end": "1608370"
  },
  {
    "text": "CHAT-80 just says, \"I don't understand.\" It doesn't know about distances between- it knows about like areas,",
    "start": "1608370",
    "end": "1615690"
  },
  {
    "text": "it'll tell you how many square miles, uh, you know, the total area of countries south of the Equator and not in Australasia,",
    "start": "1615690",
    "end": "1622095"
  },
  {
    "text": "but it can't tell you about distances between places. So it has two pretty profound limitations.",
    "start": "1622095",
    "end": "1629160"
  },
  {
    "text": "One is, um, that it is it only knows about certain things, it's certainly restricted to geography,",
    "start": "1629160",
    "end": "1636285"
  },
  {
    "text": "even within geography, it only knows about certain kinds of geographic facts. That's one restriction.",
    "start": "1636285",
    "end": "1641955"
  },
  {
    "text": "The other restriction is on the ph- the phrasing the allowable phrasing of questions.",
    "start": "1641955",
    "end": "1647640"
  },
  {
    "text": "Even questions that it knows the answer to, you have to express your question in a certain specific way.",
    "start": "1647640",
    "end": "1654645"
  },
  {
    "text": "Maybe if- maybe there are a few different ways that it can handle, but there are lots of other ways that to a human are",
    "start": "1654645",
    "end": "1660330"
  },
  {
    "text": "perfectly reasonable ways to ask that the system just can't handle. [NOISE] So on the one hand,",
    "start": "1660330",
    "end": "1666975"
  },
  {
    "text": "systems like SHRDLU and CHAT-80 are pretty astonishing because, um,",
    "start": "1666975",
    "end": "1672780"
  },
  {
    "text": "[NOISE] long before most of you guys were even born, these systems demonstrated precise and complete understanding",
    "start": "1672780",
    "end": "1681060"
  },
  {
    "text": "of even quite complex sentences. And, by the way, they did it while running on",
    "start": "1681060",
    "end": "1686865"
  },
  {
    "text": "hardware that's less powerful than you know my rice cooker. Um, admittedly, I have a really fancy rice cooker, [LAUGHTER] but still,",
    "start": "1686865",
    "end": "1695160"
  },
  {
    "text": "uh, it's, um, [NOISE] it's kind of impressive what they were able to do.",
    "start": "1695160",
    "end": "1700680"
  },
  {
    "text": "But their coverage was extremely narrow, it was limited to one specific domain, and even within that domain,",
    "start": "1700680",
    "end": "1706485"
  },
  {
    "text": "they were very brittle. If you ask a question this way, you get an answer; if you use just slightly different words, nothing.",
    "start": "1706485",
    "end": "1713220"
  },
  {
    "text": "[NOISE] Today, by contrast, we have systems that exhibit vastly greater robustness and with very broad coverage,",
    "start": "1713220",
    "end": "1722054"
  },
  {
    "text": "but with very fuzzy and partial understanding. So you can ask Google about just about anything and it never says \"I don't understand.\"",
    "start": "1722055",
    "end": "1732505"
  },
  {
    "text": "But it might not exactly ask your, uh, it might not exactly answer your question if you ask Google this question about",
    "start": "1732505",
    "end": "1741245"
  },
  {
    "text": "what country- which country bordering Mediterranean borders a country that is bordered by a country whose population exceeds the population of India.",
    "start": "1741245",
    "end": "1747639"
  },
  {
    "text": "Google is not gonna tell you the answer or actually what it probably will do is it will link you to my slides from last year,",
    "start": "1747640",
    "end": "1755010"
  },
  {
    "text": "um, which maybe had the answer. Um, but it's- it doesn't have that complete precise understanding that's needed to actually answer the question.",
    "start": "1755010",
    "end": "1762885"
  },
  {
    "text": "Uh, where we wanna be is up here with C-3PO and the pot of gold.",
    "start": "1762885",
    "end": "1768375"
  },
  {
    "text": "We want to build systems that can understand precisely, and completely, and robustly over broad domains.",
    "start": "1768375",
    "end": "1777180"
  },
  {
    "text": "[NOISE] Now, you might not feel super inspired by examples like that- that one,",
    "start": "1777180",
    "end": "1782880"
  },
  {
    "text": "what's the population of the largest continent, that- that one. Um, because let's be honest, who cares?",
    "start": "1782880",
    "end": "1788559"
  },
  {
    "text": "But the ability to answer these highly structured kind of database-y type of queries has lots of applications that are more compelling.",
    "start": "1788560",
    "end": "1797720"
  },
  {
    "text": "[NOISE] So, for example, if you're a policy analyst working on global warming, you wanna be able to answer questions like these.",
    "start": "1797720",
    "end": "1805575"
  },
  {
    "start": "1798000",
    "end": "1824000"
  },
  {
    "text": "And it's easy to imagine that you have a database that contains all kinds of statistics about carbon emissions.",
    "start": "1805575",
    "end": "1812235"
  },
  {
    "text": "But unless you are a programmer, you probably don't know how to write SQL queries to pull out the information that you need.",
    "start": "1812235",
    "end": "1818580"
  },
  {
    "text": "So it will be great to have a system where you could just type in questions like this and get the answer.",
    "start": "1818580",
    "end": "1823590"
  },
  {
    "text": "[NOISE] Here's another example. If you grew up in America, there's a good chance that you have an Uncle Barney who",
    "start": "1823590",
    "end": "1829440"
  },
  {
    "start": "1824000",
    "end": "1849000"
  },
  {
    "text": "is a total freak about baseball trivia. Uncle Barney would love to be able to ask questions like these,",
    "start": "1829440",
    "end": "1835935"
  },
  {
    "text": "but again he doesn't know how to write database queries. Um, but if you can invent a semantic parsing system,",
    "start": "1835935",
    "end": "1844305"
  },
  {
    "text": "um, maybe you can make a website and sell subscriptions and Uncle Barney will pay you 10 bucks a month. [NOISE] Ah, and here's an application that has become very important at Google,",
    "start": "1844305",
    "end": "1854010"
  },
  {
    "text": "and Apple, and Amazon, uh, voice commands for getting things done. [NOISE] Um, one thing to notice here is that",
    "start": "1854010",
    "end": "1861585"
  },
  {
    "text": "these queries are not well-served by conventional keyword-based search.",
    "start": "1861585",
    "end": "1868080"
  },
  {
    "text": "Just imagine if you ask Google, \"How do I get to the Ferry building by bike?\" And Google responded by showing web pages containing those terms.",
    "start": "1868080",
    "end": "1878250"
  },
  {
    "text": "That would be a disappointment because you don't want web pages containing those terms, you want a map with a blue line on it.",
    "start": "1878250",
    "end": "1885360"
  },
  {
    "text": "And the only way we can draw that map is if we know where you are and we compute a route, a route from where you are to the Ferry building,",
    "start": "1885360",
    "end": "1892245"
  },
  {
    "text": "and doing that requires understanding your intent in a complete and precise way.",
    "start": "1892245",
    "end": "1897450"
  },
  {
    "text": "So satisfying queries like these requires mapping them into structured machine-readable representations,",
    "start": "1897450",
    "end": "1902969"
  },
  {
    "text": "with meaning, that we can pass to a downstream component, uh, to take- to take action on. It requires semantic parsing.",
    "start": "1902969",
    "end": "1909840"
  },
  {
    "text": "[NOISE] So the goal of semantic parsing is to do precise complete, uh,",
    "start": "1909840",
    "end": "1916335"
  },
  {
    "start": "1911000",
    "end": "1938000"
  },
  {
    "text": "interpretation of linguistic inputs and to map those inputs into structured machine-readable representations of meaning.",
    "start": "1916335",
    "end": "1923610"
  },
  {
    "text": "[NOISE] So really important question is, what kind of semantic representation are we aiming at?",
    "start": "1923610",
    "end": "1929925"
  },
  {
    "text": "What's our target output? Um, and there are a lot of different possibilities kind of depending",
    "start": "1929925",
    "end": "1935279"
  },
  {
    "text": "on what the problem is and what the domain is. Um, [NOISE] if the goal is to facilitate data exploration and analysis,",
    "start": "1935280",
    "end": "1945750"
  },
  {
    "start": "1938000",
    "end": "1951000"
  },
  {
    "text": "then the right semantic representation might be a database query language like SQL.",
    "start": "1945750",
    "end": "1950970"
  },
  {
    "text": "[NOISE] Uh, for a robot control application, you might want a custom-designed procedural language.",
    "start": "1950970",
    "end": "1958140"
  },
  {
    "start": "1951000",
    "end": "1959000"
  },
  {
    "text": "[NOISE] For interpreting voice commands, you can often get away with a relatively simple meaning representation,",
    "start": "1958140",
    "end": "1965700"
  },
  {
    "start": "1959000",
    "end": "2031000"
  },
  {
    "text": "which is based around a fixed set of high-level intents that are parameterized by specific arguments.",
    "start": "1965700",
    "end": "1972210"
  },
  {
    "text": "So, for example, if the query is directions to SF by train, the semantic representation might be",
    "start": "1972210",
    "end": "1978570"
  },
  {
    "text": "something that first indicates that this is a travel query, so that's kind of indicating the intent here,",
    "start": "1978570",
    "end": "1984090"
  },
  {
    "text": "the type of intent. And then, with two parameters. One is a destination parameter and the value there is a Freebase ID,",
    "start": "1984090",
    "end": "1992765"
  },
  {
    "text": "which is the Freebase ID for San Francisco. And then the second parameter describes the transportation mode.",
    "start": "1992765",
    "end": "1999434"
  },
  {
    "text": "And here the value is, uh, I guess any num value, there's maybe like five different transportation modes and transit is one of them.",
    "start": "1999435",
    "end": "2008284"
  },
  {
    "text": "And so this little machine-readable expression conveys everything that you need to",
    "start": "2008285",
    "end": "2015320"
  },
  {
    "text": "pass to a back-end system which can actually like figure out the directions and draw a map and give it to the user,",
    "start": "2015320",
    "end": "2022580"
  },
  {
    "text": "uh, and similarly for other kinds of, uh, other kinds of queries here. [NOISE]",
    "start": "2022580",
    "end": "2032645"
  },
  {
    "start": "2031000",
    "end": "2050000"
  },
  {
    "text": "Okay. So to illustrate the central ideas of semantic parsing, we've created a simple semantic parser called SippyCup.",
    "start": "2032645",
    "end": "2040220"
  },
  {
    "text": "Although it's designed for simplicity and readability, it uses methods that are commonly used at Google and",
    "start": "2040220",
    "end": "2046820"
  },
  {
    "text": "Apple for semantic interpretation of user queries. Ah, and we produced a series of four codebooks that introduce SippyCup.",
    "start": "2046820",
    "end": "2054964"
  },
  {
    "start": "2050000",
    "end": "2108000"
  },
  {
    "text": "So Unit 0 is kind of a high level overview of semantic parsing,",
    "start": "2054965",
    "end": "2060020"
  },
  {
    "text": "and then the remaining units demonstrate the application of SippyCup to three different problem domains.",
    "start": "2060020",
    "end": "2065195"
  },
  {
    "text": "So Unit 1 focuses on the domain of natural language arithmetic. This is queries like 2 times 3 plus 4 as English words rather than mathematical symbols.",
    "start": "2065195",
    "end": "2074284"
  },
  {
    "text": "Um, Unit 2 focuses on the domain of travel queries. So this is queries like driving directions to Williamsburg Virginia, ah,",
    "start": "2074285",
    "end": "2081980"
  },
  {
    "text": "which has pretty obvious applications for assistant products like, ah, Google Assistant and Alexa and Siri.",
    "start": "2081980",
    "end": "2087935"
  },
  {
    "text": "Ah, and then finally, Unit 3 focuses on geographical queries. So things like how many states border the largest state,",
    "start": "2087935",
    "end": "2094129"
  },
  {
    "text": "and this has a very similar flavor to the kinds of, ah, queries that CHAT-80 takes on.",
    "start": "2094130",
    "end": "2099380"
  },
  {
    "text": "So Unit 3 kind of illustrates a modern machine learning based approach to the same problem that the CHAT-80 system took on.",
    "start": "2099380",
    "end": "2107520"
  },
  {
    "text": "By the way, this approach, that, that SippyCup, uh, illustrates was pioneered first by Luke Zettlemoyer and his group at Udub,",
    "start": "2108610",
    "end": "2117455"
  },
  {
    "text": "and later by Percy Liang, and his group here at Stanford. Um, so the key elements of this approach are, first,",
    "start": "2117455",
    "end": "2124385"
  },
  {
    "text": "a context-free grammar which defines the possible syntactic structures for the queries.",
    "start": "2124385",
    "end": "2129920"
  },
  {
    "text": "Ah, second, semantic attachments to the CFG rules, which enable bottom-up semantic interpretation.",
    "start": "2129920",
    "end": "2137405"
  },
  {
    "text": "Third, a log-linear scoring model for, which is learned from training data. Fourth, phrase annotators for recognizing names of people,",
    "start": "2137405",
    "end": "2147020"
  },
  {
    "text": "locations, dates, times, and so on. And finally, grammar induction, inducing grammars from training data",
    "start": "2147020",
    "end": "2154369"
  },
  {
    "text": "in order to quickly scale into new domains and new languages. Um, and over the following slides I'll,",
    "start": "2154370",
    "end": "2160940"
  },
  {
    "text": "I'll talk about each of these five elements in turn.",
    "start": "2160940",
    "end": "2165089"
  },
  {
    "start": "2167000",
    "end": "2330000"
  },
  {
    "text": "So let's start with the grammar. Ah, the grammar is the core of the semantic parsing system,",
    "start": "2167230",
    "end": "2172880"
  },
  {
    "text": "and it has two parts. It has a syntactic, a syntactic part and a semantic part. Um, the syntactic part is a fairly conventional context-free grammar.",
    "start": "2172880",
    "end": "2183005"
  },
  {
    "text": "So we have terminals like Google, and NY, and me, and bike, and car.",
    "start": "2183005",
    "end": "2189495"
  },
  {
    "text": "Um, and then we have non-terminals which we indicate with the dollar sign. So like $look, for example, is a non-terminal.",
    "start": "2189495",
    "end": "2198720"
  },
  {
    "text": "Um, and we also use, oh, we have a designated start symbol which,",
    "start": "2199000",
    "end": "2204590"
  },
  {
    "text": "ah, here we're by convention, we're calling $ROOT. So every derivation has to,",
    "start": "2204590",
    "end": "2210335"
  },
  {
    "text": "has to bottom out with $ROOT. We're also using a notational convenience here.",
    "start": "2210335",
    "end": "2217190"
  },
  {
    "text": "This question mark indicates that this element is optional, and so that's just a notational convenience.",
    "start": "2217190",
    "end": "2224525"
  },
  {
    "text": "If I wanted to avoid using this, I could instead have two rules here. One that has $ROOT,",
    "start": "2224525",
    "end": "2231125"
  },
  {
    "text": "and all this stuff without the parentheses and the question mark, and another rule which has $ROOT,",
    "start": "2231125",
    "end": "2237634"
  },
  {
    "text": "and all this stuff except that. So this is just saying, \"This could be here, or it could not be here, it's optional.\"",
    "start": "2237635",
    "end": "2244790"
  },
  {
    "text": "So this particular grammar fragment could be used to parse just a handful of queries.",
    "start": "2244790",
    "end": "2251180"
  },
  {
    "text": "It could be used to parse route",
    "start": "2251180",
    "end": "2256309"
  },
  {
    "text": "me to New York by car.",
    "start": "2256310",
    "end": "2263060"
  },
  {
    "text": "That's one possible thing that can match this grammar, or it could match,",
    "start": "2263060",
    "end": "2268355"
  },
  {
    "text": "um, route, I'll skip this, to, let me do a compound location,",
    "start": "2268355",
    "end": "2275660"
  },
  {
    "text": "Google in New York by bike or a handful of other queries.",
    "start": "2275660",
    "end": "2282859"
  },
  {
    "text": "Ah, there's not very many queries which match this very limited fragment, but it gives you a flavor of the,",
    "start": "2282860",
    "end": "2289190"
  },
  {
    "text": "the kinds of things that are, that are, that are achievable. Um, as is typical for grammars of natural language,",
    "start": "2289190",
    "end": "2297470"
  },
  {
    "text": "these grammars are usually non-deterministic. So if you've looked at CFGs in the context of programming languages like if you took CS143,",
    "start": "2297470",
    "end": "2307220"
  },
  {
    "text": "you're probably, there you probably have seen deterministic grammars where there's only one possible, ah, parse.",
    "start": "2307220",
    "end": "2314210"
  },
  {
    "text": "One possible interpretation for any given input. In linguistics, we typically deal with nondeterministic grammars,",
    "start": "2314210",
    "end": "2319730"
  },
  {
    "text": "where there are multiple possible parses for a given input. And that's important because natural language utterances are very often,",
    "start": "2319730",
    "end": "2327515"
  },
  {
    "text": "I dare say usually ambiguous. So here's an example of a parse for the input route me to Google in New York by car.",
    "start": "2327515",
    "end": "2336560"
  },
  {
    "text": "Ah, we recognize me as an optional word. We recognize Google, as a $loc, a location.",
    "start": "2336560",
    "end": "2343445"
  },
  {
    "text": "Recognized New York as a $loc, we then recognize $loc and $loc as a compound $loc.",
    "start": "2343445",
    "end": "2352340"
  },
  {
    "text": "Ah, we recognize bike as a $mode, and then because we've got a destination and a mode,",
    "start": "2352340",
    "end": "2359630"
  },
  {
    "text": "we can use that last rule to put the whole thing together into a $ROOT which is the the final,",
    "start": "2359630",
    "end": "2366875"
  },
  {
    "text": "ah, syntactic production parsing. So this is basically the syntactic parse,",
    "start": "2366875",
    "end": "2372020"
  },
  {
    "text": "one possible syntactic parse for that input. So far so good.",
    "start": "2372020",
    "end": "2378545"
  },
  {
    "text": "So this is the syntactic part of the grammar. Um, okay.",
    "start": "2378545",
    "end": "2386150"
  },
  {
    "text": "So given a grammar and an input query, we can generate all possible parses of the query using dynamic programming,",
    "start": "2386150",
    "end": "2395105"
  },
  {
    "text": "and specifically we use an adaptation of the well-known CYK chart parsing algorithm. So if you've ever looked at syntactic parsing before,",
    "start": "2395105",
    "end": "2403609"
  },
  {
    "text": "ah, you may have seen, ah, you may have seen this. Um, here's how it works.",
    "start": "2403610",
    "end": "2408859"
  },
  {
    "text": "The first thing we do is, we rewrite the grammar so that all of the rules in the grammar are binary or maybe unary.",
    "start": "2408860",
    "end": "2417965"
  },
  {
    "text": "Binary means they only have two things on the right-hand side. What we don't want to have, is three or four or five things on the right-hand side.",
    "start": "2417965",
    "end": "2425270"
  },
  {
    "text": "We want to have at most two things on the right-hand side. Then what we do, is we consider every span of tokens,",
    "start": "2425270",
    "end": "2432785"
  },
  {
    "text": "every subspan of the whole query, and we do that bottom-up. So we work our way up from very small spans,",
    "start": "2432785",
    "end": "2438980"
  },
  {
    "text": "like spans of one up to larger and larger spans. As we go, for every span,",
    "start": "2438980",
    "end": "2446150"
  },
  {
    "text": "we consider all way, all ways of splitting that span into two parts.",
    "start": "2446150",
    "end": "2451625"
  },
  {
    "text": "And then we consider every grammar rule whose right-hand side can match those two parts,",
    "start": "2451625",
    "end": "2458270"
  },
  {
    "text": "and that's why it's important to make the grammar binary, so that we only have to consider splitting things in two,",
    "start": "2458270",
    "end": "2463805"
  },
  {
    "text": "and not splitting things into three or four or five. Every time we have a grammar rule that match,",
    "start": "2463805",
    "end": "2469790"
  },
  {
    "text": "that can potentially match that right-hand side, that tells us that we have a way of making",
    "start": "2469790",
    "end": "2475640"
  },
  {
    "text": "the category which is on the left-hand side of the rule. And so we can record that as a possible, ah,",
    "start": "2475640",
    "end": "2484130"
  },
  {
    "text": "interpretation, a possible parse for that span, and that can be helpful as we work our way up to larger and larger spans,",
    "start": "2484130",
    "end": "2491240"
  },
  {
    "text": "because it can help us build bigger things above that. We can use those categories in trying to interpret larger spans.",
    "start": "2491240",
    "end": "2498359"
  },
  {
    "start": "2499000",
    "end": "2936000"
  },
  {
    "text": "Okay so that's the syntax. What about the semantic part of the grammar? Every rule in the CFG can come with what's known as a semantic attachment,",
    "start": "2499690",
    "end": "2509150"
  },
  {
    "text": "and I've shown the semantic attachments here in the square brackets in green. You can think of these semantic attachments as little programs that are",
    "start": "2509150",
    "end": "2519230"
  },
  {
    "text": "run when the parser applies the corresponding syntax rule,",
    "start": "2519230",
    "end": "2524375"
  },
  {
    "text": "and their outputs are fragments of our meaning representation.",
    "start": "2524375",
    "end": "2529685"
  },
  {
    "text": "Um, they basically, the semantic attachments basically specify how to construct",
    "start": "2529685",
    "end": "2535430"
  },
  {
    "text": "the semantics for the thing on the left-hand side from the semantics for the things on the right-hand side.",
    "start": "2535430",
    "end": "2543200"
  },
  {
    "text": "So, um, for Google, this one is very straightforward. The semantics for Google is just gonna be a freebase ID which means Google.",
    "start": "2543200",
    "end": "2553190"
  },
  {
    "text": "It's the entity Google. And similarly for New York. For $loc, in $loc.",
    "start": "2553190",
    "end": "2559355"
  },
  {
    "text": "Um, this thing says, \"The way to construct the semantics for this $loc,",
    "start": "2559355",
    "end": "2565020"
  },
  {
    "text": "is to build it up out of the semantics for this $loc, and this $loc, if you've already got semantics for this $loc, and this $loc,",
    "start": "2565020",
    "end": "2573290"
  },
  {
    "text": "I'm going to call the first one $1, and the second one $2, and this thing says,",
    "start": "2573290",
    "end": "2578494"
  },
  {
    "text": "\"Just take the semantics for this $loc, and semantics for that $loc, and stuff it into one of these S expressions with an in, in the front\".",
    "start": "2578495",
    "end": "2587690"
  },
  {
    "text": "It's a fragment of our- our meaning representation, and this thing tells us how to build up these pieces into larger and larger pieces.",
    "start": "2587690",
    "end": "2596400"
  },
  {
    "text": "These ones are straightforward. The semantics of, of a $mode is just one of these enum values,",
    "start": "2596410",
    "end": "2602450"
  },
  {
    "text": "and then the last thing that's interesting, is that this one tells us how to build the semantics for the entire request.",
    "start": "2602450",
    "end": "2609349"
  },
  {
    "text": "It says, \"It's a Get Directions Request.\" I guess that comes from the fact that it's a route.",
    "start": "2609350",
    "end": "2614944"
  },
  {
    "text": "Um, the destination is gonna be whatever the semantics is for this non-terminal,",
    "start": "2614945",
    "end": "2621645"
  },
  {
    "text": "and the mode is gonna be whatever the semantics is for this non-terminal. So these semantic attachments tell me exactly how to construct",
    "start": "2621645",
    "end": "2631610"
  },
  {
    "text": "my semantic representation from smaller pieces building up to larger, and larger pieces.",
    "start": "2631610",
    "end": "2638825"
  },
  {
    "text": "So here's our example parts again, but this time I've added in green the semantic yield associated with each node of the parse tree.",
    "start": "2638825",
    "end": "2645530"
  },
  {
    "text": "By the way, if you're a linguist, this is basically Montague semantics. It's bottom-up syntax driven semantic construction.",
    "start": "2645530",
    "end": "2653870"
  },
  {
    "text": "So first, we construct the semantics for Google and for New York as Freebase IDs.",
    "start": "2653870",
    "end": "2660170"
  },
  {
    "text": "Um, and for bike as an enum value, ah, then we combine these two to get the semantics for the compound location up there,",
    "start": "2660170",
    "end": "2670520"
  },
  {
    "text": "and finally we combine everything to get the semantics for the Get Directions Request at the top.",
    "start": "2670520",
    "end": "2677700"
  },
  {
    "text": "Okay, let me pause there because that was a lot to absorb.",
    "start": "2677980",
    "end": "2682800"
  },
  {
    "text": "Any questions so far?",
    "start": "2683440",
    "end": "2686700"
  },
  {
    "text": "Okay. Let me keep going.",
    "start": "2689340",
    "end": "2692690"
  },
  {
    "text": "Um, so the next question is, how do we recognize na-names and dates and numbers and things like that?",
    "start": "2694440",
    "end": "2701515"
  },
  {
    "text": "Um, we could do it all in the grammar and that's just what I did,",
    "start": "2701515",
    "end": "2707079"
  },
  {
    "text": "uh, with Google and New York here. I had directly in my grammar, uh,",
    "start": "2707080",
    "end": "2712450"
  },
  {
    "text": "something that associates the string Google with the semantics which is a Freebase ID.",
    "start": "2712450",
    "end": "2719724"
  },
  {
    "text": "And I could do that for long long lists of entities and I could also do it for dates and numbers and things like that.",
    "start": "2719725",
    "end": "2729265"
  },
  {
    "text": "But, um, if I do that, it's gonna mean, um,",
    "start": "2729265",
    "end": "2734410"
  },
  {
    "text": "adding lots and lots like millions of rules to my grammar,",
    "start": "2734410",
    "end": "2740275"
  },
  {
    "text": "um, which is gonna be really messy and cumbersome and brittle and difficult to maintain.",
    "start": "2740275",
    "end": "2745960"
  },
  {
    "text": "And it's gonna have limited coverage anyways. So I mean, I can't possibly put every possible date or every possible number into my grammar.",
    "start": "2745960",
    "end": "2754045"
  },
  {
    "text": "So instead, what we're gonna do is leverage special-purpose annotators for,",
    "start": "2754045",
    "end": "2760290"
  },
  {
    "text": "uh, phrases that describe entities, locations, names, numbers, dates, times and things like that.",
    "start": "2760290",
    "end": "2766395"
  },
  {
    "text": "So here's an example. The, the example query is reserved Gary Danko with Tom next Friday.",
    "start": "2766395",
    "end": "2773015"
  },
  {
    "text": "And so here we're imagining that we have three different annotators that are gonna help us interpret this query and they",
    "start": "2773015",
    "end": "2781000"
  },
  {
    "text": "basically function like black boxes which run first before the syntactic machinery gets to work",
    "start": "2781000",
    "end": "2788170"
  },
  {
    "text": "and can hand their results to the syntactic machinery. So first I imagine that I have a Freebase annotator, and this thing,  its job",
    "start": "2788170",
    "end": "2795595"
  },
  {
    "text": "is to look for entity mentions that are things that Freebase knows about. And it recognizes this phrase,",
    "start": "2795595",
    "end": "2801955"
  },
  {
    "text": "this string Gary Danko and it says, oh I know about that. That's Freebase entity this thing.",
    "start": "2801955",
    "end": "2808914"
  },
  {
    "text": "And it tells me this is a $restaurant, um, which I think it figured out from, uh,",
    "start": "2808915",
    "end": "2816490"
  },
  {
    "text": "it, it, it, is also able to generate lots of metadata because it has all of Freebase at its disposal right?",
    "start": "2816490",
    "end": "2822220"
  },
  {
    "text": "It knows about Freebase. And so it's able to look this thing up and figure out it's a restaurant and it knows to generate that syntactic category.",
    "start": "2822220",
    "end": "2830005"
  },
  {
    "text": "And then it also, uh, generates this helpful metadata that can be passed downstream.",
    "start": "2830005",
    "end": "2835140"
  },
  {
    "text": "So for example, it has a confidence score that says how, how sure it is that it's made",
    "start": "2835140",
    "end": "2841080"
  },
  {
    "text": "the right interpretation here and that confidence score, uh, can be passed through, um,",
    "start": "2841080",
    "end": "2846420"
  },
  {
    "text": "and, and uh be an input to scoring the interpretation later on.",
    "start": "2846420",
    "end": "2852490"
  },
  {
    "text": "Um, I also mentioned that we have a contact annotator which recognizes this, this string Tom.",
    "start": "2852490",
    "end": "2858460"
  },
  {
    "text": "And it says, oh Tom, I know who that is. It's this user ID and he has this email.",
    "start": "2858460",
    "end": "2864355"
  },
  {
    "text": "So obviously the only way that can work is if the contact annotator knows who issued the request.",
    "start": "2864355",
    "end": "2872065"
  },
  {
    "text": "It knows that this request is from a specific user and that user has a friend named Tom and this is his user ID.",
    "start": "2872065",
    "end": "2878560"
  },
  {
    "text": "So it needs access to some personal information in order to ground these semantics with a specific user ID.",
    "start": "2878560",
    "end": "2886030"
  },
  {
    "text": "And finally, a date annotator. It recognizes this phrase next Friday. And it says oh, I know how to generate semantics for that.",
    "start": "2886030",
    "end": "2893065"
  },
  {
    "text": "Next Friday means May 10th, 2019. And it was able to do that because it knows when the query was",
    "start": "2893065",
    "end": "2900325"
  },
  {
    "text": "issued and therefore is able to interpret next Friday appropriately. So next Friday is an indexical expression but to ground it correctly,",
    "start": "2900325",
    "end": "2908860"
  },
  {
    "text": "I need to know something about where the, whe- when the query came from. So we have uh these annotators that can run essentially as black-box modules,",
    "start": "2908860",
    "end": "2918790"
  },
  {
    "text": "run over the input query, generate hypotheses about how to interpret small spans and record",
    "start": "2918790",
    "end": "2925569"
  },
  {
    "text": "those hypotheses as inputs to the syntactic machinery that will will,",
    "start": "2925570",
    "end": "2931570"
  },
  {
    "text": "uh, will get rolling afterwards.",
    "start": "2931570",
    "end": "2934790"
  },
  {
    "start": "2936000",
    "end": "3111000"
  },
  {
    "text": "Okay. Um, a pervasive problem. Yes. Just going off back to that approach.",
    "start": "2936750",
    "end": "2943660"
  },
  {
    "text": "Yeah. What exactly is the issue it's tackling? Like when you first pitched sort of the problem,",
    "start": "2943660",
    "end": "2948970"
  },
  {
    "text": "I thought a solution could be to affect the annotation itself. So rather than saying location goes to New York,",
    "start": "2948970",
    "end": "2954760"
  },
  {
    "text": "you could save location goes to span, and then the location would be invoked lookup on span, rather than running the entity recognition first,",
    "start": "2954760",
    "end": "2963940"
  },
  {
    "text": "you could go to the semantic parser and it would be able to identify the span and then pass it to the annotator. Is there a reason why we put on the annotator first?",
    "start": "2963940",
    "end": "2972710"
  },
  {
    "text": "Um, I think maybe what you're suggesting is that the parsing could happen top-down instead of bottom-up.",
    "start": "2973680",
    "end": "2982035"
  },
  {
    "text": "Does that sound right? That could be yeah. Um, and that's, uh,",
    "start": "2982035",
    "end": "2988045"
  },
  {
    "text": "conceptually that's definitely possible. Um, and like when you for example if you've taken CS 143,",
    "start": "2988045",
    "end": "2996460"
  },
  {
    "text": "you study lots of different approaches to parsing and some of them are bottom-up and some of them are top-down and some of them are a mix of both and all of them are conceptually possible.",
    "start": "2996460",
    "end": "3005070"
  },
  {
    "text": "But there can be big differences as far as the efficiency of parsing.",
    "start": "3005070",
    "end": "3010500"
  },
  {
    "text": "And particularly for natural language which is so highly ambiguous.",
    "start": "3010500",
    "end": "3016485"
  },
  {
    "text": "Um, top-down parsing turns out to be prohibitively expensive. And bottom-up parsing is, um,",
    "start": "3016485",
    "end": "3023955"
  },
  {
    "text": "way more efficient because you can eliminate, uh, unlikely possibilities early in the process.",
    "start": "3023955",
    "end": "3032370"
  },
  {
    "text": "Um, when I was working on this problem at Google, the grammars that we were working with, uh,",
    "start": "3032370",
    "end": "3037620"
  },
  {
    "text": "it was commonplace for even very pedestrian inputs to have literally thousands of possible parses.",
    "start": "3037620",
    "end": "3046710"
  },
  {
    "text": "In fact that's the next point I'm gonna turn to is ambiguity. Um, and when there are thousands of possible parses,",
    "start": "3046710",
    "end": "3053160"
  },
  {
    "text": "you need to do pruning fairly early in the, in the process. We, we would use, uh,",
    "start": "3053160",
    "end": "3058950"
  },
  {
    "text": "what's called a beam search to basically maintain as, as the, the process of parsing is happening to maintain",
    "start": "3058950",
    "end": "3066030"
  },
  {
    "text": "a finite length list of the most promising possibilities and aggressively prune beyond that list.",
    "start": "3066030",
    "end": "3074295"
  },
  {
    "text": "Um, and that was the only way to to keep the search for a plausible parse manageable.",
    "start": "3074295",
    "end": "3082424"
  },
  {
    "text": "Just following up on that. When we do the annotations, it does help us to limit the number of possible parses and",
    "start": "3082425",
    "end": "3088340"
  },
  {
    "text": "so that's one of the big advantages to running the annotator first? Yeah. Yeah. Thank you.",
    "start": "3088340",
    "end": "3093795"
  },
  {
    "text": "Yeah. So this problem of ambiguity is, uh,",
    "start": "3093795",
    "end": "3101805"
  },
  {
    "text": "this is a problem that's that's pervasive, uh, throughout language and certainly, um,",
    "start": "3101805",
    "end": "3108300"
  },
  {
    "text": "a big challenge for semantic parsing and ambiguity can include both syntactic ambiguity and semantic ambiguity.",
    "start": "3108300",
    "end": "3116745"
  },
  {
    "start": "3111000",
    "end": "3548000"
  },
  {
    "text": "So here's an example, uh, the input is mission bicycle directions. So imagine the the user issues this query to Siri, or to the Google Assistant.",
    "start": "3116745",
    "end": "3126750"
  },
  {
    "text": "Uh, one possible interpretation for that is that we wanna get to the mission by bike.",
    "start": "3126750",
    "end": "3134550"
  },
  {
    "text": "I want mission bicycle direct, I wanna ride my bike to the mission. That's certainly a possible interpretation.",
    "start": "3134550",
    "end": "3139980"
  },
  {
    "text": "It turns out that there's a bike shop called Mission Bicycle. So another possible interpretation is I want directions to Mission Bicycle.",
    "start": "3139980",
    "end": "3148470"
  },
  {
    "text": "And I'm not specifying transportation mode. I just want direct maybe, it's maybe I want driving directions but where I wanna go with mission bicycle.",
    "start": "3148470",
    "end": "3155955"
  },
  {
    "text": "Um, so here I show these two different parses for this query. In this one mission is the location,",
    "start": "3155955",
    "end": "3162915"
  },
  {
    "text": "bicycle is the mode. In this one, Mission Bicycle is the location and I'm not specifying a mode.",
    "start": "3162915",
    "end": "3169365"
  },
  {
    "text": "In this case, in this example, there's only two possible parses but as I mentioned a moment ago, in complex domains,",
    "start": "3169365",
    "end": "3176280"
  },
  {
    "text": "it's with rich grammars, it's commonplace that there are tens or hundreds or even thousands of possible parses.",
    "start": "3176280",
    "end": "3183285"
  },
  {
    "text": "So if our grammar supports multiple interpretations, how do we know which one to choose?",
    "start": "3183285",
    "end": "3189720"
  },
  {
    "text": "The answer is with a scoring function. We need a way to score the different candidates so that we can figure out which one is the most plausible.",
    "start": "3189720",
    "end": "3197955"
  },
  {
    "text": "And one approach to doing that is with a log-linear model to score alternative derivations.",
    "start": "3197955",
    "end": "3203440"
  },
  {
    "text": "So a little bit of terminology here. I'm gonna call the input that is the the query,",
    "start": "3203440",
    "end": "3208640"
  },
  {
    "text": "the national language query X. Um, I'm gonna call the derivation or parse.",
    "start": "3208640",
    "end": "3214994"
  },
  {
    "text": "So that's the syntactic parse tree with all of its semantic attachments. I'm gonna call that Z.",
    "start": "3214995",
    "end": "3220410"
  },
  {
    "text": "And I'm gonna call, uh, I'm gonna use Y to to designate the semantic yield.",
    "start": "3220410",
    "end": "3226215"
  },
  {
    "text": "So that means the final semantics. It's basically the semantics that you get at the root node in the parse tree.",
    "start": "3226215",
    "end": "3233550"
  },
  {
    "text": "Uh, by the way, Z completely determines Y. Uh, but for any given X,",
    "start": "3233550",
    "end": "3239250"
  },
  {
    "text": "you may have lots of candidates Zs and correspondingly lots of candidate Ys.",
    "start": "3239250",
    "end": "3244470"
  },
  {
    "text": "So to to build this scoring function, what we're gonna do is first, define a feature representation which captures the key characteristics of the input X,",
    "start": "3244470",
    "end": "3255714"
  },
  {
    "text": "the candidate parse Z and the candidate semantics Y.",
    "start": "3255715",
    "end": "3261875"
  },
  {
    "text": "Uh, there's a lot of room for variation in the feature representation but just to give you a flavor of like some common commonly used features.",
    "start": "3261875",
    "end": "3269630"
  },
  {
    "text": "Uh, your feature representation might include, um, an indicator function which is one,",
    "start": "3269630",
    "end": "3277545"
  },
  {
    "text": "just in case the input contains the word to. And the candidates semantics contains a destination parameter.",
    "start": "3277545",
    "end": "3286619"
  },
  {
    "text": "Presumably like intuitively makes sense those two things are likely to go together.",
    "start": "3286620",
    "end": "3292095"
  },
  {
    "text": "And so seeing those together, might count as weak evidence. It's hardly proof but it might count as weak evidence that this is actually a good parse.",
    "start": "3292095",
    "end": "3302474"
  },
  {
    "text": "Um, or you might have features which capture again,",
    "start": "3302475",
    "end": "3307710"
  },
  {
    "text": "indicator features so Boolean features which capture the occurrence of specific CFG rules or specific categories the dollar the dollar things,",
    "start": "3307710",
    "end": "3317760"
  },
  {
    "text": "um, in the candidate parse. The intuition here is some rules in your grammar might be much more likely or",
    "start": "3317760",
    "end": "3326055"
  },
  {
    "text": "unlikely than others to participate in good parses, in valid parses.",
    "start": "3326055",
    "end": "3332954"
  },
  {
    "text": "You might not be able to anticipate that in advance but if you have features like these, then you have the opportunity to learn that from data.",
    "start": "3332955",
    "end": "3340680"
  },
  {
    "text": "You can learn from your data that some rules work much better than others. Uh, another kind of feature you might include is features which",
    "start": "3340680",
    "end": "3348720"
  },
  {
    "text": "pass through the confidence score that you got from an annotator. Presumably, if the annotator's really confident that makes it more",
    "start": "3348720",
    "end": "3356670"
  },
  {
    "text": "plausible that a parse that includes that annotation is a good parse.",
    "start": "3356670",
    "end": "3362380"
  },
  {
    "text": "There's lots of room for variation in the feature representation but once you have a feature representation,",
    "start": "3362480",
    "end": "3368895"
  },
  {
    "text": "the score for a, a derivation, the score for parse Z will just be the dot product",
    "start": "3368895",
    "end": "3377339"
  },
  {
    "text": "of the feature vector and a weight vector theta which is learned from training data.",
    "start": "3377340",
    "end": "3382545"
  },
  {
    "text": "And once you have a score, you can turn the score into a probability in the usual way by using the soft-max function.",
    "start": "3382545",
    "end": "3389430"
  },
  {
    "text": "[NOISE] So the next question is, where do we get this thing from?",
    "start": "3389430",
    "end": "3396355"
  },
  {
    "text": "Where do we get the weight vector theta? This is basically the parameters of our scoring model.",
    "start": "3396355",
    "end": "3402670"
  },
  {
    "text": "Um, well, we're going to get it from data, we're gonna estimate those model parameters from training data, and we can do it using a variant of the EM algorithm.",
    "start": "3402670",
    "end": "3411850"
  },
  {
    "text": "The reason for using the EM algorithm is that our training data consists of",
    "start": "3411850",
    "end": "3417685"
  },
  {
    "text": "pairs of inputs x and target semantics y,",
    "start": "3417685",
    "end": "3424690"
  },
  {
    "text": "but the training data doesn't include the correct parse trees, z.",
    "start": "3424690",
    "end": "3431770"
  },
  {
    "text": "So there could be multiple parse trees that yield the same semantics.",
    "start": "3431770",
    "end": "3437095"
  },
  {
    "text": "So we have to treat those Z's as latent variables, and that's what the EM algorithm is good at. Yeah.",
    "start": "3437095",
    "end": "3443140"
  },
  {
    "text": "[inaudible]? Yeah. I'll, um, I'll try to,",
    "start": "3443140",
    "end": "3450250"
  },
  {
    "text": "um, explain it in application to the, to- to- to this specific application.",
    "start": "3450250",
    "end": "3456025"
  },
  {
    "text": "The EM algorithm, uh, alternates between E-step and M-step. Um, EM stands for Expectation Maximization.",
    "start": "3456025",
    "end": "3463705"
  },
  {
    "text": "And in the E step, what- what we do here, is use the current model parameters theta to parse the inputs in our training data,",
    "start": "3463705",
    "end": "3474510"
  },
  {
    "text": "and for each input x, generate an end best list of possible parses.",
    "start": "3474510",
    "end": "3481080"
  },
  {
    "text": "So we're just parsing all the inputs using our current model. Then, in the M-step,",
    "start": "3481080",
    "end": "3486880"
  },
  {
    "text": "we're gonna change the weights of the model. And specifically we change the weights to put more probability mass",
    "start": "3486880",
    "end": "3495190"
  },
  {
    "text": "on the elements of the n-best list that actually generated the correct semantics.",
    "start": "3495190",
    "end": "3502329"
  },
  {
    "text": "Um, in the n-best list, some of them are gonna have good semantics which match the target, some of them will not, and we want to shift",
    "start": "3502330",
    "end": "3509140"
  },
  {
    "text": "the probability mass towards the ones that match the target semantics. Um, and then we go back to the E-step and do it again.",
    "start": "3509140",
    "end": "3516865"
  },
  {
    "text": "We reparse everything using our updated weights that could cause the n-best list to shift around,",
    "start": "3516865",
    "end": "3522700"
  },
  {
    "text": "um, and we keep doing that back and forth between the E-step, and the M-step. So these updates to the models are basically SGD updates.",
    "start": "3522700",
    "end": "3531640"
  },
  {
    "text": "This is kind of like a stochastic gradient descent algorithm, uh, and the weights will adjust gradually over time,",
    "start": "3531640",
    "end": "3538030"
  },
  {
    "text": "uh, toward weights that are more and more successful in generating the target parses for our training data.",
    "start": "3538030",
    "end": "3546770"
  },
  {
    "text": "Okay. So we've got a grammar, it's got syntax rules, it's got semantic attachments, there's ambiguity,",
    "start": "3549030",
    "end": "3556960"
  },
  {
    "text": "we have a scoring function, we've learned the scoring function from data. The next question is,",
    "start": "3556960",
    "end": "3563215"
  },
  {
    "text": "where did the grammar rules come from? If- and the answer really depends on what domain you're working in.",
    "start": "3563215",
    "end": "3570444"
  },
  {
    "text": "If it's a small simple domain, then grammars with a few dozen or a few hundred rules,",
    "start": "3570445",
    "end": "3577450"
  },
  {
    "text": "are commonly enough, and at that's sca- at that scale, it's practical to write grammars manually.",
    "start": "3577450",
    "end": "3584665"
  },
  {
    "text": "You just like, think about the domain, and look at lots of example queries, and just manually generate some rules that will capture,",
    "start": "3584665",
    "end": "3593530"
  },
  {
    "text": "uh, that will cover the- the- the- the- the- the set of input, uh, input the- the set of inputs, uh, properly.",
    "start": "3593530",
    "end": "3603160"
  },
  {
    "text": "But that's not the common situation. The common situation is, you're in a large complex domain,",
    "start": "3603160",
    "end": "3610164"
  },
  {
    "text": "um, and you, uh, need thousands of rules to model the domain well,",
    "start": "3610164",
    "end": "3617665"
  },
  {
    "text": "and at that scale, it's just not feasible to write down all the rules manually. Uh, so instead we want to learn the rules automatically from- from training data.",
    "start": "3617665",
    "end": "3627910"
  },
  {
    "text": "And this is the challenge of grammar induction, and it's where some of the most interesting research work lies.",
    "start": "3627910",
    "end": "3633955"
  },
  {
    "text": "Um, one strategy for grammar reduction which- it's a very simplistic strategy but it's illustrated in Unit 1 of the SippyCup codebooks.",
    "start": "3633955",
    "end": "3642625"
  },
  {
    "text": "The idea is simply to generate all possible rules and add them to your grammar, uh,",
    "start": "3642625",
    "end": "3648670"
  },
  {
    "text": "and then to use standard parameter learning to learn weights for each rule, to learn which rules are most likely to contribute to a successful parse.",
    "start": "3648670",
    "end": "3655960"
  },
  {
    "text": "So all- what is- first, what is all possible rules mean? It basically means, um,",
    "start": "3655960",
    "end": "3661075"
  },
  {
    "text": "all ways of combining the symbols of your semantic representation. Your sort of semantic,",
    "start": "3661075",
    "end": "3666850"
  },
  {
    "text": "like your language of formal semantics always combining those symbols into syntax rules,",
    "start": "3666850",
    "end": "3672370"
  },
  {
    "text": "every possible right-hand side, every possible left-hand side, the cross-product of all those things.",
    "start": "3672370",
    "end": "3678460"
  },
  {
    "text": "And if we add all those rules to our grammar, then we can generate a huge variety of different parses.",
    "start": "3678460",
    "end": "3686605"
  },
  {
    "text": "Most of them are bad, but we can use the- the weight learning that I talked",
    "start": "3686605",
    "end": "3692110"
  },
  {
    "text": "about on the previous slide to learn from data which ones are good, and which ones are bad.",
    "start": "3692110",
    "end": "3698690"
  },
  {
    "text": "This works but it comes at a heavy cost because",
    "start": "3698730",
    "end": "3704770"
  },
  {
    "text": "generating all possible rules leads to an exponential blowup in the number of possible parses,",
    "start": "3704770",
    "end": "3711100"
  },
  {
    "text": "and consequently in the time that's required for parsing, uh, and if you work your way through SippyCup Unit",
    "start": "3711100",
    "end": "3718030"
  },
  {
    "text": "1 you'll see this illustrated very vividly. So more sophisticated approaches to",
    "start": "3718030",
    "end": "3723805"
  },
  {
    "text": "grammar induction look for ways to be far more selective about, uh, introducing new grammar rules,",
    "start": "3723805",
    "end": "3729955"
  },
  {
    "text": "and also ways to prune them aggressively when they're not contributing to successful parses,",
    "start": "3729955",
    "end": "3735670"
  },
  {
    "text": "to keep the size of the grammar manageable so that training can still run in a feasible amount of time.",
    "start": "3735670",
    "end": "3742430"
  },
  {
    "text": "So we've talked about two different ways of using training data in this process.",
    "start": "3743130",
    "end": "3749365"
  },
  {
    "text": "One way of using training data is to induce rules of the grammar,",
    "start": "3749365",
    "end": "3754690"
  },
  {
    "text": "to figure out which syntactic productions should be part of the grammar. The other way of using data is to estimate the parameters of our linear scoring model,",
    "start": "3754690",
    "end": "3765715"
  },
  {
    "text": "um, and these two- two way, uh, two ways of using data are both really important and kinda work hand in hand.",
    "start": "3765715",
    "end": "3772549"
  },
  {
    "text": "Um, so that's, this kind of underscores the importance of data for making this whole thing work.",
    "start": "3773340",
    "end": "3778930"
  },
  {
    "text": "You can't do grammar reduction and you can't learn the parameters of your scoring model without training data,",
    "start": "3778930",
    "end": "3785305"
  },
  {
    "text": "and not just a little bit of data, to really make this work, you want massive amounts of data.",
    "start": "3785305",
    "end": "3790585"
  },
  {
    "text": "So organizations that are doing this at scale, like Google and Apple invest a lot of money in data annotation,",
    "start": "3790585",
    "end": "3797710"
  },
  {
    "text": "uh, using proprietary Crowdsourcing platforms similar to Mechanical Turk. So paying graders, paying human annotators to look at example",
    "start": "3797710",
    "end": "3806529"
  },
  {
    "text": "input queries and write down the- the target semantics for those queries so that we can then,",
    "start": "3806530",
    "end": "3812455"
  },
  {
    "text": "um, train- train machine-learning systems to- to- to, um, to capture that.",
    "start": "3812455",
    "end": "3819535"
  },
  {
    "text": "However, that's really expensive. Labeling examples with targeted, er, target semantics, um, is slow and laborious,",
    "start": "3819535",
    "end": "3828400"
  },
  {
    "text": "and costs a lot of money. So another really productive direction has been to enable learning from indirect supervision.",
    "start": "3828400",
    "end": "3835105"
  },
  {
    "text": "Um, an idea pi- pioneered by Percy Liang is the idea of learning from denotations.",
    "start": "3835105",
    "end": "3841525"
  },
  {
    "text": "So denotation basically means, if your semantic representation is something that can",
    "start": "3841525",
    "end": "3847630"
  },
  {
    "text": "be executed or evaluated in some way, that execution or evaluation could result in something that's a lot,",
    "start": "3847630",
    "end": "3857230"
  },
  {
    "text": "uh, simpler and more intuitive for a human annotator to produce.",
    "start": "3857230",
    "end": "3862525"
  },
  {
    "text": "So an example here, I should have put an example on the slide, an example might be like,",
    "start": "3862525",
    "end": "3867740"
  },
  {
    "text": "you know, what's the capital of the largest state in the United States?",
    "start": "3868140",
    "end": "3876670"
  },
  {
    "text": "The semantics for that might be some kind of complex, um, logical formula that literally says,",
    "start": "3876670",
    "end": "3884964"
  },
  {
    "text": "except in logical language instead of English, what is the capital of the largest state?",
    "start": "3884965",
    "end": "3890920"
  },
  {
    "text": "The denotation of that semantics would be the answer to the question like, Austin.",
    "start": "3890920",
    "end": "3898809"
  },
  {
    "text": "Juneau, yes. I guess, if we're talking about large in terms of area, right? What is the capital of the largest state?",
    "start": "3898810",
    "end": "3904930"
  },
  {
    "text": "Juneau, Alaska. Um, so that's the denotation. If your training data consists of inputs, like,",
    "start": "3904930",
    "end": "3911590"
  },
  {
    "text": "what is the capital of the largest state, paired with logical forms, we can learn very effectively from that,",
    "start": "3911590",
    "end": "3918069"
  },
  {
    "text": "but it's hard to produce that training data because it's hard to get human annotators to produce those logical forms.",
    "start": "3918070",
    "end": "3924700"
  },
  {
    "text": "Um, and in Google and Apple we figured out all kinds of tricks to make that a little bit easier for ordinary people to produce logical forums,",
    "start": "3924700",
    "end": "3931825"
  },
  {
    "text": "but it's an intrinsically hard problem. It's much easier to get ordinary human annotators to produce the answers, like, Juneau.",
    "start": "3931825",
    "end": "3940990"
  },
  {
    "text": "And so if we can have training data that says, What's the capital of the largest state? Juneau. If we can figure out a way to learn from that kind of data, uh,",
    "start": "3940990",
    "end": "3949900"
  },
  {
    "text": "we'll be able to get lots more data, um, and, um, and the benefit of- of learning from that data.",
    "start": "3949900",
    "end": "3956349"
  },
  {
    "text": "So that's the idea of learning from denotations. Um, this is a really powerful idea,",
    "start": "3956350",
    "end": "3961750"
  },
  {
    "text": "and it's illustrated again in Unit 1 of SippyCup, where the domain is natural language arithmetic.",
    "start": "3961750",
    "end": "3968050"
  },
  {
    "text": "So there the donations are just the answer to a simple arithmetical computation.",
    "start": "3968050",
    "end": "3974870"
  },
  {
    "text": "Okay. So to recap, the key ingredients of this approach to",
    "start": "3977400",
    "end": "3982540"
  },
  {
    "text": "semantic parsing are CFGs with semantic attachments, log-linear scoring models, annotators,",
    "start": "3982540",
    "end": "3990190"
  },
  {
    "text": "grammar induction, and above all, lots and lots of training data.",
    "start": "3990190",
    "end": "3996160"
  },
  {
    "text": "Um, I think- I hope that that's enough of a high level overview,",
    "start": "3996160",
    "end": "4001544"
  },
  {
    "text": "that if this topic interests you, you'll be able to dive in to the SippyCup codebooks,",
    "start": "4001544",
    "end": "4006630"
  },
  {
    "text": "um, start reading some papers, and get a much more concrete sense of how all this stuff fits together,",
    "start": "4006630",
    "end": "4013380"
  },
  {
    "text": "and how all this works. I think I'll stop there for today.",
    "start": "4013380",
    "end": "4018040"
  }
]