[
  {
    "text": "thank you for joining me today to hear about flood containers and to discuss",
    "start": "6720",
    "end": "12080"
  },
  {
    "text": "some caveats of using these data structures if okay first of all this",
    "start": "12080",
    "end": "18359"
  },
  {
    "text": "talk is planned for like 45 50 minutes and if you have any kind of questions or",
    "start": "18359",
    "end": "23720"
  },
  {
    "text": "comments just raise your hand and ask I guess we also have mic here which is functional so if you need it I probably",
    "start": "23720",
    "end": "31439"
  },
  {
    "text": "can pass it for you",
    "start": "31439",
    "end": "36920"
  },
  {
    "text": "uh yeah okay uh so first of all a few words about",
    "start": "37640",
    "end": "45079"
  },
  {
    "text": "myself my name is Vitali and I've been doing software for quite a file mostly",
    "start": "45079",
    "end": "50800"
  },
  {
    "text": "in C++ now I'm working at remarkable this is Norwegian company and uh we do",
    "start": "50800",
    "end": "57840"
  },
  {
    "text": "this e-link like not a part that provides very nice writing experience so",
    "start": "57840",
    "end": "63960"
  },
  {
    "text": "if you do a lot of notes and stuff or working with some schemes charts or",
    "start": "63960",
    "end": "72960"
  },
  {
    "text": "somehow visualizing your thoughts that's a very nice stuff to use and we use it a",
    "start": "72960",
    "end": "79119"
  },
  {
    "text": "lot to work for today first I want to give you",
    "start": "79119",
    "end": "84400"
  },
  {
    "text": "some overview of existing containers and the containers that will",
    "start": "84400",
    "end": "90640"
  },
  {
    "text": "be included uh into the standard library at the C++ 23 we want to look into some",
    "start": "90640",
    "end": "97880"
  },
  {
    "text": "implementation details of those containers uh then I'm going to talk about some advantages and why we might",
    "start": "97880",
    "end": "104719"
  },
  {
    "text": "want to use those containers in real production code and what kind of issues",
    "start": "104719",
    "end": "110799"
  },
  {
    "text": "they can solve for us then we will look to some very artificial benchmarks and I",
    "start": "110799",
    "end": "117920"
  },
  {
    "text": "will tell you why basic basically should bitmark everything yourself when you do real production code taking into account",
    "start": "117920",
    "end": "125520"
  },
  {
    "text": "all of this Hardware build plugs and so on and then there will be only one site",
    "start": "125520",
    "end": "130959"
  },
  {
    "text": "of General recommendation how you're going to use them or how you want to create those",
    "start": "130959",
    "end": "136280"
  },
  {
    "text": "containers and so on yeah let's get started with a small overview of",
    "start": "136280",
    "end": "143680"
  },
  {
    "text": "containers uh before C++ 2us 3 we had only those",
    "start": "143680",
    "end": "150360"
  },
  {
    "text": "three in the standard library then in C++ 23 we have things",
    "start": "150360",
    "end": "157160"
  },
  {
    "text": "with underscore flat prefix and somewhere in between that's",
    "start": "157160",
    "end": "164480"
  },
  {
    "text": "not the matter I want to talk in this particular time should be Google upsale",
    "start": "164480",
    "end": "172000"
  },
  {
    "text": "containers that based on B trees that's kind of hybrid between of Pur flat and",
    "start": "172000",
    "end": "178560"
  },
  {
    "text": "uh spare tree structure and now the short",
    "start": "178560",
    "end": "184080"
  },
  {
    "text": "question for you because flat containers are not kind of a new thing so how many of you ever used flood containers from",
    "start": "184080",
    "end": "190159"
  },
  {
    "text": "Boost from other stuff oh good cool so to understand why they actually",
    "start": "190159",
    "end": "199000"
  },
  {
    "text": "flat and what kind of properties they utilize we should ah okay similarities",
    "start": "199000",
    "end": "204480"
  },
  {
    "text": "that's SL I always forgot about so all of those containers they are associative",
    "start": "204480",
    "end": "211480"
  },
  {
    "text": "containers with some difference because standard gives us a definition of what the associative container is and",
    "start": "211480",
    "end": "218599"
  },
  {
    "text": "arguably flat syns are not fully associative according this definition",
    "start": "218599",
    "end": "223840"
  },
  {
    "text": "but let's not talk about it all of those containers they requir to have St L",
    "start": "223840",
    "end": "230159"
  },
  {
    "text": "operation to compare keys and all of those provide logarithmic time for search",
    "start": "230159",
    "end": "238560"
  },
  {
    "text": "which is very good and fast and we should start with st set to",
    "start": "238560",
    "end": "246400"
  },
  {
    "text": "understand the core differences between those containers so who knows what Under",
    "start": "246400",
    "end": "251920"
  },
  {
    "text": "The Hoot of St set okay is yeah then we can talk about",
    "start": "251920",
    "end": "258959"
  },
  {
    "text": "it a little bit because this is very good question for programming interview",
    "start": "258959",
    "end": "264040"
  },
  {
    "text": "we are not doing it in remarkable just in case so under the hoood is a tree",
    "start": "264040",
    "end": "270280"
  },
  {
    "text": "it's not just a tree but it's a self-balancing binary search",
    "start": "270280",
    "end": "276000"
  },
  {
    "text": "tree I strongly believe that in most implementation this uh red black tree",
    "start": "276000",
    "end": "283840"
  },
  {
    "text": "not AV or something else so some fundamental properties of those three",
    "start": "283840",
    "end": "289880"
  },
  {
    "text": "helps us to provide good complexities for three major",
    "start": "289880",
    "end": "295680"
  },
  {
    "text": "operations and uh those properties are that this three is kind of sorted you",
    "start": "295680",
    "end": "301400"
  },
  {
    "text": "may see that the root is in the middle and all",
    "start": "301400",
    "end": "307320"
  },
  {
    "text": "left nodes are either less or equal than the root and all right sub are greater",
    "start": "307320",
    "end": "317199"
  },
  {
    "text": "than the root and that repeats for all sub trees uh there are other fundamental",
    "start": "317199",
    "end": "323960"
  },
  {
    "text": "properties and I'm not going to talk about it but basically to keep it balance there should be",
    "start": "323960",
    "end": "330199"
  },
  {
    "text": "the same count of black nodes and each children of red notes should be black",
    "start": "330199",
    "end": "337560"
  },
  {
    "text": "and so on but yeah it's not important for now another important property that what we can do with this three is we can",
    "start": "337560",
    "end": "344639"
  },
  {
    "text": "do in order the traversal the Green Dot here is where the traversal starts it",
    "start": "344639",
    "end": "350039"
  },
  {
    "text": "goes from the root to the leftmost sub tree then up this",
    "start": "350039",
    "end": "356680"
  },
  {
    "text": "way and if we just Traverse it this way we can get a sorted list of elements",
    "start": "356680",
    "end": "364520"
  },
  {
    "text": "which is a very good property and we need to keep it in mind to understand",
    "start": "364520",
    "end": "370400"
  },
  {
    "text": "flat containers better and as I said before that's uh just a tree and this is",
    "start": "370400",
    "end": "378039"
  },
  {
    "text": "very naive implementation of such a tree written by",
    "start": "378039",
    "end": "383720"
  },
  {
    "text": "me so here we have just a note for set",
    "start": "383720",
    "end": "388800"
  },
  {
    "text": "then we can and the same for left and right sub trees we have a color that",
    "start": "388800",
    "end": "394080"
  },
  {
    "text": "just enumeration in this case and we have a value that's how it can be implemented and from even this",
    "start": "394080",
    "end": "400160"
  },
  {
    "text": "implementation you can see that we not storing just a value or key",
    "start": "400160",
    "end": "405560"
  },
  {
    "text": "value pair instead of map in case of map but we are also storing of color that",
    "start": "405560",
    "end": "411080"
  },
  {
    "text": "doesn't matter this color beit or just the numeration or something and we also need to store pointers to two sub trees",
    "start": "411080",
    "end": "418000"
  },
  {
    "text": "that kind of create memory overhead that can be crucial in some",
    "start": "418000",
    "end": "423879"
  },
  {
    "text": "cases fundamental properties of this three that I described before they",
    "start": "424560",
    "end": "430960"
  },
  {
    "text": "guarantee us all three basic operations complexity of log n which is",
    "start": "430960",
    "end": "438639"
  },
  {
    "text": "very good complexity in many cases and if you do traversing of uh the values of",
    "start": "438639",
    "end": "444360"
  },
  {
    "text": "this three they will be sorted uh in ascending order so so they",
    "start": "444360",
    "end": "451599"
  },
  {
    "text": "just uh when you Traverse it would be in order to",
    "start": "451599",
    "end": "456960"
  },
  {
    "text": "traversal but now let's talk about flat set so who knows what they're under the",
    "start": "456960",
    "end": "462240"
  },
  {
    "text": "hoood of flat set good and this is super",
    "start": "462240",
    "end": "470560"
  },
  {
    "text": "simple this just a extendedly sorted contiguous container of elements it's",
    "start": "471240",
    "end": "477960"
  },
  {
    "text": "sorted Vector in many cases so and uh that's why you can see",
    "start": "477960",
    "end": "485280"
  },
  {
    "text": "why it's flat so we took a tree we collapse it it's flatten",
    "start": "485280",
    "end": "492360"
  },
  {
    "text": "now here I tried to visualize binary search on this",
    "start": "492360",
    "end": "498080"
  },
  {
    "text": "container so and it is like when we searching something in a tree we starting from the middle then we since",
    "start": "498080",
    "end": "505479"
  },
  {
    "text": "we searching for zero we're checking okay not this element then we go left left left left until we find that zero",
    "start": "505479",
    "end": "512518"
  },
  {
    "text": "element and that's why we can guarantee logarithmic time for search here the possible",
    "start": "512519",
    "end": "521560"
  },
  {
    "text": "implementation of this container could look this way I guess it's copied from",
    "start": "521560",
    "end": "527640"
  },
  {
    "text": "the standard because all my implementation show here they just not a reference implementation it's very naive",
    "start": "527640",
    "end": "533600"
  },
  {
    "text": "and simple implementations the point is uh if we look into the the features per compilers",
    "start": "533600",
    "end": "541000"
  },
  {
    "text": "flat containers are not implementing at any it just threatened this table and this morning I checked uh there are some",
    "start": "541000",
    "end": "547839"
  },
  {
    "text": "pool requests especially for Microsoft STL which is open but it's not merched yet and there are some discussion I",
    "start": "547839",
    "end": "554279"
  },
  {
    "text": "guess the first commit was done at 2nd of July or something like that and now",
    "start": "554279",
    "end": "560000"
  },
  {
    "text": "it's 50 something commits and very long discussion how to implement in merch flat containers so but get back to this",
    "start": "560000",
    "end": "567560"
  },
  {
    "text": "stuff to my implementation what we have here now is key we have comparator and",
    "start": "567560",
    "end": "573279"
  },
  {
    "text": "we have a containers for storing keys and from this we can get that this is not like a",
    "start": "573279",
    "end": "580920"
  },
  {
    "text": "container but it's container adapter and uh in this particular part it's placed",
    "start": "580920",
    "end": "588040"
  },
  {
    "text": "in the standard so it's a container adapter here we have two members one for",
    "start": "588040",
    "end": "594720"
  },
  {
    "text": "container and one for comparing stuff and there are some very important limitations for container and for",
    "start": "594720",
    "end": "602120"
  },
  {
    "text": "iterator So based on standard we should have a sequential container that provides random access iterators for",
    "start": "602120",
    "end": "609480"
  },
  {
    "text": "performing binary search efficiently so it means that not all",
    "start": "609480",
    "end": "614760"
  },
  {
    "text": "containers can be used here should be satisfied this particular",
    "start": "614760",
    "end": "621560"
  },
  {
    "text": "requirement now let's talk about find operation and why it's also logarithmic",
    "start": "622279",
    "end": "631040"
  },
  {
    "text": "this Cod is quite simple and we can assume that the underlying container is",
    "start": "636279",
    "end": "642279"
  },
  {
    "text": "sorted because we're using only the methods and it helps us keep an",
    "start": "642279",
    "end": "647519"
  },
  {
    "text": "invariant so on this Slide the code I'm using lower bound and the lower bound",
    "start": "647519",
    "end": "653200"
  },
  {
    "text": "from ranges it can be lowerbound from standard library with containers and",
    "start": "653200",
    "end": "659240"
  },
  {
    "text": "something I guess I used ranges V three for my implementation not super important uh lower bound takes a",
    "start": "659240",
    "end": "665360"
  },
  {
    "text": "container takes a key to search and a comparator and it returns first element",
    "start": "665360",
    "end": "671639"
  },
  {
    "text": "that either equal or greater than the key so and here we can check if element",
    "start": "671639",
    "end": "678440"
  },
  {
    "text": "is completely not found we return theator to the end but here if element",
    "start": "678440",
    "end": "684200"
  },
  {
    "text": "is found we return the element itself and otherwise we return that of cont",
    "start": "684200",
    "end": "689519"
  },
  {
    "text": "coner stictly speaking this is a binary search so that's a complexity of it it's logarithmic very cool we're good here",
    "start": "689519",
    "end": "697720"
  },
  {
    "text": "but if we move to other operations we move into insert operations",
    "start": "697720",
    "end": "704079"
  },
  {
    "text": "say so and the insert operation we also utilize lower bound here we could",
    "start": "704079",
    "end": "709839"
  },
  {
    "text": "Implement insert in terms of f but it wouldn't be that convenient in this",
    "start": "709839",
    "end": "715639"
  },
  {
    "text": "case and uh we can found an inator by but here we should check if the key is",
    "start": "715639",
    "end": "722079"
  },
  {
    "text": "the same based on standard we should maintain uniqueness of keys so I cannot",
    "start": "722079",
    "end": "727839"
  },
  {
    "text": "insert it's kind of stable insertation if you will so I cannot just replace",
    "start": "727839",
    "end": "733160"
  },
  {
    "text": "elements and in this case I also should return an iterator to the element here I",
    "start": "733160",
    "end": "738600"
  },
  {
    "text": "cheating a little bit I'm assuming my container has this operation to insert",
    "start": "738600",
    "end": "744440"
  },
  {
    "text": "so I'm having my iterator and the key to insert and then returning what I",
    "start": "744440",
    "end": "751360"
  },
  {
    "text": "inserted that might potentially work for logarithmic time but the problem here is",
    "start": "751639",
    "end": "758680"
  },
  {
    "text": "that we need logarithmic time for lookup itself but then say we want to insert",
    "start": "758680",
    "end": "765839"
  },
  {
    "text": "something in the beginning of the container and container does not prelate",
    "start": "765839",
    "end": "771240"
  },
  {
    "text": "any kind of space at the front part so",
    "start": "771240",
    "end": "776320"
  },
  {
    "text": "it means that we need to move all other elements ments which gives us worst case performance is a linear for this",
    "start": "776320",
    "end": "784000"
  },
  {
    "text": "operation so and another caveat it's uh pretty much the same as for Vector so it",
    "start": "784000",
    "end": "792240"
  },
  {
    "text": "can invalidate iterators why because we can shift elements or we can completely",
    "start": "792240",
    "end": "798880"
  },
  {
    "text": "relocate the entire chunk of the memory because that's how Vector works if capacity is not enough that would",
    "start": "798880",
    "end": "805279"
  },
  {
    "text": "allocate more with some factor and then move all elements into the new chunk of",
    "start": "805279",
    "end": "810360"
  },
  {
    "text": "memory you should keep this cave and someone ask me before the",
    "start": "810360",
    "end": "817279"
  },
  {
    "text": "talk uh can you use those containers as a dropin replacement for standard",
    "start": "817279",
    "end": "823440"
  },
  {
    "text": "containers please don't do it because some code can rely on the property of",
    "start": "823440",
    "end": "828800"
  },
  {
    "text": "iterators and so on you should be very careful when you decide to use something",
    "start": "828800",
    "end": "833839"
  },
  {
    "text": "as a drop in replacement so no questions so far we",
    "start": "833839",
    "end": "838920"
  },
  {
    "text": "can go the erase operation and",
    "start": "838920",
    "end": "844240"
  },
  {
    "text": "eras so Implement in terms of find we just do find but here only one",
    "start": "844240",
    "end": "850759"
  },
  {
    "text": "interesting thing that we need to check whether this iterator is valid or not",
    "start": "850759",
    "end": "856120"
  },
  {
    "text": "because that's requirements for erase that iterator you want to erase shouldn't point to the end of the",
    "start": "856120",
    "end": "861920"
  },
  {
    "text": "container to the behind of container and that's pretty much it if nothing to eras",
    "start": "861920",
    "end": "867759"
  },
  {
    "text": "we return an itate and otherwise we return uh the next",
    "start": "867759",
    "end": "873759"
  },
  {
    "text": "iterator after the erased one that's how eras for Vector works and this how erase",
    "start": "873759",
    "end": "880240"
  },
  {
    "text": "for flat map things will be working because it's just a container adapter I",
    "start": "880240",
    "end": "886120"
  },
  {
    "text": "strongly believe so then uh here the complexity",
    "start": "886120",
    "end": "891240"
  },
  {
    "text": "is completely the same if we erase something at the beginning of the container and we are not cheating no",
    "start": "891240",
    "end": "897360"
  },
  {
    "text": "preallocating or something if this literally contigous container we again get in the linear",
    "start": "897360",
    "end": "904120"
  },
  {
    "text": "performance so we need to shift all elements and it's the same as insert it",
    "start": "904120",
    "end": "910959"
  },
  {
    "text": "can invalidate iterator sum or all or only just after the container but it's",
    "start": "910959",
    "end": "917320"
  },
  {
    "text": "implementation details and you cannot rely on them when you're doing real",
    "start": "917320",
    "end": "922600"
  },
  {
    "text": "code uh now we should consider flat map and the reason why decided",
    "start": "923399",
    "end": "930600"
  },
  {
    "text": "to to talk about flat map separately is here there",
    "start": "930600",
    "end": "937720"
  },
  {
    "text": "are at least two different possibilities how you can Implement flat",
    "start": "937720",
    "end": "943000"
  },
  {
    "text": "map the first one is a contigous container of key value pairs so you have",
    "start": "943000",
    "end": "949279"
  },
  {
    "text": "a vector and then you have a pair first element is key the second is a value",
    "start": "949279",
    "end": "954680"
  },
  {
    "text": "it's fine but there is another layout so and the second",
    "start": "954680",
    "end": "960480"
  },
  {
    "text": "layout uh is two different containers one container for keys and one containers for values now that's a short",
    "start": "960480",
    "end": "969319"
  },
  {
    "text": "quiz guess what implementation is widely used in the world nowadays first or",
    "start": "969319",
    "end": "976480"
  },
  {
    "text": "second it's first and guess which implementation goes to",
    "start": "980480",
    "end": "986639"
  },
  {
    "text": "standard yes so that's the point uh is that those",
    "start": "986639",
    "end": "992319"
  },
  {
    "text": "implementations are slightly different in terms of performance and from what I know there is only one implementation of",
    "start": "992319",
    "end": "999560"
  },
  {
    "text": "the second approach now it's in a private API of the cute library and they",
    "start": "999560",
    "end": "1004600"
  },
  {
    "text": "have their own flat map they implement it completely as it's done in the standard so that's two containers I",
    "start": "1004600",
    "end": "1013759"
  },
  {
    "text": "guess uh yeah I reviewed that particular patch and it's implemented just all interface are super consistent with a",
    "start": "1013759",
    "end": "1020199"
  },
  {
    "text": "standard so they just copy paste in terms of interfaces which is kind of cool we have sort of a reference",
    "start": "1020199",
    "end": "1026959"
  },
  {
    "text": "implementation but the SEC uh in a few slides I will show some caveats of the second",
    "start": "1026959",
    "end": "1035558"
  },
  {
    "text": "approach but before we should see that uh the possible implementation we still",
    "start": "1035559",
    "end": "1042678"
  },
  {
    "text": "have we have slightly larger implementation that we had for",
    "start": "1042679",
    "end": "1049679"
  },
  {
    "text": "just map be for sorry for set before we have now Keys values we have comparator",
    "start": "1049679",
    "end": "1056440"
  },
  {
    "text": "and we have separate containers for keys and values uh those are also copied from",
    "start": "1056440",
    "end": "1062160"
  },
  {
    "text": "the standard I guess probably even with this Capital stuff and the limitations",
    "start": "1062160",
    "end": "1068720"
  },
  {
    "text": "of those containers are the same as I said before for set so for iterators and for sequential of this container then we",
    "start": "1068720",
    "end": "1076120"
  },
  {
    "text": "have data structure that contains key and values we have data members and we have",
    "start": "1076120",
    "end": "1083080"
  },
  {
    "text": "comparator let's move to the most interesting thing",
    "start": "1083840",
    "end": "1089440"
  },
  {
    "text": "iterator so who has ever implemented own",
    "start": "1089440",
    "end": "1095120"
  },
  {
    "text": "iterator so that's interesting thing because iterator uh has some operators to De",
    "start": "1095720",
    "end": "1103320"
  },
  {
    "text": "reference itself and to return mutable reference to the internal data that a",
    "start": "1103320",
    "end": "1108960"
  },
  {
    "text": "super good question since iterators are implementation defined based of the standard so what should we return if we",
    "start": "1108960",
    "end": "1117039"
  },
  {
    "text": "have two different containers uh it's not a question I want to answer",
    "start": "1117039",
    "end": "1122760"
  },
  {
    "text": "here it's uh very tricky and I don't even want to put some current",
    "start": "1122760",
    "end": "1128880"
  },
  {
    "text": "implementation on the slide because you don't want to see a fake pointers fake references and some other stuff to",
    "start": "1128880",
    "end": "1135880"
  },
  {
    "text": "implement it but I have very simple iterator here just to show how",
    "start": "1135880",
    "end": "1141159"
  },
  {
    "text": "algorithms are working so this iterator doesn't contain any things to Der",
    "start": "1141159",
    "end": "1147000"
  },
  {
    "text": "reference to access stuff I'm cheating again the iterator contains only a",
    "start": "1147000",
    "end": "1153320"
  },
  {
    "text": "reference to data and depos which is of course since it's",
    "start": "1153320",
    "end": "1158840"
  },
  {
    "text": "knife implementation not initialized but it's not important here uh so then we can start with",
    "start": "1158840",
    "end": "1166799"
  },
  {
    "text": "implementations and implementation s are a little bit more complicated here I usually don't like putting wall of code",
    "start": "1166799",
    "end": "1174200"
  },
  {
    "text": "on my slides and I hope it's not W of code but uh that's a smallest implementation",
    "start": "1174200",
    "end": "1183400"
  },
  {
    "text": "and the more the densest first implementation I could came up with so",
    "start": "1183400",
    "end": "1190120"
  },
  {
    "text": "we still have lower bound but we now using lower bound only on keys so because again we access our data only",
    "start": "1190120",
    "end": "1197840"
  },
  {
    "text": "through them methods and that means that two containers should be",
    "start": "1197840",
    "end": "1203840"
  },
  {
    "text": "consistent or we have completely broken in variant so if key is found we check",
    "start": "1203840",
    "end": "1210559"
  },
  {
    "text": "in it so then we can return the reference to the data packed into our",
    "start": "1210559",
    "end": "1216919"
  },
  {
    "text": "iterator and then the position which is just the distance between the be",
    "start": "1216919",
    "end": "1222520"
  },
  {
    "text": "beginning of the container and what we found and if nothing found we return",
    "start": "1222520",
    "end": "1228000"
  },
  {
    "text": "return an iterator again but it's very specific iterator so this um the size of",
    "start": "1228000",
    "end": "1233360"
  },
  {
    "text": "container is a second so it's kind of improvised end here so it's longer than",
    "start": "1233360",
    "end": "1239080"
  },
  {
    "text": "the container itself it means that iterator kind of points to the",
    "start": "1239080",
    "end": "1245240"
  },
  {
    "text": "end no questions so far I don't put any complexities here because all complexities are the same as this set",
    "start": "1245760",
    "end": "1253400"
  },
  {
    "text": "this set the same properties",
    "start": "1253400",
    "end": "1258880"
  },
  {
    "text": "now we have insert and for insert we again need to",
    "start": "1258880",
    "end": "1264120"
  },
  {
    "text": "do search to do lower bound we are inserting pair of key values as it might",
    "start": "1264120",
    "end": "1271520"
  },
  {
    "text": "be good idea then first would be key we're looking for a key then we checking",
    "start": "1271520",
    "end": "1279279"
  },
  {
    "text": "whether we can insert or not again we shouldn't insertive the keys already in",
    "start": "1279279",
    "end": "1285440"
  },
  {
    "text": "the container based on the reference so when we insert we have now insert something",
    "start": "1285440",
    "end": "1293440"
  },
  {
    "text": "to the Keys then we found an distance of which where we inserted things and then",
    "start": "1293440",
    "end": "1300640"
  },
  {
    "text": "we can insert value after that exactly into the same position and in iterator",
    "start": "1300640",
    "end": "1306520"
  },
  {
    "text": "since it's a consistent we just return an iterator with the data and the position",
    "start": "1306520",
    "end": "1312600"
  },
  {
    "text": "and again if we cannot insert we return something that just points to the",
    "start": "1312600",
    "end": "1320760"
  },
  {
    "text": "end so guess you could read I will publish",
    "start": "1320760",
    "end": "1325880"
  },
  {
    "text": "the slides both in Channel and then they will be published so if you need to revisit it you can do it later if you",
    "start": "1325880",
    "end": "1332080"
  },
  {
    "text": "don't have time to read right now and the arrays arrays is also super",
    "start": "1332080",
    "end": "1338559"
  },
  {
    "text": "easy here to short amount of code I decided to implement arrays for iterator",
    "start": "1338559",
    "end": "1344720"
  },
  {
    "text": "but again if you need to do it for for key you can invoke find and then invoke",
    "start": "1344720",
    "end": "1352400"
  },
  {
    "text": "this arrays so you can Implement one in terms of another you need to also potentially",
    "start": "1352400",
    "end": "1358799"
  },
  {
    "text": "check the iterator consistency whether this valid iterator it's iterator from the same container or something like",
    "start": "1358799",
    "end": "1366039"
  },
  {
    "text": "that but I just point it out here in many cases you probably don't need to do",
    "start": "1366039",
    "end": "1372360"
  },
  {
    "text": "that then you again finding an element erasing it and do the same for values to",
    "start": "1372360",
    "end": "1379159"
  },
  {
    "text": "keep it consistent and we are done here we can",
    "start": "1379159",
    "end": "1384919"
  },
  {
    "text": "return an iterator this is the distance and the data again that's how those three",
    "start": "1384919",
    "end": "1392440"
  },
  {
    "text": "functions three major functions can be implemented and the operations",
    "start": "1392440",
    "end": "1398960"
  },
  {
    "text": "complexity now for search it's logarithmic binary search we good for",
    "start": "1398960",
    "end": "1406360"
  },
  {
    "text": "insert it's lar in the worst case and for erase it's also linear in the worst",
    "start": "1406360",
    "end": "1412279"
  },
  {
    "text": "case because we might need to relocate all of the elements but uh you might now see okay",
    "start": "1412279",
    "end": "1420080"
  },
  {
    "text": "fine at least two out of three operations for flat containers are much",
    "start": "1420080",
    "end": "1426200"
  },
  {
    "text": "worsome so we don't probably want to use them in many cases but apparently we",
    "start": "1426200",
    "end": "1433320"
  },
  {
    "text": "might want to use it and on practice some log n might be faster than another",
    "start": "1433320",
    "end": "1439279"
  },
  {
    "text": "Lan and we should see why so the main question what are those",
    "start": "1439279",
    "end": "1445840"
  },
  {
    "text": "containers for and uh those two containers why they haven't exist they",
    "start": "1445840",
    "end": "1453279"
  },
  {
    "text": "utilize one of probably two fundamental properties of physical Hardware the",
    "start": "1453279",
    "end": "1460880"
  },
  {
    "text": "first one we should talk very briefly about caches so and who are familiar",
    "start": "1460880",
    "end": "1467360"
  },
  {
    "text": "with how CPU caches are more work in was Cash locality cach line and stuff oh",
    "start": "1467360",
    "end": "1473559"
  },
  {
    "text": "okay good I don't even need to probably include this section but anyway there are many good talks about uh data access",
    "start": "1473559",
    "end": "1482039"
  },
  {
    "text": "patterns cach locality some other stuff I'm just there are so many you can just",
    "start": "1482039",
    "end": "1487840"
  },
  {
    "text": "pick what you want and watch I'll just very briefly imagine that we have a",
    "start": "1487840",
    "end": "1494600"
  },
  {
    "text": "linked list Now sing in list forward list from standard library from STL so and I want",
    "start": "1494600",
    "end": "1502640"
  },
  {
    "text": "to iterate over this list that's how this list of four elements can be",
    "start": "1502640",
    "end": "1508600"
  },
  {
    "text": "allocated in memory on Hep because each each note can be allocated separately so",
    "start": "1508600",
    "end": "1513919"
  },
  {
    "text": "to process it somehow uh CPU needs to fetch it to read it from the RAM and to",
    "start": "1513919",
    "end": "1521960"
  },
  {
    "text": "do that CPU doesn't fetch things by one bit or one bite because it's on this",
    "start": "1521960",
    "end": "1528279"
  },
  {
    "text": "addressing so it just FES by chunk so and say I want to read the first",
    "start": "1528279",
    "end": "1535360"
  },
  {
    "text": "element okay I fed this chunk and in this chunk there is only one element I",
    "start": "1535360",
    "end": "1541159"
  },
  {
    "text": "want to iterate over and there is nothing in my cache I",
    "start": "1541159",
    "end": "1547000"
  },
  {
    "text": "need to go further I need to fetch another chunk and there is second element good but I want to go further",
    "start": "1547000",
    "end": "1555080"
  },
  {
    "text": "further further and there are nothing and luy we for the S read we get two",
    "start": "1555080",
    "end": "1561760"
  },
  {
    "text": "elements and we don't need to go to Ram anymore in contrarily if we have a",
    "start": "1561760",
    "end": "1569679"
  },
  {
    "text": "vector or sorted Vector for iterating depending on data type and many other things then can be read all at",
    "start": "1569679",
    "end": "1578440"
  },
  {
    "text": "once so we need only one read instead of",
    "start": "1578440",
    "end": "1584679"
  },
  {
    "text": "potentially three four reads doesn't really matter we can reduce amount of",
    "start": "1584679",
    "end": "1591279"
  },
  {
    "text": "reading from Ram to CPU cash uh the famous table it's",
    "start": "1591279",
    "end": "1599039"
  },
  {
    "text": "probably published in most of the chalk the original is here you can go and review with some",
    "start": "1599039",
    "end": "1607679"
  },
  {
    "text": "sort of things for L3 cache I just put my approximate numbers here but the",
    "start": "1607679",
    "end": "1613679"
  },
  {
    "text": "point is if we even compare reading from the",
    "start": "1613679",
    "end": "1619399"
  },
  {
    "text": "slowest cach like L L3 which is 2 * approximately faster than ROM we",
    "start": "1619399",
    "end": "1627360"
  },
  {
    "text": "can read the numbers here so that's why it might be important",
    "start": "1627360",
    "end": "1633320"
  },
  {
    "text": "to have data put close to each other for",
    "start": "1633320",
    "end": "1638559"
  },
  {
    "text": "them to be cached so we can potentially access like approximately 10 times",
    "start": "1638559",
    "end": "1645120"
  },
  {
    "text": "faster when we our processing data that's the one property of having",
    "start": "1645120",
    "end": "1650399"
  },
  {
    "text": "contigous container for storing data which is good and another property it's",
    "start": "1650399",
    "end": "1657600"
  },
  {
    "text": "very similar I would say and originates or tightly coupled if you view from the",
    "start": "1657600",
    "end": "1663600"
  },
  {
    "text": "first one this is about memory fragmentation so imagine we now have",
    "start": "1663600",
    "end": "1670679"
  },
  {
    "text": "another object and this sum tree of five",
    "start": "1670679",
    "end": "1675760"
  },
  {
    "text": "nodes doesn't really matter this and all not are Loca non",
    "start": "1675760",
    "end": "1680840"
  },
  {
    "text": "contiguously I'm adding one element it's locating here another here there there and super dense so",
    "start": "1680840",
    "end": "1688240"
  },
  {
    "text": "spread and if I can count the memory there are red segments it's",
    "start": "1688240",
    "end": "1694840"
  },
  {
    "text": "again huge simplification but anyway so in those red segments if you want to do",
    "start": "1694840",
    "end": "1702399"
  },
  {
    "text": "allocate one more note you cannot insert it into those red segments you cannot",
    "start": "1702399",
    "end": "1707760"
  },
  {
    "text": "utilize those segments what you can use is a green chunk",
    "start": "1707760",
    "end": "1714000"
  },
  {
    "text": "here but if you have a contigous container we can potentially like all our pairs or",
    "start": "1714000",
    "end": "1720840"
  },
  {
    "text": "nodes tightly coupled to each other it just allocate continuously and then on",
    "start": "1720840",
    "end": "1726480"
  },
  {
    "text": "the screen you can notice that the green chunk is wide so you can put more",
    "start": "1726480",
    "end": "1732640"
  },
  {
    "text": "elements that's why it might be important to align your data and to to use the contigous container if you have",
    "start": "1732640",
    "end": "1740399"
  },
  {
    "text": "some certain circumstances for use it because apparently this stuff this uh",
    "start": "1740399",
    "end": "1748120"
  },
  {
    "text": "reducing memory fragmentation might be a bad property for some programs and I",
    "start": "1748120",
    "end": "1753519"
  },
  {
    "text": "will talk why a little bit later there important stuff so I",
    "start": "1753519",
    "end": "1761080"
  },
  {
    "text": "promised you to show benchmarks now we had a chat about fundamental properties we had a chat how things are implemented",
    "start": "1761080",
    "end": "1768039"
  },
  {
    "text": "and I want to show you some benchmarks because this presentation won't be full or good enough without it but before we",
    "start": "1768039",
    "end": "1775200"
  },
  {
    "text": "start with benchmarks I want to tell you just do not rely on my benchmarks do your own",
    "start": "1775200",
    "end": "1782559"
  },
  {
    "text": "benchmarks because uh they might be different build types so I would suggest",
    "start": "1782559",
    "end": "1789200"
  },
  {
    "text": "to use uh release this debug info but I know that some",
    "start": "1789200",
    "end": "1796000"
  },
  {
    "text": "people try to Benchmark debug builds and then surprised by results don't do that",
    "start": "1796000",
    "end": "1801640"
  },
  {
    "text": "but benchmarking on red and stuff then you might have your own certain tool chain you might have different hardware",
    "start": "1801640",
    "end": "1807919"
  },
  {
    "text": "and especially for embedded this is important you might have different use cases how you use this structure how you",
    "start": "1807919",
    "end": "1814600"
  },
  {
    "text": "how often do you insert remove elements and so on you can have different data",
    "start": "1814600",
    "end": "1819679"
  },
  {
    "text": "types because size of data type is also important like it's either 3 x 64",
    "start": "1819679",
    "end": "1826279"
  },
  {
    "text": "integers or one 16 integers this difference is critical then data types",
    "start": "1826279",
    "end": "1832480"
  },
  {
    "text": "and the number of elements of course because if you want to allocate from time to time 1 million of elements",
    "start": "1832480",
    "end": "1838120"
  },
  {
    "text": "continuously that might not work in many cases so uh I used my home PC just kind",
    "start": "1838120",
    "end": "1848120"
  },
  {
    "text": "of outdated little bit configuration for all test those slide you can also review",
    "start": "1848120",
    "end": "1854840"
  },
  {
    "text": "later if you want there are ram ram timing CPU stuff and so on very important for some and probably",
    "start": "1854840",
    "end": "1862399"
  },
  {
    "text": "not super important for us now then data types I Benchmark four",
    "start": "1862399",
    "end": "1870440"
  },
  {
    "text": "data types that's 16 32 64bit integers and midsize",
    "start": "1870440",
    "end": "1878000"
  },
  {
    "text": "sport I decided that midsize sport is something 3x in 64 You can disagree with",
    "start": "1878000",
    "end": "1884639"
  },
  {
    "text": "this or agree but that's what be in my bench marks and since I had many",
    "start": "1884639",
    "end": "1891039"
  },
  {
    "text": "benchmarked many things from 100 to 100,000 elements with a step of multiple",
    "start": "1891039",
    "end": "1897320"
  },
  {
    "text": "by 10 I will not present all of the results but all images they just",
    "start": "1897320",
    "end": "1902360"
  },
  {
    "text": "automatically generated by plot here so if uh there are some things with scale",
    "start": "1902360",
    "end": "1909840"
  },
  {
    "text": "or fonts they should be readable I checked on another Proctor but we will",
    "start": "1909840",
    "end": "1915279"
  },
  {
    "text": "see and we will start with find",
    "start": "1915279",
    "end": "1919840"
  },
  {
    "text": "operation so is it read oh I hope I hope it's more or less readable for you guys",
    "start": "1920480",
    "end": "1926760"
  },
  {
    "text": "so in top here we have what we are benchmarking there is an elements count",
    "start": "1926760",
    "end": "1932320"
  },
  {
    "text": "10 we are find for 10 elements here from Blue to Red we have 16 32 64 and midsize",
    "start": "1932320",
    "end": "1941159"
  },
  {
    "text": "Sport and at top we have Boost flat map which I should remind implemented as",
    "start": "1941159",
    "end": "1947799"
  },
  {
    "text": "a sequence it's one container of key value pirs here we have St flat map it's my",
    "start": "1947799",
    "end": "1954600"
  },
  {
    "text": "own implementation because there are no implementations apparently and uh in the bottom we have",
    "start": "1954600",
    "end": "1961080"
  },
  {
    "text": "standard map so do you all see it well yeah",
    "start": "1961080",
    "end": "1968159"
  },
  {
    "text": "okay so and the time in Nan seconds for small numbers of elements that's just a",
    "start": "1968159",
    "end": "1974480"
  },
  {
    "text": "scale but for large number of elements that will be logarithmically scaled because otherwise you cannot fit it you",
    "start": "1974480",
    "end": "1981919"
  },
  {
    "text": "will see and for find we can see that uh",
    "start": "1981919",
    "end": "1987639"
  },
  {
    "text": "it's more or less the same benchmarks we cannot tell much from it especially",
    "start": "1987639",
    "end": "1994880"
  },
  {
    "text": "taking into account some deviations from uh the hardware use cases and so on but",
    "start": "1994880",
    "end": "2001720"
  },
  {
    "text": "uh the Boost flat map slightly overperform if we use can",
    "start": "2001720",
    "end": "2007799"
  },
  {
    "text": "find yeah you may see that I'm comparing maps not sets or it would be completely",
    "start": "2007799",
    "end": "2013200"
  },
  {
    "text": "boring but in the second case we jumping from 10 elements to 100,000",
    "start": "2013200",
    "end": "2019279"
  },
  {
    "text": "elements and here the situation is a little bit more interesting so if we use",
    "start": "2019279",
    "end": "2024880"
  },
  {
    "text": "fountain 100,000 elements we can clearly see that St map is working much much",
    "start": "2024880",
    "end": "2031720"
  },
  {
    "text": "slower uh this scale is now logarithmic stuff you can just probably estimate",
    "start": "2031720",
    "end": "2037679"
  },
  {
    "text": "amount based on this and the flat map we have a flat map of two",
    "start": "2037679",
    "end": "2043360"
  },
  {
    "text": "containers not not surprisingly it performs faster than uh the Boost flat map which is much",
    "start": "2043360",
    "end": "2052000"
  },
  {
    "text": "wider and you can take less elements into the cach at once so that's why it",
    "start": "2052000",
    "end": "2057638"
  },
  {
    "text": "performs worse but again for large number of El I got this Benchmark and",
    "start": "2057639",
    "end": "2062800"
  },
  {
    "text": "this is it's probably not even noticeable here but it's just like slly faster than the flat map the Boost flat",
    "start": "2062800",
    "end": "2070919"
  },
  {
    "text": "map so all data also will be attached and I probably will attach even all pictures datas and",
    "start": "2070919",
    "end": "2076560"
  },
  {
    "text": "benchmarks then archive or Gio we will see now we should move uh so far no",
    "start": "2076560",
    "end": "2085280"
  },
  {
    "text": "questions surprises or something yeah okay that's expect",
    "start": "2085280",
    "end": "2090520"
  },
  {
    "text": "it for insert operation some operations you probably shouldn't perform Super",
    "start": "2090520",
    "end": "2095919"
  },
  {
    "text": "frequently on FL containers here we have 10 elements and uh surprisingly I have this",
    "start": "2095919",
    "end": "2104520"
  },
  {
    "text": "Spike I measured it a lot of times I use cat two benchmarks for benchmarking",
    "start": "2104520",
    "end": "2110280"
  },
  {
    "text": "things and there are already fut durations by default but I tried on different machines and I got this Spike",
    "start": "2110280",
    "end": "2116720"
  },
  {
    "text": "here for the flat map perhaps because my implementation is bad or something but",
    "start": "2116720",
    "end": "2121760"
  },
  {
    "text": "it's notoriously slow for inserting elements or because you need to relocate two containers or do something like that",
    "start": "2121760",
    "end": "2128040"
  },
  {
    "text": "I can only imagine this I didn't check uh profiles reports to be honest but for",
    "start": "2128040",
    "end": "2135359"
  },
  {
    "text": "flat map we can see that it works kind of faster in average than both flat map",
    "start": "2135359",
    "end": "2143599"
  },
  {
    "text": "and St map but the situation slightly different if we",
    "start": "2143599",
    "end": "2149240"
  },
  {
    "text": "insert lunch number of elements so and that's again scaled the X X so and if we",
    "start": "2149240",
    "end": "2158599"
  },
  {
    "text": "insert a lot of elements uh",
    "start": "2158599",
    "end": "2163760"
  },
  {
    "text": "here into map so that's Works fast super",
    "start": "2163760",
    "end": "2169480"
  },
  {
    "text": "fast and if we do the same for flat map for some types it works a little bit",
    "start": "2169480",
    "end": "2176680"
  },
  {
    "text": "faster for 16bit in or for 32 but uh the",
    "start": "2176680",
    "end": "2184319"
  },
  {
    "text": "mid size sport X3 in 64 it's like comparable for both flat Maps but again",
    "start": "2184319",
    "end": "2191760"
  },
  {
    "text": "the flat map is proposed for the standard Library kind of Performing better even for inser",
    "start": "2191760",
    "end": "2199160"
  },
  {
    "text": "numbers then erase I am not sure why don't ask me",
    "start": "2200040",
    "end": "2208599"
  },
  {
    "text": "please but probably boost flat map they somehow cheating in implementation or something or not exactly eras or not",
    "start": "2208599",
    "end": "2215960"
  },
  {
    "text": "relocate it's a just standard boost thingy with a default container but it",
    "start": "2215960",
    "end": "2221880"
  },
  {
    "text": "much much faster when we are trying to erase and especially when we are trying to erase in",
    "start": "2221880",
    "end": "2228200"
  },
  {
    "text": "64 so it's probably on my system again but it's much faster than all other",
    "start": "2228200",
    "end": "2233480"
  },
  {
    "text": "stuff and I suspect if you play with underlying containers there you you might get different results but here we",
    "start": "2233480",
    "end": "2240640"
  },
  {
    "text": "go so that's what we have and if you want to erase SL number",
    "start": "2240640",
    "end": "2246920"
  },
  {
    "text": "of elements again it's scaled obviously St map is much faster so you don't need",
    "start": "2246920",
    "end": "2252200"
  },
  {
    "text": "to relocate this one but again flat map from the standard library is better in",
    "start": "2252200",
    "end": "2258880"
  },
  {
    "text": "terms of this point of view of this Benchmark than the flat map for Boost so",
    "start": "2258880",
    "end": "2266680"
  },
  {
    "text": "if we even do many operations then we can somehow conclude based on this",
    "start": "2266680",
    "end": "2272240"
  },
  {
    "text": "unreliable data from my personal PC that flat map can be better in terms of two",
    "start": "2272240",
    "end": "2278480"
  },
  {
    "text": "other inefficient operations but again you should do your own",
    "start": "2278480",
    "end": "2284160"
  },
  {
    "text": "benchmarks and this particular test I eded because some people asked",
    "start": "2284960",
    "end": "2292720"
  },
  {
    "text": "me to do and they said you need to insert iterate over vector and compare",
    "start": "2292720",
    "end": "2298720"
  },
  {
    "text": "it to iterate over map that's what I'm doing right now and the results are also very interesting to be",
    "start": "2298720",
    "end": "2304440"
  },
  {
    "text": "honest so the iteration surpris surprisingly pretty",
    "start": "2304440",
    "end": "2310720"
  },
  {
    "text": "much the same or comparable for both flat map and uh my flat map",
    "start": "2310720",
    "end": "2318599"
  },
  {
    "text": "implementation and that's slightly slower for map and if we have large",
    "start": "2318599",
    "end": "2325400"
  },
  {
    "text": "number of elements so they iterating",
    "start": "2325400",
    "end": "2330760"
  },
  {
    "text": "over boost here for the small elements is kind of faster but for other elements",
    "start": "2330760",
    "end": "2338960"
  },
  {
    "text": "is well it's comparable so if you just iterate over things so you might don't want to really",
    "start": "2338960",
    "end": "2346880"
  },
  {
    "text": "care how your key and values are located other two containers or in a single",
    "start": "2346880",
    "end": "2352440"
  },
  {
    "text": "container but again it was benchmarks from my own machine so do your own don't",
    "start": "2352440",
    "end": "2359000"
  },
  {
    "text": "rely on this data and now we can talk about",
    "start": "2359000",
    "end": "2367520"
  },
  {
    "text": "advantages and disadvantages flat versus non",
    "start": "2367520",
    "end": "2372680"
  },
  {
    "text": "flat so let's start with uh pros and cons of using standard set or map I'm",
    "start": "2379520",
    "end": "2386319"
  },
  {
    "text": "combining it here because that's pretty much the same under the hood so and at",
    "start": "2386319",
    "end": "2391760"
  },
  {
    "text": "the first line for both first pro and first con you can see that",
    "start": "2391760",
    "end": "2397200"
  },
  {
    "text": "I put here that it's non-contiguous container and why it both pros and cons because apparently it does utilize this",
    "start": "2397200",
    "end": "2405680"
  },
  {
    "text": "memory thingy cache memory fragmentation and stuff but on the other hand is a pro",
    "start": "2405680",
    "end": "2412160"
  },
  {
    "text": "because the memory of your system can be in so bad state that you cannot find",
    "start": "2412160",
    "end": "2417680"
  },
  {
    "text": "enough contigous memory to allocate chunk and this is an issue so if you",
    "start": "2417680",
    "end": "2423280"
  },
  {
    "text": "your system in this state that's definitely a conf for you but uh among",
    "start": "2423280",
    "end": "2428680"
  },
  {
    "text": "Pros there is good complexity good complexity is for all three operations it's very predictable it's very",
    "start": "2428680",
    "end": "2435760"
  },
  {
    "text": "consistent it's nice to use it then no iterators so references are",
    "start": "2435760",
    "end": "2442520"
  },
  {
    "text": "invalidated so it just allocated somewhere on hip you can access use it very cool you can even take a note",
    "start": "2442520",
    "end": "2449640"
  },
  {
    "text": "handle if you want the newest standard but the conses as I said about",
    "start": "2449640",
    "end": "2456319"
  },
  {
    "text": "non-contiguous stuff then memory fragmentation not good for many systems so your system might get into the state",
    "start": "2456319",
    "end": "2463440"
  },
  {
    "text": "where it cannot Tate a contigous Chan by a reason because your memory is too fragmented and you not using pools for",
    "start": "2463440",
    "end": "2471319"
  },
  {
    "text": "small objects and something like that and your app is running for a long time and potentially there are more cach",
    "start": "2471319",
    "end": "2479200"
  },
  {
    "text": "misses I had this table you can see how many cycles or seconds any every cashm",
    "start": "2479200",
    "end": "2487000"
  },
  {
    "text": "can cost your system but again it might not be an issue for you if you're not running some high performance",
    "start": "2487000",
    "end": "2492839"
  },
  {
    "text": "applications or games or something like that so if it's a desktop software for",
    "start": "2492839",
    "end": "2498480"
  },
  {
    "text": "some reasons written in C++ then you can",
    "start": "2498480",
    "end": "2504800"
  },
  {
    "text": "just mostly ignore this negative part and now we are talking about uh",
    "start": "2504800",
    "end": "2512400"
  },
  {
    "text": "flat stuff so and again first pro and first SC this is a contigous container",
    "start": "2512400",
    "end": "2518280"
  },
  {
    "text": "right so you might again have not enough memory to allocate the contigous chunk",
    "start": "2518280",
    "end": "2523640"
  },
  {
    "text": "it's well it's mostly will be contigous container to be honest uh and uh it's a",
    "start": "2523640",
    "end": "2530520"
  },
  {
    "text": "good stuff that you can avoid memory fragmentation just by locating those chunks this has better cach locality for",
    "start": "2530520",
    "end": "2538760"
  },
  {
    "text": "sure the FAS itating and searching we saw it even in our benchmarks and then from the",
    "start": "2538760",
    "end": "2544440"
  },
  {
    "text": "implementation then it's possible to choose a different underling container very cool stuff especially if you use it",
    "start": "2544440",
    "end": "2551440"
  },
  {
    "text": "for small caches or something so you can take boost small vector or things that",
    "start": "2551440",
    "end": "2557800"
  },
  {
    "text": "pre-allocated elements even on stack if you want and then utilize this you just",
    "start": "2557800",
    "end": "2564599"
  },
  {
    "text": "uh can create it at once and use very good and very fast so and there a cons",
    "start": "2564599",
    "end": "2571880"
  },
  {
    "text": "two major operations instant inter race slow and uh insert operation can",
    "start": "2571880",
    "end": "2578319"
  },
  {
    "text": "invalidate iterators as well as aray can and usar",
    "start": "2578319",
    "end": "2585400"
  },
  {
    "text": "advices uh I partially I guess touched many of these things are a good time",
    "start": "2585400",
    "end": "2593839"
  },
  {
    "text": "there so you should use flat containers if you",
    "start": "2593839",
    "end": "2599119"
  },
  {
    "text": "have relatively small count of items so it might be 10 100 1,000 even more it",
    "start": "2599119",
    "end": "2607960"
  },
  {
    "text": "depends on the element size so if it's 16 in you can put more or if you have",
    "start": "2607960",
    "end": "2616000"
  },
  {
    "text": "specific memory in you're embeding specific traits you can again put more it depends but it's recommended that you",
    "start": "2616000",
    "end": "2624359"
  },
  {
    "text": "have relatively small number of elements for this container then relatively small element",
    "start": "2624359",
    "end": "2630920"
  },
  {
    "text": "themselves so like if it doesn't perform well if when it's like midsize sport in",
    "start": "2630920",
    "end": "2636559"
  },
  {
    "text": "general but it can be good it depend on how you utilize the properties of those",
    "start": "2636559",
    "end": "2642559"
  },
  {
    "text": "structures then uh there are no many inserts and erases",
    "start": "2642559",
    "end": "2648880"
  },
  {
    "text": "operation should be performed on these containers the probably best usage scenario that you can create it at once",
    "start": "2648880",
    "end": "2655960"
  },
  {
    "text": "doesn't matter how but you create it at once and then only use for either itera or for searching elements as I mentioned",
    "start": "2655960",
    "end": "2663760"
  },
  {
    "text": "uh that's very good if it's um like a small cache I use it for small caches for",
    "start": "2663760",
    "end": "2670520"
  },
  {
    "text": "stuff like that or even uh of embeded thing but yeah that's the best case so",
    "start": "2670520",
    "end": "2678040"
  },
  {
    "text": "it reduces the memory overhead and fragmentation why I separated the memory",
    "start": "2678040",
    "end": "2686119"
  },
  {
    "text": "overhead remember my implementation naive implementation of the tree node it",
    "start": "2686119",
    "end": "2692359"
  },
  {
    "text": "has more Fields it has a field for color and it has two pointer fields for sub",
    "start": "2692359",
    "end": "2699520"
  },
  {
    "text": "trees and then it has of course key value stuff so the memory overhead there",
    "start": "2699520",
    "end": "2705280"
  },
  {
    "text": "are some benchmarks from Google I believe and they show that the memory overhead of flat containers is much much",
    "start": "2705280",
    "end": "2713319"
  },
  {
    "text": "less than if you especially if use more of those containers in your program than",
    "start": "2713319",
    "end": "2718760"
  },
  {
    "text": "if you use standard Maps or sets uh ruse memory fragmentation",
    "start": "2718760",
    "end": "2724440"
  },
  {
    "text": "because it's most likely will be biggest container it's one chunk of memory or like",
    "start": "2724440",
    "end": "2729920"
  },
  {
    "text": "chance and the last bullet I also mentioned that you can allocate or",
    "start": "2729920",
    "end": "2735760"
  },
  {
    "text": "pre-allocate or use different containers just utilize this property since it's container adapters standard Vector is",
    "start": "2735760",
    "end": "2742599"
  },
  {
    "text": "good it's a default container for pretty much everything you don't know which container to choose go for Vector",
    "start": "2742599",
    "end": "2747760"
  },
  {
    "text": "probably but you can play with this just experiment what better suits your needs in the app and",
    "start": "2747760",
    "end": "2755960"
  },
  {
    "text": "and with this I don't have I believe anything else to share with you guys",
    "start": "2755960",
    "end": "2761319"
  },
  {
    "text": "don't want to hold you before the lunch thank you for attending [Applause]",
    "start": "2761319",
    "end": "2768219"
  },
  {
    "text": "yeah yeah",
    "start": "2769920",
    "end": "2773240"
  },
  {
    "text": "should that's a good question I don't really know but we can probably check",
    "start": "2776160",
    "end": "2783240"
  },
  {
    "text": "the reference and standard but since it should be why not I mean if",
    "start": "2783240",
    "end": "2789480"
  },
  {
    "text": "it's if the underline container is able to use it many methods and interface are also marked as a Conex from what I",
    "start": "2789480",
    "end": "2796640"
  },
  {
    "text": "remember so should be possible theoretically but I cannot give you 100%",
    "start": "2796640",
    "end": "2803760"
  },
  {
    "text": "guarantee so any other questions but yeah if not",
    "start": "2803760",
    "end": "2812440"
  },
  {
    "text": "thank you again we're done",
    "start": "2812440",
    "end": "2817800"
  }
]