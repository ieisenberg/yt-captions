[
  {
    "start": "0",
    "end": "175000"
  },
  {
    "text": "well thank you for coming welcome this is uh the C++ truck and uh they keep",
    "start": "1599",
    "end": "7120"
  },
  {
    "text": "moving us right if you were at U NDC for a few years you know they keep moving us from room to room this time they hid Us",
    "start": "7120",
    "end": "13719"
  },
  {
    "text": "in this very uh secure and closure uh but anyway thank you for coming and uh",
    "start": "13719",
    "end": "19720"
  },
  {
    "text": "this is going to be investigating C++ applications in production on Linux and windows quite a title uh my name is",
    "start": "19720",
    "end": "26080"
  },
  {
    "text": "Sasha I work for a training and consulting company called Cella uh we do U this sort of thing uh",
    "start": "26080",
    "end": "32599"
  },
  {
    "text": "debugging performance investigations and uh specifically if you have C++ uh",
    "start": "32599",
    "end": "38040"
  },
  {
    "text": "that's crossplatform that you try to run on both windows and Linux or some other flavors of Unix systems or even if you",
    "start": "38040",
    "end": "44840"
  },
  {
    "text": "only target one platform the whole story of how to look at your application in production get performance information",
    "start": "44840",
    "end": "51360"
  },
  {
    "text": "from production get uh diagnostic information from production has traditionally been uh pretty difficult",
    "start": "51360",
    "end": "57800"
  },
  {
    "text": "this whole production side of things so so there's lots of tools for the development story for the development",
    "start": "57800",
    "end": "63559"
  },
  {
    "text": "time profiling and debugging and that sort of thing uh if you're on Windows I bet you're using visual studio or",
    "start": "63559",
    "end": "69680"
  },
  {
    "text": "something like this if you're developing for Linux uh with C++ you might be using Eclipse but these development tools they",
    "start": "69680",
    "end": "76799"
  },
  {
    "text": "have uh some pretty good debugging and uh occasionally performance profiling capabilities also uh but the production",
    "start": "76799",
    "end": "83200"
  },
  {
    "text": "side has often been neglected and so this is what I want to focus on uh in this talk give you uh some idea of the",
    "start": "83200",
    "end": "89119"
  },
  {
    "text": "tools I use and other people use to diagnose issues in production in R C++",
    "start": "89119",
    "end": "95240"
  },
  {
    "text": "applications um so just the slide is not advancing there we go uh some objectives",
    "start": "95240",
    "end": "100680"
  },
  {
    "text": "I would like us to cover uh and for you to come back at the end of the talk and be sure that you actually learned uh so",
    "start": "100680",
    "end": "106600"
  },
  {
    "text": "we'll talk briefly about dump analysis uh getting core dumps or dump files depends on the OS uh and analyzing them",
    "start": "106600",
    "end": "113280"
  },
  {
    "text": "in a debugger without leaving the production environment ideally uh we'll talk about some tracing tools uh so",
    "start": "113280",
    "end": "119920"
  },
  {
    "text": "lightweight loggers that you can attach to your application and get an idea of uh interesting runtime events that are",
    "start": "119920",
    "end": "126119"
  },
  {
    "text": "happening like uh file accesses uh dis accesses Network events that sort of",
    "start": "126119",
    "end": "131120"
  },
  {
    "text": "thing we'll talk about CPU profiling and how to visualize uh CPU profiling results to pinpoint uh CPU bottlenecks",
    "start": "131120",
    "end": "138519"
  },
  {
    "text": "in your production system uh without having to suspend the process without having to restart the process just doing",
    "start": "138519",
    "end": "144599"
  },
  {
    "text": "this for a live uh production process we'll talk about uh memory leaks briefly and how to identify which areas in your",
    "start": "144599",
    "end": "151480"
  },
  {
    "text": "code are allocating and not freeing certain uh memory blocks and uh we'll do",
    "start": "151480",
    "end": "156519"
  },
  {
    "text": "that by instrumenting memory allocations but again doing this for a live production process without having to",
    "start": "156519",
    "end": "161879"
  },
  {
    "text": "recompile or restart it and finally we'll talk about some I'll show you some examples of uh little oneliner",
    "start": "161879",
    "end": "168560"
  },
  {
    "text": "investigations where you briefly slightly customize a tool uh to do something very specific so that's the",
    "start": "168560",
    "end": "174239"
  },
  {
    "text": "plan uh in terms of operating systems so I tried to highlight uh five core areas",
    "start": "174239",
    "end": "179959"
  },
  {
    "start": "175000",
    "end": "175000"
  },
  {
    "text": "which we'll be looking at uh CPU sampling so figure out the CPU bottleneck Dynamic tracing which",
    "start": "179959",
    "end": "186040"
  },
  {
    "text": "basically means attaching to an area of the system that is not uh instrumented with some logging in advance then",
    "start": "186040",
    "end": "193239"
  },
  {
    "text": "there's static tracing which is attaching and tracing events on a system which is instrumented for that in",
    "start": "193239",
    "end": "198840"
  },
  {
    "text": "advance and then we have core dump generation and core dump analysis and for all these different scenarios I've",
    "start": "198840",
    "end": "204799"
  },
  {
    "text": "tried to put together some tools on different operating systems which would be able to uh sort of stand up to the",
    "start": "204799",
    "end": "211680"
  },
  {
    "text": "task and that can be used in a production environment so for example when on Windows I'm putting down Visual",
    "start": "211680",
    "end": "217920"
  },
  {
    "text": "Studio in there I do I do intend to show an alternative that you can use if you can't install Visual Studio in your",
    "start": "217920",
    "end": "224200"
  },
  {
    "text": "production environment and uh on Linux again I want to show tools that can actually be used in production and so",
    "start": "224200",
    "end": "229959"
  },
  {
    "text": "what we'll be focusing on is just windows and Linux but of course uh similar options exist uh for other os's",
    "start": "229959",
    "end": "236480"
  },
  {
    "text": "sometimes uh some features might not be fully supported or exactly the same but the general idea hopefully will be",
    "start": "236480",
    "end": "242840"
  },
  {
    "text": "useful before we get started uh just a few disclaimers uh first mind the",
    "start": "242840",
    "end": "247920"
  },
  {
    "start": "243000",
    "end": "243000"
  },
  {
    "text": "overhead any kind of production investigation comes with the risk of uh screwing something up in your uh in your",
    "start": "247920",
    "end": "254360"
  },
  {
    "text": "environment by other slowing things down or uh even crashing your process because",
    "start": "254360",
    "end": "259600"
  },
  {
    "text": "you attach a tool that is too invasive or maybe even crashing the whole system if you put too much uh uh stress on the",
    "start": "259600",
    "end": "266400"
  },
  {
    "text": "whole box so you need to measure you need to test all the tools I'm going to show you in your own system in your own",
    "start": "266400",
    "end": "272400"
  },
  {
    "text": "test environment uh before you go ahead and deploy them to production and a lot of tools will have a dedicated overhead",
    "start": "272400",
    "end": "279039"
  },
  {
    "text": "section in their documentation at least the good tools they will tell you what to expect how they work and what the",
    "start": "279039",
    "end": "285800"
  },
  {
    "text": "expected overhead should be and then you should be able to decide for yourself so like if the overhead uh the worst case",
    "start": "285800",
    "end": "291960"
  },
  {
    "text": "overhead is is 20% I might be okay with this for my production box someone else",
    "start": "291960",
    "end": "297759"
  },
  {
    "text": "might say no anything that's worse than 2% I cannot afford to run on my production box but some tools actually",
    "start": "297759",
    "end": "304520"
  },
  {
    "text": "have an overhead of like 200% and then well they're just not so well suited for",
    "start": "304520",
    "end": "309600"
  },
  {
    "text": "production use I suppose so we'll start with uh core dumps uh or dump files",
    "start": "309600",
    "end": "315199"
  },
  {
    "start": "312000",
    "end": "312000"
  },
  {
    "text": "depends on the OS just as a very very general uh introduction core dumps or dump file is a memory snapshot of a",
    "start": "315199",
    "end": "322880"
  },
  {
    "text": "running process so you have a process running uh over time it has a bunch of threads and you can attach to the",
    "start": "322880",
    "end": "329080"
  },
  {
    "text": "process a particular Moment In Time suspend the process and write out the process memory to a file and this can",
    "start": "329080",
    "end": "336479"
  },
  {
    "text": "happen either on demand like whenever you want so like in this illustration the process is running and then we stop",
    "start": "336479",
    "end": "342840"
  },
  {
    "text": "it grab a dump and let the process continue execution or this could happen",
    "start": "342840",
    "end": "348080"
  },
  {
    "text": "on Crash so if the process crashes if the system uh crashes has an unhandled",
    "start": "348080",
    "end": "353240"
  },
  {
    "text": "exception or signal then we can generate a core dump as well and this is what most people actually recognize when you",
    "start": "353240",
    "end": "359479"
  },
  {
    "text": "you mention core dumps to them they think of crash dumps actually uh but you can generate dumps whenever you want",
    "start": "359479",
    "end": "365560"
  },
  {
    "text": "based on arbitrary triggers and conditions so let's take a look at some",
    "start": "365560",
    "end": "370639"
  },
  {
    "start": "370000",
    "end": "370000"
  },
  {
    "text": "of the tools we have for uh generating dumps by the way in terms of demos I do",
    "start": "370639",
    "end": "375720"
  },
  {
    "text": "have uh live demos of everything but if something doesn't work or if we don't have time I also have screenshots so the",
    "start": "375720",
    "end": "381880"
  },
  {
    "text": "slides you will have at the end uh will hopefully let you reconstruct this whole story uh on your own box uh so un Lear",
    "start": "381880",
    "end": "390039"
  },
  {
    "text": "the dump generation story is fairly simple uh the system is typically configured in such a way that dumps can",
    "start": "390039",
    "end": "397160"
  },
  {
    "text": "be generated when an application crashes you can get core dumps when an application crashes there's a magic file",
    "start": "397160",
    "end": "403599"
  },
  {
    "text": "called process kernel core pattern uh which you can configure for one of two things you can either put a file name in",
    "start": "403599",
    "end": "410479"
  },
  {
    "text": "there and then you would just get a Core dump file with that name in the current",
    "start": "410479",
    "end": "416000"
  },
  {
    "text": "directory if your application crashes with some unhandled exception ction or you could put an application name in",
    "start": "416000",
    "end": "423199"
  },
  {
    "text": "there and essentially pipe uh the dump information into a uh separate process",
    "start": "423199",
    "end": "429240"
  },
  {
    "text": "which might just capture some basic info and write out a log and not actually",
    "start": "429240",
    "end": "434840"
  },
  {
    "text": "generate the whole core dump which could be multiple gigabytes of of space so you could uh pipe the dump output to an",
    "start": "434840",
    "end": "441520"
  },
  {
    "text": "application or you write it out uh to a file there's also a uh configuration",
    "start": "441520",
    "end": "446840"
  },
  {
    "text": "switch which controls the maximum core dump file size that you are willing to accept and you limit can configure that",
    "start": "446840",
    "end": "453639"
  },
  {
    "text": "and finally to open core dumps you can use u a bunch of different debuggers GDB Works lb works and there's uh obviously",
    "start": "453639",
    "end": "461000"
  },
  {
    "text": "additional custom tools as well the windows story is fairly similar on Windows there's a registry key of course",
    "start": "461000",
    "end": "468199"
  },
  {
    "text": "because that's the windows configuration database so there's a registry key that you can configure uh to get dump files",
    "start": "468199",
    "end": "475199"
  },
  {
    "text": "automatically whenever an application crashes you can configure this uh to be systemwide or for just one particular",
    "start": "475199",
    "end": "482520"
  },
  {
    "text": "process and both of these things hopefully are something that you can actually do on production boxes on uh",
    "start": "482520",
    "end": "489520"
  },
  {
    "text": "Linux you might want to limit the core dump file size on Windows you have control over the type of the dump if",
    "start": "489520",
    "end": "495960"
  },
  {
    "text": "it's going to contain the whole process memory or just certain portions so that the file is actually smaller but",
    "start": "495960",
    "end": "502520"
  },
  {
    "text": "generally these settings are something you can apply to a production system and they would only have effect if a process",
    "start": "502520",
    "end": "508840"
  },
  {
    "text": "actually crashes so as long as you don't have crashes and operation is normal you don't really pay anything for these uh",
    "start": "508840",
    "end": "514719"
  },
  {
    "text": "settings you only pay for them when there's an actual crash and you want to identify what happened uh later on",
    "start": "514719",
    "end": "521159"
  },
  {
    "text": "Windows there's also proc dump which can generate core dumps on demand on Linux",
    "start": "521159",
    "end": "526279"
  },
  {
    "text": "there's a similar tool called goree which can generate core dumps on demand what do you do with them and I'll show",
    "start": "526279",
    "end": "532880"
  },
  {
    "start": "532000",
    "end": "532000"
  },
  {
    "text": "you a quick demo uh in a moment so on Linux uh you can attach GDB for example",
    "start": "532880",
    "end": "538200"
  },
  {
    "text": "or lldb or a bunch bunch of other debuggers uh to the dump file to the core dump and ask uh the debugger to",
    "start": "538200",
    "end": "545959"
  },
  {
    "text": "give you information about the uh crash that occurred the call stack of the current thread get list of threads",
    "start": "545959",
    "end": "552880"
  },
  {
    "text": "basically navigate the core dump as if you were attached to the live process at the moment of the crash this is kind of",
    "start": "552880",
    "end": "559880"
  },
  {
    "text": "the idea of generating C dumps you get a snapshot of the process and you can uh just Traverse it as if it were live of",
    "start": "559880",
    "end": "567360"
  },
  {
    "text": "course you can't continue execution from that point because it's just a snapshot in time but it does give you the same as",
    "start": "567360",
    "end": "573800"
  },
  {
    "text": "if you broke into a debugger and started looking around that's the effect we want to get on Windows uh Visual Studio can",
    "start": "573800",
    "end": "581480"
  },
  {
    "text": "actually open dump files and this is again less interesting for production although you could of course copy the",
    "start": "581480",
    "end": "588079"
  },
  {
    "text": "file from the production environment to a development box and then open the dump in Visual Studio on your development",
    "start": "588079",
    "end": "594519"
  },
  {
    "text": "machine alternatively there is a set of lightweight debuggers such as windbg and",
    "start": "594519",
    "end": "600720"
  },
  {
    "text": "cdb which you can run in the actual production system it's just files you need to copy over there's no",
    "start": "600720",
    "end": "606320"
  },
  {
    "text": "installation involved and they can also perform some basic uh dump analysis and",
    "start": "606320",
    "end": "611720"
  },
  {
    "text": "tell you what the exception was what the call stack was which modules were loaded which threads were running and that sort",
    "start": "611720",
    "end": "617720"
  },
  {
    "text": "of thing and for both of these options you might also want to look and that's something I'm not going to cover here",
    "start": "617720",
    "end": "624279"
  },
  {
    "text": "into automation of this whole process so if you have a 100 dump files opening",
    "start": "624279",
    "end": "629560"
  },
  {
    "text": "each of them individually and then running commands manually and inspecting the results is going to get pretty",
    "start": "629560",
    "end": "635000"
  },
  {
    "text": "tedious so you do want to have some sort of script which would uh get you just the basic detailed uh the basic details",
    "start": "635000",
    "end": "642079"
  },
  {
    "text": "out of each uh cord dump like the crash that occurred the call stack which module was responsible and then the next",
    "start": "642079",
    "end": "649519"
  },
  {
    "text": "file and the next and the next this can be achieved on both Linux and windows by just automating the debugger essentially",
    "start": "649519",
    "end": "655760"
  },
  {
    "text": "scripting the debugger to do what you want so I want to show you a couple of examples again uh I have SC screenshots",
    "start": "655760",
    "end": "662480"
  },
  {
    "text": "as a backup but let's hope we don't need them um so on Windows I have in my registry the",
    "start": "662480",
    "end": "669360"
  },
  {
    "text": "configuration mentioned on the slides so I have this app called battery meter which crashes occasionally and uh I have",
    "start": "669360",
    "end": "676519"
  },
  {
    "text": "configured local dumps on my uh Windows registry to uh generate dumps for the",
    "start": "676519",
    "end": "682279"
  },
  {
    "text": "battery meter process and place them in this folder c/t dumps whenever a crash",
    "start": "682279",
    "end": "688680"
  },
  {
    "text": "in that process occurs now if we actually run this crashing battery meter",
    "start": "688680",
    "end": "696279"
  },
  {
    "text": "application here's what it looks like it's not actually doing anything it's just a sample of course and then I can",
    "start": "696279",
    "end": "701720"
  },
  {
    "text": "click around and still nothing happens but after a while it uh crashes so",
    "start": "701720",
    "end": "706920"
  },
  {
    "text": "application has stopped working and I can close it and then if I'm look in my",
    "start": "706920",
    "end": "712600"
  },
  {
    "text": "uh dumps directory then there's a sample file I generated yesterday and there's",
    "start": "712600",
    "end": "718200"
  },
  {
    "text": "also the dump file file from right now which Windows created as soon as that process crashed now this is a complete",
    "start": "718200",
    "end": "724200"
  },
  {
    "text": "memory snapshot so we see it's it's like 64 uh megabytes and obviously for larger",
    "start": "724200",
    "end": "729839"
  },
  {
    "text": "processes it could be a lot larger so there is control you can exercise over the exact size of the file now you can",
    "start": "729839",
    "end": "737079"
  },
  {
    "text": "open those again like I've said in Visual Studio or in uh a more production",
    "start": "737079",
    "end": "742800"
  },
  {
    "text": "friendly debugger just to illustrate what happens when you open this kind of file in Visual Studio I'm going to drag",
    "start": "742800",
    "end": "749639"
  },
  {
    "text": "it in and then Visual Studio shows me uh the basic information about the file",
    "start": "749639",
    "end": "755800"
  },
  {
    "text": "which includes uh the exception code that happened now this number might not tell me much but if I click debug here",
    "start": "755800",
    "end": "762760"
  },
  {
    "text": "on the right then Visual Studio displays uh additional information that says a",
    "start": "762760",
    "end": "768120"
  },
  {
    "text": "heap has been corrupted so I have a memory corruption in this uh process actually and uh if I click break it will",
    "start": "768120",
    "end": "776560"
  },
  {
    "text": "show me the call stack where this crash occurred uh so this is a call stack",
    "start": "776560",
    "end": "781920"
  },
  {
    "text": "inside the windows Hep manager which had a a crash so basically was trying to",
    "start": "781920",
    "end": "787760"
  },
  {
    "text": "free memory and then the Heap noticed that it is corrupted and I can navigate",
    "start": "787760",
    "end": "793560"
  },
  {
    "text": "to my own source code as well which is in this function here and then I just need to",
    "start": "793560",
    "end": "798920"
  },
  {
    "text": "tell my debugger where to find uh the source for this",
    "start": "798920",
    "end": "805959"
  },
  {
    "text": "um for this process oh I don't have the source is here well I'm sorry about that but you could um you could obviously",
    "start": "805959",
    "end": "812560"
  },
  {
    "text": "tell your debugger uh to open the source and actually show you the source I do have a screenshot of this right over",
    "start": "812560",
    "end": "818440"
  },
  {
    "text": "here this is what it looks like where I do have the sources on the system it just points to the specific line of",
    "start": "818440",
    "end": "824000"
  },
  {
    "text": "source which had the crash and if you look at the line it's actually pointing to the closing brace over here and so",
    "start": "824000",
    "end": "831360"
  },
  {
    "text": "you might ask how come the closing brace is trying to deallocate memory but then you think about it and the closing brace",
    "start": "831360",
    "end": "838160"
  },
  {
    "text": "is where is structors run correct so some Destructor was running at this closing brace and trying to uh free",
    "start": "838160",
    "end": "845360"
  },
  {
    "text": "memory so probably either the battery information or the CPU information classes they have inside a heap pointer",
    "start": "845360",
    "end": "852240"
  },
  {
    "text": "and the destructor for these classes is then trying to free that pointer and um it it notices that the Heap has been",
    "start": "852240",
    "end": "858480"
  },
  {
    "text": "corrupted now obviously this isn't enough to actually investigate what happened exactly but we know where the",
    "start": "858480",
    "end": "863759"
  },
  {
    "text": "crash was and what the exception was and what the call stack was and what all the other were doing as well if we wanted to",
    "start": "863759",
    "end": "872000"
  },
  {
    "text": "the same thing we could replicate using uh either windy BG or even light more",
    "start": "872000",
    "end": "878079"
  },
  {
    "text": "lightweight debuggers again these are there are many options and we're not going to look in depth at all of them",
    "start": "878079",
    "end": "884040"
  },
  {
    "text": "but for example in windbg which is a lightweight debugger you could drag and",
    "start": "884040",
    "end": "889120"
  },
  {
    "text": "drop the dump file into the debugger again and then if you run an uh extra",
    "start": "889120",
    "end": "894480"
  },
  {
    "text": "command called Heap you would actually get uh some more specific specific information about the Heap corruption",
    "start": "894480",
    "end": "901160"
  },
  {
    "text": "and this is something Visual Studio actually doesn't do and so this uh more specific information would tell you for",
    "start": "901160",
    "end": "906959"
  },
  {
    "text": "example that we detected an error whose features are consistent with a buffer overrun so our memory corruption in the",
    "start": "906959",
    "end": "913880"
  },
  {
    "text": "Heap is not just a random memory corruption it looks like a buffer overrun over a heap buffer which can be",
    "start": "913880",
    "end": "919519"
  },
  {
    "text": "used for further investigation and this whole process can also be automated so here I have a",
    "start": "919519",
    "end": "925279"
  },
  {
    "text": "screenshot from a command line window on uh on Windows where I ran the cdb XY uh tool this is a",
    "start": "925279",
    "end": "934199"
  },
  {
    "text": "command line debugger which is again very very lightweight and what it can give you is uh the same analysis",
    "start": "934199",
    "end": "940680"
  },
  {
    "text": "essentially in in in the shape of a text file and I have actually stored uh that",
    "start": "940680",
    "end": "946199"
  },
  {
    "text": "text file right over here so we can look at it if we want and um this is just an",
    "start": "946199",
    "end": "951560"
  },
  {
    "text": "analysis an exception analysis which has in in text format the same information",
    "start": "951560",
    "end": "956759"
  },
  {
    "text": "we had a corrupted Heap you can see the C stack you can see the function in which it happened the reason I'm showing",
    "start": "956759",
    "end": "962519"
  },
  {
    "text": "this is just to explain that we can automate the whole process once I have a command a oneliner that analyzes the",
    "start": "962519",
    "end": "969040"
  },
  {
    "text": "dump and generates this kind of text I can build a whole workflow which would do this for 100 files and then aggregate",
    "start": "969040",
    "end": "976000"
  },
  {
    "text": "the the exception results let's take a look at the story on Linux just very briefly so uh this is a screenshot but",
    "start": "976000",
    "end": "983079"
  },
  {
    "text": "let's try and do it live um so I have over here a a core file which was",
    "start": "983079",
    "end": "989360"
  },
  {
    "text": "generated previously from uh crashing one of my sample processes these are our",
    "start": "989360",
    "end": "994880"
  },
  {
    "text": "online so you could uh replicate these results later so I'm going to uh just resize this a",
    "start": "994880",
    "end": "1001399"
  },
  {
    "text": "little I'm going to run uh GDB and uh tell GDB that the actual application we",
    "start": "1001399",
    "end": "1008440"
  },
  {
    "text": "are um we are looking at is uh sorry it's over here in this folder actually",
    "start": "1008440",
    "end": "1013720"
  },
  {
    "text": "it's called parre and the core file is this core file over here",
    "start": "1013720",
    "end": "1019040"
  },
  {
    "text": "and then GDB happily loads that core file and says that uh the program was",
    "start": "1019040",
    "end": "1024480"
  },
  {
    "text": "terminated with the signal sigga boort uh so this is why we crashed and it",
    "start": "1024480",
    "end": "1029558"
  },
  {
    "text": "tells me that the current thread is thread number one and then we get we could again perform some analysis so for",
    "start": "1029559",
    "end": "1034720"
  },
  {
    "text": "example I could get a stack Trace in uh in GDB and this is C++ so the function",
    "start": "1034720",
    "end": "1041120"
  },
  {
    "text": "names you know what it what it's like uh the function names are slightly on on the longer side um but you can see that",
    "start": "1041120",
    "end": "1049160"
  },
  {
    "text": "um this whole thing is happening inside the Heap so this also has a heap",
    "start": "1049160",
    "end": "1054440"
  },
  {
    "text": "corruption very likely uh so we are trying to call uh Lipsy free to free memory and then it just uh bails out",
    "start": "1054440",
    "end": "1062400"
  },
  {
    "text": "with a with an error and we can see along the way some strings indicating double free or corruption so we we also",
    "start": "1062400",
    "end": "1069039"
  },
  {
    "text": "have a heap corruption here and if we look uh at the whole call stack which is kind of um hard to read through but if",
    "start": "1069039",
    "end": "1075679"
  },
  {
    "text": "we look at the co stack it we we got here from from uh from stood Vector um",
    "start": "1075679",
    "end": "1081720"
  },
  {
    "text": "over here stood Vector of string which was trying to uh allocate something so",
    "start": "1081720",
    "end": "1087360"
  },
  {
    "text": "it called into the allocator and probably had to resize things and and eventually the the uh hip uh",
    "start": "1087360",
    "end": "1094360"
  },
  {
    "text": "implementation again in lipy noticed that the Heap has become corrupted um so this is just again a",
    "start": "1094360",
    "end": "1102039"
  },
  {
    "text": "very very general overview of what dump files and core dumps can do for you um",
    "start": "1102039",
    "end": "1107360"
  },
  {
    "text": "you can generate the automatically when something goes wrong you can then on the same system even in production analyze",
    "start": "1107360",
    "end": "1113760"
  },
  {
    "text": "the crash and see like what's what's happening in your process and this is very very similar across uh operating",
    "start": "1113760",
    "end": "1121120"
  },
  {
    "text": "systems and it is a key way of diagnosing production crashes essentially there's a I mean hardly a",
    "start": "1121120",
    "end": "1128720"
  },
  {
    "text": "way to run a debugger attached to your production process at all times so this is the second best thing it basically",
    "start": "1128720",
    "end": "1134760"
  },
  {
    "text": "replicates the whole debugger experience on a on a snapshot of your your processes",
    "start": "1134760",
    "end": "1139919"
  },
  {
    "text": "memory now it unfortunately requires if you are trying to do this on the production system it unfortunally",
    "start": "1139919",
    "end": "1146720"
  },
  {
    "text": "requires that you have debug information or debugging symbols on the production system as well if you want to do cord",
    "start": "1146720",
    "end": "1153240"
  },
  {
    "text": "dump analysis in production you will also need debug information in production if you do not have debug",
    "start": "1153240",
    "end": "1159320"
  },
  {
    "text": "information and I'll touch on that in a second you will get uh meaningless call Stacks you will not get function names",
    "start": "1159320",
    "end": "1166280"
  },
  {
    "text": "you will not get code uh addresses and Source information so for example on Linux you might get something like this",
    "start": "1166280",
    "end": "1173400"
  },
  {
    "text": "where the call stack is just full of question marks on Windows you might get a call stack which maybe looks a little",
    "start": "1173400",
    "end": "1180320"
  },
  {
    "text": "better but it doesn't actually have function names uh mostly right it only has U module names and offsets so this",
    "start": "1180320",
    "end": "1189480"
  },
  {
    "text": "is typically happening because you don't have debug information or symbols for your uh for your application and just to",
    "start": "1189480",
    "end": "1196840"
  },
  {
    "start": "1196000",
    "end": "1196000"
  },
  {
    "text": "briefly cover that before we move on um on Linux when you build you need to generate debug information into into",
    "start": "1196840",
    "end": "1204200"
  },
  {
    "text": "your binary this is something that happens at link time and that debug information would include function names",
    "start": "1204200",
    "end": "1210440"
  },
  {
    "text": "class names layouts of various types parameter information Source information",
    "start": "1210440",
    "end": "1215679"
  },
  {
    "text": "as well and if you don't like the fact it bloats up your binaries then you can",
    "start": "1215679",
    "end": "1221360"
  },
  {
    "text": "separate the debug information from the actual executable or from your actual Library so you can emit it into the",
    "start": "1221360",
    "end": "1228280"
  },
  {
    "text": "binary but then separate them so you have a a separate debug information file and a separate uh executable file and on",
    "start": "1228280",
    "end": "1236039"
  },
  {
    "text": "Windows it's a pretty similar story except they are always separate so in Windows when you compile with debug",
    "start": "1236039",
    "end": "1241840"
  },
  {
    "text": "information the compiler and Linker generate a separate file called pdb a pdb file which contains uh the debug",
    "start": "1241840",
    "end": "1249600"
  },
  {
    "text": "information and if you're looking for uh debug information for binaries outside of your control like your uh C++ runtime",
    "start": "1249600",
    "end": "1257720"
  },
  {
    "text": "implement mentation or your C++ library then these should probably be available",
    "start": "1257720",
    "end": "1262919"
  },
  {
    "text": "um well officially so you're not you don't really have to build these components from Source in order to get",
    "start": "1262919",
    "end": "1268840"
  },
  {
    "text": "debug information for them uh on Windows Microsoft makes available most of the",
    "start": "1268840",
    "end": "1274520"
  },
  {
    "text": "debug information for Microsoft binaries so for the stdl and the C++ runtime and",
    "start": "1274520",
    "end": "1280559"
  },
  {
    "text": "so on Microsoft has a public server a web server which will serve your",
    "start": "1280559",
    "end": "1285600"
  },
  {
    "text": "debugger the debug info files automatically Ally and on Linux it's slightly more evolved but still most",
    "start": "1285600",
    "end": "1292360"
  },
  {
    "text": "distributions would have readymade packages with debug information that you can install so for example on Ubunto you",
    "start": "1292360",
    "end": "1299559"
  },
  {
    "text": "might be able to install um a package with the dbg suffix where as on Fedora",
    "start": "1299559",
    "end": "1305240"
  },
  {
    "text": "for example there's a dedicated debug info install command which takes a package and tries to find the matching",
    "start": "1305240",
    "end": "1311640"
  },
  {
    "text": "debug information of course there's a lot of salties here in terms of finding the exact right version and so on on but",
    "start": "1311640",
    "end": "1318640"
  },
  {
    "text": "this is something that generally debuggers have learned to take care of uh for",
    "start": "1318640",
    "end": "1323799"
  },
  {
    "text": "us so this was the dump analysis story in very very short and I hope I sort of",
    "start": "1323799",
    "end": "1329799"
  },
  {
    "text": "try manage to convey the important pieces of this of of of being able to get to gather dump files when something",
    "start": "1329799",
    "end": "1336320"
  },
  {
    "text": "crashes or goes wrong in your production environment and then analyzing those crash dumps or core dumps even on the",
    "start": "1336320",
    "end": "1342679"
  },
  {
    "text": "same system the reason I'm doing this sort of summary is that from now on we're going to move to a performance and",
    "start": "1342679",
    "end": "1349039"
  },
  {
    "text": "tracing things and if you have any questions about diagnostic part we saw so far uh you could uh we could talk",
    "start": "1349039",
    "end": "1355679"
  },
  {
    "text": "about this at the end so we're going to talk about again performance and tracing now again on both operating systems and",
    "start": "1355679",
    "end": "1362880"
  },
  {
    "start": "1356000",
    "end": "1356000"
  },
  {
    "text": "there's an important concept to get out of the way first which is the concept of sampling versus tracing so essentially",
    "start": "1362880",
    "end": "1370840"
  },
  {
    "text": "uh both of these are just techniques for diagnostics for getting performance information and diagnostic information",
    "start": "1370840",
    "end": "1377080"
  },
  {
    "text": "out of the system sampling works by not looking at every",
    "start": "1377080",
    "end": "1382159"
  },
  {
    "text": "that is happening but rather grabbing samples once in a while so for example",
    "start": "1382159",
    "end": "1387480"
  },
  {
    "text": "if you wanted to follow a CPU execution of a particular application you probably couldn't record every single CPU",
    "start": "1387480",
    "end": "1394480"
  },
  {
    "text": "instruction as it is executed that would be a little too expensive so you usually use sampling for this you configure the",
    "start": "1394480",
    "end": "1401200"
  },
  {
    "text": "CPU to give you for example an interrupt every million instructions executed and",
    "start": "1401200",
    "end": "1407159"
  },
  {
    "text": "then you aggregate those samples so you don't really have a record of every single instruction you have a record",
    "start": "1407159",
    "end": "1412960"
  },
  {
    "text": "every millionth instruction but then you aggregate those samples and you have something statistically meaningful uh to",
    "start": "1412960",
    "end": "1419320"
  },
  {
    "text": "draw results from uh tracing on the other hand is recording every single",
    "start": "1419320",
    "end": "1424720"
  },
  {
    "text": "event and this is something You' typically use uh for lower frequency",
    "start": "1424720",
    "end": "1430600"
  },
  {
    "text": "things like uh disk accesses maybe uh DNS resolution requests HTTP requests",
    "start": "1430600",
    "end": "1437559"
  },
  {
    "text": "that sort of thing which is only happening like uh 10,000 times per second and not 10 billion times per",
    "start": "1437559",
    "end": "1444600"
  },
  {
    "text": "second so that's pretty much where uh sampling and tracing would fit in and at these uh request rates",
    "start": "1444600",
    "end": "1451559"
  },
  {
    "text": "essentially so on Windows uh both sampling and tracing are pretty well",
    "start": "1451559",
    "end": "1457200"
  },
  {
    "start": "1452000",
    "end": "1452000"
  },
  {
    "text": "covered by a mechanism called event tracing for Windows in the previous slot there was actually a talk uh about etw",
    "start": "1457200",
    "end": "1464520"
  },
  {
    "text": "uh with a more net perspective but it can absolutely be used for C++ on Windows as well and I'll show you some",
    "start": "1464520",
    "end": "1470440"
  },
  {
    "text": "pretty cool things that we can do with etw it is basically a logging infrastructure for the operating system",
    "start": "1470440",
    "end": "1477520"
  },
  {
    "text": "where various components across the system like uh the kernel itself the scheduler the memory manager the Heap",
    "start": "1477520",
    "end": "1484840"
  },
  {
    "text": "implementation a bunch of other components emit interesting Trace messages that we can either record into",
    "start": "1484840",
    "end": "1491919"
  },
  {
    "text": "a file or analyze in real time just get the events in real time and process them",
    "start": "1491919",
    "end": "1497799"
  },
  {
    "text": "without even saving them to disk and this allows for very low overhead uh",
    "start": "1497799",
    "end": "1503000"
  },
  {
    "text": "tracing tools to be implemented if you don't actually store the events if you just look at them in real time and then",
    "start": "1503000",
    "end": "1508679"
  },
  {
    "text": "drop them you can get very low overheads even if you have high frequencies of events like memory allocations for",
    "start": "1508679",
    "end": "1515559"
  },
  {
    "text": "example could be happening uh hundreds of thousands of times per second but you could still feasibly use etw if you are",
    "start": "1515559",
    "end": "1523080"
  },
  {
    "text": "discarding events and not actually recording the whole thing on Linux there is a similar mechanism similar in spirit",
    "start": "1523080",
    "end": "1530799"
  },
  {
    "text": "anyway uh called perf events which is built into the Linux kernel it's been",
    "start": "1530799",
    "end": "1535919"
  },
  {
    "text": "available for ages as well and it can do sampling and tracing uh again it has a",
    "start": "1535919",
    "end": "1541760"
  },
  {
    "text": "very similar architecture actually where there's various kinds of events that you can enable and they can either go into a",
    "start": "1541760",
    "end": "1548720"
  },
  {
    "text": "file for later analysis or into a shared memory buffer for realtime consumption",
    "start": "1548720",
    "end": "1554640"
  },
  {
    "text": "by some kind of application and Linux also Al has a front end for using perf",
    "start": "1554640",
    "end": "1560000"
  },
  {
    "text": "events which is just called perf and it's not built into Linux in the sense it won't always be available by default",
    "start": "1560000",
    "end": "1567080"
  },
  {
    "text": "but it is part of the Linux kernel tree so you can install it typically or even build it from Source uh for the specific",
    "start": "1567080",
    "end": "1573799"
  },
  {
    "text": "kernel that you have and it works on a variety of platforms uh Intel obviously but also arm and a bunch of other uh",
    "start": "1573799",
    "end": "1580640"
  },
  {
    "text": "less traditional uh platforms that Linux works on and before we actually look at uh",
    "start": "1580640",
    "end": "1587000"
  },
  {
    "start": "1584000",
    "end": "1584000"
  },
  {
    "text": "collecting storing and and well visualizing uh events from sampling and",
    "start": "1587000",
    "end": "1592360"
  },
  {
    "text": "tracing I do want to mention just briefly uh something a lot of C++ developers are already using but some",
    "start": "1592360",
    "end": "1598760"
  },
  {
    "text": "are not uh which is a visualization method for a lot of performance information that we'll be generating",
    "start": "1598760",
    "end": "1604840"
  },
  {
    "text": "today very very useful and important called Flame graphs it is basically a",
    "start": "1604840",
    "end": "1610039"
  },
  {
    "text": "way to visualize lots of Stack traces so for example suppose you record all the five",
    "start": "1610039",
    "end": "1617600"
  },
  {
    "text": "file accesses that your system is performing and you have a call stack of where that file access came from in your",
    "start": "1617600",
    "end": "1623760"
  },
  {
    "text": "code and then you want to see like which paths in my code are causing lots of",
    "start": "1623760",
    "end": "1628799"
  },
  {
    "text": "file accesses you might want to do the same thing with network events which paths in my code are causing lots of",
    "start": "1628799",
    "end": "1634880"
  },
  {
    "text": "network accesses or which parts in my code are using lots of CPU time so whenever you have a lot of call Stacks",
    "start": "1634880",
    "end": "1641799"
  },
  {
    "text": "and you want to visualize them quickly in a meaningful way this is where uh flame graphs come in and uh we'll I'll",
    "start": "1641799",
    "end": "1649039"
  },
  {
    "start": "1648000",
    "end": "1648000"
  },
  {
    "text": "show you an example in a moment but basically if you look at the diagram it is just an adjacency diagram where uh",
    "start": "1649039",
    "end": "1656000"
  },
  {
    "text": "there's two axis the the horizontal axis is not a timeline it is just sorted",
    "start": "1656000",
    "end": "1662320"
  },
  {
    "text": "alphabetically so it's not a timeline series it's just a sorted alphabetically uh chart the the vertical axis the Y AIS",
    "start": "1662320",
    "end": "1671360"
  },
  {
    "text": "is a call stack so if you see a function on top of another function it means it was called by that other function",
    "start": "1671360",
    "end": "1677519"
  },
  {
    "text": "function and of course I didn't say but every rectangle in the graph is a",
    "start": "1677519",
    "end": "1682600"
  },
  {
    "text": "function is a function in a CO stack that you collected and The Wider something is the more prominent it was",
    "start": "1682600",
    "end": "1690760"
  },
  {
    "text": "so width is something that's fairly easy to identify and this is why flame graphs are useful you can glance at the whole",
    "start": "1690760",
    "end": "1697440"
  },
  {
    "text": "thing immediately and you can say Okay so this thing here on the right looks interesting let's look at that but this",
    "start": "1697440",
    "end": "1705000"
  },
  {
    "text": "little flame over here right this thing it doesn't look meaningful so even",
    "start": "1705000",
    "end": "1710120"
  },
  {
    "text": "though I can't see the function name I'm probably not going to zoom into that unless I'm really desperate uh because",
    "start": "1710120",
    "end": "1715440"
  },
  {
    "text": "that's that's just a tiny proportion of time so let's see how to generate those",
    "start": "1715440",
    "end": "1721320"
  },
  {
    "text": "just one little thing before we get there uh in order to actually successfully resolve call Stacks so we",
    "start": "1721320",
    "end": "1727960"
  },
  {
    "text": "get a full picture of where the event was coming from we have to overcome uh a",
    "start": "1727960",
    "end": "1733080"
  },
  {
    "text": "pretty annoying optimization which some compilers uh do by default called frame",
    "start": "1733080",
    "end": "1738200"
  },
  {
    "text": "pointer emission uh basically frame pointer emission means that the compiler will not will not create uh a linked",
    "start": "1738200",
    "end": "1746080"
  },
  {
    "text": "list of frame pointers on the stack so you can't reconstruct the stack by just",
    "start": "1746080",
    "end": "1751279"
  },
  {
    "text": "looking at its state in a given time and that can make it hard for tools like etw",
    "start": "1751279",
    "end": "1756840"
  },
  {
    "text": "and perf and other profiling tools as well to get an accurate stack trace of",
    "start": "1756840",
    "end": "1762440"
  },
  {
    "text": "your threads now Foo does have like some performance benefit but I think it is",
    "start": "1762440",
    "end": "1769360"
  },
  {
    "text": "mostly agreed by people in the performance world that it's not worth it like the the the two or 3% performance",
    "start": "1769360",
    "end": "1776399"
  },
  {
    "text": "benefit you get from this optimization is not worth the pain in profiling and",
    "start": "1776399",
    "end": "1781480"
  },
  {
    "text": "debugging your system later so essentially it's it's an optimization worth turning off now on Linux um",
    "start": "1781480",
    "end": "1788799"
  },
  {
    "text": "there's a switch for uh most compilers called f NOA mid-frame pointer which will disable this optimization um Linux",
    "start": "1788799",
    "end": "1796600"
  },
  {
    "text": "actually in some cases if you have full debug information uh perf would sometimes be able to figure out your",
    "start": "1796600",
    "end": "1803320"
  },
  {
    "text": "call stock even if you do have fpo turned on but a lot of other tools will",
    "start": "1803320",
    "end": "1808679"
  },
  {
    "text": "not be able to cope with it so you you probably would want to turn this off anyway and on Windows uh etw basically",
    "start": "1808679",
    "end": "1816279"
  },
  {
    "text": "doesn't work if you have a binary compiled with this optimization so uh the Microsoft compilers anyway they",
    "start": "1816279",
    "end": "1822760"
  },
  {
    "text": "stopped using this optimization for quite a while I think since visuals C++ 20 three uh they realize it's just not",
    "start": "1822760",
    "end": "1829600"
  },
  {
    "text": "worth the the pain in debugging and profiling which usually results so once",
    "start": "1829600",
    "end": "1835000"
  },
  {
    "text": "we have that out of the way we can actually take a look at getting some stack traces out of a live running",
    "start": "1835000",
    "end": "1841200"
  },
  {
    "text": "system we'll start with CPU profiling but then I'll talk about off CPU time as",
    "start": "1841200",
    "end": "1846399"
  },
  {
    "text": "well so blocked threads like why is my thread blocking and waiting for something and then we'll talk about",
    "start": "1846399",
    "end": "1851960"
  },
  {
    "text": "memory leaks as well which are well the technique I'm going to use is still going to be based on colle collecting",
    "start": "1851960",
    "end": "1857600"
  },
  {
    "text": "stock traces at interesting points so let's take a look a quick look at the CPU story first uh I might skip by using",
    "start": "1857600",
    "end": "1865480"
  },
  {
    "text": "screenshots here but I do want to show you the um Target application that I'll",
    "start": "1865480",
    "end": "1871320"
  },
  {
    "text": "be using it is a very simple one on Windows called stupid notepad um it's a",
    "start": "1871320",
    "end": "1877320"
  },
  {
    "text": "notepad like uh app this is a notepad like app and I am typing uh like pretty",
    "start": "1877320",
    "end": "1883880"
  },
  {
    "text": "fast but there are some delays so there are these hiccups in the",
    "start": "1883880",
    "end": "1889880"
  },
  {
    "text": "um in the app and uh if I put it side by side with uh something simple like task",
    "start": "1889880",
    "end": "1896200"
  },
  {
    "text": "manager and uh just look at stupid notepad at the CPU usage so if you look at that uh at the same time as I'm",
    "start": "1896200",
    "end": "1903320"
  },
  {
    "text": "typing uh you would see occasional uh jumps right so it goes from zero all the",
    "start": "1903320",
    "end": "1908799"
  },
  {
    "text": "way to 20 18 something like that so there are CPU spikes and um I mean even",
    "start": "1908799",
    "end": "1915000"
  },
  {
    "text": "without using any professional tools you might be able to conclude that the CPU spikes are related to my typing activity",
    "start": "1915000",
    "end": "1921799"
  },
  {
    "text": "and when there is a spike then there is also a lag in the U actual user",
    "start": "1921799",
    "end": "1927039"
  },
  {
    "text": "interface so this is what we want to investigate and on Windows we are going to use etw for this we're going to",
    "start": "1927039",
    "end": "1934519"
  },
  {
    "text": "record events every certain number of clock Cycles we're are going to record",
    "start": "1934519",
    "end": "1940600"
  },
  {
    "text": "the call stack of what this application is doing and then we'll visualize the",
    "start": "1940600",
    "end": "1945639"
  },
  {
    "text": "whole thing so the recording if I actually did it from scratch here I would probably do with Windows",
    "start": "1945639",
    "end": "1951519"
  },
  {
    "text": "performance recorder which is a free tool based on etw which you can absolutely put in production and in its",
    "start": "1951519",
    "end": "1958960"
  },
  {
    "text": "uh in its basic mode it just has a bunch of checkboxes you can check for recording different kinds of interesting",
    "start": "1958960",
    "end": "1965240"
  },
  {
    "text": "events so you want uh to profile just CPU usage we check the CPU usage uh",
    "start": "1965240",
    "end": "1970639"
  },
  {
    "text": "checkbox and then you do a recording with this tool and you open it with a",
    "start": "1970639",
    "end": "1977039"
  },
  {
    "text": "slightly different tool called oops the windows performance analyzer so this is",
    "start": "1977039",
    "end": "1982840"
  },
  {
    "text": "uh the the the matching tool they both ship as part of the same uh library and",
    "start": "1982840",
    "end": "1988600"
  },
  {
    "text": "you can actually just copy them over it's just uh executable files you you don't really need to install anything",
    "start": "1988600",
    "end": "1994880"
  },
  {
    "text": "now once I opened my uh recording file in Windows performance analyzer it can give me an overview",
    "start": "1994880",
    "end": "2002760"
  },
  {
    "text": "first let's just switch back to the line graph it can give me an overview of CPU usage across the different processes on",
    "start": "2002760",
    "end": "2009639"
  },
  {
    "text": "my system and uh this is just a default view there's a bunch of options we could customize but you can see that uh the",
    "start": "2009639",
    "end": "2016840"
  },
  {
    "text": "stupid notepad process which is this guy over here this is this line um has",
    "start": "2016840",
    "end": "2022440"
  },
  {
    "text": "pretty obvious spikes in CPU activity and I can actually filter and just keep",
    "start": "2022440",
    "end": "2028679"
  },
  {
    "text": "that one process on my chart uh so you can see these pretty obvious spikes in activity over the recording interval so",
    "start": "2028679",
    "end": "2035440"
  },
  {
    "text": "most of the time I'm idle but then then I just have those spikes going all the way up to uh",
    "start": "2035440",
    "end": "2041039"
  },
  {
    "text": "25% of of CPU and actually it's across all cores so if I have four cores 25% is",
    "start": "2041039",
    "end": "2048240"
  },
  {
    "text": "one full core being utilized by this process now I want to figure out which",
    "start": "2048240",
    "end": "2053760"
  },
  {
    "text": "parts of the actual code are are being spent um on CPU and this is where uh the",
    "start": "2053760",
    "end": "2061919"
  },
  {
    "text": "stack view comes in so let me just see if I can yeah",
    "start": "2061919",
    "end": "2067960"
  },
  {
    "text": "so I'm going to start expanding here and one of the things I want you to see is that you can uh when you visualize a",
    "start": "2067960",
    "end": "2074280"
  },
  {
    "text": "stack tree like this textually like an actual tree which is the default for a lot of tools it can be really hard to",
    "start": "2074280",
    "end": "2081480"
  },
  {
    "text": "see what's going on you'd need to expand lots and lots of levels to figure out",
    "start": "2081480",
    "end": "2086878"
  },
  {
    "text": "which function is actually taking lots of time and if you've ever used profilers you know that most profilers",
    "start": "2086879",
    "end": "2092800"
  },
  {
    "text": "will default to this sort of view which has a tree that you have to navigate up to a 100 depth which is really hard so",
    "start": "2092800",
    "end": "2101280"
  },
  {
    "text": "let's start navigating and just to give you an idea this is a very simple application by the way but it is Windows",
    "start": "2101280",
    "end": "2107680"
  },
  {
    "text": "and there's a lot of uh stuff around so I am still expanding and none of this is",
    "start": "2107680",
    "end": "2114560"
  },
  {
    "text": "still my actual code um so I'm going to keep expanding a little more and we are",
    "start": "2114560",
    "end": "2121079"
  },
  {
    "text": "in dispatch message and uh internal call Wen procedure and okay so this is actually a",
    "start": "2121079",
    "end": "2129480"
  },
  {
    "text": "function in my application that I can tell you something about if we make it a little",
    "start": "2129480",
    "end": "2134720"
  },
  {
    "text": "bigger this is a function called onchange main edit which is in my source",
    "start": "2134720",
    "end": "2140480"
  },
  {
    "text": "code and it's probably I mean judging by the name it's probably called whenever I type something in and so it looks like",
    "start": "2140480",
    "end": "2146720"
  },
  {
    "text": "it's doing uh some CPU work now how much exactly I could go back",
    "start": "2146720",
    "end": "2154800"
  },
  {
    "text": "here and so this count column that you see is the number of Stack traces that",
    "start": "2154800",
    "end": "2161440"
  },
  {
    "text": "we grabbed which had this function on the stack so how how many samples did we",
    "start": "2161440",
    "end": "2168839"
  },
  {
    "text": "grab overall we had 800 uh",
    "start": "2168839",
    "end": "2174119"
  },
  {
    "text": "8,960 stack samples overall 5,000 something were in that function and its",
    "start": "2174119",
    "end": "2180119"
  },
  {
    "text": "descendants so this is probably one of the CPU bottlenecks in my application but I mean I did have to navigate the",
    "start": "2180119",
    "end": "2186920"
  },
  {
    "text": "tree quite a bit and um it's it's very painful for more complex apps obviously",
    "start": "2186920",
    "end": "2193480"
  },
  {
    "text": "so uh flame graphs again could be pretty useful and windows performance analyzer actually now has support for flame",
    "start": "2193480",
    "end": "2200680"
  },
  {
    "text": "graphs this is relatively new so if we switch to the flame graph view here's",
    "start": "2200680",
    "end": "2205800"
  },
  {
    "text": "what it looks like and I mean the individual rectangles are a little too",
    "start": "2205800",
    "end": "2212000"
  },
  {
    "text": "small to read so we don't really see function names unless we zoom in even even further but hopefully like the",
    "start": "2212000",
    "end": "2219000"
  },
  {
    "text": "structure of the tree is immediately visible so I don't really need to navigate through sorry I'm not going to",
    "start": "2219000",
    "end": "2225319"
  },
  {
    "text": "point at this screen I don't really have to navigate through this whole hierarchy to figure out that these are the",
    "start": "2225319",
    "end": "2232119"
  },
  {
    "text": "functions I should be looking at right so everything below I just see it has the same width and there's nothing",
    "start": "2232119",
    "end": "2238520"
  },
  {
    "text": "particularly interesting in there probably so I can immediately go to this unchange main edit function and then if",
    "start": "2238520",
    "end": "2245839"
  },
  {
    "text": "I want I could investigate its descendants like which functions are called by this guy in order to uh",
    "start": "2245839",
    "end": "2253119"
  },
  {
    "text": "consume CPU time so again this is just a visualization technique but a pretty",
    "start": "2253119",
    "end": "2258920"
  },
  {
    "text": "useful one and I hope you uh find it useful as well uh the underlying process was quite simple we recorded stack",
    "start": "2258920",
    "end": "2265599"
  },
  {
    "text": "samples and then we used Windows performance analyzer to take a look the Linux story is uh fairly simple let's",
    "start": "2265599",
    "end": "2273720"
  },
  {
    "text": "see if we uh could do this live uh so let's let try the matte exp",
    "start": "2273720",
    "end": "2280599"
  },
  {
    "text": "app so this is a a very simple uh C++ app which basically uh multiplies",
    "start": "2280760",
    "end": "2287680"
  },
  {
    "text": "matrices uh 500 times and uh it's pretty CPU intensive and I want to figure out",
    "start": "2287680",
    "end": "2293640"
  },
  {
    "text": "where so we're going to use on Linux we're going to use perf in order to investigate uh Its Behavior so I'm just",
    "start": "2293640",
    "end": "2300720"
  },
  {
    "text": "going to switch over to this root shell make it a little bigger and uh I will",
    "start": "2300720",
    "end": "2306760"
  },
  {
    "text": "run PF this is the front end for uh for the perf events mechanism which I have installed I'm going to run it in record",
    "start": "2306760",
    "end": "2313599"
  },
  {
    "text": "mode I will instruct it to capture 97 uh samples per second so this is easily",
    "start": "2313599",
    "end": "2321040"
  },
  {
    "text": "configurable I will instructed to grab call Stacks for me the G switch is for call stack for some reason well actually",
    "start": "2321040",
    "end": "2327640"
  },
  {
    "text": "it's called graph so maybe it makes sense and then finally I need to give it the actual workload to to execute or I",
    "start": "2327640",
    "end": "2335119"
  },
  {
    "text": "could attach it to an already run running process I'm going to use a um just the existing",
    "start": "2335119",
    "end": "2342560"
  },
  {
    "text": "binary okay so it's running with perf attached and uh taking 97 snapshots per",
    "start": "2342599",
    "end": "2349760"
  },
  {
    "text": "second and you can see it it basically finished and it says I wrote out",
    "start": "2349760",
    "end": "2355319"
  },
  {
    "text": "632 samples so again 97 times per second perf grabbed a call stack of what the",
    "start": "2355319",
    "end": "2362520"
  },
  {
    "text": "application was doing and at the end we have 632 of those snapshots and it's not very",
    "start": "2362520",
    "end": "2368640"
  },
  {
    "text": "big like the file we we wrote this to was not very big just uh uh 72 kiloby or",
    "start": "2368640",
    "end": "2373800"
  },
  {
    "text": "so of course if we increase the frequency or if you have multiple cores being used or if you capture for a",
    "start": "2373800",
    "end": "2381119"
  },
  {
    "text": "longer interval your files might grow uh bigger and now it's time to visualize",
    "start": "2381119",
    "end": "2387079"
  },
  {
    "text": "this so I could show you we're going to skip that I could show you the native perf interface for looking at the",
    "start": "2387079",
    "end": "2394079"
  },
  {
    "text": "recording at the recorded information it's basically this uh command line based uh UI it's curses um but we're not",
    "start": "2394079",
    "end": "2402200"
  },
  {
    "text": "going to go through that I just want to immediately generate a flame graph of this and show you the flame graph so I",
    "start": "2402200",
    "end": "2408359"
  },
  {
    "text": "have a screenshot of the flame graph which is going to be a little easier here's what the flame graph looks like",
    "start": "2408359",
    "end": "2414200"
  },
  {
    "text": "on the bottom so again instead of navigating through a lot of uh a lot of Stack frames a lot of trees I can just",
    "start": "2414200",
    "end": "2421400"
  },
  {
    "text": "immediately see that the hottest functions in this app are uh Matrix of",
    "start": "2421400",
    "end": "2427359"
  },
  {
    "text": "float operator oh this is actually unfortunate this is operator um uh",
    "start": "2427359",
    "end": "2432760"
  },
  {
    "text": "rectangular brackets but uh the flame graph generator actually stripped that",
    "start": "2432760",
    "end": "2437880"
  },
  {
    "text": "it probably thought it was just uh uh unnecessary well C++ you know so this um",
    "start": "2437880",
    "end": "2444079"
  },
  {
    "text": "this is Matrix of float operator rectangular brackets and also Matrix of float operator star uh is doing the",
    "start": "2444079",
    "end": "2451319"
  },
  {
    "text": "actual multiplication and here on the right there's also something inside vector now if this was uh If This Were a",
    "start": "2451319",
    "end": "2458280"
  },
  {
    "text": "live flame graph I could actually um navigate this View and zoom in again I",
    "start": "2458280",
    "end": "2463440"
  },
  {
    "text": "don't have a lot of time so I'm not going to zoom into this but I will have the flame graph file for you to look at",
    "start": "2463440",
    "end": "2469119"
  },
  {
    "text": "if you'd like so this is again just a very quick way uh from the command line to generate a visualization of where my",
    "start": "2469119",
    "end": "2476240"
  },
  {
    "text": "process is spending time and what's nice about perf here is that the overhead is",
    "start": "2476240",
    "end": "2481920"
  },
  {
    "text": "totally controllable so I used um 97",
    "start": "2481920",
    "end": "2486960"
  },
  {
    "text": "uh snapshots per second here if this is too much and I see it slows down my process I can bring this down I can take",
    "start": "2486960",
    "end": "2493800"
  },
  {
    "text": "10 samples per second and if I record for sufficiently long I will have a meaningful sample or on the other hand",
    "start": "2493800",
    "end": "2500440"
  },
  {
    "text": "if I don't get enough samples then I could uh increase the number of samples per second and from experience uh around",
    "start": "2500440",
    "end": "2507960"
  },
  {
    "text": "100 samples per second works pretty much okay on on typical systems unless you",
    "start": "2507960",
    "end": "2513000"
  },
  {
    "text": "have a very large number of cores and then you'd probably want to take this down a notch because it grabs a sample",
    "start": "2513000",
    "end": "2518800"
  },
  {
    "text": "of every core so it will get bigger if you have more cores so this was uh just CPU profiling",
    "start": "2518800",
    "end": "2527000"
  },
  {
    "start": "2526000",
    "end": "2526000"
  },
  {
    "text": "and I want us to be able to apply a very similar technique for memory leak analysis as well and now again if you've",
    "start": "2527000",
    "end": "2534040"
  },
  {
    "text": "been doing C++ for a while you know that there are some development time tools for this like Val grind on on Linux and",
    "start": "2534040",
    "end": "2542200"
  },
  {
    "text": "some uh code analysis tools on Windows as well these are not very uh relevant",
    "start": "2542200",
    "end": "2547720"
  },
  {
    "text": "for production use because they typically either slow down your process uh like by",
    "start": "2547720",
    "end": "2553200"
  },
  {
    "text": "500% or they require recompilation which is not something you'd probably do in",
    "start": "2553200",
    "end": "2558599"
  },
  {
    "text": "production so instead here's a general process we're going to follow uh we are",
    "start": "2558599",
    "end": "2563920"
  },
  {
    "text": "going to attach to a running process and look at every Malo and free call and of",
    "start": "2563920",
    "end": "2570240"
  },
  {
    "text": "course if you're using some custom allocator we could attach to your custom allocators allocation routine and your",
    "start": "2570240",
    "end": "2576559"
  },
  {
    "text": "custom allocators deallocation routine and then for each allocation you make",
    "start": "2576559",
    "end": "2582520"
  },
  {
    "text": "we're going to record and store the allocated address and the size and the",
    "start": "2582520",
    "end": "2587760"
  },
  {
    "text": "call stack which led to that allocation and then whenever you free memory we'll",
    "start": "2587760",
    "end": "2593319"
  },
  {
    "text": "look at the address and if it's something we know that you allocated before we're just going to discard that",
    "start": "2593319",
    "end": "2599160"
  },
  {
    "text": "allocation so at any given time we only have the outstanding allocations the one that were allocated but not free",
    "start": "2599160",
    "end": "2606720"
  },
  {
    "text": "yet by the application when we suspect that there's a memory leak we can just dump out all the outstanding allocations",
    "start": "2606720",
    "end": "2614839"
  },
  {
    "text": "and see how many bytes we have outstanding how many allocations we have outstanding and which call Stacks led to",
    "start": "2614839",
    "end": "2622119"
  },
  {
    "text": "those outstanding allocations so which call Stacks allocated the memory that wasn't freed yet now of course it will",
    "start": "2622119",
    "end": "2629760"
  },
  {
    "text": "still be up to you to determine if it's a if it's a genuine leak or just something you're going to free later",
    "start": "2629760",
    "end": "2637040"
  },
  {
    "text": "right but it will still give you the immediate insight into okay so here's something I have allocated and haven't",
    "start": "2637040",
    "end": "2642839"
  },
  {
    "text": "freed yet does that make sense now of course aggregation is very important here because if I have a million",
    "start": "2642839",
    "end": "2649160"
  },
  {
    "text": "outstanding allocations I don't want to see a million lines I want something aggregated so this call stack performed",
    "start": "2649160",
    "end": "2657480"
  },
  {
    "text": "100,000 allocations that were not freed yet now the old way of doing this on",
    "start": "2657480",
    "end": "2664040"
  },
  {
    "text": "Linux and I'm going to show the the Linux and windows ways in a moment the old way of doing this on Linux would be",
    "start": "2664040",
    "end": "2670480"
  },
  {
    "text": "by using uh perf again we could instruct perf to record maloc and free calls in",
    "start": "2670480",
    "end": "2677720"
  },
  {
    "text": "the libc library put that in a file in a perf do data file and then analyze it",
    "start": "2677720",
    "end": "2684920"
  },
  {
    "text": "using some kind of script I suppose uh to see which allocations were",
    "start": "2684920",
    "end": "2690240"
  },
  {
    "text": "outstanding now this is um slow probably and the per. data file that we generate",
    "start": "2690240",
    "end": "2696400"
  },
  {
    "text": "is probably going to be uh gigantic if we do this for even 5 minutes on a typical process it's going to be a huge",
    "start": "2696400",
    "end": "2703200"
  },
  {
    "text": "uh data file so the new way and this is something worth knowing about modern Linux systems the new way is to actually",
    "start": "2703200",
    "end": "2711200"
  },
  {
    "text": "do the whole aggregation part the stack aggregation part in the kernel when you",
    "start": "2711200",
    "end": "2717359"
  },
  {
    "text": "uh attach to the interesting events rather than dump out the whole thing to a file and then look at the file",
    "start": "2717359",
    "end": "2723559"
  },
  {
    "text": "contents later so there's a unique kernel technology on Linux there's not something like this available for",
    "start": "2723559",
    "end": "2729920"
  },
  {
    "text": "Windows unfortunately called BPF and this is uh this has been part of",
    "start": "2729920",
    "end": "2735440"
  },
  {
    "text": "Linux uh since Linux uh well the the original BPF technology actually has",
    "start": "2735440",
    "end": "2740520"
  },
  {
    "text": "been part of Linux for ages uh but using BPF for tracing is something you can do",
    "start": "2740520",
    "end": "2746720"
  },
  {
    "text": "since Linux 4.1 or so so it's it's fairly recent and it's only in fairly",
    "start": "2746720",
    "end": "2751880"
  },
  {
    "text": "recent kernels however if you do have a sufficiently recent kernel kernel you can get the next generation of tracing",
    "start": "2751880",
    "end": "2758920"
  },
  {
    "text": "tools essentially by using that kernel side aggregator rather than dumping all",
    "start": "2758920",
    "end": "2765240"
  },
  {
    "text": "the events out to a file and then analyzing the file and there's a large collection of tools called BCC which you",
    "start": "2765240",
    "end": "2772880"
  },
  {
    "text": "can find online uh I've also written some of those and there's contributors from a bunch of different companies all",
    "start": "2772880",
    "end": "2779319"
  },
  {
    "text": "open source tools which uh use the BPF technology in order to solve particular",
    "start": "2779319",
    "end": "2784680"
  },
  {
    "text": "problems which are too EXP expensive for uh standard tracers here are some of the tools uh that BCC contains and one of",
    "start": "2784680",
    "end": "2792920"
  },
  {
    "text": "them happens to be uh mem leak up top which is a tool for uh inspecting memory",
    "start": "2792920",
    "end": "2798480"
  },
  {
    "text": "leaks it basically does what I described previously it attaches to Malon free and",
    "start": "2798480",
    "end": "2804160"
  },
  {
    "text": "then it dumps out a record of outstanding allocations but it doesn't dump every single event to a file and",
    "start": "2804160",
    "end": "2811839"
  },
  {
    "text": "postprocess it later it does the aggregation on the Kernel side of things things so the only thing that's actually",
    "start": "2811839",
    "end": "2817800"
  },
  {
    "text": "stored in memory is this call stack made 100 allocations you don't even store the",
    "start": "2817800",
    "end": "2824319"
  },
  {
    "text": "same call stock 100 times you do the aggregation right when you collect uh the event so the overhead is much much",
    "start": "2824319",
    "end": "2831559"
  },
  {
    "text": "lower in Practical terms what does it look like so uh I'm going to switch to screenshots here because we don't have a",
    "start": "2831559",
    "end": "2838040"
  },
  {
    "text": "lot of time on the Windows side of things and I'm going to start in the same order on the Windows side of things",
    "start": "2838040",
    "end": "2845280"
  },
  {
    "text": "if you have a a memory leak like this we're going to use exactly the strategy I just described we're going to attach",
    "start": "2845280",
    "end": "2851720"
  },
  {
    "text": "to Malon free and we're going to inspect uh the differences the outstanding",
    "start": "2851720",
    "end": "2857079"
  },
  {
    "text": "allocations and the way we actually attach to Malon free is going to be using etw events this is a full listing",
    "start": "2857079",
    "end": "2865359"
  },
  {
    "text": "of all the commands you would need to run for this in order to attach uh etw tracing to Heap allocations and freeze",
    "start": "2865359",
    "end": "2873040"
  },
  {
    "text": "and get a file that has a record of every allocation and free that your process has made but again it's going to",
    "start": "2873040",
    "end": "2880000"
  },
  {
    "text": "be a file so it's going to be a pretty massive file and you would need to analyze that file later because Windows",
    "start": "2880000",
    "end": "2886920"
  },
  {
    "text": "doesn't have BPF or anything like it so this is actually the only way to get uh",
    "start": "2886920",
    "end": "2892240"
  },
  {
    "text": "this sort of thing and then you would analyze that recording in Windows",
    "start": "2892240",
    "end": "2897720"
  },
  {
    "text": "performance analyzer or some other etw tool and again just skipping to the uh",
    "start": "2897720",
    "end": "2903440"
  },
  {
    "text": "to the Crux of it you would be able to get a stack Trace which allocates memory that wasn't",
    "start": "2903440",
    "end": "2910960"
  },
  {
    "text": "freed so this is all outstanding allocations and You' be able to see the",
    "start": "2910960",
    "end": "2916079"
  },
  {
    "text": "number of the allocations made by that call stack and their total impacting",
    "start": "2916079",
    "end": "2921160"
  },
  {
    "text": "size so the total size of those allocations in bytes so this is a call stack inside my application which has",
    "start": "2921160",
    "end": "2928119"
  },
  {
    "text": "allocated 8 megabytes of memory which hasn't been freed yet so this is what we get from this uh uh output and again",
    "start": "2928119",
    "end": "2935799"
  },
  {
    "text": "it's it's actually pretty simple like the whole process you can write a batch file which would do this for you but it",
    "start": "2935799",
    "end": "2941400"
  },
  {
    "text": "does rely on generating a huge file if you run this on a production system for",
    "start": "2941400",
    "end": "2948119"
  },
  {
    "text": "10 minutes you could get uh like several gigabytes worth of allocation and free",
    "start": "2948119",
    "end": "2953920"
  },
  {
    "text": "uh data the Linux side is slightly easier so I'm just going to skip over to the actual",
    "start": "2953920",
    "end": "2960559"
  },
  {
    "text": "tool this is output from the M leak tool from",
    "start": "2960559",
    "end": "2966119"
  },
  {
    "text": "BCC and it basically dumps out stock traces and how many outstanding",
    "start": "2966119",
    "end": "2972200"
  },
  {
    "text": "allocations these stock traces have so it's basically the same information except in text format and it can be",
    "start": "2972200",
    "end": "2978760"
  },
  {
    "text": "parsed and displayed as a flame graph if you prefer so again it's just stack traces so it might actually make sense",
    "start": "2978760",
    "end": "2986000"
  },
  {
    "text": "to display them as a flame graph and so as usual there's this uh huge C++ stack",
    "start": "2986000",
    "end": "2992040"
  },
  {
    "text": "here so it's a little hard to read but it does say at the beginning I have um",
    "start": "2992040",
    "end": "2997400"
  },
  {
    "text": "95 outstanding allocations which are responsible for slightly under a",
    "start": "2997400",
    "end": "3002640"
  },
  {
    "text": "megabyte of memory which all came from this call stack so this call stack has made 95 allocations which have not been",
    "start": "3002640",
    "end": "3010559"
  },
  {
    "text": "reclaimed which have not been freed and you can go ahead and analyze and if and see if that makes sense um that your app",
    "start": "3010559",
    "end": "3017799"
  },
  {
    "text": "should not have freed that memory yet so I'm going to cover very briefly",
    "start": "3017799",
    "end": "3023200"
  },
  {
    "start": "3021000",
    "end": "3021000"
  },
  {
    "text": "just to leave a minute or two for questions as well uh I'm going to cover very briefly two additional scenarios",
    "start": "3023200",
    "end": "3029000"
  },
  {
    "text": "which tracing tools can cover in a very similar way so there's not going to be something super Innovative here but just",
    "start": "3029000",
    "end": "3035119"
  },
  {
    "text": "to let you know that these scenarios can also be covered on both operating systems using pretty much the same tools",
    "start": "3035119",
    "end": "3041200"
  },
  {
    "text": "we already learned about so one of those is blocked time a lot of applications",
    "start": "3041200",
    "end": "3046720"
  },
  {
    "text": "don't actually have lots of CPU usage or not exclusively about CPU usage they actually have a lot of blocking as well",
    "start": "3046720",
    "end": "3053599"
  },
  {
    "text": "so waiting for something waiting waiting for a synchronization mechanism waiting for network waiting for a database",
    "start": "3053599",
    "end": "3059480"
  },
  {
    "text": "waiting for a file these are waiting things that are applications would typically do now to trace that time to",
    "start": "3059480",
    "end": "3067599"
  },
  {
    "text": "actually account for that time where processes are uh sleeping essentially waiting for something we can use context",
    "start": "3067599",
    "end": "3074799"
  },
  {
    "text": "switch events from the operating system so both on Windows and on Linux we can",
    "start": "3074799",
    "end": "3080119"
  },
  {
    "text": "ask the respective tracing tools to get us a record of every context switch so",
    "start": "3080119",
    "end": "3085559"
  },
  {
    "text": "whenever a thread switches from running to waiting and then back from waiting to running we can trace where this is",
    "start": "3085559",
    "end": "3093000"
  },
  {
    "text": "happening when this is happening for how long this is happening and then give you a picture of okay so this function here",
    "start": "3093000",
    "end": "3100440"
  },
  {
    "text": "I spent 5 Seconds waiting for a lock while in that function so it's",
    "start": "3100440",
    "end": "3105720"
  },
  {
    "text": "essentially just a matter of correlating the context switch events which of course sounds easier than it is but",
    "start": "3105720",
    "end": "3111760"
  },
  {
    "text": "someone has already done this job but basically we just need from the the context switch information in order to",
    "start": "3111760",
    "end": "3118160"
  },
  {
    "text": "do that now the only reason I'm even mentioning this is that context switches",
    "start": "3118160",
    "end": "3123960"
  },
  {
    "text": "are a pretty common thing so you could have a million context switches per second like easily on a typical loaded",
    "start": "3123960",
    "end": "3131319"
  },
  {
    "text": "system and recording every single contact switch to a file again is going",
    "start": "3131319",
    "end": "3136680"
  },
  {
    "text": "to be pretty prohibitive so on Linux we have BPF which can do this analysis",
    "start": "3136680",
    "end": "3142240"
  },
  {
    "text": "without actually storing stuff to disk on window windows we could potentially",
    "start": "3142240",
    "end": "3147400"
  },
  {
    "text": "process some of this information in real time but in practice most tools will record this to a file and then analyze",
    "start": "3147400",
    "end": "3154559"
  },
  {
    "text": "the file so this is slightly uh less efficient on Windows actually not slightly this is less efficient on",
    "start": "3154559",
    "end": "3160400"
  },
  {
    "text": "Windows um so what can this look like I'm just going to skip straight to the actual",
    "start": "3160400",
    "end": "3166319"
  },
  {
    "text": "screenshots uh or even I have this open on my windows box so this is what it can look like on",
    "start": "3166319",
    "end": "3173119"
  },
  {
    "text": "Windows by aggregating all the context switch events I could get a timeline",
    "start": "3173119",
    "end": "3178319"
  },
  {
    "text": "view of each of the threads in my process and see exactly what it was doing and when so for example here if I",
    "start": "3178319",
    "end": "3186319"
  },
  {
    "text": "focus on my main thread in my application I can see on a timeline from",
    "start": "3186319",
    "end": "3191520"
  },
  {
    "text": "0 to 20 seconds exactly by colors and times what that thread was doing so",
    "start": "3191520",
    "end": "3197480"
  },
  {
    "text": "green here is execution this is synchronization I also have some sleeping going on so I can see exactly",
    "start": "3197480",
    "end": "3204839"
  },
  {
    "text": "what my thread is doing in terms of waiting and running and if I click any",
    "start": "3204839",
    "end": "3210119"
  },
  {
    "text": "of those like I did here I actually get a stack Trace so what the tread was doing if it was blocked where was it",
    "start": "3210119",
    "end": "3217480"
  },
  {
    "text": "blocked if it was running what was it running again this is all available just by virtue of looking at the context",
    "start": "3217480",
    "end": "3223920"
  },
  {
    "text": "switch events from running to waiting and from waiting back to running but again the underlying data can be pretty",
    "start": "3223920",
    "end": "3230880"
  },
  {
    "text": "massive because every context switch would have to be traced on the Linux",
    "start": "3230880",
    "end": "3235960"
  },
  {
    "text": "side of things uh on the Linux side of things we could use uh BCC tools based",
    "start": "3235960",
    "end": "3243040"
  },
  {
    "text": "on the BPF kernel technology to get a flame graph of where my threads in my",
    "start": "3243040",
    "end": "3248440"
  },
  {
    "text": "applications are actually uh sleeping waiting blocking for something without",
    "start": "3248440",
    "end": "3254040"
  },
  {
    "text": "having to generate a uh a file that has an event for every single context switch",
    "start": "3254040",
    "end": "3260079"
  },
  {
    "text": "so basically what I used here is a tool called off CPU time which is from from",
    "start": "3260079",
    "end": "3265319"
  },
  {
    "text": "the BCC collection on GitHub and it generates a recording but the recording",
    "start": "3265319",
    "end": "3270720"
  },
  {
    "text": "only contains the aggregated results so I don't have like every single context switch in there I only have the",
    "start": "3270720",
    "end": "3277240"
  },
  {
    "text": "aggregated record saying this call stack had 500,000 context switches which took that",
    "start": "3277240",
    "end": "3284440"
  },
  {
    "text": "much time so I don't aggregate every single uh context switch making this a",
    "start": "3284440",
    "end": "3289680"
  },
  {
    "text": "tool that you could actually run uh in production so that's uh that's for context switches and the last thing I",
    "start": "3289680",
    "end": "3297000"
  },
  {
    "text": "want to briefly mention is tracing file and disk and network IO which is very",
    "start": "3297000",
    "end": "3302359"
  },
  {
    "text": "important and so you might be asking like why am I leaving this for the last 4 and a half minutes of the presentation",
    "start": "3302359",
    "end": "3308040"
  },
  {
    "text": "but the reason is basically that it's it's more of the same we have basically seen the underlying technology for",
    "start": "3308040",
    "end": "3314880"
  },
  {
    "text": "tracing different kinds of events so here is just a matter of picking the right events to trace so on Windows for",
    "start": "3314880",
    "end": "3321760"
  },
  {
    "text": "example etw can trace file accesses and disk accesses and network send and",
    "start": "3321760",
    "end": "3327799"
  },
  {
    "text": "receive events and on Linux similar Trace points are available in the kernal",
    "start": "3327799",
    "end": "3333480"
  },
  {
    "text": "for Block uh IO access for network access so essentially it's just a matter of using the same tools etw on Linux on",
    "start": "3333480",
    "end": "3342319"
  },
  {
    "text": "Windows uh perf and BCC on Linux to just get an aggregation of file accesses and",
    "start": "3342319",
    "end": "3350520"
  },
  {
    "text": "uh Network accesses and disk accesses and that sort of thing just a few screenshot shots of what's possible to",
    "start": "3350520",
    "end": "3357000"
  },
  {
    "text": "get your appetite up um for example on the left you see a Linux tool which",
    "start": "3357000",
    "end": "3362480"
  },
  {
    "text": "gives you a record of which files are currently the hottest across the systems like which files am I accessing the most",
    "start": "3362480",
    "end": "3369559"
  },
  {
    "text": "for reads and for writes kind of like top but for files for file accesses on",
    "start": "3369559",
    "end": "3375039"
  },
  {
    "text": "the right you see a similar thing from Windows when looking at a recording in",
    "start": "3375039",
    "end": "3380119"
  },
  {
    "text": "Windows performance analyzer you can see a summary of which files are being heavily accessed on this particular",
    "start": "3380119",
    "end": "3386920"
  },
  {
    "text": "system the only difference is Linux is live Windows is uh analyzing a recording",
    "start": "3386920",
    "end": "3393039"
  },
  {
    "text": "a recording file that's the only difference between those tracing file accesses in real time is also possible",
    "start": "3393039",
    "end": "3399319"
  },
  {
    "start": "3395000",
    "end": "3395000"
  },
  {
    "text": "so on the left on Linux you see a tool which prints out every file access taking longer than a certain time so",
    "start": "3399319",
    "end": "3407240"
  },
  {
    "text": "slow file accesses print them please and on the left there's a Windows command",
    "start": "3407240",
    "end": "3412359"
  },
  {
    "text": "line tool uh which I wrote called erce which does uh pretty much the same thing you can instruct it to look at etw",
    "start": "3412359",
    "end": "3419200"
  },
  {
    "text": "events and print out events matching a certain filter so again there's some screenshots",
    "start": "3419200",
    "end": "3425240"
  },
  {
    "text": "here of what this whole thing would look like just a couple of final notes to see here which might be interesting for you",
    "start": "3425240",
    "end": "3431520"
  },
  {
    "text": "this is pretty cool if you have mechanical drives like non SSD uh this is basically a summary of Where the dis",
    "start": "3431520",
    "end": "3438720"
  },
  {
    "text": "head is on your drive um so again on ssds it is slightly less interesting",
    "start": "3438720",
    "end": "3444920"
  },
  {
    "text": "thing but on mechanical discs it's pretty important uh occasionally to optimize and defragment the drive so",
    "start": "3444920",
    "end": "3451200"
  },
  {
    "text": "that you have uh adjacent accesses happening at the same offset on dis roughly so you don't have a lot of",
    "start": "3451200",
    "end": "3457119"
  },
  {
    "text": "travel a lot of uh uh seeks essentially and this is a diagram that can show you",
    "start": "3457119",
    "end": "3462559"
  },
  {
    "text": "those um this is a Linux screenshot of a tool called open Snoop which is pretty",
    "start": "3462559",
    "end": "3469880"
  },
  {
    "text": "cool and it traces uh failures to open files so whenever you have a process",
    "start": "3469880",
    "end": "3475520"
  },
  {
    "text": "that tries to open and file and fails it would print which file it was and what the error was so just again some of the",
    "start": "3475520",
    "end": "3482839"
  },
  {
    "text": "things that are possible by uh instrumenting those same uh underlying mechanisms perf on uh Linux and uh etw",
    "start": "3482839",
    "end": "3491760"
  },
  {
    "text": "on windows so hopefully we've seen this Whirlwind tour of uh uh Diagnostics and",
    "start": "3491760",
    "end": "3498440"
  },
  {
    "text": "performance investigations on both operating systems uh we we looked at crash dump analysis and how to get dumps",
    "start": "3498440",
    "end": "3505440"
  },
  {
    "text": "of uh crashing processes on both os's and how to get uh basic details like a",
    "start": "3505440",
    "end": "3510760"
  },
  {
    "text": "stack trace and exception information out of them we talked about some of the performance tracing tools that can be",
    "start": "3510760",
    "end": "3517039"
  },
  {
    "text": "used for production with uh C++ applications we saw how to generate flame graphs of various things not just",
    "start": "3517039",
    "end": "3524119"
  },
  {
    "text": "CPU use which is the most typical use but also for um like blocked time for",
    "start": "3524119",
    "end": "3529880"
  },
  {
    "text": "example or for dis accesses and that sort of thing and we looked at memory Le analysis which is pretty tricky",
    "start": "3529880",
    "end": "3536240"
  },
  {
    "text": "especially in production but you see there are some options available for this uh as well there are some",
    "start": "3536240",
    "end": "3542240"
  },
  {
    "text": "references in the slides uh touching on the different tools we looked at today there's lots and lots to learn of course",
    "start": "3542240",
    "end": "3548200"
  },
  {
    "text": "Beyond this presentation and here are the uh slides and all the demos I've used uh some of these are actually in",
    "start": "3548200",
    "end": "3555000"
  },
  {
    "text": "lab format so if you would like to spend a few hours practicing some of these tools you can look at those two GitHub",
    "start": "3555000",
    "end": "3561440"
  },
  {
    "text": "repos which have labs for both Linux and windows you can try in your own environment and just learn more um about",
    "start": "3561440",
    "end": "3568400"
  },
  {
    "text": "some of those scenarios I used but all of these are covered all my demos are covered by these two uh repositories now",
    "start": "3568400",
    "end": "3575280"
  },
  {
    "text": "we have 22 seconds for questions which is going to be a little tricky and also I have uh in 20 minutes a talk in",
    "start": "3575280",
    "end": "3580880"
  },
  {
    "text": "another room so if anyone wants to chat we could do that during lunch or you could walk with me there uh but this is",
    "start": "3580880",
    "end": "3587720"
  },
  {
    "text": "as much as I can offer because I do have a talk uh in 20 minutes uh anyway thank you very very much for coming and I hope",
    "start": "3587720",
    "end": "3594319"
  },
  {
    "text": "you enjoy the rest of NDC please be in touch thank",
    "start": "3594319",
    "end": "3599200"
  },
  {
    "text": "you",
    "start": "3600760",
    "end": "3603760"
  }
]