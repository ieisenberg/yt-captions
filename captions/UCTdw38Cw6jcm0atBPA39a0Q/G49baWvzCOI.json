[
  {
    "text": "okay so hi everybody again starting again first of thank you for coming I know it's late",
    "start": "7320",
    "end": "12990"
  },
  {
    "text": "and well on the upside I can keep you here as long as I want just kidding so I",
    "start": "12990",
    "end": "20700"
  },
  {
    "text": "work at riverbed we do application performance monitoring and I'm going to talk to you today about how you can",
    "start": "20700",
    "end": "27390"
  },
  {
    "text": "optimize the memory traffic of your dotnet applications so first I'm going",
    "start": "27390",
    "end": "33450"
  },
  {
    "text": "to give you some motivation I'm going to show you some real life questions and",
    "start": "33450",
    "end": "38579"
  },
  {
    "text": "problems that people encounters that have to do with memory traffic I'm going to show you several ways with which you",
    "start": "38579",
    "end": "47010"
  },
  {
    "text": "can identify that you have a memory problem in your application because",
    "start": "47010",
    "end": "53490"
  },
  {
    "text": "obviously you can't start optimizing before you know where the bottleneck is then we're going to see a few examples",
    "start": "53490",
    "end": "61130"
  },
  {
    "text": "actual live demos of code patterns parents specific coding patterns that",
    "start": "61130",
    "end": "67920"
  },
  {
    "text": "can lead to problematic and excessive memory allocations and finally we're",
    "start": "67920",
    "end": "73799"
  },
  {
    "text": "going to finish with some general recommendations about how you can lower",
    "start": "73799",
    "end": "79350"
  },
  {
    "text": "your memory allocation and thus time spent in GC even further so memory",
    "start": "79350",
    "end": "88259"
  },
  {
    "text": "allocation is easy right it's cheap you just have to move your heat pointer you",
    "start": "88259",
    "end": "94560"
  },
  {
    "text": "know one simple one simple command it's not free though and it adds up and it",
    "start": "94560",
    "end": "101789"
  },
  {
    "text": "has side effects on top of adding up or rather one major side effects and that",
    "start": "101789",
    "end": "107600"
  },
  {
    "text": "GC because the more memory you have the more GC you need to do and it takes time",
    "start": "107600",
    "end": "114060"
  },
  {
    "text": "GC has to actually stop your application from running in order to do that memory",
    "start": "114060",
    "end": "119999"
  },
  {
    "text": "clamping that it does and so the more memory you use the more GC you need to",
    "start": "119999",
    "end": "125189"
  },
  {
    "text": "do and the GC itself takes more time and you know things kind of get out of hand",
    "start": "125189",
    "end": "130590"
  },
  {
    "text": "big performance problem and the thing is that at least from my experience usually",
    "start": "130590",
    "end": "136770"
  },
  {
    "text": "we spend most of the time when we plan our work think about thinking about optimizing algorithms",
    "start": "136770",
    "end": "143620"
  },
  {
    "text": "and mainly our CPU usage and it's not until we encounter a really severe",
    "start": "143620",
    "end": "149799"
  },
  {
    "text": "problem that comes from excessive memory allocation that we suddenly remember oh",
    "start": "149799",
    "end": "155019"
  },
  {
    "text": "that's right I should have made that better I should have optimized that thing and",
    "start": "155019",
    "end": "161290"
  },
  {
    "text": "that's what we're here to talk about so I'm just going to give you a few",
    "start": "161290",
    "end": "166420"
  },
  {
    "text": "examples that I found online there are really a lot of questions Stack Overflow that has to do with that have to do with",
    "start": "166420",
    "end": "173079"
  },
  {
    "text": "memory allocation and GC so here's the first example here there's a guy who's",
    "start": "173079",
    "end": "178629"
  },
  {
    "text": "using unity to write a game he had some very severe performance problems in his",
    "start": "178629",
    "end": "186670"
  },
  {
    "text": "update function update is what you do when you need to update your frame and",
    "start": "186670",
    "end": "191859"
  },
  {
    "text": "it has to be really efficient if you want the game to run smoothly and you actually ran a profiler and he found",
    "start": "191859",
    "end": "198730"
  },
  {
    "text": "that 33% of the time in the update",
    "start": "198730",
    "end": "203859"
  },
  {
    "text": "function is GC collects now 33% that a third of the time that's a lot it's not",
    "start": "203859",
    "end": "211419"
  },
  {
    "text": "normal it's a huge degradation in performance something you shouldn't Lee don't want to have inside your update",
    "start": "211419",
    "end": "218650"
  },
  {
    "text": "function another example someone is asking why or his code is causing so",
    "start": "218650",
    "end": "227709"
  },
  {
    "text": "much GC he doesn't know why he wrote the code sample it doesn't matter in this",
    "start": "227709",
    "end": "232900"
  },
  {
    "text": "moment my point is that he wants to know why it happens it wants to understand his code or another example someone",
    "start": "232900",
    "end": "239980"
  },
  {
    "text": "wants to detect what or who or why someone is calling GC collect he was",
    "start": "239980",
    "end": "247660"
  },
  {
    "text": "using a third-party library and he had a performance issue and he had an idea",
    "start": "247660",
    "end": "253090"
  },
  {
    "text": "that maybe that third-party library was calling GC collection side and he wanted to know how he could check that so the",
    "start": "253090",
    "end": "262690"
  },
  {
    "text": "first thing that we're going to do today is talk about identification of the problem",
    "start": "262690",
    "end": "268960"
  },
  {
    "text": "I do hope that by the end of the talk you're going to know enough about how dotnet works with regards to memory",
    "start": "268960",
    "end": "276280"
  },
  {
    "text": "allocation garbage collection and you will be able to understand how the code that you",
    "start": "276280",
    "end": "281340"
  },
  {
    "text": "write effect affects memory traffic and so you will be able to answer these",
    "start": "281340",
    "end": "287250"
  },
  {
    "text": "questions and more so again let's start with identification because without",
    "start": "287250",
    "end": "292590"
  },
  {
    "text": "identifying the problem we can't start optimizing the easiest way I think to",
    "start": "292590",
    "end": "299100"
  },
  {
    "text": "detect that you have a garbage collection problem is using performance counters performance counters are",
    "start": "299100",
    "end": "305850"
  },
  {
    "text": "available system-wide in Windows they're built in there kind of like these data",
    "start": "305850",
    "end": "311520"
  },
  {
    "text": "emitters which are embedded in different locations in your system and they can",
    "start": "311520",
    "end": "316920"
  },
  {
    "text": "provide performance information numerical information about the",
    "start": "316920",
    "end": "322680"
  },
  {
    "text": "different areas where they were it sits so you can get information about the CPU",
    "start": "322680",
    "end": "327930"
  },
  {
    "text": "usage and about memory allocations and disk usage and networking and of course",
    "start": "327930",
    "end": "333630"
  },
  {
    "text": "dot map and the nice thing about it is that it's available on demand you don't",
    "start": "333630",
    "end": "338640"
  },
  {
    "text": "have to relaunch recompile get sure that your application you just need to use",
    "start": "338640",
    "end": "343710"
  },
  {
    "text": "the right tool to kind of hook inside and see these performance counters in",
    "start": "343710",
    "end": "348900"
  },
  {
    "text": "action so for example two available tools for you which come built-in inside Windows R type curve which is a",
    "start": "348900",
    "end": "355500"
  },
  {
    "text": "command-line tool which allows you to monitor any performance count where you",
    "start": "355500",
    "end": "360810"
  },
  {
    "text": "want in real time or perfmon which has a nice graphical UI which allows you to do",
    "start": "360810",
    "end": "367170"
  },
  {
    "text": "the same thing as a side note I will mention that you can also create your own performance counters and omit",
    "start": "367170",
    "end": "374330"
  },
  {
    "text": "performance information about your own applications so that's maybe the DevOps",
    "start": "374330",
    "end": "380490"
  },
  {
    "text": "people or you know someone else can monitor easily your application and production but that's not the topic of",
    "start": "380490",
    "end": "386940"
  },
  {
    "text": "our talk so first let's see how we can use person one to realize that we have a",
    "start": "386940",
    "end": "394020"
  },
  {
    "text": "problem I have a virtual machine here with Windows and I have and I have",
    "start": "394020",
    "end": "406360"
  },
  {
    "text": "an application ready for us it's called the Jack compiler by the name you can",
    "start": "406360",
    "end": "412150"
  },
  {
    "text": "understand that it compiles something it's actually an exercise I did for university quite a few years ago it's a",
    "start": "412150",
    "end": "420639"
  },
  {
    "text": "made-up language we used to learn how in compilers work so we implemented the",
    "start": "420639",
    "end": "425889"
  },
  {
    "text": "compiler and we are going to run this compiler on some big problem excuse me",
    "start": "425889",
    "end": "434379"
  },
  {
    "text": "on some big program ok I'm starting it",
    "start": "434379",
    "end": "439569"
  },
  {
    "text": "run now I want to monitor what my application does so I'm going to run",
    "start": "439569",
    "end": "445449"
  },
  {
    "text": "perfmon nice graphical UI I go to the",
    "start": "445449",
    "end": "451659"
  },
  {
    "text": "performance line tour area and it comes ready with displaying the CPU time in",
    "start": "451659",
    "end": "458199"
  },
  {
    "text": "our machine I'm not interested in that right now so I will just remove that do it and I will add the performance",
    "start": "458199",
    "end": "465370"
  },
  {
    "text": "counters that I am interested in which in this case have to do with memory consumption so I'm clicking the plus",
    "start": "465370",
    "end": "472449"
  },
  {
    "text": "here and I can see a very long list of groups of performance counters they",
    "start": "472449",
    "end": "480639"
  },
  {
    "text": "actually grouped into groups by area by by the system that they put a monitor so",
    "start": "480639",
    "end": "487240"
  },
  {
    "text": "you have energy meter sack service file system something HTTP obviously we won't",
    "start": "487240",
    "end": "494560"
  },
  {
    "text": "go over all of them because there's a lot of them so I'll just skip right ahead to the dotnet CLR memory where is",
    "start": "494560",
    "end": "503589"
  },
  {
    "text": "it here this to the dogmas CLR memory group I'll expand it and I can see the",
    "start": "503589",
    "end": "510009"
  },
  {
    "text": "actual performance for our counters so for X for example I'll obviously be interested in the bytes and all heaps",
    "start": "510009",
    "end": "516130"
  },
  {
    "text": "that's the entire managed memory that our application uses and I can either monitor it for the entire system or it",
    "start": "516130",
    "end": "523479"
  },
  {
    "text": "can select a specific process in our case where is it",
    "start": "523479",
    "end": "530310"
  },
  {
    "text": "it doesn't run I thought started starting ok now it's running I apologize",
    "start": "531209",
    "end": "538939"
  },
  {
    "text": "try again ok I think I need to close that and so plus dotnet dotnet memory by",
    "start": "538939",
    "end": "554639"
  },
  {
    "text": "it's an all heap and okay here it is thank you I will add it to my list you",
    "start": "554639",
    "end": "560939"
  },
  {
    "text": "can see that we can get the information about the number of GC handles the number of GM 0 collections the number of",
    "start": "560939",
    "end": "570029"
  },
  {
    "text": "induced GC which might be interesting the number of pins objects and so on",
    "start": "570029",
    "end": "576179"
  },
  {
    "text": "I will obviously select the percentage of time in GC that's a very important metric for me and I also want to see",
    "start": "576179",
    "end": "582720"
  },
  {
    "text": "let's say be allocated by its per second and I will start that and immediately I",
    "start": "582720",
    "end": "588600"
  },
  {
    "text": "can see a real time graph monitoring these values now in order to see all of",
    "start": "588600",
    "end": "594839"
  },
  {
    "text": "them on the same plot I will have to scale them ok and here they are now the",
    "start": "594839",
    "end": "601619"
  },
  {
    "text": "most important one in this case is this blue line which symbolizes the amount of",
    "start": "601619",
    "end": "607649"
  },
  {
    "text": "time the percentage of time spent in GC and straight away we can see it's a",
    "start": "607649",
    "end": "613230"
  },
  {
    "text": "problem it's actually the scale here for this graph is 1 and so we can see that on average our program spends about I",
    "start": "613230",
    "end": "620279"
  },
  {
    "text": "know let's say 60% of time in GC that's totally not normal so I now know for",
    "start": "620279",
    "end": "626699"
  },
  {
    "text": "sure that I have a problem with GC do I have a memory leak probably not the red",
    "start": "626699",
    "end": "633179"
  },
  {
    "text": "graph here that's the bytes and all heaps that's all of my managed memory it might be",
    "start": "633179",
    "end": "638639"
  },
  {
    "text": "high it's scaled it doesn't look higher at scale so it's high but it's constant",
    "start": "638639",
    "end": "644339"
  },
  {
    "text": "it doesn't change however still we do enough locations in such a way the GC is",
    "start": "644339",
    "end": "650549"
  },
  {
    "text": "very stressed ok so now we know we have a problem we",
    "start": "650549",
    "end": "657629"
  },
  {
    "text": "don't know where it is though we don't know what caused this excessive GC so",
    "start": "657629",
    "end": "664800"
  },
  {
    "text": "we no need to figure out what's going on in our program luckily for us there's another tracing mechanism built in",
    "start": "664800",
    "end": "671130"
  },
  {
    "text": "inside windows and that's etw event tracing for windows in a sense it's very",
    "start": "671130",
    "end": "676800"
  },
  {
    "text": "similar to performance counters in the sense that it proved it's all over the",
    "start": "676800",
    "end": "683370"
  },
  {
    "text": "system it can provide information from both user mode and kernel mode from drivers from services from dotnet from",
    "start": "683370",
    "end": "691410"
  },
  {
    "text": "the file system networking whatever you want it's even inside third-party components like Chrome it can also be",
    "start": "691410",
    "end": "698579"
  },
  {
    "text": "turned on on demand just by starting to write to and analyzing that you don't",
    "start": "698579",
    "end": "705390"
  },
  {
    "text": "have to relaunch or recompile your application but the big difference compared to performance counters is that",
    "start": "705390",
    "end": "712440"
  },
  {
    "text": "this is not limited to numerical data egw is actually a logging framework a",
    "start": "712440",
    "end": "719180"
  },
  {
    "text": "structured logging framework which can provide any data at once",
    "start": "719180",
    "end": "725490"
  },
  {
    "text": "basically I support hundreds of thousands of structures log messages per",
    "start": "725490",
    "end": "730680"
  },
  {
    "text": "second and it has very low overhead of course depending on the amount of data that you want to emit now again as a",
    "start": "730680",
    "end": "737700"
  },
  {
    "text": "side note I mentioned that you can write your own etw provider and you can omit your own into W messages and again",
    "start": "737700",
    "end": "744839"
  },
  {
    "text": "that's not the topic of our talk though it's worth mentioning that so let's see",
    "start": "744839",
    "end": "750570"
  },
  {
    "text": "what other data we can get using etw this time I'm going to use a different",
    "start": "750570",
    "end": "756870"
  },
  {
    "text": "tool called perfu it's not built-in inside windows but it is freely",
    "start": "756870",
    "end": "763140"
  },
  {
    "text": "available from the Microsoft web site and in fact this recently became open source so you can you know totally use",
    "start": "763140",
    "end": "769980"
  },
  {
    "text": "it enhance it whatever you want and and this is although not very visually",
    "start": "769980",
    "end": "776790"
  },
  {
    "text": "appealing a very good functional UI for both collecting and later analyzing",
    "start": "776790",
    "end": "784410"
  },
  {
    "text": "these etw logs so if I start my",
    "start": "784410",
    "end": "789600"
  },
  {
    "text": "application again and I want to record what's going on the",
    "start": "789600",
    "end": "796660"
  },
  {
    "text": "system I can go to the collect menu here this requires administrative rights so I",
    "start": "796660",
    "end": "803860"
  },
  {
    "text": "will have to restart it as again and again not very visually appealing but",
    "start": "803860",
    "end": "810939"
  },
  {
    "text": "functional there are a few options here which we can configure I'm not going to",
    "start": "810939",
    "end": "816429"
  },
  {
    "text": "go into much detail because that's not the focus of our talk but you can see that you can select different areas of",
    "start": "816429",
    "end": "822790"
  },
  {
    "text": "the system that you want to monitor CPU sampling dotnet dotnet allocations",
    "start": "822790",
    "end": "829920"
  },
  {
    "text": "inlining file i/o all sorts of stuff like that now I'm not going to collect",
    "start": "829920",
    "end": "836110"
  },
  {
    "text": "now because I don't want to waste time on running the application and collecting the data but generally you",
    "start": "836110",
    "end": "841959"
  },
  {
    "text": "just do starts collecting wait a while I don't know 10 seconds whatever and stop",
    "start": "841959",
    "end": "848470"
  },
  {
    "text": "collecting and after you stop collecting what you're going to get is a file with",
    "start": "848470",
    "end": "856720"
  },
  {
    "text": "the ETL extension not sure what it stands for eg log I don't know doesn't matter and",
    "start": "856720",
    "end": "864759"
  },
  {
    "text": "the same application perfu is actually able to analyze this file for us and",
    "start": "864759",
    "end": "870730"
  },
  {
    "text": "provides very convenient statistical predefined views for viewing these these",
    "start": "870730",
    "end": "876879"
  },
  {
    "text": "log messages so the first thing we're going to look at is the steel called CPU effects now I'm not sure if you noticed",
    "start": "876879",
    "end": "885040"
  },
  {
    "text": "but I actually didn't select anywhere in the collect menu that I want to sample specifically my Jack compiler and that's",
    "start": "885040",
    "end": "891939"
  },
  {
    "text": "because the collection is done system-wide so as I have information here about all the processes to run on",
    "start": "891939",
    "end": "898209"
  },
  {
    "text": "my system so I'm going to select in this view my Jack compiler and the first",
    "start": "898209",
    "end": "903519"
  },
  {
    "text": "thing that I'm going to see is this nice table with lots of function names and",
    "start": "903519",
    "end": "908799"
  },
  {
    "text": "the percentage of time that the application spent in these functions and straightaway I can see that 58% of the",
    "start": "908799",
    "end": "916899"
  },
  {
    "text": "time my application spent inside string concatenation okay interesting maybe",
    "start": "916899",
    "end": "922990"
  },
  {
    "text": "it's okay maybe not but that's important information now if I want to know who called that string",
    "start": "922990",
    "end": "929340"
  },
  {
    "text": "concatenation I can double click it and it will lead me to this knife well I",
    "start": "929340",
    "end": "934470"
  },
  {
    "text": "don't know it's quite nice but this tree call stack view which will allow me to",
    "start": "934470",
    "end": "940590"
  },
  {
    "text": "expand it and see the code path which led me to the call to synchro catenation",
    "start": "940590",
    "end": "947550"
  },
  {
    "text": "so I can see that 12 13 percentage thirteen percentage of the time I was",
    "start": "947550",
    "end": "955320"
  },
  {
    "text": "led to string concatenation from the assignment function and another 12% was",
    "start": "955320",
    "end": "961680"
  },
  {
    "text": "from the Cole function and so on I can now go back to my code and see what's",
    "start": "961680",
    "end": "967170"
  },
  {
    "text": "going on there let's look at more views that we have here we have a memory group",
    "start": "967170",
    "end": "972480"
  },
  {
    "text": "interesting right and we have a GC stats view let's open it up again we have",
    "start": "972480",
    "end": "983040"
  },
  {
    "text": "information for all of the process on the system but we're going to select the Jack compiler and what we can see here",
    "start": "983040",
    "end": "989720"
  },
  {
    "text": "is some statistical is a statistical summary of the GC for my application so",
    "start": "989720",
    "end": "997500"
  },
  {
    "text": "for example I can see the total amount of allocations and I can see the total GC CPU time and I can see the percentage",
    "start": "997500",
    "end": "1006260"
  },
  {
    "text": "of time the CPU took and and so on in fact if I go down I even get more",
    "start": "1006260",
    "end": "1013760"
  },
  {
    "text": "information about the different generations in the GC and if I go even",
    "start": "1013760",
    "end": "1019220"
  },
  {
    "text": "further down I can see a huge list of all of the collections that happens in",
    "start": "1019220",
    "end": "1025459"
  },
  {
    "text": "my application obviously we're not going to look at it now but the data is there",
    "start": "1025459",
    "end": "1031209"
  },
  {
    "text": "okay let's see what else we can get from this excuse me here it is okay we have",
    "start": "1031209",
    "end": "1040459"
  },
  {
    "text": "another interesting and you see view here and that's view summarizing all of",
    "start": "1040459",
    "end": "1045949"
  },
  {
    "text": "the allocations that our application made and in fact that's probably what's going to solve the mystery of what's",
    "start": "1045950",
    "end": "1052790"
  },
  {
    "text": "causing our problem takes a little while to analyze okay again we have to select",
    "start": "1052790",
    "end": "1059120"
  },
  {
    "text": "our pro such a compiler and okay how easy was",
    "start": "1059120",
    "end": "1064430"
  },
  {
    "text": "that a hundred percent of our allocations is system strings now",
    "start": "1064430",
    "end": "1069830"
  },
  {
    "text": "combining to the fact that we know that sixty percent of the time we were spending in string concatenation you",
    "start": "1069830",
    "end": "1075080"
  },
  {
    "text": "know that string concatenation might not be the most efficient thing in the world thus mystery solved if I want to know",
    "start": "1075080",
    "end": "1083510"
  },
  {
    "text": "more specifics about where the strings are allocated like magic I double-click",
    "start": "1083510",
    "end": "1088970"
  },
  {
    "text": "my type and I get this nice view tree",
    "start": "1088970",
    "end": "1094370"
  },
  {
    "text": "like view again where I can see where in my program these allocations were made",
    "start": "1094370",
    "end": "1103480"
  },
  {
    "text": "so cool if UW gave us a lot of information another way with the solve",
    "start": "1103480",
    "end": "1114610"
  },
  {
    "text": "or look for memory allocation problem in problems in our application is using",
    "start": "1114610",
    "end": "1120170"
  },
  {
    "text": "static analysis static analysis basically allows us detecting the",
    "start": "1120170",
    "end": "1125840"
  },
  {
    "text": "problem before we even start running the application we don't have to wait and",
    "start": "1125840",
    "end": "1131510"
  },
  {
    "text": "run it and like wait for some specific weird scenarios to occur the idea is",
    "start": "1131510",
    "end": "1137630"
  },
  {
    "text": "that an automatic tool goes over our code and searches for specific coding",
    "start": "1137630",
    "end": "1145400"
  },
  {
    "text": "patterns which are known to be problematic or excessive in allocations",
    "start": "1145400",
    "end": "1150590"
  },
  {
    "text": "for example string concatenation right I mean it's really easy to detect string",
    "start": "1150590",
    "end": "1155780"
  },
  {
    "text": "concatenation automatically you need two strings and you need a plus operator between them sounds like a good Python",
    "start": "1155780",
    "end": "1163250"
  },
  {
    "text": "exercise another area where it could help us is try to detect a memory weak",
    "start": "1163250",
    "end": "1170510"
  },
  {
    "text": "even by detecting where we forget to call dispose on our I disposable objects",
    "start": "1170510",
    "end": "1178190"
  },
  {
    "text": "that's less trivial than finding string concatenation correct but still it's a",
    "start": "1178190",
    "end": "1184130"
  },
  {
    "text": "coding pattern and once you have a pattern an automatic tool can do it for you of where static analysis is not",
    "start": "1184130",
    "end": "1190730"
  },
  {
    "text": "limited to just finding memory problems it can help you in other coding problems as well like passing the wrong",
    "start": "1190730",
    "end": "1198720"
  },
  {
    "text": "number of dynamic parameters to console.writeline or if you try to use",
    "start": "1198720",
    "end": "1204480"
  },
  {
    "text": "an uninitialized local variable for example now they're available there are",
    "start": "1204480",
    "end": "1210600"
  },
  {
    "text": "several available tools for you to do static analysis starting from a built in",
    "start": "1210600",
    "end": "1217380"
  },
  {
    "text": "static analyzer and Visual Studio ranging through resharper which I guess",
    "start": "1217380",
    "end": "1222450"
  },
  {
    "text": "you are all familiar with and then you have Coverity which specializes",
    "start": "1222450",
    "end": "1227820"
  },
  {
    "text": "specifically in static analysis and costs many thousands of dollars per year",
    "start": "1227820",
    "end": "1235400"
  },
  {
    "text": "so so yeah now let's try I don't have",
    "start": "1235400",
    "end": "1240570"
  },
  {
    "text": "Coverity but let's try to see what Visual Studio could tell us about our",
    "start": "1240570",
    "end": "1246030"
  },
  {
    "text": "Jack compiler which and we can see that we could avoid all of this problem to",
    "start": "1246030",
    "end": "1252450"
  },
  {
    "text": "begin with so going back to my machines to close some stuff close good I have",
    "start": "1252450",
    "end": "1263340"
  },
  {
    "text": "Visual Studio here do you see the code the back there good",
    "start": "1263340",
    "end": "1268950"
  },
  {
    "text": "so here is my Jack where is my Jack",
    "start": "1268950",
    "end": "1277770"
  },
  {
    "text": "compiler here is here's my Jack compiler we're not going to like to really read",
    "start": "1277770",
    "end": "1282960"
  },
  {
    "text": "the code now right I'll just open a few random files you will understand Daniel T why I do that",
    "start": "1282960",
    "end": "1290040"
  },
  {
    "text": "and what happens is that whenever a file is open visual studio runs its static",
    "start": "1290040",
    "end": "1298440"
  },
  {
    "text": "analyzer on on the open files and emits warnings here at the error list window",
    "start": "1298440",
    "end": "1306290"
  },
  {
    "text": "now just I forgot to say that it's not exactly built-in inside Visual Studio",
    "start": "1306290",
    "end": "1312230"
  },
  {
    "text": "it's actually a it's a free extension available online for free so it's not a",
    "start": "1312230",
    "end": "1318000"
  },
  {
    "text": "problem and it's integrated inside Visual Studio it's called CLR heap allocation analyzer",
    "start": "1318000",
    "end": "1323820"
  },
  {
    "text": "its sole purpose is to memory allocations your.net applications",
    "start": "1323820",
    "end": "1331010"
  },
  {
    "text": "and so let's look at a few examples of the of the warnings that this extension",
    "start": "1331010",
    "end": "1336990"
  },
  {
    "text": "amidst well so let's see I'll double click here and I'll read it to you it's",
    "start": "1336990",
    "end": "1343020"
  },
  {
    "text": "a little small non value type enumerators may result in a heap allocation so if you do forage and on",
    "start": "1343020",
    "end": "1350810"
  },
  {
    "text": "non objects or non reference type list",
    "start": "1350810",
    "end": "1357870"
  },
  {
    "text": "you might cause heap allocation or another example here is a good one",
    "start": "1357870",
    "end": "1364230"
  },
  {
    "text": "consider using string builder this is one of our famous or infamous string",
    "start": "1364230",
    "end": "1371070"
  },
  {
    "text": "concatenation in this case it's just two strings so you know maybe it's not at",
    "start": "1371070",
    "end": "1376530"
  },
  {
    "text": "that but actually have more more examples here when we concatenate a",
    "start": "1376530",
    "end": "1382080"
  },
  {
    "text": "whole bunch of strings and so it tells me you're better off using a string builder let's see another example and",
    "start": "1382080",
    "end": "1389970"
  },
  {
    "text": "then we'll move on okay let's do that no I like it laughs okay you can see a lot",
    "start": "1389970",
    "end": "1398370"
  },
  {
    "text": "a lot of string concatenation we're already know that that's the problem right okay that's nice what is that",
    "start": "1398370",
    "end": "1406260"
  },
  {
    "text": "non overridden virtual method call on a value type adds a boxing or constrained",
    "start": "1406260",
    "end": "1414120"
  },
  {
    "text": "instruction so basically we have a we have a value type here and we call a",
    "start": "1414120",
    "end": "1420330"
  },
  {
    "text": "virtual we call a virtual method and it causes allocation and in fact we're",
    "start": "1420330",
    "end": "1426270"
  },
  {
    "text": "going to talk in more detail about it in a few minutes so it seems like we could avoid a lot of problems by just running",
    "start": "1426270",
    "end": "1433290"
  },
  {
    "text": "the static analyzer on our Jack compiler before we started running it good the",
    "start": "1433290",
    "end": "1441450"
  },
  {
    "text": "last method of detecting problems and your application is dynamic analysis the",
    "start": "1441450",
    "end": "1447960"
  },
  {
    "text": "problem with static analysis is that some problems are still very hard to find and are not characterized by very",
    "start": "1447960",
    "end": "1456300"
  },
  {
    "text": "specific and constrained coding patterns moreover there are some scenarios such",
    "start": "1456300",
    "end": "1461519"
  },
  {
    "text": "as memory leaks which are very hard to diagnose without some sort of temporal analysis of what's going on in your",
    "start": "1461519",
    "end": "1469320"
  },
  {
    "text": "program and that's what dynamic memory profiling is for again you can do that",
    "start": "1469320",
    "end": "1475710"
  },
  {
    "text": "both on native and managed memory and they're a bunch of tools available out",
    "start": "1475710",
    "end": "1482669"
  },
  {
    "text": "there they're mostly commercial and what's interesting here that you might want to maybe we're asking yourself we",
    "start": "1482669",
    "end": "1490289"
  },
  {
    "text": "got a lot of information from etw right and indeed some of the tools used etw",
    "start": "1490289",
    "end": "1496469"
  },
  {
    "text": "as the source of their information however the main difference between using etw yourself and using a",
    "start": "1496469",
    "end": "1504389"
  },
  {
    "text": "commercial tool is that the commercial tool will usually provide a nicer view",
    "start": "1504389",
    "end": "1509460"
  },
  {
    "text": "of the results it would make some of the analysis for you it would point you into",
    "start": "1509460",
    "end": "1515339"
  },
  {
    "text": "the correct direction if you need to diagnose a leak using etw you would have to go over a",
    "start": "1515339",
    "end": "1521159"
  },
  {
    "text": "lot of objects and might count them or whatever a memory profiler will usually",
    "start": "1521159",
    "end": "1527190"
  },
  {
    "text": "do all that comparison and analysis for you and just give you the results okay that's the type that is leaking that's",
    "start": "1527190",
    "end": "1533759"
  },
  {
    "text": "what's holding it in memory now running a memory profile takes a while so we won't do that now but I do have a",
    "start": "1533759",
    "end": "1540269"
  },
  {
    "text": "screenshot here from a tool that is named dotnet memory profiler that's very",
    "start": "1540269",
    "end": "1547219"
  },
  {
    "text": "not very imaginative and what you can see here is that I ran it it's actually",
    "start": "1547219",
    "end": "1553619"
  },
  {
    "text": "also has an extension for visual studio and I ran it on a certain c-sharp application not the Jack compiler and I",
    "start": "1553619",
    "end": "1561119"
  },
  {
    "text": "took several snapshots and then I used all that memory compiler to compare",
    "start": "1561119",
    "end": "1566159"
  },
  {
    "text": "between these snapshots and it actually tells me that the number of response",
    "start": "1566159",
    "end": "1571859"
  },
  {
    "text": "objects grew from my first snapshot to my last snapshot this might be a leak",
    "start": "1571859",
    "end": "1579509"
  },
  {
    "text": "not necessarily it's quite possible that it's got all going to be freed up in a minute but it might be a leak now if I want to",
    "start": "1579509",
    "end": "1586649"
  },
  {
    "text": "know what's keeping these objects from being collected I can just go to another",
    "start": "1586649",
    "end": "1592049"
  },
  {
    "text": "view inside the dotnet memory profiler and this time it will show me that in",
    "start": "1592049",
    "end": "1597329"
  },
  {
    "text": "fact there is a static object called response cache well not everything is clear right so this response cache which",
    "start": "1597329",
    "end": "1605549"
  },
  {
    "text": "is static that's the route that's holding all of my response objects in the memory at this point I might decide",
    "start": "1605549",
    "end": "1613019"
  },
  {
    "text": "that this is indeed a bug I can go back to my code and fix it ok so I think we",
    "start": "1613019",
    "end": "1620639"
  },
  {
    "text": "have a good understanding of how we can detect that we have a problem now let's",
    "start": "1620639",
    "end": "1627899"
  },
  {
    "text": "try to see a few examples about how we could reach such a bad state in our",
    "start": "1627899",
    "end": "1636089"
  },
  {
    "text": "application which coding patterns that we all use by the way might lead us to",
    "start": "1636089",
    "end": "1641369"
  },
  {
    "text": "such behavior so first of all I'm going to start with an example I have lots of",
    "start": "1641369",
    "end": "1647429"
  },
  {
    "text": "stack overflow screenshots today there's a guy here he's doing some graphics I",
    "start": "1647429",
    "end": "1653969"
  },
  {
    "text": "think a lot of my examples have to do with graphics it's interesting so he has",
    "start": "1653969",
    "end": "1659940"
  },
  {
    "text": "a dictionary of vectors and what he noticed is that whenever he accesses",
    "start": "1659940",
    "end": "1668039"
  },
  {
    "text": "this dictionary there is memory allocation happening and he was",
    "start": "1668039",
    "end": "1674339"
  },
  {
    "text": "surprised because dictionaries are supposed to go first of all he's just accessing like he's not allocating",
    "start": "1674339",
    "end": "1679769"
  },
  {
    "text": "anything himself he just wanted to look inside the dictionary but also he was quite surprised because dictionaries are",
    "start": "1679769",
    "end": "1686009"
  },
  {
    "text": "supposed to be really efficient right so do any of you have an idea about what",
    "start": "1686009",
    "end": "1692339"
  },
  {
    "text": "might be causing this memory allocation boxing ok good that's the answer I was",
    "start": "1692339",
    "end": "1697829"
  },
  {
    "text": "hoping for it's the correct answer not a trick question indeed it's boxing but",
    "start": "1697829",
    "end": "1703499"
  },
  {
    "text": "what I want to do next is understand like really down to the metal what's",
    "start": "1703499",
    "end": "1710369"
  },
  {
    "text": "going on and what's causing this boxing and to do that I will do my own benchmark on something Oh which is a",
    "start": "1710369",
    "end": "1718470"
  },
  {
    "text": "little different but simplifies what happens in this case so in",
    "start": "1718470",
    "end": "1724410"
  },
  {
    "text": "one sentence I'll remind you that the dictionary is actually a hash hash or",
    "start": "1724410",
    "end": "1729780"
  },
  {
    "text": "table right but a hash table has Senate size so some bins in the hash table",
    "start": "1729780",
    "end": "1736040"
  },
  {
    "text": "contain lists of elements right the elements that have the same hash",
    "start": "1736040",
    "end": "1741330"
  },
  {
    "text": "function so eventually when you access a dictionary you're going to calculate the",
    "start": "1741330",
    "end": "1747450"
  },
  {
    "text": "hash of your object and then you're going to have to go through that list of elements and find the one that you're",
    "start": "1747450",
    "end": "1753180"
  },
  {
    "text": "looking for so what I'm going to do now is that I'm going to benchmark the hell",
    "start": "1753180",
    "end": "1759390"
  },
  {
    "text": "out of searching elements inside list",
    "start": "1759390",
    "end": "1764510"
  },
  {
    "text": "okay so let's imagine that we have a data structure and it contains a single",
    "start": "1764510",
    "end": "1772110"
  },
  {
    "text": "integer the guy had a vector it was two integers or two doubles whatever we're going to have a single single member",
    "start": "1772110",
    "end": "1779070"
  },
  {
    "text": "single member and then we're going to have a list or array doesn't matter of",
    "start": "1779070",
    "end": "1785370"
  },
  {
    "text": "such data structures and we're going to search through those and the key thing",
    "start": "1785370",
    "end": "1791220"
  },
  {
    "text": "to understand here is that there are actually three ways to implement that",
    "start": "1791220",
    "end": "1796770"
  },
  {
    "text": "scenario the search is always the same right we just you know use contains",
    "start": "1796770",
    "end": "1802170"
  },
  {
    "text": "we're going to see that in a moment but the data structure is so we could write it in three different ways we could either you know it just let's",
    "start": "1802170",
    "end": "1809760"
  },
  {
    "text": "look at the code instead we'll be much easier to understand",
    "start": "1809760",
    "end": "1815360"
  },
  {
    "text": "boxing okey okey so",
    "start": "1816500",
    "end": "1822770"
  },
  {
    "text": "don't mean that okay so the struct itself as I said it's going to hold a single data field and there are three",
    "start": "1823940",
    "end": "1832489"
  },
  {
    "text": "ways to create such a data structure so we're going to use a struct you could",
    "start": "1832489",
    "end": "1839179"
  },
  {
    "text": "just you know right at the simplest way we could struct with a property value",
    "start": "1839179",
    "end": "1845539"
  },
  {
    "text": "easy three lines you know looks perfect",
    "start": "1845539",
    "end": "1850609"
  },
  {
    "text": "then another thing we could do is that we could override the equals the base",
    "start": "1850609",
    "end": "1858679"
  },
  {
    "text": "equals method that we have in every dotnet object the code is simple that",
    "start": "1858679",
    "end": "1865039"
  },
  {
    "text": "didn't do anything special again not trick code we take we check the type",
    "start": "1865039",
    "end": "1871190"
  },
  {
    "text": "and we compare the value very simple and then I could even go as far as",
    "start": "1871190",
    "end": "1877239"
  },
  {
    "text": "implementing the I equatable interface the I equatable interface basically says",
    "start": "1877239",
    "end": "1883639"
  },
  {
    "text": "that the type has an equals method which",
    "start": "1883639",
    "end": "1888919"
  },
  {
    "text": "doesn't accept an object but accepts the type itself and in this case when I",
    "start": "1888919",
    "end": "1895849"
  },
  {
    "text": "implemented it's much simpler because I don't need to check the type I already know that it's the correct size because",
    "start": "1895849",
    "end": "1902059"
  },
  {
    "text": "that's the input of the function and I just compare values so those are the three different ways in which I could",
    "start": "1902059",
    "end": "1908659"
  },
  {
    "text": "implement such a stroke now let's look at the test itself by the way all the",
    "start": "1908659",
    "end": "1918049"
  },
  {
    "text": "code is available on github you'll see a link at the end of the slides and you have some extra test cases here which",
    "start": "1918049",
    "end": "1924529"
  },
  {
    "text": "we're not going to discuss but I recommend that you look at them later it's interesting to try to understand",
    "start": "1924529",
    "end": "1931039"
  },
  {
    "text": "what's what's going on so for my benchmark I'm going to initialize three",
    "start": "1931039",
    "end": "1937099"
  },
  {
    "text": "lists of the same size of course of these three different structures now the",
    "start": "1937099",
    "end": "1944839"
  },
  {
    "text": "initialization which happens here is not going to be measured as part of the",
    "start": "1944839",
    "end": "1951799"
  },
  {
    "text": "benchmark because I'm only interested in the search time and then",
    "start": "1951799",
    "end": "1957590"
  },
  {
    "text": "I'm going to do the search itself so we have three benchmark functions which are",
    "start": "1957590",
    "end": "1964279"
  },
  {
    "text": "marked with the benchmark attribute I'll explain that in a moment and they all do the same thing basically each of them",
    "start": "1964279",
    "end": "1970850"
  },
  {
    "text": "goes over the list and it asks whether it contains the last element of that",
    "start": "1970850",
    "end": "1979610"
  },
  {
    "text": "list why laughs because I want my benchmark to go over the entire list if",
    "start": "1979610",
    "end": "1986210"
  },
  {
    "text": "it stops after the first one it's less interesting for me I kind of want to check the worst case possible now just",
    "start": "1986210",
    "end": "1994669"
  },
  {
    "text": "one or two sentences about this benchmark attribute here bench correct",
    "start": "1994669",
    "end": "2001570"
  },
  {
    "text": "benchmarking is not easy you need to think about warming up the cash you need",
    "start": "2001570",
    "end": "2006880"
  },
  {
    "text": "to think about the overhead of the measurements itself there's a lot of stuff that you need to think about and",
    "start": "2006880",
    "end": "2013120"
  },
  {
    "text": "there's a free library online and some nougat it's called benchmark dotnet again I'm not going to get into much",
    "start": "2013120",
    "end": "2019899"
  },
  {
    "text": "detail about it but it just makes your benchmarking life much easier basically",
    "start": "2019899",
    "end": "2026440"
  },
  {
    "text": "you put that attribute on your benchmark functions and then in your main you will",
    "start": "2026440",
    "end": "2033190"
  },
  {
    "text": "simply call benchmark runner doctrine and your class with all the benchmarking functions whatever you",
    "start": "2033190",
    "end": "2039970"
  },
  {
    "text": "route you're right and the class constructor is not counted as the benchmark so that's why I have the",
    "start": "2039970",
    "end": "2046179"
  },
  {
    "text": "initialization of the lists in this in the beginning and the constructor and then I have the methods which implement",
    "start": "2046179",
    "end": "2054010"
  },
  {
    "text": "the benchmark themselves later now benchmarking takes a lot of time so we're not going to run it live but again",
    "start": "2054010",
    "end": "2060730"
  },
  {
    "text": "you can totally recreate the results at home I just prepare the results in advance",
    "start": "2060730",
    "end": "2066720"
  },
  {
    "text": "voila these are the results now let's",
    "start": "2066720",
    "end": "2073270"
  },
  {
    "text": "ignore the first line for now I promise I will get back to it later so let's",
    "start": "2073270",
    "end": "2079929"
  },
  {
    "text": "concentrate first on understanding the difference in the results between the",
    "start": "2079929",
    "end": "2085330"
  },
  {
    "text": "case where we override equals and the case where we implement I equatable know",
    "start": "2085330",
    "end": "2090589"
  },
  {
    "text": "two things here the time for the override is longer and there are memory",
    "start": "2090589",
    "end": "2097279"
  },
  {
    "text": "allocations while the time for the interface is shorter and there are no",
    "start": "2097279",
    "end": "2104690"
  },
  {
    "text": "memory allocations at all let's understand how that happens so how does",
    "start": "2104690",
    "end": "2110420"
  },
  {
    "text": "searching work well it's easier right we have our collection we basically go over",
    "start": "2110420",
    "end": "2115549"
  },
  {
    "text": "it and compare you know all the elements to the elements that we're searching for",
    "start": "2115549",
    "end": "2121210"
  },
  {
    "text": "so if we're dealing with primitives for example it's pretty obvious how to",
    "start": "2121210",
    "end": "2126589"
  },
  {
    "text": "compare them right but if we have user-defined structures it's not so",
    "start": "2126589",
    "end": "2131900"
  },
  {
    "text": "obvious anymore so we need to create a compare which is going to compare the",
    "start": "2131900",
    "end": "2137029"
  },
  {
    "text": "elements for me and it turns out that this is where the difference lies we can",
    "start": "2137029",
    "end": "2142999"
  },
  {
    "text": "see it a snippet from the create compare function here and we can see that there",
    "start": "2142999",
    "end": "2148309"
  },
  {
    "text": "is a difference there is a specific special comparer created for the case",
    "start": "2148309",
    "end": "2155479"
  },
  {
    "text": "that the time implements i equatable and another compare for the rest of the",
    "start": "2155479",
    "end": "2163099"
  },
  {
    "text": "cases and if you think about it it actually makes sense right because after",
    "start": "2163099",
    "end": "2168200"
  },
  {
    "text": "all if you implement it i equatable it must mean that you want to use your own",
    "start": "2168200",
    "end": "2174259"
  },
  {
    "text": "you know equality function that make sense now let's look at the compare ourselves",
    "start": "2174259",
    "end": "2180849"
  },
  {
    "text": "so this is the object equality compare that's the regular compare oh the one",
    "start": "2180849",
    "end": "2186469"
  },
  {
    "text": "that's used for for everything everything but i equatable the code is pretty straightforward right that's the",
    "start": "2186469",
    "end": "2194119"
  },
  {
    "text": "key command here right x equals y now",
    "start": "2194119",
    "end": "2199969"
  },
  {
    "text": "what is this equals function this is just a regular object with no constraints so this equals function is",
    "start": "2199969",
    "end": "2207559"
  },
  {
    "text": "bound to the base class object equals method which accepts objects as an input",
    "start": "2207559",
    "end": "2216880"
  },
  {
    "text": "now so let's try to understand what we have we have a struct which is a value",
    "start": "2216880",
    "end": "2222469"
  },
  {
    "text": "type and we have a compare which calls equals which accepts an object we need to pass the value tied to",
    "start": "2222469",
    "end": "2229730"
  },
  {
    "text": "an object so boxing number one why is",
    "start": "2229730",
    "end": "2235190"
  },
  {
    "text": "obviously boxed what about X well again X is a value type right it'll struct",
    "start": "2235190",
    "end": "2242000"
  },
  {
    "text": "however equals is a virtual method and",
    "start": "2242000",
    "end": "2247000"
  },
  {
    "text": "we need to transform X into a reference with all of the Tedder's and virtual",
    "start": "2247809",
    "end": "2255319"
  },
  {
    "text": "method tables and so on in order to be able to call that virtual equals method",
    "start": "2255319",
    "end": "2260990"
  },
  {
    "text": "on our X that's boxing number two okay so now we understand where all those",
    "start": "2260990",
    "end": "2267380"
  },
  {
    "text": "memory allocation is coming from that's the code for the generic equality",
    "start": "2267380",
    "end": "2272779"
  },
  {
    "text": "compare the names are really bad by the way I have to say I can't remember which",
    "start": "2272779",
    "end": "2278329"
  },
  {
    "text": "is which like ever so the code for the Equality compare which is specific for I",
    "start": "2278329",
    "end": "2284869"
  },
  {
    "text": "equatable it looks the same you can play really compare it it looks exactly the same only that and you can",
    "start": "2284869",
    "end": "2291799"
  },
  {
    "text": "see that in the comment here that in this case the equals method is bound not",
    "start": "2291799",
    "end": "2298640"
  },
  {
    "text": "to the object equals the object method but rather to the eye equatable equals",
    "start": "2298640",
    "end": "2304730"
  },
  {
    "text": "method you can see that by looking at the code that that's the way it is now",
    "start": "2304730",
    "end": "2310869"
  },
  {
    "text": "with that information what's going on we have the struct if I equatable we pass",
    "start": "2310869",
    "end": "2317750"
  },
  {
    "text": "it to the equals of that i equatable awesome no boxing so minus 1 bucks what",
    "start": "2317750",
    "end": "2325369"
  },
  {
    "text": "about X though now this is a little tricky and the reason that X doesn't get",
    "start": "2325369",
    "end": "2332299"
  },
  {
    "text": "boxed either is that the CLR was planned in such a way that calling interface",
    "start": "2332299",
    "end": "2338900"
  },
  {
    "text": "methods on value types is jetted into a direct function call so this is not a",
    "start": "2338900",
    "end": "2347509"
  },
  {
    "text": "virtual method call and instructions you don't have inheritance doesn't make some new virtual methods so the gist",
    "start": "2347509",
    "end": "2354589"
  },
  {
    "text": "transforms this into a direct call again - two boxes no memory allocation",
    "start": "2354589",
    "end": "2362380"
  },
  {
    "text": "whatsoever and that explains the results indeed if",
    "start": "2362380",
    "end": "2367549"
  },
  {
    "text": "we run etw if we sample a little bit our test case with the overridden equals we",
    "start": "2367549",
    "end": "2377210"
  },
  {
    "text": "can see that what is that like forty percent of the time in the test was spent on creating new objects so that",
    "start": "2377210",
    "end": "2386380"
  },
  {
    "text": "really explains what happens to that guy with a dictionary because his problem was that he is vector the key to his",
    "start": "2386380",
    "end": "2394039"
  },
  {
    "text": "dictionary did not implement I equatable and once he implemented I equatable on",
    "start": "2394039",
    "end": "2401720"
  },
  {
    "text": "his vector all of his problems were solved cool now I didn't forget that I",
    "start": "2401720",
    "end": "2411079"
  },
  {
    "text": "ignored one using I didn't forget that I ignored one test case and that's the",
    "start": "2411079",
    "end": "2418160"
  },
  {
    "text": "case where we searched abstract that didn't have any sort of specialized",
    "start": "2418160",
    "end": "2423619"
  },
  {
    "text": "implementation for equals now that has less to do with boxing the memory and more to do with the fact that the",
    "start": "2423619",
    "end": "2429680"
  },
  {
    "text": "default comparison for structs is not reference comparison but rather a value",
    "start": "2429680",
    "end": "2436130"
  },
  {
    "text": "member by member comparison and if you don't implement it yourself dotnet is",
    "start": "2436130",
    "end": "2442400"
  },
  {
    "text": "going to implement it for you but it's going to use reflection and all sorts of very non efficient stuff and that's what",
    "start": "2442400",
    "end": "2449690"
  },
  {
    "text": "that's the result in this horrible performance so if you ever have a struct",
    "start": "2449690",
    "end": "2454700"
  },
  {
    "text": "and you know that you're going to compare it to like anything ever just you know the best thing would be to",
    "start": "2454700",
    "end": "2459980"
  },
  {
    "text": "implement I available but like as we override the equals method okay so to",
    "start": "2459980",
    "end": "2467329"
  },
  {
    "text": "our next scenario another c-sharp GUI which we're all like using lambdas",
    "start": "2467329",
    "end": "2472480"
  },
  {
    "text": "everybody uses lambdas they're so awesome they make the code shorter so a",
    "start": "2472480",
    "end": "2478970"
  },
  {
    "text": "quicker explanation about how lambdas are used how are they compiled so if we",
    "start": "2478970",
    "end": "2487010"
  },
  {
    "text": "have a lambda which captures estates from its scope what the",
    "start": "2487010",
    "end": "2493430"
  },
  {
    "text": "compiler is going to do and that's totally a compiler goodie here what the compiler is going to do is that it's",
    "start": "2493430",
    "end": "2498710"
  },
  {
    "text": "going to generate behind the scenes class we don't know its name we don't see it in the code and this class is",
    "start": "2498710",
    "end": "2505610"
  },
  {
    "text": "going to have a field which is the state that needs to be captured by the lambda",
    "start": "2505610",
    "end": "2511100"
  },
  {
    "text": "and it's going to have a method which is the actual code for the lambda and if",
    "start": "2511100",
    "end": "2517430"
  },
  {
    "text": "you want to call that lambda then you're going to have what the compiler does it",
    "start": "2517430",
    "end": "2522710"
  },
  {
    "text": "for you instantiate this behind-the-scenes class it will save the",
    "start": "2522710",
    "end": "2527990"
  },
  {
    "text": "state inside the field in that class and then it will create a new action",
    "start": "2527990",
    "end": "2533650"
  },
  {
    "text": "invoking the method implementing your",
    "start": "2533650",
    "end": "2538970"
  },
  {
    "text": "actual code okay now what I want to do is to try to measure the effect of all",
    "start": "2538970",
    "end": "2547250"
  },
  {
    "text": "of this on our code what I'm going to do as I thought of this a lot of times we",
    "start": "2547250",
    "end": "2556370"
  },
  {
    "text": "use lambdas in tasks right we create tasks we pass a lambda that runs the",
    "start": "2556370",
    "end": "2562580"
  },
  {
    "text": "code so what I wanted to do is see how this affects our task creation so I'll",
    "start": "2562580",
    "end": "2569810"
  },
  {
    "text": "just open it up tasks already now since",
    "start": "2569810",
    "end": "2575390"
  },
  {
    "text": "I didn't want to measure the running of the tasks themselves but just creating",
    "start": "2575390",
    "end": "2581330"
  },
  {
    "text": "the tasks I wrote a task stub which doesn't do anything except that it has",
    "start": "2581330",
    "end": "2587960"
  },
  {
    "text": "the same API as the real task class for creating tasks so mainly it has two",
    "start": "2587960",
    "end": "2595880"
  },
  {
    "text": "functions it has start new which accepts an action and it has a start new which",
    "start": "2595880",
    "end": "2603380"
  },
  {
    "text": "accepts an action and a state which is to be passed to that creation to that",
    "start": "2603380",
    "end": "2610520"
  },
  {
    "text": "function okay and let's look at the scenarios that we're going to check so",
    "start": "2610520",
    "end": "2617240"
  },
  {
    "text": "most mainly what we're going to do is that we're going to check the case where we have states that",
    "start": "2617240",
    "end": "2623330"
  },
  {
    "text": "we want to pass to the task and the case where we don't have to pass state to the",
    "start": "2623330",
    "end": "2629420"
  },
  {
    "text": "task so it's a little artificial example I know but let's imagine that we have",
    "start": "2629420",
    "end": "2637070"
  },
  {
    "text": "some data structure and we want to sum up some numbers to a global sum and for",
    "start": "2637070",
    "end": "2643970"
  },
  {
    "text": "some reason we want to do it from multiple tasks all right so first",
    "start": "2643970",
    "end": "2649990"
  },
  {
    "text": "example let's say that we want to capture the state and that's the data",
    "start": "2649990",
    "end": "2656630"
  },
  {
    "text": "that we want to sum up to our global member so we could have a loop go over",
    "start": "2656630",
    "end": "2662030"
  },
  {
    "text": "the elements we create our data and then we start a task with the lambda which",
    "start": "2662030",
    "end": "2668870"
  },
  {
    "text": "captures this data from the scope then",
    "start": "2668870",
    "end": "2674680"
  },
  {
    "text": "we could use the fancy tasks API and instead of capturing the state we will",
    "start": "2674680",
    "end": "2682700"
  },
  {
    "text": "use the API which accepts the state as",
    "start": "2682700",
    "end": "2688070"
  },
  {
    "text": "an object as an input to the task creation function so in this case the",
    "start": "2688070",
    "end": "2694010"
  },
  {
    "text": "lambda is actually receiving input it received receives the data as an input",
    "start": "2694010",
    "end": "2699920"
  },
  {
    "text": "and this input is then provided to the task by the task class provided to the",
    "start": "2699920",
    "end": "2709070"
  },
  {
    "text": "lambda excuse me by the task itself and then we have two cases where we don't",
    "start": "2709070",
    "end": "2715640"
  },
  {
    "text": "have any state that we want to pass so we just have some constant value that we're adding to our tasks so we just",
    "start": "2715640",
    "end": "2723260"
  },
  {
    "text": "know do a loop starting a new task adding some constant value no data to be",
    "start": "2723260",
    "end": "2730010"
  },
  {
    "text": "passed and another case well sometimes we don't have a lambda we actually have",
    "start": "2730010",
    "end": "2737120"
  },
  {
    "text": "a function with a name and I could do this sort of silly lambda right but we",
    "start": "2737120",
    "end": "2745130"
  },
  {
    "text": "Sharper keeps suggesting that it turned that into a method group which makes the code much simpler right so I just do",
    "start": "2745130",
    "end": "2753290"
  },
  {
    "text": "that it's nice and easy let's look at the results okay so let",
    "start": "2753290",
    "end": "2761480"
  },
  {
    "text": "that sink in for a while these are the results we're going to see them later",
    "start": "2761480",
    "end": "2767570"
  },
  {
    "text": "again so let's just analyze case by case what's going on",
    "start": "2767570",
    "end": "2773170"
  },
  {
    "text": "the first thing though what I want to show you is that there's a correspondence in general between the",
    "start": "2773170",
    "end": "2779780"
  },
  {
    "text": "total allocations that we made in our benchmark and the time that the benchmark took and I think it should",
    "start": "2779780",
    "end": "2786410"
  },
  {
    "text": "surprise you by now judging from all the examples that we saw before so now let's try to understand where all these",
    "start": "2786410",
    "end": "2793130"
  },
  {
    "text": "allocations are coming from in each case so let's start with the case where we capture states when we capture state we",
    "start": "2793130",
    "end": "2800869"
  },
  {
    "text": "have that behind the scenes class that we need to instantiate okay so instantiate the class and of course we",
    "start": "2800869",
    "end": "2806960"
  },
  {
    "text": "need to instantiate the bailer itself obviously we save it inside our field",
    "start": "2806960",
    "end": "2812180"
  },
  {
    "text": "and then we need to instantiate an action which is going to run the method",
    "start": "2812180",
    "end": "2817250"
  },
  {
    "text": "in that behind-the-scenes class that implements our addition to the global",
    "start": "2817250",
    "end": "2822680"
  },
  {
    "text": "variable so we have three things that we allocate in each iteration the second",
    "start": "2822680",
    "end": "2830270"
  },
  {
    "text": "case we pass the state as a parameter and when the state is passed to the",
    "start": "2830270",
    "end": "2835730"
  },
  {
    "text": "parameter there's actually no capturing and if there's no capturing then we",
    "start": "2835730",
    "end": "2841369"
  },
  {
    "text": "don't have to instantiate the behind-the-scenes class so in this case we're only going to need to create the",
    "start": "2841369",
    "end": "2847340"
  },
  {
    "text": "data will we pass the data so we need to create it obviously but then we just use",
    "start": "2847340",
    "end": "2853100"
  },
  {
    "text": "a method which the compiler created for us it's a method inside a static field",
    "start": "2853100",
    "end": "2858260"
  },
  {
    "text": "it accepts input and it implements the addition and the compiler is actually",
    "start": "2858260",
    "end": "2865580"
  },
  {
    "text": "smart enough to do the action creation just once it caches it inside a static",
    "start": "2865580",
    "end": "2872359"
  },
  {
    "text": "field so we have data which is infatuated for each iteration but again I mean that's what we wanted and we have",
    "start": "2872359",
    "end": "2878869"
  },
  {
    "text": "a single instantiation of the action those are the cases where we have States",
    "start": "2878869",
    "end": "2884030"
  },
  {
    "text": "graph what about the case where we don't have state well that's easy",
    "start": "2884030",
    "end": "2889700"
  },
  {
    "text": "we don't have States at all so we don't allocate the data we do however need an",
    "start": "2889700",
    "end": "2895580"
  },
  {
    "text": "action which you know sums up this constant value that you're using and again the compiler is smart enough to",
    "start": "2895580",
    "end": "2903050"
  },
  {
    "text": "cash it in a static field and sanction the action just once now here's the most interesting thing though you would",
    "start": "2903050",
    "end": "2909380"
  },
  {
    "text": "expect this case to be exactly the same as the last case where I used a named",
    "start": "2909380",
    "end": "2914690"
  },
  {
    "text": "function right but it turns out there's I think it's a bug in the fish our",
    "start": "2914690",
    "end": "2920780"
  },
  {
    "text": "compiler and for some reason when you use a method group it fails to do this",
    "start": "2920780",
    "end": "2925850"
  },
  {
    "text": "optimization of creating the action just once so so in fact you get a worse",
    "start": "2925850",
    "end": "2934070"
  },
  {
    "text": "performance than you would have thought and this pretty much explains the results so in the first case you have to",
    "start": "2934070",
    "end": "2941180"
  },
  {
    "text": "allocate data you have to allocate action and you have to allocate in the behind-the-scenes class each iteration",
    "start": "2941180",
    "end": "2946970"
  },
  {
    "text": "so that's the worst case then the second case you have to instantiate the data of",
    "start": "2946970",
    "end": "2952010"
  },
  {
    "text": "course and well basically that's if you allocate the action just once so it's better in the third case you have the",
    "start": "2952010",
    "end": "2961430"
  },
  {
    "text": "action which was instantiated wise once you don't have data you don't have faith so that's the best case and then sadly",
    "start": "2961430",
    "end": "2968600"
  },
  {
    "text": "although you would expect it to behave the same in this case the action is",
    "start": "2968600",
    "end": "2973700"
  },
  {
    "text": "allocated over and over again and I guess that the action object takes more space than our data objects because it",
    "start": "2973700",
    "end": "2980600"
  },
  {
    "text": "seems that the total amount of memory in the last case is higher than in the case",
    "start": "2980600",
    "end": "2987260"
  },
  {
    "text": "where we have state awesome so now we understand that and if we join these two",
    "start": "2987260",
    "end": "2995210"
  },
  {
    "text": "things together boxing's plus path lambdas in two using",
    "start": "2995210",
    "end": "3001120"
  },
  {
    "text": "our favorite link right then looking fully understand that link is the",
    "start": "3001120",
    "end": "3006250"
  },
  {
    "text": "culmination of all evil now family I don't have much time because I don't want to keep you here long much longer",
    "start": "3006250",
    "end": "3012430"
  },
  {
    "text": "than you need to but I will just tell you that I wrote I wrote a benchmark",
    "start": "3012430",
    "end": "3018460"
  },
  {
    "text": "doing some mathematical computation which involved a double loop 1 loop inside of another",
    "start": "3018460",
    "end": "3026640"
  },
  {
    "text": "and I implemented it in three different ways once you know just like using loops another time using a single loop and a",
    "start": "3026640",
    "end": "3034800"
  },
  {
    "text": "little helper thing inside from dotnet and once totally using link you can see",
    "start": "3034800",
    "end": "3041040"
  },
  {
    "text": "the code and github later trust me that I implemented it correctly I checked",
    "start": "3041040",
    "end": "3046140"
  },
  {
    "text": "that the value returned from these functions was the same and then I ran the benchmark and I got these crazy",
    "start": "3046140",
    "end": "3053340"
  },
  {
    "text": "result okay so the wrong version is actually almost 10 times worse than the",
    "start": "3053340",
    "end": "3062220"
  },
  {
    "text": "version which just used loops and look at all of the memory allocations we see",
    "start": "3062220",
    "end": "3070740"
  },
  {
    "text": "that the memory allocation is about 10 times higher and as we already saw",
    "start": "3070740",
    "end": "3076980"
  },
  {
    "text": "there's a correspondence between time and memory and so you know it's really",
    "start": "3076980",
    "end": "3082560"
  },
  {
    "text": "bad I can't really say otherwise the last demo that I want to show you today",
    "start": "3082560",
    "end": "3087750"
  },
  {
    "text": "is the case of premature allocation it's a really cute one let's see here let's",
    "start": "3087750",
    "end": "3096840"
  },
  {
    "text": "imagine we're a web server and we need to return responses and these responses",
    "start": "3096840",
    "end": "3102120"
  },
  {
    "text": "are based on you know lists of collections of results or whatever which",
    "start": "3102120",
    "end": "3108150"
  },
  {
    "text": "we're going to have to put inside an HTML list so we could do it in three",
    "start": "3108150",
    "end": "3114420"
  },
  {
    "text": "different ways the most naive representation would be to use a string builder and that's",
    "start": "3114420",
    "end": "3119550"
  },
  {
    "text": "already a of course an optimization over just concatenating strings over and over again but basically we go over the data",
    "start": "3119550",
    "end": "3126510"
  },
  {
    "text": "we concatenate the items and encode the results and return us when the data is",
    "start": "3126510",
    "end": "3132360"
  },
  {
    "text": "empty this loop is not going to get executed you know everything works a",
    "start": "3132360",
    "end": "3138350"
  },
  {
    "text": "better version we could implement is to cache the empty response which I saved",
    "start": "3138350",
    "end": "3145170"
  },
  {
    "text": "here right this empress part just holds an empty HTML list so if I detest that",
    "start": "3145170",
    "end": "3153090"
  },
  {
    "text": "my data is empty I just return an encoding of the empty list or of",
    "start": "3153090",
    "end": "3159839"
  },
  {
    "text": "course I could go as far as optimizing this whole thing I mean after all why",
    "start": "3159839",
    "end": "3165839"
  },
  {
    "text": "should I encode this empty result over and over again I'll just cache the encoding the final",
    "start": "3165839",
    "end": "3172099"
  },
  {
    "text": "encoding result for the empty bytes and if I detect that there is no data to",
    "start": "3172099",
    "end": "3177240"
  },
  {
    "text": "return I just return the pre calculated results let's look at the results of the",
    "start": "3177240",
    "end": "3183599"
  },
  {
    "text": "benchmark Wow astounding again right I think it was",
    "start": "3183599",
    "end": "3189990"
  },
  {
    "text": "rather obvious that the the second and the third are going to be better so the",
    "start": "3189990",
    "end": "3196260"
  },
  {
    "text": "second is like three times better than the first one but the last one it's",
    "start": "3196260",
    "end": "3201420"
  },
  {
    "text": "basically infinitely better than the first two I mean there's nothing on a",
    "start": "3201420",
    "end": "3206790"
  },
  {
    "text": "computer that runs so little time so it was basically all optimized out like it",
    "start": "3206790",
    "end": "3212400"
  },
  {
    "text": "actually does nothing and that's obviously the best you could hope for and imagine this is your web server",
    "start": "3212400",
    "end": "3219330"
  },
  {
    "text": "which you know has to answer millions of requests per second whatever and this optimization is so easy you could",
    "start": "3219330",
    "end": "3225839"
  },
  {
    "text": "totally go ahead and do it like right now good so in the time that we have",
    "start": "3225839",
    "end": "3230940"
  },
  {
    "text": "left I want to give you some general recommendations like morning on hand-waving the style of more ways you",
    "start": "3230940",
    "end": "3239490"
  },
  {
    "text": "could reduce the stress on your G C in your diet application again we're going",
    "start": "3239490",
    "end": "3246690"
  },
  {
    "text": "to have some real-life examples from Stack Overflow so the first recommendation to you is don't call GC",
    "start": "3246690",
    "end": "3253560"
  },
  {
    "text": "collect yourself okay it's okay if you do it for debugging or testing or",
    "start": "3253560",
    "end": "3259650"
  },
  {
    "text": "whatever but you really need to make sure that you remove it before deploying to production because generally what",
    "start": "3259650",
    "end": "3266490"
  },
  {
    "text": "happens here is that you have a memory problem so we're selling through in self oh okay I'll just go GC kolaks",
    "start": "3266490",
    "end": "3273000"
  },
  {
    "text": "and everything will be okay but you need to trust the CLR the system is just the system that it will call GC collect when",
    "start": "3273000",
    "end": "3280890"
  },
  {
    "text": "it says fit and what you're doing is like putting a patch or like putting band-aids on a bleeding hole in your",
    "start": "3280890",
    "end": "3288690"
  },
  {
    "text": "hand because if you have already a memory problem then calling GC collects will",
    "start": "3288690",
    "end": "3293849"
  },
  {
    "text": "just take up more time if you have a memory problem and will cause more process and more performance degradation",
    "start": "3293849",
    "end": "3299579"
  },
  {
    "text": "for your application instead you should use all the techniques that we discussed today - I know like avoid getting your",
    "start": "3299579",
    "end": "3309390"
  },
  {
    "text": "the hole in your hand or whatever no caching and again we already saw this",
    "start": "3309390",
    "end": "3315509"
  },
  {
    "text": "screenshot from Stack Overflow and the beginning of the of the talk this guy",
    "start": "3315509",
    "end": "3320819"
  },
  {
    "text": "was using a third-party library and the third-party library people thought it",
    "start": "3320819",
    "end": "3326220"
  },
  {
    "text": "was a good idea to call GC collect and just ended up giving more performance",
    "start": "3326220",
    "end": "3331559"
  },
  {
    "text": "problems to this poor guy who is using this library I'm not sure which one as well doesn't really matter",
    "start": "3331559",
    "end": "3338339"
  },
  {
    "text": "here's a funny story in this case what the guy had he had a sort of a",
    "start": "3338339",
    "end": "3344729"
  },
  {
    "text": "producer-consumer kind of thing and this application kept crashing with out of memory exception in a desperate attempt",
    "start": "3344729",
    "end": "3352259"
  },
  {
    "text": "to solve the problem he put GC collect inside his producer cred and that solved",
    "start": "3352259",
    "end": "3360450"
  },
  {
    "text": "the problem okay cool now if you go online and read what he",
    "start": "3360450",
    "end": "3368579"
  },
  {
    "text": "wrote next you would find out that the actual problem he will eventually he",
    "start": "3368579",
    "end": "3374309"
  },
  {
    "text": "solved the mystery they actually dropped the actual problem was that his consumers weren't fast enough and simply",
    "start": "3374309",
    "end": "3382920"
  },
  {
    "text": "weren't fast enough they just couldn't keep up with you know the producers producing the the jobs to do and you",
    "start": "3382920",
    "end": "3390930"
  },
  {
    "text": "know memory would just get filled up so when he pulled GC collects inside his producer said he artificially inserted a",
    "start": "3390930",
    "end": "3398009"
  },
  {
    "text": "delay in producing jobs so I mean you",
    "start": "3398009",
    "end": "3403319"
  },
  {
    "text": "know I put the animal in brackets I don't know if it's fortunate or unfortunate but this is a really good",
    "start": "3403319",
    "end": "3408630"
  },
  {
    "text": "example of how you catch up the problem and you don't see the real root cause",
    "start": "3408630",
    "end": "3413880"
  },
  {
    "text": "and that's what you need to solve so that's a cute example",
    "start": "3413880",
    "end": "3420990"
  },
  {
    "text": "my second recommendation to you is whenever applicable which is the whole",
    "start": "3420990",
    "end": "3426090"
  },
  {
    "text": "we not always prefer value types value types are might be much more efficient",
    "start": "3426090",
    "end": "3433860"
  },
  {
    "text": "to use in case where you have a raise or list of many data structures because of",
    "start": "3433860",
    "end": "3441330"
  },
  {
    "text": "the way they are stored in memory let's first look at the reference reference",
    "start": "3441330",
    "end": "3446610"
  },
  {
    "text": "sites what happens in reference types is that each reference each objects also",
    "start": "3446610",
    "end": "3452430"
  },
  {
    "text": "has an 8 or 16 byte header depending on your business with all the metadata and",
    "start": "3452430",
    "end": "3458730"
  },
  {
    "text": "information that has to store with the objects about the type virtual methods whatever so you have the data itself and",
    "start": "3458730",
    "end": "3465840"
  },
  {
    "text": "then you have the D headers and then of course the array itself is made up of",
    "start": "3465840",
    "end": "3472520"
  },
  {
    "text": "references right through these objects and of course not to mention that now",
    "start": "3472520",
    "end": "3477840"
  },
  {
    "text": "all of this data is not continuous in memory structs on the other hand don't",
    "start": "3477840",
    "end": "3483960"
  },
  {
    "text": "incur any extra cost at all it just backs up continuously in a single chunk",
    "start": "3483960",
    "end": "3491400"
  },
  {
    "text": "in memory so that's good for caching it's good because you don't allocate a",
    "start": "3491400",
    "end": "3497160"
  },
  {
    "text": "lot of stuff you can do many allocations and you don't cause many structures that",
    "start": "3497160",
    "end": "3504060"
  },
  {
    "text": "stress out the GC now so I'm not saying",
    "start": "3504060",
    "end": "3509280"
  },
  {
    "text": "you should always use structs because they do have extra overhead in passing them as function parameters or returning",
    "start": "3509280",
    "end": "3515400"
  },
  {
    "text": "them from functions but if you have a scenario where you lots of calculations on a raise of such objects it's",
    "start": "3515400",
    "end": "3522810"
  },
  {
    "text": "definitely worth considering using the struct like for example if you do image processing that's why we have the point",
    "start": "3522810",
    "end": "3529590"
  },
  {
    "text": "to the example here and this is exactly what happened here in this question",
    "start": "3529590",
    "end": "3536090"
  },
  {
    "text": "someone is implementing a ray tracer in c-sharp I'm not sure why someone would",
    "start": "3536090",
    "end": "3541590"
  },
  {
    "text": "implement a ray tracer in c-sharp over C++ but let's put that aside vectors are",
    "start": "3541590",
    "end": "3547440"
  },
  {
    "text": "used quite a lot in graphics he had very severe",
    "start": "3547440",
    "end": "3553530"
  },
  {
    "text": "memory problems the performance problems in general and they were all fixed once",
    "start": "3553530",
    "end": "3558690"
  },
  {
    "text": "he transformed his vector from being a class to being a struct so again based",
    "start": "3558690",
    "end": "3566490"
  },
  {
    "text": "on a real story next recommendation is complex reference graphs are stressful",
    "start": "3566490",
    "end": "3575490"
  },
  {
    "text": "on your GC they cause more cache misses",
    "start": "3575490",
    "end": "3580560"
  },
  {
    "text": "again like in the case with the array so in general you could replace them with",
    "start": "3580560",
    "end": "3587790"
  },
  {
    "text": "just simple arrays of course it depends on the size and it's true that a nice",
    "start": "3587790",
    "end": "3595380"
  },
  {
    "text": "object area oriented the design would use classes and subclasses and reference",
    "start": "3595380",
    "end": "3601560"
  },
  {
    "text": "and so on but it has a call but it definitely has a cost another very important recommendation is",
    "start": "3601560",
    "end": "3608880"
  },
  {
    "text": "you should make note of finding figuring out what your most expensive or your",
    "start": "3608880",
    "end": "3615600"
  },
  {
    "text": "remote or your largest objects in your application and pull them buffer them",
    "start": "3615600",
    "end": "3621600"
  },
  {
    "text": "reuse them however you can just not to allocate them over and over again there",
    "start": "3621600",
    "end": "3628440"
  },
  {
    "text": "are many objects pool excuse me implementations out there in fact",
    "start": "3628440",
    "end": "3634350"
  },
  {
    "text": "recently I saw that Microsoft uploaded their own to nougat I didn't use it myself but it has like a gazillion",
    "start": "3634350",
    "end": "3640290"
  },
  {
    "text": "downloads so I I guess if you don't have your own object pool just try that one it's going to save you a lot of time",
    "start": "3640290",
    "end": "3647310"
  },
  {
    "text": "another idea you could do especially if you have lots of byte arrays instead of",
    "start": "3647310",
    "end": "3652920"
  },
  {
    "text": "allocating small byte arrays each time you move one you can allocate you can manage the memory on your own you",
    "start": "3652920",
    "end": "3660480"
  },
  {
    "text": "allocate a large buffer to begin with and you kind of let consumers chunks of",
    "start": "3660480",
    "end": "3666210"
  },
  {
    "text": "that of that buffer according to what they need until you just take special",
    "start": "3666210",
    "end": "3671760"
  },
  {
    "text": "note that dealing with sub arrays might cause allocation like copying or",
    "start": "3671760",
    "end": "3678030"
  },
  {
    "text": "whatever and so again there's a library available for you in nougat it's called the system slices and it provides an",
    "start": "3678030",
    "end": "3685770"
  },
  {
    "text": "allocation of three API for dealing with sub-arrays school",
    "start": "3685770",
    "end": "3692030"
  },
  {
    "text": "alright again based on a real story and in fact this one happened to me as well",
    "start": "3692030",
    "end": "3697710"
  },
  {
    "text": "personally so I'm feeling very emotionally connected to this one again",
    "start": "3697710",
    "end": "3702720"
  },
  {
    "text": "from from the graphics area someone who is writing a WPF application and he had",
    "start": "3702720",
    "end": "3708660"
  },
  {
    "text": "to display an image which was updated over time he was using a bitmap source",
    "start": "3708660",
    "end": "3713850"
  },
  {
    "text": "and each time he got new data he created a new bitmap source to display in his",
    "start": "3713850",
    "end": "3719070"
  },
  {
    "text": "application but the truth is that when you have such a scenario what you need",
    "start": "3719070",
    "end": "3724200"
  },
  {
    "text": "to use is something called writable bitmap which provides an API for images",
    "start": "3724200",
    "end": "3732630"
  },
  {
    "text": "that you can update without allocating the pixel buffer again and again you can",
    "start": "3732630",
    "end": "3739350"
  },
  {
    "text": "simply overwrite the pixels whenever you have new data instead of creating the overhead of a new image",
    "start": "3739350",
    "end": "3746570"
  },
  {
    "text": "excuse me and as we all know images these days tend to be quite large",
    "start": "3746570",
    "end": "3753080"
  },
  {
    "text": "the last recommendation I want to give you the final recommendation I want to give you is to avoid the finalization",
    "start": "3753080",
    "end": "3761030"
  },
  {
    "text": "it's true that you can rely on finalization to free up your resources but you don't know when it's going to",
    "start": "3761030",
    "end": "3767820"
  },
  {
    "text": "happen and in fact not only do you not know when it's going to happen there",
    "start": "3767820",
    "end": "3774600"
  },
  {
    "text": "actually might be some weird scenarios that happen with finalization for example since finalization happens on a",
    "start": "3774600",
    "end": "3781320"
  },
  {
    "text": "different thread if you access other objects in your finalizer you might create concurrency problems or there are",
    "start": "3781320",
    "end": "3789030"
  },
  {
    "text": "some other weird scenarios where you can somehow resurrect objects in your",
    "start": "3789030",
    "end": "3795270"
  },
  {
    "text": "finalizer or you could accidentally finalize an object which is being used",
    "start": "3795270",
    "end": "3801090"
  },
  {
    "text": "that's crazy so as much as you can I know it's not always possible but if you",
    "start": "3801090",
    "end": "3807420"
  },
  {
    "text": "can implement a disposable and call dispose manually so that was my final",
    "start": "3807420",
    "end": "3814950"
  },
  {
    "text": "recommendation to you and that's that I hope you learned new ways to optimize",
    "start": "3814950",
    "end": "3822349"
  },
  {
    "text": "your your applications today I know I certainly enjoyed timing all that stuff",
    "start": "3822349",
    "end": "3828369"
  },
  {
    "text": "the results were surprising at times for sure now just one final note I know that the",
    "start": "3828369",
    "end": "3836809"
  },
  {
    "text": "differences in the performance seemed huge but that's because all of my examples were specifically tailored for",
    "start": "3836809",
    "end": "3845289"
  },
  {
    "text": "memory allocation and for the points I was trying to prove obviously not all of",
    "start": "3845289",
    "end": "3850819"
  },
  {
    "text": "your applications are a hundred percent about memory allocation and all of all",
    "start": "3850819",
    "end": "3857479"
  },
  {
    "text": "the some of the stuff that I showed my major code less clear less maintainable",
    "start": "3857479",
    "end": "3864920"
  },
  {
    "text": "so my final recommendation really is detect the critical code path in your",
    "start": "3864920",
    "end": "3871009"
  },
  {
    "text": "code you know how to measure performance you know how to how to profile your",
    "start": "3871009",
    "end": "3877789"
  },
  {
    "text": "applications detect those critical code paths and optimize them if you have a",
    "start": "3877789",
    "end": "3883130"
  },
  {
    "text": "plan node graph keep it in its reference ignorant bliss and you will define thank",
    "start": "3883130",
    "end": "3890749"
  },
  {
    "text": "you so much for coming I hope you enjoyed the rest of the MVC tomorrow and almost on time",
    "start": "3890749",
    "end": "3898350"
  },
  {
    "text": "[Applause]",
    "start": "3898350",
    "end": "3902830"
  }
]