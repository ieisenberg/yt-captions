[
  {
    "start": "0",
    "end": "102000"
  },
  {
    "text": "so basically building contracts for your apis uh making sure uh certain properties of types are met before your",
    "start": "6399",
    "end": "13400"
  },
  {
    "text": "API is invoked and can do stuff at runtime uh the other thing is member detection so basically building your own",
    "start": "13400",
    "end": "20119"
  },
  {
    "text": "type Checkers which verify that certain types have certain properties have certain members have certain subtypes um",
    "start": "20119",
    "end": "27640"
  },
  {
    "text": "then we have algorithm selection so basically will specialize uh a certain algorithm such as an STL algorithm or",
    "start": "27640",
    "end": "34440"
  },
  {
    "text": "one of our own uh based on the type properties that we detect um so we",
    "start": "34440",
    "end": "39760"
  },
  {
    "text": "there's a bunch of examples and I'll show you a couple and uh finally towards the end uh there's a couple of examples",
    "start": "39760",
    "end": "45600"
  },
  {
    "text": "of compile time computation with const exper uh which really allows for uh a",
    "start": "45600",
    "end": "51079"
  },
  {
    "text": "lot simpler u a lot simpler type checking and a lot simpler computation where you'd have to use recursive",
    "start": "51079",
    "end": "57800"
  },
  {
    "text": "templates and a bunch of complex stuff before um I'm going to just be using a lot of",
    "start": "57800",
    "end": "63000"
  },
  {
    "text": "examples and um U most of the stuff I'm doing here requires C++ 11 uh should",
    "start": "63000",
    "end": "69320"
  },
  {
    "text": "work with any C++ 11 conformant compiler maybe uh except for visual C++ which uh",
    "start": "69320",
    "end": "76280"
  },
  {
    "text": "uh still has some incompatibilities um some of the code requires C++ 14 but it can be Rewritten",
    "start": "76280",
    "end": "82560"
  },
  {
    "text": "to only require 11 um and without some features such as deal type which were",
    "start": "82560",
    "end": "88200"
  },
  {
    "text": "introduced in C++ 11 it's quite hard or anyway harder uh to implement some of",
    "start": "88200",
    "end": "93560"
  },
  {
    "text": "the things I'm going to talk about and some are even impossible actually with the uh older version of the standard um",
    "start": "93560",
    "end": "100399"
  },
  {
    "text": "so some motivation and examples uh here's an example of a situation where",
    "start": "100399",
    "end": "105759"
  },
  {
    "start": "102000",
    "end": "102000"
  },
  {
    "text": "uh constrainted checking could actually be useful so if you're sitting in the back you can't even read this whole",
    "start": "105759",
    "end": "111439"
  },
  {
    "text": "thing uh but this is basically what happened when uh I just uh launched xcode built a little C++ project and try",
    "start": "111439",
    "end": "119840"
  },
  {
    "text": "tried to uh use as a map key A type that doesn't have uh the less than operator",
    "start": "119840",
    "end": "127159"
  },
  {
    "text": "right so I built an STD map and the key is a type that doesn't have the less than operator now just declaring a map",
    "start": "127159",
    "end": "134760"
  },
  {
    "text": "like that as you probably know doesn't cause any issues in compilation time however trying to use it so once I try",
    "start": "134760",
    "end": "141640"
  },
  {
    "text": "an insert an element into the map with a certain key that blows up and uh this is",
    "start": "141640",
    "end": "147360"
  },
  {
    "text": "just a very small part of the actual compiler error message that I received but um one thing to note is that um the",
    "start": "147360",
    "end": "155920"
  },
  {
    "text": "error is coming from clang in this case is is pretty decent so it's telling me invalid operan to Binary expression less",
    "start": "155920",
    "end": "162480"
  },
  {
    "text": "than where I am trying to uh invoke less than on values of type const Fu and fu",
    "start": "162480",
    "end": "168640"
  },
  {
    "text": "is the key type in my map which doesn't have the less than operator but then if",
    "start": "168640",
    "end": "173959"
  },
  {
    "text": "you look at some of the further notes emitted by the compiler there's a bunch of nonsense here so why do I care about",
    "start": "173959",
    "end": "181480"
  },
  {
    "text": "something called a tree with a value comparer and um if you look a little uh",
    "start": "181480",
    "end": "187440"
  },
  {
    "text": "lower um it has some ridiculous stuff about not being match not being able to",
    "start": "187440",
    "end": "192920"
  },
  {
    "text": "match the operator less than for pairs of of whatever so if you're an experienced C++ developer you've seen",
    "start": "192920",
    "end": "199840"
  },
  {
    "text": "this era before and you know that you just forgot to declare less than operator or your keys are are invalid uh",
    "start": "199840",
    "end": "206360"
  },
  {
    "text": "but for Less seasoned developers this is very uh Ling and um they can spend a",
    "start": "206360",
    "end": "212040"
  },
  {
    "text": "while you know just posting this thing to to stack Overflow and getting flamed by everyone so uh better error checking",
    "start": "212040",
    "end": "219519"
  },
  {
    "text": "for example in the STL could be really helpful if at compile time we could get a nice error message that says well in",
    "start": "219519",
    "end": "226360"
  },
  {
    "text": "addition to all these other problems um it is likely that what you forgot to do",
    "start": "226360",
    "end": "231439"
  },
  {
    "text": "is just to declare uh less than or specialize STD less for your type and",
    "start": "231439",
    "end": "237480"
  },
  {
    "text": "just move forward um so so the other example I've mentioned is algorithm selection where you have multiple",
    "start": "237480",
    "end": "244079"
  },
  {
    "start": "239000",
    "end": "239000"
  },
  {
    "text": "versions of an algorithm that can be more performant more efficient for certain types uh here's a couple of",
    "start": "244079",
    "end": "250159"
  },
  {
    "text": "classic examples from the STL which uh a lot of STL implementations actually use",
    "start": "250159",
    "end": "255200"
  },
  {
    "text": "so STD copy can be specialized if the thing we are copying is a plain old data",
    "start": "255200",
    "end": "261320"
  },
  {
    "text": "type doesn't have any uh sophisticated assignment behavior and uh you're",
    "start": "261320",
    "end": "266639"
  },
  {
    "text": "copying from pointer ranges not iterators so so if you basically have uh a mem copy situation and you are allowed",
    "start": "266639",
    "end": "274800"
  },
  {
    "text": "to just optimize and use M Copy instead of uh the the slower Loop version of STD",
    "start": "274800",
    "end": "280360"
  },
  {
    "text": "copy that can be uh considerable performance gains for certain types um",
    "start": "280360",
    "end": "285440"
  },
  {
    "text": "another example is STD distance and uh distance as you know finds the number of elements in a range between two",
    "start": "285440",
    "end": "292039"
  },
  {
    "text": "iterators so for certain iterators such as random access iterators it can be",
    "start": "292039",
    "end": "297240"
  },
  {
    "text": "implemented in constant time o of one right and for uh say forward only",
    "start": "297240",
    "end": "303080"
  },
  {
    "text": "iterators you'd have to actually Traverse the iterator so you'd have an O of n a linear time implementation so",
    "start": "303080",
    "end": "309800"
  },
  {
    "text": "that's another example of where uh figuring out some information about the type could help optimize an algorithm",
    "start": "309800",
    "end": "316240"
  },
  {
    "text": "select the right algorithm at compile time and then another example uh as I said is compile time computation so",
    "start": "316240",
    "end": "323240"
  },
  {
    "start": "318000",
    "end": "318000"
  },
  {
    "text": "certain things can be precomputed at compile time or solved entirely at compile time one example that I really",
    "start": "323240",
    "end": "330000"
  },
  {
    "text": "hope to show you towards the end is string validation so if the user provides a literal string as an input to",
    "start": "330000",
    "end": "336720"
  },
  {
    "text": "a certain function we could check that that string has certain properties at compile time instead of throwing an",
    "start": "336720",
    "end": "343319"
  },
  {
    "text": "exception at runtime and for certain apis such as maybe print F right it can",
    "start": "343319",
    "end": "348919"
  },
  {
    "text": "be useful to emit errors as early as possible at compile time instead of deferring to run time so there's a bunch",
    "start": "348919",
    "end": "355080"
  },
  {
    "text": "of users which hopefully illustrate this as a practical thing to talk about even though not the most practical in the",
    "start": "355080",
    "end": "360919"
  },
  {
    "start": "357000",
    "end": "357000"
  },
  {
    "text": "world the main tool we'll be using uh throughout this talk is template specialization so this is just a very",
    "start": "360919",
    "end": "367440"
  },
  {
    "text": "very quick reminder of how this works uh what it looks like so basically here we",
    "start": "367440",
    "end": "372479"
  },
  {
    "text": "have a partial and an explicit complete specialization of the less template so",
    "start": "372479",
    "end": "378240"
  },
  {
    "text": "less uh has an operator that can be invoked as a function and it compares to",
    "start": "378240",
    "end": "383360"
  },
  {
    "text": "uh objects determines which one should be sorted before the other uh we also have a specialization for pointers here",
    "start": "383360",
    "end": "391000"
  },
  {
    "text": "which Compares not the pointers but compares the targets right the Pointes",
    "start": "391000",
    "end": "396240"
  },
  {
    "text": "uh the the things the pointers are pointing to and finally we have a a complete explicit specialization for a",
    "start": "396240",
    "end": "403000"
  },
  {
    "text": "CH pointer where uh we use Str strcmp so we're not comparing the the chars we're",
    "start": "403000",
    "end": "409000"
  },
  {
    "text": "not comparing the pointers either we are comparing the whole string until the null Terminator so that's just the tool",
    "start": "409000",
    "end": "414880"
  },
  {
    "text": "we're going to be using and hopefully you're all uh familiar with that but it's it never hurts to just just see a quick example so let's start with",
    "start": "414880",
    "end": "422319"
  },
  {
    "text": "constraint checking um as you probably know in uh the standard Library there is",
    "start": "422319",
    "end": "427400"
  },
  {
    "start": "423000",
    "end": "423000"
  },
  {
    "text": "a header type traits which has a bunch of useful meta functions which take types and return in some cases values in",
    "start": "427400",
    "end": "435599"
  },
  {
    "text": "some cases uh types meta functions basically operate at compile time on",
    "start": "435599",
    "end": "440840"
  },
  {
    "text": "types and produce either values like bulans uh for example does a type have a",
    "start": "440840",
    "end": "446120"
  },
  {
    "text": "certain property or other types so for example you could have a meta function",
    "start": "446120",
    "end": "451400"
  },
  {
    "text": "that takes a type and adds a reference to it so it produces the same type but with a reference added at the end or",
    "start": "451400",
    "end": "458479"
  },
  {
    "text": "removes const from a type that kind of thing um a lot of these can actually be",
    "start": "458479",
    "end": "463840"
  },
  {
    "text": "implemented pretty easily so if you're looking for exercises on uh on meta functions you can Implement a lot of",
    "start": "463840",
    "end": "470080"
  },
  {
    "text": "these type traits yourself there's a lot of corner cases to take care of but you could um a lot of these however cannot",
    "start": "470080",
    "end": "477240"
  },
  {
    "text": "be implemented without uh actual compiler support so uh the standard Library implementation on a particular",
    "start": "477240",
    "end": "483520"
  },
  {
    "text": "platform would have to ask the compiler for hooks which Implement some of these",
    "start": "483520",
    "end": "488680"
  },
  {
    "text": "uh type traits because there's no way uh to express in the language itself uh checking for that kind of constraint so",
    "start": "488680",
    "end": "496120"
  },
  {
    "text": "some useful examples uh is pointer for example checks if a type is a pointer type and you know it sounds easy but if",
    "start": "496120",
    "end": "503840"
  },
  {
    "text": "you actually look at the implementation you have to take care of uh pointers to functions and pointers to members and",
    "start": "503840",
    "end": "510479"
  },
  {
    "text": "const pointers and pointers to const and a bunch of other edge cases so it's useful to have this in the library uh we",
    "start": "510479",
    "end": "517760"
  },
  {
    "text": "have more complex um more complex traits such as is no throw copy constructible",
    "start": "517760",
    "end": "522800"
  },
  {
    "text": "right so does the type T have a copy Constructor which is marked no except and will not emit exceptions at runtime",
    "start": "522800",
    "end": "530680"
  },
  {
    "text": "um we can use a lot of these and we can develop some of our own type traits based on what's available in the library",
    "start": "530680",
    "end": "537800"
  },
  {
    "text": "and based on other techniques as well so here's a very simple example of using a",
    "start": "537800",
    "end": "543519"
  },
  {
    "start": "541000",
    "end": "541000"
  },
  {
    "text": "type trait this is not a standard Library situation it's just a type I figured I want to develop uh it's a",
    "start": "543519",
    "end": "550360"
  },
  {
    "text": "class called array there's actually STD array in the standard library but suppose that's not what we're seeing",
    "start": "550360",
    "end": "555640"
  },
  {
    "text": "here and uh my array wants to be uh a no throw kind of type A no accept type I",
    "start": "555640",
    "end": "562160"
  },
  {
    "text": "want the Constructor of the array to not throw exceptions I want all the members actually to do the same um and so if in",
    "start": "562160",
    "end": "569519"
  },
  {
    "text": "my array I have a statically allocated array of T's I would like to produce a",
    "start": "569519",
    "end": "576040"
  },
  {
    "text": "clean error message in case that type T does not have a non-throwing default",
    "start": "576040",
    "end": "582399"
  },
  {
    "text": "Constructor so I can mark my own classes Constructor as no accept and that will",
    "start": "582399",
    "end": "588640"
  },
  {
    "text": "produce some error message if T doesn't meet the necessary requirements but I actually want to go further than that",
    "start": "588640",
    "end": "595440"
  },
  {
    "text": "and I want a clean uh assertion that says exactly what happen happened if the user uses an incorrect type um so I can",
    "start": "595440",
    "end": "602800"
  },
  {
    "text": "put a static assertion that uses a standard Library type trait and checks explicitly that t has a default",
    "start": "602800",
    "end": "610279"
  },
  {
    "text": "Constructor a parameterless Constructor which does not throw which is marked no accept um",
    "start": "610279",
    "end": "617240"
  },
  {
    "text": "explicitly another example of using traits in a situation that's not exactly",
    "start": "617240",
    "end": "623480"
  },
  {
    "start": "619000",
    "end": "619000"
  },
  {
    "text": "uh error checking but rather um sort of making sure your implementation is very",
    "start": "623480",
    "end": "628680"
  },
  {
    "text": "accurate is is this example from swap over here so this is STD swap pretty much with",
    "start": "628680",
    "end": "636320"
  },
  {
    "text": "some minor uh changes introduced everyone's familiar with STD swap um and",
    "start": "636320",
    "end": "642240"
  },
  {
    "text": "what it does inside is it tries to use move operations right in case the type T",
    "start": "642240",
    "end": "648079"
  },
  {
    "text": "supports move I wouldn't like to copy uh to a temporary and then copy back from",
    "start": "648079",
    "end": "653480"
  },
  {
    "text": "the temporary I'd rather just do moves all the way and I would like the swap",
    "start": "653480",
    "end": "658560"
  },
  {
    "text": "operator to be marked no accept I would like it um but I'm not actually sure if",
    "start": "658560",
    "end": "664680"
  },
  {
    "text": "the code inside is going to be throwing exceptions or not I don't know in advance whether for example the move",
    "start": "664680",
    "end": "671680"
  },
  {
    "text": "Constructor and the move assignment operator for T are marked no accept or",
    "start": "671680",
    "end": "677320"
  },
  {
    "text": "not so I don't want to emit an error in that case I don't want to place a static assert in my swap that says no you can't",
    "start": "677320",
    "end": "684639"
  },
  {
    "text": "use this swap function if your T is not no accept because that just is plain bad",
    "start": "684639",
    "end": "690720"
  },
  {
    "text": "um instead we could in this case for example use the conditional uh form of the no accept operator so we could say",
    "start": "690720",
    "end": "698320"
  },
  {
    "text": "that okay this function is no accept in case certain properties are met so this",
    "start": "698320",
    "end": "703959"
  },
  {
    "text": "is the no accept operator which takes a Boolean value that has to be known at compile time so my swap is no accept as",
    "start": "703959",
    "end": "711920"
  },
  {
    "text": "long as T has uh no throw a no accept move Constructor and a no accept uh move",
    "start": "711920",
    "end": "719160"
  },
  {
    "text": "assignment operator if these two properties hold then the code I wrote is actually going to be no accept uh",
    "start": "719160",
    "end": "725600"
  },
  {
    "text": "correct um so that's just another use of of constraint checking and type checking",
    "start": "725600",
    "end": "731279"
  },
  {
    "text": "that we could introduce even if not to emit errors but just to make sure we're really expressing ourselves very",
    "start": "731279",
    "end": "738480"
  },
  {
    "text": "accurately okay so suppose we have the basic type traits uh figured out the ones that are in the standard Library uh",
    "start": "738480",
    "end": "745839"
  },
  {
    "text": "but we have a unique situation of our own we have some kind of property of a type that we want to detect uh that we",
    "start": "745839",
    "end": "752320"
  },
  {
    "text": "want to test for one example that I often use in uh in training workshops is",
    "start": "752320",
    "end": "758639"
  },
  {
    "text": "uh is determining whether a certain type is an STL container okay so for example",
    "start": "758639",
    "end": "764279"
  },
  {
    "text": "imagine you're building a serialization framework or maybe just a debug printing",
    "start": "764279",
    "end": "769880"
  },
  {
    "text": "framework that takes an arbitrary object and wants to print it as accurately as possible so if the type already has an",
    "start": "769880",
    "end": "778399"
  },
  {
    "text": "output operator right then I I'll just invoke that um if the type is um a",
    "start": "778399",
    "end": "784519"
  },
  {
    "text": "container I would like to detect its a container and print out the the contents",
    "start": "784519",
    "end": "789639"
  },
  {
    "text": "right print out the elements of the container and do so recursively so this can be useful for serialization can be",
    "start": "789639",
    "end": "796160"
  },
  {
    "text": "useful for uh again debug printouts uh but the question is how is this uh generic template uh print function or",
    "start": "796160",
    "end": "804079"
  },
  {
    "text": "serialized function is going to figure out if our type is a container or not have uh would have to have multiple",
    "start": "804079",
    "end": "811240"
  },
  {
    "text": "implementations and pick the right one but in order to pick we have to ask is",
    "start": "811240",
    "end": "816279"
  },
  {
    "text": "this thing a container so we could go with the formal definitions of what a",
    "start": "816279",
    "end": "821360"
  },
  {
    "text": "container is or maybe a range if you want to work with somewhat newer Concepts um but still it boils down to",
    "start": "821360",
    "end": "828120"
  },
  {
    "text": "asking does a type have certain properties so for example to be very naive I could say a type is a container",
    "start": "828120",
    "end": "835920"
  },
  {
    "text": "if it has a begin member function so you know a bunch of types might have a begin",
    "start": "835920",
    "end": "841800"
  },
  {
    "text": "member functions and not be containers and also arrays are containers but they don't have a member function called",
    "start": "841800",
    "end": "848279"
  },
  {
    "text": "begin but that would be an approximation or I could maybe say a type is a",
    "start": "848279",
    "end": "853800"
  },
  {
    "text": "container if it has uh an a nested type def called iterator right like vector",
    "start": "853800",
    "end": "860480"
  },
  {
    "text": "iterator map iterator and so on so again that wouldn't work for arrays uh but it",
    "start": "860480",
    "end": "866000"
  },
  {
    "text": "would be an approximation and if we wanted to like super accurate we could just ask what do we want to do with that",
    "start": "866000",
    "end": "872560"
  },
  {
    "text": "object if it is a container so the answer is okay if it is a container I want to enumerate all the uh elements in",
    "start": "872560",
    "end": "879720"
  },
  {
    "text": "the container and then I could just test for that directly so can I invoke begin",
    "start": "879720",
    "end": "886160"
  },
  {
    "text": "and get something that looks like an iterator which I can increment and compare and der reference so there's a",
    "start": "886160",
    "end": "892839"
  },
  {
    "text": "bunch of type properties that we want to be checking so uh this happens a lot again if you're building a",
    "start": "892839",
    "end": "899720"
  },
  {
    "text": "uh generic libraries that have to ask for uh that have to care about the",
    "start": "899720",
    "end": "904800"
  },
  {
    "text": "properties of the given type uh sometimes just to reject certain types and in other cases to specialize your",
    "start": "904800",
    "end": "911399"
  },
  {
    "text": "decision based on properties of a type so let's build um something that detects",
    "start": "911399",
    "end": "917360"
  },
  {
    "text": "whether a type is a container there's a bunch of techniques for this um even in C++ 98 we could sort of uh ask if a type",
    "start": "917360",
    "end": "926480"
  },
  {
    "text": "has certain members for example or if a type has certain uh nested type deps but",
    "start": "926480",
    "end": "931560"
  },
  {
    "text": "in C++ 11 with deal type and with a bunch of further advances we have easier solutions for this problem so again we",
    "start": "931560",
    "end": "938399"
  },
  {
    "text": "want to build uh our own type traits which ask does a type have a certain member or more generally does a certain",
    "start": "938399",
    "end": "946519"
  },
  {
    "text": "expression make sense for my type does it compile and even maybe does it",
    "start": "946519",
    "end": "952720"
  },
  {
    "text": "produce uh a certain type as a result so for example not just uh for example for",
    "start": "952720",
    "end": "958160"
  },
  {
    "text": "the direct reference operator on iterators I actually wanted to produce a value if I have a void returning uh the",
    "start": "958160",
    "end": "965519"
  },
  {
    "text": "reference operator that's a little fishy for uh for a container um so we want to",
    "start": "965519",
    "end": "972600"
  },
  {
    "text": "ask if a certain expression makes sense and uh maybe produces a particular type",
    "start": "972600",
    "end": "978000"
  },
  {
    "text": "so there's a very cool uh trick here introduced by Walter Brown I think",
    "start": "978000",
    "end": "984759"
  },
  {
    "text": "a couple of years ago at cppcon I was very impressed um when I saw it first there's a bunch of other ways to express",
    "start": "984759",
    "end": "991360"
  },
  {
    "text": "the same thing but this one is so clean and so concise that I really fell in love with this technique and I've been",
    "start": "991360",
    "end": "996680"
  },
  {
    "text": "telling about it um to people since so uh basically you have this super simple",
    "start": "996680",
    "end": "1003120"
  },
  {
    "text": "and weird looking uh template this is actually a an alas template which",
    "start": "1003120",
    "end": "1009720"
  },
  {
    "text": "defines void t as void for any type right so this is a template you could",
    "start": "1009720",
    "end": "1015920"
  },
  {
    "text": "say void T of int void T of flat void T of St vector and it's always just void",
    "start": "1015920",
    "end": "1022600"
  },
  {
    "text": "it's always defined to be void uh the point is not that it is void the point is that if we try and use this thing if",
    "start": "1022600",
    "end": "1030199"
  },
  {
    "text": "we try and use void t with a type that's not well formed with a type that's not",
    "start": "1030199",
    "end": "1036480"
  },
  {
    "text": "valid um then this thing just has no uh definition the thing doesn't make sense",
    "start": "1036480",
    "end": "1042280"
  },
  {
    "text": "so void T wouldn't be uh sensible whereas if we use any valid type as the",
    "start": "1042280",
    "end": "1047760"
  },
  {
    "text": "template for ameter here we would get a void always just regardless of what we",
    "start": "1047760",
    "end": "1052919"
  },
  {
    "text": "put in um there's alternatives for this in the standard library but it's it's really clean to just see it this way so",
    "start": "1052919",
    "end": "1060280"
  },
  {
    "text": "here's how we use it for uh is container in our example um up top there's the",
    "start": "1060280",
    "end": "1067559"
  },
  {
    "start": "1061000",
    "end": "1061000"
  },
  {
    "text": "first version the the more General version of the is container template and",
    "start": "1067559",
    "end": "1073600"
  },
  {
    "text": "it has two template type parameters T and another one which is unnamed I don't",
    "start": "1073600",
    "end": "1079480"
  },
  {
    "text": "care what it is called and it has a default type parameter value which is which is void so this one is the more",
    "start": "1079480",
    "end": "1087400"
  },
  {
    "text": "generic template it's not a specialization and this one is defined to uh inherit from stood is array of T",
    "start": "1087400",
    "end": "1095840"
  },
  {
    "text": "so basically if we if we go to that uh is container template up top and we ignore everything else on the slide then",
    "start": "1095840",
    "end": "1103039"
  },
  {
    "text": "it's basically equivalent to asking is T an array if T is an array then this uh",
    "start": "1103039",
    "end": "1108480"
  },
  {
    "text": "template recognizes it as a container and if T is not an array then we don't",
    "start": "1108480",
    "end": "1114320"
  },
  {
    "text": "recognize it as a container so we've taken care of arrays uh separately and is array of course is defined in type",
    "start": "1114320",
    "end": "1121400"
  },
  {
    "text": "traits and we assume it works correctly and then we have the specialization um it's occasionally",
    "start": "1121400",
    "end": "1128400"
  },
  {
    "text": "unclear why this thing is even a specialization of the first thing so uh",
    "start": "1128400",
    "end": "1136520"
  },
  {
    "text": "how would you convince your friends um that this second definition is a",
    "start": "1136520",
    "end": "1141679"
  },
  {
    "text": "specialization of the first has fewer type parameters it has",
    "start": "1141679",
    "end": "1147919"
  },
  {
    "text": "fewer type parameters right so uh the one up top has two type parameters even",
    "start": "1147919",
    "end": "1153200"
  },
  {
    "text": "though the second one has a default value but the one uh on the bottom only has one type parameter so that's that's",
    "start": "1153200",
    "end": "1159960"
  },
  {
    "text": "enough for me I suppose um and uh this is container template is a",
    "start": "1159960",
    "end": "1166120"
  },
  {
    "text": "specialization in case uh well T the first argument is just the T we got",
    "start": "1166120",
    "end": "1172400"
  },
  {
    "text": "passed in and the second thing the second type parameter which has a",
    "start": "1172400",
    "end": "1177799"
  },
  {
    "text": "default value of void over here the second type parameter is that void T",
    "start": "1177799",
    "end": "1182880"
  },
  {
    "text": "template specialized well sorry parameterized with uh T iterator right",
    "start": "1182880",
    "end": "1189360"
  },
  {
    "text": "with the nested iterator type Def and if we use this specialization then I just",
    "start": "1189360",
    "end": "1196159"
  },
  {
    "text": "inherit from uh stood true type to indicate that yes we are a container so",
    "start": "1196159",
    "end": "1201520"
  },
  {
    "text": "basically if this specialization is chosen then we deduced that t is a",
    "start": "1201520",
    "end": "1208039"
  },
  {
    "text": "container okay so for this specialization to be chosen what needs",
    "start": "1208039",
    "end": "1213640"
  },
  {
    "text": "to happen is that void T of that type is",
    "start": "1213640",
    "end": "1219600"
  },
  {
    "text": "well formed if it is not if our type is for example an INT then what we have",
    "start": "1219600",
    "end": "1225840"
  },
  {
    "text": "over here is just int colon colon iterator that doesn't make sense that's",
    "start": "1225840",
    "end": "1231240"
  },
  {
    "text": "not well formed and then uh substitution failure kicks in and we just ignore this",
    "start": "1231240",
    "end": "1237080"
  },
  {
    "text": "specialization and we have our base case which will then deduce that int because",
    "start": "1237080",
    "end": "1242360"
  },
  {
    "text": "it's not an array is not a container but if T does have a nested iterator type",
    "start": "1242360",
    "end": "1249120"
  },
  {
    "text": "def then this thing over here is well formed and this is just plain void right",
    "start": "1249120",
    "end": "1257000"
  },
  {
    "text": "and then this is a specialization of the previous case and this specialization is a better match so the compiler when",
    "start": "1257000",
    "end": "1264000"
  },
  {
    "text": "doing the the template specialization pattern matching would pick this version and deduce that our type is a container",
    "start": "1264000",
    "end": "1271559"
  },
  {
    "text": "because we inherited from True type why uh just one final thing um why",
    "start": "1271559",
    "end": "1277440"
  },
  {
    "text": "does it matter that this here is void why did they put void in here and",
    "start": "1277440",
    "end": "1283039"
  },
  {
    "text": "not something else",
    "start": "1283039",
    "end": "1289919"
  },
  {
    "text": "everyone's looking to for for the same person to answer so with vo you have to have a",
    "start": "1289919",
    "end": "1297279"
  },
  {
    "text": "outcome and W brown was saying doesn't matter what it returns as long as it returns something the same every time",
    "start": "1297279",
    "end": "1304480"
  },
  {
    "text": "that's why equals whatever return yeah no so what I'm asking is why is does",
    "start": "1304480",
    "end": "1310840"
  },
  {
    "text": "this have to be void and not say int right because that's the type because the type of VO returns is yes because",
    "start": "1310840",
    "end": "1317840"
  },
  {
    "text": "this it has to be void and U the thing that happens is if the user of my",
    "start": "1317840",
    "end": "1323799"
  },
  {
    "text": "template of this container doesn't provide the second type right so my user says is container of int the user",
    "start": "1323799",
    "end": "1331919"
  },
  {
    "text": "doesn't specify what the second type is so if the user says is container of int",
    "start": "1331919",
    "end": "1336960"
  },
  {
    "text": "I would like both versions to be potential candidates so uh in this case",
    "start": "1336960",
    "end": "1343320"
  },
  {
    "text": "um is container the first version would be is container of T and void and this",
    "start": "1343320",
    "end": "1348480"
  },
  {
    "text": "one would be is container of T and whatever void T produces so if void T produces void we have our two candidates",
    "start": "1348480",
    "end": "1355600"
  },
  {
    "text": "and the more the more specialized one can be picked but if here I said int for",
    "start": "1355600",
    "end": "1361159"
  },
  {
    "text": "example then when the user says is container of whatever then what the user",
    "start": "1361159",
    "end": "1366279"
  },
  {
    "text": "actually said is is container whatever comma comma int right and then the",
    "start": "1366279",
    "end": "1372000"
  },
  {
    "text": "second specialization would just never be valid because uh void T doesn't produce an INT it produces void so all",
    "start": "1372000",
    "end": "1378440"
  },
  {
    "text": "the parts here matter right it does matter that we have void up there it matters that void T returns void um",
    "start": "1378440",
    "end": "1386320"
  },
  {
    "text": "everything's important in this uh in this uh skeleton if you will for uh",
    "start": "1386320",
    "end": "1391360"
  },
  {
    "text": "member detection now you might ask can this be generalized further and yes it",
    "start": "1391360",
    "end": "1397480"
  },
  {
    "text": "can so here we're just testing if a type has a certain uh nested type def uh but",
    "start": "1397480",
    "end": "1403799"
  },
  {
    "text": "we can make this further uh uh generic if you will so if I want to test that a",
    "start": "1403799",
    "end": "1409919"
  },
  {
    "start": "1404000",
    "end": "1404000"
  },
  {
    "text": "certain expression arbitrary expression pretty much on arbitrary types makes",
    "start": "1409919",
    "end": "1415360"
  },
  {
    "text": "sense and that's the trait I am checking for that's the property I'm testing for then the general recipe would be we uh",
    "start": "1415360",
    "end": "1422919"
  },
  {
    "text": "Define an alas template for that specific test and it's basically just the deal type of whatever this",
    "start": "1422919",
    "end": "1429720"
  },
  {
    "text": "expression returns so suppose I want to check if uh T1 has a member function",
    "start": "1429720",
    "end": "1436120"
  },
  {
    "text": "called Fu which takes a at T2 right so I have this alas template which is a",
    "start": "1436120",
    "end": "1441720"
  },
  {
    "text": "template in T1 and T2 and it is declared as the deal type of this expression here",
    "start": "1441720",
    "end": "1447600"
  },
  {
    "text": "which declares a value of type T1 reference and then invokes Fu on it passing in a T2 right and the decal Val",
    "start": "1447600",
    "end": "1456440"
  },
  {
    "text": "function it's just a very stupid silly little function from the standard Library it has no body it's just a",
    "start": "1456440",
    "end": "1462200"
  },
  {
    "text": "declaration because we use it in contexts which do not require evaluation so it's basically just declaring T1 for",
    "start": "1462200",
    "end": "1468960"
  },
  {
    "text": "us or T2 for us um that's the only thing we care about um once we have that test",
    "start": "1468960",
    "end": "1474919"
  },
  {
    "text": "we just plug it into our skeleton so uh this the the generic version of does my",
    "start": "1474919",
    "end": "1482440"
  },
  {
    "text": "condition uh is my condition true for a certain pair of types um the one over",
    "start": "1482440",
    "end": "1488360"
  },
  {
    "text": "here the generic version takes T1 and T2 and that uh dummy void uh template",
    "start": "1488360",
    "end": "1494520"
  },
  {
    "text": "parameter and the specialization takes T1 and T2 and whatever void T returns",
    "start": "1494520",
    "end": "1500720"
  },
  {
    "text": "when invoked with my test which is up there so if that expression makes sense",
    "start": "1500720",
    "end": "1506000"
  },
  {
    "text": "if this thing here is well formed then void T produces void and we pick the second specialization and if it is not",
    "start": "1506000",
    "end": "1513080"
  },
  {
    "text": "well formed then we pick the first one and we reject uh that property and we could even test if we wanted that my",
    "start": "1513080",
    "end": "1521000"
  },
  {
    "text": "test T is not just well formed we could ask what kind of thing it is so I could",
    "start": "1521000",
    "end": "1527159"
  },
  {
    "text": "add uh for example over here I could add so is my test T of T1 and T2 actually",
    "start": "1527159",
    "end": "1534799"
  },
  {
    "text": "say an INT or a const reference or whatever else I wanted to assert um so",
    "start": "1534799",
    "end": "1541440"
  },
  {
    "text": "we basically have now a a generic recipe for checking properties of uh um of",
    "start": "1541440",
    "end": "1546760"
  },
  {
    "text": "types thanks to this void T trick um this uh again it requires compiler",
    "start": "1546760",
    "end": "1552440"
  },
  {
    "text": "support so for example my uh my usual goto compiler again which is visual C",
    "start": "1552440",
    "end": "1557640"
  },
  {
    "text": "C++ still has some restrictions around uh expression substitution failure is not an error Expressions Fini so uh it",
    "start": "1557640",
    "end": "1565320"
  },
  {
    "text": "would actually reject a bunch of these examples but the more conforming compilers GCC clang uh they're they're",
    "start": "1565320",
    "end": "1571679"
  },
  {
    "text": "okay uh with this and Microsoft is working on fixing the uh The Edge C",
    "start": "1571679",
    "end": "1577000"
  },
  {
    "text": "cases that still don't work and actually this kind of uh template is pretty useful in the standard Library as well",
    "start": "1577000",
    "end": "1584039"
  },
  {
    "text": "so just as an example in the standard Library there is a type trait called is",
    "start": "1584039",
    "end": "1589320"
  },
  {
    "text": "assignable which just determines whether one type can be assigned to another",
    "start": "1589320",
    "end": "1594399"
  },
  {
    "text": "using the assignment operator you could easily implement it using this uh uh",
    "start": "1594399",
    "end": "1600720"
  },
  {
    "text": "generic trick right so um over here in the deal typ body we would have just a",
    "start": "1600720",
    "end": "1607080"
  },
  {
    "text": "you know deal Val a uh assignment deal Val B and we'd have to test if that is",
    "start": "1607080",
    "end": "1613399"
  },
  {
    "text": "well formed um so standard libraries all over the world can now use this instead",
    "start": "1613399",
    "end": "1619559"
  },
  {
    "text": "of requiring compiler hooks or uh you know some sophisticated uh oneoff uh",
    "start": "1619559",
    "end": "1624840"
  },
  {
    "text": "tricks there's just a generic trick that works for all the cases so that was member detection and",
    "start": "1624840",
    "end": "1632320"
  },
  {
    "text": "um once we have that let's talk about some um um ways right some strategies",
    "start": "1632320",
    "end": "1638000"
  },
  {
    "text": "for actually using the property we we discovered for choosing one of multiple",
    "start": "1638000",
    "end": "1643919"
  },
  {
    "text": "algorithms again if we want to optimize STD copy for for example for uh pointers",
    "start": "1643919",
    "end": "1649880"
  },
  {
    "text": "to primitive types as opposed to the general case of just iterators we know nothing about so there's three General",
    "start": "1649880",
    "end": "1657399"
  },
  {
    "start": "1657000",
    "end": "1657000"
  },
  {
    "text": "strategies I want to show you which are common in a bunch of different template",
    "start": "1657399",
    "end": "1662760"
  },
  {
    "text": "libraries including the STL one is just explicit specialization when you write",
    "start": "1662760",
    "end": "1668120"
  },
  {
    "text": "all the boilerplate yourself the other is tag dispatch which is useful and used a lot in the in the STL where you have",
    "start": "1668120",
    "end": "1675000"
  },
  {
    "text": "multiple versions of an algorithm so basically basically the property you're testing is not binary true or false it",
    "start": "1675000",
    "end": "1681240"
  },
  {
    "text": "has multiple uh degrees of of being true and there's also stood enable if which",
    "start": "1681240",
    "end": "1688120"
  },
  {
    "text": "is usually used if you want to disable a certain function if you want to remove a certain function from the set of",
    "start": "1688120",
    "end": "1694120"
  },
  {
    "text": "overloads that you would want the compiler to consider so let's take a look at a few examples again just an",
    "start": "1694120",
    "end": "1699799"
  },
  {
    "text": "overview of the tricks that a lot of libraries use so this uh rather verbose",
    "start": "1699799",
    "end": "1706360"
  },
  {
    "start": "1702000",
    "end": "1702000"
  },
  {
    "text": "uh thing on the screen is an attempt to uh specialize the sort",
    "start": "1706360",
    "end": "1712159"
  },
  {
    "text": "implementation uh just a general sort that takes iterators um for two cases um one when",
    "start": "1712159",
    "end": "1720600"
  },
  {
    "text": "the type we're sorting just has General properties uh is generally comparable right so it has a less than operator",
    "start": "1720600",
    "end": "1728080"
  },
  {
    "text": "which provides order and the other case is if it's hashable if there is a way to",
    "start": "1728080",
    "end": "1733200"
  },
  {
    "text": "produce hashes from um values of that type so if it is hashable maybe I'm",
    "start": "1733200",
    "end": "1739559"
  },
  {
    "text": "going to use a different sort algorithm like radic sort and if it's not hashable I'm going to use something else it's",
    "start": "1739559",
    "end": "1746320"
  },
  {
    "text": "just an example I'm not saying there's a practical use of this kind of sort implementation but we want to ask about",
    "start": "1746320",
    "end": "1752039"
  },
  {
    "text": "a property of the type and then uh just redirect to two different",
    "start": "1752039",
    "end": "1757120"
  },
  {
    "text": "implementations so I can have uh this base case um of A Sort imple class",
    "start": "1757120",
    "end": "1762960"
  },
  {
    "text": "template which is undefined basically I don't care about it because I am going to have specializations for both of the",
    "start": "1762960",
    "end": "1769679"
  },
  {
    "text": "cases so this base uh template is a template of some type and the Boolean",
    "start": "1769679",
    "end": "1776840"
  },
  {
    "text": "and then I have two specializations I have one for some type and false and",
    "start": "1776840",
    "end": "1783120"
  },
  {
    "text": "another for some type and true so I basically covered all all the cases",
    "start": "1783120",
    "end": "1789279"
  },
  {
    "text": "because booleans can be either true or false um so there shouldn't be any case where we actually get to the base",
    "start": "1789279",
    "end": "1796080"
  },
  {
    "text": "template and the compiler would complain that we haven't actually defined it so for false I have one definition of a",
    "start": "1796080",
    "end": "1803000"
  },
  {
    "text": "static sort function and for true I have a different definition of a of a static",
    "start": "1803000",
    "end": "1808679"
  },
  {
    "text": "sort function so basically this is just a way of picking overloads at compile time I have two functions in two",
    "start": "1808679",
    "end": "1815279"
  },
  {
    "text": "different class templates and I'm choosing the right one based on whether some property is true or false at",
    "start": "1815279",
    "end": "1821559"
  },
  {
    "text": "compile time so now I just have to ask uh is that property true and redirect to",
    "start": "1821559",
    "end": "1827640"
  },
  {
    "text": "one of the options so in in this uh version which is the the publicly",
    "start": "1827640",
    "end": "1832880"
  },
  {
    "text": "accessible one that's the thing that clients actually invoke in this version",
    "start": "1832880",
    "end": "1838080"
  },
  {
    "text": "I uh specialize sort imple I parameterize sort imple by whether uh",
    "start": "1838080",
    "end": "1845200"
  },
  {
    "text": "the value type of that iterator has some property so is hashable V that's not a",
    "start": "1845200",
    "end": "1852200"
  },
  {
    "text": "standard Library thing but it's a type trait that we uh built right using the tech techniques we talked about",
    "start": "1852200",
    "end": "1858399"
  },
  {
    "text": "previously so sort imple of my iterator type and either true or false just picks",
    "start": "1858399",
    "end": "1866039"
  },
  {
    "text": "one of the two uh class template specializations we had over here and",
    "start": "1866039",
    "end": "1871799"
  },
  {
    "text": "then I invoke the static sort method on that passing in my iterators so we have just successfully picked one of two",
    "start": "1871799",
    "end": "1878559"
  },
  {
    "text": "implementations based on a Boolean property of some type um this is a bit",
    "start": "1878559",
    "end": "1884240"
  },
  {
    "text": "verbose uh but it works and um in some cases you might actually prefer",
    "start": "1884240",
    "end": "1889880"
  },
  {
    "text": "it for example if that type that you're using actually has to have some State",
    "start": "1889880",
    "end": "1895720"
  },
  {
    "text": "and member functions it's actually useful to just pick one of multiple uh class template specializations and then",
    "start": "1895720",
    "end": "1902600"
  },
  {
    "text": "just work with that class template kind of like the strategy pattern except you're doing it in compile time and not",
    "start": "1902600",
    "end": "1909240"
  },
  {
    "text": "at runtime and this can be obviously expanded uh further to a bunch of additional",
    "start": "1909240",
    "end": "1914880"
  },
  {
    "text": "examples the other alternative which is is uh pretty common in the standard library is tag dispatch uh this doesn't",
    "start": "1914880",
    "end": "1921799"
  },
  {
    "start": "1916000",
    "end": "1916000"
  },
  {
    "text": "require class template specialization uh just uh multiple overloads of a certain",
    "start": "1921799",
    "end": "1927559"
  },
  {
    "text": "function and the overloads are different only by usually a trailing type which",
    "start": "1927559",
    "end": "1933960"
  },
  {
    "text": "can take multiple uh type values so here's a classic example from distance",
    "start": "1933960",
    "end": "1939919"
  },
  {
    "text": "this is an STD algorithm that finds the distance between two iterators right uh how many",
    "start": "1939919",
    "end": "1946080"
  },
  {
    "text": "elements are in the range between two iterators so this is the um publicly",
    "start": "1946080",
    "end": "1951240"
  },
  {
    "text": "accessible declaration so distance takes two iterators what it returns is uh well",
    "start": "1951240",
    "end": "1959120"
  },
  {
    "text": "whatever iterator traits difference type is for my iterator type so conveniently",
    "start": "1959120",
    "end": "1965760"
  },
  {
    "text": "we have iterator traits which is supposed to tell us things about iterators this is yet another example of",
    "start": "1965760",
    "end": "1971720"
  },
  {
    "text": "a meta function that takes types and returns uh values and types for us",
    "start": "1971720",
    "end": "1977600"
  },
  {
    "text": "and then I I invoke uh distance helper which is not a publicly accessible interface and distance helper takes the",
    "start": "1977600",
    "end": "1985159"
  },
  {
    "text": "two iterators first and last as well as an additional parameter and this one is",
    "start": "1985159",
    "end": "1990440"
  },
  {
    "text": "also obtained from iterator traits so in iterator traits I have iterator category",
    "start": "1990440",
    "end": "1996159"
  },
  {
    "text": "which is a type so I instantiate that type over here and that's what I passed",
    "start": "1996159",
    "end": "2001880"
  },
  {
    "text": "to distance helper so now distance helper can be overloaded for various",
    "start": "2001880",
    "end": "2008200"
  },
  {
    "text": "types that iterator category can return just for Simplicity suppose iterator",
    "start": "2008200",
    "end": "2014039"
  },
  {
    "text": "category is sometimes an INT and sometimes a float so I can now build two",
    "start": "2014039",
    "end": "2020480"
  },
  {
    "text": "distance helpers one that takes an INT and one that takes a float as the third",
    "start": "2020480",
    "end": "2026240"
  },
  {
    "text": "parameter and in such a way specialize my implementation um iterator category",
    "start": "2026240",
    "end": "2031919"
  },
  {
    "text": "fortunately doesn't return int or float it's a meta function that returns one of",
    "start": "2031919",
    "end": "2036960"
  },
  {
    "text": "multiple types indicating what kind of iterators we have in our hands right so it could be a forward iterator an input",
    "start": "2036960",
    "end": "2044440"
  },
  {
    "text": "iterator uh bit directional iterator random access iterator and so on and um",
    "start": "2044440",
    "end": "2051200"
  },
  {
    "start": "2051000",
    "end": "2051000"
  },
  {
    "text": "here's what the U actual helper could look like so for Random Access iterator tag",
    "start": "2051200",
    "end": "2060240"
  },
  {
    "text": "which is the iterator category for random access iterators my implementation just uses uh the minus",
    "start": "2060240",
    "end": "2068158"
  },
  {
    "text": "operator right so um we just find the distance between the two",
    "start": "2068159",
    "end": "2073638"
  },
  {
    "text": "iterators and for anything else this is the second version of distance helper it",
    "start": "2073639",
    "end": "2079560"
  },
  {
    "text": "takes iterator tag base which is the base class of all the other iterator categories of all the iterator",
    "start": "2079560",
    "end": "2085638"
  },
  {
    "text": "categories so for um for iterator tag base we have this implementation here",
    "start": "2085639",
    "end": "2091079"
  },
  {
    "text": "which declares a counter and then just traverses the range incrementing the",
    "start": "2091079",
    "end": "2096440"
  },
  {
    "text": "counter till we reach last right so while first is not last increment last",
    "start": "2096440",
    "end": "2101800"
  },
  {
    "text": "increment n till we uh get to the end and then return n so this is going to be",
    "start": "2101800",
    "end": "2106960"
  },
  {
    "text": "the linear time version and that's going to be hopefully a constant time version and we just used a property a type",
    "start": "2106960",
    "end": "2114000"
  },
  {
    "text": "property uh returned by iterator category to choose one of the two so",
    "start": "2114000",
    "end": "2119800"
  },
  {
    "text": "that's a pretty common technique as well and a third example I want to show you is",
    "start": "2119800",
    "end": "2125800"
  },
  {
    "start": "2124000",
    "end": "2124000"
  },
  {
    "text": "enable",
    "start": "2125800",
    "end": "2128800"
  },
  {
    "text": "just like a lot of classes and it also has uh this Constructor over here which",
    "start": "2184079",
    "end": "2190680"
  },
  {
    "text": "takes a universal reference to any T and the reason you'd usually have that kind",
    "start": "2190680",
    "end": "2197280"
  },
  {
    "text": "of Constructor does it work now okay um so the reason you'd usually have that kind of Constructor which takes a",
    "start": "2197280",
    "end": "2203760"
  },
  {
    "text": "universal reference is not uh to emulate a copy Constructor and a move Constructor on your own type but rather",
    "start": "2203760",
    "end": "2210760"
  },
  {
    "text": "to enable construction from some other type so for example maybe my widget it",
    "start": "2210760",
    "end": "2215800"
  },
  {
    "text": "can actually be um constructed from uh for example a topple of configuration",
    "start": "2215800",
    "end": "2222240"
  },
  {
    "text": "values and I want to optimize for two cases one when I am passed an R value",
    "start": "2222240",
    "end": "2227280"
  },
  {
    "text": "reference which I can move from and the other when I'm passed a const reference to an L value which I can only copy from",
    "start": "2227280",
    "end": "2234480"
  },
  {
    "text": "that's a pretty common situation but uh ignore even ignore the reason why I",
    "start": "2234480",
    "end": "2239599"
  },
  {
    "text": "actually have that kind of a templated Constructor the issue here is hiding",
    "start": "2239599",
    "end": "2244839"
  },
  {
    "text": "what can happen is that if my if the user of my widget class initializes a",
    "start": "2244839",
    "end": "2250319"
  },
  {
    "text": "widget and uses an lalue reference to a widget which is not const so basically",
    "start": "2250319",
    "end": "2256640"
  },
  {
    "text": "just widget Ampersand right an L value reference to a widget which isn't const",
    "start": "2256640",
    "end": "2262440"
  },
  {
    "text": "then the compiler can choose between my copy Constructor which takes a const",
    "start": "2262440",
    "end": "2268079"
  },
  {
    "text": "reference to a widget and this template Constructor which was never intended",
    "start": "2268079",
    "end": "2273640"
  },
  {
    "text": "where for situations where T is a widget but it would apply in that case and it",
    "start": "2273640",
    "end": "2279880"
  },
  {
    "text": "would be picked because this Constructor Works where uh where the T ref ref",
    "start": "2279880",
    "end": "2286480"
  },
  {
    "text": "actually resolves to just a widget M perent to an L value reference to a widget so we have a Constructor that",
    "start": "2286480",
    "end": "2292640"
  },
  {
    "text": "takes a const reference and a Constructor which takes a a non-const reference and that second Constructor",
    "start": "2292640",
    "end": "2298920"
  },
  {
    "text": "would be preferred so essentially we built a universal Constructor which hides our own copy Constructor this is",
    "start": "2298920",
    "end": "2305520"
  },
  {
    "text": "undesirable so we can ask um the compiler essentially to not pick um that",
    "start": "2305520",
    "end": "2313839"
  },
  {
    "text": "specific overload that specific Constructor if uh I'm using a widget as",
    "start": "2313839",
    "end": "2319560"
  },
  {
    "text": "T so the way this typically works is that",
    "start": "2319560",
    "end": "2326000"
  },
  {
    "text": "somewhere in the signature and there's a lot of places you could actually put that in the signature somewhere in the",
    "start": "2326000",
    "end": "2332079"
  },
  {
    "text": "signature you put enable if and enable if is a is is very similar to void T",
    "start": "2332079",
    "end": "2338800"
  },
  {
    "text": "actually it just determines whether an expression is well formed and then it's used um for substitution failure to",
    "start": "2338800",
    "end": "2345839"
  },
  {
    "text": "remove that overload from the set of overloads that can be considered so in this case the expression I'm passing to",
    "start": "2345839",
    "end": "2352240"
  },
  {
    "text": "an able if is not is same T widget",
    "start": "2352240",
    "end": "2358040"
  },
  {
    "text": "reference value so basically a Boolean which says whether or not t is the same",
    "start": "2358040",
    "end": "2364400"
  },
  {
    "text": "thing as an L value reference to a widget so if T is the same thing as an L",
    "start": "2364400",
    "end": "2370040"
  },
  {
    "text": "value reference to a widget this expression because of the not here this expression is going to be false and then",
    "start": "2370040",
    "end": "2376359"
  },
  {
    "text": "we have enable if of false and enable if of false is not defined so it's not a",
    "start": "2376359",
    "end": "2384880"
  },
  {
    "text": "type it's not any type whereas enable if of true is void kind of like our void t",
    "start": "2384880",
    "end": "2392800"
  },
  {
    "text": "uh template so in the case where enable if if T here produces void this template",
    "start": "2392800",
    "end": "2399839"
  },
  {
    "text": "overload is considered valid and in the case we're enable if T takes false and",
    "start": "2399839",
    "end": "2406040"
  },
  {
    "text": "it is undefined this Constructor is just removed from the set of candidates",
    "start": "2406040",
    "end": "2411119"
  },
  {
    "text": "because it is a substitution failure uh when trying to match the template arguments the template type arguments um",
    "start": "2411119",
    "end": "2418440"
  },
  {
    "text": "you could place that enable if in a bunch additional places maybe in uh when",
    "start": "2418440",
    "end": "2423480"
  },
  {
    "text": "reviewing template libraries you might have see enable if um as an additional",
    "start": "2423480",
    "end": "2429800"
  },
  {
    "text": "parameter right so in some cases you put it as an additional parameter which has a default null value um you could use",
    "start": "2429800",
    "end": "2437240"
  },
  {
    "text": "enable if as the return type not in a Constructor though Constructors can't",
    "start": "2437240",
    "end": "2442960"
  },
  {
    "text": "have declared return types but in other functions you could use enable ift as the return type um again just to get the",
    "start": "2442960",
    "end": "2450160"
  },
  {
    "text": "compiler to consider that type as part of the function's signature and again if",
    "start": "2450160",
    "end": "2455800"
  },
  {
    "text": "it doesn't doesn't uh match then this uh uh signature that overload is removed",
    "start": "2455800",
    "end": "2461640"
  },
  {
    "text": "from the set of candidates that the compiler would consider so in this way we could just disable this overload in",
    "start": "2461640",
    "end": "2468359"
  },
  {
    "text": "certain circumstances and this trick is used a lot in dstl",
    "start": "2468359",
    "end": "2473960"
  },
  {
    "text": "yeah is is there a way to apply what what do you",
    "start": "2478800",
    "end": "2485240"
  },
  {
    "text": "mean template VD and had a copy Constructor",
    "start": "2485240",
    "end": "2492400"
  },
  {
    "text": "and a move Constructor okay and you wanted it to choose the copy Constructor",
    "start": "2492400",
    "end": "2498160"
  },
  {
    "text": "in the cases where it was copying if you there's a as you said the",
    "start": "2498160",
    "end": "2503880"
  },
  {
    "text": "move Constructor will always be preferred if it's a nonon no so if you if you declare a copy",
    "start": "2503880",
    "end": "2510480"
  },
  {
    "text": "Constructor and the move Constructor then the move Constructor will be chosen if you have an R value reference if you",
    "start": "2510480",
    "end": "2515880"
  },
  {
    "text": "have a reference to a temporary if you have a reference to an L value then the",
    "start": "2515880",
    "end": "2521280"
  },
  {
    "text": "copy Constructor will always be chosen automatically just think about it your move Constructor is going to be moving",
    "start": "2521280",
    "end": "2527119"
  },
  {
    "text": "so it's going to destroy the object if you have an L value that would be extremely unsafe you don't need this uh",
    "start": "2527119",
    "end": "2533440"
  },
  {
    "text": "trick at all if you just declare a copy Constructor and a move Constructor and you want the compiler to pick so in that",
    "start": "2533440",
    "end": "2538839"
  },
  {
    "text": "case ites coll refence it it was not what so it doesn't collapse to just a",
    "start": "2538839",
    "end": "2544040"
  },
  {
    "text": "reference in thate if you so you're you're saying no template here no Universal reference just a copy",
    "start": "2544040",
    "end": "2550280"
  },
  {
    "text": "Constructor and a move Constructor right I'm saying the class is template oh that's fine and the constructors what do",
    "start": "2550280",
    "end": "2557040"
  },
  {
    "text": "they take do they take widgets or do they take the one of the template arguments H type name so you still have",
    "start": "2557040",
    "end": "2565319"
  },
  {
    "text": "univalence but just one Constructor both a copy and but they're not a copy and a move Constructor if",
    "start": "2565319",
    "end": "2572119"
  },
  {
    "text": "they don't take the exact type right so if you have a Constructor that takes for",
    "start": "2572119",
    "end": "2577319"
  },
  {
    "text": "example in this class if I had a Constructor that takes an INT you wouldn't say that's a copy Constructor",
    "start": "2577319",
    "end": "2582400"
  },
  {
    "text": "or a move Constructor that's just yet another Constructor so if this thing was a template of whatever and you had a",
    "start": "2582400",
    "end": "2589359"
  },
  {
    "text": "Constructor taking whatever and not widget of whatever that's not a copy in our a move Constructor that's just yet",
    "start": "2589359",
    "end": "2595559"
  },
  {
    "text": "another Constructor yeah hopefully that clears things",
    "start": "2595559",
    "end": "2601280"
  },
  {
    "text": "up okay um so we do have a few minutes left so I want to show you real quick",
    "start": "2601280",
    "end": "2606480"
  },
  {
    "text": "just one more example of using um sort of the same techniques for a slightly different scenario for uh compile time",
    "start": "2606480",
    "end": "2614119"
  },
  {
    "text": "computation and first I just want to make sure uh we're all familiar with con exper so basically in uh the good old",
    "start": "2614119",
    "end": "2621599"
  },
  {
    "start": "2619000",
    "end": "2619000"
  },
  {
    "text": "days uh to perform compile time computation you'd have to do stuff like that with recursive templates that's",
    "start": "2621599",
    "end": "2627720"
  },
  {
    "text": "just a classical example I'm sure you've all seen that thing so for example here I'm calculating factorial by having U an",
    "start": "2627720",
    "end": "2635319"
  },
  {
    "text": "um a class template specialization for size T where uh the base case is defined",
    "start": "2635319",
    "end": "2642880"
  },
  {
    "text": "as one and then uh all the other cases are recursively invoking that uh class",
    "start": "2642880",
    "end": "2648800"
  },
  {
    "text": "template until it's specialized down to zero um so first of all we can replace a",
    "start": "2648800",
    "end": "2655599"
  },
  {
    "text": "lot of these recursive templates with const exper which was introduced in C++ 11 um so when applied to a function con",
    "start": "2655599",
    "end": "2663920"
  },
  {
    "text": "xer means that in some cas the value that this function returns can",
    "start": "2663920",
    "end": "2668960"
  },
  {
    "text": "be obtained at compile time so you don't have to actually invoke it at runtime you can just uh sort of run through that",
    "start": "2668960",
    "end": "2676160"
  },
  {
    "text": "function at compile time and get the output um so here's factorial as just a",
    "start": "2676160",
    "end": "2681880"
  },
  {
    "text": "conext per function and obviously the advantage here is that even though the thing is calculated at compile time you",
    "start": "2681880",
    "end": "2688599"
  },
  {
    "text": "still specify it exactly the same way as any other function that would be calculated at runtime furthermore you",
    "start": "2688599",
    "end": "2695280"
  },
  {
    "text": "could use that factorial function with values that are known at compile time and then the result is known at compile",
    "start": "2695280",
    "end": "2701720"
  },
  {
    "text": "time or with values that would only be known at runtime and then the result would only be known at runtime which is",
    "start": "2701720",
    "end": "2707760"
  },
  {
    "text": "nice um in C++ 14 a lot of restrictions on Conex per were lifted so for example",
    "start": "2707760",
    "end": "2715040"
  },
  {
    "text": "now in Conex per functions you can use loops and you can declare local variables which you couldn't in C++ 11",
    "start": "2715040",
    "end": "2722160"
  },
  {
    "text": "where the whole thing had to be a single return expression so that opens the door for a bunch of additional things that",
    "start": "2722160",
    "end": "2728400"
  },
  {
    "text": "you can express as compile time computation and you can even now have",
    "start": "2728400",
    "end": "2733480"
  },
  {
    "text": "types which are con exper essentially so here's for example the complex type uh",
    "start": "2733480",
    "end": "2739520"
  },
  {
    "text": "tupple has similar uh situations so here's a complex type where the Constructor can be const exper and it",
    "start": "2739520",
    "end": "2747040"
  },
  {
    "text": "has a real and the set real function which are const exper and a conjugate function that can be con exper so",
    "start": "2747040",
    "end": "2753720"
  },
  {
    "text": "basically we can now Express computations on complex numbers and they will be performed at compile time which",
    "start": "2753720",
    "end": "2759440"
  },
  {
    "text": "is rather cool I think what's even more cool is that um con and const exper are",
    "start": "2759440",
    "end": "2765200"
  },
  {
    "text": "two totally distinct Concepts right so for example here's a function which is const exper but it's not const it's",
    "start": "2765200",
    "end": "2772079"
  },
  {
    "text": "actually mutating an object that mutation just happens at compile time so that's what we're saying by using con",
    "start": "2772079",
    "end": "2778640"
  },
  {
    "text": "exper here this function here it's mutating a value but it's happening at compile time so that's what Conex per",
    "start": "2778640",
    "end": "2784920"
  },
  {
    "text": "means great so that's just a very very quick overview of Conex per some simple",
    "start": "2784920",
    "end": "2790359"
  },
  {
    "start": "2789000",
    "end": "2789000"
  },
  {
    "text": "uses are rather nice so for example you can replace the horrible",
    "start": "2790359",
    "end": "2796640"
  },
  {
    "text": "array size macro which takes an array a statically defined array and Returns the",
    "start": "2796640",
    "end": "2801839"
  },
  {
    "text": "number of elements in that array you can replace that with a conext per function",
    "start": "2801839",
    "end": "2806880"
  },
  {
    "text": "template which is template um um where the template arguments are the type and",
    "start": "2806880",
    "end": "2814359"
  },
  {
    "text": "the number of elements in in the array and we just return the number of elements and that array size can be used",
    "start": "2814359",
    "end": "2821400"
  },
  {
    "text": "at compile time uh situations so for example you could declare an array whose",
    "start": "2821400",
    "end": "2826920"
  },
  {
    "text": "size is array size of some other array which is a rather common use of array",
    "start": "2826920",
    "end": "2832280"
  },
  {
    "text": "size so that's a compile time known value another example is the power function which can be calculated",
    "start": "2832280",
    "end": "2838400"
  },
  {
    "text": "recursively so two to the power of something is some is you know comes up a lot so these are simple uses and there's",
    "start": "2838400",
    "end": "2845520"
  },
  {
    "text": "a bunch of them in the library and uh in code you'd write yourself but here's a slightly less um obvious use where const",
    "start": "2845520",
    "end": "2853319"
  },
  {
    "start": "2849000",
    "end": "2849000"
  },
  {
    "text": "expert can actually replace a bunch of class templates uh which you would use",
    "start": "2853319",
    "end": "2858480"
  },
  {
    "text": "uh which you would use to Define meta functions before so our task here in",
    "start": "2858480",
    "end": "2863800"
  },
  {
    "text": "this particular case is to build a compile time facility a compile time",
    "start": "2863800",
    "end": "2869480"
  },
  {
    "text": "function basically a meta function which takes a certain type trait a Boolean",
    "start": "2869480",
    "end": "2875240"
  },
  {
    "text": "property of types such as is integral or is floating point or is no throw move",
    "start": "2875240",
    "end": "2882200"
  },
  {
    "text": "constructible some kind of Boolean property of types and an open collection",
    "start": "2882200",
    "end": "2887760"
  },
  {
    "text": "of types just any types we want T1 T2 T3 an arbitrary number of types and we want",
    "start": "2887760",
    "end": "2894440"
  },
  {
    "text": "this thing here and F to evaluate whether this uh Boolean meta function is",
    "start": "2894440",
    "end": "2901960"
  },
  {
    "text": "true for all my types T1 T2 T3 and return true or false which would be",
    "start": "2901960",
    "end": "2908440"
  },
  {
    "text": "known at compile time so this is a classic scenario which you would solve using class template specialization",
    "start": "2908440",
    "end": "2915079"
  },
  {
    "text": "before con exper was available you'd have to build a couple of class templates recursively they would have to",
    "start": "2915079",
    "end": "2921400"
  },
  {
    "text": "um derive or extend each other um here's the Conex per solution which uh for me",
    "start": "2921400",
    "end": "2928400"
  },
  {
    "text": "anyway in some cases is clearer so here's the base case uh for and F for",
    "start": "2928400",
    "end": "2935000"
  },
  {
    "text": "this little function function the base case doesn't take any types it only",
    "start": "2935000",
    "end": "2940040"
  },
  {
    "text": "takes the operator it only takes the binary function uh the Boolean function",
    "start": "2940040",
    "end": "2945799"
  },
  {
    "text": "such as in is integral and it returns true because if you apply that function",
    "start": "2945799",
    "end": "2950920"
  },
  {
    "text": "to no types then we could say it is true for all the types for all the no types",
    "start": "2950920",
    "end": "2957280"
  },
  {
    "text": "we have um and then the interesting case the recursive case is over here where we",
    "start": "2957280",
    "end": "2963359"
  },
  {
    "text": "have that oper operation uh um the Boolean property of types we have the",
    "start": "2963359",
    "end": "2968559"
  },
  {
    "text": "first type and we have all the rest of the types and uh the rest can also be",
    "start": "2968559",
    "end": "2973760"
  },
  {
    "text": "empty so we could be down to just one thing and we just perform a recursive",
    "start": "2973760",
    "end": "2978880"
  },
  {
    "text": "invocation right so we ask is up of T true and the recursive invocation for",
    "start": "2978880",
    "end": "2987760"
  },
  {
    "text": "all the rest of the types is it true as well and that's what we return and the",
    "start": "2987760",
    "end": "2993160"
  },
  {
    "text": "whole thing of course is coner so it's all evaluated at compile time it's not like at run time you're actually going",
    "start": "2993160",
    "end": "2999040"
  },
  {
    "text": "to have any recursive invocations that whole thing just folds down to true or",
    "start": "2999040",
    "end": "3004079"
  },
  {
    "text": "false at compile time and for me in some cases this conext per function style is",
    "start": "3004079",
    "end": "3010520"
  },
  {
    "text": "more readable and more understandable than uh class templates which would have",
    "start": "3010520",
    "end": "3015640"
  },
  {
    "text": "to interact with each other through specializations especially if the thing you're working with uh is values and not",
    "start": "3015640",
    "end": "3022640"
  },
  {
    "text": "types so in this case I'm working with values I have true false which I have to combine in some way and not types which",
    "start": "3022640",
    "end": "3029280"
  },
  {
    "text": "would be harder to combine uh using just functions so my final example from the",
    "start": "3029280",
    "end": "3035280"
  },
  {
    "text": "conext per uh area is one I've come across about a year ago or maybe a little more uh which is paring strings",
    "start": "3035280",
    "end": "3042520"
  },
  {
    "text": "at compile time so here's a little class called cstr for compile time string",
    "start": "3042520",
    "end": "3049640"
  },
  {
    "text": "which uh has a Constructor from an array of characters with a known size so it",
    "start": "3049640",
    "end": "3057920"
  },
  {
    "text": "can basically be initialized from literal strings right uh literal strings",
    "start": "3057920",
    "end": "3063599"
  },
  {
    "text": "uh known at compile time so that's a an array of characters and the size is also",
    "start": "3063599",
    "end": "3068839"
  },
  {
    "text": "known what this Constructor does is just initialize members uh the pointer to the",
    "start": "3068839",
    "end": "3074319"
  },
  {
    "text": "beginning of the string and the length of the string and now I can have in that",
    "start": "3074319",
    "end": "3079920"
  },
  {
    "text": "class multiple con exper operations which interact with these Fields so for",
    "start": "3079920",
    "end": "3086680"
  },
  {
    "text": "example I could do a length function which would return length I can do an is",
    "start": "3086680",
    "end": "3093480"
  },
  {
    "text": "empty function which returns whether length is zero I could also do a function which uh looks for a certain",
    "start": "3093480",
    "end": "3100799"
  },
  {
    "text": "character in the string and Returns the first occurrence and that function would still be Conex per because this whole",
    "start": "3100799",
    "end": "3107799"
  },
  {
    "text": "thing is performed at compile time and one example of using it is uh for printf",
    "start": "3107799",
    "end": "3114400"
  },
  {
    "start": "3112000",
    "end": "3112000"
  },
  {
    "text": "like situations where I want to test that my format string is valid so just",
    "start": "3114400",
    "end": "3119839"
  },
  {
    "text": "think about it if the format string is a compile time literal string which happens in a lot of cases you can",
    "start": "3119839",
    "end": "3126920"
  },
  {
    "text": "validate it at compile time not waiting until runtime to make sure the format string is valid so in this very simple",
    "start": "3126920",
    "end": "3134680"
  },
  {
    "text": "example I have a static assertion which makes sure that the count of percent",
    "start": "3134680",
    "end": "3141200"
  },
  {
    "text": "signs in my format string is the same has the number of arguments passed to",
    "start": "3141200",
    "end": "3147640"
  },
  {
    "text": "the print F function so that's obviously a simplification because in print F",
    "start": "3147640",
    "end": "3152880"
  },
  {
    "text": "format strings you can have double percent sign and that's not a placeholder but you know the general",
    "start": "3152880",
    "end": "3159680"
  },
  {
    "text": "idea still holds um we can test at compile time whether a certain a certain",
    "start": "3159680",
    "end": "3164920"
  },
  {
    "text": "string literal has a certain number of percent signs and reject at compile time",
    "start": "3164920",
    "end": "3170480"
  },
  {
    "text": "that format string if it doesn't so for example if I invoke my printer function with two arguments but only one percent",
    "start": "3170480",
    "end": "3177760"
  },
  {
    "text": "sign the compiler could complain and that static assertion would fire and tell me number of arguments doesn't",
    "start": "3177760",
    "end": "3184000"
  },
  {
    "text": "match the format string so obviously this is just a prototype right but um it",
    "start": "3184000",
    "end": "3189040"
  },
  {
    "text": "can be used in a lot of situations where I have to validate strings at compile time uh for example imagine a regular",
    "start": "3189040",
    "end": "3195720"
  },
  {
    "text": "expression Constructor that tests that the regular expression is well formed a bunch of things that's uh that are quite",
    "start": "3195720",
    "end": "3202200"
  },
  {
    "text": "easy to express once we have Conex per because you can essentially reuse the",
    "start": "3202200",
    "end": "3207400"
  },
  {
    "text": "same code the same algorithm for testing things at compile time and at run time",
    "start": "3207400",
    "end": "3213680"
  },
  {
    "text": "so that's just a wrap a wrapper case for um for for my examples right so we have",
    "start": "3213680",
    "end": "3220079"
  },
  {
    "text": "about 3 minutes left so if you have any questions there'll be a little time I hope um I hope you've seen some examples",
    "start": "3220079",
    "end": "3226040"
  },
  {
    "text": "of using uh template meta programming in a variety of tasks in both libraries and applications so admittedly a lot of",
    "start": "3226040",
    "end": "3233599"
  },
  {
    "text": "these examples are from the library world uh implementing STL algorithms optimizing them and so on but hopefully",
    "start": "3233599",
    "end": "3240960"
  },
  {
    "text": "application Level examples can also be extracted from these uh uh samples and",
    "start": "3240960",
    "end": "3246200"
  },
  {
    "text": "uh with the tools we have in C++ today such as deal type such as con exper it's",
    "start": "3246200",
    "end": "3251319"
  },
  {
    "text": "a lot easier to build these kind of uh Solutions than it was in C++ 98 now if",
    "start": "3251319",
    "end": "3257359"
  },
  {
    "text": "you're uh seriously considering investing in uh in TMP libraries um",
    "start": "3257359",
    "end": "3262640"
  },
  {
    "text": "instead of building these uh basic tools yourself uh there's a bunch of options",
    "start": "3262640",
    "end": "3267880"
  },
  {
    "text": "to choose from right so you don't have to build uh the basic combinators for example for testing whether a certain",
    "start": "3267880",
    "end": "3274440"
  },
  {
    "text": "property holds for multiple types that kind of thing you don't have to build yourself unless you just enjoy the",
    "start": "3274440",
    "end": "3279720"
  },
  {
    "text": "process I enjoy the process but still um you don't have to build these things yourself there's a bunch of libraries",
    "start": "3279720",
    "end": "3285160"
  },
  {
    "text": "including in boost uh some Modern some older which uh provide solutions to",
    "start": "3285160",
    "end": "3290680"
  },
  {
    "text": "Common tasks uh that you have to perform at compile time so this is all quite fun",
    "start": "3290680",
    "end": "3296240"
  },
  {
    "text": "and hopefully will be applicable to at least some situations you encounter and um if you have any questions we have uh",
    "start": "3296240",
    "end": "3303040"
  },
  {
    "text": "about 3 minutes yeah",
    "start": "3303040",
    "end": "3306720"
  },
  {
    "text": "so",
    "start": "3309960",
    "end": "3312960"
  },
  {
    "text": "yes instead of instead of the TR instead of the extra",
    "start": "3318960",
    "end": "3326799"
  },
  {
    "text": "okay so just repeat the question why did I show you U uh an example of using class template specialization and tag",
    "start": "3326799",
    "end": "3334039"
  },
  {
    "text": "dispatch um instead of just using one of them so first it's nice to see multiple options and second um tag dispatch is",
    "start": "3334039",
    "end": "3341640"
  },
  {
    "text": "usually used when you're trying to invoke a function if you have a whole class template that you want to pick and",
    "start": "3341640",
    "end": "3347359"
  },
  {
    "text": "that class template would have members and would have Behavior Uh so State and you have multiple functions to invoke I",
    "start": "3347359",
    "end": "3354200"
  },
  {
    "text": "think it would be more more convenient to use uh specialization um I think it's also a matter of taste to some",
    "start": "3354200",
    "end": "3362760"
  },
  {
    "text": "extent all right well anyway uh thank you very very much for coming and uh I'll have some samples for you um on",
    "start": "3366440",
    "end": "3373640"
  },
  {
    "text": "Twitter later um if you'd like to explore some Labs yourself and the examples I've uh shown you here today I",
    "start": "3373640",
    "end": "3380640"
  },
  {
    "text": "hope you enjoy the rest of NDC thank you very very much for coming thank you",
    "start": "3380640",
    "end": "3386920"
  }
]