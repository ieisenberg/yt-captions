[
  {
    "text": "all right everybody Rick giving everybody a couple of minutes to come in",
    "start": "6240",
    "end": "12870"
  },
  {
    "text": "no it's not a clock on the last day so I hope everyone's had their coffee especially after last night yeah yeah",
    "start": "12870",
    "end": "21630"
  },
  {
    "text": "I'm not liking need a second cup all right so let's get started shall we so",
    "start": "21630",
    "end": "29170"
  },
  {
    "text": "good morning thanks for everyone for coming my name is Daniel chambers and until recently I was a senior consultant",
    "start": "29170",
    "end": "35620"
  },
  {
    "text": "at ratify but recently in the last couple weeks in fact this would be my third week I started a new job at",
    "start": "35620",
    "end": "42670"
  },
  {
    "text": "Liberty Financial to help them along their functional programming journey so you might see why I had to change jobs",
    "start": "42670",
    "end": "48399"
  },
  {
    "text": "because my background is as a dotnet developer starting it's starting in",
    "start": "48399",
    "end": "55149"
  },
  {
    "text": "c-sharp however over the last few years I've become a little bit of a bit of a functional programming nut I didn't",
    "start": "55149",
    "end": "62440"
  },
  {
    "text": "learn any functional programming at university unfortunately so when I learned F sharp it was a brand new",
    "start": "62440",
    "end": "67720"
  },
  {
    "text": "experience for me and then a couple of years ago I got a fantastic opportunity to write shipping production software in",
    "start": "67720",
    "end": "75159"
  },
  {
    "text": "Haskell and this opened my eyes to a completely new way of writing software and Haskell became my new favorite",
    "start": "75159",
    "end": "81820"
  },
  {
    "text": "programming language so hopefully today I can impart to you some of the reasons why I love writing code in Haskell and",
    "start": "81820",
    "end": "89229"
  },
  {
    "text": "why I think that more people should consider to consider it as a viable functional programming language so",
    "start": "89229",
    "end": "97659"
  },
  {
    "text": "developers we're human we're smart creative ingenious people we like taking complex problems breaking them down and",
    "start": "97659",
    "end": "104170"
  },
  {
    "text": "writing solutions for them we use abstractions to help us manage the increasing complexity of our software",
    "start": "104170",
    "end": "109600"
  },
  {
    "text": "problems we strive to do our best and be constantly improving however being human we also make",
    "start": "109600",
    "end": "115960"
  },
  {
    "text": "mistakes we oversimplify we over complicate and we miss edge cases and most importantly",
    "start": "115960",
    "end": "121630"
  },
  {
    "text": "we forget things there's nothing wrong with this it's just a part of our human nature and we're not blind to our",
    "start": "121630",
    "end": "127390"
  },
  {
    "text": "shortcomings we always create tools to help us overcome our deficiencies we created fire to keep us warm",
    "start": "127390",
    "end": "133420"
  },
  {
    "text": "whilst allow us to move around more easily writing to allow us to remember or beyond are fallible memories machines",
    "start": "133420",
    "end": "140209"
  },
  {
    "text": "to amplify our strength and make us more productive electricity to power our machines in our homes and of course most",
    "start": "140209",
    "end": "147409"
  },
  {
    "text": "recently computers to amplify our minds the history of software development is",
    "start": "147409",
    "end": "153409"
  },
  {
    "text": "one of continual improvement the first pieces of software that we wrote was simple but now decades later the scale",
    "start": "153409",
    "end": "159319"
  },
  {
    "text": "and complexity of software far Dwarfs anything that we've done in the past and just like throughout history we managed",
    "start": "159319",
    "end": "165859"
  },
  {
    "text": "this through developing better tools to allow us fallible humans to manage this complexity we used to write code in roar",
    "start": "165859",
    "end": "173780"
  },
  {
    "text": "assembly but soon progressed onto high level languages like C the abstractions",
    "start": "173780",
    "end": "179150"
  },
  {
    "text": "that structured programming introduced allowed us to write more complex software letting the tool take care of",
    "start": "179150",
    "end": "184519"
  },
  {
    "text": "some of the details and check our thinking during the compilation process soon after came C++ and more generally",
    "start": "184519",
    "end": "192019"
  },
  {
    "text": "object-oriented programming which enabled greater complexity by giving us the tools of encapsulation and",
    "start": "192019",
    "end": "197450"
  },
  {
    "text": "abstraction managed memory runtimes such as the JVM and dotnet soon arrived to",
    "start": "197450",
    "end": "203959"
  },
  {
    "text": "take care of the complexity of memory management and JavaScript once a simple scripting language for the web has been",
    "start": "203959",
    "end": "209870"
  },
  {
    "text": "continually improved and fought with sister languages like typescript adding more tooling such as static typing to",
    "start": "209870",
    "end": "215239"
  },
  {
    "text": "help with managing complexity and correctness even with this continual",
    "start": "215239",
    "end": "221329"
  },
  {
    "text": "improvement of our tools software and software engineering as an industry still has problems with managing complexity and in particular ensuring",
    "start": "221329",
    "end": "228379"
  },
  {
    "text": "the software that we write is correct there are so many industry jokes about it but a recent xkcd comic that you may",
    "start": "228379",
    "end": "234799"
  },
  {
    "text": "have seen really highlighted it for me when it compared software to other disciplines with taking a stab at would",
    "start": "234799",
    "end": "240470"
  },
  {
    "text": "you really trust voting software with your democracy and I think the answer would probably be a resounding no",
    "start": "240470",
    "end": "246590"
  },
  {
    "text": "because of our really bad track record at security change is a constant in our",
    "start": "246590",
    "end": "254989"
  },
  {
    "text": "industry and like the tide against the cliffs over time it grinds our software down into a broken broken buggy",
    "start": "254989",
    "end": "260780"
  },
  {
    "text": "unmanageable mess as developers we find it difficult to safely modify our software over time to adapt to changing",
    "start": "260780",
    "end": "267469"
  },
  {
    "text": "requirements while ensuring that it still works as intended we forget or fail to",
    "start": "267469",
    "end": "272860"
  },
  {
    "text": "recognize edge cases and we forget sometimes why something was written the way it was and we might not understand",
    "start": "272860",
    "end": "279130"
  },
  {
    "text": "code that someone else had written and we know this so we employ more tools to help us",
    "start": "279130",
    "end": "284410"
  },
  {
    "text": "compilers unit tests continuous integration pipelines automated deployments but let's not forget the",
    "start": "284410",
    "end": "290770"
  },
  {
    "text": "humble programming language a good language should help us express our intention clearly so that others can",
    "start": "290770",
    "end": "296889"
  },
  {
    "text": "understand it it should only allow us to express our intention in a way that minimizes mistakes and it should",
    "start": "296889",
    "end": "303400"
  },
  {
    "text": "wherever possible verify what we have written is correct it should allow us to think with precision never allowing us",
    "start": "303400",
    "end": "309639"
  },
  {
    "text": "to forget important edge cases I believe functional programming and FP languages",
    "start": "309639",
    "end": "316180"
  },
  {
    "text": "especially Haskell are the next step in our evolution of our language tools FP",
    "start": "316180",
    "end": "322060"
  },
  {
    "text": "can help us manage software complexity resilience to change and quality functional programming has become more",
    "start": "322060",
    "end": "328630"
  },
  {
    "text": "and more popular over time as mainstream languages like C sharp C++ JavaScript and Java all adopt functional",
    "start": "328630",
    "end": "334810"
  },
  {
    "text": "programming features and ideas more fully functional languages like Haskell F sharp and Scala are gaining popularity",
    "start": "334810",
    "end": "341020"
  },
  {
    "text": "as people recognize the advantages that functional programming brings things like functions as first-class objects",
    "start": "341020",
    "end": "347770"
  },
  {
    "text": "that allow us to more easily compose and reuse code in ways that make sense a declarative programming style that",
    "start": "347770",
    "end": "354430"
  },
  {
    "text": "allows us to lift our level of abstraction up and focus on expressing our business logic and not writing plumbing code and purity and",
    "start": "354430",
    "end": "361780"
  },
  {
    "text": "immutability provide us guarantees that allow us to write code that's more testable and maintainable horrible",
    "start": "361780",
    "end": "367120"
  },
  {
    "text": "global mutable state is eliminated and you can more easily reason about your code when your functions are pure and",
    "start": "367120",
    "end": "372729"
  },
  {
    "text": "have no side effects and immutability also gives us that double benefit of",
    "start": "372729",
    "end": "377800"
  },
  {
    "text": "making it easier to write concurrent code that is correct and without race conditions because it's not possible for",
    "start": "377800",
    "end": "383800"
  },
  {
    "text": "two threads to mutate the same state haskell is a language that embodies",
    "start": "383800",
    "end": "390310"
  },
  {
    "text": "functional programming principles unlike a language like F sharp or Scala which straddle the fence between an",
    "start": "390310",
    "end": "395889"
  },
  {
    "text": "object-oriented language and a functional one Haskell is a pure functional language that epitomizes",
    "start": "395889",
    "end": "401440"
  },
  {
    "text": "functional ideals so let's take a tour of Haskell's features that help us write quality software that is correct",
    "start": "401440",
    "end": "407589"
  },
  {
    "text": "understandable and easily refactor able so number one Haskell is a statically",
    "start": "407589",
    "end": "414669"
  },
  {
    "text": "typed language and this means that it has a type system that is enforced and checked by the compiler at compile time",
    "start": "414669",
    "end": "421080"
  },
  {
    "text": "people still debate dynamic versus static languages but I think one only needs to look at the JavaScript",
    "start": "421080",
    "end": "426520"
  },
  {
    "text": "ecosystem to see the value of a statically typed language people have literally had to make new statically",
    "start": "426520",
    "end": "432310"
  },
  {
    "text": "typed language that compile to JavaScript such as typescript in order to be able to manage larger and larger",
    "start": "432310",
    "end": "437589"
  },
  {
    "text": "JavaScript code bases dynamic typing can be fine for small scripts throw away prototypes and for quick coding but for",
    "start": "437589",
    "end": "444550"
  },
  {
    "text": "quality non-trivial software developers need static types in order to help them manage complexity jondor gos has",
    "start": "444550",
    "end": "452020"
  },
  {
    "text": "commented on Twitter that an underpowered type system forces one to program defensively and I think anyone",
    "start": "452020",
    "end": "457630"
  },
  {
    "text": "who's used a type system like C sharps and Javas will know this feeling having to do null checks and type tests is busy",
    "start": "457630",
    "end": "463870"
  },
  {
    "text": "work yet is easily forgotten and a source of annoying bugs on the other",
    "start": "463870",
    "end": "468880"
  },
  {
    "text": "hand a powerful type system liberate s-- the developer to make changes with confidence knowing that the type system",
    "start": "468880",
    "end": "474250"
  },
  {
    "text": "will validate his or her corrode code for correctness John calls this fearless programming Haskell has an extremely",
    "start": "474250",
    "end": "481690"
  },
  {
    "text": "powerful and strict type system as a consequence Haskell forces you to write code that is correct and rejects code",
    "start": "481690",
    "end": "488440"
  },
  {
    "text": "that is not now this might seem arduous as you write code in comparison to a dynamically typed language but what it",
    "start": "488440",
    "end": "494979"
  },
  {
    "text": "means is you actually spend far less time debugging errors at runtime it's somewhat of an in-joke that within",
    "start": "494979",
    "end": "501130"
  },
  {
    "text": "Haskell if it compiles it probably works but I've actually found this to be the case far more often than not one of the",
    "start": "501130",
    "end": "510099"
  },
  {
    "text": "annoyances of static typing can be constantly having to tell the compiler the type of what the type of things is",
    "start": "510099",
    "end": "516578"
  },
  {
    "text": "you write code if to repeat it over and over thankfully Haskell has a very powerful type inference engine that can",
    "start": "516579",
    "end": "522849"
  },
  {
    "text": "infer the types of your values and functions by looking at the context of what it is that you've actually written",
    "start": "522849",
    "end": "528600"
  },
  {
    "text": "so up on the slide we've got a function called print error message and it takes a message parameter and it prints to the",
    "start": "528600",
    "end": "534880"
  },
  {
    "text": "console that message parameter and the error value both have both been inferred to be",
    "start": "534880",
    "end": "541090"
  },
  {
    "text": "of type string and this is because the compiler can figure that out by looking at the context of where they've been",
    "start": "541090",
    "end": "546460"
  },
  {
    "text": "used so the message parameter is passed to that string concatenation function",
    "start": "546460",
    "end": "551770"
  },
  {
    "text": "which is the plus plus operator and that error is passed to put string line which itself takes a string and the print",
    "start": "551770",
    "end": "559270"
  },
  {
    "text": "error message function itself is inferred to return the type I O of unit because that's what pure that puts stir",
    "start": "559270",
    "end": "565690"
  },
  {
    "text": "line returns however this type inference can be a double-edged sword if your code",
    "start": "565690",
    "end": "571810"
  },
  {
    "text": "is not correct as you write it's the compiler may infer incorrect types for things which can make compiler error",
    "start": "571810",
    "end": "577600"
  },
  {
    "text": "message is much harder to understand because it'll be telling you about types that you didn't actually intend to write",
    "start": "577600",
    "end": "584370"
  },
  {
    "text": "but it's also much harder to understand code when the types aren't there and",
    "start": "584370",
    "end": "589450"
  },
  {
    "text": "everything's inferred good naming of variables can help carry you for a while but nothing beats a good type to",
    "start": "589450",
    "end": "595060"
  },
  {
    "text": "describe exactly what something is other languages like F sharp will try to try",
    "start": "595060",
    "end": "600370"
  },
  {
    "text": "to resolve this issue through tooling so if you use the vs code extension ioan I'd in F sharp it'll display the type",
    "start": "600370",
    "end": "607060"
  },
  {
    "text": "signature for functions above them in line in the code to help you understand the code as you're reading it however",
    "start": "607060",
    "end": "612730"
  },
  {
    "text": "this doesn't help you when you're reviewing code in another editor or in github in a PR for example haskell",
    "start": "612730",
    "end": "620470"
  },
  {
    "text": "solves these issues by allowing people to explicitly add type signatures to functions and this helps resolves the",
    "start": "620470",
    "end": "626410"
  },
  {
    "text": "issue of when you're writing code and you've got a little bit wrong and type inference is messing up your compiler",
    "start": "626410",
    "end": "631630"
  },
  {
    "text": "error messages because the incorrect types are slipping in so you start writing a function by defining its",
    "start": "631630",
    "end": "638290"
  },
  {
    "text": "desired type signature and then as you write the function the compiler can help you fill in the blanks using type",
    "start": "638290",
    "end": "643840"
  },
  {
    "text": "inference and this actually changes the way you write code whereby you let the compiler guide you by looking at the",
    "start": "643840",
    "end": "649750"
  },
  {
    "text": "error messages that it gives you back to determine what you need to do next in your function to satisfy the type",
    "start": "649750",
    "end": "655300"
  },
  {
    "text": "signature that you started with by having that type signature actually in",
    "start": "655300",
    "end": "660490"
  },
  {
    "text": "the code it also means you can read the code directly on github or and any any editor that you like and still be able",
    "start": "660490",
    "end": "666010"
  },
  {
    "text": "to see these types images because they're just texting for me after having this it's going back",
    "start": "666010",
    "end": "672230"
  },
  {
    "text": "and reading f-sharp code is a bit harder because I can't see the type of functions when I viewed the code on github in Haskell type signatures are",
    "start": "672230",
    "end": "680630"
  },
  {
    "text": "just there for me to read and because they're written separately above the function it keeps the actual code clean and",
    "start": "680630",
    "end": "686180"
  },
  {
    "text": "concise without cluttering it with type information the type signatures also act",
    "start": "686180",
    "end": "692360"
  },
  {
    "text": "as documentation for a function so you can very often look at a function and tell what it does and how to use it",
    "start": "692360",
    "end": "698090"
  },
  {
    "text": "simply by inspecting its type signature so we can see that the print error message function does IO because it",
    "start": "698090",
    "end": "704120"
  },
  {
    "text": "returns the IO type another good example is the function zip and that's type",
    "start": "704120",
    "end": "709430"
  },
  {
    "text": "signatures up in the slide in the bottom by reading that type of signature we can see that it takes a list of a's and the",
    "start": "709430",
    "end": "715910"
  },
  {
    "text": "list is the the square bracket syntax and it takes a list of b's so it takes two parameters and it will return a list",
    "start": "715910",
    "end": "722120"
  },
  {
    "text": "of a b pairs that's a tuple of a and B we can intuit that this means that it",
    "start": "722120",
    "end": "728060"
  },
  {
    "text": "combines those two lists together and produces a single list of the elements paired together and we can tell that just by looking at the types the a's and",
    "start": "728060",
    "end": "735440"
  },
  {
    "text": "b's there are generic types so this function could be used with a list of string there's in a list of intz for example and it would return a list of",
    "start": "735440",
    "end": "742190"
  },
  {
    "text": "string end pairs this descriptiveness of",
    "start": "742190",
    "end": "748010"
  },
  {
    "text": "the type system provides unexpected benefits so the Haskell eco system has a",
    "start": "748010",
    "end": "753560"
  },
  {
    "text": "search engine called Google which allows you to search for functions by their type signatures so let's try an example",
    "start": "753560",
    "end": "759730"
  },
  {
    "text": "imagine we want a function that takes a list transforms each element and then",
    "start": "759730",
    "end": "764930"
  },
  {
    "text": "also filters the list at the same time so you can think about it as a where and a select together f-sharp people might",
    "start": "764930",
    "end": "772070"
  },
  {
    "text": "recognize that as a choose function but if we're new to Haskell we might not know what it's actually called in the Haskell standard libraries and this is",
    "start": "772070",
    "end": "779090"
  },
  {
    "text": "where who will can come in and help us we can write out the type signature for that function so the first parameter is",
    "start": "779090",
    "end": "785090"
  },
  {
    "text": "a function itself that transforms each element a into a B and can optionally",
    "start": "785090",
    "end": "790910"
  },
  {
    "text": "discard it and that's where that may be type comes in so maybe we'll keep it the B or not the second parameter is an",
    "start": "790910",
    "end": "797780"
  },
  {
    "text": "input list of A's and the return type is a list of transformed and filtered B so when I put that type of signature",
    "start": "797780",
    "end": "804440"
  },
  {
    "text": "into Google it immediately returns a set of matching functions and right at the top is the one that I want which is the",
    "start": "804440",
    "end": "810529"
  },
  {
    "text": "map maybe function from the data maybe module that's pretty cool so huugle is incredibly useful to see",
    "start": "810529",
    "end": "817250"
  },
  {
    "text": "whether there's a function out there that does what you need rather than you implementing it yourself a lot of the",
    "start": "817250",
    "end": "822589"
  },
  {
    "text": "time you're just able to pull on a library that does what you want and it's also super useful when you're learning and you don't know where all the basic",
    "start": "822589",
    "end": "828709"
  },
  {
    "text": "functions are you can just ask huugle I need a function that does this type it's type signature in and it'll give you a",
    "start": "828709",
    "end": "834709"
  },
  {
    "text": "list of matching functions and it does a fuzzy match as well so if you don't get it quite right it might find you one that's close another static typing",
    "start": "834709",
    "end": "844970"
  },
  {
    "text": "feature that Haskell offers is to help you write an understandable and correct code is something called a some type a",
    "start": "844970",
    "end": "851180"
  },
  {
    "text": "some type is a type that expresses a fixed set of alternatives so another way",
    "start": "851180",
    "end": "856520"
  },
  {
    "text": "of saying this is that a sum type allows you to make a choice between different things so you can define an explicit",
    "start": "856520",
    "end": "862640"
  },
  {
    "text": "choice between a B and C a typical example is modeling the presence or",
    "start": "862640",
    "end": "868250"
  },
  {
    "text": "absence of a value so Haskell does this with the maybe type which can either be just with a value or nothing without a",
    "start": "868250",
    "end": "875510"
  },
  {
    "text": "value so the syntax is up on the slide is saying that we have a data type called maybe it has a generic parameter",
    "start": "875510",
    "end": "882020"
  },
  {
    "text": "that we're calling a and it can either be a value called just that has contains",
    "start": "882020",
    "end": "887420"
  },
  {
    "text": "a value of whatever the type a is or it can be a value called nothing which doesn't have anything associated with it",
    "start": "887420",
    "end": "894040"
  },
  {
    "text": "so when we have a maybe value we can use Haskell pattern matching syntax which is that case of syntax to see whether then",
    "start": "894040",
    "end": "901070"
  },
  {
    "text": "maybe we have at hand is actually a just or nothing and then do something different in each case that may be type",
    "start": "901070",
    "end": "907250"
  },
  {
    "text": "is actually built into the Haskell base library so you don't need to write it yourself but that's pretty much all it is the either some type is also built in",
    "start": "907250",
    "end": "916850"
  },
  {
    "text": "and it offers the ability to model a choice between two different values so we can either be a left which can",
    "start": "916850",
    "end": "922820"
  },
  {
    "text": "contain whatever type a is or right which can contain whatever type B is the",
    "start": "922820",
    "end": "928970"
  },
  {
    "text": "either some type is often used to model error handling so for example either error int is a type that could either be",
    "start": "928970",
    "end": "935660"
  },
  {
    "text": "left with era or right with an INT of course you can define your own some types to model",
    "start": "935660",
    "end": "942319"
  },
  {
    "text": "alternatives in your domain accurately so for example we could make an arrow",
    "start": "942319",
    "end": "947690"
  },
  {
    "text": "type that models the different areas that we get when we validate a file path so it could exceed the max length of a",
    "start": "947690",
    "end": "953209"
  },
  {
    "text": "path and we could pass along the the actual length that it that it was it could use invalid characters and we",
    "start": "953209",
    "end": "959420"
  },
  {
    "text": "could also pass along the length of the invalid characters that it did use or it could just be an empty string well we",
    "start": "959420",
    "end": "965569"
  },
  {
    "text": "don't really need to put a new associated data with it we could then write up PA's file path function that",
    "start": "965569",
    "end": "971990"
  },
  {
    "text": "takes that string validates it and then returns either a path validation or a",
    "start": "971990",
    "end": "977899"
  },
  {
    "text": "valid file path and that's what the type signature up on the slide is is saying",
    "start": "977899",
    "end": "983290"
  },
  {
    "text": "so a typical way of writing code like this in a language like C sharp might be",
    "start": "983290",
    "end": "988459"
  },
  {
    "text": "to use exceptions we've probably all seen a method similar to this at some point where you've got you pass a string",
    "start": "988459",
    "end": "996500"
  },
  {
    "text": "to this validate file path method and it will either just do nothing or throw an exception with probably the error inside",
    "start": "996500",
    "end": "1004449"
  },
  {
    "text": "that exception type now unfortunately with that sort of form we have no way of knowing what sort of errors to expect",
    "start": "1004449",
    "end": "1010959"
  },
  {
    "text": "from that validate file path method without reading its implementation or perhaps its documentation the type",
    "start": "1010959",
    "end": "1017319"
  },
  {
    "text": "signature there doesn't mention the exception at all that could be thrown so",
    "start": "1017319",
    "end": "1022360"
  },
  {
    "text": "we can see how some types can be used to make error handling explicit and indeed can be used to make any alternatives in",
    "start": "1022360",
    "end": "1028569"
  },
  {
    "text": "your code explicit in the types and this is also useful when you change your code so if you add an alternative to a some",
    "start": "1028569",
    "end": "1036010"
  },
  {
    "text": "type the compiler will tell you all the places in your code that you need to update to account for that new",
    "start": "1036010",
    "end": "1041020"
  },
  {
    "text": "alternative and it will do that through a compiler warnings and typically that's one of the compiler warnings you turn into an error so this is a really good",
    "start": "1041020",
    "end": "1047709"
  },
  {
    "text": "example of how Haskell helps you refactor your code safely because you can go and modify these some types in the future and the compiler will tell",
    "start": "1047709",
    "end": "1054280"
  },
  {
    "text": "you all the places that you need to update in fact through the use of some types",
    "start": "1054280",
    "end": "1061340"
  },
  {
    "text": "Haskell eliminates that annoying non-reference exception that we get in languages like C sharp and JavaScript in",
    "start": "1061340",
    "end": "1067309"
  },
  {
    "text": "c-sharp any reference type can be null in Haskell null isn't a thing at all it",
    "start": "1067309",
    "end": "1073070"
  },
  {
    "text": "doesn't even exist if you need to model the potential absence of something then you use the maybe type and this means in",
    "start": "1073070",
    "end": "1080090"
  },
  {
    "text": "Haskell you opt into null ability if you try to pass and maybe to a function that",
    "start": "1080090",
    "end": "1085820"
  },
  {
    "text": "doesn't take a maybe you get a type error so the compiler won't let you do it if a function returns a maybe and you",
    "start": "1085820",
    "end": "1092510"
  },
  {
    "text": "don't deal with it then you get a compile error so this contrasts against the languages like C sharp where you",
    "start": "1092510",
    "end": "1098539"
  },
  {
    "text": "have you have opt-out null ability and you have to end up doing busy work and error-prone coding such as checking for",
    "start": "1098539",
    "end": "1104899"
  },
  {
    "text": "unexpected nulls and throwing exceptions to work around it the compiler doesn't stop you from passing null where you",
    "start": "1104899",
    "end": "1110870"
  },
  {
    "text": "shouldn't and you find out at runtime with a crash if you call a function and you get back a null but you don't code",
    "start": "1110870",
    "end": "1117559"
  },
  {
    "text": "for it then you get a crash at runtime have a look at the a school and c-sharp",
    "start": "1117559",
    "end": "1123919"
  },
  {
    "text": "list find type signatures up on the slide in the high school version of find it's impossible to pass maybes to that",
    "start": "1123919",
    "end": "1130880"
  },
  {
    "text": "function because it doesn't take maybes and you explicitly get back and maybe to represent if you weren't able to find",
    "start": "1130880",
    "end": "1137630"
  },
  {
    "text": "whatever it was you were looking for in that list you can't get it the contents of that may be unless you do a pattern",
    "start": "1137630",
    "end": "1143690"
  },
  {
    "text": "match so you know you literally have to handle the case where you didn't find something the language forces you to do",
    "start": "1143690",
    "end": "1150230"
  },
  {
    "text": "it in the C sharp version you can pass null for that predicate and you'll get an argument null reference sorry an",
    "start": "1150230",
    "end": "1156830"
  },
  {
    "text": "argument null exception at runtime you can also get back null from that function and unless you explicitly check",
    "start": "1156830",
    "end": "1163279"
  },
  {
    "text": "for null being returned you could get a null reference exception so this is just",
    "start": "1163279",
    "end": "1168529"
  },
  {
    "text": "one of the many ways that Haskell uses its strict and powerful static type system to ensure that you're writing",
    "start": "1168529",
    "end": "1174380"
  },
  {
    "text": "correct and bug-free code by making such concepts explicit in the types",
    "start": "1174380",
    "end": "1179630"
  },
  {
    "text": "developers can clearly understand the implications and the edge cases of using functions which means that they can",
    "start": "1179630",
    "end": "1185690"
  },
  {
    "text": "write and refactor code more safely and confidently",
    "start": "1185690",
    "end": "1190360"
  },
  {
    "text": "another powerful feature of using the Haskell static type system is the ability to find new types a new type is",
    "start": "1191630",
    "end": "1199140"
  },
  {
    "text": "a data type that simply wraps an existing type and this is useful when you want to add new meaning to an",
    "start": "1199140",
    "end": "1204660"
  },
  {
    "text": "existing type so a good example is an email address an email address is just a",
    "start": "1204660",
    "end": "1211110"
  },
  {
    "text": "string but it's not just any string it's a string that must match a certain format so you can define a new type",
    "start": "1211110",
    "end": "1216810"
  },
  {
    "text": "called email address that wraps the string and then you can pass around email address instead and this means",
    "start": "1216810",
    "end": "1222330"
  },
  {
    "text": "that you can write a validation function that takes a normal string and checks if it's a valid email address and then",
    "start": "1222330",
    "end": "1227400"
  },
  {
    "text": "returns either an error or a valid wrapped email address so that pars a",
    "start": "1227400",
    "end": "1232500"
  },
  {
    "text": "mail address type signature on the slide is an example of what that might look like once you've got a valid wrapped email",
    "start": "1232500",
    "end": "1239550"
  },
  {
    "text": "address you can pass that around and use it safely in all subsequent code the compiler prevents you from passing a",
    "start": "1239550",
    "end": "1245640"
  },
  {
    "text": "string to a function that expects an email address because a string and an email address are not the same type the",
    "start": "1245640",
    "end": "1250770"
  },
  {
    "text": "email address is a new type code that takes an email address can know that it",
    "start": "1250770",
    "end": "1255930"
  },
  {
    "text": "doesn't need to deal with invalid email addresses which simplifies the code and helps eliminate bugs it also makes your",
    "start": "1255930",
    "end": "1263760"
  },
  {
    "text": "type signatures file or more descriptive which helps the understandability of the code so have a look at the send email",
    "start": "1263760",
    "end": "1269910"
  },
  {
    "text": "type signature and this is kind of an extreme example but you can see that it takes an email address a subject and a",
    "start": "1269910",
    "end": "1275400"
  },
  {
    "text": "body just from the types if this was just a string string string that'd be far less useful we can't",
    "start": "1275400",
    "end": "1282060"
  },
  {
    "text": "accidentally pass a body where the subject would go or vice versa that would be a compiler over because subject",
    "start": "1282060",
    "end": "1288120"
  },
  {
    "text": "and body are at the same time and the best thing about new types in Haskell is that they're cost free at runtime the",
    "start": "1288120",
    "end": "1294750"
  },
  {
    "text": "compiler after type checking will actually substitute the unwrapped type so there are no extra memory allocations",
    "start": "1294750",
    "end": "1300420"
  },
  {
    "text": "needed for that wrapper type at all and this is unlike in other languages where a wrapper types often have a runtime",
    "start": "1300420",
    "end": "1305790"
  },
  {
    "text": "performance in memory penalty so here's",
    "start": "1305790",
    "end": "1310890"
  },
  {
    "text": "a practical example of where new types can help improve code clarity on a pass gig I saw some code in a class that",
    "start": "1310890",
    "end": "1317460"
  },
  {
    "text": "talked to an API that deals with some IOT devices the developer who wrote the code made a responsive",
    "start": "1317460",
    "end": "1323520"
  },
  {
    "text": "tea class to represent either some error of return sorry some data that's returned by that API call so that would",
    "start": "1323520",
    "end": "1329100"
  },
  {
    "text": "be whatever the T is or an error if in a string if that if something happened to",
    "start": "1329100",
    "end": "1335070"
  },
  {
    "text": "that API call he had some methods that call that that backing API so I put the type signature for a couple of them up",
    "start": "1335070",
    "end": "1341310"
  },
  {
    "text": "there one was called get devices and it returns a responsive string it turns out",
    "start": "1341310",
    "end": "1346770"
  },
  {
    "text": "that string was actually the entire jason body of the HTTP response he also had get device serial which got the",
    "start": "1346770",
    "end": "1354600"
  },
  {
    "text": "serial number of a device given a particular ID but it also returned a responsive string except in this case",
    "start": "1354600",
    "end": "1360330"
  },
  {
    "text": "the string was a serial number so straight away we can see some issues with this code right both methods",
    "start": "1360330",
    "end": "1365340"
  },
  {
    "text": "ostensibly return the same thing but it's not really the same thing and it's hard to tell what they actually return",
    "start": "1365340",
    "end": "1371220"
  },
  {
    "text": "without looking the implement at the implementation of those methods the response type also doesn't stop you from",
    "start": "1371220",
    "end": "1377280"
  },
  {
    "text": "having a null data or an error or even both data or error being said at the same time in c-sharp to create a wrapper",
    "start": "1377280",
    "end": "1386160"
  },
  {
    "text": "type around those strings to distinguish between adjacent string and a device serial you need to create a new class",
    "start": "1386160",
    "end": "1391500"
  },
  {
    "text": "but this is kind of ugly because it incurs an extra memory allocation that value that value property could still be",
    "start": "1391500",
    "end": "1397830"
  },
  {
    "text": "null and you can't compare that type for quality like you can the string so you",
    "start": "1397830",
    "end": "1403320"
  },
  {
    "text": "can fix all those issues but it requires lines and lines of tedious and error-prone code in high school this is",
    "start": "1403320",
    "end": "1410640"
  },
  {
    "text": "a non-issue we can simply create cost free new type wrappers for all of those types and we can use the either type to",
    "start": "1410640",
    "end": "1418710"
  },
  {
    "text": "to model that alternative between a success and a failure we could even create a some type for the error to",
    "start": "1418710",
    "end": "1424500"
  },
  {
    "text": "explicitly describe the set of errors that we expect rather than just using a string so straight away it's now clear",
    "start": "1424500",
    "end": "1431640"
  },
  {
    "text": "what our functions take and what they return so we can see where our get devices we can tell that it does some IO",
    "start": "1431640",
    "end": "1438300"
  },
  {
    "text": "because there's an IO type and it can return either an error or a JSON string and then when we look at the get device",
    "start": "1438300",
    "end": "1444120"
  },
  {
    "text": "serial we can see that it takes a device ID and it does some IO and will return either an error or a device serial so I",
    "start": "1444120",
    "end": "1450720"
  },
  {
    "text": "can look at those immediately know what I need to pass them and I know what turn so again Haskell is helping us",
    "start": "1450720",
    "end": "1457470"
  },
  {
    "text": "right understandable and correct code through its strict and expressive static type system so variables variables are",
    "start": "1457470",
    "end": "1468090"
  },
  {
    "text": "moving parts in our code and we know that undisciplined use of variables can result in code that's very difficult to",
    "start": "1468090",
    "end": "1473790"
  },
  {
    "text": "reason about and therefore get correct and bug free and maintained into the future working with immutable data",
    "start": "1473790",
    "end": "1480030"
  },
  {
    "text": "structures can simplify code by removing those moving parts in our code the variables it's not that immutable data",
    "start": "1480030",
    "end": "1487620"
  },
  {
    "text": "structures don't change it's a it's just that they operate on a copy-on-write basis so modifying an immutable data",
    "start": "1487620",
    "end": "1494490"
  },
  {
    "text": "structure results in new copy being created that incorporates those modifications and this isn't necessarily",
    "start": "1494490",
    "end": "1500460"
  },
  {
    "text": "as inefficient as it sounds as many data structures immutable data structures will reuse a large part of the old data",
    "start": "1500460",
    "end": "1507120"
  },
  {
    "text": "structure in the new version so for example a Haskell list is a singly linked list so adding a new element to",
    "start": "1507120",
    "end": "1513600"
  },
  {
    "text": "the list simply means adding a new node to the front of the existing data structure and as you can see up on the",
    "start": "1513600",
    "end": "1519240"
  },
  {
    "text": "slide list a hasn't changed at all but list B includes lists as nodes inside itself all data types in Haskell are",
    "start": "1519240",
    "end": "1528960"
  },
  {
    "text": "immutable it's not possible to create mutable data types in Haskell at all and this guarantee takes a lot of complexity",
    "start": "1528960",
    "end": "1536280"
  },
  {
    "text": "and unknowns out of your code immediately you never need to worry about whether a type might be mutable",
    "start": "1536280",
    "end": "1541920"
  },
  {
    "text": "and therefore whether you need to worry about it being mutated or unexpectedly if I pass a data structure to a function",
    "start": "1541920",
    "end": "1548070"
  },
  {
    "text": "it is a hundred percent guaranteed that that function can't mess with it if I pass a list to a method in c-sharp for",
    "start": "1548070",
    "end": "1554670"
  },
  {
    "text": "example I don't get a guarantee that that method isn't going to modify the list or it might even modify something",
    "start": "1554670",
    "end": "1559800"
  },
  {
    "text": "inside the list in Haskell as a function author if I I know that if I'm past",
    "start": "1559800",
    "end": "1565830"
  },
  {
    "text": "something I can safely use it without worrying that something else that I don't know about perhaps on another",
    "start": "1565830",
    "end": "1570870"
  },
  {
    "text": "thread might change that thing that I have I don't have to check that assumption in high school it's a",
    "start": "1570870",
    "end": "1576300"
  },
  {
    "text": "guarantee so Haskell has language features that make it really easy to work with",
    "start": "1576300",
    "end": "1581550"
  },
  {
    "text": "immutable data structures so up on the slide I've defined a Haskell record type called book",
    "start": "1581550",
    "end": "1587370"
  },
  {
    "text": "contains title and author fields we can then define a function called change",
    "start": "1587370",
    "end": "1593250"
  },
  {
    "text": "title that takes a new title and an old book and creates a new book based on the",
    "start": "1593250",
    "end": "1598350"
  },
  {
    "text": "old book and just changes the title on it so Haskell will take care of copying all the other fields on that on that",
    "start": "1598350",
    "end": "1604650"
  },
  {
    "text": "book such as the author forests and that works even if there are more fields there so if we had 10 extra fields on",
    "start": "1604650",
    "end": "1611040"
  },
  {
    "text": "that book record type that change title code wouldn't change it wouldn't change at all it would stay the same and the",
    "start": "1611040",
    "end": "1616590"
  },
  {
    "text": "compiler would just behind the scenes copy those extra fields for us and this is in stark contrast to languages like C",
    "start": "1616590",
    "end": "1622559"
  },
  {
    "text": "sharp well we're working and creating immutable data structures is extremely",
    "start": "1622559",
    "end": "1627720"
  },
  {
    "text": "tedious you need to create a class with read only properties you need a constructor that'll take all the values",
    "start": "1627720",
    "end": "1632760"
  },
  {
    "text": "and set the properties and you need to write methods to manually do that copy-on-write it's so painful it's not",
    "start": "1632760",
    "end": "1639450"
  },
  {
    "text": "surprising that nobody does it functions",
    "start": "1639450",
    "end": "1644550"
  },
  {
    "text": "take input and they return output a pure function is one that does no",
    "start": "1644550",
    "end": "1649740"
  },
  {
    "text": "side-effects and that when given the same input will always deterministically return the same output impure functions",
    "start": "1649740",
    "end": "1657480"
  },
  {
    "text": "are harder to maintain and reason about because they depend upon shared state so in order to think about what an impure",
    "start": "1657480",
    "end": "1663300"
  },
  {
    "text": "function does you have to kind of expand your mind to encompass every other piece of code that modifies that shared state",
    "start": "1663300",
    "end": "1669150"
  },
  {
    "text": "with it as well as that impure function that you're trying to understand at hand pure functions by contrast can be viewed",
    "start": "1669150",
    "end": "1676710"
  },
  {
    "text": "and understood entirely in isolation their type signatures give a very strong signal as to what they do which is",
    "start": "1676710",
    "end": "1682890"
  },
  {
    "text": "really nice when it comes to maintainability because I don't need to dive into implementations to see what something does you can just look at the",
    "start": "1682890",
    "end": "1690390"
  },
  {
    "text": "types of a pure function and go oh yeah I kind of see what that thing does and there's no fear that they might be doing",
    "start": "1690390",
    "end": "1695820"
  },
  {
    "text": "might be doing some invisible side-effects in its implementation that you actually do need to know about so if",
    "start": "1695820",
    "end": "1702660"
  },
  {
    "text": "we look at that map function type signature up in the slide which we've seen before but you might recognize it",
    "start": "1702660",
    "end": "1708150"
  },
  {
    "text": "as select from C sharp we can see that we give it a function that converts an A",
    "start": "1708150",
    "end": "1714660"
  },
  {
    "text": "into a B and we can and we also give it a list of A's and it will return back to us a list",
    "start": "1714660",
    "end": "1720130"
  },
  {
    "text": "B's so the a and B here abstract and that's like generics in c-sharp or Java",
    "start": "1720130",
    "end": "1726370"
  },
  {
    "text": "there's no typecasting in Haskell so when a function receives an abstract type like an A or a B it literally can",
    "start": "1726370",
    "end": "1733990"
  },
  {
    "text": "do nothing with it at all because it doesn't know what it doesn't know what it is - it is just this is an a I don't",
    "start": "1733990",
    "end": "1739120"
  },
  {
    "text": "know anything more about it in this case the map function can do nothing with an A or a B except for one thing it can",
    "start": "1739120",
    "end": "1745870"
  },
  {
    "text": "convert an A into a B and that's only because it was given a function that can convert an A into a B so as someone",
    "start": "1745870",
    "end": "1755200"
  },
  {
    "text": "looking at this function you know that there cannot be any black magic going on inside this function at all that could bite you because all data types are",
    "start": "1755200",
    "end": "1762520"
  },
  {
    "text": "immutable in Haskell you know the list that this produces must be a new list and that original list that you pass it",
    "start": "1762520",
    "end": "1768130"
  },
  {
    "text": "will remain untouched you don't need to check the documentation or the implementation to know this and this",
    "start": "1768130",
    "end": "1773860"
  },
  {
    "text": "strictness gives you confidence as a developer to know what a function can do without checking its implementation for",
    "start": "1773860",
    "end": "1780160"
  },
  {
    "text": "unexpected behavior it means you can write and refactor code with confidence",
    "start": "1780160",
    "end": "1785790"
  },
  {
    "text": "this is in contrast to other less strict FP languages like F sharp for example if",
    "start": "1785790",
    "end": "1791470"
  },
  {
    "text": "I see a function in F sharp there's no guarantee that that function doesn't modify some static variable or mutated",
    "start": "1791470",
    "end": "1797530"
  },
  {
    "text": "cinput parameters or perform any other side effect inside itself now it's good practice in F sharp to not do that and",
    "start": "1797530",
    "end": "1803590"
  },
  {
    "text": "to work with immutable data types but because mutability and impurity are allowed in the language you don't have",
    "start": "1803590",
    "end": "1810160"
  },
  {
    "text": "that absolute guarantee like you do in haskell you lose a level of trust and you have to spend a bit more time checking your assumptions so for example",
    "start": "1810160",
    "end": "1817660"
  },
  {
    "text": "look at the F sharp version of the change title function up on the slide I can see that it takes a new title and an",
    "start": "1817660",
    "end": "1824710"
  },
  {
    "text": "existing book and it returns a book but unless I check that book is actually in",
    "start": "1824710",
    "end": "1829720"
  },
  {
    "text": "a mutable type I've no guarantee that this function is actually a pure so for example book might be a mutable class",
    "start": "1829720",
    "end": "1836200"
  },
  {
    "text": "type and change title might be mutating that input book and returning it now this would be very poor form an F sharp",
    "start": "1836200",
    "end": "1841720"
  },
  {
    "text": "and if I found it in a PR that PR would be sent back and you would have to change that to an immutable immutable",
    "start": "1841720",
    "end": "1848110"
  },
  {
    "text": "type but in F sharp it is possible so you lose that level of trust in Haskell this is impossible because",
    "start": "1848110",
    "end": "1855590"
  },
  {
    "text": "mutability doesn't exist so Haskell's restrictions of requiring immutability and purity actually benefit the",
    "start": "1855590",
    "end": "1861830"
  },
  {
    "text": "developer by ensuring that he or she can make safe assumptions about how code works immutability and pure functions",
    "start": "1861830",
    "end": "1871640"
  },
  {
    "text": "also aid us and writing testable code so pure functions are naturally testable because they don't have any side effects",
    "start": "1871640",
    "end": "1877400"
  },
  {
    "text": "if you give a few if you give a pure function the same input it will always deterministically return the same output",
    "start": "1877400",
    "end": "1884510"
  },
  {
    "text": "which makes it super-easy to test you just pass your input and assert that it returns what you expect pretty simple as",
    "start": "1884510",
    "end": "1891620"
  },
  {
    "text": "a contrast in pure code that has side effects either can't be tested or it",
    "start": "1891620",
    "end": "1897230"
  },
  {
    "text": "must have those side effects mock down and carefully managed resulting in complex and fragile tests pure code is",
    "start": "1897230",
    "end": "1904730"
  },
  {
    "text": "also very easy to make concurrent the biggest issue with writing concurrent code is dealing with race conditions",
    "start": "1904730",
    "end": "1909919"
  },
  {
    "text": "where two threads will modify the shared state in unexpected ways and in unexpected times because pure code only",
    "start": "1909919",
    "end": "1917990"
  },
  {
    "text": "works with immutable datatypes it's impossible for multiple threads running pure code to interfere with each other",
    "start": "1917990",
    "end": "1924740"
  },
  {
    "text": "since because this mutable state just doesn't exist so Haskell's purity guarantee that means you can trust that",
    "start": "1924740",
    "end": "1931010"
  },
  {
    "text": "any pure functions are safe to use in concurrent parts of your application they can't modify any shared state by",
    "start": "1931010",
    "end": "1936860"
  },
  {
    "text": "definition which means that you know for sure that whole classes of race conditions are just not possible you",
    "start": "1936860",
    "end": "1941929"
  },
  {
    "text": "don't need to check you can just use it and it works this is another haskell",
    "start": "1941929",
    "end": "1946970"
  },
  {
    "text": "guarantee that gives you confidence that you're writing correct code so purity is",
    "start": "1946970",
    "end": "1953210"
  },
  {
    "text": "all well and good but your programs kind of useless unless it can actually do some side-effects and affect the real",
    "start": "1953210",
    "end": "1958610"
  },
  {
    "text": "world so if Haskell so pure how do we manage impurity so a function for getting the",
    "start": "1958610",
    "end": "1965000"
  },
  {
    "text": "current time is a good simple example on the slide up at the top there's a function that takes unit which is a bit",
    "start": "1965000",
    "end": "1970580"
  },
  {
    "text": "like void and it returns the current time however that function is actually impossible in high school since for that",
    "start": "1970580",
    "end": "1977419"
  },
  {
    "text": "function to return a different UTC time each time it's called with the same input to the same void like unit it",
    "start": "1977419",
    "end": "1984860"
  },
  {
    "text": "would have to violate purity because pure functions must be deterministic given the same input they must return the same output so given the",
    "start": "1984860",
    "end": "1991100"
  },
  {
    "text": "same unit I get a different time every time I call it so this is where Pascal's IO monad comes in the IO monad allows us",
    "start": "1991100",
    "end": "1999440"
  },
  {
    "text": "to write impure code in a pure way so to get our current time our get current",
    "start": "1999440",
    "end": "2004480"
  },
  {
    "text": "time function would probably look more like that it would return an IO of UTC",
    "start": "2004480",
    "end": "2010929"
  },
  {
    "text": "time and in fact because of purity this function would always have to return the same IO of UTC time anyway because given",
    "start": "2010929",
    "end": "2018490"
  },
  {
    "text": "the same input must return the same output so we can just drop that input parameter and just have a value instead",
    "start": "2018490",
    "end": "2023679"
  },
  {
    "text": "of a function and the value is of type IO of UTC time so how can we use this well",
    "start": "2023679",
    "end": "2030490"
  },
  {
    "text": "let's write something simple that calculates the current time and adds 10 seconds to it to do this we can use the",
    "start": "2030490",
    "end": "2036399"
  },
  {
    "text": "bind operator which kind of allows us to hook a function up that receives the",
    "start": "2036399",
    "end": "2041559"
  },
  {
    "text": "value inside the IO so here we're using a lambda function and that's what--that's slash in arrow syntaxes and",
    "start": "2041559",
    "end": "2048490"
  },
  {
    "text": "that lambda function will take the current time out of the IO and then add 10 seconds to it this lambda function",
    "start": "2048490",
    "end": "2056319"
  },
  {
    "text": "itself is still pure code given the same time it will always return the same",
    "start": "2056319",
    "end": "2063040"
  },
  {
    "text": "value the IO type in the signature is a big signal to the developer that there's",
    "start": "2063040",
    "end": "2068648"
  },
  {
    "text": "some impure stuff going on inside this code which is a big bonus for code readability now these io values are just potential",
    "start": "2068649",
    "end": "2075760"
  },
  {
    "text": "values to actually run them and see them to i/o you actually have to hook them up to the real worlds and we can do this by",
    "start": "2075760",
    "end": "2081339"
  },
  {
    "text": "hooking them up to the programs main entry point so in the case up on the slide we've got a little program that",
    "start": "2081339",
    "end": "2086878"
  },
  {
    "text": "reads the current time adds 10 seconds to it and then prints that to the console and quits so we can now affect",
    "start": "2086879",
    "end": "2096970"
  },
  {
    "text": "the real world by using the IO monad however this doesn't mean we want to do our entire program inside of IO what we",
    "start": "2096970",
    "end": "2104380"
  },
  {
    "text": "want to achieve is the majority of our code to be written outside of IO in a pure fashion and then we connect its",
    "start": "2104380",
    "end": "2109660"
  },
  {
    "text": "edges up to the real world with a little bit of IO so in other words we want to push IO to the edges of our application",
    "start": "2109660",
    "end": "2115480"
  },
  {
    "text": "and this makes our code a lot easier to test and reason about so here's a micro example of how we",
    "start": "2115480",
    "end": "2122720"
  },
  {
    "text": "could cut up that previous code that we wrote in order to keep the obits separate from the actual program logic",
    "start": "2122720",
    "end": "2127849"
  },
  {
    "text": "so notice how we've pulled out that pure lambda into a separate function we can test and reason about that more easily",
    "start": "2127849",
    "end": "2134390"
  },
  {
    "text": "now seeing the IO type on functions and values is an instant indication that",
    "start": "2134390",
    "end": "2140779"
  },
  {
    "text": "there's some sort of side effect going on inside that code and this makes the division between impure and pure code",
    "start": "2140779",
    "end": "2146509"
  },
  {
    "text": "very obvious and never a nasty surprise to the developer and this is important when writing new code or refactoring",
    "start": "2146509",
    "end": "2152720"
  },
  {
    "text": "existing code because you can immediately start thinking about all the additional complexities that side effect",
    "start": "2152720",
    "end": "2157730"
  },
  {
    "text": "of all code introduces and be wary on the flip side not seeing io means you",
    "start": "2157730",
    "end": "2162859"
  },
  {
    "text": "don't need to think about those complexities at all so you have that level of trust",
    "start": "2162859",
    "end": "2167680"
  },
  {
    "text": "Haskell makes it very very easy to get value semantics for your data types now valley semantics is where the",
    "start": "2170950",
    "end": "2177589"
  },
  {
    "text": "identity of an object is determined by its value rather than by the particular instance of the object in memory so for",
    "start": "2177589",
    "end": "2183769"
  },
  {
    "text": "example instance strings in c-sharp have value semantics I can have the same string two instances in memory and if I",
    "start": "2183769",
    "end": "2189710"
  },
  {
    "text": "say equals they'll be considered to be equal but by default classes in c-sharp have reference to quality so if I knew",
    "start": "2189710",
    "end": "2196640"
  },
  {
    "text": "up this the same class that have the same properties on it unless I override equals and I say if these are equal",
    "start": "2196640",
    "end": "2201980"
  },
  {
    "text": "LeBeau no because these are two different objects in memory so when types are mutable value semantics can be",
    "start": "2201980",
    "end": "2208640"
  },
  {
    "text": "tricky because equality results can change as the instance mutates but since",
    "start": "2208640",
    "end": "2213859"
  },
  {
    "text": "everything in Haskell is immutable it's very easy to start using value semantics in fact usually all you need to do is",
    "start": "2213859",
    "end": "2219890"
  },
  {
    "text": "ask the compiler to derive the EQ type class on your type and you've got equality for free have you ever tried to",
    "start": "2219890",
    "end": "2227480"
  },
  {
    "text": "write a test where you need to compare a list of objects or nested object graphs this is super painful to do without",
    "start": "2227480",
    "end": "2234410"
  },
  {
    "text": "value semantics you have to compare each list element individually typically in a loop and then compare each property",
    "start": "2234410",
    "end": "2240589"
  },
  {
    "text": "individually with your assertion library wouldn't be better if you could just construct the expected result and just",
    "start": "2240589",
    "end": "2246799"
  },
  {
    "text": "go equals well in Haskell you can so we could write a unit test that for example gets a list of transactions",
    "start": "2246799",
    "end": "2254000"
  },
  {
    "text": "and simply does a comparison between the expected list and the actual list using",
    "start": "2254000",
    "end": "2259040"
  },
  {
    "text": "equals and that's all this should be function is doing under the covers it just doesn't equals and the other",
    "start": "2259040",
    "end": "2264380"
  },
  {
    "text": "stuff that it does is if it is not equals it prints out nice things on your test runner lists in Haskell are also",
    "start": "2264380",
    "end": "2271460"
  },
  {
    "text": "equatable so long as what they contain is equatable so in this case our transaction data type is equatable",
    "start": "2271460",
    "end": "2277400"
  },
  {
    "text": "because we derived a queue on it so the lists are also naturally equatable as well which means that we can just do",
    "start": "2277400",
    "end": "2283550"
  },
  {
    "text": "should be on the two lists and it works so compare how easy this was to achieve",
    "start": "2283550",
    "end": "2289280"
  },
  {
    "text": "versus how you'd need to do it in F sharp or C sharp well in F sharp it's actually easy even in C sharp it's a bit",
    "start": "2289280",
    "end": "2295550"
  },
  {
    "text": "more painful so in C sharp if we wanted to implement value semantics you'd need",
    "start": "2295550",
    "end": "2300650"
  },
  {
    "text": "to implement equals yourself and you need to do it for each of your types and you need to compare each property on the",
    "start": "2300650",
    "end": "2306680"
  },
  {
    "text": "type by hand and if you added a new property later you'd better remember to update your equals implementation or",
    "start": "2306680",
    "end": "2312260"
  },
  {
    "text": "you've got a subtle bug in highschool the compiler takes care of it for you ensuring that you can easily modify your",
    "start": "2312260",
    "end": "2319010"
  },
  {
    "text": "code with confidence into the future so if I went and added and say in the future description to my transaction I",
    "start": "2319010",
    "end": "2325130"
  },
  {
    "text": "wouldn't have to change anything except I'd have to modify that test so the compiler would catch me there because",
    "start": "2325130",
    "end": "2330560"
  },
  {
    "text": "I'm creating transactions are not sending the description so property",
    "start": "2330560",
    "end": "2337910"
  },
  {
    "text": "testing is another thing that's really easy to do in high school especially with value semantics being so easily",
    "start": "2337910",
    "end": "2343400"
  },
  {
    "text": "doable so probably testing is where you can have your test framework generate",
    "start": "2343400",
    "end": "2348560"
  },
  {
    "text": "random input values and then you write a test to check whether your code works in",
    "start": "2348560",
    "end": "2354080"
  },
  {
    "text": "a certain way for all the generated input values so in other words for all inputs a certain property holds for your",
    "start": "2354080",
    "end": "2360590"
  },
  {
    "text": "code under test so the textbook example of this is if you're writing tests for a",
    "start": "2360590",
    "end": "2366110"
  },
  {
    "text": "list reversing function so a property of reversing a list is if you reverse a list twice you get back what you started",
    "start": "2366110",
    "end": "2373690"
  },
  {
    "text": "so this property holds no matter what type of list you give the reverse function so you can see in the code up",
    "start": "2373690",
    "end": "2381080"
  },
  {
    "text": "on the slide we're passing a lambda function to the to the tests the test framework we'll call our",
    "start": "2381080",
    "end": "2387080"
  },
  {
    "text": "lambda function over and over and over and it will pass in empty lists it'll pass in lists was one things in them it",
    "start": "2387080",
    "end": "2392360"
  },
  {
    "text": "will pass the list with two things this were ten things and it will do that a number of times and we ascertain our",
    "start": "2392360",
    "end": "2397730"
  },
  {
    "text": "test that the input list is the same as reversing the list twice now if any",
    "start": "2397730",
    "end": "2403700"
  },
  {
    "text": "input causes that assertion to fail then our property test fails properties are",
    "start": "2403700",
    "end": "2409670"
  },
  {
    "text": "particular to your domain so imagine an our domain we could say that all invoices must generate at least two",
    "start": "2409670",
    "end": "2415430"
  },
  {
    "text": "transactions we could write a property test that generates random invoices and checks that our transaction list length",
    "start": "2415430",
    "end": "2421250"
  },
  {
    "text": "is always greater than or equal to two so property testing is a great way to",
    "start": "2421250",
    "end": "2426680"
  },
  {
    "text": "ensure that you're writing correct code that stays correct as you change it over time Highschool is a lazy evaluation",
    "start": "2426680",
    "end": "2436400"
  },
  {
    "text": "language as opposed to the strict evaluation languages that we'd normally use this means that you can write code",
    "start": "2436400",
    "end": "2443330"
  },
  {
    "text": "in a way that appears to be inefficient from a strict language point of view but since high school only evaluates what's",
    "start": "2443330",
    "end": "2449990"
  },
  {
    "text": "necessary when it's actually required your code executes sufficiently anyway",
    "start": "2449990",
    "end": "2455260"
  },
  {
    "text": "laziness helps you subtly all over the place when you're writing high school so to demonstrate laziness on this slide",
    "start": "2455260",
    "end": "2461270"
  },
  {
    "text": "we're going to use the from maybe function and let's see how that function works before we use it so from maybe",
    "start": "2461270",
    "end": "2466640"
  },
  {
    "text": "we'll take a maybe value and a fallback value and if the maybe exists then it'll just return what's inside the maybe so",
    "start": "2466640",
    "end": "2473330"
  },
  {
    "text": "if it's just it returns it but if it's nothing then it returns your fallback",
    "start": "2473330",
    "end": "2479120"
  },
  {
    "text": "value so for example here where we pass just something we get back something but if we pass nothing then we get back our",
    "start": "2479120",
    "end": "2485750"
  },
  {
    "text": "fallback value so you can think of it a bit like a null coalesce in c-sharp now",
    "start": "2485750",
    "end": "2491930"
  },
  {
    "text": "let's see how laziness kicks in when we look at the code at the bottom of the slide in a strict language that",
    "start": "2491930",
    "end": "2497990"
  },
  {
    "text": "expensive value would be evaluated before it's passed to from maybe so we'd pay the costs of calculating that",
    "start": "2497990",
    "end": "2504440"
  },
  {
    "text": "fallback value even though it wasn't necessarily going to be used in high school expressions are only evaluated",
    "start": "2504440",
    "end": "2511310"
  },
  {
    "text": "when their value is actually required so the millionth prime that we're calculating here is the fallback value",
    "start": "2511310",
    "end": "2516830"
  },
  {
    "text": "would only be calculated if there maybe was nothing if there maybe was just then we don't need that",
    "start": "2516830",
    "end": "2522470"
  },
  {
    "text": "fallback value so it will never be calculated here's another example",
    "start": "2522470",
    "end": "2528040"
  },
  {
    "text": "imagine we're transforming each item in the big list with an expensive calculation so that weird dollar symbol",
    "start": "2528040",
    "end": "2533990"
  },
  {
    "text": "is map so like select in NC shop now we",
    "start": "2533990",
    "end": "2539540"
  },
  {
    "text": "only want the 101st of 150 lament from that list we want to drop the first 100 and take the next 5 in a strict language",
    "start": "2539540",
    "end": "2548000"
  },
  {
    "text": "if we wrote it this way we'd be paying that expensive transform costs for those first at least the first 100 list",
    "start": "2548000",
    "end": "2554510"
  },
  {
    "text": "elements the ones that were dropping on the floor before we get to the five that we actually want however in Haskell",
    "start": "2554510",
    "end": "2560140"
  },
  {
    "text": "laziness ensures that that transform will only be done when required so when we eventually look at the five elements",
    "start": "2560140",
    "end": "2566540"
  },
  {
    "text": "that we've picked out of the list the transform will be done then and only on those five elements the hundred that we dropped and just lost that will never do",
    "start": "2566540",
    "end": "2574310"
  },
  {
    "text": "that transform on them laziness means that you can write code more declaratively in a way that makes makes",
    "start": "2574310",
    "end": "2581870"
  },
  {
    "text": "sense it reads more cleanly and only the parts that are actually needed are actually run however laziness is a",
    "start": "2581870",
    "end": "2590690"
  },
  {
    "text": "double-edged sword you get those execution efficiencies but you can also get cut by a new type of memory leaf",
    "start": "2590690",
    "end": "2596600"
  },
  {
    "text": "called a space lick and this is where because of laziness you may retain things in memory longer than you expect",
    "start": "2596600",
    "end": "2603050"
  },
  {
    "text": "because the code that would otherwise decide to drop that memory hasn't actually run yet so on a pass Haskell",
    "start": "2603050",
    "end": "2609590"
  },
  {
    "text": "project that I worked on we had an issue where we loaded a whole bunch of jobs out of a CSV data source and we put them",
    "start": "2609590",
    "end": "2615140"
  },
  {
    "text": "into a map so that we could look them up easily now each CSV row that we had would",
    "start": "2615140",
    "end": "2620630"
  },
  {
    "text": "contain far more information than we actually needed it was quite a big CSV so we only stored the few columns that",
    "start": "2620630",
    "end": "2626750"
  },
  {
    "text": "we actually cared about in our job record type which you can see up on the slide however when we ran this thing our",
    "start": "2626750",
    "end": "2633740"
  },
  {
    "text": "program used a lot of memory for no apparent reason even though we were keeping only a few fields from each row",
    "start": "2633740",
    "end": "2639920"
  },
  {
    "text": "and you can see the chart the Haskell memory profiler generated for us up on the slides we used a lot of memory and",
    "start": "2639920",
    "end": "2645680"
  },
  {
    "text": "we're like what so what was actually happening was that each CSV row was",
    "start": "2645680",
    "end": "2651140"
  },
  {
    "text": "being read in form M read into memory for pausing however when we set the properties on those on",
    "start": "2651140",
    "end": "2656450"
  },
  {
    "text": "those records such as job ID the actual pausing of that row in memory to get those fields out of the row in memory",
    "start": "2656450",
    "end": "2663740"
  },
  {
    "text": "was lazy so until we actually needed the values of the properties on the job record that",
    "start": "2663740",
    "end": "2670550"
  },
  {
    "text": "pausing wasn't being done because it was lazy and therefore the memory holding what was going to be paused was kept",
    "start": "2670550",
    "end": "2677270"
  },
  {
    "text": "around so effectively it did the opposite of what we wanted and loaded the entire CSV into memory until we",
    "start": "2677270",
    "end": "2683090"
  },
  {
    "text": "looked at the jobs and then it went oh you actually want to know what the advertiser ID is cool I'll do the pausing now and here's your advertiser",
    "start": "2683090",
    "end": "2689210"
  },
  {
    "text": "ID so we fixed this by forcing strictness on each job as we created it",
    "start": "2689210",
    "end": "2695510"
  },
  {
    "text": "so there is a way in highschool to say no no actually run this now please and that of course forced the evaluation of",
    "start": "2695510",
    "end": "2702320"
  },
  {
    "text": "the parsing logic which now complete drops the CSV row from memory during garbage collection because we don't need",
    "start": "2702320",
    "end": "2707450"
  },
  {
    "text": "it anymore and as you can see we went from over a gigabyte of memory usage down to about 180 Meg which is much more like what we",
    "start": "2707450",
    "end": "2713960"
  },
  {
    "text": "expected now in my mind space licks are the biggest downside of high school",
    "start": "2713960",
    "end": "2719450"
  },
  {
    "text": "laziness while useful pretty much all the time in high school sometimes also",
    "start": "2719450",
    "end": "2724460"
  },
  {
    "text": "makes it harder to reason about the execution time and the memory usage of your code so you need to keep an eye on",
    "start": "2724460",
    "end": "2729620"
  },
  {
    "text": "it so you aren't in for any surprises when you're dealing with a large data set or high load however I think it's",
    "start": "2729620",
    "end": "2737270"
  },
  {
    "text": "fair to say that for any application that will experience high load or will be using a very large data set you",
    "start": "2737270",
    "end": "2742790"
  },
  {
    "text": "should probably always be testing it under that load or with that large data set so that that requirement shouldn't",
    "start": "2742790",
    "end": "2748520"
  },
  {
    "text": "be an unusual burden but it is something to keep an eye on when you're writing high school so developers these days are",
    "start": "2748520",
    "end": "2758360"
  },
  {
    "text": "excited about various language and runtimes that allow them to do asynchronous and concurrent programming",
    "start": "2758360",
    "end": "2763430"
  },
  {
    "text": "more easily traditionally threading and concurrency has been quite difficult to manage by hand so C sharps async/await nodejs is a",
    "start": "2763430",
    "end": "2771530"
  },
  {
    "text": "non-blocking i/o and go Lang's lightweight go routines have gotten developers quite rightly salivating",
    "start": "2771530",
    "end": "2778060"
  },
  {
    "text": "Haskell also has a very elegant and powerful handling of asynchrony and concurrency so high scores of runtime",
    "start": "2778060",
    "end": "2783980"
  },
  {
    "text": "uses a lightweight threading which means that you can spin spin up and use very like loads and loads of",
    "start": "2783980",
    "end": "2789560"
  },
  {
    "text": "threads with very little overhead all IO operations in Haskell are non blocking",
    "start": "2789560",
    "end": "2794840"
  },
  {
    "text": "by default in that they don't block an OS thread and this means Haskell is asynchronous by default however Haskell",
    "start": "2794840",
    "end": "2801950"
  },
  {
    "text": "does give you explicit control over when you go concurrent and when you don't so for example that read from web services",
    "start": "2801950",
    "end": "2808610"
  },
  {
    "text": "function up on the slide is asynchronous in that we get each web respond each get web response call doesn't block an OS",
    "start": "2808610",
    "end": "2815660"
  },
  {
    "text": "thread however that function doesn't perform those those requests in parallel",
    "start": "2815660",
    "end": "2820670"
  },
  {
    "text": "it does them sequentially if you want to go parallel you can ask the Haskell runtime to perform that IO concurrently",
    "start": "2820670",
    "end": "2827270"
  },
  {
    "text": "and that's what we're doing in red from Web Services in parallel the simple",
    "start": "2827270",
    "end": "2832820"
  },
  {
    "text": "change there is to just pass each i/o operation which is the get web response a and get web response b2 concurrently",
    "start": "2832820",
    "end": "2839510"
  },
  {
    "text": "and then concurrently will execute those two things in parallel and will get the response back ice cores libraries offer",
    "start": "2839510",
    "end": "2847070"
  },
  {
    "text": "many different functions that make doing things concurrently simple such as like a function that will take a list of i/o",
    "start": "2847070",
    "end": "2852980"
  },
  {
    "text": "operations and run them all in parallel though Haskell can expose to you its",
    "start": "2852980",
    "end": "2859340"
  },
  {
    "text": "underlying threading model most of the time you just work with these high-level constructs this means you usually don't mess around the threads yourself instead",
    "start": "2859340",
    "end": "2865880"
  },
  {
    "text": "you just work with concurrency functions and a kind of async/await style of coding and you let the runtime figure",
    "start": "2865880",
    "end": "2871550"
  },
  {
    "text": "out how to schedule all that stuff the best on your multiple cores and of course because there's no mutability in",
    "start": "2871550",
    "end": "2877160"
  },
  {
    "text": "high school writing concurrent code is much easier so most statically typed",
    "start": "2877160",
    "end": "2884390"
  },
  {
    "text": "languages these days support the concept of generics or type of parameterization",
    "start": "2884390",
    "end": "2889450"
  },
  {
    "text": "generic code is extremely useful for expressing abstractions that don't care about the types used within them so for",
    "start": "2889450",
    "end": "2896180"
  },
  {
    "text": "example a list of T where T can be any type at all Haskell's type system takes",
    "start": "2896180",
    "end": "2902480"
  },
  {
    "text": "us one step further by supporting a feature called higher kind of types now",
    "start": "2902480",
    "end": "2907910"
  },
  {
    "text": "you can think of kinds of a way of expressing types of types so types",
    "start": "2907910",
    "end": "2913040"
  },
  {
    "text": "without generics are just types but once you introduce generics you change the",
    "start": "2913040",
    "end": "2918230"
  },
  {
    "text": "kind of a type to be a type function so a type that takes another type and returns a type just",
    "start": "2918230",
    "end": "2923839"
  },
  {
    "text": "like a function takes a value and returns a value and this is why the maybe type has a kind of type arrow type",
    "start": "2923839",
    "end": "2931249"
  },
  {
    "text": "because it's actually a type function that takes a type and returns a type so if you call the maybe type by just",
    "start": "2931249",
    "end": "2938900"
  },
  {
    "text": "giving it another type so like if we write maybe int then you've actually invoked a type function and you've made",
    "start": "2938900",
    "end": "2944509"
  },
  {
    "text": "a type that's maybe specialized two intz higher kind of types is where you can",
    "start": "2944509",
    "end": "2951289"
  },
  {
    "text": "write generic code where the generic type parameters can be higher kind so for example type arrow type or type",
    "start": "2951289",
    "end": "2957769"
  },
  {
    "text": "arrow type arrow type and so on and you can see an example up on the slide that the map function is generic over a type",
    "start": "2957769",
    "end": "2964249"
  },
  {
    "text": "called F whose kind is type arrow type and we can tell what kind is that because we can see F has been passed a and F has",
    "start": "2964249",
    "end": "2970490"
  },
  {
    "text": "been passed B so it must be a type function now this isn't possible in",
    "start": "2970490",
    "end": "2976130"
  },
  {
    "text": "something like dotnet unfortunately and you can see where I've tried to write what it might look like in c-sharp but you can't do that that will obviously be",
    "start": "2976130",
    "end": "2982160"
  },
  {
    "text": "a compile error but it is possible in a language like Haskell so type classes",
    "start": "2982160",
    "end": "2989809"
  },
  {
    "text": "are another Haskell feature that when used with higher coded types allow us to write some extremely powerful abstractions these abstractions make our",
    "start": "2989809",
    "end": "2997279"
  },
  {
    "text": "code far less noisy and allow for high levels of code reuse don't confuse type classes with oo",
    "start": "2997279",
    "end": "3003160"
  },
  {
    "text": "classes just because it has the word class in there type classes are more like traits if you've ever used a language that has traits and maybe you",
    "start": "3003160",
    "end": "3010569"
  },
  {
    "text": "could stretch it and say they're a little bit like interfaces so let's see one in action we can define a type class",
    "start": "3010569",
    "end": "3016450"
  },
  {
    "text": "called a functor that has a higher kind of type called F and defines a single function called map which we've seen a",
    "start": "3016450",
    "end": "3022930"
  },
  {
    "text": "number of times now so just think select in your head so we can create an",
    "start": "3022930",
    "end": "3028930"
  },
  {
    "text": "instance of this type class for the maybe type and so that means when we use",
    "start": "3028930",
    "end": "3034960"
  },
  {
    "text": "the map function on Maeby's the compiler knows oh I know how to implement functor",
    "start": "3034960",
    "end": "3040450"
  },
  {
    "text": "for Maeby's and i go here and this is where my map function is defined so you",
    "start": "3040450",
    "end": "3046480"
  },
  {
    "text": "can see on the right hand of this of the slide where we're passing an inter string function to the map along with a",
    "start": "3046480",
    "end": "3051579"
  },
  {
    "text": "maybe to convert the in that might be inside the maybe into a string if it's their honor if we",
    "start": "3051579",
    "end": "3058160"
  },
  {
    "text": "substitute the concrete types into the map type signature so that's the Green Line we can see that a has is now int B",
    "start": "3058160",
    "end": "3064789"
  },
  {
    "text": "is string and F is may be and we can implement functor for many more types so",
    "start": "3064789",
    "end": "3071420"
  },
  {
    "text": "for example list and i/o and we can use map in exactly the same way so you can",
    "start": "3071420",
    "end": "3076549"
  },
  {
    "text": "see in each of those in the green type signatures the only thing that's different is that F is list and i/o",
    "start": "3076549",
    "end": "3081940"
  },
  {
    "text": "respectively and this is very powerful because what it means is that we can write a function",
    "start": "3081940",
    "end": "3088220"
  },
  {
    "text": "that works for any functor so for example we could make an inter string any functor version of those functions",
    "start": "3088220",
    "end": "3095270"
  },
  {
    "text": "that works for any functor we give it and we can see in the type of signature that we've basically pinned int and",
    "start": "3095270",
    "end": "3102230"
  },
  {
    "text": "string but we've left F to be abstract and we're saying that F must be a functor so type classes let us write",
    "start": "3102230",
    "end": "3110480"
  },
  {
    "text": "functions that are abstract over types and therefore get really good code reusability it also means that when I",
    "start": "3110480",
    "end": "3116359"
  },
  {
    "text": "look at a function like inter string any functor I have confidence that the only thing that it can do with that F type is",
    "start": "3116359",
    "end": "3121809"
  },
  {
    "text": "use the map function on it because the only thing it knows about F is that F is a function and a functor can do map this",
    "start": "3121809",
    "end": "3129349"
  },
  {
    "text": "means that I can trust that if I pass the list it's not going to mess with that list in an unexpected way the only thing they can do with it is do a map",
    "start": "3129349",
    "end": "3136250"
  },
  {
    "text": "over it again this clarity and strictness means that we can look at a",
    "start": "3136250",
    "end": "3141289"
  },
  {
    "text": "function and be comfortable what it can and can't do and therefore write and refactor code more confidently there are",
    "start": "3141289",
    "end": "3147289"
  },
  {
    "text": "no surprises or black magic allowed at all so the nice thing about programming",
    "start": "3147289",
    "end": "3153829"
  },
  {
    "text": "in Haskell is that Haskell is a functional first language other functional languages come with a baggage",
    "start": "3153829",
    "end": "3159349"
  },
  {
    "text": "of the non FP platform that they're built on so for example Scala doesn't have mutually recursive functions because the JVM doesn't support tail",
    "start": "3159349",
    "end": "3165920"
  },
  {
    "text": "calls and this means that recursion which is a key functional technique needs to be handled with care and",
    "start": "3165920",
    "end": "3171020"
  },
  {
    "text": "scholar and often worked around with a technique called trampolining to make sure you don't blow the stack in F sharp",
    "start": "3171020",
    "end": "3176779"
  },
  {
    "text": "it doesn't unfortunately support high kind of types because the dotnet generic system doesn't support them and",
    "start": "3176779",
    "end": "3182480"
  },
  {
    "text": "Haskell's doesn't doesn't have cloves and suffer from either these problems because it's run time was designed with",
    "start": "3182480",
    "end": "3188480"
  },
  {
    "text": "functional programming in mind and it doesn't have either of these two limitations",
    "start": "3188480",
    "end": "3193900"
  },
  {
    "text": "Haskell's runtime also includes a special garbage collector that's built to handle the generation and collection",
    "start": "3193900",
    "end": "3199819"
  },
  {
    "text": "of a lot of garbage and because everything is immutable and hassle you can imagine that lots of intermediate garbage values are created during the",
    "start": "3199819",
    "end": "3206359"
  },
  {
    "text": "execution of a program so Haskell's garbage collector can take advantage of some of the guarantees that",
    "start": "3206359",
    "end": "3211460"
  },
  {
    "text": "function purity provides and it uses techniques that ensure that lots of garbage that you create in a short amount of time that you then don't use",
    "start": "3211460",
    "end": "3218390"
  },
  {
    "text": "is discarded and cleaned up with a very small cost now one of the advantages of",
    "start": "3218390",
    "end": "3226940"
  },
  {
    "text": "using a language like F sharp is that you can lean on the entire of the.net ecosystem for libraries which is really",
    "start": "3226940",
    "end": "3232460"
  },
  {
    "text": "good but the downside of this is that often you'll be dealing with oo style libraries that love their mutability and",
    "start": "3232460",
    "end": "3238010"
  },
  {
    "text": "where you'd actually rather be dealing with an FP style library that uses functional types like option which is",
    "start": "3238010",
    "end": "3244010"
  },
  {
    "text": "the maybe in f-sharp and you know uses immutable types in Haskell all the",
    "start": "3244010",
    "end": "3250670"
  },
  {
    "text": "libraries are functional and immutable so you don't have to compromise the downside being that sometimes there isn't a library for that thing that you",
    "start": "3250670",
    "end": "3256910"
  },
  {
    "text": "want now the learning curve of Haskell is one of its disadvantages learning a",
    "start": "3256910",
    "end": "3263990"
  },
  {
    "text": "language like F sharp is easier because it is a hybrid language with oo which lets you lean on your previous knowledge",
    "start": "3263990",
    "end": "3269240"
  },
  {
    "text": "as you adopt and getting used to the new functional bits and because Haskell",
    "start": "3269240",
    "end": "3274250"
  },
  {
    "text": "enforces purity and immutability and is a lazy language writing real programs and it can be quite different to using",
    "start": "3274250",
    "end": "3281059"
  },
  {
    "text": "other languages and this means there can be a fair bit of upfront learning that you need to do in order to learn how to do things in a pure functional way",
    "start": "3281059",
    "end": "3288220"
  },
  {
    "text": "however I don't think we should be surprised that this is the case and I think it's unfair to compare it in the",
    "start": "3288220",
    "end": "3293359"
  },
  {
    "text": "same way that we might compare a c-sharp developer picking up JavaScript well c-sharp and JavaScript do have their differences the syntax is still C",
    "start": "3293359",
    "end": "3300140"
  },
  {
    "text": "based there's still imperative mutable strict evaluation languages Haskell is much more different as we've seen it's",
    "start": "3300140",
    "end": "3306319"
  },
  {
    "text": "not C based it's functional it's immutable and it has lazy evaluation so naturally things are going to be",
    "start": "3306319",
    "end": "3312079"
  },
  {
    "text": "different another perspective on this is that the learning functional programming properly is actually easier in high",
    "start": "3312079",
    "end": "3318260"
  },
  {
    "text": "school because the whole language is geared for it and libraries and examples are always done in a pure functional style and of course",
    "start": "3318260",
    "end": "3324990"
  },
  {
    "text": "because pure FP is quite different to normal imperative programming it takes a little bit of learning to adjust but",
    "start": "3324990",
    "end": "3331140"
  },
  {
    "text": "you'll come out with a small sound understanding of FP principles at the end now real Haskell programs require to",
    "start": "3331140",
    "end": "3337589"
  },
  {
    "text": "pick up many different functional concepts such as functors applicatives monads of which there are many io state",
    "start": "3337589",
    "end": "3343200"
  },
  {
    "text": "may be either reader and writer and many others there's also mono transformers and",
    "start": "3343200",
    "end": "3349769"
  },
  {
    "text": "foldable and a whole bunch of others so there's lots of new things to learn but all of them are helpful abstractions",
    "start": "3349769",
    "end": "3356010"
  },
  {
    "text": "that soon become as familiar to you as the strategy pattern or the observer pattern is you know oh now don't try to",
    "start": "3356010",
    "end": "3363180"
  },
  {
    "text": "reach for your oo abstractions when you are trying to write FP code instead think about the problem that they're",
    "start": "3363180",
    "end": "3369180"
  },
  {
    "text": "originally designed to solve and think of and find out how that problem is solved using FP techniques instead so",
    "start": "3369180",
    "end": "3375720"
  },
  {
    "text": "for example in FP dependency injection is just function composition it's",
    "start": "3375720",
    "end": "3381990"
  },
  {
    "text": "important to realize that getting over high schools learning curve is absolutely an achievable task while",
    "start": "3381990",
    "end": "3388019"
  },
  {
    "text": "concepts like monads and functors sounds scary you don't actually need to be a genius or a math person to understand",
    "start": "3388019",
    "end": "3394859"
  },
  {
    "text": "them like I don't know any maths I went to Johns quantum computing stuff and he blew my mind with math there are plenty",
    "start": "3394859",
    "end": "3403200"
  },
  {
    "text": "of good tutorials online and books to read that explain what these concepts",
    "start": "3403200",
    "end": "3408539"
  },
  {
    "text": "are and why you choose to use them and I'll recommend a few at the end these abstractions aren't just academic and",
    "start": "3408539",
    "end": "3414900"
  },
  {
    "text": "learning them is an investment that does pay off as they allow you to write declarative code that has minimal",
    "start": "3414900",
    "end": "3420240"
  },
  {
    "text": "plumbing and that expresses intention more clearly because you've extracted that plumbing away from it Haskell is a",
    "start": "3420240",
    "end": "3427019"
  },
  {
    "text": "very deep language don't measure your progress by seeing how far you are away from knowing that everything that Haskell has to offer instead focus on",
    "start": "3427019",
    "end": "3434339"
  },
  {
    "text": "whether you need to know you know what you need to know in order to solve a problem that you haven't had there are corners of Haskell that you'll probably",
    "start": "3434339",
    "end": "3440279"
  },
  {
    "text": "never venture into so am I saying if you",
    "start": "3440279",
    "end": "3445319"
  },
  {
    "text": "want to do functional programming you should always use from you should always use Haskell if you want to be a real functional programmer no I'm not saying",
    "start": "3445319",
    "end": "3452640"
  },
  {
    "text": "that I would never say that Haskell should be use in all situations and I don't think I'd say that about any specific technology unfortunately the world is",
    "start": "3452640",
    "end": "3460589"
  },
  {
    "text": "not black and white it would be simpler if it was and your personal requirements might be different to mine if you don't",
    "start": "3460589",
    "end": "3466710"
  },
  {
    "text": "feel ready to go whole hog on functional programming purity and immutability then you'd like to stay in familiar dotnet or",
    "start": "3466710",
    "end": "3472319"
  },
  {
    "text": "Java and both F sharp and Scala are competent languages and I do encourage you to go off and use them with that",
    "start": "3472319",
    "end": "3478769"
  },
  {
    "text": "said I think you should consider Haskell if you've done some FP before in one of these hybrid languages and you're loving",
    "start": "3478769",
    "end": "3483839"
  },
  {
    "text": "it but you're getting frustrated when you have to cross over into that oo mutable part of the language if you've",
    "start": "3483839",
    "end": "3490079"
  },
  {
    "text": "seen how useful immutability and purity are and you want more of that",
    "start": "3490079",
    "end": "3495150"
  },
  {
    "text": "then Haskell will make you a very happy person Haskell is quite different but if",
    "start": "3495150",
    "end": "3500999"
  },
  {
    "text": "you're willing to learn new things it's extremely rewarding and absolutely within reach for those who have the",
    "start": "3500999",
    "end": "3506099"
  },
  {
    "text": "patience to learn and if correctness and clarity of paramount importance to you then Haskell is a really good choice",
    "start": "3506099",
    "end": "3512279"
  },
  {
    "text": "because you can express your intention in a clear declarative style so what",
    "start": "3512279",
    "end": "3518279"
  },
  {
    "text": "sort of applications are good to write in high school well anytime you want to do some data pausing or processing high",
    "start": "3518279",
    "end": "3524219"
  },
  {
    "text": "schools a really great choice it's declarative style and great pausing libraries make that sort of problem a pleasure to solve any program with",
    "start": "3524219",
    "end": "3532559"
  },
  {
    "text": "complex algorithms is going to be really good to ride in Haskell because you can write DSL is very easily that make that",
    "start": "3532559",
    "end": "3539549"
  },
  {
    "text": "code understandable and it's type system and really good testing capabilities make ensuring correctness easy programs",
    "start": "3539549",
    "end": "3547529"
  },
  {
    "text": "that consume Web Services or our web services are well supported in high school there are really good libraries available for dealing with HTTP and JSON",
    "start": "3547529",
    "end": "3555259"
  },
  {
    "text": "and scripts and command line programs also really good to write in high school scripts can often go out of control over",
    "start": "3555259",
    "end": "3562170"
  },
  {
    "text": "time they start out small and then end up getting really large but Haskell static typing and it's type of inference",
    "start": "3562170",
    "end": "3567599"
  },
  {
    "text": "helps keep your scripts correct but still concise Haskell also has a really",
    "start": "3567599",
    "end": "3573210"
  },
  {
    "text": "good command-line argument puzzle library it's probably the best I've ever use and we probably shouldn't be surprised because Haskell's really good",
    "start": "3573210",
    "end": "3578940"
  },
  {
    "text": "at pausing however Haskell isn't suited for everything just yet so sequel",
    "start": "3578940",
    "end": "3584700"
  },
  {
    "text": "databases are surprising an annoying weak point if you're wanting to use Postgres and",
    "start": "3584700",
    "end": "3589920"
  },
  {
    "text": "you can use Postgres then it'll be fine because there are some really good libraries working for Postgres but major",
    "start": "3589920",
    "end": "3595380"
  },
  {
    "text": "commercial databases like sequel server and oracle they have some support but apparently it's not perfect which is a",
    "start": "3595380",
    "end": "3602160"
  },
  {
    "text": "shame gooey desktop applications are also not Haskell's forte there are some libraries",
    "start": "3602160",
    "end": "3607410"
  },
  {
    "text": "to help you write like gtk apps but you can fade it forget about WPF and zamel and let's face it if you're writing",
    "start": "3607410",
    "end": "3612960"
  },
  {
    "text": "something new these days it's probably for the web anyway so the state of Haskell ecosystem document that Gabriele",
    "start": "3612960",
    "end": "3619590"
  },
  {
    "text": "Gonzalez keeps up-to-date on github is a good place to look to see whether your particular problem is well suited to",
    "start": "3619590",
    "end": "3625260"
  },
  {
    "text": "Haskell so that's how I know about sequel databases because I went into there and it says immature and it gives",
    "start": "3625260",
    "end": "3631020"
  },
  {
    "text": "some reasoning as well so who else use Haskell who else in",
    "start": "3631020",
    "end": "3636720"
  },
  {
    "text": "industry uses Haskell in production well the highest profile use that I know of is it Facebook where they use Haskell to",
    "start": "3636720",
    "end": "3642240"
  },
  {
    "text": "fight spam they developed a hacks old data access framework that allows them to quickly and efficiently access the",
    "start": "3642240",
    "end": "3648120"
  },
  {
    "text": "data they need to figure out whether post to spam or not and then they write these rules in Haskell Facebook have",
    "start": "3648120",
    "end": "3653700"
  },
  {
    "text": "done a number of presentations about this and you're able to find recordings on it if you just google for it I know",
    "start": "3653700",
    "end": "3659610"
  },
  {
    "text": "seek has a couple of teams that work in high school to do some data processing and analysis as well as internal api's it was at seek that I got my production",
    "start": "3659610",
    "end": "3666660"
  },
  {
    "text": "high school experience there's also a helium and circuit hub if you want to look up what they do now if you want to",
    "start": "3666660",
    "end": "3674760"
  },
  {
    "text": "learn Haskell I highly recommend the Haskell programming from first principles book otherwise known as the",
    "start": "3674760",
    "end": "3680070"
  },
  {
    "text": "Haskell book it starts from the beginning and it goes into sufficient detail and it doesn't gloss over things",
    "start": "3680070",
    "end": "3685320"
  },
  {
    "text": "and it has exercises along the way that you can do if you want to cement these concepts in the head in your head because often you can stare at them and",
    "start": "3685320",
    "end": "3691920"
  },
  {
    "text": "then you go I still don't get it and it wasn't isn't until you actually do it a few times then it clicks so having those",
    "start": "3691920",
    "end": "3698310"
  },
  {
    "text": "exercises put out before you really helps there's also learn you at Haskell for a great good so if you want to read",
    "start": "3698310",
    "end": "3704280"
  },
  {
    "text": "something for free online you can have a look at that but you know if you've got a if you've got some spare cash I really",
    "start": "3704280",
    "end": "3709440"
  },
  {
    "text": "do recommend buying a Haskell book it's a much better resource there's also maybe Haskell with some",
    "start": "3709440",
    "end": "3714870"
  },
  {
    "text": "pragmatic examples about why you should care about FP and Haskell Haskell subreddit obviously Stack Overflow and there's",
    "start": "3714870",
    "end": "3721500"
  },
  {
    "text": "some haskell tagged post on the FP complete blog which have some good practical advice for production high school as",
    "start": "3721500",
    "end": "3726930"
  },
  {
    "text": "well so wrapping up we took a lightning tour of many of the features that",
    "start": "3726930",
    "end": "3733680"
  },
  {
    "text": "Haskell offers us developers to make reading writing and maintaining correct code easier Haskell's strong static",
    "start": "3733680",
    "end": "3741089"
  },
  {
    "text": "typing system allows us to refactor fearlessly by getting the compiler to check our correctness type inference and",
    "start": "3741089",
    "end": "3746670"
  },
  {
    "text": "huugle make it easy to work with that type system and find the functions that we need some types help us model our",
    "start": "3746670",
    "end": "3754530"
  },
  {
    "text": "alternatives explicitly freeing us from among other things the tyranny of unexpected null references new types",
    "start": "3754530",
    "end": "3761220"
  },
  {
    "text": "help us model our domain types more explicitly and provide clarity and make that type system work for us or for the",
    "start": "3761220",
    "end": "3767910"
  },
  {
    "text": "runtime cost of zero immutable immutability and purity help us write simpler more understandable code that",
    "start": "3767910",
    "end": "3774420"
  },
  {
    "text": "can be used in concurrent systems safely and function purity and along with Haskell's easy support of value",
    "start": "3774420",
    "end": "3780780"
  },
  {
    "text": "semantics and property testing make casting our code for correctness easier and laziness helps us write more",
    "start": "3780780",
    "end": "3787890"
  },
  {
    "text": "declarative code that will still execute efficiently but we do need to keep an eye out for those space leaks and",
    "start": "3787890",
    "end": "3793890"
  },
  {
    "text": "haskell makes it easy to write fast scalable concurrent code on its green threading system because it natively",
    "start": "3793890",
    "end": "3799830"
  },
  {
    "text": "supports asynchronously I think a synchrony and makes testing concurrent libraries and has those powerful",
    "start": "3799830",
    "end": "3806790"
  },
  {
    "text": "concurrent libraries and of course immutability and concurrency go very very well together so hopefully you've",
    "start": "3806790",
    "end": "3813960"
  },
  {
    "text": "enjoyed your peek into the haskell universe and you can see how it can help you as a developer and now you want to",
    "start": "3813960",
    "end": "3819000"
  },
  {
    "text": "go find out some more rest assured that I've only touched lightly the surface of what Haskell is about even though I've",
    "start": "3819000",
    "end": "3824849"
  },
  {
    "text": "kind of ranted for Buckett an hour so I put these slides up on github so the link is up there please take a picture",
    "start": "3824849",
    "end": "3830190"
  },
  {
    "text": "or memorize it if you've got a great memory I'm also on Twitter so feel free to contact me there if you see me around",
    "start": "3830190",
    "end": "3835680"
  },
  {
    "text": "the conference just look out for the bright green jumper and you find me in a crowd I'm happy to take any questions",
    "start": "3835680",
    "end": "3841410"
  },
  {
    "text": "although I think I'm a little bit over time so I am actually going to the dotnet rocks interview just after this",
    "start": "3841410",
    "end": "3847950"
  },
  {
    "text": "so and I believe they do do a Q&A so maybe come have a chat to me quickly",
    "start": "3847950",
    "end": "3853020"
  },
  {
    "text": "after that and then I've got up there and maybe come and ask me live in front of an audience a question embarrass me or something thank you",
    "start": "3853020",
    "end": "3860110"
  },
  {
    "text": "[Applause]",
    "start": "3860110",
    "end": "3864449"
  }
]