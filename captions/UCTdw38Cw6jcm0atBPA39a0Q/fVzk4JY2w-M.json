[
  {
    "start": "0",
    "end": "41000"
  },
  {
    "text": "okay hello this is uh robert c cord and i'm going to",
    "start": "3919",
    "end": "9440"
  },
  {
    "text": "uh talk to you today about uh about uh secure coding cnc plus plus and",
    "start": "9440",
    "end": "15679"
  },
  {
    "text": "uh volatile the volatile qualifier so just to",
    "start": "15679",
    "end": "20960"
  },
  {
    "text": "stay current with uh you know what's going on in the world today i i asked delphi if i should qualify my",
    "start": "20960",
    "end": "28960"
  },
  {
    "text": "verb was volatile and it it thinks it's a good thing to do so",
    "start": "28960",
    "end": "34160"
  },
  {
    "text": "um that's at least the ai position on volatility",
    "start": "34160",
    "end": "40399"
  },
  {
    "text": "um so i'm uh technical director at ncc group uh i uh",
    "start": "40399",
    "end": "47520"
  },
  {
    "text": "spend most of my time doing things like this developing and delivering secure coding training classes in java c c plus",
    "start": "47520",
    "end": "54160"
  },
  {
    "text": "plus c sharp uh i also do a code security review",
    "start": "54160",
    "end": "60079"
  },
  {
    "text": "uh code analysis and i lead the research team at ncc group",
    "start": "60079",
    "end": "65518"
  },
  {
    "text": "that's interested in reducing vulnerabilities at scale and open source software",
    "start": "65519",
    "end": "70640"
  },
  {
    "text": "i'm also a um a member of the c standards committee i've been on the committee since",
    "start": "70640",
    "end": "76680"
  },
  {
    "text": "2004 and uh my first meeting was actually there in uh in norway in lillihamer",
    "start": "76680",
    "end": "84799"
  },
  {
    "text": "um i also wanted to uh thank uh jf bastian aaron ballman uh",
    "start": "84799",
    "end": "90640"
  },
  {
    "text": "both of whom helped me out with the um with the contents of this presentation",
    "start": "90640",
    "end": "97200"
  },
  {
    "start": "96000",
    "end": "122000"
  },
  {
    "text": "so here's the agenda uh going to briefly go over some historical context",
    "start": "97200",
    "end": "103600"
  },
  {
    "text": "and then talk about uh volatile semantics some work to",
    "start": "103600",
    "end": "109280"
  },
  {
    "text": "deprecate some aspects of the use of volatile qualified types",
    "start": "109280",
    "end": "114479"
  },
  {
    "text": "talk about inter-thread communication shared memory and some updates to the",
    "start": "114479",
    "end": "119520"
  },
  {
    "text": "c23 standard so here's a use case uh from",
    "start": "119520",
    "end": "125520"
  },
  {
    "start": "122000",
    "end": "185000"
  },
  {
    "text": "early unix sources that sort of motivated the use of volatile in the c language",
    "start": "125520",
    "end": "132720"
  },
  {
    "text": "uh and and here we've got um you know we've got an address uh",
    "start": "132720",
    "end": "138319"
  },
  {
    "text": "specified by this macro kl and we want to",
    "start": "138319",
    "end": "143760"
  },
  {
    "text": "um iterate while uh we're waiting for the",
    "start": "143760",
    "end": "149680"
  },
  {
    "text": "uh the sign bit of a keyboard status register mapped to this address in kl uh",
    "start": "149680",
    "end": "157280"
  },
  {
    "text": "to uh become non-zero and the problem with this code is the",
    "start": "157280",
    "end": "163440"
  },
  {
    "text": "possibility that the compiler might optimize this so it might read this",
    "start": "163440",
    "end": "170640"
  },
  {
    "text": "you know memory location into a register and then you know just evaluate that register",
    "start": "170640",
    "end": "176319"
  },
  {
    "text": "and at that point the register is never going to change value it's only the process of actually reading this address",
    "start": "176319",
    "end": "182080"
  },
  {
    "text": "that might produce a a new value so volatile can address this problem and",
    "start": "182080",
    "end": "190720"
  },
  {
    "start": "185000",
    "end": "239000"
  },
  {
    "text": "can be used to rewrite the loop where we perform a volatile qualified access",
    "start": "190720",
    "end": "196000"
  },
  {
    "text": "to reference the memory equivalently we can",
    "start": "196000",
    "end": "201280"
  },
  {
    "text": "declare the uh load byte to be a pointer to vol volatile qualified memory and",
    "start": "201280",
    "end": "208560"
  },
  {
    "text": "access the byte through through low bite and so the purpose of uh the volatile",
    "start": "208560",
    "end": "214799"
  },
  {
    "text": "qualification here is to prevent the compiler from caching uh that memory uh the value",
    "start": "214799",
    "end": "221120"
  },
  {
    "text": "in that memory location into a register uh so we want to guarantee that it's actually",
    "start": "221120",
    "end": "227760"
  },
  {
    "text": "red on each iteration so uh when it finally changes we can detect",
    "start": "227760",
    "end": "232799"
  },
  {
    "text": "the change otherwise we would wind up with a with a true infinite loop that would never never",
    "start": "232799",
    "end": "238840"
  },
  {
    "text": "exit so an object that has volatile qualified type can be modified in ways",
    "start": "238840",
    "end": "245040"
  },
  {
    "start": "239000",
    "end": "341000"
  },
  {
    "text": "unknown to the compiler to the implementation or have other unknown side effects",
    "start": "245040",
    "end": "250879"
  },
  {
    "text": "so the volatile keyword imposes restrictions on on access to that object and",
    "start": "250879",
    "end": "258320"
  },
  {
    "text": "caching of the object so in the latest draft of the c23 standard",
    "start": "258320",
    "end": "264479"
  },
  {
    "text": "it says that access is two objects through the use of l values or volatile qualified types are evaluated strictly",
    "start": "264479",
    "end": "271840"
  },
  {
    "text": "according to the rules of the abstract machine uh meaning that you know basically every",
    "start": "271840",
    "end": "277919"
  },
  {
    "text": "every read has to be performed and every rate has to be performed",
    "start": "277919",
    "end": "283040"
  },
  {
    "text": "so at every sequence point uh the value stored uh last joining",
    "start": "283040",
    "end": "288320"
  },
  {
    "text": "object has to agree with uh what's prescribed by the abstract machine at",
    "start": "288320",
    "end": "293520"
  },
  {
    "text": "that time so in the absence of the volatile qualifier the contents of the location can be assumed to be unchanged",
    "start": "293520",
    "end": "301120"
  },
  {
    "text": "except for aliasing and so what that means is that you know the compiler might",
    "start": "301120",
    "end": "307840"
  },
  {
    "text": "make decide to optimize it right so it might decide uh well you know i'm writing to this",
    "start": "307840",
    "end": "314639"
  },
  {
    "text": "storage but i'm not reading it again so that's a dead code store which can be removed but with the",
    "start": "314639",
    "end": "320240"
  },
  {
    "text": "volatile qualifier it can't be removed because you know we're telling",
    "start": "320240",
    "end": "325520"
  },
  {
    "text": "uh the compiler that um you know writing to that object might have side effects",
    "start": "325520",
    "end": "330880"
  },
  {
    "text": "and uh you know they have to occur so you have to uh make sure",
    "start": "330880",
    "end": "337759"
  },
  {
    "text": "code is generated to perform that right so uh so this is appropriate for you",
    "start": "337759",
    "end": "344720"
  },
  {
    "start": "341000",
    "end": "449000"
  },
  {
    "text": "know memory mapped io registers so a static volatile object can be used for a memory mapped i o",
    "start": "344720",
    "end": "352320"
  },
  {
    "text": "register uh compilers have to take into account the relative",
    "start": "352320",
    "end": "357520"
  },
  {
    "text": "hardware details on the target system and make sure they implement those correctly when",
    "start": "357520",
    "end": "365199"
  },
  {
    "text": "implementing access to these volatile objects so for example the hardware",
    "start": "365199",
    "end": "370479"
  },
  {
    "text": "might require that a two by uh memory mapped register uh not be accessed with",
    "start": "370479",
    "end": "376400"
  },
  {
    "text": "uh with byte operations you might have to read or write both bytes at the same time",
    "start": "376400",
    "end": "382319"
  },
  {
    "text": "so compiler would have to assure that no byte operations were were generated",
    "start": "382319",
    "end": "388720"
  },
  {
    "text": "even if the source code was only accessing a single byte of the register",
    "start": "388720",
    "end": "394479"
  },
  {
    "text": "so um so whether or not read modify write instructions can be used on these",
    "start": "394479",
    "end": "400560"
  },
  {
    "text": "devices also has to be considered right because that would both read and write the object in a",
    "start": "400560",
    "end": "407120"
  },
  {
    "text": "single uh you know um you know in sequence and um you know whether or not",
    "start": "407120",
    "end": "413039"
  },
  {
    "text": "that makes sense for that register has to be determined so",
    "start": "413039",
    "end": "418319"
  },
  {
    "text": "uh because of all this um access to volatile qualified objects is implementation defined right the um you",
    "start": "418319",
    "end": "426000"
  },
  {
    "text": "know the compiler has to know for example the particular register maybe has to be accessed uh you know uh",
    "start": "426000",
    "end": "433199"
  },
  {
    "text": "can't be accessed with byte operations and because this is implementation defined behavior",
    "start": "433199",
    "end": "439280"
  },
  {
    "text": "all these behaviors have to be documented by the implementation so you know",
    "start": "439280",
    "end": "444639"
  },
  {
    "text": "what they are and how they're how they're performed",
    "start": "444639",
    "end": "450120"
  },
  {
    "start": "449000",
    "end": "528000"
  },
  {
    "text": "so a static uh const volatile uh",
    "start": "450160",
    "end": "455280"
  },
  {
    "text": "uh appropriately models a memory mapped input port such as a real-time clock",
    "start": "455280",
    "end": "461120"
  },
  {
    "text": "right so uh you won't write to the clock but each time you read from the clock you'll get",
    "start": "461120",
    "end": "466639"
  },
  {
    "text": "the current time for example a const volatile object can be used to",
    "start": "466639",
    "end": "472400"
  },
  {
    "text": "model a variable that can be altered by a different process but not by the current process",
    "start": "472400",
    "end": "480000"
  },
  {
    "text": "and the cast of a non-volatile object to a volatile type uh doesn't have uh",
    "start": "480000",
    "end": "485199"
  },
  {
    "text": "doesn't have any effect whatsoever you can't uh cast away uh the volatility uh",
    "start": "485199",
    "end": "492639"
  },
  {
    "text": "uh sorry you can't you can't uh you know kind of",
    "start": "492639",
    "end": "498000"
  },
  {
    "text": "take a non-volatile object and turn it into a volatile object by by",
    "start": "498000",
    "end": "503199"
  },
  {
    "text": "applying a cast to the object so to access a non-volatile object using",
    "start": "503199",
    "end": "509440"
  },
  {
    "text": "a volatile semantics you can cast its address to a pointer to",
    "start": "509440",
    "end": "514719"
  },
  {
    "text": "volatile and access through that pointer and we'll actually talk about this a bit more uh towards the end of the",
    "start": "514719",
    "end": "521680"
  },
  {
    "text": "presentation today and what its current status is in the in the c language",
    "start": "521680",
    "end": "528640"
  },
  {
    "start": "528000",
    "end": "645000"
  },
  {
    "text": "so loads and stores uh that access volatile memory in the original source code need",
    "start": "528640",
    "end": "535360"
  },
  {
    "text": "to generate instructions by which each byte is accessed exactly once right it",
    "start": "535360",
    "end": "542160"
  },
  {
    "text": "can't be accessed zero times it can't be accessed more than once uh so volatile can be used for example",
    "start": "542160",
    "end": "549279"
  },
  {
    "text": "to load and store variables used for shared memory for signal handling and uh",
    "start": "549279",
    "end": "555760"
  },
  {
    "text": "for set and long jump and other external modifications such as you know special hardware registers",
    "start": "555760",
    "end": "563040"
  },
  {
    "text": "so the key here is really uh that volatile is used for uh things that can be externally",
    "start": "563040",
    "end": "569360"
  },
  {
    "text": "modified so if the source code has a load or store of a volatile",
    "start": "569360",
    "end": "576160"
  },
  {
    "text": "operation these must occur the same number of times in the final",
    "start": "576160",
    "end": "581760"
  },
  {
    "text": "execution so if you have you know five reads and seven rights the final execution has to have five reads and",
    "start": "581760",
    "end": "587839"
  },
  {
    "text": "seven rights uh a volatile operation can't be eliminated or fused with a subsequent",
    "start": "587839",
    "end": "593440"
  },
  {
    "text": "one uh you know even if the compiler thinks um you know it can do it without changing uh the behavior of the program",
    "start": "593440",
    "end": "601440"
  },
  {
    "text": "just because again each each right or read is",
    "start": "601440",
    "end": "606480"
  },
  {
    "text": "is essential and in fact if you if you have volatile qualified object x and you say x equals x",
    "start": "606480",
    "end": "613040"
  },
  {
    "text": "uh the compiler is required to to read x and then take the value it just read and write it back to x every",
    "start": "613040",
    "end": "620720"
  },
  {
    "text": "every read and write needs to be performed",
    "start": "620720",
    "end": "625600"
  },
  {
    "text": "so a volatile operation also cannot be speculated even if the compiler can undo",
    "start": "625839",
    "end": "631360"
  },
  {
    "text": "or make that speculation benign uh because the speculation will access the",
    "start": "631360",
    "end": "637839"
  },
  {
    "text": "uh volatile qualified object and that again can have side effects that the compiler is not not aware",
    "start": "637839",
    "end": "644839"
  },
  {
    "text": "of so here's an example of a set jump long jump program and in this program we",
    "start": "644839",
    "end": "652399"
  },
  {
    "text": "have a variable foo which we initialize to the value 5",
    "start": "652399",
    "end": "657519"
  },
  {
    "text": "and then we have a set jump point here and within the set jump we'll compa",
    "start": "657519",
    "end": "663120"
  },
  {
    "text": "we'll see if foo is not equal to five and if it is we'll print out this uh",
    "start": "663120",
    "end": "669040"
  },
  {
    "text": "string hi and then long jump uh back to",
    "start": "669040",
    "end": "674800"
  },
  {
    "text": "this point here the set jump point and re-test uh to see if it's return two or",
    "start": "674800",
    "end": "680000"
  },
  {
    "text": "not um and so uh after this line",
    "start": "680000",
    "end": "685040"
  },
  {
    "text": "uh we set foot a six and then we long jump uh back here again but with a value",
    "start": "685040",
    "end": "691519"
  },
  {
    "text": "one so this isn't going to terminate it's going to continue through the loop uh and so what should happen is that",
    "start": "691519",
    "end": "698320"
  },
  {
    "text": "you know on the first iterations loop foo is not five so we um so we continue executing we set food",
    "start": "698320",
    "end": "705839"
  },
  {
    "text": "a six we jump back uh and now foo is is six is not five so we'll put uh print",
    "start": "705839",
    "end": "713680"
  },
  {
    "text": "out high long jump back to here and this time we'll exit the loop",
    "start": "713680",
    "end": "719279"
  },
  {
    "text": "uh but unfortunately it doesn't quite work like that so uh the compiler of course is always",
    "start": "719279",
    "end": "725760"
  },
  {
    "text": "looking to optimize your code uh typically that's a good thing um and so",
    "start": "725760",
    "end": "731120"
  },
  {
    "text": "what it'll do is it look and say well uh for this line uh you know for this code",
    "start": "731120",
    "end": "736880"
  },
  {
    "text": "to execute uh foo has to be not equal to five but it is",
    "start": "736880",
    "end": "743120"
  },
  {
    "text": "clearly equal to five uh so the compiler will reach the conclusion that uh this",
    "start": "743120",
    "end": "749440"
  },
  {
    "text": "line of code cannot execute and therefore can be uh can be removed",
    "start": "749440",
    "end": "755519"
  },
  {
    "text": "uh then uh it'll look and say okay we're assigning a value to foo of 6 but we're",
    "start": "755519",
    "end": "761600"
  },
  {
    "text": "not going to read that again so that's a dead store and that can also be be removed",
    "start": "761600",
    "end": "767920"
  },
  {
    "text": "and the consequence of this is that we now end up with an infinite loop because we just come down to this",
    "start": "767920",
    "end": "773839"
  },
  {
    "text": "long jump with one that jumps back to here it's not equal to two so it just",
    "start": "773839",
    "end": "779519"
  },
  {
    "text": "iterates uh uh for all for all eternity",
    "start": "779519",
    "end": "784880"
  },
  {
    "text": "um so the way this can be fixed is to declare uh foo",
    "start": "784880",
    "end": "790320"
  },
  {
    "text": "uh to be uh to be a volatile qualified object uh and what happens now is when the",
    "start": "790320",
    "end": "796720"
  },
  {
    "text": "compiler looks at this line you know it can no longer say that foo",
    "start": "796720",
    "end": "803279"
  },
  {
    "text": "is is definitely equal to five because uh we've declared food to be volatile",
    "start": "803279",
    "end": "808800"
  },
  {
    "text": "qualified and this means it can be changed in a way that's unknown to the compiler and in this case",
    "start": "808800",
    "end": "815920"
  },
  {
    "text": "this is the change that it doesn't know about because it's not aware basically that this set jump code can be",
    "start": "815920",
    "end": "822079"
  },
  {
    "text": "executed multiple times because of the set jump long jump",
    "start": "822079",
    "end": "827760"
  },
  {
    "text": "so by by making foo volatile we",
    "start": "827760",
    "end": "833040"
  },
  {
    "text": "prevent this optimization we prevent this code from being optimized out and now the code will execute as as intended",
    "start": "833040",
    "end": "842880"
  },
  {
    "start": "842000",
    "end": "1022000"
  },
  {
    "text": "so uh for inter-thread communication um volatile uh object can be used for",
    "start": "842880",
    "end": "849600"
  },
  {
    "text": "objects shared among uh multiple processes uh for um for within a within a process",
    "start": "849600",
    "end": "858639"
  },
  {
    "text": "uh most implementations do not insert sufficient memory faces to guarantee",
    "start": "858639",
    "end": "864320"
  },
  {
    "text": "that other threads or hardware devices see volatile operations in the order in",
    "start": "864320",
    "end": "869519"
  },
  {
    "text": "which they were issued uh so it's it's pretty unclear how to",
    "start": "869519",
    "end": "875199"
  },
  {
    "text": "um how to use these weak guarantees in in portable code",
    "start": "875199",
    "end": "880720"
  },
  {
    "text": "uh for volatile objects to be useful for inter-thread communication updates have",
    "start": "880720",
    "end": "886800"
  },
  {
    "text": "to be atomic as as with the reads of those objects",
    "start": "886800",
    "end": "892079"
  },
  {
    "text": "so volatile doesn't guarantee that memory operations won't tear",
    "start": "892079",
    "end": "897440"
  },
  {
    "text": "so evolve to load uh or or read can be observed in uh",
    "start": "897440",
    "end": "902959"
  },
  {
    "text": "could observe partial rights right so for example let's say we were on a 32-bit architecture",
    "start": "902959",
    "end": "909920"
  },
  {
    "text": "and we had a 64-bit value that had to be written or read in uh two instructions",
    "start": "909920",
    "end": "915920"
  },
  {
    "text": "right so uh this uh you know the high order bits could be uh could be written",
    "start": "915920",
    "end": "922639"
  },
  {
    "text": "and then uh the entire object could be red",
    "start": "922639",
    "end": "927839"
  },
  {
    "text": "uh and then after it's red the uh the low order 32 bits could be",
    "start": "927839",
    "end": "933040"
  },
  {
    "text": "written and so we would wind up uh with a with a split read where we've got half",
    "start": "933040",
    "end": "938800"
  },
  {
    "text": "of the new value and half the old value right and that would um that would not be good",
    "start": "938800",
    "end": "944959"
  },
  {
    "text": "um so um so we have to be concerned about volatile reads and writes being",
    "start": "944959",
    "end": "952079"
  },
  {
    "text": "being split being ripped um so realistically uh the only reads",
    "start": "952079",
    "end": "958399"
  },
  {
    "text": "and writes that will tear is when uh the hardware doesn't have an instruction that will perform the entire",
    "start": "958399",
    "end": "964720"
  },
  {
    "text": "memory operation atomically so if you have a type like sig atomic t",
    "start": "964720",
    "end": "970800"
  },
  {
    "text": "that's guaranteed to be readable and writable atomically um but you know for larger types there",
    "start": "970800",
    "end": "977920"
  },
  {
    "text": "might not you know like uh like the previous example of our 64-bit",
    "start": "977920",
    "end": "983440"
  },
  {
    "text": "um object on a 32-bit architecture there might not be an instruction that can",
    "start": "983440",
    "end": "988959"
  },
  {
    "text": "read and write the entire object at one time",
    "start": "988959",
    "end": "995199"
  },
  {
    "text": "so uh an implementation is required to touch each target by once",
    "start": "995199",
    "end": "1001360"
  },
  {
    "text": "uh one after the other in an unspecified order and that order could change on",
    "start": "1001360",
    "end": "1007440"
  },
  {
    "text": "each execution the order volatile operations cannot change relative to other volatile",
    "start": "1007440",
    "end": "1014079"
  },
  {
    "text": "operations but it can be reordered uh relative to non-volatile operations",
    "start": "1014079",
    "end": "1022160"
  },
  {
    "start": "1022000",
    "end": "1089000"
  },
  {
    "text": "so uh so volatile doesn't imply and any observable ordering in the",
    "start": "1022639",
    "end": "1028959"
  },
  {
    "text": "memory model uh atomic instructions will guarantee sequential consistency for",
    "start": "1028959",
    "end": "1034558"
  },
  {
    "text": "data race free programs if you have a data race uh data races are undefined behavior and once you have",
    "start": "1034559",
    "end": "1041120"
  },
  {
    "text": "undefined behavior basically anything can happen there are there are no guarantees anymore",
    "start": "1041120",
    "end": "1047438"
  },
  {
    "text": "um so volatile doesn't provide such a guarantee and doesn't imply a memory ordering or any",
    "start": "1047439",
    "end": "1053600"
  },
  {
    "text": "fencing although there are some implementations such as extensive processors and",
    "start": "1053600",
    "end": "1059360"
  },
  {
    "text": "microsoft visual studio that will provide stronger guarantees",
    "start": "1059360",
    "end": "1065760"
  },
  {
    "text": "so the instructions are emitted in a defined order but processors can issue",
    "start": "1065760",
    "end": "1070799"
  },
  {
    "text": "and execute them out of order and other cords can observe them completely different order",
    "start": "1070799",
    "end": "1077360"
  },
  {
    "text": "if there's no extra synchronization being used so this will come from or can come from",
    "start": "1077360",
    "end": "1084480"
  },
  {
    "text": "implementation guarantees or or hardware mapping specifics",
    "start": "1084480",
    "end": "1089600"
  },
  {
    "text": "so here's an example of the use of volatile for synchronization which of course is something that you you should",
    "start": "1089600",
    "end": "1095840"
  },
  {
    "text": "you shouldn't do so in this example we have a volatile",
    "start": "1095840",
    "end": "1101679"
  },
  {
    "text": "qualified a boolean called a g update finished",
    "start": "1101679",
    "end": "1106880"
  },
  {
    "text": "and we've got a thread so we've got our first thread that uh initializes",
    "start": "1106880",
    "end": "1113600"
  },
  {
    "text": "this boolean volatile boolean flag to false",
    "start": "1113600",
    "end": "1118880"
  },
  {
    "text": "and then we perform an update of some global data and then we perform update of some other global data and",
    "start": "1118880",
    "end": "1125600"
  },
  {
    "text": "once all our updates are finished we set this volatile",
    "start": "1125600",
    "end": "1130720"
  },
  {
    "text": "boolean flag to true then the second thread is basically",
    "start": "1130720",
    "end": "1136080"
  },
  {
    "text": "looping waiting for this flag to get set to true",
    "start": "1136080",
    "end": "1141600"
  },
  {
    "text": "so it knows that these updates have completed and now it can go ahead and",
    "start": "1141600",
    "end": "1147440"
  },
  {
    "text": "render you know the global data and and the problem with this code is",
    "start": "1147440",
    "end": "1153360"
  },
  {
    "text": "that um again reads and writes of volatile qualified",
    "start": "1153360",
    "end": "1158559"
  },
  {
    "text": "objects can be reordered with respect to non-volatile operations and so",
    "start": "1158559",
    "end": "1165120"
  },
  {
    "text": "um the compiler you know is free to uh to to relocate this code to before",
    "start": "1165120",
    "end": "1172960"
  },
  {
    "text": "these global uh variables are actually updated so the um",
    "start": "1172960",
    "end": "1178960"
  },
  {
    "text": "you know the second thread could detect uh you know",
    "start": "1178960",
    "end": "1184320"
  },
  {
    "text": "uh update finish being set to uh true and decide that um you know these",
    "start": "1184320",
    "end": "1190960"
  },
  {
    "text": "variables have been updated and render them when really they haven't been",
    "start": "1190960",
    "end": "1196240"
  },
  {
    "text": "updated yet or maybe are partially updated so again you don't want to use volatile",
    "start": "1196240",
    "end": "1202000"
  },
  {
    "text": "for synchronization it's not designed for this purpose um it is",
    "start": "1202000",
    "end": "1207600"
  },
  {
    "text": "it can be a bit confusing because in java volatile can be used for synchronization because they have a different memory",
    "start": "1207600",
    "end": "1214240"
  },
  {
    "text": "model but in cnc plus plus it cannot",
    "start": "1214240",
    "end": "1220039"
  },
  {
    "start": "1219000",
    "end": "1313000"
  },
  {
    "text": "so uh basically you know volatile is used for",
    "start": "1220320",
    "end": "1226080"
  },
  {
    "text": "uh external modification so uh examples include uh shared uh shared",
    "start": "1226080",
    "end": "1232840"
  },
  {
    "text": "memory um where volatile can avoid uh time of check a time of use or tactile",
    "start": "1232840",
    "end": "1240720"
  },
  {
    "text": "race conditions which can pretty easily result in software vulnerabilities",
    "start": "1240720",
    "end": "1246640"
  },
  {
    "text": "signal handling is another use case where signal can occur at any time in the program's execution",
    "start": "1246640",
    "end": "1252320"
  },
  {
    "text": "and the optimizer has to ensure that the volatile operations occur even if they are allowed to tear",
    "start": "1252320",
    "end": "1259760"
  },
  {
    "text": "um it's used as we've already seen in in a prior example in set jump long jump where set jump can effectively return",
    "start": "1259760",
    "end": "1266240"
  },
  {
    "text": "twice uh so volatile will be used to prevent the motion of memory operations around",
    "start": "1266240",
    "end": "1272400"
  },
  {
    "text": "that operation and uh external modifications such as um you",
    "start": "1272400",
    "end": "1278240"
  },
  {
    "text": "know memory mapped registers where the compiler can't assume the memory uh hasn't changed or",
    "start": "1278240",
    "end": "1285120"
  },
  {
    "text": "any right to that memory isn't um having some sort of side effect",
    "start": "1285120",
    "end": "1291840"
  },
  {
    "text": "uh so in c plus plus but not in c uh volatile can also be used to mark an",
    "start": "1291840",
    "end": "1298240"
  },
  {
    "text": "infinite loop that has side effects and is therefore not undefined behavior",
    "start": "1298240",
    "end": "1303600"
  },
  {
    "text": "and finally it can enforce control dependencies and prevent",
    "start": "1303600",
    "end": "1309120"
  },
  {
    "text": "compiler value speculation",
    "start": "1309120",
    "end": "1312960"
  },
  {
    "start": "1313000",
    "end": "1539000"
  },
  {
    "text": "so as we kind of pointed out already",
    "start": "1314799",
    "end": "1319840"
  },
  {
    "text": "volatile has has implementation defined behavior",
    "start": "1320000",
    "end": "1325360"
  },
  {
    "text": "so the c standard says that an excime expression has the value of the left operand after",
    "start": "1325360",
    "end": "1331280"
  },
  {
    "text": "the assignment but is not an l value the implementation is permitted to read",
    "start": "1331280",
    "end": "1338080"
  },
  {
    "text": "the object to determine the value but is not required to even when the object is volatile",
    "start": "1338080",
    "end": "1344480"
  },
  {
    "text": "qualified type so so what you're you're getting here is some flexibility where",
    "start": "1344480",
    "end": "1350559"
  },
  {
    "text": "the compiler has the option uh but is not required to read the value",
    "start": "1350559",
    "end": "1357440"
  },
  {
    "text": "so the consequence of that is that this code has implementation defined behavior",
    "start": "1357440",
    "end": "1364400"
  },
  {
    "text": "where a and c are not volatile qualified objects but b is a volatile qualified",
    "start": "1364400",
    "end": "1370720"
  },
  {
    "text": "object so we're going to assign you know the value in c to the location",
    "start": "1370720",
    "end": "1377360"
  },
  {
    "text": "stored by b and then we're going to assign a value to a",
    "start": "1377360",
    "end": "1384080"
  },
  {
    "text": "right but it's unclear if we're going to read b again in order",
    "start": "1384080",
    "end": "1389440"
  },
  {
    "text": "to assign it or we're just going to assign it a second time into a",
    "start": "1389440",
    "end": "1394880"
  },
  {
    "text": "and so there's two independent but valid interpretations of this",
    "start": "1394880",
    "end": "1400880"
  },
  {
    "text": "both of which access the volatile qualified objects uh in different ways",
    "start": "1400880",
    "end": "1406400"
  },
  {
    "text": "and so that's uh quite problematic right because uh accesses of these volatile qualified",
    "start": "1406400",
    "end": "1412799"
  },
  {
    "text": "objects could um you know could could have uh have a have a meeting and you want to",
    "start": "1412799",
    "end": "1419440"
  },
  {
    "text": "uh be very precise in determining how many reads and rights occur and and in",
    "start": "1419440",
    "end": "1424960"
  },
  {
    "text": "what order so uh so basically this has become a deprecated behavior in c plus and we",
    "start": "1424960",
    "end": "1432559"
  },
  {
    "text": "proposed also to deprecate it in in c um",
    "start": "1432559",
    "end": "1438080"
  },
  {
    "text": "but uh it's a good idea uh whether or not it's deprecated you you want to uh",
    "start": "1438080",
    "end": "1444159"
  },
  {
    "text": "avoid that that type of code so if uh what you're trying to do is",
    "start": "1444159",
    "end": "1450480"
  },
  {
    "text": "uh you you want uh you want b to be read uh",
    "start": "1450480",
    "end": "1455840"
  },
  {
    "text": "after uh being written to then you know it's it's best to write the code out",
    "start": "1455840",
    "end": "1461039"
  },
  {
    "text": "like this uh to make it clear that you know we're gonna put the value in c into b we're gonna read b uh and then we're",
    "start": "1461039",
    "end": "1468320"
  },
  {
    "text": "gonna write that back to a so this will get you a write followed by a read of the volatile qualified object",
    "start": "1468320",
    "end": "1475520"
  },
  {
    "text": "on the other hand if we don't want to read b we can adjust assign c to b and then",
    "start": "1475520",
    "end": "1481440"
  },
  {
    "text": "assign c to a and this will indicate that we don't want b to be read so this is a clear and",
    "start": "1481440",
    "end": "1488960"
  },
  {
    "text": "unambiguous while you know this version of the same code is not",
    "start": "1488960",
    "end": "1496159"
  },
  {
    "text": "unambiguous okay um",
    "start": "1496159",
    "end": "1501840"
  },
  {
    "text": "so again uh this behavior has been deprecated in c plus plus 20 uh and i've written a proposal to",
    "start": "1501840",
    "end": "1509120"
  },
  {
    "text": "deprecate it and see but the committee hasn't um hasn't heard the proposal yet so",
    "start": "1509120",
    "end": "1514720"
  },
  {
    "text": "we're not sure what the outcome of that will be but uh this is currently deprecated behavior for c plus 20 and",
    "start": "1514720",
    "end": "1521919"
  },
  {
    "text": "we'll we'll see what happens for uh for c23",
    "start": "1521919",
    "end": "1527279"
  },
  {
    "text": "uh but regardless of what decisions made right we",
    "start": "1527279",
    "end": "1532559"
  },
  {
    "text": "you want to avoid writing this code because it's clearly ambiguous and",
    "start": "1532559",
    "end": "1537919"
  },
  {
    "text": "you know could be wrong so another issue is with a compound",
    "start": "1537919",
    "end": "1543279"
  },
  {
    "start": "1539000",
    "end": "1665000"
  },
  {
    "text": "assignment so here uh we've got a structure uh describing a device a",
    "start": "1543279",
    "end": "1550000"
  },
  {
    "text": "controller and uh we want to either to start the device or we want to stop",
    "start": "1550000",
    "end": "1557120"
  },
  {
    "text": "the device and so the way we uh start the device is",
    "start": "1557120",
    "end": "1562720"
  },
  {
    "text": "that we we or uh this address",
    "start": "1562720",
    "end": "1568240"
  },
  {
    "text": "with this value and then assign it back to the address and to",
    "start": "1568240",
    "end": "1573279"
  },
  {
    "text": "um to uh stop it we we and uh the complement um with with",
    "start": "1573279",
    "end": "1581039"
  },
  {
    "text": "this value and store it back in the value and what's a little bit you know um",
    "start": "1581039",
    "end": "1587919"
  },
  {
    "text": "uh unclear about um you know this logic and here we put it in say a",
    "start": "1587919",
    "end": "1594799"
  },
  {
    "text": "header file that might be included into a c or c plus program uh is is the fact that",
    "start": "1594799",
    "end": "1602000"
  },
  {
    "text": "these compound uh assignments so the compound assignment of that form uh it basically is",
    "start": "1602000",
    "end": "1609200"
  },
  {
    "text": "equivalent to uh you know e1 equals e1",
    "start": "1609200",
    "end": "1614559"
  },
  {
    "text": "and then whatever operation is e2 except that it guarantees the value e1",
    "start": "1614559",
    "end": "1620000"
  },
  {
    "text": "is evaluated only once when you use the compound assignment but",
    "start": "1620000",
    "end": "1627039"
  },
  {
    "text": "this operation is still a read modify write operation so basically this",
    "start": "1627039",
    "end": "1633120"
  },
  {
    "text": "this value in a controller is going to be read",
    "start": "1633120",
    "end": "1638320"
  },
  {
    "text": "and then modified we're going to or it and then it's going to be written so",
    "start": "1638320",
    "end": "1645360"
  },
  {
    "text": "we're going to have uh two uh two axises of this volatile qualified memory",
    "start": "1645360",
    "end": "1651279"
  },
  {
    "text": "first to read it and then write it and it's not always clear you know looking at code with these compound",
    "start": "1651279",
    "end": "1657600"
  },
  {
    "text": "instructions that there's going to be multiple multiple accesses of that",
    "start": "1657600",
    "end": "1663440"
  },
  {
    "text": "volatile qualified storage the same thing is true of pre and post",
    "start": "1663440",
    "end": "1668480"
  },
  {
    "start": "1665000",
    "end": "1726000"
  },
  {
    "text": "increment and decrement of volatile qualified types it's a read modify write",
    "start": "1668480",
    "end": "1673520"
  },
  {
    "text": "operation so if i say you know i plus plus the first thing that happens is we have",
    "start": "1673520",
    "end": "1679200"
  },
  {
    "text": "to read the current value in i then we have to operate on it by or modify it by",
    "start": "1679200",
    "end": "1685120"
  },
  {
    "text": "incrementing it and then we have to write back the value into i so",
    "start": "1685120",
    "end": "1690159"
  },
  {
    "text": "um so the uh the object again might be",
    "start": "1690159",
    "end": "1695200"
  },
  {
    "text": "accessed uh will be accessed more than uh one time so c plus plus 20 um",
    "start": "1695200",
    "end": "1702640"
  },
  {
    "text": "uh and uh you know deprecates this and and we have our proposal and c to make",
    "start": "1702640",
    "end": "1708000"
  },
  {
    "text": "this uh obsolete uh for you know a",
    "start": "1708000",
    "end": "1713039"
  },
  {
    "text": "volatile compound assignment and for pre and post increment and decrement uh",
    "start": "1713039",
    "end": "1718880"
  },
  {
    "text": "operations to uh be performed on volatile qualified objects",
    "start": "1718880",
    "end": "1725840"
  },
  {
    "start": "1726000",
    "end": "1785000"
  },
  {
    "text": "okay so shared memory so here's an example from uh from chromium",
    "start": "1726240",
    "end": "1733200"
  },
  {
    "text": "where basically we have we have a gpu process",
    "start": "1733200",
    "end": "1738640"
  },
  {
    "text": "here and we've got a rendering process here so",
    "start": "1738640",
    "end": "1744080"
  },
  {
    "text": "there are multiple processes and the rendering process is going to",
    "start": "1744080",
    "end": "1750880"
  },
  {
    "text": "send webgl commands to the gpu to execute",
    "start": "1750880",
    "end": "1756000"
  },
  {
    "text": "and the way it works is that you you call a function and that function will uh you know write the command and the",
    "start": "1756000",
    "end": "1763200"
  },
  {
    "text": "arguments into a command buffer and the gpu process will loop uh and",
    "start": "1763200",
    "end": "1769919"
  },
  {
    "text": "you know read these commands from the buffer and then process them and when when it's done it'll actually then write",
    "start": "1769919",
    "end": "1777279"
  },
  {
    "text": "a result back into shared memory to communicate it back to the rendering",
    "start": "1777279",
    "end": "1783279"
  },
  {
    "text": "process so there was a cve",
    "start": "1783279",
    "end": "1788799"
  },
  {
    "start": "1785000",
    "end": "2005000"
  },
  {
    "text": "for the software with the unlikely number of one two three four",
    "start": "1788799",
    "end": "1795279"
  },
  {
    "text": "um and so this was in this uh command decoder which allowed remote attackers",
    "start": "1795279",
    "end": "1801679"
  },
  {
    "text": "to cause a buffer overflow and uh what was happening was that the",
    "start": "1801679",
    "end": "1807279"
  },
  {
    "text": "gl get uniform fb uh api opengl api was",
    "start": "1807279",
    "end": "1812480"
  },
  {
    "text": "being called the shared arguments the shared memory used for the commands is going to be filled with the",
    "start": "1812480",
    "end": "1819520"
  },
  {
    "text": "uh appropriate function id and and the arguments to that function the gpu would then read the command",
    "start": "1819520",
    "end": "1826799"
  },
  {
    "text": "and process the data and then write uh write uh the return value back",
    "start": "1826799",
    "end": "1833600"
  },
  {
    "text": "into shared memory uh for the uh the rendering process or the client process",
    "start": "1833600",
    "end": "1840559"
  },
  {
    "text": "so the vulnerability in this case is triggered by having these two threads running",
    "start": "1840559",
    "end": "1846480"
  },
  {
    "text": "and uh one thread kind of the the attacking thread would continuously call",
    "start": "1846480",
    "end": "1853360"
  },
  {
    "text": "gl get uniform fv while the other one is going to",
    "start": "1853360",
    "end": "1858399"
  },
  {
    "text": "you know process the commands and write to the value where the result",
    "start": "1858399",
    "end": "1863519"
  },
  {
    "text": "resides and the result in this case is a is a size so",
    "start": "1863519",
    "end": "1869279"
  },
  {
    "text": "the way this was fixed was with this following with this code here",
    "start": "1869279",
    "end": "1877120"
  },
  {
    "text": "size result here is just a struct with uh pod members",
    "start": "1877120",
    "end": "1882960"
  },
  {
    "text": "and this call here to get shared memory as is just gonna return the the pointer",
    "start": "1882960",
    "end": "1889200"
  },
  {
    "text": "to shared memory uh and and so the key to this is really um",
    "start": "1889200",
    "end": "1894799"
  },
  {
    "text": "you know here's the uh the right uh the shared memory store",
    "start": "1894799",
    "end": "1899840"
  },
  {
    "text": "uh but this was uh causing the race condition because this size could",
    "start": "1899840",
    "end": "1906480"
  },
  {
    "text": "wind up changing again uh before it was used and then",
    "start": "1906480",
    "end": "1912480"
  },
  {
    "text": "because the ren because the gpu had",
    "start": "1912480",
    "end": "1917840"
  },
  {
    "text": "had an invalid value because it was changed because this basically is tactile condition uh",
    "start": "1917840",
    "end": "1925279"
  },
  {
    "text": "it would wind up with a buffer overflow because it no longer knew the size of the object it was it was writing to",
    "start": "1925279",
    "end": "1932080"
  },
  {
    "text": "so the way this was fixed was that the size value is also uh you know it is stored",
    "start": "1932080",
    "end": "1940000"
  },
  {
    "text": "into um shared memory but it's also stored on the local stack uh where it can't be uh",
    "start": "1940000",
    "end": "1947200"
  },
  {
    "text": "can't be overwritten uh but the problem with the solution is",
    "start": "1947200",
    "end": "1952399"
  },
  {
    "text": "that the compiler doesn't know that the shared memory can",
    "start": "1952399",
    "end": "1957919"
  },
  {
    "text": "be externally modified uh and consequently you know it can perform a lot of optimizations around",
    "start": "1957919",
    "end": "1963919"
  },
  {
    "text": "this such as delaying the store and definitely reusing the stored value",
    "start": "1963919",
    "end": "1970000"
  },
  {
    "text": "not using result size or even reusing result sizes temporary storage",
    "start": "1970000",
    "end": "1976559"
  },
  {
    "text": "because as far as the compiler implementation knows you know this this memory is not shared",
    "start": "1976559",
    "end": "1982080"
  },
  {
    "text": "with anyone and no one else is accessing it so in order to let the compiler know that this is uh",
    "start": "1982080",
    "end": "1989919"
  },
  {
    "text": "you know shared memory uh you can declare it as volatile and then um you",
    "start": "1989919",
    "end": "1995360"
  },
  {
    "text": "know it can it now knows that this can be modified in ways uh unknown to um",
    "start": "1995360",
    "end": "2002640"
  },
  {
    "text": "to the compiler so uh volatile atomic um",
    "start": "2002640",
    "end": "2010000"
  },
  {
    "start": "2005000",
    "end": "2121000"
  },
  {
    "text": "as we've already seen a volatile can can tear it provides no ordering guarantees with",
    "start": "2010000",
    "end": "2017440"
  },
  {
    "text": "respect to non-volatile memory application operations and also with respect to cpu",
    "start": "2017440",
    "end": "2023760"
  },
  {
    "text": "reordering it's required to touch bytes exactly once and it inhibits optimizations which",
    "start": "2023760",
    "end": "2030799"
  },
  {
    "text": "is uh you know the actually the the purpose it serves uh atomic on the other hand cannot tear",
    "start": "2030799",
    "end": "2038240"
  },
  {
    "text": "uh because all the operations are uh atomic i can't i can't think of another word for that maybe there is one",
    "start": "2038240",
    "end": "2045039"
  },
  {
    "text": "but um so these operations cannot tear it has a full memory model uh but it can require",
    "start": "2045039",
    "end": "2053358"
  },
  {
    "text": "a loop to succeed and it can be optimized so",
    "start": "2053359",
    "end": "2059679"
  },
  {
    "text": "ideally you would think that by combining these two uh together",
    "start": "2059679",
    "end": "2065358"
  },
  {
    "text": "you would get the union of properties but this is not true um so",
    "start": "2065359",
    "end": "2070960"
  },
  {
    "text": "for example read modify rate operations can be implemented by loops which are going to",
    "start": "2070960",
    "end": "2076560"
  },
  {
    "text": "retry with locked instructions each of which performs a load and store",
    "start": "2076560",
    "end": "2082800"
  },
  {
    "text": "so the fact that you have a loop uh where you might retry multiple times",
    "start": "2082800",
    "end": "2088480"
  },
  {
    "text": "loading and storing these objects means that you know we we've lost",
    "start": "2088480",
    "end": "2094398"
  },
  {
    "text": "uh we've lost the guarantee with volatile that these",
    "start": "2094399",
    "end": "2100000"
  },
  {
    "text": "bytes are going to be touched exactly once uh similarly we could implement this",
    "start": "2100000",
    "end": "2105200"
  },
  {
    "text": "with transactional memory operations which might also access the bytes multiple times",
    "start": "2105200",
    "end": "2111839"
  },
  {
    "text": "the only way really to to ensure that you're only touching the bite once is to do these as memory uh",
    "start": "2111839",
    "end": "2119119"
  },
  {
    "text": "controller operations so um so if you want to",
    "start": "2119119",
    "end": "2125280"
  },
  {
    "start": "2121000",
    "end": "2238000"
  },
  {
    "text": "um so a non-lock free atomic can be volatile",
    "start": "2125280",
    "end": "2130480"
  },
  {
    "text": "in which case it can tear when you consider the instructions that might be",
    "start": "2130480",
    "end": "2136160"
  },
  {
    "text": "generated so here we're going to look at a little example where we have a volatile atomic object which",
    "start": "2136160",
    "end": "2143839"
  },
  {
    "text": "is which is a small int which can be um which can which has a",
    "start": "2143839",
    "end": "2149680"
  },
  {
    "text": "lock-free atomic and we've got a larger struct which contains a",
    "start": "2149680",
    "end": "2155920"
  },
  {
    "text": "a 16 element integer array which",
    "start": "2155920",
    "end": "2160960"
  },
  {
    "text": "cannot which doesn't have a a lock free atomic associated with it",
    "start": "2160960",
    "end": "2166400"
  },
  {
    "text": "and so if we look first at the larger object and we attempt to make a copy of it",
    "start": "2166400",
    "end": "2172960"
  },
  {
    "text": "you'll see that there's a there's a bunch of instructions that need to be called so the problem is that you know a",
    "start": "2172960",
    "end": "2180079"
  },
  {
    "text": "volatile atomic operation needs to be performed as a single copy atomic",
    "start": "2180079",
    "end": "2186720"
  },
  {
    "text": "across shared memory when the processes can't share a lock",
    "start": "2186720",
    "end": "2191760"
  },
  {
    "text": "uh without this without the um without having the",
    "start": "2191760",
    "end": "2197599"
  },
  {
    "text": "lock free atomic you're going to end up with just a regular unprotected mem copy",
    "start": "2197599",
    "end": "2204720"
  },
  {
    "text": "so this is not what we want on the other hand if we have um if we",
    "start": "2204720",
    "end": "2211200"
  },
  {
    "text": "have a lock free atomic for example of this integer um",
    "start": "2211200",
    "end": "2216640"
  },
  {
    "text": "this uh you know we're now assured that this lock free atomic instruction uh",
    "start": "2216640",
    "end": "2222960"
  },
  {
    "text": "can't rip and so um you know to get this um volatile",
    "start": "2222960",
    "end": "2229680"
  },
  {
    "text": "atomic behavior you really need to have lock free atomics for this to work successfully",
    "start": "2229680",
    "end": "2238160"
  },
  {
    "text": "okay so i mentioned earlier uh some wording changes in c23",
    "start": "2239520",
    "end": "2244960"
  },
  {
    "text": "uh one of the problems with volatile when you read the current version of the",
    "start": "2244960",
    "end": "2250240"
  },
  {
    "text": "standard which is c17 or earlier versions of the standard",
    "start": "2250240",
    "end": "2256400"
  },
  {
    "text": "is that volatile semantics are are specified to apply to objects uh",
    "start": "2256400",
    "end": "2262079"
  },
  {
    "text": "declared with the volatile qualifier so the standard says for example",
    "start": "2262079",
    "end": "2268160"
  },
  {
    "text": "accessing a volatile object modifying an object or side effects which are changes",
    "start": "2268160",
    "end": "2273760"
  },
  {
    "text": "in the state of the execution environment and that accesses to volatile objects",
    "start": "2273760",
    "end": "2279599"
  },
  {
    "text": "are valued strictly according to the rules of the abstract machine so the c standard refers to volatile",
    "start": "2279599",
    "end": "2286720"
  },
  {
    "text": "objects as regions of storage uh storing the representations of their",
    "start": "2286720",
    "end": "2291760"
  },
  {
    "text": "values and and so you can see here that you know volatile is associated with the object",
    "start": "2291760",
    "end": "2298800"
  },
  {
    "text": "you know with the storage of the object with the data so um so objects are distinct from the",
    "start": "2298800",
    "end": "2308000"
  },
  {
    "start": "2302000",
    "end": "2448000"
  },
  {
    "text": "expressions that are used to designate and access them right so those",
    "start": "2308000",
    "end": "2313359"
  },
  {
    "text": "expressions are called l values uh you know it's basically an expression",
    "start": "2313359",
    "end": "2318480"
  },
  {
    "text": "that when evaluated is going to reference a particular object but it doesn't have to to mention the",
    "start": "2318480",
    "end": "2325359"
  },
  {
    "text": "name of the access object it could just be uh you know accessed through uh through",
    "start": "2325359",
    "end": "2330480"
  },
  {
    "text": "a pointer um so if we go back to the the original",
    "start": "2330480",
    "end": "2335920"
  },
  {
    "text": "example uh that we had uh for you know the the motivating example in the early",
    "start": "2335920",
    "end": "2341680"
  },
  {
    "text": "unix source code for uh introducing volatile um you know we had a we had kl which was an address in",
    "start": "2341680",
    "end": "2349280"
  },
  {
    "text": "memory and so there was there's no way to declare that volatile so instead there was an expression",
    "start": "2349280",
    "end": "2355359"
  },
  {
    "text": "uh where we um you know we we cast it to a volatile qualified",
    "start": "2355359",
    "end": "2361040"
  },
  {
    "text": "pointer and then access it so the object itself is not uh is not a volatile qualified",
    "start": "2361040",
    "end": "2368880"
  },
  {
    "text": "object it's just being accessed through a volatile qualified l value",
    "start": "2368880",
    "end": "2375359"
  },
  {
    "text": "um so uh so l values are not mentioned by c17",
    "start": "2375359",
    "end": "2381119"
  },
  {
    "text": "so volatile semantics could be inferred to to not apply to these uh accesses and",
    "start": "2381119",
    "end": "2388000"
  },
  {
    "text": "um you know it's definitely you know a legitimate reading of the",
    "start": "2388000",
    "end": "2393520"
  },
  {
    "text": "standard although uh you know the response to this as well you know this is exactly the reason why",
    "start": "2393520",
    "end": "2400720"
  },
  {
    "text": "these were introduced so um in the linux kernel uh the lyft car",
    "start": "2400720",
    "end": "2408400"
  },
  {
    "text": "relies on volatile in its implementation of synchronization primitives such as spin locks",
    "start": "2408400",
    "end": "2414720"
  },
  {
    "text": "and uh performance counters so the objects that are operating on these",
    "start": "2414720",
    "end": "2420079"
  },
  {
    "text": "primitives are usually um declared to be unqualified or",
    "start": "2420079",
    "end": "2425520"
  },
  {
    "text": "non-volatile scalar types and and just allocate it in ordinary memory",
    "start": "2425520",
    "end": "2431119"
  },
  {
    "text": "so this is this is for maximum efficiency so that each object is read and written",
    "start": "2431119",
    "end": "2437280"
  },
  {
    "text": "just like any other object and you know so the value can be cached in a register",
    "start": "2437280",
    "end": "2443839"
  },
  {
    "text": "and you know various optimizations be performed so",
    "start": "2443839",
    "end": "2449440"
  },
  {
    "text": "um at well-defined points in the kernel a variable might need to be accessed by",
    "start": "2449440",
    "end": "2456319"
  },
  {
    "text": "more than one cpu at a time uh at which time we want to prevent caching",
    "start": "2456319",
    "end": "2462319"
  },
  {
    "text": "and so on these occasions these objects need to be accessed through the volatile semantics",
    "start": "2462319",
    "end": "2469680"
  },
  {
    "text": "um so to achieve this the kernel has two macros a read once and a write one's",
    "start": "2469680",
    "end": "2475200"
  },
  {
    "text": "macro which basically provides these primitives using um",
    "start": "2475200",
    "end": "2481359"
  },
  {
    "text": "volatile semantics so each macro prevents the compiler",
    "start": "2481359",
    "end": "2486720"
  },
  {
    "text": "optimization by casting the argument to a volatile qualified pointer",
    "start": "2486720",
    "end": "2493280"
  },
  {
    "start": "2492000",
    "end": "2526000"
  },
  {
    "text": "so uh linus uh torvo weighs in on this by saying uh you",
    "start": "2493280",
    "end": "2498960"
  },
  {
    "text": "know volatile is on the wrong part of the system and see it's it's the data that's volatile but",
    "start": "2498960",
    "end": "2505520"
  },
  {
    "text": "that's insane uh data's and volatile accesses to data are volatile",
    "start": "2505520",
    "end": "2510720"
  },
  {
    "text": "so it makes sense to say this particular axis uh be careful uh but not make all",
    "start": "2510720",
    "end": "2516960"
  },
  {
    "text": "access just data use some some some random i'm not sure it's a random but uh",
    "start": "2516960",
    "end": "2522720"
  },
  {
    "text": "you know basically be treated as a volatile qualified object so um so you know that's that's correct",
    "start": "2522720",
    "end": "2530240"
  },
  {
    "start": "2526000",
    "end": "2617000"
  },
  {
    "text": "and this was i i i think the original tent of this all all along uh it's just",
    "start": "2530240",
    "end": "2535599"
  },
  {
    "text": "that the language and the c standard wasn't very clear so in c23 uh we've",
    "start": "2535599",
    "end": "2541280"
  },
  {
    "text": "we've already modified this language and this will be found in the the latest",
    "start": "2541280",
    "end": "2546400"
  },
  {
    "text": "working draft of c23 and so basically what we've done",
    "start": "2546400",
    "end": "2552160"
  },
  {
    "text": "is we've taken every reference to a to volatile object",
    "start": "2552160",
    "end": "2557520"
  },
  {
    "text": "that appeared in the standard and replaced it with",
    "start": "2557520",
    "end": "2563280"
  },
  {
    "text": "language which says you know access through an l value of a volatile qualified type right so uh",
    "start": "2563280",
    "end": "2570960"
  },
  {
    "text": "basically we we changed the language in c23 so it's no longer",
    "start": "2570960",
    "end": "2576960"
  },
  {
    "text": "referring to the data you know the the volatile qualified object but instead",
    "start": "2576960",
    "end": "2582640"
  },
  {
    "text": "is referring to the uh the access through a volatile qualified uh l value",
    "start": "2582640",
    "end": "2590560"
  },
  {
    "text": "so uh so this this really is should just be a word and change and it's really designed to",
    "start": "2590560",
    "end": "2598640"
  },
  {
    "text": "um to make sure the language is in line with what we hope uh all existing implementations are",
    "start": "2598640",
    "end": "2604880"
  },
  {
    "text": "already doing so uh hopefully there are no implementations that",
    "start": "2604880",
    "end": "2610160"
  },
  {
    "text": "actually have to change to uh to satisfy uh this new language",
    "start": "2610160",
    "end": "2618160"
  },
  {
    "start": "2617000",
    "end": "2746000"
  },
  {
    "text": "uh so in summary um volatility is on the access not on the",
    "start": "2618160",
    "end": "2624400"
  },
  {
    "text": "object well it can also be on the object in which case all accesses would have to be uh volatile but um",
    "start": "2624400",
    "end": "2631440"
  },
  {
    "text": "you know the the axis itself can be volatile even if the object is not volatile qualified",
    "start": "2631440",
    "end": "2638000"
  },
  {
    "text": "um there are a number of misleading or invalid volatile operations",
    "start": "2638000",
    "end": "2643440"
  },
  {
    "text": "that we've seen including uh the simple assignment uh you know compound assignment and",
    "start": "2643440",
    "end": "2650480"
  },
  {
    "text": "uh pre and post increment decrement operations these have been deprecated in c plus plus 20 along with some other uh",
    "start": "2650480",
    "end": "2657680"
  },
  {
    "text": "uses of um volatile that are unique to c plus plus",
    "start": "2657680",
    "end": "2663040"
  },
  {
    "text": "but may or may not be deprecated and see uh that's still um to be determined",
    "start": "2663040",
    "end": "2669440"
  },
  {
    "text": "by the committee um but it's it's a good idea to avoid these",
    "start": "2669440",
    "end": "2675280"
  },
  {
    "text": "deprecated operations in both languages you know for uh security reasons because",
    "start": "2675280",
    "end": "2681760"
  },
  {
    "text": "um you know these sort of uses that we've described are are prone to misuse and so you could",
    "start": "2681760",
    "end": "2688240"
  },
  {
    "text": "wind up with a defect or a security vulnerability quite easily and also to maintain compatibility between these",
    "start": "2688240",
    "end": "2694800"
  },
  {
    "text": "languages because um c plus plus has deprecated this behavior uh whether or not c does it you",
    "start": "2694800",
    "end": "2701359"
  },
  {
    "text": "know so you want to avoid the deprecated behavior again in both languages",
    "start": "2701359",
    "end": "2707280"
  },
  {
    "text": "so volatility does not prevent tear tears and atomicity doesn't guarantee uh",
    "start": "2707280",
    "end": "2713119"
  },
  {
    "text": "bytes are only touched once um overall is about external modifications",
    "start": "2713119",
    "end": "2720480"
  },
  {
    "text": "it's not about anything else particularly about um synchronization so",
    "start": "2720480",
    "end": "2726000"
  },
  {
    "text": "volatility preserves the order of memory operations relative to um",
    "start": "2726000",
    "end": "2731440"
  },
  {
    "text": "only only relative to other volatile operations so again it's uh",
    "start": "2731440",
    "end": "2736960"
  },
  {
    "text": "it's not generally suitable for a thread synchronization you want to use other",
    "start": "2736960",
    "end": "2743680"
  },
  {
    "text": "other synchronization primitives instead so here's a list of references uh to",
    "start": "2743680",
    "end": "2749920"
  },
  {
    "start": "2746000",
    "end": "2820000"
  },
  {
    "text": "various papers this is the uh the pro c proposal uh that the c committee is going to",
    "start": "2749920",
    "end": "2756800"
  },
  {
    "text": "review uh here's various versions of uh jf",
    "start": "2756800",
    "end": "2762079"
  },
  {
    "text": "bastian's proposal to the c plus plus committee uh eventually it was the the",
    "start": "2762079",
    "end": "2767440"
  },
  {
    "text": "r4 version which was adopted uh and uh some additional papers that",
    "start": "2767440",
    "end": "2773599"
  },
  {
    "text": "provide some some background material for uh for this talk and for these other papers",
    "start": "2773599",
    "end": "2781119"
  },
  {
    "text": "uh so that's it that's all i have to say about uh volatile if you have any follow-on",
    "start": "2781119",
    "end": "2786960"
  },
  {
    "text": "questions you can find me on twitter at rcs you can find me on linkedin",
    "start": "2786960",
    "end": "2793520"
  },
  {
    "text": "you can send me email you can call me but i'm not really good at picking up my",
    "start": "2793520",
    "end": "2800160"
  },
  {
    "text": "phone so that's probably the worst of the options uh but anything else uh i i monitor",
    "start": "2800160",
    "end": "2806319"
  },
  {
    "text": "pretty regularly so you should um you should hear back from me pretty quickly",
    "start": "2806319",
    "end": "2811839"
  },
  {
    "text": "so if there are no other questions uh i'm gonna end there and uh thank you",
    "start": "2811839",
    "end": "2818000"
  },
  {
    "text": "thank you for your time",
    "start": "2818000",
    "end": "2821800"
  }
]