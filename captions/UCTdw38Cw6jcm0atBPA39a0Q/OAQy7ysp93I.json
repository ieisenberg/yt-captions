[
  {
    "start": "0",
    "end": "104000"
  },
  {
    "text": "well i believe that it's time so let's start hello everyone my name is alexander",
    "start": "12639",
    "end": "20400"
  },
  {
    "text": "maslinkov and today i want to talk to you about your phone's performance optimization",
    "start": "20400",
    "end": "31840"
  },
  {
    "text": "a little bit by myself uh i work as a software development engineer at intel and",
    "start": "32000",
    "end": "39520"
  },
  {
    "text": "for the most part i am busy transforming a desktop profiler named viton into a cloud",
    "start": "39520",
    "end": "46000"
  },
  {
    "text": "service over the course of the talk i will show some reports and",
    "start": "46000",
    "end": "51840"
  },
  {
    "text": "diagrams from this tool and uh the first question that you need",
    "start": "51840",
    "end": "59039"
  },
  {
    "text": "to ask yourself before diving into the whole optimization process is uh do you really need to tune your",
    "start": "59039",
    "end": "66080"
  },
  {
    "text": "performance and you don't really need to do it if you have no demand for higher",
    "start": "66080",
    "end": "71600"
  },
  {
    "text": "performance which means that your application or your service is running fine and",
    "start": "71600",
    "end": "79600"
  },
  {
    "text": "it's able to handle its big load you might also get away with tuning in",
    "start": "79600",
    "end": "86000"
  },
  {
    "text": "the performance of your system if you can easily afford running it on better hardware which of course",
    "start": "86000",
    "end": "94240"
  },
  {
    "text": "is not the case if your system is run on the client's hardware but in some cases it may be the easiest",
    "start": "94240",
    "end": "101040"
  },
  {
    "text": "solution and if you decided to proceed then",
    "start": "101040",
    "end": "109200"
  },
  {
    "start": "104000",
    "end": "104000"
  },
  {
    "text": "the first thing that you need to do is define the optimization criterion and the stepping condition optimization",
    "start": "109200",
    "end": "116640"
  },
  {
    "text": "criterion is a metric that you will use to evaluate the performance of your workload",
    "start": "116640",
    "end": "123600"
  },
  {
    "text": "and it doesn't necessarily need to be the execution time because for example if you have a",
    "start": "123600",
    "end": "130000"
  },
  {
    "text": "graphics application then you might want to measure the frame rate or if you develop a real-time system",
    "start": "130000",
    "end": "137440"
  },
  {
    "text": "then latency becomes your primary metric the stepping condition is basically a",
    "start": "137440",
    "end": "144080"
  },
  {
    "text": "threshold for your optimization criterion which declares the optimization successful",
    "start": "144080",
    "end": "149680"
  },
  {
    "text": "when met and the optimization process can be",
    "start": "149680",
    "end": "155920"
  },
  {
    "start": "153000",
    "end": "153000"
  },
  {
    "text": "visualized as a wheel diagram which you can see on the left where you",
    "start": "155920",
    "end": "160959"
  },
  {
    "text": "first make the change that potentially increases the performance then you measure the value",
    "start": "160959",
    "end": "166480"
  },
  {
    "text": "of your target metric and then based on that value uh you decide to commit or reject the",
    "start": "166480",
    "end": "173120"
  },
  {
    "text": "change and start over until the step and condition is met and you should always start with a",
    "start": "173120",
    "end": "179920"
  },
  {
    "text": "baseline measurement which reflects the absolute best performance that your",
    "start": "179920",
    "end": "185040"
  },
  {
    "text": "workload is capable of in its current state uh it's extremely important because you will",
    "start": "185040",
    "end": "192319"
  },
  {
    "text": "compare all your future results with this measurement which if not done correctly will affect",
    "start": "192319",
    "end": "198480"
  },
  {
    "text": "the results of your optimizations and in the next slide i will talk a little bit",
    "start": "198480",
    "end": "204879"
  },
  {
    "text": "about how to achieve that absolute best performance and",
    "start": "204879",
    "end": "211200"
  },
  {
    "text": "so what can we do uh to build a solid baseline uh most of the steps that i've listed on",
    "start": "211200",
    "end": "217360"
  },
  {
    "text": "this slide will seem trivial and implied for a lot of people in the audience",
    "start": "217360",
    "end": "223040"
  },
  {
    "text": "but you should be careful and make sure that you've completed all of them when building a baseline",
    "start": "223040",
    "end": "230000"
  },
  {
    "text": "it's possible that after ensuring that you applied all of the enhancements the performance",
    "start": "230000",
    "end": "236319"
  },
  {
    "text": "of your system will match the target performance that you're going for and you won't need to proceed with the",
    "start": "236319",
    "end": "242400"
  },
  {
    "text": "tuning process uh the first enhancement uh is to compile the solution in",
    "start": "242400",
    "end": "247920"
  },
  {
    "text": "release mode with the enabled optimization flex o2 or o3 for different different",
    "start": "247920",
    "end": "254640"
  },
  {
    "text": "compilers you should also compile your code for the cpu architecture that your code is",
    "start": "254640",
    "end": "260959"
  },
  {
    "text": "going to run on that way you may benefit from avx avx 2 or avx-512",
    "start": "260959",
    "end": "268880"
  },
  {
    "text": "instruction sets and this can be done using dash m arch dash m tune or dash m cpu",
    "start": "268880",
    "end": "276800"
  },
  {
    "text": "compiler flex you can also try to switch to the optimized versions",
    "start": "276800",
    "end": "282160"
  },
  {
    "text": "of the libraries that you use in your code",
    "start": "282160",
    "end": "286720"
  },
  {
    "start": "287000",
    "end": "287000"
  },
  {
    "text": "so let's assume that we've defined an optimization criterion a stepping condition and built a",
    "start": "287680",
    "end": "294080"
  },
  {
    "text": "baseline measurement the next step is to extract a workload from your system",
    "start": "294080",
    "end": "299840"
  },
  {
    "text": "which you are going to tune and measure you can use for example a slightly changed regression test as",
    "start": "299840",
    "end": "306800"
  },
  {
    "text": "your workloads or the application itself if it's small enough but no matter how you extract your",
    "start": "306800",
    "end": "313759"
  },
  {
    "text": "workload it must meet three key requirements",
    "start": "313759",
    "end": "318880"
  },
  {
    "text": "first the workload should be measurable which means that after each run you",
    "start": "318880",
    "end": "324479"
  },
  {
    "text": "should be able to calculate the value of your target metric the second the workload should be",
    "start": "324479",
    "end": "331520"
  },
  {
    "text": "reproducible and should yield similar results when passed the same input and the workload should",
    "start": "331520",
    "end": "339280"
  },
  {
    "text": "be representative which means that after you tune it you will also get the performance",
    "start": "339280",
    "end": "345360"
  },
  {
    "text": "increase of the corresponding part of your system",
    "start": "345360",
    "end": "349759"
  },
  {
    "text": "uh and the ways to optimize the performance can be split into two groups uh the first one for which",
    "start": "350960",
    "end": "358479"
  },
  {
    "text": "the performance increase is unknown in advance and potentially might be huge",
    "start": "358479",
    "end": "364800"
  },
  {
    "text": "this group includes algorithmic and design optimization and the second group for which the",
    "start": "364800",
    "end": "371520"
  },
  {
    "text": "performance increase is limited by the hardware capabilities uh it includes vectorization",
    "start": "371520",
    "end": "377720"
  },
  {
    "text": "parallelization and other microarchitecture optimizations one way or another",
    "start": "377720",
    "end": "384479"
  },
  {
    "text": "we will touch on each of those optimizations over the course of the talk",
    "start": "384479",
    "end": "390479"
  },
  {
    "text": "so now let's put our newly acquired knowledge in practice for this talk i've developed a small",
    "start": "391039",
    "end": "398319"
  },
  {
    "text": "sample application which i'm going to use to illustrate some of the optimization techniques",
    "start": "398319",
    "end": "404800"
  },
  {
    "text": "this sample application is a small model of in-memory database which gives data about",
    "start": "404800",
    "end": "410240"
  },
  {
    "text": "employees of some company their name position age and salary",
    "start": "410240",
    "end": "416080"
  },
  {
    "text": "this application allows supply and filters and getting filtered data as a result",
    "start": "416080",
    "end": "422800"
  },
  {
    "text": "this database holds 50 million records so that we can see some noticeable",
    "start": "422800",
    "end": "428400"
  },
  {
    "text": "performance increase when we apply the optimizations",
    "start": "428400",
    "end": "433039"
  },
  {
    "start": "432000",
    "end": "432000"
  },
  {
    "text": "the data flow of the sample application looks something like this the client makes a request to the",
    "start": "433599",
    "end": "440160"
  },
  {
    "text": "database and provides filters then the registry which",
    "start": "440160",
    "end": "445360"
  },
  {
    "text": "holds all the records performance filtration and returns filtered data in json response",
    "start": "445360",
    "end": "453520"
  },
  {
    "text": "i've decided to extract filtering operations as a workload and tune them",
    "start": "454319",
    "end": "461039"
  },
  {
    "text": "as a target performance metric we will use a completely made up for this application queries per second metric for which we",
    "start": "461039",
    "end": "468400"
  },
  {
    "text": "will refer to as qps later in the talk this metric shows how many filtering queries the",
    "start": "468400",
    "end": "475280"
  },
  {
    "text": "application processes in a second so let's imagine that our database is",
    "start": "475280",
    "end": "480879"
  },
  {
    "text": "queried on average 30 times per second which will make our desired qps of 30.",
    "start": "480879",
    "end": "489199"
  },
  {
    "text": "to help exactly extract the workload from the system i've used a small library called",
    "start": "489199",
    "end": "494879"
  },
  {
    "text": "itt api that allows you to divide code into sections and subsections",
    "start": "494879",
    "end": "502560"
  },
  {
    "text": "that we can filter by in some profilers my hardware setup consisted of intel",
    "start": "502560",
    "end": "509280"
  },
  {
    "text": "xeon gold 6152 processor which features 22 cores on two sockets and",
    "start": "509280",
    "end": "517518"
  },
  {
    "text": "avx 512 support and 128 gigabytes of ram uh the application was",
    "start": "517519",
    "end": "526080"
  },
  {
    "text": "compiled with the intel compiler 19.0 and on this uh b-ster machine",
    "start": "526080",
    "end": "532800"
  },
  {
    "text": "i've got the baseline performance of just 3.9 qps which is not that high and is almost",
    "start": "532800",
    "end": "541200"
  },
  {
    "text": "time 10 times less than our desired performance so we'll try to optimize it",
    "start": "541200",
    "end": "549760"
  },
  {
    "start": "549000",
    "end": "549000"
  },
  {
    "text": "you should always start the optimization process with the algorithmic and design optimizations because it",
    "start": "549760",
    "end": "556560"
  },
  {
    "text": "just makes sense to first fix your code and then try to tune it for this specific",
    "start": "556560",
    "end": "561760"
  },
  {
    "text": "hardware algorithmic optimization lies in choosing the most",
    "start": "561760",
    "end": "567360"
  },
  {
    "text": "suitable algorithms to solve your problem it doesn't always mean choosing the",
    "start": "567360",
    "end": "572399"
  },
  {
    "text": "algorithms with the best time or space complexity because for example on small sets of",
    "start": "572399",
    "end": "578720"
  },
  {
    "text": "data some linear algorithms might perform better than the ones that have constant complexity and on the",
    "start": "578720",
    "end": "586720"
  },
  {
    "text": "previous talk that was given by bjorn feller we saw exactly that",
    "start": "586720",
    "end": "593200"
  },
  {
    "text": "the algorithmic optimization also consists of using the libraries that contain",
    "start": "593360",
    "end": "598959"
  },
  {
    "text": "algorithms optimized for your target hardware and preferable by the vendor of that",
    "start": "598959",
    "end": "605120"
  },
  {
    "text": "hardware because in that case upgrading the hardware and the version of the library",
    "start": "605120",
    "end": "610880"
  },
  {
    "text": "will automatically give you a performance increase some optimized libraries or your own",
    "start": "610880",
    "end": "618079"
  },
  {
    "text": "codes might perform better than the vendor version but",
    "start": "618079",
    "end": "623279"
  },
  {
    "text": "will require additional efforts to support newest hardware capabilities",
    "start": "623279",
    "end": "630160"
  },
  {
    "start": "631000",
    "end": "631000"
  },
  {
    "text": "uh design optimization uh means carefully revising your code's architecture",
    "start": "631120",
    "end": "636959"
  },
  {
    "text": "and design to avoid performance bottlenecks it can result in eliminating unnecessary",
    "start": "636959",
    "end": "643680"
  },
  {
    "text": "copy operations switching to async operations instead of active weights",
    "start": "643680",
    "end": "650000"
  },
  {
    "text": "caching some data and so on it's a very creative process and a lot of books were written on how",
    "start": "650000",
    "end": "657360"
  },
  {
    "text": "to design your code in the right way so we won't go into much details here",
    "start": "657360",
    "end": "665040"
  },
  {
    "text": "uh you should start the algorithmic and design optimization with the hotspots analysis",
    "start": "665600",
    "end": "671360"
  },
  {
    "text": "uh hotspot is a place in your codes where your application is spending the most time hotspots are the",
    "start": "671360",
    "end": "679040"
  },
  {
    "text": "main candidates for optimization because by targeting the hotspots you can significantly reduce the",
    "start": "679040",
    "end": "685279"
  },
  {
    "text": "execution time of your application i'm sorry yeah",
    "start": "685279",
    "end": "692320"
  },
  {
    "text": "yeah don't search for the hotspots analytically and use the profiler",
    "start": "692320",
    "end": "699120"
  },
  {
    "text": "because not every hotspot you will expect to see and some of them you can just",
    "start": "699120",
    "end": "705680"
  },
  {
    "text": "miss when looking over your code a profiler on the other hand will analyze",
    "start": "705680",
    "end": "711200"
  },
  {
    "text": "your application and provide you with a well-reasoned list of the hotspots",
    "start": "711200",
    "end": "716240"
  },
  {
    "text": "after you get that list you should focus on the most unexpected hotspots for example you've",
    "start": "716240",
    "end": "722480"
  },
  {
    "text": "noticed that one of the top hotspots is some copy operation that you didn't expect to take so much cpu",
    "start": "722480",
    "end": "729680"
  },
  {
    "text": "time you go ahead and fix it then rerun the hotspots analysis",
    "start": "729680",
    "end": "735920"
  },
  {
    "text": "pick the next unexpectedly large hotspot and repeat the process after that you should",
    "start": "735920",
    "end": "742079"
  },
  {
    "text": "focus on just large hotspots which take a significant amount of cpu time",
    "start": "742079",
    "end": "748000"
  },
  {
    "text": "because it doesn't make much sense to tune the function that takes for example one percent of the cpu",
    "start": "748000",
    "end": "755279"
  },
  {
    "text": "time at most because the performance of your workloads will increase",
    "start": "755279",
    "end": "760320"
  },
  {
    "text": "in the best case by that one percent uh the algorithmic optimization will",
    "start": "760320",
    "end": "766560"
  },
  {
    "text": "give you the best results if your algorithms aren't optimal",
    "start": "766560",
    "end": "771760"
  },
  {
    "text": "if you paid attention to them before you decided to tune the performance of your application then you",
    "start": "771760",
    "end": "777279"
  },
  {
    "text": "probably won't benefit much from it",
    "start": "777279",
    "end": "781279"
  },
  {
    "start": "781000",
    "end": "781000"
  },
  {
    "text": "and this is a list of top hotspots of our sample application as you can see",
    "start": "782639",
    "end": "790079"
  },
  {
    "text": "the number one hotspot is in place operation of the stood vector",
    "start": "790079",
    "end": "797680"
  },
  {
    "text": "i didn't expect to see it here so i've decided to check the call stack",
    "start": "797680",
    "end": "802720"
  },
  {
    "text": "and found out that it was called by the filter method of employee register class let's see the",
    "start": "802720",
    "end": "810240"
  },
  {
    "text": "source code for this method this method receives a bunch of filters",
    "start": "810240",
    "end": "818079"
  },
  {
    "text": "performs the filtration then copies the filtered records into the result",
    "start": "818079",
    "end": "823440"
  },
  {
    "text": "vector of employee objects and returns it there's also no space",
    "start": "823440",
    "end": "828480"
  },
  {
    "text": "reservation for the result vector so let's recall the data flow of the",
    "start": "828480",
    "end": "833920"
  },
  {
    "text": "application it goes like this the client makes a request and provides filters",
    "start": "833920",
    "end": "840399"
  },
  {
    "text": "the employee registry performs the filtration and then the result of that filtration",
    "start": "840399",
    "end": "846800"
  },
  {
    "text": "is returned in json response uh when we assemble the json response we serialize the data",
    "start": "846800",
    "end": "854160"
  },
  {
    "text": "and basically copy it with the copy operation in the filter method uh we basically",
    "start": "854160",
    "end": "861199"
  },
  {
    "text": "copy the same data twice for one request which seems redundant",
    "start": "861199",
    "end": "866959"
  },
  {
    "text": "let's try to fix this method and i've got something like this and now",
    "start": "866959",
    "end": "874399"
  },
  {
    "text": "this method returns a vector of indices of filtered records in the main vector",
    "start": "874399",
    "end": "880079"
  },
  {
    "text": "which we can return by reference in another method this wouldn't make sense if we didn't",
    "start": "880079",
    "end": "887040"
  },
  {
    "text": "take a look at the data flow but it works in the context of the whole system",
    "start": "887040",
    "end": "893839"
  },
  {
    "text": "we now also reserve the space for the result vector and size of the vector that holds all of",
    "start": "893839",
    "end": "900000"
  },
  {
    "text": "the records it's not optimal space wise but saves us time on vector relocations",
    "start": "900000",
    "end": "907839"
  },
  {
    "text": "after this change we have a performance of 9.3 qps which is almost",
    "start": "907839",
    "end": "914160"
  },
  {
    "text": "two and a half times faster than the baseline but still not enough so we continue",
    "start": "914160",
    "end": "921920"
  },
  {
    "text": "uh this is this is the list of top hotspots after the design optimization which now",
    "start": "921920",
    "end": "928880"
  },
  {
    "text": "only contains simple filtering operations and functions and they only iterate over the container",
    "start": "928880",
    "end": "936639"
  },
  {
    "text": "and simply compare the values with the predicates so it doesn't make much sense to",
    "start": "936639",
    "end": "942000"
  },
  {
    "text": "optimize them algorithmically so we go on and we get to the",
    "start": "942000",
    "end": "949199"
  },
  {
    "text": "vectorization it's a cool feature that",
    "start": "949199",
    "end": "954399"
  },
  {
    "text": "most modern cpus support where these scalar operations are",
    "start": "954399",
    "end": "960240"
  },
  {
    "text": "transformed into the vector ones which allow us the cpu to execute them simultaneously",
    "start": "960240",
    "end": "969360"
  },
  {
    "text": "executes simultaneously a bunch of operations of the same time that are executed in a loop and this",
    "start": "969360",
    "end": "976320"
  },
  {
    "text": "significantly reduces the execution time the way that",
    "start": "976320",
    "end": "981519"
  },
  {
    "start": "980000",
    "end": "980000"
  },
  {
    "text": "vectorization works uh is by copying the operands to the long vector registers",
    "start": "981519",
    "end": "988079"
  },
  {
    "text": "uh executing a bulk operation and placing the results in another vector register uh this means",
    "start": "988079",
    "end": "995120"
  },
  {
    "text": "that the performance gain from vectorization is limited by the size of that vector register uh",
    "start": "995120",
    "end": "1002480"
  },
  {
    "text": "the most advanced instruction set at the moment is avx 512 which supports",
    "start": "1002480",
    "end": "1009600"
  },
  {
    "text": "the register length of 512 bits which means that it cannot fit more than",
    "start": "1009600",
    "end": "1017199"
  },
  {
    "text": "16 32-bit integers or more than 8 64-bits double values",
    "start": "1017199",
    "end": "1025839"
  },
  {
    "start": "1025000",
    "end": "1025000"
  },
  {
    "text": "so now let's take a look at the vectorization report of our sample application as you can see",
    "start": "1025919",
    "end": "1033520"
  },
  {
    "text": "the tool didn't find any loops in the filtering functions thursday so there is nothing to",
    "start": "1033520",
    "end": "1039760"
  },
  {
    "text": "vectorize the filter methods now looks like this",
    "start": "1039760",
    "end": "1046160"
  },
  {
    "text": "after the last optimization and i've highlighted in red the things that",
    "start": "1046160",
    "end": "1052240"
  },
  {
    "text": "prevent this code from being vectorized those may look like math science but",
    "start": "1052240",
    "end": "1058880"
  },
  {
    "text": "there are tools that will analyze your application and point out what places of your codes",
    "start": "1058880",
    "end": "1065039"
  },
  {
    "text": "weren't vectorized and why i specifically used intel advisor which was which is the",
    "start": "1065039",
    "end": "1072799"
  },
  {
    "text": "tool that you could see on the last slide and",
    "start": "1072799",
    "end": "1078160"
  },
  {
    "text": "it provides you with a recent list of the things that prevent your code from",
    "start": "1078160",
    "end": "1084160"
  },
  {
    "text": "being vectorized uh so what stands in the way of vectorizing our filter method",
    "start": "1084160",
    "end": "1090640"
  },
  {
    "text": "uh first when we loop through the records we apply all provided filters for each",
    "start": "1090640",
    "end": "1096480"
  },
  {
    "text": "record individually basically we do so much in the loop body",
    "start": "1096480",
    "end": "1101520"
  },
  {
    "text": "that compiler doesn't know how how to vectorize it second we keep our records as a vector",
    "start": "1101520",
    "end": "1109600"
  },
  {
    "text": "of struct objects with the four fields to be vectorized effectively the",
    "start": "1109600",
    "end": "1115520"
  },
  {
    "text": "operands should be located in the memory near each other so that the cpu could easily take the",
    "start": "1115520",
    "end": "1121600"
  },
  {
    "text": "block of memory and copy it into the vector register items in the vector",
    "start": "1121600",
    "end": "1127440"
  },
  {
    "text": "are located near each other but because it holds struct objects corresponding fields of",
    "start": "1127440",
    "end": "1133360"
  },
  {
    "text": "two objects have a gap between them and the third you can't really vectorize",
    "start": "1133360",
    "end": "1141840"
  },
  {
    "text": "two string it's a great and convenient class but we can't determine its length in",
    "start": "1141840",
    "end": "1149520"
  },
  {
    "text": "compile time and the compiler needs to know it to figure out how many objects it can",
    "start": "1149520",
    "end": "1156160"
  },
  {
    "text": "fit in the vector register so let's try to fix these issues",
    "start": "1156160",
    "end": "1162880"
  },
  {
    "text": "let's see what we got we replaced uh the usages of uh stood string",
    "start": "1162880",
    "end": "1168000"
  },
  {
    "text": "to stood array of chars with the fixed length uh switched the vector of struct objects",
    "start": "1168000",
    "end": "1175280"
  },
  {
    "text": "with four fields to four vectors of simple types and now filtering functions receive the",
    "start": "1175280",
    "end": "1182880"
  },
  {
    "text": "whole container iterate over it and execute simple filtering operations",
    "start": "1182880",
    "end": "1189919"
  },
  {
    "text": "after we've removed the roadblocks we can vectorize the codes really easily",
    "start": "1189919",
    "end": "1196000"
  },
  {
    "text": "by just putting two compiler pragmas before the loop the first one pragma if dapp tells the",
    "start": "1196000",
    "end": "1203440"
  },
  {
    "text": "compiler to ignore any assumed dependencies between input and output data",
    "start": "1203440",
    "end": "1209039"
  },
  {
    "text": "uh which would occur if for example if we used the results of the previous iteration to",
    "start": "1209039",
    "end": "1215280"
  },
  {
    "text": "calculate the next one uh we don't do such stuff here so it's",
    "start": "1215280",
    "end": "1220400"
  },
  {
    "text": "okay to put this pragma the second one pragma vector always tells",
    "start": "1220400",
    "end": "1225760"
  },
  {
    "text": "the compiler to always try to vectorize the loop below as you might have noticed",
    "start": "1225760",
    "end": "1233120"
  },
  {
    "text": "we have now more code we have to we had to provide different template",
    "start": "1233120",
    "end": "1239200"
  },
  {
    "text": "specializations for different data types because we can't really compare strings",
    "start": "1239200",
    "end": "1245919"
  },
  {
    "text": "the same way as for example two integers because to compare the strings you",
    "start": "1245919",
    "end": "1252559"
  },
  {
    "text": "have to iterate over each of the characters and compare them one by one",
    "start": "1252559",
    "end": "1259840"
  },
  {
    "text": "also the code is now less readable but with hardware optimizations it's",
    "start": "1259840",
    "end": "1266240"
  },
  {
    "text": "always a trade-off between code complexity and its performance",
    "start": "1266240",
    "end": "1272720"
  },
  {
    "text": "so the vectorization report now says that all filter loops were vectorized and",
    "start": "1274000",
    "end": "1279840"
  },
  {
    "text": "some were completely unrolled by the compiler uh so let's see what we got now and",
    "start": "1279840",
    "end": "1287520"
  },
  {
    "start": "1285000",
    "end": "1285000"
  },
  {
    "text": "the performance that we now have is at 24 qps which is six point times",
    "start": "1287520",
    "end": "1294240"
  },
  {
    "text": "faster than the baseline and 2.6 times faster than the previous step",
    "start": "1294240",
    "end": "1301360"
  },
  {
    "text": "but we want 30 qps or more so we continue",
    "start": "1301360",
    "end": "1306960"
  },
  {
    "start": "1307000",
    "end": "1307000"
  },
  {
    "text": "and get to the parallelization the ideal execution speed up from",
    "start": "1307360",
    "end": "1312960"
  },
  {
    "text": "parallelization that we would expect equals the number of course that the",
    "start": "1312960",
    "end": "1318000"
  },
  {
    "text": "code runs on but it's not the case in the real life and there are a bunch of factors",
    "start": "1318000",
    "end": "1324799"
  },
  {
    "text": "contributing to the overhead such as managing the threats communication and synchronization",
    "start": "1324799",
    "end": "1331280"
  },
  {
    "text": "between them and the overhead of the parallel runtime that you use",
    "start": "1331280",
    "end": "1337200"
  },
  {
    "text": "there's also amdahl's law that limits the theoretical speed up of the parallel",
    "start": "1337200",
    "end": "1344640"
  },
  {
    "text": "systems uh to parallelize the codes i've used the library called threading",
    "start": "1344840",
    "end": "1351039"
  },
  {
    "start": "1346000",
    "end": "1346000"
  },
  {
    "text": "building blocks which didn't require much code change to enable parallel execution",
    "start": "1351039",
    "end": "1357760"
  },
  {
    "text": "uh we just initialize the task scheduler and the task group and then we schedule",
    "start": "1357760",
    "end": "1364640"
  },
  {
    "text": "each filter and operation to execute in parallel all the details are left for the",
    "start": "1364640",
    "end": "1370400"
  },
  {
    "text": "parallel runtime to figure out as we can see the performance increased",
    "start": "1370400",
    "end": "1375679"
  },
  {
    "text": "significantly and is now at 130 qps uh which is which is 33 times faster",
    "start": "1375679",
    "end": "1383840"
  },
  {
    "text": "than the baseline and of course it meets our staffing condition",
    "start": "1383840",
    "end": "1389120"
  },
  {
    "text": "uh in the timeline diagram you can see a time points after test data initiation",
    "start": "1389120",
    "end": "1395240"
  },
  {
    "text": "initialization where the parallel runtime loaded all of the worker threads to almost 100 percent because uh this",
    "start": "1395240",
    "end": "1403679"
  },
  {
    "text": "brownish color actually represents uh the uh uh cpu uh",
    "start": "1403679",
    "end": "1409919"
  },
  {
    "text": "load of the thread and looking at how easily we've enabled",
    "start": "1409919",
    "end": "1415280"
  },
  {
    "text": "parallel execution of our codes you may ask why don't we do",
    "start": "1415280",
    "end": "1420559"
  },
  {
    "text": "the same thing with the baseline and skip all the previous steps completely",
    "start": "1420559",
    "end": "1426240"
  },
  {
    "text": "but it doesn't work that way our code became less than two times",
    "start": "1426240",
    "end": "1431520"
  },
  {
    "start": "1427000",
    "end": "1427000"
  },
  {
    "text": "faster on a machine with 22 cores on each of two sockets",
    "start": "1431520",
    "end": "1438960"
  },
  {
    "text": "this happened because in all previous steps we optimized the performance of a single",
    "start": "1438960",
    "end": "1444880"
  },
  {
    "text": "thread which is multiplied after parallelization so it's very important not to overlook",
    "start": "1444880",
    "end": "1452640"
  },
  {
    "text": "the single thread performance and we've met our stopping condition uh",
    "start": "1452640",
    "end": "1459760"
  },
  {
    "start": "1456000",
    "end": "1456000"
  },
  {
    "text": "but uh if we wanted to go further uh we could make an attempt to optimize",
    "start": "1459760",
    "end": "1465120"
  },
  {
    "text": "the micro architecture execution of our code uh the performance gain from microarchitecture optimizations",
    "start": "1465120",
    "end": "1472000"
  },
  {
    "text": "is limited by the ideal cpi or clocks per instructions metric",
    "start": "1472000",
    "end": "1477520"
  },
  {
    "text": "value which indicates how many clocks it took for the cpu to execute the instruction",
    "start": "1477520",
    "end": "1484799"
  },
  {
    "text": "most modern cpus cannot execute more than four instructions per clock so the ideal",
    "start": "1484799",
    "end": "1491760"
  },
  {
    "text": "cpi is limited by 0.25",
    "start": "1491760",
    "end": "1497440"
  },
  {
    "text": "in microarchitecture optimizations it's helpful to use metrics that depend on",
    "start": "1497440",
    "end": "1503520"
  },
  {
    "text": "clocks rather than on cpu frequency because the cpu frequency may change",
    "start": "1503520",
    "end": "1509600"
  },
  {
    "text": "during the workloads execution and you will get inconsistent results",
    "start": "1509600",
    "end": "1516640"
  },
  {
    "text": "the ideal cpu execution pipeline looks similar to the top picture where on each clock",
    "start": "1516640",
    "end": "1523679"
  },
  {
    "text": "the cpu receives four instructions which are successfully retired",
    "start": "1523679",
    "end": "1528720"
  },
  {
    "text": "but it's uh doesn't happen in real life and the real cpu execution pipeline",
    "start": "1528720",
    "end": "1534960"
  },
  {
    "text": "looks more like the picture at the bottom uh where the amounts of instructions",
    "start": "1534960",
    "end": "1540159"
  },
  {
    "text": "retired on each cloak varies",
    "start": "1540159",
    "end": "1544640"
  },
  {
    "text": "this may happen for three main reasons and all other reasons are derived from those",
    "start": "1546720",
    "end": "1552559"
  },
  {
    "text": "three frontend bounds and bound and bad speculation",
    "start": "1552559",
    "end": "1558400"
  },
  {
    "text": "modern cpu core is a complex device which consists of two main parts",
    "start": "1558400",
    "end": "1564559"
  },
  {
    "text": "front-end and back-end or the execution engine",
    "start": "1564559",
    "end": "1570400"
  },
  {
    "text": "the purpose of the cpu front-ends is to fetch operations that need to be executed transform them",
    "start": "1570400",
    "end": "1577200"
  },
  {
    "text": "into micro-operations that's back-end understands and supply them to the back-end",
    "start": "1577200",
    "end": "1583520"
  },
  {
    "text": "sometimes front end under supplies the backend and a portion of pipeline slots is",
    "start": "1583520",
    "end": "1589679"
  },
  {
    "text": "remaining empty that's what's called front and bound",
    "start": "1589679",
    "end": "1595120"
  },
  {
    "text": "cpu backhands dispatches ready micro operations which can happen i'm sorry uh cpu",
    "start": "1595120",
    "end": "1601840"
  },
  {
    "text": "beckons dispatches radio micro operations into their execution units",
    "start": "1601840",
    "end": "1606880"
  },
  {
    "text": "and retires them upon completion uh sometimes uh back ends lacks required resources",
    "start": "1606880",
    "end": "1614400"
  },
  {
    "text": "for exception of new micro operations which can happen for example due to cache misses",
    "start": "1614400",
    "end": "1620240"
  },
  {
    "text": "where the cpu has to go and fetch some data from the main memory",
    "start": "1620240",
    "end": "1626559"
  },
  {
    "text": "that's what's called backhand bound branch predictor is a part of cpu",
    "start": "1626559",
    "end": "1633120"
  },
  {
    "text": "front-end this one this block right here which guesses which way a condition branch",
    "start": "1633120",
    "end": "1640640"
  },
  {
    "text": "will go before this is known based on previous statistical data",
    "start": "1640640",
    "end": "1646559"
  },
  {
    "text": "bad speculation happens when the branch predictor takes an incorrect guess",
    "start": "1646559",
    "end": "1652000"
  },
  {
    "text": "when that happens uh all the operations from incorrect branch that were executed",
    "start": "1652000",
    "end": "1657279"
  },
  {
    "text": "in advance have to be discarded",
    "start": "1657279",
    "end": "1661360"
  },
  {
    "start": "1662000",
    "end": "1662000"
  },
  {
    "text": "um as you can see uh microarchitecture efficiency of our sample application",
    "start": "1662480",
    "end": "1667679"
  },
  {
    "text": "is not very high and only 20 percent of instructions retire successfully and",
    "start": "1667679",
    "end": "1674880"
  },
  {
    "text": "60 of instructions are stalled due to demand of memory that happens",
    "start": "1674880",
    "end": "1683600"
  },
  {
    "text": "because the application deals with a large amount of data",
    "start": "1683600",
    "end": "1689039"
  },
  {
    "text": "which does not fit in the cpu cache and the cpu has to fetch it from the ram",
    "start": "1689039",
    "end": "1695520"
  },
  {
    "text": "it could probably be fixed if we processed our memory in small chunks rather than",
    "start": "1695520",
    "end": "1702000"
  },
  {
    "text": "all at once but we hit our target performance and won't bother with it this time",
    "start": "1702000",
    "end": "1711840"
  },
  {
    "start": "1711000",
    "end": "1711000"
  },
  {
    "text": "so what if you want to dig deeper and rewrite everything in assembly",
    "start": "1711840",
    "end": "1719200"
  },
  {
    "text": "whatever you do here i advise you to always measure the cpi of specific operations",
    "start": "1719200",
    "end": "1726240"
  },
  {
    "text": "and check how it affects the cpi in general that's important because not",
    "start": "1726240",
    "end": "1733600"
  },
  {
    "text": "all of the optimizations that are obvious and useful to us and the programmers are obvious and",
    "start": "1733600",
    "end": "1740080"
  },
  {
    "text": "useful to the compiler and can actually hurts the performance",
    "start": "1740080",
    "end": "1746240"
  },
  {
    "text": "you should also use top-down approach and focus on actual execution problems",
    "start": "1746240",
    "end": "1753679"
  },
  {
    "text": "and rewriting everything in assembly also puts on you a burden of manually",
    "start": "1753679",
    "end": "1759840"
  },
  {
    "text": "adapting your code to support the newest cpu features",
    "start": "1759840",
    "end": "1766320"
  },
  {
    "start": "1766000",
    "end": "1766000"
  },
  {
    "text": "and yeah as a summary i want to empha emphasize some key points",
    "start": "1766320",
    "end": "1772000"
  },
  {
    "text": "of the talk uh first use optimized libraries that saves your time and efforts and",
    "start": "1772000",
    "end": "1779760"
  },
  {
    "text": "brings you automatic performance increase when updated if this is not enough or not the way for",
    "start": "1779760",
    "end": "1786880"
  },
  {
    "text": "you and you want to start optimizing your code start with a solid baseline and check",
    "start": "1786880",
    "end": "1793440"
  },
  {
    "text": "that you've done everything to enhance its capabilities because you will base all your future",
    "start": "1793440",
    "end": "1799279"
  },
  {
    "text": "results on this measurement also define an optimization criterion",
    "start": "1799279",
    "end": "1804799"
  },
  {
    "text": "that is most suitable for your workload don't just go with the execution time as",
    "start": "1804799",
    "end": "1811039"
  },
  {
    "text": "a default metric it's maybe suitable for you but not as a",
    "start": "1811039",
    "end": "1818159"
  },
  {
    "text": "default option don't optimize your code analytically",
    "start": "1818159",
    "end": "1823360"
  },
  {
    "text": "and profile your codes to find performance bottlenecks",
    "start": "1823360",
    "end": "1828960"
  },
  {
    "text": "first fix your code algorithms and code design and then vectorize and parallelize your",
    "start": "1829120",
    "end": "1835919"
  },
  {
    "text": "code and rather help the compiler to generate optimal code",
    "start": "1835919",
    "end": "1841520"
  },
  {
    "text": "then write your own low level code here are some useful links to the tools",
    "start": "1841520",
    "end": "1849360"
  },
  {
    "start": "1846000",
    "end": "1846000"
  },
  {
    "text": "that i've used and to the codes of the sample application that i've used to illustrate the",
    "start": "1849360",
    "end": "1854480"
  },
  {
    "text": "optimization process it's broken down to the same steps that were shown",
    "start": "1854480",
    "end": "1860080"
  },
  {
    "text": "in the talk and you can look and try the code yourself",
    "start": "1860080",
    "end": "1865120"
  },
  {
    "text": "i've also put down a link to the top-down methodology i used to analyze microarchitecture that",
    "start": "1865120",
    "end": "1872240"
  },
  {
    "text": "i was talking about previously so now i will be happy to",
    "start": "1872240",
    "end": "1877360"
  },
  {
    "text": "take your questions and i see in the slack one question do you know how much of the",
    "start": "1877360",
    "end": "1884720"
  },
  {
    "text": "performance increase after enabling vectorization if any are due to replacing stood string",
    "start": "1884720",
    "end": "1890480"
  },
  {
    "text": "with the the ray of chairs alone well if you're talking about",
    "start": "1890480",
    "end": "1898480"
  },
  {
    "text": "the vectorization uh without with just replacing the stood string",
    "start": "1898480",
    "end": "1903919"
  },
  {
    "text": "with the student array of chairs and not putting",
    "start": "1903919",
    "end": "1911600"
  },
  {
    "text": "not broken not breaking down the structure of objects into simple vectors",
    "start": "1911600",
    "end": "1919120"
  },
  {
    "text": "of simple types then probably it's just can't be done because",
    "start": "1919120",
    "end": "1927200"
  },
  {
    "text": "all of those factors were contributing to the fact that the code could not be",
    "start": "1927200",
    "end": "1934080"
  },
  {
    "text": "vectorized and to do it we had to remove all the",
    "start": "1934080",
    "end": "1939279"
  },
  {
    "text": "roadblocks if you're talking about",
    "start": "1939279",
    "end": "1944559"
  },
  {
    "text": "the replacing the stood string with the stud array and not vectorizing your code uh i",
    "start": "1944960",
    "end": "1952159"
  },
  {
    "text": "did not do it and you have the links to the code and if you want you can try",
    "start": "1952159",
    "end": "1959039"
  },
  {
    "text": "it yourself",
    "start": "1959039",
    "end": "1963840"
  },
  {
    "text": "yes are there convincing reasons to use asym over intrinsic for vectorizing code",
    "start": "1964880",
    "end": "1971440"
  },
  {
    "text": "or is it better to rely on the compiler to vectorize yes as i as i said",
    "start": "1971440",
    "end": "1980960"
  },
  {
    "text": "i would not recommend writing the code in assembly unless you",
    "start": "1980960",
    "end": "1988480"
  },
  {
    "text": "absolutely have to uh because uh the modern compiler uh is a",
    "start": "1988480",
    "end": "1995200"
  },
  {
    "text": "uh is a very smart tool that knows how to generate uh optimal code",
    "start": "1995200",
    "end": "2003200"
  },
  {
    "text": "and i think that you just need to",
    "start": "2003200",
    "end": "2010240"
  },
  {
    "text": "try to help the compiler generate more optimal code than",
    "start": "2010240",
    "end": "2015600"
  },
  {
    "text": "handling everything yourself when writing an assembly",
    "start": "2015600",
    "end": "2022080"
  },
  {
    "text": "and for example i i know for a fact that a lot of performance libraries that are",
    "start": "2022960",
    "end": "2030640"
  },
  {
    "text": "written here at intel use intrinsics as a main",
    "start": "2030640",
    "end": "2038159"
  },
  {
    "text": "mechanism and they do just fine",
    "start": "2038159",
    "end": "2042799"
  },
  {
    "text": "so if there's not anything else then i think that we can finish and",
    "start": "2043519",
    "end": "2051440"
  },
  {
    "text": "you can approach me in the slack channel of the room or like in personal messages",
    "start": "2051440",
    "end": "2059040"
  },
  {
    "text": "i will be available for the rest of the",
    "start": "2059040",
    "end": "2063280"
  },
  {
    "text": "conference",
    "start": "2069320",
    "end": "2072320"
  }
]