[
  {
    "start": "0",
    "end": "60000"
  },
  {
    "text": "okay then I think we might as well crack on um thank you all for coming this is all good um you do realize a Rob",
    "start": "6770",
    "end": "12260"
  },
  {
    "text": "Connery's down in door room on he's doing a talk about Cassini and space and all that kind of so yet don't blame me I",
    "start": "12260",
    "end": "18110"
  },
  {
    "text": "would too but sadly you've got me and it's okay we're gonna have a bit of a talk about how to pass a file gonna have",
    "start": "18110",
    "end": "24590"
  },
  {
    "text": "a look at some sort of structured parsing kind of stuff and some things that maybe you've had a look at but maybe not since University or something",
    "start": "24590",
    "end": "31430"
  },
  {
    "text": "if you haven't looked at all um and we're gonna start kind of nice and easy and simply and say don't don't pass",
    "start": "31430",
    "end": "37370"
  },
  {
    "text": "files it's not worth it it's a this isn't your problem this is somebody else's problem we've got lots of",
    "start": "37370",
    "end": "42530"
  },
  {
    "text": "general-purpose programming languages it's not your speciality it's not your business it's not your the thing is",
    "start": "42530",
    "end": "47539"
  },
  {
    "text": "gonna deliver value to your customers so generally speaking don't pass fast use XML use the animal UCS for use anything",
    "start": "47539",
    "end": "53780"
  },
  {
    "text": "don't do it yourself that's my top tip so plenty of time to go and catch Rob Connery is good but finally if you do",
    "start": "53780",
    "end": "61249"
  },
  {
    "start": "60000",
    "end": "420000"
  },
  {
    "text": "want to stay and everything we can sort of say why would we want to pass a file there are still some reasons for doing",
    "start": "61249",
    "end": "66830"
  },
  {
    "text": "the parsing yourself and I can think of a handful really the kind of the first one really I think would be sort of",
    "start": "66830",
    "end": "72860"
  },
  {
    "text": "speed or efficiency perhaps the general-purpose parsing you've got isn't fast enough for your use case perhaps",
    "start": "72860",
    "end": "78320"
  },
  {
    "text": "you've got a really big file which takes a long time to parse all we lost in lots of small files which is then uses a lot",
    "start": "78320",
    "end": "83840"
  },
  {
    "text": "of memory or something you know so that's a good reason but you got to sort",
    "start": "83840",
    "end": "89360"
  },
  {
    "text": "of think about the trade-offs that are involved the maintenance cost that you're taking on by writing your own parser and building your own parser",
    "start": "89360",
    "end": "96340"
  },
  {
    "text": "another reason might be to reduce dependencies perhaps you're working in a resource-constrained environment you",
    "start": "96340",
    "end": "101960"
  },
  {
    "text": "know if you're a mobile or something you don't to take on another dependency on a general-purpose parser and again that's",
    "start": "101960",
    "end": "107899"
  },
  {
    "text": "useful thing custom or simple file formats if using a custom file format you don't really have much choice you",
    "start": "107899",
    "end": "112909"
  },
  {
    "text": "have to pass something you have to do something with that if it's something nice and simple it's possibly quick and easy enough to to pass yourself and",
    "start": "112909",
    "end": "119570"
  },
  {
    "text": "that's a good going but similarly you might want to then sort of switch to a more general-purpose language and just",
    "start": "119570",
    "end": "124820"
  },
  {
    "text": "use off-the-shelf components as a way to doing that the next one's a really good",
    "start": "124820",
    "end": "130130"
  },
  {
    "text": "reason I think is something that isn't a file that isn't something that can't really be represented nicely in a",
    "start": "130130",
    "end": "136970"
  },
  {
    "text": "general-purpose language something like a DSL a domain-specific language and there's plenty of sort of examples",
    "start": "136970",
    "end": "143420"
  },
  {
    "text": "of this you know things like make files so make is a good example there you know that's got its own custom file format",
    "start": "143420",
    "end": "148580"
  },
  {
    "text": "but then there's sort of the flipside to that you've got things like cake which is just c-sharp you got fake f-sharp",
    "start": "148580",
    "end": "154160"
  },
  {
    "text": "rake which is there's a theme here isn't that this Ruby so you know you again",
    "start": "154160",
    "end": "159260"
  },
  {
    "text": "those don't need custom parsing that's just a using a language even Gradle is",
    "start": "159260",
    "end": "164390"
  },
  {
    "text": "using groovy the things like a command-line options HTTP headers perhaps but again there's likely",
    "start": "164390",
    "end": "170300"
  },
  {
    "text": "general-purpose languages sre libraries out there which you can use for that kind of thing parsing standard out is a",
    "start": "170300",
    "end": "176630"
  },
  {
    "text": "good one if you just want to get the output of a file and see what's happened capturing the output and handling that",
    "start": "176630",
    "end": "182560"
  },
  {
    "text": "or other things things would like might be a natural language command so",
    "start": "182560",
    "end": "187970"
  },
  {
    "text": "something which you can just type into a application straight on so you track for",
    "start": "187970",
    "end": "193850"
  },
  {
    "text": "example issue track you can just type work ten hours and it'll add it on it knows what to do with that kind of thing",
    "start": "193850",
    "end": "200350"
  },
  {
    "text": "the other reason though is is kind of where I come in it's it's where we're just as interested in the structure of",
    "start": "200350",
    "end": "205790"
  },
  {
    "text": "the file as its contents so not just the the actual date of this in there but how",
    "start": "205790",
    "end": "211010"
  },
  {
    "text": "is how its structured how its formatted so we'll just whine back a bit and this is me hello that's what I looked like on",
    "start": "211010",
    "end": "216530"
  },
  {
    "text": "the internet work for JetBrains I'm a developer and developer advocates and if you don't know jetbrains we build a lot",
    "start": "216530",
    "end": "222290"
  },
  {
    "text": "of ID's if you've got a language there's likely an IDE for it and the way we build IDs is the interesting bit because",
    "start": "222290",
    "end": "229040"
  },
  {
    "text": "we build a parser for every single file type and we understand the structure of",
    "start": "229040",
    "end": "234140"
  },
  {
    "text": "the files and we use that to build features we can use that structure and the semantic knowledge from that to",
    "start": "234140",
    "end": "239600"
  },
  {
    "text": "build navigation seems like highlighting refactoring inspections and so on and in fact if you kind of did a back of",
    "start": "239600",
    "end": "246260"
  },
  {
    "text": "the napkin architecture diagram of what an ID JetBrains IDE looks like you'd come up with something like this you've",
    "start": "246260",
    "end": "251720"
  },
  {
    "text": "got a base platform at the bottom which is kind of like fire handling UI that kind of thing project model wife are we",
    "start": "251720",
    "end": "258500"
  },
  {
    "text": "working with lot of compilation options and I've got this nice section here psi program structure index that's where all",
    "start": "258500",
    "end": "264590"
  },
  {
    "text": "the fun stuff happens we parse all the files we get our semantic and structural information we cache it and read all",
    "start": "264590",
    "end": "270590"
  },
  {
    "text": "that kind of thing and then and this is the key bit big thing at the top features that's all the features we have those are all the",
    "start": "270590",
    "end": "276620"
  },
  {
    "text": "inspections the quick fixes the refactorings the navigation everything and the key thing is that it sits on top",
    "start": "276620",
    "end": "282350"
  },
  {
    "text": "of the psi it's really important so if we have a PSI if we have this structural information of the code we can build a",
    "start": "282350",
    "end": "288710"
  },
  {
    "text": "whole load of stuff but the flip side is if we don't have that we've got nothing so it's a it's an interesting sort of",
    "start": "288710",
    "end": "294979"
  },
  {
    "text": "model that's going on there and where I come into all of this is that I've been",
    "start": "294979",
    "end": "300830"
  },
  {
    "text": "working on the unity support in rider and unity for ever know what unity is",
    "start": "300830",
    "end": "307150"
  },
  {
    "text": "yeah brilliant it's absolutely massive it's powering if you've got any game on your phone good",
    "start": "307150",
    "end": "313250"
  },
  {
    "text": "chances are that it's written in unity it's got its own file format for shader",
    "start": "313250",
    "end": "318530"
  },
  {
    "text": "support for doing things with the GPU and that's about as much as I understand it things with the GPU and I wanted to",
    "start": "318530",
    "end": "326660"
  },
  {
    "text": "add that into into rider and resharper and once you've syntax highlighting for that and code folding and all these kinds of things and to do that I need",
    "start": "326660",
    "end": "333110"
  },
  {
    "text": "that psi level and so I wanted to pass shader lab files and it ended up being a",
    "start": "333110",
    "end": "340789"
  },
  {
    "text": "lot of fun and so I thought right if it's a lot of fun and interesting to me and a lot of interesting challenges interesting problems then I'm gonna go",
    "start": "340789",
    "end": "346340"
  },
  {
    "text": "and tell you that as well misery shared it's great so what am I trying to build what do I want out of this I've already",
    "start": "346340",
    "end": "353419"
  },
  {
    "text": "said that I want to know about the structure and the syntax of the file and we end up with a tree like this which is going to represent all of the data that",
    "start": "353419",
    "end": "360020"
  },
  {
    "text": "we've got I can show it to you in in real time on the Left we have a shader",
    "start": "360020",
    "end": "365720"
  },
  {
    "text": "file from a unity project there's no syntax highlighting in this one unfortunately that's the way it goes",
    "start": "365720",
    "end": "371169"
  },
  {
    "text": "and we kind of have blocks at the top which describe everything we can have properties here with colors and so on",
    "start": "371169",
    "end": "377960"
  },
  {
    "text": "and it's a sort of a structured file format it's a sort of hierarchical thing and we can map it on the right-hand side",
    "start": "377960",
    "end": "384139"
  },
  {
    "text": "there to a past version of the file and so this is our sort of syntax tree that represents everything we've got here so",
    "start": "384139",
    "end": "389780"
  },
  {
    "text": "we have a shader lab file at the top that breaks down into a shader command and inside that we've got a keyword for",
    "start": "389780",
    "end": "397159"
  },
  {
    "text": "the rich maps to shader and then shader values and it kind of drops down and goes in sort of hierarchical order from",
    "start": "397159",
    "end": "403520"
  },
  {
    "text": "now and given this information we can do lots of fun things so for example we can reckon colors and highlight them and do fun",
    "start": "403520",
    "end": "410330"
  },
  {
    "text": "stuff like that so how do we do this how do we build this how do we pass a file",
    "start": "410330",
    "end": "416600"
  },
  {
    "text": "in brackets for an IDE so that's my use case I want to build it for an IDE um by the way if anybody has any",
    "start": "416600",
    "end": "423770"
  },
  {
    "start": "420000",
    "end": "852000"
  },
  {
    "text": "questions any time please shout down we can address those so we can start simply",
    "start": "423770",
    "end": "430550"
  },
  {
    "text": "we can have a naive parser which is incredibly naive and it just kind of walks through each character in turn and",
    "start": "430550",
    "end": "436190"
  },
  {
    "text": "sort of looks at that and compares it is it an S okay is it an H is it a D er okay of match j2 brilliant now do this",
    "start": "436190",
    "end": "443110"
  },
  {
    "text": "and yeah fine it'll work and everything but you don't to do this this is not",
    "start": "443110",
    "end": "448160"
  },
  {
    "text": "well architected not well designed not useful not maintainable it's terrible what we want to do is is really TechEd",
    "start": "448160",
    "end": "456650"
  },
  {
    "text": "it we want to split it up a little bit split up the responsibilities we want to be able to read our individual characters and identify the specific",
    "start": "456650",
    "end": "463760"
  },
  {
    "text": "building blocks of this file format things like keywords identifies that the punctuation of the the operators or",
    "start": "463760",
    "end": "469460"
  },
  {
    "text": "semicolons the open brackets and so on I know once we got all that we want to use",
    "start": "469460",
    "end": "474920"
  },
  {
    "text": "our information to recognize the more complex constructs the blocks the if we're defining a property the sort of",
    "start": "474920",
    "end": "481250"
  },
  {
    "text": "the name of the property and the value of it it's a color what type of color it is and so on and then do something with",
    "start": "481250",
    "end": "488510"
  },
  {
    "text": "that so is that what we want to do depends on our application for for myself as an IDE so I'm going to be",
    "start": "488510",
    "end": "494000"
  },
  {
    "text": "building this psi low it layer from our architecture diagram but if you're doing something else you might want it to to",
    "start": "494000",
    "end": "500420"
  },
  {
    "text": "write out values at that point you know so you're streaming things as you're as you're passing your file or you might",
    "start": "500420",
    "end": "505580"
  },
  {
    "text": "want to sort of save that information build a new different kind of data structure to save at the end but we want",
    "start": "505580",
    "end": "512750"
  },
  {
    "text": "to split up these responsibilities and do something with it fortunately somebody's already done this for us somebody's already got this",
    "start": "512750",
    "end": "518630"
  },
  {
    "text": "architecture set for us and we can go back to the archetypal example of a a",
    "start": "518630",
    "end": "525890"
  },
  {
    "text": "parser and look at the compiler the compiler is a very structured parser that we've got here and it's not us so",
    "start": "525890",
    "end": "531320"
  },
  {
    "text": "the compilers kind of split into two parts a front end and a back end and the front end is the bit which we're interested it does all the actual",
    "start": "531320",
    "end": "537590"
  },
  {
    "text": "parsing the back end is the bit which generates code and does all fun stuff like that so have a",
    "start": "537590",
    "end": "543080"
  },
  {
    "text": "look at the front end bit this actually maps nicely to what we want to do in the IDE as well so that's also useful will",
    "start": "543080",
    "end": "549260"
  },
  {
    "text": "be split into three things we got lexical analysis syntactic analysis and then finally semantic analysis which we",
    "start": "549260",
    "end": "558560"
  },
  {
    "text": "can then use for our parsing we got a lexer a parser and we end up with the result in our case in my case sorry the",
    "start": "558560",
    "end": "565100"
  },
  {
    "text": "result is going to be some semantic analysis so what Alexis and parses so",
    "start": "565100",
    "end": "570890"
  },
  {
    "text": "lex's we'll start with that this performs lexical analysis and lexical is",
    "start": "570890",
    "end": "577100"
  },
  {
    "text": "something that relates to words of vocabulary or something so this recognizes key words recognize that identifier it breaks down a big block of",
    "start": "577100",
    "end": "584120"
  },
  {
    "text": "text into smaller chunks which we can manage which we can do something with so it's going to take our file is gonna",
    "start": "584120",
    "end": "590029"
  },
  {
    "text": "take a big block of string of text and convert that into a stream of tokens so we're going to generate a token to",
    "start": "590029",
    "end": "595310"
  },
  {
    "text": "represent each individual thing in our file format and I can be an identifier a",
    "start": "595310",
    "end": "600770"
  },
  {
    "text": "comment it can be whitespace it could be string literals or it could be any kind of operator or punctuation",
    "start": "600770",
    "end": "607310"
  },
  {
    "text": "I want to key things with Lexa's is that our tokens are lightweight generally",
    "start": "607310",
    "end": "612800"
  },
  {
    "text": "it's just an integer value all you need to do is be able to identify this is a comment this is a bit of white space so there quite often just an integer value",
    "start": "612800",
    "end": "619600"
  },
  {
    "text": "in my case with resharper in the IDE they're actually singleton object instances because it gives us a bit more",
    "start": "619600",
    "end": "626240"
  },
  {
    "text": "information on there but once we got our tokens passing them becomes a lot easier",
    "start": "626240",
    "end": "631779"
  },
  {
    "text": "because all we need to do now is match instead of having to sort of figure out what this block of text means we've just",
    "start": "631779",
    "end": "637880"
  },
  {
    "text": "got a list of tokens we just have to match against these tokens so for example with an expression if you had integer followed by the plus operator",
    "start": "637880",
    "end": "645620"
  },
  {
    "text": "symbol followed by an integer you know you've got an expression so that's a lot easier to pass them the digits 1 2 3 + 4",
    "start": "645620",
    "end": "652880"
  },
  {
    "text": "5 6 and because of this then Lexa's can actually be harder to write than pies on",
    "start": "652880",
    "end": "658370"
  },
  {
    "text": "the pies it can be a lot easier because you're just pattern matching over this stream of tokens so what do we get out",
    "start": "658370",
    "end": "665420"
  },
  {
    "text": "of a lexer so we have were say we're gonna get a stream of tokens and on the",
    "start": "665420",
    "end": "671990"
  },
  {
    "text": "left here we got an example of the file format itself this is the structured file format with the keywords with string literals with braces and so on",
    "start": "671990",
    "end": "678260"
  },
  {
    "text": "and on the right then we have a stream of tokens that matches this so we start",
    "start": "678260",
    "end": "683510"
  },
  {
    "text": "off with an end-of-line comment and it tells us what the value of that is we've got new lines we've got shade a keyword",
    "start": "683510",
    "end": "688550"
  },
  {
    "text": "we've got whitespace a string literal and so on so it's just a stream of tokens yes so the question is what is",
    "start": "688550",
    "end": "716840"
  },
  {
    "text": "the difference between a lexer and a posit because Alexa is we're just showing that Alexa is going to pattern",
    "start": "716840",
    "end": "722510"
  },
  {
    "text": "match on characters to produce tokens and in the parser is pattern matching on tokens to produce bigger constructs and",
    "start": "722510",
    "end": "728240"
  },
  {
    "text": "in that respect they are conceptually similar however it's just what level",
    "start": "728240",
    "end": "733760"
  },
  {
    "text": "they're doing it at and it's splitting up the responsibility so if the lexer is responsible for converting a big block",
    "start": "733760",
    "end": "740630"
  },
  {
    "text": "of text into something smaller and manageable that we can work with and that the smaller manageable thing is a stream of tokens and the parse that then",
    "start": "740630",
    "end": "747620"
  },
  {
    "text": "just needs to work with the stream of tokens rather than having to posit each individual character as it goes through",
    "start": "747620",
    "end": "753850"
  },
  {
    "text": "yeah and so again the question is could that be could there be other layers on top of that which will take the output",
    "start": "761060",
    "end": "766800"
  },
  {
    "text": "of a parser and do something useful for it yes what's this place so is every ok",
    "start": "766800",
    "end": "774630"
  },
  {
    "text": "with lectures and stuff so far awesome right next thing that Lex's there are solve problem they've been",
    "start": "774630",
    "end": "780540"
  },
  {
    "text": "around for absolutely ages and they have been written for us you can use we can",
    "start": "780540",
    "end": "785910"
  },
  {
    "text": "work with this so you can use a little extra generator basically you don't have to write one yourself you can use",
    "start": "785910",
    "end": "791100"
  },
  {
    "text": "electric generator things like Lex the granddaddy of them all which is nearly as old as I am I'm not a granddaddy hang",
    "start": "791100",
    "end": "798990"
  },
  {
    "text": "on oh if we've got flex which is a slightly better version of Lex then there's things like C s Lex for C sharp",
    "start": "798990",
    "end": "805190"
  },
  {
    "text": "FS Lex for F sharp J flex for Java and so on it's basically been ported and",
    "start": "805190",
    "end": "810870"
  },
  {
    "text": "improved and made different for each different platform that you're working with so what does it look like what is",
    "start": "810870",
    "end": "816750"
  },
  {
    "text": "it input of this look like traditionally this Alexa is Alexa file is split into",
    "start": "816750",
    "end": "822779"
  },
  {
    "text": "three parts you've kind of got an intro part at the top which is just user code and this just gets thrown into the output then",
    "start": "822779",
    "end": "829110"
  },
  {
    "text": "you get a middle path for declarations where you define directives such as the the namespaces you're going to use the",
    "start": "829110",
    "end": "835350"
  },
  {
    "text": "class names the interfaces and so on and they need to clear some regular expression macros declare some States and it finally your last part down the",
    "start": "835350",
    "end": "842279"
  },
  {
    "text": "bottom is a whole load of rules and actions and those rules are are the regular expressions we got to match and",
    "start": "842279",
    "end": "847350"
  },
  {
    "text": "then the action that we're going to do and the action is most frequently returned a token yeah regular",
    "start": "847350",
    "end": "855000"
  },
  {
    "start": "852000",
    "end": "1154000"
  },
  {
    "text": "expressions so everybody who has told you that you don't use regular expressions to parse HTML has been lying",
    "start": "855000",
    "end": "860070"
  },
  {
    "text": "to you so don't quote me on that let's do ever ok so let's have a look at a",
    "start": "860070",
    "end": "868310"
  },
  {
    "text": "lecture class so this is you can everyone see that one okay we write that",
    "start": "868310",
    "end": "873959"
  },
  {
    "text": "good stuff so this is a lexical flexo file for the shade lab file format at",
    "start": "873959",
    "end": "879480"
  },
  {
    "text": "the top there we just got a bunch of using statements these will get copied to the output file just as is there's a",
    "start": "879480",
    "end": "885570"
  },
  {
    "text": "bunch of definitions for example there's a namespace there that's going to be the",
    "start": "885570",
    "end": "891029"
  },
  {
    "text": "namespace that gets generated the name of the class that we generates more boring stuff like that and then we",
    "start": "891029",
    "end": "897790"
  },
  {
    "text": "start to hit our regular expressions so here's one for example this is defining",
    "start": "897790",
    "end": "904720"
  },
  {
    "text": "newline characters and these gonna be the newline characters we're going to match and the the braces around that",
    "start": "904720",
    "end": "910110"
  },
  {
    "text": "referencing other macro so we've got a file which would bring in which just includes a whole lot of characters for",
    "start": "910110",
    "end": "915550"
  },
  {
    "text": "us so that we don't have to use backslash our blacks backslash n everywhere but these are defining all the characters that represent new lines",
    "start": "915550",
    "end": "922140"
  },
  {
    "text": "so we've got standard character and live feed but also Unicode stuff because we also need to deal with Unicode we need",
    "start": "922140",
    "end": "928120"
  },
  {
    "text": "to remember to handle that we can then build those up into a slightly more",
    "start": "928120",
    "end": "933400"
  },
  {
    "text": "complex regular expression whereby it's we've got an optional CR CR question",
    "start": "933400",
    "end": "939400"
  },
  {
    "text": "mark optional carriage return followed by a line feed or it's just a scarier term by itself or it's just I forget",
    "start": "939400",
    "end": "945339"
  },
  {
    "text": "what n L stands for but one of the unicode line break characters or page",
    "start": "945339",
    "end": "951220"
  },
  {
    "text": "break Kara graph break parrot characters and so on and as we go down we get kind",
    "start": "951220",
    "end": "957400"
  },
  {
    "text": "of more interesting regular expressions as well so we can define a decimal digits or we can have an integer literal",
    "start": "957400",
    "end": "963700"
  },
  {
    "text": "whether that one integer literal which is a minus symbol followed by one or",
    "start": "963700",
    "end": "969280"
  },
  {
    "text": "more decimal digits and so on so great for expressions and finally we get our",
    "start": "969280",
    "end": "974530"
  },
  {
    "text": "block of rules which match against actions and so on so for example here we",
    "start": "974530",
    "end": "980980"
  },
  {
    "text": "have an equals sign and the action we do just there is just return just return the token which is equals so it's nice",
    "start": "980980",
    "end": "988180"
  },
  {
    "text": "and straightforward it's a really quite straightforward thing we have the real expressions which just describe",
    "start": "988180",
    "end": "993250"
  },
  {
    "text": "something I show something which actually is a regular expression so there's our integer literal for example",
    "start": "993250",
    "end": "999880"
  },
  {
    "text": "and then there's the token that we return at the end of it so we're splitting up our code based on regular",
    "start": "999880",
    "end": "1005880"
  },
  {
    "text": "expressions sorry we're splitting up our input file based on regular expressions and returning back tokens is everybody happy",
    "start": "1005880",
    "end": "1013440"
  },
  {
    "text": "with that in a quick overview of what a file looks like",
    "start": "1013440",
    "end": "1017899"
  },
  {
    "text": "okay so how does oh sorry about a question now it's so the question was is",
    "start": "1019500",
    "end": "1031839"
  },
  {
    "text": "out file format specific to a particular lexer or are they all using the same file format they're not using the same",
    "start": "1031839",
    "end": "1038380"
  },
  {
    "text": "file format but they're all very very similar so they all base if they're all pretty much based on Lex from 1975 and",
    "start": "1038380",
    "end": "1044290"
  },
  {
    "text": "so they're all very very similar they will have different capabilities with the regular expressions they will have other different things with the",
    "start": "1044290",
    "end": "1050710"
  },
  {
    "text": "directives but they'll be very similar and they pretty much all follow that pattern so it's very similar alright so",
    "start": "1050710",
    "end": "1060850"
  },
  {
    "text": "how does it work the lexer when it's run on that input file will generate some source code so it's not generating",
    "start": "1060850",
    "end": "1066760"
  },
  {
    "text": "binaries or dll's or anything like that it's just generate some source code and that will be included in your project and it'll be built and it'll do the work",
    "start": "1066760",
    "end": "1072850"
  },
  {
    "text": "for you all of the rules which are regular expressions get converted into a single finite state machine and that means that",
    "start": "1072850",
    "end": "1080170"
  },
  {
    "text": "all of our regular expressions are combined and matched at the same time then that's really cool you don't believe me but it is this",
    "start": "1080170",
    "end": "1087820"
  },
  {
    "text": "thing gets encoded into state transition tables which means everything is all done by lookups and the lookups are",
    "start": "1087820",
    "end": "1092980"
  },
  {
    "text": "based on the characters and the current state of where we are in the transitions and that means it's very fast and it's",
    "start": "1092980",
    "end": "1098800"
  },
  {
    "text": "very efficient so we're not allocating loads of memory we're not running crazy regular expressions we've got a limited subset of regular expressions that we",
    "start": "1098800",
    "end": "1105220"
  },
  {
    "text": "can do and it's all done through input look-up tables it also means that the",
    "start": "1105220",
    "end": "1111370"
  },
  {
    "text": "code is not very maintainable so if we look at the generated code off the back of this it gets very very scary very",
    "start": "1111370",
    "end": "1120040"
  },
  {
    "text": "very quickly so these I mean I'm just",
    "start": "1120040",
    "end": "1125680"
  },
  {
    "text": "still scrolling no small arrays oh there",
    "start": "1125680",
    "end": "1136600"
  },
  {
    "text": "we go and then there's there's the code it gets scary quickly it's not easy to maintain it's not easy to terribly easy",
    "start": "1136600",
    "end": "1142540"
  },
  {
    "text": "to debug but it's very good and it is very efficient so it's a bit of a",
    "start": "1142540",
    "end": "1148330"
  },
  {
    "text": "trade-off there with maintainability and there isn't any and efficiency",
    "start": "1148330",
    "end": "1154200"
  },
  {
    "start": "1154000",
    "end": "1409000"
  },
  {
    "text": "so I'm gonna kind of one of my reasons for doing this talk was looking at that",
    "start": "1154200",
    "end": "1160660"
  },
  {
    "text": "file and going what on earth is happening in there and so it was like well if I submit a talk that means I have to find out what all that greys are",
    "start": "1160660",
    "end": "1167080"
  },
  {
    "text": "doing so I'm going to tell you we'll be able to take this as an example regular",
    "start": "1167080",
    "end": "1172540"
  },
  {
    "text": "expression so is the simple regular session a and followed by a B or C followed by zero more D's followed by",
    "start": "1172540",
    "end": "1178660"
  },
  {
    "text": "one or more ease so nice and straightforward we can represent that as a state transition diagram so we start",
    "start": "1178660",
    "end": "1185560"
  },
  {
    "text": "at state zero we can then have an a we move to state one we can either have a B or a see and remove the state two from",
    "start": "1185560",
    "end": "1192070"
  },
  {
    "text": "there we can have a D and we stay at state two so we could have a zero or more DS and then we can have an e which",
    "start": "1192070",
    "end": "1197530"
  },
  {
    "text": "moves us to state three at which point we can have extra ease so we've already got a one so of more ease going up there",
    "start": "1197530",
    "end": "1204580"
  },
  {
    "text": "and we either terminate or we keep going it at the final state does that is that",
    "start": "1204580",
    "end": "1210340"
  },
  {
    "text": "clear to everyone awesome we can represent this as a table and this is effectively what's going on",
    "start": "1210340",
    "end": "1216670"
  },
  {
    "text": "inside that file with the index of the arrays effectively map that table and",
    "start": "1216670",
    "end": "1221920"
  },
  {
    "text": "the table has elements for all of the characters that you can match and and",
    "start": "1221920",
    "end": "1227410"
  },
  {
    "text": "something that happens at that point so we can either match it and move to new States we can accept the the pattern and",
    "start": "1227410",
    "end": "1235690"
  },
  {
    "text": "we've that means we're at the end of our regular expression or we've got an error nothing matches so we start at state",
    "start": "1235690",
    "end": "1241210"
  },
  {
    "text": "zero and let's say we hit we get the character B state zero with B is an",
    "start": "1241210",
    "end": "1247570"
  },
  {
    "text": "error so that's no good we don't match that but if we get a we match and we",
    "start": "1247570",
    "end": "1253120"
  },
  {
    "text": "move to state one I know we're at state one if we get a we get an error doesn't work but if we go to B we match we can",
    "start": "1253120",
    "end": "1259540"
  },
  {
    "text": "move to state 2 at which point if we get a D then oh right well that's our zero or more so if we get a D we stay on",
    "start": "1259540",
    "end": "1266590"
  },
  {
    "text": "state two and we loop and we can carry on looping but if we get an e we match we move on to state three a state three",
    "start": "1266590",
    "end": "1273460"
  },
  {
    "text": "is our final state and if we get an e again we're looping here because it",
    "start": "1273460",
    "end": "1278590"
  },
  {
    "text": "stays of state three or if it's anything else well then we're at we've hit accept",
    "start": "1278590",
    "end": "1283960"
  },
  {
    "text": "States and we've matched and there we are we've we've matched the token and then at that point the LexA will do the action we've",
    "start": "1283960",
    "end": "1290950"
  },
  {
    "text": "got return the token we've matched does that make sense awesome because it gets better we can",
    "start": "1290950",
    "end": "1299679"
  },
  {
    "text": "match two rules at the same time with the same table so with the diagram there",
    "start": "1299679",
    "end": "1305169"
  },
  {
    "text": "we've added on an extra bit the first state we can either match a as before or Rica match any other characters between",
    "start": "1305169",
    "end": "1311230"
  },
  {
    "text": "0 and 9 that will take us to a new state which at that point we can match 0 to 9 again and it stays at state 4 or we end",
    "start": "1311230",
    "end": "1319859"
  },
  {
    "text": "so again we start at state 0 if we got our a we would just go the route we just",
    "start": "1319859",
    "end": "1324940"
  },
  {
    "text": "went and everything's fine well or we could get a 0 to 9 character and at that",
    "start": "1324940",
    "end": "1330460"
  },
  {
    "text": "point we then we match state we match and we move to state for our new state down at the bottom at this point if we",
    "start": "1330460",
    "end": "1337389"
  },
  {
    "text": "might get another 0 or 9 then we've matched and we stay at state 4 and we loop otherwise anything else says right",
    "start": "1337389",
    "end": "1343809"
  },
  {
    "text": "ok that's it we've accepted and we've matched and so that allows us to match",
    "start": "1343809",
    "end": "1349119"
  },
  {
    "text": "multiple regular expressions at the same time with a table based lock-up which is",
    "start": "1349119",
    "end": "1354669"
  },
  {
    "text": "really cool and really efficient but don't make me write those arrays by hand I've got no idea so um it's very cool",
    "start": "1354669",
    "end": "1363100"
  },
  {
    "text": "we've got lookup in the state transitions table it's very fast it's very efficient there no allocations going on there which is also a really",
    "start": "1363100",
    "end": "1368409"
  },
  {
    "text": "cool thing but the trade-off is then the size of the tables I mean you saw from the file that massive amount of tables you need one entry in each the table for",
    "start": "1368409",
    "end": "1376210"
  },
  {
    "text": "every character you going to match because it's just a lookup but that's a fixed cost and you know you that's a",
    "start": "1376210",
    "end": "1382210"
  },
  {
    "text": "good trade-off to take the other thing you need to do is make sure that you match everything you need to match so in",
    "start": "1382210",
    "end": "1388509"
  },
  {
    "text": "your rules for your lexer they you make sure you're matching your newline characters matching your unicode",
    "start": "1388509",
    "end": "1394869"
  },
  {
    "text": "characters as well so that if someone sends you a Unicode file you can work with that and the other thing is that",
    "start": "1394869",
    "end": "1400600"
  },
  {
    "text": "you need to handle an expected output so they could have a catch-all rule which says no bad character I can't do",
    "start": "1400600",
    "end": "1405820"
  },
  {
    "text": "anything with that and it throws an error and it can't handle it alright so",
    "start": "1405820",
    "end": "1411070"
  },
  {
    "start": "1409000",
    "end": "1703000"
  },
  {
    "text": "we're gonna move on to pausing before we do is everybody happy with lexing excellent",
    "start": "1411070",
    "end": "1416659"
  },
  {
    "text": "I feel like setting your homework now I feel good oh I'm too far so what's parsing that so pausing",
    "start": "1416659",
    "end": "1422989"
  },
  {
    "text": "performs the syntactic analysis so once we've got our stream of tokens we've now going to verify that the the file our",
    "start": "1422989",
    "end": "1430429"
  },
  {
    "text": "inputs matches the syntax that we expect from the file so we've now no longer dealing with character level we're",
    "start": "1430429",
    "end": "1435559"
  },
  {
    "text": "dealing at something slightly higher we've got a higher level abstraction to work with and all we need to do is pattern match on our stream of tokens",
    "start": "1435559",
    "end": "1441799"
  },
  {
    "text": "which we've got from the lexer we've also got other information from the lecture as well that's given us token offsets and we can also look at the",
    "start": "1441799",
    "end": "1448369"
  },
  {
    "text": "contents of the text as well so we can see what that block what that identifier is what what the value of things are the",
    "start": "1448369",
    "end": "1457159"
  },
  {
    "text": "syntax is described by a grammar and if you're lucky the file format you're trying to pass has a well described",
    "start": "1457159",
    "end": "1463159"
  },
  {
    "text": "grammar and if you're not looking there isn't one and it's just a bunch of text which is harder but a grammar is usually",
    "start": "1463159",
    "end": "1469759"
  },
  {
    "text": "represented as a recursive hierarchy of rules so the top-level be the whole file and then it kind of gets broken down and",
    "start": "1469759",
    "end": "1477469"
  },
  {
    "text": "composed hierarchically into into other structures and finally down to tokens so",
    "start": "1477469",
    "end": "1483289"
  },
  {
    "text": "for example with my shade of file given a sort of an abridged shader file on the",
    "start": "1483289",
    "end": "1488449"
  },
  {
    "text": "right hand side there the grammar to describe that on the Left would start with shader file which is a block which",
    "start": "1488449",
    "end": "1495019"
  },
  {
    "text": "has got a keyword a string literal an opening brace I can have an optional",
    "start": "1495019",
    "end": "1500149"
  },
  {
    "text": "properties block an optional tags block some more stuff which is abridged and in our closing brace and that's it but we",
    "start": "1500149",
    "end": "1508459"
  },
  {
    "text": "recursively fight define things so the properties block is defined on the properties block can be a property's keyword an opening brace stuff abridged",
    "start": "1508459",
    "end": "1517329"
  },
  {
    "text": "so for example in that one I've actually got a property star which is 0 or more properties and in the closing brace same",
    "start": "1517329",
    "end": "1523909"
  },
  {
    "text": "with a tags block tag keyword opening brace and content 0 more tags and braces",
    "start": "1523909",
    "end": "1530179"
  },
  {
    "text": "and it builds up and it gets nice and big from there I can show you",
    "start": "1530179",
    "end": "1537819"
  },
  {
    "text": "the parser as well so this is actually this is a bad idea because there's a lot of extra boilerplate in here let's go",
    "start": "1544290",
    "end": "1552360"
  },
  {
    "text": "find a file okay so there's our",
    "start": "1552360",
    "end": "1558750"
  },
  {
    "text": "top-level rule which is shade a lab file and it's got shade of command in here",
    "start": "1558750",
    "end": "1565130"
  },
  {
    "text": "which again okay so there's our shade of command rule and the shadow command rule is a shader keyword followed by a shade",
    "start": "1566270",
    "end": "1572790"
  },
  {
    "text": "of value and a shade of value as a block itself and that's got a shade of value name which again isn't recursively",
    "start": "1572790",
    "end": "1578910"
  },
  {
    "text": "defined rule a token there which is left brace so the way this one works is there",
    "start": "1578910",
    "end": "1584670"
  },
  {
    "text": "anything in capitals that start there is actually a token anything in lowercase is a is under the rule another block",
    "start": "1584670",
    "end": "1590010"
  },
  {
    "text": "we've got left brace of properties question yes yeah so the question is",
    "start": "1590010",
    "end": "1611210"
  },
  {
    "text": "we're looking at structure in the pars of right now in the structure of the file does that is the lexer concerned",
    "start": "1611210",
    "end": "1617190"
  },
  {
    "text": "about structure as well so if you get an invalid file in the lexer does that fail does that go wrong and the answer is",
    "start": "1617190",
    "end": "1622890"
  },
  {
    "text": "usually no but and it's also there that's a good difference between a lexer and parser because the lexer doesn't care about the ordering of the tokens it",
    "start": "1622890",
    "end": "1629640"
  },
  {
    "text": "just cares about identifying tokens and so you could have you know 23 left",
    "start": "1629640",
    "end": "1634980"
  },
  {
    "text": "braces followed by a comment an identifier return keyword and everything",
    "start": "1634980",
    "end": "1640260"
  },
  {
    "text": "those are valid tokens but they're invalid is an invalid program so the generally speaking the lexer doesn't",
    "start": "1640260",
    "end": "1646410"
  },
  {
    "text": "necessarily care about the structure of things it's not quite true because the lexer can have states so it can",
    "start": "1646410",
    "end": "1653550"
  },
  {
    "text": "recognize the start of a token so for example there might be regular expressions in your lecture which only",
    "start": "1653550",
    "end": "1659010"
  },
  {
    "text": "match under certain conditions I'm struggling to think of something now there might be yeah so you can see here",
    "start": "1659010",
    "end": "1666540"
  },
  {
    "text": "I've got these things on the left here these are different states so when I enter it a bracket I have to pass things",
    "start": "1666540",
    "end": "1672540"
  },
  {
    "text": "a little bit differently sorry I have to Lex things a little bit differently much different",
    "start": "1672540",
    "end": "1677550"
  },
  {
    "text": "expressions for a couple of things because they're only valid in certain contexts and so you can have different",
    "start": "1677550",
    "end": "1682650"
  },
  {
    "text": "contexts in a lexer but it doesn't really care about the overall structure of the file only the parser itself does",
    "start": "1682650",
    "end": "1688290"
  },
  {
    "text": "another question yes the parser is",
    "start": "1688290",
    "end": "1694560"
  },
  {
    "text": "ignoring whitespace and new lines great question love it we'll come back to that yes so",
    "start": "1694560",
    "end": "1705680"
  },
  {
    "text": "okay so go back to this we will come back don't worry parsing is unlike",
    "start": "1705680",
    "end": "1712350"
  },
  {
    "text": "lexing parsing isn't these kind of a solve problem to be honest that there's lots of solutions to the problem there's",
    "start": "1712350",
    "end": "1718920"
  },
  {
    "text": "lots of different ways of writing parsers and generating parses there's two main styles really top-down and",
    "start": "1718920",
    "end": "1724500"
  },
  {
    "text": "recursive descent and botton up recursive assets so I'm going down one going up so top down is you match the",
    "start": "1724500",
    "end": "1731580"
  },
  {
    "text": "whole file first and then you recursively go down and to smaller and smaller things bottom-up you match",
    "start": "1731580",
    "end": "1736920"
  },
  {
    "text": "tokens and slowly build things up from there so if we're talking top down",
    "start": "1736920",
    "end": "1742230"
  },
  {
    "start": "1740000",
    "end": "1769000"
  },
  {
    "text": "parses so imagine a c-sharp file so we're probably all familiar with c-sharp files hopefully the the file is split into",
    "start": "1742230",
    "end": "1749430"
  },
  {
    "text": "things like you know using statements at the top then you've got like a zero zero or more namespace declarations namespace",
    "start": "1749430",
    "end": "1755490"
  },
  {
    "text": "declaration is written to zero more class declarations class declaration is written there more method declarations",
    "start": "1755490",
    "end": "1760680"
  },
  {
    "text": "method declaration so on you know so you see the connect collapses down into something smaller and smaller constructs but recursively so that's top down a",
    "start": "1760680",
    "end": "1767310"
  },
  {
    "text": "natural cursory descent and sort of pseudocode it would be kind of something",
    "start": "1767310",
    "end": "1774210"
  },
  {
    "text": "like this so you start with passing the shade lab file the first thing you would",
    "start": "1774210",
    "end": "1779310"
  },
  {
    "text": "try and do there is parse the shader command when you're trying to do that the first thing you would do then is match the token the shader keyword token",
    "start": "1779310",
    "end": "1786510"
  },
  {
    "text": "that would pull in the token from the lexer and match it and if everything's good we move on we then pass the shade",
    "start": "1786510",
    "end": "1792450"
  },
  {
    "text": "of value that recurse is down into a method which will pass the just the",
    "start": "1792450",
    "end": "1798060"
  },
  {
    "text": "shader value name match that match the string literal for that match the opening brace and then look at the next",
    "start": "1798060",
    "end": "1804540"
  },
  {
    "text": "token it might be a properties keyword in which case go and pass the properties it might be the substrate a keyword go",
    "start": "1804540",
    "end": "1810270"
  },
  {
    "text": "and positive sub shader or it might be a tax keyword don't pass that so we've got sort of optional recursive descent in that now",
    "start": "1810270",
    "end": "1818580"
  },
  {
    "text": "I've shown you that in pseudocode because the generated code has a lot of",
    "start": "1818580",
    "end": "1823919"
  },
  {
    "text": "boilerplate in it as well",
    "start": "1823919",
    "end": "1826878"
  },
  {
    "text": "so this is the pass file method and it kind of it takes up the whole fire whole screen because it's doing extra stuff",
    "start": "1839640",
    "end": "1845280"
  },
  {
    "text": "it's doing error handling and so on but we can see that the first thing it does here is powers shader command and in",
    "start": "1845280",
    "end": "1853020"
  },
  {
    "text": "part shade command itself we'll do a match against a shader keyword and then",
    "start": "1853020",
    "end": "1859140"
  },
  {
    "text": "it will do power shade a value here and so on so it does the same sort of thing but there's a lot of boilerplate there",
    "start": "1859140",
    "end": "1864990"
  },
  {
    "text": "so we're not gonna look at it moving on just does that make sense for top-down",
    "start": "1864990",
    "end": "1870630"
  },
  {
    "text": "pauses yes question there yes yes I",
    "start": "1870630",
    "end": "1877890"
  },
  {
    "text": "shoulda said that so I said the way it works with resharper we do have a parser generator yes so that is a an input file",
    "start": "1877890",
    "end": "1885540"
  },
  {
    "text": "to passage and rate to its custom I'll come back to that in a sec right so",
    "start": "1885540",
    "end": "1891900"
  },
  {
    "text": "bottom-up pauses are an entirely different beast and they start at the bottom and work their way up instead of",
    "start": "1891900",
    "end": "1897179"
  },
  {
    "text": "starting you know saying match I'm gonna match the whole file and then match smaller and smaller pieces they smart",
    "start": "1897179",
    "end": "1902309"
  },
  {
    "text": "start small and end up matching the whole file so this works with what's called the shift reduce algorithm I'm",
    "start": "1902309",
    "end": "1907559"
  },
  {
    "text": "not going to go over this because it's difficult to to show to demonstrate and to debug as well it's it's it's tricky",
    "start": "1907559",
    "end": "1914610"
  },
  {
    "text": "but the idea is something like you know you match a token this could be an integer and then what you do is you",
    "start": "1914610",
    "end": "1919950"
  },
  {
    "text": "shift it onto a stack and that's the shift of the part of the shift reduce so you might have something which has got an integer the the plus operator symbol",
    "start": "1919950",
    "end": "1927480"
  },
  {
    "text": "and you've just matched another integer you've shoved that onto the stack you've shift that onto the stack you then",
    "start": "1927480",
    "end": "1932669"
  },
  {
    "text": "reduce that and you say ah I recognize that pattern that's an expression so I'm gonna reduce that down to an expression",
    "start": "1932669",
    "end": "1938580"
  },
  {
    "text": "and then you get your next token which maybe it's another plus symbol and it might be another integer and you shift",
    "start": "1938580",
    "end": "1943710"
  },
  {
    "text": "those on and you can reduce that again you get another expression and you build things up from there might be a variable",
    "start": "1943710",
    "end": "1949260"
  },
  {
    "text": "assignment so you kind of reduce it down to a variable assignment then we reduce it down to a method declaration reduce",
    "start": "1949260",
    "end": "1954330"
  },
  {
    "text": "it down to a class declaration so you're building a bigger structure from a smaller thing to start with okay so I'm",
    "start": "1954330",
    "end": "1964950"
  },
  {
    "start": "1963000",
    "end": "2110000"
  },
  {
    "text": "gonna as I say I'm gonna skip over this you free yes [Music]",
    "start": "1964950",
    "end": "1971529"
  },
  {
    "text": "benefits and drawbacks of top-down and bottom-up pauses there are in some",
    "start": "1973800",
    "end": "1979890"
  },
  {
    "text": "respects yes there are some grammars which can be best handled with different",
    "start": "1979890",
    "end": "1985470"
  },
  {
    "text": "types of parses and it's all to do with recursion of something so if you have an",
    "start": "1985470",
    "end": "1991380"
  },
  {
    "text": "expression we should defined for example as an expression plus expression all of",
    "start": "1991380",
    "end": "1996630"
  },
  {
    "text": "a sudden your recursive there because your expression could to match that you have to match expression but to match",
    "start": "1996630",
    "end": "2001760"
  },
  {
    "text": "expression you have to match expression and so certain parses are better at handling that than others and that you",
    "start": "2001760",
    "end": "2009650"
  },
  {
    "text": "can go in an entire rabbit warren of Wikipedia pages on nois it's a it's a lot of fun there's some definition of",
    "start": "2009650",
    "end": "2016730"
  },
  {
    "text": "fun building a parser you've got a couple of choices here as well you can do a hand rolled parser you can write",
    "start": "2016730",
    "end": "2022730"
  },
  {
    "text": "one yourself or you can use a parser generator if it's actually easier to",
    "start": "2022730",
    "end": "2028910"
  },
  {
    "text": "write a parser than you'd think you know the lecture is the harder think to write building a parser especially if there's",
    "start": "2028910",
    "end": "2034610"
  },
  {
    "text": "a top-down recursive descent parser it's a very mechanical process pars file parse command passed keyword passed this",
    "start": "2034610",
    "end": "2041690"
  },
  {
    "text": "it's it's mechanical process is fairly straightforward to build it's also easy",
    "start": "2041690",
    "end": "2047510"
  },
  {
    "text": "to understand if you're reading it debugging it it's easy to follow it's easy to understand you can also use a",
    "start": "2047510",
    "end": "2052878"
  },
  {
    "text": "parser generator such as yak and bison yak stands for yet another compiler compiler there was a companion piece to",
    "start": "2052879",
    "end": "2059990"
  },
  {
    "text": "Lex bison was a newer version of yak probably named because it was yak you",
    "start": "2059990",
    "end": "2065148"
  },
  {
    "text": "know an antler have no idea it's an acronym of something and ah perfect",
    "start": "2065149",
    "end": "2072350"
  },
  {
    "text": "another tool for language with recognition because I was thinking antlers and these like Bisons don't have antlers they have horns but they usually",
    "start": "2072350",
    "end": "2079820"
  },
  {
    "text": "bottom up so they normally were their nominee table-driven that generated their table-driven and work as a",
    "start": "2079820",
    "end": "2085790"
  },
  {
    "text": "bottom-up recursive descent parser and they are also harder to understand harder to understand Hardesty but to",
    "start": "2085790",
    "end": "2092120"
  },
  {
    "text": "debug as well so in resharper we've got that follows showing you there it's a custom file format and we generate a we",
    "start": "2092120",
    "end": "2100460"
  },
  {
    "text": "actually generate the same sort of thing you would do as a hand-rolled top-down recursive descent parser it's a",
    "start": "2100460",
    "end": "2105830"
  },
  {
    "text": "mechanical process just gets generated there's another type of parser that I'd",
    "start": "2105830",
    "end": "2113520"
  },
  {
    "start": "2110000",
    "end": "2168000"
  },
  {
    "text": "like to to mention though which is part of combinators these is an interesting initialling way of doing things where",
    "start": "2113520",
    "end": "2119760"
  },
  {
    "text": "you build a positive by combining other smaller passes and so you can have if this is more of a sort of functional",
    "start": "2119760",
    "end": "2125310"
  },
  {
    "text": "programming style of doing things you'd have a function which say is to say parses a string and then you have",
    "start": "2125310",
    "end": "2131760"
  },
  {
    "text": "something which is going to pass a bigger construct and you combine positive lists of the string parts of function and mash things all together",
    "start": "2131760",
    "end": "2139160"
  },
  {
    "text": "it's kind of similar to how link works in the you know sort of functional its compositional and all of that but you",
    "start": "2139160",
    "end": "2146250"
  },
  {
    "text": "know it's also very easy to use but there's a sort of similar cost associated to that because you're building your parser at runtime and so",
    "start": "2146250",
    "end": "2152910"
  },
  {
    "text": "you're combining all those things at runtime and so then there is a cost to that that might be absolutely fine we do",
    "start": "2152910",
    "end": "2158340"
  },
  {
    "text": "have some usages of parser combinators in resharper but we actually save it for",
    "start": "2158340",
    "end": "2163860"
  },
  {
    "text": "our build tools rather than for as you type analysis so an example of this is f",
    "start": "2163860",
    "end": "2171119"
  },
  {
    "start": "2168000",
    "end": "2234000"
  },
  {
    "text": "parsec for f-sharp this is an example from fill trail Foods blog and given a",
    "start": "2171119",
    "end": "2177930"
  },
  {
    "text": "couple of sort of primitive functions P string to parse a string P float to",
    "start": "2177930",
    "end": "2183240"
  },
  {
    "text": "parse a float and space is one to pass one or more float sorry one or more whitespace characters you can define a",
    "start": "2183240",
    "end": "2189510"
  },
  {
    "text": "new parser pass forward which will match the string FD or forward you can see",
    "start": "2189510",
    "end": "2196080"
  },
  {
    "text": "that the sort of angle brackets pipe symbol would be or matching or followed",
    "start": "2196080",
    "end": "2202230"
  },
  {
    "text": "by one or more spaces followed by a float and if you match that do this",
    "start": "2202230",
    "end": "2207450"
  },
  {
    "text": "function which is going to be creating an instance of this you do a similar thing with left and right and generate",
    "start": "2207450",
    "end": "2213390"
  },
  {
    "text": "two you've now generated three pars of functions there and then finally we've got P come out which combines those all",
    "start": "2213390",
    "end": "2219540"
  },
  {
    "text": "together and it says match either the forward or left or right as we kind of",
    "start": "2219540",
    "end": "2225900"
  },
  {
    "text": "combine those all together to give us a final part of which we can then invoke and parse things that",
    "start": "2225900",
    "end": "2233099"
  },
  {
    "text": "Parviz there's a similar thing for C sharp which is using links in tax",
    "start": "2233099",
    "end": "2238500"
  },
  {
    "start": "2234000",
    "end": "2259000"
  },
  {
    "text": "personally I find this less readable than the F sharp version but it's",
    "start": "2238500",
    "end": "2243579"
  },
  {
    "text": "available and it's there and it's interesting we this is the library we use in in resharper but that's doing a",
    "start": "2243579",
    "end": "2249220"
  },
  {
    "text": "sort of similar sort of thing parsing many white spaces parsing one character or a digit or white space and",
    "start": "2249220",
    "end": "2255640"
  },
  {
    "text": "concatenated everything and building up a parser at the end of it so I'm not gonna spend too much time I'll ask a",
    "start": "2255640",
    "end": "2261579"
  },
  {
    "text": "question yes it is actually yes that's a",
    "start": "2261579",
    "end": "2266619"
  },
  {
    "text": "very good point this is doing the lexing and the pausing as that one is at the same time as well yes very good point I",
    "start": "2266619",
    "end": "2274510"
  },
  {
    "text": "hadn't kind of tweaked that before after splitting everything down and responsibilities and everything yes so",
    "start": "2274510",
    "end": "2279579"
  },
  {
    "text": "this one will be parsing whitespace and it'll just do those particular things there because it can actually build",
    "start": "2279579",
    "end": "2284859"
  },
  {
    "text": "things up from smaller values right so",
    "start": "2284859",
    "end": "2290619"
  },
  {
    "text": "that's kind of an overview of lexing and parsing so we're all experts like this now and the what then comes in is some",
    "start": "2290619",
    "end": "2299079"
  },
  {
    "text": "of the interesting problems that you kind of encountered the gotchas and everything and as was mentioned before",
    "start": "2299079",
    "end": "2304890"
  },
  {
    "text": "whitespace and comments oh it's a good one so we'd expect this to work so we've kind of got a grammar on the left-hand",
    "start": "2304890",
    "end": "2311230"
  },
  {
    "text": "side there the shader block there it's a keyword followed by a string literal an opening brace some stuff which is",
    "start": "2311230",
    "end": "2317470"
  },
  {
    "text": "abridged and a closing brace and that's what we're seeing on the right hand side and that looks like it should match but",
    "start": "2317470",
    "end": "2324369"
  },
  {
    "text": "the actual input we get is usually very different we get a whole bunch of carriage return line feeds white spaces",
    "start": "2324369",
    "end": "2330400"
  },
  {
    "text": "weird line feeds we've got comments and we've got all sorts of stuff and if we Lex that we get a whole bunch of stuff",
    "start": "2330400",
    "end": "2337680"
  },
  {
    "text": "including our comments and new lines which doesn't match what we said it was going to be in the grammar there's an",
    "start": "2337680",
    "end": "2345549"
  },
  {
    "start": "2344000",
    "end": "2389000"
  },
  {
    "text": "easy answer to this we filter things out we have a lexer which just returned so our lexer returns a stream of tokens",
    "start": "2345549",
    "end": "2352270"
  },
  {
    "text": "what we do is we create a new lecture which kind of decorates that decorate a pattern and it filters out our",
    "start": "2352270",
    "end": "2357460"
  },
  {
    "text": "whitespace and comments so resharper as I said has its tokens instead of being",
    "start": "2357460",
    "end": "2362859"
  },
  {
    "text": "integer values they are singleton object instances one of the things we've there isn't is filtered property so it",
    "start": "2362859",
    "end": "2368830"
  },
  {
    "text": "makes it very easy to filter things out so yes we just wrap that and we filter",
    "start": "2368830",
    "end": "2374410"
  },
  {
    "text": "out any tokens that we don't want to see so then the parser when it's looking at its stream of tokens it doesn't have to",
    "start": "2374410",
    "end": "2380200"
  },
  {
    "text": "worry about comments it doesn't have to worry about whitespace it just says do I have a keyword followed by a string literal followed by a left brace some",
    "start": "2380200",
    "end": "2386380"
  },
  {
    "text": "stuff and a right brace and that's a lot easier to match but the question we need",
    "start": "2386380",
    "end": "2391720"
  },
  {
    "text": "to ask is is it safe to lose the whitespace and that kind of depends on what it is we're building why we're",
    "start": "2391720",
    "end": "2396880"
  },
  {
    "text": "doing the putt this parsing in the first place if we just want to get stuff out and we're interested in the contents of",
    "start": "2396880",
    "end": "2402280"
  },
  {
    "text": "the file you know because it's a custom file format or whatever that well might well be yes but my answer is no I'm",
    "start": "2402280",
    "end": "2408910"
  },
  {
    "text": "building for an IDE and I've got a different set of constrict constraints with this so I'm trying to build sort of code editor features syntax highlighting",
    "start": "2408910",
    "end": "2415390"
  },
  {
    "text": "code folding and so on error highlighting inspections where you put a squiggly in the the right place",
    "start": "2415390",
    "end": "2421260"
  },
  {
    "text": "refactorings and formatting and so on so I need to work with both the contents and the structure of the file because",
    "start": "2421260",
    "end": "2427210"
  },
  {
    "text": "the contents gives us our semantic information for navigation and so on and here's an identifier and what that is",
    "start": "2427210",
    "end": "2432580"
  },
  {
    "text": "and so on but the structure allows us to report all our inspections so if I know what the structure of the file is I know",
    "start": "2432580",
    "end": "2438880"
  },
  {
    "text": "where to put the highlight so I know where the squiggly line goes so I know how to rewrite stuff I know where to put",
    "start": "2438880",
    "end": "2444430"
  },
  {
    "text": "in new lines if I move formatting code so I need to represent the structure of",
    "start": "2444430",
    "end": "2449590"
  },
  {
    "text": "the file as well as the contents so that's gonna be syntax trees so if we're using a syntax tree accuse inspections",
    "start": "2449590",
    "end": "2456580"
  },
  {
    "text": "to walk the tree I can refactoring it just by rewriting that tree and then sort of basically re serializing that as",
    "start": "2456580",
    "end": "2461830"
  },
  {
    "text": "text so who thought about stats syntax trees yeah no static syntax trees the an",
    "start": "2461830",
    "end": "2468820"
  },
  {
    "start": "2462000",
    "end": "2506000"
  },
  {
    "text": "abstract syntax tree is abstracts that see the Glee it doesn't represent the",
    "start": "2468820",
    "end": "2473950"
  },
  {
    "text": "contents of the file it represents what the file does effectively so these two nodes are the same the the brackets on",
    "start": "2473950",
    "end": "2480700"
  },
  {
    "text": "the left are implicit in the structure of the of the tree itself because the",
    "start": "2480700",
    "end": "2486640"
  },
  {
    "text": "brackets are used for precedence well we've already got that because of how the nodes are laid out what we need to",
    "start": "2486640",
    "end": "2492820"
  },
  {
    "text": "use instead are concrete parse trees and this is just a data structure which includes everything all of the new lines",
    "start": "2492820",
    "end": "2499060"
  },
  {
    "text": "or the whites all of the comments and everything we've got in there so basically we need those",
    "start": "2499060",
    "end": "2508269"
  },
  {
    "start": "2506000",
    "end": "2525000"
  },
  {
    "text": "filter tokens I'm trying to build a syntax tree of a concrete parse tree but",
    "start": "2508269",
    "end": "2513339"
  },
  {
    "text": "I've filtered out a whole bunch of tokens I need to get those back in and so I have to add in an extra process at",
    "start": "2513339",
    "end": "2518859"
  },
  {
    "text": "the end of my parsing thing to reinsert those missing tokens and add all the white space and comments back in and",
    "start": "2518859",
    "end": "2527289"
  },
  {
    "start": "2525000",
    "end": "2541000"
  },
  {
    "text": "that's like it's boring it's a mechanical process basically you walk your tree and if there are any gaps in",
    "start": "2527289",
    "end": "2532539"
  },
  {
    "text": "the the tokens that are there you compare it with the original excerpt and put them back in and it's a mechanical",
    "start": "2532539",
    "end": "2538930"
  },
  {
    "text": "process is fairly straightforward and it's good to go but then I hear you say what about what a significant whitespace",
    "start": "2538930",
    "end": "2545799"
  },
  {
    "start": "2541000",
    "end": "2569000"
  },
  {
    "text": "so if we just strip out a white space when we're dealing with with code how do we deal with something like this with F",
    "start": "2545799",
    "end": "2552069"
  },
  {
    "text": "sharp F sharp doesn't have well in depending on configuration it doesn't have end of scope markers there's",
    "start": "2552069",
    "end": "2558099"
  },
  {
    "text": "nothing to tell you that the method has finished apart from indentation same with a for loop and the if statement so we filtered",
    "start": "2558099",
    "end": "2565329"
  },
  {
    "text": "out all of our whitespace but we need significant whitespace so how do we deal with that and the answer is to actually insert",
    "start": "2565329",
    "end": "2572499"
  },
  {
    "start": "2569000",
    "end": "2620000"
  },
  {
    "text": "tokens we're in control of the lexo we can do interesting things there when the",
    "start": "2572499",
    "end": "2577869"
  },
  {
    "text": "lexer sees that there is an indent we can put in a new token which is zero width it doesn't have any particular",
    "start": "2577869",
    "end": "2583809"
  },
  {
    "text": "size so it's not gonna affect the output and just say his yeah here's an indent",
    "start": "2583809",
    "end": "2588940"
  },
  {
    "text": "and when we're coming out of the other way and it's shorter we can put in a token which is out stent or an indent is",
    "start": "2588940",
    "end": "2595930"
  },
  {
    "text": "it out dent or anything nobody knows it says is tricky or we can call it block start and block into to sort of save",
    "start": "2595930",
    "end": "2602170"
  },
  {
    "text": "things there and then if the parser can then match these tokens in the grammar so that the parser can say you know gone",
    "start": "2602170",
    "end": "2609400"
  },
  {
    "text": "if if token some stuff then match indent batch of whole bunch of stuff and match",
    "start": "2609400",
    "end": "2616329"
  },
  {
    "text": "finally outdent and carry on and this then kind of it",
    "start": "2616329",
    "end": "2625630"
  },
  {
    "text": "was a bit of a not exactly a lightbulb moment a reminder of how flexible code",
    "start": "2625630",
    "end": "2630940"
  },
  {
    "text": "is and how good everything is because we can interesting things with the lexer and with the code and just because it's",
    "start": "2630940",
    "end": "2636940"
  },
  {
    "text": "generated doesn't mean that we can't work with it so other examples are things like with f-sharp the if you see",
    "start": "2636940",
    "end": "2642670"
  },
  {
    "text": "two followed by a full full start character that's a float but if it's in",
    "start": "2642670",
    "end": "2648579"
  },
  {
    "text": "the contract of square brackets 2.0 that's now a range operator so you've",
    "start": "2648579",
    "end": "2653920"
  },
  {
    "text": "kind of got to figure out now how to match whether it's a float character or an operator and what we can do instead",
    "start": "2653920",
    "end": "2660460"
  },
  {
    "text": "is well let the lexer match in taught as a specific token and then we can put",
    "start": "2660460",
    "end": "2667749"
  },
  {
    "text": "another decorator around our lexer and say whenever you see in dot split that into two tokens so we kind of",
    "start": "2667749",
    "end": "2674259"
  },
  {
    "text": "post-processing this token stream and so who is the gentleman asked about extra",
    "start": "2674259",
    "end": "2680380"
  },
  {
    "text": "things on top of the lecture and the top of the pars and post-processing and things this is where that starts to come",
    "start": "2680380",
    "end": "2685420"
  },
  {
    "text": "in we've got flexibility with the lexer a similar example is rigor expressions",
    "start": "2685420",
    "end": "2691839"
  },
  {
    "start": "2688000",
    "end": "2730000"
  },
  {
    "text": "might not capture everything we might have to do things differently shada lab has nested comments and you",
    "start": "2691839",
    "end": "2697779"
  },
  {
    "text": "can't do that with regular expressions so when I said that people who've been lying to you about HTML and regular expressions they're telling the truth",
    "start": "2697779",
    "end": "2703989"
  },
  {
    "text": "really don't do it nested things in regular expressions it doesn't work and you definitely can't do it in the lexer",
    "start": "2703989",
    "end": "2709920"
  },
  {
    "text": "so you do things differently instead you have a rule which matches the start of the comment and the action for that",
    "start": "2709920",
    "end": "2715690"
  },
  {
    "text": "instead of just returning a token the action finishes off flexing that comment and ask custom code you could just put",
    "start": "2715690",
    "end": "2722170"
  },
  {
    "text": "whatever you want in there and that code can then count the number of start and end comment characters to handle nested",
    "start": "2722170",
    "end": "2728650"
  },
  {
    "text": "comments so that a lot of flexibility is kind of I don't really know how to sum this up succinctly but it's you don't",
    "start": "2728650",
    "end": "2735279"
  },
  {
    "start": "2730000",
    "end": "2749000"
  },
  {
    "text": "have to blindly follow the rules with these things you don't have to blindly follow the pattern of just return a",
    "start": "2735279",
    "end": "2740529"
  },
  {
    "text": "token make of just forcing everything into a regular expression you can do extra things you can do more complex",
    "start": "2740529",
    "end": "2746349"
  },
  {
    "text": "things and you can get it to work work with you another interesting problem",
    "start": "2746349",
    "end": "2752559"
  },
  {
    "start": "2749000",
    "end": "2805000"
  },
  {
    "text": "which encountered with these lashade lab file format is that some tokens can actually just appear anywhere and a good",
    "start": "2752559",
    "end": "2759130"
  },
  {
    "text": "example of this is c-sharp files as well so if you have hash if debug and hash and if they could appear absolutely",
    "start": "2759130",
    "end": "2765970"
  },
  {
    "text": "anywhere but if you can have tokens that appear anywhere how do you put those into the grammar how does the deposit deal with",
    "start": "2765970",
    "end": "2771850"
  },
  {
    "text": "that because the parser couldn't even deal with comments or white spaces so how does it deal with surprise tokens so",
    "start": "2771850",
    "end": "2779020"
  },
  {
    "text": "in shade lab we've got this cg program token here about halfway down and everything else is sort of shaded green",
    "start": "2779020",
    "end": "2784870"
  },
  {
    "text": "behind that that can appear anywhere in the file format which makes things interesting it's essentially a",
    "start": "2784870",
    "end": "2791620"
  },
  {
    "text": "preprocessor token to make things more interesting with not going to delve dwell on is the block inside C G program",
    "start": "2791620",
    "end": "2798490"
  },
  {
    "text": "is actually a different language and can be positive can plead differently but that's an entirely we're not going to go",
    "start": "2798490",
    "end": "2805300"
  },
  {
    "start": "2805000",
    "end": "2849000"
  },
  {
    "text": "into that but the way to deal with this is is to pass passing you kind of you have a preprocessor you treat it like a",
    "start": "2805300",
    "end": "2811720"
  },
  {
    "text": "preprocessor and you have a first pass which finds these preprocessor tokens",
    "start": "2811720",
    "end": "2817260"
  },
  {
    "text": "parses them does something with them and then gives that to a new filtering lexer",
    "start": "2817260",
    "end": "2822850"
  },
  {
    "text": "which can skip them I think your parsers normal and the grammar just doesn't see",
    "start": "2822850",
    "end": "2827950"
  },
  {
    "text": "it the parser doesn't see those surprise tokens at the end of that though I need to put those back in and so it's exactly",
    "start": "2827950",
    "end": "2835180"
  },
  {
    "text": "the same process as the missing tokens in Sirte and they just get shoved back in and everything's good error handling",
    "start": "2835180",
    "end": "2843880"
  },
  {
    "text": "that's not right that's more like it error handling is more of an art than a",
    "start": "2843880",
    "end": "2849820"
  },
  {
    "start": "2849000",
    "end": "2864000"
  },
  {
    "text": "science error handling is is kind of tricky is there's also surprisingly",
    "start": "2849820",
    "end": "2855310"
  },
  {
    "text": "little written about this as well there's about three or four papers and and things articles written about how to",
    "start": "2855310",
    "end": "2861790"
  },
  {
    "text": "do error handling with when parsing why do we care why do you care about error handling if you're parsing a custom file",
    "start": "2861790",
    "end": "2869170"
  },
  {
    "start": "2864000",
    "end": "2931000"
  },
  {
    "text": "format you want to have some useful error reporting and you also want to be sort of minimal error reporting you",
    "start": "2869170",
    "end": "2874510"
  },
  {
    "text": "don't want to have to say you know if there was a missing token the rest of your grammar is going to fail you know",
    "start": "2874510",
    "end": "2880030"
  },
  {
    "text": "because you can't match something it's all gone horribly wrong then you need to be able to just sort of",
    "start": "2880030",
    "end": "2886330"
  },
  {
    "text": "say there's an error here rather than saying your entire files messed up in",
    "start": "2886330",
    "end": "2891880"
  },
  {
    "text": "the IDE we especially need to do that because as you type your code is broken you don't type incomplete constructs you",
    "start": "2891880",
    "end": "2898960"
  },
  {
    "text": "type in you know characters and so for a large part of the time in the IDE your code is incorrect and you don't want the whole",
    "start": "2898960",
    "end": "2906290"
  },
  {
    "text": "file to be highlighted and shown as an error so you got a couple of choices you",
    "start": "2906290",
    "end": "2912620"
  },
  {
    "text": "can fail fast you know if you're if you're pausing a custom file format you might just want to say oh there's an",
    "start": "2912620",
    "end": "2917660"
  },
  {
    "text": "error right there and leave it as that but you're not going to be reporting any following errors you don't reporting",
    "start": "2917660",
    "end": "2922790"
  },
  {
    "text": "once and somebody could fix that and is like oh there's an error there now as well honey it's not great or you can try",
    "start": "2922790",
    "end": "2928310"
  },
  {
    "text": "and recover you can try to error recovering so what happens when there is",
    "start": "2928310",
    "end": "2934490"
  },
  {
    "start": "2931000",
    "end": "2971000"
  },
  {
    "text": "an error in my case the parser is going to add an error element into the tree so instead of having an element which",
    "start": "2934490",
    "end": "2940070"
  },
  {
    "text": "represents a method declaration or a block or a keyword or whatever I have a custom element in my tree which",
    "start": "2940070",
    "end": "2947720"
  },
  {
    "text": "represents an error the error spans everything has been passed so far which",
    "start": "2947720",
    "end": "2955220"
  },
  {
    "text": "could be the incorrect token or the thing we're not expecting and in that case for myself with my shade lab files",
    "start": "2955220",
    "end": "2961940"
  },
  {
    "text": "that means highlighting that in the editor is trivial basically I just look for an error element in the file",
    "start": "2961940",
    "end": "2968060"
  },
  {
    "text": "if there is one put a highlight for that whole token how do we find an error",
    "start": "2968060",
    "end": "2973880"
  },
  {
    "start": "2971000",
    "end": "3000000"
  },
  {
    "text": "sounds kind of obvious the starties is obvious you don't match something the parser is trying to match a particular",
    "start": "2973880",
    "end": "2979760"
  },
  {
    "text": "token and it doesn't find it so the either the token is missing or it's",
    "start": "2979760",
    "end": "2985010"
  },
  {
    "text": "something different and it's and there we go but where does the error stop",
    "start": "2985010",
    "end": "2990560"
  },
  {
    "text": "that's the tricky thing because if you've just kind of got one token missing or one token extra everything's",
    "start": "2990560",
    "end": "2995960"
  },
  {
    "text": "shunted along and it's gonna be very hard then to find where to stop so you need to try and recover but how what are",
    "start": "2995960",
    "end": "3001870"
  },
  {
    "start": "3000000",
    "end": "3111000"
  },
  {
    "text": "the options for you and it comes out to sort of three things basically you've got three options you can go into panic",
    "start": "3001870",
    "end": "3007330"
  },
  {
    "text": "mode which is a great description for it this is what the papers called it's not just me and that is basically you eat",
    "start": "3007330",
    "end": "3013990"
  },
  {
    "text": "tokens until you find something you recognize so if there was an error in a method declaration for example you would",
    "start": "3013990",
    "end": "3020830"
  },
  {
    "text": "go into panic mode and say oh quick something's gone wrong I need to find a closing brace and as soon as you find a closing brace is half fine and carry on",
    "start": "3020830",
    "end": "3027550"
  },
  {
    "text": "parsing it might work you might not another option you can do which works",
    "start": "3027550",
    "end": "3032650"
  },
  {
    "text": "surprisingly well is token insertion or removal a substitution it's kinda like playing what if he's saying oh I've got that I",
    "start": "3032650",
    "end": "3038650"
  },
  {
    "text": "wasn't expecting that what if I did get it and the other option you got is actually encoding the",
    "start": "3038650",
    "end": "3044620"
  },
  {
    "text": "rules into the grammar so panic mode as an example in my shader file here I'm",
    "start": "3044620",
    "end": "3050710"
  },
  {
    "text": "trying to pass a property here and a property is one of those lines and it's supposed to be the name followed by stuff in brackets equals and then a",
    "start": "3050710",
    "end": "3058420"
  },
  {
    "text": "value on the second line there I've actually got something going wrong because I don't have any brackets and so",
    "start": "3058420",
    "end": "3064300"
  },
  {
    "text": "it's gone into panic mode it is said I'm not expecting that I was expecting brackets I'll panic until I finds the",
    "start": "3064300",
    "end": "3070630"
  },
  {
    "text": "end of that particular expression which is the end of light and so it just eats everything so that's that's fine we've",
    "start": "3070630",
    "end": "3077110"
  },
  {
    "text": "kind of recovered nicely but if you look at the second example where somebody's put in an extra bit of text in there you",
    "start": "3077110",
    "end": "3083140"
  },
  {
    "text": "have a syntax error it tries to tries to match up again and finds the next thing it can and the next thing it can find",
    "start": "3083140",
    "end": "3091900"
  },
  {
    "text": "actually is then the start of a new rule which is going to be an identifier for an X property but that's not the",
    "start": "3091900",
    "end": "3098260"
  },
  {
    "text": "identifier for an X property that's still part of this line and so it gets it wrong and so all of a sudden now we've got two errors and it's it's kind",
    "start": "3098260",
    "end": "3105070"
  },
  {
    "text": "of messed up so panic mode will kind of get us part of the way there but it's",
    "start": "3105070",
    "end": "3110920"
  },
  {
    "text": "not brilliant token insertion however is a good a good chance and it kind of gets",
    "start": "3110920",
    "end": "3116620"
  },
  {
    "start": "3111000",
    "end": "3154000"
  },
  {
    "text": "a lot of it does capture quite a few of the issues so example here is we've got",
    "start": "3116620",
    "end": "3122500"
  },
  {
    "text": "a missing closing brace at the end of the word color there at the end of the color key word and what we do in that",
    "start": "3122500",
    "end": "3128500"
  },
  {
    "text": "case is we assume we got it so we said what if we did get it here and I care a try and carry on parsing from that and I",
    "start": "3128500",
    "end": "3135430"
  },
  {
    "text": "say well okay I'm I'm expecting a right parenthesis character I didn't get it it",
    "start": "3135430",
    "end": "3140980"
  },
  {
    "text": "should be followed by an equals character let's pretend I did and we've actually look at it here now we see",
    "start": "3140980",
    "end": "3146320"
  },
  {
    "text": "there is an equals character so it's like fine and he carry on parsing and it actually recovers very very quickly there and we've got a very small",
    "start": "3146320",
    "end": "3152290"
  },
  {
    "text": "localized error if that fails we can do the opposite you know perhaps somebody's",
    "start": "3152290",
    "end": "3158320"
  },
  {
    "start": "3154000",
    "end": "3184000"
  },
  {
    "text": "type too many characters and we can do total token removal so for example if we",
    "start": "3158320",
    "end": "3164650"
  },
  {
    "text": "tried to concerting a character and it didn't sink back up we can then try and say well perhaps as an extra character there and",
    "start": "3164650",
    "end": "3170660"
  },
  {
    "text": "I was expecting equals but I got another right parenthesis what if I didn't get the right percent parentheses what would",
    "start": "3170660",
    "end": "3177170"
  },
  {
    "text": "happen next look at the next character isn't equals it's correct and we sync back up again and we move on and the",
    "start": "3177170",
    "end": "3185960"
  },
  {
    "start": "3184000",
    "end": "3226000"
  },
  {
    "text": "final one then is is initially one in that you can tell your parser to expect an error and you can encode it directly",
    "start": "3185960",
    "end": "3193220"
  },
  {
    "text": "into the parser if there's are going to be a common place in the file where there's usually an error or way is obvious or you expect that something",
    "start": "3193220",
    "end": "3199370"
  },
  {
    "text": "could go wrong you can put something in there to catch it directly so a good",
    "start": "3199370",
    "end": "3204560"
  },
  {
    "text": "example is an empty block so if something which has got a left and right brace character and you know it's going to be empty you also know that",
    "start": "3204560",
    "end": "3211250"
  },
  {
    "text": "somebody's going to put something in there because that's what people do so you kind of code something in you you actually put in a rule there to say",
    "start": "3211250",
    "end": "3217490"
  },
  {
    "text": "match me something but if you do match anything make it an error you know it's just kind of that's like this I think",
    "start": "3217490",
    "end": "3224920"
  },
  {
    "text": "fine I'll deal with it so um just start",
    "start": "3224920",
    "end": "3230120"
  },
  {
    "start": "3226000",
    "end": "3281000"
  },
  {
    "text": "to wrap up now then really there are a couple of other things which are pertinent only really so to an IDE which",
    "start": "3230120",
    "end": "3237140"
  },
  {
    "text": "are also very interesting though incremental lexing and parsing and the idea of this is really that you don't",
    "start": "3237140",
    "end": "3242780"
  },
  {
    "text": "want to parse the whole file on every change so field a nice big file and you hit one character you don't have to repass the entire file relax the entire",
    "start": "3242780",
    "end": "3249680"
  },
  {
    "text": "file so anyone who just repass the subsets the smallest subset that encloses the change you also want to",
    "start": "3249680",
    "end": "3256490"
  },
  {
    "text": "avoid relaxing it as well and that's actually easier than it sounds you just go walk up to find a block the stealing",
    "start": "3256490",
    "end": "3263510"
  },
  {
    "text": "there you've already you you have to cache the lecture output first of all but you've already got that information and you know how to parse and you just",
    "start": "3263510",
    "end": "3269990"
  },
  {
    "text": "start parsing from that point on until you've finished you close the block and basically resync everything up and",
    "start": "3269990",
    "end": "3275300"
  },
  {
    "text": "you're carrying out it's a surprisingly sort of straightforward mechanical process and the other problem then is",
    "start": "3275300",
    "end": "3283970"
  },
  {
    "start": "3281000",
    "end": "3386000"
  },
  {
    "text": "composable languages and there's there's several ones of these that can have things like injected languages so that's",
    "start": "3283970",
    "end": "3289910"
  },
  {
    "text": "like the cg program problem that shader lab has where the cg program block is a",
    "start": "3289910",
    "end": "3295820"
  },
  {
    "text": "different language again and you can solve this in a couple of ways your part you can extend your parser so it expects",
    "start": "3295820",
    "end": "3300950"
  },
  {
    "text": "that and it as effectively a whole extra set of rules embedded in it to deal with that or you can have support for that too so",
    "start": "3300950",
    "end": "3310370"
  },
  {
    "text": "the ID for example can have support for that saying okay well I'm gonna treat this as a separate file and you have",
    "start": "3310370",
    "end": "3315650"
  },
  {
    "text": "just a different person or a different thing treated as a separate file you can",
    "start": "3315650",
    "end": "3320690"
  },
  {
    "text": "have things like inherited languages so typescript is a superset of JavaScript for example so when you're typing when",
    "start": "3320690",
    "end": "3328190"
  },
  {
    "text": "you're parsing your JavaScript sorry your typescript files that's what can also work with valid",
    "start": "3328190",
    "end": "3333400"
  },
  {
    "text": "together right around when you're pausing a type script file that can also be valid JavaScript and the way you can",
    "start": "3333400",
    "end": "3339140"
  },
  {
    "text": "do that then is it's useful if you are using a hand-rolled parser or a a",
    "start": "3339140",
    "end": "3345849"
  },
  {
    "text": "mechanically pies are generated top-down recursive one where you can override",
    "start": "3347170",
    "end": "3352580"
  },
  {
    "text": "certain parts of it so you can extend the parser class just like you'll extend any old cut any kind of class and then",
    "start": "3352580",
    "end": "3359780"
  },
  {
    "text": "the other ones would be interesting are nested languages things like JavaScript or CSS nested inside HTML or raised or",
    "start": "3359780",
    "end": "3366500"
  },
  {
    "text": "in c-sharp and you can sort of switching from that and that one again you kind of have some sort of inheritance type thing",
    "start": "3366500",
    "end": "3372800"
  },
  {
    "text": "going on or a mode switching which can sort of multiplex as it were between the two razor and c-sharp is a particularly",
    "start": "3372800",
    "end": "3379970"
  },
  {
    "text": "interesting one because they can be embedded in certain inside themselves several times which gets messy so to sum",
    "start": "3379970",
    "end": "3389090"
  },
  {
    "start": "3386000",
    "end": "3523000"
  },
  {
    "text": "up then how do you par as a file don't just just just avoid it please",
    "start": "3389090",
    "end": "3394340"
  },
  {
    "text": "it's not worth it stick tej so it's a xml six of CSS six the am will stick to a general-purpose",
    "start": "3394340",
    "end": "3399740"
  },
  {
    "text": "language but there but if you do there's a lots of fun there's lots of interesting things you can do with it so",
    "start": "3399740",
    "end": "3405110"
  },
  {
    "text": "finally some some links then if you want to see what's going on with the shader lab file it's all open source it's and",
    "start": "3405110",
    "end": "3410930"
  },
  {
    "text": "resharper unity github page on JetBrains account and then a couple of links there",
    "start": "3410930",
    "end": "3417590"
  },
  {
    "text": "which are pretty much the only things I could find on error recovery for for pauses which is you know considering the",
    "start": "3417590",
    "end": "3424760"
  },
  {
    "text": "size the internet three or four articles is is a pretty impressive and that brings me to the end and really so if",
    "start": "3424760",
    "end": "3431540"
  },
  {
    "text": "anybody has any questions please let me know otherwise thank you very much for attending we have a question yes I'm",
    "start": "3431540",
    "end": "3447940"
  },
  {
    "text": "sorry miss that yeah so the question is",
    "start": "3447940",
    "end": "3453280"
  },
  {
    "text": "if the tokens are integer values how do you get to the contents of the token and",
    "start": "3453280",
    "end": "3458530"
  },
  {
    "text": "that's actually a when the the stream of I kind of lied to it when I said it's a",
    "start": "3458530",
    "end": "3463630"
  },
  {
    "text": "stream of tokens it's a stream of tokens plus offsets plus well tokens plus offsets and given the offset you can",
    "start": "3463630",
    "end": "3469840"
  },
  {
    "text": "then get the text there so yes somebody else have a question yes yes so the",
    "start": "3469840",
    "end": "3490090"
  },
  {
    "text": "question is that some of the things are recognizing things based on where they are with the neighbors so Z that is not",
    "start": "3490090",
    "end": "3497230"
  },
  {
    "text": "far removed from convolutional neural nets the my answer is I have no idea I don't",
    "start": "3497230",
    "end": "3505120"
  },
  {
    "text": "know but that'll be cool you know artificial intelligence file pausing that's cool",
    "start": "3505120",
    "end": "3511740"
  },
  {
    "text": "you know there desi PhD right there tell you it's anyone else nope",
    "start": "3512040",
    "end": "3519640"
  },
  {
    "text": "cool very good thank you very much",
    "start": "3519640",
    "end": "3522869"
  }
]