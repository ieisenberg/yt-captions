[
  {
    "start": "0",
    "end": "120000"
  },
  {
    "text": "um hello everybody thank you all for coming um it's been a while since we've done this sort of thing in person and",
    "start": "7520",
    "end": "13120"
  },
  {
    "text": "i've forgotten how scary it is to stand up on here seeing so many people there so um yeah it's i'm more used to doing this in",
    "start": "13120",
    "end": "19520"
  },
  {
    "text": "an empty room uh so if any of you want to leave now now is your chance",
    "start": "19520",
    "end": "24880"
  },
  {
    "text": "um uh so anyway hello my name is matt uh and i'm gonna be talking about pattern matching um in c-sharp uh we'll have a",
    "start": "24880",
    "end": "32078"
  },
  {
    "text": "bit of an overview have a look at it see what it's about see what's going on uh and see if we like it or not",
    "start": "32079",
    "end": "38000"
  },
  {
    "text": "and um just to clarify we're talking about pattern matching here we're not talking about design patterns",
    "start": "38000",
    "end": "43840"
  },
  {
    "text": "and we're not talking about uh pattern recognition and sort of uh",
    "start": "43840",
    "end": "48960"
  },
  {
    "text": "regular expressions and that kind of thing so we are talking instead about pattern matching",
    "start": "48960",
    "end": "54640"
  },
  {
    "text": "if you haven't come across it before pattern matching is uh well funnily enough there's no sort of",
    "start": "54640",
    "end": "60559"
  },
  {
    "text": "authority to cite on what pattern matching actually is you know you can't go to wikipedia and say this is the definition of pattern matching",
    "start": "60559",
    "end": "67280"
  },
  {
    "text": "and so you kind of have all these languages that implement pattern matching but not too a specific sort of spec so",
    "start": "67280",
    "end": "72960"
  },
  {
    "text": "they just implement the pattern of pattern matching which is quite nice i like that but anyway what pattern matching is",
    "start": "72960",
    "end": "79040"
  },
  {
    "text": "it's a means of testing a value to make sure that it matches a specific shape",
    "start": "79040",
    "end": "84479"
  },
  {
    "text": "and then it optionally optionally extracts information from that a specific shape is a kind of a weird",
    "start": "84479",
    "end": "90159"
  },
  {
    "text": "sort of thing to say about a value but the what i mean there really is that it matches certain conditions and certain",
    "start": "90159",
    "end": "96079"
  },
  {
    "text": "characteristics and so these can be very sort of simple things like a value is 42 or be something a bit more complex",
    "start": "96079",
    "end": "103600"
  },
  {
    "text": "that it is a person object with a name with a specific name and an age which is greater than 18 and so on",
    "start": "103600",
    "end": "110079"
  },
  {
    "text": "but one of the key characteristics of pattern matching is the ability to not just match complex",
    "start": "110079",
    "end": "116560"
  },
  {
    "text": "characteristics but also to extract information and use that later before we dive into c sharp though let's",
    "start": "116560",
    "end": "123280"
  },
  {
    "start": "120000",
    "end": "404000"
  },
  {
    "text": "have a look at what it looks like in some other languages there pattern matching is used all over the place lots of different languages it's been around",
    "start": "123280",
    "end": "129360"
  },
  {
    "text": "for a very long time longer even than me and if you have a quick search on wikipedia one of the things that pops up",
    "start": "129360",
    "end": "134720"
  },
  {
    "text": "is snowball from the 1960s i have no idea what snowball is but apparently it has pattern matching so",
    "start": "134720",
    "end": "141440"
  },
  {
    "text": "well done snowball um it's also very popular in functional programming languages i bet everybody's",
    "start": "141440",
    "end": "147040"
  },
  {
    "text": "probably heard of it from um functional languages such as f sharp and ocamel and haskell and so on but it's",
    "start": "147040",
    "end": "153200"
  },
  {
    "text": "also used in various procedural languages as well so swift and scala have both got it uh java",
    "start": "153200",
    "end": "159040"
  },
  {
    "text": "is starting to get it um they are sort of following the c sharp roots it's looking very similar so far to what we've got in c sharp uh interestingly",
    "start": "159040",
    "end": "166640"
  },
  {
    "text": "talking of java kotlin doesn't have it and um there are conversations about it but",
    "start": "166640",
    "end": "172239"
  },
  {
    "text": "right now there's no sort of real movement on that kotlin has something different such as smart casts which are testing",
    "start": "172239",
    "end": "179840"
  },
  {
    "text": "for testing an instance testing a value is of a particular type",
    "start": "179840",
    "end": "186000"
  },
  {
    "text": "uh and then using it like that type so i can say if x is a person then use x like",
    "start": "186000",
    "end": "191200"
  },
  {
    "text": "it's a person so you've got some sort of flow typing there which is good and colin's also got a very powerful sort of wen expression which is uh",
    "start": "191200",
    "end": "198720"
  },
  {
    "text": "kind of gets rid of some of the need then to have some pattern matching features in there but even crazier even c plus is getting",
    "start": "198720",
    "end": "205680"
  },
  {
    "text": "it too there's a proposal being worked on and uh going through there",
    "start": "205680",
    "end": "212000"
  },
  {
    "text": "so um has anyone tried f sharp and pan matching f sharp a couple right i'm going to scare you",
    "start": "212000",
    "end": "217360"
  },
  {
    "text": "with some f sharp now then um this is quite an interesting sort of quite a thorough example i'm not going to dive",
    "start": "217360",
    "end": "223760"
  },
  {
    "text": "too much deeply into it but to quickly talk you through it on the left there we've got a type and this is a shape and",
    "start": "223760",
    "end": "229760"
  },
  {
    "text": "this is a discriminated union if you're not familiar with f sharp that's essentially like an enum with data so",
    "start": "229760",
    "end": "235760"
  },
  {
    "text": "we've got a shape here which can either be a rectangle or an ellipse if it's a rectangle it's got a position and a size",
    "start": "235760",
    "end": "242080"
  },
  {
    "text": "and if it's an ellipse it's got a position and a minimax radius or it could also be a composed shape",
    "start": "242080",
    "end": "248319"
  },
  {
    "text": "which is a shape made up of two two other shapes so it could be a shape with two rectangles",
    "start": "248319",
    "end": "254560"
  },
  {
    "text": "on the right we've got a function which is going to calculate the area of our shape and we've got this match uh keyword here",
    "start": "254560",
    "end": "261919"
  },
  {
    "text": "which is kind of like this the switch keyword in c sharp we're going to match on shape but it's going to do pattern",
    "start": "261919",
    "end": "267600"
  },
  {
    "text": "matching for us and we've got several uh actual patterns in there first one is a",
    "start": "267600",
    "end": "272880"
  },
  {
    "text": "rectangle and i'm going to ignore the i've got an underscore there to ignore the position and i've got the width and",
    "start": "272880",
    "end": "279360"
  },
  {
    "text": "height there i'm decomposing the size into width and height i can very quickly then multiply them together get the area",
    "start": "279360",
    "end": "286080"
  },
  {
    "text": "ellipse is very simple similar too i match on ellipse i ignore the position i got my min and max radiuses and i can",
    "start": "286080",
    "end": "292880"
  },
  {
    "text": "work with that things get a bit more fun with composed if we jump down to the bottom one we've",
    "start": "292880",
    "end": "298080"
  },
  {
    "text": "got a composed of two shapes uh i recursively call the area function there",
    "start": "298080",
    "end": "303199"
  },
  {
    "text": "to get the area of those two shapes and add them together and get rid of do some hand waving to get",
    "start": "303199",
    "end": "308800"
  },
  {
    "text": "rid of some intersecting area there as well where things get more powerful",
    "start": "308800",
    "end": "314720"
  },
  {
    "text": "is the sort of the the first composed option there and we have to order them like this as well because patterns are",
    "start": "314720",
    "end": "320560"
  },
  {
    "text": "evaluated in order but this first composed item here is going to match two rectangles and it's",
    "start": "320560",
    "end": "326800"
  },
  {
    "text": "got a condition there to say when uh one rectang rectangle is a nested rectangle",
    "start": "326800",
    "end": "331840"
  },
  {
    "text": "if one rectangle lives completely inside another rectangle they can i can optimize this and just return the width",
    "start": "331840",
    "end": "337840"
  },
  {
    "text": "and height of the owning rectangle there so it allows me to sort of match on this shape here i've",
    "start": "337840",
    "end": "343120"
  },
  {
    "text": "got a composed uh shape which is made up of two rectangles one",
    "start": "343120",
    "end": "348800"
  },
  {
    "text": "which lives inside the other i can very concisely write that down",
    "start": "348800",
    "end": "355039"
  },
  {
    "text": "but it's not just about sort of matching a pattern to do a thing like that something like haskell can take",
    "start": "355440",
    "end": "362000"
  },
  {
    "text": "this and use pattern matching when declaring functions as well so if we're in haskell we can actually declare a",
    "start": "362000",
    "end": "367600"
  },
  {
    "text": "factorial function and we can declare it with two",
    "start": "367600",
    "end": "372720"
  },
  {
    "text": "actual method instances we have one where the parameter is zero and we can just return one and then we",
    "start": "372720",
    "end": "379680"
  },
  {
    "text": "have another method declaration which has a pattern of n and n is just going to match",
    "start": "379680",
    "end": "385440"
  },
  {
    "text": "anything there and it's going to bind the value that we have passed in there to the name n and we can",
    "start": "385440",
    "end": "391199"
  },
  {
    "text": "use that n inside the definition of the method itself there so it's very interesting",
    "start": "391199",
    "end": "396560"
  },
  {
    "text": "you can do pattern matching for different things here you can use it for uh working with data like that or",
    "start": "396560",
    "end": "402080"
  },
  {
    "text": "actually choosing which method to call now you can relax we're not going to do any more functional languages we're",
    "start": "402080",
    "end": "408160"
  },
  {
    "start": "404000",
    "end": "417000"
  },
  {
    "text": "gonna get back to some c sharp here and what do patterns look like in c sharp that's one",
    "start": "408160",
    "end": "415360"
  },
  {
    "text": "oh okay uh how about that one no uh this one all right so that's kind",
    "start": "415360",
    "end": "420720"
  },
  {
    "start": "417000",
    "end": "597000"
  },
  {
    "text": "of the wrong question to ask really so we're not really going to say what our patterns here the better thing to do is",
    "start": "420720",
    "end": "425759"
  },
  {
    "text": "back up a little bit first and say where can we use patterns because we can't just sort of have a pattern there we",
    "start": "425759",
    "end": "430880"
  },
  {
    "text": "need to be able to use them and in c-sharp we've got three places we can use it we can use it in an is expression",
    "start": "430880",
    "end": "437440"
  },
  {
    "text": "which we should all probably be familiar with if statements there if x is person we're testing to see whether it's a",
    "start": "437440",
    "end": "443120"
  },
  {
    "text": "person and if it is then we're going to assign that value to the person variable",
    "start": "443120",
    "end": "448800"
  },
  {
    "text": "which is going to be of type person we can also use it in the switch statement case labels so uh exactly the",
    "start": "448800",
    "end": "455039"
  },
  {
    "text": "same thing there switching on x case person so if it's a type person and",
    "start": "455039",
    "end": "461520"
  },
  {
    "text": "we can assign it to the person variable and do something we can also use it in the uh in a switch",
    "start": "461520",
    "end": "467360"
  },
  {
    "text": "expression has anyone come across a switch expression this was in c sharp eights right few of you",
    "start": "467360",
    "end": "473199"
  },
  {
    "text": "this is a new bit of syntax there for using switch statements well using switches as an expression rather than as",
    "start": "473199",
    "end": "479680"
  },
  {
    "text": "a statement and as a bit of a reminder here then an expression is something that has a value",
    "start": "479680",
    "end": "485039"
  },
  {
    "text": "while a statement doesn't so an expression is going to be anything it could be like a method call which",
    "start": "485039",
    "end": "490639"
  },
  {
    "text": "returns you back a value you know getage is going to return me back a value of uh integer",
    "start": "490639",
    "end": "496800"
  },
  {
    "text": "or well as a statement doesn't have any value there so an if is a statement because you can't assign it to anything",
    "start": "496800",
    "end": "503120"
  },
  {
    "text": "it's uh completely by itself so um with our switch expression there",
    "start": "503120",
    "end": "509280"
  },
  {
    "text": "we can actually see that it's being called x um it's in in an in fix fashion so we've",
    "start": "509280",
    "end": "515279"
  },
  {
    "text": "got the the expression we're trying to work with x and switch and then we can do uh some work with that and then the",
    "start": "515279",
    "end": "522159"
  },
  {
    "text": "return value of that is being assigned to something and if you look at the types of these different expressions",
    "start": "522159",
    "end": "528080"
  },
  {
    "text": "an is expression is a boolean and that's why we tend to use them in if statements there so if x is person true or false",
    "start": "528080",
    "end": "534480"
  },
  {
    "text": "and we use it there um switch statement that's a statement it doesn't have a value so there's no type and the switch",
    "start": "534480",
    "end": "541200"
  },
  {
    "text": "expression i'm assigning that to a variable y and the return sorry the type",
    "start": "541200",
    "end": "546320"
  },
  {
    "text": "of variable y is the return type of the arms that are in the uh",
    "start": "546320",
    "end": "552080"
  },
  {
    "text": "in the switch there here i'm calling a method called get value and that's going to return me back an int in this case and so the the type",
    "start": "552080",
    "end": "559680"
  },
  {
    "text": "of my switch expression is an int and speaking of history there um switch",
    "start": "559680",
    "end": "566240"
  },
  {
    "text": "expressions there c sharp eight uh it's uh pattern matching has been around with us for a little while now",
    "start": "566240",
    "end": "572640"
  },
  {
    "text": "actually uh i was a bit surprised when i was looking at this i kind of was under the impression that pattern matching was",
    "start": "572640",
    "end": "578240"
  },
  {
    "text": "a c 10 thing turns out it's not it started in c sharp seven uh we got a few things in there the um",
    "start": "578240",
    "end": "585680"
  },
  {
    "text": "not terribly exciting for that but then things really got going with c sharp eight and nine and we've got some more interesting uh",
    "start": "585680",
    "end": "592399"
  },
  {
    "text": "features in c sharp eight and nine and c sharp ten is actually just a little tweak more than anything",
    "start": "592399",
    "end": "598240"
  },
  {
    "start": "597000",
    "end": "892000"
  },
  {
    "text": "right patterns let's have a better look at some patterns here",
    "start": "598240",
    "end": "603519"
  },
  {
    "text": "i'm going to start with a couple of things that you're probably going to find familiar this one is a type pattern i was",
    "start": "603519",
    "end": "608640"
  },
  {
    "text": "introduced in c sharp knight but it looks very familiar if x is person that's just going to be checking the",
    "start": "608640",
    "end": "613839"
  },
  {
    "text": "type of x to see whether it is a person excuse me",
    "start": "613839",
    "end": "620000"
  },
  {
    "text": "and it's going to check to see whether x at runtime is a person derives from person implements an interface which",
    "start": "620000",
    "end": "626000"
  },
  {
    "text": "might be called person uh or it'll also do things like implicit conversions and boxing and so on",
    "start": "626000",
    "end": "632880"
  },
  {
    "text": "now this does look a little bit familiar this has been around since c sharp 1 but in c sharp 9 they introduced a type",
    "start": "632880",
    "end": "638320"
  },
  {
    "text": "pattern which effectively changes how the is operator works and so instead of it",
    "start": "638320",
    "end": "644079"
  },
  {
    "text": "being this type of an actual type expression",
    "start": "644079",
    "end": "649440"
  },
  {
    "text": "and a type check it is now a pattern check and x is person is a is now a type pattern so it kind of",
    "start": "649440",
    "end": "655519"
  },
  {
    "text": "retcons this and retroactively makes that into a pattern statement but this particular",
    "start": "655519",
    "end": "661760"
  },
  {
    "text": "syntax only tests for a type it requires casting before use and so",
    "start": "661760",
    "end": "667920"
  },
  {
    "text": "for that we need to use a declaration pattern and again i'm sure people are very familiar with this one if x is",
    "start": "667920",
    "end": "673200"
  },
  {
    "text": "person then assign it to a very a new variable called person this tests the the runtime type again if",
    "start": "673200",
    "end": "679920"
  },
  {
    "text": "it's um the value is null then it doesn't match and so it would get false in this you wouldn't go",
    "start": "679920",
    "end": "685839"
  },
  {
    "text": "into the if statement and one of the interesting things with this is that it controls the scope of the variable",
    "start": "685839",
    "end": "692640"
  },
  {
    "text": "assignment so the person variable is still defined outside of the if statement",
    "start": "692640",
    "end": "698560"
  },
  {
    "text": "however it's only assigned inside the if statement if it's true",
    "start": "698560",
    "end": "704079"
  },
  {
    "text": "so if x's person is true then person only has a value once you're inside the if block",
    "start": "704079",
    "end": "710480"
  },
  {
    "text": "the other thing to point out here as well is this got really ugly syntax for negation if you want to say if it's not",
    "start": "710480",
    "end": "715839"
  },
  {
    "text": "a person you've got to do this not brackets and all that kind of stuff and we've got some dots on the is there to",
    "start": "715839",
    "end": "720880"
  },
  {
    "text": "kind of tell us there's a better way of doing it now which is nice we'll get on to that",
    "start": "720880",
    "end": "727200"
  },
  {
    "text": "another nice simple one we've got here is a constant pattern you can just check to see whether a variable is a",
    "start": "727680",
    "end": "733519"
  },
  {
    "text": "particular constant so if i is 42 it's an integer it's got the value 42.",
    "start": "733519",
    "end": "738880"
  },
  {
    "text": "if s is a string and says hello world we're good and so those are very simple equality checks",
    "start": "738880",
    "end": "744639"
  },
  {
    "text": "and it's not um you can only really work with constants here so you can't compare against a variable you can only compare",
    "start": "744639",
    "end": "750320"
  },
  {
    "text": "against a constant but you can compare against other constants defined in fields so you can",
    "start": "750320",
    "end": "756320"
  },
  {
    "text": "use int dot max value or you can use you know my my max count or whatever",
    "start": "756320",
    "end": "763440"
  },
  {
    "text": "we can also use null here as well so we've got yet another way of uh checking for null i think c sharp is probably",
    "start": "763440",
    "end": "769440"
  },
  {
    "text": "about 10 different ways of checking for null or not null so it's uh take your pick",
    "start": "769440",
    "end": "774959"
  },
  {
    "text": "and of course i'm using is as an example here same with the type tests we've got",
    "start": "774959",
    "end": "780399"
  },
  {
    "text": "before as well but you can also use them in switch statements and switch expressions so you can have a switch",
    "start": "780399",
    "end": "787279"
  },
  {
    "text": "statement with these constants as part of the case labels or you can",
    "start": "787279",
    "end": "792639"
  },
  {
    "text": "have them in the expression there and it's going to return back a specific value based on the match on the constant",
    "start": "792639",
    "end": "798720"
  },
  {
    "text": "you might notice that the switch statement has gone underscore as the last item",
    "start": "798720",
    "end": "804399"
  },
  {
    "text": "this is a discard pattern and this is going to match anything and",
    "start": "804399",
    "end": "809760"
  },
  {
    "text": "then throw it away so it ignores it this is because the switch expression does not have a default case like the",
    "start": "809760",
    "end": "816480"
  },
  {
    "text": "switch statement does and so you've got to um you've got to have another pattern there",
    "start": "816480",
    "end": "822399"
  },
  {
    "text": "which is going to match anything and finish up and match make make sure that your switch",
    "start": "822399",
    "end": "827519"
  },
  {
    "text": "expression is is exhaustive it matches everything if you don't have something",
    "start": "827519",
    "end": "832880"
  },
  {
    "text": "uh being matched there you could end up with an expression that doesn't return a value and then that's not an expression then it's all weird and we don't want",
    "start": "832880",
    "end": "840000"
  },
  {
    "text": "weird i don't think um the other the other important point with",
    "start": "840000",
    "end": "845680"
  },
  {
    "text": "the discard pattern though is it means that order is important here so if we've got a switch switch expression",
    "start": "845680",
    "end": "851839"
  },
  {
    "text": "the order in which we evaluate those patterns is important if i put that discard right at the top it's going to immediately match and it's",
    "start": "851839",
    "end": "858000"
  },
  {
    "text": "not going to check any of the other patterns there either and so order is now important inside a",
    "start": "858000",
    "end": "864480"
  },
  {
    "text": "switch statement and also inside a switch case then we always say the wrong way around",
    "start": "864480",
    "end": "871120"
  },
  {
    "text": "it's important inside a switch expression as shown here but it's also important inside a switch statement in",
    "start": "871120",
    "end": "876560"
  },
  {
    "text": "the case labels as well whereas previously switched statements order wasn't important",
    "start": "876560",
    "end": "882959"
  },
  {
    "text": "so um the underscore there as well is going to be familiar from things like lambda parameters and deconstructing",
    "start": "882959",
    "end": "888480"
  },
  {
    "text": "variables where you might want to ignore the value it's the same sort of thing we're using it again",
    "start": "888480",
    "end": "894240"
  },
  {
    "start": "892000",
    "end": "1067000"
  },
  {
    "text": "so you're looking at this now and it's like great we can compare against equality against a constant i can check",
    "start": "894240",
    "end": "899920"
  },
  {
    "text": "something is a type a type or a an empty value or anything is that",
    "start": "899920",
    "end": "905120"
  },
  {
    "text": "really anything better than an if and right now i would say no we're probably not there or anything so we probably",
    "start": "905120",
    "end": "910800"
  },
  {
    "text": "want to have a look at something a little more interesting and start to use some more uh complex",
    "start": "910800",
    "end": "917519"
  },
  {
    "text": "patterns uh the first one i'm going to look at though is a property pattern this was introduced in c sharp eight this is",
    "start": "917519",
    "end": "922639"
  },
  {
    "text": "where things started to get a bit more interesting and this can match a field or property",
    "start": "922639",
    "end": "928240"
  },
  {
    "text": "of an object and we can optionally match the type as well so here i'm saying if o is a person",
    "start": "928240",
    "end": "935360"
  },
  {
    "text": "then match the name property and see if the name property is mat if so store that in the person variable",
    "start": "935360",
    "end": "943519"
  },
  {
    "text": "we can optionally match the type if i was already a person that would that type there would be um",
    "start": "943519",
    "end": "949370"
  },
  {
    "text": "[Music] unnecessary and we also don't need to assign it to a type there as well so we can just have",
    "start": "949370",
    "end": "955040"
  },
  {
    "text": "it where it's just matching the the properties uh or we can have it doing everything there we can also match",
    "start": "955040",
    "end": "960560"
  },
  {
    "text": "one or more properties um or fields there so we can have something which is a bit",
    "start": "960560",
    "end": "966079"
  },
  {
    "text": "more complex so i could match the first name is matt second name is ellis and so on",
    "start": "966079",
    "end": "973120"
  },
  {
    "text": "what's interesting here is yet another way to check null well not null if you have no properties",
    "start": "973519",
    "end": "979600"
  },
  {
    "text": "listed in your property pattern there then it's just going to match anything that is not null so we have yet another",
    "start": "979600",
    "end": "985600"
  },
  {
    "text": "way of saying is this value not null however that's getting a bit funky that syntax there so",
    "start": "985600",
    "end": "993120"
  },
  {
    "text": "i don't like it um we've also got a var pattern um this matches anything and assigns it to a new",
    "start": "993120",
    "end": "1000240"
  },
  {
    "text": "variable which is kind of frankly a little bit weird this is always going to match fx",
    "start": "1000240",
    "end": "1005440"
  },
  {
    "text": "is var y yes it is and now we've got y and it's like okay",
    "start": "1005440",
    "end": "1010639"
  },
  {
    "text": "thanks thanks c sharp why um and the reason for this is that it's",
    "start": "1010639",
    "end": "1016399"
  },
  {
    "text": "um it's actually useful for uh working inside an expression so we can have something a much longer expression",
    "start": "1016399",
    "end": "1023600"
  },
  {
    "text": "and pulling value out from say the results of a of a method call and then using that to be able to test the",
    "start": "1023600",
    "end": "1029918"
  },
  {
    "text": "results there so if i've got you know get value store that into a temporary variable i can say is valid value and is",
    "start": "1029919",
    "end": "1036079"
  },
  {
    "text": "greater than anything value and is this then do something",
    "start": "1036079",
    "end": "1041520"
  },
  {
    "text": "so it's useful to be able to pull that out uh it can be used to match multiple values as well so i could uh use it to",
    "start": "1041520",
    "end": "1048240"
  },
  {
    "text": "match x and y so it can deconstruct stuff for me and we've also got a discard case here",
    "start": "1048240",
    "end": "1053600"
  },
  {
    "text": "as well so var underscore will match anything and ignore it which is",
    "start": "1053600",
    "end": "1058799"
  },
  {
    "text": "i still don't really know a use case for that one to be perfectly honest but um you can match anything and then throw it away",
    "start": "1058799",
    "end": "1064880"
  },
  {
    "text": "but where this is really useful is with recursive patterns and recursive patterns is where we're",
    "start": "1064880",
    "end": "1070000"
  },
  {
    "start": "1067000",
    "end": "1460000"
  },
  {
    "text": "really starting to put things together and get some power out of this and",
    "start": "1070000",
    "end": "1075760"
  },
  {
    "text": "when we're talking about the property uh pattern i kind of just didn't really explain this one properly",
    "start": "1075760",
    "end": "1082080"
  },
  {
    "text": "um i said that we're going to match the name um what's the name property to see uh",
    "start": "1082080",
    "end": "1088960"
  },
  {
    "text": "whether it's equal to mat or not but the way you do that is fairly obvious you do it with a pattern and",
    "start": "1088960",
    "end": "1094960"
  },
  {
    "text": "here this is just a constant pattern so i'm using the constant pattern mats to match it against my actual property you",
    "start": "1094960",
    "end": "1100960"
  },
  {
    "text": "can get a bit more interesting and do things a little more deeper here and have a proper sort of recursive pattern",
    "start": "1100960",
    "end": "1107520"
  },
  {
    "text": "and you can match that a property has then itself got complex properties so",
    "start": "1107520",
    "end": "1113200"
  },
  {
    "text": "let's say our name uh property here is actually a complex type it's got two separate fields two",
    "start": "1113200",
    "end": "1119679"
  },
  {
    "text": "separate properties for first name and surname and here i can match that and i can actually now say",
    "start": "1119679",
    "end": "1125919"
  },
  {
    "text": "that my person has a name property and that name property has a first",
    "start": "1125919",
    "end": "1131679"
  },
  {
    "text": "name on it and that first name has a constant pattern which is mat so i'm starting to sort of nest these here but",
    "start": "1131679",
    "end": "1137200"
  },
  {
    "text": "you can now see that we're doing something a bit more powerful and uh we're describing a much more",
    "start": "1137200",
    "end": "1142880"
  },
  {
    "text": "complex shape that we want to match but that is a syntax that only a mother",
    "start": "1142880",
    "end": "1148480"
  },
  {
    "text": "can love really isn't it it's it's it's what it is there's not a huge amount we can do with it uh c-sharp",
    "start": "1148480",
    "end": "1155440"
  },
  {
    "text": "10 the little tweak that it did introduce some sort of uh um",
    "start": "1155440",
    "end": "1160480"
  },
  {
    "text": "extended proper property syntax there so we can do name.first which makes it a little cleaner however these can still",
    "start": "1160480",
    "end": "1166880"
  },
  {
    "text": "get a bit clunky and a bit uh awkward but it's what we've got",
    "start": "1166880",
    "end": "1172240"
  },
  {
    "text": "now that var pattern this is where things start to get again more interesting because we can actually use that as one",
    "start": "1172240",
    "end": "1178080"
  },
  {
    "text": "of our recursive patterns and where we've got matching a constant pattern on the first",
    "start": "1178080",
    "end": "1184000"
  },
  {
    "text": "name i've now got a var pattern on the second name so what this is going to do is it's going to say get me any person",
    "start": "1184000",
    "end": "1190559"
  },
  {
    "text": "that has matt as the first name uh save that as the variable person",
    "start": "1190559",
    "end": "1196320"
  },
  {
    "text": "but we're using the var pattern to capture the surname so inside my if statement i can now use the surname",
    "start": "1196320",
    "end": "1203840"
  },
  {
    "text": "does that make sense cool i just could have scanned the whole",
    "start": "1203840",
    "end": "1209520"
  },
  {
    "text": "room to see um so you can start to do more uh fun things with this now so it's starting to",
    "start": "1209520",
    "end": "1216559"
  },
  {
    "text": "get more powerful so i can match something with a more complex shape and i can pull data out of that shape inside",
    "start": "1216559",
    "end": "1222880"
  },
  {
    "text": "the nested pieces i can pull data out and use that somewhere else so now we're starting to see well this isn't just",
    "start": "1222880",
    "end": "1229840"
  },
  {
    "text": "simple if statements doing this with an if statement you can't you're going to have to have nested things going on here you're going",
    "start": "1229840",
    "end": "1235840"
  },
  {
    "text": "to have to have uh you know check to see if it's a person check with the first name of",
    "start": "1235840",
    "end": "1241039"
  },
  {
    "text": "mats then assign that to a new variable and then check to see what we want to do with",
    "start": "1241039",
    "end": "1246480"
  },
  {
    "text": "that all right couple more patterns to rattle through and then we'll have a look at something",
    "start": "1246480",
    "end": "1252799"
  },
  {
    "text": "a bit more fun for time",
    "start": "1252799",
    "end": "1257919"
  },
  {
    "text": "because we can work with sort of recursive patterns patterns that use patterns then we've got the scope to be",
    "start": "1258559",
    "end": "1264240"
  },
  {
    "text": "able to do something a little more interesting and we can have logical patterns so and or",
    "start": "1264240",
    "end": "1271760"
  },
  {
    "text": "and not and we can have a not pattern which says this pattern does not match and this is",
    "start": "1271760",
    "end": "1278799"
  },
  {
    "text": "a nicer way of doing not null or is not person so remember when we had our type",
    "start": "1278799",
    "end": "1284240"
  },
  {
    "text": "pattern there we had exclamation mark brackets x's person and it's kind of ugly well now i can just do x is not",
    "start": "1284240",
    "end": "1290720"
  },
  {
    "text": "person and it's much cleaner much nicer and it actually reads sensibly as well",
    "start": "1290720",
    "end": "1297200"
  },
  {
    "text": "we can apply that to our constant pattern and we've got another way of checking for null",
    "start": "1297200",
    "end": "1302880"
  },
  {
    "text": "or not null there and we can uh evaluate that and we've got the and and or in there as",
    "start": "1302880",
    "end": "1309600"
  },
  {
    "text": "well so i can check on multiple things i can check to see if my integer value there if it's a value of 42 or it's a",
    "start": "1309600",
    "end": "1316400"
  },
  {
    "text": "value of 100 and act appropriately now this is you know i could do this with i",
    "start": "1316400",
    "end": "1321679"
  },
  {
    "text": "equals 42 or i equals 100 but the",
    "start": "1321679",
    "end": "1326880"
  },
  {
    "text": "benefit of doing it with a pattern like this is i only need to do the expression once so if i was a",
    "start": "1326880",
    "end": "1332400"
  },
  {
    "text": "calculation if i was doing uh get expensive calculation equals 42",
    "start": "1332400",
    "end": "1339039"
  },
  {
    "text": "i'd either have to introduce a temporary variable outside of my if uh well that's what i can do",
    "start": "1339039",
    "end": "1344840"
  },
  {
    "text": "really whereas what i can do here is i can use the expression just once",
    "start": "1344840",
    "end": "1350320"
  },
  {
    "text": "and then apply multiple patterns to that to that one value",
    "start": "1350320",
    "end": "1356840"
  },
  {
    "text": "and then relational patterns we've is uh another one as well and these are",
    "start": "1360159",
    "end": "1365679"
  },
  {
    "text": "quite uh similar sort of idea um we check to see whether the value is",
    "start": "1365679",
    "end": "1371200"
  },
  {
    "text": "greater than less than greater than or equal to less than or equal to a specific pattern",
    "start": "1371200",
    "end": "1377200"
  },
  {
    "text": "sorry not a specific pattern to a specific constant so these only work with constant values",
    "start": "1377200",
    "end": "1383200"
  },
  {
    "text": "so that's probably good you know it's great for this particular example it's great for various other",
    "start": "1383200",
    "end": "1389120"
  },
  {
    "text": "examples we can come up with um it's checking against uh a constant value checking against a char literal",
    "start": "1389120",
    "end": "1395360"
  },
  {
    "text": "here to see whether it's going to be a character a letter based character rather than anything else",
    "start": "1395360",
    "end": "1401600"
  },
  {
    "text": "obviously don't use this in production code because there are more letters out there um and it's great for for checking uh",
    "start": "1401600",
    "end": "1408480"
  },
  {
    "text": "ranges uh i'm working with the logical patterns the and or and not and so on",
    "start": "1408480",
    "end": "1414240"
  },
  {
    "text": "but there are probably times when you want to be able to sort of configure what those ranges are so for example if we had a relational",
    "start": "1414240",
    "end": "1421520"
  },
  {
    "text": "pattern which checked um uh whether something was within a",
    "start": "1421520",
    "end": "1426880"
  },
  {
    "text": "particular tolerance and we wanted to be able to configure that tolerance we can't do that with a pattern because the pattern only works",
    "start": "1426880",
    "end": "1432799"
  },
  {
    "text": "with constants so we would have to then sort of break out into more traditional if statements",
    "start": "1432799",
    "end": "1439520"
  },
  {
    "text": "uh yeah and again here with the uh very similar to the logical patterns there we only need to uh create the value once",
    "start": "1441200",
    "end": "1448080"
  },
  {
    "text": "and we get to reuse it but it can look a little bit weird when we just suddenly got these uh relational operators sort",
    "start": "1448080",
    "end": "1454720"
  },
  {
    "text": "of standing by themselves",
    "start": "1454720",
    "end": "1458278"
  },
  {
    "start": "1460000",
    "end": "1584000"
  },
  {
    "text": "last last pattern to look at but this one's much more fun um positional pattern it matches on",
    "start": "1461520",
    "end": "1468720"
  },
  {
    "text": "deconstructed values and so here again if we're talking about a name which is a bit more of a complex",
    "start": "1468720",
    "end": "1474720"
  },
  {
    "text": "type which has got a first name and a surname uh i want to be able to match on those and i can do that with this syntax",
    "start": "1474720",
    "end": "1480720"
  },
  {
    "text": "here so it looks like a type test again but then i'm using the brackets to",
    "start": "1480720",
    "end": "1485919"
  },
  {
    "text": "specify my positional parameters and what this will do under the covers is to invoke the deconstruct method",
    "start": "1485919",
    "end": "1493520"
  },
  {
    "text": "and matches the patterns on those results so i've got recursive patterns inside the inside the brackets there so",
    "start": "1493520",
    "end": "1498960"
  },
  {
    "text": "that matte and the ellis there those are both constant patterns which are matching recursively on the",
    "start": "1498960",
    "end": "1504720"
  },
  {
    "text": "deconstructed values this one took me a little while to get my head around this was something which i didn't like very much was initially",
    "start": "1504720",
    "end": "1511760"
  },
  {
    "text": "something which maybe not like patterns very much that and the syntax of property patterns",
    "start": "1511760",
    "end": "1518720"
  },
  {
    "text": "because this looks like a method call and i couldn't figure out well is it a method call but if it's a method call that looks",
    "start": "1518720",
    "end": "1525200"
  },
  {
    "text": "like a constructor so is that a call to the constructor or something and the answer is no it's not and that's",
    "start": "1525200",
    "end": "1532000"
  },
  {
    "text": "why i put a space in between the the name there and the the brackets it's a type check followed by then positional",
    "start": "1532000",
    "end": "1538320"
  },
  {
    "text": "parameters deconstructing and getting these values out um one thing that is quite nice with",
    "start": "1538320",
    "end": "1546080"
  },
  {
    "text": "this syntax however is that at the same time it does look a little bit like a constructor so you're kind of",
    "start": "1546080",
    "end": "1552080"
  },
  {
    "text": "saying give me a name which is uh looks like this so you can actually sort of see it's",
    "start": "1552080",
    "end": "1558159"
  },
  {
    "text": "it's almost uh the opposite of a constructor it's it's describing again the shape of the name",
    "start": "1558159",
    "end": "1564240"
  },
  {
    "text": "that i want um which is quite a nicer way of",
    "start": "1564240",
    "end": "1569840"
  },
  {
    "text": "remembering what this means here but there's no method calls going on there's no uh new instances being created uh and",
    "start": "1569840",
    "end": "1576400"
  },
  {
    "text": "so on you've got a couple more things you can do with this particular pattern you can add on property patterns at the end of",
    "start": "1576400",
    "end": "1582400"
  },
  {
    "text": "it you can assign it to a variable and it's fun um but let's back up a little bit again",
    "start": "1582400",
    "end": "1587679"
  },
  {
    "start": "1584000",
    "end": "1926000"
  },
  {
    "text": "um deconstruction has everybody used deconstruction with like tuples and things like that",
    "start": "1587679",
    "end": "1593360"
  },
  {
    "text": "right a few of you that's cool let's uh let's cover a few things there so um tuples we",
    "start": "1593360",
    "end": "1598880"
  },
  {
    "text": "can use uh tuples here and uh we can deconstruct them so",
    "start": "1598880",
    "end": "1604159"
  },
  {
    "text": "a tuple is a lightweight instance of a type called value tuple it's a struct um i forget which version of c-sharp it",
    "start": "1604159",
    "end": "1610559"
  },
  {
    "text": "was brought in two to be perfectly honest but we've got language syntax to be able to do it brackets one two three",
    "start": "1610559",
    "end": "1616640"
  },
  {
    "text": "uh that will create us a new instance of a tuple and we can assign that to t t is now of",
    "start": "1616640",
    "end": "1622159"
  },
  {
    "text": "type value tuple which is a generic type in this case with three values",
    "start": "1622159",
    "end": "1628559"
  },
  {
    "text": "we also have support in the language for deconstruction and i can use this uh bracket syntax again with a ver with a",
    "start": "1628559",
    "end": "1635760"
  },
  {
    "text": "yeah with a var keyword to deconstruct that into new variables",
    "start": "1635760",
    "end": "1641279"
  },
  {
    "text": "so i've got a variable a and a variable c and they match the first and third",
    "start": "1641279",
    "end": "1646720"
  },
  {
    "text": "items within this tuple here excuse me the second item is an underscore and",
    "start": "1646720",
    "end": "1653760"
  },
  {
    "text": "again we've seen that before that's one of our discard kind of things discard discard discard",
    "start": "1653760",
    "end": "1659200"
  },
  {
    "text": "discard right um and basically that's just saying ignore",
    "start": "1659200",
    "end": "1664399"
  },
  {
    "text": "it i don't care about the second item here i just want to use the first one and the third one and",
    "start": "1664399",
    "end": "1669840"
  },
  {
    "text": "i've deconstructed it i've put those values into the variables a and variable c now again with this syntax with the brackets",
    "start": "1669840",
    "end": "1676799"
  },
  {
    "text": "on the left hand side of the var it kind of does look like a tuple again but it's not this is deconstruction so what i end",
    "start": "1676799",
    "end": "1683440"
  },
  {
    "text": "up with is an a and a c as separate variables so there's no new instance of",
    "start": "1683440",
    "end": "1688720"
  },
  {
    "text": "a tuple being created here it's just about deconstructing",
    "start": "1688720",
    "end": "1694919"
  },
  {
    "text": "yeah i can do the same with uh user types as well so if i've got my name type which i'm creating now the new instance of",
    "start": "1696399",
    "end": "1702720"
  },
  {
    "text": "that passing values into the constructor i can then use the deconstruct method to",
    "start": "1702720",
    "end": "1709520"
  },
  {
    "text": "pull those out so it's the same syntax with the var brackets first name and surname two new variables",
    "start": "1709520",
    "end": "1715440"
  },
  {
    "text": "one first name one surname and that will be the deconstructed value of my name",
    "start": "1715440",
    "end": "1721600"
  },
  {
    "text": "and it the compiler does this by calling the deconstruct method it's got out variables",
    "start": "1721600",
    "end": "1726720"
  },
  {
    "text": "sorry out parameters and those are just assigned and populated so again when the",
    "start": "1726720",
    "end": "1732399"
  },
  {
    "text": "compiler is done with this we end up with two variables which have got the first",
    "start": "1732399",
    "end": "1738399"
  },
  {
    "text": "name and certain name so if we jump back to our positional parameter here",
    "start": "1738399",
    "end": "1744799"
  },
  {
    "text": "sorry a positional pattern um what we can see is this is going to invoke the deconstruct method and it matches then",
    "start": "1744799",
    "end": "1751440"
  },
  {
    "text": "those patterns on those results and yeah so that's calling the same",
    "start": "1751440",
    "end": "1756720"
  },
  {
    "text": "deconstruct method which i just had and it's going to use the constant pattern on the variables that is pulled out of that",
    "start": "1756720",
    "end": "1765320"
  },
  {
    "text": "but speaking of tuples and brackets and all that kind of stuff um we can match on multiple values as well so this makes",
    "start": "1769200",
    "end": "1775600"
  },
  {
    "text": "us uh gives us even more power behind our pattern matching here we can",
    "start": "1775600",
    "end": "1781360"
  },
  {
    "text": "actually look at multiple values going in to see what's going on there so",
    "start": "1781360",
    "end": "1787360"
  },
  {
    "text": "here i'm passing i'm looking at two values i and o an integer and an object i'm making sure that the value of i is",
    "start": "1787360",
    "end": "1794159"
  },
  {
    "text": "42 and also that my uh object is a person name of mat and ages",
    "start": "1794159",
    "end": "1801120"
  },
  {
    "text": "slightly over 21. and again we've got the brackets going around the value at the start that's",
    "start": "1801120",
    "end": "1807840"
  },
  {
    "text": "just syntax it's not creating a new tuple here so there's no allocation going on there",
    "start": "1807840",
    "end": "1813600"
  },
  {
    "text": "yeah and this is a great way of doing uh complex",
    "start": "1814320",
    "end": "1819360"
  },
  {
    "text": "conditions of between sort of unrelated values there so in this particular example with an is is",
    "start": "1819360",
    "end": "1824399"
  },
  {
    "text": "perhaps not terribly useful but it's more useful when you're using a switch statement and you can then look at a whole load of things so the i there",
    "start": "1824399",
    "end": "1831360"
  },
  {
    "text": "could be a value for i don't know employee status and it could then have a check on all",
    "start": "1831360",
    "end": "1838000"
  },
  {
    "text": "the different employee statuses you could have and then the person on the other side",
    "start": "1838000",
    "end": "1844000"
  },
  {
    "text": "right so that's a quick run through all the different patterns we've",
    "start": "1844240",
    "end": "1849440"
  },
  {
    "text": "uh got in there and what's kind of missing there uh as i said with a constant pattern we can do a check to",
    "start": "1849679",
    "end": "1855200"
  },
  {
    "text": "see whether something is a constant value uh our relational patterns use that then they compare against constant",
    "start": "1855200",
    "end": "1861279"
  },
  {
    "text": "values but we can't compare against a variable itself um this is the case across a number of",
    "start": "1861279",
    "end": "1868399"
  },
  {
    "text": "different languages uh f sharp has is the same i believe um so you can't compare a relational value against a",
    "start": "1868399",
    "end": "1876000"
  },
  {
    "text": "variable only against constants but i think c plus is looking to do just that",
    "start": "1876000",
    "end": "1881440"
  },
  {
    "text": "and i think that's actually causing them some headaches because then you don't quite know what you're parsing and quite",
    "start": "1881440",
    "end": "1887120"
  },
  {
    "text": "know what the pattern looks like but that's okay you can still just extract it to a variable and compare it",
    "start": "1887120",
    "end": "1892799"
  },
  {
    "text": "with a traditional if test the other thing that's missing is if we wanted to look at the property",
    "start": "1892799",
    "end": "1899679"
  },
  {
    "text": "um parameter the property pattern we can only really look at sort of simple properties in a way or complex",
    "start": "1899679",
    "end": "1906720"
  },
  {
    "text": "properties until you get down to a simple property you can't look at lists you can't look at the third item in this",
    "start": "1906720",
    "end": "1912640"
  },
  {
    "text": "list or you can't say does this list have four items there actually you can because you can do you",
    "start": "1912640",
    "end": "1918320"
  },
  {
    "text": "can look at the length property to say that the length is four but then you can't look at the values within that list",
    "start": "1918320",
    "end": "1926080"
  },
  {
    "start": "1926000",
    "end": "2089000"
  },
  {
    "text": "right so how do patterns work i mean that the kind of syntax which",
    "start": "1926399",
    "end": "1931760"
  },
  {
    "text": "we've seen so far has been very very declarative they look",
    "start": "1931760",
    "end": "1937120"
  },
  {
    "text": "they're not executable code there this is just describing a shape it's looking declarative so how does all of this",
    "start": "1937120",
    "end": "1943200"
  },
  {
    "text": "work how does it all work under the hood and everything and um basically it's compiler magic the",
    "start": "1943200",
    "end": "1948559"
  },
  {
    "text": "compiler just rewrites everything it's a mechanical transformation to uh to change it but it's not obvious what's",
    "start": "1948559",
    "end": "1955440"
  },
  {
    "text": "going on under the covers there so if you're familiar with uh iterators the yield return statements",
    "start": "1955440",
    "end": "1961840"
  },
  {
    "text": "there's a fairly mechanical transformation that's happening under the covers there to um",
    "start": "1961840",
    "end": "1969120"
  },
  {
    "text": "to to convert into a state machine and which can sort of save the the current states and then jump straight back in",
    "start": "1969120",
    "end": "1975600"
  },
  {
    "text": "and return the next item uh there's a similar but more complex transformation going on with async",
    "start": "1975600",
    "end": "1981120"
  },
  {
    "text": "awaits link is a very simple uh transformation into method calls and so those kind of",
    "start": "1981120",
    "end": "1987120"
  },
  {
    "text": "make a little bit more mental mental sense to me fit my mental model of what's going on with c sharp",
    "start": "1987120",
    "end": "1993760"
  },
  {
    "text": "but with patterns it's a little less obvious and so we can have a quick look at some of these things",
    "start": "1993760",
    "end": "2000799"
  },
  {
    "text": "so i've got um i've got an example here which is uh off the the.net sites there's um",
    "start": "2000799",
    "end": "2008640"
  },
  {
    "text": "there is a set of dot net samples um as part of all the c sharp stuff",
    "start": "2008640",
    "end": "2014640"
  },
  {
    "text": "which will um gives you a nice tutorial really to look for working through pattern",
    "start": "2014640",
    "end": "2020320"
  },
  {
    "text": "matching and how to use pattern matching how to evolve a bit of code into using something which is based on patterns",
    "start": "2020320",
    "end": "2026880"
  },
  {
    "text": "and what we can do is we can have a look at some of these kinds of things see some examples of where we might want to use it and then see how the compiler",
    "start": "2026880",
    "end": "2033120"
  },
  {
    "text": "actually what it looks like under the covers so",
    "start": "2033120",
    "end": "2039519"
  },
  {
    "text": "i'm going to jump to a simple one first",
    "start": "2039519",
    "end": "2046600"
  },
  {
    "text": "hang on i've lost my",
    "start": "2049599",
    "end": "2052560"
  },
  {
    "text": "one sex sorry i've lost my",
    "start": "2056480",
    "end": "2060679"
  },
  {
    "text": "yes so um the is letter uh example there so if we",
    "start": "2064240",
    "end": "2071520"
  },
  {
    "text": "yes the problem is i've lost the source code for that one that was what i was looking for the the original if we remember the is letter check we had we",
    "start": "2072079",
    "end": "2078800"
  },
  {
    "text": "had a simple uh return statement i'll just grab it back off here's a couple up there",
    "start": "2078800",
    "end": "2087078"
  },
  {
    "text": "i've passed it that one that's right given a pattern like this we've got a uh",
    "start": "2088879",
    "end": "2094638"
  },
  {
    "text": "a method there is letter it's an expression-bodied item there we're just going to return back the",
    "start": "2094639",
    "end": "2100320"
  },
  {
    "text": "result of this is expression as a pattern and we're doing a relational thing we've got",
    "start": "2100320",
    "end": "2106079"
  },
  {
    "text": "um that it's between a and z lowercase and or it's between a and z uppercase",
    "start": "2106079",
    "end": "2113200"
  },
  {
    "text": "we can then sort of see what's going on and how that's sort of decompiles to and basically it doesn't decompile uh into",
    "start": "2113200",
    "end": "2121200"
  },
  {
    "text": "perfectly or into the same c sharp that you would write yourself so the code",
    "start": "2121200",
    "end": "2126560"
  },
  {
    "text": "that the compiler generates is a little different to the code that you would and so when the decompiler sees it it",
    "start": "2126560",
    "end": "2133119"
  },
  {
    "text": "doesn't recognize a normal set of if statements and so we end up with go to's and things like that",
    "start": "2133119",
    "end": "2139119"
  },
  {
    "text": "but we've got um a similar sort of flow going on here again the order of the flow is important first checks to see",
    "start": "2139119",
    "end": "2145040"
  },
  {
    "text": "whether the value is uh greater than a if it is it then sort of checks to see",
    "start": "2145040",
    "end": "2150560"
  },
  {
    "text": "whether it is uh greater than z lowercase and if so we jump to level level",
    "start": "2150560",
    "end": "2156240"
  },
  {
    "text": "label four sorry and uh we basically then return false so",
    "start": "2156240",
    "end": "2162240"
  },
  {
    "text": "that's failed so it's um",
    "start": "2162240",
    "end": "2168320"
  },
  {
    "text": "if it's less than z so if it's greater than a and less than z we end up at this state here",
    "start": "2168320",
    "end": "2175359"
  },
  {
    "text": "with uh setting a flag jumping to label five which is exit so again this isn't necessarily the code you'd write and",
    "start": "2175359",
    "end": "2181760"
  },
  {
    "text": "looking at it it takes a minute to get your head around what's going on here",
    "start": "2181760",
    "end": "2186880"
  },
  {
    "text": "um but it is still just sort of simple if statements and when i say simple i mean they're",
    "start": "2186880",
    "end": "2192560"
  },
  {
    "text": "nested they're complex the pattern we wrote was shorter and simpler you know this one particularly here now",
    "start": "2192560",
    "end": "2198800"
  },
  {
    "text": "that's a nice much more uh easier pattern that we would recognize sorry",
    "start": "2198800",
    "end": "2204560"
  },
  {
    "text": "not pattern an easier if statement that we would recognize and that we would write ourselves and it would show us",
    "start": "2204560",
    "end": "2210400"
  },
  {
    "text": "what we've got we can also have a look at",
    "start": "2210400",
    "end": "2216160"
  },
  {
    "text": "our property patterns yep i've got the code for that one",
    "start": "2216160",
    "end": "2222640"
  },
  {
    "text": "and again this is going to be a very similar sort of example as was shown in the slides can",
    "start": "2223119",
    "end": "2229760"
  },
  {
    "text": "anyone see the the font size big enough by the way everyone happy cool yep so we've got two patterns",
    "start": "2229760",
    "end": "2234960"
  },
  {
    "text": "going on here we've got a simple one at the top we'll look at that one first if o is person and then check the uh",
    "start": "2234960",
    "end": "2241839"
  },
  {
    "text": "simple name is matt my definitions are down here i got a person",
    "start": "2241839",
    "end": "2247760"
  },
  {
    "text": "with a string property simple name and a name property uh complex name and then name one is",
    "start": "2247760",
    "end": "2254880"
  },
  {
    "text": "just it's just a type so if we look at the simple property pattern first",
    "start": "2254880",
    "end": "2261280"
  },
  {
    "text": "if i swap back into the decompiler yep decompile code",
    "start": "2261280",
    "end": "2266960"
  },
  {
    "text": "there you go that's actually quite nice that one's decompiled quite nicely there we've got a type pattern it recognizes looking for",
    "start": "2266960",
    "end": "2273680"
  },
  {
    "text": "a type assigns it to a variable and then just checks that the the variable is the constants that we've got there so that",
    "start": "2273680",
    "end": "2280480"
  },
  {
    "text": "one's nice i can break that one down that one's good if we look at the more complex",
    "start": "2280480",
    "end": "2285599"
  },
  {
    "text": "pattern we've got here which is going to be checking for uh a first name of matt and then saying get",
    "start": "2285599",
    "end": "2293119"
  },
  {
    "text": "me out the surname i don't care what the surname is just get it because i want to use it later because i'm going to write it out",
    "start": "2293119",
    "end": "2299440"
  },
  {
    "text": "if you look at that what that compiles down to we've got something here and again we've got go to's",
    "start": "2299440",
    "end": "2305520"
  },
  {
    "text": "because it's not the normal style of code that you would write that the compiler would generate and so the",
    "start": "2305520",
    "end": "2312400"
  },
  {
    "text": "compiler doesn't recognize it to be able to put it back into uh if statements",
    "start": "2312400",
    "end": "2318319"
  },
  {
    "text": "and so the first thing we do is we check that it's not null because we've got lots of different ways of checking that it's not null",
    "start": "2318560",
    "end": "2325040"
  },
  {
    "text": "and then we pull out the complex name we check that that's not null and then we",
    "start": "2325040",
    "end": "2330160"
  },
  {
    "text": "just check to see whether the first name is mat it is and so we populate our variable",
    "start": "2330160",
    "end": "2337760"
  },
  {
    "text": "which we defined at the top here i've got no idea what num equals 1 is",
    "start": "2337760",
    "end": "2342800"
  },
  {
    "text": "for oh yeah so that's the if statement um it says basically says it's true that",
    "start": "2342800",
    "end": "2349520"
  },
  {
    "text": "the pattern matched then we go to our label if it didn't match don't do anything and",
    "start": "2349520",
    "end": "2355040"
  },
  {
    "text": "if it did match then we can write out our surname so you can see that this is complex compared to the",
    "start": "2355040",
    "end": "2362400"
  },
  {
    "text": "um to the pattern that we wrote the pattern is simpler we can do a simpler check on several different things",
    "start": "2362400",
    "end": "2370160"
  },
  {
    "text": "without having to jump through a bunch of nested if statements",
    "start": "2370160",
    "end": "2375200"
  },
  {
    "text": "let's have a quick look at the tuples class does anyone have any questions just yet yes",
    "start": "2379839",
    "end": "2386880"
  },
  {
    "text": "so the question is whether the null checks are done automatically and the answer is yes so as part of a",
    "start": "2388400",
    "end": "2394079"
  },
  {
    "text": "type check it only matches if the value is not null so if i've got if x is person that only",
    "start": "2394079",
    "end": "2400960"
  },
  {
    "text": "matches if x is not null and if i'm got a",
    "start": "2400960",
    "end": "2406800"
  },
  {
    "text": "if i have a type check as part of my property pattern there that is also going to make sure that the",
    "start": "2407040",
    "end": "2413599"
  },
  {
    "text": "the value is not null so here well the value matches the type and is",
    "start": "2413599",
    "end": "2418880"
  },
  {
    "text": "not null so if i passed in null if i called simple property pattern null",
    "start": "2418880",
    "end": "2424960"
  },
  {
    "text": "then this pattern would not match and the null check does that for me if i pass in a string instead of a",
    "start": "2424960",
    "end": "2430640"
  },
  {
    "text": "person that type check finds that",
    "start": "2430640",
    "end": "2435760"
  },
  {
    "text": "and it doesn't match in that case even though the value is not not is that happy",
    "start": "2435760",
    "end": "2441920"
  },
  {
    "text": "cool anybody else yes",
    "start": "2441920",
    "end": "2447880"
  },
  {
    "text": "yes so yeah absolutely so the the the comments about the the ternary operator",
    "start": "2456000",
    "end": "2462480"
  },
  {
    "text": "so i haven't mentioned that at all yet so uh i mentioned that the if statement uh the ifs are statements and ifs do not",
    "start": "2462480",
    "end": "2468480"
  },
  {
    "text": "have a value um but if you want to do something similar to an if else",
    "start": "2468480",
    "end": "2474000"
  },
  {
    "text": "statement you can use the ternary operator there that that's uh we're coming that would be something",
    "start": "2474000",
    "end": "2480880"
  },
  {
    "text": "like um var x equals o equals to null",
    "start": "2480880",
    "end": "2487040"
  },
  {
    "text": "question mark hello colon well",
    "start": "2487040",
    "end": "2492240"
  },
  {
    "text": "so that would be the uh ternary uh operator in action",
    "start": "2492240",
    "end": "2497440"
  },
  {
    "text": "okay is that oh i've got nullability on there there we go yeah fine",
    "start": "2498560",
    "end": "2503680"
  },
  {
    "text": "see the c sharp null ability um so we can use the ternary operator to",
    "start": "2503680",
    "end": "2509520"
  },
  {
    "text": "give us uh an expression there so that's one way of sort of reducing some of the complexity which we can have with uh nested if",
    "start": "2509520",
    "end": "2515920"
  },
  {
    "text": "statements and things like that but pattern matching takes out further pattern matching sort of extends all of that gives us a whole well it's a whole",
    "start": "2515920",
    "end": "2523359"
  },
  {
    "text": "new language a whole new set of syntax for describing the conditions that we want to meet there so uh",
    "start": "2523359",
    "end": "2530640"
  },
  {
    "text": "with the ternary operator we've got our resulting values here but the condition is still just that part there whereas",
    "start": "2530640",
    "end": "2536880"
  },
  {
    "text": "with a pattern this is this part is my condition and there's a lot of condition",
    "start": "2536880",
    "end": "2542400"
  },
  {
    "text": "going on there to try and put that into a ternary operator would give us uh an equally complex uh condition",
    "start": "2542400",
    "end": "2549760"
  },
  {
    "text": "at that site tuples",
    "start": "2549760",
    "end": "2556240"
  },
  {
    "text": "so the uh yeah so so one of the uh other things that confused me with patterns was",
    "start": "2559119",
    "end": "2565359"
  },
  {
    "text": "working with tuples and deconstruction and stuff like that because you've got the bracket syntax the positional parameters the two pulls the",
    "start": "2565359",
    "end": "2571359"
  },
  {
    "text": "deconstruction it all uses these brackets sort of syntax there it all looks very similar and i kind of cut i",
    "start": "2571359",
    "end": "2577119"
  },
  {
    "text": "don't know well when is it a tuple when is it deconstruction when is it matching on multiple values and things like that",
    "start": "2577119",
    "end": "2582960"
  },
  {
    "text": "so we can take a look at how that works here uh i've got a struct uh point with",
    "start": "2582960",
    "end": "2589680"
  },
  {
    "text": "an x and y i can construct it here passing that in and setting it up",
    "start": "2589680",
    "end": "2595359"
  },
  {
    "text": "fun syntax going on there there's an expression-bodied thing to assign two things thanks to brackets and",
    "start": "2595359",
    "end": "2600480"
  },
  {
    "text": "deconstruction just to confuse things even further and then we've got a deconstruct method",
    "start": "2600480",
    "end": "2606319"
  },
  {
    "text": "with two out parameters and again it's just assigning them at the same time to the x and y",
    "start": "2606319",
    "end": "2613040"
  },
  {
    "text": "properties there so i mean that is the same as as writing x equals x",
    "start": "2613040",
    "end": "2618960"
  },
  {
    "text": "y equals y to say the same thing",
    "start": "2618960",
    "end": "2623440"
  },
  {
    "text": "so we can use that with a deconstruct",
    "start": "2624240",
    "end": "2629599"
  },
  {
    "text": "situation here so here we are deconstructing our point into x and y and that's actually",
    "start": "2629599",
    "end": "2635520"
  },
  {
    "text": "creating two new variables x and y that's not creating a tuple even though that bracket syntax perhaps looks like",
    "start": "2635520",
    "end": "2641440"
  },
  {
    "text": "it is so that will deconstruct and then i'm just using the two variables",
    "start": "2641440",
    "end": "2646720"
  },
  {
    "text": "to work on as a switch statement there and here i can match",
    "start": "2646720",
    "end": "2652000"
  },
  {
    "text": "both values 0 0 i'm at the origin i'm either all the way on the x axis or all the way",
    "start": "2652000",
    "end": "2658240"
  },
  {
    "text": "on the y axis or i can use my discard to match anything",
    "start": "2658240",
    "end": "2664400"
  },
  {
    "text": "and if we quickly look at the decompiling of that",
    "start": "2664400",
    "end": "2670880"
  },
  {
    "text": "in fact the decompiler is smart enough not to call the the uh the deconstruct method there but to give it to us in in",
    "start": "2672160",
    "end": "2678079"
  },
  {
    "text": "nice uh c-sharp syntax let me see this is one which",
    "start": "2678079",
    "end": "2685359"
  },
  {
    "text": "might if it wants to actually do anything",
    "start": "2685359",
    "end": "2691280"
  },
  {
    "text": "oh there you",
    "start": "2691280",
    "end": "2693839"
  },
  {
    "text": "okay how's that so this is uh decompiling to a",
    "start": "2701680",
    "end": "2706880"
  },
  {
    "text": "an older version of c sharp which doesn't understand about the deconstructing syntax there but you can see i've got my",
    "start": "2706880",
    "end": "2713680"
  },
  {
    "text": "point value i call the deconstruct method and it creates two new variables for me there so we're actually not",
    "start": "2713680",
    "end": "2719680"
  },
  {
    "text": "creating a tuple we're just pulling it out into uh variables and",
    "start": "2719680",
    "end": "2726319"
  },
  {
    "start": "2724000",
    "end": "2828000"
  },
  {
    "text": "then the way that uh the the rider's decompiler here has interpreted this is as a switch",
    "start": "2726319",
    "end": "2731760"
  },
  {
    "text": "and it switches on the first value of the x and if it's zero it then sort of checks the y value",
    "start": "2731760",
    "end": "2737760"
  },
  {
    "text": "zero zero gives me the origin zero one gives me my uh y axis",
    "start": "2737760",
    "end": "2743040"
  },
  {
    "text": "if it's one it then checks the other value to match against that",
    "start": "2743040",
    "end": "2748880"
  },
  {
    "text": "and otherwise we've got a default case and we're all done so again",
    "start": "2748880",
    "end": "2755599"
  },
  {
    "text": "uh sort of a fairly complex bit of code being written there which is much more concise and perhaps",
    "start": "2755599",
    "end": "2762160"
  },
  {
    "text": "readable there because we've actually got like a table of the values that we want here so this is now where pattern matching starts to show",
    "start": "2762160",
    "end": "2768800"
  },
  {
    "text": "some use because we can make it more readable and we can actually just show a a table of the values that we're going",
    "start": "2768800",
    "end": "2774640"
  },
  {
    "text": "to be using here",
    "start": "2774640",
    "end": "2777359"
  },
  {
    "text": "okay the question was do you have to deconstruct it the answer is no i wanted to show the difference here really because",
    "start": "2780079",
    "end": "2786079"
  },
  {
    "text": "the next one here i am uh creating a tuple from that well in fact",
    "start": "2786079",
    "end": "2792240"
  },
  {
    "text": "uh i think i could probably just do just do that and that would that will work as well so the uh the switch",
    "start": "2792880",
    "end": "2798800"
  },
  {
    "text": "expression will deconstruct it itself as well so i didn't have to deconstruct it myself",
    "start": "2798800",
    "end": "2806240"
  },
  {
    "text": "but the the switch will do it too um we have a sort of similar",
    "start": "2806240",
    "end": "2812319"
  },
  {
    "text": "pattern going on here where i'm actually creating a new tuple and this is going to be a new allocation a",
    "start": "2812319",
    "end": "2817520"
  },
  {
    "text": "value type here of the tuple and then i can match that on the switch and it pretty much gives us",
    "start": "2817520",
    "end": "2823520"
  },
  {
    "text": "basically the same let's have a quick look at",
    "start": "2823520",
    "end": "2829440"
  },
  {
    "start": "2828000",
    "end": "2966000"
  },
  {
    "text": "some more examples of when you would like to use a uh of",
    "start": "2829440",
    "end": "2834720"
  },
  {
    "text": "pattern matching and so on so the example that's used in this tutorial is of a a toll and it depends on what type",
    "start": "2834720",
    "end": "2842400"
  },
  {
    "text": "of vehicle goes across how many passengers there are and so on there's various different",
    "start": "2842400",
    "end": "2847520"
  },
  {
    "text": "conditions for doing it and what we can do here is we can first of all uh switch",
    "start": "2847520",
    "end": "2852800"
  },
  {
    "text": "on the vehicle itself what kind of vehicle it is so here we're saying well okay it's a car we'll do something based on that",
    "start": "2852800",
    "end": "2860400"
  },
  {
    "text": "uh otherwise it's a taxi otherwise it's a bus or it's a delivery",
    "start": "2860400",
    "end": "2866000"
  },
  {
    "text": "truck and then find last two patterns well it's something but i don't know what it is so let's throw an argument saying",
    "start": "2866000",
    "end": "2872319"
  },
  {
    "text": "it's a sorry an argument exception saying that it's an unknown type of vehicle",
    "start": "2872319",
    "end": "2878000"
  },
  {
    "text": "or it's uh it's null somebody's passed me null that's bad i don't know what to do i'm gonna throw an argument no",
    "start": "2878000",
    "end": "2883280"
  },
  {
    "text": "exception but we can do lots of different things with our particular uh switch statements",
    "start": "2883280",
    "end": "2889839"
  },
  {
    "text": "here as well so if it's a car well then i can do a nested switch to say well how many passengers are there if there's um",
    "start": "2889839",
    "end": "2897359"
  },
  {
    "text": "if there's zero passengers how do you do that with a car okay if if you have a self-driving car",
    "start": "2897359",
    "end": "2902960"
  },
  {
    "text": "then it will uh charge you more if there's a one presumably passengers on top of drivers uh then it gives you",
    "start": "2902960",
    "end": "2910640"
  },
  {
    "text": "a total of uh two dollars pounds whatever if there's two a different deduction and",
    "start": "2910640",
    "end": "2917760"
  },
  {
    "text": "any more than that you get a maximum deduction so it's nice there uh similar sort of thing for taxis and fares you can decide",
    "start": "2917760",
    "end": "2924559"
  },
  {
    "text": "what you want to do based on something within the taxi you can do more fun things with if",
    "start": "2924559",
    "end": "2930160"
  },
  {
    "text": "there's a bus there we can have a when expression to say well if it's a bus",
    "start": "2930160",
    "end": "2936800"
  },
  {
    "text": "with this information do that kind of stuff and we've also got a similar sort of",
    "start": "2936800",
    "end": "2943359"
  },
  {
    "text": "when clause with the delivery truck but we're also getting a highlighter there so we can say we can merge it into a pattern and we can pull that out now and",
    "start": "2943359",
    "end": "2949520"
  },
  {
    "text": "we've got a slightly more complex pattern which says it's a delivery truck and check to see whether the gross weight class property is greater than",
    "start": "2949520",
    "end": "2956640"
  },
  {
    "text": "5000 things and then give it a different value from that",
    "start": "2956640",
    "end": "2964400"
  },
  {
    "start": "2966000",
    "end": "3116000"
  },
  {
    "text": "the other example which is fun is this one which is the peak time premium so if you've got your toll you've also got a",
    "start": "2967440",
    "end": "2974400"
  },
  {
    "text": "peak time premium which is added on top or as a multiplier i think it is and there's a whole set of rules that",
    "start": "2974400",
    "end": "2980720"
  },
  {
    "text": "are going on about that and here we are trying to figure that one out and we are matching on several different",
    "start": "2980720",
    "end": "2987440"
  },
  {
    "text": "things is it a weekday or is it the weekend what time it is morning daytime evening",
    "start": "2987440",
    "end": "2993839"
  },
  {
    "text": "uh and overnight because it's going to change from that and whether you're inbound or outbound",
    "start": "2993839",
    "end": "2999200"
  },
  {
    "text": "and here you can see you've got a full uh table of uh of the states there so this is great there's a way of being",
    "start": "2999200",
    "end": "3005359"
  },
  {
    "text": "able to list your entire state table there and work with it and",
    "start": "3005359",
    "end": "3010640"
  },
  {
    "text": "this is useful for um making sure you've got all those things going on",
    "start": "3010640",
    "end": "3015839"
  },
  {
    "text": "but we can see that there's oh hello we can see that there's a there's some redundancy so for example here we've got",
    "start": "3015839",
    "end": "3023440"
  },
  {
    "text": "well it's a weekday uh it's daytime and i don't care whether it's true sorry the inbound true and false are both giving",
    "start": "3023440",
    "end": "3030480"
  },
  {
    "text": "us a premium of one and a half we could simplify that we could use the",
    "start": "3030480",
    "end": "3036400"
  },
  {
    "text": "underscore discard pattern there and we can then match both at the same time we get a",
    "start": "3036400",
    "end": "3042000"
  },
  {
    "text": "warning to say it's already been handled so we can delete that and then we can actually simplify this pattern down using",
    "start": "3042000",
    "end": "3049440"
  },
  {
    "text": "discards to something that looks a little bit more like this which is a a lot more readable",
    "start": "3049440",
    "end": "3056480"
  },
  {
    "text": "and it's a lot more expressive and it gives us a lot of power there as well so we can say yes it's a weekday and",
    "start": "3056480",
    "end": "3062319"
  },
  {
    "text": "whether it's if it's overnight uh give it this one if it's daytime do that if it's the morning or evening rush depends",
    "start": "3062319",
    "end": "3068640"
  },
  {
    "text": "on your direction of traffic and and everything else is just the normal sort of premium",
    "start": "3068640",
    "end": "3076319"
  },
  {
    "text": "and to put that into an if statement you end up with something like this which is",
    "start": "3076319",
    "end": "3082800"
  },
  {
    "text": "you know less readable and i think you know you could probably clean it up with",
    "start": "3082800",
    "end": "3088400"
  },
  {
    "text": "you know uh using the ternary operators going on there as well and uh you know you could probably get rid",
    "start": "3088400",
    "end": "3094960"
  },
  {
    "text": "of a few things to clean up and that but but even so that",
    "start": "3094960",
    "end": "3100400"
  },
  {
    "text": "that's is not quite as concise and as readable as this sort of state pattern",
    "start": "3100400",
    "end": "3105760"
  },
  {
    "text": "state table that we've got going on here okay let's",
    "start": "3105760",
    "end": "3111920"
  },
  {
    "text": "finish off",
    "start": "3111920",
    "end": "3114480"
  },
  {
    "start": "3116000",
    "end": "3343000"
  },
  {
    "text": "what a pattern is good for we've had a look at a few examples there the states table there is is really useful it's",
    "start": "3117119",
    "end": "3123119"
  },
  {
    "text": "great for reducing nested if statements because you can declaratively describe the shape of the",
    "start": "3123119",
    "end": "3129280"
  },
  {
    "text": "uh the thing you're looking for rather than sort of procedurally checking for it you can describe things as a state table",
    "start": "3129280",
    "end": "3135200"
  },
  {
    "text": "and check multiple values all at the same time and the other thing excuse me the other thing which is",
    "start": "3135200",
    "end": "3140960"
  },
  {
    "text": "really useful is being able to pull the data out of a complex condition especially sort of several",
    "start": "3140960",
    "end": "3146160"
  },
  {
    "text": "layers deep if you're using a nested property pattern there are several sort of canonical",
    "start": "3146160",
    "end": "3152720"
  },
  {
    "text": "examples um if you kind of look at this the sort of pattern matching um",
    "start": "3152720",
    "end": "3158400"
  },
  {
    "text": "uh sort of tutorials for more functional languages you're going to get things like you know working with tree",
    "start": "3158400",
    "end": "3163520"
  },
  {
    "text": "structures and so for example if we've got a node here which has got several uh",
    "start": "3163520",
    "end": "3168720"
  },
  {
    "text": "subtypes of uh describing an expression you know an addition multiplication uh",
    "start": "3168720",
    "end": "3174319"
  },
  {
    "text": "negation then the traditional way of doing that in a sort of procedural language would be to",
    "start": "3174319",
    "end": "3179839"
  },
  {
    "text": "use a visitor pattern and be able to sort of walk through all those nodes at once here you can just do it as uh as a",
    "start": "3179839",
    "end": "3185280"
  },
  {
    "text": "pattern we can map uh we can match our node there if it's a constant pull",
    "start": "3185280",
    "end": "3191680"
  },
  {
    "text": "out the uh the value itself if it's a negation well make it to negative and evaluate the",
    "start": "3191680",
    "end": "3198800"
  },
  {
    "text": "child node that's available there if it's an addition evaluate the two items on the left and the right if there's a",
    "start": "3198800",
    "end": "3204400"
  },
  {
    "text": "multiplication just multiply them otherwise it's a node which we don't know",
    "start": "3204400",
    "end": "3209440"
  },
  {
    "text": "but you can very concisely evaluate an expression just based on that there so it's matching a tree structure does that",
    "start": "3209440",
    "end": "3215760"
  },
  {
    "text": "one kind of make sense okay cool how about this one so i lied about the",
    "start": "3215760",
    "end": "3222240"
  },
  {
    "text": "functional program there's one last one this is wikipedia being pure wikipedia this is great it's like um search for",
    "start": "3222240",
    "end": "3227839"
  },
  {
    "text": "pattern matching on wikipedia it says here's a fantastic example and",
    "start": "3227839",
    "end": "3232880"
  },
  {
    "text": "it looks terrifying i have to say but it's actually really smart um this",
    "start": "3232880",
    "end": "3238559"
  },
  {
    "text": "is for rebalancing a red black tree red black tree is some kind of binary search tree",
    "start": "3238559",
    "end": "3244319"
  },
  {
    "text": "and so basically you've got each node has got a color to say what state it's at it's got a left tree a",
    "start": "3244319",
    "end": "3251520"
  },
  {
    "text": "right tree and a value and you want to rebalance it to make sure that your tree is not too lopsided",
    "start": "3251520",
    "end": "3258800"
  },
  {
    "text": "and this what this does is it basically has four conditions at the top there which matches unbalanced trees",
    "start": "3258800",
    "end": "3265040"
  },
  {
    "text": "and they can be nested so you've got trees within trees and you've got patterns uh which describe variables to pull them out",
    "start": "3265040",
    "end": "3271920"
  },
  {
    "text": "and then at the at the end there it just describes a brand new tree which is balanced",
    "start": "3271920",
    "end": "3278079"
  },
  {
    "text": "and that's really smart it's hard to unpick because there's lots of commas and brackets going on in the different places but you've got four conditions",
    "start": "3278079",
    "end": "3284480"
  },
  {
    "text": "matching the uh unbalanced tree and pulling the data out and then you just create one balance tree to do it",
    "start": "3284480",
    "end": "3290960"
  },
  {
    "text": "doing that procedurally with if statements would be a lot more code than that",
    "start": "3290960",
    "end": "3297280"
  },
  {
    "text": "might possibly be slightly more easy to understand but we'll we'll skip that",
    "start": "3297280",
    "end": "3302720"
  },
  {
    "text": "so to sum up pattern matching pattern matching tests that value is uh of a specific shape that it has certain",
    "start": "3303200",
    "end": "3308559"
  },
  {
    "text": "characteristics more importantly you can extract the information out from within the test for",
    "start": "3308559",
    "end": "3314480"
  },
  {
    "text": "later use and you can combine all these patterns to make more and more con sort of complex",
    "start": "3314480",
    "end": "3322160"
  },
  {
    "text": "conditions to match your characteristics then this can help you to reduce your nested if statements make everything a",
    "start": "3322319",
    "end": "3327760"
  },
  {
    "text": "bit more declarative with c-sharp you use is to match a single pattern this will give you back a",
    "start": "3327760",
    "end": "3333119"
  },
  {
    "text": "boolean true false otherwise use a switch then to choose between different patterns to be able to",
    "start": "3333119",
    "end": "3339599"
  },
  {
    "text": "um to perform an action so that brings me to the end of everything there if you want to have a",
    "start": "3339599",
    "end": "3346319"
  },
  {
    "text": "look at the tutorial which i was showing some of the code for that uh calculating the toll it's a good",
    "start": "3346319",
    "end": "3352160"
  },
  {
    "text": "tutorial which will walk you through sort of uh changing some code from a procedural way into a",
    "start": "3352160",
    "end": "3357599"
  },
  {
    "text": "um a pattern matching way the the links at the bottom there other than that thank you all for coming",
    "start": "3357599",
    "end": "3363280"
  },
  {
    "text": "and for uh joining me and if you have any questions please shout out",
    "start": "3363280",
    "end": "3368480"
  },
  {
    "text": "hello you said you specified the patterns but if you don't",
    "start": "3368480",
    "end": "3374720"
  },
  {
    "text": "know the type say you have a method and you can send in a person it is running a customer and the only thing you know",
    "start": "3374720",
    "end": "3380799"
  },
  {
    "text": "that i want to know if this has a property called name and i want to use that name can i do that say racket name",
    "start": "3380799",
    "end": "3391640"
  },
  {
    "text": "okay so that's a really good question so if we were looking at a property pattern",
    "start": "3393440",
    "end": "3400240"
  },
  {
    "text": "i'm looking at things like the the name being matt the surname the age being over a certain thing there",
    "start": "3400240",
    "end": "3407040"
  },
  {
    "text": "and when i was doing it i was doing it with a person type and the question is can we do that",
    "start": "3407040",
    "end": "3413440"
  },
  {
    "text": "based on no type at all can we just say well i'm getting something in i'm expecting to have a name i expect him to have a surname can we do the pattern on",
    "start": "3413440",
    "end": "3420720"
  },
  {
    "text": "that and the answer is no because it's c-sharp a c-sharp is a strongly typed language so you need to",
    "start": "3420720",
    "end": "3427520"
  },
  {
    "text": "know what it is beforehand if we are using the property pattern and we say person first and then put our",
    "start": "3427520",
    "end": "3435119"
  },
  {
    "text": "properties there you know for name surname age then what we're doing is we're telling the uh compiler that this will be a",
    "start": "3435119",
    "end": "3442799"
  },
  {
    "text": "person or we hope it will be a person type if we don't include that type there",
    "start": "3442799",
    "end": "3448400"
  },
  {
    "text": "then the type has to match whatever is in the object itself so if i",
    "start": "3448400",
    "end": "3454799"
  },
  {
    "text": "quickly find",
    "start": "3454799",
    "end": "3459400"
  },
  {
    "text": "yeah so if it's an image i can't do it uh yeah here here for example o can be an",
    "start": "3460079",
    "end": "3466640"
  },
  {
    "text": "object but then i'm telling the compiler well this object i'm expecting it to be a person and in that case person has a",
    "start": "3466640",
    "end": "3473040"
  },
  {
    "text": "name we know that the compiler knows that but if o is already a person",
    "start": "3473040",
    "end": "3478799"
  },
  {
    "text": "that person type check there would be redundant and then again the compiler still knows",
    "start": "3478799",
    "end": "3484400"
  },
  {
    "text": "that it's a person so it knows it's got a property of name if i was an object and i don't specify the type check the",
    "start": "3484400",
    "end": "3490160"
  },
  {
    "text": "compiler will go i don't know what name is you need to fix that because c-sharp and c-sharp is strongly typed",
    "start": "3490160",
    "end": "3497839"
  },
  {
    "text": "anybody else",
    "start": "3498160",
    "end": "3501480"
  },
  {
    "text": "the comment was you could use an or uh pattern there and yes you can use an all pattern",
    "start": "3512079",
    "end": "3517359"
  },
  {
    "text": "you'd probably use a switch statement in that kind of case there because they're sort of starting to get into disparate things but you could have if o is person",
    "start": "3517359",
    "end": "3525040"
  },
  {
    "text": "blah blah blah or customer blah blah blah and that would yes that would work there so you can do",
    "start": "3525040",
    "end": "3531440"
  },
  {
    "text": "different checks there but again you still need to know what the type the target type is going to be so the compiler can then know what the",
    "start": "3531440",
    "end": "3537119"
  },
  {
    "text": "properties are and validate those and check those",
    "start": "3537119",
    "end": "3541440"
  },
  {
    "text": "hello hi um i get the feeling that it's possible to get high on these things",
    "start": "3542839",
    "end": "3549040"
  },
  {
    "text": "like we did every loop became linked and now every",
    "start": "3549040",
    "end": "3554559"
  },
  {
    "text": "single if statement everything is",
    "start": "3554559",
    "end": "3559720"
  },
  {
    "text": "i'm going to refer you back to the wikipedia article um um no so that's that is a great comment",
    "start": "3561520",
    "end": "3568079"
  },
  {
    "text": "i mean i love the way of getting high on this kind of thing yes never get high in your own supply um",
    "start": "3568079",
    "end": "3574799"
  },
  {
    "text": "yes it's it's very very easy to overdo all of these kinds of things we've done it with link we've done it with so many",
    "start": "3574799",
    "end": "3580720"
  },
  {
    "text": "other things pattern matching is probably going to be uh a very similar sort of thing um",
    "start": "3580720",
    "end": "3588160"
  },
  {
    "text": "i don't know it's it's it's the same argument that you have with link there it's kind of you you kind of have to use",
    "start": "3588799",
    "end": "3595200"
  },
  {
    "text": "it to learn it and you have to make the mistakes to realize when you've got it wrong and when you've overused it to",
    "start": "3595200",
    "end": "3601119"
  },
  {
    "text": "then roll it back and use it in the appropriate places um i think we will probably end up using",
    "start": "3601119",
    "end": "3608079"
  },
  {
    "text": "pattern matching in lots of places we're probably going to use it in smaller places where we would use normal if statements so if i is greater than",
    "start": "3608079",
    "end": "3617040"
  },
  {
    "text": "10 and less than 3 rather than if i is greater than 10 and or sorry i is less",
    "start": "3617040",
    "end": "3624079"
  },
  {
    "text": "than three so we will write a pattern rather than just using the normal relational operators there i think we'll",
    "start": "3624079",
    "end": "3629359"
  },
  {
    "text": "do that kind of thing um i think to an extent the where is it",
    "start": "3629359",
    "end": "3636640"
  },
  {
    "text": "the the pain of this kind of uh of syntax is probably going to stop us doing too crazy stuff with that",
    "start": "3636640",
    "end": "3643839"
  },
  {
    "text": "um but then uh i think we'll we'll have a lot of things",
    "start": "3643839",
    "end": "3648880"
  },
  {
    "text": "so again that's gonna be great because that's nice and concise and good",
    "start": "3648880",
    "end": "3655440"
  },
  {
    "text": "that's starting to not get great because that's just too much and i kind of can't keep track of all of those",
    "start": "3655440",
    "end": "3662400"
  },
  {
    "text": "conditions there to sort of say that well have i covered everything um interestingly i think the compiler will tell me",
    "start": "3662400",
    "end": "3669680"
  },
  {
    "text": "yeah so if i've missed something there the compiler actually tells me that there's a value that hasn't been handled",
    "start": "3669680",
    "end": "3676240"
  },
  {
    "text": "which is useful but um also if if that had been",
    "start": "3676240",
    "end": "3681280"
  },
  {
    "text": "yeah if that was a relational operator there the compiler wouldn't necessarily tell me but the compiler does a very",
    "start": "3681280",
    "end": "3686319"
  },
  {
    "text": "good job of making sure that the switch is exhaustive",
    "start": "3686319",
    "end": "3690960"
  },
  {
    "text": "okay there we go um have we got any time um i think i",
    "start": "3694960",
    "end": "3700319"
  },
  {
    "text": "think that's it for time now actually um so uh thank you all very much for for coming i'll be hanging around if you",
    "start": "3700319",
    "end": "3705599"
  },
  {
    "text": "have any more questions uh please let me know so thank you [Applause]",
    "start": "3705599",
    "end": "3717179"
  },
  {
    "text": "you",
    "start": "3723200",
    "end": "3725280"
  }
]