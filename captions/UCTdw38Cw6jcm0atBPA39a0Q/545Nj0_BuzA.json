[
  {
    "start": "0",
    "end": "55000"
  },
  {
    "text": "welcome to real world examples on optimizing.net performance",
    "start": "1079",
    "end": "6540"
  },
  {
    "text": "I'm Stefan Newcastle I'm Icelandic a principal software engineer at",
    "start": "6540",
    "end": "11639"
  },
  {
    "text": "lucinity in regular also Microsoft MVP and have a pinpoint contributor maintainer",
    "start": "11639",
    "end": "18779"
  },
  {
    "text": "and that's a link to my blog if you want to check it out I'm gonna go over a few topics",
    "start": "18779",
    "end": "24840"
  },
  {
    "text": "here today a lot of them have to do with memory allocations on the garbage collector in in.net",
    "start": "24840",
    "end": "31980"
  },
  {
    "text": "value versus reference types that's like Heap stack memory techniques for example for memory",
    "start": "31980",
    "end": "38579"
  },
  {
    "text": "pooling stack allocations boxing serialization ndns",
    "start": "38579",
    "end": "44640"
  },
  {
    "text": "channels which I wish more people knew about and then some benchmarking and profiling tools let's see if we can get",
    "start": "44640",
    "end": "51480"
  },
  {
    "text": "all over all of this so starting at the beginning with memory allocations dotnet is a managed runtime",
    "start": "51480",
    "end": "58680"
  },
  {
    "start": "55000",
    "end": "55000"
  },
  {
    "text": "as you know what that means is that when you start up a.net process it allocates",
    "start": "58680",
    "end": "66140"
  },
  {
    "text": "contigues a heap of memory for each process and it manages it for you actually takes care of allocating and",
    "start": "66140",
    "end": "73439"
  },
  {
    "text": "cleaning up the memory that you use and this process is maintained by the garbage collector in.net",
    "start": "73439",
    "end": "80520"
  },
  {
    "text": "now there's a link there to the fundamentals of coverage collection",
    "start": "80520",
    "end": "86520"
  },
  {
    "start": "81000",
    "end": "81000"
  },
  {
    "text": "and to optimize the performance the garbage collector splits the Heap into three generations called zero one and",
    "start": "86520",
    "end": "93540"
  },
  {
    "text": "two and that's to help it manage like different lifetimes of objects that",
    "start": "93540",
    "end": "99960"
  },
  {
    "text": "you're allocating it also has a separate Heap for large objects there's objects that are bigger",
    "start": "99960",
    "end": "106140"
  },
  {
    "text": "than 85 000 bytes which is called the large object Heap get to that in a bit",
    "start": "106140",
    "end": "112500"
  },
  {
    "text": "so the garbage collector basically consists of three phases",
    "start": "112500",
    "end": "117540"
  },
  {
    "start": "115000",
    "end": "115000"
  },
  {
    "text": "and this is what it runs for every generation that it collects it marks the objects that are still alive",
    "start": "117540",
    "end": "124079"
  },
  {
    "text": "in that generation reload kitchen if it has to and then it compacts that Heap for that generation",
    "start": "124079",
    "end": "132480"
  },
  {
    "text": "and this is done to make space for other objects that you might be allocating now the generations are like I said zero",
    "start": "132480",
    "end": "139620"
  },
  {
    "start": "138000",
    "end": "138000"
  },
  {
    "text": "one and two generation zeros where all your new objects get allocated when you create them",
    "start": "139620",
    "end": "145379"
  },
  {
    "text": "reference types that is and if generation zero is full the garbage collector has to run a",
    "start": "145379",
    "end": "152220"
  },
  {
    "text": "collection on that generation releasing objects so it can make space for the new objects that you're allocating",
    "start": "152220",
    "end": "158400"
  },
  {
    "text": "an object that survived get promoted up to gen one that's sort of how it keeps",
    "start": "158400",
    "end": "163440"
  },
  {
    "text": "track of uh like short short-lived objects and log lived objects",
    "start": "163440",
    "end": "168840"
  },
  {
    "text": "concept compact that generation gen 1 very similar",
    "start": "168840",
    "end": "175200"
  },
  {
    "text": "if there is not enough memory that gets freed up in generation zero it does the same thing that it didn't generation",
    "start": "175200",
    "end": "180660"
  },
  {
    "text": "zero to gen 1. survivors get promoted to Gen 2 which is the final one and that's pretty much",
    "start": "180660",
    "end": "186959"
  },
  {
    "text": "where all long-lived objects end up in the end and similar to generation zero if there",
    "start": "186959",
    "end": "193500"
  },
  {
    "text": "still is enough space it's going to run a Gen 2 collection Gen 2 collection is a bit different so",
    "start": "193500",
    "end": "200040"
  },
  {
    "text": "objects there are usually just objects that live for long that is they've survived through two",
    "start": "200040",
    "end": "205140"
  },
  {
    "text": "collections this generation zero and one and collecting a generation as you see",
    "start": "205140",
    "end": "211739"
  },
  {
    "text": "means that it has been doing all generations before it as well so what generation 2 collection is called a full",
    "start": "211739",
    "end": "217800"
  },
  {
    "text": "garbage collection and by definition is the most expensive one that's also the old the only uh",
    "start": "217800",
    "end": "225000"
  },
  {
    "text": "collection that actually collects things from the large object Heap but the large trucks were cheap due",
    "start": "225000",
    "end": "230400"
  },
  {
    "text": "to like those mostly being like big objects is not compacted so generation 2 is expensive",
    "start": "230400",
    "end": "238099"
  },
  {
    "text": "to run quickly over like reference versus value types preference types are the types that you normally",
    "start": "238799",
    "end": "245099"
  },
  {
    "start": "239000",
    "end": "239000"
  },
  {
    "text": "knew up or our object okay examples of those are strings objects classes and",
    "start": "245099",
    "end": "251159"
  },
  {
    "text": "arrays the value types do not get allocated in Heap memory so they don't get cleaned up",
    "start": "251159",
    "end": "259199"
  },
  {
    "text": "because they don't have to those are in bytes characters for examples bulls and struct structs like",
    "start": "259199",
    "end": "266340"
  },
  {
    "text": "install classes now the difference between those for example when your colleague methods is",
    "start": "266340",
    "end": "272100"
  },
  {
    "text": "reference types get copied by reference so you can think like when you're sending a reference type as a parameter",
    "start": "272100",
    "end": "277680"
  },
  {
    "text": "to a method the value of it is not copied you're just sending a pointer to that reference",
    "start": "277680",
    "end": "283620"
  },
  {
    "text": "type value types however get copied so like if you create a string send it to a",
    "start": "283620",
    "end": "288720"
  },
  {
    "text": "method that method changes the string it's going to change the original object however ever if you send an integer into",
    "start": "288720",
    "end": "295740"
  },
  {
    "text": "a method and you for example incremented the original integer is not going to get modified because it was copied before it",
    "start": "295740",
    "end": "302040"
  },
  {
    "text": "was sent to the sent to the method so",
    "start": "302040",
    "end": "307680"
  },
  {
    "text": "knowing all this then we can pretty much at least get a good sense of how we can increase performance like best thing of",
    "start": "307680",
    "end": "314699"
  },
  {
    "start": "310000",
    "end": "310000"
  },
  {
    "text": "course is to not allocate at all because then the garbage collection doesn't have to do anything but that's unrealistic",
    "start": "314699",
    "end": "320400"
  },
  {
    "text": "we're always going to have to allocate something so a good aim for us to do is to try to",
    "start": "320400",
    "end": "325919"
  },
  {
    "text": "keep the objects that we have short-lived and to keep them small to avoid them ending up on a large object keep because",
    "start": "325919",
    "end": "332580"
  },
  {
    "text": "as I said that only gets cleaned up as part of a Gen 2 collection to sort of",
    "start": "332580",
    "end": "338639"
  },
  {
    "text": "show you a little bit of an example of this if we want to convert a string to utf-8",
    "start": "338639",
    "end": "343740"
  },
  {
    "start": "342000",
    "end": "342000"
  },
  {
    "text": "bytes this is something that a lot of us have probably done at some point in time",
    "start": "343740",
    "end": "349680"
  },
  {
    "text": "however this is where an allocation takes place because we need to put that string",
    "start": "349680",
    "end": "355500"
  },
  {
    "text": "create a byte array for it and converted into that byte array",
    "start": "355500",
    "end": "361680"
  },
  {
    "text": "but we can actually avoid this allocation so some tricks that's where we get to memory pooling",
    "start": "361680",
    "end": "367320"
  },
  {
    "text": "there's a class called the array pool it's good because it actually",
    "start": "367320",
    "end": "373020"
  },
  {
    "text": "keeps a bucket of arrays for different types that's why it's a generic",
    "start": "373020",
    "end": "378660"
  },
  {
    "text": "and you can rent the Rays from it and then work with it and once you're done working with it you can return it again",
    "start": "378660",
    "end": "385440"
  },
  {
    "text": "now there's a gotcha here you have to remember to return it because if you finish up all the arrays in the pool",
    "start": "385440",
    "end": "390720"
  },
  {
    "text": "then you have to turn them it's gonna have to start creating new ones but it's not going to clean the other ones up because they're being referenced by the",
    "start": "390720",
    "end": "396360"
  },
  {
    "text": "pool so if you don't return them you're going to end up with a memory leak and a good way to do that is to use a",
    "start": "396360",
    "end": "402360"
  },
  {
    "text": "try and finally I'm actually not doing that in this example just to keep it short but this is how it works for",
    "start": "402360",
    "end": "407460"
  },
  {
    "text": "example you rent you rent bytes from the array pool",
    "start": "407460",
    "end": "412680"
  },
  {
    "text": "and you can actually use that array for example to turn a string into UTF encoded bytes",
    "start": "412680",
    "end": "419400"
  },
  {
    "text": "and then that get byte call is not going to allocate any memory because it's already been allocated as part of the",
    "start": "419400",
    "end": "425520"
  },
  {
    "text": "pool so you can reuse it again and again there is a helper you can use which is",
    "start": "425520",
    "end": "430680"
  },
  {
    "text": "called the memory pool it's very similar to the array pool actually uses an arrival underneath but it helps you take",
    "start": "430680",
    "end": "436620"
  },
  {
    "text": "care of the investing and returning by implementing an eye disposable so you can just use by using declaration",
    "start": "436620",
    "end": "442680"
  },
  {
    "text": "for the memory that you wrapped and it'll get returned eventually when you're done using it",
    "start": "442680",
    "end": "448280"
  },
  {
    "text": "another one of those things that you can do is stack allocations they're a bit different because they are",
    "start": "448440",
    "end": "454680"
  },
  {
    "text": "not allocating objects on the Heap so they're not creating objects that need to be cleaned up so by definition they are often a lot",
    "start": "454680",
    "end": "462599"
  },
  {
    "text": "more performant a lot faster to do but there are caveats to it there are limitations you don't have an endless amount of",
    "start": "462599",
    "end": "469020"
  },
  {
    "text": "Stack space I think we've all seen what happens for example if you have a an infinite recursion you end up with a",
    "start": "469020",
    "end": "474720"
  },
  {
    "text": "stack Overflow exception because you're not out of Stack memory that's why you cannot like do this or",
    "start": "474720",
    "end": "482520"
  },
  {
    "text": "use endless amount of it there are other limitations as well you cannot use it in async methods",
    "start": "482520",
    "end": "487560"
  },
  {
    "text": "because the compiler will generate all sorts of State machines and Method jumps between it so there's no way for it to",
    "start": "487560",
    "end": "493199"
  },
  {
    "text": "keep track of the stack allocated memory and you have a limited memory space you should never assume that you have more",
    "start": "493199",
    "end": "499259"
  },
  {
    "text": "than just a few kilobytes of memory to use also when you're stack allocating memory",
    "start": "499259",
    "end": "504599"
  },
  {
    "text": "it is best to allocate a constant size because that allows the compiler to do a lot of",
    "start": "504599",
    "end": "510120"
  },
  {
    "text": "optimizations to make the allocations faster there is one",
    "start": "510120",
    "end": "515339"
  },
  {
    "text": "hint in there which I didn't put on the slide you should never use a stacker location in the loop for obvious reasons",
    "start": "515339",
    "end": "522419"
  },
  {
    "text": "because you will of course eventually end up with a stack Overflow exception if you do that",
    "start": "522419",
    "end": "528300"
  },
  {
    "text": "now there is a trick you can use to combine stack allocations and the array pool",
    "start": "528300",
    "end": "533339"
  },
  {
    "text": "where you can pretty much at runtime decide which one you're going to do so in this case we decided okay we're",
    "start": "533339",
    "end": "540300"
  },
  {
    "text": "gonna allocate or have a limit of like one kilobyte",
    "start": "540300",
    "end": "545640"
  },
  {
    "text": "we create a knowable reference told by the rail which is the pulled array which will",
    "start": "545640",
    "end": "551519"
  },
  {
    "text": "only get populated if we need to go to the ray pool and can't use the stack allocation then we figure out how many parts we're",
    "start": "551519",
    "end": "558180"
  },
  {
    "text": "going to need if it's under the stack allocation limit we use the stack allocation otherwise we use the array pool",
    "start": "558180",
    "end": "564000"
  },
  {
    "text": "and then at the end we check if we actually erected an array and return it if we have to",
    "start": "564000",
    "end": "569899"
  },
  {
    "text": "now to put this into perspective and sort of show you what happens like with the utf-8 example if we run a benchmark on",
    "start": "571740",
    "end": "578820"
  },
  {
    "text": "this uh for like three different sizes a string that has 64 bytes",
    "start": "578820",
    "end": "584760"
  },
  {
    "start": "579000",
    "end": "579000"
  },
  {
    "text": "or 64 characters 512 characters and 1024 characters",
    "start": "584760",
    "end": "590399"
  },
  {
    "text": "for short strings you will actually see that just like directly allocating it just",
    "start": "590399",
    "end": "595980"
  },
  {
    "text": "using the the plane method is actually faster than using a memory pool and the reason for that is because the",
    "start": "595980",
    "end": "602279"
  },
  {
    "text": "memory pool like I said uses eye disposable so there's overhead involved there it has",
    "start": "602279",
    "end": "607980"
  },
  {
    "text": "to have a try finally around the eye disposable it has to call the dispose method so for short strings memory pool",
    "start": "607980",
    "end": "615360"
  },
  {
    "text": "is actually more expensive there but as the strings get larger you can see that the standard method gets slower",
    "start": "615360",
    "end": "622800"
  },
  {
    "text": "in every case and in all of these cases stack allocations are the fastest ones",
    "start": "622800",
    "end": "628260"
  },
  {
    "text": "if you look at the column there that says allocated you can see how much memory is being allocated in each case",
    "start": "628260",
    "end": "634620"
  },
  {
    "text": "but you can see for example when I have a string of length 64 I'm allocating 88 bytes of memory",
    "start": "634620",
    "end": "640980"
  },
  {
    "text": "there are there are extra 24 bytes there that are being allocated every time and I'll get to it later why that is",
    "start": "640980",
    "end": "647820"
  },
  {
    "text": "you also see that those same 24 bytes are allocated in the memory pool instance",
    "start": "647820",
    "end": "652850"
  },
  {
    "text": "[Music] and that brings us to boxing when you have a value type that you need",
    "start": "652850",
    "end": "660120"
  },
  {
    "text": "to convert or not convert you need to store it as maybe it implements an interface",
    "start": "660120",
    "end": "666959"
  },
  {
    "text": "the runtime can't store it directly it has to put it inside an object class and",
    "start": "666959",
    "end": "672720"
  },
  {
    "text": "store it somewhere so even if you have a value type if you treat it as an interface",
    "start": "672720",
    "end": "678540"
  },
  {
    "text": "you're going to be allocating memory because it needs to be put into that object",
    "start": "678540",
    "end": "684019"
  },
  {
    "text": "so for example this happens when you wrap a value in an object class for example let's say you have let's say you",
    "start": "685019",
    "end": "691680"
  },
  {
    "text": "have a list of like icomparables if you put an integer into the list you're",
    "start": "691680",
    "end": "697740"
  },
  {
    "text": "going to allocate memory because it's going to need to treat that value type as an interface and interfaces are",
    "start": "697740",
    "end": "704100"
  },
  {
    "text": "actually objects so memory needs to be allocated on the Heap",
    "start": "704100",
    "end": "710399"
  },
  {
    "text": "every time you need to box a value type the memory allocated on 32-bit machines",
    "start": "710399",
    "end": "716220"
  },
  {
    "text": "is always well at least 16 bytes depends on the size of the value type being boxed and it's at least 24 bytes on 65",
    "start": "716220",
    "end": "724560"
  },
  {
    "text": "4-bit machine that's the 24 price that I was showing you earlier because we had",
    "start": "724560",
    "end": "730019"
  },
  {
    "text": "we had our memory pool used as an eye disposable so it needed to wrap it in an",
    "start": "730019",
    "end": "735540"
  },
  {
    "text": "interface that's why that method actually allocated 24 bytes even though we were using full memory",
    "start": "735540",
    "end": "741779"
  },
  {
    "text": "and this is the reason for example if we put an integer and box it this is the object that actually gets",
    "start": "741779",
    "end": "748740"
  },
  {
    "text": "created in the memory layout you get an object header that depends on if you have a 32-bit or 64-bit machine how big",
    "start": "748740",
    "end": "755160"
  },
  {
    "text": "it is it needs a method table pointer than it needs the actual value and because it needs to like align",
    "start": "755160",
    "end": "762180"
  },
  {
    "text": "everything it needs to align the objects to like specific architectures it needs",
    "start": "762180",
    "end": "768000"
  },
  {
    "text": "to have eight bytes for padding as well so in the example here boxing let's say",
    "start": "768000",
    "end": "775200"
  },
  {
    "text": "I create an interface I want to create a serialization interface",
    "start": "775200",
    "end": "780540"
  },
  {
    "text": "and to minimize allocations I create a struct to implement that interface so all that interface does is it takes a",
    "start": "780540",
    "end": "787139"
  },
  {
    "text": "spanner bytes and it's supposed to write that object into that span another method calls you realize which",
    "start": "787139",
    "end": "794160"
  },
  {
    "text": "takes any object that or any object or structure whatever it is that implements the interface and serialize it to the",
    "start": "794160",
    "end": "802260"
  },
  {
    "text": "bytes in there but again to minimize allocations I",
    "start": "802260",
    "end": "807480"
  },
  {
    "text": "created a struct I'm using stack allocated bytesville destination so although there are no allocations there",
    "start": "807480",
    "end": "813899"
  },
  {
    "text": "and I call the share release method but because we're treating it as an interface this is going to allocate",
    "start": "813899",
    "end": "820440"
  },
  {
    "text": "memory regardless this is always going to allocate on at least on my machine which is 64 bits at least 24 bytes of",
    "start": "820440",
    "end": "826440"
  },
  {
    "text": "memory but there is actually a sneaky way that we can get around this",
    "start": "826440",
    "end": "832740"
  },
  {
    "text": "we can use generics to trick the compiler to say",
    "start": "832740",
    "end": "838980"
  },
  {
    "text": "my serialized method is going to be generic this time but I'm going to restrict it to taking objects that",
    "start": "838980",
    "end": "845459"
  },
  {
    "text": "implement this interface so when I actually now call this method the compiler is going to basically",
    "start": "845459",
    "end": "851339"
  },
  {
    "text": "create an implementation of this method using the struct directly instead of the interface so no boxing will take place",
    "start": "851339",
    "end": "858720"
  },
  {
    "text": "but there's two other things that actually happen as well in the previous version we were actually",
    "start": "858720",
    "end": "864720"
  },
  {
    "text": "using the interface it also needs to do what's called the virtual method call",
    "start": "864720",
    "end": "869880"
  },
  {
    "text": "because it's receiving an interface it doesn't know what the object is that's coming in so it can't do any",
    "start": "869880",
    "end": "876240"
  },
  {
    "text": "optimizations well it technically can if you have very few types implementing the interface but usually you should",
    "start": "876240",
    "end": "881880"
  },
  {
    "text": "consider that it doesn't and that brings us to something called inlining",
    "start": "881880",
    "end": "887040"
  },
  {
    "text": "if we have a small method that doesn't do a lot then they compiler will",
    "start": "887040",
    "end": "894120"
  },
  {
    "text": "sometimes instead of making your code call that method simply take the content of the method and put it instead of a",
    "start": "894120",
    "end": "899699"
  },
  {
    "text": "method call so it saves a method call and the like the code version the like",
    "start": "899699",
    "end": "906600"
  },
  {
    "text": "generated code version of the method becomes a little bit bigger but it's faster because there's no overhead in having to like copy parameters and",
    "start": "906600",
    "end": "913320"
  },
  {
    "text": "everything else so this actually gives us three benefits we get rid of the boxing",
    "start": "913320",
    "end": "919980"
  },
  {
    "text": "we get really virtual call on the interface and we actually allow the compiler to start inlining things",
    "start": "919980",
    "end": "926160"
  },
  {
    "text": "and to for example in this case I like the implementation of MySQL like the Bison",
    "start": "926160",
    "end": "931560"
  },
  {
    "text": "was just taking like an integer converted to bytes because integers just four bytes in memory",
    "start": "931560",
    "end": "938220"
  },
  {
    "text": "the difference in performance here is actually quite dramatic if we use the interface call",
    "start": "938220",
    "end": "945060"
  },
  {
    "start": "942000",
    "end": "942000"
  },
  {
    "text": "like pretty much every call takes six nanoseconds but using the generic interface it goes",
    "start": "945060",
    "end": "951899"
  },
  {
    "text": "down to 0.4 it's actually 93 faster than the other one now just to be clear this is a micro",
    "start": "951899",
    "end": "959220"
  },
  {
    "text": "optimization like you might have a lot of code that you would change to do this and you wouldn't notice anything in your",
    "start": "959220",
    "end": "965220"
  },
  {
    "text": "application but if your application is doing a lot of doing a lot of things with either interfaces or struct types you should",
    "start": "965220",
    "end": "971399"
  },
  {
    "text": "see a difference and speaking of serialization that brings us to indian-ness",
    "start": "971399",
    "end": "979079"
  },
  {
    "start": "976000",
    "end": "976000"
  },
  {
    "text": "is something that is dependent on the architecture of the machine that you're",
    "start": "979079",
    "end": "985440"
  },
  {
    "text": "running machines can be like big Indian or little Indian and then when it comes to networking",
    "start": "985440",
    "end": "991079"
  },
  {
    "text": "a lot of a lot of libraries or protocols say that like you should be sending things in network byte order Network",
    "start": "991079",
    "end": "996839"
  },
  {
    "text": "byte order is just big Indian to show you what I mean by engineers",
    "start": "996839",
    "end": "1003320"
  },
  {
    "text": "if I take an inside integer with this value Which con like converts to the hex",
    "start": "1003320",
    "end": "1009019"
  },
  {
    "text": "like AABB ccdd on a big ending machine this is stored",
    "start": "1009019",
    "end": "1014060"
  },
  {
    "text": "in that order in memory it's going to be stored as a a b b c c d d but on a little Indian machine which is probably",
    "start": "1014060",
    "end": "1020480"
  },
  {
    "text": "most of your machines it's actually stored in memory as ddccpaa",
    "start": "1020480",
    "end": "1026660"
  },
  {
    "text": "so if you would send this send its integer over a network that's expecting this to be in the correct",
    "start": "1027439",
    "end": "1033438"
  },
  {
    "text": "order you would actually be reversing the integer without knowing it so this is something you need to be aware",
    "start": "1033439",
    "end": "1039199"
  },
  {
    "text": "of for example if you're writing cross-platform serialization code we're sending stuff over the network according",
    "start": "1039199",
    "end": "1044360"
  },
  {
    "text": "to like different protocols so there are of course ways that we can",
    "start": "1044360",
    "end": "1050240"
  },
  {
    "text": "just get around this we can like detect the ndns we'll just reverse the bytes if we want to and this is what about",
    "start": "1050240",
    "end": "1057039"
  },
  {
    "start": "1057000",
    "end": "1057000"
  },
  {
    "text": "rabbitmq.net client used to do this is this is not very pretty code",
    "start": "1057039",
    "end": "1063260"
  },
  {
    "text": "like if you if you've used bit wise like operations like ending or",
    "start": "1063260",
    "end": "1068780"
  },
  {
    "text": "or shifting things you might realize what it's doing it's basically taking the bytes in that long",
    "start": "1068780",
    "end": "1075620"
  },
  {
    "text": "and it's reversing them but it's trying to do it all like without allocating anything",
    "start": "1075620",
    "end": "1081860"
  },
  {
    "text": "so there are no temporary variables that are really being used that require allocation",
    "start": "1081860",
    "end": "1087559"
  },
  {
    "text": "but of course for us to be able to like to do this we need to read it as an unsigned integer so we're like sure that",
    "start": "1087559",
    "end": "1094039"
  },
  {
    "text": "all the bytes are in the correct place however there is an easier way to do this because.net has a thing called binary",
    "start": "1094039",
    "end": "1100640"
  },
  {
    "text": "Primitives which does the same thing we can read eight bytes we can simply",
    "start": "1100640",
    "end": "1106580"
  },
  {
    "text": "say like read this as a big Indian there are also right in 64 big Indian",
    "start": "1106580",
    "end": "1112039"
  },
  {
    "text": "and right operations for most other value types that you have and to visualize this if you look at the",
    "start": "1112039",
    "end": "1120380"
  },
  {
    "text": "actual assembly code that gets generated for these two methods it looks like this",
    "start": "1120380",
    "end": "1126140"
  },
  {
    "start": "1124000",
    "end": "1124000"
  },
  {
    "text": "and I'm going to highlight the important part the old method is on the left those are",
    "start": "1126140",
    "end": "1131179"
  },
  {
    "text": "all of the CPU instructions that needed to be run just to make sure that we were returning",
    "start": "1131179",
    "end": "1136640"
  },
  {
    "text": "the bytes followed along in the correct order using a binary Primitives class",
    "start": "1136640",
    "end": "1142640"
  },
  {
    "text": "it boils down to one instruction because it turns out our CPUs actually have a single instruction that just does this",
    "start": "1142640",
    "end": "1149539"
  },
  {
    "text": "take this memory thing reverse it store it somewhere else and again like with the other Benchmark",
    "start": "1149539",
    "end": "1155600"
  },
  {
    "text": "that we saw the difference is actually quite dramatic this the new method is actually 95",
    "start": "1155600",
    "end": "1162820"
  },
  {
    "start": "1157000",
    "end": "1157000"
  },
  {
    "text": "faster and I think we can all agree on which one is more readable as well",
    "start": "1162820",
    "end": "1169179"
  },
  {
    "text": "so that brings me to something called channels this is one of the things that I wish",
    "start": "1169700",
    "end": "1174740"
  },
  {
    "start": "1173000",
    "end": "1173000"
  },
  {
    "text": "more people knew about um if you've ever if you've ever written for example a concurrent application that uses",
    "start": "1174740",
    "end": "1180860"
  },
  {
    "text": "multiple threads and you need to pass things back and forth you might have you might have used",
    "start": "1180860",
    "end": "1187280"
  },
  {
    "text": "a lot of like different constructs like cues you might have used like locks around them to make sure that like one",
    "start": "1187280",
    "end": "1192980"
  },
  {
    "text": "thing is pulling stuff from the cube one thing is putting stuff in there this is what channel s do for you",
    "start": "1192980",
    "end": "1199640"
  },
  {
    "text": "it's made to sort of do this producer consumer pattern",
    "start": "1199640",
    "end": "1204860"
  },
  {
    "text": "it has optimizations for different scenarios like do I have multiple Riders do I have a single Rider single reader",
    "start": "1204860",
    "end": "1210500"
  },
  {
    "text": "multiple readers whatever and it has both async and synchronous",
    "start": "1210500",
    "end": "1216100"
  },
  {
    "text": "interfaces as well because as soon as you start doing something like this async",
    "start": "1216100",
    "end": "1221240"
  },
  {
    "text": "you have to do a lot of complex things for example you might have used a q and a lock you might have used a concurrent",
    "start": "1221240",
    "end": "1227780"
  },
  {
    "text": "cue in semaphores and then you start running into like task completion sources if you want to have this async and whatnot",
    "start": "1227780",
    "end": "1233840"
  },
  {
    "text": "channels just make this easy because they take care of all this for you out of the box Channel comes with two",
    "start": "1233840",
    "end": "1240679"
  },
  {
    "text": "implementations there's an unbounded one which is basically says I can put as many items in the channel as I want",
    "start": "1240679",
    "end": "1247580"
  },
  {
    "text": "which is good like if you want to do things quickly but you have to be really sure that you can actually process",
    "start": "1247580",
    "end": "1253100"
  },
  {
    "text": "things faster than they come in because otherwise you're going to run out of memory eventually",
    "start": "1253100",
    "end": "1258320"
  },
  {
    "text": "but for those cases you actually have the bounded Channel the boundary channel can set a maximum",
    "start": "1258320",
    "end": "1263900"
  },
  {
    "text": "number of items that can stay in the channel so it's great for buffering things up you can say like I want to create a",
    "start": "1263900",
    "end": "1269360"
  },
  {
    "text": "channel that takes like 100 items and if it's full the producer is going to have to wait",
    "start": "1269360",
    "end": "1274820"
  },
  {
    "text": "until the reader is actually taking stuff out of it before it can put new stuff in",
    "start": "1274820",
    "end": "1280220"
  },
  {
    "text": "if we look at just a simplified example of this let's say we have the Creator method at",
    "start": "1280220",
    "end": "1286760"
  },
  {
    "text": "the top that processes an integer and just to simulative work we're going to randomly sleep for up to 100",
    "start": "1286760",
    "end": "1292280"
  },
  {
    "text": "milliseconds asynchronously of course then we write to the console if this is",
    "start": "1292280",
    "end": "1297500"
  },
  {
    "text": "number this number is odd or even then we create another method an asynchronous method which processes",
    "start": "1297500",
    "end": "1303860"
  },
  {
    "text": "Channel and you can see that it takes Channel reader as a parameter it can asynchronously for reach through",
    "start": "1303860",
    "end": "1311240"
  },
  {
    "text": "it so for every item that comes in asynchronously it's gonna call the process method",
    "start": "1311240",
    "end": "1318799"
  },
  {
    "text": "if there are no items to read this method is not going to block and take up one of our threads",
    "start": "1318799",
    "end": "1324559"
  },
  {
    "text": "it's just going to yield it back and it could go do something else then we create a bounded Channel 10",
    "start": "1324559",
    "end": "1331159"
  },
  {
    "text": "items and we start the consumer process now at that point it's not going to do anything because there's nothing in the channel",
    "start": "1331159",
    "end": "1338780"
  },
  {
    "text": "then we just do a simple for Loop put the Thousand items in the channel asynchronously of course because we have",
    "start": "1338780",
    "end": "1344179"
  },
  {
    "text": "to wait for the reader to take them up because we can just keep maximum of 10 items in there at a time",
    "start": "1344179",
    "end": "1349760"
  },
  {
    "text": "and we write when we've actually written something to it and once we're done writing we complete the channel",
    "start": "1349760",
    "end": "1354980"
  },
  {
    "text": "and we have to complete the channel to let the reader know that there are no more items going to be coming through otherwise the reader would just run",
    "start": "1354980",
    "end": "1361580"
  },
  {
    "text": "forever but this is to signal to it and say hey like you're done and then we wait for the consumer to",
    "start": "1361580",
    "end": "1368000"
  },
  {
    "text": "finish and if we just run this really quickly",
    "start": "1368000",
    "end": "1376059"
  },
  {
    "text": "can this is what it does just runs",
    "start": "1378200",
    "end": "1385179"
  },
  {
    "text": "very easily it's just two-way synchronous tasks one is writing always reading television telling you if it's",
    "start": "1385460",
    "end": "1391520"
  },
  {
    "text": "an odd or even number but",
    "start": "1391520",
    "end": "1396559"
  },
  {
    "text": "we of course have multi-core machines so we might want to do this in parallel take advantage of them",
    "start": "1396559",
    "end": "1402679"
  },
  {
    "text": "when we're using channels we can actually just focus on that part of the code we don't have to worry about uh",
    "start": "1402679",
    "end": "1408080"
  },
  {
    "text": "like do I have multiple readers or multiple writers channels just take care of that for us so all we got to do really is change the",
    "start": "1408080",
    "end": "1416480"
  },
  {
    "text": "processing method or the one that actually reads on the channel and this is what I actually like in this",
    "start": "1416480",
    "end": "1422720"
  },
  {
    "text": "example because doing this in parallel is actually simpler than to not doing it",
    "start": "1422720",
    "end": "1427940"
  },
  {
    "text": "because we have asynchronous parallel helpers for this and to give you an idea of the",
    "start": "1427940",
    "end": "1433880"
  },
  {
    "text": "difference we can do something like this I think",
    "start": "1433880",
    "end": "1438980"
  },
  {
    "text": "this is even still running doing it in parallel becomes",
    "start": "1438980",
    "end": "1445700"
  },
  {
    "text": "something like this and it's done",
    "start": "1445700",
    "end": "1452360"
  },
  {
    "text": "taking full advantage of the course that we have on our machine without really having to focus anything on how we were",
    "start": "1452360",
    "end": "1458419"
  },
  {
    "text": "producing consuming things just focusing on the actual thing reading from the channel",
    "start": "1458419",
    "end": "1464320"
  },
  {
    "text": "so gone over a few things that we can",
    "start": "1466220",
    "end": "1471380"
  },
  {
    "text": "actually use in these cases now this talk is about how these things",
    "start": "1471380",
    "end": "1477740"
  },
  {
    "start": "1476000",
    "end": "1476000"
  },
  {
    "text": "were actually applied in the real world and I actually applied these things on the rabbitmq.net client",
    "start": "1477740",
    "end": "1484940"
  },
  {
    "text": "rabbitmq for those who don't know is like a it's a well it's a queue message queue and it",
    "start": "1484940",
    "end": "1492080"
  },
  {
    "text": "uses the amqp protocol just to give you a very quick overview what it does",
    "start": "1492080",
    "end": "1497860"
  },
  {
    "text": "connections have channels like these are not the same channels I was just showing you this is the webmq term Channel",
    "start": "1497860",
    "end": "1504860"
  },
  {
    "text": "for multiplexing purposes so you can be using the connection for for multiple things at a time and channels issue",
    "start": "1504860",
    "end": "1511400"
  },
  {
    "text": "commands like create a queue declare a queue delete it or publish a message whatever",
    "start": "1511400",
    "end": "1517059"
  },
  {
    "text": "commands eventually when they get sent to the server are serialized into frames frames are just like",
    "start": "1517059",
    "end": "1523460"
  },
  {
    "text": "just by the race really they consist of a header payload and marker",
    "start": "1523460",
    "end": "1529640"
  },
  {
    "text": "to show you sort of like a very simple explanation of the layout a frame looks",
    "start": "1529640",
    "end": "1535100"
  },
  {
    "start": "1531000",
    "end": "1531000"
  },
  {
    "text": "like this one byte for the type two butts for the channel payload length is 4 byte",
    "start": "1535100",
    "end": "1541400"
  },
  {
    "text": "payload different depending on what is actually being sent if I'm creating a queue I need to send the queue name and",
    "start": "1541400",
    "end": "1546799"
  },
  {
    "text": "other things if I'm publishing a message I might be sending headers Etc and then there's an end marker",
    "start": "1546799",
    "end": "1552799"
  },
  {
    "text": "telling you that like this is the end of the frame the payload layout is",
    "start": "1552799",
    "end": "1558799"
  },
  {
    "text": "like what you would actually be put into the frame payload two bytes for the class ID class ID can",
    "start": "1558799",
    "end": "1565880"
  },
  {
    "text": "be like Q or exchange whatever and then the method ID which is like create delete publish",
    "start": "1565880",
    "end": "1572960"
  },
  {
    "text": "things like that and then the arguments that go with it like the queue name for example",
    "start": "1572960",
    "end": "1579640"
  },
  {
    "text": "so we can see that we have things we need to serialize things we need to deserialize and work with",
    "start": "1579860",
    "end": "1588200"
  },
  {
    "text": "so what the webmq client did before we actually made these changes when it was sending a command",
    "start": "1588200",
    "end": "1594260"
  },
  {
    "text": "this is what it did step one was it created a memory stream it wrapped that memory stream in a",
    "start": "1594260",
    "end": "1600080"
  },
  {
    "text": "network binary writer which was basically a helpful helper class that did all the serialization like big",
    "start": "1600080",
    "end": "1606440"
  },
  {
    "text": "Indian serialization other things wrote the commands to the network binary writer which put it on the memory stream",
    "start": "1606440",
    "end": "1613279"
  },
  {
    "text": "grab the resulting byte array out of the memory stream because now we have serialized this into bytes",
    "start": "1613279",
    "end": "1619580"
  },
  {
    "text": "set that to the actual Network stream needed to lock it of course because we",
    "start": "1619580",
    "end": "1624679"
  },
  {
    "text": "can't be having many people send trying to write bytes to the network at a time wrote it and had to release the lock",
    "start": "1624679",
    "end": "1631460"
  },
  {
    "text": "now there are multiple problems here related to what we were just going over always creating a memory stream is",
    "start": "1631460",
    "end": "1638120"
  },
  {
    "start": "1633000",
    "end": "1633000"
  },
  {
    "text": "expensive because it's allocating a new byte array under the membership at all times now you you can't tell the memory",
    "start": "1638120",
    "end": "1644120"
  },
  {
    "text": "stream to use an existing byte array if you have one and you can tell it to like you can",
    "start": "1644120",
    "end": "1649820"
  },
  {
    "text": "initialize it to a certain size also if you want but in the cases where we're having commands we have no idea how big or small they're going to be",
    "start": "1649820",
    "end": "1656720"
  },
  {
    "text": "memory stream depending on how big the comment is might have to resize the array and that means allocate a new",
    "start": "1656720",
    "end": "1662539"
  },
  {
    "text": "array copy everything over making more space and they might have to do this multiple times if the command was really big for",
    "start": "1662539",
    "end": "1668360"
  },
  {
    "text": "example if you're publishing a large message another problem was that the helper",
    "start": "1668360",
    "end": "1675020"
  },
  {
    "text": "class the network binary writer always assumed it was running on a little Indian architecture so usually a pretty",
    "start": "1675020",
    "end": "1680659"
  },
  {
    "text": "safe assumption to make but if it was to be run on other architectures",
    "start": "1680659",
    "end": "1686840"
  },
  {
    "text": "this would fail there's a lot of custom serialization logic which I'll show you for example",
    "start": "1686840",
    "end": "1693140"
  },
  {
    "text": "with the big method that was doing all the like bit shifting ending boring whatnot",
    "start": "1693140",
    "end": "1699500"
  },
  {
    "text": "doing a lot of these things is not good for the CPU because like you're you're",
    "start": "1699500",
    "end": "1704900"
  },
  {
    "text": "basically like creating a very big assembly code out of it doesn't inline very well because it gets complex",
    "start": "1704900",
    "end": "1711620"
  },
  {
    "text": "which is not good for the compiler either and doing all the Locking of course on",
    "start": "1711620",
    "end": "1717860"
  },
  {
    "text": "the connections slows things down as well like if we were doing a lot of things in parallel you would be getting into a lot of lock",
    "start": "1717860",
    "end": "1724520"
  },
  {
    "text": "contentions you're like nope you have to wait till I get the lock so I can like write this Frame because of someone else is writing another frame or a big frame",
    "start": "1724520",
    "end": "1731659"
  },
  {
    "text": "so every frame means like had to take a lock write it release it so it added up",
    "start": "1731659",
    "end": "1736940"
  },
  {
    "text": "quickly in case you had like high concurrency every frame implementation then had like",
    "start": "1736940",
    "end": "1744679"
  },
  {
    "text": "knew how to serialize it was a class and like I showed you earlier classes",
    "start": "1744679",
    "end": "1749840"
  },
  {
    "text": "are reference types so that means even if we were just creating a simple command that was creating a queue we",
    "start": "1749840",
    "end": "1755179"
  },
  {
    "text": "needed to start allocating bytes or extra bytes at least",
    "start": "1755179",
    "end": "1760880"
  },
  {
    "text": "so we need to figure out where the solar problem so we thought okay instead of writing conventional memory stream let's",
    "start": "1760880",
    "end": "1766520"
  },
  {
    "start": "1762000",
    "end": "1762000"
  },
  {
    "text": "just Implement a frame interface knows how to calculate its size so we",
    "start": "1766520",
    "end": "1771860"
  },
  {
    "text": "can actually know beforehand how many bytes we're going to need and then the interface like tells it or",
    "start": "1771860",
    "end": "1778279"
  },
  {
    "text": "instructs is on that it needs to know how to write itself to those bytes",
    "start": "1778279",
    "end": "1784100"
  },
  {
    "text": "we changed the serialization Desolation to use the binary Primitives as I showed you before so like most properly",
    "start": "1784100",
    "end": "1791120"
  },
  {
    "text": "cross-platform code was a lot easier to read as well then we decided to use the channels as a",
    "start": "1791120",
    "end": "1796820"
  },
  {
    "text": "buffer between the connection and the outgoing frames so instead of always taking a lock on an",
    "start": "1796820",
    "end": "1803720"
  },
  {
    "text": "upper connection and start writing we will just put it on a channel",
    "start": "1803720",
    "end": "1810039"
  },
  {
    "text": "so after the changes what we do like how we would actually",
    "start": "1811880",
    "end": "1817039"
  },
  {
    "text": "send commands to the webmq server is we would calculate the command size because we have an interface to do that",
    "start": "1817039",
    "end": "1823279"
  },
  {
    "text": "we ranked an array that is big enough for us to write into it we again have an interface we know how",
    "start": "1823279",
    "end": "1829820"
  },
  {
    "text": "to write to that array send the array to the channel writer and there's just a single reader picking",
    "start": "1829820",
    "end": "1836720"
  },
  {
    "text": "everything up from the channel writing it to a network stream and once it's done it sends the array back to the",
    "start": "1836720",
    "end": "1842899"
  },
  {
    "text": "array pool so in this case we're not well we're",
    "start": "1842899",
    "end": "1848539"
  },
  {
    "text": "hoping we at least not allocate anything to validate that these changes were actually doing what they were supposed",
    "start": "1848539",
    "end": "1854659"
  },
  {
    "start": "1853000",
    "end": "1853000"
  },
  {
    "text": "to be doing we needed to profile and Benchmark to changes so created a simple wrapping",
    "start": "1854659",
    "end": "1861320"
  },
  {
    "text": "Cube test application what it did was it opened the connection to the server Creator Channel and subscriber sends 50",
    "start": "1861320",
    "end": "1869000"
  },
  {
    "text": "000 messages gets it back with uh we decided to have like a big payload",
    "start": "1869000",
    "end": "1874340"
  },
  {
    "text": "wait until it receives them all back and then quits so doing the math on this like we were",
    "start": "1874340",
    "end": "1880340"
  },
  {
    "text": "sending less than two gigabytes of data over the network should be",
    "start": "1880340",
    "end": "1886299"
  },
  {
    "text": "no before we actually made all these changes",
    "start": "1888380",
    "end": "1894679"
  },
  {
    "text": "this is what the revenue client did it allocated 7.14 gigabytes of memory to",
    "start": "1894679",
    "end": "1902899"
  },
  {
    "text": "send 50 000 messages so to send less than two gigabytes of messages we were allocating",
    "start": "1902899",
    "end": "1909320"
  },
  {
    "text": "more than seven gigabytes those are not like allocations that were all being done at the same time so like the the",
    "start": "1909320",
    "end": "1915440"
  },
  {
    "text": "client didn't take 70 gigabytes of memory like it was constantly like allocating it and cleaning it up",
    "start": "1915440",
    "end": "1921500"
  },
  {
    "text": "but you can see that like it's allocating a bunch of bytes it's allocating a bunch of memory streams",
    "start": "1921500",
    "end": "1928039"
  },
  {
    "text": "and it's actually allocating or creating and the garbage collection having to",
    "start": "1928039",
    "end": "1933740"
  },
  {
    "text": "collect like four million objects so this is not very optimal",
    "start": "1933740",
    "end": "1940520"
  },
  {
    "text": "after we did the changes that we that I just showed you it went down to this",
    "start": "1940520",
    "end": "1947559"
  },
  {
    "text": "99 megabytes in total allocated to send this because we can simply reuse all our",
    "start": "1947779",
    "end": "1955159"
  },
  {
    "text": "flight arrays again and again and again also reduce the number of objects",
    "start": "1955159",
    "end": "1960200"
  },
  {
    "text": "allocated from like over 4 million down to 1.8 and this was actually just by making",
    "start": "1960200",
    "end": "1965720"
  },
  {
    "text": "these changes that I actually did in there there was room for a lot of improvement more",
    "start": "1965720",
    "end": "1971659"
  },
  {
    "text": "and it has actually been improved I think we're actually down to like using this using this same Benchmark I think",
    "start": "1971659",
    "end": "1978140"
  },
  {
    "text": "currently we're around 30 or 40 megabytes that get allocated",
    "start": "1978140",
    "end": "1983200"
  },
  {
    "text": "so this is sort of a way that you can actually apply things like this in the real world",
    "start": "1984080",
    "end": "1989659"
  },
  {
    "text": "with actual real world benefits but doing this is as with everything else",
    "start": "1989659",
    "end": "1996559"
  },
  {
    "text": "you can't just like go all out and start optimizing everything without actually knowing what you're",
    "start": "1996559",
    "end": "2001720"
  },
  {
    "text": "supposed to be optimizing and so we're going to need some tools to do that",
    "start": "2001720",
    "end": "2007299"
  },
  {
    "text": "to go over some of them there are if you're using visual studio it has actually a built-in profiling",
    "start": "2007299",
    "end": "2013120"
  },
  {
    "text": "tool which is really really nice and has actually been improved a lot lately",
    "start": "2013120",
    "end": "2018580"
  },
  {
    "text": "it's become a lot faster than it used to be and it's built into like I said built",
    "start": "2018580",
    "end": "2023919"
  },
  {
    "text": "into Visual Studio but if you're not reusing visual studio uh jetbrains has memory allocation tools",
    "start": "2023919",
    "end": "2030159"
  },
  {
    "text": "as well that you can do memory profiling on you can see for example it does uh it",
    "start": "2030159",
    "end": "2035559"
  },
  {
    "text": "shows you like visually how much memory is in each generation like the generation zero generation one two",
    "start": "2035559",
    "end": "2042279"
  },
  {
    "text": "or the large objective for that matter and it shows you like the difference in what happens when it actually does collections",
    "start": "2042279",
    "end": "2048398"
  },
  {
    "text": "it also has a really really nice snapshotting feature so you can take snapshots at your applications running",
    "start": "2048399",
    "end": "2053440"
  },
  {
    "text": "and actually compare them so you can see like the difference in for example how many strings I've been allocating",
    "start": "2053440",
    "end": "2059200"
  },
  {
    "text": "between the snapshots or how many of them are getting cleaned up or how many of them are still left so you can see use that for example to",
    "start": "2059200",
    "end": "2065858"
  },
  {
    "text": "track memory leaks another tool jetbrains has is dot Trace",
    "start": "2065859",
    "end": "2071919"
  },
  {
    "start": "2070000",
    "end": "2070000"
  },
  {
    "text": "now this is a CPU profiler so instead of profiling your memory usage you can use",
    "start": "2071919",
    "end": "2077919"
  },
  {
    "text": "this to like profile your application and see where it's actually spending all the GPU",
    "start": "2077919",
    "end": "2083320"
  },
  {
    "text": "time you can also use it to see if you have a multi-thread application you can see all the context switches going on",
    "start": "2083320",
    "end": "2089020"
  },
  {
    "text": "see which tasks are running or which threads are actually doing anything it can also help you spot for example if",
    "start": "2089020",
    "end": "2094960"
  },
  {
    "text": "you have threads that are blocking or waiting for something when they should when they should be like yielding or",
    "start": "2094960",
    "end": "2101380"
  },
  {
    "text": "attached to other threads so it's very good to to look at threat utilization as well",
    "start": "2101380",
    "end": "2106960"
  },
  {
    "text": "I forgot to mention for example Visual Studio tools they actually have both a CPU and a memory profiler built in uh so",
    "start": "2106960",
    "end": "2115119"
  },
  {
    "text": "that's pretty handy if you wanna really get down to something Nitty Gritty uh you can use",
    "start": "2115119",
    "end": "2120520"
  },
  {
    "text": "perfume it's not it does not have the Jose it's not have",
    "start": "2120520",
    "end": "2127540"
  },
  {
    "text": "the best user interface but if you get used to it like I would not recommend you start using this tool like to begin",
    "start": "2127540",
    "end": "2133180"
  },
  {
    "text": "with use something simple to begin with but this tool is really really powerful it can show you a lot of things if you",
    "start": "2133180",
    "end": "2139240"
  },
  {
    "text": "know what you're looking for and you can do CPU allocations no CPU sorry profiling memory allocations they can",
    "start": "2139240",
    "end": "2145960"
  },
  {
    "text": "even start looking at things like when you're jumping from manage code into native code you can tell you for example like",
    "start": "2145960",
    "end": "2151839"
  },
  {
    "text": "if you have a managed application that's opening and like opening a lot of files it can actually show you once it goes",
    "start": "2151839",
    "end": "2157720"
  },
  {
    "text": "output to the operating system to open a file and it can show it like ah Defender is pulling in there trying to like scan",
    "start": "2157720",
    "end": "2163900"
  },
  {
    "text": "the file before I'm opening it and everything else so it's really really good but take some time getting used to",
    "start": "2163900",
    "end": "2172380"
  },
  {
    "text": "benchmarks the benchmarks I show you or like the results I showed you were created with benchmark.net",
    "start": "2174280",
    "end": "2182578"
  },
  {
    "text": "benchmark.net is really released use and it's really powerful it's great for",
    "start": "2184740",
    "end": "2189880"
  },
  {
    "text": "these micro benchmarks it's not very good at showing you for example like it's not very good at benchmarking an",
    "start": "2189880",
    "end": "2195820"
  },
  {
    "text": "entire application that does a lot of things it's best for benchmarking like small pieces of code",
    "start": "2195820",
    "end": "2202480"
  },
  {
    "text": "and it gives you results in like multiple formats you can get a text format markdown format it can give you",
    "start": "2202480",
    "end": "2208180"
  },
  {
    "text": "reports for example of as we saw the memory allocations it can even give you reports of the assembly code that gets",
    "start": "2208180",
    "end": "2214540"
  },
  {
    "text": "generated so you can start running this seeing the difference in in code generation",
    "start": "2214540",
    "end": "2219700"
  },
  {
    "text": "and a lot of other very very cool things you can also you can also for example I guess down here you can say I have a",
    "start": "2219700",
    "end": "2225880"
  },
  {
    "text": "benchmark I want you to run it on these different types of the internet framework and compare the results",
    "start": "2225880",
    "end": "2231760"
  },
  {
    "text": "so you can see the performance improvements for example between.net framework versions all.net corporations for that matter",
    "start": "2231760",
    "end": "2239040"
  },
  {
    "text": "another tool that I'm really fond of is shortlab.io this is pretty much a",
    "start": "2239079",
    "end": "2244780"
  },
  {
    "text": "website you just go there you paste in some c-sharp code they will actually compile it and it can",
    "start": "2244780",
    "end": "2251980"
  },
  {
    "text": "show you the results it can show you for example if you if you have a c-sharp code where you're using a lot of like a lot of the new",
    "start": "2251980",
    "end": "2259540"
  },
  {
    "text": "syntax it can show you the actual c-sharp code that it gets turned into you can also show you the Intermediate",
    "start": "2259540",
    "end": "2265839"
  },
  {
    "text": "Language code IO code or even the assembly code that gets generated so this is really nice as well",
    "start": "2265839",
    "end": "2273480"
  },
  {
    "text": "it's easy for example if you want to share like share code generation with someone else",
    "start": "2273520",
    "end": "2279339"
  },
  {
    "text": "you can just like copy paste URLs and it will actually the code is actually usually a part of the part of the URL in",
    "start": "2279339",
    "end": "2285460"
  },
  {
    "text": "there also has like in this case you can see that probably in the middle there",
    "start": "2285460",
    "end": "2290560"
  },
  {
    "text": "there's an x64 you can like see how the different code is generated depending on",
    "start": "2290560",
    "end": "2295960"
  },
  {
    "text": "what architecture you're picking so that's that's a really nice thing and another thing that",
    "start": "2295960",
    "end": "2303099"
  },
  {
    "text": "I'm really fond of is power up it's a tool made by Bartos adamsky I think I think I'm",
    "start": "2303099",
    "end": "2310720"
  },
  {
    "start": "2304000",
    "end": "2304000"
  },
  {
    "text": "pronouncing that correctly but there's a tool he actually created because he he likes looking at compilers",
    "start": "2310720",
    "end": "2317859"
  },
  {
    "text": "seeing like the different things compilers do or different compilers a lot different things they should be doing and aren't doing",
    "start": "2317859",
    "end": "2324339"
  },
  {
    "text": "and this works not just for dotnet code it's actually this can actually show you code generation for I think golang rust",
    "start": "2324339",
    "end": "2331000"
  },
  {
    "text": "as well so I'd highly recommend that you take a look at this tool if you wanna if you want to see what actually happens",
    "start": "2331000",
    "end": "2338880"
  },
  {
    "text": "so I think that's pretty much it I decided to leave some room from for questions if you have any",
    "start": "2340480",
    "end": "2347260"
  },
  {
    "start": "2344000",
    "end": "2344000"
  },
  {
    "text": "um this is a lot to go over to digest so please bring them on if you",
    "start": "2347260",
    "end": "2352839"
  },
  {
    "text": "have any can't see anything",
    "start": "2352839",
    "end": "2358680"
  },
  {
    "text": "any questions you have right yep",
    "start": "2360400",
    "end": "2368380"
  },
  {
    "text": "to you sorry it's a question if you can use Channels with the RX Library yeah",
    "start": "2375520",
    "end": "2381040"
  },
  {
    "text": "all right",
    "start": "2381040",
    "end": "2383460"
  },
  {
    "text": "I not that I know of but I would I would I would guess that it would not be very",
    "start": "2386440",
    "end": "2393339"
  },
  {
    "text": "hard to do it might actually be a good fit in some cases it might be helpful",
    "start": "2393339",
    "end": "2399900"
  },
  {
    "text": "anyone else you're gonna have to speak up because I",
    "start": "2400599",
    "end": "2406060"
  },
  {
    "text": "like I can't see if you're raising your hands [Applause]",
    "start": "2406060",
    "end": "2411400"
  },
  {
    "text": "all right so thank you very much my blog",
    "start": "2411400",
    "end": "2418680"
  }
]