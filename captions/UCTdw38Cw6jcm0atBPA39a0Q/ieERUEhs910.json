[
  {
    "start": "0",
    "end": "114000"
  },
  {
    "text": "I had a bit of a dilemma with this talk just too many slides and so it's always",
    "start": "7010",
    "end": "15080"
  },
  {
    "text": "hard to cut stuff away and what I decided to do instead was use the drink from a fire hose approach which is to",
    "start": "15080",
    "end": "21710"
  },
  {
    "text": "just leave them in and there are a whole bunch of slides which only need 10 seconds and that's all I'm going to give",
    "start": "21710",
    "end": "27650"
  },
  {
    "text": "them and so the burden is on you that if you see something go by that you want me to stop and dwell on just yell make some",
    "start": "27650",
    "end": "35780"
  },
  {
    "text": "audible noise like pause stop whoa something like that so that I'll know",
    "start": "35780",
    "end": "40940"
  },
  {
    "text": "that you'd like me to dwell there I you'll see a few of these adjust I didn't want to delete them but they only",
    "start": "40940",
    "end": "46160"
  },
  {
    "text": "they really only take a few seconds okay so what motivated this talk is I live in",
    "start": "46160",
    "end": "52820"
  },
  {
    "text": "a C++ world but I do have clients who are still using just C and what I found",
    "start": "52820",
    "end": "61760"
  },
  {
    "text": "is a lot of them are still using C 90 with just a little bit of c 99 thrown in",
    "start": "61760",
    "end": "68810"
  },
  {
    "text": "and so the every so often i get somebody who's interested in knowing well what am",
    "start": "68810",
    "end": "74000"
  },
  {
    "text": "i missing out on and so this is gonna cover things that i think it's not a",
    "start": "74000",
    "end": "83000"
  },
  {
    "text": "completely exhaustive set but these are things which i think you're interesting also if you live in the c++ world it is",
    "start": "83000",
    "end": "88940"
  },
  {
    "text": "interesting just as a student of languages to see the different sensibilities of the c standardization",
    "start": "88940",
    "end": "96320"
  },
  {
    "text": "effort and c++ and so that i think even if you live in a c++ world mostly it's",
    "start": "96320",
    "end": "102800"
  },
  {
    "text": "still kind of interesting to see because there's a fair amount of cross-pollination that occurs where",
    "start": "102800",
    "end": "108650"
  },
  {
    "text": "something originates in C and then winds up in C++ and vice-versa okay very briefly here's the timeline",
    "start": "108650",
    "end": "116090"
  },
  {
    "start": "114000",
    "end": "114000"
  },
  {
    "text": "it's that there really have been four standards for the C language C 89 and 90",
    "start": "116090",
    "end": "125030"
  },
  {
    "text": "are essentially the same thing 89 was the US standard and 90 was the",
    "start": "125030",
    "end": "130399"
  },
  {
    "text": "international version of that same standard so most of us just refer to it as c90 c90 9 then 2011 they",
    "start": "130399",
    "end": "140840"
  },
  {
    "text": "were substantive additions probably the biggest incremental change was between 90 and 99 11 then added a bunch of other",
    "start": "140840",
    "end": "150140"
  },
  {
    "text": "things and then 18 is essentially just 11 with wording changes refinements",
    "start": "150140",
    "end": "158959"
  },
  {
    "text": "there's and it's supposed to be no feature changes it's similar to the situation in C++ but with having to do",
    "start": "158959",
    "end": "166040"
  },
  {
    "text": "with C++ O 3 and 98 which are essentially the same language one thing",
    "start": "166040",
    "end": "173900"
  },
  {
    "text": "that I think is very interesting is a philosophical attitude that is much more",
    "start": "173900",
    "end": "180290"
  },
  {
    "text": "prominent in the C standardization effort than in C++ which is that they",
    "start": "180290",
    "end": "185810"
  },
  {
    "text": "have a I think a greater concern for not breaking existing code in other words if something is compiling with the current",
    "start": "185810",
    "end": "192799"
  },
  {
    "text": "generation of compilers the sikh community tries harder to make it that when the new standard comes out the old",
    "start": "192799",
    "end": "199519"
  },
  {
    "text": "code still works and that manifests itself particularly in the treatment of",
    "start": "199519",
    "end": "205430"
  },
  {
    "text": "keywords and and and new identifiers so what I'm talking about is this is",
    "start": "205430",
    "end": "211940"
  },
  {
    "start": "210000",
    "end": "210000"
  },
  {
    "text": "there's a set of headers it's about 40 standard headers and they all have",
    "start": "211940",
    "end": "218650"
  },
  {
    "text": "well-documented identifiers that are published there so if you include for example standard IO dot H everybody",
    "start": "218650",
    "end": "224870"
  },
  {
    "text": "knows you get EOF and file and printf and things like that but you also get the possibility of a",
    "start": "224870",
    "end": "232069"
  },
  {
    "text": "handful of names that you don't know about it one of the common examples is",
    "start": "232069",
    "end": "237169"
  },
  {
    "text": "that the data type file is often implemented as a type def which is an",
    "start": "237169",
    "end": "243560"
  },
  {
    "text": "alias for some structure type whose name you're not supposed to know but the",
    "start": "243560",
    "end": "249680"
  },
  {
    "text": "problem is how do you avoid inadvertently creating a name that's",
    "start": "249680",
    "end": "255230"
  },
  {
    "text": "spelled the same that could cause a compilation problem another example",
    "start": "255230",
    "end": "262849"
  },
  {
    "text": "where this crops up is that there is a rule with it with the exception of the header assert dot H the idea is that any",
    "start": "262849",
    "end": "271219"
  },
  {
    "text": "header should be allowed standard header should be allowed to be included more than once and in any order with respect to the",
    "start": "271219",
    "end": "278150"
  },
  {
    "text": "other standard headers and there's a common idiom for implementing this which you all know which is to use include",
    "start": "278150",
    "end": "283790"
  },
  {
    "text": "guards and the problem is that the include guards require identifiers for",
    "start": "283790",
    "end": "289310"
  },
  {
    "text": "the names of the macros which are used in the include guards so and the problem",
    "start": "289310",
    "end": "296000"
  },
  {
    "text": "is if you inadvertently use one of those names you're going to have compilation problems and there is a standard way of",
    "start": "296000",
    "end": "303710"
  },
  {
    "text": "staying away from those names and that is that the standard has this notion of",
    "start": "303710",
    "end": "309080"
  },
  {
    "start": "307000",
    "end": "307000"
  },
  {
    "text": "reserved identifiers and and the idea is that there are rules for forming",
    "start": "309080",
    "end": "316040"
  },
  {
    "text": "identifiers that the standard says just don't use these and it's your obligation as a programmer to know what those rules",
    "start": "316040",
    "end": "322580"
  },
  {
    "text": "are and fortunately the rules are pretty simple the rule one rule is that any name that begins with an underscore and",
    "start": "322580",
    "end": "329890"
  },
  {
    "text": "a lowercase lever letter is reserved for use at global scope turns out you're",
    "start": "329890",
    "end": "336950"
  },
  {
    "text": "allowed to use these names as structure members and local variables you're just",
    "start": "336950",
    "end": "343370"
  },
  {
    "text": "not allowed to use them as global names the other category of reserved identifiers they're things that begin",
    "start": "343370",
    "end": "349220"
  },
  {
    "text": "with two underscores or an underscore in a capital letter and those are reserved",
    "start": "349220",
    "end": "354770"
  },
  {
    "text": "absolutely for all uses you just never invent your own names with that spelling",
    "start": "354770",
    "end": "360470"
  },
  {
    "text": "convention now here's how this impacts you this is observable behavior that you",
    "start": "360470",
    "end": "366860"
  },
  {
    "text": "can see in the standardization effort and one good example is the way that C",
    "start": "366860",
    "end": "372770"
  },
  {
    "text": "treats the boolean type originally C didn't have a boolean type so it was",
    "start": "372770",
    "end": "379760"
  },
  {
    "text": "common practice among C programmers who had experience in any other language to",
    "start": "379760",
    "end": "385730"
  },
  {
    "text": "fashion their own boolean Titan C programmers who had only known C thought",
    "start": "385730",
    "end": "390890"
  },
  {
    "text": "that boolean z' were integers with the values 0 and nonzero but those of us who",
    "start": "390890",
    "end": "396140"
  },
  {
    "text": "have multilingual explicit oh how can you get by without a boolean type the",
    "start": "396140",
    "end": "401360"
  },
  {
    "text": "problem was people would conjure up the boolean type differently some people made it a type def in which true and",
    "start": "401360",
    "end": "407660"
  },
  {
    "text": "Falls were macro definitions others made it an enumeration type so that when c99",
    "start": "407660",
    "end": "413990"
  },
  {
    "text": "added the boolean type they had to make sure that it didn't break code and so",
    "start": "413990",
    "end": "419570"
  },
  {
    "text": "they used a reserved identifier for the keyword in particular the the name of",
    "start": "419570",
    "end": "427250"
  },
  {
    "text": "the standard boolean type in C that was added in c99 was underscore capital B",
    "start": "427250",
    "end": "433580"
  },
  {
    "text": "bool and the reason for that was that this was a name that was in the pool of",
    "start": "433580",
    "end": "440210"
  },
  {
    "text": "reserved identifiers which means that if you had been using this you were already",
    "start": "440210",
    "end": "445970"
  },
  {
    "text": "writing a program with undefined behavior and the standards attitude was now you get what you deserve and so they",
    "start": "445970",
    "end": "455360"
  },
  {
    "text": "could safely use that as the new type and so it was a reserved identifier now",
    "start": "455360",
    "end": "461570"
  },
  {
    "text": "its keyword and and you'll see this pattern in a number of the other features that we're going to discuss so",
    "start": "461570",
    "end": "469910"
  },
  {
    "text": "if you want to use the more aesthetic spelling which is bool all in lowercase",
    "start": "469910",
    "end": "477040"
  },
  {
    "text": "you have to include a header standard bullet and when you do not only do you get bool but you get false and true and",
    "start": "477040",
    "end": "484160"
  },
  {
    "text": "this C standard took this approach because they say if you know that you can get these names now added to your",
    "start": "484160",
    "end": "492260"
  },
  {
    "text": "program without any conflict go ahead and include standard voltage now",
    "start": "492260",
    "end": "498500"
  },
  {
    "text": "interestingly C++ couldn't take this approach C++ had to make bool a keyword",
    "start": "498500",
    "end": "504530"
  },
  {
    "text": "and the reason is that the overloading rules in C++ say that if we had just use",
    "start": "504530",
    "end": "513349"
  },
  {
    "text": "a type def then that's not a unique type",
    "start": "513349",
    "end": "518960"
  },
  {
    "text": "for the purposes of overloading if we want to be able to overload on bull it has to be a clearly distinct type and so",
    "start": "518960",
    "end": "526430"
  },
  {
    "text": "they say okay I can't figure out how to do this other than make it a keyword and so you see that the C++ language for",
    "start": "526430",
    "end": "533950"
  },
  {
    "text": "legitimate reasons couldn't be quite as deferential",
    "start": "533950",
    "end": "539680"
  },
  {
    "text": "to existing code as the C language has been now one of the other concerns that",
    "start": "539680",
    "end": "549640"
  },
  {
    "start": "546000",
    "end": "546000"
  },
  {
    "text": "the Sikh community C++ community had was we'd like to know whether or not you're",
    "start": "549640",
    "end": "555070"
  },
  {
    "text": "compiling with a standard C compiler C would when seen 90 came out that was the",
    "start": "555070",
    "end": "561190"
  },
  {
    "text": "first standard and so one of the questions that people would want to know is well am i compiling now with a",
    "start": "561190",
    "end": "567610"
  },
  {
    "text": "standard compiler or do I have to do some things to dance around the fact",
    "start": "567610",
    "end": "572649"
  },
  {
    "text": "that I'm compiling with a pre standard compiler so the way this was handled in",
    "start": "572649",
    "end": "578860"
  },
  {
    "text": "C 90 was to introduce this macro called underscore underscore standard stood C",
    "start": "578860",
    "end": "584380"
  },
  {
    "text": "underscore underscore whose value was either 0 or 1 and you could use these in conditionals in order to be able to say",
    "start": "584380",
    "end": "591880"
  },
  {
    "text": "nothing can I rely on all the features of standard C now this is a classic",
    "start": "591880",
    "end": "597160"
  },
  {
    "text": "example though of not planning ahead because the next standard came out with",
    "start": "597160",
    "end": "605140"
  },
  {
    "text": "new features and immediately the question wasn't is it standard or not but which standard is it and so they",
    "start": "605140",
    "end": "612610"
  },
  {
    "text": "solved that by introducing another they didn't get rid of stood C they added",
    "start": "612610",
    "end": "618279"
  },
  {
    "text": "another one which is stood C version and this is what you use to disturb oast",
    "start": "618279",
    "end": "625360"
  },
  {
    "text": "parts stood C is now not particularly interesting this is the one that is interesting and this is also there's",
    "start": "625360",
    "end": "631270"
  },
  {
    "text": "something like this in C++ as well because C++ has to deal with the same issue and the choice of the values for",
    "start": "631270",
    "end": "639520"
  },
  {
    "text": "stood see the macro is a sequence of digits a long integer essentially whose",
    "start": "639520",
    "end": "646630"
  },
  {
    "text": "numeric value is the month and year in which the standard came out so that 2017",
    "start": "646630",
    "end": "654670"
  },
  {
    "text": "10 is the date that it is considered that the 20 that's actually the C 18",
    "start": "654670",
    "end": "662709"
  },
  {
    "text": "standard came out some some of the insiders actually refer to it as C 17 but those of us involved in",
    "start": "662709",
    "end": "670060"
  },
  {
    "text": "standardisation process know that there's a lag but between the time the committee says we're done and the the time the the ISO",
    "start": "670060",
    "end": "677990"
  },
  {
    "text": "hierarchy finally puts the stamp of approval on it so you can test am i",
    "start": "677990",
    "end": "683990"
  },
  {
    "text": "compiling with c18 by comparing the macro stood C version to that value you",
    "start": "683990",
    "end": "689540"
  },
  {
    "text": "say well if it's not C 18 is it C 11 and if it's not c11 is it C 99 and if it's",
    "start": "689540",
    "end": "698420"
  },
  {
    "text": "not is it at least standard C and if it's not that then you say well I I I'm",
    "start": "698420",
    "end": "705440"
  },
  {
    "text": "dealing with something really ancient here and so you can ask that question",
    "start": "705440",
    "end": "713330"
  },
  {
    "text": "through in the form of a and if def like this now C 99 has a fair number of",
    "start": "713330",
    "end": "722360"
  },
  {
    "start": "719000",
    "end": "719000"
  },
  {
    "text": "features which are in common with C++ in some cases they're identical in others",
    "start": "722360",
    "end": "728360"
  },
  {
    "text": "there are minor variations and I'll try to point out those variations as we go",
    "start": "728360",
    "end": "734300"
  },
  {
    "text": "the first one is the slash last comment that's an example of a slide which",
    "start": "734300",
    "end": "740420"
  },
  {
    "text": "merits three seconds or less the long long integer types the extended integer",
    "start": "740420",
    "end": "746600"
  },
  {
    "text": "types relax declaration ordering and declarations and for statements let's just he hit each of them these really",
    "start": "746600",
    "end": "753530"
  },
  {
    "text": "quickly and you'll stop me if you see anything that you'd like a question now",
    "start": "753530",
    "end": "760190"
  },
  {
    "text": "by the way in lining and complex arithmetic or also things that C shares",
    "start": "760190",
    "end": "765830"
  },
  {
    "text": "in common with C++ but there are clear differences which we'll take a moment to",
    "start": "765830",
    "end": "771800"
  },
  {
    "text": "point out there we go slash slash",
    "start": "771800",
    "end": "777890"
  },
  {
    "text": "comments the thing I want to say about this is my understanding I was not on",
    "start": "777890",
    "end": "783290"
  },
  {
    "text": "this I was on the C committee way back in the 80s but when they got around to",
    "start": "783290",
    "end": "789260"
  },
  {
    "text": "after they finished the c90 standard and we're looking at what do we do for the next standard by the way the common",
    "start": "789260",
    "end": "796130"
  },
  {
    "text": "practice is that many of these standards committees release a standard and then they sort of go dormant for a while",
    "start": "796130",
    "end": "804020"
  },
  {
    "text": "I think the obligation is that have to meet again within something like five years to decide the question is do",
    "start": "804020",
    "end": "811720"
  },
  {
    "text": "we keep the standard as is is it now obsolete and nobody cares about it or are there certain things we'd like to",
    "start": "811720",
    "end": "817600"
  },
  {
    "text": "add or tweak but as we've seen with the C++ committee then it's just a",
    "start": "817600",
    "end": "824230"
  },
  {
    "text": "never-ending churn of activity they don't you know who wants to go to sleep for a little while like we got so much",
    "start": "824230",
    "end": "830769"
  },
  {
    "text": "to do it hasn't been and so the first thing that the C committee did was they",
    "start": "830769",
    "end": "835929"
  },
  {
    "text": "started to look at the list of things that C++ had added and said are there",
    "start": "835929",
    "end": "842439"
  },
  {
    "text": "any of these that we would like to borrow and incorporate into C 19 C",
    "start": "842439",
    "end": "847720"
  },
  {
    "text": "whatever it is after C 90 and it turned out that every single feature was controversial except one and that was",
    "start": "847720",
    "end": "854739"
  },
  {
    "text": "this this one that was it was you I think unanimous let's just do it other",
    "start": "854739",
    "end": "860829"
  },
  {
    "text": "than that this requires no additional elaboration the long long integer type believe that originated in C and was",
    "start": "860829",
    "end": "867879"
  },
  {
    "text": "borrowed over into C++ it's not just the addition of you know that you can now",
    "start": "867879",
    "end": "872980"
  },
  {
    "text": "say long long instead of just long and it wasn't enough to just add the type",
    "start": "872980",
    "end": "878259"
  },
  {
    "text": "the type required some additional support from the library in particular functions like ADA L or the lab's",
    "start": "878259",
    "end": "885850"
  },
  {
    "text": "function for computing absolute value had to be augmented to include ll",
    "start": "885850",
    "end": "891339"
  },
  {
    "text": "versions of those functions also things like printf and scanf had to be",
    "start": "891339",
    "end": "896350"
  },
  {
    "text": "augmented with format specifiers and that was the extent of the support for that exact with integer types most",
    "start": "896350",
    "end": "904899"
  },
  {
    "text": "people know about these but there is an aspect of it which is worth pointing out and this trade is also common with C++",
    "start": "904899",
    "end": "912009"
  },
  {
    "text": "which is that as you all know there's a certain amount of implementation to find",
    "start": "912009",
    "end": "919209"
  },
  {
    "text": "slack in the sizes of all of the arithmetic types and it's an aid to",
    "start": "919209",
    "end": "926939"
  },
  {
    "text": "portability in a lot of respects but it's also a real nuisance for people who",
    "start": "926939",
    "end": "932169"
  },
  {
    "text": "have specific range requirements they need to know how many what's the range",
    "start": "932169",
    "end": "937720"
  },
  {
    "text": "of values of an and so it became common practice early on for people to invent their own",
    "start": "937720",
    "end": "943730"
  },
  {
    "text": "fixed-width types and it was such a common thing that finally the Standards",
    "start": "943730",
    "end": "949639"
  },
  {
    "text": "Committee let's just standardize a set and this set they standardized was placed in a header file called stood in",
    "start": "949639",
    "end": "955730"
  },
  {
    "text": "th and c plus plus provides essentially",
    "start": "955730",
    "end": "962660"
  },
  {
    "text": "the same header and as common in this case the names that are in the c 99",
    "start": "962660",
    "end": "968810"
  },
  {
    "text": "version are all global names in the C++ version which is C stood int the names",
    "start": "968810",
    "end": "975769"
  },
  {
    "text": "are all members of namespace STD that's the essential difference and most of you",
    "start": "975769",
    "end": "983720"
  },
  {
    "text": "are familiar with the the int and you int underscore T names and there's the",
    "start": "983720",
    "end": "989240"
  },
  {
    "text": "set covers everything from 8 bit 16 bits 32 and 64 variations of signed and",
    "start": "989240",
    "end": "996050"
  },
  {
    "text": "unsigned here's the interesting thing these types are optional it's that if",
    "start": "996050",
    "end": "1002079"
  },
  {
    "text": "you include student dot H you are not guaranteed to get the full set you can",
    "start": "1002079",
    "end": "1010149"
  },
  {
    "text": "it's reasonable to expect to find something like you int 32 and in 32 but",
    "start": "1010149",
    "end": "1016149"
  },
  {
    "text": "you're not guaranteed to get into 8 more in 16 and the reason for that is that C",
    "start": "1016149",
    "end": "1025178"
  },
  {
    "text": "and C++ aspire to be languages that compile for a wide range of target",
    "start": "1025179",
    "end": "1030579"
  },
  {
    "text": "platforms and one platform of interest our digital signal processors which",
    "start": "1030579",
    "end": "1037630"
  },
  {
    "text": "often have word sizes which are not as",
    "start": "1037630",
    "end": "1042909"
  },
  {
    "text": "small as 8 bits or 16 bits it's not uncommon to see a DSP with a 32-bit word",
    "start": "1042909",
    "end": "1048038"
  },
  {
    "text": "size or a 64-bit word size and that's the smallest addressable unit on the",
    "start": "1048039",
    "end": "1053590"
  },
  {
    "text": "architecture by definition a byte in C and C++ is the size it's an object to",
    "start": "1053590",
    "end": "1060909"
  },
  {
    "text": "size as the smallest addressable unit it's by definition as size of 1 but it's",
    "start": "1060909",
    "end": "1066789"
  },
  {
    "text": "not guaranteed to be 8 bits it could be 16 or 32 or 24 bits",
    "start": "1066789",
    "end": "1072550"
  },
  {
    "text": "something like that so that's why this set is not guaranteed to be everywhere",
    "start": "1072550",
    "end": "1079770"
  },
  {
    "text": "now if you have an 8-bit processor which is common for most desktop workstation",
    "start": "1079770",
    "end": "1085480"
  },
  {
    "text": "you're gonna get them all but if you're concerned about writing highly portable",
    "start": "1085480",
    "end": "1090580"
  },
  {
    "text": "code this is an assumption that you can't make so what do you do well the",
    "start": "1090580",
    "end": "1097720"
  },
  {
    "text": "[Music] the header provides the in leased data",
    "start": "1097720",
    "end": "1104590"
  },
  {
    "start": "1100000",
    "end": "1100000"
  },
  {
    "text": "types and just out of curiosity how many of you have seen these before only a",
    "start": "1104590",
    "end": "1110200"
  },
  {
    "text": "small number well here there's something new you just learned which is that there",
    "start": "1110200",
    "end": "1115900"
  },
  {
    "text": "are these types at least eight at least sixteen at least 32 and 64 and what this",
    "start": "1115900",
    "end": "1122500"
  },
  {
    "text": "is you use these when you say I only need to represent in bits but I'll take",
    "start": "1122500",
    "end": "1129820"
  },
  {
    "text": "the smallest thing that will hold that so that if you you don't need it to be",
    "start": "1129820",
    "end": "1137110"
  },
  {
    "text": "exactly 8 bits what you do is you say oh I want at least 8 and you might get 16",
    "start": "1137110",
    "end": "1143230"
  },
  {
    "text": "or 32 bits allocated to the storage unit but you'll get 8 that you can use now",
    "start": "1143230",
    "end": "1150340"
  },
  {
    "text": "the one thing though is you're not guaranteed when you use these types that the arithmetic that you use on those",
    "start": "1150340",
    "end": "1156520"
  },
  {
    "text": "will behave exactly the same as the exact width types because when there's",
    "start": "1156520",
    "end": "1163110"
  },
  {
    "text": "overflows it'll actually propagate into the higher order bits that you didn't",
    "start": "1163110",
    "end": "1168820"
  },
  {
    "text": "ask for so you do have to understand that that's what you're getting you're",
    "start": "1168820",
    "end": "1174070"
  },
  {
    "text": "not getting something that's a larger allocation with the exact same behavior is the exact width type you're just",
    "start": "1174070",
    "end": "1181150"
  },
  {
    "text": "getting a compromise that you then have to program carefully but it does give",
    "start": "1181150",
    "end": "1187960"
  },
  {
    "text": "you the ability to write it gives you a slightly greater chance of writing standard portable code to do this and",
    "start": "1187960",
    "end": "1196410"
  },
  {
    "text": "these types are required they are not optional you're guaranteed that they will be in the header the other set of",
    "start": "1196410",
    "end": "1204400"
  },
  {
    "start": "1204000",
    "end": "1204000"
  },
  {
    "text": "type deaths that - this is inte fast n or you inte fast",
    "start": "1204400",
    "end": "1212140"
  },
  {
    "text": "ed and what does this represent this says I would like to do arithmetic in n bits and I would like it to be",
    "start": "1212140",
    "end": "1219519"
  },
  {
    "text": "represented in the storage unit in which it will execute the fastest said well",
    "start": "1219519",
    "end": "1224980"
  },
  {
    "text": "why isn't why is an in fast eight exactly eight well classic example is",
    "start": "1224980",
    "end": "1231220"
  },
  {
    "text": "the RISC processors like the classic ARM architecture they have a decided bias",
    "start": "1231220",
    "end": "1239409"
  },
  {
    "text": "toward 32-bit arithmetic if you declare entities which are 8 bits what the code",
    "start": "1239409",
    "end": "1246820"
  },
  {
    "text": "wants to do is take the 8 bits convert it into a 32-bit register which requires a movement a sign extend and does the",
    "start": "1246820",
    "end": "1254260"
  },
  {
    "text": "arithmetic in that format and then stores it back into exactly 8 bits by",
    "start": "1254260",
    "end": "1260049"
  },
  {
    "text": "chopping it down and you can easily do experiments with compilers on that kind",
    "start": "1260049",
    "end": "1266110"
  },
  {
    "text": "of a target and find that choosing the exact width type actually incurs a performance penalty for certain kinds of",
    "start": "1266110",
    "end": "1273460"
  },
  {
    "text": "arithmetic and that if you say I want the it fast 8 version it'll just give you a 32-bit entity so I'll store that",
    "start": "1273460",
    "end": "1280510"
  },
  {
    "text": "and you'll find that you don't pay the penalty for the sign for the expansion",
    "start": "1280510",
    "end": "1286360"
  },
  {
    "text": "and contraction of the data type getting it into the exact width size so this is",
    "start": "1286360",
    "end": "1291730"
  },
  {
    "text": "often or potentially a good choice for things like a loop control variable where you know that the index value is",
    "start": "1291730",
    "end": "1300399"
  },
  {
    "text": "still in a limited range but you say but I want it to run fast you know it's it",
    "start": "1300399",
    "end": "1305440"
  },
  {
    "text": "would be inappropriate though to use these things for structures in which you have to have precise storage layout yeah",
    "start": "1305440",
    "end": "1314289"
  },
  {
    "text": "and these things exist in both C and C++ and more or less the same form other",
    "start": "1314289",
    "end": "1321159"
  },
  {
    "start": "1320000",
    "end": "1320000"
  },
  {
    "text": "extended integer types there's an int Max and a you ain't Max and this is",
    "start": "1321159",
    "end": "1326320"
  },
  {
    "text": "saying I would like an integer that will hold the largest possible value whatever",
    "start": "1326320",
    "end": "1332320"
  },
  {
    "text": "this architecture will deal with you say no what isn't that long long int and unsigned long long no not necessarily",
    "start": "1332320",
    "end": "1339760"
  },
  {
    "text": "because it could be on a given architecture that long long integer is",
    "start": "1339760",
    "end": "1345090"
  },
  {
    "text": "64 bits but there is a an underscore underscore huge int which is 128 bits on",
    "start": "1345090",
    "end": "1353500"
  },
  {
    "text": "that platform and each since that's not standard each",
    "start": "1353500",
    "end": "1359760"
  },
  {
    "text": "compiler might give that large integer type some other name where they might",
    "start": "1359760",
    "end": "1366550"
  },
  {
    "text": "support long long long end which is a non-standard datatype and this is a portable way of",
    "start": "1366550",
    "end": "1373390"
  },
  {
    "text": "saying whatever that integer type is I want it in Max and you in max",
    "start": "1373390",
    "end": "1378720"
  },
  {
    "text": "another one is input or you nth putter and this is I would like to have an",
    "start": "1378720",
    "end": "1384520"
  },
  {
    "text": "integer which is big enough to store all the bits in a pointer without losing",
    "start": "1384520",
    "end": "1391690"
  },
  {
    "text": "information sometimes hopefully not very",
    "start": "1391690",
    "end": "1396730"
  },
  {
    "text": "often you need to be able to do arithmetic other than just adding and",
    "start": "1396730",
    "end": "1402340"
  },
  {
    "text": "subtracting on a pointer you want to be able to do operations like divides or",
    "start": "1402340",
    "end": "1407410"
  },
  {
    "text": "multiplies because you're doing some hashing or something like that on a pointer value and you can't do that",
    "start": "1407410",
    "end": "1415270"
  },
  {
    "text": "natively on pointers pointers all you can do is that and subtract so you can",
    "start": "1415270",
    "end": "1421000"
  },
  {
    "text": "you say I want to convert it to an integer what is the appropriate integer type that I can convert it to without",
    "start": "1421000",
    "end": "1427030"
  },
  {
    "text": "losing information the answer is its input her or you input her now this is",
    "start": "1427030",
    "end": "1434530"
  },
  {
    "text": "an optional type and that's because there may not be an architectural guarantee that I mean if it turns out",
    "start": "1434530",
    "end": "1442690"
  },
  {
    "text": "for example that the size of a data point or a void star is larger than the",
    "start": "1442690",
    "end": "1448420"
  },
  {
    "text": "size of int max then there is no input or you input her",
    "start": "1448420",
    "end": "1454710"
  },
  {
    "text": "right there's no integer big enough to hold a pointer value without losing data",
    "start": "1454710",
    "end": "1461639"
  },
  {
    "text": "but pardon I'm not oh I can't name one",
    "start": "1462039",
    "end": "1468590"
  },
  {
    "text": "but I don't think the Standards Committee did this simply because it was",
    "start": "1468590",
    "end": "1475429"
  },
  {
    "text": "a hypothetical I think I suspect that such architectures do exist okay",
    "start": "1475429",
    "end": "1484870"
  },
  {
    "text": "another feature is underscored func underscore and this is the way that you",
    "start": "1484870",
    "end": "1493700"
  },
  {
    "text": "can ask at compile time what's the name of the function that I'm currently compiling this is useful for doing",
    "start": "1493700",
    "end": "1500090"
  },
  {
    "text": "tracing and error messages and it's not a macro it's actually an implicitly defined local object right there in the",
    "start": "1500090",
    "end": "1508370"
  },
  {
    "text": "middle of the slide it shows you what you can expect the definition for underscore underscore func underscore",
    "start": "1508370",
    "end": "1515659"
  },
  {
    "text": "underscore to look like it's actually a statically allocated array of characters initialized with a string literal whose",
    "start": "1515659",
    "end": "1523190"
  },
  {
    "text": "value is the name of the function and this is if if accessed this will be",
    "start": "1523190",
    "end": "1530270"
  },
  {
    "text": "defined for each function that use it that refers to double underscore func now you can only do this inside the body",
    "start": "1530270",
    "end": "1537440"
  },
  {
    "text": "of a function you can't refer to this in other scopes and here would be a use for",
    "start": "1537440",
    "end": "1544669"
  },
  {
    "text": "it it's for example you could define macros that support doing runtime tracing of",
    "start": "1544669",
    "end": "1551740"
  },
  {
    "text": "each time you enter and leave a function and what it does is it simply does",
    "start": "1551740",
    "end": "1557570"
  },
  {
    "text": "prints out a message that says I'm entering this function with this name and you can just put the enter and leave",
    "start": "1557570",
    "end": "1564580"
  },
  {
    "text": "macro calls inside the body of a function like foo or bar and when you",
    "start": "1564580",
    "end": "1571010"
  },
  {
    "text": "run the program you see a trace you probably want to make this conditional",
    "start": "1571010",
    "end": "1577059"
  },
  {
    "text": "but yes oh I think you could use string",
    "start": "1577059",
    "end": "1586840"
  },
  {
    "text": "concatenate oh I'm sorry funk is not a macro so I yeah pardon",
    "start": "1586840",
    "end": "1594580"
  },
  {
    "text": "yes it's actually the name of an object so you would have to rap funk in another",
    "start": "1594580",
    "end": "1599920"
  },
  {
    "text": "macro to get string key cat and by the time you get done with that you'd say okay it's not worth the effort okay just",
    "start": "1599920",
    "end": "1615750"
  },
  {
    "text": "okay what's next relax declaration ordering this one was",
    "start": "1619500",
    "end": "1625120"
  },
  {
    "start": "1621000",
    "end": "1621000"
  },
  {
    "text": "a no-brainer originally c90 had the old-style where all declarations had to",
    "start": "1625120",
    "end": "1631570"
  },
  {
    "text": "be at the beginning of a block they are syntactically they treated declarations and statements as distinct things C++",
    "start": "1631570",
    "end": "1638559"
  },
  {
    "text": "this was introduced because it allows you to practice the good habit of",
    "start": "1638559",
    "end": "1645850"
  },
  {
    "text": "delaying the declaration of an object until you're ready to initialize it and so C language said hey there's really no",
    "start": "1645850",
    "end": "1655120"
  },
  {
    "text": "reason to continue that old rigid style let's just borrow that idea and and then",
    "start": "1655120",
    "end": "1663760"
  },
  {
    "text": "it followed that it made sense to do this for for loops as well the old C 90 style was again to put the Declaration",
    "start": "1663760",
    "end": "1671500"
  },
  {
    "text": "of for loop control variables at the beginning of a block and then initialize them that way and now C 90 uses the C++",
    "start": "1671500",
    "end": "1680470"
  },
  {
    "text": "approach with the same modern scope rules which is that the scope of a loop",
    "start": "1680470",
    "end": "1686080"
  },
  {
    "text": "control variable is it ends with the close curly brace it ends with the body",
    "start": "1686080",
    "end": "1691750"
  },
  {
    "text": "of the controlled statement and so",
    "start": "1691750",
    "end": "1696790"
  },
  {
    "text": "that's that's just the same as C++ inlining is also a feature that c 99",
    "start": "1696790",
    "end": "1706690"
  },
  {
    "text": "borrowed from c++ the classic example is you know doing something like that you",
    "start": "1706690",
    "end": "1712059"
  },
  {
    "text": "want to test is and even integer but that's not a self-evident computation I mean it's not",
    "start": "1712059",
    "end": "1719170"
  },
  {
    "text": "too hard to reverse-engineer it good habit would be to give it a name but you",
    "start": "1719170",
    "end": "1724450"
  },
  {
    "text": "don't want to pay a price for that you'd like to get the same code quality there all sorts of justifications for wanting",
    "start": "1724450",
    "end": "1731110"
  },
  {
    "text": "to do inlining and the traditional way of doing this in C was to use macros",
    "start": "1731110",
    "end": "1736740"
  },
  {
    "text": "which had a number of negative effects",
    "start": "1736740",
    "end": "1741760"
  },
  {
    "text": "one of the principal negative effects was that macro calls don't behave",
    "start": "1741760",
    "end": "1747400"
  },
  {
    "text": "exactly like function calls in that the argument if the arguments to the macro",
    "start": "1747400",
    "end": "1753880"
  },
  {
    "text": "call themselves have side-effects like pre and post increments and the",
    "start": "1753880",
    "end": "1759240"
  },
  {
    "text": "expression that represented the argument value was referenced more than once in",
    "start": "1759240",
    "end": "1764470"
  },
  {
    "text": "the body of the macro then something like star P plus plus would be applied",
    "start": "1764470",
    "end": "1769480"
  },
  {
    "text": "more than once in that execution and you would not get the same computed value as",
    "start": "1769480",
    "end": "1774820"
  },
  {
    "text": "if you had used the function for doing that and so inlining has the nice",
    "start": "1774820",
    "end": "1781150"
  },
  {
    "text": "property that when you define a function",
    "start": "1781150",
    "end": "1786910"
  },
  {
    "text": "as an inline it has the same semantics as a non inline function in a couple of",
    "start": "1786910",
    "end": "1794830"
  },
  {
    "text": "ways interestingly inline in c99 is not underscore capital",
    "start": "1794830",
    "end": "1800440"
  },
  {
    "text": "inline it's inline the same way it is in C++ and I'm not quite sure the rationale",
    "start": "1800440",
    "end": "1807910"
  },
  {
    "text": "for that it's interesting to me that it wasn't done the way the others were but",
    "start": "1807910",
    "end": "1813760"
  },
  {
    "text": "I double-checked it it is a keyword and",
    "start": "1813760",
    "end": "1818830"
  },
  {
    "text": "so what happens is as you well know the within line calls basically it takes the",
    "start": "1818830",
    "end": "1825520"
  },
  {
    "text": "body of the function and substitutes it at the point of the call but it's not",
    "start": "1825520",
    "end": "1830980"
  },
  {
    "text": "just a textual substitution the way a macro is it's a what happens is it will",
    "start": "1830980",
    "end": "1838240"
  },
  {
    "text": "do what it has to do in order to guarantee that the function still has the inline function call has functioned",
    "start": "1838240",
    "end": "1845170"
  },
  {
    "text": "like semantics so in the case of something like calling the max value with star P plus plus star Q plus plus",
    "start": "1845170",
    "end": "1853120"
  },
  {
    "text": "we want to make sure that the side effect of the plus plus is don't only done once so the a compiler would",
    "start": "1853120",
    "end": "1860230"
  },
  {
    "text": "guarantee that it would you know call evaluate star P plus plus and capture",
    "start": "1860230",
    "end": "1865690"
  },
  {
    "text": "that value in a temporary a CPU register and it would do that for both star P",
    "start": "1865690",
    "end": "1872140"
  },
  {
    "text": "plus plus and star Q plus plus and then use those in the evaluation of the comparison expression so that that's one",
    "start": "1872140",
    "end": "1881200"
  },
  {
    "text": "of the big improvements of inlining over over macros the other one is that you",
    "start": "1881200",
    "end": "1887110"
  },
  {
    "text": "can take the address of an inline function inline functions are functions",
    "start": "1887110",
    "end": "1893620"
  },
  {
    "text": "and you can take the address of a function that's not net well you can do it even if it's inline",
    "start": "1893620",
    "end": "1899100"
  },
  {
    "text": "then you've ever done that just out of curiosity how many of you knew you could",
    "start": "1899100",
    "end": "1904870"
  },
  {
    "text": "do that this is this is behavior in C++ as well so this is nothing different and",
    "start": "1904870",
    "end": "1912789"
  },
  {
    "text": "so the question is what happens when you",
    "start": "1912789",
    "end": "1920039"
  },
  {
    "text": "take the address and the answer is it generates a non inline copy of an inline",
    "start": "1920070",
    "end": "1925960"
  },
  {
    "text": "function now it doesn't turn all uses of the function into a non inline function",
    "start": "1925960",
    "end": "1932590"
  },
  {
    "text": "it only happens when the call occurs through the pointer in the other",
    "start": "1932590",
    "end": "1938080"
  },
  {
    "text": "situations the compiler is still going to try to evaluate the the function call",
    "start": "1938080",
    "end": "1947230"
  },
  {
    "text": "as an inline yes",
    "start": "1947230",
    "end": "1951809"
  },
  {
    "text": "the question is how do what happens in multiple compilation units I'm going to answer that question in a slide or two",
    "start": "1953850",
    "end": "1960310"
  },
  {
    "text": "that's a good question so let's just talk about PAC how",
    "start": "1960310",
    "end": "1968350"
  },
  {
    "text": "inlining effects packaging typically when functions are not in lined by the",
    "start": "1968350",
    "end": "1974890"
  },
  {
    "text": "way the default I talked about this in my lecture yesterday with having to do with storage duration and linkage if you",
    "start": "1974890",
    "end": "1982750"
  },
  {
    "text": "if I'm telling you anything here which doesn't quite sit right go watch the other talk when the video comes out the",
    "start": "1982750",
    "end": "1989980"
  },
  {
    "text": "typical way that you package non inline functions is that you put function",
    "start": "1989980",
    "end": "1995020"
  },
  {
    "text": "declarations in a header file and you put the corresponding function definition in a dot C or in C++ at CPP",
    "start": "1995020",
    "end": "2002340"
  },
  {
    "text": "file by default these functions have external linkage which means that they",
    "start": "2002340",
    "end": "2007470"
  },
  {
    "text": "can be used for communication from one separately compiled translation unit to",
    "start": "2007470",
    "end": "2013620"
  },
  {
    "text": "another if you were to place the entire",
    "start": "2013620",
    "end": "2019170"
  },
  {
    "text": "function definition in a header file and include that header in more than one place then you would have problems not",
    "start": "2019170",
    "end": "2027210"
  },
  {
    "text": "at compile time but at link time because the compiler would observe oh I'm not",
    "start": "2027210",
    "end": "2032220"
  },
  {
    "text": "the compiler I misspoke the linker would see hey that same function is defined in",
    "start": "2032220",
    "end": "2037560"
  },
  {
    "text": "more than one object file and what you would get is a link error which says the",
    "start": "2037560",
    "end": "2042690"
  },
  {
    "text": "symbol is multiply defined well that's expected behavior however with inline",
    "start": "2042690",
    "end": "2048240"
  },
  {
    "start": "2043000",
    "end": "2043000"
  },
  {
    "text": "functions you do go ahead and put the DEF not just the Declaration but you put",
    "start": "2048240",
    "end": "2053700"
  },
  {
    "text": "the definition in the header file now if",
    "start": "2053700",
    "end": "2061679"
  },
  {
    "text": "the function is never called in a way that forces the compiler to generate a",
    "start": "2061679",
    "end": "2067620"
  },
  {
    "text": "non inline copy all that's going to happen is the compiler uses that definition at the point of each call to",
    "start": "2067620",
    "end": "2074820"
  },
  {
    "text": "simply substitute the body no harm done but the question is what happens if for",
    "start": "2074820",
    "end": "2083460"
  },
  {
    "text": "example two separate translation units decide to take the address of that",
    "start": "2083460",
    "end": "2089579"
  },
  {
    "text": "function and the compiler says oh I got to generate a non inline call how many",
    "start": "2089579",
    "end": "2096690"
  },
  {
    "text": "copies of the function am I going to wind up with am I going to wind up with a copy in each translation unit and the",
    "start": "2096690",
    "end": "2102299"
  },
  {
    "text": "answer in both C and C++ says you still wind up with only one non inline copy",
    "start": "2102299",
    "end": "2108119"
  },
  {
    "text": "for the entire program the official terminology we say that that that non",
    "start": "2108119",
    "end": "2114059"
  },
  {
    "text": "inline copy has external linkage and that all no matter where the call takes",
    "start": "2114059",
    "end": "2120359"
  },
  {
    "text": "place in in any translation they wind up going to one single copy it's not so the",
    "start": "2120359",
    "end": "2129240"
  },
  {
    "text": "compiler doesn't regard that as multiply defined now in C++ this is all handled",
    "start": "2129240",
    "end": "2138510"
  },
  {
    "text": "automatically basically you just go ahead and put your inline definition in",
    "start": "2138510",
    "end": "2144180"
  },
  {
    "text": "a header file and you can include that in as many separately compiled source",
    "start": "2144180",
    "end": "2150329"
  },
  {
    "text": "files to produce object modules and at linked time the linker is smart enough",
    "start": "2150329",
    "end": "2157170"
  },
  {
    "text": "to recognize that the non inline copies are permitted duplicates and it throws",
    "start": "2157170",
    "end": "2163980"
  },
  {
    "text": "away all the one and it's all done automatically but in C my understanding",
    "start": "2163980",
    "end": "2170490"
  },
  {
    "text": "is they didn't want to burden the linker with that additional smarts so you have if you think this is going to happen",
    "start": "2170490",
    "end": "2177140"
  },
  {
    "text": "this is where C and C++ treat in lines differently it's that in C what you have",
    "start": "2177140",
    "end": "2184799"
  },
  {
    "text": "to do is you have to pick the spot where you would like the non inline copy to go",
    "start": "2184799",
    "end": "2190470"
  },
  {
    "text": "if it gets used and the way you do that is in one of the dot C files you write a",
    "start": "2190470",
    "end": "2197760"
  },
  {
    "text": "declaration but not a definition for the inline function to say if an online copy",
    "start": "2197760",
    "end": "2205440"
  },
  {
    "text": "is to be generated here's where I want it to be so it's interesting it's kind",
    "start": "2205440",
    "end": "2213359"
  },
  {
    "text": "of backwards from the way you do it with non in lines which is with a non inline you put the declaration in the header in",
    "start": "2213359",
    "end": "2218880"
  },
  {
    "text": "the definition in a source file here you put the definition in the header and the declaration in the source file now and",
    "start": "2218880",
    "end": "2231570"
  },
  {
    "text": "so by the way if you want you can put the word extern on that and it's benign",
    "start": "2231570",
    "end": "2236790"
  },
  {
    "text": "it doesn't hurt so doing it either way in this dot C file would work you can",
    "start": "2236790",
    "end": "2242970"
  },
  {
    "text": "even say X turn in line if you prefer that stylistically what you can't do is just put in line by itself that will get",
    "start": "2242970",
    "end": "2251880"
  },
  {
    "text": "the compiler upset so to a large extent",
    "start": "2251880",
    "end": "2258780"
  },
  {
    "text": "in lining is the same in C and C++ with this exception now if you go ahead and",
    "start": "2258780",
    "end": "2265920"
  },
  {
    "text": "try this for example with the new compiler my experiences canoe is more permissive and you may find that you can",
    "start": "2265920",
    "end": "2273210"
  },
  {
    "text": "go ahead and get it to build without this but it is my understanding that's non-standard they're giving you C++ like",
    "start": "2273210",
    "end": "2281670"
  },
  {
    "text": "semantics in AC environment which canoe does that in a number of ways they'll",
    "start": "2281670",
    "end": "2286710"
  },
  {
    "text": "just it also you the default I believe for many new distributions is that the",
    "start": "2286710",
    "end": "2293790"
  },
  {
    "text": "new C++ compiler will throw in some C features which are not standard C++ just",
    "start": "2293790",
    "end": "2299940"
  },
  {
    "text": "because well we've got them here you can use them and you have to actually go out of your way to turn these things off if",
    "start": "2299940",
    "end": "2305730"
  },
  {
    "text": "they look carefully at the command options to say no no give me just see",
    "start": "2305730",
    "end": "2311330"
  },
  {
    "text": "don't give me C augmented with some niceties from C++ and when I was",
    "start": "2311330",
    "end": "2319170"
  },
  {
    "text": "developing the tests to verify this stuff I had to go and find those kinds of options because I would do stuff like",
    "start": "2319170",
    "end": "2325590"
  },
  {
    "text": "this and find canoe is compiling it and I don't think they're right you drill down and you find out oh they were they",
    "start": "2325590",
    "end": "2332220"
  },
  {
    "text": "were being nice to you and looking the other way while you did something that was non-standard okay another feature is",
    "start": "2332220",
    "end": "2343160"
  },
  {
    "start": "2339000",
    "end": "2339000"
  },
  {
    "text": "complex numbers the c99 added support",
    "start": "2343160",
    "end": "2349530"
  },
  {
    "text": "for comprar complex arithmetic in rectangular form so you can represent X plus y I",
    "start": "2349530",
    "end": "2356250"
  },
  {
    "text": "where I is the imaginary number they do it with an extended keyword underscore",
    "start": "2356250",
    "end": "2363270"
  },
  {
    "text": "capital C complex and you can control the precision of a complex number you can do float double long double you can",
    "start": "2363270",
    "end": "2370620"
  },
  {
    "text": "also declare in C you can have optionally you can have just imaginary",
    "start": "2370620",
    "end": "2379140"
  },
  {
    "text": "numbers in other words a representation of a number with no real part only an imaginary part now complex is required",
    "start": "2379140",
    "end": "2387120"
  },
  {
    "text": "the imaginary ones are optional not all see implement stations have to support",
    "start": "2387120",
    "end": "2394230"
  },
  {
    "text": "that now in contrast C++ doesn't have this as a built-in type it's done with a template you get a lot of the same",
    "start": "2394230",
    "end": "2401280"
  },
  {
    "text": "functionality but if you want to write code that's compatible in both languages you have to do a little bit of dancing",
    "start": "2401280",
    "end": "2408600"
  },
  {
    "text": "around you know the type names are a little different and C++ doesn't support",
    "start": "2408600",
    "end": "2414750"
  },
  {
    "text": "a purely imaginary type I'm not aware of that implementation and by the way the",
    "start": "2414750",
    "end": "2419880"
  },
  {
    "text": "just like it doesn't matter whether you say unsigned int or int unsigned it doesn't matter what the order double",
    "start": "2419880",
    "end": "2426060"
  },
  {
    "text": "complex complex double same thing it supports all the arithmetic that you",
    "start": "2426060",
    "end": "2432810"
  },
  {
    "text": "expect it to support and notice again that the type name is underscore capital",
    "start": "2432810",
    "end": "2439470"
  },
  {
    "text": "C complex so if you include the header complex dot H then you get a more",
    "start": "2439470",
    "end": "2446190"
  },
  {
    "text": "attractive spelling a lowercase C without the underscore and the constant",
    "start": "2446190",
    "end": "2453990"
  },
  {
    "text": "complex underscore I is that's the representation of the value of the",
    "start": "2453990",
    "end": "2459210"
  },
  {
    "text": "imaginary value 0 plus 1 I and then",
    "start": "2459210",
    "end": "2464520"
  },
  {
    "text": "there's also versions like that for imaginary and underscore imaginary I and",
    "start": "2464520",
    "end": "2470030"
  },
  {
    "text": "then there's also if you include complex H you also get a definition for the",
    "start": "2470030",
    "end": "2477030"
  },
  {
    "text": "symbol capital I so that's a name conflict you might want to look out for",
    "start": "2477030",
    "end": "2483350"
  },
  {
    "text": "right not a lot of us named variables or functions that way",
    "start": "2483350",
    "end": "2488470"
  },
  {
    "text": "but I could imagine that one might be used somewhere okay and of course the",
    "start": "2488470",
    "end": "2495130"
  },
  {
    "text": "it's a built-in type it has a reasonable set of conversions between the complex types and the floating types and not",
    "start": "2495130",
    "end": "2502480"
  },
  {
    "text": "surprisingly if you convert a floating point number into a complex number it",
    "start": "2502480",
    "end": "2507550"
  },
  {
    "text": "just assumes that the imaginary part is 0 if you take a complex value and convert it into a floating value it",
    "start": "2507550",
    "end": "2514780"
  },
  {
    "text": "simply truncates the imaginary part so most of this stuff does reasonably what",
    "start": "2514780",
    "end": "2520119"
  },
  {
    "text": "you expect and there are functions like C real and see a match that allow you to",
    "start": "2520119",
    "end": "2526510"
  },
  {
    "text": "extract the real and imaginary parts and they're also format well actually there",
    "start": "2526510",
    "end": "2531760"
  },
  {
    "text": "are no I don't think there's a format specifier specifically for displaying",
    "start": "2531760",
    "end": "2537089"
  },
  {
    "text": "the real and imaginary parts you have to extract the real and imaginary parts and",
    "start": "2537089",
    "end": "2543310"
  },
  {
    "text": "display them as floats ok literals let's",
    "start": "2543310",
    "end": "2549400"
  },
  {
    "start": "2547000",
    "end": "2547000"
  },
  {
    "text": "talk about those for a moment the the syntactic construct called the literal",
    "start": "2549400",
    "end": "2554410"
  },
  {
    "text": "or things like well 1 or 10 or 123 that's an integer literal quote X quote",
    "start": "2554410",
    "end": "2561220"
  },
  {
    "text": "is the character literal or a double quoted sequence is a string literal and",
    "start": "2561220",
    "end": "2567270"
  },
  {
    "text": "but if you invent a user-defined type suppose I want to come up with with a representation for rational numbers",
    "start": "2567270",
    "end": "2574150"
  },
  {
    "text": "where I store a numerator and a denominator and I'd like to have the value one half or one third you can't do",
    "start": "2574150",
    "end": "2581740"
  },
  {
    "text": "that on the fly in C 90 you actually have to make a named constant like one",
    "start": "2581740",
    "end": "2586990"
  },
  {
    "text": "half equal to and a brace initialized value and in c99",
    "start": "2586990",
    "end": "2592359"
  },
  {
    "text": "now you can do this kind of stuff on the fly with a notation as shown there in",
    "start": "2592359",
    "end": "2598060"
  },
  {
    "text": "the highlighted red where you can just put the name of the type rational in",
    "start": "2598060",
    "end": "2604000"
  },
  {
    "text": "parentheses followed by a brace enclosed in valid initial value list and this is",
    "start": "2604000",
    "end": "2611650"
  },
  {
    "text": "what's known as a compound literal and so that's an unnamed object temporary object of type rational whose",
    "start": "2611650",
    "end": "2618650"
  },
  {
    "text": "structure members are initialized with a 1 into 2 and that looks similar to",
    "start": "2618650",
    "end": "2624069"
  },
  {
    "text": "something you can do in C++ now that C++ has curly brace",
    "start": "2624069",
    "end": "2630259"
  },
  {
    "text": "initializers you can do things like it looks similar but that does that turns",
    "start": "2630259",
    "end": "2635450"
  },
  {
    "text": "out that doesn't compile a c++ c++ wants you to get rid of the parens around the type so you'd have to write it that way",
    "start": "2635450",
    "end": "2642759"
  },
  {
    "text": "so it's close but not quite the same in these two languages you can also have",
    "start": "2642759",
    "end": "2652479"
  },
  {
    "text": "on-the-fly literals of an array type so for example there I want to have an",
    "start": "2652479",
    "end": "2658219"
  },
  {
    "text": "integer array with so many elements in it you can have the essentially write a",
    "start": "2658219",
    "end": "2666200"
  },
  {
    "text": "type name int square bracket m where m is some constant value and then have a",
    "start": "2666200",
    "end": "2672319"
  },
  {
    "text": "bration that initializer and that will on the fly create an array with those elements in it and not surprisingly you",
    "start": "2672319",
    "end": "2679219"
  },
  {
    "text": "can omit from inside the square brackets the dimension and the compiler will",
    "start": "2679219",
    "end": "2684319"
  },
  {
    "text": "figure out what the dimension is based on the number of elements in the initializer list again this is similar",
    "start": "2684319",
    "end": "2691579"
  },
  {
    "text": "to something you can do in C++ but C++ doesn't like those parens around the",
    "start": "2691579",
    "end": "2697009"
  },
  {
    "text": "type what you'd have to do in C++ to do something equivalent is come up with a",
    "start": "2697009",
    "end": "2702140"
  },
  {
    "text": "named type like digits and use the name without parentheses in front of it in",
    "start": "2702140",
    "end": "2708650"
  },
  {
    "text": "front of the curly brace to initialize it list and do it that way so it's a",
    "start": "2708650",
    "end": "2715339"
  },
  {
    "text": "similar capability but not identical",
    "start": "2715339",
    "end": "2719650"
  },
  {
    "text": "okay that's compound lip designated initializers one use case for this I",
    "start": "2721029",
    "end": "2731269"
  },
  {
    "start": "2723000",
    "end": "2723000"
  },
  {
    "text": "think one of the principal motivations is that when you define unions and you",
    "start": "2731269",
    "end": "2737269"
  },
  {
    "text": "want to be able to initialize an element in the Union you in C 90 you would put",
    "start": "2737269",
    "end": "2744469"
  },
  {
    "text": "for example define a glop g1 inside the curly braces there it",
    "start": "2744469",
    "end": "2750500"
  },
  {
    "text": "would take whatever that value was and say okay that's the initial value for the first variant within the Union there",
    "start": "2750500",
    "end": "2757550"
  },
  {
    "text": "was no notation in c90 by which you could say no I don't want to initialize the int I want to initialize the double",
    "start": "2757550",
    "end": "2764930"
  },
  {
    "text": "and so in fact if you put the 12.3 there which looks like a floating point value",
    "start": "2764930",
    "end": "2770510"
  },
  {
    "text": "and you'd say okay that means I'm going to be initializing the double with that value knowing what it would do is take",
    "start": "2770510",
    "end": "2776570"
  },
  {
    "text": "that twelve point three throw away the point three turn it into an integer and use it to initialize the int member of",
    "start": "2776570",
    "end": "2785680"
  },
  {
    "text": "the float I'm sorry yeah the int member",
    "start": "2785680",
    "end": "2792110"
  },
  {
    "text": "of the glop I misspoke and in doing that you probably get a warning about a",
    "start": "2792110",
    "end": "2797420"
  },
  {
    "text": "truncation error but you're not mandated to get that warning so with designated",
    "start": "2797420",
    "end": "2802730"
  },
  {
    "text": "initializers you can put a dot and the name of the member equals and that will now you can select which member of the",
    "start": "2802730",
    "end": "2810560"
  },
  {
    "text": "Union you want to initialize that's a designated initializer and these are going to be in C++ twenty they haven't",
    "start": "2810560",
    "end": "2818450"
  },
  {
    "text": "been in C++ yet but they will be coming to a compiler near you another use for",
    "start": "2818450",
    "end": "2827150"
  },
  {
    "text": "these is suppose I have a structure type like date and a date represents in a day",
    "start": "2827150",
    "end": "2835550"
  },
  {
    "text": "a month in a year problem is that the North America at least the u.s.",
    "start": "2835550",
    "end": "2840590"
  },
  {
    "text": "conventions for the order of these things are different like so much you know the u.s. insists on doing it",
    "start": "2840590",
    "end": "2846350"
  },
  {
    "text": "differently than everybody else and so we would in the States most people would",
    "start": "2846350",
    "end": "2852530"
  },
  {
    "text": "put the month first and then the day but most of the rest of the world puts the day first and then the month and the",
    "start": "2852530",
    "end": "2858890"
  },
  {
    "text": "problem is without designated initializers you could easily get them out of order and not know that you've",
    "start": "2858890",
    "end": "2865010"
  },
  {
    "text": "done it wrong but if you use designated initializers you can have a slightly",
    "start": "2865010",
    "end": "2871700"
  },
  {
    "text": "higher assurance that you've got you put together what you want you can also use",
    "start": "2871700",
    "end": "2878450"
  },
  {
    "text": "designated initializers with a raise so for example I've got this array",
    "start": "2878450",
    "end": "2884300"
  },
  {
    "text": "with ten elements and I want it to be zeros almost everywhere except for some",
    "start": "2884300",
    "end": "2890390"
  },
  {
    "text": "values in the middle or at the end and you can just put square bracket three to",
    "start": "2890390",
    "end": "2896390"
  },
  {
    "text": "say I want the third eyelet the element with index three to be initialized with",
    "start": "2896390",
    "end": "2901400"
  },
  {
    "text": "an eight the element with index seven to be initialized with a two and everything else will be zero if it's statically",
    "start": "2901400",
    "end": "2910310"
  },
  {
    "text": "allocated oh I think it doesn't matter I have to check the rules on that but I",
    "start": "2910310",
    "end": "2917240"
  },
  {
    "text": "believe it's zeros even for an automatic object okay so here are some c99",
    "start": "2917240",
    "end": "2930110"
  },
  {
    "text": "features that are not in C++ one of them is variable-length arrays and the in C",
    "start": "2930110",
    "end": "2938960"
  },
  {
    "text": "90 and still in C++ when you declare I should say define an array object you",
    "start": "2938960",
    "end": "2945830"
  },
  {
    "text": "have to give the dimension and that dimension has to be expressed as a constant expression meaning it can be an",
    "start": "2945830",
    "end": "2952310"
  },
  {
    "text": "expression with multiple operands and operators in it as long as the whole thing can be evaluated to get a value at",
    "start": "2952310",
    "end": "2959390"
  },
  {
    "text": "compile time it can't be a runtime variable and this is a problem if you",
    "start": "2959390",
    "end": "2965000"
  },
  {
    "text": "have a function for example like this function f which wants to be able to say",
    "start": "2965000",
    "end": "2970040"
  },
  {
    "text": "well I've got a parameter to the function which represents the number of elements that I want for an array like I",
    "start": "2970040",
    "end": "2977300"
  },
  {
    "text": "wanted I want to just have a local variable of an array type with that many elements and that was not native to C 90",
    "start": "2977300",
    "end": "2984110"
  },
  {
    "text": "it's not native to C++ either so you had to do something like dynamic allocation which then of course imposes the burden",
    "start": "2984110",
    "end": "2992000"
  },
  {
    "text": "of remembering to clean up after yourself something that's easy to forget to do and so it gets even worse if you",
    "start": "2992000",
    "end": "3000100"
  },
  {
    "text": "have multi-dimensional arrays because you would have to do a more complex",
    "start": "3000100",
    "end": "3005170"
  },
  {
    "text": "computation to compute the size of the allocation plus when you go to index the",
    "start": "3005170",
    "end": "3010330"
  },
  {
    "text": "elements you can't use multiple square bracketed indices you have to have to do",
    "start": "3010330",
    "end": "3017050"
  },
  {
    "text": "the arithmetic treat it as if it's a single dimension array this was a you know a recurring",
    "start": "3017050",
    "end": "3023020"
  },
  {
    "text": "problem for people who did arithmetic on a race array elements so with",
    "start": "3023020",
    "end": "3029859"
  },
  {
    "text": "variable-length arrays you can now do this you can just declare a local variable of an array type and the",
    "start": "3029859",
    "end": "3036910"
  },
  {
    "text": "dimensions can be non constant and the compiler imposes on the runtime system",
    "start": "3036910",
    "end": "3045220"
  },
  {
    "text": "the responsibility of allocating the storage for that and deallocating it",
    "start": "3045220",
    "end": "3050430"
  },
  {
    "text": "automatically that's what's called a variable length array and I didn't look",
    "start": "3050430",
    "end": "3059170"
  },
  {
    "text": "carefully at very many implementations but these are probably not on the stack these are probably managed dynamic yes",
    "start": "3059170",
    "end": "3068700"
  },
  {
    "text": "yes mm-hmm it will crash yesterday so",
    "start": "3073200",
    "end": "3082660"
  },
  {
    "text": "yeah the implementation is not specified as to where that storage come from it's a matter of the runtime system deciding",
    "start": "3082660",
    "end": "3089740"
  },
  {
    "text": "whether it will use heap or I mean it's smart you can you can often do this stuff with stack allocation what so what",
    "start": "3089740",
    "end": "3097030"
  },
  {
    "text": "you want to do if you are going to use these things is investigate the allocation and de-allocation strategy",
    "start": "3097030",
    "end": "3104640"
  },
  {
    "text": "and the nice thing is with the VLA s you can act especially with multi-dimensional arrays you can use",
    "start": "3104640",
    "end": "3110170"
  },
  {
    "text": "multiple lis dimensioned sub scripting and it will do the correct offset computations for you okay and you can",
    "start": "3110170",
    "end": "3120550"
  },
  {
    "text": "also have fieles as parameters now don't you know they're allowed to be local",
    "start": "3120550",
    "end": "3126460"
  },
  {
    "text": "objects and they're allowed to be parameters they are not allowed to occur outside of block scope so you can't make",
    "start": "3126460",
    "end": "3134140"
  },
  {
    "text": "these things global now the other thing that happens is size of which for every",
    "start": "3134140",
    "end": "3141130"
  },
  {
    "text": "other data type is a compiled time computation sizeof becomes a run time",
    "start": "3141130",
    "end": "3146140"
  },
  {
    "text": "computation for V la's it's not it's not a constant it's not",
    "start": "3146140",
    "end": "3152580"
  },
  {
    "text": "guaranteed anymore to be a constant expression as I say VL A's can only",
    "start": "3152580",
    "end": "3157800"
  },
  {
    "text": "appear as function parameters are in a function body and they can't be externa static they can't be statically",
    "start": "3157800",
    "end": "3163380"
  },
  {
    "text": "allocated interestingly this was in the",
    "start": "3163380",
    "end": "3169500"
  },
  {
    "text": "Guddu compilers early on it's hard to find another C compiler that supports",
    "start": "3169500",
    "end": "3174900"
  },
  {
    "text": "this so much so that when C 11 came out this became did they reclassified it as",
    "start": "3174900",
    "end": "3181560"
  },
  {
    "text": "an optional feature it was kind of like a big oh never mind and in C++ it",
    "start": "3181560",
    "end": "3189300"
  },
  {
    "text": "doesn't exist the expectation is you're going to use vector now flexible array",
    "start": "3189300",
    "end": "3197220"
  },
  {
    "start": "3195000",
    "end": "3195000"
  },
  {
    "text": "members here's a use case for this suppose that it's not uncommon in",
    "start": "3197220",
    "end": "3203760"
  },
  {
    "text": "communication software for example that you have packet structures where you have a fixed size header followed by a",
    "start": "3203760",
    "end": "3209430"
  },
  {
    "text": "variable length tail and so how do you represent that well you want to be able",
    "start": "3209430",
    "end": "3214830"
  },
  {
    "text": "to have a structure which has some fixed layout header and then an array of a",
    "start": "3214830",
    "end": "3221540"
  },
  {
    "text": "variable dimension and the problem is you can't use a variable e dimension",
    "start": "3221540",
    "end": "3226800"
  },
  {
    "text": "array in this context and so the common idiom prior to c99 was to simply say",
    "start": "3226800",
    "end": "3235410"
  },
  {
    "text": "okay I'll just pick one as the dimension of that array and then I'll just allow",
    "start": "3235410",
    "end": "3242400"
  },
  {
    "text": "the fact that she doesn't do bounds checking and go ahead and allocate something bigger and pretend there's a",
    "start": "3242400",
    "end": "3249210"
  },
  {
    "text": "bigger array there now the thing is that when you do it this way you have to be",
    "start": "3249210",
    "end": "3254580"
  },
  {
    "text": "careful about how you compute the size",
    "start": "3254580",
    "end": "3259830"
  },
  {
    "text": "of the total object that you allocate because you say okay if I want to have a",
    "start": "3259830",
    "end": "3264960"
  },
  {
    "text": "packet with n bytes in the trailing portion what I'll do is I want to malloc",
    "start": "3264960",
    "end": "3271650"
  },
  {
    "text": "the size of the header plus n times the size of of data actually that should",
    "start": "3271650",
    "end": "3279690"
  },
  {
    "text": "have been a data sub 0 I think that's a type of I want the type of not",
    "start": "3279690",
    "end": "3286690"
  },
  {
    "text": "the whole right in this case the yeah so I think it should have been size of data sub 0 or it couldn't just oh no I",
    "start": "3286690",
    "end": "3294640"
  },
  {
    "text": "misspoke data is the tight data type so it's n times size of data that is correct the problem with this strategy",
    "start": "3294640",
    "end": "3302290"
  },
  {
    "text": "is drum roll yeah it's the the presence",
    "start": "3302290",
    "end": "3307480"
  },
  {
    "text": "of possible padding bytes because if the data requires alignment the compiler is",
    "start": "3307480",
    "end": "3312970"
  },
  {
    "text": "free to put padding bytes after the header before the first element in the",
    "start": "3312970",
    "end": "3319060"
  },
  {
    "text": "data portion and so what you have to do actually is compute not the size of the",
    "start": "3319060",
    "end": "3324640"
  },
  {
    "text": "header but the offset of where the data portion is and you can use the standard",
    "start": "3324640",
    "end": "3330190"
  },
  {
    "text": "offset of macro to do that so it was a trickier computation easy to make a",
    "start": "3330190",
    "end": "3336100"
  },
  {
    "text": "mistake and so the c99 solution to this is to use what's called a flexible array",
    "start": "3336100",
    "end": "3343150"
  },
  {
    "text": "member not to be confused with a VL a in which you can just use empty square brackets as the dimension of the",
    "start": "3343150",
    "end": "3352570"
  },
  {
    "text": "trailing portion of the packet and and",
    "start": "3352570",
    "end": "3358170"
  },
  {
    "text": "this is what's known as a flexible array member and so now the computation is",
    "start": "3358170",
    "end": "3364510"
  },
  {
    "text": "that the size of the packet includes any trailing padding bytes that might be there ok so that that's how you work",
    "start": "3364510",
    "end": "3375010"
  },
  {
    "start": "3375000",
    "end": "3375000"
  },
  {
    "text": "with those another feature restrict keyword restrict this is another type specifier",
    "start": "3375010",
    "end": "3381070"
  },
  {
    "text": "like Const or volatile and you see this now in the declarations of functions in",
    "start": "3381070",
    "end": "3388360"
  },
  {
    "text": "places like standard live dot H and string dot H and actually that's a",
    "start": "3388360",
    "end": "3395890"
  },
  {
    "text": "mistake up there it's not standard live dot H declares store copy its string dot H but and you strict is really intended",
    "start": "3395890",
    "end": "3406240"
  },
  {
    "text": "for the Declaration of pointer parameters that's even though it's syntactically like Const of a little it",
    "start": "3406240",
    "end": "3412690"
  },
  {
    "text": "really doesn't have any use other than for what you see there now what does this mean why is",
    "start": "3412690",
    "end": "3417760"
  },
  {
    "text": "this there it's because pointer aliasing can create problems for optimizers that",
    "start": "3417760",
    "end": "3425800"
  },
  {
    "text": "want especially on architectures that have vector operations and in order to",
    "start": "3425800",
    "end": "3431410"
  },
  {
    "text": "be able to use optimizations which might use vector processing instructions you",
    "start": "3431410",
    "end": "3437740"
  },
  {
    "text": "have to have confidence that the operands to the vector operations are non-overlapping and so essentially what",
    "start": "3437740",
    "end": "3445300"
  },
  {
    "text": "a restricted pointer means is its permission to the compiler to say go ahead and assume that this pointer is",
    "start": "3445300",
    "end": "3451840"
  },
  {
    "text": "the only pointer pointing to that entity and that you're allowed to freely",
    "start": "3451840",
    "end": "3457870"
  },
  {
    "text": "reorder operations to optimize vector operations without worrying G is the",
    "start": "3457870",
    "end": "3465070"
  },
  {
    "text": "source and the destination overlapping in which case I would care about not",
    "start": "3465070",
    "end": "3470470"
  },
  {
    "text": "reordering things it allows the greater caching and things like that and so",
    "start": "3470470",
    "end": "3478240"
  },
  {
    "text": "that's that's what restrict is used for primarily so that you'll see yeah I'm",
    "start": "3478240",
    "end": "3484090"
  },
  {
    "text": "going to wrap up here that the standard will standard definitions for these",
    "start": "3484090",
    "end": "3491050"
  },
  {
    "text": "functions now have restricts in them and now what happens is if you go ahead and",
    "start": "3491050",
    "end": "3496150"
  },
  {
    "text": "pass in operands the two overlap the behavior is undefined it's your responsibility to make sure that you've",
    "start": "3496150",
    "end": "3501820"
  },
  {
    "text": "passed in data that does satisfy the restrict constraint there are functions",
    "start": "3501820",
    "end": "3507010"
  },
  {
    "text": "like memo which don't have the restrict",
    "start": "3507010",
    "end": "3512560"
  },
  {
    "text": "there because mem move is defined to work for possibly overlapping operands let's just see if we have and so I'll",
    "start": "3512560",
    "end": "3522040"
  },
  {
    "start": "3520000",
    "end": "3520000"
  },
  {
    "text": "just mention this and wrap up at this point which is that you know that",
    "start": "3522040",
    "end": "3527400"
  },
  {
    "text": "declarations which have array parameters with an empty square bracket it's essentially just a pointer and when you",
    "start": "3527400",
    "end": "3534340"
  },
  {
    "text": "declare things which are arrays of Const or Ray's a volatile you can do them",
    "start": "3534340",
    "end": "3539590"
  },
  {
    "text": "either as pointers or square brackets square bracket at arrays the problem is",
    "start": "3539590",
    "end": "3545620"
  },
  {
    "text": "that if you have a parameter which is a Const and pointer there's no comparable there",
    "start": "3545620",
    "end": "3552730"
  },
  {
    "text": "wasn't any comparable array notation you can that do it now in c99 with putting",
    "start": "3552730",
    "end": "3557980"
  },
  {
    "text": "the Const inside the square brackets now tell you though that's not very useful",
    "start": "3557980",
    "end": "3563040"
  },
  {
    "text": "turns out that the real use for that is to be able to put the restrict in there",
    "start": "3563040",
    "end": "3568050"
  },
  {
    "text": "so be able to use array notation and say that this is an array that's restricted",
    "start": "3568050",
    "end": "3573420"
  },
  {
    "text": "okay and I think that's as far as we'll get I had a few more but I think I'll",
    "start": "3573420",
    "end": "3579160"
  },
  {
    "text": "just leave it at that because somebody else has to speak in this time slot so I hope you found this useful Thanks",
    "start": "3579160",
    "end": "3585510"
  },
  {
    "text": "[Applause]",
    "start": "3585510",
    "end": "3593669"
  }
]