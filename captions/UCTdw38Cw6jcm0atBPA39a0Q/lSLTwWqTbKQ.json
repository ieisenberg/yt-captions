[
  {
    "text": "so welcome everyone thank you so much for joining us today this is a talk called",
    "start": "7290",
    "end": "15530"
  },
  {
    "text": "taking elixir to the metal with rust my name is Sonny Skagen an elixir developer",
    "start": "15530",
    "end": "23300"
  },
  {
    "text": "also erling as well obviously but I'm really excited to talk today about this because",
    "start": "23300",
    "end": "30740"
  },
  {
    "text": "it's been something uh there's a project that I've been working on to kind of integrate the two together so that you",
    "start": "30740",
    "end": "37370"
  },
  {
    "text": "can take advantage of the wonderful things that each of these languages provide and so for those of you are not",
    "start": "37370",
    "end": "45829"
  },
  {
    "text": "familiar with elixir it's a dynamic functional language it runs on the Erlang p.m. and it's a fascinating",
    "start": "45829",
    "end": "54739"
  },
  {
    "text": "language because of the fact that it's got this Erlang VM and it has been",
    "start": "54739",
    "end": "60500"
  },
  {
    "text": "around for thirty years you know and it's been known for building scalable fault tolerant applications and so you",
    "start": "60500",
    "end": "69110"
  },
  {
    "text": "kind of have this holy trinity of these three things of concurrency fault tolerance and distribution that our",
    "start": "69110",
    "end": "76580"
  },
  {
    "text": "length provides that kind of allows you to build systems that don't go down and",
    "start": "76580",
    "end": "84250"
  },
  {
    "text": "if processes crash and things like that you will have something that actually",
    "start": "84250",
    "end": "89630"
  },
  {
    "text": "restarts these things and and allows you to keep your systems running for long",
    "start": "89630",
    "end": "95619"
  },
  {
    "text": "many many years at a time so but one thing that I think that people who",
    "start": "95619",
    "end": "101479"
  },
  {
    "text": "aren't familiar with about Erlang is that it's really an integration platform and earlier this this week Brian Hunter",
    "start": "101479",
    "end": "109070"
  },
  {
    "text": "was speaking about Interop between f-sharp and elixir and and how the",
    "start": "109070",
    "end": "114799"
  },
  {
    "text": "Erlang VM really provides a lot of ways for doing that and so you know you can",
    "start": "114799",
    "end": "120950"
  },
  {
    "text": "use things like ports which are essentially like pipes where you talk to",
    "start": "120950",
    "end": "126259"
  },
  {
    "text": "other programs via standard and standard out and you also have something called Earle interface and Earle interface is a",
    "start": "126259",
    "end": "134239"
  },
  {
    "text": "C API exposed by the Erlang VM that allows you to kind of talk to external",
    "start": "134239",
    "end": "143450"
  },
  {
    "text": "programs with erlangs distribution protocol and that opens you up to be able to do all kinds of",
    "start": "143450",
    "end": "149870"
  },
  {
    "text": "interesting things so see nodes are a version of that where you have a C",
    "start": "149870",
    "end": "155360"
  },
  {
    "text": "program that uses url' interface and so from the Erlang VM you can actually talk",
    "start": "155360",
    "end": "161690"
  },
  {
    "text": "to a c program like it would like it's actually an Earling node so really",
    "start": "161690",
    "end": "168019"
  },
  {
    "text": "interesting stuff there's also stuff like port drivers which the files like",
    "start": "168019",
    "end": "174080"
  },
  {
    "text": "if you want need to talk to the file system it goes through a port driver and so those are all implemented in C so",
    "start": "174080",
    "end": "180140"
  },
  {
    "text": "they're all kind of native functions they have you know really fast execution and stuff like that and then we also",
    "start": "180140",
    "end": "187010"
  },
  {
    "text": "have native implemented functions or NIF's for short and those simply are",
    "start": "187010",
    "end": "192849"
  },
  {
    "text": "native functions that you can call so some integration examples the mix",
    "start": "192849",
    "end": "201260"
  },
  {
    "text": "tool with elixir will use ports for instance if you have a dependency in",
    "start": "201260",
    "end": "208130"
  },
  {
    "text": "your application that uses git it will actually use the git on your system to",
    "start": "208130",
    "end": "214250"
  },
  {
    "text": "go and fetch the dependency another cool example is the eye net driver in Erlang",
    "start": "214250",
    "end": "220549"
  },
  {
    "text": "it is a port driver which allows you to do networking so TCP UDP all that kind",
    "start": "220549",
    "end": "227239"
  },
  {
    "text": "of stuff and of course it's written in C as well and then an example for as an if",
    "start": "227239",
    "end": "233269"
  },
  {
    "text": "is this library called jiffy and it's a really nice library that that does JSON",
    "start": "233269",
    "end": "239870"
  },
  {
    "text": "decoding and encoding and stuff like that and that's all implemented in C as well so this talk is going to focus on",
    "start": "239870",
    "end": "249290"
  },
  {
    "text": "writing NIF's and knits are as I said",
    "start": "249290",
    "end": "254630"
  },
  {
    "text": "before native implemented functions is the acronym and they are usually",
    "start": "254630",
    "end": "259760"
  },
  {
    "text": "implemented in C or C++ and obviously with that there's a lot of unsafe things",
    "start": "259760",
    "end": "267050"
  },
  {
    "text": "that can happen and so it is a feature that is reserved for Wizards people who know what they're doing and are going to",
    "start": "267050",
    "end": "275960"
  },
  {
    "text": "to not do you know things like null point out-of-bounds checks and stuff like that",
    "start": "275960",
    "end": "282200"
  },
  {
    "text": "and crashed crash your VM so when you write niffs it comes with this gigantic",
    "start": "282200",
    "end": "287780"
  },
  {
    "text": "warning that basically I'm not going to I'm not going to read it but it's essentially you are in the like land",
    "start": "287780",
    "end": "296210"
  },
  {
    "text": "where you have to be safe and you have to be very careful otherwise there are consequences for your actions if you",
    "start": "296210",
    "end": "303380"
  },
  {
    "text": "write an if that crashes or causes a seg fault you will crash the entire Erlang",
    "start": "303380",
    "end": "308570"
  },
  {
    "text": "virtual machine and then obviously is a big problem when you are writing fault",
    "start": "308570",
    "end": "313640"
  },
  {
    "text": "tolerant applications who you can't guarantee fault tolerance anymore because you have some C program that",
    "start": "313640",
    "end": "319820"
  },
  {
    "text": "actually takes your whole which takes your whole program down so NIF's",
    "start": "319820",
    "end": "325970"
  },
  {
    "text": "they can be called just like any other Erlang or elixir function so you have a",
    "start": "325970",
    "end": "330980"
  },
  {
    "text": "module that has functions inside of it and anytime you call a function on that",
    "start": "330980",
    "end": "337190"
  },
  {
    "text": "module that is an if then it gets the native code gets executed and so NIF's",
    "start": "337190",
    "end": "345380"
  },
  {
    "text": "live in a dynamically loaded library so I shared object or a DLL for Windows I",
    "start": "345380",
    "end": "350900"
  },
  {
    "text": "think is what that is usually I'm not familiar with Windows stuff so but NIF's",
    "start": "350900",
    "end": "358190"
  },
  {
    "text": "when the module is loaded actually ends up replacing the bytecode that would",
    "start": "358190",
    "end": "364520"
  },
  {
    "text": "normally be written in an earlier line module and replaces it with native",
    "start": "364520",
    "end": "370040"
  },
  {
    "text": "native code so the NIF functionality itself there's an API that allows you to",
    "start": "370040",
    "end": "377240"
  },
  {
    "text": "read and write Erlang terms you can have there that was like some special",
    "start": "377240",
    "end": "383380"
  },
  {
    "text": "operations for doing binaries there's also these things called resource objects that we'll talk about and it",
    "start": "383380",
    "end": "390740"
  },
  {
    "text": "also has some functions for doing threads and other concurrency features",
    "start": "390740",
    "end": "396760"
  },
  {
    "text": "so to get started if we were to kind of",
    "start": "396760",
    "end": "401810"
  },
  {
    "text": "create something like a JSON module we could have this onload module attributes",
    "start": "401810",
    "end": "410120"
  },
  {
    "text": "when Erlang loads is load this module it's going to hit this attribute here and it's going to say hey",
    "start": "410120",
    "end": "416360"
  },
  {
    "text": "I want you to call the init function when I'm when I'm loading when you're loading me and so this an it function is",
    "start": "416360",
    "end": "422330"
  },
  {
    "text": "now going to find the path to our dynamic library and then call Erlang",
    "start": "422330",
    "end": "429110"
  },
  {
    "text": "load NIF with the dynamic library and then these are the functions that you",
    "start": "429110",
    "end": "434150"
  },
  {
    "text": "would you'd put them in your module still so in code and decode but you can",
    "start": "434150",
    "end": "440389"
  },
  {
    "text": "just simply throw an error or something if it was ever to be called in the NIF is not loaded for some reason and these",
    "start": "440389",
    "end": "447949"
  },
  {
    "text": "are well actually are the functions that will be replaced by the native code so",
    "start": "447949",
    "end": "454669"
  },
  {
    "text": "why would you write an if they seem unsafe right so but really you know",
    "start": "454669",
    "end": "460699"
  },
  {
    "text": "Erlang was not designed for sheer raw CPU speed it was done designed so that",
    "start": "460699",
    "end": "467030"
  },
  {
    "text": "you could have a nice consistent run time where everything performed you know",
    "start": "467030",
    "end": "473449"
  },
  {
    "text": "pretty linearly if the more processes that are in the system you can understand how how the system's going to",
    "start": "473449",
    "end": "481190"
  },
  {
    "text": "perform at scale a lot easier and so you",
    "start": "481190",
    "end": "486979"
  },
  {
    "text": "know if you need to talk directly to hardware there's no other way to do it then to use kind of native code if you",
    "start": "486979",
    "end": "494330"
  },
  {
    "text": "have like you need to interrupt with some graphics library you'd want to do that in some native code and you know",
    "start": "494330",
    "end": "502580"
  },
  {
    "text": "maybe the functionality that you need already exists and maybe it doesn't already exist in an ER Lang or an elixir",
    "start": "502580",
    "end": "509210"
  },
  {
    "text": "library but it exists in some C library and you just want to use that functionality because rewriting it in",
    "start": "509210",
    "end": "516339"
  },
  {
    "text": "Erlang would be you know too costly or whatnot so so let's take a look at the",
    "start": "516339",
    "end": "523520"
  },
  {
    "text": "structure of an if in C generally you're going to include the Earle NIF API so",
    "start": "523520",
    "end": "531100"
  },
  {
    "text": "all that from the header file and all nips have this signature so it takes the",
    "start": "531100",
    "end": "537709"
  },
  {
    "text": "first argument is a pointer to an illness environment type it's got an",
    "start": "537709",
    "end": "544579"
  },
  {
    "text": "integer which says this is how many arguments I I take and then you have an array of of NIF",
    "start": "544579",
    "end": "552980"
  },
  {
    "text": "terms that are going to be of the length of that is going to be the count of the",
    "start": "552980",
    "end": "558590"
  },
  {
    "text": "integer of the arc C and then the function itself just needs to return an earnest term so this NIF environment is",
    "start": "558590",
    "end": "567350"
  },
  {
    "text": "essentially what what when you call an if this NIF environment is a it's",
    "start": "567350",
    "end": "573530"
  },
  {
    "text": "essentially the like the environment of the calling process and so it represents",
    "start": "573530",
    "end": "580540"
  },
  {
    "text": "the the calling process itself it's got some transient information that you would never really interact with itself",
    "start": "580540",
    "end": "587300"
  },
  {
    "text": "but it's it's an opaque type and it",
    "start": "587300",
    "end": "593300"
  },
  {
    "text": "allows you to essentially create terms and decode and encode and stuff using",
    "start": "593300",
    "end": "599450"
  },
  {
    "text": "this environment and the erlan if term is very similar to that where it's",
    "start": "599450",
    "end": "604760"
  },
  {
    "text": "opaque you can use it you pass you have to pass it in to all the API functions and you can test to see hey is this term",
    "start": "604760",
    "end": "612200"
  },
  {
    "text": "an atom or is it a is it a binary is it is it a boolean you can have just",
    "start": "612200",
    "end": "618830"
  },
  {
    "text": "different functions that will test those things and such like that and there's",
    "start": "618830",
    "end": "624350"
  },
  {
    "text": "one thing that's interesting too when you read the documentation the documentation actually talks clearly",
    "start": "624350",
    "end": "630110"
  },
  {
    "text": "about the lifetime of terms and an environment so terms cannot live longer",
    "start": "630110",
    "end": "637070"
  },
  {
    "text": "than an environment that they're that they're bound to and we'll see how that",
    "start": "637070",
    "end": "642890"
  },
  {
    "text": "plays out in rust later so the next",
    "start": "642890",
    "end": "648320"
  },
  {
    "text": "thing in an if is you're going to say hey these are the functions that I export and you provide this the first",
    "start": "648320",
    "end": "655130"
  },
  {
    "text": "thing here is you know you have a code and then which is the the Erlang",
    "start": "655130",
    "end": "661190"
  },
  {
    "text": "function name or elixir function name the arity of the function which how many arguments does it take and then it's",
    "start": "661190",
    "end": "668240"
  },
  {
    "text": "basically a pointer to a function in them in the NIF itself that it's going to call when it does it and then you",
    "start": "668240",
    "end": "674450"
  },
  {
    "text": "just simply load it with earlness in it and you can see here you pass in a",
    "start": "674450",
    "end": "680490"
  },
  {
    "text": "module name for where it's going to actually live for that code and so in",
    "start": "680490",
    "end": "688620"
  },
  {
    "text": "for all licks or modules if you're not familiar when you create a module in elixir even though I created a JSON",
    "start": "688620",
    "end": "695850"
  },
  {
    "text": "module called JSON when it actually compiles into the beam code that module name is elixir dot JSON so that's why we",
    "start": "695850",
    "end": "703290"
  },
  {
    "text": "have that there alright so but I don't know about you but I am NOT a C",
    "start": "703290",
    "end": "708570"
  },
  {
    "text": "programmer I don't know how to do any of C programs I would not trust myself if",
    "start": "708570",
    "end": "715170"
  },
  {
    "text": "my life depended on it to write a safe C program but rust is here and promises a",
    "start": "715170",
    "end": "722130"
  },
  {
    "text": "lot of great things to help us along the compiler is absolutely amazing it",
    "start": "722130",
    "end": "728160"
  },
  {
    "text": "essentially will not let you write a program that will cause dangling",
    "start": "728160",
    "end": "734040"
  },
  {
    "text": "pointers or you know unbound checks and things like that and so it's really fast",
    "start": "734040",
    "end": "740839"
  },
  {
    "text": "and it keeps you safe so it causes the",
    "start": "740839",
    "end": "746910"
  },
  {
    "text": "compiler will not let you compile a broken program essentially it doesn't",
    "start": "746910",
    "end": "752820"
  },
  {
    "text": "mean that the the logic is correct but it will at least compile and guarantee safety so so some other things that are",
    "start": "752820",
    "end": "760230"
  },
  {
    "text": "that stand out with this here this is the list on their website you know the kind of bullet points of what it does",
    "start": "760230",
    "end": "765540"
  },
  {
    "text": "and so it's guys like zero cost abstractions guarantee memory safety threads without race conditions which is",
    "start": "765540",
    "end": "772980"
  },
  {
    "text": "a great thing there's also pattern matching which is similar I mean you do we use pattern",
    "start": "772980",
    "end": "778920"
  },
  {
    "text": "matching and elixir and Erlang which is nice so let's get a nice match it has type inference as well which is good and",
    "start": "778920",
    "end": "788120"
  },
  {
    "text": "it also the the bottom one here is efficient C bindings so the Erlang NIF",
    "start": "788120",
    "end": "795029"
  },
  {
    "text": "library you know from Erlang is written in C and so that means that Russ can",
    "start": "795029",
    "end": "801360"
  },
  {
    "text": "actually be a wrapper around that and actually use use it directly and so this",
    "start": "801360",
    "end": "808350"
  },
  {
    "text": "allows us to use or niffs written in rust within our or elixir and so that brings us to this",
    "start": "808350",
    "end": "816149"
  },
  {
    "text": "project here it's called Rustler and it was started by this guy Hans Josephson",
    "start": "816149",
    "end": "823200"
  },
  {
    "text": "and just a couple months ago I went out on a journey looking to do this and I",
    "start": "823200",
    "end": "830850"
  },
  {
    "text": "found this project at the time it wasn't compiling correctly for for max and so I",
    "start": "830850",
    "end": "836850"
  },
  {
    "text": "took upon myself to make a couple pull requests to fix a few things and became a collaborator so this project is really",
    "start": "836850",
    "end": "844980"
  },
  {
    "text": "really fun and it's now allowing us to to build niffs in rust which is nice so",
    "start": "844980",
    "end": "852480"
  },
  {
    "text": "Ressler itself is you know obviously a library for writing rolling this in rust",
    "start": "852480",
    "end": "857540"
  },
  {
    "text": "but it provides facilities for generating boilerplate and things like",
    "start": "857540",
    "end": "863820"
  },
  {
    "text": "that that makes it nice to to get up and running and get started really quickly",
    "start": "863820",
    "end": "869430"
  },
  {
    "text": "so it handles encoding and decoding terms from from Erlang terms to rust",
    "start": "869430",
    "end": "876300"
  },
  {
    "text": "types and rust types back into Erlang with just a simple function call which",
    "start": "876300",
    "end": "882089"
  },
  {
    "text": "is really nice it catches any rust panics that might happen for unhandled things where you",
    "start": "882089",
    "end": "890160"
  },
  {
    "text": "actually say in the code that I don't know what to do here so I'm just going to panic if you do panic in your in your",
    "start": "890160",
    "end": "896459"
  },
  {
    "text": "Russ code it will catch those before it unwinds back into C causing a seg fault and blowing up to the M and so the goal",
    "start": "896459",
    "end": "906060"
  },
  {
    "text": "really is is that the the code that you write in a rust NIF should never crash the Erlang VM so to get started you just",
    "start": "906060",
    "end": "913529"
  },
  {
    "text": "simply create a new elixir project with mix so mix new and then your project",
    "start": "913529",
    "end": "919470"
  },
  {
    "text": "name you install or you add the rustler dependency right now this is going to be",
    "start": "919470",
    "end": "925800"
  },
  {
    "text": "the next version that's that's published 0.12 but for now what you can do is you",
    "start": "925800",
    "end": "931020"
  },
  {
    "text": "can use master you can just pass in github and the kind of user name and",
    "start": "931020",
    "end": "936899"
  },
  {
    "text": "repository there and then because this project in has both the rust code",
    "start": "936899",
    "end": "945459"
  },
  {
    "text": "and the elixir code all in one repo you can use this parse option to specify the",
    "start": "945459",
    "end": "952480"
  },
  {
    "text": "path to the to the actual directory where the elixir project is so then you",
    "start": "952480",
    "end": "958750"
  },
  {
    "text": "affect your dependencies mix a depth socket and then Ruster provides this Rustler new tasks and it'll just kind of",
    "start": "958750",
    "end": "967600"
  },
  {
    "text": "prompt you through like hey what's the name of the module and what is the name of your rust library that you want to",
    "start": "967600",
    "end": "973540"
  },
  {
    "text": "create and so in this case we have a module named JSON and I'm calling the",
    "start": "973540",
    "end": "979300"
  },
  {
    "text": "the library fast JSON and overriding the the JSON because we'll actually be using",
    "start": "979300",
    "end": "984550"
  },
  {
    "text": "a rust crate called JSON and we can't have the name closure in there or so so",
    "start": "984550",
    "end": "991060"
  },
  {
    "text": "then you just need to add the compiler the rust rustler compiler essentially is",
    "start": "991060",
    "end": "996820"
  },
  {
    "text": "a compiler that's written in in elixir that keeps track of where the files",
    "start": "996820",
    "end": "1002250"
  },
  {
    "text": "should go and invokes the the rust compiler with the right flags and things",
    "start": "1002250",
    "end": "1007709"
  },
  {
    "text": "like that so which is nice and then we just set up this option here for called",
    "start": "1007709",
    "end": "1013079"
  },
  {
    "text": "rustic crates which we call this function here and this function just sets up some",
    "start": "1013079",
    "end": "1019010"
  },
  {
    "text": "configuration for the crates themselves and that's what you call a rust library",
    "start": "1019010",
    "end": "1024209"
  },
  {
    "text": "they call it a crate so this just shows you know the path and also the mode in",
    "start": "1024209",
    "end": "1033329"
  },
  {
    "text": "which we want to invoke the rust compiler so if we're running in the like dev mode in a lick sir we'll probably",
    "start": "1033329",
    "end": "1040829"
  },
  {
    "text": "just want to compile the rust code with the debug mode so that it's a faster",
    "start": "1040829",
    "end": "1046650"
  },
  {
    "text": "compile time but if we're running in production we want to release it with the release mode so that it's better",
    "start": "1046650",
    "end": "1053490"
  },
  {
    "text": "optimized and and all that stuff but it the compiling step is takes a little bit",
    "start": "1053490",
    "end": "1058650"
  },
  {
    "text": "longer so if we go back to our code this",
    "start": "1058650",
    "end": "1064440"
  },
  {
    "text": "is what we had before and with Ressler it becomes this here so you just say use",
    "start": "1064440",
    "end": "1071570"
  },
  {
    "text": "rustler give it the name of your location and then it can go ahead and",
    "start": "1071570",
    "end": "1076620"
  },
  {
    "text": "find the crate that you intend to use you could also with with a project have",
    "start": "1076620",
    "end": "1084690"
  },
  {
    "text": "multiple crates within your project and so in that case you can also specify a crate name that you want to use and it",
    "start": "1084690",
    "end": "1091590"
  },
  {
    "text": "will go ahead and find that so you know we go from this to to this so much nicer",
    "start": "1091590",
    "end": "1099740"
  },
  {
    "text": "alright so let's take a look at some Russ code so the main files live RS and",
    "start": "1099740",
    "end": "1107850"
  },
  {
    "text": "in here we're just using extern hey I'm going to use an external library",
    "start": "1107850",
    "end": "1115640"
  },
  {
    "text": "so we're calling rustler and another one called lazy static which is for like",
    "start": "1115640",
    "end": "1120750"
  },
  {
    "text": "creating our atoms and stuff like that and right here we're using also the JSON",
    "start": "1120750",
    "end": "1126870"
  },
  {
    "text": "crate which is an external crates from from the Russ community that does JSON",
    "start": "1126870",
    "end": "1133290"
  },
  {
    "text": "parsing and and stuff like that so right here we're just taking advantage of a library that already exists I don't have",
    "start": "1133290",
    "end": "1139679"
  },
  {
    "text": "to go and write a JSON parser which is nice right here we have a couple of other modules in our project so the",
    "start": "1139679",
    "end": "1146940"
  },
  {
    "text": "decoder for calling the decoding and then we just export so we have this",
    "start": "1146940",
    "end": "1151980"
  },
  {
    "text": "macro called Wrestler export niffs and you provide the name of the module you provide the kind of exports themselves",
    "start": "1151980",
    "end": "1161309"
  },
  {
    "text": "very similar to the the scene if so we have the function in the module for your",
    "start": "1161309",
    "end": "1167370"
  },
  {
    "text": "Earling module or elixir module you have the arity and then you have the rust",
    "start": "1167370",
    "end": "1173490"
  },
  {
    "text": "function that you're going to call and then this nun down here",
    "start": "1173490",
    "end": "1179220"
  },
  {
    "text": "that is if you have additional things that you need to do when the NIF is loaded you can do it in another function",
    "start": "1179220",
    "end": "1186570"
  },
  {
    "text": "and you can provide so this nun if you're not familiar is kind of a monadic",
    "start": "1186570",
    "end": "1192570"
  },
  {
    "text": "type where it's it's an option type so it has it's either something or it's nothing so this in this case it's",
    "start": "1192570",
    "end": "1199200"
  },
  {
    "text": "nothing but if it was if we did want to provide a function we could just call some and then passing",
    "start": "1199200",
    "end": "1205210"
  },
  {
    "text": "the function that we want to call and I will see the example later on that that so the simple approach or the naive",
    "start": "1205210",
    "end": "1212890"
  },
  {
    "text": "approach is simply just use existing rust jsonparser",
    "start": "1212890",
    "end": "1218130"
  },
  {
    "text": "that we don't have to do any extra work you know we're going to take in a string or binary from from Erlang side and",
    "start": "1218130",
    "end": "1225940"
  },
  {
    "text": "we'll convert that into rust types and then we'll convert the rust types back",
    "start": "1225940",
    "end": "1231100"
  },
  {
    "text": "into Erlang terms so this is the decoder and all NIST NIF terms this is the the",
    "start": "1231100",
    "end": "1239950"
  },
  {
    "text": "decode function here is the this is the signature here so it takes the",
    "start": "1239950",
    "end": "1245230"
  },
  {
    "text": "environment right here it also takes a vector of NIF terms as arguments and",
    "start": "1245230",
    "end": "1253720"
  },
  {
    "text": "then it returns what's called an if result which of NIF terms and you'll see",
    "start": "1253720",
    "end": "1259570"
  },
  {
    "text": "these tick a things in there those represents annotations for lifetimes so",
    "start": "1259570",
    "end": "1267660"
  },
  {
    "text": "it helps the RUS compiler know that you know you know when something can outlast",
    "start": "1267660",
    "end": "1274150"
  },
  {
    "text": "the other thing and so all of these things are kind of bound to the same lifetime across the board so alright so",
    "start": "1274150",
    "end": "1282460"
  },
  {
    "text": "the next thing is we just grabbed out the first argument from the vector so we can say args 0 dot decode and that will",
    "start": "1282460",
    "end": "1290470"
  },
  {
    "text": "return us the actual binary itself and then we can use pattern matching when",
    "start": "1290470",
    "end": "1296860"
  },
  {
    "text": "we're calling this json.parse function we pass in the data and then we will",
    "start": "1296860",
    "end": "1302890"
  },
  {
    "text": "either get so it returns a result so we either get ok or an error and this is",
    "start": "1302890",
    "end": "1309760"
  },
  {
    "text": "also very very common and similar to how you use Erlang and elixir a lot of",
    "start": "1309760",
    "end": "1314890"
  },
  {
    "text": "functions will return a tuple of okay and the value or an error and the reason",
    "start": "1314890",
    "end": "1320230"
  },
  {
    "text": "and so this is actually kind of plays very well together and so if we get a",
    "start": "1320230",
    "end": "1327450"
  },
  {
    "text": "good result then we get some JSON types back and now we can call a function to",
    "start": "1327450",
    "end": "1333600"
  },
  {
    "text": "turn those JSON types into Erlang terms",
    "start": "1333600",
    "end": "1338710"
  },
  {
    "text": "and then we will just return right here will return a tuple of the atom okay and",
    "start": "1338710",
    "end": "1344760"
  },
  {
    "text": "the actual result of calling that function and that will end up being",
    "start": "1344760",
    "end": "1351490"
  },
  {
    "text": "returned as the result of the function in the case of an error we'll just return an error to pool so that JSON two",
    "start": "1351490",
    "end": "1360039"
  },
  {
    "text": "term here is just essentially a recursive function that if it has an",
    "start": "1360039",
    "end": "1365140"
  },
  {
    "text": "object or an array it recursive over all the items in in of those things and",
    "start": "1365140",
    "end": "1370559"
  },
  {
    "text": "essentially gives us one data structure back and then we can send it as the",
    "start": "1370559",
    "end": "1375610"
  },
  {
    "text": "result so and all of these are simply just calling encode on all of the",
    "start": "1375610",
    "end": "1380980"
  },
  {
    "text": "different types and turning turning the rod rust types directly into an ER Lang",
    "start": "1380980",
    "end": "1389400"
  },
  {
    "text": "term so let's time our NIF so if you get",
    "start": "1389400",
    "end": "1398220"
  },
  {
    "text": "if you if you run this on like really small inputs it's going to be fast and it's going to be performant and nice but",
    "start": "1398220",
    "end": "1406270"
  },
  {
    "text": "when you get some like big data you know you have some big JSON file this one here is like eight megabytes and you run",
    "start": "1406270",
    "end": "1414370"
  },
  {
    "text": "it and you time it then we get something like this which is really bad because it",
    "start": "1414370",
    "end": "1420190"
  },
  {
    "text": "it actually only it took almost 1.5 seconds so 1.5 seconds",
    "start": "1420190",
    "end": "1426970"
  },
  {
    "text": "of CPU of blocking the CPU blocking the scheduler in Erlang is a bad thing but",
    "start": "1426970",
    "end": "1434110"
  },
  {
    "text": "why is that so in order to really understand why that's bad let's take a",
    "start": "1434110",
    "end": "1440200"
  },
  {
    "text": "look at the warnings a little closer that you get here so a native function",
    "start": "1440200",
    "end": "1446169"
  },
  {
    "text": "doing new lengthly work it doesn't really specify which how long that is",
    "start": "1446169",
    "end": "1451480"
  },
  {
    "text": "but before before returning degrades the responsiveness of the VM and it can",
    "start": "1451480",
    "end": "1457630"
  },
  {
    "text": "cause miscellaneous strange behaviors this is actually verbatim out of the out of the docs so such strange behaviors",
    "start": "1457630",
    "end": "1464559"
  },
  {
    "text": "include but are not limited to extreme memory usage and bad load balancing between schedulers",
    "start": "1464559",
    "end": "1470460"
  },
  {
    "text": "so so again so let's take a little bit deeper dive into the Erlang VM and see",
    "start": "1470460",
    "end": "1477269"
  },
  {
    "text": "how this architecture works and why we need to be careful when we're writing this so if you have a machine and that",
    "start": "1477269",
    "end": "1484799"
  },
  {
    "text": "machine has eight cores then you have the operating system and kernel threads",
    "start": "1484799",
    "end": "1490320"
  },
  {
    "text": "on top of that and then if you start the Erlang VM you have one process one our",
    "start": "1490320",
    "end": "1496139"
  },
  {
    "text": "link process and that Erlang process VM or VM process is going to then spawn a",
    "start": "1496139",
    "end": "1502879"
  },
  {
    "text": "scheduler thread for every single core on your machine and each of these cores",
    "start": "1502879",
    "end": "1509519"
  },
  {
    "text": "now are each of these schedulers rather has what's called a run queue and it",
    "start": "1509519",
    "end": "1515309"
  },
  {
    "text": "actually in reality has more than one queue but the main one is the run queue and the run queue basically holds all of",
    "start": "1515309",
    "end": "1521669"
  },
  {
    "text": "the Erlang processes that are going to be executed and so you have a queue here",
    "start": "1521669",
    "end": "1526860"
  },
  {
    "text": "and it just pops off the head of a queue runs the bytecode that that process is",
    "start": "1526860",
    "end": "1533100"
  },
  {
    "text": "supposed to run and if it reaches some code some opcode that says hey I'm I",
    "start": "1533100",
    "end": "1539669"
  },
  {
    "text": "need to get some file i/o or I need to make a network call or I'm waiting for a",
    "start": "1539669",
    "end": "1545309"
  },
  {
    "text": "message from some other process then the Erlang VM can preempt and actually stop",
    "start": "1545309",
    "end": "1553919"
  },
  {
    "text": "executing that process and move it out into another queue until that message arrives for that process and so then it",
    "start": "1553919",
    "end": "1562470"
  },
  {
    "text": "can pop that one to the back of the queue and then pick the next one off and keep going and so it can either do that",
    "start": "1562470",
    "end": "1569610"
  },
  {
    "text": "for like if it's if it's going to do a blocking operation or it also has this",
    "start": "1569610",
    "end": "1574950"
  },
  {
    "text": "thing it has a limit of things that it can do so it can it gives each process what are called reductions and you get",
    "start": "1574950",
    "end": "1582360"
  },
  {
    "text": "2,000 reductions and then you're talking stick is taken away until the next time you're scheduled so and this essentially",
    "start": "1582360",
    "end": "1590249"
  },
  {
    "text": "a reduction is roughly equivalent to a function call it's not exact oops so one",
    "start": "1590249",
    "end": "1599759"
  },
  {
    "text": "thing that's interesting is that the schedulers actually use this thing called thread",
    "start": "1599759",
    "end": "1605020"
  },
  {
    "text": "progress and there's a really interesting article or markdown document in the the Erlang repo that you can read",
    "start": "1605020",
    "end": "1611380"
  },
  {
    "text": "here and and thread progress is quite an interesting thing instead of using you",
    "start": "1611380",
    "end": "1619030"
  },
  {
    "text": "know that while the schedulers themselves they share some data structures and so when you have shared",
    "start": "1619030",
    "end": "1625450"
  },
  {
    "text": "data you have you know definite problems of race conditions and corrupting memory and things like that so instead of",
    "start": "1625450",
    "end": "1632830"
  },
  {
    "text": "protecting them with locks or ref counts which don't scale very well",
    "start": "1632830",
    "end": "1639070"
  },
  {
    "text": "instead they actually frequently kind of give a progress report out to all of the",
    "start": "1639070",
    "end": "1644950"
  },
  {
    "text": "different schedulers and so what that does is it allows the schedulers to understand what work has been done what",
    "start": "1644950",
    "end": "1651610"
  },
  {
    "text": "data structures are still being used and when it's okay and when it's safe to actually like get rid of stuff and so if",
    "start": "1651610",
    "end": "1660580"
  },
  {
    "text": "you block the scheduler that's really really bad because now you block thread progress and it makes all of the other",
    "start": "1660580",
    "end": "1669130"
  },
  {
    "text": "schedulers wait so if you block even just one scheduler you can now cause the",
    "start": "1669130",
    "end": "1674800"
  },
  {
    "text": "other schedulers to have to wait around to ensure that memory safety is",
    "start": "1674800",
    "end": "1680410"
  },
  {
    "text": "happening within the VM and also the",
    "start": "1680410",
    "end": "1685720"
  },
  {
    "text": "another big problem is that if you block scheduler all the other processes that are in that same scheduler can't run so",
    "start": "1685720",
    "end": "1692680"
  },
  {
    "text": "an if should never take longer should never block the scheduler for for more than one millisecond is what the",
    "start": "1692680",
    "end": "1699930"
  },
  {
    "text": "documentation says now one millisecond in CPU time is like an eternity so even",
    "start": "1699930",
    "end": "1706330"
  },
  {
    "text": "that feels really really long so so when you're writing this you should also",
    "start": "1706330",
    "end": "1712450"
  },
  {
    "text": "count reductions and there's a way to do that but a lot of people don't actually",
    "start": "1712450",
    "end": "1717610"
  },
  {
    "text": "do it because it's been introduced quite recently so so one way we can count",
    "start": "1717610",
    "end": "1723310"
  },
  {
    "text": "reductions in our in our code just to like test to see how our NIF is",
    "start": "1723310",
    "end": "1728350"
  },
  {
    "text": "performing we can write this function here we just basically send send ourself",
    "start": "1728350",
    "end": "1733540"
  },
  {
    "text": "a message in the end we we get our start time we calculate we prop were responding a",
    "start": "1733540",
    "end": "1739690"
  },
  {
    "text": "new process to actually run run the calculation or run run the computation and we get the reductions the starting",
    "start": "1739690",
    "end": "1745779"
  },
  {
    "text": "reductions for that process we run the function with the data we get a time",
    "start": "1745779",
    "end": "1752080"
  },
  {
    "text": "difference we get the reductions afterwards after running it and then we",
    "start": "1752080",
    "end": "1757389"
  },
  {
    "text": "send the parent process a message that just basically shows us the time and and",
    "start": "1757389",
    "end": "1763720"
  },
  {
    "text": "and all that data there so and then we just wait for the message there the actual result here so when we do this",
    "start": "1763720",
    "end": "1770919"
  },
  {
    "text": "with our big data we can see it took two seconds we started at six reductions we",
    "start": "1770919",
    "end": "1776950"
  },
  {
    "text": "ended at sixteen reductions with a total diff of ten so we have two thousand",
    "start": "1776950",
    "end": "1782769"
  },
  {
    "text": "reductions and reductions are way that kind of helped the VM understand how much work you're doing how much time",
    "start": "1782769",
    "end": "1789249"
  },
  {
    "text": "it's going to take you and when we don't have proper reduction counting it throws",
    "start": "1789249",
    "end": "1795580"
  },
  {
    "text": "everything off and so this is this is this should be much much higher with",
    "start": "1795580",
    "end": "1800859"
  },
  {
    "text": "running running a block in the schedule for two seconds so we can do better so",
    "start": "1800859",
    "end": "1806649"
  },
  {
    "text": "one option is chunking so rather than calling an if once and waiting for the",
    "start": "1806649",
    "end": "1812049"
  },
  {
    "text": "result you can hit it once it'll turn you back a partial result you can keep",
    "start": "1812049",
    "end": "1817749"
  },
  {
    "text": "kind of chunking it and calling it recursively and then that way when you are returning on the erlang side the",
    "start": "1817749",
    "end": "1823899"
  },
  {
    "text": "Erlang scheduler now can preempt the process in the middle of what it's doing and then you get kind of much more",
    "start": "1823899",
    "end": "1831659"
  },
  {
    "text": "better behavior out of it so in order to do that though we can't use that JSON",
    "start": "1831659",
    "end": "1837399"
  },
  {
    "text": "crate so we have to actually do some work we have to build a parser so so",
    "start": "1837399",
    "end": "1844539"
  },
  {
    "text": "this this way here we're going to have to do is we're going to have to NIF's we're going to have to one that",
    "start": "1844539",
    "end": "1850080"
  },
  {
    "text": "initializes and then and then calls the second one and then can allow us to",
    "start": "1850080",
    "end": "1855789"
  },
  {
    "text": "actually call this this iterative NIF over and over and over again so what we do here is we have our decode in it and",
    "start": "1855789",
    "end": "1863379"
  },
  {
    "text": "decode it err and right here in decode we pass in the data and we pipe this",
    "start": "1863379",
    "end": "1870280"
  },
  {
    "text": "data into decode in it which then will call the NIF decode in it and it will",
    "start": "1870280",
    "end": "1877900"
  },
  {
    "text": "then internally call decode it err and when we get a result back we're going to",
    "start": "1877900",
    "end": "1884830"
  },
  {
    "text": "if we get this more tuple here we can now take the data that's returned from",
    "start": "1884830",
    "end": "1891400"
  },
  {
    "text": "that and keep chunking it over and over again in a loop and recursive loop so",
    "start": "1891400",
    "end": "1898510"
  },
  {
    "text": "this is going to require us to learn about something else though which is pretty cool it's called an if resource",
    "start": "1898510",
    "end": "1904120"
  },
  {
    "text": "object and resource objects are essentially like a safe pointer and so",
    "start": "1904120",
    "end": "1909520"
  },
  {
    "text": "it's a safe way to return pointers to native data structures within rust or or",
    "start": "1909520",
    "end": "1915370"
  },
  {
    "text": "C or whatever from anis and it can be stored it can be passed around to any it",
    "start": "1915370",
    "end": "1923320"
  },
  {
    "text": "can actually be passed from process to process it can be passed and shared amongst processes you can actually make",
    "start": "1923320",
    "end": "1929020"
  },
  {
    "text": "copies of it and things like that and so you can have multiple processes actually having the same resource which is",
    "start": "1929020",
    "end": "1935380"
  },
  {
    "text": "actually quite a interesting thing when you think of Erlang with immutability and stuff like that because now you have",
    "start": "1935380",
    "end": "1942040"
  },
  {
    "text": "this handle to something that you can actually kind of almost mutate inside the thing so and really the end result",
    "start": "1942040",
    "end": "1952900"
  },
  {
    "text": "of a resource is to pass it back into Erlang so that it can continue to be used over and over again",
    "start": "1952900",
    "end": "1958570"
  },
  {
    "text": "and a resource object is not D allocated until there's no more processes having",
    "start": "1958570",
    "end": "1963970"
  },
  {
    "text": "reference to to the to the data structure so this is going a step",
    "start": "1963970",
    "end": "1972340"
  },
  {
    "text": "further we have now a parser and a sync to store terms we have our decode in it",
    "start": "1972340",
    "end": "1979570"
  },
  {
    "text": "and it err and now we're using the sum and load now so we have a load function",
    "start": "1979570",
    "end": "1985360"
  },
  {
    "text": "where we actually need to initiate our resource object so we we have a special",
    "start": "1985360",
    "end": "1992050"
  },
  {
    "text": "struct called parser resource and we now have this allocated so that we can use",
    "start": "1992050",
    "end": "1997870"
  },
  {
    "text": "it within our nips and so decode and knit simply",
    "start": "1997870",
    "end": "2003890"
  },
  {
    "text": "we have this parser resource which holds a mutex of our parser struct and",
    "start": "2003890",
    "end": "2010240"
  },
  {
    "text": "obviously we need to have a mutex because the fact that those resources can be shared with multiple processes",
    "start": "2010240",
    "end": "2016340"
  },
  {
    "text": "and if you have two processes on different schedulers running at the same time then you have the possibility of you know data corruption things like",
    "start": "2016340",
    "end": "2023630"
  },
  {
    "text": "that so you have to be safe and careful so with decode in it we do the same",
    "start": "2023630",
    "end": "2030350"
  },
  {
    "text": "thing as before we get the source we create this resource and this I wish",
    "start": "2030350",
    "end": "2035810"
  },
  {
    "text": "rust had the pipe operator that would be really cool because then you could write this much much nicer so reading it",
    "start": "2035810",
    "end": "2042170"
  },
  {
    "text": "inside out we're creating a new parser from the source wrapping that in the",
    "start": "2042170",
    "end": "2047300"
  },
  {
    "text": "mutex putting that into the parser resource struct and then we're creating this resource self that comes from",
    "start": "2047300",
    "end": "2053600"
  },
  {
    "text": "rustler and then we create a new empty",
    "start": "2053600",
    "end": "2059030"
  },
  {
    "text": "vector and we send it in to decode it err which is that which is another miss",
    "start": "2059030",
    "end": "2065090"
  },
  {
    "text": "so what we've done here is we've set up the arguments for passing in and calling",
    "start": "2065090",
    "end": "2071060"
  },
  {
    "text": "decode it err by just essentially making them up here on our own so when this",
    "start": "2071060",
    "end": "2079340"
  },
  {
    "text": "gets called we now have a resource that we can grab we can decode that we get",
    "start": "2079340",
    "end": "2087408"
  },
  {
    "text": "our sink stack which is essentially it's a place to hold terms outside of the",
    "start": "2087409",
    "end": "2093830"
  },
  {
    "text": "parser because the parser is going to be stored in the resource and it can't have",
    "start": "2093830",
    "end": "2099860"
  },
  {
    "text": "access to terms or the environment that are going to be that are not going to",
    "start": "2099860",
    "end": "2107390"
  },
  {
    "text": "outlive the call of the NIF call so so I have to separate those and make sure that there there are two distinct places",
    "start": "2107390",
    "end": "2114670"
  },
  {
    "text": "so we create this sink so that we can stick our terms in we have to get a lock",
    "start": "2114670",
    "end": "2120680"
  },
  {
    "text": "on the mutex for the for the parser and then we use this thing called consume",
    "start": "2120680",
    "end": "2127760"
  },
  {
    "text": "time slice so consume time slice allows us to report reductions kind of to the",
    "start": "2127760",
    "end": "2134960"
  },
  {
    "text": "to the VM every time we call it the is going to tell us whether or not we're up like our times up so if it returns",
    "start": "2134960",
    "end": "2142400"
  },
  {
    "text": "false then it will go in and it will",
    "start": "2142400",
    "end": "2147740"
  },
  {
    "text": "actually parse it'll do some work so it'll call parts on the parser and if it",
    "start": "2147740",
    "end": "2153020"
  },
  {
    "text": "returns ok true then we return the results of the end of it if it returns",
    "start": "2153020",
    "end": "2159680"
  },
  {
    "text": "false that means it's not done parsing there's still more stuff to do so return continue and then if there's an error",
    "start": "2159680",
    "end": "2167030"
  },
  {
    "text": "return the error if we end up getting we're consumed time slice returns true",
    "start": "2167030",
    "end": "2173390"
  },
  {
    "text": "that means your time is up you're done you got to give over the talking stick so we return a three tuple of more and",
    "start": "2173390",
    "end": "2181599"
  },
  {
    "text": "then the the resource itself and the",
    "start": "2181599",
    "end": "2187970"
  },
  {
    "text": "current stack state of the of the sink and these are these terms that we can we",
    "start": "2187970",
    "end": "2195290"
  },
  {
    "text": "can now act and treat as an accumulator for the chunking so the result of this",
    "start": "2195290",
    "end": "2202550"
  },
  {
    "text": "is much different oops so we now have a",
    "start": "2202550",
    "end": "2208190"
  },
  {
    "text": "diff here where we actually are doing 11300 reductions which is much much better",
    "start": "2208190",
    "end": "2213830"
  },
  {
    "text": "we didn't block the scheduler and what probably didn't block scheduler but this",
    "start": "2213830",
    "end": "2220640"
  },
  {
    "text": "is definitely much more on track it still took a long time but we were a",
    "start": "2220640",
    "end": "2226099"
  },
  {
    "text": "good citizen of the beam which is nice so there's also a way that you can do",
    "start": "2226099",
    "end": "2232369"
  },
  {
    "text": "what's called rescheduling or yet they called yielding and there's a function",
    "start": "2232369",
    "end": "2237560"
  },
  {
    "text": "in the NIF API called eNOS schedule NIF but and you can if you were to combine",
    "start": "2237560",
    "end": "2244400"
  },
  {
    "text": "it with the consume time slice it allows you to instead of having to return back",
    "start": "2244400",
    "end": "2249920"
  },
  {
    "text": "to Erlang or or elixir you can simply just reschedule another niffle",
    "start": "2249920",
    "end": "2256119"
  },
  {
    "text": "internally so instead of chunking from the outside where you have to call the",
    "start": "2256119",
    "end": "2262730"
  },
  {
    "text": "NIF from Erlang over and over again you can actually do that within the nests and have the NIF rescheduled likewise so",
    "start": "2262730",
    "end": "2270380"
  },
  {
    "text": "unfortunately right now it's not available in rustler and simply because it's unsafe to do so right now one of",
    "start": "2270380",
    "end": "2278720"
  },
  {
    "text": "the goals of Rustler is to make sure that you can't do things that are unsafe and cause crashes and cause bad things",
    "start": "2278720",
    "end": "2284960"
  },
  {
    "text": "to happen and so until we can find a way to support this in rustler we've got to",
    "start": "2284960",
    "end": "2291470"
  },
  {
    "text": "kind of do some other stuff but I'm sure eventually we'll be able to get it in it's just a matter of the documentation",
    "start": "2291470",
    "end": "2298970"
  },
  {
    "text": "specifying that you have to do these things in order to do it and if you can't guarantee at compile time that you",
    "start": "2298970",
    "end": "2306200"
  },
  {
    "text": "are using it that way then we don't want to put it in a library yet so that",
    "start": "2306200",
    "end": "2312260"
  },
  {
    "text": "brings us to another option which is threaded Mis so simply you can call an",
    "start": "2312260",
    "end": "2319010"
  },
  {
    "text": "if that NIF spawns an operating system thread to do the work and once it's done it will send your process a message and",
    "start": "2319010",
    "end": "2326960"
  },
  {
    "text": "so what's cool about this is we can go back to using the JSON crate which",
    "start": "2326960",
    "end": "2333470"
  },
  {
    "text": "simplifies our code because we don't have to you know manually create a",
    "start": "2333470",
    "end": "2338780"
  },
  {
    "text": "parser that we have to maintain that's slower than the original one anyways and so this one's called decode threaded and",
    "start": "2338780",
    "end": "2347230"
  },
  {
    "text": "same as before we get the source we spawn a we call this thread spawn from",
    "start": "2347230",
    "end": "2354200"
  },
  {
    "text": "the rustler crate and it takes this this trait called a thread spawner you pass",
    "start": "2354200",
    "end": "2361100"
  },
  {
    "text": "in the caller so if you notice up at the top the NIF environment i've it's still",
    "start": "2361100",
    "end": "2368060"
  },
  {
    "text": "an if environment but I've named it caller to specify just so that we have",
    "start": "2368060",
    "end": "2373070"
  },
  {
    "text": "because we also have an invariable that's passed into this closure over",
    "start": "2373070",
    "end": "2378170"
  },
  {
    "text": "here and so to keep the two kind of distinct I use the caller as the",
    "start": "2378170",
    "end": "2386150"
  },
  {
    "text": "variable so this passes in the caller and the caller is an environment for the",
    "start": "2386150",
    "end": "2392780"
  },
  {
    "text": "calling process and we can just get the pid' or the process ID of the calling process so that we can actually send a",
    "start": "2392780",
    "end": "2399770"
  },
  {
    "text": "message to it from what's returned in in our value here so we can just call json.parse on that we",
    "start": "2399770",
    "end": "2407840"
  },
  {
    "text": "get the value that's returned there and in internally underneath it's going to send that value to the process directly",
    "start": "2407840",
    "end": "2414400"
  },
  {
    "text": "and then here we're just returning immediately after this thread spawned so",
    "start": "2414400",
    "end": "2421060"
  },
  {
    "text": "we returned back to the caller just an okay tuple to say okay I did the the",
    "start": "2421060",
    "end": "2427400"
  },
  {
    "text": "thing now you can go ahead and wait and this would be the elixir code that you would write in order to do that so you'd",
    "start": "2427400",
    "end": "2434420"
  },
  {
    "text": "have your decode you would have you'd call decode threaded and then you would",
    "start": "2434420",
    "end": "2440270"
  },
  {
    "text": "just wait in a receive block for the result if you get okay results and",
    "start": "2440270",
    "end": "2445430"
  },
  {
    "text": "you're good you return that if you can narrow return that and if it if it takes like longer than five seconds then just",
    "start": "2445430",
    "end": "2453230"
  },
  {
    "text": "throw a timeout or something all right",
    "start": "2453230",
    "end": "2460460"
  },
  {
    "text": "so another option is call is is dirtiness and dirty NIF's are a way to",
    "start": "2460460",
    "end": "2469090"
  },
  {
    "text": "basically never block the normal schedulers because you can actually",
    "start": "2469090",
    "end": "2475310"
  },
  {
    "text": "compile Erlang with this enable dirty schedulers option it's currently an",
    "start": "2475310",
    "end": "2480560"
  },
  {
    "text": "experimental feature but they are working on it with Erlang OTP 20 version 20 and it should be pretty much stable",
    "start": "2480560",
    "end": "2490580"
  },
  {
    "text": "by then I think they're going to try and make it stable so it'll it'll just be there you won't have to compile it specially which is",
    "start": "2490580",
    "end": "2496520"
  },
  {
    "text": "nice but essentially it allows you to call NIF's without worrying about",
    "start": "2496520",
    "end": "2501980"
  },
  {
    "text": "blocking the normal schedulers because in addition to the if you have an eight-core machine as an example I had",
    "start": "2501980",
    "end": "2508700"
  },
  {
    "text": "if you have an eight-core machine and then you if you have dirty schedulers enabled now you have eight more threads",
    "start": "2508700",
    "end": "2515690"
  },
  {
    "text": "that are completely separate from the normal way of scheduling processes so",
    "start": "2515690",
    "end": "2520970"
  },
  {
    "text": "normal processes are just not even scheduled on dirty schedulers it's only for niffs that are are things that are",
    "start": "2520970",
    "end": "2528080"
  },
  {
    "text": "going to could potentially take too long and block the scheduler so",
    "start": "2528080",
    "end": "2535829"
  },
  {
    "text": "dirty nips simply you can pass in a flag here call it dirty cpu so if it's a CPU",
    "start": "2535829",
    "end": "2546099"
  },
  {
    "text": "bounds kind of works then you use dirty CPU if it's an i/o bound thing that",
    "start": "2546099",
    "end": "2552130"
  },
  {
    "text": "you're doing there's dirty i/o as well so there's a couple people I have to",
    "start": "2552130",
    "end": "2558849"
  },
  {
    "text": "thank for this talk one is the creator of Rustler Hans",
    "start": "2558849",
    "end": "2564789"
  },
  {
    "text": "Josephson and also Jason Orndorff who's a good friend of mine and he's been",
    "start": "2564789",
    "end": "2570509"
  },
  {
    "text": "mentoring me and rusts he's actually currently writing the O'Reilly rust book",
    "start": "2570509",
    "end": "2576940"
  },
  {
    "text": "co-authoring for that and he's just an amazing guy both of these guys have been",
    "start": "2576940",
    "end": "2582849"
  },
  {
    "text": "really really helpful in this process and I'm really excited about what we've been doing and so with that I'm done",
    "start": "2582849",
    "end": "2592269"
  },
  {
    "text": "thank you if there's any questions I",
    "start": "2592269",
    "end": "2601029"
  },
  {
    "text": "think there's a microphone that can be passed around",
    "start": "2601029",
    "end": "2605700"
  },
  {
    "text": "so I'll ask you I'll ask you later about the safety concerns with the yields because I'm curious about that by I",
    "start": "2614650",
    "end": "2621229"
  },
  {
    "text": "suppose that's longer but a shorter question was do you get into any sort of",
    "start": "2621229",
    "end": "2627709"
  },
  {
    "text": "interesting troubles where the fact that in Erlang when you have the reference to",
    "start": "2627709",
    "end": "2633709"
  },
  {
    "text": "safe references they can be sort of copied around and stuff does it interrupt in any funny way with",
    "start": "2633709",
    "end": "2639380"
  },
  {
    "text": "the with the rust sort of ownership checking or does it what caused any",
    "start": "2639380",
    "end": "2645709"
  },
  {
    "text": "troubles there so the the resource itself is is stored in such a way that",
    "start": "2645709",
    "end": "2652190"
  },
  {
    "text": "the lifetimes it's not dependent on the lifetimes and so it can essentially be a",
    "start": "2652190",
    "end": "2661219"
  },
  {
    "text": "data structure that's in memory that's actually in the VM that's that's there and so the Erlang VM will keep keep a",
    "start": "2661219",
    "end": "2668539"
  },
  {
    "text": "hold of it inside until there's no more nothing else actually using it and",
    "start": "2668539",
    "end": "2674359"
  },
  {
    "text": "they'll just get D out D allocated so that answer your question okay",
    "start": "2674359",
    "end": "2680680"
  },
  {
    "text": "cool",
    "start": "2681170",
    "end": "2683499"
  },
  {
    "text": "so I had like two kind of minor questions on the parser was it just",
    "start": "2688900",
    "end": "2695710"
  },
  {
    "text": "mutating the sink stack when you're in it so the sink stack itself it was it's",
    "start": "2695710",
    "end": "2704200"
  },
  {
    "text": "essentially just a vector of NIF terms in rust and then when you when you",
    "start": "2704200",
    "end": "2710289"
  },
  {
    "text": "return it you actually encode it into Erlang terms and send it back to Erlang",
    "start": "2710289",
    "end": "2716849"
  },
  {
    "text": "I'll ask you I want to look at the codes in more DDS you just get a get something explained and then um I don't think the",
    "start": "2716849",
    "end": "2724599"
  },
  {
    "text": "other question needs needs asking all I'll talk about it's super unimportant cool all right anything else awesome no",
    "start": "2724599",
    "end": "2739569"
  },
  {
    "text": "thank you [Applause]",
    "start": "2739569",
    "end": "2742980"
  }
]