[
  {
    "text": "this is going to be a debugging and profiling Dartmouth core application and hopefully some of you have already",
    "start": "9480",
    "end": "16040"
  },
  {
    "text": "looked into using dotnet core at all we're using dotnet core on Linux",
    "start": "16040",
    "end": "21410"
  },
  {
    "text": "specifically and if you have you know the story is not quite what it should be",
    "start": "21410",
    "end": "26560"
  },
  {
    "text": "doing dotnet on windows for ages I've been using that net since 2002 it's it's",
    "start": "26560",
    "end": "33260"
  },
  {
    "text": "got a very large echo system of different performance tools profilers production tools there's a lot of stuff",
    "start": "33260",
    "end": "39110"
  },
  {
    "text": "built into Windows itself which has dotnet in mind or was tailored for dotnet specifically over time so it's a",
    "start": "39110",
    "end": "45830"
  },
  {
    "text": "lot easier to do this sort of thing on Windows and getting dotnet ported to a different platform is not just a matter",
    "start": "45830",
    "end": "51440"
  },
  {
    "text": "of you know running console.writeline hello world it's also a matter of this whole ecosystem of tools techniques best",
    "start": "51440",
    "end": "57920"
  },
  {
    "text": "practices for doing performance investigations for doing debugging for doing production work and most of my",
    "start": "57920",
    "end": "64250"
  },
  {
    "text": "work actually is performance investigations and production debugging stuff for customers I'm a consultant so",
    "start": "64250",
    "end": "70580"
  },
  {
    "text": "that's a large part of my work and I've been really interested in Linux and Dartmouth cordis combination and this",
    "start": "70580",
    "end": "76430"
  },
  {
    "text": "talk is kind of a set of practices a set of tools that work as they tend to say",
    "start": "76430",
    "end": "82789"
  },
  {
    "text": "conference talks are not for really learning how to do every single thing but more about what's possible so if you",
    "start": "82789",
    "end": "88399"
  },
  {
    "text": "want there's a bunch of references for you to explore I've also written a couple of blog posts about this with",
    "start": "88399",
    "end": "94549"
  },
  {
    "text": "more detailed instructions and some of this stuff keeps changing so just also that to bear in mind it's all fairly new",
    "start": "94549",
    "end": "100789"
  },
  {
    "text": "and still being changed by Microsoft and by the open-source community so my name",
    "start": "100789",
    "end": "106009"
  },
  {
    "text": "is Sasha I work for a training and consulting company back in Israel it's been quite a trip",
    "start": "106009",
    "end": "111530"
  },
  {
    "text": "here to Australia but it's I've enjoyed it really much so far my wife is also speaking at the conference we've been",
    "start": "111530",
    "end": "117920"
  },
  {
    "text": "we've turned this into a three week holiday so that was pretty awesome so again this is a talk on debugging and",
    "start": "117920",
    "end": "124850"
  },
  {
    "text": "profiling dotnet core apps on Linux and again it's it's it's worth just stopping",
    "start": "124850",
    "end": "130130"
  },
  {
    "text": "for a moment and just sort of admiring the fact we got here that we can actually run dotnet core apps on Linux",
    "start": "130130",
    "end": "135680"
  },
  {
    "text": "and we can talk about profiling them and we can talk about advanced topics related to dotnet core and Linux this is",
    "start": "135680",
    "end": "141830"
  },
  {
    "text": "pretty incredible so the five things I would like you to take away is profiling CPU activity",
    "start": "141830",
    "end": "147030"
  },
  {
    "text": "which is pretty obvious you want to make sure you're not overloading the CPU and if you are what is taking my CPU time",
    "start": "147030",
    "end": "153840"
  },
  {
    "text": "which functions which stack traces which threads we're going to talk about visualizing these stack traces for",
    "start": "153840",
    "end": "160170"
  },
  {
    "text": "example visualizing CPU activity using flame graphs which are incredibly popular on Linux less so in the windows",
    "start": "160170",
    "end": "167340"
  },
  {
    "text": "world although we are getting some traction but we'll talk about flame graphs specifically for Linux on data",
    "start": "167340",
    "end": "173040"
  },
  {
    "text": "core applications we'll talk about some Linux tracing tools which can be used with dotnet core processors as well",
    "start": "173040",
    "end": "179250"
  },
  {
    "text": "although it takes some tweaking and we'll talk about the tweaking necessary to make it work we'll talk about dotnet",
    "start": "179250",
    "end": "185250"
  },
  {
    "text": "core run time events if you're familiar with CLR etw events on windows things",
    "start": "185250",
    "end": "191610"
  },
  {
    "text": "like garbage collection events just-in-time compilation events that sort of thing that you can get out of the CLR this is also possible than Linux",
    "start": "191610",
    "end": "199680"
  },
  {
    "text": "with again some tweaking and we'll talk about LT T and G which is the Linux equivalent for etw that microsoft has",
    "start": "199680",
    "end": "206870"
  },
  {
    "text": "chosen to use and finally it will also talk about generating core dumps and again for production use on Windows",
    "start": "206870",
    "end": "213750"
  },
  {
    "text": "hopefully you are familiar with core dumps or dump files incredibly useful for any kind of post-mortem",
    "start": "213750",
    "end": "220549"
  },
  {
    "text": "investigations and production crashes memory leaks a bunch of different scenarios so these the same techniques",
    "start": "220549",
    "end": "227700"
  },
  {
    "text": "are also applicable to Linux and we'll talk about getting this stuff out of qualifier core dump files on Linux as",
    "start": "227700",
    "end": "234420"
  },
  {
    "text": "well so that's the general story I've told you this already a lot of these stuff changes I've sort of tested all of",
    "start": "234420",
    "end": "241560"
  },
  {
    "text": "these tools and scripts with Dartmouth core 1.1 and 2.0 but if something",
    "start": "241560",
    "end": "247079"
  },
  {
    "text": "doesn't work is probably my fault and you could definitely get in touch a lot",
    "start": "247079",
    "end": "252780"
  },
  {
    "text": "of this relies on scripts I kind of hacked together so it's not exactly the recommended way of doing things it's just sort of the only way of doing",
    "start": "252780",
    "end": "259979"
  },
  {
    "text": "things right now and hopefully some of these things will improve now just to draw parallels between different",
    "start": "259979",
    "end": "266610"
  },
  {
    "text": "operating systems this is a Linux talk so we'll only look at the Linux side of things but a lot of these things have",
    "start": "266610",
    "end": "272669"
  },
  {
    "text": "equivalents on other platforms so that meth core obviously runs on Windows it's a lot easier for it to run on Windows",
    "start": "272669",
    "end": "279910"
  },
  {
    "text": "Windows has for example etw which is very very powerful instrumentation framework built into the operating",
    "start": "279910",
    "end": "286180"
  },
  {
    "text": "system which can be used for CPU profiling it can be used for tracing",
    "start": "286180",
    "end": "291190"
  },
  {
    "text": "interesting static events like garbage collections JIT compilations assembly loading that sort of thing so atw",
    "start": "291190",
    "end": "298060"
  },
  {
    "text": "equivalents on linux for example would be perf and LT t and g and we'll talk",
    "start": "298060",
    "end": "303340"
  },
  {
    "text": "about both of these tools today there's also another cool thing that you can do on linux but you can't do on",
    "start": "303340",
    "end": "308650"
  },
  {
    "text": "Windows easily anyway and that's dynamic tracing we'll look into that as well just basically choosing any arbitrary",
    "start": "308650",
    "end": "315250"
  },
  {
    "text": "function and tracing its execution without having to recompile or even launch your code again so that's",
    "start": "315250",
    "end": "321190"
  },
  {
    "text": "something we can do on linux but not so easily on Windows we'll talk about dumps and again there's tools for Windows for",
    "start": "321190",
    "end": "327850"
  },
  {
    "text": "this and there's tools for Linux and Mac OS and we'll analyze dump files as well and again there's tools for Windows",
    "start": "327850",
    "end": "333520"
  },
  {
    "text": "including visual studio and there's slightly less user-friendly tools for this for other platforms so there's",
    "start": "333520",
    "end": "340450"
  },
  {
    "text": "roughly mostly equivalents for things we're going to do on all platforms our focus is Linux again if you want to",
    "start": "340450",
    "end": "348130"
  },
  {
    "text": "talk later about how to do the same things on Windows for example please feel free to reach me I'll be happy to",
    "start": "348130",
    "end": "355570"
  },
  {
    "text": "explain and show you examples one final thing before we get started with different tools and techniques for this",
    "start": "355570",
    "end": "362140"
  },
  {
    "text": "presentation is the overhead and if you're used to development time",
    "start": "362140",
    "end": "367180"
  },
  {
    "text": "profilers like the visual studio profiler or maybe the Intel VT own",
    "start": "367180",
    "end": "372640"
  },
  {
    "text": "parallel studio that sort of tools the JetBrains tools like dot trace and dot",
    "start": "372640",
    "end": "377680"
  },
  {
    "text": "memory all these development time profilers usually have an overhead which",
    "start": "377680",
    "end": "383020"
  },
  {
    "text": "is not really acceptable for production use and I would expect most people using",
    "start": "383020",
    "end": "388300"
  },
  {
    "text": "Dartmouth core on Linux to actually do a lot of their investigations on production because your development",
    "start": "388300",
    "end": "393640"
  },
  {
    "text": "environment might actually be Windows with visual studio but then you want to put your app in the Linux docker",
    "start": "393640",
    "end": "399130"
  },
  {
    "text": "container and run it there and so a lot of the investigations we'll be doing will not be using JetBrains",
    "start": "399130",
    "end": "405220"
  },
  {
    "text": "dot trace on windows it will be actual work in production on Linux and there",
    "start": "405220",
    "end": "411520"
  },
  {
    "text": "they overhead there's a lot more considerable so a lot of profilers will just tell you upfront by running",
    "start": "411520",
    "end": "417259"
  },
  {
    "text": "this profiler we will slow down your app by two thousand percent and it's sort of",
    "start": "417259",
    "end": "422900"
  },
  {
    "text": "okay for development I guess if it slows down your app by two thousand percent not so much again for production it's",
    "start": "422900",
    "end": "429740"
  },
  {
    "text": "not even very good for development time if the app takes a very long time to load now or a certain scenario takes",
    "start": "429740",
    "end": "435409"
  },
  {
    "text": "seven hours to go through but that's sort of acceptable for development not so much for production so for a lot of",
    "start": "435409",
    "end": "442159"
  },
  {
    "text": "tools we'll talk briefly about overhead and we'll even have alternatives so this one has more overhead that one has less",
    "start": "442159",
    "end": "449060"
  },
  {
    "text": "overhead but it's it's got a different set of requirements which might be harder for you to satisfy so we'll talk",
    "start": "449060",
    "end": "456169"
  },
  {
    "text": "about overhead as well now there's two major categories of tools that we'll be looking at and this",
    "start": "456169",
    "end": "462530"
  },
  {
    "text": "is not Linux specific it's just the general observation about performance investigation tools there are sampling",
    "start": "462530",
    "end": "469400"
  },
  {
    "text": "tools and tracing tools some of you might already be familiar with the terms just the brief overview sampling is for",
    "start": "469400",
    "end": "477860"
  },
  {
    "text": "events or for things that you want to monitor which happen in a very high frequency so you can't possibly record",
    "start": "477860",
    "end": "484400"
  },
  {
    "text": "or inspect every single occurrence of that thing you're monitoring a good",
    "start": "484400",
    "end": "489740"
  },
  {
    "text": "example of this is CPU instructions in many cases you want to figure out like which functions are doing a lot of CPU",
    "start": "489740",
    "end": "496580"
  },
  {
    "text": "work in your program but you can't record every single CPU instruction this",
    "start": "496580",
    "end": "501589"
  },
  {
    "text": "the processor is executing and then make a tally of which ones were more more active it's just going to slow you down",
    "start": "501589",
    "end": "508159"
  },
  {
    "text": "by not 2,000 percent probably two million percent so instead you do sampling you look at the CPU execution",
    "start": "508159",
    "end": "515779"
  },
  {
    "text": "in in certain intervals for example every certain million every million",
    "start": "515779",
    "end": "521328"
  },
  {
    "text": "clock cycles or every couple of milliseconds and then you make a tally of which functions or which threads or",
    "start": "521329",
    "end": "528290"
  },
  {
    "text": "which processes were active in many of those samples so you don't record every",
    "start": "528290",
    "end": "533449"
  },
  {
    "text": "single event you only take samples once in a while and then you try to draw conclusions and interpolate from these samples tracing",
    "start": "533449",
    "end": "541279"
  },
  {
    "text": "on the other hand means you record everything you look at every single occurrence of a an event and then again you analyze",
    "start": "541279",
    "end": "547730"
  },
  {
    "text": "post-processor to draw conclusions so tracing works for lower frequency events like disk accesses or garbage",
    "start": "547730",
    "end": "554630"
  },
  {
    "text": "collections that sort of thing which happens maybe tens or hundreds of times per second",
    "start": "554630",
    "end": "559850"
  },
  {
    "text": "sampling works for higher frequency events say millions of events per second you can no longer record every single",
    "start": "559850",
    "end": "566990"
  },
  {
    "text": "one so that's just a couple of techniques will be used so dotnet core on Linux what are the different tracing",
    "start": "566990",
    "end": "574340"
  },
  {
    "text": "components were different moving pieces that we can put together and get extract information from so some of these are",
    "start": "574340",
    "end": "581150"
  },
  {
    "text": "not really a dotnet core specific if you have a Java app running on Linux if you have a C++ app running on Linux there's",
    "start": "581150",
    "end": "588080"
  },
  {
    "text": "a lot of stuff from the core operating system that you could already be using so looking down at the bottom of this",
    "start": "588080",
    "end": "594890"
  },
  {
    "text": "diagram the CPU itself and this is not even OS specific that's also available on Windows the CPU itself has a bunch of",
    "start": "594890",
    "end": "602630"
  },
  {
    "text": "performance monitoring events that we could sample and record and that helps with identifying heavy CPU consumers it",
    "start": "602630",
    "end": "610310"
  },
  {
    "text": "helps with stuff like cache misses branch mispredictions various kind of",
    "start": "610310",
    "end": "616370"
  },
  {
    "text": "pipeline events inside the processor so if you're optimizing your algorithms for CPU performance the CPU itself has a",
    "start": "616370",
    "end": "623900"
  },
  {
    "text": "bunch of performance information and Linux makes it very easy with freely available tools to extract that",
    "start": "623900",
    "end": "630170"
  },
  {
    "text": "information and display it on windows by the way we have the Intel tools mostly for this and they're not really free",
    "start": "630170",
    "end": "637190"
  },
  {
    "text": "quite the opposite of free on top of the CPU we have the operating system kernel",
    "start": "637190",
    "end": "642650"
  },
  {
    "text": "which has a bunch of interesting events as well there's two kinds of events so one on linux is called a category of",
    "start": "642650",
    "end": "649670"
  },
  {
    "text": "events is called software events and these are like low-level OS things such as page faults so when you access a",
    "start": "649670",
    "end": "657050"
  },
  {
    "text": "memory location which is not in main memory or core migrations when you have a thread migrating from one core to",
    "start": "657050",
    "end": "663290"
  },
  {
    "text": "another the scheduler moving a thread between course so that sort of thing can be traced on the kernel level there's",
    "start": "663290",
    "end": "669950"
  },
  {
    "text": "also several hundreds of static trace points in the kernel as well in the",
    "start": "669950",
    "end": "676100"
  },
  {
    "text": "block i/o subsystem so stuff like writing to quitting from desk networking events",
    "start": "676100",
    "end": "682100"
  },
  {
    "text": "like a packet being received for a packet being sent there is events and the scheduler there's events and the",
    "start": "682100",
    "end": "688189"
  },
  {
    "text": "interrupt processing layer so everywhere across the Linux kernel there's hundreds of static trace points that we could",
    "start": "688189",
    "end": "694550"
  },
  {
    "text": "trace and again for our dotnet apps it might be relevant for our Java apps as well for Python as well so that's not",
    "start": "694550",
    "end": "700459"
  },
  {
    "text": "really special specific for dotnet core in userspace again there is a set of",
    "start": "700459",
    "end": "705920"
  },
  {
    "text": "libraries which are not dotnet specific such as the Lib C library which is the C",
    "start": "705920",
    "end": "711230"
  },
  {
    "text": "runtime C++ runtime the P thread library a bunch of other libraries provided by",
    "start": "711230",
    "end": "717679"
  },
  {
    "text": "Linux provided by your Linux distribution which again have some tracing data which have some tracing",
    "start": "717679",
    "end": "723709"
  },
  {
    "text": "events inside that we can record and these vary across the different libraries so Lib C has a lot of those",
    "start": "723709",
    "end": "731119"
  },
  {
    "text": "leap P thread has a lot of those other libraries might only have a handful but there's a lot of different things in",
    "start": "731119",
    "end": "738050"
  },
  {
    "text": "these libraries that again we could be tracing so again drawing the parallel to Windows that's kind of like etw events",
    "start": "738050",
    "end": "744649"
  },
  {
    "text": "which you might have embedded in user space which you might have embedded in Windows itself in the kernel finally",
    "start": "744649",
    "end": "750799"
  },
  {
    "text": "dotnet core itself has two major components so we have the core CLR which",
    "start": "750799",
    "end": "755990"
  },
  {
    "text": "is written in C++ and that has a bunch of interesting events which are also available on Windows it's kind of a",
    "start": "755990",
    "end": "762740"
  },
  {
    "text": "cross-platform eventing implementation so if you have a garbage collection started event on linux you also have a",
    "start": "762740",
    "end": "769160"
  },
  {
    "text": "similar event on Windows you also have a similar event on Mac OS you just have to use different tools to record them but",
    "start": "769160",
    "end": "775999"
  },
  {
    "text": "the event itself the payload will be the same so there's a bunch of these events which we'll look at and the Linux tool",
    "start": "775999",
    "end": "783199"
  },
  {
    "text": "for recording these events is called ltte and gee that's a decision Microsoft",
    "start": "783199",
    "end": "788540"
  },
  {
    "text": "made so they could have chosen from a variety of different tracing frameworks and they chose to use LT T and G for a",
    "start": "788540",
    "end": "794329"
  },
  {
    "text": "bunch of reasons we'll look at LT TNG later it stands for Linux tracing toolkit next generation so it's it's a",
    "start": "794329",
    "end": "801559"
  },
  {
    "text": "fairly modern library it's a fairly modern toolset it's it's pretty nice and clean record high frequency events using",
    "start": "801559",
    "end": "808610"
  },
  {
    "text": "that and finally your daughter core application itself can also write custom events so kind of like log",
    "start": "808610",
    "end": "816320"
  },
  {
    "text": "messages you might be familiar again on Windows with the event source class which is part of etw it writes out etw",
    "start": "816320",
    "end": "823040"
  },
  {
    "text": "events so the same class is also available on linux and you can use it to omit tracing messages at runtime enable",
    "start": "823040",
    "end": "830720"
  },
  {
    "text": "them disable them record them or just ignore them whenever you want so that's",
    "start": "830720",
    "end": "835730"
  },
  {
    "text": "kind of the different pieces of tracing that we can record so the first thing",
    "start": "835730",
    "end": "845570"
  },
  {
    "text": "we're going to be talking about is recording CPU samples so taking a dotted quarter plication which burns a lot of",
    "start": "845570",
    "end": "852350"
  },
  {
    "text": "CPU and trying to figure out where which functions are most active which functions are taking up lots of CPU time",
    "start": "852350",
    "end": "858800"
  },
  {
    "text": "and the official story for this which I want to share with you first and that's not what we're going to be using is a",
    "start": "858800",
    "end": "865550"
  },
  {
    "text": "script is a little bash script not so little actually it's probably a few thousand lines of bash called perf",
    "start": "865550",
    "end": "872030"
  },
  {
    "text": "collect and so the official workflow if you have a dot and core app running on",
    "start": "872030",
    "end": "878000"
  },
  {
    "text": "Linux maybe in a container maybe just on a bare bone VM the official story would be the following you download that bash",
    "start": "878000",
    "end": "885200"
  },
  {
    "text": "script which is just a bash script and then you run the script with the install",
    "start": "885200",
    "end": "890630"
  },
  {
    "text": "argument which installs a bunch of prerequisites and there is tailored for different distributions so the script",
    "start": "890630",
    "end": "896420"
  },
  {
    "text": "detects which distribution you're on downloads the different dependencies install them that's all good then you",
    "start": "896420",
    "end": "902690"
  },
  {
    "text": "run collection so you run perf collect collect and that records a bunch of stuff it basically records everything",
    "start": "902690",
    "end": "909860"
  },
  {
    "text": "there is to record it records CPU samples so you can do CPU profiling it",
    "start": "909860",
    "end": "915050"
  },
  {
    "text": "also enables and records all the runtime events so garbage collections exceptions being",
    "start": "915050",
    "end": "920660"
  },
  {
    "text": "thrown assemblies being loaded methods being compiled everything is getting",
    "start": "920660",
    "end": "925820"
  },
  {
    "text": "recorded and that produces a zip file now the workflow gets a little more",
    "start": "925820",
    "end": "931610"
  },
  {
    "text": "shady you take that zip file and you copy it over to a Windows machine because you can't analyze it on Linux",
    "start": "931610",
    "end": "937370"
  },
  {
    "text": "using perf glass so you take the zip file and you copy it over to a Windows machine then you download perfume which",
    "start": "937370",
    "end": "944120"
  },
  {
    "text": "is really great tool for Windows it's free it's a Microsoft developed tool for analyzing performance traces for recording etw",
    "start": "944120",
    "end": "950870"
  },
  {
    "text": "events really really useful and then you open the trace in purview and you can look at the events and you can figure",
    "start": "950870",
    "end": "958070"
  },
  {
    "text": "out which functions are taking lots of CPU time in your dotnet core on Linux application now there's several things",
    "start": "958070",
    "end": "964880"
  },
  {
    "text": "wrong with this and hopefully it's not going to remain the official workflow for long but that's the story right now",
    "start": "964880",
    "end": "970610"
  },
  {
    "text": "just a couple of things that come to mind there's a very long turnaround time",
    "start": "970610",
    "end": "976460"
  },
  {
    "text": "here so you have to record this recording get a zip file copy it over somewhere else open it there do analysis",
    "start": "976460",
    "end": "983300"
  },
  {
    "text": "maybe fix your code go back to that machine record a zip file again copy it over keep doing that the zip files can",
    "start": "983300",
    "end": "990110"
  },
  {
    "text": "easily grow to hundreds of megabytes for very short periods of time so it's not",
    "start": "990110",
    "end": "996140"
  },
  {
    "text": "something you'd be copying around like super easily especially if it's a cloud VM somewhere and the Windows machine is",
    "start": "996140",
    "end": "1002500"
  },
  {
    "text": "in your office or that sort of setup so that's one problem the turnaround time the second issue is you obviously can do",
    "start": "1002500",
    "end": "1009160"
  },
  {
    "text": "any real-time monitoring like this right so you have to make a zip file copy it over open it you can do real-time",
    "start": "1009160",
    "end": "1015490"
  },
  {
    "text": "monitoring on the linux box and of course I mean there's no control over",
    "start": "1015490",
    "end": "1020800"
  },
  {
    "text": "exactly what gets collected so you basically say perf collect collect and it decides for you which events to",
    "start": "1020800",
    "end": "1026800"
  },
  {
    "text": "record goes ahead and record them there's some tweaking you can do but basically it records everything so",
    "start": "1026800",
    "end": "1033730"
  },
  {
    "text": "that's the official story and they were not going to be going with the official story because what the perf collect script actually does is not that",
    "start": "1033730",
    "end": "1039579"
  },
  {
    "text": "complicated and we can totally replicate parts of this ourselves so we'll be using perf and perf is what",
    "start": "1039579",
    "end": "1047558"
  },
  {
    "text": "perf collects perf collect users as well perf is a Linux tool for performance investigations it's not doesn't core",
    "start": "1047559",
    "end": "1054220"
  },
  {
    "text": "specific at all it's just the go-to tool on Linux if you have any kind of performance investigation to do its part",
    "start": "1054220",
    "end": "1061030"
  },
  {
    "text": "of the Linux kernel so I mean it's developed as part of the lunar of the Linux kernel tree so there's always a",
    "start": "1061030",
    "end": "1067450"
  },
  {
    "text": "build of perf that matches the build of the kernel you have and if you upgrade your kernel you also have to upgrade",
    "start": "1067450",
    "end": "1073630"
  },
  {
    "text": "perf along side it's available of course for all distributions because again it's",
    "start": "1073630",
    "end": "1078820"
  },
  {
    "text": "just part of the kernel so for example an Ubuntu you install it from Linux tools common on redhead you'd install it",
    "start": "1078820",
    "end": "1084490"
  },
  {
    "text": "from the perf package so it's just out there you have to install it and in some cases it might even be available out of",
    "start": "1084490",
    "end": "1090910"
  },
  {
    "text": "the box now perf is a command-line tool with a gazillion different options it",
    "start": "1090910",
    "end": "1096730"
  },
  {
    "text": "can record it can display it can process events it can do a bunch of different things",
    "start": "1096730",
    "end": "1102040"
  },
  {
    "text": "one thing we'll be doing is just recording CPU samples but first did the general architecture of what proof",
    "start": "1102040",
    "end": "1108250"
  },
  {
    "text": "events look like so the basic premise is you have different event sources so for",
    "start": "1108250",
    "end": "1114850"
  },
  {
    "text": "example here on the left you have some kernel events like page folds cache misses contexts which is a bunch of",
    "start": "1114850",
    "end": "1121990"
  },
  {
    "text": "different things happening and you can also have some events in user space for example memory allocations in a in a C",
    "start": "1121990",
    "end": "1129760"
  },
  {
    "text": "application so all these events if you enable them go into the perf events",
    "start": "1129760",
    "end": "1134830"
  },
  {
    "text": "mechanism in the kernel which writes them out to a file or a shared memory",
    "start": "1134830",
    "end": "1140050"
  },
  {
    "text": "buffer so there's two options for you to work with the default which most tools use that's also what perf collect uses",
    "start": "1140050",
    "end": "1146440"
  },
  {
    "text": "is to go through that perf dot data file so you write out every single event",
    "start": "1146440",
    "end": "1151450"
  },
  {
    "text": "occurrence to a file and then you analyze that file a little later you might analyze it on a Windows machine",
    "start": "1151450",
    "end": "1158140"
  },
  {
    "text": "using per few or you might analyze it on the same Linux box using perf itself but",
    "start": "1158140",
    "end": "1163690"
  },
  {
    "text": "you do the recording into a file and then you analyze it later and that's a pretty generic architecture for an event",
    "start": "1163690",
    "end": "1169990"
  },
  {
    "text": "collector DRD the ability to work with memory buffers rather than files is",
    "start": "1169990",
    "end": "1176170"
  },
  {
    "text": "pretty important because it means you can build real time tools so you don't have to go through a file you can write",
    "start": "1176170",
    "end": "1182170"
  },
  {
    "text": "events to a cyclic buffer in memory and then just analyze those and discard them so you don't have to record everything",
    "start": "1182170",
    "end": "1189160"
  },
  {
    "text": "for weeks or so so that's the general architecture so let's see how to use",
    "start": "1189160",
    "end": "1194650"
  },
  {
    "text": "this thing I was planning to do demos but I don't have my computer so I do",
    "start": "1194650",
    "end": "1200920"
  },
  {
    "text": "have screenshots of everything that's a sort of mock was my backup plan so we're going to see how to do a perfect and how",
    "start": "1200920",
    "end": "1207790"
  },
  {
    "text": "to get reports out of it but we do have to talk about symbolic information first so if I were doing a",
    "start": "1207790",
    "end": "1214250"
  },
  {
    "text": "demo I just show you what happens if we don't take care of it first but here I'm just gonna have to fall back to the",
    "start": "1214250",
    "end": "1219560"
  },
  {
    "text": "slides so you know that on Windows as well we need symbols we need pdbs right we",
    "start": "1219560",
    "end": "1226490"
  },
  {
    "text": "need PDB files to do debugging that's the most common scenario when you encounter pdbs but for profiling you",
    "start": "1226490",
    "end": "1234260"
  },
  {
    "text": "need PDP's as well you need them to figure out the relationship between addresses and function names in your app",
    "start": "1234260",
    "end": "1240740"
  },
  {
    "text": "in your source code so the same thing exactly happens on Linux you need symbolic debug information you need",
    "start": "1240740",
    "end": "1247370"
  },
  {
    "text": "debug info files in order to match addresses to function names so for",
    "start": "1247370",
    "end": "1252500"
  },
  {
    "text": "dotnet code if we did a proof recording and then we asked Perth to visualize the",
    "start": "1252500",
    "end": "1257600"
  },
  {
    "text": "results we'd get a bunch of addresses like on this slide so all of these great numbers here this is where our code is",
    "start": "1257600",
    "end": "1264590"
  },
  {
    "text": "this is the stuff we care about but it's just shown as addresses and on windows",
    "start": "1264590",
    "end": "1270470"
  },
  {
    "text": "there is actually a fairly elaborate set of different moving pieces which work together to make sure you get symbolic",
    "start": "1270470",
    "end": "1278030"
  },
  {
    "text": "information for your dotnet code and Linux it's a little trickier and that's part of what the perf collect script",
    "start": "1278030",
    "end": "1284510"
  },
  {
    "text": "takes care of for you so what do you have to do to get symbolic information on Linux for the different moving pieces",
    "start": "1284510",
    "end": "1291020"
  },
  {
    "text": "so on the left you have a call stack of a dotnet app calling console.writeline",
    "start": "1291020",
    "end": "1297560"
  },
  {
    "text": "on a Linux box and it goes all the way from the bottom where there's the thread",
    "start": "1297560",
    "end": "1304220"
  },
  {
    "text": "initialization stuff going through the core CLR and then we have the green frames which is managed code so the main",
    "start": "1304220",
    "end": "1310760"
  },
  {
    "text": "method and program dot foo which is some function and that goes through to that and framework implementation",
    "start": "1310760",
    "end": "1315940"
  },
  {
    "text": "console.writeline and so on all the way down to the Linux kernel so each of",
    "start": "1315940",
    "end": "1321080"
  },
  {
    "text": "these different functions all on the stack they need symbol information they",
    "start": "1321080",
    "end": "1326840"
  },
  {
    "text": "need debug information to be resolved to function names and the source of that debug information is different for each",
    "start": "1326840",
    "end": "1333500"
  },
  {
    "text": "of those so for example if we're dealing with native frames so C or C++ code on",
    "start": "1333500",
    "end": "1340550"
  },
  {
    "text": "Linux the story is pretty similar to what happens on those there's debug information files",
    "start": "1340550",
    "end": "1345990"
  },
  {
    "text": "which ship alongside with the binary so you can install them separately or you",
    "start": "1345990",
    "end": "1351629"
  },
  {
    "text": "can just get them as part of the binary package itself and these files contain all the symbolic information you're",
    "start": "1351629",
    "end": "1357960"
  },
  {
    "text": "going to need to translate addresses to function names but for managed code the story is a little different because",
    "start": "1357960",
    "end": "1363389"
  },
  {
    "text": "managed code gets compiled at runtime right we have the JIT compiler which is great so we don't have upfront",
    "start": "1363389",
    "end": "1370710"
  },
  {
    "text": "information about code addresses it all gets created when the code gets compiled",
    "start": "1370710",
    "end": "1375929"
  },
  {
    "text": "at runtime so we need a different set of information sources and indeed there's",
    "start": "1375929",
    "end": "1381960"
  },
  {
    "text": "this weird convention on Linux that whenever you have a JIT compiled runtime like the JVM nodejs",
    "start": "1381960",
    "end": "1390769"
  },
  {
    "text": "dotnet core there's this convention where the runtime would write out",
    "start": "1390769",
    "end": "1396539"
  },
  {
    "text": "symbolic information for any methods that are compiled to a text file which",
    "start": "1396539",
    "end": "1401970"
  },
  {
    "text": "is stored in a certain location by default it's under the temp directory so it just goes there and then performance",
    "start": "1401970",
    "end": "1408330"
  },
  {
    "text": "analysis tools can just pick it up from there and use it so that's the convention and Microsoft decided to go",
    "start": "1408330",
    "end": "1414750"
  },
  {
    "text": "along with the same convention so you can turn off of a turn on a flag which we'll show you in a moment and then the",
    "start": "1414750",
    "end": "1421200"
  },
  {
    "text": "dotnet just-in-time compiler will write out symbolic information to that text file which all the performance tools",
    "start": "1421200",
    "end": "1427559"
  },
  {
    "text": "will be able to pick up so here's what it looks like just gonna skip for a moment here to show you the these are",
    "start": "1427559",
    "end": "1434789"
  },
  {
    "text": "the screenshots I was talking about so just want to show you the switch we need to tune so there's this oops there's",
    "start": "1434789",
    "end": "1443129"
  },
  {
    "text": "this comp last perf map enabled environment variable which when turned",
    "start": "1443129",
    "end": "1448950"
  },
  {
    "text": "on will instruct the CLR to write out a text file with a line for each method",
    "start": "1448950",
    "end": "1455039"
  },
  {
    "text": "that gets JIT compiled so there's going to be a line there with the method address and the method names and perf is",
    "start": "1455039",
    "end": "1461159"
  },
  {
    "text": "going to be able to pick that up now you have to turn this on again in advance so",
    "start": "1461159",
    "end": "1466740"
  },
  {
    "text": "before you launch your application that environment variable has to be on it does have a certain overhead because it",
    "start": "1466740",
    "end": "1473129"
  },
  {
    "text": "means every method getting compiled also incurs right to a temp file and the file can",
    "start": "1473129",
    "end": "1478840"
  },
  {
    "text": "grow pretty big as well but it's in the temp file system so hopefully not nothing to worry about but you",
    "start": "1478840",
    "end": "1484840"
  },
  {
    "text": "definitely need to turn this on if you plan to do any debugging in production if you plan to do performance analysis",
    "start": "1484840",
    "end": "1490000"
  },
  {
    "text": "you just have to turn this thing on in advance I have a slide at the very end with a checklist of all the different",
    "start": "1490000",
    "end": "1496180"
  },
  {
    "text": "things you need to prepare if you plan to do performance investigations in production okay so assuming we have",
    "start": "1496180",
    "end": "1503590"
  },
  {
    "text": "debug information let's finally move on to getting CPU profiles and we'll",
    "start": "1503590",
    "end": "1510160"
  },
  {
    "text": "visualize those we'll put them on the screen using flame graphs which again is a concept a lot of linux people are",
    "start": "1510160",
    "end": "1517000"
  },
  {
    "text": "familiar with but on windows it's only getting traction recently and a flame graph is a visualization method for",
    "start": "1517000",
    "end": "1523000"
  },
  {
    "text": "taking a bunch of stock traces a lot of stock traces like millions of stock traces and putting them in a single",
    "start": "1523000",
    "end": "1529150"
  },
  {
    "text": "diagram now if you use the profiler before you've already worked with stock traces so you might be used to various",
    "start": "1529150",
    "end": "1535570"
  },
  {
    "text": "kinds of trees where you expand the tree to get through the stack trace or maybe",
    "start": "1535570",
    "end": "1540790"
  },
  {
    "text": "lists of functions or other kinds of views fan graphs are really really useful and again even on Windows they're",
    "start": "1540790",
    "end": "1547120"
  },
  {
    "text": "getting traction now even as part of Microsoft official tools like the windows performance analyzer and that",
    "start": "1547120",
    "end": "1552700"
  },
  {
    "text": "sort of thing so what basically a flame graph does is put in a single diagram a",
    "start": "1552700",
    "end": "1558490"
  },
  {
    "text": "bunch of stock traces where each rectangle and I'll have a bigger example to show you in a moment each rectangle",
    "start": "1558490",
    "end": "1565480"
  },
  {
    "text": "you see on the screen is a function the vertical axis is color Koli",
    "start": "1565480",
    "end": "1571300"
  },
  {
    "text": "relationships so if a function is on top of another function it was called by that function so if a is on top of B it",
    "start": "1571300",
    "end": "1579310"
  },
  {
    "text": "means that a was called by B the horizontal axis is just alphabetic",
    "start": "1579310",
    "end": "1585370"
  },
  {
    "text": "sorting so it's not a time line or anything it's just alphabetically sorted the wider something is the more common",
    "start": "1585370",
    "end": "1592690"
  },
  {
    "text": "it was the more times that function appeared and that's pretty much it the colors are usually just randomly",
    "start": "1592690",
    "end": "1600100"
  },
  {
    "text": "assigned to make it look pretty that's mostly why we have different colors it",
    "start": "1600100",
    "end": "1605410"
  },
  {
    "text": "does help sort of differentiate the different functions you could also assign colors by some",
    "start": "1605410",
    "end": "1612330"
  },
  {
    "text": "other metric like maybe c-sharp functions would be green and C++",
    "start": "1612330",
    "end": "1617940"
  },
  {
    "text": "functions would be yellow and kernel functions would be orange or whatever there's obviously a bunch of stuff you",
    "start": "1617940",
    "end": "1623969"
  },
  {
    "text": "can do now the diagram itself is usually just an SVG file and SVG's are just XML",
    "start": "1623969",
    "end": "1630659"
  },
  {
    "text": "files and xml is text so you can do a bunch of stuff on that like grep and",
    "start": "1630659",
    "end": "1636089"
  },
  {
    "text": "zoom and and remove stuff out of it and filter and that sort of thing so let's",
    "start": "1636089",
    "end": "1641099"
  },
  {
    "text": "take a look at what the workflow looks like for dotnet core app on on Linux again I'm sorry it's screenshots but",
    "start": "1641099",
    "end": "1646769"
  },
  {
    "text": "it's it's the same workflow exactly it's except it's not going to be interactive so on the Left we have set that",
    "start": "1646769",
    "end": "1654179"
  },
  {
    "text": "environment variable compassed perf map enabled equals 1 and then we ran our",
    "start": "1654179",
    "end": "1659309"
  },
  {
    "text": "Dartmouth application giving it a certain set of things to do so just running there and printing dots on the",
    "start": "1659309",
    "end": "1666059"
  },
  {
    "text": "console in the right on the right hand side I rent Pitt stat which is I went",
    "start": "1666059",
    "end": "1672119"
  },
  {
    "text": "Pitt stat which is a built-in tool that shows you CPU usage for a certain process and it shows me that my CPU",
    "start": "1672119",
    "end": "1679710"
  },
  {
    "text": "usage for that buggy process is pretty high so user CPU is time spent in user",
    "start": "1679710",
    "end": "1686159"
  },
  {
    "text": "space system is time spent in kernel space and it adds up to sometimes a",
    "start": "1686159",
    "end": "1692729"
  },
  {
    "text": "hundred percent of a CPU so that's a CPU intensive app then we run perf record",
    "start": "1692729",
    "end": "1698759"
  },
  {
    "text": "and perfect chord is an incantation that tells perf to sample the CPU it's a",
    "start": "1698759",
    "end": "1705059"
  },
  {
    "text": "certain interval and record each individual sampling into a perf data",
    "start": "1705059",
    "end": "1711029"
  },
  {
    "text": "file now the interval is over here at the end - F 97 that 97 means 97 times per second",
    "start": "1711029",
    "end": "1718979"
  },
  {
    "text": "so sample the CPU 97 times per second and record samples and then you just hit",
    "start": "1718979",
    "end": "1725429"
  },
  {
    "text": "control C to stop and perf record says captured and wrote that much data to",
    "start": "1725429",
    "end": "1731249"
  },
  {
    "text": "perf the data 720 samples were captured overall you could do this for more or",
    "start": "1731249",
    "end": "1737339"
  },
  {
    "text": "less depends on your scenario then you use perf report which is not actually shown",
    "start": "1737339",
    "end": "1744300"
  },
  {
    "text": "on the screen shot to get this illustration here on the right and this is a coal tree in text format it shows",
    "start": "1744300",
    "end": "1751770"
  },
  {
    "text": "you which functions called other functions so if you start from here the main function called the fetch function",
    "start": "1751770",
    "end": "1758670"
  },
  {
    "text": "and then the fetch function called the process result function and so on so you can read this thing like a tree and it",
    "start": "1758670",
    "end": "1765150"
  },
  {
    "text": "has percentage points assigned and it's kind of like exploring in a in a GUI",
    "start": "1765150",
    "end": "1770720"
  },
  {
    "text": "except if you have a lot of stack traces if you have a real application you might",
    "start": "1770720",
    "end": "1775890"
  },
  {
    "text": "have like 5000 screen falls of this to go through so you don't really want to",
    "start": "1775890",
    "end": "1781710"
  },
  {
    "text": "work with the text format it's just an illustration that you can do a lot of the stuff on the terminal but you really",
    "start": "1781710",
    "end": "1787200"
  },
  {
    "text": "want to turn this into a a chart so that's where we use perf script and pass",
    "start": "1787200",
    "end": "1793710"
  },
  {
    "text": "it through a bunch of scripts that generate a flame graph again all the commands are available online and the",
    "start": "1793710",
    "end": "1799830"
  },
  {
    "text": "presentation as well and that just generates at the very end in SVG and SVG",
    "start": "1799830",
    "end": "1805290"
  },
  {
    "text": "fun the application by the way keeps running in the mean time so we didn't have to restart it we didn't have to",
    "start": "1805290",
    "end": "1811530"
  },
  {
    "text": "stop and start it again it's just running there we record a few samples and we analyze those samples on the same",
    "start": "1811530",
    "end": "1818340"
  },
  {
    "text": "machine the only thing we had to do in advance is this environment variable because otherwise we wouldn't have",
    "start": "1818340",
    "end": "1824280"
  },
  {
    "text": "function names like main and fetch and process result we wouldn't have those so",
    "start": "1824280",
    "end": "1829950"
  },
  {
    "text": "what does the flame graph look like this is the actual flame graph generated from this exercise so again remember the",
    "start": "1829950",
    "end": "1837000"
  },
  {
    "text": "wider something is the more prominent it was the more time we spent there so the",
    "start": "1837000",
    "end": "1843810"
  },
  {
    "text": "more prominent flame seems to be this one right this one right in the middle but there's also some other flames like",
    "start": "1843810",
    "end": "1850290"
  },
  {
    "text": "this one here and this one here which have a few samples if you hover over the",
    "start": "1850290",
    "end": "1855450"
  },
  {
    "text": "different rectangles if it wasn't just a screenshot you'd have a tooltip saying exactly the percentage points so you",
    "start": "1855450",
    "end": "1861780"
  },
  {
    "text": "don't have to just trust your eyes now looking on the right here if you can see the function names because the zoom",
    "start": "1861780",
    "end": "1867780"
  },
  {
    "text": "doesn't work either but if you if you look at the function names this is a garbage collection thread right the",
    "start": "1867780",
    "end": "1874650"
  },
  {
    "text": "function names you we're gonna read that for you GC heap BGC thread stub BGC is background GC GC",
    "start": "1874650",
    "end": "1882310"
  },
  {
    "text": "GC heap GC 1 GC scan that sort of thing this is just a tread doing garbage",
    "start": "1882310",
    "end": "1888430"
  },
  {
    "text": "collection in the background and that's that's okay we recorded that of course this is not c-sharp code that's just C++",
    "start": "1888430",
    "end": "1895030"
  },
  {
    "text": "code inside the cell are our c-sharp code is over here so this is program",
    "start": "1895030",
    "end": "1903010"
  },
  {
    "text": "main and there's a bunch of functions leading up to that point in the course alarm but this is our code here program",
    "start": "1903010",
    "end": "1910630"
  },
  {
    "text": "main program fetch program process result and then we can see some of the ways it goes from here so for example",
    "start": "1910630",
    "end": "1917800"
  },
  {
    "text": "one frame that we have a bunch of set of functions on is framed allocates trained",
    "start": "1917800",
    "end": "1924040"
  },
  {
    "text": "and then slow allocate string so I mean it's not slow deliberately it's just",
    "start": "1924040",
    "end": "1929470"
  },
  {
    "text": "there's probably a fast path where you can still allocate from a local buffer and then there's a slow path where you",
    "start": "1929470",
    "end": "1935380"
  },
  {
    "text": "can't but regardless we have function names for our c-sharp code as well as for the course CLR the Linux libraries",
    "start": "1935380",
    "end": "1944080"
  },
  {
    "text": "and so on all the debug information is available and we get a full fidelity flame graph now again coloring could",
    "start": "1944080",
    "end": "1951130"
  },
  {
    "text": "maybe help like color the c-sharp code yellow green whatever that's definitely something you can do as a",
    "start": "1951130",
    "end": "1956800"
  },
  {
    "text": "post-processing step so that's just an illustration of getting a CPU profile of",
    "start": "1956800",
    "end": "1962980"
  },
  {
    "text": "your app where you're spending lots of CPU time what kinds of things you were doing there's nothing super interesting",
    "start": "1962980",
    "end": "1968200"
  },
  {
    "text": "in this scenario itself is just really allocating a lot of stuff and in the",
    "start": "1968200",
    "end": "1973480"
  },
  {
    "text": "process it's also causing lots of garbage collections to happen in the background so it's interesting that we have a full view of what's happening in",
    "start": "1973480",
    "end": "1979990"
  },
  {
    "text": "the process not just the c-sharp code every everything using the CPU in that process",
    "start": "1979990",
    "end": "1986580"
  },
  {
    "text": "I'm sorry again no no this so this is",
    "start": "1988690",
    "end": "1996310"
  },
  {
    "text": "this hiraman yeah that's that's core sealer yeah and this is our C sharp code",
    "start": "1996310",
    "end": "2002460"
  },
  {
    "text": "it's it's not marked meaningfully right it doesn't say C sharp or C++ next to it",
    "start": "2002460",
    "end": "2008370"
  },
  {
    "text": "but you could figure out by the function names just if you recognize your code yeah okay so that was CPU profiling we",
    "start": "2008370",
    "end": "2016740"
  },
  {
    "text": "do have a bunch of other scenarios to go through so I'm gonna move ahead and I'm going to talk talk briefly about BPF",
    "start": "2016740",
    "end": "2025140"
  },
  {
    "text": "which is a different set of tools for doing performance investigations on linux which i want to talk to you about",
    "start": "2025140",
    "end": "2030300"
  },
  {
    "text": "in addition to perf there are some cases where the BPF approach is gonna be",
    "start": "2030300",
    "end": "2035840"
  },
  {
    "text": "giving you a lower overhead and will be more suitable for continuous performance",
    "start": "2035840",
    "end": "2041220"
  },
  {
    "text": "monitoring so it's worth mentioning even though perf is kind of the go-to tool like I just showed it so this just",
    "start": "2041220",
    "end": "2048060"
  },
  {
    "text": "illustrates the two different approaches to doing performance work on Linux the",
    "start": "2048060",
    "end": "2053250"
  },
  {
    "text": "one on top is the perfect roach which we've been going through so far and the one on the bottom is something new so",
    "start": "2053250",
    "end": "2059129"
  },
  {
    "text": "just go through the bar to the top part first this is what we've been doing so far we have the perfect mechanism in the",
    "start": "2059130",
    "end": "2066690"
  },
  {
    "text": "kernel which receives events from somewhere and writes them out to a text",
    "start": "2066690",
    "end": "2072240"
  },
  {
    "text": "to a sorry a binary file perf dot data and then you have some user space scripts analysis processes visualizers",
    "start": "2072240",
    "end": "2080460"
  },
  {
    "text": "whatever generating some sort of reports from that the report could be a bunch of text the report could be a flame graph",
    "start": "2080460",
    "end": "2087780"
  },
  {
    "text": "the report could be anything but you go through this data file you go through a major major big file on this the other",
    "start": "2087780",
    "end": "2098070"
  },
  {
    "text": "approach which we'll be talking about here is the BPF approach where inside",
    "start": "2098070",
    "end": "2103380"
  },
  {
    "text": "the kernel there's a little analysis program that we install and run so rather than putting all our events in a",
    "start": "2103380",
    "end": "2110670"
  },
  {
    "text": "file and doing analysis after the fact in userspace we do analysis as the events arrive in",
    "start": "2110670",
    "end": "2117270"
  },
  {
    "text": "the kernel using this BPF technology now I wish could spend more time talking about BPF",
    "start": "2117270",
    "end": "2123390"
  },
  {
    "text": "itself BP f stands for Berkeley packet filters so it sounds like packet filtering technology and indeed it was",
    "start": "2123390",
    "end": "2130859"
  },
  {
    "text": "used for packet filters many years ago started in the early 90s was ported to",
    "start": "2130859",
    "end": "2136800"
  },
  {
    "text": "Linux from BSD so Berkeley packet filters but today it can be used for",
    "start": "2136800",
    "end": "2143460"
  },
  {
    "text": "performance tracing for performance analysis for performance investigations as well again the key difference you",
    "start": "2143460",
    "end": "2149040"
  },
  {
    "text": "have to remember is that with BPF you can do aggregations you can generate",
    "start": "2149040",
    "end": "2154170"
  },
  {
    "text": "visualizations charts histograms that sort of thing right when the events arrive and not by inspecting a huge file",
    "start": "2154170",
    "end": "2161760"
  },
  {
    "text": "that has millions or billions of entries so that's going to be the key difference and that enables continuous performance",
    "start": "2161760",
    "end": "2167940"
  },
  {
    "text": "monitoring it enables higher frequency event collection because you don't have to store every single event to disk",
    "start": "2167940",
    "end": "2173640"
  },
  {
    "text": "there's a bunch of things opening up and indeed if you look at the pipe to user space the pipe instead of a file becomes",
    "start": "2173640",
    "end": "2181859"
  },
  {
    "text": "a data structure which is called a map in BPF terminology and that map is just",
    "start": "2181859",
    "end": "2187770"
  },
  {
    "text": "exactly the set of data you want to pass you want to pass through the user space it's not every single event occurrence",
    "start": "2187770",
    "end": "2194250"
  },
  {
    "text": "so that's just the general story very briefly now BPF itself is a kernel",
    "start": "2194250",
    "end": "2199609"
  },
  {
    "text": "technology which has a bunch of different front ends available in user space Python C++ Java go a bunch of",
    "start": "2199609",
    "end": "2208770"
  },
  {
    "text": "languages that can interact with BPF to a set of libraries the set of tools I'll",
    "start": "2208770",
    "end": "2213990"
  },
  {
    "text": "be using is called BCC the BPF compiler collection it's an open source project that I've also contributed a couple of",
    "start": "2213990",
    "end": "2220589"
  },
  {
    "text": "tools to and there's a bunch of people working on it from Netflix from Facebook from planned grid from VMware a bunch of",
    "start": "2220589",
    "end": "2226920"
  },
  {
    "text": "people collaborating on building gnu/linux performance tools that use BPF",
    "start": "2226920",
    "end": "2233280"
  },
  {
    "text": "now before we go there just one minor thing you want to be you might be asking",
    "start": "2233280",
    "end": "2238910"
  },
  {
    "text": "why would we even use perf anymore right so if we can instead of going through a big big file if we can just process the",
    "start": "2238910",
    "end": "2246240"
  },
  {
    "text": "events in real time why use peripheral why use what I've just shown you the in the first 20 minutes and the answer is BPF is fairly",
    "start": "2246240",
    "end": "2252990"
  },
  {
    "text": "new so BPF is generally available in Linux kernel 4.1 and onwards which means roughly the last",
    "start": "2252990",
    "end": "2260740"
  },
  {
    "text": "two and a half years which means if you have a super old Linux distribution like",
    "start": "2260740",
    "end": "2266470"
  },
  {
    "text": "cent OS 6 for example or Ubuntu 14 or that sort of thing that you have to keep",
    "start": "2266470",
    "end": "2272140"
  },
  {
    "text": "working with you simply don't have access to new enough kernels to use BPF if you have a bunch of 16 if you have",
    "start": "2272140",
    "end": "2279520"
  },
  {
    "text": "Center 7 if you have fairly recent Linux distros which keep updating with recent",
    "start": "2279520",
    "end": "2285400"
  },
  {
    "text": "kernels you'll be able to use BPF probably today if not then maybe in a couple of months but for older",
    "start": "2285400",
    "end": "2291940"
  },
  {
    "text": "distributions perf remains the tool of choice because perf has been available since linux 2.6 it's just there so",
    "start": "2291940",
    "end": "2300190"
  },
  {
    "text": "that's roughly why we want to go into BPF here's a small subset of the tools",
    "start": "2300190",
    "end": "2306700"
  },
  {
    "text": "we have available today built on top of BPF there is something for everyone here",
    "start": "2306700",
    "end": "2311950"
  },
  {
    "text": "if you're doing low-level work on like filesystem networking that sort of thing",
    "start": "2311950",
    "end": "2317740"
  },
  {
    "text": "there's a bunch of tools for you if you're working at higher levels like data tracing database accesses tracing",
    "start": "2317740",
    "end": "2323800"
  },
  {
    "text": "trade events tracing garbage collections there's a bunch of tools for that as well",
    "start": "2323800",
    "end": "2328900"
  },
  {
    "text": "for different managed runtimes dotnet Java Python a bunch of different managed",
    "start": "2328900",
    "end": "2335080"
  },
  {
    "text": "runtimes out there I'm going to show you just a couple of examples of what you can do with with the BPF based tools",
    "start": "2335080",
    "end": "2341920"
  },
  {
    "text": "some of these things can also be done with perf but with an higher overhead and going through a big file that you",
    "start": "2341920",
    "end": "2348400"
  },
  {
    "text": "have to pay for writing and reading whenever you do a performance investigation so just a couple of quick",
    "start": "2348400",
    "end": "2353650"
  },
  {
    "text": "examples I'm gonna just probably skip this one here because it's not super interesting when I show the other one",
    "start": "2353650",
    "end": "2359950"
  },
  {
    "text": "because we're a little short on time so this super long invocation here on the",
    "start": "2359950",
    "end": "2365770"
  },
  {
    "text": "right which I don't expect you to memorize basically says I want to trace all the functions inside the core CLR",
    "start": "2365770",
    "end": "2372940"
  },
  {
    "text": "which have garbage collect in their name now the core CLR is open source so I",
    "start": "2372940",
    "end": "2378250"
  },
  {
    "text": "don't really have to guess function names you can just go to the source and see what there are but I don't remember exactly so let's say anything that has",
    "start": "2378250",
    "end": "2384790"
  },
  {
    "text": "garbage collect in its name I want to trace so we're just running this tool when a.net process is active on Linux I can",
    "start": "2384790",
    "end": "2392559"
  },
  {
    "text": "get a report that says for each individual function how many times it was invoked so this function here was",
    "start": "2392559",
    "end": "2399369"
  },
  {
    "text": "invoked once this function here was invoked eleven hundred and seventy times",
    "start": "2399369",
    "end": "2405010"
  },
  {
    "text": "and so on now the function names look mangled and that's just what the C++ compiler does",
    "start": "2405010",
    "end": "2411069"
  },
  {
    "text": "to your functions if you are if you compile C++ code it would mangle the",
    "start": "2411069",
    "end": "2416260"
  },
  {
    "text": "function name slightly there's actually a simple tool called CPP filled which",
    "start": "2416260",
    "end": "2421450"
  },
  {
    "text": "would revert this which would give you the original C++ name back but we didn't",
    "start": "2421450",
    "end": "2427059"
  },
  {
    "text": "run this in in this example so basically I can draw conclusions from this even if",
    "start": "2427059",
    "end": "2432700"
  },
  {
    "text": "I don't kind of like the decorated format it looks here like a garbage collection started function and a",
    "start": "2432700",
    "end": "2438910"
  },
  {
    "text": "garbage collection finished function both were invoked the very large number of times it does seem like the started",
    "start": "2438910",
    "end": "2445599"
  },
  {
    "text": "callback was invoked more times than the finished callback which is curious but we're talking about thousands of",
    "start": "2445599",
    "end": "2451740"
  },
  {
    "text": "invocations anyway so I suspect there's a lot of garbage collection going on in this process and this is not by using",
    "start": "2451740",
    "end": "2459240"
  },
  {
    "text": "the core CLR static events it does have events for garbage collections it can",
    "start": "2459240",
    "end": "2464950"
  },
  {
    "text": "emit this is just by looking at functions arbitrary functions inside the runtime so that doesn't require any kind",
    "start": "2464950",
    "end": "2471849"
  },
  {
    "text": "of cooperation from the application that you're tracing and it's applicable to any language it's applicable to JVM apps",
    "start": "2471849",
    "end": "2478720"
  },
  {
    "text": "running on Linux or Python apps running on Linux or whatever as long as you have the function name another example of",
    "start": "2478720",
    "end": "2485470"
  },
  {
    "text": "what we could do is actually get stack traces invoking a particular function",
    "start": "2485470",
    "end": "2490809"
  },
  {
    "text": "frequently kind of like CPU profiling but instead of profiling just arbitrary",
    "start": "2490809",
    "end": "2496089"
  },
  {
    "text": "CPU work I want to see who's calling a particular function frequently and so I",
    "start": "2496089",
    "end": "2501760"
  },
  {
    "text": "can run another tool which is not shown here and get a stack trace and account",
    "start": "2501760",
    "end": "2506829"
  },
  {
    "text": "at the bottom here and that means that this stack trace was calling the",
    "start": "2506829",
    "end": "2512619"
  },
  {
    "text": "function I'm interested in thirty one hundred and fifty five times so it's",
    "start": "2512619",
    "end": "2517630"
  },
  {
    "text": "just a slightly different way of performance profiling rather than just looking at arbitrary CPU work there's a",
    "start": "2517630",
    "end": "2523810"
  },
  {
    "text": "certain function I'm zooming in on and I want to know who's calling that particular function and so that gives me",
    "start": "2523810",
    "end": "2529660"
  },
  {
    "text": "again I managed stack as well and so these are",
    "start": "2529660",
    "end": "2534820"
  },
  {
    "text": "functions were familiar with like main and fetch and process result and they are causing lots of garbage collections",
    "start": "2534820",
    "end": "2541300"
  },
  {
    "text": "by doing lots of allocations which is again not surprising if you recall the flame graph but we just got there in a",
    "start": "2541300",
    "end": "2547480"
  },
  {
    "text": "slightly different way so we can use this for garbage collection tracing for example now I want to show you the",
    "start": "2547480",
    "end": "2553630"
  },
  {
    "text": "static events as well and so I'm just gonna jump over again I've told you in",
    "start": "2553630",
    "end": "2558820"
  },
  {
    "text": "the beginning that the equivalent for etw events on Windows the equivalent on",
    "start": "2558820",
    "end": "2564310"
  },
  {
    "text": "Linux is called LT TNG that's the framework Microsoft opted to use for",
    "start": "2564310",
    "end": "2570010"
  },
  {
    "text": "static events coming out of dotnet core both the core CLR which is the C++ part",
    "start": "2570010",
    "end": "2576010"
  },
  {
    "text": "and your dotnet code your c-sharp code that wants to emit run time tracing",
    "start": "2576010",
    "end": "2581350"
  },
  {
    "text": "events using the event source API so LD T and G again Linux tracing toolkit next",
    "start": "2581350",
    "end": "2587410"
  },
  {
    "text": "generation is fairly similar to what perf does in in spirit and by that I",
    "start": "2587410",
    "end": "2594130"
  },
  {
    "text": "mean there is a kernel component which aggregates events from the kernel",
    "start": "2594130",
    "end": "2599170"
  },
  {
    "text": "there's also a user space component that aggregates events from user space like",
    "start": "2599170",
    "end": "2604690"
  },
  {
    "text": "garbage collections events assembly load events whatever you emit as tracing",
    "start": "2604690",
    "end": "2610390"
  },
  {
    "text": "events and these events can go to memory buffers or to files so again kind of",
    "start": "2610390",
    "end": "2617800"
  },
  {
    "text": "like perf kind of like any performance tracing framework out there you can either work with memory buffers which",
    "start": "2617800",
    "end": "2623710"
  },
  {
    "text": "are limited in space or in addition to you could also write out to a file on",
    "start": "2623710",
    "end": "2629530"
  },
  {
    "text": "disk and analyze that later you can do real-time processing or you can look at",
    "start": "2629530",
    "end": "2634750"
  },
  {
    "text": "the whole file after the fact with a bunch of different tracing tools one advantage this architecture has compared",
    "start": "2634750",
    "end": "2641830"
  },
  {
    "text": "to perf is that file format is actually standardized so it's not the random",
    "start": "2641830",
    "end": "2647830"
  },
  {
    "text": "binder we perform at its CTF which is the common trace format and there's a bunch",
    "start": "2647830",
    "end": "2653710"
  },
  {
    "text": "of different tools from a variety of vendors that can write and read CTF files it's kind of a common log binary",
    "start": "2653710",
    "end": "2661480"
  },
  {
    "text": "format which a lot of tools would recognize so that that quarry itself",
    "start": "2661480",
    "end": "2666700"
  },
  {
    "text": "again has a bunch of different events it can write out through LT TNG so I'm",
    "start": "2666700",
    "end": "2672550"
  },
  {
    "text": "going to show you again a demo of some of those so the general process is as follows for the.net process to emit",
    "start": "2672550",
    "end": "2680710"
  },
  {
    "text": "events you need to enable yet another environment variable which is called comp plus enable event log if you don't",
    "start": "2680710",
    "end": "2688570"
  },
  {
    "text": "there's not gonna be any events it's just quite as simple as that you can't enable just the subset of",
    "start": "2688570",
    "end": "2694750"
  },
  {
    "text": "events you either turn the whole thing on or the whole thing off and then the CLR will emit or not emit any events you",
    "start": "2694750",
    "end": "2702010"
  },
  {
    "text": "run your application and in the background you can do whenever you want you can create a recording of these",
    "start": "2702010",
    "end": "2708430"
  },
  {
    "text": "events getting emitted so there's a bunch of commands you have to run for this which again no one is supposed to",
    "start": "2708430",
    "end": "2713710"
  },
  {
    "text": "memorize you can obviously script it out so LT T&G create a trace at context",
    "start": "2713710",
    "end": "2719500"
  },
  {
    "text": "enable certain events you're interested in start the recording stop the recording destroy the session and then",
    "start": "2719500",
    "end": "2726160"
  },
  {
    "text": "you have a file on disk you can analyze later now the file again is in binary format but you can inspect it with a",
    "start": "2726160",
    "end": "2733960"
  },
  {
    "text": "bunch of different tools the one built in that just comes with LT T&G if you install it from your package",
    "start": "2733960",
    "end": "2740020"
  },
  {
    "text": "distribution is called babel trace so it reads an arbitrary",
    "start": "2740020",
    "end": "2745150"
  },
  {
    "text": "common trace format file and just prints out a text listing of all the events in",
    "start": "2745150",
    "end": "2751240"
  },
  {
    "text": "that file so you can just see it's a fairly simple format you can just see individual events now these aren't super",
    "start": "2751240",
    "end": "2758140"
  },
  {
    "text": "interesting but let's take a look at slightly more interesting events so here I've just used grep to look for",
    "start": "2758140",
    "end": "2764260"
  },
  {
    "text": "exception thrown events and now you can see a bunch of lines here each indicating an exception that was thrown",
    "start": "2764260",
    "end": "2771520"
  },
  {
    "text": "in that trace recording so they're all pretty much the same dot at runtime",
    "start": "2771520",
    "end": "2777730"
  },
  {
    "text": "exception thrown it gives me the process name exception type which was HTTP request",
    "start": "2777730",
    "end": "2783560"
  },
  {
    "text": "exception the exception message I got and a bunch of other stuff one notable",
    "start": "2783560",
    "end": "2788960"
  },
  {
    "text": "thing missing is the call stack there is no call stack right and when you have an",
    "start": "2788960",
    "end": "2794060"
  },
  {
    "text": "exception event the call stack might be kind of important and interesting unfortunately probably the only drawback",
    "start": "2794060",
    "end": "2802490"
  },
  {
    "text": "that LTTE angie has right now is it doesn't support stack trace collection so whenever you have an event you get a",
    "start": "2802490",
    "end": "2810050"
  },
  {
    "text": "lot of stuff in there like the process name process ID time stamp and so on you can't get the whole stack embedded",
    "start": "2810050",
    "end": "2816500"
  },
  {
    "text": "inside the event automatically and this is something a lot of other tracing frameworks actually do support but that",
    "start": "2816500",
    "end": "2823580"
  },
  {
    "text": "was a conscious decision Microsoft made the core Solara team made they opted to use Alta T&G in knowing that they won't",
    "start": "2823580",
    "end": "2830660"
  },
  {
    "text": "get stuck trace support the LDT energy team is working on adding stack trace",
    "start": "2830660",
    "end": "2837080"
  },
  {
    "text": "support that some future may be release it's an open source project you can also contribute but right now you can't do",
    "start": "2837080",
    "end": "2844370"
  },
  {
    "text": "meaningful stack trace collection for core CLR events so for GC events for",
    "start": "2844370",
    "end": "2850490"
  },
  {
    "text": "exception events for assembly load defense you can get the event information but not the call stack on",
    "start": "2850490",
    "end": "2857090"
  },
  {
    "text": "Windows you can on windows etw supports stack trace collection for ages it's",
    "start": "2857090",
    "end": "2862670"
  },
  {
    "text": "just not something available on linux and it's really painful I'm only mentioning this as a drawback because it",
    "start": "2862670",
    "end": "2867740"
  },
  {
    "text": "is a pretty painful drawback so a couple of other things you can do with these",
    "start": "2867740",
    "end": "2873440"
  },
  {
    "text": "trace files and these are just examples there's obviously a lot more so this one here is a plot that a guy called Alex",
    "start": "2873440",
    "end": "2882590"
  },
  {
    "text": "Avery shaggin has created from the GC events this gives you a plot of your",
    "start": "2882590",
    "end": "2888320"
  },
  {
    "text": "dotnet memory usage over time so it just looks at the garbage collection events",
    "start": "2888320",
    "end": "2893450"
  },
  {
    "text": "in that trace and draws a plot of time and amount of memory in your dotnet",
    "start": "2893450",
    "end": "2899960"
  },
  {
    "text": "heaps now if you have ever done this sort of thing on windows on windows it's like super trivial to do this with",
    "start": "2899960",
    "end": "2906500"
  },
  {
    "text": "performance counters it takes five seconds to get this kind of graph on Linux unfortunately the CLR doesn't have",
    "start": "2906500",
    "end": "2914180"
  },
  {
    "text": "proof counters and there's no such thing as performance counters on Linux so the next best thing is getting out those GC",
    "start": "2914180",
    "end": "2921230"
  },
  {
    "text": "events and analyzing them in real time to produce a plot so that's a certainly doable but someone else has to do it",
    "start": "2921230",
    "end": "2928690"
  },
  {
    "text": "this example over here is just a bunch of shell pipes that look at all the",
    "start": "2928690",
    "end": "2934640"
  },
  {
    "text": "allocation events in the runtime and give you statistics over which types",
    "start": "2934640",
    "end": "2939680"
  },
  {
    "text": "were allocated more frequently so again just another kind of thing that you can do so 39 allocations of system byte",
    "start": "2939680",
    "end": "2946280"
  },
  {
    "text": "array 20 allocations of system string and so on these are sampled allocations",
    "start": "2946280",
    "end": "2951470"
  },
  {
    "text": "so it's not every single allocation that gets recorded that would be way too expensive it's just every 100 kilobytes",
    "start": "2951470",
    "end": "2957830"
  },
  {
    "text": "you get a an allocation event for for that sample so there's just a couple of",
    "start": "2957830",
    "end": "2963560"
  },
  {
    "text": "examples of what you can do by analyzing those recordings of the CLR events that",
    "start": "2963560",
    "end": "2968660"
  },
  {
    "text": "I wanted to show you so the final thing I want to discuss with you and we're yeah it's gonna probably take a little",
    "start": "2968660",
    "end": "2974720"
  },
  {
    "text": "more than four minutes but I hope to finish on time it's the very last thing I wanted to talk to you briefly about is",
    "start": "2974720",
    "end": "2980570"
  },
  {
    "text": "core dump analysis and again I wanted to show you a nice demo but I do have",
    "start": "2980570",
    "end": "2985820"
  },
  {
    "text": "screenshots covering the whole thing so hopefully core dumps again you're familiar with a core dump is a snapshot",
    "start": "2985820",
    "end": "2992000"
  },
  {
    "text": "of a process of a running process on Windows they're usually not called core dumps they're usually just called dumps",
    "start": "2992000",
    "end": "2998510"
  },
  {
    "text": "or mini dumps or dump files on Linux its core dumps but it's pretty much the same thing you take the process you suspend",
    "start": "2998510",
    "end": "3005050"
  },
  {
    "text": "it for a moment you write out the whole thing to a file and you let the process keep running and this can be useful for",
    "start": "3005050",
    "end": "3011320"
  },
  {
    "text": "crash analysis if you have a process just crashing under you you can record",
    "start": "3011320",
    "end": "3016420"
  },
  {
    "text": "its state at the moment of the crash and then let it crash and you can analyze the crash later or it can be useful for",
    "start": "3016420",
    "end": "3022360"
  },
  {
    "text": "just live analysis memory leaks accumulating over time or maybe you have",
    "start": "3022360",
    "end": "3028090"
  },
  {
    "text": "a deadlock and your process is stuck and you want to figure out what's happening so that's where core dumps can be useful",
    "start": "3028090",
    "end": "3034950"
  },
  {
    "text": "now remember again we're dealing with a slightly more production angle than development so you usually can't attach",
    "start": "3034950",
    "end": "3041860"
  },
  {
    "text": "a debugger in production you don't usually even have the debugger installed in production",
    "start": "3041860",
    "end": "3046880"
  },
  {
    "text": "and core dumps are kind of the next best thing so how to generate kadam's this is",
    "start": "3046880",
    "end": "3052520"
  },
  {
    "text": "again not really dotnet specific Linux has a bunch of knobs that you have to tune to make sure you get core dumps on",
    "start": "3052520",
    "end": "3058609"
  },
  {
    "text": "crashes for example there is a file which is in progress so it's not a real file it's a system setting that you can",
    "start": "3058609",
    "end": "3066050"
  },
  {
    "text": "tune to modify word the core file goes where the dump gets written and if it",
    "start": "3066050",
    "end": "3071420"
  },
  {
    "text": "gets written in the first place and there's also a limit that you can set per session that controls the core file",
    "start": "3071420",
    "end": "3077839"
  },
  {
    "text": "size and in some environments it might be set to zero by default so the maximum",
    "start": "3077839",
    "end": "3083030"
  },
  {
    "text": "size of the dump is zero bytes which means you won't ever get core dumps so you do have to tweak those if you do if",
    "start": "3083030",
    "end": "3090050"
  },
  {
    "text": "you just tweak those two you will get crash dumps you will get core dumps on crashes if you want a core dump on",
    "start": "3090050",
    "end": "3096740"
  },
  {
    "text": "demand there's again a bunch of tools that you can use the easiest one being just G core which is part of the gdb",
    "start": "3096740",
    "end": "3103490"
  },
  {
    "text": "debugger G core just takes a process attaches to it writes out a dump file",
    "start": "3103490",
    "end": "3108500"
  },
  {
    "text": "and detaches it's just giving you a dump file on the map now what do you do with the dotnet dump file so the only",
    "start": "3108500",
    "end": "3116270"
  },
  {
    "text": "debugger currently capable of opening dotnet core dump files on Linux is LL DB",
    "start": "3116270",
    "end": "3122390"
  },
  {
    "text": "you can't take that core file and open it in Visual Studio you can take that core file and open it in GDP the only",
    "start": "3122390",
    "end": "3128869"
  },
  {
    "text": "debugger that works is LL DB and you need a specific version of LD P which",
    "start": "3128869",
    "end": "3134210"
  },
  {
    "text": "matches the version of the core CLR that you happen to be using currently it's l DB 3.6 even though l DB 3.9 is now",
    "start": "3134210",
    "end": "3142609"
  },
  {
    "text": "available but you do have to stick to 3.6 so you open the dump file in l DB",
    "start": "3142609",
    "end": "3148550"
  },
  {
    "text": "and you'll get a prompt it's a text based debugger so forget Visual Studio nice tool windows and then you run the",
    "start": "3148550",
    "end": "3155780"
  },
  {
    "text": "BT command which stands for back trace that's supposed to give you a stack trace of where you crashed for example",
    "start": "3155780",
    "end": "3161750"
  },
  {
    "text": "here's where you crashed these are the frames you care about these are the managed functions which caused the",
    "start": "3161750",
    "end": "3169280"
  },
  {
    "text": "exceptions if you look at the bottom and the top of the stack there's function",
    "start": "3169280",
    "end": "3174530"
  },
  {
    "text": "names here but these are unmanaged C++ functions in core CLR the managed frames the c-sharp frames",
    "start": "3174530",
    "end": "3181490"
  },
  {
    "text": "gone now again you might expect a map file like with the perfect proach a map",
    "start": "3181490",
    "end": "3187140"
  },
  {
    "text": "file would be somewhere and then you just feed that map file to the debugger no LOD B doesn't use the same approach",
    "start": "3187140",
    "end": "3194490"
  },
  {
    "text": "you don't need a map file what you need is a plugin which Microsoft provides it",
    "start": "3194490",
    "end": "3200789"
  },
  {
    "text": "builds alongside course LR itself and that plugin is called Lib SOS plugin now",
    "start": "3200789",
    "end": "3207089"
  },
  {
    "text": "if you used windbg on windows you know there is SOS on windows which is a",
    "start": "3207089",
    "end": "3212519"
  },
  {
    "text": "plugin which is an extension for windbg that you can use to do managed analysis",
    "start": "3212519",
    "end": "3217559"
  },
  {
    "text": "in windbg same thing here it's the same source code so Microsoft just ported the plug-in to Linux and it's now called",
    "start": "3217559",
    "end": "3224730"
  },
  {
    "text": "Libre so as plug-in ur so you load that into LD B and then you get a bunch of commands like show me the dotnet stack",
    "start": "3224730",
    "end": "3232440"
  },
  {
    "text": "show me my objects on the heap show me the contents of a particular",
    "start": "3232440",
    "end": "3237599"
  },
  {
    "text": "object or array so you get a bunch of text commands for analyzing the state of your process it's just to walk you",
    "start": "3237599",
    "end": "3243869"
  },
  {
    "text": "through a couple of screenshots just very quickly here we ran a dotnet process and it crashed and that's what",
    "start": "3243869",
    "end": "3251279"
  },
  {
    "text": "it printed to the console so unhandled exception system application exception task crashed and the call stack it",
    "start": "3251279",
    "end": "3258210"
  },
  {
    "text": "doesn't look meaningful it says here tasks exception holder finalize task",
    "start": "3258210",
    "end": "3263579"
  },
  {
    "text": "scheduler publish an observed task exception and then handle and handled exceptions so you don't really know",
    "start": "3263579",
    "end": "3269420"
  },
  {
    "text": "where the original exception came from you might have run into something like this with your own code if you have tasks throwing and handled exceptions",
    "start": "3269420",
    "end": "3276509"
  },
  {
    "text": "but it says here core dumped good so we have a core file to analyze now opening",
    "start": "3276509",
    "end": "3283259"
  },
  {
    "text": "that core file in l DB 3.6 here on the right just prints out a bunch of stuff",
    "start": "3283259",
    "end": "3288599"
  },
  {
    "text": "which is totally unimportant just ignore this whole thing it shows you the state of each single thread but then if you",
    "start": "3288599",
    "end": "3295440"
  },
  {
    "text": "run bt it shows you the stack we saw on one of the screenshots the one that has",
    "start": "3295440",
    "end": "3300930"
  },
  {
    "text": "a bunch of missing frames okay so we go ahead and load the SOS plug-in and then",
    "start": "3300930",
    "end": "3308190"
  },
  {
    "text": "we can finally use a command called print exception which prints the exception information and the call stock",
    "start": "3308190",
    "end": "3315260"
  },
  {
    "text": "but this is still the same bad call stack it's still the same course that we saw in the terminal which has a task",
    "start": "3315260",
    "end": "3322010"
  },
  {
    "text": "exception holder finalized and published an observed task exception but what's nice is that if we actually look at the",
    "start": "3322010",
    "end": "3329300"
  },
  {
    "text": "tread call stack the publish unobserved task exception function and the handle",
    "start": "3329300",
    "end": "3334910"
  },
  {
    "text": "and handled exceptions function it takes an event args which has the original exception inside so it's not super",
    "start": "3334910",
    "end": "3342080"
  },
  {
    "text": "interesting I'm just gonna skip through it real quick you can look at the stack you can extract the object out of there",
    "start": "3342080",
    "end": "3348140"
  },
  {
    "text": "you can look into the object you can find the original exception like you would in Visual Studio in about three",
    "start": "3348140",
    "end": "3353270"
  },
  {
    "text": "and a half seconds but here it would take a bunch of spelunking through through text-based commands so we look",
    "start": "3353270",
    "end": "3361100"
  },
  {
    "text": "at the stack and we look at the event args parameter which is over here and",
    "start": "3361100",
    "end": "3366410"
  },
  {
    "text": "then we ask to print out that object and that object has an exception property at",
    "start": "3366410",
    "end": "3372050"
  },
  {
    "text": "this address and then we print that and that's an aggregate exception object and it has a list of inner exceptions here",
    "start": "3372050",
    "end": "3379100"
  },
  {
    "text": "on the bottom at this address and then we grab that and we print it out and it's a read-only collection and",
    "start": "3379100",
    "end": "3385130"
  },
  {
    "text": "the read on the collection has an array inside called list at this address and we print that out and that's an array of",
    "start": "3385130",
    "end": "3391609"
  },
  {
    "text": "exceptions and the only element in that array is at this address and then we print the exception and here it is so it",
    "start": "3391609",
    "end": "3398690"
  },
  {
    "text": "was an invalid operation exception which happened at this call stack okay and",
    "start": "3398690",
    "end": "3404570"
  },
  {
    "text": "that's what we were after so the original exception that caused the whole sequence of events to unfold",
    "start": "3404570",
    "end": "3409750"
  },
  {
    "text": "so somewhere in program update async I had an exception thrown so again just an",
    "start": "3409750",
    "end": "3416330"
  },
  {
    "text": "example of why you'd actually go through all these commands because the terminal output doesn't show you what what you're after",
    "start": "3416330",
    "end": "3421990"
  },
  {
    "text": "so that's again some of the things you might have learned about using windbg and SOS on windows would certainly apply",
    "start": "3421990",
    "end": "3427910"
  },
  {
    "text": "here as well and again currently you can't grab the core file and just open it and visual studio like you're used to",
    "start": "3427910",
    "end": "3434180"
  },
  {
    "text": "on windows so for now this is the workflow we're stuck with so here's a",
    "start": "3434180",
    "end": "3439730"
  },
  {
    "text": "quick checklist that you'll be able to take a look at later for what you need to do to per your production environment so it",
    "start": "3439730",
    "end": "3445170"
  },
  {
    "text": "has all the different things like the perf map enabled variable and event log variable and the setup you need to do",
    "start": "3445170",
    "end": "3451349"
  },
  {
    "text": "installations and so on this is things you need to do in your production environment so you'll be able to",
    "start": "3451349",
    "end": "3457380"
  },
  {
    "text": "replicate some of my examples so I hope to show you in this really quick tour",
    "start": "3457380",
    "end": "3462660"
  },
  {
    "text": "how to profile CPU activity in dotted core applications and how to visualize them using flare graphs we saw a couple",
    "start": "3462660",
    "end": "3469529"
  },
  {
    "text": "of linux tracing tools that you could use with dotnet core like perf and the bcc tools we talked about core doesn't",
    "start": "3469529",
    "end": "3476160"
  },
  {
    "text": "quarantine events like garbage collections exceptions getting thrown and how LT t ng can collect them and we",
    "start": "3476160",
    "end": "3482430"
  },
  {
    "text": "took a quick look at generating an opening core dumps as well it's all super painful right now and it's all",
    "start": "3482430",
    "end": "3490019"
  },
  {
    "text": "just hacked together from different bits and pieces I've blogged about this there's a bunch of references you can",
    "start": "3490019",
    "end": "3495299"
  },
  {
    "text": "take a look at here the slides are over there and there's also a bunch of labs for linux tracing if you're interested",
    "start": "3495299",
    "end": "3501210"
  },
  {
    "text": "in this I have a bunch of labs on Java and node and dotnet as well available on",
    "start": "3501210",
    "end": "3506309"
  },
  {
    "text": "github for you to take a look if you have any questions we have a long one hour break now so please feel free to",
    "start": "3506309",
    "end": "3512190"
  },
  {
    "text": "stay here and just ask whatever you'd like and if you want to go please go ahead thank you very much for coming I",
    "start": "3512190",
    "end": "3517859"
  },
  {
    "text": "hope you enjoy the rest of NDC and sorry [Applause] [Music]",
    "start": "3517859",
    "end": "3523910"
  }
]