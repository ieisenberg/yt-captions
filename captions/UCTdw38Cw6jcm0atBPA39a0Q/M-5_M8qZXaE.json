[
  {
    "start": "0",
    "end": "28000"
  },
  {
    "text": "so I'll be mutation testing and then do a deep dive",
    "start": "5110",
    "end": "11330"
  },
  {
    "text": "into some mutations for C++ 11 specifically I'm surf the bursar I work",
    "start": "11330",
    "end": "19700"
  },
  {
    "text": "at Nokia I do test infrastructure and this is also a part of the foyer I'm",
    "start": "19700",
    "end": "25280"
  },
  {
    "text": "doing this talk so let's start with why do we actually test some reasons are to",
    "start": "25280",
    "end": "34309"
  },
  {
    "start": "28000",
    "end": "151000"
  },
  {
    "text": "verify that your program behaves as the specifications say it should others are",
    "start": "34309",
    "end": "47020"
  },
  {
    "text": "having the confidence to change your code for new requirements knowing that",
    "start": "47020",
    "end": "52520"
  },
  {
    "text": "the test will tell you if you break something and there's an interesting issue how do you know your tests will",
    "start": "52520",
    "end": "57980"
  },
  {
    "text": "actually tell you that you broke something the most common way we usually do this",
    "start": "57980",
    "end": "67130"
  },
  {
    "text": "is having some measure of how much of the codes the tests execute so code",
    "start": "67130",
    "end": "73549"
  },
  {
    "text": "coverage may be you expand that into branch coverage to see how much different choices through our two codes",
    "start": "73549",
    "end": "79159"
  },
  {
    "text": "your tests actually check but what I am just got coverage in our case we use",
    "start": "79159",
    "end": "87530"
  },
  {
    "text": "symbol coverage because because",
    "start": "87530",
    "end": "95180"
  },
  {
    "text": "generating more data is too is too expensive we can't take a 50 percent",
    "start": "95180",
    "end": "102500"
  },
  {
    "text": "performance hits to do full line coverage but coverage should give us",
    "start": "102500",
    "end": "111140"
  },
  {
    "text": "some idea of how good our tests are why doesn't it well when people have",
    "start": "111140",
    "end": "119210"
  },
  {
    "text": "coverage as a metric to see how good they're testing and then often it's put",
    "start": "119210",
    "end": "126259"
  },
  {
    "text": "up from on high that the manager says we need to we need 90 percent code coverage people start writing stuff like this",
    "start": "126259",
    "end": "133060"
  },
  {
    "text": "just a function somewhere in their codes that it just can grow to be as big as",
    "start": "133060",
    "end": "140389"
  },
  {
    "text": "they need to to have the overall statistic be 90 percent a",
    "start": "140389",
    "end": "146740"
  },
  {
    "text": "gladiator climate so this confidence",
    "start": "147310",
    "end": "152630"
  },
  {
    "start": "151000",
    "end": "228000"
  },
  {
    "text": "what are ways to actually get that one way is especially in a project that",
    "start": "152630",
    "end": "159710"
  },
  {
    "text": "lasts for several decades just gather statistics of how many bucks you guys",
    "start": "159710",
    "end": "166250"
  },
  {
    "text": "didn't catch in test versus in production what if we can speed that",
    "start": "166250",
    "end": "171800"
  },
  {
    "text": "process up so what if we take a source",
    "start": "171800",
    "end": "177890"
  },
  {
    "text": "in this case there's an if test and we change it to be either smaller than or",
    "start": "177890",
    "end": "185300"
  },
  {
    "text": "equal not equal larger than or equal we world each of those through test and",
    "start": "185300",
    "end": "190460"
  },
  {
    "text": "check which are called by the test and which aren't and then we use that as a",
    "start": "190460",
    "end": "195710"
  },
  {
    "text": "score for the test suite and we do that for all the source code we're interested",
    "start": "195710",
    "end": "202880"
  },
  {
    "text": "in and run all the tests every time have",
    "start": "202880",
    "end": "209660"
  },
  {
    "text": "an overall score that's actually the",
    "start": "209660",
    "end": "214910"
  },
  {
    "text": "basic overview of mutation testing mutator is the interesting part that actually does the thing and then yeah",
    "start": "214910",
    "end": "224440"
  },
  {
    "text": "but outside of killed and survived it's",
    "start": "224440",
    "end": "230390"
  },
  {
    "start": "228000",
    "end": "334000"
  },
  {
    "text": "also part of the survive mutants that we don't want because they actually didn't",
    "start": "230390",
    "end": "236030"
  },
  {
    "text": "change anything about the behavior of the code in example before the the large",
    "start": "236030",
    "end": "243590"
  },
  {
    "text": "the smaller than equal didn't actually get killed by a test but maybe there is",
    "start": "243590",
    "end": "249950"
  },
  {
    "text": "a guarantee that the only way it differs if is if it is if it's bigger so you",
    "start": "249950",
    "end": "256790"
  },
  {
    "text": "have outside guarantees that it will never be smaller so that test doesn't actually that mutation doesn't change",
    "start": "256790",
    "end": "262640"
  },
  {
    "text": "anything about the code so we want to",
    "start": "262640",
    "end": "268700"
  },
  {
    "text": "discard those as for the",
    "start": "268700",
    "end": "274960"
  },
  {
    "text": "for the event for the total score the problem is that is a lot of manual labor",
    "start": "283160",
    "end": "289340"
  },
  {
    "text": "because it requires human analysis of the codes because static analyzers aren't usually there yet and there are a",
    "start": "289340",
    "end": "296060"
  },
  {
    "text": "lot of cases they won't be able to catch one major example is one classic example",
    "start": "296060",
    "end": "304520"
  },
  {
    "text": "of a mutation that should always be different is changing plus 2 or minus",
    "start": "304520",
    "end": "310030"
  },
  {
    "text": "but if you have a piece of code that that checks if the sum of a list of",
    "start": "310030",
    "end": "318530"
  },
  {
    "text": "numbers is 0 it doesn't matter if you use plus or minus so that's a reason why",
    "start": "318530",
    "end": "326660"
  },
  {
    "text": "equipped why automatically detecting the equivalent mutants and discarding them is really hard it's basically the",
    "start": "326660",
    "end": "332930"
  },
  {
    "text": "halting problem so what can you get out of mutation testing I could get an",
    "start": "332930",
    "end": "339200"
  },
  {
    "start": "334000",
    "end": "417000"
  },
  {
    "text": "overall score of your test suite you could get a score of every test at how",
    "start": "339200",
    "end": "348620"
  },
  {
    "text": "good a particular test is at catching bugs in the code it executes another",
    "start": "348620",
    "end": "354010"
  },
  {
    "text": "thing you can get is redundant test if you have several tests that all kill exactly are almost exactly the same set",
    "start": "354010",
    "end": "361100"
  },
  {
    "text": "of mutants they might be testing the exact same thing and you might be able to throw one out and if your test Suites",
    "start": "361100",
    "end": "367010"
  },
  {
    "text": "execute faster and one other thing that I find personally it's functionally dead",
    "start": "367010",
    "end": "373400"
  },
  {
    "text": "code code that gets executed as side effects but they don't actually matter to the end result this happens a lot",
    "start": "373400",
    "end": "382190"
  },
  {
    "text": "when you're dealing with complex code you have some later refactorings and it",
    "start": "382190",
    "end": "387830"
  },
  {
    "text": "turns out it's a complicated piece of logic the results of it always get overridden later even though it still",
    "start": "387830",
    "end": "393830"
  },
  {
    "text": "runs and I could remove like a dozen lines of very complicated conditionals",
    "start": "393830",
    "end": "400070"
  },
  {
    "text": "to find an edge case because later in the code there was a guarantee that it",
    "start": "400070",
    "end": "406600"
  },
  {
    "text": "would always get found there because that was a better place to find that",
    "start": "406600",
    "end": "411890"
  },
  {
    "text": "case so keeping that in mind let's go over",
    "start": "411890",
    "end": "419020"
  },
  {
    "text": "what choices you need to make if you want to start doing mutation testing",
    "start": "419020",
    "end": "424229"
  },
  {
    "text": "first level of choice is what's what the",
    "start": "424229",
    "end": "435009"
  },
  {
    "text": "thing is you're actually mutating you can have most simple tool that looks at",
    "start": "435009",
    "end": "445810"
  },
  {
    "text": "source code change the source code big disadvantage here is that you need to compile and Link every single mutant",
    "start": "445810",
    "end": "452699"
  },
  {
    "text": "you need to go through the whole compile cycle and for some code bases that is really heavy to do another option is",
    "start": "452699",
    "end": "462360"
  },
  {
    "text": "doing tation at the LLVM ir level these are exactly the same mutations just in",
    "start": "462360",
    "end": "469750"
  },
  {
    "text": "ir syntax where you can then use a cheat to then only compile and Link in the",
    "start": "469750",
    "end": "479259"
  },
  {
    "text": "small mutation and all the rest is already compiled in linked so that gives",
    "start": "479259",
    "end": "486039"
  },
  {
    "text": "a way faster feedback loop the problem is that not all mutations at this level",
    "start": "486039",
    "end": "491080"
  },
  {
    "text": "have representation at a source so it might not actually be a bad program it could make so it's not really worth",
    "start": "491080",
    "end": "497949"
  },
  {
    "text": "testing for and those need to be filtered out which is again a hard problem and if you want to go even",
    "start": "497949",
    "end": "506889"
  },
  {
    "text": "further you can even mutate binary literal assembly code and they get even",
    "start": "506889",
    "end": "518018"
  },
  {
    "text": "more speed advantage but even more garbage mutants that don't have",
    "start": "518019",
    "end": "523120"
  },
  {
    "text": "representation in the code so it's trade-off like how important is it that",
    "start": "523120",
    "end": "530199"
  },
  {
    "text": "the feedback loop is fast which it's very important because if you're",
    "start": "530199",
    "end": "536050"
  },
  {
    "text": "mutating every single plus in the code to a minus 1 by 1 or a minus",
    "start": "536050",
    "end": "541990"
  },
  {
    "text": "remove minus 1 or change all these checks into multiple",
    "start": "541990",
    "end": "548180"
  },
  {
    "text": "mutants it's it's a lot of computation time so let's talk about rare in the",
    "start": "548180",
    "end": "559310"
  },
  {
    "text": "codes to put mutations which is another configuration choice you make with the",
    "start": "559310",
    "end": "566210"
  },
  {
    "start": "566000",
    "end": "798000"
  },
  {
    "text": "tools so occasions you can just mutate",
    "start": "566210",
    "end": "572450"
  },
  {
    "text": "all of the code which will give you the",
    "start": "572450",
    "end": "577580"
  },
  {
    "text": "most direct analog to code coverage but",
    "start": "577580",
    "end": "585400"
  },
  {
    "text": "if core is not covered those mutants won't get actually hit by any test but",
    "start": "585400",
    "end": "591470"
  },
  {
    "text": "you will run the whole test suite and waste a lot of time if you have coverage",
    "start": "591470",
    "end": "597590"
  },
  {
    "text": "information I'm not saying coverage isn't good I am only saying it's not good as a metric for how good your tests",
    "start": "597590",
    "end": "603740"
  },
  {
    "text": "are you can only generate mutants in covered codes but if you want to then",
    "start": "603740",
    "end": "612800"
  },
  {
    "text": "use the result you get out of that as a general statistic you need good task of you need good coverage to start with a",
    "start": "612800",
    "end": "621520"
  },
  {
    "text": "small distinction to this is directly covered codes where the idea is that",
    "start": "621520",
    "end": "626720"
  },
  {
    "text": "tests only really tests goes up to three",
    "start": "626720",
    "end": "632930"
  },
  {
    "text": "levels of the call stack and anything deeper is probably library code that should have separate tests because this",
    "start": "632930",
    "end": "640310"
  },
  {
    "text": "testing something that's called 5 6",
    "start": "640310",
    "end": "646370"
  },
  {
    "text": "levels deep in the call stack it's unlikely to find the bug in that thing but in how it is used instead and one",
    "start": "646370",
    "end": "655820"
  },
  {
    "text": "more instead of running it over your whole codebase you could and you",
    "start": "655820",
    "end": "662270"
  },
  {
    "text": "probably should if you have a large enough code base only run it on code that's actually actively developed a nut",
    "start": "662270",
    "end": "668180"
  },
  {
    "text": "code that has been basically an internal library for 20 years and we already know",
    "start": "668180",
    "end": "674030"
  },
  {
    "text": "that it works well because we stopped finding bugs and still in have use and",
    "start": "674030",
    "end": "681050"
  },
  {
    "text": "take a picture so next up the mutator",
    "start": "681050",
    "end": "689120"
  },
  {
    "text": "itself which mittens are we actually going to generate on simple ones like",
    "start": "689120",
    "end": "694790"
  },
  {
    "text": "what I already said replacing operators so an a a plus can",
    "start": "694790",
    "end": "700040"
  },
  {
    "text": "be replaced by a minus multiply or divide that one there is a pretty simple",
    "start": "700040",
    "end": "706870"
  },
  {
    "text": "statement deletions for statements with",
    "start": "706870",
    "end": "712430"
  },
  {
    "text": "no they are not required for the rest of the logic of the code to still compile",
    "start": "712430",
    "end": "718279"
  },
  {
    "text": "so all Ford calls I'll see out calls whatever can remove them and see if the",
    "start": "718279",
    "end": "726440"
  },
  {
    "text": "tests catch that you're not having a side effect anymore",
    "start": "726440",
    "end": "732519"
  },
  {
    "text": "you can of course start mutating object-oriented programming constructs",
    "start": "732730",
    "end": "739459"
  },
  {
    "text": "so here we have a parent with a virtual function a child with that function that of writes hit the against the parent has",
    "start": "739459",
    "end": "746329"
  },
  {
    "text": "an implementation so what if we move the implementation in child it will now",
    "start": "746329",
    "end": "751520"
  },
  {
    "text": "always call her parents if if tests don't check that the stuff that the child was different from the parents",
    "start": "751520",
    "end": "757370"
  },
  {
    "text": "actually happens you need to check for that another interesting thing which",
    "start": "757370",
    "end": "765579"
  },
  {
    "text": "might make some people think of how hard it is to test for this training",
    "start": "765579",
    "end": "771950"
  },
  {
    "text": "constructs you have to log arts that take to me Texas in order",
    "start": "771950",
    "end": "776990"
  },
  {
    "text": "what if you switch them around there are tools that are specifically made to to",
    "start": "776990",
    "end": "785570"
  },
  {
    "text": "do these kinds of mutations to check that you have good trading tests",
    "start": "785570",
    "end": "791390"
  },
  {
    "text": "links at the end of the presentation",
    "start": "791390",
    "end": "797500"
  },
  {
    "start": "798000",
    "end": "877000"
  },
  {
    "text": "some optimizations in generating mutants if mutant schemata which is the idea",
    "start": "798160",
    "end": "805279"
  },
  {
    "text": "that you only generate mutants once and then choose between them at run time with a global flag so instead of you",
    "start": "805279",
    "end": "813529"
  },
  {
    "text": "mutate this to and immediately invoked lambda that then switches which side affected us at one",
    "start": "813529",
    "end": "821180"
  },
  {
    "text": "time based on mutant slacker also for",
    "start": "821180",
    "end": "827090"
  },
  {
    "text": "the generation end testing actually distributed use a server farm so each",
    "start": "827090",
    "end": "835190"
  },
  {
    "text": "row every single file you have or use some other division method two different",
    "start": "835190",
    "end": "841730"
  },
  {
    "text": "notes in your network the h2 mutation testing on that file and",
    "start": "841730",
    "end": "847250"
  },
  {
    "text": "then try the results back to a main collector which can of course give you",
    "start": "847250",
    "end": "857840"
  },
  {
    "text": "an almost perfect parallel speed up because each of those things can be done",
    "start": "857840",
    "end": "864200"
  },
  {
    "text": "completely in parallel because each test runs independent of the others because",
    "start": "864200",
    "end": "869420"
  },
  {
    "text": "you're only testing one here and at a time moving on to the testing itself I",
    "start": "869420",
    "end": "877270"
  },
  {
    "start": "877000",
    "end": "980000"
  },
  {
    "text": "do run tests they run all tests every single time if you don't have coverage",
    "start": "877270",
    "end": "882320"
  },
  {
    "text": "information that's basically all we can do you look at what tests actually",
    "start": "882320",
    "end": "888290"
  },
  {
    "text": "covered the mutant you made and only run those tests you can change you what all",
    "start": "888290",
    "end": "898070"
  },
  {
    "text": "your on the test if you want total result for the test suite you can do this and use tests that either already",
    "start": "898070",
    "end": "905690"
  },
  {
    "text": "run quickly or that have already proven themselves over time to be very good",
    "start": "905690",
    "end": "910910"
  },
  {
    "text": "mutant killers to run them first so you get results faster and you don't need to run the longer running tests because the",
    "start": "910910",
    "end": "917150"
  },
  {
    "text": "mutants has already been killed something other tools need to do is check for infinite loops that is",
    "start": "917150",
    "end": "924920"
  },
  {
    "text": "introduced so I just timeout time dynamically by seeing what the code base",
    "start": "924920",
    "end": "931520"
  },
  {
    "text": "does if it's an infinite loop one tool I know does this also blink at the end it",
    "start": "931520",
    "end": "941030"
  },
  {
    "text": "starts at like a time out of five seconds but it's configurable and then when it notices an infinite loop",
    "start": "941030",
    "end": "948170"
  },
  {
    "text": "it's attend dynamically changes the",
    "start": "948170",
    "end": "953600"
  },
  {
    "text": "timeout it uses to have a better idea of",
    "start": "953600",
    "end": "958990"
  },
  {
    "text": "what is infinite loop and what is just the program taking a bit longer than usual I'm actually going way faster",
    "start": "958990",
    "end": "972350"
  },
  {
    "text": "through my slides and I thought I was already halfway through my thing and I'm",
    "start": "972350",
    "end": "977779"
  },
  {
    "text": "rolling 50 minutes in well time to make this info table longer so they should be",
    "start": "977779",
    "end": "986510"
  },
  {
    "start": "980000",
    "end": "1066000"
  },
  {
    "text": "designed this was what I actually did for my master's thesis so the main",
    "start": "986510",
    "end": "993370"
  },
  {
    "text": "problem invitation design is that you want to make mutations that resemble",
    "start": "993370",
    "end": "999139"
  },
  {
    "text": "bugs that programmers would make and that would be able to go to code review",
    "start": "999139",
    "end": "1007779"
  },
  {
    "text": "and be overlooked because they're small changes and that stuff so we have very",
    "start": "1007779",
    "end": "1016420"
  },
  {
    "text": "similar graph to the earlier one but here we have a set of all buting's we",
    "start": "1016420",
    "end": "1021430"
  },
  {
    "text": "have developed ones so the ones that compile and then we have the equivalent ones and equivalents is the main problem",
    "start": "1021430",
    "end": "1030010"
  },
  {
    "text": "in design because you need to at least try to remove remove as many of those as",
    "start": "1030010",
    "end": "1039370"
  },
  {
    "text": "possible so that there's less human effort involved after the fact and",
    "start": "1039370",
    "end": "1044699"
  },
  {
    "text": "here's my actual example that I used earlier because I didn't think like yeah",
    "start": "1044699",
    "end": "1053100"
  },
  {
    "text": "so so let's start with the first",
    "start": "1055620",
    "end": "1064990"
  },
  {
    "text": "operator I made so initialize Lewis constructor for factor and string and",
    "start": "1064990",
    "end": "1072540"
  },
  {
    "start": "1066000",
    "end": "1174000"
  },
  {
    "text": "aggregates etc so C plus 11 you can create a vector of teams with just the",
    "start": "1072540",
    "end": "1079540"
  },
  {
    "text": "names in there and it will allocate the array in back-end and just fill it so",
    "start": "1079540",
    "end": "1086830"
  },
  {
    "text": "you have curly brackets and then you have a constructor of factory that creates a vector of 20 Jones",
    "start": "1086830",
    "end": "1094960"
  },
  {
    "text": "how many Jones are in the audience probably not many I try to pick a name",
    "start": "1094960",
    "end": "1100120"
  },
  {
    "text": "that was common but is interesting what",
    "start": "1100120",
    "end": "1106810"
  },
  {
    "text": "happens if you use if you use this with integral integral types so we have a",
    "start": "1106810",
    "end": "1113620"
  },
  {
    "text": "vector of 5 times 42 and you feel that",
    "start": "1113620",
    "end": "1122260"
  },
  {
    "text": "vector choosing iota so it will be 0 1 2",
    "start": "1122260",
    "end": "1127330"
  },
  {
    "text": "3 4 what happens if you change the brackets to curly brackets anyone want",
    "start": "1127330",
    "end": "1135220"
  },
  {
    "text": "to make it guess yeah what happens when",
    "start": "1135220",
    "end": "1141310"
  },
  {
    "text": "we run the exact same code the size is",
    "start": "1141310",
    "end": "1147720"
  },
  {
    "text": "not taken from the vector this is good I've seen boom that's what you get if",
    "start": "1147720",
    "end": "1156370"
  },
  {
    "text": "you're lucky otherwise you're just gonna start overwriting random data that's after the fact thing and you might go up",
    "start": "1156370",
    "end": "1162940"
  },
  {
    "text": "some heap some heap structures so after",
    "start": "1162940",
    "end": "1171970"
  },
  {
    "text": "we decide that this is an interesting one we need to do some analysis other cases",
    "start": "1171970",
    "end": "1177610"
  },
  {
    "start": "1174000",
    "end": "1261000"
  },
  {
    "text": "that we can detect statically in a tool",
    "start": "1177610",
    "end": "1182820"
  },
  {
    "text": "where it is where the code does the exact same thing",
    "start": "1182820",
    "end": "1188390"
  },
  {
    "text": "and yes there is - - there's another",
    "start": "1188390",
    "end": "1194100"
  },
  {
    "text": "case where or actually if the initializer list constructor would it",
    "start": "1194100",
    "end": "1201330"
  },
  {
    "text": "compile it uses the other constructor yeah curly brackets fall back on normal",
    "start": "1201330",
    "end": "1209310"
  },
  {
    "text": "constructors if initializer list doesn't overload correctly it was really fun to",
    "start": "1209310",
    "end": "1215520"
  },
  {
    "text": "find out I figured that I'd like three days before the conference invalidity",
    "start": "1215520",
    "end": "1221910"
  },
  {
    "text": "when doesn't it compile and like if we can detect this beforehand we don't need another compile cycle that will then",
    "start": "1221910",
    "end": "1228420"
  },
  {
    "text": "error out if you do the the operator in",
    "start": "1228420",
    "end": "1239070"
  },
  {
    "text": "the other direction which is also interesting these curly brackets now",
    "start": "1239070",
    "end": "1247800"
  },
  {
    "text": "don't work anymore so yeah this is pretty revealed to check in a tool that",
    "start": "1247800",
    "end": "1253800"
  },
  {
    "text": "this won't compile this is a very simple operator everybody should have put my",
    "start": "1253800",
    "end": "1259710"
  },
  {
    "text": "first operation here so range for loop again to give you the team you have",
    "start": "1259710",
    "end": "1266400"
  },
  {
    "start": "1261000",
    "end": "1330000"
  },
  {
    "text": "vectors names and we're going to change the first letter of each name to lowercase and yes I know this won't work",
    "start": "1266400",
    "end": "1273210"
  },
  {
    "text": "at Unicode and then you get second",
    "start": "1273210",
    "end": "1279750"
  },
  {
    "text": "Cynthia what there's a s1 little",
    "start": "1279750",
    "end": "1284970"
  },
  {
    "text": "character there there remove that",
    "start": "1284970",
    "end": "1291990"
  },
  {
    "text": "ampersand and suddenly you're just changing your copy of each name so the vectors say the same",
    "start": "1291990",
    "end": "1299450"
  },
  {
    "text": "so yeah this is something that STL warned about in a talk at CB peak on",
    "start": "1301230",
    "end": "1311570"
  },
  {
    "text": "2014 I think it was a panel and they each member of mandala to say what's the",
    "start": "1311570",
    "end": "1317639"
  },
  {
    "text": "worst feature C++ you know it's like having this as default because this is",
    "start": "1317639",
    "end": "1324659"
  },
  {
    "text": "mistake people make and that's my inspiration for this so equivalence",
    "start": "1324659",
    "end": "1330649"
  },
  {
    "start": "1330000",
    "end": "1403000"
  },
  {
    "text": "if this compiles if you only use consummate that's on each member then",
    "start": "1330649",
    "end": "1339630"
  },
  {
    "text": "you're not actually changing it so doing the stuff with the copy or doing the",
    "start": "1339630",
    "end": "1344760"
  },
  {
    "text": "stuff with a real thing doesn't change so yeah so ii can just try compiling",
    "start": "1344760",
    "end": "1351330"
  },
  {
    "text": "this instead and seeing if it works if it works it's going to be equivalent we can throw it away when this operator",
    "start": "1351330",
    "end": "1360090"
  },
  {
    "text": "doesn't work and will not compile everything is not copyable this won't",
    "start": "1360090",
    "end": "1366510"
  },
  {
    "text": "work so we need to check for that but yeah checking for culpability it's also",
    "start": "1366510",
    "end": "1373590"
  },
  {
    "text": "pretty real there are more interesting",
    "start": "1373590",
    "end": "1380909"
  },
  {
    "text": "equivalence cases but that usually boils down to calling a function that takes it",
    "start": "1380909",
    "end": "1386549"
  },
  {
    "text": "by reference but doesn't actually mutate it but if the tool can't see the implementation of the function or it",
    "start": "1386549",
    "end": "1392220"
  },
  {
    "text": "would require a lot of heavy static analysis yeah you can't easily check for",
    "start": "1392220",
    "end": "1398789"
  },
  {
    "text": "that automatically so that's left to the humans afterwards and now it come to",
    "start": "1398789",
    "end": "1404820"
  },
  {
    "start": "1403000",
    "end": "1517000"
  },
  {
    "text": "lambdas I'll start with a simple function that just adds miss to the",
    "start": "1404820",
    "end": "1412350"
  },
  {
    "text": "front of the name we have again vectors vectors names we transform and we put",
    "start": "1412350",
    "end": "1420809"
  },
  {
    "text": "this in front of each or our names but what if you want to like do it as a",
    "start": "1420809",
    "end": "1428460"
  },
  {
    "text": "one-liner you can write lump there what if you want to",
    "start": "1428460",
    "end": "1434930"
  },
  {
    "text": "to make the thing you're adding to it a variable so you can change it at one",
    "start": "1434930",
    "end": "1441090"
  },
  {
    "text": "time you make it variable and you captured by value so you gets copied",
    "start": "1441090",
    "end": "1446670"
  },
  {
    "text": "into the lambda and then you add neither",
    "start": "1446670",
    "end": "1454200"
  },
  {
    "text": "the same thing but you can then do is make this pre Pender actually function",
    "start": "1454200",
    "end": "1462300"
  },
  {
    "text": "that returns such a lambda and then if pre Pender with misses and then you get",
    "start": "1462300",
    "end": "1469500"
  },
  {
    "text": "again the same result what happens if you don't catch up a value by reference",
    "start": "1469500",
    "end": "1476030"
  },
  {
    "text": "so now that lambda there holds a reference to the argument prepend we",
    "start": "1476030",
    "end": "1483750"
  },
  {
    "text": "think it's returned so you get a reference to a local variable outer",
    "start": "1483750",
    "end": "1490260"
  },
  {
    "text": "scope these are a few results I managed to coax out of some compilers so you can",
    "start": "1490260",
    "end": "1498690"
  },
  {
    "text": "get kharbut results you can get a crash you can get you can actually get the right",
    "start": "1498690",
    "end": "1504930"
  },
  {
    "text": "results which is the problem yeah that's",
    "start": "1504930",
    "end": "1512160"
  },
  {
    "text": "another mutator which i much fun designing so again equivalence first up",
    "start": "1512160",
    "end": "1520470"
  },
  {
    "start": "1517000",
    "end": "1608000"
  },
  {
    "text": "if the capture list is actually empty or equivalent to capturing this pointer",
    "start": "1520470",
    "end": "1526550"
  },
  {
    "text": "changing value capture to reference capture it doesn't change anything so that's done or if the the lambda is",
    "start": "1526550",
    "end": "1535140"
  },
  {
    "text": "being passed into something that only use it locally you can use either and it",
    "start": "1535140",
    "end": "1540930"
  },
  {
    "text": "will work because if the variables never go our scope passing it into something",
    "start": "1540930",
    "end": "1547170"
  },
  {
    "text": "is is dangerous if it ends up getting stored somewhere and then run on a",
    "start": "1547170",
    "end": "1552840"
  },
  {
    "text": "different thread or something because then it's very likely to be our scope in go boom invalidity is was really hard to",
    "start": "1552840",
    "end": "1563460"
  },
  {
    "text": "find yes it will just compile like capturing",
    "start": "1563460",
    "end": "1570450"
  },
  {
    "text": "by reference will always compile there's no no way outside of having tackle type",
    "start": "1570450",
    "end": "1579409"
  },
  {
    "text": "static asserts inside of the lambda to check if you captured by failure reference to make it not compile but I",
    "start": "1579409",
    "end": "1588539"
  },
  {
    "text": "found a way touch W error compilers",
    "start": "1588539",
    "end": "1595019"
  },
  {
    "text": "warned about returning reference to local variables even if they're inside of a lambda and that brings me to",
    "start": "1595019",
    "end": "1603450"
  },
  {
    "text": "something Phyllis mentioned several times in this course compilation is test",
    "start": "1603450",
    "end": "1609679"
  },
  {
    "start": "1608000",
    "end": "1659000"
  },
  {
    "text": "because we said that like invalid mutants they just don't compile so",
    "start": "1609679",
    "end": "1615720"
  },
  {
    "text": "they're not interesting for the score of the suite but what if you use compile",
    "start": "1615720",
    "end": "1623070"
  },
  {
    "text": "time tests what if you static asserts as part of your test suite what do we do with them do we count them as guilt",
    "start": "1623070",
    "end": "1633120"
  },
  {
    "text": "mutants or do we condemn as invalid mutants but then you don't get a good",
    "start": "1633120",
    "end": "1638309"
  },
  {
    "text": "idea of how good your compile time test wheel is eye-catching bugs this is a really interesting problem",
    "start": "1638309",
    "end": "1644970"
  },
  {
    "text": "I've had our long discussions with several people about this and we can't",
    "start": "1644970",
    "end": "1650879"
  },
  {
    "text": "find a good answer so if anyone has ideas feel free and it turns out I",
    "start": "1650879",
    "end": "1656909"
  },
  {
    "text": "managed to go through all my slides in half an hour oops I should have done the right ones",
    "start": "1656909",
    "end": "1664128"
  },
  {
    "start": "1659000",
    "end": "1785000"
  },
  {
    "text": "so any questions",
    "start": "1664730",
    "end": "1668658"
  },
  {
    "text": "like yeah if you can have a way to",
    "start": "1696880",
    "end": "1705850"
  },
  {
    "text": "detect those and well I went to Phil",
    "start": "1705850",
    "end": "1712159"
  },
  {
    "text": "stark earlier um errors and their error",
    "start": "1712159",
    "end": "1717649"
  },
  {
    "text": "handling stuff has a very specific syntax it's also mostly statically check so it might suddenly become invalid but",
    "start": "1717649",
    "end": "1727970"
  },
  {
    "text": "yeah that's indeed an interesting mutation and I don't think I've actually seen it to do that but the thing is that",
    "start": "1727970",
    "end": "1740710"
  },
  {
    "text": "checking for an error oftentimes that happens in like a separate if block it",
    "start": "1742029",
    "end": "1749269"
  },
  {
    "text": "just has an early return of the user an error there are mutations that just invert the condition of an of an if so",
    "start": "1749269",
    "end": "1757730"
  },
  {
    "text": "that will have the same effect so mutation tools will likely already have",
    "start": "1757730",
    "end": "1765970"
  },
  {
    "text": "mutations that will end up being that without actually remove trying to figure",
    "start": "1765970",
    "end": "1774169"
  },
  {
    "text": "out what code is error handling code and what the cause is regular code and removed error handling specifically the",
    "start": "1774169",
    "end": "1790639"
  },
  {
    "start": "1785000",
    "end": "2021000"
  },
  {
    "text": "first two are source level tools the second to our IR tools last one is is",
    "start": "1790639",
    "end": "1798309"
  },
  {
    "text": "the binary level tool the last one actually I can't find a public download",
    "start": "1798309",
    "end": "1803720"
  },
  {
    "text": "for it only the academic paper so you might need to contact the others if you",
    "start": "1803720",
    "end": "1809870"
  },
  {
    "text": "want it but yours are all downloadable textual mutates and use the X to mutate",
    "start": "1809870",
    "end": "1816470"
  },
  {
    "text": "is is mostly just regular simplices",
    "start": "1816470",
    "end": "1822710"
  },
  {
    "text": "mutations like mutating expressions if conditions removing calls to for",
    "start": "1822710",
    "end": "1830040"
  },
  {
    "text": "replacing a call with a value of that type just hard-coded those kind of",
    "start": "1830040",
    "end": "1837660"
  },
  {
    "text": "things new CBP does those things several",
    "start": "1837660",
    "end": "1843720"
  },
  {
    "text": "of those mediators but also has object-oriented programming mutations",
    "start": "1843720",
    "end": "1851150"
  },
  {
    "text": "not only like removing an implementation but also like inserting direct calls to",
    "start": "1851330",
    "end": "1858900"
  },
  {
    "text": "parent implementations or toying with dynamic cost that kind of stuff",
    "start": "1858900",
    "end": "1865350"
  },
  {
    "text": "Mel is is an IRA level tool that",
    "start": "1865350",
    "end": "1870980"
  },
  {
    "text": "basically also does all the basic mutations but it works at IR and it's",
    "start": "1871220",
    "end": "1877860"
  },
  {
    "text": "proven to be relatively fast they managed to do a mutation test of the",
    "start": "1877860",
    "end": "1884070"
  },
  {
    "text": "LLVM codebase so that's quite impressive",
    "start": "1884070",
    "end": "1889130"
  },
  {
    "text": "it's done by Alex Denisov and some other people and they were on CBP cast so you",
    "start": "1890930",
    "end": "1896880"
  },
  {
    "text": "might want to go look that episode up CC mute air is mutation tool on on trading",
    "start": "1896880",
    "end": "1903840"
  },
  {
    "text": "stuff it also works at IR level and it just plays with all of the POSIX calls",
    "start": "1903840",
    "end": "1909080"
  },
  {
    "text": "that happen underneath and X emu is",
    "start": "1909080",
    "end": "1914630"
  },
  {
    "text": "based on Q EMU so it's does emulation",
    "start": "1914630",
    "end": "1919710"
  },
  {
    "text": "but it's handy for verifying stuff you don't have a source code for but only",
    "start": "1919710",
    "end": "1925050"
  },
  {
    "text": "binary so you can see if your tests actually verify the stuff inside of",
    "start": "1925050",
    "end": "1930210"
  },
  {
    "text": "things you can you can't mutate that source or IR level so maybe some",
    "start": "1930210",
    "end": "1936330"
  },
  {
    "text": "embedded folks might want to check it out",
    "start": "1936330",
    "end": "1939740"
  },
  {
    "text": "I was curious whether you have had any issues with in C++ using overloaded",
    "start": "1943720",
    "end": "1949570"
  },
  {
    "text": "operators if operators are one of the communication well to test or to do",
    "start": "1949570",
    "end": "1966639"
  },
  {
    "text": "mutation zone well to scan check if you",
    "start": "1966639",
    "end": "1975460"
  },
  {
    "text": "can subtract before generating the imitation a TRL at the IR level that",
    "start": "1975460",
    "end": "1982870"
  },
  {
    "text": "just turns into calls so you you have no real there are other mutate mutations",
    "start": "1982870",
    "end": "1990159"
  },
  {
    "text": "that then just call another function or something but yeah at the source level",
    "start": "1990159",
    "end": "1997500"
  },
  {
    "text": "it will just replace it and hope that it compiles or checks that it will compile",
    "start": "1997500",
    "end": "2004100"
  },
  {
    "text": "but yeah if you have a good type system a lot of mutations won't be possible so",
    "start": "2004100",
    "end": "2009509"
  },
  {
    "text": "you'll get a good score if you count things that are killed by the type",
    "start": "2009509",
    "end": "2014700"
  },
  {
    "text": "system or other compiler checks as skilled sorry there in a Santa question",
    "start": "2014700",
    "end": "2047270"
  },
  {
    "start": "2021000",
    "end": "2178000"
  },
  {
    "text": "but there is research at like higher level mutations like stuff that does",
    "start": "2047270",
    "end": "2053760"
  },
  {
    "text": "more than just single and there's",
    "start": "2053760",
    "end": "2060440"
  },
  {
    "text": "somewhat of conflict in the between papers because some papers say these",
    "start": "2060440",
    "end": "2067319"
  },
  {
    "text": "low-level mutations give basically the same results as the higher-level mutations but then always say that the",
    "start": "2067319",
    "end": "2073710"
  },
  {
    "text": "high level mutations have an advantage because there will be less of them so you don't need to run as many Browns but",
    "start": "2073710",
    "end": "2080339"
  },
  {
    "text": "the tools the windows are also more complex so they have more processing time before they can do a mutation so",
    "start": "2080339",
    "end": "2087679"
  },
  {
    "text": "and then the land are captured by a reference here this flight was actually",
    "start": "2095419",
    "end": "2112289"
  },
  {
    "text": "just me building up to this being the actual source codes because I was not",
    "start": "2112289",
    "end": "2119009"
  },
  {
    "text": "sure how many people knew how land laws worked so I was trying to build up to it instead of throwing a function that",
    "start": "2119009",
    "end": "2126480"
  },
  {
    "text": "returns another function well in this",
    "start": "2126480",
    "end": "2151980"
  },
  {
    "text": "case that no this entry doesn't live beyond the propeller like there are also",
    "start": "2151980",
    "end": "2177960"
  },
  {
    "text": "mutators that let me just go back to the slides if people want links there are",
    "start": "2177960",
    "end": "2184950"
  },
  {
    "start": "2178000",
    "end": "2665000"
  },
  {
    "text": "mutaters that like that give a reason to",
    "start": "2184950",
    "end": "2190109"
  },
  {
    "text": "use strong types because if there's a function that takes multiple arguments",
    "start": "2190109",
    "end": "2195569"
  },
  {
    "text": "of the same type some Beauty meteors just switch the order around and see",
    "start": "2195569",
    "end": "2202259"
  },
  {
    "text": "what happens there are lots of fun mutations to do",
    "start": "2202259",
    "end": "2207799"
  },
  {
    "text": "how much do you need I mean if you want to get your first music thing to run how",
    "start": "2208650",
    "end": "2214210"
  },
  {
    "text": "much how much how hard is it most of these pretty much just need a",
    "start": "2214210",
    "end": "2221200"
  },
  {
    "text": "Clank compilation database and they can start decks to mutate is clang based",
    "start": "2221200",
    "end": "2229290"
  },
  {
    "text": "Mississippi I'm it's on the client base so that will also yeah actually both the",
    "start": "2229290",
    "end": "2236309"
  },
  {
    "text": "source level and the IR level mutaters here are all client based so if your",
    "start": "2236309",
    "end": "2241809"
  },
  {
    "text": "code base can pass with clang or you can hack a compilation database together",
    "start": "2241809",
    "end": "2247329"
  },
  {
    "text": "with something else like I use something at our code base because we compile GCC",
    "start": "2247329",
    "end": "2252520"
  },
  {
    "text": "and clang doesn't really like some of our source files so yeah there's a tool",
    "start": "2252520",
    "end": "2262030"
  },
  {
    "text": "that's it basically wraps the make command and then sees all the compiler",
    "start": "2262030",
    "end": "2267099"
  },
  {
    "text": "implications that will also give you a compilation database see ya what are",
    "start": "2267099",
    "end": "2273160"
  },
  {
    "text": "these tools you just need a compilation database and a little bit of",
    "start": "2273160",
    "end": "2280900"
  },
  {
    "text": "configuration to make the choices of the things you want like which parts of the code base you want to mutate what mute",
    "start": "2280900",
    "end": "2287770"
  },
  {
    "text": "is to turn on or off that kind of thing and then you can basically run them all",
    "start": "2287770",
    "end": "2297670"
  },
  {
    "text": "so these are pretty easy setup if you",
    "start": "2297670",
    "end": "2302770"
  },
  {
    "text": "have a somewhat sane build system it's a",
    "start": "2302770",
    "end": "2313630"
  },
  {
    "text": "big chase on file that clang tools can use so if you can use Clank tools on your code base you can use these",
    "start": "2313630",
    "end": "2321030"
  },
  {
    "text": "database you can export that's a giant JSON file with compiled commands for each of these source files yeah yeah",
    "start": "2329029",
    "end": "2334569"
  },
  {
    "text": "yeah Tennessee mycotic no see mike has to be able to do that for yeah that's a",
    "start": "2334569",
    "end": "2365449"
  },
  {
    "text": "setup you could do yeah these tools usually well I can actually just go to",
    "start": "2365449",
    "end": "2372739"
  },
  {
    "text": "one of them and see the documentation Milus well now I'm gonna need to just",
    "start": "2372739",
    "end": "2384130"
  },
  {
    "text": "you just duplicate that makes makes simple so this is small it is IDE",
    "start": "2392280",
    "end": "2400200"
  },
  {
    "text": "integration with some IDs with Xcode so",
    "start": "2400200",
    "end": "2407550"
  },
  {
    "text": "you can see which one survived or what what what tool did yeah now I don't",
    "start": "2407550",
    "end": "2422910"
  },
  {
    "text": "actually have numbers sorry but yeah",
    "start": "2422910",
    "end": "2428270"
  },
  {
    "text": "well you can see they did the demo -",
    "start": "2429050",
    "end": "2435990"
  },
  {
    "text": "testing on OpenSSL and the timings a few",
    "start": "2435990",
    "end": "2443610"
  },
  {
    "text": "minutes but that's really good rest yeah two minutes ish for OpenSSL which",
    "start": "2443610",
    "end": "2453210"
  },
  {
    "text": "is not that big of a code base but quite a complicated one so and then yeah",
    "start": "2453210",
    "end": "2464660"
  },
  {
    "text": "burning stuff what did i do on LLVM wait",
    "start": "2464660",
    "end": "2471270"
  },
  {
    "text": "they only know this format Lee I know they also did did it on part of LLVM but",
    "start": "2471270",
    "end": "2479720"
  },
  {
    "text": "it doesn't seem to be in this with me River yeah it can be pretty fast at IR",
    "start": "2479720",
    "end": "2487200"
  },
  {
    "text": "level you only need to recompile from IR to two binary and just get that in so",
    "start": "2487200",
    "end": "2496580"
  },
  {
    "text": "only that part will be maybe a little bit slower than the rest of the course I don't know I don't know all the details",
    "start": "2496580",
    "end": "2503280"
  },
  {
    "text": "of mo for that go off Alex Denis off on",
    "start": "2503280",
    "end": "2509070"
  },
  {
    "text": "Twitter or something",
    "start": "2509070",
    "end": "2511700"
  },
  {
    "text": "don't look like the range of mutations",
    "start": "2515360",
    "end": "2520950"
  },
  {
    "text": "are available pretty much is decided by the tool or or any of them so you can",
    "start": "2520950",
    "end": "2527310"
  },
  {
    "text": "make your own well most of these tools are open-source so you could at your own",
    "start": "2527310",
    "end": "2534570"
  },
  {
    "text": "if you know enough about writing LLVM code",
    "start": "2534570",
    "end": "2540270"
  },
  {
    "text": "well clank from that most well Mali's LVM but text to mutate is a source level",
    "start": "2540270",
    "end": "2546390"
  },
  {
    "text": "so you would write clang matures and those things actually friend of mine is",
    "start": "2546390",
    "end": "2553830"
  },
  {
    "text": "not doing his PhD on making a distributed version of dex tool so that",
    "start": "2553830",
    "end": "2559380"
  },
  {
    "text": "might be a feature that's coming i",
    "start": "2559380",
    "end": "2570770"
  },
  {
    "text": "haven't maybe they have done that on their own code but well the thing is",
    "start": "2570770",
    "end": "2587070"
  },
  {
    "text": "there's a reason all of these tools are basically all based on clang because clang is the only parser that's easily",
    "start": "2587070",
    "end": "2594240"
  },
  {
    "text": "to hook into and sip a source language is very heavy to parse",
    "start": "2594240",
    "end": "2602900"
  },
  {
    "text": "turns out i was able to find all of my mutation sites which just grab because",
    "start": "2603530",
    "end": "2609330"
  },
  {
    "text": "my imitations are pretty simple and easy to grab for but others aren't I actually",
    "start": "2609330",
    "end": "2618720"
  },
  {
    "text": "didn't have the time to build those mutaters and there's the team of you cpp",
    "start": "2618720",
    "end": "2625560"
  },
  {
    "text": "was working on it but then the priorities got changed and they needed to get some PhD out fast and at some",
    "start": "2625560",
    "end": "2633870"
  },
  {
    "text": "other conferences they needed so might be a while until we actually get an",
    "start": "2633870",
    "end": "2639150"
  },
  {
    "text": "implementation of those is their front useful my numbers say they are but",
    "start": "2639150",
    "end": "2646670"
  },
  {
    "text": "only checked a few code bases more",
    "start": "2646670",
    "end": "2651900"
  },
  {
    "text": "questions",
    "start": "2651900",
    "end": "2654260"
  },
  {
    "text": "hello English [Applause]",
    "start": "2662230",
    "end": "2667099"
  }
]