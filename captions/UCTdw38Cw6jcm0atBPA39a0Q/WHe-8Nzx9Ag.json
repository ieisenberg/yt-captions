[
  {
    "text": "um yeah hello everyone um well thanks for coming to my talk my name is uh Timo dumla I'm also known as",
    "start": "8040",
    "end": "14099"
  },
  {
    "text": "Timor audio on Twitter I'm C plus plus developer Advocate at jetbrains we make the c-line IDE and other C plus",
    "start": "14099",
    "end": "21300"
  },
  {
    "text": "plus tools um and I'm actually here for the first time at NDC Tech town it's very exciting",
    "start": "21300",
    "end": "27720"
  },
  {
    "text": "to be here and I have a couple days ago agreed to the slightly crazy thing of doing three",
    "start": "27720",
    "end": "33899"
  },
  {
    "text": "talks in a row here so it's a bit of a talk Marathon um it's all going to be in",
    "start": "33899",
    "end": "39180"
  },
  {
    "text": "this room this is the first one of them and it's by far the most Niche and specialized topic out of the three talks",
    "start": "39180",
    "end": "45239"
  },
  {
    "text": "so it's interesting to see so many people turn up um I hope I hope you're not going to be too",
    "start": "45239",
    "end": "51360"
  },
  {
    "text": "disappointed um this is um a 60 Minute version of a",
    "start": "51360",
    "end": "57300"
  },
  {
    "text": "90-minute talk that I gave a couple months ago at C plus plus now and it's about electricity Atomic sharep",
    "start": "57300",
    "end": "63480"
  },
  {
    "text": "pointer now you might ask yourself uh why are we still talking about chat pointers in",
    "start": "63480",
    "end": "69479"
  },
  {
    "text": "2022 you know we learned that it's Global mutable State that's a bad thing we shouldn't be doing this we should be",
    "start": "69479",
    "end": "75960"
  },
  {
    "text": "doing value-based programming and then everything becomes fine well",
    "start": "75960",
    "end": "81600"
  },
  {
    "text": "um yes totally agree with that but Atomic set pointer actually has uh it's a kind of more specific thing which has",
    "start": "81600",
    "end": "86880"
  },
  {
    "text": "very interesting use cases and um so first of all when you talk about chat pointer itself",
    "start": "86880",
    "end": "93659"
  },
  {
    "text": "um who has been to the talk just before this one in room one Hannah dushikova lightning updates",
    "start": "93659",
    "end": "99659"
  },
  {
    "text": "okay a few people so she mentioned this if you make it a shared pointer to a const object then the whole problem of",
    "start": "99659",
    "end": "105600"
  },
  {
    "text": "mutable Global State kind of goes away but that's not what you're going to talk about we're going to talk about the atomic shot pointer path and that is",
    "start": "105600",
    "end": "113640"
  },
  {
    "text": "um also very useful in particular if you have objects that you need to share across threads and in particular if you",
    "start": "113640",
    "end": "120360"
  },
  {
    "text": "need to manage the lifetime of those objects across threads so you want to avoid scenarios where you know one",
    "start": "120360",
    "end": "126180"
  },
  {
    "text": "thread is deleting an object and another thread is still accessing it and stuff like that so Atomic shared pointer gives you a",
    "start": "126180",
    "end": "132780"
  },
  {
    "text": "very nice solution for that and if you've been to Hannah's talk just now she actually had you know an example for that she",
    "start": "132780",
    "end": "138840"
  },
  {
    "text": "actually was using that in her code where she was doing exactly this and you want to do it in a luxury way if you are",
    "start": "138840",
    "end": "145020"
  },
  {
    "text": "on some kind of time critical low latency time constrained system you don't want to",
    "start": "145020",
    "end": "150720"
  },
  {
    "text": "use a mutex there you don't want to wait on the mutex you don't want to run into the parenting version and things",
    "start": "150720",
    "end": "156060"
  },
  {
    "text": "like that and um also this topic of kind of flock free",
    "start": "156060",
    "end": "161220"
  },
  {
    "text": "uh log view Atomic SharePoint uh actually comes up um when you're not just sharing objects across threats in a",
    "start": "161220",
    "end": "167700"
  },
  {
    "text": "locky way but uh using lock fee structures log free data structures that's something that kind of often",
    "start": "167700",
    "end": "173640"
  },
  {
    "text": "often happens so you have something like a log VQ or a log free stack you know things like that",
    "start": "173640",
    "end": "179700"
  },
  {
    "text": "and it turns out um uh they're they're kind of multiple ways",
    "start": "179700",
    "end": "185940"
  },
  {
    "text": "to implement those and usually it gets very very complex um",
    "start": "185940",
    "end": "191099"
  },
  {
    "text": "and um but like there was a stock there was a talk by uh further because a couple um years ago where he identified",
    "start": "191099",
    "end": "197040"
  },
  {
    "text": "pretty much three kind of basic uh building blocks that you can use uh",
    "start": "197040",
    "end": "202500"
  },
  {
    "text": "to implement uh blockly data structures one of them is RCU read copy update another one is Hazard pointers and a",
    "start": "202500",
    "end": "208379"
  },
  {
    "text": "third one is the atomic sharep pointer um and they all have different trade-offs so you might want to use one",
    "start": "208379",
    "end": "214680"
  },
  {
    "text": "or the other or the third depending on what exactly you're trying to implement uh an atomic checkpoint there's obviously the one that we are going to",
    "start": "214680",
    "end": "220739"
  },
  {
    "text": "talk about here and it has some interesting properties in particular if you have a log free implementation both",
    "start": "220739",
    "end": "225900"
  },
  {
    "text": "reading and writing can be lock free on as many threads as you want basically simultaneously which is which is a very",
    "start": "225900",
    "end": "231659"
  },
  {
    "text": "interesting property and here's a paper by Hub Sutter which was the motivating paper for putting Atomic smart Atomic",
    "start": "231659",
    "end": "238620"
  },
  {
    "text": "sharep pointer into the standard and here he mentioned as the motivation ABI",
    "start": "238620",
    "end": "243720"
  },
  {
    "text": "robustness and efficiency and the ABA problem is something that you run into immediately if you're",
    "start": "243720",
    "end": "249239"
  },
  {
    "text": "trying to implement a log fee structure of your data structure in C plus plus it's basically this thing of uh you know",
    "start": "249239",
    "end": "254819"
  },
  {
    "text": "you have an object and then that gets removed but then another object gets placed into the same memory and then the",
    "start": "254819",
    "end": "260220"
  },
  {
    "text": "other thread cannot tell that the object actually has changed and then everything just explodes and it's very very complicated to get",
    "start": "260220",
    "end": "265860"
  },
  {
    "text": "around that problem if you look into for example real world implementations of kind of a multi-reader multi-writer lock",
    "start": "265860",
    "end": "272040"
  },
  {
    "text": "VQ like boost lock V has one Moody camel has one and you look into how they're",
    "start": "272040",
    "end": "277139"
  },
  {
    "text": "implemented and you're going to see that they're horrendously complicated there's this really like load store all these",
    "start": "277139",
    "end": "282240"
  },
  {
    "text": "operations have these like really really long implementations with really complicated cast Loops in them and it turns out this complexity comes from",
    "start": "282240",
    "end": "288360"
  },
  {
    "text": "basically two things a you need to manage the lifetime of your nodes your Elements which is quite",
    "start": "288360",
    "end": "293699"
  },
  {
    "text": "complex across threads and B you need to account for the ABA problem which is very very complicated to do in C plus",
    "start": "293699",
    "end": "300900"
  },
  {
    "text": "um and it turns out um Atomic SharePoint are kind of really nicely encapsulates both of those problems because obviously Atomic sharep",
    "start": "300900",
    "end": "308340"
  },
  {
    "text": "pointer manages the lifetime of the object so you kind of solve that problem and then also Atomic chat pointer",
    "start": "308340",
    "end": "313919"
  },
  {
    "text": "doesn't really um suffer from the ABA problem because sharepointers are aware of the identity of the objects that they're pointing to",
    "start": "313919",
    "end": "319560"
  },
  {
    "text": "right so if you have another shared pointer even if the object that points to lives in the same memory it's going",
    "start": "319560",
    "end": "325139"
  },
  {
    "text": "to be a different object but a different SharePoint are pointing to it so you don't have this ABA problem because sharepointers are aware of the identity",
    "start": "325139",
    "end": "331380"
  },
  {
    "text": "of their objects it turns out that if you use that as a building block then log fee programming becomes a lot more",
    "start": "331380",
    "end": "338340"
  },
  {
    "text": "kind of easy to reason about and so here's an example from herbs paper",
    "start": "338340",
    "end": "344400"
  },
  {
    "text": "uh where he's implementing a concurrent stack um and you can also do this with the",
    "start": "344400",
    "end": "350220"
  },
  {
    "text": "queue it's going to you know be pretty much the same size of code more or less",
    "start": "350220",
    "end": "356120"
  },
  {
    "text": "so what this does is it's a concurrent structure that supports uh pop and push",
    "start": "356120",
    "end": "361199"
  },
  {
    "text": "uh it's a stack so it's pop front and push fund and then it also supports find so you",
    "start": "361199",
    "end": "367680"
  },
  {
    "text": "can find an element and you can do any of those things simultaneously from as many threads as you want",
    "start": "367680",
    "end": "372919"
  },
  {
    "text": "and it's just going to work and the whole thing fits on the slide and this is the complete working implementation",
    "start": "372919",
    "end": "378660"
  },
  {
    "text": "okay so that's pretty cool and the secret here is this Atomic shot pointer",
    "start": "378660",
    "end": "384479"
  },
  {
    "text": "that's the thing that makes it possible because it kind of encapsulates like this whole complexity and it's this is",
    "start": "384479",
    "end": "390000"
  },
  {
    "text": "not necessarily the fastest um implementation you can come up with if you write everything out by hand",
    "start": "390000",
    "end": "395039"
  },
  {
    "text": "probably you're going to be and you're tweaking it to a use case you're probably gonna end up with something a bit faster but you know this is very",
    "start": "395039",
    "end": "401039"
  },
  {
    "text": "easy to reason about it's very useful kind of as a building block and",
    "start": "401039",
    "end": "406440"
  },
  {
    "text": "um yes and you want this to be Lock 3 if you're on a Time constrained system",
    "start": "406440",
    "end": "411660"
  },
  {
    "text": "um so we're gonna look later into how to achieve that before we do that let's briefly talk about",
    "start": "411660",
    "end": "417000"
  },
  {
    "text": "um sharepointers so we have three parts here right we have shared pointer Atomic and log free and I'm going to talk about all three obviously let's start with the",
    "start": "417000",
    "end": "423720"
  },
  {
    "text": "sharep pointer if you're here in this room I assume that you all know what a shared pointer does",
    "start": "423720",
    "end": "430620"
  },
  {
    "text": "um so I'm just gonna extremely briefly go through this this is what the C plus standard says about chat pointer it's a",
    "start": "430620",
    "end": "438180"
  },
  {
    "text": "smart pointer that stores a pointer usually obtained by a new so it's something that lives on the Heap and it implements semantics of shared",
    "start": "438180",
    "end": "445380"
  },
  {
    "text": "ownership and the last remaining owner of the pointers responsible for destroying the object so basically it implements ref counts",
    "start": "445380",
    "end": "452280"
  },
  {
    "text": "and implements kind of deterministic uh cleaning up of objects using ref count",
    "start": "452280",
    "end": "457800"
  },
  {
    "text": "how does it work under the hood here's like a very Bare Bones minimal implementation of a shared pointer",
    "start": "457800",
    "end": "464039"
  },
  {
    "text": "basically the SharePoint itself it's just this pointer to a control block there's this thing on the left and the",
    "start": "464039",
    "end": "469440"
  },
  {
    "text": "thing on the right is the control block itself which contains a pointer to the object that the SharePoint is managing it",
    "start": "469440",
    "end": "476280"
  },
  {
    "text": "contains a reference count ref count uh which in this case is one because we have one shared pointer that's pointing",
    "start": "476280",
    "end": "482699"
  },
  {
    "text": "to it and then we have the object itself that's the the yellow blob and depending on whether or not you allocate this with",
    "start": "482699",
    "end": "488099"
  },
  {
    "text": "make shared or not the object might or might not live in the same block of memory as the whole control block",
    "start": "488099",
    "end": "494940"
  },
  {
    "text": "and now what we can do is we can copy the SharePoint and create a new sharep pointer pointing to the same control block and then that's going to",
    "start": "494940",
    "end": "502020"
  },
  {
    "text": "increase the ref count right so now the ref comes two we can",
    "start": "502020",
    "end": "507060"
  },
  {
    "text": "delete that chat pointer object or like it will go out of scope somewhere and it's the structure is going to be called",
    "start": "507060",
    "end": "512520"
  },
  {
    "text": "and then um the refcon is going to decrease again to one and then if that one last set",
    "start": "512520",
    "end": "519539"
  },
  {
    "text": "pointer instance is also eventually going out of scope then the refcon is going to reach zero and as soon as that",
    "start": "519539",
    "end": "524700"
  },
  {
    "text": "happens uh the control block is going to actually deallocate the object and then it's going to deallocate",
    "start": "524700",
    "end": "531600"
  },
  {
    "text": "basically itself and again if you allocated this with makeshare then this whole thing will be a single the",
    "start": "531600",
    "end": "537540"
  },
  {
    "text": "allocation so this is basically how uh you know oversimplified how a SharePoint is implemented and now you want to make",
    "start": "537540",
    "end": "543779"
  },
  {
    "text": "this Atomic okay so that's the next thing we need to do what does atomic mean Atomic basically means it's thread",
    "start": "543779",
    "end": "549839"
  },
  {
    "text": "safe like you can operate on it from multiple threads and there's not going to be a race condition right this is pretty much what Atomic means",
    "start": "549839",
    "end": "557760"
  },
  {
    "text": "um so it's basically threat safe um the C plus standard doesn't really say very much about whether or not",
    "start": "557760",
    "end": "564260"
  },
  {
    "text": "shared pointer is threat safe it says this sentence here changes in",
    "start": "564260",
    "end": "570660"
  },
  {
    "text": "use count which is the ref count do not reflect modifications that can introduce data races this is this is all it says",
    "start": "570660",
    "end": "577500"
  },
  {
    "text": "about that so um what that means is if you have a sharep",
    "start": "577500",
    "end": "583860"
  },
  {
    "text": "pointer and you have a ref count of one and then on one thread you make a copy and then the refund is two and then on",
    "start": "583860",
    "end": "590279"
  },
  {
    "text": "another thread you make another copy and now the ref count is three uh both threats are going to agree that",
    "start": "590279",
    "end": "596160"
  },
  {
    "text": "the ref count is three and you're not going to have a data race and this is achieved by having the ref",
    "start": "596160",
    "end": "602700"
  },
  {
    "text": "can't be an atomic counter right so this is this is basically how this works this is how a shared pointer Works hopefully",
    "start": "602700",
    "end": "608700"
  },
  {
    "text": "this is not too surprising for anybody here um is this actually threat safe right so",
    "start": "608700",
    "end": "616200"
  },
  {
    "text": "so let's look at this um so we have a shared pointer we created with make shared and then as you",
    "start": "616200",
    "end": "623100"
  },
  {
    "text": "already said uh we're making a copy of that on one thread and we're making another copy of that on another thread",
    "start": "623100",
    "end": "628260"
  },
  {
    "text": "and that is fine as we just saw the ref count is atomic it's it's fine",
    "start": "628260",
    "end": "634440"
  },
  {
    "text": "what happens though if we flip this around on the second thread and now on one thread we copy the sharep pointer",
    "start": "634440",
    "end": "641580"
  },
  {
    "text": "and on another thread we are signing a new object to it or rather we assigning a new shared",
    "start": "641580",
    "end": "647160"
  },
  {
    "text": "pointer to it so we're copying on one thread and we're assigning to it on another thread is",
    "start": "647160",
    "end": "653160"
  },
  {
    "text": "this thread safe who thinks it is",
    "start": "653160",
    "end": "658500"
  },
  {
    "text": "who thinks it's not yeah this is a data race this is undefined Behavior",
    "start": "658500",
    "end": "665160"
  },
  {
    "text": "and um actually if you think about it it's not very surprising because um it actually behaves exactly like an",
    "start": "665160",
    "end": "670860"
  },
  {
    "text": "INT right if you have an integer you can copy it on one thread you can copy it on another thread and that's fine but if you copy it on one thread",
    "start": "670860",
    "end": "677220"
  },
  {
    "text": "and you read from it sorry if you copy it on one thread and you assign to it on another thread",
    "start": "677220",
    "end": "683160"
  },
  {
    "text": "that's a data race right so you need to make it an atomic end in order to for that not to happen",
    "start": "683160",
    "end": "688500"
  },
  {
    "text": "so it's it's the same thing as with an end really and this problem you know has been well known for a while",
    "start": "688500",
    "end": "694920"
  },
  {
    "text": "um that chat pointer isn't thread safe really you can't use it in this multi-thirded environment that we're",
    "start": "694920",
    "end": "700620"
  },
  {
    "text": "interested in like the stuff that Hannah was showing for example in the previous talk",
    "start": "700620",
    "end": "706220"
  },
  {
    "text": "um so since C plus 11 actually since we had shared pointer in the standard we also had this stuff understand that uh",
    "start": "706440",
    "end": "712800"
  },
  {
    "text": "which are these weird um kind of free standing functions um that allow Atomic operations on",
    "start": "712800",
    "end": "719399"
  },
  {
    "text": "shared pointer so we have these things 11 they're probably not very well known uh it's these freestanding functions and",
    "start": "719399",
    "end": "726120"
  },
  {
    "text": "they always have the name Atomic underscore whatever operation load store compare exchange Etc and then you pass",
    "start": "726120",
    "end": "733320"
  },
  {
    "text": "the pointer to the shared pointer that you want to operate on as the first argument there's like a really awkward",
    "start": "733320",
    "end": "739500"
  },
  {
    "text": "kind of non-c plus C API that we had now for a while",
    "start": "739500",
    "end": "745440"
  },
  {
    "text": "um and that's kind of all we have in a standard really and all we had understand that uh and uh you would use",
    "start": "745440",
    "end": "753060"
  },
  {
    "text": "it like this um so this is what you had to do before c plus 20 um instead of copying it and then",
    "start": "753060",
    "end": "759420"
  },
  {
    "text": "assigning it we would have to do an atomic load on one thread which is the copy and then an atomic store which is",
    "start": "759420",
    "end": "765360"
  },
  {
    "text": "the assignment on another thread and if you do this it's thread safe however it's not a great solution",
    "start": "765360",
    "end": "772200"
  },
  {
    "text": "first of all because they're freestanding functions it's you can't really efficiently Implement that that's kind of a more like an implementation",
    "start": "772200",
    "end": "778440"
  },
  {
    "text": "problem because you can't keep the state that you need to like keep track of the",
    "start": "778440",
    "end": "783899"
  },
  {
    "text": "multi-threaded stuff like with the sharep pointer it's a freestanding function so it needs to operate on any",
    "start": "783899",
    "end": "789420"
  },
  {
    "text": "shared pointer um so you can't really efficiently implement this but actually the bigger problem is",
    "start": "789420",
    "end": "796380"
  },
  {
    "text": "um that um it's not safe to use it's unsafe by default right if you have a shared pointer you copy it you assign to",
    "start": "796380",
    "end": "802380"
  },
  {
    "text": "it that's my thread save you have to remember to use the atomic load and atomic store instead to make a thread",
    "start": "802380",
    "end": "808740"
  },
  {
    "text": "safe right and if you forget to do these like freestanding wrapper functions even on one thread in one place you just use",
    "start": "808740",
    "end": "815760"
  },
  {
    "text": "the normal assignment or copying then your whole program is undefined Behavior because you have a data arrays right so",
    "start": "815760",
    "end": "821339"
  },
  {
    "text": "it's really not a good API and so",
    "start": "821339",
    "end": "826620"
  },
  {
    "text": "um coming back to this paper by herb who proposed to make a atomic set pointer a thing so",
    "start": "826620",
    "end": "833040"
  },
  {
    "text": "it's an object and you have everything in there um we now got it in C plus 20 so Atomic",
    "start": "833040",
    "end": "839579"
  },
  {
    "text": "sharp pointer now is NC Plus 20. um and with that",
    "start": "839579",
    "end": "844980"
  },
  {
    "text": "um it becomes a lot easier so now instead of declaring a sharep pointer you would declare an atomic set pointer",
    "start": "844980",
    "end": "851279"
  },
  {
    "text": "and then you can load it on one thread and store into it from another thread so it's the same API as a normal study",
    "start": "851279",
    "end": "857339"
  },
  {
    "text": "Atomic and that is now thread safe since it was just 20. so that's great and you don't usually actually even have to",
    "start": "857339",
    "end": "863100"
  },
  {
    "text": "write the load in the store you can just omit that because it the API is just like enormous to the atomic so you can just write like this naked copying or",
    "start": "863100",
    "end": "870480"
  },
  {
    "text": "assignment um and it's going to do the atomic thing under the hood",
    "start": "870480",
    "end": "875579"
  },
  {
    "text": "um so it's safe by default which is much better um I still prefer to do it like this",
    "start": "875579",
    "end": "881279"
  },
  {
    "text": "because I still prefer to be explicit about hey this is an atomic operation but it's a matter of code style right",
    "start": "881279",
    "end": "888120"
  },
  {
    "text": "um and the other great thing about Atomic set pointer is now that it allows more efficient implementation so for",
    "start": "888120",
    "end": "893399"
  },
  {
    "text": "example if you're doing this with a mutex under the hood which we're going to come to we don't want that right we want log free but like uh the kind of",
    "start": "893399",
    "end": "900839"
  },
  {
    "text": "the naive implementation is to do it with the mutex if you have these freestanding functions you can't store",
    "start": "900839",
    "end": "905880"
  },
  {
    "text": "the mutex with the shared pointer right because you can't store any states so you have to have some kind of",
    "start": "905880",
    "end": "911420"
  },
  {
    "text": "uh either like a lookup table where you have one mutex per shared pointer or you just have a global mutex for all the",
    "start": "911420",
    "end": "919019"
  },
  {
    "text": "shared pointers which is apparently what the freestanding function implementations or at least some of them were actually doing so it's super",
    "start": "919019",
    "end": "924540"
  },
  {
    "text": "inefficient with the atomic SharePoint there you can put this additional state that you need to make a threat safe into",
    "start": "924540",
    "end": "929639"
  },
  {
    "text": "the atomic object itself so you can you can implement it much more efficiently",
    "start": "929639",
    "end": "936000"
  },
  {
    "text": "um and actually both GCC and msvc already ship this clang doesn't yet but",
    "start": "936000",
    "end": "941760"
  },
  {
    "text": "both GCC and msvc in the latest version um you get the Atomic sharep pointer",
    "start": "941760",
    "end": "947040"
  },
  {
    "text": "there in C plus if UNC plus 20 mode so that's great um and",
    "start": "947040",
    "end": "953579"
  },
  {
    "text": "um that was me um before the latest song that came out I was like",
    "start": "953579",
    "end": "960540"
  },
  {
    "text": "okay great we standardized Atomic shot pointer and surely it's going to be Lock Free as well right because that's what",
    "start": "960540",
    "end": "965699"
  },
  {
    "text": "you want uh because if you're if you're in a Time constrained system if you're doing kind of low latency programming you don't",
    "start": "965699",
    "end": "972000"
  },
  {
    "text": "want to be messing around with mutexes that you you want to have a log free implementation",
    "start": "972000",
    "end": "977720"
  },
  {
    "text": "um and it turns out no",
    "start": "978000",
    "end": "984620"
  },
  {
    "text": "um so I posted this on Twitter you know when it was discussed um before c plus 20 came out I think it was early 2019",
    "start": "988440",
    "end": "994680"
  },
  {
    "text": "and I was like Hey C plus plus standard Library implementers hello committee friends surely you're gonna ship a lock",
    "start": "994680",
    "end": "1000560"
  },
  {
    "text": "for the implementation of this right and then um STL who is the maintainer of",
    "start": "1000560",
    "end": "1005779"
  },
  {
    "text": "the Microsoft Library said no and I don't even think it can be",
    "start": "1005779",
    "end": "1010820"
  },
  {
    "text": "implemented right because um how do you copy the pointer and",
    "start": "1010820",
    "end": "1017000"
  },
  {
    "text": "increment the ref count all at once and one Atomic operation that's not possible so this is I don't think this is",
    "start": "1017000",
    "end": "1023000"
  },
  {
    "text": "implementable so we don't we don't do this so our Atomic chat pointer is doing exactly what the freestanding functions",
    "start": "1023000",
    "end": "1028699"
  },
  {
    "text": "have been doing since C plus 11 which is using mutex under the hood right",
    "start": "1028699",
    "end": "1035140"
  },
  {
    "text": "so and indeed if you do this on mscc or in GCC um",
    "start": "1035140",
    "end": "1040220"
  },
  {
    "text": "and you you use these functions here is log free this is the per instance",
    "start": "1040220",
    "end": "1045319"
  },
  {
    "text": "version and then the is always Lock Free which is the kind of static compile time version both of them are going to tell",
    "start": "1045319",
    "end": "1051260"
  },
  {
    "text": "you false it's not lock free it's containing mutexes inside so you know if you're in a system where",
    "start": "1051260",
    "end": "1057520"
  },
  {
    "text": "you you want to be doing Lottery programming because you're on a tight timeline",
    "start": "1057520",
    "end": "1064220"
  },
  {
    "text": "um and you want to have this kind of logic guarantee that at least one thread is making progress all the time",
    "start": "1064220",
    "end": "1070880"
  },
  {
    "text": "um you can't use this right you can't use the standard Library implementations",
    "start": "1070880",
    "end": "1077960"
  },
  {
    "text": "um which is sad uh so that was going on and at the same time you know there was further already",
    "start": "1077960",
    "end": "1084140"
  },
  {
    "text": "in 2017 was giving a talk about this and said oh yeah Atomic shot pointer yeah it's it's one of those um you know",
    "start": "1084140",
    "end": "1091160"
  },
  {
    "text": "things that you can do here and of course like it's Lock Free and you know",
    "start": "1091160",
    "end": "1096679"
  },
  {
    "text": "um uh obviously I have an implementation of that lying around and um there's",
    "start": "1096679",
    "end": "1102260"
  },
  {
    "text": "actually Anthony Williams as well who is wrote the book about concurrency um NC plus plus in action you know one of the",
    "start": "1102260",
    "end": "1108500"
  },
  {
    "text": "I would say Godfathers of concurrency in C plus plus um and he um he published a blog post a",
    "start": "1108500",
    "end": "1114980"
  },
  {
    "text": "while ago he has this just thread Library which contains lots of concurrency tools and you're saying well",
    "start": "1114980",
    "end": "1120440"
  },
  {
    "text": "yeah so you can like have a log free implementation it's a bit more complex but it's worth it because",
    "start": "1120440",
    "end": "1126200"
  },
  {
    "text": "um um you know it in the it might be slow in the uncontended cases but when you",
    "start": "1126200",
    "end": "1131360"
  },
  {
    "text": "have contention you get this guarantee that it's Lock Free which is a very nice property therefore my library ships with",
    "start": "1131360",
    "end": "1136460"
  },
  {
    "text": "the log free Atomic sharep pointer implementation right so on the one hand I have these standard Library implementers who were saying",
    "start": "1136460",
    "end": "1143419"
  },
  {
    "text": "this is not implementable and on the other hand I have these other people like further and Anthony which are experts in a current programming which",
    "start": "1143419",
    "end": "1149660"
  },
  {
    "text": "are saying well yeah you should use the locker implementation and by the way I have one it's closed doors so I you",
    "start": "1149660",
    "end": "1155419"
  },
  {
    "text": "can't look at it but I'm using it and I was like this both of these things can't be true",
    "start": "1155419",
    "end": "1162200"
  },
  {
    "text": "at the same time either it's implementable or it's not right so I would really want to see how this",
    "start": "1162200",
    "end": "1168440"
  },
  {
    "text": "works but where's the code so I wasn't this in this in this dilemma",
    "start": "1168440",
    "end": "1173960"
  },
  {
    "text": "for a while and then I was like okay I need to do some research here I need to like figure out what's actually going on here is this implementable or not how",
    "start": "1173960",
    "end": "1180140"
  },
  {
    "text": "does this work and that's kind of what led me to that was kind of the motivation for this talk essentially",
    "start": "1180140",
    "end": "1187460"
  },
  {
    "text": "um so um status quo as of today as I said msvc and GCC both ship with a non-lock free",
    "start": "1187460",
    "end": "1194419"
  },
  {
    "text": "um implementation of atomic checkpoint a clang just doesn't have an implementation I don't know if anybody in clang is working on one",
    "start": "1194419",
    "end": "1201980"
  },
  {
    "text": "but um it turns out that actually there are three um open source implementations of atomic",
    "start": "1201980",
    "end": "1209059"
  },
  {
    "text": "log free shared pointer that you can look at today um so Anthony Williams actually",
    "start": "1209059",
    "end": "1215360"
  },
  {
    "text": "um published a version of his Atomic lockfish head pointer it's not the one that he has in his just thread Library",
    "start": "1215360",
    "end": "1221720"
  },
  {
    "text": "which is like the commercial production ready version it's more like a stripped down kind of proof of concept version",
    "start": "1221720",
    "end": "1226940"
  },
  {
    "text": "that shows the algorithm but you can look at it then Folly which is Facebook's C plus",
    "start": "1226940",
    "end": "1233660"
  },
  {
    "text": "plus library has an implementation of atomic set pointer which is also lock free and you can also look at it",
    "start": "1233660",
    "end": "1239179"
  },
  {
    "text": "uh It Was Written originally by Dave Watson who since left Facebook it's now maintained by uh",
    "start": "1239179",
    "end": "1244700"
  },
  {
    "text": "somebody else um David Goldblatt um and then actually I found the third",
    "start": "1244700",
    "end": "1249799"
  },
  {
    "text": "implementation which is also open source and you can also use um",
    "start": "1249799",
    "end": "1256059"
  },
  {
    "text": "and he was basically looking at Anthony Williams implementation he was saying well I don't like this like it's using",
    "start": "1257600",
    "end": "1263360"
  },
  {
    "text": "double with compare and swap it's too slow and then he was looking at the Facebook implementation the following one and he was like I don't understand",
    "start": "1263360",
    "end": "1268760"
  },
  {
    "text": "this and then he was like I'm gonna write my own so so he did that and you can look",
    "start": "1268760",
    "end": "1274039"
  },
  {
    "text": "at that as well and um I looked at all of three of those",
    "start": "1274039",
    "end": "1279200"
  },
  {
    "text": "um quite extensively um and try to understand what's going on there and also exchange quite a few emails with all of these people",
    "start": "1279200",
    "end": "1286760"
  },
  {
    "text": "um and that was very helpful um and actually vladislav also wrote",
    "start": "1286760",
    "end": "1292220"
  },
  {
    "text": "himself as well a blog post about how he implemented this which is a very very interesting blog post which I very",
    "start": "1292220",
    "end": "1297380"
  },
  {
    "text": "recommend you to read except it's in Russian so I can read it because it's my mother Tong but you can't probably so",
    "start": "1297380",
    "end": "1304340"
  },
  {
    "text": "maybe use Google Translate I think I hope I hope that's possible I think that's a really cool blog post where",
    "start": "1304340",
    "end": "1309799"
  },
  {
    "text": "he's kind of going through the experience of implementing this um so how can we implement this is this",
    "start": "1309799",
    "end": "1317900"
  },
  {
    "text": "actually implementable or not and how can we how can we do this and this is kind of what what we're going to look at",
    "start": "1317900",
    "end": "1323840"
  },
  {
    "text": "um so the problem is um why did you know STL and the other standard Library people say I don't",
    "start": "1323840",
    "end": "1330559"
  },
  {
    "text": "think this is implementable because we have this fundamental problem here um the shared pointer the state of the",
    "start": "1330559",
    "end": "1336860"
  },
  {
    "text": "sharep pointer is basically the pointer to the control block which contains the object and then the ref count right",
    "start": "1336860",
    "end": "1342559"
  },
  {
    "text": "those are the two things that determine the state of the sharep pointer and if you want to make this Atomic and",
    "start": "1342559",
    "end": "1348740"
  },
  {
    "text": "log free we need to mutate both of those values at the same time in one Atomic",
    "start": "1348740",
    "end": "1353900"
  },
  {
    "text": "log 3 operation okay but they live at different memory",
    "start": "1353900",
    "end": "1360320"
  },
  {
    "text": "addresses they're not adjacent to each other the attack one lives in a shared pointer instance the other one lives in the control block so they're like in",
    "start": "1360320",
    "end": "1366320"
  },
  {
    "text": "completely different memory addresses but you need to change both of them atomically log free at the same time with one CPU instruction",
    "start": "1366320",
    "end": "1373400"
  },
  {
    "text": "which is something that's called double compare and swap",
    "start": "1373400",
    "end": "1378500"
  },
  {
    "text": "and it turns out there's actually exactly one CPU that supports this operation which is the good old Motorola",
    "start": "1378500",
    "end": "1384200"
  },
  {
    "text": "68000. so that CPU supports uh comparing uh",
    "start": "1384200",
    "end": "1389960"
  },
  {
    "text": "double compared swap um on this particular CPU implementing a log free Atomic SharePoint that is",
    "start": "1389960",
    "end": "1395900"
  },
  {
    "text": "actually pretty easy unfortunately no modern CPU supports this operation so",
    "start": "1395900",
    "end": "1403520"
  },
  {
    "text": "you cannot do this you cannot log free atomically with one instruction modify two separate memory locations at the",
    "start": "1403520",
    "end": "1409700"
  },
  {
    "text": "same time on Intel or arm or like any of these like more modern chipsets",
    "start": "1409700",
    "end": "1415120"
  },
  {
    "text": "what those chips do support is something that's called double width compare and",
    "start": "1415120",
    "end": "1420320"
  },
  {
    "text": "swap which is not the same as double comparing to what and double width compare and swap is basically",
    "start": "1420320",
    "end": "1425980"
  },
  {
    "text": "modifying two words atomically log-free at the same time but only when they're adjacent to each other so you you have",
    "start": "1425980",
    "end": "1432500"
  },
  {
    "text": "like one if you're in 64-bit it's going to be 128 bits and you can modify you",
    "start": "1432500",
    "end": "1438020"
  },
  {
    "text": "know a field of 128 bits at the same time atomically log 3 and 1 CPU",
    "start": "1438020",
    "end": "1443900"
  },
  {
    "text": "operations unfortunately the control block pointer and the ref count are not adjacent to each other so",
    "start": "1443900",
    "end": "1451100"
  },
  {
    "text": "how can we make this work and it turns out there is actually an algorithm that makes that possible it's called a",
    "start": "1451100",
    "end": "1456919"
  },
  {
    "text": "split ref count and it's not something that you typically find in like a",
    "start": "1456919",
    "end": "1462500"
  },
  {
    "text": "computer science textbook so David Goldblatt who is the maintainer of the Folly implementation",
    "start": "1462500",
    "end": "1469039"
  },
  {
    "text": "said it's sort of a folk algorithm it's like there's a few people on a planet who know how this works and it's kind of",
    "start": "1469039",
    "end": "1475340"
  },
  {
    "text": "passed down from one person to another um I actually I actually found uh two pieces in the",
    "start": "1475340",
    "end": "1483919"
  },
  {
    "text": "literature where this algorithm is mentioned uh one of them is Dimitri vukov's uh",
    "start": "1483919",
    "end": "1490280"
  },
  {
    "text": "blog about differential reference counting and another one is Anthony Williams is a brilliant book about C plus concurrency",
    "start": "1490280",
    "end": "1497000"
  },
  {
    "text": "both of them mention um the split refcon idea but not in the context of implementing a shared pointer",
    "start": "1497000",
    "end": "1502159"
  },
  {
    "text": "so it's not quite the same thing but it's kind of the the same idea so it it is mentioned in literature people are",
    "start": "1502159",
    "end": "1507919"
  },
  {
    "text": "doing it but it's just kind of a little bit more obscure it's not like you know merge side or something which you know a",
    "start": "1507919",
    "end": "1513860"
  },
  {
    "text": "lot of people are kind of aware about so it's it's not that you can find lots of implementations of this everywhere on the internet",
    "start": "1513860",
    "end": "1520159"
  },
  {
    "text": "but um you can find this in every one of these three implementations that are",
    "start": "1520159",
    "end": "1525620"
  },
  {
    "text": "open source and there are at least two more implementations that are not open source that I'm aware of there's one big",
    "start": "1525620",
    "end": "1530840"
  },
  {
    "text": "company that has a closed Source implementation that I can't look at and then there's filter Picos who also has",
    "start": "1530840",
    "end": "1536059"
  },
  {
    "text": "his own implementation which is a little bit different it's kind of an intrusive shared pointer but it also uses kind of",
    "start": "1536059",
    "end": "1542059"
  },
  {
    "text": "the same idea and kind of split refcon so there are implementations of this out there and at least three of them are open source",
    "start": "1542059",
    "end": "1548539"
  },
  {
    "text": "um how does this work the basic idea is that instead of one ref count we basically split the ref",
    "start": "1548539",
    "end": "1553820"
  },
  {
    "text": "count into two things we have a local ref count which lives with the shared pointer and then we have a global refcon",
    "start": "1553820",
    "end": "1559580"
  },
  {
    "text": "which lives in the control block and so what we can do atomically is we can modify the control block pointer and",
    "start": "1559580",
    "end": "1565640"
  },
  {
    "text": "the local ref count simultaneously and then we try to synchronize the local revcon with the global ref count in in",
    "start": "1565640",
    "end": "1572659"
  },
  {
    "text": "an additional step so how does this work here's a little bit of code",
    "start": "1572659",
    "end": "1578659"
  },
  {
    "text": "uh so if you want to implement our Atomic SharePoint that we're going to have this counted pointer structure in there which is basically exactly this",
    "start": "1578659",
    "end": "1584960"
  },
  {
    "text": "it's a control block pointer and a local ref count and this is our double width",
    "start": "1584960",
    "end": "1590299"
  },
  {
    "text": "um double width thingy that you want to double with atomically swap later and then so we have an atomic uh",
    "start": "1590299",
    "end": "1597980"
  },
  {
    "text": "instance of one of these um and then you know yeah need to assert that it's locked free because we don't",
    "start": "1597980",
    "end": "1603080"
  },
  {
    "text": "want to use mutexes in there and then here's the basic idea of this algorithm so um we cannot atomically update the",
    "start": "1603080",
    "end": "1611360"
  },
  {
    "text": "control block pointer and increment the global ref count at the same time so this is for the case when you want to",
    "start": "1611360",
    "end": "1618140"
  },
  {
    "text": "um load load the SharePoint and we need to increment the refcon",
    "start": "1618140",
    "end": "1623659"
  },
  {
    "text": "but what we can do is we can atomically increment um the local refcon or we can atomically",
    "start": "1623659",
    "end": "1629240"
  },
  {
    "text": "change the pointer and increment the local ref count so that's step one incrementing the local revcon and then",
    "start": "1629240",
    "end": "1635539"
  },
  {
    "text": "in a separate step we're incrementing the global ref count and then we are trying then we're trying to decrement the local ref count again so you want to",
    "start": "1635539",
    "end": "1641779"
  },
  {
    "text": "move the increment from the local refcon to the global ref count right so that all the other SharePoint instances are",
    "start": "1641779",
    "end": "1647419"
  },
  {
    "text": "also oh the only other threads are also aware of it um but this we can do in a cast Loop so",
    "start": "1647419",
    "end": "1653179"
  },
  {
    "text": "we can say okay we modify the local local ref count and then we're trying to modify the global rough count and",
    "start": "1653179",
    "end": "1660500"
  },
  {
    "text": "you know reverting the local graph count but if any other thread has modified the state in the meantime we're just gonna",
    "start": "1660500",
    "end": "1667159"
  },
  {
    "text": "repeat we're gonna try again so we're gonna do a cast Loop right compare Exchange",
    "start": "1667159",
    "end": "1672919"
  },
  {
    "text": "um and this is kind of the idea and we try to do this until we succeeded basically until we got to increment the global",
    "start": "1672919",
    "end": "1679640"
  },
  {
    "text": "graph count without any other thread getting in the way so we're going to have a cast Loop in there and this is",
    "start": "1679640",
    "end": "1684679"
  },
  {
    "text": "basically the the idea and I'm just going to show quickly um how it's implemented um how the load is implemented because we have load store",
    "start": "1684679",
    "end": "1691159"
  },
  {
    "text": "exchange and compare Exchange uh I'm obviously not going to show the implementation of all four of them",
    "start": "1691159",
    "end": "1698480"
  },
  {
    "text": "because then we would be looking for an hour just a wall of code which I",
    "start": "1698480",
    "end": "1703760"
  },
  {
    "text": "don't really want to do to you but the load is actually the simplest one but it does kind of contain this basic idea so",
    "start": "1703760",
    "end": "1709279"
  },
  {
    "text": "if you if you understand the load you understand the idea so we have our counted pointer here",
    "start": "1709279",
    "end": "1714559"
  },
  {
    "text": "which is the control pointer and the ref count so we have this Atomic we have an atomic member of those",
    "start": "1714559",
    "end": "1721220"
  },
  {
    "text": "we make sure it's Lock Free and then here's how we implement the load the first step as I said is incrementing the",
    "start": "1721220",
    "end": "1726919"
  },
  {
    "text": "local ref count annoyingly because it's a double with variable there's no double with increment so we need to do this in a",
    "start": "1726919",
    "end": "1733340"
  },
  {
    "text": "cast loop as well so we kind of have to um increment the local refcon but also",
    "start": "1733340",
    "end": "1738860"
  },
  {
    "text": "making sure that the control block pointer hasn't been modified by another thread in the meantime so that's why there is this like if compare exchange",
    "start": "1738860",
    "end": "1745039"
  },
  {
    "text": "weak Loop going on here but all this does in the end is to just increment the local ref count",
    "start": "1745039",
    "end": "1752299"
  },
  {
    "text": "so now once we have that we have a new valid state for our local sharep pointer instance so we're going to make a copy",
    "start": "1752299",
    "end": "1757880"
  },
  {
    "text": "of that and like if we succeed this is the thing we can return this is like the new state of our shared pointer with the",
    "start": "1757880",
    "end": "1763820"
  },
  {
    "text": "incremented ref count now we can increment the global ref count this is this is the next step we",
    "start": "1763820",
    "end": "1770419"
  },
  {
    "text": "can increment the Global Response we're just going to go into the control block and increment it",
    "start": "1770419",
    "end": "1775760"
  },
  {
    "text": "and and now you're like hang on uh okay so now we need to decrement the local ref",
    "start": "1775760",
    "end": "1781220"
  },
  {
    "text": "count right and then and then we're good then we have effectively incremented the global ref count",
    "start": "1781220",
    "end": "1786380"
  },
  {
    "text": "but we can't just go ahead and do that because we need to make sure that no other thread in the meantime has done",
    "start": "1786380",
    "end": "1792440"
  },
  {
    "text": "anything right so we have again a loop we have again a cast Loop here",
    "start": "1792440",
    "end": "1798260"
  },
  {
    "text": "um where basically we say okay we're going to try to decrement the local ref count you see this minus minus local refcon",
    "start": "1798260",
    "end": "1804620"
  },
  {
    "text": "there and then um if the state of the whole thing with the control block pointer is still the",
    "start": "1804620",
    "end": "1810140"
  },
  {
    "text": "same as before then we're good no other thread has modified this in the meantime",
    "start": "1810140",
    "end": "1815480"
  },
  {
    "text": "however if they did then we need to go around the loop again and there's another case we which we have to handle",
    "start": "1815480",
    "end": "1822380"
  },
  {
    "text": "which is if somebody change the control block pointer itself it means that another thread has",
    "start": "1822380",
    "end": "1828980"
  },
  {
    "text": "assigned into the shared pointer instance and that means we were not supposed to modify the global refcon",
    "start": "1828980",
    "end": "1834620"
  },
  {
    "text": "because it's not pointing to the same object anymore right so we need to um subtract that again",
    "start": "1834620",
    "end": "1840320"
  },
  {
    "text": "and um so we're going to end up in this Castle so if you're the only thread",
    "start": "1840320",
    "end": "1845720"
  },
  {
    "text": "then we're just gonna fall through and do these these three things in order increment increment decrement but if",
    "start": "1845720",
    "end": "1852320"
  },
  {
    "text": "there's another thread you might be looping for a little bit um but because it's a lock free",
    "start": "1852320",
    "end": "1857360"
  },
  {
    "text": "algorithm you might fail on this cast Loop but if you do you know that another thread has succeeded doing this right so",
    "start": "1857360",
    "end": "1863360"
  },
  {
    "text": "you never end up with a situation where you just waiting on a mutex and you have no idea how long it's going to take",
    "start": "1863360",
    "end": "1869059"
  },
  {
    "text": "until the system can make progress but you have this lock fee guarantee that at least one thread will always",
    "start": "1869059",
    "end": "1874279"
  },
  {
    "text": "succeed in the loop and you know get get to update the shared pointer and your whole system can move forward and then",
    "start": "1874279",
    "end": "1880220"
  },
  {
    "text": "in the end we just return the new state of the shared point and then we're good so this is basically how it works",
    "start": "1880220",
    "end": "1887120"
  },
  {
    "text": "um which means each operation on the atomic SharePoint at each axis each Atomic axis",
    "start": "1887120",
    "end": "1892279"
  },
  {
    "text": "has at least three Atomic operations right because you have this like local refcon Global refund local refcon",
    "start": "1892279",
    "end": "1898899"
  },
  {
    "text": "and if there's contention if there's multiple threads trying to do this at the same time then on the same",
    "start": "1898899",
    "end": "1904640"
  },
  {
    "text": "SharePoint instance then you're not going to have free Atomic operations but you're going to have more because you're going to be looping on these right",
    "start": "1904640",
    "end": "1911600"
  },
  {
    "text": "um so that's definitely going to be slower than a mutex if there's no contention because acquiring a mutex if",
    "start": "1911600",
    "end": "1916880"
  },
  {
    "text": "you have no contention is very quick whereas here in the best case you still have these three Atomic operations if",
    "start": "1916880",
    "end": "1923539"
  },
  {
    "text": "there's no contention so that's going to be a lot slower however if you have high contention if there's lots of threads",
    "start": "1923539",
    "end": "1928760"
  },
  {
    "text": "trying to like pound those atomic then the lobby case is going to behave much",
    "start": "1928760",
    "end": "1933980"
  },
  {
    "text": "better than the mutex so that's the basic idea the Folly",
    "start": "1933980",
    "end": "1939440"
  },
  {
    "text": "implementation adds something on top of that they do this thing called refcon",
    "start": "1939440",
    "end": "1944720"
  },
  {
    "text": "batching where instead of doing this like increment increment decrement every time they kind of",
    "start": "1944720",
    "end": "1951100"
  },
  {
    "text": "pre-increment the the ref count to a certain amount K Which is higher than",
    "start": "1951100",
    "end": "1956240"
  },
  {
    "text": "the number of threads you expect to be touching this at the same time and then basically every time you you access it",
    "start": "1956240",
    "end": "1962120"
  },
  {
    "text": "you just like bite off another pre-incremented kind of ref count right so basically",
    "start": "1962120",
    "end": "1968480"
  },
  {
    "text": "um you don't have to touch the control block so you basically pre-allocate like allocate is now not memory allocation",
    "start": "1968480",
    "end": "1974779"
  },
  {
    "text": "but kind of allocating like a ref count so you pre pre-increment them so you have some some ref cons that you can",
    "start": "1974779",
    "end": "1981799"
  },
  {
    "text": "hand out and just use and so then when a new thread access it you just like decrement the local ref count until you",
    "start": "1981799",
    "end": "1987860"
  },
  {
    "text": "reach some threshold like K divided by 2 is one possibility and then you're like oh I'm running out of",
    "start": "1987860",
    "end": "1994059"
  },
  {
    "text": "pre-incremented refcon so I'm going to need to go to the control block and get some more Global ref counts now but you",
    "start": "1994059",
    "end": "1999919"
  },
  {
    "text": "don't have to do that every time you just do that once some threshold has been reached and you can actually optimize that as well like exactly how",
    "start": "1999919",
    "end": "2006399"
  },
  {
    "text": "this algorithm works you can kind of tweak it depending on what your scenario and very interesting can talk for a",
    "start": "2006399",
    "end": "2011799"
  },
  {
    "text": "whole hour about that I'm not going to do that now um so you but you can save some Atomic operations this way the trade-off here",
    "start": "2011799",
    "end": "2018519"
  },
  {
    "text": "is that um use count which is a member function of SharePoint and now basically",
    "start": "2018519",
    "end": "2024100"
  },
  {
    "text": "becomes useless because you don't have a meaningful ref count anymore you have you just kind of pre-increment the ref",
    "start": "2024100",
    "end": "2030340"
  },
  {
    "text": "count to some high number so it's just going to contain some high number you can't reason anymore about",
    "start": "2030340",
    "end": "2036340"
  },
  {
    "text": "um how many like what the refund actually is and this is kind of a typical uh thing for these kinds of classes like",
    "start": "2036340",
    "end": "2042880"
  },
  {
    "text": "the more you try to optimize them the more genericity you lose so if you do the revcon patching you don't have a",
    "start": "2042880",
    "end": "2048878"
  },
  {
    "text": "member function anymore that Returns the current ref count which you probably don't need you only need to know if it's",
    "start": "2048879",
    "end": "2055000"
  },
  {
    "text": "zero or non-zero basically or maybe you need to know if it's zero or one you're the only",
    "start": "2055000",
    "end": "2061000"
  },
  {
    "text": "one and or if there's more threats that's all you need to know typically but if you want to do more",
    "start": "2061000",
    "end": "2066339"
  },
  {
    "text": "optimizations you lose more stuff for example you know photos implementation uh and uses an intrusive",
    "start": "2066339",
    "end": "2073260"
  },
  {
    "text": "approach which is not the same API anymore as the generic SharePoint so now you have intrusive pointers you can do",
    "start": "2073260",
    "end": "2079118"
  },
  {
    "text": "more optimization but you lose more genericity and then you can tweak it for your particular data structure that",
    "start": "2079119",
    "end": "2084760"
  },
  {
    "text": "you're using and then again you can get some speed up but you lose even more genericity so this is kind of typical trade-off here we're trying to implement",
    "start": "2084760",
    "end": "2091480"
  },
  {
    "text": "kind of the generic Atomic SharePoint uh kind of as a starting point right this is how the",
    "start": "2091480",
    "end": "2096940"
  },
  {
    "text": "algorithm works that's a generic version that is just always going to work and you can just use it in your code you",
    "start": "2096940",
    "end": "2102580"
  },
  {
    "text": "don't have to like design your own lockview data structure or whatever you can just use that anyway so we've done all this",
    "start": "2102580",
    "end": "2110859"
  },
  {
    "text": "looks like we have a lock for the atomic sharep pointer now right so we succeeded this is hopefully convinced you by",
    "start": "2110859",
    "end": "2117520"
  },
  {
    "text": "showing you this code that this is implementable right I haven't walked you through the complete implementation but hopefully I've convinced you that it's",
    "start": "2117520",
    "end": "2124599"
  },
  {
    "text": "implementable is it though so the problem is we were assuming that",
    "start": "2124599",
    "end": "2131440"
  },
  {
    "text": "this is how a shared pointer works this is not the whole truth right this is a very very simple shared pointer",
    "start": "2131440",
    "end": "2137200"
  },
  {
    "text": "this is not how Stitch head pointer actually works Stitch head pointer has a lot more features first of all",
    "start": "2137200",
    "end": "2143740"
  },
  {
    "text": "it supports weak pointer so it has a weak count as well which you need to break Cycles you don't really need that if you're",
    "start": "2143740",
    "end": "2150280"
  },
  {
    "text": "dealing with a point point at your const object but in general you have a we count",
    "start": "2150280",
    "end": "2155680"
  },
  {
    "text": "sharep pointer also supports a custom deleteer and it also supports custom allocator",
    "start": "2155680",
    "end": "2162339"
  },
  {
    "text": "now none of this is a problem because all of these all of the stuff is in the control block and there's just one control block you don't have to worry",
    "start": "2162339",
    "end": "2168040"
  },
  {
    "text": "about this this is not part of the state of every individual shared pointer instance so that's not a problem but",
    "start": "2168040",
    "end": "2173079"
  },
  {
    "text": "there's another thing which is a problem and that's this thing sharepointer also contains a pointer to",
    "start": "2173079",
    "end": "2179619"
  },
  {
    "text": "the object itself that's pointing to which may or may not be the same pointer as the pointer in the control block",
    "start": "2179619",
    "end": "2186579"
  },
  {
    "text": "and that's the thing that that makes it really complicated why is that there well shared pointer has a thing called",
    "start": "2186579",
    "end": "2192940"
  },
  {
    "text": "the idea zinc Constructor how many of you have used this okay a couple people basically what the",
    "start": "2192940",
    "end": "2200500"
  },
  {
    "text": "Alias Constructor does is you can have a shared pointer that's managing the lifetime of one object but actually points to another object",
    "start": "2200500",
    "end": "2206619"
  },
  {
    "text": "and this is really useful if the other object it points to has the same lifetime of the object you're managing",
    "start": "2206619",
    "end": "2212800"
  },
  {
    "text": "for example it's a it's a member of the of the so you can have this kind of thing where you at that point as",
    "start": "2212800",
    "end": "2218560"
  },
  {
    "text": "managing a pointer to a widget but then it's actually pointing to a member of the widget that's like intj here right",
    "start": "2218560",
    "end": "2224560"
  },
  {
    "text": "so if you dereference it you get the J the integer but then uh if it goes out of scope the thing that's going to be",
    "start": "2224560",
    "end": "2230500"
  },
  {
    "text": "deallocated is the whole widget this is maybe a little bit of an exotic use case I haven't actually used this in",
    "start": "2230500",
    "end": "2237099"
  },
  {
    "text": "production ever I know that if a few people have used this it's not it's not like it never happens but it's a rare",
    "start": "2237099",
    "end": "2243339"
  },
  {
    "text": "case but there's a much much more common case which we need to account for which is this this is a lot more common I bet most",
    "start": "2243339",
    "end": "2249820"
  },
  {
    "text": "people who use shared pointer like as soon as you have polymorphism going on you will you will run into this",
    "start": "2249820",
    "end": "2255760"
  },
  {
    "text": "you can have a sharep pointer to base but the object is actually pointing to is is a derived class right and you need",
    "start": "2255760",
    "end": "2262180"
  },
  {
    "text": "to make sure that if if you delocate the object you call the right Destructor you call the structure of derived right",
    "start": "2262180",
    "end": "2267820"
  },
  {
    "text": "otherwise you get slicing and everything is really really horrible so this is actually a very very basic",
    "start": "2267820",
    "end": "2273400"
  },
  {
    "text": "use case that you just need to support if you want to implement a shared pointer and now we have and and so so",
    "start": "2273400",
    "end": "2278440"
  },
  {
    "text": "base and derived they don't necessarily have the same address right you can have multiple base classes and stuff like",
    "start": "2278440",
    "end": "2283660"
  },
  {
    "text": "this so in general a pointer to base and a pointer to drive will point to different addresses even if they're pointing to the same object right and",
    "start": "2283660",
    "end": "2290200"
  },
  {
    "text": "this is what makes it really complicated here because um now you have a pointer to base which",
    "start": "2290200",
    "end": "2296680"
  },
  {
    "text": "lives in the shared pointer and you have a pointer to derived which lives in the control block those are two different pointers",
    "start": "2296680",
    "end": "2302800"
  },
  {
    "text": "the pointer to base is per instance so it needs to be in the shared pointer it can't be in the control block right and",
    "start": "2302800",
    "end": "2308560"
  },
  {
    "text": "now we need to modify not only the control block point and the local revcon simultaneously but also this other",
    "start": "2308560",
    "end": "2313720"
  },
  {
    "text": "pointer you also need to modify that simultaneously so you need to modify all threes simultaneously",
    "start": "2313720",
    "end": "2319780"
  },
  {
    "text": "we can't do that like there's not like there's no triple with compare and swap on any CPU I'm aware of this is just not",
    "start": "2319780",
    "end": "2326020"
  },
  {
    "text": "a thing so you just can't do that how do you get around that well different the kind of the three uh open source",
    "start": "2326020",
    "end": "2332560"
  },
  {
    "text": "implementations that I can look at they're doing three different things",
    "start": "2332560",
    "end": "2337660"
  },
  {
    "text": "um Anthony Williams's solution does this he says okay we can't store a pointer to",
    "start": "2337660",
    "end": "2344140"
  },
  {
    "text": "the aliased object but we can store the actual Alias",
    "start": "2344140",
    "end": "2349480"
  },
  {
    "text": "pointers into a separate data structure and we can store an index into this data structure and then we can",
    "start": "2349480",
    "end": "2355000"
  },
  {
    "text": "cram this index and the ref count together into one integer because you",
    "start": "2355000",
    "end": "2360339"
  },
  {
    "text": "don't like if you're on a 64-bit it's probably enough if you have 32 bits for the refcon and 32 bits for the index so",
    "start": "2360339",
    "end": "2366700"
  },
  {
    "text": "you can cram them into 164-bit integer and then be good we we have two integers again that we're storing",
    "start": "2366700",
    "end": "2373540"
  },
  {
    "text": "um and the way this works is that for every new alias uh shared pointer that's using the same",
    "start": "2373540",
    "end": "2379480"
  },
  {
    "text": "control block you have a new slot there and you have three slots that are kind of pre-allocated they're part of the",
    "start": "2379480",
    "end": "2385119"
  },
  {
    "text": "shared pointer so and if you have more set pointers to point which point to different areas",
    "start": "2385119",
    "end": "2390160"
  },
  {
    "text": "objects uh you're gonna basically push back into the state destruction and you're going to create this kind of in blocks of free",
    "start": "2390160",
    "end": "2396599"
  },
  {
    "text": "and the way this works obviously it all needs to be a atomic Lock Free thread save and everything but this is such a",
    "start": "2396599",
    "end": "2402940"
  },
  {
    "text": "simple data structure that you can do it it's the only thing it supports is push back and find and that's it",
    "start": "2402940",
    "end": "2408220"
  },
  {
    "text": "so it can only grow it can never shrink and if you make it that simple then you can implement this kind of helper helper",
    "start": "2408220",
    "end": "2414760"
  },
  {
    "text": "structure here with like 30 lines of code just with some Atomic integers it's kind of easy to do",
    "start": "2414760",
    "end": "2421000"
  },
  {
    "text": "so you have this like helper helper helper structure here and if you have more earliest pointers",
    "start": "2421000",
    "end": "2427480"
  },
  {
    "text": "you're just gonna you know push back into this thing and you're going to allocate more of these like blocks of",
    "start": "2427480",
    "end": "2432940"
  },
  {
    "text": "three um there's a problem here though",
    "start": "2432940",
    "end": "2438660"
  },
  {
    "text": "uh the problem is if you do this that's a memory allocation",
    "start": "2439839",
    "end": "2445540"
  },
  {
    "text": "memory allocation is not log free right so if you lose the property that the",
    "start": "2445540",
    "end": "2451000"
  },
  {
    "text": "whole thing is Lock Free um and actually you potentially need to do",
    "start": "2451000",
    "end": "2458260"
  },
  {
    "text": "this on every store on every exchange and every compare exchange it's an edge case right if you're using like",
    "start": "2458260",
    "end": "2463660"
  },
  {
    "text": "different Alias pointers with the same underlying object it's kind of a bit of a weird Edge case but you got to support",
    "start": "2463660",
    "end": "2469780"
  },
  {
    "text": "this if you don't it's not going to be lock free so you can't claim that your SharePoint is Lock Free and indeed Anthony Williams we discussed this on on",
    "start": "2469780",
    "end": "2476440"
  },
  {
    "text": "Twitter admits then yes my implementation needs a lock for the allocator",
    "start": "2476440",
    "end": "2481960"
  },
  {
    "text": "otherwise it's not luxury and the lock the allocator is you know it's a pretty complicated Beast it kind",
    "start": "2481960",
    "end": "2488800"
  },
  {
    "text": "of constrains quite significantly like what you can do with your system you need to somehow",
    "start": "2488800",
    "end": "2494859"
  },
  {
    "text": "it's not it's not applicable like in every um in every use case if you're like Facebook or Google and you have a",
    "start": "2494859",
    "end": "2500920"
  },
  {
    "text": "big server and um you have like your own allocator going on there and you control the world you can do something like this if if",
    "start": "2500920",
    "end": "2508599"
  },
  {
    "text": "you're doing and like like what I have been doing for like a decade of my",
    "start": "2508599",
    "end": "2513760"
  },
  {
    "text": "career as your Implement audio processing software that runs on a laptop or a phone it's like an audio",
    "start": "2513760",
    "end": "2520900"
  },
  {
    "text": "plugin that runs somewhere you can't put a lock the allocator in there you like a plugin that runs on a host and you have",
    "start": "2520900",
    "end": "2527079"
  },
  {
    "text": "only that much memory and like you can't you can't do this right so so basically this whole algorithm becomes not viable",
    "start": "2527079",
    "end": "2534520"
  },
  {
    "text": "I have a suggestion I I have a suggestion how to fix this which is we can move the allocation from the atomic",
    "start": "2534520",
    "end": "2539920"
  },
  {
    "text": "shared pointer into the sharep pointer so now instead of allocating whenever you um do like an atomic",
    "start": "2539920",
    "end": "2545680"
  },
  {
    "text": "store you allocate already when you construct the shared pointer aliased",
    "start": "2545680",
    "end": "2552640"
  },
  {
    "text": "with the Alice chat pointer this is when you allocate and then if you uh if you put that into",
    "start": "2552640",
    "end": "2559300"
  },
  {
    "text": "an atomic set point are you just it's just an atomic it's just like an atomic copy you just have to copy that integer",
    "start": "2559300",
    "end": "2565300"
  },
  {
    "text": "and you don't have to allocate anything anymore the problem with this is that it's overhead for every earliest chat pointer right every time you create a",
    "start": "2565300",
    "end": "2571240"
  },
  {
    "text": "SharePoint that has an LDS Constructor or is like a pointer to base which points to the right you're going to have an extra memory allocation there",
    "start": "2571240",
    "end": "2579420"
  },
  {
    "text": "um well there is actually something even more clever that you can do which is um well observed that if you",
    "start": "2579760",
    "end": "2587680"
  },
  {
    "text": "have an alias pointer typically the pointer of for example base or derived or the pointer of like an object and",
    "start": "2587680",
    "end": "2594040"
  },
  {
    "text": "like a member of the object these are typical use cases they're not going to be very far away from each other right so we're going to be pointing into the",
    "start": "2594040",
    "end": "2599859"
  },
  {
    "text": "same object so what you can do is you can compute the pointer difference between the object pointer and the Alias pointer and",
    "start": "2599859",
    "end": "2606220"
  },
  {
    "text": "that difference typically is not going to be very big and if that fits into 32 bits and I",
    "start": "2606220",
    "end": "2611859"
  },
  {
    "text": "really hope it does because I really hope you don't have one object which is bigger than four gigabytes",
    "start": "2611859",
    "end": "2617680"
  },
  {
    "text": "you can just store that pointer difference directly instead of the index",
    "start": "2617680",
    "end": "2623200"
  },
  {
    "text": "right it fits into 32-bits you can cram it into the second 64-bit of your 128 bits together",
    "start": "2623200",
    "end": "2629740"
  },
  {
    "text": "with the ref count you just store the pointed difference directly and if you have this weird Edge case",
    "start": "2629740",
    "end": "2635619"
  },
  {
    "text": "where your earliest point and object pointer are more than four gigabytes apart for whatever weird reason then you",
    "start": "2635619",
    "end": "2641500"
  },
  {
    "text": "can still use the extension list so which is this auxiliary data structure that Anthony Williams invented but it",
    "start": "2641500",
    "end": "2647619"
  },
  {
    "text": "will happen extremely rarely probably never and only in that case you will have to pay for this allocation in the",
    "start": "2647619",
    "end": "2653140"
  },
  {
    "text": "sharep pointer but you can put it in the shared point you don't have to put it in the atomic and then you can also use one of the alignment bits to indicate which",
    "start": "2653140",
    "end": "2659380"
  },
  {
    "text": "methods you're using and then your Atomic sharep pointer is Lock Free this is cool right",
    "start": "2659380",
    "end": "2665380"
  },
  {
    "text": "yes so do we now have a log free Atomic shared pointer have we have we done",
    "start": "2665380",
    "end": "2672099"
  },
  {
    "text": "turns out it has another problem this whole thing relies on double width compare and swap actually being",
    "start": "2672099",
    "end": "2677260"
  },
  {
    "text": "available is that actually the case and again I looked into this and again I",
    "start": "2677260",
    "end": "2683740"
  },
  {
    "text": "got very conflicting information from different people and there were some people kind of the hardware people that",
    "start": "2683740",
    "end": "2688900"
  },
  {
    "text": "were saying oh yeah yeah double with compare and swap it's you get it on every modern CPU if you're",
    "start": "2688900",
    "end": "2694000"
  },
  {
    "text": "dealing with like Intel or arm or something like this um like yeah yeah yeah all the modern CPUs they have this",
    "start": "2694000",
    "end": "2699220"
  },
  {
    "text": "instruction no problem and then on the other hand I have you know C plus plus people and they were",
    "start": "2699220",
    "end": "2704319"
  },
  {
    "text": "saying no no no no no you can't do this portably like this is not like some platforms maybe support this but in",
    "start": "2704319",
    "end": "2711040"
  },
  {
    "text": "general doubly with comparison swap is not a thing you cannot rely on that being there I was like",
    "start": "2711040",
    "end": "2718240"
  },
  {
    "text": "like these like what's actually going on there so I I did a lot of research I wrote it up in a really long blog post",
    "start": "2718240",
    "end": "2724180"
  },
  {
    "text": "I don't have time to basically go over all of this now but if you're interested you can read it it's on my blog",
    "start": "2724180",
    "end": "2729520"
  },
  {
    "text": "timar.audio uh I'm gonna give you like a very quick summary of this",
    "start": "2729520",
    "end": "2735460"
  },
  {
    "text": "um basically the first question do our CPUs support this and if you're talking about desktop or mobile or",
    "start": "2735460",
    "end": "2743079"
  },
  {
    "text": "something like this you're going to be talking about 32-bit Intel 64-bit Intel 32-bit arm and",
    "start": "2743079",
    "end": "2748599"
  },
  {
    "text": "64-bit arm right these are kind of the platforms that I'm interested in if you if you're on some kind of embedded",
    "start": "2748599",
    "end": "2753819"
  },
  {
    "text": "platform I don't know I'm not the expert you are the experts you tell me but like on these on these CPUs",
    "start": "2753819",
    "end": "2760119"
  },
  {
    "text": "they all support this uh 32-bit x86 has this instruction compare exchange 8B",
    "start": "2760119",
    "end": "2766660"
  },
  {
    "text": "eight bytes 64 bits uh the 64-bit Intel version has compare exchange 16b which",
    "start": "2766660",
    "end": "2772540"
  },
  {
    "text": "is available on every every 60 every x64 chip since like there's of some very old",
    "start": "2772540",
    "end": "2778900"
  },
  {
    "text": "like AMD chips from 2008 and before that don't have that instruction but they're",
    "start": "2778900",
    "end": "2784119"
  },
  {
    "text": "very old everything since then you you can rely on that instruction being there actually Windows doesn't run if you have",
    "start": "2784119",
    "end": "2789579"
  },
  {
    "text": "if you don't have that instruction since Windows 8.1 like Windows doesn't even install if you if your CPU doesn't",
    "start": "2789579",
    "end": "2796000"
  },
  {
    "text": "doesn't support this instruction so it's there and the same story on arm depending on like what version of arm",
    "start": "2796000",
    "end": "2802540"
  },
  {
    "text": "you're on like the very newest ones I think they also have one instruction now for this kind of and then kind of older",
    "start": "2802540",
    "end": "2808599"
  },
  {
    "text": "arm chips they have this uh other thing which is called load Link store conditional which is different way of basically doing something that is the",
    "start": "2808599",
    "end": "2815440"
  },
  {
    "text": "same thing so it's there the instruction on these platforms is available",
    "start": "2815440",
    "end": "2821740"
  },
  {
    "text": "something that people have said yeah but it's slow and then I looked into this too and it found I found well not really",
    "start": "2821740",
    "end": "2827619"
  },
  {
    "text": "on x64 double compared to what was about twice as slow as comparing top",
    "start": "2827619",
    "end": "2833440"
  },
  {
    "text": "which makes sense because it's doing double the work but it's not 10 times slow or anything like this you don't get an abysmal performance hit actually I",
    "start": "2833440",
    "end": "2840400"
  },
  {
    "text": "tried this also on the oldest x64 computer I could find at home which was a Mac Mini from 2012 and I got the same",
    "start": "2840400",
    "end": "2846640"
  },
  {
    "text": "numbers it's only twice as slow it's not 10 times as slow or anything like that and I'm actually on on modern arm chips",
    "start": "2846640",
    "end": "2853599"
  },
  {
    "text": "it's not even twice as slow it's more like one and a half times slow so you don't have a catastrophic performance",
    "start": "2853599",
    "end": "2859060"
  },
  {
    "text": "hit if you use this but the the bigger and more interesting question is um",
    "start": "2859060",
    "end": "2864579"
  },
  {
    "text": "well does it work with the standard Library does it work in C plus where we have study atomic",
    "start": "2864579",
    "end": "2870160"
  },
  {
    "text": "in other words is this assert going to pass",
    "start": "2870160",
    "end": "2876540"
  },
  {
    "text": "and that was me when I was looking into this I was like well your CPU supports this surely stood Atomic is going to",
    "start": "2877060",
    "end": "2882760"
  },
  {
    "text": "support that too no",
    "start": "2882760",
    "end": "2889500"
  },
  {
    "text": "um and again I wrote it up in this blog post um I'm gonna just quickly show you like the the table basically",
    "start": "2890740",
    "end": "2896740"
  },
  {
    "text": "um you have the different CPUs and like the different compilers so on on Mac OS",
    "start": "2896740",
    "end": "2901839"
  },
  {
    "text": "like apple systems Mac OS iOS everything is fine um all of their their apple clang",
    "start": "2901839",
    "end": "2908200"
  },
  {
    "text": "supports it because all of their platforms require that to be there clang on Linux is is kind of a bit more",
    "start": "2908200",
    "end": "2915099"
  },
  {
    "text": "of a mixed bag you need to pass this this compiler flag to make it work and also align it on 128 bits and then if",
    "start": "2915099",
    "end": "2922359"
  },
  {
    "text": "you use the compiler flag you have like two different versions of subatomic floating around in your binary potentially so you get all the r",
    "start": "2922359",
    "end": "2928240"
  },
  {
    "text": "violations it's hairy and then on DCC and CC is really sad on the on the 64-bit versions both",
    "start": "2928240",
    "end": "2937119"
  },
  {
    "text": "arm and and um Intel which are the two platforms that we really need if you want to do",
    "start": "2937119",
    "end": "2943780"
  },
  {
    "text": "stuff on Modern consumer Hardware like this laptop or my phone it's it's not available",
    "start": "2943780",
    "end": "2951359"
  },
  {
    "text": "so that's another one of those cases where the com the standard Committee just or the kind of implementers choose",
    "start": "2986680",
    "end": "2992200"
  },
  {
    "text": "um uh basically backwards compatibility over performance which I think is not a",
    "start": "2992200",
    "end": "2997900"
  },
  {
    "text": "good solution for most people it's May San so what can we do about this well we can Implement our own statatomic",
    "start": "2997900",
    "end": "3004440"
  },
  {
    "text": "oh and by the way like GCC libatomic this is what this falls back to and on 64-bit that doesn't help us either like",
    "start": "3004440",
    "end": "3011339"
  },
  {
    "text": "they have these like Library calls and they have this like CPU intrinsics but it will also like you have no guarantee",
    "start": "3011339",
    "end": "3017700"
  },
  {
    "text": "that it will actually use the instruction it goes somewhere interlib Atomic and that probably will add mute",
    "start": "3017700",
    "end": "3022920"
  },
  {
    "text": "exist you have no guarantees whatsoever um so you can use your custom implementation of libatomic basically",
    "start": "3022920",
    "end": "3029880"
  },
  {
    "text": "which is something that I don't know how many years that would take to write but I would certainly not be able to do that",
    "start": "3029880",
    "end": "3035160"
  },
  {
    "text": "there is an implementation in boost Atomic which maybe you can use which gives you this",
    "start": "3035160",
    "end": "3041640"
  },
  {
    "text": "um or the other solution is don't use double with compound swap and actually this is kind of what you",
    "start": "3041640",
    "end": "3048599"
  },
  {
    "text": "end up doing don't use double with compare and swap how do we implement this without using double compare and swap well actually there is a technique",
    "start": "3048599",
    "end": "3055380"
  },
  {
    "text": "it's called packed pointer and that's uh the one that's used by all the implementations except the Anthony",
    "start": "3055380",
    "end": "3060839"
  },
  {
    "text": "Williams one so uh bloody slots implementation uses it the fully Facebook implementation user said it",
    "start": "3060839",
    "end": "3066540"
  },
  {
    "text": "only works in 64-bit and basically what it does it exploits the fact that 64-bit Intel doesn't",
    "start": "3066540",
    "end": "3072240"
  },
  {
    "text": "actually use all the 64 bits to store an address it operates on a",
    "start": "3072240",
    "end": "3077339"
  },
  {
    "text": "48-bit address space which means that first of all you have a few bits here which are the alignment",
    "start": "3077339",
    "end": "3083220"
  },
  {
    "text": "bits which you can use for like because either three or four of them depending on what the value of stud Max align T is but more importantly you",
    "start": "3083220",
    "end": "3090000"
  },
  {
    "text": "have 16 bits on a in the front which are just not used for for the address at all they're not used so you can put your own",
    "start": "3090000",
    "end": "3096000"
  },
  {
    "text": "you can put your ref count in there right uh and you have 16 bits so that means",
    "start": "3096000",
    "end": "3101400"
  },
  {
    "text": "you can have up to 65 000 threads which hopefully is more than anybody needs",
    "start": "3101400",
    "end": "3108720"
  },
  {
    "text": "and so you can you can cram your refcon in there so Intel actually now went to I think a",
    "start": "3108720",
    "end": "3114900"
  },
  {
    "text": "57-bit address space so then like it's it's more complicated but actually and there is um Linux kernel that supports",
    "start": "3114900",
    "end": "3122280"
  },
  {
    "text": "this and there is also Hardware I think that now supports a 57-bit address space but",
    "start": "3122280",
    "end": "3127680"
  },
  {
    "text": "um actually surprise hyrum's law you know um there are lots of programs out there",
    "start": "3127680",
    "end": "3133559"
  },
  {
    "text": "depending on those 16 bits being unused so this whole 57-bit address space thing is kind of just for internal space for",
    "start": "3133559",
    "end": "3140099"
  },
  {
    "text": "now and like if you have a user space application it's an opt-in and by default it's still only going to use the",
    "start": "3140099",
    "end": "3145800"
  },
  {
    "text": "48-bit addresses and the same story on 64-bit um again they have a 48-bit virtual",
    "start": "3145800",
    "end": "3152700"
  },
  {
    "text": "address space and now you have a thing where you can use uh more bits but again",
    "start": "3152700",
    "end": "3158400"
  },
  {
    "text": "that's opt-in and by default you can rely on those 16 bits being unused and that's I don't think that's going to",
    "start": "3158400",
    "end": "3164160"
  },
  {
    "text": "change at least in the next decade because we have this you know software that already relies on that being there",
    "start": "3164160",
    "end": "3170400"
  },
  {
    "text": "well let's see but for now I think we're good with using those 16 bits there and then if you do that you end up with",
    "start": "3170400",
    "end": "3176160"
  },
  {
    "text": "something like this so this uh now we have instead of the uh kind of struct",
    "start": "3176160",
    "end": "3181559"
  },
  {
    "text": "that has a pointer to a control block and then a ref count you have the slightly more complicated structure",
    "start": "3181559",
    "end": "3186720"
  },
  {
    "text": "which is the atomic pack pointer where you have just one Atomic uh 64-bit integer that's your value and that now",
    "start": "3186720",
    "end": "3193079"
  },
  {
    "text": "contains uh 16 bits of refcon and 48 bits of address and in order to get the pointer",
    "start": "3193079",
    "end": "3199260"
  },
  {
    "text": "out or to get the ref count out you kind of have to do offset and mask you kind of have to either shift the 16 bits out",
    "start": "3199260",
    "end": "3205079"
  },
  {
    "text": "or mask the 48 bits away um and um yeah if you store you have to",
    "start": "3205079",
    "end": "3212099"
  },
  {
    "text": "do them in Reverse I'm sure you can imagine what that looks like um this one actually it's kind of a",
    "start": "3212099",
    "end": "3218700"
  },
  {
    "text": "hidden reinterpret cast here because like you're you're doing like an offset on an integer so and then you're kind of",
    "start": "3218700",
    "end": "3224400"
  },
  {
    "text": "returning that as a pointer but actually turns out this is fine this is like pretty much the only use case where reinterpret cost is actually okay",
    "start": "3224400",
    "end": "3230579"
  },
  {
    "text": "because there is actually an object alive at that exact address that you're going to return in the end so we're good",
    "start": "3230579",
    "end": "3238160"
  },
  {
    "text": "um and now we're here um so we have a ref count and our pointer to the control board crammed",
    "start": "3238440",
    "end": "3243540"
  },
  {
    "text": "into 164-bit um variable now which is great we still have the problem of the areas pointer",
    "start": "3243540",
    "end": "3249780"
  },
  {
    "text": "and now there's definitely no space to put the ls pointer anywhere so how are we going to solve that",
    "start": "3249780",
    "end": "3255980"
  },
  {
    "text": "um so Folly has one solution which is um they kind of wrap this they have another level living direction right they wrap",
    "start": "3256380",
    "end": "3262380"
  },
  {
    "text": "this into another thingy so you store a pointer to a thingy which then points the control",
    "start": "3262380",
    "end": "3268500"
  },
  {
    "text": "block um which in that case is just another shared pointer basically problem",
    "start": "3268500",
    "end": "3275099"
  },
  {
    "text": "this is again a memory allocation so it's not lock free and if you're if you're Facebook that's probably fine",
    "start": "3275099",
    "end": "3280740"
  },
  {
    "text": "because you have your own allocator that handles all the allocations on your server and you you know what's going on",
    "start": "3280740",
    "end": "3286559"
  },
  {
    "text": "there but if you want to run audio an audio plugin on a laptop that's",
    "start": "3286559",
    "end": "3292380"
  },
  {
    "text": "not good so again my suggestion is we can move the allocation from Atomic sharep",
    "start": "3292380",
    "end": "3297660"
  },
  {
    "text": "pointer into the shared pointer Constructor so the atomic one is going to be Lock Free now we still have this overhead for",
    "start": "3297660",
    "end": "3303300"
  },
  {
    "text": "every LS chat pointer every time we use the LDS Constructor you have a shared pointer to base and it's storing a",
    "start": "3303300",
    "end": "3308579"
  },
  {
    "text": "derived you're going to have an extra memory location and this time there's no way to get around that that's not going to be an acceptable",
    "start": "3308579",
    "end": "3314880"
  },
  {
    "text": "trade-off for people who just want to use the shared pointer without the atomic part so that means you definitely can't build this on top of Stitch head",
    "start": "3314880",
    "end": "3321420"
  },
  {
    "text": "point where we need to use our custom shared pointer now but you know if you want to use an atomic sand pointer that's probably okay",
    "start": "3321420",
    "end": "3327180"
  },
  {
    "text": "and we can make it log free it's just that Facebook hasn't done that and the other implementation is the one from",
    "start": "3327180",
    "end": "3332880"
  },
  {
    "text": "vladislav and he also uses um the pack pointer technique but he basically just doesn't handle that",
    "start": "3332880",
    "end": "3338819"
  },
  {
    "text": "so if you take his implementation and you create a shared pointer to base and give it a pointer to derived it just",
    "start": "3338819",
    "end": "3345119"
  },
  {
    "text": "crashes it just doesn't handle that case at all which is unfortunate but",
    "start": "3345119",
    "end": "3350700"
  },
  {
    "text": "um it's not a production ready implementation so actually here this is a little overview of all the different implementations that there are",
    "start": "3350700",
    "end": "3358319"
  },
  {
    "text": "um that are open source portability Anthony Williams relies on W with component swap that's not in",
    "start": "3358319",
    "end": "3364559"
  },
  {
    "text": "general portable vladislav um works everywhere in 64-bit because he",
    "start": "3364559",
    "end": "3370440"
  },
  {
    "text": "uses the pointer packing so that's good fully actually only runs on GCC because they built their thing on top of GCC",
    "start": "3370440",
    "end": "3377160"
  },
  {
    "text": "lipstick C plus plus shared pointer right so they actually have this thing where you know you have this trick where",
    "start": "3377160",
    "end": "3382200"
  },
  {
    "text": "you use um explicit template translation to like get access to a private",
    "start": "3382200",
    "end": "3388079"
  },
  {
    "text": "a data member of a class I don't know if anybody has heard about that trick but that's what they're using that is really evil",
    "start": "3388079",
    "end": "3394260"
  },
  {
    "text": "um and that obviously only works for this particular standard shared pointer implementation so it only works in GCC",
    "start": "3394260",
    "end": "3400980"
  },
  {
    "text": "um is it actually lock free for the earliest pointer case none of them are like Anthony Williams has this like",
    "start": "3400980",
    "end": "3406680"
  },
  {
    "text": "auxiliary data structure which allocates uh related stuff just doesn't handle that and 4D also allocates",
    "start": "3406680",
    "end": "3412680"
  },
  {
    "text": "is it standard conforming Anthony Williams is almost there he pretty much has the whole interface",
    "start": "3412680",
    "end": "3418079"
  },
  {
    "text": "of shared pointer there the light's laugh is very very rudimentary there's lots of stuff missing there's no",
    "start": "3418079",
    "end": "3423359"
  },
  {
    "text": "exchange lots of the constructors are missing it's kind of just just a half half finished implementation at this point 40 is pretty good",
    "start": "3423359",
    "end": "3430500"
  },
  {
    "text": "um they don't support weak pointer there's a few other things they don't support but it's mostly the functionality of shared pointers there and then obviously most importantly is",
    "start": "3430500",
    "end": "3437460"
  },
  {
    "text": "it production ready well Anthony Williams and vladislav both of them are just proof of concept they're not really",
    "start": "3437460",
    "end": "3443760"
  },
  {
    "text": "finished production ready implementations I found bugs in them in both of them within five minutes of",
    "start": "3443760",
    "end": "3450059"
  },
  {
    "text": "using it like something crashes something doesn't work um uh the Folly one implementation is",
    "start": "3450059",
    "end": "3455940"
  },
  {
    "text": "the only one that I'm aware of that's both open source and production ready that actually works they have been using it for years and years",
    "start": "3455940",
    "end": "3461940"
  },
  {
    "text": "that's where we are today okay I have a couple more minutes maybe very quickly run through the benchmarks",
    "start": "3461940",
    "end": "3467099"
  },
  {
    "text": "here um what I was doing here is I was trying to see how this performs um so I did this",
    "start": "3467099",
    "end": "3473940"
  },
  {
    "text": "very crude thing it's not a good way to Benchmark this I really need to figure out a better way to do this um",
    "start": "3473940",
    "end": "3478980"
  },
  {
    "text": "basically I have a bunch of threads and they're just pounding this Atomic sharep pointer so I just have a custom here",
    "start": "3478980",
    "end": "3484500"
  },
  {
    "text": "they're just like trying to update the value there and then I have this one thread and the number of those threads",
    "start": "3484500",
    "end": "3490859"
  },
  {
    "text": "is kind of variable uh and then I have one thread where I'm just doing one Atomic load or one Atomic",
    "start": "3490859",
    "end": "3498359"
  },
  {
    "text": "store or one Atomic compare exchange or one Atomic repair Exchange in the loop until it succeeds and I'm gonna see how long that takes",
    "start": "3498359",
    "end": "3506900"
  },
  {
    "text": "and um I'm kind of doing two things at the same time here I'm measuring this kind",
    "start": "3507300",
    "end": "3512400"
  },
  {
    "text": "of contention on an atomic in general at the same time as measuring the actual shared pointer so it's not a good way to",
    "start": "3512400",
    "end": "3517619"
  },
  {
    "text": "Benchmark this if anybody has an idea how to Benchmark this better please let me know I want to know these are the",
    "start": "3517619",
    "end": "3523140"
  },
  {
    "text": "results um basically this is on Apple client this",
    "start": "3523140",
    "end": "3529079"
  },
  {
    "text": "is one of the two compilers where you can compare multiple implementations so I'm comparing the standard one I just",
    "start": "3529079",
    "end": "3534420"
  },
  {
    "text": "use the freestanding because Clank doesn't have the atomic SharePoint it only has a freestanding function so I wrote a wrapper around it",
    "start": "3534420",
    "end": "3541020"
  },
  {
    "text": "and I'm using that that one uses mutexes under the hood that's the black lines and then we have Anthony Williams of GSW",
    "start": "3541020",
    "end": "3546299"
  },
  {
    "text": "with compare and Swap and largest love and you see this typical thing here where the mutex version on average",
    "start": "3546299",
    "end": "3552599"
  },
  {
    "text": "that's like the star is actually faster it's actually a lot faster on average but then if you look at the worst case",
    "start": "3552599",
    "end": "3558299"
  },
  {
    "text": "which is the top of the bar that's where the mutex one is really bad because once in a while you get stuck on this mutex",
    "start": "3558299",
    "end": "3563819"
  },
  {
    "text": "forever and you can't reason about how long that's going to be so you you're not limited and like how long you might",
    "start": "3563819",
    "end": "3569280"
  },
  {
    "text": "wait on there and so the the lockview versions both Anthony Williams and vladislav",
    "start": "3569280",
    "end": "3575460"
  },
  {
    "text": "um they're more costly on average but the worst case is orders of magnitude better and that's really what you want",
    "start": "3575460",
    "end": "3580680"
  },
  {
    "text": "if you do in lockview programming interestingly also um bloody slap here is about two to",
    "start": "3580680",
    "end": "3586079"
  },
  {
    "text": "three times faster one reason is he doesn't use double with compound swap he uses the pack pointer",
    "start": "3586079",
    "end": "3591540"
  },
  {
    "text": "and the other reason is if you use pack pointer then the local ref count increment you don't have to do the cast up there anymore remember that was the",
    "start": "3591540",
    "end": "3598200"
  },
  {
    "text": "first step of the atomic load you can just do one Atomic add one Atomic Atomic",
    "start": "3598200",
    "end": "3603480"
  },
  {
    "text": "increment so that becomes faster as well if you look at the other operations so that was the load if you look at store",
    "start": "3603480",
    "end": "3608880"
  },
  {
    "text": "compare exchange and compare Exchange in a loop legislife has a kind of an unfortunate implementation of store it's not very",
    "start": "3608880",
    "end": "3614640"
  },
  {
    "text": "efficient uh Anthony is better there um that can be implemented better compare exchange is kind of the same as",
    "start": "3614640",
    "end": "3621599"
  },
  {
    "text": "load and then doing compare Exchange in the lube is actually really bad you should be avoiding this if you're doing a lock for Atomic SharePoint and because",
    "start": "3621599",
    "end": "3627780"
  },
  {
    "text": "now the the compare exchange itself is a cast Loop and then you put the whole thing in an outer cast loop as well and",
    "start": "3627780",
    "end": "3634680"
  },
  {
    "text": "that's just going to have bad performance so that's not really better than the mutex version so you should avoid that",
    "start": "3634680",
    "end": "3639900"
  },
  {
    "text": "and this is the other compiler where I can Benchmark stuff which is GCC because for the compilers on DCC and largest",
    "start": "3639900",
    "end": "3646020"
  },
  {
    "text": "love comparison GCC Anthony doesn't because GC doesn't do double with compare and swap",
    "start": "3646020",
    "end": "3651540"
  },
  {
    "text": "and here it's it's a very similar picture um really um",
    "start": "3651540",
    "end": "3657140"
  },
  {
    "text": "right um that's pretty much it um future work I want to do better",
    "start": "3657240",
    "end": "3662700"
  },
  {
    "text": "benchmarks and the other really important thing is obviously I'm working on my own implementation because I want to solve these problems",
    "start": "3662700",
    "end": "3671220"
  },
  {
    "text": "um remember this is kind of where we are today with the three open source implementations that are available what I want to do is I want to be more",
    "start": "3671220",
    "end": "3677760"
  },
  {
    "text": "portable by actually letting you choose whether you want to do double with compare and swap or not and potentially also using like a custom",
    "start": "3677760",
    "end": "3684720"
  },
  {
    "text": "atomics in there so you can force it to use double boot campaign swap if you want to if you know that your CPU supports it I want to I want to uh solve",
    "start": "3684720",
    "end": "3693540"
  },
  {
    "text": "this problem of the logography I want to actually make it lock free like for the Alice chat pointer case which none of",
    "start": "3693540",
    "end": "3698760"
  },
  {
    "text": "the implementations are doing that which I showed you how how to do that and I want to make it sound like",
    "start": "3698760",
    "end": "3703799"
  },
  {
    "text": "conforming as well by basically supporting the whole the whole API and hopefully one day I will actually have",
    "start": "3703799",
    "end": "3709440"
  },
  {
    "text": "this in a production ready State it's unfortunately right now not there yet so",
    "start": "3709440",
    "end": "3714480"
  },
  {
    "text": "it's not public yet um so I also want to experiment a little bit further with some optimizations and",
    "start": "3714480",
    "end": "3720180"
  },
  {
    "text": "then once my implementation is ready which hopefully will be later this year I will publish it on GitHub so right now",
    "start": "3720180",
    "end": "3725940"
  },
  {
    "text": "it's unfortunately not ready yet but I'm working on it hopefully in a few months or even faster I don't know how much",
    "start": "3725940",
    "end": "3732119"
  },
  {
    "text": "time I get to work on this uh it will be on GitHub and um yeah I actually already this is",
    "start": "3732119",
    "end": "3737940"
  },
  {
    "text": "my last slide I actually know I I can already tell you where it's going to be when it's going to be on GitHub it's going to be in this repository this is a",
    "start": "3737940",
    "end": "3744599"
  },
  {
    "text": "site project that I started with a friend of mine uh Fabian van Giles uh just a few weeks ago and I can this is",
    "start": "3744599",
    "end": "3751559"
  },
  {
    "text": "first time I'm announcing this we started this little Library which is called Krill Krill stands for",
    "start": "3751559",
    "end": "3756780"
  },
  {
    "text": "cross-platform real-time i o and low latency Library so it's going to contain all these little utilities for like lock",
    "start": "3756780",
    "end": "3762299"
  },
  {
    "text": "free and the latency uh programming that we have come up with over the years currently it's it's very raw it just",
    "start": "3762299",
    "end": "3768599"
  },
  {
    "text": "contains one class and at the moment which is this spin lock with Progressive back off that I have done another talk",
    "start": "3768599",
    "end": "3773880"
  },
  {
    "text": "about that's all there is there is no documentation yet either but this is where we're going to be putting all",
    "start": "3773880",
    "end": "3779940"
  },
  {
    "text": "these little utilities and this is where the atomic shared pointer is going to be as soon as I finished implementing it so",
    "start": "3779940",
    "end": "3785460"
  },
  {
    "text": "watch this space and with that I'm done sorry for overrunning by three minutes I hope you",
    "start": "3785460",
    "end": "3791280"
  },
  {
    "text": "can forgive me and I hope you enjoyed the talk",
    "start": "3791280",
    "end": "3795260"
  }
]