[
  {
    "text": "hello everyone uh welcome to yet another talk about asynchronous programming in dotnet",
    "start": "640",
    "end": "6720"
  },
  {
    "text": "so why another talk well uh most of the ones i've seen uh focus on how to use tasks and usually",
    "start": "6720",
    "end": "13840"
  },
  {
    "text": "end up with somebody asking in that precise situation that you didn't describe",
    "start": "13840",
    "end": "19359"
  },
  {
    "text": "should i use configure weight or not and i believe the reason for that is that those talks focus on how to use",
    "start": "19359",
    "end": "27119"
  },
  {
    "text": "this api but they don't really explain what happens under the hood",
    "start": "27119",
    "end": "32238"
  },
  {
    "text": "so when faced with a new situation you can't really extrapolate about what",
    "start": "32239",
    "end": "37440"
  },
  {
    "text": "you're supposed to do this time i'm not going to talk about how to use task",
    "start": "37440",
    "end": "42640"
  },
  {
    "text": "instead i'll try to break the magic and show you what happens under the hood and to do that we're",
    "start": "42640",
    "end": "49280"
  },
  {
    "text": "going to re-implement tasks from scratch of course we won't have time to cover",
    "start": "49280",
    "end": "55199"
  },
  {
    "text": "anything far from it so i'll focus only on the subset of features uh needed",
    "start": "55199",
    "end": "61280"
  },
  {
    "text": "to re-implement async await and by the end of the talk you might still don't know whether you",
    "start": "61280",
    "end": "66960"
  },
  {
    "text": "need to use a configure weight in that particular situation but i hope i will have given you the",
    "start": "66960",
    "end": "72960"
  },
  {
    "text": "tools to dig into the framework and find the answer by yourself so let's jump in and start by setting",
    "start": "72960",
    "end": "80720"
  },
  {
    "text": "a bit of vocabulary if i managed yeah there we go uh so uh",
    "start": "80720",
    "end": "87840"
  },
  {
    "text": "task is the microsoft implementation of the future and promise pattern which is a pattern for asynchronous programming",
    "start": "87840",
    "end": "95040"
  },
  {
    "text": "and the way it works is that the user code occurs in a synchronous method",
    "start": "95040",
    "end": "100159"
  },
  {
    "text": "and on the side of the method immediately a pair of objects is created a promise",
    "start": "100159",
    "end": "106479"
  },
  {
    "text": "and a feature and the future is written to the client and then a nasa clause operation",
    "start": "106479",
    "end": "113759"
  },
  {
    "text": "executing the background and when it's done it uses it signals",
    "start": "113759",
    "end": "119119"
  },
  {
    "text": "the promise sorry which in turn completes the future and on client side so after calling the",
    "start": "119119",
    "end": "125759"
  },
  {
    "text": "method the method returns shortly after with the future then the client can do other stuff on",
    "start": "125759",
    "end": "132800"
  },
  {
    "text": "the side and when it's ready to fetch the result it can use the feature to get that data to give a real world",
    "start": "132800",
    "end": "139840"
  },
  {
    "text": "analogy it works a bit like if you were a pre-order stop pre-ordering some stuff at the store so you go to the store you",
    "start": "139840",
    "end": "146720"
  },
  {
    "text": "pre-order they give you a voucher and then you go back home and live your life and a few days after",
    "start": "146720",
    "end": "152160"
  },
  {
    "text": "after there is a product you can go back to the store and exchange the voucher for the product you pre-order so that's",
    "start": "152160",
    "end": "158800"
  },
  {
    "text": "exactly how it works and so in the framework uh the promise",
    "start": "158800",
    "end": "164560"
  },
  {
    "text": "is named tacom completion source and the future is named task and this is the two",
    "start": "164560",
    "end": "170800"
  },
  {
    "text": "objects that we will re-implement during this talk and so for the remainder i will refer to",
    "start": "170800",
    "end": "178720"
  },
  {
    "text": "test completion source as promise and task as future so",
    "start": "178720",
    "end": "184640"
  },
  {
    "text": "we are going to start with the most basic implementation of those two objects so",
    "start": "184640",
    "end": "191680"
  },
  {
    "text": "here is the most basic feature that we can make this class has an internal constructor",
    "start": "191680",
    "end": "197680"
  },
  {
    "text": "because we don't want user to directly create it and we have a very simple state it's",
    "start": "197680",
    "end": "203280"
  },
  {
    "text": "either completed or is not we don't deal with exception or cancellation we don't have time for that",
    "start": "203280",
    "end": "209440"
  },
  {
    "text": "and we have a simple synchronization we have one v text when we said completely to true we",
    "start": "209440",
    "end": "215760"
  },
  {
    "text": "signal the mutex and we have a wet method to wait for it so we can't choose by itself we also",
    "start": "215760",
    "end": "223360"
  },
  {
    "text": "need to implement a promise so i'm going to copy paste it right there and in the promise",
    "start": "223360",
    "end": "231840"
  },
  {
    "text": "we wrap the future and we expose it in the property and we have a single method complete",
    "start": "231840",
    "end": "237599"
  },
  {
    "text": "which transitions the future to complete it so promise is our class completion source and future",
    "start": "237599",
    "end": "243840"
  },
  {
    "text": "is our task and from there from the from the user code you can write this kind of asynchronous",
    "start": "243840",
    "end": "251360"
  },
  {
    "text": "method where we immediately create a promise",
    "start": "251360",
    "end": "256479"
  },
  {
    "text": "start an asynchronous operation and return the future during the example when the asynchronous",
    "start": "256479",
    "end": "262320"
  },
  {
    "text": "operation completes after one second we just complete the promise and then on client side",
    "start": "262320",
    "end": "268240"
  },
  {
    "text": "we can call the asynchronous method here we do our stuff and then",
    "start": "268240",
    "end": "275680"
  },
  {
    "text": "at some point we can wait on the future and fetch the results and so if i run it like this uh well",
    "start": "275680",
    "end": "282320"
  },
  {
    "text": "nothing impresses is going to happen it's just going to wait for one second and then we see it done",
    "start": "282320",
    "end": "288479"
  },
  {
    "text": "um more often than not you will want your asynchronous method to return some data alongside the",
    "start": "288479",
    "end": "295759"
  },
  {
    "text": "feature so this is what we're going to implement next so we need a generic version of the",
    "start": "295759",
    "end": "301360"
  },
  {
    "text": "feature that we're going to call a feature of t and we just make it inherit from the future",
    "start": "301360",
    "end": "307440"
  },
  {
    "text": "and the only thing it adds is a result property which will contain the result",
    "start": "307440",
    "end": "312720"
  },
  {
    "text": "of the method then we need a new promise to manipulate it so a generic promise",
    "start": "312720",
    "end": "320720"
  },
  {
    "text": "so we create a promise of t and here you might be tempted to make it",
    "start": "320720",
    "end": "326560"
  },
  {
    "text": "inherit from promise but we can't do that because if we do that then we get the parameter less complete",
    "start": "326560",
    "end": "333840"
  },
  {
    "text": "method and it means that somebody can complete the promise without setting a result on",
    "start": "333840",
    "end": "339440"
  },
  {
    "text": "the future which will lead to some consistent states so we cannot do that and if you think about it that's the",
    "start": "339440",
    "end": "345840"
  },
  {
    "text": "reason why for so long there hasn't been a non-generic task completion source in the dotted",
    "start": "345840",
    "end": "351520"
  },
  {
    "text": "framework it's because to implement it since they can't make one inherit from the other",
    "start": "351520",
    "end": "356560"
  },
  {
    "text": "they would have to duplicate the code and so they don't want to do that unless they have a compelling reason to",
    "start": "356560",
    "end": "362160"
  },
  {
    "text": "do so and a bit of trivia the non-generic test compression source",
    "start": "362160",
    "end": "367600"
  },
  {
    "text": "was merged into net core a few days ago so it should be finally",
    "start": "367600",
    "end": "373520"
  },
  {
    "text": "available in dot five so we can do that so instead we have to",
    "start": "373520",
    "end": "379520"
  },
  {
    "text": "copy paste the code of the promise and here use a generic feature instead and of course",
    "start": "379520",
    "end": "386319"
  },
  {
    "text": "the complete method will take a value and then we just assign the value to the",
    "start": "386319",
    "end": "391600"
  },
  {
    "text": "future so we will not take care of race condition and this kind of stuff",
    "start": "391600",
    "end": "396960"
  },
  {
    "text": "because we won't have time and so now that we have that here we can return the future of hints",
    "start": "396960",
    "end": "402880"
  },
  {
    "text": "so we can create a promise of it and we can complete the promise with the value 42",
    "start": "402880",
    "end": "409039"
  },
  {
    "text": "and then from client side we can say console.writeline a feature completed",
    "start": "409039",
    "end": "415199"
  },
  {
    "text": "with value and if everything works properly then",
    "start": "415199",
    "end": "421759"
  },
  {
    "text": "then it should display fortitude hopefully oh there we go so still nothing very",
    "start": "421759",
    "end": "429840"
  },
  {
    "text": "impressive but you already have the basic tools to do some async programming",
    "start": "429840",
    "end": "435120"
  },
  {
    "text": "but pretty quickly you will notice one problem is that whenever you need to fetch the value of",
    "start": "435120",
    "end": "440400"
  },
  {
    "text": "a feature that is not yet completed you only well your only way is to call the weight method",
    "start": "440400",
    "end": "446560"
  },
  {
    "text": "which will block the thread synchronously and so you will be wasting resources uh",
    "start": "446560",
    "end": "453440"
  },
  {
    "text": "just waiting around which is a shame since one of the points of asynchronous programming is pretty",
    "start": "453440",
    "end": "459360"
  },
  {
    "text": "easy to free those threads when waiting for operations so to fix that we need to add",
    "start": "459360",
    "end": "465520"
  },
  {
    "text": "a new api we need to add a notification system that allows us to subscribe to the",
    "start": "465520",
    "end": "470879"
  },
  {
    "text": "future and be called back when it completes we are going to implement that and i go back to my future and i'm",
    "start": "470879",
    "end": "478879"
  },
  {
    "text": "going to add that method that we're going to continue with i'm going to take an",
    "start": "478879",
    "end": "484000"
  },
  {
    "text": "actionable feature which is a continuation and the idea that whenever this future completes we are",
    "start": "484000",
    "end": "491919"
  },
  {
    "text": "going to call this continuation with the future as a as a parameter this way the",
    "start": "491919",
    "end": "498319"
  },
  {
    "text": "continuation can take decision based on the status of his parents",
    "start": "498319",
    "end": "503520"
  },
  {
    "text": "but if we design the api like that we will be able of course to do here",
    "start": "503520",
    "end": "509599"
  },
  {
    "text": "feature dot continue it but then if we want to chain another continuation after this one we",
    "start": "509599",
    "end": "516479"
  },
  {
    "text": "cannot because our return type is void so it would be much more convenient",
    "start": "516479",
    "end": "521599"
  },
  {
    "text": "to instead return the future and the convention will be that this future completes",
    "start": "521599",
    "end": "527200"
  },
  {
    "text": "when this callback is complete and this way we can create a workflow",
    "start": "527200",
    "end": "533519"
  },
  {
    "text": "so to implement this we can use uh our promise object but for optimization",
    "start": "533519",
    "end": "539839"
  },
  {
    "text": "purpose to reduce the number of allocations it's better to have one type dedicated to this and so we",
    "start": "539839",
    "end": "546320"
  },
  {
    "text": "we're going to introduce a new type of future that we're going to call future continuation i'm going to copy it",
    "start": "546320",
    "end": "552959"
  },
  {
    "text": "here so it's very simple uh it's inherit from future",
    "start": "552959",
    "end": "558080"
  },
  {
    "text": "it takes the continuation and the parent future and store them and then it explores an",
    "start": "558080",
    "end": "563920"
  },
  {
    "text": "invoke method that is internal that's very important that calls the continuation and",
    "start": "563920",
    "end": "568959"
  },
  {
    "text": "transitions the future from to completed so basically it's merged the concept of future and promise into a",
    "start": "568959",
    "end": "576480"
  },
  {
    "text": "second class mainly to reduce the number of heap allocation and also to make some stuff",
    "start": "576480",
    "end": "582560"
  },
  {
    "text": "easier to implement later so once we have that we can go back to our continue",
    "start": "582560",
    "end": "590000"
  },
  {
    "text": "with method and implement it so it will be something like that we create our future continuation we",
    "start": "590000",
    "end": "596000"
  },
  {
    "text": "call an add continuation method that we haven't implemented yet and we'll return the future but if i",
    "start": "596000",
    "end": "602240"
  },
  {
    "text": "have only discontinued then here let's say that i want to",
    "start": "602240",
    "end": "607360"
  },
  {
    "text": "return the value so say 10 i won't be able to because our only continuous",
    "start": "607360",
    "end": "612959"
  },
  {
    "text": "return is non-general future and we have no overload that returns a generic one so we are going to",
    "start": "612959",
    "end": "619760"
  },
  {
    "text": "add this so like this i declare",
    "start": "619760",
    "end": "625120"
  },
  {
    "text": "this overload so of course he knew is that take a thunk instead of an action this time and it",
    "start": "625120",
    "end": "631360"
  },
  {
    "text": "returns a generic feature and so i'm going to copy paste the code here",
    "start": "631360",
    "end": "636880"
  },
  {
    "text": "but it's not going to work because feature continuation is a non-general feature and here we",
    "start": "636880",
    "end": "644720"
  },
  {
    "text": "need to return a generic one so we need a new implementation of future continuation so we are going",
    "start": "644720",
    "end": "651920"
  },
  {
    "text": "to do that and here we have future continuation of t which is just like future continuation",
    "start": "651920",
    "end": "659200"
  },
  {
    "text": "except that it inherits from future of t and so it takes the continuation and the parent and in the internal",
    "start": "659200",
    "end": "665920"
  },
  {
    "text": "invoke equals the continuation assign the result to the future and transition to complete it",
    "start": "665920",
    "end": "673839"
  },
  {
    "text": "so now i can just use my generic future continuation and it should work but then let's",
    "start": "673839",
    "end": "680320"
  },
  {
    "text": "imagine that i don't want to return 42 but i want to return the value of the parent future times",
    "start": "680320",
    "end": "687839"
  },
  {
    "text": "uh i can do that because continuous is only declared on the non-general future so i need to",
    "start": "687839",
    "end": "694240"
  },
  {
    "text": "add overload on the generic one so we are going to do that right now so my",
    "start": "694240",
    "end": "701120"
  },
  {
    "text": "general future is right there and so i need to continue with on this",
    "start": "701120",
    "end": "706399"
  },
  {
    "text": "class and here you may be tempted to copy paste this",
    "start": "706399",
    "end": "711680"
  },
  {
    "text": "but this is not going to compile because future continuation accepts an action or feature and here we",
    "start": "711680",
    "end": "718480"
  },
  {
    "text": "have an actionable feature of t and so if you want to do things cleanly you have to implement",
    "start": "718480",
    "end": "724480"
  },
  {
    "text": "not two types of continuation but four different types of continuation and that's what they did",
    "start": "724480",
    "end": "730000"
  },
  {
    "text": "in the dotted framework so in our case we're going to cut corners just to go faster and i'm going to",
    "start": "730000",
    "end": "737680"
  },
  {
    "text": "reuse the same future continuation but introduce a lambda that will cast the future to",
    "start": "737680",
    "end": "743519"
  },
  {
    "text": "future security but by doing so i add a heap allocation because of the closure",
    "start": "743519",
    "end": "748880"
  },
  {
    "text": "and so if you're worried about performance you cannot do that and that's why they didn't do that in the detail framework",
    "start": "748880",
    "end": "756079"
  },
  {
    "text": "okay so i still need the one for that routine the generic feature and now we can finish implementing it so",
    "start": "756079",
    "end": "762399"
  },
  {
    "text": "we still don't have the add continuation method so i'm going to implement it",
    "start": "762399",
    "end": "767519"
  },
  {
    "text": "and we just need to enqueue the continuation to some internal queue",
    "start": "767519",
    "end": "773200"
  },
  {
    "text": "and i have to do here i will go back to it later and so i still need to introduce that",
    "start": "773200",
    "end": "780240"
  },
  {
    "text": "concurrent queue so concurrent queue feature that i call continuation",
    "start": "780240",
    "end": "787440"
  },
  {
    "text": "there we go and so uh right there this works and we we have",
    "start": "787440",
    "end": "793760"
  },
  {
    "text": "our continuations that are included and we still need to execute them when our feature is completed",
    "start": "793760",
    "end": "799440"
  },
  {
    "text": "so i'm going to introduce an invoke continuations method",
    "start": "799440",
    "end": "805360"
  },
  {
    "text": "i'm going to copy paste it right there and the idea is that we just take",
    "start": "805360",
    "end": "811519"
  },
  {
    "text": "everything we have in the queue and we call invoke honest but this cannot work because",
    "start": "811519",
    "end": "817680"
  },
  {
    "text": "invoke is an internal method that is declared on future continuation",
    "start": "817680",
    "end": "823440"
  },
  {
    "text": "and future continuation of t and here we have a cure future so we cannot use invoke",
    "start": "823440",
    "end": "829680"
  },
  {
    "text": "there are multiple ways to fix that for instance we could do some testing but we have potentially",
    "start": "829680",
    "end": "835760"
  },
  {
    "text": "four different types of contamination we could use interfaces but the way they did that in the net",
    "start": "835760",
    "end": "840880"
  },
  {
    "text": "framework is by introducing an internal virtual invoke method on the base feature",
    "start": "840880",
    "end": "848000"
  },
  {
    "text": "and then just overriding it when necessary right there and my other future",
    "start": "848000",
    "end": "854399"
  },
  {
    "text": "continuation is right there so it means that if you call in work on some kind of feature you will get an",
    "start": "854399",
    "end": "861360"
  },
  {
    "text": "exception but this should never happen because the method is internal and on our side",
    "start": "861360",
    "end": "867040"
  },
  {
    "text": "we are careful to only call it when it makes sense we still need to call in the continuation",
    "start": "867040",
    "end": "872720"
  },
  {
    "text": "some point so we're going to say when i set is completed to true i'm going to call invert continuations",
    "start": "872720",
    "end": "879519"
  },
  {
    "text": "like that and uh yes and the to do so if i add continuation of feature that",
    "start": "879519",
    "end": "885920"
  },
  {
    "text": "is not completed is going to be enqueued and then when we transition to completed we call invert",
    "start": "885920",
    "end": "891600"
  },
  {
    "text": "continuation and we execute it but if the future is already completed when i call add continuation",
    "start": "891600",
    "end": "898160"
  },
  {
    "text": "then i'm going to enter it and never execute it because we've already called in the",
    "start": "898160",
    "end": "903279"
  },
  {
    "text": "continuation so in that case i'm going to say okay if the current future is already",
    "start": "903279",
    "end": "909519"
  },
  {
    "text": "completed so i directly invoke the continuation without unqueueing it",
    "start": "909519",
    "end": "916240"
  },
  {
    "text": "and with that we should have everything we need so i'm just going to put that in there",
    "start": "916399",
    "end": "923040"
  },
  {
    "text": "and i'm going to chain another feature after that so continue with here i'm going to say a second feature",
    "start": "923040",
    "end": "932320"
  },
  {
    "text": "and display the the result and we're going to make sure that it's",
    "start": "932320",
    "end": "937360"
  },
  {
    "text": "working and uh we see that done is displayed right away because we are not blocking",
    "start": "937360",
    "end": "943199"
  },
  {
    "text": "the thread anymore and then we see 42 and 84.",
    "start": "943199",
    "end": "948240"
  },
  {
    "text": "but we still have a problem let's say that i want to add a continuation to the",
    "start": "948240",
    "end": "954000"
  },
  {
    "text": "first feature so i'm adding a continuation to the feature that was returned by essing",
    "start": "954000",
    "end": "960160"
  },
  {
    "text": "method and here i'm going to write a second continuation like this and then uh",
    "start": "960160",
    "end": "968160"
  },
  {
    "text": "i'm going to make the asynchronous method slightly faster just to save time and we will say that the first",
    "start": "968160",
    "end": "974399"
  },
  {
    "text": "continuation takes some time to run and now if i run my program what is",
    "start": "974399",
    "end": "980800"
  },
  {
    "text": "going to happen is that we have done instantaneously and then we have a two second pers",
    "start": "980800",
    "end": "986320"
  },
  {
    "text": "and then we have a future completely that is executed first then second future and finally second",
    "start": "986320",
    "end": "993120"
  },
  {
    "text": "continuation so second continuation had to wait for those two to execute",
    "start": "993120",
    "end": "998399"
  },
  {
    "text": "before executing even though it should have been able to run as soon as the synchronous method completed so what happened",
    "start": "998399",
    "end": "1005759"
  },
  {
    "text": "the problem with our current implementation is that we are calling the continuations",
    "start": "1005759",
    "end": "1010880"
  },
  {
    "text": "in the same thread that completed the promise uh this is something in asynchronous",
    "start": "1010880",
    "end": "1016320"
  },
  {
    "text": "programming that we call inlining and this is a very fine optimization in some cases but",
    "start": "1016320",
    "end": "1022160"
  },
  {
    "text": "there are other cases like that where this is not a desirable behavior to work around that",
    "start": "1022160",
    "end": "1030000"
  },
  {
    "text": "we need to introduce a way to schedule our continuation on another thread",
    "start": "1030000",
    "end": "1035760"
  },
  {
    "text": "but depending on the application they may have a different requirements for uh scheduling so we're going to",
    "start": "1035760",
    "end": "1042640"
  },
  {
    "text": "introduce an api for that so i go back to my implementation and",
    "start": "1042640",
    "end": "1048240"
  },
  {
    "text": "i'm going to introduce this api that we are going to call future scheduler",
    "start": "1048240",
    "end": "1055200"
  },
  {
    "text": "and uh the idea is that we will introduce a single method that is q future and whenever you",
    "start": "1055520",
    "end": "1062000"
  },
  {
    "text": "implement your own scheduler you override this method and you get called back whenever there",
    "start": "1062000",
    "end": "1067360"
  },
  {
    "text": "is a future to schedule and then it's up to you to pick when and on what thread this future should",
    "start": "1067360",
    "end": "1073280"
  },
  {
    "text": "execute so we are going to implement a scheduler ourselves so this is a thread pull",
    "start": "1073280",
    "end": "1080960"
  },
  {
    "text": "feature scheduler so we're going to schedule the future on the thread pool we override the q",
    "start": "1080960",
    "end": "1087039"
  },
  {
    "text": "future and here we're just going to schedule it on the thread",
    "start": "1087039",
    "end": "1094799"
  },
  {
    "text": "and you may be thinking that it is going to work but um let's imagine that i'm here",
    "start": "1094799",
    "end": "1101200"
  },
  {
    "text": "i'm inside of my future library so i have access to all the internals but if i'm in my application so in a",
    "start": "1101200",
    "end": "1107360"
  },
  {
    "text": "different assembly and i try to do the same thing then i'm going to have a compilation",
    "start": "1107360",
    "end": "1112559"
  },
  {
    "text": "error here because invoke is internal and we don't want to make invoke public",
    "start": "1112559",
    "end": "1119039"
  },
  {
    "text": "because there are situations where we shouldn't call invoke so we want to present that ideally we",
    "start": "1119039",
    "end": "1126000"
  },
  {
    "text": "would need a way for the user to execute the future that was given to him through the q future method but only",
    "start": "1126000",
    "end": "1133520"
  },
  {
    "text": "this one and the way they fix that in the dotted framework is by introducing a protecting method",
    "start": "1133520",
    "end": "1140559"
  },
  {
    "text": "that we're going to call execute feature which takes the future and here we're going to make some sanity",
    "start": "1140559",
    "end": "1146880"
  },
  {
    "text": "check to make sure that this feature is the same as this one and then we call invoke safely",
    "start": "1146880",
    "end": "1153760"
  },
  {
    "text": "sorry it should be on the base base scheduler there we go and so when we implement our",
    "start": "1153760",
    "end": "1159840"
  },
  {
    "text": "own scheduler instead of invert we should do execute feature",
    "start": "1159840",
    "end": "1165440"
  },
  {
    "text": "and this should work as expected so we still need to wire everything up",
    "start": "1165440",
    "end": "1173120"
  },
  {
    "text": "whenever we do continue with we enqueue the future but now we will now accept a feature",
    "start": "1173120",
    "end": "1180160"
  },
  {
    "text": "scheduler scheduler",
    "start": "1180160",
    "end": "1184880"
  },
  {
    "text": "and the idea that we enqueue the future but we should also enter the scheduler and one way to",
    "start": "1186000",
    "end": "1192880"
  },
  {
    "text": "do that is to add the notion of scheduler to our future continuation",
    "start": "1192880",
    "end": "1198400"
  },
  {
    "text": "and in fact it's even easier for many reasons to add the notion of future",
    "start": "1198400",
    "end": "1204320"
  },
  {
    "text": "directly to the parent future that's what they did in the data framework the notion of scheduler is",
    "start": "1204320",
    "end": "1209760"
  },
  {
    "text": "backed directly into the task so i'm going to add to our internal",
    "start": "1209760",
    "end": "1216000"
  },
  {
    "text": "constructor the scheduler i'm going to store it in a property",
    "start": "1216000",
    "end": "1222880"
  },
  {
    "text": "and then i'm just going to update all of our constructors to make sure",
    "start": "1223039",
    "end": "1228240"
  },
  {
    "text": "we take the scheduler so i do that for future of t and i'm going to do that for future",
    "start": "1228240",
    "end": "1234640"
  },
  {
    "text": "continuation as well so here i just take the scheduler and then i call the base scheduler",
    "start": "1234640",
    "end": "1241520"
  },
  {
    "text": "and if the scheduler is null then i will give future scheduler the default so i'm going to add that in a second",
    "start": "1241520",
    "end": "1249440"
  },
  {
    "text": "there we go and then we are going to define the notion of a default scheduler just to make",
    "start": "1249440",
    "end": "1254799"
  },
  {
    "text": "thing easier so static read only your scheduler default",
    "start": "1254799",
    "end": "1261679"
  },
  {
    "text": "and we return the thread through scheduler and now uh we should have pretty much",
    "start": "1261679",
    "end": "1270159"
  },
  {
    "text": "everything so we just need to replace the parameter in all of our continuous",
    "start": "1270159",
    "end": "1276640"
  },
  {
    "text": "call basically i take the scheduler and i give it to the future continuation",
    "start": "1276640",
    "end": "1282960"
  },
  {
    "text": "and i do that everywhere so we're just going to skip around it there we go but",
    "start": "1282960",
    "end": "1290400"
  },
  {
    "text": "i'm still not using the scheduler so uh to use it i'm going to add a helper that",
    "start": "1290400",
    "end": "1296960"
  },
  {
    "text": "i'm going to call a schedule and start and what it does is asking the scheduler to enter",
    "start": "1296960",
    "end": "1302720"
  },
  {
    "text": "the future and now every time i was using invoke i will be using schedule and start",
    "start": "1302720",
    "end": "1308320"
  },
  {
    "text": "instead so if i forgot nothing and i run my",
    "start": "1308320",
    "end": "1313520"
  },
  {
    "text": "program we see that second continuation appears immediately without waiting for the other",
    "start": "1313520",
    "end": "1319520"
  },
  {
    "text": "continuation to execute so we've solved the scheduling problem but we went from a situation where",
    "start": "1319520",
    "end": "1326400"
  },
  {
    "text": "everything was in line to a situation where nothing is in line it would be nice to have a situation in",
    "start": "1326400",
    "end": "1332480"
  },
  {
    "text": "between where we inline only when it's safe so we are going to add",
    "start": "1332480",
    "end": "1337760"
  },
  {
    "text": "uh the notion of inlining to our schedule so we will add a protected",
    "start": "1337760",
    "end": "1346400"
  },
  {
    "text": "internal virtual bull try execute feature inline that takes a",
    "start": "1346400",
    "end": "1352720"
  },
  {
    "text": "feature default implementation returns always false",
    "start": "1352720",
    "end": "1358880"
  },
  {
    "text": "and then in the threat to scheduler we're going to say okay it's fine to inline",
    "start": "1359679",
    "end": "1365840"
  },
  {
    "text": "if we are currently on the threat pool so if the current threat is a threat to thread then we execute",
    "start": "1365840",
    "end": "1372960"
  },
  {
    "text": "the future and we return true to say okay we've inlined the future",
    "start": "1372960",
    "end": "1378799"
  },
  {
    "text": "otherwise we wrote on force so the idea that you implement this you get called",
    "start": "1378799",
    "end": "1384960"
  },
  {
    "text": "whenever there is a possibility to inline your future and then you take the decision to execute it or not and it will turn",
    "start": "1384960",
    "end": "1391600"
  },
  {
    "text": "through if you did or force otherwise and then we still need to decide when it's safe",
    "start": "1391600",
    "end": "1397600"
  },
  {
    "text": "to call doing lining and we will say that it's safe whenever",
    "start": "1397600",
    "end": "1404880"
  },
  {
    "text": "we have only one continuation in our on our future so right there i'm",
    "start": "1404880",
    "end": "1410880"
  },
  {
    "text": "going to say okay if we have only one continuation then i take it i give it to the",
    "start": "1410880",
    "end": "1417200"
  },
  {
    "text": "scheduler and i ask do you want to inline this future and if the scheduler refuse then i just",
    "start": "1417200",
    "end": "1423360"
  },
  {
    "text": "schedule the the future as usual and of course you can think of many situations",
    "start": "1423360",
    "end": "1430400"
  },
  {
    "text": "where it's safe to inline the future or not and in fact you have different rules between dotted framework the plant core",
    "start": "1430400",
    "end": "1437279"
  },
  {
    "text": "and mono here we will only implement this one just to make sure that it's working i'm",
    "start": "1437279",
    "end": "1443679"
  },
  {
    "text": "going to add the dnxt message right there so in lining",
    "start": "1443679",
    "end": "1448720"
  },
  {
    "text": "and if i run my program uh we see second continuation future completed and",
    "start": "1448720",
    "end": "1454320"
  },
  {
    "text": "only there i see in lining because this is the only place in my workflow where i have only",
    "start": "1454320",
    "end": "1459679"
  },
  {
    "text": "one continuation also i forgot what to do sorry about",
    "start": "1459679",
    "end": "1465039"
  },
  {
    "text": "that right there in execute future we still need the sanity check to make sure that",
    "start": "1465039",
    "end": "1471039"
  },
  {
    "text": "this feature is the same as this one well now that we have the notion of scheduler inside of",
    "start": "1471039",
    "end": "1476640"
  },
  {
    "text": "our future we can just say okay if the scheduler of the future is dif is different from",
    "start": "1476640",
    "end": "1483200"
  },
  {
    "text": "this then it means that the user is trying to do something funky and we throw an exception okay",
    "start": "1483200",
    "end": "1490799"
  },
  {
    "text": "so at this point we have everything we need from uh the task so uh just to summarize",
    "start": "1490799",
    "end": "1498000"
  },
  {
    "text": "uh the type that we have implemented are future for task from s for task completion",
    "start": "1498000",
    "end": "1504080"
  },
  {
    "text": "source future continuation for continuation test from task and as i explained there are four",
    "start": "1504080",
    "end": "1510240"
  },
  {
    "text": "different types of continuation in the data framework and future scheduler for task scheduler",
    "start": "1510240",
    "end": "1516480"
  },
  {
    "text": "and so now uh if you need to implement your own scheduler for your.net framework application",
    "start": "1516480",
    "end": "1522320"
  },
  {
    "text": "you should be able to understand what you are expected to do instead inside of task and try execute task in",
    "start": "1522320",
    "end": "1528880"
  },
  {
    "text": "line because they work the same way as what i described okay so we can't talk about",
    "start": "1528880",
    "end": "1537679"
  },
  {
    "text": "asynchronous programming in net without mentioning async await",
    "start": "1537679",
    "end": "1542799"
  },
  {
    "text": "so i've got an api here with a few asynchronous methods some of them",
    "start": "1542799",
    "end": "1547840"
  },
  {
    "text": "are private and the idea that we wait for an asynchronous delay and",
    "start": "1547840",
    "end": "1553360"
  },
  {
    "text": "then we return a half-credit value so 1 10 100 and do something else takes an",
    "start": "1553360",
    "end": "1560720"
  },
  {
    "text": "input and double it and so in modern c-sharp you will be able to write this",
    "start": "1560720",
    "end": "1567120"
  },
  {
    "text": "basically you will be able to write your ma to mark your method as async and then use the away keyword to change",
    "start": "1567120",
    "end": "1573919"
  },
  {
    "text": "your code just like if you were writing synchronous code and then something magic happens at the",
    "start": "1573919",
    "end": "1581039"
  },
  {
    "text": "compilation and it works and we're going to re-implement that magic",
    "start": "1581039",
    "end": "1587120"
  },
  {
    "text": "so whenever you mark a method as async the compiler is going to emit what we",
    "start": "1587120",
    "end": "1592640"
  },
  {
    "text": "call a state machine so it's going to be a class that is nested inside of your parent class why is it nested",
    "start": "1592640",
    "end": "1600080"
  },
  {
    "text": "because it needs to access to the same method that your asynchronous method even if they are",
    "start": "1600080",
    "end": "1606480"
  },
  {
    "text": "private and then it will declare a few field first the state because it's a state",
    "start": "1606480",
    "end": "1612240"
  },
  {
    "text": "machine then a reference to the instance of the parent class",
    "start": "1612240",
    "end": "1617600"
  },
  {
    "text": "if the method is not static then a move next method which will",
    "start": "1617600",
    "end": "1623600"
  },
  {
    "text": "contain the core of the logic and then it needs to declare a promise so a",
    "start": "1623600",
    "end": "1630799"
  },
  {
    "text": "public promise of it here we return the future of int so we declare promise offense",
    "start": "1630799",
    "end": "1640000"
  },
  {
    "text": "and there we go and then the compiler is going to rewrite your uh collision method into this",
    "start": "1640000",
    "end": "1649039"
  },
  {
    "text": "listing sorry so first increase the state machine",
    "start": "1649360",
    "end": "1655279"
  },
  {
    "text": "then it assign the this field then it could move next and whenever",
    "start": "1655279",
    "end": "1663520"
  },
  {
    "text": "move next returns it return the feature that is stated to",
    "start": "1663520",
    "end": "1668640"
  },
  {
    "text": "the promise so it doesn't look like your original method at all and now from our code",
    "start": "1668640",
    "end": "1676320"
  },
  {
    "text": "we are not going to need this anymore uh we can call a new api dot core async we can",
    "start": "1676320",
    "end": "1683120"
  },
  {
    "text": "wait for it to complete and then we can just display the result",
    "start": "1683120",
    "end": "1689919"
  },
  {
    "text": "so if i run this right now nothing is going to happen because my state machine is empty and now we're going to implement it so",
    "start": "1689919",
    "end": "1697840"
  },
  {
    "text": "the state machine is basically a giant switch case so we switch on the state and the first",
    "start": "1697840",
    "end": "1705679"
  },
  {
    "text": "time the state is zero so we update the state so that the next time we call moon next",
    "start": "1705679",
    "end": "1712240"
  },
  {
    "text": "we will move to the next branch of the switch then we need to call uh do something",
    "start": "1712240",
    "end": "1718240"
  },
  {
    "text": "async one and await it so we are going to say okay this that do something asynchronous",
    "start": "1718240",
    "end": "1726000"
  },
  {
    "text": "which returns the future and we're going to add a field to store it",
    "start": "1726000",
    "end": "1731600"
  },
  {
    "text": "like this and then we need to wait for this feature to be completed",
    "start": "1733440",
    "end": "1739840"
  },
  {
    "text": "so we are going to call continuous and ask okay when this future completes",
    "start": "1739840",
    "end": "1745919"
  },
  {
    "text": "just call me back call back the move next method and since we've updated the state",
    "start": "1745919",
    "end": "1752559"
  },
  {
    "text": "when the future completes it will cause move next and we will move to the next branch of the switch statement",
    "start": "1752559",
    "end": "1757919"
  },
  {
    "text": "and here we can't do anything else so we're just going to return that's important it means that we will freeze the thread",
    "start": "1757919",
    "end": "1764799"
  },
  {
    "text": "so here we will return and at this point we will return the feature to the client so whenever you call an asynchronous",
    "start": "1764799",
    "end": "1771360"
  },
  {
    "text": "method is going to execute synchronously until you get the first time you await",
    "start": "1771360",
    "end": "1776480"
  },
  {
    "text": "an asynchronous operation and then is going to return to you",
    "start": "1776480",
    "end": "1781760"
  },
  {
    "text": "okay so the next time it's going to be to be case one so we update the state just like before",
    "start": "1781760",
    "end": "1788159"
  },
  {
    "text": "and so the future completed and we need to assign this feature to the i variable so we are going to add a",
    "start": "1788159",
    "end": "1795120"
  },
  {
    "text": "few fields to our state machine to keep track of the local variable",
    "start": "1795120",
    "end": "1801278"
  },
  {
    "text": "uh and i'm missing one of those there we go and i'm going to fetch the results of my",
    "start": "1801600",
    "end": "1808240"
  },
  {
    "text": "future and store it into i",
    "start": "1808240",
    "end": "1811840"
  },
  {
    "text": "like this and so now we've implemented the first line and we need to do the same thing for",
    "start": "1813279",
    "end": "1818399"
  },
  {
    "text": "every line of our asynchronous method so here i'm just going to copy paste stuff",
    "start": "1818399",
    "end": "1824799"
  },
  {
    "text": "so after that we can do something essential bitcoin continue with and we return",
    "start": "1824799",
    "end": "1831440"
  },
  {
    "text": "next case we phase the result into j we could do something sm3",
    "start": "1831440",
    "end": "1838720"
  },
  {
    "text": "next case uh we switch into k now we can do",
    "start": "1838720",
    "end": "1844960"
  },
  {
    "text": "something else async and we give all the local variables that we",
    "start": "1844960",
    "end": "1850000"
  },
  {
    "text": "stored on our state machine and the last case is a bit different because we it's the last one",
    "start": "1850000",
    "end": "1857919"
  },
  {
    "text": "and here we're going to complete the promise which will in turn transition the future to",
    "start": "1857919",
    "end": "1863120"
  },
  {
    "text": "complete it and so now if i run my program",
    "start": "1863120",
    "end": "1868240"
  },
  {
    "text": "we wait for a while and here we see the value so our method executed properly so",
    "start": "1868240",
    "end": "1876080"
  },
  {
    "text": "there is a nice optimization that we can do here uh the problem that do something essay",
    "start": "1876080",
    "end": "1882399"
  },
  {
    "text": "will sometimes execute synchronously and when that happens we still going to call continuous which may schedule us to",
    "start": "1882399",
    "end": "1889039"
  },
  {
    "text": "another thread only to be called back so it would be nice if when this",
    "start": "1889039",
    "end": "1894080"
  },
  {
    "text": "executes synchronously we just directly jump to the next state of our state machine so we're going to",
    "start": "1894080",
    "end": "1899519"
  },
  {
    "text": "do just that so i'm going to say okay this feature is completed then go to case one",
    "start": "1899519",
    "end": "1907760"
  },
  {
    "text": "and then we do that for uh for every branch",
    "start": "1907760",
    "end": "1912720"
  },
  {
    "text": "so uh to understand that because of that uh if all of our away curl sorry",
    "start": "1912880",
    "end": "1921039"
  },
  {
    "text": "complete synchronously then our async method will complete synchronously and will not return",
    "start": "1921039",
    "end": "1926640"
  },
  {
    "text": "before the end because every time we jump to the next case and we don't return okay just making sure that i",
    "start": "1926640",
    "end": "1934799"
  },
  {
    "text": "brought nothing okay so here we have a working state",
    "start": "1934799",
    "end": "1939919"
  },
  {
    "text": "machine and the one in the data framework use the same principle of course it's much more complex because",
    "start": "1939919",
    "end": "1945919"
  },
  {
    "text": "it has to deal with try catch block with if else with while loop and so on so there",
    "start": "1945919",
    "end": "1950960"
  },
  {
    "text": "are many more states and it can jump back to previous state and so on but the basic principle is the same",
    "start": "1950960",
    "end": "1959200"
  },
  {
    "text": "but right now i can only await the future because my state machine only know how",
    "start": "1959200",
    "end": "1964880"
  },
  {
    "text": "to manipulate the future it would be nice if we could just await any arbitrary type",
    "start": "1964880",
    "end": "1971360"
  },
  {
    "text": "such as task or value task or even your your own custom feature to do that we're",
    "start": "1971360",
    "end": "1978320"
  },
  {
    "text": "going to uh introduce an abstraction we're going to called subtraction io waiter",
    "start": "1978320",
    "end": "1985200"
  },
  {
    "text": "which will define what we need to avoid something and here we're going to say okay what do",
    "start": "1985200",
    "end": "1991039"
  },
  {
    "text": "i need from the future i need to know if it's completed i need to change the continuation",
    "start": "1991039",
    "end": "1997039"
  },
  {
    "text": "and i need to fetch the results so i'm going to add those three things to my abstraction so get results",
    "start": "1997039",
    "end": "2004320"
  },
  {
    "text": "is completed and uncompleted to change the continuation then i'm going to introduce future",
    "start": "2004320",
    "end": "2010720"
  },
  {
    "text": "waiter which is the implementation of io waiter for our future so all it does is take a",
    "start": "2010720",
    "end": "2018159"
  },
  {
    "text": "feature store it and then we just map every method of the api of the interface on our feature so",
    "start": "2018159",
    "end": "2025360"
  },
  {
    "text": "uncompleted is mapped on continuous and once we've done that we can say that",
    "start": "2025360",
    "end": "2031760"
  },
  {
    "text": "the convention is that whenever you await something we will call get a waiter on that something and we",
    "start": "2031760",
    "end": "2037679"
  },
  {
    "text": "expect to get an iota and then we know how to use it",
    "start": "2037679",
    "end": "2042880"
  },
  {
    "text": "so here i will replace this by a future waiter and here whenever i await something i",
    "start": "2042880",
    "end": "2048480"
  },
  {
    "text": "use get a waiter oh yeah and i also should add the getaway to method sorry i'm skipping one",
    "start": "2048480",
    "end": "2054560"
  },
  {
    "text": "step here so i add a get a waiter method to my future i write it as an extension method but it",
    "start": "2054560",
    "end": "2061280"
  },
  {
    "text": "could be a normal method it will work the same and when you call get a waiter we return the new feature waiter for the future",
    "start": "2061280",
    "end": "2068878"
  },
  {
    "text": "so now i can use get the waiter and here i'm just going to replace everything by the api",
    "start": "2068879",
    "end": "2074800"
  },
  {
    "text": "of a get a waiter so uncompleted",
    "start": "2074800",
    "end": "2079280"
  },
  {
    "text": "and results become get result so i'm just going to replace everything",
    "start": "2080240",
    "end": "2086480"
  },
  {
    "text": "i'm just going to copy paste to go faster like this so just it's the same set",
    "start": "2086480",
    "end": "2093040"
  },
  {
    "text": "machine except that i replace the car with the ioh api so making sure that i brought",
    "start": "2093040",
    "end": "2099520"
  },
  {
    "text": "nothing and it's still working and so at this point we can await any type that uh define a get a waiter",
    "start": "2099520",
    "end": "2107520"
  },
  {
    "text": "method that returns an io waiter so that's pretty nice but",
    "start": "2107520",
    "end": "2113599"
  },
  {
    "text": "we can await anything but we still have to return the future because we only know how to manipulate",
    "start": "2113599",
    "end": "2119839"
  },
  {
    "text": "these problems so just like the waiter it would be nice if we abstracted that that we can return any arbitrary kind",
    "start": "2119839",
    "end": "2128400"
  },
  {
    "text": "of future so that we can return a task value task you name it",
    "start": "2128400",
    "end": "2133920"
  },
  {
    "text": "just like before we're going to introduce a new abstraction and we are going to call that nasync",
    "start": "2133920",
    "end": "2140240"
  },
  {
    "text": "method builder and we will call ours the future builder",
    "start": "2140240",
    "end": "2145599"
  },
  {
    "text": "and then we see what do we need from the promise we need to fetch the associated feature and we need to",
    "start": "2145599",
    "end": "2152000"
  },
  {
    "text": "complete it we need only those two things so i'm going to add those two things to my",
    "start": "2152000",
    "end": "2157760"
  },
  {
    "text": "future builder so we create a promise we have a task",
    "start": "2157760",
    "end": "2162800"
  },
  {
    "text": "property which returns the future and we have set results which complete the promise okay",
    "start": "2162800",
    "end": "2168400"
  },
  {
    "text": "and i'm going to add one more thing right now is my state machine that calls",
    "start": "2168400",
    "end": "2174079"
  },
  {
    "text": "uncompleted on the operator i want to delegate that to the builder",
    "start": "2174079",
    "end": "2179440"
  },
  {
    "text": "so that it will give the builder a chance for instance to log some stuff or to save the state before yielding the",
    "start": "2179440",
    "end": "2186640"
  },
  {
    "text": "thread it's just to make the api more powerful",
    "start": "2186640",
    "end": "2191760"
  },
  {
    "text": "so i will call this method await and completed and it will take an awaiter and a",
    "start": "2191760",
    "end": "2199359"
  },
  {
    "text": "state machine and then the most basic implementation",
    "start": "2199359",
    "end": "2204720"
  },
  {
    "text": "we will just call the awaiter and ask to call back the state machine but right there we could",
    "start": "2204720",
    "end": "2210640"
  },
  {
    "text": "uh save the state or lock stuff or whatever so this is not going to compile i cannot",
    "start": "2210640",
    "end": "2216800"
  },
  {
    "text": "refer on the state machine because every asynchronous method will have a different state machine because it's",
    "start": "2216800",
    "end": "2222079"
  },
  {
    "text": "emitted at compilation time for that we're going to introduce an interface that we will call ising state",
    "start": "2222079",
    "end": "2229520"
  },
  {
    "text": "machine and it has a movement x method and so here i can expect an i asking state",
    "start": "2229520",
    "end": "2235200"
  },
  {
    "text": "machine and this should compile and here i'm just going to say that",
    "start": "2235200",
    "end": "2240560"
  },
  {
    "text": "i implement my async state machine that i have future builder instead of my",
    "start": "2240560",
    "end": "2246720"
  },
  {
    "text": "promise i will call it builder",
    "start": "2246720",
    "end": "2250320"
  },
  {
    "text": "and i just need to replace everything so here we return builder.task and uh",
    "start": "2252320",
    "end": "2259359"
  },
  {
    "text": "instead of feature that uncompleted we will be there that awaits and completed like",
    "start": "2259359",
    "end": "2265599"
  },
  {
    "text": "this and in the end we will call a builder that completes",
    "start": "2265599",
    "end": "2272000"
  },
  {
    "text": "that set result so just like before i'm going to copy paste there we go so here we call bill.search",
    "start": "2272000",
    "end": "2279520"
  },
  {
    "text": "result and now just making sure it's still working",
    "start": "2279520",
    "end": "2285520"
  },
  {
    "text": "and this is still working so right now our state machine can await any arbitrary type and return",
    "start": "2285520",
    "end": "2293280"
  },
  {
    "text": "any arbitrary type so it's pretty nice from this point we're going to optimize",
    "start": "2293280",
    "end": "2299280"
  },
  {
    "text": "some stuff and mainly i would like to reduce the number of hip allocation because uh when you allocate something on the",
    "start": "2299280",
    "end": "2306320"
  },
  {
    "text": "hip you could proceed on the gc and it can uh cause unwanted poses",
    "start": "2306320",
    "end": "2311760"
  },
  {
    "text": "in the client applications so we start by our builder and we will make it a struct to remove",
    "start": "2311760",
    "end": "2318560"
  },
  {
    "text": "one allocation you can't have initializers in the industry but in any case i don't want to",
    "start": "2318560",
    "end": "2324800"
  },
  {
    "text": "manipulate promise because it will add one heap allocation that we can remove so instead we will directly manipulate",
    "start": "2324800",
    "end": "2331680"
  },
  {
    "text": "the future and in the test property we will lazily allocate",
    "start": "2331680",
    "end": "2336880"
  },
  {
    "text": "that feature so if it's not there i create it as a librarian and so in search results i'm going since",
    "start": "2336880",
    "end": "2344240"
  },
  {
    "text": "i don't have a promise i'm going to manipulate directly the the future it's okay because it's in our",
    "start": "2344240",
    "end": "2350320"
  },
  {
    "text": "library and i use the test property so that it gets allocated lazily if it's not already allocated",
    "start": "2350320",
    "end": "2357920"
  },
  {
    "text": "and one more organization here when i call await and completed i expect an io waiter and my future",
    "start": "2357920",
    "end": "2364880"
  },
  {
    "text": "waiter is a struct which means that it's going to be boxed why because structs are value types and interfaces",
    "start": "2364880",
    "end": "2372720"
  },
  {
    "text": "are reference type they are different semantics and so for you to be able to cast your struct to an interface",
    "start": "2372720",
    "end": "2379599"
  },
  {
    "text": "the runtime is automatically going to box it which means going to make a copy of it on the hip we can",
    "start": "2379599",
    "end": "2387280"
  },
  {
    "text": "avoid that by making our meta generic so instead of expecting an io waiter",
    "start": "2387280",
    "end": "2392720"
  },
  {
    "text": "we expect a tier waiter where tier waiter is an eye waiter which looks dumb like",
    "start": "2392720",
    "end": "2398640"
  },
  {
    "text": "that but by doing so you remove the hip allocation you remove the boxing",
    "start": "2398640",
    "end": "2404400"
  },
  {
    "text": "so just making sure that it's still working still good so we're going to optimize",
    "start": "2404400",
    "end": "2410880"
  },
  {
    "text": "further uh now let's have a look of our state machine um right now it's a class it would be",
    "start": "2410880",
    "end": "2418400"
  },
  {
    "text": "nice if it was abstract so fun fact in the dotted framework if you compile in debug",
    "start": "2418400",
    "end": "2424000"
  },
  {
    "text": "mode the state machine is a class and if you compile in release it's a struct that's because it's much",
    "start": "2424000",
    "end": "2430480"
  },
  {
    "text": "easier for the debugger to keep track of it if it's a reference type and so in debug mode it's sacrificing",
    "start": "2430480",
    "end": "2436640"
  },
  {
    "text": "the optimization just to make debugging easier so i cannot have initializer but i don't",
    "start": "2436640",
    "end": "2442560"
  },
  {
    "text": "care because feature builder is a struct so i don't need to new it and that's it looks like it compiles",
    "start": "2442560",
    "end": "2452240"
  },
  {
    "text": "but if i run my code here i'm going to wait forever because it's not actually working",
    "start": "2452240",
    "end": "2457680"
  },
  {
    "text": "and so uh we're just going to add a few breakpoints to see what's happening",
    "start": "2457680",
    "end": "2463040"
  },
  {
    "text": "so one here and one in uh when we complete the builder",
    "start": "2463040",
    "end": "2468319"
  },
  {
    "text": "there if i run my program in debug mode so here we see that call async returned",
    "start": "2468319",
    "end": "2474079"
  },
  {
    "text": "and we are waiting on the future so far so good then at the other end of",
    "start": "2474079",
    "end": "2479760"
  },
  {
    "text": "the asynchronous workflow we're going to call set results on the builder which",
    "start": "2479760",
    "end": "2484800"
  },
  {
    "text": "will transition the future to completed but here if we inspect underscore future",
    "start": "2484800",
    "end": "2491040"
  },
  {
    "text": "we can see that the value is null so it's going to be lazily allocated when we call the tax property",
    "start": "2491040",
    "end": "2496880"
  },
  {
    "text": "but that's really weird because we are already waiting on the future at the other side so how can it be null well",
    "start": "2496880",
    "end": "2504079"
  },
  {
    "text": "this one is a bit hard to understand so i prepared an animation for it",
    "start": "2504079",
    "end": "2509359"
  },
  {
    "text": "and so there we are so we have a very accurate representation of the memory with the stack on the left and the hip",
    "start": "2509359",
    "end": "2515520"
  },
  {
    "text": "on the right and this is our code a bit blurry so we create the state machine the state",
    "start": "2515520",
    "end": "2521440"
  },
  {
    "text": "machine is extract so it gets allocated on the stack the future builder is a struct as well so we get",
    "start": "2521440",
    "end": "2527440"
  },
  {
    "text": "nested inside of the state machine that's how structs work in that path",
    "start": "2527440",
    "end": "2532960"
  },
  {
    "text": "then later on we call await and completed and here we're going to box our state",
    "start": "2532960",
    "end": "2538000"
  },
  {
    "text": "machine we're going to do so at two places first here because we cast it to an interface so that's what i explained for",
    "start": "2538000",
    "end": "2544400"
  },
  {
    "text": "iowa this is going to cause uh to cause boxing and",
    "start": "2544400",
    "end": "2549440"
  },
  {
    "text": "here which is less obvious why we box here because we take a delegate",
    "start": "2549440",
    "end": "2555359"
  },
  {
    "text": "to an instance method of extract the problem is that the struct leaves on the stack and the stack we get",
    "start": "2555359",
    "end": "2561440"
  },
  {
    "text": "clear when the method return but the delegates can live pretty much",
    "start": "2561440",
    "end": "2566880"
  },
  {
    "text": "forever and can be called at any point in time during the lifetime of the application so by the time my delegate is going to",
    "start": "2566880",
    "end": "2574319"
  },
  {
    "text": "be called my struct might not be on the stack anymore which will cause us to reference",
    "start": "2574319",
    "end": "2579839"
  },
  {
    "text": "invalid memory so to make this safer uh whenever you take a delegate",
    "start": "2579839",
    "end": "2585040"
  },
  {
    "text": "to an instance method of extract the runtime automatically box it",
    "start": "2585040",
    "end": "2590240"
  },
  {
    "text": "why is that a problem well when you bug something as explained the runtime is going to",
    "start": "2590240",
    "end": "2595440"
  },
  {
    "text": "allocate a chunk of memory on the hip then it's going to make a copy of the stack",
    "start": "2595440",
    "end": "2601119"
  },
  {
    "text": "to the hip and so at this point we end up with two different state machines in memory",
    "start": "2601119",
    "end": "2606960"
  },
  {
    "text": "then later on we are going to call wait which will cause a lazy allocation of a",
    "start": "2606960",
    "end": "2612079"
  },
  {
    "text": "future and this is going to be allocated on the future builder that is on the stack",
    "start": "2612079",
    "end": "2617280"
  },
  {
    "text": "so the one on the left now has a feature that has been lazily allocated and then at the other end of the",
    "start": "2617280",
    "end": "2622880"
  },
  {
    "text": "workflow we're going to call move next on the boxed state machine and later",
    "start": "2622880",
    "end": "2627920"
  },
  {
    "text": "we're going to call set result again on the box state machine which will cause the lazy allocation",
    "start": "2627920",
    "end": "2634079"
  },
  {
    "text": "of the future on the boxster machine but then we end up with two different features",
    "start": "2634079",
    "end": "2639200"
  },
  {
    "text": "and so if we complete the one on the right the one on the left still isn't completed so how can we fix that well the most",
    "start": "2639200",
    "end": "2646480"
  },
  {
    "text": "obvious fix is to get rid of the boxing and we can easily get rid of the first",
    "start": "2646480",
    "end": "2651599"
  },
  {
    "text": "box because we did that for iota we can just make our method generic the second one we can't get rid of it",
    "start": "2651599",
    "end": "2657920"
  },
  {
    "text": "it's a runtime limitation so we have to live with it instead right there we're going to force",
    "start": "2657920",
    "end": "2664240"
  },
  {
    "text": "the allocation of the future so what does it change well the idea that we force the allocation of the future",
    "start": "2664240",
    "end": "2670400"
  },
  {
    "text": "while our state machine is still on the stack so now we have a feature in our future",
    "start": "2670400",
    "end": "2675680"
  },
  {
    "text": "builder and then when we get to the next line and we box the state machine we make a",
    "start": "2675680",
    "end": "2681119"
  },
  {
    "text": "copy of it and so we make a copy of it with the future inside of it and so now if i call search result on",
    "start": "2681119",
    "end": "2687680"
  },
  {
    "text": "the right it completes the one on the left because future is a reference type and so both of them refer on the same object",
    "start": "2687680",
    "end": "2695440"
  },
  {
    "text": "please note that it can only work because future is a reference type and that's why in data framework when",
    "start": "2695440",
    "end": "2701839"
  },
  {
    "text": "you use value task which is a strict implementation of the task if you await an asynchronous",
    "start": "2701839",
    "end": "2707839"
  },
  {
    "text": "operation it will have to do a heap allocation under the hood precisely because of that problem",
    "start": "2707839",
    "end": "2715920"
  },
  {
    "text": "all right so uh we're going to implement the fix that i mentioned so i just need to go back to my builder",
    "start": "2716640",
    "end": "2722640"
  },
  {
    "text": "that is right there uh i'm going to make it generic to prevent the boxing",
    "start": "2722640",
    "end": "2728960"
  },
  {
    "text": "note that i also add the ref keyword i didn't explain that that's because now that i",
    "start": "2728960",
    "end": "2736800"
  },
  {
    "text": "expect a struct whenever you call a method and give a stroke as a parameter you make a copy of it and since we make",
    "start": "2736800",
    "end": "2743200"
  },
  {
    "text": "a copy of it we end up in exactly the same problem as we had with boxing so by using the ref keyword",
    "start": "2743200",
    "end": "2749920"
  },
  {
    "text": "i make sure that we make we don't make a copy of it so here i need to force the allocation",
    "start": "2749920",
    "end": "2755280"
  },
  {
    "text": "of the task the future sorry so i need to call the task property i cannot call an empty property like",
    "start": "2755280",
    "end": "2762240"
  },
  {
    "text": "that that's not by c-sharp so i like to use the g6 use the gckpoli",
    "start": "2762240",
    "end": "2767599"
  },
  {
    "text": "method which is an empty method just to make it valid but i could do that and that would be the exact same",
    "start": "2767599",
    "end": "2774240"
  },
  {
    "text": "thing it's just a matter of style and so if i run my program right now and",
    "start": "2774240",
    "end": "2780240"
  },
  {
    "text": "if i made no mistake hopefully oh yeah since i added the ref keyword i need to update",
    "start": "2780240",
    "end": "2785760"
  },
  {
    "text": "all the call sites to give the ref parameter so there are a few of them four of them",
    "start": "2785760",
    "end": "2793359"
  },
  {
    "text": "sorry there we go so now if i run my program and if i make no mistake",
    "start": "2793359",
    "end": "2798720"
  },
  {
    "text": "now this work and our state machine is abstract that's one last optimization i would",
    "start": "2798720",
    "end": "2804480"
  },
  {
    "text": "like to do right now every time we call await uncompleted we box the state machine",
    "start": "2804480",
    "end": "2810800"
  },
  {
    "text": "right there but every time it's going to be the same state machine so it would be nice if we boxed it only once",
    "start": "2810800",
    "end": "2816960"
  },
  {
    "text": "and then we stored the box state machine somewhere so we're going to implement that i'm going to add a field to store the",
    "start": "2816960",
    "end": "2824079"
  },
  {
    "text": "state machine like that and then here i'm going to say okay if state machine",
    "start": "2824079",
    "end": "2829599"
  },
  {
    "text": "is null then i box it",
    "start": "2829599",
    "end": "2834480"
  },
  {
    "text": "so to block it i just cast it to an interface with an equal inspector and then i store",
    "start": "2834800",
    "end": "2841520"
  },
  {
    "text": "it in my underscore state machine field and of course i call move next on the",
    "start": "2841520",
    "end": "2848880"
  },
  {
    "text": "box state machine so i thought that was working and then i added a diagnostic message",
    "start": "2848880",
    "end": "2855040"
  },
  {
    "text": "so right there i'm going to write boxing and if i run this we see that boxing is",
    "start": "2855040",
    "end": "2862480"
  },
  {
    "text": "called is displayed every time we await so our optimization is not working which is really weird because it's very",
    "start": "2862480",
    "end": "2868160"
  },
  {
    "text": "straightforward if that machine is null we assign it and so it shouldn't be null anymore",
    "start": "2868160",
    "end": "2873520"
  },
  {
    "text": "so this one took me actually an entire afternoon to understand so i have an animation for it so",
    "start": "2873520",
    "end": "2880720"
  },
  {
    "text": "we have the same representation as before with the stack and the hip and this is our code so at this point we",
    "start": "2880720",
    "end": "2886880"
  },
  {
    "text": "have the state machine on the stack and we get to this line where we're going to box the state machine",
    "start": "2886880",
    "end": "2892480"
  },
  {
    "text": "and since we box it i've already explained we make a copy of it on the heap and then we are going to",
    "start": "2892480",
    "end": "2898960"
  },
  {
    "text": "assign our underscore state machine with a pointer to the box state machine",
    "start": "2898960",
    "end": "2904319"
  },
  {
    "text": "the problem is that we assign underscore state machine to this parameter so we assign it to the",
    "start": "2904319",
    "end": "2910319"
  },
  {
    "text": "state machine that is on the stack okay and then later we call the waiter on",
    "start": "2910319",
    "end": "2916880"
  },
  {
    "text": "completed and we return so the stack get cleared move next get called at some point",
    "start": "2916880",
    "end": "2922880"
  },
  {
    "text": "on the state machine on the hip and then during the execution is going to be unboxed",
    "start": "2922880",
    "end": "2928400"
  },
  {
    "text": "and we end up with a copy of the hip on the stack and then nothing reference the state machine the box state machine anymore",
    "start": "2928400",
    "end": "2935760"
  },
  {
    "text": "and it's going to get garbage collected and we get back to the initial situation we are going to box the state machine",
    "start": "2935760",
    "end": "2942480"
  },
  {
    "text": "we are going to assign it to underscore state machine but we assign it to the one on the stack",
    "start": "2942480",
    "end": "2948240"
  },
  {
    "text": "and the problem is that we never assign it to the one on the hip so it's pretty much the same program as",
    "start": "2948240",
    "end": "2954400"
  },
  {
    "text": "we had with the future just previously and so you may think we can fix that by",
    "start": "2954400",
    "end": "2960160"
  },
  {
    "text": "uh making by boxing the state machine only after assigning the underscore state machine",
    "start": "2960160",
    "end": "2966880"
  },
  {
    "text": "field but we can't do that because to ascend assign the field sorry we need to box",
    "start": "2966880",
    "end": "2972079"
  },
  {
    "text": "the state machine first so it's a kind of chicken and egg problem to fix it we are going to use",
    "start": "2972079",
    "end": "2979280"
  },
  {
    "text": "this bit of code so let's see first we block the state machine just like before",
    "start": "2979280",
    "end": "2984400"
  },
  {
    "text": "then we assign it to underscore state machine just like before and then we call set state machine on",
    "start": "2984400",
    "end": "2990800"
  },
  {
    "text": "the block state machine and we give the block state machine as parameter so that's that looks weird so first is very",
    "start": "2990800",
    "end": "2997760"
  },
  {
    "text": "important to understand that we call set state machine on the block state machine so i call it on this one not the one on",
    "start": "2997760",
    "end": "3004800"
  },
  {
    "text": "the stack then inside of set state machine we are going to call",
    "start": "3004800",
    "end": "3010839"
  },
  {
    "text": "builder.setstatemachine since we are in the boxed state machine we will call a set state machine on the boxed",
    "start": "3010839",
    "end": "3017119"
  },
  {
    "text": "future builder and then we just assign the underscore state machine field and",
    "start": "3017119",
    "end": "3022800"
  },
  {
    "text": "so we end up with the underscore state machine field that is assigned inside of our box and our",
    "start": "3022800",
    "end": "3029280"
  },
  {
    "text": "optimizations we were from there so we're just going to implement it",
    "start": "3029280",
    "end": "3036559"
  },
  {
    "text": "real quick so the idea is that right there",
    "start": "3036559",
    "end": "3041680"
  },
  {
    "text": "i copy paste the same code as the slide and so it means that we are going to need a set stack machine method",
    "start": "3041680",
    "end": "3048960"
  },
  {
    "text": "on my builder so right there add a set state machine on my uh is",
    "start": "3048960",
    "end": "3055359"
  },
  {
    "text": "instead machine here on my interface i'm going to copy paste this like that",
    "start": "3055359",
    "end": "3063520"
  },
  {
    "text": "and now we need to implement it on the actual state machine so right there",
    "start": "3063760",
    "end": "3070720"
  },
  {
    "text": "and now if i forgot nothing if i run my code we see that boxing is displayed only",
    "start": "3071359",
    "end": "3078160"
  },
  {
    "text": "once and is still working at this point we've implemented all the features that are needed",
    "start": "3078160",
    "end": "3083760"
  },
  {
    "text": "to make i think a weight work in the dotted framework and to prove it i'm going to go back to",
    "start": "3083760",
    "end": "3090880"
  },
  {
    "text": "our future of t implementation that is right there and i'm going to add the async method",
    "start": "3090880",
    "end": "3096559"
  },
  {
    "text": "builder attribute it tells the compiler whenever i make an asynchronous method",
    "start": "3096559",
    "end": "3101920"
  },
  {
    "text": "that returns a feature use this builder okay then i going to um",
    "start": "3101920",
    "end": "3110480"
  },
  {
    "text": "add the ideatific completion interface to the io waiter this is just the io waiter of",
    "start": "3110480",
    "end": "3116880"
  },
  {
    "text": "the total framework and then i'm going to delete the iasing state machine because it already exists",
    "start": "3116880",
    "end": "3124240"
  },
  {
    "text": "in the dot framework so here now we reference the one that is in the dotted framework",
    "start": "3124240",
    "end": "3131119"
  },
  {
    "text": "and i'm going to add a few things to the builder because i took some shortcuts so first i need to add a tweet method",
    "start": "3131119",
    "end": "3137680"
  },
  {
    "text": "which create a new builder that's all it does and we are going to add a staff method",
    "start": "3137680",
    "end": "3143440"
  },
  {
    "text": "which called move next on the state machine so why because i lied to you",
    "start": "3143440",
    "end": "3150079"
  },
  {
    "text": "here uh when you use the dotted compiler what it does it doesn't call move next",
    "start": "3150079",
    "end": "3155760"
  },
  {
    "text": "on the state machine it calls start on the builder which in turn called move next on the state machine",
    "start": "3155760",
    "end": "3162559"
  },
  {
    "text": "this is to give the builder a chance to do some initialization or change the state or change the thread",
    "start": "3162559",
    "end": "3168480"
  },
  {
    "text": "and so on but right now we just call move next on the state machine and i'm going to add a set exception",
    "start": "3168480",
    "end": "3174960"
  },
  {
    "text": "method that we're not going to implement because we don't have exceptions in our future and last",
    "start": "3174960",
    "end": "3180640"
  },
  {
    "text": "but not least we're going to add a new wait and save on completed that i don't have time to explain but it",
    "start": "3180640",
    "end": "3186240"
  },
  {
    "text": "has something to do with the execution context but here i just call the traditional await and",
    "start": "3186240",
    "end": "3193280"
  },
  {
    "text": "and now complete i've done that i can delete this i can delete this and i can just",
    "start": "3193280",
    "end": "3201119"
  },
  {
    "text": "uncomment this method and it should compile and work just fine and so we see our",
    "start": "3201119",
    "end": "3207599"
  },
  {
    "text": "boxing once and we have the expected result and so we've reimplemented basically a single",
    "start": "3207599",
    "end": "3213040"
  },
  {
    "text": "weight uh in the dotted framework all right uh one last thing uh we cannot",
    "start": "3213040",
    "end": "3220400"
  },
  {
    "text": "talk about async without mentioning the circulation context and so what is the synchronization context so",
    "start": "3220400",
    "end": "3226800"
  },
  {
    "text": "if you are used to making a winform or wpf application you may already know",
    "start": "3226800",
    "end": "3233839"
  },
  {
    "text": "that you can only update ui controllers from the ui thread the circulation context is an",
    "start": "3233839",
    "end": "3239520"
  },
  {
    "text": "abstraction that allows you to send your course back to the ui thread to make your life easier basically",
    "start": "3239520",
    "end": "3246800"
  },
  {
    "text": "and so here i have a synchronization context not going to show it and instead of calling collecting like",
    "start": "3246800",
    "end": "3253280"
  },
  {
    "text": "this i'm going to call it on the synchronization context so basically i use the post method or",
    "start": "3253280",
    "end": "3258800"
  },
  {
    "text": "synchronization context and it says okay execute that call on the ui thread",
    "start": "3258800",
    "end": "3264720"
  },
  {
    "text": "and then in collision i'm going to instrument it with the display current circulation",
    "start": "3264720",
    "end": "3270319"
  },
  {
    "text": "context method which name is self-explanatory and i'm going to run the code and here",
    "start": "3270319",
    "end": "3276160"
  },
  {
    "text": "we see that the first time we are on our custom synchronization context we are in the ui",
    "start": "3276160",
    "end": "3281200"
  },
  {
    "text": "thread and then we await and then we are outside of it but because our future scheduler put us",
    "start": "3281200",
    "end": "3288000"
  },
  {
    "text": "back on the thread pool every time and so if you are writing a ui it means that right there",
    "start": "3288000",
    "end": "3294240"
  },
  {
    "text": "you can update your ui controls and there you cannot anymore even though you are",
    "start": "3294240",
    "end": "3299760"
  },
  {
    "text": "in the same method so this is very error prone and so to fix that",
    "start": "3299760",
    "end": "3304880"
  },
  {
    "text": "we would like to stay in the ui thread for the duration of the method so we're going to add this feature to",
    "start": "3304880",
    "end": "3311359"
  },
  {
    "text": "the feature waiter so in the future waiter whenever it's completed we use continuous",
    "start": "3311359",
    "end": "3318400"
  },
  {
    "text": "to call back so instead what we're going to do is first we capture the circulation context",
    "start": "3318400",
    "end": "3325599"
  },
  {
    "text": "and then in the continuous we're going to post the continuation back to the circulation",
    "start": "3325599",
    "end": "3331440"
  },
  {
    "text": "context if there was one or if there's none we just resume the execution normally",
    "start": "3331440",
    "end": "3338880"
  },
  {
    "text": "now if i run my code we see that we stay on the synchronization context for the entire while of the method",
    "start": "3338880",
    "end": "3346720"
  },
  {
    "text": "but so if you're a ui guy then you're happy but if you are writing a library then you're",
    "start": "3346720",
    "end": "3352720"
  },
  {
    "text": "not so happy because your library is going to be hosted in many different applications",
    "start": "3352720",
    "end": "3358960"
  },
  {
    "text": "and all of them might have have a different secondation context even custom one and so you don't want to",
    "start": "3358960",
    "end": "3366559"
  },
  {
    "text": "resume execution in their circulation context because it may have softer rules for threading which",
    "start": "3366559",
    "end": "3373359"
  },
  {
    "text": "could cause dead blocks in your code so basically we should add a way to opt",
    "start": "3373359",
    "end": "3379119"
  },
  {
    "text": "out from this behavior so okay we are going to update the waiter again",
    "start": "3379119",
    "end": "3384720"
  },
  {
    "text": "so i go back to the future waiter i'm going to add one parameter we're going to call it",
    "start": "3384720",
    "end": "3390720"
  },
  {
    "text": "capture context and then we're going to say okay we capture the synchronization context",
    "start": "3390720",
    "end": "3397920"
  },
  {
    "text": "only if capture context is true otherwise we don't capture it",
    "start": "3397920",
    "end": "3403440"
  },
  {
    "text": "but then we have a problem uh when we write our asynchronous method we just say we await",
    "start": "3403440",
    "end": "3409920"
  },
  {
    "text": "that and then the compiler is going to call a get a waiter on whatever this petal",
    "start": "3409920",
    "end": "3415280"
  },
  {
    "text": "written but we cannot give a parameter and so we we cannot feed the value of",
    "start": "3415280",
    "end": "3423599"
  },
  {
    "text": "capture contacts we want to our feature a waiter so the way they fix this uh until here",
    "start": "3423599",
    "end": "3430480"
  },
  {
    "text": "yeah and so here in the parameter let's get a waiter we must choose true or false but we cannot have both",
    "start": "3430480",
    "end": "3437440"
  },
  {
    "text": "so the way they fix that in the dotted framework is by introducing another type that we're",
    "start": "3437440",
    "end": "3442960"
  },
  {
    "text": "going to call configured feature awaitable and all is it is a struct that get",
    "start": "3442960",
    "end": "3448880"
  },
  {
    "text": "contains the future and a value for capture context and it exposes a parameter let's get the waiter",
    "start": "3448880",
    "end": "3455520"
  },
  {
    "text": "which return the future waiter with the value we want so how the how does that help us well",
    "start": "3455520",
    "end": "3461680"
  },
  {
    "text": "now that we have that we can add an extension method so they are here that we're going to call configure",
    "start": "3461680",
    "end": "3468000"
  },
  {
    "text": "weight and configure weight we'll take the boolean and create the configure future awaitable with the",
    "start": "3468000",
    "end": "3474559"
  },
  {
    "text": "value we want and then the state machine we call getawaiter on that type",
    "start": "3474559",
    "end": "3480160"
  },
  {
    "text": "and get the future waiter that is properly configured so this is just a workaround for the",
    "start": "3480160",
    "end": "3485839"
  },
  {
    "text": "fact that whenever you await a type you cannot give a parameter",
    "start": "3485839",
    "end": "3491040"
  },
  {
    "text": "to your awaiter so now let's say that there's a second call i do configure it",
    "start": "3491040",
    "end": "3496559"
  },
  {
    "text": "first oh sorry",
    "start": "3496559",
    "end": "3503040"
  },
  {
    "text": "so remember that configure weight does not do anything to the talk to the task all it",
    "start": "3503040",
    "end": "3509200"
  },
  {
    "text": "does is create an intermediary type that will return a properly configured",
    "start": "3509200",
    "end": "3514400"
  },
  {
    "text": "awaiter that's all it does and so if i run my program here we can",
    "start": "3514400",
    "end": "3519520"
  },
  {
    "text": "see that for the first two call we are on the segregation context so on the ui thread",
    "start": "3519520",
    "end": "3524799"
  },
  {
    "text": "and then we await we configure weight first and then we are back to the straightforward",
    "start": "3524799",
    "end": "3531040"
  },
  {
    "text": "and that's exactly how configure weight work uh in the data framework and so you see",
    "start": "3531040",
    "end": "3536640"
  },
  {
    "text": "that if you do not use a weight uh and more precisely if you do not use",
    "start": "3536640",
    "end": "3542480"
  },
  {
    "text": "the uncompleted method of your operator then configure weight will have no",
    "start": "3542480",
    "end": "3548880"
  },
  {
    "text": "effect at all on your program all right so",
    "start": "3548880",
    "end": "3554160"
  },
  {
    "text": "that's it that's a lot of content for just one hour i hope you appreciated it and maybe we",
    "start": "3554160",
    "end": "3560720"
  },
  {
    "text": "have a bit of time for questions and otherwise i will be hanging around on slack",
    "start": "3560720",
    "end": "3566559"
  },
  {
    "text": "to answer them",
    "start": "3566559",
    "end": "3570799"
  }
]