[
  {
    "text": "hello again my name is Timo dumler I'm C plus plus developer Advocate at Japan's",
    "start": "7259",
    "end": "12960"
  },
  {
    "text": "and this is the third of my three talks in a row talk Marathon at NDC Tech town",
    "start": "12960",
    "end": "18660"
  },
  {
    "text": "thank you very much for coming especially those of you who have",
    "start": "18660",
    "end": "24060"
  },
  {
    "text": "stuck around in this room really appreciate that um so this is",
    "start": "24060",
    "end": "30119"
  },
  {
    "text": "um a talk called Lambda idioms and it's about lambdas and silver spas and I'm",
    "start": "30119",
    "end": "36540"
  },
  {
    "text": "gonna try and do kind of two things here in this talk on the one hand kind of dig a little bit deeper into how lambdas",
    "start": "36540",
    "end": "42540"
  },
  {
    "text": "actually work on C plus plus and um what are some kind of the traps that you can fall into when using them",
    "start": "42540",
    "end": "49260"
  },
  {
    "text": "or things you should keep in mind or kind of maybe some surprising properties as well and then the other",
    "start": "49260",
    "end": "56340"
  },
  {
    "text": "thing that I want to do is um to talk about a few idioms or patterns that I have seen people use",
    "start": "56340",
    "end": "61739"
  },
  {
    "text": "when programming with lamb less than C plus plus that I kind of see popping up and that I think might be interesting or",
    "start": "61739",
    "end": "67740"
  },
  {
    "text": "useful um you know that you know it's probably interesting to know about",
    "start": "67740",
    "end": "73979"
  },
  {
    "text": "and I'm also going to um kind of look at how lambdas kind of evolve throughout the kind of the",
    "start": "73979",
    "end": "80100"
  },
  {
    "text": "different versions of the Superstar standard and my ambitious goal is that every one of you should learn something",
    "start": "80100",
    "end": "85320"
  },
  {
    "text": "about namdas today that you have not known before so let's see if I achieved this very",
    "start": "85320",
    "end": "91920"
  },
  {
    "text": "ambitious goal let's start um damnedest 11.",
    "start": "91920",
    "end": "98640"
  },
  {
    "text": "um here's a very simple example you have black person you have some Vector of",
    "start": "99960",
    "end": "105600"
  },
  {
    "text": "people and you want to do something with this Vector you use a stud algorithm like for example you want to sort it a",
    "start": "105600",
    "end": "112020"
  },
  {
    "text": "lot of stat algorithms you know have functions that you can pass in as parameters for example sort accepts a",
    "start": "112020",
    "end": "118920"
  },
  {
    "text": "predicate that tells it how to sort things what the comparison operator function is and so you can use the default you can",
    "start": "118920",
    "end": "125820"
  },
  {
    "text": "pass in your own in t plus 98 we had to either pass a row",
    "start": "125820",
    "end": "131099"
  },
  {
    "text": "function pointer or pass like a handwritten struct with a call Operator or there were some like ugly macro based",
    "start": "131099",
    "end": "138420"
  },
  {
    "text": "Solutions like boost Lambda if anybody remembers that um since 11 we have lambdas and this is one",
    "start": "138420",
    "end": "145680"
  },
  {
    "text": "of the many use cases for them and um I'm going to assume that you're familiar with this basic syntax I'm not going to",
    "start": "145680",
    "end": "150720"
  },
  {
    "text": "explain lambdas from scratch so I hope you're going to know what it means when you write Square back at square bracket",
    "start": "150720",
    "end": "156000"
  },
  {
    "text": "which is the Lambda introducer and then you write a Lambda expression but I want to dig a little bit deeper",
    "start": "156000",
    "end": "161940"
  },
  {
    "text": "into what actually happens under the hood so the Superstar standard this is a screenshot from the simplest standard",
    "start": "161940",
    "end": "168239"
  },
  {
    "text": "actually spells out very exactly what happens if you write a Lambda expression you write a Lambda expression it's going",
    "start": "168239",
    "end": "173819"
  },
  {
    "text": "to create under the hood a so-called closure type which is a class",
    "start": "173819",
    "end": "180180"
  },
  {
    "text": "um that has a public inline function call Operator right so if you um imagine",
    "start": "180180",
    "end": "186420"
  },
  {
    "text": "that at the top is the code you wrote and at the bottom is um some approximation of what the compiler",
    "start": "186420",
    "end": "192420"
  },
  {
    "text": "generates under the hood um then it's going to be something like this you write a Lambda expression here",
    "start": "192420",
    "end": "198840"
  },
  {
    "text": "and what you get is a closure type which is a Class Type the name of that type is something you",
    "start": "198840",
    "end": "204959"
  },
  {
    "text": "cannot name is some internal string that the compiler generates every",
    "start": "204959",
    "end": "210000"
  },
  {
    "text": "time you write a new Lambda expression and you cannot name that type I wrote underscore underscore Lambda something",
    "start": "210000",
    "end": "215400"
  },
  {
    "text": "here in practice is probably going to be something longer involving maybe the file name or something like that something unique",
    "start": "215400",
    "end": "222299"
  },
  {
    "text": "um and then it's going to create a temporary instance of that type and that's what you get and then you can",
    "start": "222299",
    "end": "228599"
  },
  {
    "text": "do with it whatever you want you can assign it to another variable or whatever a few things that are worth",
    "start": "228599",
    "end": "234299"
  },
  {
    "text": "keeping in mind this inline call Operator here oh and of course the body of the inline call Operator is going to",
    "start": "234299",
    "end": "240180"
  },
  {
    "text": "be the body of the Lambda expression that you wrote right that should be pretty obvious a few things to keep in",
    "start": "240180",
    "end": "245760"
  },
  {
    "text": "mind um this operator by default is going to be const so that's one of the cases",
    "start": "245760",
    "end": "251400"
  },
  {
    "text": "where C plus plus actually got the defaults right it's const by default",
    "start": "251400",
    "end": "256400"
  },
  {
    "text": "um if you wanted to not be conned you have to explicitly write mutable otherwise it's going to be constant by",
    "start": "256440",
    "end": "261720"
  },
  {
    "text": "default the compiler is going to deduce the return type for you automatically so in",
    "start": "261720",
    "end": "267120"
  },
  {
    "text": "this case it's going to return a bull but of course you can also overwrite that you can explicitly write the return",
    "start": "267120",
    "end": "272160"
  },
  {
    "text": "type with the trading return type it's not no except by default if you want it to be no except that function you need",
    "start": "272160",
    "end": "279000"
  },
  {
    "text": "to write that yeah that's pretty much it um this is kind of what you get you get",
    "start": "279000",
    "end": "286620"
  },
  {
    "text": "a little bit more than that in t plus 11 the standard also says that the closure type has a deleted default",
    "start": "286620",
    "end": "293220"
  },
  {
    "text": "Constructor and a deleted assignment operator so you cannot default construct them and you cannot assign them so the",
    "start": "293220",
    "end": "299040"
  },
  {
    "text": "only instance of the closure type is going to be the one instance that the compiler has generated for you as with",
    "start": "299040",
    "end": "304680"
  },
  {
    "text": "the result of you writing that Lambda expression and then the other really cool feature",
    "start": "304680",
    "end": "310199"
  },
  {
    "text": "that you get kind of out of the box is that if your Lambda has no state if you",
    "start": "310199",
    "end": "316740"
  },
  {
    "text": "don't have any capture if the square brackets at the beginning are empty it's going to generate an implicit conversion",
    "start": "316740",
    "end": "323520"
  },
  {
    "text": "operator to function pointer so lambdas without captures are implicitly convertible to function pointers which",
    "start": "323520",
    "end": "329340"
  },
  {
    "text": "is really cool if you have some kind of Legacy API typically like a C library or something which takes a pointer to a raw",
    "start": "329340",
    "end": "334800"
  },
  {
    "text": "function you can just pass in a Lambda expression as long as there's nothing in the square brackets there",
    "start": "334800",
    "end": "340440"
  },
  {
    "text": "it just works right as long as this is empty the standard again spells pretty",
    "start": "340440",
    "end": "345660"
  },
  {
    "text": "precisely what that is it's a conversion function to point at a function the type of that point that the function",
    "start": "345660",
    "end": "352199"
  },
  {
    "text": "is matching the function signature of the Lambda that you wrote and then you get this inline conversion operator here",
    "start": "352199",
    "end": "359759"
  },
  {
    "text": "so that's what the compiler also generates for you provided that you have no captures and now we already come to",
    "start": "359759",
    "end": "365820"
  },
  {
    "text": "the first Lambda idiom of the day which is the unity plus trick so as I already said you get implicit conversion to",
    "start": "365820",
    "end": "372419"
  },
  {
    "text": "function pointer here right so that works but what if we want to explicitly convert to a function pointer",
    "start": "372419",
    "end": "378660"
  },
  {
    "text": "so for example here like um it's kind of a bit of a contrived example but it's kind of I think it's kind of cool so",
    "start": "378660",
    "end": "385319"
  },
  {
    "text": "you have this variable here F pointer which is the Lambda and this is now of type Lambda something something",
    "start": "385319",
    "end": "390960"
  },
  {
    "text": "something but what if you want F Peter to actually be the function pointer like here like",
    "start": "390960",
    "end": "397080"
  },
  {
    "text": "you're starting that it's the same type as a function pointer this obviously will error out because it's not the same type",
    "start": "397080",
    "end": "403800"
  },
  {
    "text": "what if you want it to be the same type well you can statically cast that to function pointer type which is a bit",
    "start": "403800",
    "end": "409860"
  },
  {
    "text": "long but you can also just write it like that you can just put a plus in the front and",
    "start": "409860",
    "end": "415919"
  },
  {
    "text": "that's gonna do the same thing and it's kind of cool to try and understand what happens here the univ",
    "start": "415919",
    "end": "422639"
  },
  {
    "text": "plus operator is not defined for Lambda expressions but it is defined for pointers including",
    "start": "422639",
    "end": "427919"
  },
  {
    "text": "for function pointers so if you write this the compiler is going to implicitly convert",
    "start": "427919",
    "end": "433139"
  },
  {
    "text": "your Lambda to a function pointer and then it's going to apply the unity plus operator to that function pointer and",
    "start": "433139",
    "end": "438479"
  },
  {
    "text": "the unity plus operator applied to a point that does exactly nothing so what this is is just a shorthand for",
    "start": "438479",
    "end": "443940"
  },
  {
    "text": "aesthetic cast to function pointer so I think that's a pretty cool hack",
    "start": "443940",
    "end": "448979"
  },
  {
    "text": "um but let's talk about lambdas that do actually capture something because that you know comes up quite a lot",
    "start": "448979",
    "end": "454919"
  },
  {
    "text": "um again I'm not gonna explain everything to you I'm assuming that you have some basic knowledge of",
    "start": "454919",
    "end": "460380"
  },
  {
    "text": "how Lambda captures work uh you can capture stuff by value using",
    "start": "460380",
    "end": "465840"
  },
  {
    "text": "the equal sign you can capture stuff by reference you can capture things explicitly implicitly you can do some kind of mixture of captioning by value",
    "start": "465840",
    "end": "471960"
  },
  {
    "text": "and by reference um the Syntax for all of this if you capture stuff by value like here",
    "start": "471960",
    "end": "477840"
  },
  {
    "text": "um what the compiler generates for you is something like this so for every entity you're capturing by value in this",
    "start": "477840",
    "end": "483660"
  },
  {
    "text": "case it's this int I and in J it's going to generate a private um non-static class member for you the name",
    "start": "483660",
    "end": "491819"
  },
  {
    "text": "of that class number though is again something you cannot name that's why I wrote like underscore underscore either",
    "start": "491819",
    "end": "496979"
  },
  {
    "text": "you can't you can't actually write lambda.i that's not going to work you cannot name these these members but you",
    "start": "496979",
    "end": "505259"
  },
  {
    "text": "can use the you know identifier that you caught like you can use the I enter J and those names are just going to",
    "start": "505259",
    "end": "511139"
  },
  {
    "text": "automatically refer to these new private members that the compiler has generated",
    "start": "511139",
    "end": "516240"
  },
  {
    "text": "for you and it's going to initialize them automatically with whatever value those variables had at the point where",
    "start": "516240",
    "end": "522360"
  },
  {
    "text": "you wrote the Lambda expression and so uh yeah the standard kind of says",
    "start": "522360",
    "end": "527399"
  },
  {
    "text": "um what happens here um it says um that for each entity captured",
    "start": "527399",
    "end": "533220"
  },
  {
    "text": "by copy and unnamed non-static data member is declared which is what I just showed it also says that declaration",
    "start": "533220",
    "end": "538440"
  },
  {
    "text": "order of these members is undefined so you cannot rely on them being declared in the same order as the variables that you're capturing",
    "start": "538440",
    "end": "544800"
  },
  {
    "text": "if you are capturing stuff by reference um it's kind of the same thing you again",
    "start": "544800",
    "end": "550860"
  },
  {
    "text": "get something like private members of reference type that you cannot name",
    "start": "550860",
    "end": "558540"
  },
  {
    "text": "um and they're going to be initialized correctly and everything and you can just that's what you're effectively using however in this case the compiler",
    "start": "558540",
    "end": "565440"
  },
  {
    "text": "has a little bit more implementation Freedom um actually in fact the standard says if you capture stuff by reference if it's",
    "start": "565440",
    "end": "571560"
  },
  {
    "text": "unspecified whether additional unnamed non-static data members are declared and if so how many of them there are and",
    "start": "571560",
    "end": "578640"
  },
  {
    "text": "that is just to give the compiler a little bit more freedom to optimize things for example if you're capturing two variables by reference but you only",
    "start": "578640",
    "end": "585899"
  },
  {
    "text": "ever use one of them at a time the compiler can use one pointer to refer to like first one and then the other under",
    "start": "585899",
    "end": "592680"
  },
  {
    "text": "the hood instead of you know having to store two pointers so this is to allow optimizations like this so this is this",
    "start": "592680",
    "end": "600060"
  },
  {
    "text": "interesting um again reminder the inline call Operator of a closure type is const",
    "start": "600060",
    "end": "605700"
  },
  {
    "text": "by default so if you are capturing stuff by reference you can use the reference to modify the value however if you catch",
    "start": "605700",
    "end": "611820"
  },
  {
    "text": "your stuff by value you cannot mutate those variables inside the Lambda because it's const you cannot mutate a",
    "start": "611820",
    "end": "619680"
  },
  {
    "text": "member data member of a class in a const function you can also capture this",
    "start": "619680",
    "end": "626040"
  },
  {
    "text": "and then you get to just use members and member functions of that object inside the Lambda expression",
    "start": "626040",
    "end": "632420"
  },
  {
    "text": "uh what the compiler is going to do under the hood it's going to capture the this pointer again as a private member",
    "start": "632420",
    "end": "639360"
  },
  {
    "text": "and then it's going to translate um calls that mention you know members and member functions into into uh and access",
    "start": "639360",
    "end": "646260"
  },
  {
    "text": "through this this pointer that has been captured uh and actually this is kind of a little bit more complicated there's different",
    "start": "646260",
    "end": "652500"
  },
  {
    "text": "ways you can capture this by value or by pointer and like um the rules how exactly you spell that",
    "start": "652500",
    "end": "658200"
  },
  {
    "text": "have also changed throughout the Superstar standard so I'm not gonna there's a little bit of a rabbit hole I'm not going to go into capturing this",
    "start": "658200",
    "end": "664260"
  },
  {
    "text": "here um but if you need that um in you run into a problem you can look up these",
    "start": "664260",
    "end": "669779"
  },
  {
    "text": "these rules they're all on CPP reference um yeah I mentioned that this is going",
    "start": "669779",
    "end": "675300"
  },
  {
    "text": "to be translated to an access to the this pointer um there is however some other gotchas",
    "start": "675300",
    "end": "681600"
  },
  {
    "text": "with Lambda captures that I think is worth pointing out because um it's not evident and certainly for me when I",
    "start": "681600",
    "end": "687360"
  },
  {
    "text": "stumbled upon them um I was like what the hell's going on here that was not obvious to me at all",
    "start": "687360",
    "end": "692820"
  },
  {
    "text": "so I think it's worth talking about that a little bit one really important thing of Lambda captures is that you're only",
    "start": "692820",
    "end": "698459"
  },
  {
    "text": "ever capturing local variables if something is not a local variable a Lambda is not going to capture it in",
    "start": "698459",
    "end": "705420"
  },
  {
    "text": "particular if you have a static variable static object like here Statics objects are not local objects even if they're",
    "start": "705420",
    "end": "712079"
  },
  {
    "text": "only visible locally they have static storage duration so don't actually local so you're not capturing them",
    "start": "712079",
    "end": "718500"
  },
  {
    "text": "so here you have a static end and then uh you know maybe you think you're capturing it by value but it's not a",
    "start": "718500",
    "end": "724680"
  },
  {
    "text": "local variable so you're not capturing it by value so if you actually um increment that integer you're",
    "start": "724680",
    "end": "730500"
  },
  {
    "text": "actually incrementing the in I on the outside and you're modifying that inside the Lambda and if and this this function is",
    "start": "730500",
    "end": "736620"
  },
  {
    "text": "going to return 43. okay and in fact you don't you're not",
    "start": "736620",
    "end": "741779"
  },
  {
    "text": "catching anything so you can actually leave that empty and it's still going to work and do exactly the same thing because it's not a local variable you're",
    "start": "741779",
    "end": "747899"
  },
  {
    "text": "not capturing it you're just accessing it because it's just there right it's the same with global variables which I",
    "start": "747899",
    "end": "754079"
  },
  {
    "text": "hope you have not that many off in your code exactly the same thing you're not capturing Global variables that's not a",
    "start": "754079",
    "end": "759540"
  },
  {
    "text": "thing you just use them so again this Lambda will modify the outside I",
    "start": "759540",
    "end": "765420"
  },
  {
    "text": "uh it's a little bit more tricky than that actually because um not only do you not capture",
    "start": "765420",
    "end": "771779"
  },
  {
    "text": "um local variables but also lambdas only capture things that are odr used inside",
    "start": "771779",
    "end": "777420"
  },
  {
    "text": "the Lambda and here's an interesting example if you have a const expert variable",
    "start": "777420",
    "end": "784320"
  },
  {
    "text": "it means that it's a variable of which the value is known at compile time okay and using that value is not an odr use",
    "start": "784320",
    "end": "792600"
  },
  {
    "text": "of that variable because it's just a constant at compile time so um using the value of a const x per",
    "start": "792600",
    "end": "798839"
  },
  {
    "text": "object is not an ODI use of",
    "start": "798839",
    "end": "804120"
  },
  {
    "text": "the variable and therefore you don't have to capture it so this code",
    "start": "804180",
    "end": "810300"
  },
  {
    "text": "is going to compile even though those brackets are empty you can still use the I inside because you're not odr using it",
    "start": "810300",
    "end": "816000"
  },
  {
    "text": "so you don't have to capture it however if you take the address of that variable that is an ODI use so that is",
    "start": "816000",
    "end": "823200"
  },
  {
    "text": "not going to compile because you're not capturing it and now you have to write the capture here and that that works",
    "start": "823200",
    "end": "829079"
  },
  {
    "text": "it gets even more tricky than that because const variables of integer type",
    "start": "829079",
    "end": "834480"
  },
  {
    "text": "are implicitly const expert so if you have a constant and you didn't write context for it's still constant",
    "start": "834480",
    "end": "840360"
  },
  {
    "text": "expert and you still are not capturing it so this code will work however if you make that a float",
    "start": "840360",
    "end": "846600"
  },
  {
    "text": "floating Point types are not integer types so they're not implicitly constant expert and so that is not going to",
    "start": "846600",
    "end": "853740"
  },
  {
    "text": "compile okay so that's uh worth keeping in mind",
    "start": "853740",
    "end": "859740"
  },
  {
    "text": "right enough about captchas we come to our second Lambda idiom which I think is",
    "start": "859740",
    "end": "865019"
  },
  {
    "text": "the most important I'm going to talk about the most widespread I think the one that I have already seen being used",
    "start": "865019",
    "end": "871579"
  },
  {
    "text": "quite a lot like several years ago um I think it's a pretty established",
    "start": "871579",
    "end": "876660"
  },
  {
    "text": "idiom so probably many of you have already seen this but I think it's so important that you know we should really talk about this because I think every",
    "start": "876660",
    "end": "883019"
  },
  {
    "text": "superstar developer should be where aware of those immediately invoked function expressions or some people also",
    "start": "883019",
    "end": "888720"
  },
  {
    "text": "call them immediately invoked lambdas what's that now we kind of know what the",
    "start": "888720",
    "end": "893820"
  },
  {
    "text": "compiler generates under the hood if you write a Lambda expression it's generating you this closure type and",
    "start": "893820",
    "end": "900060"
  },
  {
    "text": "it's going to create a temporary instance of that type right and so you can assign that to a variable which is",
    "start": "900060",
    "end": "905160"
  },
  {
    "text": "what we have been doing before but you can also just call it right there right you don't have to assign it to a",
    "start": "905160",
    "end": "910920"
  },
  {
    "text": "variable you can just take this temporary object of closure type and you can just immediately call it and then",
    "start": "910920",
    "end": "917040"
  },
  {
    "text": "that's it and then it's just because of the temporary it's just going to make poop and go out of scope and that's it",
    "start": "917040",
    "end": "923040"
  },
  {
    "text": "and that's totally fine so what's happening here is you basically just print hello world because that's just a",
    "start": "923040",
    "end": "928440"
  },
  {
    "text": "weird way of writing let's see how hello world right you might think this is maybe not that",
    "start": "928440",
    "end": "934139"
  },
  {
    "text": "useful but actually it's super useful um and uh here's um one case where it's",
    "start": "934139",
    "end": "939240"
  },
  {
    "text": "super useful initializing objects imagine you have an object and you want to initialize it and has some kind of",
    "start": "939240",
    "end": "945420"
  },
  {
    "text": "complex initialization code it's not just you assign a value to it but you need to write some code in order to",
    "start": "945420",
    "end": "950820"
  },
  {
    "text": "initialize it with the value right you have some condition in there maybe there's a little bit more going on",
    "start": "950820",
    "end": "956220"
  },
  {
    "text": "and so um the way you know a lot of people are writing this is you first declare the object and then you",
    "start": "956220",
    "end": "962339"
  },
  {
    "text": "kind of figure out what the value is and you assign the value to that object which isn't great because",
    "start": "962339",
    "end": "967980"
  },
  {
    "text": "um if you declare it you're not initializing it so potentially there's some uninitialized values there like if",
    "start": "967980",
    "end": "973079"
  },
  {
    "text": "in between you access it s undefined Behavior you kind of have this two-step initialization it's it's",
    "start": "973079",
    "end": "980579"
  },
  {
    "text": "not great it's it's it's not a good way to to write this and it might not even compile if Foo",
    "start": "980579",
    "end": "987899"
  },
  {
    "text": "doesn't have a default Constructor then it's just not going to work and it's also not going to work if who is const",
    "start": "987899",
    "end": "993600"
  },
  {
    "text": "then you cannot assign to a constant object now you can do this in Java in Java instead of Conte has the final",
    "start": "993600",
    "end": "999660"
  },
  {
    "text": "keyword which basically just means you can assign to this object exactly once so in Java this would work but in C plus",
    "start": "999660",
    "end": "1005899"
  },
  {
    "text": "it means you can only assign it at the point where you declare it and so this two-step initialization is",
    "start": "1005899",
    "end": "1012560"
  },
  {
    "text": "not going to work for a const object how can we work around this well we can maybe if it's something relatively",
    "start": "1012560",
    "end": "1018740"
  },
  {
    "text": "simple like here we can write a ternary expression that's going to work in this case but if you have something more complicated the Turning expression is",
    "start": "1018740",
    "end": "1025339"
  },
  {
    "text": "going to get really really ugly really quickly um what else can we do we can Factor the",
    "start": "1025339",
    "end": "1030860"
  },
  {
    "text": "initialization out into a separate function and then you can assign the return value of that function this is going to work",
    "start": "1030860",
    "end": "1037100"
  },
  {
    "text": "but now you're kind of separating your logic right you have your code spread over different parts",
    "start": "1037100",
    "end": "1042438"
  },
  {
    "text": "in your file or maybe even multiple files so it becomes kind of more difficult to reason about also if the",
    "start": "1042439",
    "end": "1048260"
  },
  {
    "text": "installation depends on some local variable now you have to pass that variable as an argument to that function",
    "start": "1048260",
    "end": "1054080"
  },
  {
    "text": "so it'd be all everything becomes more complicated it's just not not good and um immediately invoke lambdas solve",
    "start": "1054080",
    "end": "1061340"
  },
  {
    "text": "this problem because what you can do is you can declare the object and then write a Lambda expression that's going",
    "start": "1061340",
    "end": "1067100"
  },
  {
    "text": "to return the value that you want to assign to and then you can immediately invoke that Lambda which is the parent",
    "start": "1067100",
    "end": "1073340"
  },
  {
    "text": "paren at the end that's going to return that variant you're going to immediately assign it to the object and now you can make it const and it works",
    "start": "1073340",
    "end": "1080600"
  },
  {
    "text": "so this is the idiom I think it's really really cool um and it not only works for this kind of",
    "start": "1080600",
    "end": "1087260"
  },
  {
    "text": "simple initialization it also works for you know perfect forwarding stuff like and place back into a vector or like",
    "start": "1087260",
    "end": "1093620"
  },
  {
    "text": "makeshare and make unique whatever you can just stick a Lambda in there and immediately invoke it now some people say um it's not very",
    "start": "1093620",
    "end": "1101059"
  },
  {
    "text": "readable because it's very easy to overlook these parents at the end and like it might look like you're passing",
    "start": "1101059",
    "end": "1107000"
  },
  {
    "text": "the Lambda as a parameter whereas actually you're evaluating the Lambda in there and then you're passing the return value right so it's easy to overlook and",
    "start": "1107000",
    "end": "1114740"
  },
  {
    "text": "so one way we can mitigate this is instead of writing program at the end is we can write stood invoke at the",
    "start": "1114740",
    "end": "1120140"
  },
  {
    "text": "beginning which is a library function which literally just takes a function and calls it that's all it does",
    "start": "1120140",
    "end": "1126980"
  },
  {
    "text": "but um it's kind of spelled out you know in the beginning rather than in the end so it's like a little bit more visible",
    "start": "1126980",
    "end": "1132559"
  },
  {
    "text": "that yes I'm calling it here right so it's a matter of code style you don't have to do this maybe",
    "start": "1132559",
    "end": "1138980"
  },
  {
    "text": "maybe it's useful sometimes to make it a bit more obvious what's what's going on here",
    "start": "1138980",
    "end": "1144080"
  },
  {
    "text": "um so there's actually another idiom which kind of uses these immediately invoked",
    "start": "1144080",
    "end": "1149360"
  },
  {
    "text": "Lambda so this is just another uh kind of example of the cool stuff that you can do with immediately invoke",
    "start": "1149360",
    "end": "1155539"
  },
  {
    "text": "lambdas this one I've learned from Daisy uh Holman in her fantastic talk what you can learn from being too cute from last",
    "start": "1155539",
    "end": "1161840"
  },
  {
    "text": "year's cppcon and what we're trying to do here is we're trying to write some code that",
    "start": "1161840",
    "end": "1168740"
  },
  {
    "text": "will be executed exactly once so this is actually quite useful imagine you have some kind of struct and you",
    "start": "1168740",
    "end": "1175640"
  },
  {
    "text": "have a Constructor and then there's some code here and you want to only call this once um this is actually this actually comes",
    "start": "1175640",
    "end": "1181580"
  },
  {
    "text": "up um I have a library where um I basically need to check I have like a",
    "start": "1181580",
    "end": "1186679"
  },
  {
    "text": "thingy and I need to check whether the CPU I'm running this on supports a particular CPU instruction people have",
    "start": "1186679",
    "end": "1193039"
  },
  {
    "text": "been to the atomic SharePoint at torque a couple of hours ago probably know what this is about so you need to check there's a way to work around this issue",
    "start": "1193039",
    "end": "1200419"
  },
  {
    "text": "that I was talking about by actually checking at runtime on Linux you know does the CPU support a",
    "start": "1200419",
    "end": "1206600"
  },
  {
    "text": "double with compare and swap instruction and so um you need to do that runtime check but you only need to do it once",
    "start": "1206600",
    "end": "1212840"
  },
  {
    "text": "the first time you use the thingy and you don't have to ever do this again so you don't want to do it in every call",
    "start": "1212840",
    "end": "1218120"
  },
  {
    "text": "of the Constructor you don't want to do it all over again every time you construct an X you just want to do it exactly once",
    "start": "1218120",
    "end": "1223940"
  },
  {
    "text": "so if we create I don't know three of these you still want this cold ones to be printed only",
    "start": "1223940",
    "end": "1229760"
  },
  {
    "text": "once how can we achieve this we can wrap this into a Lambda because",
    "start": "1229760",
    "end": "1236059"
  },
  {
    "text": "Lambda solve everything then uh we need to return some value",
    "start": "1236059",
    "end": "1241160"
  },
  {
    "text": "from this Lambda it doesn't really matter what we return we just need to return something and then we can immediately invoke that",
    "start": "1241160",
    "end": "1247100"
  },
  {
    "text": "Lambda and you know return that value which means this code is going to be",
    "start": "1247100",
    "end": "1252620"
  },
  {
    "text": "evaluated and then we can assign it to a static local object right",
    "start": "1252620",
    "end": "1259640"
  },
  {
    "text": "and that's going to do the trick here um people who have read Scott Mayas I",
    "start": "1259640",
    "end": "1265220"
  },
  {
    "text": "know about the Maya Singleton probably know what's going on here if you have a static object",
    "start": "1265220",
    "end": "1272240"
  },
  {
    "text": "there's a guarantee in a standard that static objects are going to be initialized only once",
    "start": "1272240",
    "end": "1278059"
  },
  {
    "text": "right so this Lambda is going to be evaluated exactly once whenever the",
    "start": "1278059",
    "end": "1283820"
  },
  {
    "text": "first time is that you call one of those Constructors and not only is it guaranteed to be",
    "start": "1283820",
    "end": "1289159"
  },
  {
    "text": "called exactly once but on static initialization of static objects and standard C plus plus have",
    "start": "1289159",
    "end": "1295520"
  },
  {
    "text": "another property since C plus 11 I should say um is that it's also threat safe like",
    "start": "1295520",
    "end": "1301400"
  },
  {
    "text": "it's guaranteed that installation will happen only once on exactly one thread and there's not going to be a race",
    "start": "1301400",
    "end": "1307039"
  },
  {
    "text": "condition so the compiler is going to insert mutexes in there as needed to make sure that this is the case you",
    "start": "1307039",
    "end": "1312200"
  },
  {
    "text": "don't have to worry about this so actually we can you can create these instances of X on multiple threads at",
    "start": "1312200",
    "end": "1317539"
  },
  {
    "text": "the same time even and you still get the guarantee that this code is exactly going to be executed once and there's not going to",
    "start": "1317539",
    "end": "1323539"
  },
  {
    "text": "be a race condition so I think that's that's really cool kind of creative way to use lambdas in",
    "start": "1323539",
    "end": "1329960"
  },
  {
    "text": "fact there is a function in the standard Library called stit call wants which is doing exactly this however Daisy found",
    "start": "1329960",
    "end": "1336380"
  },
  {
    "text": "in her code that if you just do it by hand like this it's going to be a lot faster than stood call ones which for",
    "start": "1336380",
    "end": "1341900"
  },
  {
    "text": "some reason is not performing very well at least on some standard Library implementations",
    "start": "1341900",
    "end": "1347360"
  },
  {
    "text": "I don't know why maybe they're gonna fix that but I think this is a really cool uh trick all right we're done with t",
    "start": "1347360",
    "end": "1353780"
  },
  {
    "text": "plus 11 let's move on to C plus 14. IN Zip 14 uh we got a really big feature",
    "start": "1353780",
    "end": "1360559"
  },
  {
    "text": "which is generic lambdas so now if you write a Lambda expression",
    "start": "1360559",
    "end": "1365720"
  },
  {
    "text": "for example here instead of a vector I have a map and now again I want to do some stud algorithm and pass some",
    "start": "1365720",
    "end": "1371179"
  },
  {
    "text": "predicate I don't have to like write out the parameter type of the Lambda I can just",
    "start": "1371179",
    "end": "1376820"
  },
  {
    "text": "write Auto and then the parameter type is going to be deduced automatically for me and that's really great in cases like this",
    "start": "1376820",
    "end": "1383179"
  },
  {
    "text": "where what's the element type of stood map hint it's not a pair of indented string",
    "start": "1383179",
    "end": "1390620"
  },
  {
    "text": "probably not everybody can spell out the correct element type on the first try um you don't have to you can just write",
    "start": "1390620",
    "end": "1396020"
  },
  {
    "text": "Auto and the compiler is going to use that for you what's actually happening here under the",
    "start": "1396020",
    "end": "1401419"
  },
  {
    "text": "hood um so if you write a generic Lambda expression like this one where you have",
    "start": "1401419",
    "end": "1407780"
  },
  {
    "text": "an auto parameter again on the left is your code and on the right is some approximation of what the compiler",
    "start": "1407780",
    "end": "1414140"
  },
  {
    "text": "generates under the hood and it's something like this where again you have this closure type",
    "start": "1414140",
    "end": "1419539"
  },
  {
    "text": "that's going to be generated with some kind of weird name that you cannot name and you still have the inline actually I",
    "start": "1419539",
    "end": "1425539"
  },
  {
    "text": "forgot I think I forgot the inline here um oh no it's a template so it's implicitly in mind right yeah okay so we're good",
    "start": "1425539",
    "end": "1431360"
  },
  {
    "text": "um so it's creating your inline call Operator as before but this is now a template a function template",
    "start": "1431360",
    "end": "1437600"
  },
  {
    "text": "and this is really important actually for a while I thought that the Lambda the closure type itself would be a template that's wrong the closure type",
    "start": "1437600",
    "end": "1444380"
  },
  {
    "text": "is not a template the call Operator is a function template right this is really really important",
    "start": "1444380",
    "end": "1449900"
  },
  {
    "text": "this is how what actually happens here and then uh yeah the the the",
    "start": "1449900",
    "end": "1456320"
  },
  {
    "text": "type of the argument is going to be deduced from what you actually call it with using the usual rules of function",
    "start": "1456320",
    "end": "1462919"
  },
  {
    "text": "template argument deduction that we always had in C plus plus so there's no magic going on there and then if you're",
    "start": "1462919",
    "end": "1470059"
  },
  {
    "text": "square brackets are empty if you're not capturing anything you don't have any state then you still also get this",
    "start": "1470059",
    "end": "1475340"
  },
  {
    "text": "implicit conversion to function pointer this operator you still get that as well but now that conversion operator is also",
    "start": "1475340",
    "end": "1482000"
  },
  {
    "text": "a template and that's really cool because that actually works like if you have your",
    "start": "1482000",
    "end": "1487400"
  },
  {
    "text": "legacy C API you can pass in a generic Lambda and it's still going to work it's still",
    "start": "1487400",
    "end": "1493760"
  },
  {
    "text": "going to figure out oh you're calling it with seven which is an end so we want to initialize we want to instantiate the the input version of that right so so",
    "start": "1493760",
    "end": "1501799"
  },
  {
    "text": "generic Lambda still do work with these like function pointer apis which is really cool however the plus trick does",
    "start": "1501799",
    "end": "1508039"
  },
  {
    "text": "not work anymore because if you just write plus generic Lambda compiler is not going to know what function pointer",
    "start": "1508039",
    "end": "1514159"
  },
  {
    "text": "type you want to convert it to right because the call Operator is a function",
    "start": "1514159",
    "end": "1519919"
  },
  {
    "text": "template it also works with forwarding references so here in this case this is",
    "start": "1519919",
    "end": "1525020"
  },
  {
    "text": "a forwarding reference order refref so you can use it with you know uh",
    "start": "1525020",
    "end": "1531380"
  },
  {
    "text": "in place back make shared whatever like it works you can you can forward you can forward it then to to other um",
    "start": "1531380",
    "end": "1539720"
  },
  {
    "text": "uh type that I actually realized I should probably write in place back instead of pushback that will probably be better I'm going to fix that",
    "start": "1539720",
    "end": "1547880"
  },
  {
    "text": "um yeah you can see here um this is what the compiler generates you can see here very obviously that this is a forwarding",
    "start": "1547880",
    "end": "1553940"
  },
  {
    "text": "reference now um it also supports um variatic uh templates right so you can write realic",
    "start": "1553940",
    "end": "1561260"
  },
  {
    "text": "lambdas which is really cool and you can write really cool stuff like this kind of thing makes it really easy",
    "start": "1561260",
    "end": "1567740"
  },
  {
    "text": "to take lambdas and pass them as arguments to other lambdas so you can use this like higher level function functional programming stuff if you're",
    "start": "1567740",
    "end": "1574460"
  },
  {
    "text": "into that so you can write a Lambda which is taking another Lambda as an argument and it's returning another",
    "start": "1574460",
    "end": "1580279"
  },
  {
    "text": "Lambda which calls the first Lambda twice and you know this you can do lots of",
    "start": "1580279",
    "end": "1585440"
  },
  {
    "text": "really fun stuff with this if you're into functional programming it just makes it so easy to write this",
    "start": "1585440",
    "end": "1591620"
  },
  {
    "text": "um and we come with uh to the next idiom which has to do with variable",
    "start": "1591620",
    "end": "1597919"
  },
  {
    "text": "lambdas and this is actually something that um John invented Bjorn father who is here at this conference not sure if",
    "start": "1597919",
    "end": "1603140"
  },
  {
    "text": "he's in a room yes Beyond here you are so this is something I got from Beyond",
    "start": "1603140",
    "end": "1608659"
  },
  {
    "text": "um I think he posted it on Twitter um",
    "start": "1608659",
    "end": "1614500"
  },
  {
    "text": "so remember that um the um if you write a generic Lambda",
    "start": "1614900",
    "end": "1620720"
  },
  {
    "text": "then the the template is on the call Operator it's on on the call Operator so the Lambda itself isn't the template the",
    "start": "1620720",
    "end": "1626779"
  },
  {
    "text": "call Operator is but what if we could make the Lambda itself also a template",
    "start": "1626779",
    "end": "1634760"
  },
  {
    "text": "so um this comes back to a thread on Twitter I think about two months ago",
    "start": "1634760",
    "end": "1640039"
  },
  {
    "text": "where I posted on Twitter Hey I'm preparing this talk about lambdas uh I found this cool trick what cool tricks",
    "start": "1640039",
    "end": "1646039"
  },
  {
    "text": "have you found and then beyond posted this you can make Lambda a variable template",
    "start": "1646039",
    "end": "1651919"
  },
  {
    "text": "and access the template parameter in it and wrote this little snippet of code here",
    "start": "1651919",
    "end": "1657799"
  },
  {
    "text": "I was like all right I don't understand this but this is super interesting",
    "start": "1657799",
    "end": "1663200"
  },
  {
    "text": "what's going on here and um so yeah I I kind of went ahead and",
    "start": "1663200",
    "end": "1670820"
  },
  {
    "text": "took this apart a little bit um so you have a variable template here",
    "start": "1670820",
    "end": "1676039"
  },
  {
    "text": "and you sign a generic Lambda turret and then you can call that Lambda and you can specify",
    "start": "1676039",
    "end": "1682460"
  },
  {
    "text": "the the template parameter here right the template parameter of the variable",
    "start": "1682460",
    "end": "1688360"
  },
  {
    "text": "um and what actually happened under the hood so this is again some rough approximation of what the compiler kind",
    "start": "1689120",
    "end": "1694700"
  },
  {
    "text": "of does with it and I think this is really really cool so you have two sets of template parameters here one is the",
    "start": "1694700",
    "end": "1701840"
  },
  {
    "text": "template parameter of the variable template that you wrote so that's effectively the template parameter of the Lambda itself",
    "start": "1701840",
    "end": "1707299"
  },
  {
    "text": "and that's in this case it's a cast so it's like the type you're casting to and that is going to be a template",
    "start": "1707299",
    "end": "1713960"
  },
  {
    "text": "parameter of the actual Lambda and then we have another set of template",
    "start": "1713960",
    "end": "1719000"
  },
  {
    "text": "parameters which is templates of the generic Lambda which are the template parameters of the call operator and",
    "start": "1719000",
    "end": "1724340"
  },
  {
    "text": "that's a different set of template parameters right so what you can do is we can take the template parameters and separate",
    "start": "1724340",
    "end": "1730640"
  },
  {
    "text": "them into two groups one is one that you specify when you write the Lambda and the other one is the one that's going to",
    "start": "1730640",
    "end": "1736220"
  },
  {
    "text": "be deduced uh when you call it right and we can separate those into two different things",
    "start": "1736220",
    "end": "1742220"
  },
  {
    "text": "and then I was like okay this is cool but is there actually a use case for this and then I messaged Beyond and thank you Bjorn for replying you",
    "start": "1742220",
    "end": "1749240"
  },
  {
    "text": "actually came up with a kind of a really cool example which I'm going to reproduce here",
    "start": "1749240",
    "end": "1754340"
  },
  {
    "text": "uh so this is this is what Bjorn sent me um and he actually said oh actually I I use",
    "start": "1754340",
    "end": "1759620"
  },
  {
    "text": "this once in production code I think probably it was not this code it was something else but this is the example that he came up with which I think is",
    "start": "1759620",
    "end": "1765620"
  },
  {
    "text": "cool so what's going on here uh we have a struct time which is storing a Time",
    "start": "1765620",
    "end": "1771020"
  },
  {
    "text": "Point somehow it's not really important like how like in this case it's a variant and for some reason you can",
    "start": "1771020",
    "end": "1777020"
  },
  {
    "text": "store it as milliseconds or as nanoseconds you can choose either representation it's a variant",
    "start": "1777020",
    "end": "1782539"
  },
  {
    "text": "and then it has this member function convert it takes the converter and then it converts this time point to something",
    "start": "1782539",
    "end": "1790100"
  },
  {
    "text": "else by calling State visit on it right so State visit is going to call",
    "start": "1790100",
    "end": "1795679"
  },
  {
    "text": "this converter either on the millisecond version or in the nanosecond version depending on depending on uh kind of what's",
    "start": "1795679",
    "end": "1801679"
  },
  {
    "text": "applicable here and that actually doesn't compile so",
    "start": "1801679",
    "end": "1806840"
  },
  {
    "text": "here we so what we do is okay we want to our converter is you want to convert it",
    "start": "1806840",
    "end": "1812059"
  },
  {
    "text": "to microseconds so we say okay stop Corner duration cost microseconds and we're going to pass that in as our converter and we get a",
    "start": "1812059",
    "end": "1818360"
  },
  {
    "text": "compiler error can anybody tell me why this is not going to compile",
    "start": "1818360",
    "end": "1824620"
  },
  {
    "text": "right so still chronic duration cost is a function template",
    "start": "1831500",
    "end": "1838820"
  },
  {
    "text": "and what you're trying to do is you're trying to pass it as essentially as a function pointer however you cannot have",
    "start": "1838820",
    "end": "1844640"
  },
  {
    "text": "a pointer to a function template you have to fully specify all the template parameters to turn it into a normal",
    "start": "1844640",
    "end": "1850520"
  },
  {
    "text": "function however we didn't do that here we only specified the first template argument",
    "start": "1850520",
    "end": "1855860"
  },
  {
    "text": "Chrono duration cost actually has three template arguments if you look in the definition it has",
    "start": "1855860",
    "end": "1861320"
  },
  {
    "text": "one template parameter which is the duration you're converting to and that's typically the one that you specify by hand",
    "start": "1861320",
    "end": "1867020"
  },
  {
    "text": "and then it has two more the rep and the period which are typically just deduced automatically from the arguments so you",
    "start": "1867020",
    "end": "1873080"
  },
  {
    "text": "don't typically spell these two but they're there so if you want to pass this as a function to another function",
    "start": "1873080",
    "end": "1879080"
  },
  {
    "text": "you need to specify all of them but you can't do that because you don't know you know which wrap and period you",
    "start": "1879080",
    "end": "1885380"
  },
  {
    "text": "want to call this with right you don't know that the call side is going to do that so",
    "start": "1885380",
    "end": "1891200"
  },
  {
    "text": "so this doesn't work uh but here we can actually use the",
    "start": "1891200",
    "end": "1896659"
  },
  {
    "text": "variable Lambda pattern so we can make this a variable uh template",
    "start": "1896659",
    "end": "1902720"
  },
  {
    "text": "and you can say Okay so this first template parameter the one that you want to specify like the duration that we",
    "start": "1902720",
    "end": "1908240"
  },
  {
    "text": "want to cast it to um that's going to be the template parameter of the Lambda itself so that's",
    "start": "1908240",
    "end": "1913820"
  },
  {
    "text": "the thing we're going to write when we call it right so template tandem T and T now and this is going to be um",
    "start": "1913820",
    "end": "1919640"
  },
  {
    "text": "it's going to be this microseconds here so the microseconds here we specify those those are the template parameters",
    "start": "1919640",
    "end": "1924799"
  },
  {
    "text": "of the Lambda itself right and then the other two template parameters well those are now going to",
    "start": "1924799",
    "end": "1932000"
  },
  {
    "text": "be template parameters of the generic Lambda so those are going to be deduced from the auto D we don't write that we're going to let the cold side uh",
    "start": "1932000",
    "end": "1939679"
  },
  {
    "text": "which is going to be somewhere inside the the convert visit there it's going to be somewhere inside the wizard it's going",
    "start": "1939679",
    "end": "1946100"
  },
  {
    "text": "to actually call this function at that point it will actually deduce the the template parameters there so you can",
    "start": "1946100",
    "end": "1951860"
  },
  {
    "text": "kind of separate out the template parameters into like one group which is the one that you want to specify by hand and another group which you want to be",
    "start": "1951860",
    "end": "1959480"
  },
  {
    "text": "deduced automatically by the usual kind of generic Lambda mechanism and you can kind of separate them out like this",
    "start": "1959480",
    "end": "1966820"
  },
  {
    "text": "um so again this system parameter of the Lambda itself this is the one you write and this these two template parameters",
    "start": "1967039",
    "end": "1974600"
  },
  {
    "text": "um it's going to be deduced these two template parameters of duration costs of which they're two",
    "start": "1974600",
    "end": "1979760"
  },
  {
    "text": "they're both going to be deduced from the o2d which is our generic Lambda",
    "start": "1979760",
    "end": "1985360"
  },
  {
    "text": "right so that's the pattern I think it's cool um it's probably not very common it's probably quite rare that you",
    "start": "1985360",
    "end": "1991880"
  },
  {
    "text": "stumble upon this but if you do it might be a handy tool",
    "start": "1991880",
    "end": "1996820"
  },
  {
    "text": "um right um let's talk about another feature that we got in CBS 14 which is init capture",
    "start": "1997340",
    "end": "2002799"
  },
  {
    "text": "and It capture is really cool um it's equals 11 there was no way to capture a move only variable",
    "start": "2002799",
    "end": "2009519"
  },
  {
    "text": "like unique pointer for example in C plus 14 you can do that writing it like this this is an init",
    "start": "2009519",
    "end": "2016299"
  },
  {
    "text": "capture you kind of declare a new variable inside the capture and you assign to it and you can do a stood move in there you can use the same name as",
    "start": "2016299",
    "end": "2023559"
  },
  {
    "text": "the variable you're signing you don't have to you can also give it a different name it doesn't really matter",
    "start": "2023559",
    "end": "2028600"
  },
  {
    "text": "what happens under the hood again this is the code that compiler kind of generates under the hood it's going to",
    "start": "2028600",
    "end": "2034240"
  },
  {
    "text": "create um a private non-static data member for",
    "start": "2034240",
    "end": "2039820"
  },
  {
    "text": "your variable it's going to deduce the right type from the initializer so in this case it's a unique pointer of",
    "start": "2039820",
    "end": "2045100"
  },
  {
    "text": "widget so you get a implicit kind of hidden private member in your closure type which is a unique pointer of widget",
    "start": "2045100",
    "end": "2050858"
  },
  {
    "text": "and then it's going to be initialized appropriately with the stood move that you you wrote okay so this is this this",
    "start": "2050859",
    "end": "2057760"
  },
  {
    "text": "is what's going to happen if you write a init capture and this is pretty cool and here's another idiom which I think is one of",
    "start": "2057760",
    "end": "2064118"
  },
  {
    "text": "those really important ones that you know you really should be aware of um and this comes from a book by Bartow",
    "start": "2064119",
    "end": "2070118"
  },
  {
    "text": "May Felipe called Lambda story it's really really cool you can get that online um it goes into a lot more detail on",
    "start": "2070119",
    "end": "2076720"
  },
  {
    "text": "some of the stuff and I can do this in my talk here so very much recommend you check out this this book",
    "start": "2076720",
    "end": "2081878"
  },
  {
    "text": "so I got permission from Baltimore May to reproduce one of his code examples from the book in this talk",
    "start": "2081879",
    "end": "2090339"
  },
  {
    "text": "um and this is the code example um the details don't really matter we",
    "start": "2090339",
    "end": "2096040"
  },
  {
    "text": "have a vector of strings and then we you know do something with it we do a study",
    "start": "2096040",
    "end": "2102400"
  },
  {
    "text": "algorithm here and we do a find if and then we have the string here um some constant string",
    "start": "2102400",
    "end": "2109300"
  },
  {
    "text": "and then we capture that string by reference in our Lambda and then we do something with it in particular here we",
    "start": "2109300",
    "end": "2116079"
  },
  {
    "text": "are appending another string to it so that's going to create a new string instance this potentially memory allocation",
    "start": "2116079",
    "end": "2122380"
  },
  {
    "text": "and because we are passing this Lambda into find if it's going to call this in a loop",
    "start": "2122380",
    "end": "2127780"
  },
  {
    "text": "right so this Lambda is going to be called potentially like a thousand times and every single time it's going to make do this computation and create a new",
    "start": "2127780",
    "end": "2134680"
  },
  {
    "text": "string object and potentially allocate memory and every single time the result is going to be the same so if you're just",
    "start": "2134680",
    "end": "2140680"
  },
  {
    "text": "wasting CPU cycles and what we can do is we can take this computation and move it into the init capture",
    "start": "2140680",
    "end": "2146440"
  },
  {
    "text": "and now it's only going to happen once and your code is going to run faster",
    "start": "2146440",
    "end": "2152680"
  },
  {
    "text": "and we're creating this new variable here stir and then we can just use that thing",
    "start": "2152680",
    "end": "2158020"
  },
  {
    "text": "inside our Lambda and that's the uh kind of init capture",
    "start": "2158020",
    "end": "2163599"
  },
  {
    "text": "optimization pattern so I think that's really cool as well right let's see what's 14. let's move on",
    "start": "2163599",
    "end": "2170859"
  },
  {
    "text": "to C plus 17. uh it's 2017 we got again lots of new features",
    "start": "2170859",
    "end": "2176859"
  },
  {
    "text": "extensive 17 lambdas can be const expert that's really cool because now you can use them for compile time meta",
    "start": "2176859",
    "end": "2182740"
  },
  {
    "text": "programming you can for example take a Lambda and use the result of a Lambda as a non-type template parameter and do",
    "start": "2182740",
    "end": "2188859"
  },
  {
    "text": "things like that this is a lot of fun um you also have another feature in CBS 17 which is called class template",
    "start": "2188859",
    "end": "2195160"
  },
  {
    "text": "argument deduction or ctad one of my favorite features it's uh what it allows you to do is if you",
    "start": "2195160",
    "end": "2202780"
  },
  {
    "text": "have a class template you don't have to actually spell out the template arguments anymore you can just leave them out for example stud vector",
    "start": "2202780",
    "end": "2209200"
  },
  {
    "text": "you don't have to write the vector of int you can just write that vector and it's going to deduce the int from the",
    "start": "2209200",
    "end": "2214599"
  },
  {
    "text": "initializer so here you have an initializer list of ins and it's going to just figure out from that that it's a vector of n",
    "start": "2214599",
    "end": "2221380"
  },
  {
    "text": "now that doesn't really have anything to do with lambdas uh in itself but it allows another",
    "start": "2221380",
    "end": "2228700"
  },
  {
    "text": "really really cool pattern which which I call the Lambda overload set which um again you know has been",
    "start": "2228700",
    "end": "2236140"
  },
  {
    "text": "around for a couple years you can find it on CPP reference so I think it's very useful it's very very useful to be aware",
    "start": "2236140",
    "end": "2243040"
  },
  {
    "text": "of that the idea here is that you want to create an object which represents an overload set so you have a callable",
    "start": "2243040",
    "end": "2248680"
  },
  {
    "text": "object and it has a bunch of overloads uh like I don't know one for in and one for float and when we call that it's",
    "start": "2248680",
    "end": "2255280"
  },
  {
    "text": "going to call the correct overload under the hood and we want to pass it a bunch of lambdas and it's going to take that",
    "start": "2255280",
    "end": "2260800"
  },
  {
    "text": "dandas and put them into an overload set we can do that by inheriting from those",
    "start": "2260800",
    "end": "2267040"
  },
  {
    "text": "lambdas and using the call Operator of the Lambda inheriting from lambdas sounds weird",
    "start": "2267040",
    "end": "2272740"
  },
  {
    "text": "well Lambda is it's a closure type right we saw what type the compiler generates for you it's a class if it's a class you",
    "start": "2272740",
    "end": "2280119"
  },
  {
    "text": "can inherit from it uh of course you cannot name the type but what you can do",
    "start": "2280119",
    "end": "2286119"
  },
  {
    "text": "is you can write a variety class template which is um takes a bunch of types and just",
    "start": "2286119",
    "end": "2292839"
  },
  {
    "text": "inherits from all of them and then it's just using the call Operator of those",
    "start": "2292839",
    "end": "2299020"
  },
  {
    "text": "those types right so it has a bunch of Base classes and it's just going to inherit the call operator from all of its base classes",
    "start": "2299020",
    "end": "2307540"
  },
  {
    "text": "is that clear what's going on here okay cool and now what we can do note that this",
    "start": "2307540",
    "end": "2314079"
  },
  {
    "text": "class is an aggregate it's an aggregate class because it it has no user-defined Constructors or",
    "start": "2314079",
    "end": "2319960"
  },
  {
    "text": "anything like this it has no private members the only thing it has it's a bunch of Base classes so it's going to be in Aggregate and its",
    "start": "2319960",
    "end": "2326500"
  },
  {
    "text": "base classes are going to be its aggregate elements so therefore you can initialize it using aggregate initialization",
    "start": "2326500",
    "end": "2333059"
  },
  {
    "text": "so let's do that you can initialize an overload and I'm using the curly brackets here",
    "start": "2333339",
    "end": "2339940"
  },
  {
    "text": "and we're going to give it a bunch of lambdas and those are going to be the base classes",
    "start": "2339940",
    "end": "2344980"
  },
  {
    "text": "and in C plus 17 I have to write the deduction guide for this which since C plus 20 we don't need anymore because we",
    "start": "2344980",
    "end": "2351339"
  },
  {
    "text": "have uh automatic ctad for Aggregates and C plus 20 so this code and Z plus 20",
    "start": "2351339",
    "end": "2356800"
  },
  {
    "text": "is just going to work and once you have this F it's really cool if you call it with an INT it's",
    "start": "2356800",
    "end": "2362800"
  },
  {
    "text": "going to do the in thingy and if you call it with a float it's going to do the float thingy so it behaves like an overload set",
    "start": "2362800",
    "end": "2370079"
  },
  {
    "text": "um you obviously can also um you know give it more lambdas",
    "start": "2371440",
    "end": "2376900"
  },
  {
    "text": "you can also give it other callable objects that they don't have to be lambdas but it's just particularly cool if you use lambdas because you can write",
    "start": "2376900",
    "end": "2382480"
  },
  {
    "text": "the whole thing in one line and it's also particularly cool if you use it with Stud variant law for example",
    "start": "2382480",
    "end": "2388420"
  },
  {
    "text": "if you have a stud variant which can be either an end or a float uh you can just call State visit and",
    "start": "2388420",
    "end": "2394240"
  },
  {
    "text": "give it the F and then it's going to call the right thing depending on what type the variant currently holds right",
    "start": "2394240",
    "end": "2399460"
  },
  {
    "text": "so if the variant is a float it's going to print float thingy and if the variant happens to at this time hold",
    "start": "2399460",
    "end": "2406420"
  },
  {
    "text": "an end it's going to print the in thingy so I think that's a really really cool pattern um",
    "start": "2406420",
    "end": "2413578"
  },
  {
    "text": "okay super 17. um 20.",
    "start": "2413740",
    "end": "2419560"
  },
  {
    "text": "it's just 20 again lots of cool new stuff since C plus 20 landlas can capture",
    "start": "2419560",
    "end": "2425079"
  },
  {
    "text": "structured bindings Landers can capture parameter packs",
    "start": "2425079",
    "end": "2430240"
  },
  {
    "text": "which is pretty cool lambdas can be Constable which means if you have a const x for Lambda you can run it you",
    "start": "2430240",
    "end": "2437560"
  },
  {
    "text": "can call it a compile time if you have a constable Lambda you can only call it that compile time right it's called an",
    "start": "2437560",
    "end": "2443260"
  },
  {
    "text": "immediate function it's a function you can only call during compile time constant evaluation so if you call a",
    "start": "2443260",
    "end": "2449619"
  },
  {
    "text": "constant of our Lambda with a compile time constant like five that's okay if you call it with something runtime in",
    "start": "2449619",
    "end": "2455680"
  },
  {
    "text": "the runtime thing like a variable X it's going to give you an error no this is not a constant expression I cannot",
    "start": "2455680",
    "end": "2461140"
  },
  {
    "text": "evaluate exact compile time but this is really cool again for meta programming and then another feature we have in",
    "start": "2461140",
    "end": "2466839"
  },
  {
    "text": "tablet 20 is templated lambdas so if you have a generic Lambda uh we can now actually explicitly",
    "start": "2466839",
    "end": "2473079"
  },
  {
    "text": "specify the the type name the the template parameter",
    "start": "2473079",
    "end": "2479260"
  },
  {
    "text": "list for each generic Lambda and in this case it's maybe unnecessary but if you have something more complex maybe you",
    "start": "2479260",
    "end": "2485680"
  },
  {
    "text": "want to write a requires clause for this Lambda and you really need to be able to name this type and previously if you",
    "start": "2485680",
    "end": "2491800"
  },
  {
    "text": "write it like this it's not possible but like this you can actually name the T and you can do meta programming with it",
    "start": "2491800",
    "end": "2497619"
  },
  {
    "text": "like inside the Lambda which is kind of cool and then the other thing that we have inside C plus 20 which is really",
    "start": "2497619",
    "end": "2504220"
  },
  {
    "text": "cool is lambdas are now allowed in unevaluated context for example decal type you can write decal type Lambda",
    "start": "2504220",
    "end": "2511000"
  },
  {
    "text": "Lambda expression and if you don't have any captures if your Lambda status you can Now default construct it and assign",
    "start": "2511000",
    "end": "2517660"
  },
  {
    "text": "it and remember that was forbidden before that rule is gone if you don't have captures you can Now default construct and assign lambdas",
    "start": "2517660",
    "end": "2524320"
  },
  {
    "text": "which means you can do something that we will never be able to do before you can actually have a Lambda as a non-static",
    "start": "2524320",
    "end": "2531640"
  },
  {
    "text": "data member of a class there's no way to write this before like you could template on whatever class but you could",
    "start": "2531640",
    "end": "2538660"
  },
  {
    "text": "not make Lambda explicitly a member because you would have to write it like this Auto f equals Lambda expression but",
    "start": "2538660",
    "end": "2544660"
  },
  {
    "text": "you cannot declare a member of a class with auto that's not going to compile you can write it like this you can say",
    "start": "2544660",
    "end": "2551440"
  },
  {
    "text": "decal type of the Lambda expression and that's going to generate the closure type for you and",
    "start": "2551440",
    "end": "2556480"
  },
  {
    "text": "then you're going to say okay this is default construct one of those and that's going to be your Lambda you might think okay why would I ever",
    "start": "2556480",
    "end": "2563500"
  },
  {
    "text": "write this but actually this comes up a lot in fact it comes up every time we",
    "start": "2563500",
    "end": "2568839"
  },
  {
    "text": "have a template where it has a function it expects a function as a template",
    "start": "2568839",
    "end": "2574660"
  },
  {
    "text": "parameter and that is all over the standard library for example unique pointer the first template parameter is the",
    "start": "2574660",
    "end": "2581200"
  },
  {
    "text": "element type the second parameter is a custom deleteer and previously you had",
    "start": "2581200",
    "end": "2587500"
  },
  {
    "text": "to give the unique pointer a custom leader at runtime when you construct it now you can just put it in the template",
    "start": "2587500",
    "end": "2593319"
  },
  {
    "text": "parameter list you can just say okay this is my deleter you write a Lambda and then you say Deco type of that and",
    "start": "2593319",
    "end": "2599440"
  },
  {
    "text": "that's going to be my my custom deleted and now it's baked into the type you can make a typedef and you can just default",
    "start": "2599440",
    "end": "2605380"
  },
  {
    "text": "construct those and it's gonna they're all gonna have that deleted same with stud set the stat has a second",
    "start": "2605380",
    "end": "2611920"
  },
  {
    "text": "template parameter which is the um uh less than comparison function that's",
    "start": "2611920",
    "end": "2617740"
  },
  {
    "text": "going to use to sort the elements again you can say decal type of my Lambda and give it a custom",
    "start": "2617740",
    "end": "2624160"
  },
  {
    "text": "um comparison operator and again you don't have to do it at runtime you can just bake it into the type and just make",
    "start": "2624160",
    "end": "2629440"
  },
  {
    "text": "it make it very easy to um to use this um",
    "start": "2629440",
    "end": "2634660"
  },
  {
    "text": "actually um it's worth digging a little bit deeper into how this works because I found this to be a",
    "start": "2634660",
    "end": "2640780"
  },
  {
    "text": "little bit confusing like the the important rule to keep in mind is that every new Lambda expression generates a",
    "start": "2640780",
    "end": "2645819"
  },
  {
    "text": "new closure type there's something that confused me in the beginning and I just want to kind of",
    "start": "2645819",
    "end": "2651640"
  },
  {
    "text": "go through this because I don't want you to be confused I want you to understand what the rules are",
    "start": "2651640",
    "end": "2658140"
  },
  {
    "text": "all right let's do a little quiz we have these two variables are they going to have the same type",
    "start": "2658660",
    "end": "2664180"
  },
  {
    "text": "no we wrote two different Lambda Expressions even though they're token by token the same they're two different",
    "start": "2664180",
    "end": "2670000"
  },
  {
    "text": "Expressions you're gonna get a separate type every time so they're going to have different types",
    "start": "2670000",
    "end": "2675940"
  },
  {
    "text": "what about this we can since C plus 20 we can do this now",
    "start": "2675940",
    "end": "2681420"
  },
  {
    "text": "no is it the same type yes because he only wrote One Lambda",
    "start": "2682540",
    "end": "2689920"
  },
  {
    "text": "expression what about this is it the same type",
    "start": "2689920",
    "end": "2695380"
  },
  {
    "text": "yes because you only wrote One Lambda expression what about this",
    "start": "2695380",
    "end": "2701160"
  },
  {
    "text": "yes what about that",
    "start": "2701319",
    "end": "2706440"
  },
  {
    "text": "same type no two different types because you wrote two different Lambda Expressions different types you're good",
    "start": "2706720",
    "end": "2713740"
  },
  {
    "text": "here's a tricky one this is again a new feature we have",
    "start": "2713740",
    "end": "2719560"
  },
  {
    "text": "since I believe C plus 20. um 17 or 20 I forgot",
    "start": "2719560",
    "end": "2725380"
  },
  {
    "text": "um template Auto so this is an automatically deduced non-type template parameter and you're going to say the",
    "start": "2725380",
    "end": "2731200"
  },
  {
    "text": "default value of that is going to be a Lambda expression are these going to be the same type or",
    "start": "2731200",
    "end": "2736780"
  },
  {
    "text": "not no why not",
    "start": "2736780",
    "end": "2741838"
  },
  {
    "text": "sorry yes so the template it's going to be instantiated every time you do that",
    "start": "2742660",
    "end": "2749859"
  },
  {
    "text": "so it's going to evaluate the Lambda expression every time you do that so it's going to treat it as if it was a",
    "start": "2749859",
    "end": "2755859"
  },
  {
    "text": "new Lambda expression so it's going to generate a new type for you every time that's really cool you can use that",
    "start": "2755859",
    "end": "2763720"
  },
  {
    "text": "this is uh the next idiom the unique types generator which was invented by",
    "start": "2763720",
    "end": "2768880"
  },
  {
    "text": "Chris ushak I noticed this on Twitter I mean I don't know if he actually invented it but he posted it on Twitter",
    "start": "2768880",
    "end": "2774640"
  },
  {
    "text": "this is where I saw it first so I'm going to credit him with the invention of this pattern and yeah so you can do this weird thing",
    "start": "2774640",
    "end": "2781780"
  },
  {
    "text": "but you declare variables one after the other and it looks like they're the same type but under the hood each one of them",
    "start": "2781780",
    "end": "2787300"
  },
  {
    "text": "will have a distinct type and you don't have to actually write that so that's really cool",
    "start": "2787300",
    "end": "2793240"
  },
  {
    "text": "um actually there were a bunch of replies on the street uh Denise says oh this is so cool I also find an abuse for",
    "start": "2793240",
    "end": "2799180"
  },
  {
    "text": "it and then gospel wrote I'm gonna use that too that's amazing and I was like oh yeah this is really cool but why are",
    "start": "2799180",
    "end": "2805720"
  },
  {
    "text": "you gonna use this four like and yeah so apparently there are",
    "start": "2805720",
    "end": "2810880"
  },
  {
    "text": "actually some interesting use cases so there are uh you know cases where you do want to um generate a new type every",
    "start": "2810880",
    "end": "2817300"
  },
  {
    "text": "time um and previously they were like quite ugly techniques for this there's this underscore underscore counter macro that",
    "start": "2817300",
    "end": "2823780"
  },
  {
    "text": "you can use to like concatenate it onto the end of a type name to make it a different type name every single time",
    "start": "2823780",
    "end": "2829960"
  },
  {
    "text": "you don't have to do that anymore like this makes it a lot easier colonton says this is smart",
    "start": "2829960",
    "end": "2836500"
  },
  {
    "text": "I still don't understand and then you know quarantine gives me another example where this can be really useful",
    "start": "2836500",
    "end": "2843819"
  },
  {
    "text": "um so yeah this is this is a cool pattern um",
    "start": "2843819",
    "end": "2849579"
  },
  {
    "text": "and now we're done already with the current standard and um we're gonna jump",
    "start": "2849579",
    "end": "2855040"
  },
  {
    "text": "to C plus 23 which is the upcoming standard which is feature complete now but not released yet that's going to",
    "start": "2855040",
    "end": "2861579"
  },
  {
    "text": "happen next year but we already know that c plus 23 is going to have a cool new feature called deducing this",
    "start": "2861579",
    "end": "2869200"
  },
  {
    "text": "and if you have been to the talk that I gave an hour ago in this room you",
    "start": "2869200",
    "end": "2874660"
  },
  {
    "text": "already know what this is about if you haven't I'm going to give you a super quick intro to deducing this",
    "start": "2874660",
    "end": "2882599"
  },
  {
    "text": "so there's this thing where you can overload based on whether this like the",
    "start": "2882599",
    "end": "2888460"
  },
  {
    "text": "object itself is constant or non-const or L value or R value and you can do this by using these const and you know",
    "start": "2888460",
    "end": "2896380"
  },
  {
    "text": "ref specifiers here and sometimes you have to write all of these overloads for example here if you",
    "start": "2896380",
    "end": "2902859"
  },
  {
    "text": "if you implement optional value um you know depending on whether the",
    "start": "2902859",
    "end": "2908140"
  },
  {
    "text": "optional itself is an L value or an R value is const or non-const you need to return a different type from from this",
    "start": "2908140",
    "end": "2914020"
  },
  {
    "text": "method right um so you need to write all of these for overloads but they're doing the same",
    "start": "2914020",
    "end": "2919960"
  },
  {
    "text": "thing so you're kind of duplicating the same code all up over and over again which is really annoying and there's in C plus 20 and before not really a good",
    "start": "2919960",
    "end": "2926200"
  },
  {
    "text": "solution for this so either you can write the same code four times or you can have one member which implements the",
    "start": "2926200",
    "end": "2933880"
  },
  {
    "text": "thing and then the other three are referring to it but then because the return types and arguments don't match you have to do these ugly costs",
    "start": "2933880",
    "end": "2941619"
  },
  {
    "text": "um it's not great or you can Factor it out into a private member function",
    "start": "2941619",
    "end": "2946859"
  },
  {
    "text": "and then that's going to do the thing and then the other the four like public members need to the overloads need to",
    "start": "2947020",
    "end": "2953500"
  },
  {
    "text": "refer to that one but this is also quite verbose and in C plus 23 we don't have to do that ever again because we can",
    "start": "2953500",
    "end": "2959319"
  },
  {
    "text": "actually template on the type of this we can template on the type of the object itself that the memory function is being",
    "start": "2959319",
    "end": "2965020"
  },
  {
    "text": "called on so we can template on whether it's constant non-cons or whether it's ref or",
    "start": "2965020",
    "end": "2970060"
  },
  {
    "text": "refref and we do it with this new syntax this self ref and the self you don't",
    "start": "2970060",
    "end": "2976240"
  },
  {
    "text": "have it doesn't have to be self you can take it you can call the type name t as well but itself is just kind of",
    "start": "2976240",
    "end": "2982180"
  },
  {
    "text": "it's a good name because this is what python people do anyway",
    "start": "2982180",
    "end": "2987280"
  },
  {
    "text": "um there's also you can you can use the short syntax here if you don't need to name this type",
    "start": "2987280",
    "end": "2993220"
  },
  {
    "text": "same thing so this is the feature you can write this type name and then it's going to deduce",
    "start": "2993220",
    "end": "3000180"
  },
  {
    "text": "automatically for you the type of the object that you're calling this member function on so that's the new feature C",
    "start": "3000180",
    "end": "3006599"
  },
  {
    "text": "plus 23 and one thing that it allows you to do is it allows you to write recursive lambdas which is really really",
    "start": "3006599",
    "end": "3012060"
  },
  {
    "text": "really cool how do we write recursive lambdas in the pre-c plus 23 world",
    "start": "3012060",
    "end": "3019680"
  },
  {
    "text": "well it turns out the naive approach doesn't work",
    "start": "3019680",
    "end": "3025200"
  },
  {
    "text": "you know let's do the canonical example yes let's implement the factorial like",
    "start": "3025200",
    "end": "3030359"
  },
  {
    "text": "obviously never actually Implement factorial with the recursive function but it's just the textbook textbook example for recursion so I'm just going",
    "start": "3030359",
    "end": "3036780"
  },
  {
    "text": "to use that let's write um pictorial is a recursive Lambda okay so",
    "start": "3036780",
    "end": "3042780"
  },
  {
    "text": "Auto f equals and then we pass in an integer and we compute the factorial and we call the Lambda itself recursively",
    "start": "3042780",
    "end": "3049940"
  },
  {
    "text": "uh obviously that's not going to compile you can't do that right because you",
    "start": "3049940",
    "end": "3054960"
  },
  {
    "text": "haven't actually finished initializing the F yet so you can't refer to it inside its own initializer that's not going to come back",
    "start": "3054960",
    "end": "3061740"
  },
  {
    "text": "um we can cheat we can make it a stud function f and then we can capture that F by reference and then we can refer to",
    "start": "3061740",
    "end": "3068160"
  },
  {
    "text": "it inside the Lambda this works this compiles um however it's not great right because",
    "start": "3068160",
    "end": "3073980"
  },
  {
    "text": "third function it's type erase type it has lots of overhead that's going to be inside you have type Erasure inside so",
    "start": "3073980",
    "end": "3081000"
  },
  {
    "text": "you have like virtual functions like indirection potentially you have a memory allocation so this will runtime",
    "start": "3081000",
    "end": "3086760"
  },
  {
    "text": "overhead that you don't really need so that's not good either one thing you",
    "start": "3086760",
    "end": "3092099"
  },
  {
    "text": "can do is um you can't um basically name the Lambda itself in its",
    "start": "3092099",
    "end": "3097319"
  },
  {
    "text": "own body you can't do that but you can template on it or you know you can you can",
    "start": "3097319",
    "end": "3102839"
  },
  {
    "text": "not quite template on yeah I guess you can so what you can do is you can pass the function into itself",
    "start": "3102839",
    "end": "3109800"
  },
  {
    "text": "as a parameter and then you can template on that so you can say okay my factorial is",
    "start": "3109800",
    "end": "3117180"
  },
  {
    "text": "I'm going to pass in a function and I'm going to call that function recursively and then you just have to um basically",
    "start": "3117180",
    "end": "3123420"
  },
  {
    "text": "at the call side pass the function explicitly to itself and and that's going to work but it",
    "start": "3123420",
    "end": "3130319"
  },
  {
    "text": "looks ugly right but with reducing this instead of",
    "start": "3130319",
    "end": "3136700"
  },
  {
    "text": "passing some function you can just make the first implicit uh parameter which is this function",
    "start": "3136700",
    "end": "3143460"
  },
  {
    "text": "which is the actual Lambda itself we can make that explicit by using this new syntax this Auto itself",
    "start": "3143460",
    "end": "3148559"
  },
  {
    "text": "and now you know it's going to be the actual Lambda itself and now you can write it beautifully like this this is the straightforward",
    "start": "3148559",
    "end": "3155040"
  },
  {
    "text": "syntax you can call it the way everybody expects you to call this",
    "start": "3155040",
    "end": "3160680"
  },
  {
    "text": "so thanks to the using this we get recursive lambdas you might think okay I'm not going to",
    "start": "3160680",
    "end": "3167339"
  },
  {
    "text": "use this in practice but um I recommend you watch bandin's talk from tppcon last year where he talks",
    "start": "3167339",
    "end": "3173880"
  },
  {
    "text": "about deducing this and all the cool things you can do with it and in that talk um he actually shows kind of a really",
    "start": "3173880",
    "end": "3181200"
  },
  {
    "text": "cool use case and I want to mention this briefly here as well because it actually combines two idioms that we have talked",
    "start": "3181200",
    "end": "3186839"
  },
  {
    "text": "about it combines the Lambda overload set remember the one with overload and then the Aggregate and then you just",
    "start": "3186839",
    "end": "3192540"
  },
  {
    "text": "give it like multiple lambdas you inherit from all of them and you're going to combine that with the recursive Lambda thing that we just",
    "start": "3192540",
    "end": "3199020"
  },
  {
    "text": "saw and we got some really really cool stuff so here's Ben's example uh we have a binary tree this is again",
    "start": "3199020",
    "end": "3205380"
  },
  {
    "text": "classic textbook stuff uh we have a binary tree and we want to implement",
    "start": "3205380",
    "end": "3211260"
  },
  {
    "text": "um basically you want to count how many leaves that tree has so we do like a classic like binary tree",
    "start": "3211260",
    "end": "3217980"
  },
  {
    "text": "traversal this is like computer science 101 right but we're going to implement the tree as a stood variant of a leaf",
    "start": "3217980",
    "end": "3224760"
  },
  {
    "text": "and a note okay and now what we can do is we can do this",
    "start": "3224760",
    "end": "3232619"
  },
  {
    "text": "um Lambda overload set here which you're already familiar with and then because at the very end we can",
    "start": "3232619",
    "end": "3239760"
  },
  {
    "text": "Implement count leaves as stood visit and give it a Lambda that it's going to",
    "start": "3239760",
    "end": "3245099"
  },
  {
    "text": "apply on the variant and that Lambda actually it's not going to be a Lambda it's going to be an overload of Lambda",
    "start": "3245099",
    "end": "3250619"
  },
  {
    "text": "so we're using the overload set you're going to say okay the thing that I want you to call on",
    "start": "3250619",
    "end": "3256020"
  },
  {
    "text": "this tree is if the tree is a leaf just return one because obviously it's just one leaf but if it's a node",
    "start": "3256020",
    "end": "3263040"
  },
  {
    "text": "then recurse into the node and call the overload set on each each child node basically so",
    "start": "3263040",
    "end": "3271319"
  },
  {
    "text": "this is this is your feature vessel and I'm calling the Lambda recursively here inside",
    "start": "3271319",
    "end": "3276960"
  },
  {
    "text": "and you might think why does this work are we not just calling this thing recursively but it turns out using this",
    "start": "3276960",
    "end": "3283380"
  },
  {
    "text": "is really clever do you think this if you do that using this this parameter this const Auto self the",
    "start": "3283380",
    "end": "3289800"
  },
  {
    "text": "type of self is going to be the statically known most derived type",
    "start": "3289800",
    "end": "3294839"
  },
  {
    "text": "right it's not going to be the Lambda type of this thing it's going to be whatever the actual type of that object is which is the overload set right this",
    "start": "3294839",
    "end": "3302760"
  },
  {
    "text": "is the most derived class which is known at compile time so this visit this cell is actually",
    "start": "3302760",
    "end": "3308520"
  },
  {
    "text": "going to be the whole overload set so recalling the whole thing recursively here and that's going to do the right thing",
    "start": "3308520",
    "end": "3314400"
  },
  {
    "text": "that's going to do the three traversal here so next time you're applying for a C plus plus job and you know the",
    "start": "3314400",
    "end": "3320940"
  },
  {
    "text": "interviewer gives you one of those really boring questions like Implement a tweet binary feature reversal you can",
    "start": "3320940",
    "end": "3326940"
  },
  {
    "text": "really impress them by writing this and then you're going to get the job but um you need to make sure that you have a",
    "start": "3326940",
    "end": "3332760"
  },
  {
    "text": "cutting edge compiler um as of right now the only compiler that's already supporting using this is the Microsoft",
    "start": "3332760",
    "end": "3338339"
  },
  {
    "text": "compiler GCC and clang don't support it yet hopefully they will support it soon",
    "start": "3338339",
    "end": "3343440"
  },
  {
    "text": "and uh these are some fun C plus plus and I'm the Indians that I hope you enjoyed thank you very much",
    "start": "3343440",
    "end": "3351440"
  },
  {
    "text": "and we even have three and a half minutes left for questions",
    "start": "3357300",
    "end": "3362000"
  },
  {
    "text": "any questions all right um if there's no questions then thank",
    "start": "3364500",
    "end": "3372119"
  },
  {
    "text": "you for coming to my talk I hope you enjoyed the conference and um have a good evening and I'll speak to you",
    "start": "3372119",
    "end": "3377640"
  },
  {
    "text": "outside if you want to stick around and talk a bit more about this thank you so much",
    "start": "3377640",
    "end": "3383000"
  }
]