[
  {
    "start": "0",
    "end": "145000"
  },
  {
    "text": "okay then everybody we might as well get started um hello thank you for coming my name is Matt and today I'm gonna talk to",
    "start": "9499",
    "end": "15990"
  },
  {
    "text": "you about writing allocation free code in c-sharp this is a topic which has",
    "start": "15990",
    "end": "21750"
  },
  {
    "text": "kind of got a bit trendy lately there's a lot of thing people talking about it there's a lot of mention on it in the",
    "start": "21750",
    "end": "27020"
  },
  {
    "text": "blog post on what have your food net core and it's a good way of kind of",
    "start": "27020",
    "end": "32640"
  },
  {
    "text": "improving your performance by reducing the amount of memory that you allocate so I'm gonna have a look at a few things",
    "start": "32640",
    "end": "39360"
  },
  {
    "text": "we're gonna look at some stuff which is perhaps sort of micro optimizations and some other things which are a bit bigger a bit more interesting such as the use",
    "start": "39360",
    "end": "45660"
  },
  {
    "text": "of the new span of T type and the api's around that um but we're gonna start off",
    "start": "45660",
    "end": "51570"
  },
  {
    "text": "with a little bit of simple advice for how you can write some allocation free code in c-sharp and that is don't don't",
    "start": "51570",
    "end": "57809"
  },
  {
    "text": "do it the things I'm gonna show you today don't bother most likely you don't need to do this there's going to be some",
    "start": "57809",
    "end": "64320"
  },
  {
    "text": "low-level optimizations and micro optimizations and basically you're not going to need it unless of course you",
    "start": "64320",
    "end": "71369"
  },
  {
    "text": "actually do need to do this and I can't tell you whether or not you are going to",
    "start": "71369",
    "end": "76560"
  },
  {
    "text": "actually need this so basically if you take one thing away from this talk is this one always be measuring profile if",
    "start": "76560",
    "end": "83759"
  },
  {
    "text": "you need to do this you will know you will see in your profiling results that you need to do this you need to do",
    "start": "83759",
    "end": "89939"
  },
  {
    "text": "something about performance and there are things you can do that then to reduce performance by reducing the",
    "start": "89939",
    "end": "95340"
  },
  {
    "text": "number of allocations you've got but always please be measuring don't just do it on gut feel measure make sure you",
    "start": "95340",
    "end": "102420"
  },
  {
    "text": "know what what you're doing and why you're doing it so let's talk about why",
    "start": "102420",
    "end": "107490"
  },
  {
    "text": "why do you want to write why would you want to write allocation free code and reduce the number of allocations you've",
    "start": "107490",
    "end": "113310"
  },
  {
    "text": "got we've been using dotnet for a good while now and we understand that we've",
    "start": "113310",
    "end": "119369"
  },
  {
    "text": "got a member managed memory environment which is great it does a lot of work for us and it removes the need to sort of",
    "start": "119369",
    "end": "125939"
  },
  {
    "text": "manually handle our allocations and when we free our memory there as we've kind",
    "start": "125939",
    "end": "131370"
  },
  {
    "text": "of got into our heads really the managed memory is cheap this isn't strictly true it's more along the lines that",
    "start": "131370",
    "end": "137720"
  },
  {
    "text": "allocation is cheap so it's very easy to allocate memory but garbage collection then there's",
    "start": "137720",
    "end": "143340"
  },
  {
    "text": "expensive so garbage collection itself it stops the world it pauses everything",
    "start": "143340",
    "end": "149310"
  },
  {
    "start": "145000",
    "end": "371000"
  },
  {
    "text": "has to do a lot of work then to to clear everything up compact your memory down and the introduces pauses and so that's",
    "start": "149310",
    "end": "156360"
  },
  {
    "text": "really what this is all about here it's all about throughput and it's it's about the idea as well which you might not be",
    "start": "156360",
    "end": "162120"
  },
  {
    "text": "using a lot of memory but you might be allocating and freeing a lot of memory so your memory traffic might be very",
    "start": "162120",
    "end": "168390"
  },
  {
    "text": "high you might be using two five gigabytes of memory over time but your peak memory could sort of stay at about",
    "start": "168390",
    "end": "174270"
  },
  {
    "text": "500 megabytes and it's about trying to reduce this throughput so if you're",
    "start": "174270",
    "end": "179850"
  },
  {
    "text": "talking about throughput the idea is that there the more allocations mean that you have more garbage collections more garbage collections mean more",
    "start": "179850",
    "end": "186269"
  },
  {
    "text": "pauses and pauses then disrupt the throughput and if we try and improve our throughput then this gives us a smoother",
    "start": "186269",
    "end": "194640"
  },
  {
    "text": "experience not necessarily faster but it usually does equate equate to the two but we are smoother we're having less",
    "start": "194640",
    "end": "200550"
  },
  {
    "text": "pauses less interruptions and things run smoother and therefore they usually faster so this is good then for anything",
    "start": "200550",
    "end": "208140"
  },
  {
    "text": "that is sort of particularly low latency so servers you obviously Don a garbage collection while you're serving a page",
    "start": "208140",
    "end": "213360"
  },
  {
    "text": "because then the user has to wait until the garbage collection is finished before they see the page the same with",
    "start": "213360",
    "end": "218850"
  },
  {
    "text": "games you don't have been lining up to take a shot at somebody and everything pauses while there's a garbage collection and then carries on similarly",
    "start": "218850",
    "end": "226350"
  },
  {
    "text": "with interactive user interfaces you don't need to pause there and block it up because you can feel it and it's it",
    "start": "226350",
    "end": "232110"
  },
  {
    "text": "interrupts the flow of what you're doing and if you look at those lists as well that kind of covers a lot of the",
    "start": "232110",
    "end": "237930"
  },
  {
    "text": "applications that we tend to build so generally speaking throughput and improving throughput is a good thing",
    "start": "237930",
    "end": "245209"
  },
  {
    "text": "it's also useful if you are working in a constrained environment so if you're working on a mobile device for example",
    "start": "245209",
    "end": "251190"
  },
  {
    "text": "or a console or other similar sorts of environments using less memory is",
    "start": "251190",
    "end": "257459"
  },
  {
    "text": "generally it's a good thing so if you can be more conservative with your memory you get again reduced garbage",
    "start": "257459",
    "end": "264240"
  },
  {
    "text": "collections and better throughput if you're working on a less powerful device then your garbage collection can be",
    "start": "264240",
    "end": "269970"
  },
  {
    "text": "slower and also it's doing more work so it's gonna be using up battery so fewer garbage collections will be better for",
    "start": "269970",
    "end": "275310"
  },
  {
    "text": "battery life and all this does come down to throughput and if you think about throughput and games again mobile",
    "start": "275310",
    "end": "281429"
  },
  {
    "text": "devices are absolutely huge for mobile gaming is absolutely huge on mobile devices and one of the big environments",
    "start": "281429",
    "end": "289679"
  },
  {
    "text": "for writing games on mobile devices is unity which is C sharp base of all of this does apply but there's another",
    "start": "289679",
    "end": "297869"
  },
  {
    "text": "reason which I think is very useful for understanding all this kind of thing is is that you should know your platform so",
    "start": "297869",
    "end": "304139"
  },
  {
    "text": "even if you're not actually going to be doing this in your own code you're still going to be using it in your in the",
    "start": "304139",
    "end": "310080"
  },
  {
    "text": "platform itself so one thing that has sort of changed over recent years with dotnet is how performance is really a",
    "start": "310080",
    "end": "316349"
  },
  {
    "text": "key part of the design of the platform it's really built in so every feature that is now being built there is always",
    "start": "316349",
    "end": "323339"
  },
  {
    "text": "always an eye on performance and you can see this in some of the recent features so if you are looking at c-sharp tuples",
    "start": "323339",
    "end": "330029"
  },
  {
    "text": "for example there's already a system to pipe they could have just built it around that but those are reference",
    "start": "330029",
    "end": "335909"
  },
  {
    "text": "types those would cause allocations every time they get used so they've actually introduced a new type value tuple which is a struct allocates on",
    "start": "335909",
    "end": "343559"
  },
  {
    "text": "this stack and that is then better than for for allocations and again for",
    "start": "343559",
    "end": "349229"
  },
  {
    "text": "reducing the amount of memory that you're using you can see a similar sort of thing with the ia sync enumerator",
    "start": "349229",
    "end": "354569"
  },
  {
    "text": "feature which is a a weight for each and also in a value task which has been",
    "start": "354569",
    "end": "360509"
  },
  {
    "text": "introduced to work with asynchronous programming I'll talk a bit more about that in a sec and then of course this",
    "start": "360509",
    "end": "367079"
  },
  {
    "text": "this new span of T API which again I'll talk about in a little while so let's",
    "start": "367079",
    "end": "373379"
  },
  {
    "start": "371000",
    "end": "563000"
  },
  {
    "text": "have a look at some some easy things here what are the low-hanging fruit what are the easy things we can do to reduce the amount of memory that's going on",
    "start": "373379",
    "end": "379379"
  },
  {
    "text": "just kind of keeping an eye on these things so again once we've profiled we want to have a look at this we want to",
    "start": "379379",
    "end": "384569"
  },
  {
    "text": "make sure that we're doing the appropriate things but there's a bunch of things we can do which are very easy to sort of fix some of these things so",
    "start": "384569",
    "end": "391169"
  },
  {
    "text": "we can reuse objects we can have object pooling we can pass in pre-allocated arrays rather than having to allocate",
    "start": "391169",
    "end": "396990"
  },
  {
    "text": "them all the time reuse an array once it's finished rather having to let the garbage collection garbage collector",
    "start": "396990",
    "end": "402569"
  },
  {
    "text": "clean it up and reallocate new stuff string concatenation we all know this",
    "start": "402569",
    "end": "408939"
  },
  {
    "text": "one use a string builder instead of just concatenating strings there and if you're using a string builder you can",
    "start": "408939",
    "end": "414580"
  },
  {
    "text": "reuse them as well so you can combine that with the first one there and if you know the length of the thing you're trying to build you can pre allocate it",
    "start": "414580",
    "end": "420610"
  },
  {
    "text": "as well so it doesn't have to work around reallocating items there params",
    "start": "420610",
    "end": "427090"
  },
  {
    "text": "is an interesting one so we'll have a look at our params is a good one here because the allocation that happens here",
    "start": "427090",
    "end": "432460"
  },
  {
    "text": "is something that you don't necessarily see when you're writing the code is something that the compiler is generating for you so you can be writing",
    "start": "432460",
    "end": "440259"
  },
  {
    "text": "code like on the left here passing in to two string variables to string value",
    "start": "440259",
    "end": "445779"
  },
  {
    "text": "sorry or nothing at all and the compiler is actually generating the code on the right so it's allocating an array for",
    "start": "445779",
    "end": "452020"
  },
  {
    "text": "you allocating array of two string values here and even when you're not passing anything at all the compiler is",
    "start": "452020",
    "end": "458289"
  },
  {
    "text": "allocating an array for you so every time you call there's another allocation but it's an allocation for an empty array except I'm lying to you that",
    "start": "458289",
    "end": "466719"
  },
  {
    "text": "doesn't happen on newer frameworks in newer compilers we use the array of",
    "start": "466719",
    "end": "472180"
  },
  {
    "text": "empty sorry the array dot empty of T method here which will reuse an empty",
    "start": "472180",
    "end": "477969"
  },
  {
    "text": "array for you so it's important to know again this is it this is you've got a profile you've got to know what the",
    "start": "477969",
    "end": "483639"
  },
  {
    "text": "platform is doing here you can't just trust me I'm just some guy standing on a stage don't trust me profile and see what's actually going on",
    "start": "483639",
    "end": "490509"
  },
  {
    "text": "what's happening but these kinds of things are allocations happening which you need to work with so boxing another",
    "start": "490509",
    "end": "499060"
  },
  {
    "text": "useful way of reducing the amount of allocations that happen boxing happens when you pass a value",
    "start": "499060",
    "end": "504849"
  },
  {
    "text": "type to a method that expects a reference type so you can have something like console.writeline the parameters",
    "start": "504849",
    "end": "510279"
  },
  {
    "text": "they get passed into that are expected to be objects but if you pass an integer to that it gets boxed and when we are",
    "start": "510279",
    "end": "517120"
  },
  {
    "text": "boxing something that creates a new object on the heap which is going to be the box it copies the value type into",
    "start": "517120",
    "end": "524290"
  },
  {
    "text": "the that object and passes that into the method and that means you're working",
    "start": "524290",
    "end": "530440"
  },
  {
    "text": "then with a copy of the value type and any changes the method tries to make to that box value doesn't get you so that's",
    "start": "530440",
    "end": "536589"
  },
  {
    "text": "an interesting side effect we'll come back to that one thing that's interesting is the river here which can help so the little screen",
    "start": "536589",
    "end": "543040"
  },
  {
    "text": "sort of the bottom there is using a plug-in to resharper and Ryder called the heap allocations viewer and",
    "start": "543040",
    "end": "549580"
  },
  {
    "text": "this will show you and highlights items where things being boxed where you don't necessarily expect it so again like with",
    "start": "549580",
    "end": "555520"
  },
  {
    "text": "the params issue this is something that the compiler and the runtime are doing for you that you don't necessarily see",
    "start": "555520",
    "end": "561010"
  },
  {
    "text": "as part of the language but talk about reference types and value types well",
    "start": "561010",
    "end": "566860"
  },
  {
    "start": "563000",
    "end": "773000"
  },
  {
    "text": "what do I mean here let's kind of remind ourselves really what's going on here so the dotnet world you've basically got",
    "start": "566860",
    "end": "574120"
  },
  {
    "text": "two types of types two kinds of types reference types and value types a",
    "start": "574120",
    "end": "580270"
  },
  {
    "text": "reference type uses the class keyword whereas value types use the struct keyword references are allocated on the",
    "start": "580270",
    "end": "586300"
  },
  {
    "text": "heap and value types are allocated on the stack they can also be embedded directly in a another object as well the",
    "start": "586300",
    "end": "595750"
  },
  {
    "text": "key difference between the two is that a variable for a reference type is actually a reference to the thing on the heap so something lives on the heap and",
    "start": "595750",
    "end": "602080"
  },
  {
    "text": "I've got a variable and it's basically saying it's over there when you want to pass things around you pass it around by",
    "start": "602080",
    "end": "608080"
  },
  {
    "text": "that reference you pass that reference to another method and they're called both the caller and the called method",
    "start": "608080",
    "end": "613570"
  },
  {
    "text": "know that it's pointing to the same thing over here and when you then assign",
    "start": "613570",
    "end": "621300"
  },
  {
    "text": "assigned to a different variable there that variable gets a copy of the reference and it points the same object",
    "start": "621300",
    "end": "626320"
  },
  {
    "text": "so you're dealing with the same object a value type on the other hand a value type is the actual value itself so for",
    "start": "626320",
    "end": "633250"
  },
  {
    "text": "an integer it's just the integer but if you're talking like a 3d point x y&z float values the value type there is",
    "start": "633250",
    "end": "639880"
  },
  {
    "text": "those three values so it's not pointing to anything on the heap is the actual content of the value itself this is",
    "start": "639880",
    "end": "648160"
  },
  {
    "text": "passed around by value so if you pass it to another method it's a copy of it this is important because then if you make",
    "start": "648160",
    "end": "654910"
  },
  {
    "text": "any modifications to that you met you're modifying the copy not the original value it's also important to know when",
    "start": "654910",
    "end": "661180"
  },
  {
    "text": "you are signing to another variable you're making another copy so you might be thinking you know if you if you've got a string for example and you have s1",
    "start": "661180",
    "end": "667810"
  },
  {
    "text": "and s2 they're gonna be the same string if you try to change it that example of strings the same thing person class for",
    "start": "667810",
    "end": "673660"
  },
  {
    "text": "example if you tried to change it both of those variables would be pointing at the same thing it would change that whereas if it",
    "start": "673660",
    "end": "679900"
  },
  {
    "text": "was a value type if you change one variable the other variable is unaffected",
    "start": "679900",
    "end": "686100"
  },
  {
    "text": "so heat versus tack I mentioned that reference types are on the heap value types are on the stack what's the",
    "start": "686100",
    "end": "691210"
  },
  {
    "text": "difference well the heap is its general-purpose memory it's available there for the lifetime of the",
    "start": "691210",
    "end": "696430"
  },
  {
    "text": "application and it's you allocate something there and it lasts until it's no longer used and the garbage collects",
    "start": "696430",
    "end": "702850"
  },
  {
    "text": "it cleans things up the stack though is a block of memory for data which is",
    "start": "702850",
    "end": "708040"
  },
  {
    "text": "required by the method so when you enter a method it will push space onto the stack ready to hold all the data that's",
    "start": "708040",
    "end": "715690"
  },
  {
    "text": "being used for that method for all the local variables and then where the method exits itself the the stack is",
    "start": "715690",
    "end": "723160"
  },
  {
    "text": "popped and everything gets cleaned up so stack allocation has a different lifetime to the heap it lasts for the",
    "start": "723160",
    "end": "728830"
  },
  {
    "text": "lifetime of the method it's being used in value types of the entire set of data",
    "start": "728830",
    "end": "734650"
  },
  {
    "text": "so if you have a value type which is the point it's got those x y&z in there that's the whole data that lives",
    "start": "734650",
    "end": "740050"
  },
  {
    "text": "directly on the stack so straight in the stack there you've got all of the data for your object for your the thing you",
    "start": "740050",
    "end": "745660"
  },
  {
    "text": "you're working with you can also use the stack alik keyword there as well to",
    "start": "745660",
    "end": "751030"
  },
  {
    "text": "allocate blocks of data on the stack but generally you don't use that one and you just use local variables but what all",
    "start": "751030",
    "end": "757570"
  },
  {
    "text": "this means really is now that we've got allocation and cleanup being cheap because everything is just and life time",
    "start": "757570",
    "end": "763720"
  },
  {
    "text": "used is well-defined as well because it lasts for the lifetime of the method but you are limited in space you can't have",
    "start": "763720",
    "end": "769630"
  },
  {
    "text": "a bigger amount of objects as you can on the heap all right back to our list over",
    "start": "769630",
    "end": "776080"
  },
  {
    "start": "773000",
    "end": "1081000"
  },
  {
    "text": "sort of things we can easily work with closures again another example of where the compiler rewrites things and",
    "start": "776080",
    "end": "782640"
  },
  {
    "text": "introduces allocations for you that are not perhaps very visible in your code so",
    "start": "782640",
    "end": "788290"
  },
  {
    "text": "if you have a closure and you're capturing values and using them inside a lambda what the compiler is going to do",
    "start": "788290",
    "end": "794140"
  },
  {
    "text": "is rewrite that until it introduces a new class and that class is going to contain all the captured variables or",
    "start": "794140",
    "end": "800530"
  },
  {
    "text": "parameters or fields and keep those inside the class",
    "start": "800530",
    "end": "805840"
  },
  {
    "text": "the lambda 10 rewritten as a method on that class so it can use that data and work with it but now to call that it has",
    "start": "805840",
    "end": "813010"
  },
  {
    "text": "to allocate the class so you've got an allocation happening there which isn't visible when you look at the code so",
    "start": "813010",
    "end": "819250"
  },
  {
    "text": "link is a great example of all of this link is very very useful it's a great system but it's because it's using a lot",
    "start": "819250",
    "end": "824770"
  },
  {
    "text": "of closures it's going to hit this problem and you gotta have allocations that are going on there but on top of",
    "start": "824770",
    "end": "831430"
  },
  {
    "text": "that link is based off a lot of static methods which then allocate in numerator classes so there's extra allocations",
    "start": "831430",
    "end": "837760"
  },
  {
    "text": "going on and again the heap allocation viewer thing can show this it can highlight where you've got methods sorry",
    "start": "837760",
    "end": "843910"
  },
  {
    "text": "variables or parameters that are being pulled into a closure class a display class and also then when the method",
    "start": "843910",
    "end": "851080"
  },
  {
    "text": "itself is going to allocate something to return back to you iterators have a",
    "start": "851080",
    "end": "857290"
  },
  {
    "text": "similar sort of problem here so if you have the yield return type feature in c-sharp iterators they also get",
    "start": "857290",
    "end": "864160"
  },
  {
    "text": "re-written as a state machine and there's an allocation going on there which the compiler does for you and you",
    "start": "864160",
    "end": "869230"
  },
  {
    "text": "don't necessarily see in your code a similar thing with a sync await your code is rewritten to a state machine",
    "start": "869230",
    "end": "874720"
  },
  {
    "text": "here there's an allocation for the state machine is allocation for the task method builder and they need on top of",
    "start": "874720",
    "end": "880030"
  },
  {
    "text": "that you get more allocations for the tasks that you return back your task or your task of T and this is generally",
    "start": "880030",
    "end": "886780"
  },
  {
    "text": "okay because if you have a long-running process then you kind of need to be able to return that you need to be able to",
    "start": "886780",
    "end": "891970"
  },
  {
    "text": "return something that is going to fulfill that at some point but it also doesn't help with some of the common use",
    "start": "891970",
    "end": "899140"
  },
  {
    "text": "cases so if you have a method is going to complete synchronously rather than asynchronously so sometimes it needs to",
    "start": "899140",
    "end": "905500"
  },
  {
    "text": "go off and do something for a long time but sometimes it can say nope I've got the answer here it is it's going to do",
    "start": "905500",
    "end": "911320"
  },
  {
    "text": "allocations for those those times when a simple method return would have been better",
    "start": "911320",
    "end": "917730"
  },
  {
    "text": "there's also no chance for reusing some of those objects when you create a task of T and you give it a value you can't",
    "start": "917940",
    "end": "924670"
  },
  {
    "text": "necessarily reuse that so it's just kind of like a throwaway item which has been allocated and the value task type which",
    "start": "924670",
    "end": "931630"
  },
  {
    "text": "has been introduced is very very helpful for some of these things it is a value type which represents the task and it's",
    "start": "931630",
    "end": "937900"
  },
  {
    "text": "it's great then for some of these use cases where you want to be able to reuse items where you also want to be able to",
    "start": "937900",
    "end": "943970"
  },
  {
    "text": "return synchronously without having to allocate something and there's a really good blog post explaining some of that",
    "start": "943970",
    "end": "949040"
  },
  {
    "text": "there and I've got some more links than at the end if you want to see those okay so those are are kind of easy things we",
    "start": "949040",
    "end": "956540"
  },
  {
    "text": "can fix up those are the sort of well-known things that we can work on to to fix up there's a bunch of ways of working around those so we were talking",
    "start": "956540",
    "end": "963230"
  },
  {
    "text": "about params for example we could introduce different overloads there with a common number of arguments so perhaps",
    "start": "963230",
    "end": "968720"
  },
  {
    "text": "we usually call the method with two parameters well create a method with two parameters there you've got the",
    "start": "968720",
    "end": "974329"
  },
  {
    "text": "flexibility to call it with more in other places but if you're frequently calling it with to have an overload",
    "start": "974329",
    "end": "980120"
  },
  {
    "text": "which does that for you to work around boxing you can introduce generic overloads and let the the runtime work",
    "start": "980120",
    "end": "987320"
  },
  {
    "text": "that for you so then you don't have any boxing there at all and if you've got closures and avoid those in critical",
    "start": "987320",
    "end": "993860"
  },
  {
    "text": "paths so if you've got some code which is called very very frequently or for a long period of time avoid them basically",
    "start": "993860",
    "end": "1000820"
  },
  {
    "text": "try and do something different perhaps you can pass the state as an argument to the lambda rather than trying to capture",
    "start": "1000820",
    "end": "1006730"
  },
  {
    "text": "it as a as a class one thing which is going to be a nice thing to look at in",
    "start": "1006730",
    "end": "1013209"
  },
  {
    "text": "recent versions of c-sharp or local functions because local functions have a similar rewriting method going on but",
    "start": "1013209",
    "end": "1020110"
  },
  {
    "text": "because the scope of the call is known most of the time it can the captured data can be represented in a value type",
    "start": "1020110",
    "end": "1026380"
  },
  {
    "text": "that's then allocated on the stack which again as we say is cheap to allocate cheap to clean up and very easy and",
    "start": "1026380",
    "end": "1032949"
  },
  {
    "text": "useful to use link very similar sort of",
    "start": "1032949",
    "end": "1038620"
  },
  {
    "text": "thing there because the closures they're avoided in critical paths we all know how to use for each and if it might be",
    "start": "1038620",
    "end": "1044140"
  },
  {
    "text": "slightly longer code but it's going to have a better performance characteristic in something which is called very very",
    "start": "1044140",
    "end": "1050110"
  },
  {
    "text": "frequently iterate is an interesting one how do you fix an iterator perhaps you",
    "start": "1050110",
    "end": "1055840"
  },
  {
    "text": "can allocate a collection and return that perhaps that allocation is going to be better than the allocation that the",
    "start": "1055840",
    "end": "1061240"
  },
  {
    "text": "runtime does for you perhaps you can't allocate a collection because you've got an infinite stream",
    "start": "1061240",
    "end": "1067960"
  },
  {
    "text": "that's going on there so you don't really have to know it and this is one way you kind of just have to be aware of",
    "start": "1067960",
    "end": "1073000"
  },
  {
    "text": "the cost and then figure out a way to minimize that for your particular use case and",
    "start": "1073000",
    "end": "1078490"
  },
  {
    "text": "then with a sink awaits investigate value tasks right so that's",
    "start": "1078490",
    "end": "1084309"
  },
  {
    "text": "kind of some of the sort of frequently known ways of reducing some of your",
    "start": "1084309",
    "end": "1089470"
  },
  {
    "text": "allocations there I want to look at something which is a bit more interesting a bit more meat to it I'm going to have a look at reference",
    "start": "1089470",
    "end": "1094809"
  },
  {
    "text": "semantics with value types which is a bit of a mouthful but it's all all good",
    "start": "1094809",
    "end": "1100299"
  },
  {
    "text": "stuff it's a set of features that came in with the sort of C sharp 7 compiler and various and following point releases",
    "start": "1100299",
    "end": "1106720"
  },
  {
    "text": "and it's a set of building blocks that combine to produce a really nice sort of",
    "start": "1106720",
    "end": "1112330"
  },
  {
    "text": "effect but what kind of effect what am I talking about what does this really mean",
    "start": "1112330",
    "end": "1118110"
  },
  {
    "start": "1118000",
    "end": "1238000"
  },
  {
    "text": "well if we have a look back at when we talk about reference types and value",
    "start": "1118110",
    "end": "1124330"
  },
  {
    "text": "types if we talk about allocating a reference type has a cost in terms of garbage collection but passing around is",
    "start": "1124330",
    "end": "1130389"
  },
  {
    "text": "cheap I can pass a reference and it is very cheap to pass around allocating of",
    "start": "1130389",
    "end": "1135429"
  },
  {
    "text": "value type is cheap because it lives on the stack and a lifetime is determined it can get cleaned up very easily but",
    "start": "1135429",
    "end": "1141580"
  },
  {
    "text": "then passing it around has a cost because it gets copied I can't necessarily modify it and there",
    "start": "1141580",
    "end": "1148659"
  },
  {
    "text": "are sort of costs associated with that so why can't we just have the best of both worlds why can't it be cheap to",
    "start": "1148659",
    "end": "1154179"
  },
  {
    "text": "allocate and cheap to pass around and that's what reference semantics with value types means basically allows us to",
    "start": "1154179",
    "end": "1161200"
  },
  {
    "text": "treat value types as though there were reference types so we can pass by reference anywhere so we can pass these",
    "start": "1161200",
    "end": "1167590"
  },
  {
    "text": "value types around by reference and we get all the benefits of everything so we",
    "start": "1167590",
    "end": "1174580"
  },
  {
    "text": "get to use value types to reduce the amount of allocations we have because everything lives on the stack and that",
    "start": "1174580",
    "end": "1180070"
  },
  {
    "text": "then reduces our memory traffic our garbage collections and so forth and so on and that then gives us better throughput",
    "start": "1180070",
    "end": "1187139"
  },
  {
    "text": "passing things by reference avoids various copies of these value types there and it also enables us to modify",
    "start": "1187139",
    "end": "1194649"
  },
  {
    "text": "things as well so I can instead of passing a copy around which is a very different thing and I can't get the",
    "start": "1194649",
    "end": "1199779"
  },
  {
    "text": "information back into it I can now modify it and work with it again it's important to point out that",
    "start": "1199779",
    "end": "1206020"
  },
  {
    "text": "these are low-level micro optimizations you only need to do these in critical paths where you have code that's being",
    "start": "1206020",
    "end": "1211750"
  },
  {
    "text": "used very very frequently and needs to be very very fast but these kinds of",
    "start": "1211750",
    "end": "1219490"
  },
  {
    "text": "things will and are being used in the platform they'll be used for you know web service they'll be used in games",
    "start": "1219490",
    "end": "1225880"
  },
  {
    "text": "that we used in parsing W's and serialization they'll be used in lots of places you're gonna see this so it is",
    "start": "1225880",
    "end": "1232120"
  },
  {
    "text": "gonna happen if you might not necessarily need to use it in your own code but then again maybe you do again profile profile profile right so what do",
    "start": "1232120",
    "end": "1240520"
  },
  {
    "text": "I mean by pass by reference and pass by value so I've been talking about these again now so a variable for a reference",
    "start": "1240520",
    "end": "1247750"
  },
  {
    "text": "type is a reference to the actual object on the heap so we've got the heat we've got the thing we're trying to create here a person whatever it is and if I",
    "start": "1247750",
    "end": "1254529"
  },
  {
    "text": "have a variable for reference type the variable is basically saying it's over there it's on the heap passing this",
    "start": "1254529",
    "end": "1260559"
  },
  {
    "text": "around is very easy you just pass a reference to the method and the called",
    "start": "1260559",
    "end": "1266649"
  },
  {
    "text": "method goes well it's that object over there on the heap it's the same object it knows where it is it's cheap it's easy they see the same object but if we",
    "start": "1266649",
    "end": "1275919"
  },
  {
    "text": "have a variable for a value type it's that the whole value itself it's our three points in a in a in a pointing the",
    "start": "1275919",
    "end": "1281740"
  },
  {
    "text": "X Y Zed in a point passing a value type to a method passes the whole thing and it passes a copy of it so you've now got",
    "start": "1281740",
    "end": "1288010"
  },
  {
    "text": "two copies of the same thing assigning a value type to a new value copies the method as well and the original value is",
    "start": "1288010",
    "end": "1294549"
  },
  {
    "text": "unmodified so there you change one it doesn't change the other it's also important to point out that copies",
    "start": "1294549",
    "end": "1300610"
  },
  {
    "text": "aren't actually that expensive it's not that much of a big deal forget x y&z it's three items three",
    "start": "1300610",
    "end": "1306010"
  },
  {
    "text": "floats that's fine it's little block of memory computers are very good at moving little blocks of memory around so the",
    "start": "1306010",
    "end": "1313149"
  },
  {
    "text": "copies aren't actually that expensive however if you are a critical path in a very hot path then they can add up and",
    "start": "1313149",
    "end": "1321370"
  },
  {
    "text": "if you can reduce the amount of work you're doing then that that's great okay",
    "start": "1321370",
    "end": "1327279"
  },
  {
    "start": "1325000",
    "end": "1728000"
  },
  {
    "text": "so let's have a look at the the first building block out of all of this then Co up seven introduced ref returns and",
    "start": "1327279",
    "end": "1333880"
  },
  {
    "text": "this allows us to return a reference to a value type rather a copy of the value so if you have a",
    "start": "1333880",
    "end": "1339400"
  },
  {
    "text": "method and you want to return something back I want return my point back from a method normally would be a copy of value",
    "start": "1339400",
    "end": "1345430"
  },
  {
    "text": "here I can now return a reference so that's great the return type of the",
    "start": "1345430",
    "end": "1350680"
  },
  {
    "text": "method changes here so here are an example of an integer this now becomes a",
    "start": "1350680",
    "end": "1356860"
  },
  {
    "text": "reference to an integer written int with an ampersand in an eye out and it's very",
    "start": "1356860",
    "end": "1362170"
  },
  {
    "text": "important that the referent the return type of the method changes if I'm",
    "start": "1362170",
    "end": "1367540"
  },
  {
    "text": "returning back a reference to a value type then the thing I'm referring to the",
    "start": "1367540",
    "end": "1372850"
  },
  {
    "text": "thing I'm using must exceed the lifetime of the called method so if I have a value type which is a local variable",
    "start": "1372850",
    "end": "1379540"
  },
  {
    "text": "inside the method I can't pass that back because as soon as I do the stack disappears for that method and that",
    "start": "1379540",
    "end": "1385900"
  },
  {
    "text": "thing is gone so that that doesn't exist so I have to pass back something which has got a longer lifetime than like the",
    "start": "1385900",
    "end": "1392620"
  },
  {
    "text": "method that has just been called so this has to be a field or an argument that's",
    "start": "1392620",
    "end": "1398350"
  },
  {
    "text": "been passed in but not a local variable for similar reasons now we can't use this with async methods because",
    "start": "1398350",
    "end": "1404320"
  },
  {
    "text": "obviously async method life time all changes and goes a bit a bit funny so we",
    "start": "1404320",
    "end": "1410980"
  },
  {
    "text": "can't use it for a sink and we're next",
    "start": "1410980",
    "end": "1417220"
  },
  {
    "text": "to the next one yes so if we modified the value so there is the value gets returned back as a reference if we",
    "start": "1417220",
    "end": "1423040"
  },
  {
    "text": "modify that returned reference then we our module it's the same as modifying the original value because it is the",
    "start": "1423040",
    "end": "1429430"
  },
  {
    "text": "original value so we're talking about the same thing here we haven't changed we haven't got any copies we're modifying the same thing you can do some",
    "start": "1429430",
    "end": "1437290"
  },
  {
    "text": "interesting things with this because I can return now a reference to an element inside an array and modify it in place",
    "start": "1437290",
    "end": "1443940"
  },
  {
    "text": "so I don't have to call a getter to get the value set something up and then call",
    "start": "1443940",
    "end": "1449320"
  },
  {
    "text": "a setter to put it back in there I can actually just change the actual thing in place because it's a reference if the",
    "start": "1449320",
    "end": "1454810"
  },
  {
    "text": "original value it's the actual thing there are no copies going on so there's a lot of very interesting things you can",
    "start": "1454810",
    "end": "1459940"
  },
  {
    "text": "do along those lines to use this you need to use the ref modifier and add",
    "start": "1459940",
    "end": "1466750"
  },
  {
    "text": "that to the the method declaration to the return type and also in the return statement itself I'll show you",
    "start": "1466750",
    "end": "1473860"
  },
  {
    "text": "this in a sec but we've kind of got a problem here now because we've got a",
    "start": "1473860",
    "end": "1480040"
  },
  {
    "text": "method which has got a return type of reference of an integer int with the ampersand at the end of it if you want",
    "start": "1480040",
    "end": "1486700"
  },
  {
    "text": "to talk about I L and how do I assign that to a local variable because a local variable isn't going to be int with an",
    "start": "1486700",
    "end": "1493120"
  },
  {
    "text": "ampersand is just going to be int so um if you assign it to if you sign a ref",
    "start": "1493120",
    "end": "1499720"
  },
  {
    "text": "return back to a new variable you're going to get a copy which kind of defeats the purpose because the variable",
    "start": "1499720",
    "end": "1505390"
  },
  {
    "text": "is a value type and we've just returned a reference so see top seven also",
    "start": "1505390",
    "end": "1510550"
  },
  {
    "text": "introduced ref locals and a ref local is a variable that is a reference to a value type and again accessing this",
    "start": "1510550",
    "end": "1517750"
  },
  {
    "text": "variable access is the original value they're the same thing so you use a ref",
    "start": "1517750",
    "end": "1523390"
  },
  {
    "text": "local to restore the the return value of a referee turn and you can also use var",
    "start": "1523390",
    "end": "1529600"
  },
  {
    "text": "for this as well but you can't just use vai you have to use 'href VAR val it's",
    "start": "1529600",
    "end": "1535090"
  },
  {
    "text": "gonna tell you well that's an int but it's not gonna tell you that it's a reference to an int it's just you have",
    "start": "1535090",
    "end": "1540400"
  },
  {
    "text": "to give it the ref modifier as well so let's have a quick look at what this",
    "start": "1540400",
    "end": "1546700"
  },
  {
    "text": "looks like in practice okay so I have I",
    "start": "1546700",
    "end": "1556440"
  },
  {
    "text": "have a couple of types here I have a struct which is a point two values an X",
    "start": "1556440",
    "end": "1561970"
  },
  {
    "text": "and a why they're public they can be modified constructed to create them and then I have my enemy class and my enemy",
    "start": "1561970",
    "end": "1568570"
  },
  {
    "text": "class contains a point and it has a constructor than which creates an enemy",
    "start": "1568570",
    "end": "1574090"
  },
  {
    "text": "and gives it a location as a point I have two methods one is to get the",
    "start": "1574090",
    "end": "1579130"
  },
  {
    "text": "current location which just returns it this is just standard sort of code would normally write and here I've got one",
    "start": "1579130",
    "end": "1585070"
  },
  {
    "text": "which is using ref returns and we can heat see here now that I've got a ref",
    "start": "1585070",
    "end": "1590559"
  },
  {
    "text": "point that I'm returning back here so I'm not ruining just a point and returning back a reference to a point and here I'm using return ref as part of",
    "start": "1590559",
    "end": "1599080"
  },
  {
    "text": "my keyword here so I'm returning back a reference to the item now I have some tests so we're going to",
    "start": "1599080",
    "end": "1605109"
  },
  {
    "text": "do some tests to make sure that the behavior is as we expect so if we excuse",
    "start": "1605109",
    "end": "1611769"
  },
  {
    "text": "me start with the first one what we're gonna see here is we we create an instance of the enemy and give it a",
    "start": "1611769",
    "end": "1617259"
  },
  {
    "text": "location at X Y 10/10 and what we can do here is we can call the get location we",
    "start": "1617259",
    "end": "1623350"
  },
  {
    "text": "get a point back if I change that value then I'm actually working on a copy so",
    "start": "1623350",
    "end": "1628450"
  },
  {
    "text": "nothing nothing changes so I can assert that my local copy is 12 but then the original value if I call get location",
    "start": "1628450",
    "end": "1635049"
  },
  {
    "text": "again is still 10 so I'm working on a copy that's no good at all I can call my",
    "start": "1635049",
    "end": "1643299"
  },
  {
    "text": "get location by ref and this will return me back this is using the ref return",
    "start": "1643299",
    "end": "1648460"
  },
  {
    "text": "value here but I'm assigning it to just a point and so what I get here is a copy even though I'm calling the method by",
    "start": "1648460",
    "end": "1655779"
  },
  {
    "text": "ref and I'm calling it with the the ref return keywords going on it's still a",
    "start": "1655779",
    "end": "1661059"
  },
  {
    "text": "copy I set it to 12 nothing changes it got 12 and 10 going on there so what I",
    "start": "1661059",
    "end": "1668980"
  },
  {
    "text": "have to do instead is I have to use the ref keyword when declaring my variable as well so I have my ref VAR location",
    "start": "1668980",
    "end": "1675460"
  },
  {
    "text": "item here which is going to be just a point but it's a reference to a point if I change it location dot X is 12",
    "start": "1675460",
    "end": "1683080"
  },
  {
    "text": "I now confirm that I've actually updated the value which is part of the the type",
    "start": "1683080",
    "end": "1688690"
  },
  {
    "text": "and if we run this let's just go to the top we'll see that's everything",
    "start": "1688690",
    "end": "1694899"
  },
  {
    "text": "hopefully goes green so great now there's one extra method down the bottom here because you can do some kind of",
    "start": "1694899",
    "end": "1702039"
  },
  {
    "text": "weird things with this because it's a reference I can assign things to a reference and I can do things so what I",
    "start": "1702039",
    "end": "1708190"
  },
  {
    "text": "can actually do is assign a value to the return value of a method which is kind",
    "start": "1708190",
    "end": "1713889"
  },
  {
    "text": "of weird don't write this in real code because it's just confusing but yeah you",
    "start": "1713889",
    "end": "1719080"
  },
  {
    "text": "can do some fun things",
    "start": "1719080",
    "end": "1722460"
  },
  {
    "text": "okay yep all right so that's great we",
    "start": "1724290",
    "end": "1730929"
  },
  {
    "start": "1728000",
    "end": "2018000"
  },
  {
    "text": "can return back a reference to a value type we can modify it and it updates the",
    "start": "1730929",
    "end": "1735970"
  },
  {
    "text": "original value and that's great and that's lovely but the downside of this is that we can now modify someone else's",
    "start": "1735970",
    "end": "1742750"
  },
  {
    "text": "state which is not necessarily what we wanted to do so we've got the benefit of being able to return something back by",
    "start": "1742750",
    "end": "1749140"
  },
  {
    "text": "reference and so we've reduced the number of copies that are going on but we've now got something which is mutable",
    "start": "1749140",
    "end": "1754270"
  },
  {
    "text": "and we can mutate state which we don't necessarily want to do so we've got them the ref read-only return feature and",
    "start": "1754270",
    "end": "1762160"
  },
  {
    "text": "this extends the ref returns and ref locals value basically it allows you to return a value type by reference but the",
    "start": "1762160",
    "end": "1768820"
  },
  {
    "text": "call is not allowed to modify it so the way to use this is that you assign to ref read-only var rather than to just",
    "start": "1768820",
    "end": "1775900"
  },
  {
    "text": "'href VAR and the compiler enforces this read-only status with with errors compile errors and also defensive copies",
    "start": "1775900",
    "end": "1783280"
  },
  {
    "text": "it'll actually make a copy of the code for you I sort of the the value type for you without you necessarily knowing so",
    "start": "1783280",
    "end": "1790600"
  },
  {
    "text": "this kind of works around a problem here where I've got some sort of shared state going on so for example I might create a",
    "start": "1790600",
    "end": "1796510"
  },
  {
    "text": "point which defines the origin of my game which is at 0 0 0 I want to return that back by reference because that's",
    "start": "1796510",
    "end": "1803170"
  },
  {
    "text": "cheaper and better and nicer and then someone comes along and modifies that reference and all of a sudden I've got",
    "start": "1803170",
    "end": "1809200"
  },
  {
    "text": "really weird bugs happening in my game because somebody has changed where zero zero zero lives and we can see this in",
    "start": "1809200",
    "end": "1817120"
  },
  {
    "text": "action as well I've got another class very similar to the last one I've got a struct point here again we've got public",
    "start": "1817120",
    "end": "1825690"
  },
  {
    "text": "values for x and y I've introduced a new method here I've got this translate in",
    "start": "1825690",
    "end": "1831010"
  },
  {
    "text": "place method and here I can modify the X and y by translating it adding values",
    "start": "1831010",
    "end": "1836890"
  },
  {
    "text": "onto X adding values onto Y and I got two two values here for of how we can do",
    "start": "1836890",
    "end": "1843490"
  },
  {
    "text": "origin so for example I just creates a static point which is going to be at 0 0 and I can return it back by reference",
    "start": "1843490",
    "end": "1851020"
  },
  {
    "text": "like we've just done in the previous example and and work with that and that's going to be a reference no copies",
    "start": "1851020",
    "end": "1856720"
  },
  {
    "text": "everything's great and I got my second example here",
    "start": "1856720",
    "end": "1862020"
  },
  {
    "text": "second example here which is going to be a read-only point now which again is set",
    "start": "1862020",
    "end": "1867640"
  },
  {
    "text": "to 0-0 and I've now got a static ref read-only as part of my return type here",
    "start": "1867640",
    "end": "1874360"
  },
  {
    "text": "and if we look at how we use this then again if I just call point of origin I'm",
    "start": "1874360",
    "end": "1881260"
  },
  {
    "text": "getting I inserting it into a standard var so I don't have any reference stuff",
    "start": "1881260",
    "end": "1886480"
  },
  {
    "text": "going on I'm getting a copy if I make any changes to that then my origin is still fine",
    "start": "1886480",
    "end": "1892059"
  },
  {
    "text": "everything's good it's just like in the previous example if I call again now",
    "start": "1892059",
    "end": "1899409"
  },
  {
    "text": "like in the previous example I call get the origin back by reference and put it",
    "start": "1899409",
    "end": "1905110"
  },
  {
    "text": "into a reference value I can change my origin to be 42 and X and now I've just broken the origin and",
    "start": "1905110",
    "end": "1911799"
  },
  {
    "text": "my game is doing crazy things so that's not good so what we do instead then is",
    "start": "1911799",
    "end": "1918520"
  },
  {
    "text": "we introduce this ref read-only var here so I've got my read-only origin here and",
    "start": "1918520",
    "end": "1923860"
  },
  {
    "text": "in fact if I try to assign that to a standard reference variable I get a compile error the compiler says you",
    "start": "1923860",
    "end": "1930760"
  },
  {
    "text": "can't do this so it has to be a read-only reference and I need to have",
    "start": "1930760",
    "end": "1936510"
  },
  {
    "text": "the reader a keyword in there and now because it's read-only I actually can't set a value on that so",
    "start": "1936510",
    "end": "1943240"
  },
  {
    "text": "I can't change my origin the compiler enforces it so this is great so now I can pass things back by reference but I",
    "start": "1943240",
    "end": "1948820"
  },
  {
    "text": "can't modify it so that's a compile error and I got my tests there which will just verify that everything is fine",
    "start": "1948820",
    "end": "1957570"
  },
  {
    "text": "but we now got a bit of another problem again because you remember I had that method translate in place so I can",
    "start": "1957570",
    "end": "1964000"
  },
  {
    "text": "actually call a method on my origin which is read-only and it's gonna",
    "start": "1964000",
    "end": "1969580"
  },
  {
    "text": "translate it in place and that would that should change it so that should change my origin but it doesn't the",
    "start": "1969580",
    "end": "1976270"
  },
  {
    "text": "compiler does something for you here the compiler goes I don't trust you you're not necessarily doing the thing you so",
    "start": "1976270",
    "end": "1983350"
  },
  {
    "text": "think you're doing here that's supposed to be read-only so I'm gonna make a copy of this to call this method because I",
    "start": "1983350",
    "end": "1988480"
  },
  {
    "text": "cannot guarantee that that mess does not change this read-only value as",
    "start": "1988480",
    "end": "1994540"
  },
  {
    "text": "we actually end up with a copy so even though I set the value to 42 here I'm",
    "start": "1994540",
    "end": "1999700"
  },
  {
    "text": "still set at 0 at the end and if we run",
    "start": "1999700",
    "end": "2004890"
  },
  {
    "text": "these tests we'll see them that all of those assertions hold true and we still",
    "start": "2004890",
    "end": "2011820"
  },
  {
    "text": "green on the side there so all of those a trip and we're still good but now",
    "start": "2011820",
    "end": "2020070"
  },
  {
    "start": "2018000",
    "end": "2203000"
  },
  {
    "text": "we've kind of got a problem well actually I'll come back to that next little building block stepping away from",
    "start": "2020070",
    "end": "2026550"
  },
  {
    "text": "the ref returns rest for a sec is in parameters so this is a method argument",
    "start": "2026550",
    "end": "2031980"
  },
  {
    "text": "modifier it kind of complements the out and the ref keyword when you're defining a method methods arguments and it allows",
    "start": "2031980",
    "end": "2039420"
  },
  {
    "text": "you to a pattern item a pass a value type by reference but you're telling the",
    "start": "2039420",
    "end": "2045120"
  },
  {
    "text": "compiler that you can't modify this so it's in only and other than that you can't do anything with it and you have a",
    "start": "2045120",
    "end": "2052830"
  },
  {
    "text": "similar thing here the compiler will enforce a whole bunch of safety but when it calls a method it will make a",
    "start": "2052830",
    "end": "2058530"
  },
  {
    "text": "defensive copy and we can quickly see that one here again we've got our",
    "start": "2058530",
    "end": "2064200"
  },
  {
    "text": "mutable points here now just to make the point here it is mutable I've got my translate in place which is going to",
    "start": "2064200",
    "end": "2069690"
  },
  {
    "text": "change things I've got public value variables there so it should be changeable it should be mutable but now we're going to have in",
    "start": "2069690",
    "end": "2076590"
  },
  {
    "text": "fact we can assert that so if I just create a point there mutable point translate in place it actually does work",
    "start": "2076590",
    "end": "2083669"
  },
  {
    "text": "in it so we know that that's working now if I have my in parameter here you can",
    "start": "2083670",
    "end": "2093540"
  },
  {
    "text": "see that I've given this method arguments the in parameter marking we've",
    "start": "2093540",
    "end": "2098820"
  },
  {
    "text": "immediately got a compiler so you can't do this you can't modify an in parameter the compiler says no so that's that's",
    "start": "2098820",
    "end": "2105570"
  },
  {
    "text": "great compile time safety is even better than runtime safety however I'm calling",
    "start": "2105570",
    "end": "2110670"
  },
  {
    "text": "my translating place which is going to change things and I don't have a well an error which is not great so the",
    "start": "2110670",
    "end": "2118350"
  },
  {
    "text": "something happening there which I necessary don't necessarily want and I've just uncommented to college",
    "start": "2118350",
    "end": "2124369"
  },
  {
    "text": "so let's see what's going on let's have a look what I can do here is I can",
    "start": "2124369",
    "end": "2130980"
  },
  {
    "text": "create a new instance of my point pass it into this do translate method here",
    "start": "2130980",
    "end": "2136259"
  },
  {
    "text": "and that do translate is going to have the in modifier so we're now saying that this particular value type is going to",
    "start": "2136259",
    "end": "2142289"
  },
  {
    "text": "be read only because it's an in parameter I can call the translate in",
    "start": "2142289",
    "end": "2147630"
  },
  {
    "text": "place and then I can assert it and it's going to tell me that actually that doesn't work because it's actually reset",
    "start": "2147630",
    "end": "2154410"
  },
  {
    "text": "it back to ten originally set at ten in the first place there so the translate doesn't work what the compiler does",
    "start": "2154410",
    "end": "2160859"
  },
  {
    "text": "again is create a defensive copy for you so that's great it's kept it read own it kept it fine but we've got another copy",
    "start": "2160859",
    "end": "2166859"
  },
  {
    "text": "going on and interestingly you could then try well perhaps I can cheat",
    "start": "2166859",
    "end": "2172380"
  },
  {
    "text": "perhaps I can pass that in parameter in as a ref so then it becomes in out and",
    "start": "2172380",
    "end": "2178230"
  },
  {
    "text": "modifiable and all that and they fortunately compilers thought of that it doesn't like it and it gives you a",
    "start": "2178230",
    "end": "2184559"
  },
  {
    "text": "compile time error so you can't do that and now if we run these tests we'll see",
    "start": "2184559",
    "end": "2189660"
  },
  {
    "text": "that all those assumptions are also true and we're still green did that run yeah",
    "start": "2189660",
    "end": "2195450"
  },
  {
    "text": "there they are so we're still green there and everything we've tried to do so far is good but I gives us a bit of a",
    "start": "2195450",
    "end": "2205170"
  },
  {
    "start": "2203000",
    "end": "2808000"
  },
  {
    "text": "problem because we're trying to do all these things to pass things around by reference and it's working it's great",
    "start": "2205170",
    "end": "2212220"
  },
  {
    "text": "we've got a whole bunch of compile time errors which is useful but if I call a method on it I'm getting a defensive",
    "start": "2212220",
    "end": "2218460"
  },
  {
    "text": "copy well how do I stop that how do I you know I want to try and avoid some of these copies happening how do I avoid",
    "start": "2218460",
    "end": "2224700"
  },
  {
    "text": "that and there's another feature another little building block which we've got here which is the read-only struct and",
    "start": "2224700",
    "end": "2232289"
  },
  {
    "text": "this is to tell the compiler basically that this structure is read-only it's",
    "start": "2232289",
    "end": "2238049"
  },
  {
    "text": "safe to call methods on it because it calling a method is not going to modify the state it's not going to mutate the",
    "start": "2238049",
    "end": "2244079"
  },
  {
    "text": "the value type itself so that makes the the type itself immutable and this is",
    "start": "2244079",
    "end": "2252180"
  },
  {
    "text": "this is great because now all there's going to be no copies being made anywhere we can pass things around by reference we can call method",
    "start": "2252180",
    "end": "2257790"
  },
  {
    "text": "we can have compile time errors and basically we've now got the best of both worlds and if we have a quick look at",
    "start": "2257790",
    "end": "2266040"
  },
  {
    "text": "this one we've got a read-only struct again I've got my point class here but",
    "start": "2266040",
    "end": "2271890"
  },
  {
    "text": "I've added the the read-only keyword to the definition so it's now a read-only struct of points and now the compiler is",
    "start": "2271890",
    "end": "2279600"
  },
  {
    "text": "going to enforce security here so if I have a mutable type here a mutable value",
    "start": "2279600",
    "end": "2285420"
  },
  {
    "text": "here the compiler gives me a warning and it tells me that you can't do this it has to be immutable so we need read-only",
    "start": "2285420",
    "end": "2291810"
  },
  {
    "text": "going on there and then that's great because now I actually can't even write my translate in place code because I get",
    "start": "2291810",
    "end": "2298650"
  },
  {
    "text": "errors the compiler enforces this because it's read-only it's immutable so that problem goes away and if we have",
    "start": "2298650",
    "end": "2307860"
  },
  {
    "text": "our value here where we try and get our points so I've got the point going on here again read-only reference types",
    "start": "2307860",
    "end": "2313950"
  },
  {
    "text": "being returned back if I try and use it even if I sign it into a copy there I try and assign something to it I can't",
    "start": "2313950",
    "end": "2321660"
  },
  {
    "text": "it's read-only it's immutable they get compile errors and even with a reference",
    "start": "2321660",
    "end": "2327570"
  },
  {
    "text": "read-only read-only reference sorry it's using the same object but it's it's",
    "start": "2327570",
    "end": "2333360"
  },
  {
    "text": "read-only and it's immutable I get compile time errors and if I try and call a method on that well I can't I",
    "start": "2333360",
    "end": "2340200"
  },
  {
    "text": "can't even define the method because it's immutable so it's no good so it's not even worth running those tests",
    "start": "2340200",
    "end": "2346440"
  },
  {
    "text": "because I can't compile so this is great more efficient got no copies made when",
    "start": "2346440",
    "end": "2352080"
  },
  {
    "text": "calling members we can pass things around without calling members and this is great for throughput performance and",
    "start": "2352080",
    "end": "2358050"
  },
  {
    "text": "so on but again this is these are all sort of micro optimizations but they can",
    "start": "2358050",
    "end": "2363060"
  },
  {
    "text": "add up in critical code paths the other key thing here is that there are no changes to the CLR so all of these",
    "start": "2363060",
    "end": "2368970"
  },
  {
    "text": "features have been added just to the language this has already been this has been previously supported by the CLR all",
    "start": "2368970",
    "end": "2375270"
  },
  {
    "text": "along and I was just exposed by c-sharp so we can make use of this anywhere and everywhere alright one last building",
    "start": "2375270",
    "end": "2384750"
  },
  {
    "text": "block which is really useful here this is this is one which looks odd on the",
    "start": "2384750",
    "end": "2390030"
  },
  {
    "text": "face of it but he's really useful come back to it shortly this is a ref struct this is the",
    "start": "2390030",
    "end": "2397470"
  },
  {
    "text": "ability to declare a value type that can only be stacked allocated you can't allocate it anywhere else you can't",
    "start": "2397470",
    "end": "2403290"
  },
  {
    "text": "embed it as part of another object so you couldn't have a person which contains one of these ref structs and",
    "start": "2403290",
    "end": "2408980"
  },
  {
    "text": "you can only allocate it understand the stack so this constrains the lifetime of",
    "start": "2408980",
    "end": "2414990"
  },
  {
    "text": "these value types it also means they can't be boxed they can't use them inside another struct if that struct is",
    "start": "2414990",
    "end": "2422190"
  },
  {
    "text": "not also a ref struct I can't use it with async methods or iterators can't be",
    "start": "2422190",
    "end": "2427560"
  },
  {
    "text": "users of generic parameters there's a whole bunch of limitations to it it doesn't really kind of make sense as to why you would do that and there are very",
    "start": "2427560",
    "end": "2434579"
  },
  {
    "text": "limited to use cases for this so one of which is using stack alec and that's",
    "start": "2434579",
    "end": "2440369"
  },
  {
    "text": "just a way of allocating a block of memory on your stack but the big reason is for span of T which is a new type",
    "start": "2440369",
    "end": "2448230"
  },
  {
    "text": "which has been around it's actually run for a little while but it's it's a very useful type which is all about reducing",
    "start": "2448230",
    "end": "2457530"
  },
  {
    "text": "the amount of allocations you get and this is where things start to get useful for you as an application developer so",
    "start": "2457530",
    "end": "2465270"
  },
  {
    "text": "span of T is it's a new type really to unify working with any kind of contiguous memory any block of of memory",
    "start": "2465270",
    "end": "2472920"
  },
  {
    "text": "so if you've got like a nice big block of memory like an array or a string which is using one long self-contained",
    "start": "2472920",
    "end": "2480660"
  },
  {
    "text": "block of memory it's really useful for working with that also useful for working with array segments so chunks of",
    "start": "2480660",
    "end": "2486450"
  },
  {
    "text": "an array or sub strings also good for native memory and for memory allocated",
    "start": "2486450",
    "end": "2493440"
  },
  {
    "text": "on the stack with a stack our keyword and basically it provides an array like API for working with this this block of",
    "start": "2493440",
    "end": "2502050"
  },
  {
    "text": "memory so it looks like indexes basically you've got a get and a set you've got the index over the square",
    "start": "2502050",
    "end": "2507690"
  },
  {
    "text": "brackets you've got you know getting set methods and so on and there's also a read-only span of T type which is",
    "start": "2507690",
    "end": "2513960"
  },
  {
    "text": "read-only and you've only got getters it's also type safe so each element in",
    "start": "2513960",
    "end": "2519900"
  },
  {
    "text": "this array this block of memory which you're going to start treating like an array is typesafe it is an instance of tea so",
    "start": "2519900",
    "end": "2527760"
  },
  {
    "text": "if you have a span of bite then each element in there is gonna be a bite if you have a span of point Ito into that",
    "start": "2527760",
    "end": "2533160"
  },
  {
    "text": "is going to be a point structure and the nice thing about this is that you get",
    "start": "2533160",
    "end": "2538830"
  },
  {
    "text": "array like performance so it's not quite as fast as an array but it's really close and the newer runtimes have",
    "start": "2538830",
    "end": "2546060"
  },
  {
    "text": "special support built into this to make it really close so it is it's very good this is a great way of working with",
    "start": "2546060",
    "end": "2551340"
  },
  {
    "text": "blocks of memory like arrays and have the same sort of performance and api's",
    "start": "2551340",
    "end": "2557520"
  },
  {
    "text": "as arrays but one of the key things one of the really really useful things the",
    "start": "2557520",
    "end": "2562620"
  },
  {
    "text": "span of tea is is slicing you can create a new span of tea which is a subsection of an existing span so if you're talking",
    "start": "2562620",
    "end": "2570030"
  },
  {
    "text": "like you've got a block of memory which is going to be a string you can get a substring out of that by pulling out a span which is just that section there",
    "start": "2570030",
    "end": "2577200"
  },
  {
    "text": "and all of this is without allocations",
    "start": "2577200",
    "end": "2583370"
  },
  {
    "text": "so if we're talking the saying that it's without allocations that means it's a value type yes it is it's great it's",
    "start": "2583370",
    "end": "2590010"
  },
  {
    "text": "available as a new get package for donek standard 1.1 which means Donna frame at",
    "start": "2590010",
    "end": "2596490"
  },
  {
    "text": "4.5 and above it's built into the lost track if it's built into the darknet",
    "start": "2596490",
    "end": "2602490"
  },
  {
    "text": "standard it's built into dotnet core 2.1 and above i think it's in the standard I",
    "start": "2602490",
    "end": "2607680"
  },
  {
    "text": "forget now but there's also a whole load of new api's and overloads for working",
    "start": "2607680",
    "end": "2613830"
  },
  {
    "text": "with with span so you can convert a string to a span or you can have streams",
    "start": "2613830",
    "end": "2619920"
  },
  {
    "text": "that return as it's a return but a block of an array of bytes you can return a",
    "start": "2619920",
    "end": "2627000"
  },
  {
    "text": "span and also then for parsing blocks of text so utf-8 powers of converting a",
    "start": "2627000",
    "end": "2633060"
  },
  {
    "text": "string into into utf-8 text and the",
    "start": "2633060",
    "end": "2638490"
  },
  {
    "text": "whole point of this is that makes a huge amount of use of all the ref semantics stuff we've just been talking about to",
    "start": "2638490",
    "end": "2643740"
  },
  {
    "text": "get a whole load of allocation free stuff going through and it's really a handful of types we've got span of T",
    "start": "2643740",
    "end": "2650250"
  },
  {
    "text": "read-only span of T which we've already mentioned there's also memory of T which is a interesting one it allows you to",
    "start": "2650250",
    "end": "2657120"
  },
  {
    "text": "work with I work around the user so the limitations of span of t being a struct",
    "start": "2657120",
    "end": "2664360"
  },
  {
    "text": "and I'll talk a bit more out in a sec they're also two versions so on more",
    "start": "2664360",
    "end": "2672040"
  },
  {
    "text": "downlevel versions of the dotnet framework then there are there's a",
    "start": "2672040",
    "end": "2678730"
  },
  {
    "text": "portable version and then there is effectively a fast version the fast version requires runtime support but",
    "start": "2678730",
    "end": "2685030"
  },
  {
    "text": "it's kind of important to say really that the portable version is not slow you get it's not as fast as a raise but",
    "start": "2685030",
    "end": "2691540"
  },
  {
    "text": "it's still good so it's just as portable doesn't mean it's slow so this works on",
    "start": "2691540",
    "end": "2696880"
  },
  {
    "text": "donna framework 4.5 and above as part of the donít standard 1.1 which is old now",
    "start": "2696880",
    "end": "2703150"
  },
  {
    "text": "and with dotnet core 3 and dotnet 5 could mean anything but the the",
    "start": "2703150",
    "end": "2711370"
  },
  {
    "text": "implementation of this one really is that this span of T has three fields you have the object reference to the big",
    "start": "2711370",
    "end": "2717910"
  },
  {
    "text": "block of memory you have an internal offset for where it starts and in the length so you know where it is there so",
    "start": "2717910",
    "end": "2723640"
  },
  {
    "text": "this is actually slightly larger than the fast version but the difference is like slightly there so dereferencing values is slightly more complex because",
    "start": "2723640",
    "end": "2731950"
  },
  {
    "text": "you got to go to the start add on the offset and then work with that but that's fine and easy the fast",
    "start": "2731950",
    "end": "2738370"
  },
  {
    "text": "implementation requires runtime support and this is a dotnet core 2.1 and above and the runtime recognizes this type",
    "start": "2738370",
    "end": "2745330"
  },
  {
    "text": "this only has two fields it has a special by ref internal pointer so you've got this block of memory and the",
    "start": "2745330",
    "end": "2751630"
  },
  {
    "text": "span says I start there so it doesn't have to start the beginning account it knows exactly where to start",
    "start": "2751630",
    "end": "2756760"
  },
  {
    "text": "and it knows the length which means thing getting at the values is slightly faster slightly simpler and and",
    "start": "2756760",
    "end": "2763750"
  },
  {
    "text": "therefore slightly better performance but more importantly the runtime knows",
    "start": "2763750",
    "end": "2769360"
  },
  {
    "text": "this type and it has specific optimizations in the dips to get rid of a few things in the same way it does with arrays so",
    "start": "2769360",
    "end": "2776620"
  },
  {
    "text": "for example when working with arrays the runtime the Donette frame at runtime",
    "start": "2776620",
    "end": "2782110"
  },
  {
    "text": "direct core runtime recognizes that you're iterating over an array and it",
    "start": "2782110",
    "end": "2787570"
  },
  {
    "text": "gets rid of the bounds checks for each array access so he knows you're going from 1 to 10",
    "start": "2787570",
    "end": "2793750"
  },
  {
    "text": "and he doesn't have to do a bounced check on every single one of those the",
    "start": "2793750",
    "end": "2799600"
  },
  {
    "text": "run time can do the same thing for span of T and that then gives you very very close to array like performance so what",
    "start": "2799600",
    "end": "2809440"
  },
  {
    "start": "2808000",
    "end": "3088000"
  },
  {
    "text": "does this have to do with ref structs I was talking about that and as building blocks and all this where does all that fit in well because we've got these",
    "start": "2809440",
    "end": "2816130"
  },
  {
    "text": "these fields inside the span of T we kind of have to update everything all at once for thread safety so we have to do",
    "start": "2816130",
    "end": "2822460"
  },
  {
    "text": "all sort of atomically if we only did one part of the the thing without doing the other we would break a be horrible",
    "start": "2822460",
    "end": "2828100"
  },
  {
    "text": "and nasty and the whole point of this type is performance so we can't put locks and synchronization around it",
    "start": "2828100",
    "end": "2834220"
  },
  {
    "text": "there because that defeats the purpose there are other reasons as well is that",
    "start": "2834220",
    "end": "2839650"
  },
  {
    "text": "this by ref pointer into the middle of an object requires special tracking",
    "start": "2839650",
    "end": "2844660"
  },
  {
    "text": "inside the garbage collector having too many of those on the go at any time can get expensive but if you reduce the",
    "start": "2844660",
    "end": "2850000"
  },
  {
    "text": "amount of them then it's manageable also if you want span of T to allocate",
    "start": "2850000",
    "end": "2855340"
  },
  {
    "text": "to represent a whole bunch of different types of memory from strings to arrays to native memory to stack allocating",
    "start": "2855340",
    "end": "2862150"
  },
  {
    "text": "memory how does it deal with stack allocated memory if span atif was a class and lived on the heap because",
    "start": "2862150",
    "end": "2868810"
  },
  {
    "text": "stack allocated memory only has a constrained lifetime and the answer to",
    "start": "2868810",
    "end": "2873820"
  },
  {
    "text": "all of those questions really is that span of T is a ref struct and by putting all those constraints which we had for",
    "start": "2873820",
    "end": "2880120"
  },
  {
    "text": "refs trucks on span of T you fix all of those problems it can only be created on the stack so you don't have to worry",
    "start": "2880120",
    "end": "2885220"
  },
  {
    "text": "about thread safety anymore because on the stack it can only be called from one method you can't pass it around because",
    "start": "2885220",
    "end": "2890440"
  },
  {
    "text": "it's it's it's got constrained access and you don't have to worry about the",
    "start": "2890440",
    "end": "2897160"
  },
  {
    "text": "number of garbage plates and a garbage collector handles going on there as well because you're only gonna have a limited",
    "start": "2897160",
    "end": "2902350"
  },
  {
    "text": "number of those thanks to the core stack okay so let's have a quick look at this",
    "start": "2902350",
    "end": "2911970"
  },
  {
    "text": "so I have another set of tests here of using this now I've got this added as a",
    "start": "2911970",
    "end": "2918900"
  },
  {
    "text": "as a new get package so I've got my packages there I have",
    "start": "2918900",
    "end": "2924490"
  },
  {
    "text": "oh no sorry I'm using this is a dotnet kora have I forgot yes I was done in collab so it's part of the.net core API",
    "start": "2924490",
    "end": "2931660"
  },
  {
    "text": "itself and so I'm just using that and I get to use my string dot as span so I've",
    "start": "2931660",
    "end": "2939430"
  },
  {
    "text": "got extension method here which is going to convert my string which is a constant defined at the top of the class there convert into a span and I sign it here",
    "start": "2939430",
    "end": "2946450"
  },
  {
    "text": "now to a read-only span of char and from here I can do a bunch of things that you would normally expect to do with with",
    "start": "2946450",
    "end": "2953470"
  },
  {
    "text": "strings basically I can treat it in the same way I can check the span of the spans length is correct I can do",
    "start": "2953470",
    "end": "2960190"
  },
  {
    "text": "equality with another string so I can do string comparisons based on this span comparing it to another string and I can",
    "start": "2960190",
    "end": "2967810"
  },
  {
    "text": "do that string comparison with the same sort of invariant culture ignoring case and so on because thanks to these",
    "start": "2967810",
    "end": "2974170"
  },
  {
    "text": "extension methods I can even do things like starts with make sure that it's it starts with the appropriate values I've",
    "start": "2974170",
    "end": "2983410"
  },
  {
    "text": "got another test now which will create a slice so again one of the benefits of",
    "start": "2983410",
    "end": "2988420"
  },
  {
    "text": "having span in fact the best benefit of it is being able to slice and pull data out without having to allocate anything",
    "start": "2988420",
    "end": "2994450"
  },
  {
    "text": "and so if I call slice of six there I can then confirm with a call to equals",
    "start": "2994450",
    "end": "3000839"
  },
  {
    "text": "that have actually got a value here which is what I would expect and I can",
    "start": "3000839",
    "end": "3007950"
  },
  {
    "text": "do a similar sort of thing here with arrays as well so I have my numbers array at the top here it's just a set of",
    "start": "3007950",
    "end": "3013859"
  },
  {
    "text": "arrays of one to ten I can create a span out of that I don't have to call as span",
    "start": "3013859",
    "end": "3020670"
  },
  {
    "text": "here there's an implicit conversion so that's nice I can just treat an array as a span without having to do anything I",
    "start": "3020670",
    "end": "3027020"
  },
  {
    "text": "can then slice it I can start at three and go forever for length of five and if I change that element there inside my",
    "start": "3027020",
    "end": "3033990"
  },
  {
    "text": "slice I can then confirm that actually it's going to be this value here inside the main array and so if I run these",
    "start": "3033990",
    "end": "3041970"
  },
  {
    "text": "tests we should see then that's again those assumptions will go green and then",
    "start": "3041970",
    "end": "3048930"
  },
  {
    "text": "the best thing is that it's all allocation free as well so I've got another test here which is first of all",
    "start": "3048930",
    "end": "3056190"
  },
  {
    "text": "getting the current amount of memory I then make sure that I'm not allowed to do any garbage collection inside this",
    "start": "3056190",
    "end": "3061469"
  },
  {
    "text": "area I call all of those tests explicitly and then I just assert that",
    "start": "3061469",
    "end": "3067589"
  },
  {
    "text": "zero memory was allocated there there was no change there I I change there so",
    "start": "3067589",
    "end": "3073979"
  },
  {
    "text": "this is kind like a very crude way of checking to see that there's no allocations happening at that point and",
    "start": "3073979",
    "end": "3080459"
  },
  {
    "text": "so we can see now that we can do all of these things create slices and change values and all of that without",
    "start": "3080459",
    "end": "3085979"
  },
  {
    "text": "allocating any extra memory all right so",
    "start": "3085979",
    "end": "3091769"
  },
  {
    "start": "3088000",
    "end": "3208000"
  },
  {
    "text": "that's great span of T is is really useful and I can probably see a number of useful ways of doing that and what",
    "start": "3091769",
    "end": "3098369"
  },
  {
    "text": "about some of real-world usage is from something else very handily a couple of days ago Microsoft announced a preview",
    "start": "3098369",
    "end": "3104459"
  },
  {
    "text": "of system text Jason this is a new library which they're using which",
    "start": "3104459",
    "end": "3111299"
  },
  {
    "text": "they're introducing to do Jason series ation and deserialization for the.net platform this is to effectively",
    "start": "3111299",
    "end": "3118769"
  },
  {
    "text": "decoupled Jason net from the platform because if the problem is the platform currently relies on Jason net and it",
    "start": "3118769",
    "end": "3125549"
  },
  {
    "text": "relies in a particular version of Jason net which means that you can't update it without updating your platform and your",
    "start": "3125549",
    "end": "3131430"
  },
  {
    "text": "application version this mismatch and so if there's problems there they also want",
    "start": "3131430",
    "end": "3136859"
  },
  {
    "text": "something which is better from a performance point of view you know making use of some of these new API s",
    "start": "3136859",
    "end": "3141869"
  },
  {
    "text": "and and so basically they've introduced a new a new library so the whole point",
    "start": "3141869",
    "end": "3149789"
  },
  {
    "text": "of this is that it uses as part of what it does it uses span of T to be able to to work with things be able to parse",
    "start": "3149789",
    "end": "3156059"
  },
  {
    "text": "things without having to introduce a whole load of new allocations and it's optimized for the things you'd expect to",
    "start": "3156059",
    "end": "3161940"
  },
  {
    "text": "use Jason for in in real life and web service and generally you'll work with",
    "start": "3161940",
    "end": "3167249"
  },
  {
    "text": "utf-8 rather than utf-16 which is the actual encoding that the string type",
    "start": "3167249",
    "end": "3172859"
  },
  {
    "text": "uses and so normally you would have to read everything in convert it to utf-16 and work on that but what system text",
    "start": "3172859",
    "end": "3179969"
  },
  {
    "text": "Jason can do is read in a set of bytes from the file treat those as utf-8 right",
    "start": "3179969",
    "end": "3187349"
  },
  {
    "text": "over by putting it all into one big span and work with that span to things and match things and get data",
    "start": "3187349",
    "end": "3196480"
  },
  {
    "text": "without allocating anything they're having to allocate any strings this is going to be part of dotnet core 3 and",
    "start": "3196480",
    "end": "3203260"
  },
  {
    "text": "right now there is a preview NuGet package which you can download and try and use the blog post which they have",
    "start": "3203260",
    "end": "3210730"
  },
  {
    "start": "3208000",
    "end": "3275000"
  },
  {
    "text": "has some micro benchmarks against Jason net and you can see here now where these",
    "start": "3210730",
    "end": "3217839"
  },
  {
    "text": "kinds of things can start really pay off so in the the benchmarks that they've used there so deserialization can be two",
    "start": "3217839",
    "end": "3224230"
  },
  {
    "text": "times faster because of reduce of better throughput basically see rosette",
    "start": "3224230",
    "end": "3231550"
  },
  {
    "text": "serialization can also be faster but getting at the document using the document object model writing and",
    "start": "3231550",
    "end": "3239260"
  },
  {
    "text": "reading these can actually be more or less allocation free and the more or less is because the way that they've",
    "start": "3239260",
    "end": "3245920"
  },
  {
    "text": "implemented things is that there are some allocations happening so for example when you read data in you have to put it into a byte array but some of",
    "start": "3245920",
    "end": "3253270"
  },
  {
    "text": "these things are pulled an object pulled so if you ignore the overhead of the",
    "start": "3253270",
    "end": "3258760"
  },
  {
    "text": "those pools for the object arrays sorry the byte arrays then you don't get any",
    "start": "3258760",
    "end": "3264130"
  },
  {
    "text": "actual allocations for the objects themselves until you then try so for example you read it you want to get a",
    "start": "3264130",
    "end": "3270220"
  },
  {
    "text": "string value out that will then allocate you a string and again you can see now",
    "start": "3270220",
    "end": "3278680"
  },
  {
    "text": "where this throughput really helps with again from the blog post from the other",
    "start": "3278680",
    "end": "3283900"
  },
  {
    "text": "day talking about Jason D serialization and serialization you can see the",
    "start": "3283900",
    "end": "3289000"
  },
  {
    "text": "requests per second figures for the difference between Jason nets and system text Jason you're actually getting a",
    "start": "3289000",
    "end": "3297069"
  },
  {
    "text": "real-world improvements there you're getting better requests / responses per second memory",
    "start": "3297069",
    "end": "3303790"
  },
  {
    "text": "usage is is not so dramatically different but the actual the throughput",
    "start": "3303790",
    "end": "3311589"
  },
  {
    "text": "itself is and we can have a very quick",
    "start": "3311589",
    "end": "3316750"
  },
  {
    "text": "look that's something here so if we have",
    "start": "3316750",
    "end": "3322020"
  },
  {
    "text": "a little bit of code here for example we can parse the value here before you pass",
    "start": "3322020",
    "end": "3328529"
  },
  {
    "text": "in a string we can parse that and pull that out into adjacent document so now can I got a Dom value here I can then",
    "start": "3328529",
    "end": "3335460"
  },
  {
    "text": "have that will allocate that's going to allocate my byte array to read the values it's gonna have some allocations",
    "start": "3335460",
    "end": "3341789"
  },
  {
    "text": "going on there those allocations are pulled so we're making use of the sort of the object reuse which we're talking previously with the low-hanging fruit",
    "start": "3341789",
    "end": "3348180"
  },
  {
    "text": "stuff and but now if I wanted to enumerate that object model I can use",
    "start": "3348180",
    "end": "3353940"
  },
  {
    "text": "this enumerate array value and have a look at how that works if I go to the",
    "start": "3353940",
    "end": "3360089"
  },
  {
    "text": "type of that we can see that's let me do that again sorry so if you go to",
    "start": "3360089",
    "end": "3365849"
  },
  {
    "text": "enumerate array we see that that returns back an array in numerator which is a struct so this is great I'm going to",
    "start": "3365849",
    "end": "3371849"
  },
  {
    "text": "return back in a numerator which is a struct so there's not gonna be much allocations going on there and if we",
    "start": "3371849",
    "end": "3377520"
  },
  {
    "text": "have a look at jason element here we see that that is also a struct so we're working with value types and having to",
    "start": "3377520",
    "end": "3385109"
  },
  {
    "text": "we're avoiding allocations going on here if I very quickly step in to get",
    "start": "3385109",
    "end": "3391289"
  },
  {
    "text": "property and try get property we then see that we're converting this into a",
    "start": "3391289",
    "end": "3396539"
  },
  {
    "text": "spam so we get the looking for a particular property with a name which is a string we convert that into a spam and",
    "start": "3396539",
    "end": "3403349"
  },
  {
    "text": "when we passed it this in here let's see if we can find the right bit of code no",
    "start": "3403349",
    "end": "3410400"
  },
  {
    "text": "that's the wrong bit of code we're working with spans there so we get to use those spans going on internally if",
    "start": "3410400",
    "end": "3416579"
  },
  {
    "text": "we have a look at the getting an integer and if we step into that a couple of times cause gets which finally calls",
    "start": "3416579",
    "end": "3428460"
  },
  {
    "text": "this we can see here that what we're doing to get the actual value is that we",
    "start": "3428460",
    "end": "3434069"
  },
  {
    "text": "are finding out where this particular property lives with a location and a",
    "start": "3434069",
    "end": "3439289"
  },
  {
    "text": "length and then we use a slice on the original string that we've got to get",
    "start": "3439289",
    "end": "3445020"
  },
  {
    "text": "that particular bit of text there so we're using slices to get at the value which we can then decode and return back",
    "start": "3445020",
    "end": "3450690"
  },
  {
    "text": "and because this is returning back an integer value then we're going to be able to do all of that without allocate anything which is pretty nifty so yes so",
    "start": "3450690",
    "end": "3461630"
  },
  {
    "text": "that entire loop there won't allocate anything which is very nice so I can work with a document object model",
    "start": "3461630",
    "end": "3467859"
  },
  {
    "text": "without allocations which brings me to the end so then that really is",
    "start": "3467859",
    "end": "3474019"
  },
  {
    "start": "3471000",
    "end": "3600000"
  },
  {
    "text": "everything that I wanted to show you there's a reasons for wanting to reduce the number of allocations we do is all",
    "start": "3474019",
    "end": "3480349"
  },
  {
    "text": "about throughput all about reducing the amount of memory we're using the amount of memory traffic that's happening so",
    "start": "3480349",
    "end": "3485569"
  },
  {
    "text": "that we can reduce the number of garbage collections improve throughput and hopefully then that will improve",
    "start": "3485569",
    "end": "3490789"
  },
  {
    "text": "performance for us as well key thing is profiling these are all",
    "start": "3490789",
    "end": "3496180"
  },
  {
    "text": "micro optimizations but they can't have a very big impact as we saw with the the",
    "start": "3496180",
    "end": "3501260"
  },
  {
    "text": "benchmarks therefore the responses for a second and there are a number of ways of",
    "start": "3501260",
    "end": "3507440"
  },
  {
    "text": "doing this that we obviously look at some of the low-hanging fruit there but there's also a number of interesting building blocks with value types passing",
    "start": "3507440",
    "end": "3514069"
  },
  {
    "text": "those around by reference and being able to enforce safety of making them",
    "start": "3514069",
    "end": "3519589"
  },
  {
    "text": "immutable and so we can't change them and working with that that code there and finally span of takes parity is",
    "start": "3519589",
    "end": "3526700"
  },
  {
    "text": "really really useful and something that you are likely to use in your own code if you need to do any kind of pausing or",
    "start": "3526700",
    "end": "3532670"
  },
  {
    "text": "serialization yourself and to be able to get it data there without how to allocate anything these are some very",
    "start": "3532670",
    "end": "3539210"
  },
  {
    "text": "useful links which have details about it there so the first one is Microsoft's",
    "start": "3539210",
    "end": "3544250"
  },
  {
    "text": "documentation for this features these features which explains what's going on with the reference semantics more detail",
    "start": "3544250",
    "end": "3550670"
  },
  {
    "text": "about the span of T some really good sort of blog post there explaining how span of T works how the runtime has",
    "start": "3550670",
    "end": "3557569"
  },
  {
    "text": "optimizations for it and then also there's a great post on how value tasks",
    "start": "3557569",
    "end": "3563390"
  },
  {
    "text": "works and when and why you would want to use it there there are some really good use cases for avoiding allocating tasks",
    "start": "3563390",
    "end": "3570680"
  },
  {
    "text": "and task of T and using value tasks instead and finally there's the system",
    "start": "3570680",
    "end": "3576380"
  },
  {
    "text": "text JSON blog post from a few days ago there which is describing this new API and some of the details around out and",
    "start": "3576380",
    "end": "3583670"
  },
  {
    "text": "finally if you want to get some of the the test always running today the sample code there is",
    "start": "3583670",
    "end": "3588980"
  },
  {
    "text": "up on github in the top right hand corner I think probably out of time there if anybody has any questions and",
    "start": "3588980",
    "end": "3595490"
  },
  {
    "text": "please feel free to come down and and ask also be at the JetBrains booth so if you want to pop by and say hello then",
    "start": "3595490",
    "end": "3601910"
  },
  {
    "text": "feel free and please don't forget about the feedback cards on the way out other than that thank you very much",
    "start": "3601910",
    "end": "3607940"
  },
  {
    "text": "[Applause]",
    "start": "3607940",
    "end": "3616739"
  }
]