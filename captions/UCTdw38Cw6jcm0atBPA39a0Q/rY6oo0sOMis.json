[
  {
    "start": "0",
    "end": "102000"
  },
  {
    "text": "alright let's get started so functional programming I'm a software developer",
    "start": "9540",
    "end": "15760"
  },
  {
    "text": "software engineer working at the company called click that click I spend most of my time working with c-sharp as the",
    "start": "15760",
    "end": "22029"
  },
  {
    "text": "primary programming language but I have a background from functional languages in particular I have some experience",
    "start": "22029",
    "end": "27610"
  },
  {
    "text": "with using Haskell and it's been very interesting to learn c-sharp coming from a Haskell background because I can",
    "start": "27610",
    "end": "33700"
  },
  {
    "text": "recognize a lot of those features that I was used to using in Haskell also in c-sharp they were lacking in languages",
    "start": "33700",
    "end": "40210"
  },
  {
    "text": "like C++ at the time when I joined but there are been a lot of talks at this conference I know about introduction to",
    "start": "40210",
    "end": "46899"
  },
  {
    "text": "functional programs know that this will sort on that topic but what I'll be doing is I'll be talking about two",
    "start": "46899",
    "end": "52539"
  },
  {
    "text": "specific features so c-sharp in particular name with tuples and pattern matching and I will show you how those",
    "start": "52539",
    "end": "58749"
  },
  {
    "text": "features have been used in in Haskell because those have been part of Haskell since the beginning which was 89 so it's",
    "start": "58749",
    "end": "66070"
  },
  {
    "text": "pretty older and they are very much a native part of the toolkit you have when you're when you're working with Haskell",
    "start": "66070",
    "end": "72390"
  },
  {
    "text": "and something special happens when you take a feature and move it into a language because you can use a certain",
    "start": "72390",
    "end": "78759"
  },
  {
    "text": "type of pattern based on those features in a very different way than you can if there are part of the part of the",
    "start": "78759",
    "end": "84070"
  },
  {
    "text": "language of the library or something like that to put some pattern matching were introduced in c-sharp seven two or",
    "start": "84070",
    "end": "90189"
  },
  {
    "text": "three years ago not remember exactly but let's start I'll just give a brief",
    "start": "90189",
    "end": "95219"
  },
  {
    "text": "repetition hopefully of what these features are so tuples everybody know where to please hope so at least yeah so",
    "start": "95219",
    "end": "102670"
  },
  {
    "start": "102000",
    "end": "269000"
  },
  {
    "text": "basically synonymous datatype that allows you to to group values of of any",
    "start": "102670",
    "end": "109750"
  },
  {
    "text": "type into a certain entity and just give a small example here this is from the",
    "start": "109750",
    "end": "114909"
  },
  {
    "text": "standard maths library of c-sharp we have the function div ramp which take dividend and the divisor and it produces",
    "start": "114909",
    "end": "121960"
  },
  {
    "text": "what you get when you divide those numbers as an integer and also produces the reminder now this is conceptually a",
    "start": "121960",
    "end": "127929"
  },
  {
    "text": "function that returns two values right and back in the days when C sharp",
    "start": "127929",
    "end": "132970"
  },
  {
    "text": "started there was no such thing as tuple so the way you would do this if you want to return two values was either to have",
    "start": "132970",
    "end": "139810"
  },
  {
    "text": "an out parameter like they did here or you would have to have some sort of structure that you were done which will",
    "start": "139810",
    "end": "145750"
  },
  {
    "text": "give some Allred and they chose this part for them but using a tuple and there's been a tuple library available",
    "start": "145750",
    "end": "151180"
  },
  {
    "text": "c-sharp for quite a while you could do something like this you could instead of having a out parameter we could return",
    "start": "151180",
    "end": "157240"
  },
  {
    "text": "an instance of this class a tuple which contains two ins or we C sub seven you",
    "start": "157240",
    "end": "164290"
  },
  {
    "text": "can refer to it like this so we can just use parent theses to construct a tuple like this it's very nice convenient now",
    "start": "164290",
    "end": "172060"
  },
  {
    "text": "one thing is to define this and we will define our a wrapper basically for this",
    "start": "172060",
    "end": "177670"
  },
  {
    "text": "dimmer different function by doing something like this so we want to have a div ram the returns a tuple of this type",
    "start": "177670",
    "end": "183190"
  },
  {
    "text": "what we'll do is basically we will call our div I'm and wrap those two functions",
    "start": "183190",
    "end": "188530"
  },
  {
    "text": "or two values as as a tuple like this so we can construct them very easily as",
    "start": "188530",
    "end": "194860"
  },
  {
    "text": "well without a lot of syntax for doing that we just prep them in parantesis all",
    "start": "194860",
    "end": "200230"
  },
  {
    "text": "this is nice and a good syntactic sugar but the interesting thing comes when you want to consume these tuples because",
    "start": "200230",
    "end": "205270"
  },
  {
    "text": "that's where it's it differs so if I want to say write a function that does",
    "start": "205270",
    "end": "210730"
  },
  {
    "text": "something like this it's supposed to take a dividend and divisor and it's goes to print the result of that",
    "start": "210730",
    "end": "216190"
  },
  {
    "text": "operation in a nice way so in this case if you provide the values 3 and 13 and 5",
    "start": "216190",
    "end": "221290"
  },
  {
    "text": "then we should print 2 and 3/5 the way we do this done is that we would call",
    "start": "221290",
    "end": "227620"
  },
  {
    "text": "our div ramp function which returns a tuple we can immediately deconstruct the",
    "start": "227620",
    "end": "233290"
  },
  {
    "text": "value is coming from that function into this tuple so instead of going we have this extra name where we have to",
    "start": "233290",
    "end": "238870"
  },
  {
    "text": "associate names to the inner porch we just get can deconstruct that and get those names immediately now we can just",
    "start": "238870",
    "end": "244930"
  },
  {
    "text": "use them in our function like this and also give a lot example how this is used in haskell for all sorts of things not",
    "start": "244930",
    "end": "251500"
  },
  {
    "text": "just trivial things like this it has some interesting consequences that you might not think of because there's one",
    "start": "251500",
    "end": "256600"
  },
  {
    "text": "other thing when a feature comes into a language you look at it say here yeah that's nice syntactic sugar but",
    "start": "256600",
    "end": "261760"
  },
  {
    "text": "sometimes it's more to it because it enables some patterns that you are not used to that's tuples second thing is pattern",
    "start": "261760",
    "end": "268960"
  },
  {
    "text": "matching pattern matching is little harder to explain but I'll give a quick example of this as well so imagine that",
    "start": "268960",
    "end": "275140"
  },
  {
    "start": "269000",
    "end": "353000"
  },
  {
    "text": "you have function called compute area it's actually taken from Microsoft's description of pattern matching so we",
    "start": "275140",
    "end": "284320"
  },
  {
    "text": "get an object as an argument and we are going to compute the area that object based on what type address so if it's a",
    "start": "284320",
    "end": "291190"
  },
  {
    "text": "square with right B Square then we have to type cost at shape to a square at",
    "start": "291190",
    "end": "296440"
  },
  {
    "text": "which point we get this handle now we can access properties of the square brace on the side so we can produce the",
    "start": "296440",
    "end": "302320"
  },
  {
    "text": "area here if it's a circle then we have to typecast it to a circle and then we",
    "start": "302320",
    "end": "307540"
  },
  {
    "text": "can ask is the radius which of course it's appropriate circle has but that the square doesn't and so on and this is",
    "start": "307540",
    "end": "314170"
  },
  {
    "text": "also a so a pattern that you'll be using for traversing data structures like this",
    "start": "314170",
    "end": "319330"
  },
  {
    "text": "where you need to know well you don't know what the object type is but you have to sort of do some some type",
    "start": "319330",
    "end": "325480"
  },
  {
    "text": "costing on this this is in case this is necessary in cases where you can't have",
    "start": "325480",
    "end": "330670"
  },
  {
    "text": "this as a member function you can imagine that the shape implements and sort of object interface or something but that's not always possible",
    "start": "330670",
    "end": "336720"
  },
  {
    "text": "especially with this shape comes from a third-party library you can't just add extra functions to it just out of the",
    "start": "336720",
    "end": "343030"
  },
  {
    "text": "box and then this type of pattern can be very useful and in c-sharp 7 they",
    "start": "343030",
    "end": "349180"
  },
  {
    "text": "introduced pattern matching to capture exactly this type of patterns so with C shop 7 you can switch directly on this",
    "start": "349180",
    "end": "356020"
  },
  {
    "text": "object and then each case statements of this switch statement will be pattern",
    "start": "356020",
    "end": "361900"
  },
  {
    "text": "matching on the type of that object so I can now say if it's a square then I immediately have a handle for a square",
    "start": "361900",
    "end": "368680"
  },
  {
    "text": "and I can access its side and return that if it's a circle and I can access the circle there as well and so on for",
    "start": "368680",
    "end": "374860"
  },
  {
    "text": "rectangles or whatever so there was a quick repetitions of what these features",
    "start": "374860",
    "end": "379900"
  },
  {
    "text": "are about and I will be focusing this talk on a certain domain in that I've",
    "start": "379900",
    "end": "385720"
  },
  {
    "text": "been working on from time to time which is code generation code generation and API testing so for some reason or other",
    "start": "385720",
    "end": "393220"
  },
  {
    "start": "387000",
    "end": "450000"
  },
  {
    "text": "I've been involved with a lot of projects over the years where code generation has been an important part of what I've been doing",
    "start": "393220",
    "end": "398890"
  },
  {
    "text": "I've click where I'm working now one of the first tasks I had when I joined the company was to participate in a group",
    "start": "398890",
    "end": "405400"
  },
  {
    "text": "that were generating c-sharp code which was supposed be a layer on top of a JSON RPC protocol",
    "start": "405400",
    "end": "412480"
  },
  {
    "text": "so our tool provides as a computational engine that you can communicate using",
    "start": "412480",
    "end": "418720"
  },
  {
    "text": "small text messages in code in JSON which tells the engine what to do so compute this for me or do this for me",
    "start": "418720",
    "end": "426060"
  },
  {
    "text": "and all that is handled using using JSON which is syntactically very simple but",
    "start": "426060",
    "end": "432250"
  },
  {
    "text": "it's also very untyped it's tricky to get those messages right from time to time but in c-sharp of course if you",
    "start": "432250",
    "end": "438760"
  },
  {
    "text": "come as an c-sharp world you want to have types on things that's why we great the library that wraps all these JSON",
    "start": "438760",
    "end": "445540"
  },
  {
    "text": "RPC messages and allows us to produce them using a type structure in c-sharp so an example of a specification for one",
    "start": "445540",
    "end": "453490"
  },
  {
    "text": "of the methods we have in our product is this one so this the name of the function is called create object and it",
    "start": "453490",
    "end": "459910"
  },
  {
    "text": "takes two parameters or it takes one parameters takes us properties for this object and returns then one of these",
    "start": "459910",
    "end": "466630"
  },
  {
    "text": "objects and some other structure here this is what the one of the parts of the specification of that protocol looks",
    "start": "466630",
    "end": "472570"
  },
  {
    "text": "like for a product and we would take this file consume it analyze it and",
    "start": "472570",
    "end": "478330"
  },
  {
    "text": "figure out ok we need a function called create object and then we will use that to generate c-sharp code that would",
    "start": "478330",
    "end": "485290"
  },
  {
    "text": "basically ensure that we produced in a type safe way those jason structures that we need to pass on over the over",
    "start": "485290",
    "end": "491740"
  },
  {
    "text": "the WebSockets to this tool so one of the methods that we generate is this this is a quite low-level method in in",
    "start": "491740",
    "end": "500200"
  },
  {
    "text": "what we generate but you can see that we are picked up a lot of those parts of",
    "start": "500200",
    "end": "505210"
  },
  {
    "text": "this definition for instance we have called we have a function here called create object async this is an async",
    "start": "505210",
    "end": "511210"
  },
  {
    "text": "version of this method we also have a synchronous version of it this name of course comes directly from a",
    "start": "511210",
    "end": "516820"
  },
  {
    "text": "specification the input parameter is one of these generic object properties this",
    "start": "516820",
    "end": "523089"
  },
  {
    "text": "itself is data structure that is also defined as part of this protocol so we will be generating a lot of cost",
    "start": "523089",
    "end": "529150"
  },
  {
    "text": "structures that that encapsulate this and what this function does is that it",
    "start": "529150",
    "end": "534670"
  },
  {
    "text": "creates this request objects and here we are starting to build the actual JSON part because this will go directly into",
    "start": "534670",
    "end": "541270"
  },
  {
    "text": "the method name that we are sending over the WebSockets so here we are starting brios drinks now has anyone here done",
    "start": "541270",
    "end": "548920"
  },
  {
    "text": "any cogeneration anytime some of you yeah so first approach to doing cogeneration",
    "start": "548920",
    "end": "556330"
  },
  {
    "text": "is that if you haven't done it before it's sort of the first thing you will say is that he is just about concatenating strings and to some level",
    "start": "556330",
    "end": "563440"
  },
  {
    "text": "that is correct but if you are to produce something more complex then that",
    "start": "563440",
    "end": "568960"
  },
  {
    "text": "starts quickly to become very difficult to scale because if you're just",
    "start": "568960",
    "end": "574240"
  },
  {
    "text": "concatenate extremes and doing all of these operations then you very quickly end up in places where you have or mr.",
    "start": "574240",
    "end": "579700"
  },
  {
    "text": "Perron theis is there or you know there's a syntax error on this function there and that that debugging process",
    "start": "579700",
    "end": "585880"
  },
  {
    "text": "and turnaround time for that can be very very tricky so when we do this project",
    "start": "585880",
    "end": "590980"
  },
  {
    "text": "we were using a different technology a technology called Cottam which is a library from Microsoft senemo News code",
    "start": "590980",
    "end": "597070"
  },
  {
    "text": "on yeah some the code room is basically a library that allows you to build the",
    "start": "597070",
    "end": "603790"
  },
  {
    "text": "structures of a program without considering its syntax an example of what that would look like is if I want",
    "start": "603790",
    "end": "610210"
  },
  {
    "start": "607000",
    "end": "645000"
  },
  {
    "text": "to build this expression X plus 1 minus 1 then in code um that would be expressed like this so we create an",
    "start": "610210",
    "end": "616810"
  },
  {
    "text": "object which is a binary operator expression this takes 3 arguments it",
    "start": "616810",
    "end": "622510"
  },
  {
    "text": "takes a left value it takes an operator and takes a right value the left value in this case is the variable X so then",
    "start": "622510",
    "end": "629410"
  },
  {
    "text": "we have a code variable reference expression and the right value that's another binary operator which contains",
    "start": "629410",
    "end": "635350"
  },
  {
    "text": "primitive expression 1 and the operator subtract so what's the other wants to do",
    "start": "635350",
    "end": "641950"
  },
  {
    "text": "this well the result of using a library like this is that you build basically",
    "start": "641950",
    "end": "647290"
  },
  {
    "start": "645000",
    "end": "808000"
  },
  {
    "text": "what is called an abstract syntax tree instead of building the syntax directly you are building the structure of the",
    "start": "647290",
    "end": "653740"
  },
  {
    "text": "program that you're going to generate so we end up with a tree like this where we",
    "start": "653740",
    "end": "660190"
  },
  {
    "text": "have the binary operators we have all the Leafs now we can take this tree and now we can generate the code for that",
    "start": "660190",
    "end": "666220"
  },
  {
    "text": "for the language you want and at this point there is two ways to do this or they might more but two there I've got",
    "start": "666220",
    "end": "672940"
  },
  {
    "text": "to talk about here a first one is the object oriented approach the object-oriented approach would be to",
    "start": "672940",
    "end": "679060"
  },
  {
    "text": "leave the responsibility of doing the printing to the individual notes so we",
    "start": "679060",
    "end": "684970"
  },
  {
    "text": "will have all these nodes implement an interface or being a extension of some",
    "start": "684970",
    "end": "690550"
  },
  {
    "text": "abstract abstract class and then we could have virtual functions saying that",
    "start": "690550",
    "end": "696910"
  },
  {
    "text": "okay a binary operator needs to implement the print did self function it knows he needs to print the subtrees and",
    "start": "696910",
    "end": "702550"
  },
  {
    "text": "so on but there's a problem to that which I mentioned earlier as well it's not always possible to do that because",
    "start": "702550",
    "end": "709600"
  },
  {
    "text": "if this objects all this objects come from are from a third-party vendor then",
    "start": "709600",
    "end": "714880"
  },
  {
    "text": "it's you can't just add functions like that on the fly me at least virtual method counts be added like that easily",
    "start": "714880",
    "end": "720870"
  },
  {
    "text": "let's community role tricky and there's no disadvantage to that and that is that",
    "start": "720870",
    "end": "726550"
  },
  {
    "text": "if I want to print this tree four different languages I mean this tree here this structure of the program this",
    "start": "726550",
    "end": "734350"
  },
  {
    "text": "is really language agnostic this is the same thing for a c-sharp s4 go or a C++",
    "start": "734350",
    "end": "740709"
  },
  {
    "text": "read in Haskell the structure of the program is the same and if I want to",
    "start": "740709",
    "end": "746170"
  },
  {
    "text": "take this structure and print both the Java and c-sharp then I will need to have different functions for those",
    "start": "746170",
    "end": "752260"
  },
  {
    "text": "different languages and another way to go about doing that is to not leave that",
    "start": "752260",
    "end": "758740"
  },
  {
    "text": "responsibility to into the individual nodes but instead leave that responsibility to a function a function",
    "start": "758740",
    "end": "765940"
  },
  {
    "text": "that traverses the tree and prints it according to whatever rules you want you",
    "start": "765940",
    "end": "771700"
  },
  {
    "text": "would like so you could have one function for printing c-sharp one for printing Java one fussy for C++ and so",
    "start": "771700",
    "end": "778060"
  },
  {
    "text": "on let me the functional approach you you are disentangling responsibility of",
    "start": "778060",
    "end": "784150"
  },
  {
    "text": "what to do with the data structure from the data structure itself you separate this to those two now now I'm gonna",
    "start": "784150",
    "end": "792940"
  },
  {
    "text": "switch the Haskell how everybody here done any Haskell anytime anybody knows it quite a few you good all right so",
    "start": "792940",
    "end": "800050"
  },
  {
    "text": "I'll I'll go isn't you and if you have any questions of course you should stop me but I'll show you how to express this type of structures in Haskell so first",
    "start": "800050",
    "end": "807430"
  },
  {
    "text": "of all in Haskell you have a type of tie closer types that is sort of different",
    "start": "807430",
    "end": "812470"
  },
  {
    "start": "808000",
    "end": "1170000"
  },
  {
    "text": "from what you see in c-sharp and most of these languages which is what it's called an algebraic data type is a fancy",
    "start": "812470",
    "end": "817570"
  },
  {
    "text": "name for it but it's basically a data type that comes in multiple different flavors so we can define a data type",
    "start": "817570",
    "end": "825399"
  },
  {
    "text": "that corresponds to an expression and this data type will have three different",
    "start": "825399",
    "end": "830560"
  },
  {
    "text": "flavors so you can be either on number which point it has an interest an argument or it contains an int or it can",
    "start": "830560",
    "end": "837310"
  },
  {
    "text": "be a variable which will contain a string X in this example or it can be a",
    "start": "837310",
    "end": "843279"
  },
  {
    "text": "binary operator and the binary operator must have an operator and it will have two sub expressions this is a recursive",
    "start": "843279",
    "end": "849430"
  },
  {
    "text": "data type which you which you use to build this type of trees right the operator I will just say is a numerable",
    "start": "849430",
    "end": "856089"
  },
  {
    "text": "basically so we can have four different values at the sub motive so this allows",
    "start": "856089",
    "end": "861130"
  },
  {
    "text": "us to build a relatively simple set of operations like this so if we now want",
    "start": "861130",
    "end": "870790"
  },
  {
    "text": "to produce this expression the X plus one minus one it has to be repeated like",
    "start": "870790",
    "end": "876730"
  },
  {
    "text": "this so these data structures immediately translate into constructor",
    "start": "876730",
    "end": "881920"
  },
  {
    "text": "functions that allows us to produce instances of this type so the binary",
    "start": "881920",
    "end": "886959"
  },
  {
    "text": "operator is a top-level node it's an ad and the left expression is the variable",
    "start": "886959",
    "end": "892930"
  },
  {
    "text": "X and the right expression is the binary operator where we subtract one from one",
    "start": "892930",
    "end": "898260"
  },
  {
    "text": "it's very easy to define these types that's comparing that to the code um",
    "start": "898260",
    "end": "903279"
  },
  {
    "text": "syntax that's very verbose compared to this it this is absolutely a subset of",
    "start": "903279",
    "end": "908920"
  },
  {
    "text": "what we can do in encode um of course but still there's a very big difference in how verbose these languages are when",
    "start": "908920",
    "end": "913990"
  },
  {
    "text": "it comes to doing things like this all right so now we have a way to express",
    "start": "913990",
    "end": "919149"
  },
  {
    "text": "this type of tree but of course we want to do something with them you want to apply functions to them so now we're going to write a function print expert",
    "start": "919149",
    "end": "926589"
  },
  {
    "text": "that takes one of these expressions and turns it into a string and at this point",
    "start": "926589",
    "end": "932079"
  },
  {
    "text": "we use pattern matching we have to use pattern matching to do stuff on this",
    "start": "932079",
    "end": "937149"
  },
  {
    "text": "type of of algebraic data types and we use it all the time in high school for doing things like this because this",
    "start": "937149",
    "end": "944140"
  },
  {
    "text": "a table comes in three different flavors so we will basically pattern-matching on those three flavors and depending on",
    "start": "944140",
    "end": "949630"
  },
  {
    "text": "which flavor we are looking at we will do different things so if it's a number now we'll just do a case which in this",
    "start": "949630",
    "end": "956050"
  },
  {
    "text": "if it's a number then we just turn that number into string show is the function in Haskell for taking a value and",
    "start": "956050",
    "end": "961840"
  },
  {
    "text": "turning industry if it's variable well then we have the idea of that variable it is already a strings we can just",
    "start": "961840",
    "end": "968710"
  },
  {
    "text": "print that out if the binary operator that is typically the interesting case in in situations like this then we will",
    "start": "968710",
    "end": "975970"
  },
  {
    "text": "have to print the left expression we will have to print the right expression we have to print the operator and then",
    "start": "975970",
    "end": "981070"
  },
  {
    "text": "we wrap it all in a parenthesis and this gives us a list of lists and we can use",
    "start": "981070",
    "end": "988570"
  },
  {
    "text": "concatenate which is a function Haskell which takes a list of lists and concatenate them into one so string in",
    "start": "988570",
    "end": "993820"
  },
  {
    "text": "Haskell is presented as a list of characters that's also a string this is a list of Lists basically that allows us",
    "start": "993820",
    "end": "1001080"
  },
  {
    "text": "to print these trees all right let's do",
    "start": "1001080",
    "end": "1006120"
  },
  {
    "text": "another one a little more interesting one so we can all see from this little tree here that there is rooms to",
    "start": "1006120",
    "end": "1012360"
  },
  {
    "text": "optimize that tree we have one minus one as one of the nodes we know that can be turned into zero one minus one is zero",
    "start": "1012360",
    "end": "1019220"
  },
  {
    "text": "so let's write a small function that takes one of these trees and tries to simplify it we call it simplify and it",
    "start": "1019220",
    "end": "1028199"
  },
  {
    "text": "takes an expression as an argument and returns another possibly simplified expression so how do we do that all",
    "start": "1028199",
    "end": "1035760"
  },
  {
    "text": "right we will be switching on pattern matching on the on the expression and if",
    "start": "1035760",
    "end": "1042930"
  },
  {
    "text": "it's a leaf if it's a number or variable well then we can't simplify it any more so we just return the original",
    "start": "1042930",
    "end": "1048390"
  },
  {
    "text": "expression underscore here is a don't care term it means that we don't care what those values are that are contained",
    "start": "1048390",
    "end": "1053880"
  },
  {
    "text": "in it also very convenient I think that was introduced in c-sharp recently as well it's very nice way to just say that",
    "start": "1053880",
    "end": "1059100"
  },
  {
    "text": "I'm not interested in this don't worry about it so if it says leaf then we just return it if the binary operator what",
    "start": "1059100",
    "end": "1065820"
  },
  {
    "text": "should we do any suggestions what do we do in the",
    "start": "1065820",
    "end": "1072870"
  },
  {
    "text": "case of a binary operator we run it exactly at this point we are",
    "start": "1072870",
    "end": "1078429"
  },
  {
    "text": "actually potential to do simplification but in order to simplify it we first has",
    "start": "1078429",
    "end": "1083619"
  },
  {
    "text": "to see how to simplify the subtrees because they could yourself be collapsed to something some node so we're going to",
    "start": "1083619",
    "end": "1089499"
  },
  {
    "text": "simplify those two trees and then we're going to do some operations on it and the way we simplify those two trees is",
    "start": "1089499",
    "end": "1096399"
  },
  {
    "text": "like this using a tuple so we construct here a tuple where the two values of the",
    "start": "1096399",
    "end": "1103749"
  },
  {
    "text": "tuple or the simplified version of the left tree and the simplified version or the right tree and why do we do that",
    "start": "1103749",
    "end": "1109450"
  },
  {
    "text": "well to be able to do pattern matching on it can now we can deck directly pattern match on that tuple with its",
    "start": "1109450",
    "end": "1116830"
  },
  {
    "text": "inner values and if both of those sub trees simplify to a number then we can",
    "start": "1116830",
    "end": "1124179"
  },
  {
    "text": "actually do the evaluation we want this is the function need to define which takes an operator on those two intz and actually does the miners here and if",
    "start": "1124179",
    "end": "1133389"
  },
  {
    "text": "it's not if they are not both numbers well then we have to possibly simplify expressions we just returned by the",
    "start": "1133389",
    "end": "1139929"
  },
  {
    "text": "operator again this is the way you would typically use tuples and patta meshed",
    "start": "1139929",
    "end": "1146019"
  },
  {
    "text": "together in haskell to just create these short-lived instances of these types in",
    "start": "1146019",
    "end": "1151419"
  },
  {
    "text": "order to do whatever you want it's a very convenient way of handling these type of operations all right that's the",
    "start": "1151419",
    "end": "1160210"
  },
  {
    "text": "first introduction to haskell pattern matching and tuples before I continue",
    "start": "1160210",
    "end": "1165460"
  },
  {
    "text": "now with the main part I will have to go a little into the type system of ASCO and in particular I'm going to talk",
    "start": "1165460",
    "end": "1171789"
  },
  {
    "start": "1170000",
    "end": "1294000"
  },
  {
    "text": "about generic types so imagine that you want to write a function that we would",
    "start": "1171789",
    "end": "1177759"
  },
  {
    "text": "call map it takes an a function as an argument so a function that turns on int",
    "start": "1177759",
    "end": "1184210"
  },
  {
    "text": "into another int and it takes a list of integers and it applies this function to all of those hints this is what you this",
    "start": "1184210",
    "end": "1190509"
  },
  {
    "text": "is called select in c-sharp right okay so we define that is that we pattern",
    "start": "1190509",
    "end": "1195759"
  },
  {
    "text": "match so the base case would be when we have an empty list if you have an empty",
    "start": "1195759",
    "end": "1201100"
  },
  {
    "text": "list well let me return them to list not much more to do there it is not an empty list and then again we pattern match on",
    "start": "1201100",
    "end": "1206950"
  },
  {
    "text": "a non empty list deconstructing it this when we apply our function to the first value and put that in front of",
    "start": "1206950",
    "end": "1214389"
  },
  {
    "text": "what we get when you apply when we do map with this function on the rest of the list so it's a recursive way to",
    "start": "1214389",
    "end": "1220419"
  },
  {
    "text": "define this nasco now this function doesn't ever use any aspects of the type",
    "start": "1220419",
    "end": "1228669"
  },
  {
    "text": "it operates on the only thing that is really interesting to is is that the function the type of the function",
    "start": "1228669",
    "end": "1234249"
  },
  {
    "text": "matches the type of the elements of the list so we don't really need to do this for only integrals we can do this for a",
    "start": "1234249",
    "end": "1240940"
  },
  {
    "text": "generic type and the way you will define that in Haskell is using a type variable",
    "start": "1240940",
    "end": "1246419"
  },
  {
    "text": "so in the standard functions you get with Haskell you have this generic type for map that looks like this and the way",
    "start": "1246419",
    "end": "1253419"
  },
  {
    "text": "you would distinguish between type variables and type names is that type variables have lower case letter and",
    "start": "1253419",
    "end": "1258669"
  },
  {
    "text": "start the local setter and type name start with a capital letter so this is the type signature from map it takes a",
    "start": "1258669",
    "end": "1265360"
  },
  {
    "text": "function with this as type from A to B takes a as inputs and returns B and a",
    "start": "1265360",
    "end": "1271809"
  },
  {
    "text": "list of values of that type a and returns a list of ice would type B and the definition of the function will be",
    "start": "1271809",
    "end": "1279309"
  },
  {
    "text": "exactly identical to what we had earlier this is how you define generic types in in Haskell to do polymorphism and",
    "start": "1279309",
    "end": "1285309"
  },
  {
    "text": "applies never so now we can for instance apply this to never comprise the n type you have there should be a little more",
    "start": "1285309",
    "end": "1292169"
  },
  {
    "text": "complex example which is LM LM is also a function in Haskell that takes a value",
    "start": "1292169",
    "end": "1297669"
  },
  {
    "start": "1294000",
    "end": "1363000"
  },
  {
    "text": "as argument and a list of values and returns true if that list contains that value right the way we define this again",
    "start": "1297669",
    "end": "1307119"
  },
  {
    "text": "in pattern matching so on the empty list its false that doesn't contain this value if it's",
    "start": "1307119",
    "end": "1312580"
  },
  {
    "text": "non-empty then either the element is equal to the first elemental list or it's an element to the rest of the list",
    "start": "1312580",
    "end": "1318460"
  },
  {
    "text": "so we have a recursion here as well a he writes little problem because at this",
    "start": "1318460",
    "end": "1324249"
  },
  {
    "text": "point we are actually using some behavior that we expect that function",
    "start": "1324249",
    "end": "1329440"
  },
  {
    "text": "that type to have we can see what that is",
    "start": "1329440",
    "end": "1335070"
  },
  {
    "text": "equality exactly we can only do this if a supports equality",
    "start": "1335580",
    "end": "1342620"
  },
  {
    "text": "not all types do that functions for instance if you want to check if a function is member of another list of",
    "start": "1342620",
    "end": "1347960"
  },
  {
    "text": "functions and I can't do that because there's no good way of comparing functions so in this case we need a",
    "start": "1347960",
    "end": "1354169"
  },
  {
    "text": "constraint we can't define this for all times we can only define this for those types that support equality and the way",
    "start": "1354169",
    "end": "1361490"
  },
  {
    "text": "they solve that in Haskell is using a concept called a type clause so type class the most the cost thing you get in",
    "start": "1361490",
    "end": "1368690"
  },
  {
    "start": "1363000",
    "end": "1428000"
  },
  {
    "text": "c-sharp an object-oriented language is an interface basically a type laws",
    "start": "1368690",
    "end": "1374179"
  },
  {
    "text": "define a set of functions function signatures and any type that claims to",
    "start": "1374179",
    "end": "1379880"
  },
  {
    "text": "be a member of this class needs to implement these functions and the",
    "start": "1379880",
    "end": "1385190"
  },
  {
    "text": "Equality class will contain definition for equality and inequality and if a function if a cross defines that then",
    "start": "1385190",
    "end": "1392029"
  },
  {
    "text": "you can actually use them with you use them for comparison so our LM function",
    "start": "1392029",
    "end": "1397669"
  },
  {
    "text": "always to do to make this compile because this doesn't compile in Haskell is to add a qualification on a type we",
    "start": "1397669",
    "end": "1404419"
  },
  {
    "text": "need to say that a has to be a member of the Equality class and if it is then this is fine because then we can use",
    "start": "1404419",
    "end": "1409669"
  },
  {
    "text": "equality and now we can do for instance",
    "start": "1409669",
    "end": "1416210"
  },
  {
    "text": "LM 3 on 1 2 3 or we can do LM I on this is my list and we can do comparison or",
    "start": "1416210",
    "end": "1423200"
  },
  {
    "text": "all kinds of different type another type class that is common Haskell is the enum sauce so enum is the class used for",
    "start": "1423200",
    "end": "1430429"
  },
  {
    "start": "1428000",
    "end": "1510000"
  },
  {
    "text": "doing enumeration so allows you to count different stuff and it contains a number",
    "start": "1430429",
    "end": "1435770"
  },
  {
    "text": "of function but the two most important or the successor and pre the best as a function which is all the fundamentals",
    "start": "1435770",
    "end": "1441200"
  },
  {
    "text": "of doing enumeration you want to count them and with this function we can for instance apply map map suck the",
    "start": "1441200",
    "end": "1450080"
  },
  {
    "text": "successor function on integers we can get like this remember that the map function can take any values we doesn't",
    "start": "1450080",
    "end": "1456590"
  },
  {
    "text": "care about what what types it is but in order for this to work we know that or",
    "start": "1456590",
    "end": "1462320"
  },
  {
    "text": "the integer type must support this function which is for this class which means that you can only apply this to",
    "start": "1462320",
    "end": "1467600"
  },
  {
    "text": "two lists all of the numerals but of course in this enumerable we can do that",
    "start": "1467600",
    "end": "1472610"
  },
  {
    "text": "there clearly or begin apply the strings so we can say four it's a map suck on Howell and",
    "start": "1472610",
    "end": "1478210"
  },
  {
    "text": "get our IBM right and then we recognize that no look at all Pater interesting",
    "start": "1478210",
    "end": "1485529"
  },
  {
    "text": "thing anyway let's go back to our little type tiles here so we had the expression data type",
    "start": "1485529",
    "end": "1494019"
  },
  {
    "text": "and we have the simplify function and what I'm going to talk about as I",
    "start": "1494019",
    "end": "1499690"
  },
  {
    "text": "mentioned earlier is test case generation randomized test cases and we",
    "start": "1499690",
    "end": "1505389"
  },
  {
    "text": "are going to use now a very interesting library in Haskell called quick check",
    "start": "1505389",
    "end": "1510929"
  },
  {
    "text": "and what Crick fares is all about is to generate random test cases for you based on a certain type and then try to figure",
    "start": "1510929",
    "end": "1518139"
  },
  {
    "text": "out find bugs in your programs based on those random test cases one of the things quick check introduces is a new",
    "start": "1518139",
    "end": "1525279"
  },
  {
    "text": "type cause the type clause it calls arbitrary so any type that claims to be",
    "start": "1525279",
    "end": "1531309"
  },
  {
    "text": "a member of this class needs to implement a function called arbitrary and that is basically a function that",
    "start": "1531309",
    "end": "1537009"
  },
  {
    "text": "states how you would generate a random instance of this type so we'll now go",
    "start": "1537009",
    "end": "1542830"
  },
  {
    "text": "ahead and make our expression Clause an instance of this type to do that we say just instance arbitrary expert where now",
    "start": "1542830",
    "end": "1550450"
  },
  {
    "text": "we have to implement those part of those functions that are included in the class",
    "start": "1550450",
    "end": "1557440"
  },
  {
    "text": "definition so we need to implement this arbitrary function here and our expression class as you know comes in",
    "start": "1557440",
    "end": "1564279"
  },
  {
    "text": "three different flavors numbers variables and binary operators so our job will basically be to write one",
    "start": "1564279",
    "end": "1570159"
  },
  {
    "text": "generator for each of those flavors and then use this function coming from quickcheck which takes three generators",
    "start": "1570159",
    "end": "1576850"
  },
  {
    "text": "and just randomly picks one so we'll start by writing a generator for the number flavor and the way we do that is",
    "start": "1576850",
    "end": "1584980"
  },
  {
    "text": "like this so we say we produce an arbitrary int and then we'll return that",
    "start": "1584980",
    "end": "1590259"
  },
  {
    "text": "and wrap it with the num constructor there's an interesting thing to say",
    "start": "1590259",
    "end": "1596590"
  },
  {
    "text": "about this and that is that I never in this code explicitly say here that the",
    "start": "1596590",
    "end": "1601809"
  },
  {
    "text": "end produced by the arbitrary is an integer and this is a consequence of a",
    "start": "1601809",
    "end": "1608080"
  },
  {
    "text": "very surface type inference technique that is used in Haskell that allows you to eliminate a",
    "start": "1608080",
    "end": "1614469"
  },
  {
    "text": "lot of those type information from your code directly because it can just you know the only type and can have as int",
    "start": "1614469",
    "end": "1620320"
  },
  {
    "text": "because I use the num constructor on it and that requires named since num is used an n n has to be an int and his n",
    "start": "1620320",
    "end": "1627219"
  },
  {
    "text": "incident this arbitrary function here must be the arbitrary function that generates an int it can't be the",
    "start": "1627219",
    "end": "1632589"
  },
  {
    "text": "function that generates a random character or a random expression it must be named",
    "start": "1632589",
    "end": "1638459"
  },
  {
    "text": "so next step to generate a random variable we will just do something very",
    "start": "1638669",
    "end": "1644619"
  },
  {
    "text": "simple I will just say that I will pick one of these two big values so elements takes a list of values and just randomly",
    "start": "1644619",
    "end": "1650079"
  },
  {
    "text": "picks one them so the variables we would call X wire set obviously in a real world environment you would probably do",
    "start": "1650079",
    "end": "1656169"
  },
  {
    "text": "something more advanced here and find in the binary operator what about that that's the interesting part well we have",
    "start": "1656169",
    "end": "1665979"
  },
  {
    "text": "to generate a random operator you have to generate a random left expression and",
    "start": "1665979",
    "end": "1671979"
  },
  {
    "text": "you have to generate a random right expression now they have those we can just wrap them in that binary operator",
    "start": "1671979",
    "end": "1678119"
  },
  {
    "text": "constructor and again I'm just writing here arbitrary arbitrary arbitrary I",
    "start": "1678119",
    "end": "1683259"
  },
  {
    "text": "don't have to say anything explicitly about those types because those are all forced on the on the language by where",
    "start": "1683259",
    "end": "1690279"
  },
  {
    "text": "I'm using them the binary objects pets expects a random expects a an operator into expressions that means that these",
    "start": "1690279",
    "end": "1696940"
  },
  {
    "text": "arbitrary expressions has to generate those values when here comes an",
    "start": "1696940",
    "end": "1703749"
  },
  {
    "text": "interesting part as well since tuples is a native part of Haskell libraries like",
    "start": "1703749",
    "end": "1710559"
  },
  {
    "text": "quick check with a function for generated tuples as well so I can reduce this instead of writing arbitrary three",
    "start": "1710559",
    "end": "1717369"
  },
  {
    "text": "times I can just say give me a random tuple and now that I'm used in the",
    "start": "1717369",
    "end": "1723309"
  },
  {
    "text": "deconstruction here immediately the type system will know that this arbitrary",
    "start": "1723309",
    "end": "1728499"
  },
  {
    "text": "function must be the arbitrary function generates our three tuple and the inner types of that tuple is forced upon it",
    "start": "1728499",
    "end": "1735279"
  },
  {
    "text": "based on menu where I'm using it here it's very nice way to write things I",
    "start": "1735279",
    "end": "1741039"
  },
  {
    "text": "think I'll just show you quickly how to write this this instance of the arbitrary on a pair",
    "start": "1741039",
    "end": "1747100"
  },
  {
    "start": "1742000",
    "end": "1897000"
  },
  {
    "text": "of values so a tuple with two values first of all we need to have a constraint there as well because we can",
    "start": "1747100",
    "end": "1753010"
  },
  {
    "text": "only generate a tuple if the types that that is contained by that tuple are also",
    "start": "1753010",
    "end": "1758440"
  },
  {
    "text": "instance of this arbitrary choice you have to be able to generate arbitrary versions over so we have to add this",
    "start": "1758440",
    "end": "1764200"
  },
  {
    "text": "qualifier arbitrary a an arbitrary B is both of those are arbitrary then even arbitrary of the pair of those values is",
    "start": "1764200",
    "end": "1770559"
  },
  {
    "text": "arbitrary and the way we define arbitrary here is just you produce an X we produce in Y and we return the pair",
    "start": "1770559",
    "end": "1778559"
  },
  {
    "text": "it's very simple to do and if we want to do this for a three tuple that's almost",
    "start": "1778559",
    "end": "1784330"
  },
  {
    "text": "the same thing we need to just say that this third value also is in our instance of the arbitrary clause and when we do",
    "start": "1784330",
    "end": "1790929"
  },
  {
    "text": "we can just add the first value so generate the first value now that you have a definition on how to generate a",
    "start": "1790929",
    "end": "1796389"
  },
  {
    "text": "tuple well we can just generate a tuple here appear and then return that three",
    "start": "1796389",
    "end": "1801669"
  },
  {
    "text": "tuple like this let's see in the in the quick check code that they have all",
    "start": "1801669",
    "end": "1807250"
  },
  {
    "text": "these different sections where you later generate up to I think it's like 13 values of something there's some in in",
    "start": "1807250",
    "end": "1813429"
  },
  {
    "text": "the standard it says how many have larger these tuples library is supposed to be able to generate but you you",
    "start": "1813429",
    "end": "1819820"
  },
  {
    "text": "rarely use that large tuples anyway because if you have that type of big data structures you usually start",
    "start": "1819820",
    "end": "1825309"
  },
  {
    "text": "wrapping it in something that is more concise and something that more explains what you're doing but these type of",
    "start": "1825309",
    "end": "1830649"
  },
  {
    "text": "functions are used all the time so let's go back to this expression of us here is",
    "start": "1830649",
    "end": "1842350"
  },
  {
    "text": "the entire code required to generate an arbitrary expression and I also added an instance arbitrary instance for for the",
    "start": "1842350",
    "end": "1850240"
  },
  {
    "text": "operator itself and what I do then is I just randomly pick one of those for in",
    "start": "1850240",
    "end": "1856750"
  },
  {
    "text": "some cases you will have restrictions on what type or what subset of a certain",
    "start": "1856750",
    "end": "1863350"
  },
  {
    "text": "type you you will you will need in a in a code so if I for instance want to be",
    "start": "1863350",
    "end": "1868630"
  },
  {
    "text": "able to generate a tree that contains only positive or non-negative values in",
    "start": "1868630",
    "end": "1874510"
  },
  {
    "text": "the different nodes then I can't just use the arbitrary here directly on the ends and the way you",
    "start": "1874510",
    "end": "1880090"
  },
  {
    "text": "would typically do that control that so in in Haskell is that it would sort of",
    "start": "1880090",
    "end": "1886509"
  },
  {
    "text": "wrap the behavior that you want for a certain type that you want to generate in a specific type so if I want this",
    "start": "1886509",
    "end": "1893200"
  },
  {
    "text": "tree to only contain non-negative values then I would introduce a new type just a",
    "start": "1893200",
    "end": "1899049"
  },
  {
    "text": "wrapper for int I'll define this part this type and as an instance of the",
    "start": "1899049",
    "end": "1905470"
  },
  {
    "text": "object class and define what I want to do there so a natural number should only contain zero or larger numbers the way I",
    "start": "1905470",
    "end": "1912909"
  },
  {
    "text": "will do that I will just generate random value I will wrap it use in there with a",
    "start": "1912909",
    "end": "1918309"
  },
  {
    "text": "natural construct and do the absolute value on that that way I can guarantee that when I produce values for this type",
    "start": "1918309",
    "end": "1925960"
  },
  {
    "text": "I will only get positive values and now that I have this all I need to do to",
    "start": "1925960",
    "end": "1933820"
  },
  {
    "text": "make sure that this code produces trees with only positive values in it is to",
    "start": "1933820",
    "end": "1939099"
  },
  {
    "text": "add the constructor here because by deconstructing my data type like this",
    "start": "1939099",
    "end": "1944799"
  },
  {
    "text": "I'm suddenly forcing this arbitrary function to generate natural values not just int this is very convenient thing",
    "start": "1944799",
    "end": "1953649"
  },
  {
    "text": "to have another place where it's used a lot is for generating lists so often if you have list as an argument there will",
    "start": "1953649",
    "end": "1959919"
  },
  {
    "start": "1954000",
    "end": "2056000"
  },
  {
    "text": "be constraints on what types of lists you can have in it might phrases be that you don't accept empty lists as an",
    "start": "1959919",
    "end": "1967029"
  },
  {
    "text": "argument in that case I can produce a type which say is a non empty this is a",
    "start": "1967029",
    "end": "1973059"
  },
  {
    "text": "basica wrapper for non-empty lists non-empty ticket has a type a type a is",
    "start": "1973059",
    "end": "1978129"
  },
  {
    "text": "basically generated like this if a is an or is the arbitrary type then I can just",
    "start": "1978129",
    "end": "1985929"
  },
  {
    "text": "generate a random list if the list is empty knowledge the function used in Haskell to determine if the list is",
    "start": "1985929",
    "end": "1992109"
  },
  {
    "text": "empty if it's empty well I just generate again if it is not empty then I have a non-empty list I can",
    "start": "1992109",
    "end": "1998649"
  },
  {
    "text": "return it you see a lot of these patterns and in the quick check library you'll find instances for instance of",
    "start": "1998649",
    "end": "2005220"
  },
  {
    "text": "sorted lists or lists containing unique values and all of these kinds of things",
    "start": "2005220",
    "end": "2010259"
  },
  {
    "text": "a lot of them permutations of different values and all that all right so let's return to our",
    "start": "2010259",
    "end": "2019380"
  },
  {
    "text": "little data structure here and the prop and the function we wrote on it we wrote",
    "start": "2019380",
    "end": "2024510"
  },
  {
    "text": "this simplify function to take a tree and and and simplify it and now we're",
    "start": "2024510",
    "end": "2031559"
  },
  {
    "text": "going to use this for testing and since we have a way to generate random",
    "start": "2031559",
    "end": "2036750"
  },
  {
    "text": "instances of this expression we also need a way to test those random values",
    "start": "2036750",
    "end": "2042000"
  },
  {
    "text": "and one of the problems with random test cases that you don't really know what they're supposed to do that's what we do",
    "start": "2042000",
    "end": "2047520"
  },
  {
    "text": "we do unit testing and some of you have a very clear picture where we want to end up for random test cases we don't so",
    "start": "2047520",
    "end": "2053429"
  },
  {
    "text": "in order to test them we have to use property based testing we have to define",
    "start": "2053429",
    "end": "2058800"
  },
  {
    "start": "2056000",
    "end": "2129000"
  },
  {
    "text": "some sort of a behavior that we know these this data type or these functions should always exhibit and the behavior",
    "start": "2058800",
    "end": "2067200"
  },
  {
    "text": "in this case that I will use for demonstration purposes is the fact that when you simplify a tree the size of the",
    "start": "2067200",
    "end": "2075990"
  },
  {
    "text": "resulting tree will always in terms of number of nodes must always be smaller than or equal to the original tree very",
    "start": "2075990",
    "end": "2084540"
  },
  {
    "text": "trivial example trivial property but to do that we need a little help fraction we need a function for computing the",
    "start": "2084540",
    "end": "2091500"
  },
  {
    "text": "size of a tree this should be easier now that you are expert in pattern matching and tuples how do we do this Casey so",
    "start": "2091500",
    "end": "2100109"
  },
  {
    "text": "justice you for the Leafs the size of",
    "start": "2100109",
    "end": "2106650"
  },
  {
    "text": "Leafs is just 1 so numbers of variables is just one node large binary operators",
    "start": "2106650",
    "end": "2112109"
  },
  {
    "text": "how large are they yes some exactly 1",
    "start": "2112109",
    "end": "2121440"
  },
  {
    "text": "plus the sum of the size of the two sub trees and now that they have this small",
    "start": "2121440",
    "end": "2126990"
  },
  {
    "text": "function we can write our property now we'll call that property prop simplification reduces size this is sort",
    "start": "2126990",
    "end": "2133410"
  },
  {
    "start": "2129000",
    "end": "2283000"
  },
  {
    "text": "of a the way you would typically name your properties in highschool and this",
    "start": "2133410",
    "end": "2138540"
  },
  {
    "text": "property is basically predicate it takes an instance of our expression type and",
    "start": "2138540",
    "end": "2143550"
  },
  {
    "text": "returns a boolean so if that simplification works",
    "start": "2143550",
    "end": "2149849"
  },
  {
    "text": "correctly then this should always return true and the way we define this that when we take an expression as argument E",
    "start": "2149849",
    "end": "2155520"
  },
  {
    "text": "and we just compute the size of e and then we compare that to the size of what to get to in the simplify and this",
    "start": "2155520",
    "end": "2162660"
  },
  {
    "text": "should return to for all possible instances of this expression class all",
    "start": "2162660",
    "end": "2169500"
  },
  {
    "text": "right",
    "start": "2169500",
    "end": "2171680"
  },
  {
    "text": "yes that's true so we didn't say so this is only a property of expect from it but",
    "start": "2176520",
    "end": "2182160"
  },
  {
    "text": "it's not the full set of qualities that we like to simplify property to have",
    "start": "2182160",
    "end": "2188790"
  },
  {
    "text": "it's just one of them absolutely so if you're working on using a property based testing larger sense",
    "start": "2188790",
    "end": "2194250"
  },
  {
    "text": "you will try to capture more behavior of this mystery than what you want there but this is just one of them I'll use",
    "start": "2194250",
    "end": "2199260"
  },
  {
    "text": "for something all right let's run that so here we have no you can see it",
    "start": "2199260",
    "end": "2209450"
  },
  {
    "text": "all right so this will actually run random generation on all its care to do",
    "start": "2221430",
    "end": "2227259"
  },
  {
    "text": "it in a presentation that hope it works there we go and we have a failing test",
    "start": "2227259",
    "end": "2233019"
  },
  {
    "text": "case you can all see what the problem is right that is the other problem with",
    "start": "2233019",
    "end": "2242589"
  },
  {
    "text": "random task energized case generation the test cases Europe end up with are",
    "start": "2242589",
    "end": "2247809"
  },
  {
    "text": "usually very very confusing big test cases containing a lot of noise that are",
    "start": "2247809",
    "end": "2254289"
  },
  {
    "text": "actually relevant to the actual problem but this is a real bug in the code we just wrote I assure you and this is",
    "start": "2254289",
    "end": "2262900"
  },
  {
    "text": "where I think quick check really shines",
    "start": "2262900",
    "end": "2269039"
  },
  {
    "text": "because what happens when you get this type of failure is that you can do more",
    "start": "2269039",
    "end": "2275199"
  },
  {
    "text": "than just look at that initial initial test case you get because quick check",
    "start": "2275199",
    "end": "2281319"
  },
  {
    "text": "includes another function this arbitrary class includes not a function call",
    "start": "2281319",
    "end": "2286630"
  },
  {
    "start": "2283000",
    "end": "2548000"
  },
  {
    "text": "shrink the shrink takes a value of this type and it's supposed to produce a list",
    "start": "2286630",
    "end": "2293559"
  },
  {
    "text": "of smaller versions of that same value and the idea here would be that once we",
    "start": "2293559",
    "end": "2299469"
  },
  {
    "text": "have found a test case failure we can produce all these smaller versions and we can try the properties news and if we",
    "start": "2299469",
    "end": "2306219"
  },
  {
    "text": "are unable to lim eliminate any information from that original test case and still get a failing property then we",
    "start": "2306219",
    "end": "2311920"
  },
  {
    "text": "have reduced the size of that failure or the example we have and something that is a hope that hopefully more easy to",
    "start": "2311920",
    "end": "2317769"
  },
  {
    "text": "read and then we can do it over again so we can try to shrink that one and you can do this over and over again until we",
    "start": "2317769",
    "end": "2323799"
  },
  {
    "text": "reach a stable minimum where we're not able to shrink anymore so how would we",
    "start": "2323799",
    "end": "2328989"
  },
  {
    "text": "define the shrink function for our expression clause well we have already have the arbitrary toss",
    "start": "2328989",
    "end": "2334199"
  },
  {
    "text": "we will Pat a match on the flavors so if it's a number then we call the built-in",
    "start": "2334199",
    "end": "2342009"
  },
  {
    "text": "shrink function for integers which is just shrink and then we map this number",
    "start": "2342009",
    "end": "2348369"
  },
  {
    "text": "construct to it so this gives the list or different numbers that are smaller than the original number",
    "start": "2348369",
    "end": "2354160"
  },
  {
    "text": "and four variables well you could you could do stuff here as well and",
    "start": "2354160",
    "end": "2359420"
  },
  {
    "text": "depending on your implementation and your environment this could be differently complex but I will just say that it's not possible to shrink a",
    "start": "2359420",
    "end": "2365150"
  },
  {
    "text": "variable so I will just return the empty list there no way to shrink it and if it's a binary operator what do we do",
    "start": "2365150",
    "end": "2370760"
  },
  {
    "text": "then you suggestions on how to shrink a binary operator with that you can shrink",
    "start": "2370760",
    "end": "2379130"
  },
  {
    "text": "the subtrees absolutely or you could just drop the binary operator all together and just try the subtrees it",
    "start": "2379130",
    "end": "2387110"
  },
  {
    "text": "might be that this binary opera is actually not necessary for the property to fill so we can just drop it and see what happens so those are two possible",
    "start": "2387110",
    "end": "2394490"
  },
  {
    "text": "ways to shrink a binary operator just take the subtrees and if that's not good enough then we have to shrink this shrink the",
    "start": "2394490",
    "end": "2400700"
  },
  {
    "text": "kids so we can shrink the operator and we could discuss what you would mean by",
    "start": "2400700",
    "end": "2405890"
  },
  {
    "text": "shrinking the operator here but you can define the versions for that for instance you all just go to the left and try to see if you can reduce to add or",
    "start": "2405890",
    "end": "2413720"
  },
  {
    "text": "we can shrink the left operator or we can shrink the right operator all right sub-tree I mean and this in",
    "start": "2413720",
    "end": "2421400"
  },
  {
    "text": "the end we end up with a huge list of different possible ways to shrink the of the the binary operator and when we are",
    "start": "2421400",
    "end": "2428330"
  },
  {
    "text": "running quick check now we can just start reversing them so you can scan through them see if you can find a failure if you do you have a smaller",
    "start": "2428330",
    "end": "2433790"
  },
  {
    "text": "case and we can run again let's do this",
    "start": "2433790",
    "end": "2439390"
  },
  {
    "text": "so we stopped drinking here we found a smaller version of it and see what it",
    "start": "2444209",
    "end": "2451599"
  },
  {
    "text": "removed it remove this binary operator returns the left-hand side of that operator we can continue shrinking it",
    "start": "2451599",
    "end": "2461079"
  },
  {
    "text": "become smaller and smaller this was a big one",
    "start": "2461079",
    "end": "2467549"
  },
  {
    "text": "and now we see is reducing it to something that is much more comprehensible and finally starting to",
    "start": "2470760",
    "end": "2475830"
  },
  {
    "text": "do reducing the inner numbers now we end up with that and now it's pretty clear",
    "start": "2475830",
    "end": "2484350"
  },
  {
    "text": "what happened right you can see what the problem is any one divided by zero yes we didn't",
    "start": "2484350",
    "end": "2493980"
  },
  {
    "text": "take care of the case where we would have this expression return a values",
    "start": "2493980",
    "end": "2499200"
  },
  {
    "text": "that will simplify to zero because then get divided by series this is actually an exception being",
    "start": "2499200",
    "end": "2504300"
  },
  {
    "text": "thrown when you run this this property and having this shrink operations done",
    "start": "2504300",
    "end": "2510840"
  },
  {
    "text": "on your test cases is very very valuable because what you end up with is typically a very very small test case",
    "start": "2510840",
    "end": "2518220"
  },
  {
    "text": "where every single part of that case the test case is necessary for the property to fill because all the other things",
    "start": "2518220",
    "end": "2524760"
  },
  {
    "text": "have been been removed by this shrink operation so it's very often the case",
    "start": "2524760",
    "end": "2530040"
  },
  {
    "text": "when you get one of these examples you can look at it say oh yeah of course I didn't think about that then you will fix your book and you run",
    "start": "2530040",
    "end": "2537030"
  },
  {
    "text": "again and continue doing this testing like this",
    "start": "2537030",
    "end": "2541220"
  },
  {
    "start": "2548000",
    "end": "2679000"
  },
  {
    "text": "so I'll talk a little about one real-world use case where I use this technique and this was for API testing",
    "start": "2549130",
    "end": "2555610"
  },
  {
    "text": "so this was this was not a click it was a previous company where we were producing we were writing a building a",
    "start": "2555610",
    "end": "2562340"
  },
  {
    "text": "tool that had a command-line interface for it which is so we could write scripts for working with this tool and",
    "start": "2562340",
    "end": "2570430"
  },
  {
    "text": "we were having some issues with with quality so at one point I started",
    "start": "2570430",
    "end": "2576290"
  },
  {
    "text": "experimenting using a quick check for doing that typo testing and what I did was this I wrote a program that would",
    "start": "2576290",
    "end": "2584000"
  },
  {
    "text": "generate a random script based on an abstract syntax pretty much like what I",
    "start": "2584000",
    "end": "2590540"
  },
  {
    "text": "had now but a little more complex than that of course it will generate random scripts encapsulating the different commands that is tools supported then I",
    "start": "2590540",
    "end": "2597620"
  },
  {
    "text": "will just run those scripts in the tool and the property would be very basic I",
    "start": "2597620",
    "end": "2603500"
  },
  {
    "text": "would be looking for crashes no pointer exceptions when this was tremendously",
    "start": "2603500",
    "end": "2609440"
  },
  {
    "text": "useful we found hundreds of box of this and most of them almost everyone all of",
    "start": "2609440",
    "end": "2615170"
  },
  {
    "text": "those test cases were three or four lines of code long containing exactly the command sequence necessary to get to",
    "start": "2615170",
    "end": "2621950"
  },
  {
    "text": "the point with the tool crash there was some a few notable exceptions one of",
    "start": "2621950",
    "end": "2627980"
  },
  {
    "text": "them was a case test case where I think it was 32 lines what happened was that we had this feature that you can turn on",
    "start": "2627980",
    "end": "2633470"
  },
  {
    "text": "and off and apparently if you did that more than 32 times within one second then you have a buffer overflow and the",
    "start": "2633470",
    "end": "2639980"
  },
  {
    "text": "tool would hang which was pretty curious because I spent way too many hours looking at the toll shrinking these",
    "start": "2639980",
    "end": "2645950"
  },
  {
    "text": "scripts because the interest is easy where I ended up like I see that what on earth is doing because he's picking out all these small subsections and I ended",
    "start": "2645950",
    "end": "2652910"
  },
  {
    "text": "up with this sequence where it on off on off on off Lang very very useful and I",
    "start": "2652910",
    "end": "2661070"
  },
  {
    "text": "can say that within the functional community this type of testing is used quite a lot its I haven't seen it much",
    "start": "2661070",
    "end": "2668270"
  },
  {
    "text": "in in the object-oriented well unfortunately because I think we are really missing out on something here and there are other parts of the industry",
    "start": "2668270",
    "end": "2673520"
  },
  {
    "text": "but this is a very prolific way of doing testing and for instance you will see",
    "start": "2673520",
    "end": "2680330"
  },
  {
    "text": "that the Erlang for instance at Eric's on the corner they are using this type of testing a",
    "start": "2680330",
    "end": "2685579"
  },
  {
    "text": "lot and if you're curious to learn more about that there's a very good talk by John Hughes one of the inventors of",
    "start": "2685579",
    "end": "2692000"
  },
  {
    "text": "quick check talked about some of the interesting cases they found that on some database tests using quick check",
    "start": "2692000",
    "end": "2697640"
  },
  {
    "text": "it's really interesting to see how how they were able to produce some very nasty bugs and find some very nice bags",
    "start": "2697640",
    "end": "2703549"
  },
  {
    "text": "using this technique also in the hardware industry if you're developing a",
    "start": "2703549",
    "end": "2709819"
  },
  {
    "text": "chip for instance when Ericsson is developing it their base station chips then they're using randomized test",
    "start": "2709819",
    "end": "2716299"
  },
  {
    "text": "generation all over the place that is the main way of doing testing of microchips and one of the reasons there",
    "start": "2716299",
    "end": "2723260"
  },
  {
    "text": "is that the cost of fixing a bug once it's in silicon in hardware is so",
    "start": "2723260",
    "end": "2728539"
  },
  {
    "text": "tremendously high that they have to ensure that they get as many of those bugs out of the way before they actually",
    "start": "2728539",
    "end": "2733700"
  },
  {
    "text": "produce it and they're randomized test generation is it's really a staple food",
    "start": "2733700",
    "end": "2741980"
  },
  {
    "text": "for for the testers that's what they do the build is big test benches and have this running these randomized tests over",
    "start": "2741980",
    "end": "2747349"
  },
  {
    "text": "and over again you can run for four weeks to find this all right just a",
    "start": "2747349",
    "end": "2756140"
  },
  {
    "start": "2756000",
    "end": "2849000"
  },
  {
    "text": "quick summary at the end there so c-sharp 7 introduces some features",
    "start": "2756140",
    "end": "2761509"
  },
  {
    "text": "mainly tuples and pattern matching that has been around in the functional world for quite a long time and my hypothesis",
    "start": "2761509",
    "end": "2767569"
  },
  {
    "text": "and i hope you agree with me is that introducing those features as native part of the language opens up the",
    "start": "2767569",
    "end": "2774710"
  },
  {
    "text": "possibility of doing stuff you probably wouldn't have done otherwise because they are too verbose or just too awkward",
    "start": "2774710",
    "end": "2781849"
  },
  {
    "text": "to do without those patterns and I think that having pattern matching and tuples",
    "start": "2781849",
    "end": "2787160"
  },
  {
    "text": "available in in c-sharp in the native way is something that will benefit a lot from in the coming years and it's",
    "start": "2787160",
    "end": "2792890"
  },
  {
    "text": "something that hopefully will be prolific and a natural part of your toolkit when you're doing development in",
    "start": "2792890",
    "end": "2798049"
  },
  {
    "text": "those languages and just as lambda expressions the link introduced the",
    "start": "2798049",
    "end": "2804140"
  },
  {
    "text": "constant stream processing which is now very ubiquitous in the c-sharp community",
    "start": "2804140",
    "end": "2809180"
  },
  {
    "text": "I think these tuples and pattern matching will allow us to do this type of functional processes and data",
    "start": "2809180",
    "end": "2814279"
  },
  {
    "text": "structures we are used to in the and Haskell community all right just a few quick",
    "start": "2814279",
    "end": "2820440"
  },
  {
    "text": "references if you want to have a look at the demo it's available in my github account so you can experiment with there",
    "start": "2820440",
    "end": "2825690"
  },
  {
    "text": "if you like and have a look at there are some demo cheats in there so don't be too hard on me if you actually look at it if you want to look at a quick check",
    "start": "2825690",
    "end": "2833160"
  },
  {
    "text": "examples they are also available I think this was from actually NDC number of years ago and finally I did a similar",
    "start": "2833160",
    "end": "2841620"
  },
  {
    "text": "presentation I can't stop stream based processing using the link in c-sharp which might find interesting if you",
    "start": "2841620",
    "end": "2846810"
  },
  {
    "text": "enjoy this alright thank you very much",
    "start": "2846810",
    "end": "2851840"
  },
  {
    "start": "2849000",
    "end": "3133000"
  },
  {
    "text": "any questions at the end yes",
    "start": "2854300",
    "end": "2861830"
  },
  {
    "text": "so the question is how you would apply this in c-sharp well the visitor patterning is nice but",
    "start": "2876940",
    "end": "2882680"
  },
  {
    "text": "you country as I said there are cases for you country to do that because you are have you have this third-party",
    "start": "2882680",
    "end": "2888769"
  },
  {
    "text": "library that you can't extend on I think the example that Microsoft used Sun on his on their website is some of these",
    "start": "2888769",
    "end": "2895900"
  },
  {
    "text": "graphical elements from one of the libraries if you want to do functions on top of those it's not that easy to do",
    "start": "2895900",
    "end": "2901880"
  },
  {
    "text": "that yeah okay perhaps I misunderstood",
    "start": "2901880",
    "end": "2910759"
  },
  {
    "text": "you I have to",
    "start": "2910759",
    "end": "2913660"
  },
  {
    "text": "okay but in the Vista pattern you basically have to do pattern national right yeah so you have the pattern",
    "start": "2921280",
    "end": "2927170"
  },
  {
    "text": "matching the rest of them",
    "start": "2927170",
    "end": "2929920"
  },
  {
    "text": "yeah that's that's what the switch statement is for it",
    "start": "2940409",
    "end": "2945329"
  },
  {
    "text": "yeah but within that visitor pattern you will basically be doing this pattern matching because that will have to",
    "start": "2957499",
    "end": "2962940"
  },
  {
    "text": "implement four different different types you will have to do the pattern instead",
    "start": "2962940",
    "end": "2969380"
  },
  {
    "text": "but okay but at some point you will actually have to do that button mashing or you'll have to write different functions for different elements for for",
    "start": "3000360",
    "end": "3009410"
  },
  {
    "text": "for the different types right but I",
    "start": "3009410",
    "end": "3014700"
  },
  {
    "text": "agree you're probably right that you are vista parties doing something similar to this it is separating the functions you want",
    "start": "3014700",
    "end": "3020520"
  },
  {
    "text": "to do on those types from the data type itself absolutely so in that case the in that type there there is a lot of",
    "start": "3020520",
    "end": "3026640"
  },
  {
    "text": "overlap for them but this is this type of pattern matching is is built specifically to allow you to do that in",
    "start": "3026640",
    "end": "3032340"
  },
  {
    "text": "the communion rail and in fact a good point on that is that many of these",
    "start": "3032340",
    "end": "3038690"
  },
  {
    "text": "features that come into the language or really encapsulations of all the design",
    "start": "3038690",
    "end": "3044130"
  },
  {
    "text": "patterns that would be used for quite a while so the visitor pattern might be similar to this but I mean there's other",
    "start": "3044130",
    "end": "3049940"
  },
  {
    "text": "features of the language that we are very used to doing that are now native the language like inheritance",
    "start": "3049940",
    "end": "3055640"
  },
  {
    "text": "object-oriented himself people were doing object-oriented development in the sea long before C++ came around with",
    "start": "3055640",
    "end": "3062640"
  },
  {
    "text": "object-oriented values or Batory of the features but now that they are in the future in the language you were just so",
    "start": "3062640",
    "end": "3069180"
  },
  {
    "text": "used them you don't really think of them as patterns anymore any other questions",
    "start": "3069180",
    "end": "3079190"
  },
  {
    "text": "if there's an implementation a quick check for c-sharp yes there is a least a",
    "start": "3083809",
    "end": "3089849"
  },
  {
    "text": "basic version of it I never tried it myself but I think we are some way from making this very convenient thing to do",
    "start": "3089849",
    "end": "3097440"
  },
  {
    "text": "in use in c-sharp but there are ways of doing this type of generation for",
    "start": "3097440",
    "end": "3103559"
  },
  {
    "text": "c-sharp but I think that as I shown you in this talk there are still features in high school that are not present in",
    "start": "3103559",
    "end": "3109109"
  },
  {
    "text": "c-sharp yeah that makes a quick check very convenient in c-sharp in Haskell I mean but I hope that we will see this",
    "start": "3109109",
    "end": "3116190"
  },
  {
    "text": "type of patterns being used there more and hopefully I will get to a point where we can do things like quick check",
    "start": "3116190",
    "end": "3122130"
  },
  {
    "text": "in a community where you're sincere any other questions okay",
    "start": "3122130",
    "end": "3130140"
  },
  {
    "text": "thank you very much [Applause]",
    "start": "3130140",
    "end": "3134859"
  }
]