[
  {
    "text": "okay hello everybody thanks for coming to my talk my name is Adam snik and today I will speak about state of the",
    "start": "2000",
    "end": "7359"
  },
  {
    "text": "doet performance who am I I'm one of the core contributors to",
    "start": "7359",
    "end": "14759"
  },
  {
    "text": "benchmark.com net performance list and I contribute to coreclr and corix",
    "start": "17600",
    "end": "23680"
  },
  {
    "text": "flab I work for Powell it's Norwegian company so it's very special for me to speak here today in alsoo because we",
    "start": "23680",
    "end": "30519"
  },
  {
    "text": "make things in Oso work my main goal is to share the",
    "start": "30519",
    "end": "35640"
  },
  {
    "text": "knowledge with you and to speak about all of the new things I'm not going to speak about improvements I would like to",
    "start": "35640",
    "end": "43000"
  },
  {
    "text": "show you the new shiny things that you can use and make your applications faster but one very important update on",
    "start": "43000",
    "end": "50039"
  },
  {
    "text": "Monday I have realized that David fer who has implemented pipelines are was",
    "start": "50039",
    "end": "56359"
  },
  {
    "text": "going to speak about pipelines have you been to his talk",
    "start": "56359",
    "end": "61480"
  },
  {
    "text": "yesterday the audience was full so instead of pipelines I have decided to take this time and speak about C",
    "start": "61480",
    "end": "68880"
  },
  {
    "text": "7.2 which is super cool in terms of performance so let's get it",
    "start": "68880",
    "end": "75360"
  },
  {
    "text": "started uh you might be surprised that I start with value Tuple because it's just",
    "start": "75360",
    "end": "80439"
  },
  {
    "text": "a tuple it's very flexible and we no longer need to create a dedicated type when we want to return more than one",
    "start": "80439",
    "end": "87040"
  },
  {
    "text": "thing from a method but the key is that that it's a value type and there is a",
    "start": "87040",
    "end": "93200"
  },
  {
    "text": "huge difference between value and reference types and it's a key to understand it to have a good performance",
    "start": "93200",
    "end": "100200"
  },
  {
    "text": "and today I will speak about few value types so this is why now I'm going to briefly describe the differences and to",
    "start": "100200",
    "end": "107759"
  },
  {
    "text": "make it simpler I will talk about value to and to of two integer Fields so first",
    "start": "107759",
    "end": "115680"
  },
  {
    "text": "of all we have an extra overhead each instance of a reference type contains two extra",
    "start": "115680",
    "end": "121399"
  },
  {
    "text": "Fields pointer to the method table and object header so for example when you",
    "start": "121399",
    "end": "127079"
  },
  {
    "text": "take a Lo on your object CLR is writing information about this to the object header when you uh invoke virtual method",
    "start": "127079",
    "end": "135440"
  },
  {
    "text": "it jumps to Method table and then it jumps to the implementation of your method also reflection is using this but",
    "start": "135440",
    "end": "142000"
  },
  {
    "text": "the point here is that we have extra overhead in terms of memory so for two",
    "start": "142000",
    "end": "147120"
  },
  {
    "text": "simple integer fields we have tripled the amount of necessary memory for 64bit",
    "start": "147120",
    "end": "152720"
  },
  {
    "text": "architecture which is recently the most common one when it comes to Value types we don't have any extra overhead what",
    "start": "152720",
    "end": "160080"
  },
  {
    "text": "you see is what you get but they're more limited you cannot take lock on them they cannot have finalizers and you",
    "start": "160080",
    "end": "165920"
  },
  {
    "text": "cannot der from them so it comes for a price but to understand how it affects",
    "start": "165920",
    "end": "172599"
  },
  {
    "text": "the performance we need to understand how CPU works so when you want to read something from memory CPU is first of",
    "start": "172599",
    "end": "179480"
  },
  {
    "text": "all looking for the value in the cash in the first level of cash if data is not out",
    "start": "179480",
    "end": "185000"
  },
  {
    "text": "there it goes to the second level if not there it goes to main memory but this",
    "start": "185000",
    "end": "190239"
  },
  {
    "text": "has different prices so accessing first level half of a nond second level 14",
    "start": "190239",
    "end": "198280"
  },
  {
    "text": "times slower going to main memory is 200 times",
    "start": "198280",
    "end": "203959"
  },
  {
    "text": "slower and CPU knows about two principles of data locality first one",
    "start": "204799",
    "end": "210280"
  },
  {
    "text": "temporal which say which says that if given value is being used right now it's likely to be used soon and second",
    "start": "210280",
    "end": "217760"
  },
  {
    "text": "spatial which says that the things that are located next to each other in memory are likely to be used together so think",
    "start": "217760",
    "end": "225760"
  },
  {
    "text": "of four Loops when we are iterating we use first element second",
    "start": "225760",
    "end": "230920"
  },
  {
    "text": "third fourth fifth so CPU does some optimization when you access the first",
    "start": "230920",
    "end": "236799"
  },
  {
    "text": "element of the array and the data is not present in the cach we have a cach my and it copies whole cach line from Main",
    "start": "236799",
    "end": "243840"
  },
  {
    "text": "memory to the cache because it predicts that you will need the other values very soon so usually the size of a single",
    "start": "243840",
    "end": "252319"
  },
  {
    "text": "cach line is 64 bytes and when we try to fit value types and reference types of",
    "start": "252319",
    "end": "259799"
  },
  {
    "text": "our example type in single cach line we can see that we can fit eight instances of value type and less than three",
    "start": "259799",
    "end": "266840"
  },
  {
    "text": "instances of a reference type and if it affects performance I decided to write a",
    "start": "266840",
    "end": "272080"
  },
  {
    "text": "benchmark for you with the help of benchmark.us in Hardware counters",
    "start": "272080",
    "end": "278759"
  },
  {
    "text": "feature and we are going to look for cach misses the Benchmark is really simple we",
    "start": "278759",
    "end": "284800"
  },
  {
    "text": "just iterate through an aray or value types and reference types and we just",
    "start": "284800",
    "end": "290400"
  },
  {
    "text": "add both Fields together so we are just touching the fields so it's more like a",
    "start": "290400",
    "end": "296160"
  },
  {
    "text": "benchmark of CPU cache but how do you think for a big data set how huge the",
    "start": "296160",
    "end": "301639"
  },
  {
    "text": "difference can be in that case for 100 millions of",
    "start": "301639",
    "end": "309919"
  },
  {
    "text": "elements doing this with reference types was more than three times slower and as",
    "start": "309919",
    "end": "315080"
  },
  {
    "text": "you can see the cash misses were were more than three times common and this affects performance this",
    "start": "315080",
    "end": "322680"
  },
  {
    "text": "is really important to understand modern CPU architecture because data locality has a great effect on the performance",
    "start": "322680",
    "end": "329479"
  },
  {
    "text": "and other great benefit of value types is that they are not affecting garbage collector so when you allocate a local",
    "start": "329479",
    "end": "337240"
  },
  {
    "text": "variable which is a value type it's invisible for garbage collector because it's get allocated on the stock if you",
    "start": "337240",
    "end": "344280"
  },
  {
    "text": "allocate an AR of integers then garbage collector allocates an r on the managed",
    "start": "344280",
    "end": "350600"
  },
  {
    "text": "hip and the integers are are inside they are nested but it doesn't care for the",
    "start": "350600",
    "end": "356560"
  },
  {
    "text": "content so they are transparent for garbage collector so anytime you create value type and you don't box it you",
    "start": "356560",
    "end": "363840"
  },
  {
    "text": "don't put any extra pressure on the garbage collector and you don't allocate any managed memory which is very",
    "start": "363840",
    "end": "371039"
  },
  {
    "text": "important if you want to go really high performance and of course for the stack",
    "start": "371039",
    "end": "377280"
  },
  {
    "text": "allocated value types we have deterministic deallocation when the method ends the stack is being just",
    "start": "377280",
    "end": "382880"
  },
  {
    "text": "unwinded and everything is being wiped out but of course there are some disad",
    "start": "382880",
    "end": "390360"
  },
  {
    "text": "vantages as when you take a look at the basic class Library most of the types are",
    "start": "390360",
    "end": "396039"
  },
  {
    "text": "classes so can you name few of them so by default they are being sent",
    "start": "396039",
    "end": "404000"
  },
  {
    "text": "to methods and returned by copy and it's expensive to copy if you have a",
    "start": "404000",
    "end": "409319"
  },
  {
    "text": "structure that has five fields and you just send it to another method all five",
    "start": "409319",
    "end": "414440"
  },
  {
    "text": "of them are going to be copied when you're doing this with reference types only value of the pointer is being",
    "start": "414440",
    "end": "420319"
  },
  {
    "text": "copied single thing so the copying is",
    "start": "420319",
    "end": "425599"
  },
  {
    "text": "also uh not obvious when it happens let's consider this example we have read",
    "start": "425599",
    "end": "431280"
  },
  {
    "text": "only field which points to Value type and we call just a method on this field",
    "start": "431280",
    "end": "438720"
  },
  {
    "text": "and what C compiler does it emits following code for us because it can see",
    "start": "438720",
    "end": "445199"
  },
  {
    "text": "that the field is read only so the it should be immutable but inside of a",
    "start": "445199",
    "end": "450560"
  },
  {
    "text": "value type you can access this keyword so the method could use this keyword to",
    "start": "450560",
    "end": "457000"
  },
  {
    "text": "change its own State this is why C compiler is emitting codes like this for",
    "start": "457000",
    "end": "462520"
  },
  {
    "text": "us to have the immutability so there is a way to avoid",
    "start": "462520",
    "end": "468960"
  },
  {
    "text": "copying we should do things by references and c 7 offers us the way to",
    "start": "468960",
    "end": "474400"
  },
  {
    "text": "return references from methods still accept the references and create local",
    "start": "474400",
    "end": "482360"
  },
  {
    "text": "references as you can see the code is quite complicated and for those of you who",
    "start": "482360",
    "end": "488360"
  },
  {
    "text": "believe in clean code and want to maintain the code clean it's really important that you should use it when",
    "start": "488360",
    "end": "495360"
  },
  {
    "text": "you need it so when you've been profiling your application or designing your it for performance and you are sure",
    "start": "495360",
    "end": "501840"
  },
  {
    "text": "that it is required to use references then you should be using them you should not use them by default anytime you can",
    "start": "501840",
    "end": "509680"
  },
  {
    "text": "and let's run some other benchmarks let's iterate through an array of big",
    "start": "509680",
    "end": "514800"
  },
  {
    "text": "structures and just initialize them big structure in this example is five Fields",
    "start": "514800",
    "end": "520240"
  },
  {
    "text": "so when we do it by copy we take a copy from R work with local copy and then we",
    "start": "520240",
    "end": "527440"
  },
  {
    "text": "put it back to the array so we copy it twice but when we do it with references",
    "start": "527440",
    "end": "533519"
  },
  {
    "text": "we D reference the r item and work with local reference we don't copy any memory",
    "start": "533519",
    "end": "541440"
  },
  {
    "text": "and the difference is quite huge in my example it was more than four and a half",
    "start": "542079",
    "end": "548720"
  },
  {
    "text": "times faster to do it with references and I have just used ref keyword",
    "start": "548720",
    "end": "555680"
  },
  {
    "text": "twice and as you can see on the chart we can see old jits and the new jit the",
    "start": "555680",
    "end": "561440"
  },
  {
    "text": "real jit and the Legacy jits and can you tell me how is it possible that this feature work with old jits",
    "start": "561440",
    "end": "570560"
  },
  {
    "text": "has Microsoft released a part for Windows no uh this feature is",
    "start": "570560",
    "end": "577600"
  },
  {
    "text": "implemented this C language feature is implemented on top of CLR feature called",
    "start": "577600",
    "end": "583240"
  },
  {
    "text": "managed pointers so it's just about exposing an old existing feature that",
    "start": "583240",
    "end": "588640"
  },
  {
    "text": "wasn't used before it was also of of course about implementing all of the",
    "start": "588640",
    "end": "594240"
  },
  {
    "text": "safety rules for the pointers but some of you can say that we could previously also used pointers in C",
    "start": "594240",
    "end": "603040"
  },
  {
    "text": "because we could go unsafe we still can go unsafe the code isn't pretty at all",
    "start": "603040",
    "end": "608480"
  },
  {
    "text": "we have to switch to un safe context we have to pin object in memory and we have to play with esss and",
    "start": "608480",
    "end": "616760"
  },
  {
    "text": "stars so let's compare the unsafe way and the safe",
    "start": "616800",
    "end": "622760"
  },
  {
    "text": "way what I got was that doing it in the safe way was faster because I didn't",
    "start": "622800",
    "end": "629519"
  },
  {
    "text": "need to pin object in memory and pinning has another overhead for garbage collector because it has an extra work",
    "start": "629519",
    "end": "636320"
  },
  {
    "text": "to do because in the first phase of garbage collection it's compacting the",
    "start": "636320",
    "end": "641639"
  },
  {
    "text": "memory so it might be you moving objects in memory and moreover we didn't need to",
    "start": "641639",
    "end": "647839"
  },
  {
    "text": "go unsafe when we doing this in the safe way and I didn't know that unsafe have",
    "start": "647839",
    "end": "655279"
  },
  {
    "text": "limitations and few years ago I've been running a demon aure and it has failed because the default",
    "start": "655279",
    "end": "661959"
  },
  {
    "text": "setting didn't allow me to have a full trust so if you want to run your code",
    "start": "661959",
    "end": "667600"
  },
  {
    "text": "everywhere you cannot use unsafe because somebody might use it in environment",
    "start": "667600",
    "end": "672639"
  },
  {
    "text": "with limited trust and the code will just fail during the runtime execution",
    "start": "672639",
    "end": "677680"
  },
  {
    "text": "so it can be a no-o as of today it's very hard to find",
    "start": "677680",
    "end": "685200"
  },
  {
    "text": "some knowledge about the managed references and value to",
    "start": "685200",
    "end": "690360"
  },
  {
    "text": "but uh one of the core members of rosing team has recently started blogging and",
    "start": "690360",
    "end": "696279"
  },
  {
    "text": "as of today in my opinion this is the best way to learn more about this so if",
    "start": "696279",
    "end": "701839"
  },
  {
    "text": "you would like to learn more about references you should go to this address which is quite easy to remember must",
    "start": "701839",
    "end": "708279"
  },
  {
    "text": "override. comom and just learn from the guy that has actually implemented this",
    "start": "708279",
    "end": "715079"
  },
  {
    "text": "features so to sum up C seven performance uh value types have better",
    "start": "715680",
    "end": "722279"
  },
  {
    "text": "data locality and they don't put any pressure on garbage collector and as you know no GC is better than NC you should",
    "start": "722279",
    "end": "729440"
  },
  {
    "text": "use value tools to have clean code and great performance and you can use references to get read of unsafe and to",
    "start": "729440",
    "end": "737040"
  },
  {
    "text": "avoid copying of value types speaking of",
    "start": "737040",
    "end": "742600"
  },
  {
    "text": "unsafe have any of you ever used stacka lock okay one person so stack alog is a",
    "start": "742600",
    "end": "752399"
  },
  {
    "text": "keyword in C that in unsafe context it allows to allocate memory on the stack it's very fast for small tanks of memory",
    "start": "752399",
    "end": "760399"
  },
  {
    "text": "it's almost two times faster than new so it would be nice to use",
    "start": "760399",
    "end": "767160"
  },
  {
    "text": "it but when we compare all different types of memory and we have small manag",
    "start": "767160",
    "end": "773279"
  },
  {
    "text": "objects large objects managed objects stack allocated memory and unmanaged memory allocated on the part of the hip",
    "start": "773279",
    "end": "781320"
  },
  {
    "text": "we can see that all of them have quite fast allocation but when it comes to deallocation there is a huge difference",
    "start": "781320",
    "end": "788399"
  },
  {
    "text": "because the native memory can be deallocated on demand in the terministic way so you can actually predict how your",
    "start": "788399",
    "end": "796079"
  },
  {
    "text": "code is going to behave when it comes to managed memory we have garbage colle collector which",
    "start": "796079",
    "end": "803560"
  },
  {
    "text": "implements a her ristic so it decides on its own when it's going to clean up the",
    "start": "803560",
    "end": "808760"
  },
  {
    "text": "memory and when it does so it's suspending all of the active threats of your",
    "start": "808760",
    "end": "815480"
  },
  {
    "text": "application so it's doing nothing else but just cleaning up the memory but on",
    "start": "815480",
    "end": "821000"
  },
  {
    "text": "the other hand the managed memory is very easy to use we have inumerable",
    "start": "821000",
    "end": "826320"
  },
  {
    "text": "extensions which are known as linku it's common it's safe unsafe memory have you",
    "start": "826320",
    "end": "832519"
  },
  {
    "text": "ever used in public API that was exposing unsafe methods yeah it's it's really not very",
    "start": "832519",
    "end": "839399"
  },
  {
    "text": "common but now people at Microsoft they want to tune net they want to make do",
    "start": "839399",
    "end": "845720"
  },
  {
    "text": "isp. net cor competitor to other Cloud Web Frameworks so they need to go they",
    "start": "845720",
    "end": "854000"
  },
  {
    "text": "need to utilize full power of whatever they can take to be in the top of the T",
    "start": "854000",
    "end": "859120"
  },
  {
    "text": "power and the other problem that we have when we want to support all types of",
    "start": "859120",
    "end": "865720"
  },
  {
    "text": "memory is our are our apis so if if you want to just accept an",
    "start": "865720",
    "end": "871120"
  },
  {
    "text": "array it's like this what if you want to take a part of the aray you accept an",
    "start": "871120",
    "end": "876880"
  },
  {
    "text": "aray start index and the length Okay and now let's handle the unmanaged memory we",
    "start": "876880",
    "end": "883040"
  },
  {
    "text": "have four methods and what if we want to specify input and",
    "start": "883040",
    "end": "889839"
  },
  {
    "text": "output so quite many of them maybe this is why very few public apis have",
    "start": "889920",
    "end": "896360"
  },
  {
    "text": "something like this and the list is not of course full so the solution is span span is a simple",
    "start": "896360",
    "end": "904279"
  },
  {
    "text": "type that allows us to work with any type of memory stack allocated memory memory from the unmanaged tip and memory",
    "start": "904279",
    "end": "911160"
  },
  {
    "text": "from the managed tip it's fully type and memory safe so you don't need to worry",
    "start": "911160",
    "end": "916880"
  },
  {
    "text": "about safety and it has almost no overhead because it just about very simple pointer arithmetics and how do",
    "start": "916880",
    "end": "924199"
  },
  {
    "text": "you think is it a value type or a reference type",
    "start": "924199",
    "end": "929360"
  },
  {
    "text": "yes it's value type it's stack only value type and I will talk more about stack only",
    "start": "929440",
    "end": "936240"
  },
  {
    "text": "soon so when I said that it supports any kind of memory we can allocate memory on the stack create span out of it allocate",
    "start": "936240",
    "end": "944199"
  },
  {
    "text": "memory with the Marshall API just use the pointer and create span out of it we",
    "start": "944199",
    "end": "949639"
  },
  {
    "text": "can create it out of an r and we have even implicit cast operator so you can",
    "start": "949639",
    "end": "954839"
  },
  {
    "text": "just assign R to Span in boom you have span and as you know strings are immutable in net so in order",
    "start": "954839",
    "end": "963120"
  },
  {
    "text": "to create span out of string we need to use readon span which is",
    "start": "963120",
    "end": "970560"
  },
  {
    "text": "immutable the API is very simple uh I would recommend to think of it like of",
    "start": "970600",
    "end": "976279"
  },
  {
    "text": "an RI which can point to any type of memory because it has the length indexer",
    "start": "976279",
    "end": "981519"
  },
  {
    "text": "which allows us to get and set elements it also allows us to do slicing and this",
    "start": "981519",
    "end": "987839"
  },
  {
    "text": "is super important because it takes parts of memory without copying them",
    "start": "987839",
    "end": "993360"
  },
  {
    "text": "because it creates you a new span with just a different pointer it does not",
    "start": "993360",
    "end": "998480"
  },
  {
    "text": "copy any memory this is one of the most important features of span you can also clear it and fill it",
    "start": "998480",
    "end": "1005120"
  },
  {
    "text": "or copy it somewhere and we have one very nice method with awesome name",
    "start": "1005120",
    "end": "1010680"
  },
  {
    "text": "dangerous get bable reference um if you need to pin the span",
    "start": "1010680",
    "end": "1015880"
  },
  {
    "text": "you should use this method but I believe that the method might change the name",
    "start": "1015880",
    "end": "1021920"
  },
  {
    "text": "might change so previously when we wanted to support all kinds of memory",
    "start": "1021920",
    "end": "1027000"
  },
  {
    "text": "with input and output with all of the variations we could have something like this with span we either have method",
    "start": "1027000",
    "end": "1033480"
  },
  {
    "text": "that accepts one span or two spans which is input and output so it simplifies all",
    "start": "1033480",
    "end": "1039839"
  },
  {
    "text": "of the public apis and span supports existing run",
    "start": "1039839",
    "end": "1046880"
  },
  {
    "text": "times is a new shiny thing for net core but to keep us all happy Microsoft has",
    "start": "1046880",
    "end": "1053880"
  },
  {
    "text": "decided to support net standard 1.0 so you can actually use span with your old",
    "start": "1053880",
    "end": "1059679"
  },
  {
    "text": "existing desktop net applications that Target something like net 4.5 or",
    "start": "1059679",
    "end": "1065039"
  },
  {
    "text": "something new but we have two different implementations one for the existing run",
    "start": "1065039",
    "end": "1070720"
  },
  {
    "text": "times and one for the new runtimes the one for the existing run times has free",
    "start": "1070720",
    "end": "1075799"
  },
  {
    "text": "Fields so let's say that we want to to create a span out of the second half of",
    "start": "1075799",
    "end": "1081080"
  },
  {
    "text": "the AR then the pointer will point to the beginning of the AR the offset will be",
    "start": "1081080",
    "end": "1087000"
  },
  {
    "text": "the amount of elements to the middle and length will be just the length of the second",
    "start": "1087000",
    "end": "1093200"
  },
  {
    "text": "half why don't we merge pointer and offset because the old garbage collectors existing ones wouldn't know",
    "start": "1093200",
    "end": "1100000"
  },
  {
    "text": "how to update the pointer when the memory is being move during the compact phase so the new run times they have",
    "start": "1100000",
    "end": "1108039"
  },
  {
    "text": "merged it as of today only net core 2.0 has native implementation for",
    "start": "1108039",
    "end": "1115000"
  },
  {
    "text": "span so they've been just merged it's super simple two",
    "start": "1115000",
    "end": "1120640"
  },
  {
    "text": "fields and some people call these two versions slow and fast spun I have",
    "start": "1121360",
    "end": "1128240"
  },
  {
    "text": "decided to write some more Nano benchmarks for you and in my opinion the most important P part of span is indexer",
    "start": "1128240",
    "end": "1135799"
  },
  {
    "text": "getter and Setter because what you are going to do with SP all of the time you will be just accessing the indexer the",
    "start": "1135799",
    "end": "1142320"
  },
  {
    "text": "values so with Benchmark net I was able to compare the version foret 4.6 for net",
    "start": "1142320",
    "end": "1149000"
  },
  {
    "text": "core 101 and for net core 2.0 and as you can see the difference is",
    "start": "1149000",
    "end": "1155000"
  },
  {
    "text": "not really huge it's from 12 to 1% slower so it means that you don't need",
    "start": "1155000",
    "end": "1162840"
  },
  {
    "text": "to exclude span for the existing run times in terms of performance because",
    "start": "1162840",
    "end": "1168280"
  },
  {
    "text": "it's just very fast and one very important note there is some place for",
    "start": "1168280",
    "end": "1174120"
  },
  {
    "text": "further",
    "start": "1174120",
    "end": "1176600"
  },
  {
    "text": "improvements other um assumption and the goal for span was that it's going to be",
    "start": "1179280",
    "end": "1184559"
  },
  {
    "text": "equals in terms of performance with the r and I have measured it the red bar is",
    "start": "1184559",
    "end": "1191320"
  },
  {
    "text": "r index or gter the orange bar is span index or getter so as you can see they",
    "start": "1191320",
    "end": "1196360"
  },
  {
    "text": "are on par so this is important but valid only for net",
    "start": "1196360",
    "end": "1202760"
  },
  {
    "text": "core 2.0 which has the native support for span for the old run times we would",
    "start": "1202760",
    "end": "1209240"
  },
  {
    "text": "see this numbers",
    "start": "1209240",
    "end": "1213320"
  },
  {
    "text": "again and as I said previously the biggest advantage of span is the possibility to create slices without any",
    "start": "1214880",
    "end": "1222640"
  },
  {
    "text": "allocations so previously in net when you wanted to take only part of given",
    "start": "1222640",
    "end": "1227960"
  },
  {
    "text": "text as string you had to use the substring method which was allocating",
    "start": "1227960",
    "end": "1233039"
  },
  {
    "text": "new memory and copying the part of the string to your memory and with span we",
    "start": "1233039",
    "end": "1238400"
  },
  {
    "text": "just do simple pointer arithmetic when you want to take only the first part of this of this text net core what we do we",
    "start": "1238400",
    "end": "1247200"
  },
  {
    "text": "create a new span by calling slice and what slice does it sets the pointer to the beginning of the string and sets the",
    "start": "1247200",
    "end": "1254240"
  },
  {
    "text": "length to nine so it's two super simple operations and when we compare the",
    "start": "1254240",
    "end": "1259720"
  },
  {
    "text": "performance in this very simple scenario we can see that substring is like three",
    "start": "1259720",
    "end": "1264880"
  },
  {
    "text": "times more slower and it was allocating memory and one important",
    "start": "1264880",
    "end": "1271640"
  },
  {
    "text": "thing as you can see here we are always going to play with pointers and length",
    "start": "1271640",
    "end": "1276760"
  },
  {
    "text": "so it's size independent because we are not copying anything so actually the",
    "start": "1276760",
    "end": "1282679"
  },
  {
    "text": "cost of slicing will be like constant in time",
    "start": "1282679",
    "end": "1288679"
  },
  {
    "text": "the reason like why really Microsoft needed span was that they have profiled",
    "start": "1291520",
    "end": "1298799"
  },
  {
    "text": "a lot of web scenarios web server scenarios and they have realized that they allocate a lot of memory when it",
    "start": "1298799",
    "end": "1305360"
  },
  {
    "text": "comes to formatting and parsing compression and decompression because what we do with",
    "start": "1305360",
    "end": "1311640"
  },
  {
    "text": "web requests we par the web request headers then we format something we play",
    "start": "1311640",
    "end": "1316840"
  },
  {
    "text": "with Jon and stuff everything is about strings encoding decoding compression de",
    "start": "1316840",
    "end": "1322960"
  },
  {
    "text": "compression as of today these apis are not production ready they are in corix",
    "start": "1322960",
    "end": "1330679"
  },
  {
    "text": "Lab uh I would say that they are quite good but not polished enough but what I",
    "start": "1330679",
    "end": "1337559"
  },
  {
    "text": "would like encourage you to is to go to corix lab and if you would like to shape the next version of net you can actually",
    "start": "1337559",
    "end": "1345480"
  },
  {
    "text": "do this so you can actually help others to create the new AR to make it happen I",
    "start": "1345480",
    "end": "1352559"
  },
  {
    "text": "believe that such chance in the word of net wasn't given to us for the last in",
    "start": "1352559",
    "end": "1357640"
  },
  {
    "text": "the last 10 years at least span has a serious problem it's",
    "start": "1357640",
    "end": "1365000"
  },
  {
    "text": "called struct tering so every uh architecture has",
    "start": "1365000",
    "end": "1370640"
  },
  {
    "text": "offers US Atomic updates but usually it can update only one thing at a time and",
    "start": "1370640",
    "end": "1377360"
  },
  {
    "text": "the thing has a size limitation when you take a look at the interlocked glass you can see that",
    "start": "1377360",
    "end": "1383640"
  },
  {
    "text": "it accepts bytes integers shorts Longs",
    "start": "1383640",
    "end": "1388760"
  },
  {
    "text": "and also pointers but nothing bigger than that and in span as you know we",
    "start": "1388760",
    "end": "1394720"
  },
  {
    "text": "have at least two Fields so it's impossible to update both of them in",
    "start": "1394720",
    "end": "1400559"
  },
  {
    "text": "atomic way and let's consider this example we have public class which has a private",
    "start": "1400559",
    "end": "1406799"
  },
  {
    "text": "span field and we we have a public method that allows to update the state",
    "start": "1406799",
    "end": "1412120"
  },
  {
    "text": "and another public that allows to read the state and we have two threets and",
    "start": "1412120",
    "end": "1418000"
  },
  {
    "text": "state of the memory when the first threat decides to to set the pointer to",
    "start": "1418000",
    "end": "1423840"
  },
  {
    "text": "a and length to 100 first thing it does it points to a so the value of memory is",
    "start": "1423840",
    "end": "1430360"
  },
  {
    "text": "a and zero because zero is the default value for integers and then in another setep another Atomic update it says the",
    "start": "1430360",
    "end": "1437720"
  },
  {
    "text": "length to 100 100 okay but now we want to set the pointer to set to B and the",
    "start": "1437720",
    "end": "1443679"
  },
  {
    "text": "length to be one what we do is another Atomic update and we have new pointer",
    "start": "1443679",
    "end": "1449200"
  },
  {
    "text": "and all length and the real problem begins when",
    "start": "1449200",
    "end": "1455640"
  },
  {
    "text": "other Frets what wants to want want to read at the same time because what it can see is BN 100",
    "start": "1455640",
    "end": "1464840"
  },
  {
    "text": "and we just wanted to set the max length to one so so when it tried to read the",
    "start": "1464840",
    "end": "1470440"
  },
  {
    "text": "10th element of the buffer it should get uh r index out of bond exception but",
    "start": "1470440",
    "end": "1476520"
  },
  {
    "text": "what it got it read a random value from memory and how can this problem be",
    "start": "1476520",
    "end": "1484520"
  },
  {
    "text": "solved maybe we should synchronize access no synchronization is slow if you",
    "start": "1484520",
    "end": "1492200"
  },
  {
    "text": "ever designed for performance and you think that you need to synchronize something I encourage you to do some",
    "start": "1492200",
    "end": "1498000"
  },
  {
    "text": "brain storming think about this for a while and try to find different way of doing things the solution is to make",
    "start": "1498000",
    "end": "1505520"
  },
  {
    "text": "span a stack only type so what does it mean it means that it can live only on",
    "start": "1505520",
    "end": "1512159"
  },
  {
    "text": "stack and stacks are not shared between multiple threets so only single threet",
    "start": "1512159",
    "end": "1518279"
  },
  {
    "text": "can access stack at the same time no need for synchronization moreover GC has",
    "start": "1518279",
    "end": "1524360"
  },
  {
    "text": "a little pointer a few pointers to track because the uh Stacks are shortlived the methods",
    "start": "1524360",
    "end": "1532640"
  },
  {
    "text": "begin and ends Stacks is being unwinded so at the same time we will just have few spans on Stacks moreover we have",
    "start": "1532640",
    "end": "1540480"
  },
  {
    "text": "safe concurrency and no need for locking and we have very safe lifetime",
    "start": "1540480",
    "end": "1546799"
  },
  {
    "text": "because when we allocated memory on the stack we stack a lock and we have stack",
    "start": "1546799",
    "end": "1551960"
  },
  {
    "text": "allocated spun and the method ends the stock is being unwinded and everything",
    "start": "1551960",
    "end": "1557200"
  },
  {
    "text": "is being clean cleared out the problem is when you have pulled the memory this is your responsibility as the developer",
    "start": "1557200",
    "end": "1564240"
  },
  {
    "text": "to return it to the pool before the method has ended but stack only means that we",
    "start": "1564240",
    "end": "1570960"
  },
  {
    "text": "cannot put it on the hip and this is where real struggle",
    "start": "1570960",
    "end": "1576440"
  },
  {
    "text": "begin let's consider this example we have method that accepts something that implements I numerable of T and we have",
    "start": "1576440",
    "end": "1583840"
  },
  {
    "text": "a value type that implements this interface and then we just create an",
    "start": "1583840",
    "end": "1589840"
  },
  {
    "text": "instance of this value type and we send it to given",
    "start": "1589840",
    "end": "1594440"
  },
  {
    "text": "method as I told you at the beginning uh value types don't have the method table",
    "start": "1596200",
    "end": "1601679"
  },
  {
    "text": "pointer so when you want to invoke a virtual method of on",
    "start": "1601679",
    "end": "1607080"
  },
  {
    "text": "them in the non-constrained way what compiler does it emits a boxing",
    "start": "1607080",
    "end": "1613520"
  },
  {
    "text": "instruction which boxes the value and put it on the hip and gives it the method table pointer and now we can use",
    "start": "1613520",
    "end": "1620640"
  },
  {
    "text": "it as the interface and the problem here is that when we box things they are being put on",
    "start": "1620640",
    "end": "1626200"
  },
  {
    "text": "the hip and hip is not stuck so stuck is",
    "start": "1626200",
    "end": "1631600"
  },
  {
    "text": "preventing us from implementing interfaces in that case this is why span",
    "start": "1631600",
    "end": "1637520"
  },
  {
    "text": "is not implementing any existing interfaces like I numerable for example because somebody could by",
    "start": "1637520",
    "end": "1644840"
  },
  {
    "text": "accident box it and put it on the hip",
    "start": "1644840",
    "end": "1649679"
  },
  {
    "text": "and it's not the end when we use asyn AWA it's great for our code productivity",
    "start": "1650919",
    "end": "1657120"
  },
  {
    "text": "but what C compiler does it emits async method Builder which creates async State",
    "start": "1657120",
    "end": "1663480"
  },
  {
    "text": "machine and at some point of time it might put all of the parameters that you",
    "start": "1663480",
    "end": "1668559"
  },
  {
    "text": "have sent to the given asynchronous methods on the hip so this is why we cannot use spans as asynchronous method",
    "start": "1668559",
    "end": "1677159"
  },
  {
    "text": "parameters moreover they also cannot be filled in non stack only types because",
    "start": "1677159",
    "end": "1684559"
  },
  {
    "text": "they would be allocated on the hip one day and then they also cannot be generic",
    "start": "1684559",
    "end": "1692120"
  },
  {
    "text": "arguments a long L of limitations but only when it comes to passing them as arguments and when it",
    "start": "1692480",
    "end": "1701200"
  },
  {
    "text": "comes to generic arguments and Microsoft has few ideas how we can make SE span",
    "start": "1701200",
    "end": "1707279"
  },
  {
    "text": "usable for everybody so the idea is not production ready yet if you take a look at",
    "start": "1707279",
    "end": "1713960"
  },
  {
    "text": "documentation then they mention something like memory if you take a look at the code there is no sign of memory",
    "start": "1713960",
    "end": "1719799"
  },
  {
    "text": "type it's called buffer now and it's work in progress they work very hard the",
    "start": "1719799",
    "end": "1725919"
  },
  {
    "text": "span is being used in pipelines right now and really pipelines are going to",
    "start": "1725919",
    "end": "1731600"
  },
  {
    "text": "shape the API of the span and the idea to overcome this problem is something to",
    "start": "1731600",
    "end": "1737799"
  },
  {
    "text": "have type that has no um limitations it can be sent and put anywhere and it will",
    "start": "1737799",
    "end": "1744600"
  },
  {
    "text": "be our on demand span Factory so when you want to use span you just create a",
    "start": "1744600",
    "end": "1751200"
  },
  {
    "text": "span which will create the span for you in for example synchronous context or",
    "start": "1751200",
    "end": "1756679"
  },
  {
    "text": "wherever you need it and Sample implementation could have a pointer to unmanaged hip and just when you create",
    "start": "1756679",
    "end": "1763440"
  },
  {
    "text": "it you create a span from the pointer and when you are done using it you call this poose which is freeing the memory",
    "start": "1763440",
    "end": "1770799"
  },
  {
    "text": "the same comes from for the pulled memory we can just return it to the",
    "start": "1770799",
    "end": "1777559"
  },
  {
    "text": "pool but as I said uh this API is not production ready yet and the types are",
    "start": "1777559",
    "end": "1784320"
  },
  {
    "text": "called buffers and owned buffer and reference counted buffer if you would like to find out more you can go to",
    "start": "1784320",
    "end": "1790679"
  },
  {
    "text": "corix laap in net repository and check this out so let's sum up the spun",
    "start": "1790679",
    "end": "1798720"
  },
  {
    "text": "it allows us to work with any type of memory it's very fast it's small it's",
    "start": "1798720",
    "end": "1804279"
  },
  {
    "text": "just an abstraction for pointer arithmetics it allows us to create slices without coping memory which is",
    "start": "1804279",
    "end": "1810880"
  },
  {
    "text": "very important and it allows us to work with unsafe memory in very easy way it",
    "start": "1810880",
    "end": "1816120"
  },
  {
    "text": "also supports net standard one so you can use it in your existing applications it's on par with r when it",
    "start": "1816120",
    "end": "1824279"
  },
  {
    "text": "comes to Performance and but it's limited due to the stack only",
    "start": "1824279",
    "end": "1829480"
  },
  {
    "text": "requirements which can be worked",
    "start": "1829480",
    "end": "1833720"
  },
  {
    "text": "around now I would like to play a video for you it's a video from a game game is",
    "start": "1835600",
    "end": "1842360"
  },
  {
    "text": "called age of asent is being developed byat games the back end is being run on",
    "start": "1842360",
    "end": "1848279"
  },
  {
    "text": "net core on Microsoft Azure and my question to you is following",
    "start": "1848279",
    "end": "1854960"
  },
  {
    "text": "what has just",
    "start": "1858080",
    "end": "1860880"
  },
  {
    "text": "happened yeah you were right DC let's take a look at the hip of the",
    "start": "1866120",
    "end": "1873080"
  },
  {
    "text": "managed uh process so we have two types of objects small and large anything that",
    "start": "1873080",
    "end": "1879960"
  },
  {
    "text": "is bigger than 85,000 bytes is considered to be large object anything smaller is considered to be small",
    "start": "1879960",
    "end": "1887039"
  },
  {
    "text": "objects and small objects are allocated on the Gen zero when they survive the first collection they are being promoted",
    "start": "1887039",
    "end": "1893960"
  },
  {
    "text": "to gen one if they survive another they're being promoted to gen two and this model works great for uh short",
    "start": "1893960",
    "end": "1901639"
  },
  {
    "text": "living objects if you think of web application web request starts and ends",
    "start": "1901639",
    "end": "1907360"
  },
  {
    "text": "and most probably any a memory that you have allocated during handling of this web request should be cleaned up this is",
    "start": "1907360",
    "end": "1914480"
  },
  {
    "text": "why gen zero is very small to have very fast collect of small space of memory but the long",
    "start": "1914480",
    "end": "1921159"
  },
  {
    "text": "living objects are supposed to live in Gen 2 which is very big and it's really time consuming to clean it up and we",
    "start": "1921159",
    "end": "1928679"
  },
  {
    "text": "have large object hip which is a separate part but the real problem is",
    "start": "1928679",
    "end": "1934080"
  },
  {
    "text": "that every large object is marked out of the box as gen two object so when we run",
    "start": "1934080",
    "end": "1940360"
  },
  {
    "text": "out of memory in large object Hep DC performs full garbage collection and",
    "start": "1940360",
    "end": "1946279"
  },
  {
    "text": "this is what we have just seen full garbage collection in production what can we do about",
    "start": "1946279",
    "end": "1953200"
  },
  {
    "text": "this we can just pull the memory it's very simple pattern pull pattern and",
    "start": "1953200",
    "end": "1959159"
  },
  {
    "text": "finally we have good implementation that we can use and rely on R pool is a pool of rable managed RIS",
    "start": "1959159",
    "end": "1968200"
  },
  {
    "text": "it has a default Max size it's important I will talk more about this soon and it's available in system. buffers pocket",
    "start": "1968200",
    "end": "1975919"
  },
  {
    "text": "it's been in production for more than a year here you can use it don't worry and usage is very simple first of all we",
    "start": "1975919",
    "end": "1983000"
  },
  {
    "text": "need to obtain an instance of an pool we can do this with shared property which",
    "start": "1983000",
    "end": "1988440"
  },
  {
    "text": "returns us a shared pool with default Max size if you want something more R",
    "start": "1988440",
    "end": "1994600"
  },
  {
    "text": "pool has a create method which allows you to create your custom pool once you have it you rent the",
    "start": "1994600",
    "end": "2001399"
  },
  {
    "text": "buffer and you specify the minimum length what you get will be most probably bigger than what you have asked",
    "start": "2001399",
    "end": "2008399"
  },
  {
    "text": "for you just use it like you used it before when you were allocating Aris",
    "start": "2008399",
    "end": "2013760"
  },
  {
    "text": "with new and after you are done using it you just return it to the",
    "start": "2013760",
    "end": "2019278"
  },
  {
    "text": "pool and yeah let's take a look at some benchmarks let's don't trust the theory",
    "start": "2019519",
    "end": "2025279"
  },
  {
    "text": "when we compare 100 bytes we can see that allocating was faster when we get",
    "start": "2025279",
    "end": "2030880"
  },
  {
    "text": "to 1,000 bytes it almost equals but when we go up",
    "start": "2030880",
    "end": "2037840"
  },
  {
    "text": "and it's 10,000 bytes we can see that allocating was much more much slower",
    "start": "2037840",
    "end": "2043399"
  },
  {
    "text": "like nine times slower we don't want to get here but when we reach the limit of",
    "start": "2043399",
    "end": "2051480"
  },
  {
    "text": "large object uh so it means that 85,000 bytes here we have 1,00 100,000 bytes we",
    "start": "2051480",
    "end": "2059679"
  },
  {
    "text": "get gen two collections the red color this is what we want to avoid so we should be definitely pulling large",
    "start": "2059679",
    "end": "2066638"
  },
  {
    "text": "objects and as of now you should observe that the cost of renting and",
    "start": "2066639",
    "end": "2074839"
  },
  {
    "text": "returning is almost Conant it's always for my box it's something around 32",
    "start": "2074839",
    "end": "2081398"
  },
  {
    "text": "NS so it size independent so you can also predict how long your code is going",
    "start": "2081399",
    "end": "2086878"
  },
  {
    "text": "to take to execute but when we reach the max size",
    "start": "2086879",
    "end": "2093760"
  },
  {
    "text": "of pool it has Behavior that you maybe wouldn't",
    "start": "2093760",
    "end": "2099359"
  },
  {
    "text": "expect but when you think of it it's kind of obvious when you ask for something that is bigger than the max",
    "start": "2099359",
    "end": "2104920"
  },
  {
    "text": "size of given pool it's just allocating new AR for you every time and when you",
    "start": "2104920",
    "end": "2111119"
  },
  {
    "text": "want to put it back it's ignoring the reference to avoid some synchronization",
    "start": "2111119",
    "end": "2116160"
  },
  {
    "text": "in general so you wanted to save time but you have actually spent more time and you have allocated the memory the",
    "start": "2116160",
    "end": "2123359"
  },
  {
    "text": "solution to avoid this problem is that you can create custom pool that is aware of the size as I said previously we have",
    "start": "2123359",
    "end": "2130160"
  },
  {
    "text": "the create method which allows you to create bigger pool of bigger um",
    "start": "2130160",
    "end": "2136640"
  },
  {
    "text": "arise did somebody raise the hand",
    "start": "2136640",
    "end": "2141680"
  },
  {
    "text": "oh um Microsoft wants to help us to avoid this problem and we have an extra",
    "start": "2141680",
    "end": "2147640"
  },
  {
    "text": "event for that um EV events so uh we have new etw event provider which is",
    "start": "2147640",
    "end": "2154480"
  },
  {
    "text": "called system buffers R pool Event Source if you want you can use perview",
    "start": "2154480",
    "end": "2159680"
  },
  {
    "text": "to profile and to watch for this events what you will see is output like",
    "start": "2159680",
    "end": "2167480"
  },
  {
    "text": "this and what you should be looking for are buffer allocated events this is the",
    "start": "2167480",
    "end": "2173119"
  },
  {
    "text": "thing that we want to avoid we want to pull memory you want to see buffer rented and buffer returned in equal",
    "start": "2173119",
    "end": "2182359"
  },
  {
    "text": "count so every large object is considered to be Gen 2 object which means full garbage",
    "start": "2186119",
    "end": "2192079"
  },
  {
    "text": "collection when we run out of space in large object Hep R pool was designed for the best possible performance it was",
    "start": "2192079",
    "end": "2199359"
  },
  {
    "text": "tuned by people like Yan kotas and Steven toe and Ben Adams I don't think",
    "start": "2199359",
    "end": "2205040"
  },
  {
    "text": "that we can go any further H it's a pull for pulling",
    "start": "2205040",
    "end": "2210520"
  },
  {
    "text": "managed memory and you should use Shard by default it's important our goal was",
    "start": "2210520",
    "end": "2217119"
  },
  {
    "text": "to keep the large object hip small when you create too many pools too many",
    "start": "2217119",
    "end": "2222160"
  },
  {
    "text": "Custom Pools you will end up once again with a lot of large objects so this is",
    "start": "2222160",
    "end": "2228040"
  },
  {
    "text": "something that we want to avoid and this is why most of the libraries that are commonly used like castl isp. net core",
    "start": "2228040",
    "end": "2236119"
  },
  {
    "text": "image sharp they're using the shared pool so they don't create any",
    "start": "2236119",
    "end": "2241480"
  },
  {
    "text": "Custom Pools in your",
    "start": "2241480",
    "end": "2244560"
  },
  {
    "text": "code and the other problematic scenario that was found when Microsoft",
    "start": "2246520",
    "end": "2252839"
  },
  {
    "text": "was profiling their web application is following we have a method which is",
    "start": "2252839",
    "end": "2258200"
  },
  {
    "text": "asynchronous it's executed very very often but most of the time it could be",
    "start": "2258200",
    "end": "2264079"
  },
  {
    "text": "executed in synchronous way but all of the time when it could be",
    "start": "2264079",
    "end": "2269400"
  },
  {
    "text": "executed in synchronous way we allocate tasks and tasks are reference types so",
    "start": "2269400",
    "end": "2275359"
  },
  {
    "text": "we create an extra overhead for garbage collector if you want to some to get",
    "start": "2275359",
    "end": "2282119"
  },
  {
    "text": "some real example you can think of a network stream it downloads whole tunks of memory let's say 4 megabytes and you",
    "start": "2282119",
    "end": "2289640"
  },
  {
    "text": "might have an asynchronous Json deserializer working with the stream so most of the time stream already has the",
    "start": "2289640",
    "end": "2296880"
  },
  {
    "text": "bites for the Jon the serializer so it could provide the data without any allocations but previously it was",
    "start": "2296880",
    "end": "2304280"
  },
  {
    "text": "impossible and it was always allocating new task when the results when the data",
    "start": "2304280",
    "end": "2309880"
  },
  {
    "text": "was already present was already waiting to be consumed the solution for this",
    "start": "2309880",
    "end": "2315079"
  },
  {
    "text": "case is to use value task value task is a discriminated Union which means that we can create",
    "start": "2315079",
    "end": "2322119"
  },
  {
    "text": "value task out of result something that is a value is present or from asynchronous task so it",
    "start": "2322119",
    "end": "2330319"
  },
  {
    "text": "can wrap non executed task and it's supposed to help in this",
    "start": "2330319",
    "end": "2336319"
  },
  {
    "text": "single scenario unfortunately Val task doesn't have any",
    "start": "2336319",
    "end": "2341960"
  },
  {
    "text": "other usages this is why I believe that uh mostly people who work with networking",
    "start": "2341960",
    "end": "2349040"
  },
  {
    "text": "and creating software for other developers will play with validas but it's important to understand",
    "start": "2349040",
    "end": "2357880"
  },
  {
    "text": "uh how can we take full advantage of alask if we are in this scenario so",
    "start": "2357880",
    "end": "2363480"
  },
  {
    "text": "first of all we need to check if synchronous execution is possible if it's possible we call the synchronous",
    "start": "2363480",
    "end": "2369680"
  },
  {
    "text": "method and we just return a value task with given result we didn't allocate",
    "start": "2369680",
    "end": "2375200"
  },
  {
    "text": "anything on the hip when it's the opposite we need to call the as",
    "start": "2375200",
    "end": "2380319"
  },
  {
    "text": "synchronous method which will allocate asynchronous task and we just wrap it",
    "start": "2380319",
    "end": "2385960"
  },
  {
    "text": "into a value TK and by default this method is not",
    "start": "2385960",
    "end": "2392079"
  },
  {
    "text": "going to be in lined because it's going to be too big and it's returning a big value type so so you might need to apply",
    "start": "2392079",
    "end": "2398920"
  },
  {
    "text": "aggressive inlining attribute if you also would like to gain benefits from",
    "start": "2398920",
    "end": "2404240"
  },
  {
    "text": "inlining and how not to consume the the value task we cannot simply await",
    "start": "2404240",
    "end": "2410839"
  },
  {
    "text": "it because C compiler will once again emit a lot of code behind for us and it",
    "start": "2410839",
    "end": "2417240"
  },
  {
    "text": "will make the code complex and we wanted it to be very simple for our hot Puff",
    "start": "2417240",
    "end": "2423640"
  },
  {
    "text": "the solution is quite trivial we just called the method which returns a task value task",
    "start": "2423640",
    "end": "2430359"
  },
  {
    "text": "and it's possible to be in lined so we have another benefit and we check for",
    "start": "2430359",
    "end": "2435680"
  },
  {
    "text": "the hot puff is it completed okay I just take the result otherwise I await the",
    "start": "2435680",
    "end": "2441240"
  },
  {
    "text": "inner task and here comes to play the asynchron state machine context",
    "start": "2441240",
    "end": "2446400"
  },
  {
    "text": "switching and all of this so we were interested in the hot puff and unfortunately we have to do it this way",
    "start": "2446400",
    "end": "2454079"
  },
  {
    "text": "like manually if we do it in the wrong",
    "start": "2454079",
    "end": "2459839"
  },
  {
    "text": "way as I told showed you on the first example it's actually going to take more",
    "start": "2459839",
    "end": "2466119"
  },
  {
    "text": "time that when we do it properly so it's a trap and as you can",
    "start": "2466119",
    "end": "2471920"
  },
  {
    "text": "see the benefit is that we don't allocate any managed memory the difference in uh um time",
    "start": "2471920",
    "end": "2480319"
  },
  {
    "text": "isn't that big and this Benchmark was just about the super positive example",
    "start": "2480319",
    "end": "2486640"
  },
  {
    "text": "for measuring the overhead so it means that in all of the cases I knew that I could execute in synchronous and I was",
    "start": "2486640",
    "end": "2493440"
  },
  {
    "text": "returning simple value so it's just about measuring the overhead and as you",
    "start": "2493440",
    "end": "2499480"
  },
  {
    "text": "can see on the right we have gen zero collections so for tasks there were some",
    "start": "2499480",
    "end": "2505599"
  },
  {
    "text": "gen zero collections but they were also some gen one Collections and why did we have gen one",
    "start": "2505599",
    "end": "2512240"
  },
  {
    "text": "collections so tasks are reference types and they have final izers to handle",
    "start": "2512240",
    "end": "2519079"
  },
  {
    "text": "unhandled exceptions so anytime a DC decides that something is a garbage but",
    "start": "2519079",
    "end": "2525319"
  },
  {
    "text": "it has a finalizer it's promoting it to the next garbage uh collection",
    "start": "2525319",
    "end": "2530520"
  },
  {
    "text": "generation and it puts it to the finalizer Q after cleaning up the memory",
    "start": "2530520",
    "end": "2535839"
  },
  {
    "text": "the finalizers are being executed and then the Gen one can be collected in",
    "start": "2535839",
    "end": "2542119"
  },
  {
    "text": "next cleanup so they survive at least one generation collection",
    "start": "2542119",
    "end": "2547720"
  },
  {
    "text": "so it's important to avoid creating a lot of them if we can in high performance",
    "start": "2547720",
    "end": "2555240"
  },
  {
    "text": "scenarios it's important to remember that it's not about replacing task it's to about to help in this single scenario",
    "start": "2556640",
    "end": "2564240"
  },
  {
    "text": "where we can avoid Hep limitations and maybe we can get some benefits of the",
    "start": "2564240",
    "end": "2570079"
  },
  {
    "text": "method in lining and to do so we need to play with the is completed property and the result property",
    "start": "2570079",
    "end": "2578400"
  },
  {
    "text": "is completed is it does it forward to the task or is it",
    "start": "2580319",
    "end": "2585359"
  },
  {
    "text": "only for the value",
    "start": "2585359",
    "end": "2588318"
  },
  {
    "text": "T the sense that that you will you won't go into a where the task finished just after you",
    "start": "2592240",
    "end": "2600520"
  },
  {
    "text": "check this complet yeah so um the method is implemented in a way that uh it checks",
    "start": "2600520",
    "end": "2606720"
  },
  {
    "text": "if t is null if it's null it checks it returns true which means that it was created for a",
    "start": "2606720",
    "end": "2613960"
  },
  {
    "text": "value and uh one very important thing valid task is a part of corx and it's",
    "start": "2613960",
    "end": "2619800"
  },
  {
    "text": "open source so we can analyze the code on our",
    "start": "2619800",
    "end": "2625240"
  },
  {
    "text": "own and there is one extra feature for the performance geks so uh as you know C",
    "start": "2625240",
    "end": "2631920"
  },
  {
    "text": "is being compiled to I code which offers us a lot of feature but C off offers as",
    "start": "2631920",
    "end": "2637640"
  },
  {
    "text": "only a subset of the things that I can do some of them are sometimes required",
    "start": "2637640",
    "end": "2644200"
  },
  {
    "text": "when you want to go really high performance for example you would like to do managed pointer arithmetics",
    "start": "2644200",
    "end": "2650839"
  },
  {
    "text": "previously we didn't have managed pointers in CP so this methods are not exposed in C and this class is a simple",
    "start": "2650839",
    "end": "2660319"
  },
  {
    "text": "single I file compiled for you and which you can consume in your C code so if if",
    "start": "2660319",
    "end": "2667200"
  },
  {
    "text": "you ever want to get something from AEL that is not available in C there is this",
    "start": "2667200",
    "end": "2672880"
  },
  {
    "text": "new class which exposes most of the possible methods for example uh if you",
    "start": "2672880",
    "end": "2679440"
  },
  {
    "text": "want to copy memory it emits the copy bulk instruction which is supposed to be",
    "start": "2679440",
    "end": "2685160"
  },
  {
    "text": "implemented by run times and which is supposed to be the fastest way to copy memory another example if you want to",
    "start": "2685160",
    "end": "2691839"
  },
  {
    "text": "get size of any type then in C we have a size of operator but it works only for",
    "start": "2691839",
    "end": "2697359"
  },
  {
    "text": "Primitives like integers if you want to get size of of your custom structure it doesn't work so but as I said it's in a",
    "start": "2697359",
    "end": "2706160"
  },
  {
    "text": "situation when you really want to take full advantage of the",
    "start": "2706160",
    "end": "2712640"
  },
  {
    "text": "IL who of you have been today to Adam talk about net",
    "start": "2713119",
    "end": "2721200"
  },
  {
    "text": "standard okay and who of you is developing up live is for other",
    "start": "2721319",
    "end": "2729800"
  },
  {
    "text": "developers okay so we have quite a lot of uh up developers and also some",
    "start": "2730400",
    "end": "2737559"
  },
  {
    "text": "libraries so previously we had when you were trying",
    "start": "2737559",
    "end": "2742920"
  },
  {
    "text": "to publish a nugget package you had to Target all of the Frameworks that you wanted to support So if you wanted to",
    "start": "2742920",
    "end": "2750079"
  },
  {
    "text": "support net for okay this was your first Target what about Mono another Target",
    "start": "2750079",
    "end": "2755640"
  },
  {
    "text": "what about zarine another Target and here Microsoft wanted to add few more",
    "start": "2755640",
    "end": "2761280"
  },
  {
    "text": "Frameworks net core 1.1 2.0 universal windows platform so what",
    "start": "2761280",
    "end": "2768720"
  },
  {
    "text": "that people should be now targeting six of them no and Microsoft has decided to",
    "start": "2768720",
    "end": "2776040"
  },
  {
    "text": "like inverse the dependency and you can think as of doet standard as of a set of",
    "start": "2776040",
    "end": "2782280"
  },
  {
    "text": "interfaces and now every framework is supposed to implement a standard",
    "start": "2782280",
    "end": "2788079"
  },
  {
    "text": "and as a library author you just Target the standard and your code can be",
    "start": "2788079",
    "end": "2793280"
  },
  {
    "text": "executed on any framework that is uh compilant with the",
    "start": "2793280",
    "end": "2798319"
  },
  {
    "text": "standard but if you are just a library consumer then what you need to know is that you need the latest visual studio",
    "start": "2798319",
    "end": "2805040"
  },
  {
    "text": "and the latest nugget client and then your tool chain will understand what net standard is and you will be able to use",
    "start": "2805040",
    "end": "2812319"
  },
  {
    "text": "all of the new things in your existing desktop. net applications",
    "start": "2812319",
    "end": "2817520"
  },
  {
    "text": "and the good thing is that all of them Target almost the lowest standard only",
    "start": "2817520",
    "end": "2823480"
  },
  {
    "text": "uh system buffers which contains rol Target",
    "start": "2823480",
    "end": "2827960"
  },
  {
    "text": "1.1 and as I told you previously I was supposed to speak about pipelines but",
    "start": "2830200",
    "end": "2835800"
  },
  {
    "text": "David did so I decided that I will take this time and speak about something else and recently I've been watching",
    "start": "2835800",
    "end": "2841920"
  },
  {
    "text": "Microsoft build and the PM of C said something like this during his stock we",
    "start": "2841920",
    "end": "2847920"
  },
  {
    "text": "sort of want Push unsafe code out of C in a way or more to the corner having more lowlevel code that is safe and",
    "start": "2847920",
    "end": "2855119"
  },
  {
    "text": "efficient and at this moment I have smiled and then he",
    "start": "2855119",
    "end": "2860359"
  },
  {
    "text": "said something like this you can go to the GitHub and see what is rumbling there so I decided that I will analyze",
    "start": "2860359",
    "end": "2867440"
  },
  {
    "text": "all of the issues available documentation language design meetings notes and prepare a list for you of all",
    "start": "2867440",
    "end": "2875200"
  },
  {
    "text": "of the new possible features that can help us in terms of performance but one",
    "start": "2875200",
    "end": "2880880"
  },
  {
    "text": "very important feature uh thing I will now speculate so I'm not Microsoft",
    "start": "2880880",
    "end": "2886720"
  },
  {
    "text": "employee I'm not promising you anything I'm just speculating and I'm just saying about things that I have found they are",
    "start": "2886720",
    "end": "2893040"
  },
  {
    "text": "in the official repository but there are plans they can be",
    "start": "2893040",
    "end": "2898240"
  },
  {
    "text": "changed first feature maybe we'll be able to Define stock only user defined",
    "start": "2898520",
    "end": "2905119"
  },
  {
    "text": "types so we'll be do we will be able to do so by applying the ref keyword in",
    "start": "2905119",
    "end": "2910440"
  },
  {
    "text": "front of type definition what compiler is going to do",
    "start": "2910440",
    "end": "2915920"
  },
  {
    "text": "is going toit is ref like um attribute but how can they prevent the old",
    "start": "2915920",
    "end": "2922520"
  },
  {
    "text": "compilers from using this new stack only types which need which needs a lot of",
    "start": "2922520",
    "end": "2928000"
  },
  {
    "text": "safety rules to make sure that everything works",
    "start": "2928000",
    "end": "2933000"
  },
  {
    "text": "correctly the current idea is to all Al emit obsolete",
    "start": "2933160",
    "end": "2939960"
  },
  {
    "text": "attribute which will trick the old compilers because when they see the Obsolete and it's rough like they think",
    "start": "2939960",
    "end": "2947119"
  },
  {
    "text": "okay this is obsolete I cannot use it the new compilers will be able to ignore it this is the plan I've seen that a lot",
    "start": "2947119",
    "end": "2954520"
  },
  {
    "text": "of people don't like this idea and I also have no idea what would happen if I as a user would define stack only type",
    "start": "2954520",
    "end": "2962119"
  },
  {
    "text": "and then decide to make it obsolete",
    "start": "2962119",
    "end": "2967000"
  },
  {
    "text": "another thing um so maybe some background information when I say that",
    "start": "2968319",
    "end": "2974200"
  },
  {
    "text": "CLR offers us type and memory safety we need to understand how is it done so",
    "start": "2974200",
    "end": "2979559"
  },
  {
    "text": "when you execute your iil code for the first time CLR is doing I verification",
    "start": "2979559",
    "end": "2984799"
  },
  {
    "text": "so it verifies the I and it makes sure that you didn't write I by hand and",
    "start": "2984799",
    "end": "2989920"
  },
  {
    "text": "didn't produce any code that can do some magic with pointers and to create any",
    "start": "2989920",
    "end": "2995119"
  },
  {
    "text": "problems with memory and that way it ensures memory safety when you go unsafe you have no longer that guarantee and",
    "start": "2995119",
    "end": "3003079"
  },
  {
    "text": "possible plan is to make stack only spans to make it possible to allocate",
    "start": "3003079",
    "end": "3009400"
  },
  {
    "text": "memory with stack a lock and make it in safe context without using the unsafe",
    "start": "3009400",
    "end": "3015000"
  },
  {
    "text": "the problem is that the compiler will need to implement a lot of safety features and also take responsibility",
    "start": "3015000",
    "end": "3023599"
  },
  {
    "text": "for making it work for all of us in all of the possible scenarios so this is why",
    "start": "3023599",
    "end": "3029400"
  },
  {
    "text": "I have put three question marks here another feature uh I believe it's",
    "start": "3029400",
    "end": "3037079"
  },
  {
    "text": "that this is one of the rather obvious features as of today we can take a reference to a field but it's impossible",
    "start": "3037079",
    "end": "3042520"
  },
  {
    "text": "for readon fields and this is why a lot of people break immutability for example if you",
    "start": "3042520",
    "end": "3048200"
  },
  {
    "text": "take a look at the no time some of the value types fields are not read only but they should be just to avoid copying of",
    "start": "3048200",
    "end": "3055440"
  },
  {
    "text": "memory so so we will have a new set of keywords readon ref which for the",
    "start": "3055440",
    "end": "3060880"
  },
  {
    "text": "incoming parameters might be shortened to in so we will be able to take readon",
    "start": "3060880",
    "end": "3067200"
  },
  {
    "text": "reference of a readon field return a readon reference accept readon reference",
    "start": "3067200",
    "end": "3072720"
  },
  {
    "text": "but we will not be able to create a readon local",
    "start": "3072720",
    "end": "3077760"
  },
  {
    "text": "reference another thing which was already merged but to a branch is read",
    "start": "3080520",
    "end": "3086119"
  },
  {
    "text": "only rors so we will have the possibility to define a read only type and from now on as I told you",
    "start": "3086119",
    "end": "3093559"
  },
  {
    "text": "previously in any method if you have a value type you can use that this keyword and you can use it to mutate your own",
    "start": "3093559",
    "end": "3100319"
  },
  {
    "text": "state so this is why for now C was emitting Cod like this to avoid copying",
    "start": "3100319",
    "end": "3105839"
  },
  {
    "text": "to make sure that you will be really in new table so nothing bad happens here so with on readon keyword the type will be",
    "start": "3105839",
    "end": "3113599"
  },
  {
    "text": "readon and this keyword will point to read only reference so you will not be",
    "start": "3113599",
    "end": "3119520"
  },
  {
    "text": "able to to change anything so I also believe that it's not only for performance but also for making",
    "start": "3119520",
    "end": "3128200"
  },
  {
    "text": "immutability a first class citizen for the C language and it might solve a lot of issues that we have so",
    "start": "3128200",
    "end": "3136920"
  },
  {
    "text": "far this feature is quite trivial let's just make the extension methods for valy",
    "start": "3136920",
    "end": "3142960"
  },
  {
    "text": "types R likee so we don't need to copy when we want to invoke an extension",
    "start": "3142960",
    "end": "3149880"
  },
  {
    "text": "method and by the way this is possible as of today in Visual Basic so Visual Basic in at least one",
    "start": "3149880",
    "end": "3157280"
  },
  {
    "text": "case is better than c as of today and now bleed table",
    "start": "3157280",
    "end": "3164359"
  },
  {
    "text": "types so I told you that we have unmanaged memory and managed memory and",
    "start": "3164359",
    "end": "3169480"
  },
  {
    "text": "we cannot put reference types to unmanaged hip because when garbage collector is updating pointers it would",
    "start": "3169480",
    "end": "3176559"
  },
  {
    "text": "not know that some of the pointers needs to be updated and we can put some very",
    "start": "3176559",
    "end": "3183240"
  },
  {
    "text": "primitive Types on the UN manner tip and they are called ble table types so we",
    "start": "3183240",
    "end": "3188559"
  },
  {
    "text": "might have the possibility to have ble table user defined types and we are going to have a compile time",
    "start": "3188559",
    "end": "3196079"
  },
  {
    "text": "verification of all of the safety routines as of today uh the idea uh the proposal wasn't",
    "start": "3196079",
    "end": "3204720"
  },
  {
    "text": "merged there is still ongoing discussion but what I as a performance guy would like to do with this is to extend one of",
    "start": "3204720",
    "end": "3212079"
  },
  {
    "text": "the span methods and to be able to cast spans of one ble table types to another",
    "start": "3212079",
    "end": "3218119"
  },
  {
    "text": "types ble table types and think of this you have a network stream which has a array of bytes you create span out of",
    "start": "3218119",
    "end": "3225240"
  },
  {
    "text": "this it's span of bytes but you know that internally it's representing value types bits ble table",
    "start": "3225240",
    "end": "3232760"
  },
  {
    "text": "value types so with simple operation like cust we would would like to be a we would be able to get our types without",
    "start": "3232760",
    "end": "3241319"
  },
  {
    "text": "any memory allocations just with few pointer arithmetics and few math operations without any",
    "start": "3241319",
    "end": "3248720"
  },
  {
    "text": "allocations so let's sum up my talk I would like you to start using value types more often please use references",
    "start": "3251119",
    "end": "3258799"
  },
  {
    "text": "to avoid copying and try use them to get rid of unsafe to be fully",
    "start": "3258799",
    "end": "3263880"
  },
  {
    "text": "safe you should use span to avoid coping when it comes to slicing when it you can",
    "start": "3263880",
    "end": "3269599"
  },
  {
    "text": "use it in parsing formatting you can help corx laap you can start to contribute and make it happen faster uh",
    "start": "3269599",
    "end": "3277799"
  },
  {
    "text": "moreover you can also use span to take full advantage of done safe memory because it's an abstraction you don't",
    "start": "3277799",
    "end": "3284359"
  },
  {
    "text": "need to care what kind of memory it is you should also pull the large objects it's very easy with r pull you can use a",
    "start": "3284359",
    "end": "3292160"
  },
  {
    "text": "value task but only in this single scenario unfortunately",
    "start": "3292160",
    "end": "3297200"
  },
  {
    "text": "and if you want to go out of c and use full iel power you can use the new",
    "start": "3297200",
    "end": "3302799"
  },
  {
    "text": "unsafe class and please please support C 7.2 ideas it's very important I'm one of",
    "start": "3302799",
    "end": "3311040"
  },
  {
    "text": "the contributors of f repositories and it's really cool when people click thumbs up because then the maintainers",
    "start": "3311040",
    "end": "3317920"
  },
  {
    "text": "know that somebody likes this idea and would like it to be implemented it's very important it's the first step for",
    "start": "3317920",
    "end": "3325039"
  },
  {
    "text": "our net ecosystem syst at least say that you like something at least click",
    "start": "3325039",
    "end": "3331480"
  },
  {
    "text": "once it doesn't cost anything I'm not asking you for any donations",
    "start": "3331480",
    "end": "3336599"
  },
  {
    "text": "so here is the list of all of the sources which you'll be able to find under this address I have put all",
    "start": "3336599",
    "end": "3344240"
  },
  {
    "text": "of the places where I took Knowledge from and if you would like to learn more about the benchmarks here is the link",
    "start": "3344240",
    "end": "3350960"
  },
  {
    "text": "for the benchmarks so thank you very much",
    "start": "3350960",
    "end": "3356400"
  },
  {
    "text": "[Music]",
    "start": "3364470",
    "end": "3367820"
  }
]