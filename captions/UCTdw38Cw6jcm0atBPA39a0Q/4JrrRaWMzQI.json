[
  {
    "text": "time to begin for us so good morning and welcome everyone thanks you for thank you for coming to this talk my name is",
    "start": "3040",
    "end": "9840"
  },
  {
    "text": "adam furmanek and today we are going to talk a little about async very hot topic",
    "start": "9840",
    "end": "14960"
  },
  {
    "text": "recently like for the last decade in c-sharp obviously and but today what we are going to do is we will see it from a",
    "start": "14960",
    "end": "22400"
  },
  {
    "text": "different angle we will see whether async in c-sharp was implemented in the right way whether the way it was",
    "start": "22400",
    "end": "29920"
  },
  {
    "text": "implemented allowed us to actually gain the most of the performance and all the benefits we could get and if there are",
    "start": "29920",
    "end": "37120"
  },
  {
    "text": "any drawbacks to the implementation we have in c sharp especially in the light of the project loom in java which was",
    "start": "37120",
    "end": "43920"
  },
  {
    "text": "released quite recently and which turned the table significantly so this is what",
    "start": "43920",
    "end": "49520"
  },
  {
    "text": "we are going to do for the next hour we will discuss how async is implemented what the pros and cons are and how to",
    "start": "49520",
    "end": "56559"
  },
  {
    "text": "re-implement it using different approach namely fibers as you can see we'll learn",
    "start": "56559",
    "end": "61680"
  },
  {
    "text": "what fibers are how they can be used in windows and whether it's possible to get some",
    "start": "61680",
    "end": "67439"
  },
  {
    "text": "other benefits from this implementation before we move on couple what about me",
    "start": "67439",
    "end": "72560"
  },
  {
    "text": "i'm a software engineer for over a decade now i written also two technical",
    "start": "72560",
    "end": "77840"
  },
  {
    "text": "books one about dotnet one about applied maths uh especially integer linear programming and how it can be used in",
    "start": "77840",
    "end": "84880"
  },
  {
    "text": "programming i'm also an author of uh of random it utensils blog at",
    "start": "84880",
    "end": "90600"
  },
  {
    "text": "blog.adamformance.po i encourage you to take a look if you are interested in things like this and also drop me a line",
    "start": "90600",
    "end": "97200"
  },
  {
    "text": "or email twitter whatever works for you too so you can reach out to me after this talk if you had any questions feel",
    "start": "97200",
    "end": "104560"
  },
  {
    "text": "free to ask them anytime feel free to interrupt also you can wait until the very end will cover all of that",
    "start": "104560",
    "end": "112159"
  },
  {
    "text": "okay moving on the agenda for today's talk is first we'll try to understand",
    "start": "112159",
    "end": "117280"
  },
  {
    "text": "why was async introduced in the fur in the beginning why was it useful what it",
    "start": "117280",
    "end": "122320"
  },
  {
    "text": "tried to solve and we'll see whether it solved it or not then we'll learn some",
    "start": "122320",
    "end": "127600"
  },
  {
    "text": "other concepts in software engineering like operating system level threads",
    "start": "127600",
    "end": "132800"
  },
  {
    "text": "green threads core routines call cc and other stuff which can be used to structure our applications a little",
    "start": "132800",
    "end": "139280"
  },
  {
    "text": "differently and ultimately at the very end we will just go to the demos showing you how we could implement async in",
    "start": "139280",
    "end": "146160"
  },
  {
    "text": "different approach the similar approach that java took on which is way different",
    "start": "146160",
    "end": "151599"
  },
  {
    "text": "than what other languages are doing so the first thing why async",
    "start": "151599",
    "end": "157040"
  },
  {
    "text": "uh probably you know that since the very early days of of dotnet development we",
    "start": "157040",
    "end": "162560"
  },
  {
    "text": "always had this need to be able to execute some code like outside of the main execution flow we always wanted to",
    "start": "162560",
    "end": "169599"
  },
  {
    "text": "run something in background calculate something on the side so that's why we wanted to have this ability to get a",
    "start": "169599",
    "end": "175120"
  },
  {
    "text": "part of this code and just run it somewhere else in some different way without actually paying attention to all",
    "start": "175120",
    "end": "181680"
  },
  {
    "text": "those little nasty details how those things are executed and the first thing we could use to do that was asynchronous",
    "start": "181680",
    "end": "187840"
  },
  {
    "text": "programming model apm for short so we had this pattern in c-sharp language which was based on two methods one of",
    "start": "187840",
    "end": "194560"
  },
  {
    "text": "them named begin something and the counterpart named and something which allowed us to execute the calculation on",
    "start": "194560",
    "end": "202480"
  },
  {
    "text": "some other thread context something else we didn't need to think about how it was",
    "start": "202480",
    "end": "208159"
  },
  {
    "text": "executed but generally it was executed somewhere the idea was that we just",
    "start": "208159",
    "end": "213280"
  },
  {
    "text": "triggered the operation and then when we want to utilize the result we have this end method which either gives us the",
    "start": "213280",
    "end": "220959"
  },
  {
    "text": "result if it's already available or it blocks until we get the result we also",
    "start": "220959",
    "end": "226720"
  },
  {
    "text": "had to provide this lambda which would do that like the continuation part so when the result is done do this thing so",
    "start": "226720",
    "end": "233280"
  },
  {
    "text": "that was the first pattern the second pattern we could use was eap even base asynchronous programming model which was",
    "start": "233280",
    "end": "239439"
  },
  {
    "text": "based on the idea that we have this background worker where we can submit our jobs to be executed the piece of",
    "start": "239439",
    "end": "245519"
  },
  {
    "text": "code we want to run and it was triggered executed on this background thingy and then we had the continuation",
    "start": "245519",
    "end": "252400"
  },
  {
    "text": "used in a way of attaching a callback so we had a callback which we could attach to the worker when the",
    "start": "252400",
    "end": "259120"
  },
  {
    "text": "thing to execute to calculate we was finished we had this callback being",
    "start": "259120",
    "end": "264639"
  },
  {
    "text": "triggered so executed by the by the platform so that's yet another approach we had obviously it could be configured",
    "start": "264639",
    "end": "271280"
  },
  {
    "text": "canceled and all that stuff we would expect from like a decent mechanism to support the problem with that was with",
    "start": "271280",
    "end": "277440"
  },
  {
    "text": "bose mechanism was that they did not necessarily allow us to structure the code in the linear way like both here in",
    "start": "277440",
    "end": "285440"
  },
  {
    "text": "this eap we had to provide this callback similarly here in this android thingy we",
    "start": "285440",
    "end": "290800"
  },
  {
    "text": "also had those we were we had those callbacks which were executed when things were done what we wanted to do",
    "start": "290800",
    "end": "296880"
  },
  {
    "text": "instead we wanted to have a continuation wrapped as a first class citizen as an",
    "start": "296880",
    "end": "302639"
  },
  {
    "text": "object which we could just carry around pass from one method to the other which would encapsulate everything which is to",
    "start": "302639",
    "end": "309759"
  },
  {
    "text": "be done not only the code but also the parameters all the continuations",
    "start": "309759",
    "end": "315199"
  },
  {
    "text": "security features like user id impersonation whatever reliability",
    "start": "315199",
    "end": "322560"
  },
  {
    "text": "context whatever else whatever you imagine right all those had to be captured in one single object which was",
    "start": "322560",
    "end": "329600"
  },
  {
    "text": "task which we could just carry around so that's how tap task-based",
    "start": "329600",
    "end": "334720"
  },
  {
    "text": "asynchronous pattern started and we had this idea that we want to create one single task which allows us to",
    "start": "334720",
    "end": "341199"
  },
  {
    "text": "encapsulate the logic and then we could wrap them together with the powerful continue with method typically the way",
    "start": "341199",
    "end": "349039"
  },
  {
    "text": "we used it was that we just added continue with and provided yet another lambda however there were multiple",
    "start": "349039",
    "end": "355360"
  },
  {
    "text": "different parameters like to continue only if there was an exception or if there were no exceptions or continue on",
    "start": "355360",
    "end": "361919"
  },
  {
    "text": "different tasks scheduler different threat pool whatever else multiple different things if you are interested",
    "start": "361919",
    "end": "368000"
  },
  {
    "text": "more in details how this thing was constructed etc i encourage you to take a look at my talk which is internals of",
    "start": "368000",
    "end": "374639"
  },
  {
    "text": "async you can find it on youtube and you will learn all about that stuff so this is what pap gave us and also",
    "start": "374639",
    "end": "382639"
  },
  {
    "text": "nice part about tap was it was super simple to actually make it parallel it",
    "start": "382639",
    "end": "387759"
  },
  {
    "text": "was super straightforward to run it on multiple threads thanks to peeling what we had to do is just do dot us parallel",
    "start": "387759",
    "end": "395199"
  },
  {
    "text": "and then bang all the magical functions we could use with link were executed like in parallel obviously.net did quite",
    "start": "395199",
    "end": "402000"
  },
  {
    "text": "a lot of scaffolding under the hood also calculating whether it's worth running things on multiple threads or whether",
    "start": "402000",
    "end": "408160"
  },
  {
    "text": "they should still go on a single threaded model whatever else it was taken care of by the by the platform but",
    "start": "408160",
    "end": "414720"
  },
  {
    "text": "the only thing we had to do was as parallel and we were all good so that was the idea the problem with this",
    "start": "414720",
    "end": "421599"
  },
  {
    "text": "approach was that hey we are still wrapping those things in tasks we still",
    "start": "421599",
    "end": "426639"
  },
  {
    "text": "have those tasks flying around from left to right and we need to use this continue with method where we just need",
    "start": "426639",
    "end": "432800"
  },
  {
    "text": "to provide this yet another lambda which still allows us to go more or less like",
    "start": "432800",
    "end": "437919"
  },
  {
    "text": "linearly but still we have those details exposed so that's why async and await",
    "start": "437919",
    "end": "444240"
  },
  {
    "text": "came to the game and there was one more super important thing why async now it was introduced it was to allow us to",
    "start": "444240",
    "end": "451680"
  },
  {
    "text": "write the code which does not block the operating system level threat we'll get to that a little later however before",
    "start": "451680",
    "end": "459039"
  },
  {
    "text": "getting to those details let's see uh a little like funny remarks about these inaudible first thing is you can await",
    "start": "459039",
    "end": "466800"
  },
  {
    "text": "anything which is away table it means it's very similar to the forage loop you",
    "start": "466800",
    "end": "472080"
  },
  {
    "text": "do not need to have any i enumerable eye whatever rater on top of the collection",
    "start": "472080",
    "end": "477599"
  },
  {
    "text": "you'd like to enumerate over the only thing you need to do is you need to use the duct typing if the collection gives",
    "start": "477599",
    "end": "483919"
  },
  {
    "text": "you the move next and the current then you can do forage over it there is no interface needed same thing applies to",
    "start": "483919",
    "end": "491599"
  },
  {
    "text": "acing and awaits you need to use the duct typing to and if you have a type which is called away table meaning that",
    "start": "491599",
    "end": "498080"
  },
  {
    "text": "it gives you this method called get a waiter which returns your type which allows you to check whether the result",
    "start": "498080",
    "end": "504160"
  },
  {
    "text": "is available or or to to continue on the when the result appears then you can",
    "start": "504160",
    "end": "510479"
  },
  {
    "text": "await on anything meaning that we can actually await on any integer so let's",
    "start": "510479",
    "end": "515839"
  },
  {
    "text": "go to a very very first simple demo so what we are doing is we are trying to await an integer so you can see that",
    "start": "515839",
    "end": "523360"
  },
  {
    "text": "first thingy we do have some code which slept for like two seconds okay and the",
    "start": "523360",
    "end": "528800"
  },
  {
    "text": "thing which is happening under the hood is we are just calling a weight two 2000 so we are awaiting 2000 milliseconds",
    "start": "528800",
    "end": "536399"
  },
  {
    "text": "how's that possible the only thing you need to do is you provide an extension method and you extend the integer type",
    "start": "536399",
    "end": "543839"
  },
  {
    "text": "to return the away table type so it does have the method called getawater which",
    "start": "543839",
    "end": "549760"
  },
  {
    "text": "returns you any away table type and under the hood we are just doing task delay and returning the same thingy",
    "start": "549760",
    "end": "555760"
  },
  {
    "text": "which task delay would return so when we call this a weight 2000 what it does",
    "start": "555760",
    "end": "561440"
  },
  {
    "text": "under the hood is it calls integer get awaiter so it finds the extension method",
    "start": "561440",
    "end": "568000"
  },
  {
    "text": "we we have below it gives the the code the away table type and we can just wait",
    "start": "568000",
    "end": "573519"
  },
  {
    "text": "for it obviously not suggesting that you should go and rewrite all your integers to be available in your code base but",
    "start": "573519",
    "end": "580000"
  },
  {
    "text": "this gives you the idea that hey anything can be our table and that's the power of the of the async and away that",
    "start": "580000",
    "end": "587040"
  },
  {
    "text": "you can use it with basically anything you'd like to to go with so",
    "start": "587040",
    "end": "593120"
  },
  {
    "text": "that's the thing that's the first thing we also know that async and now it gives us this ability to basically write the",
    "start": "593120",
    "end": "598880"
  },
  {
    "text": "code like linearly right we don't need to think about attaching continuations we just do await bank we are good that's",
    "start": "598880",
    "end": "604720"
  },
  {
    "text": "what documentation tells us right there are tons of problems with that and again",
    "start": "604720",
    "end": "609920"
  },
  {
    "text": "i encourage i refer you to yet my another talk which is called like all the why async is the worst idea in c",
    "start": "609920",
    "end": "616800"
  },
  {
    "text": "sharp you can find it not youtube obviously but what we are going to do for to focus on today is the third part",
    "start": "616800",
    "end": "622240"
  },
  {
    "text": "of the async which is a synchronous code does not block the operating system",
    "start": "622240",
    "end": "628720"
  },
  {
    "text": "level thread and this like very simple sentence actually gives us a lot of time like a",
    "start": "628720",
    "end": "636399"
  },
  {
    "text": "lot of useful information first we cannot block that's the important thing but what is even more important",
    "start": "636399",
    "end": "642880"
  },
  {
    "text": "here is we cannot block the operating system level threat meaning that with async and await we can",
    "start": "642880",
    "end": "650240"
  },
  {
    "text": "actually block but not on the os fret and this is what we are going to utilize",
    "start": "650240",
    "end": "655920"
  },
  {
    "text": "under the hood we will see how the blocking is implemented currently in c-sharp and then we will see how it",
    "start": "655920",
    "end": "662720"
  },
  {
    "text": "could be implemented in different way so this is what's up next",
    "start": "662720",
    "end": "668079"
  },
  {
    "text": "and in order to get all of that we need to go through all those like three big",
    "start": "668079",
    "end": "673279"
  },
  {
    "text": "deals of async and awaiting c-sharps so the first big deal is async and c-sharp is implemented as a co-routine compiler",
    "start": "673279",
    "end": "680160"
  },
  {
    "text": "level transformation that's very magical term which we'll see later on but which",
    "start": "680160",
    "end": "685440"
  },
  {
    "text": "tells us that whenever you write a method which is marked as async compiler",
    "start": "685440",
    "end": "690480"
  },
  {
    "text": "steps in and rewrites this method into the state machine so we'll get that a little",
    "start": "690480",
    "end": "697279"
  },
  {
    "text": "later also similar thing was happening with viewed keyword compiler was basically restructuring all your methods",
    "start": "697279",
    "end": "704000"
  },
  {
    "text": "to provide this core routine like experience the second part is c-sharp async in c-sharp is implemented as a",
    "start": "704000",
    "end": "710399"
  },
  {
    "text": "service locator for promise orchestration meaning that there is a static global",
    "start": "710399",
    "end": "716000"
  },
  {
    "text": "variable named synchronization context which gives you like the service locator",
    "start": "716000",
    "end": "721279"
  },
  {
    "text": "behavior into how you schedule the continuations because depending on what",
    "start": "721279",
    "end": "726320"
  },
  {
    "text": "application you run if it's like a desktop application or if it's like a web application or if it's a blazer",
    "start": "726320",
    "end": "732959"
  },
  {
    "text": "thingy then your continuations need to be scheduled differently in desktop applications they can go on one thread",
    "start": "732959",
    "end": "740480"
  },
  {
    "text": "only because whenever you await on the user interface the callback needs to be",
    "start": "740480",
    "end": "745519"
  },
  {
    "text": "executed on the same thread which manages your ui why is that because otherwise it would have no access to the",
    "start": "745519",
    "end": "752079"
  },
  {
    "text": "ui components buttons labels etc you would get exception that you are trying to access the ui from some other thread",
    "start": "752079",
    "end": "759279"
  },
  {
    "text": "however in the web world the only thing we need to take off is that the",
    "start": "759279",
    "end": "764480"
  },
  {
    "text": "continuation needs to be executed in the context of the same web request you do",
    "start": "764480",
    "end": "769600"
  },
  {
    "text": "not need to care whether it's exactly the same thread operating system level thread but you only want to the only",
    "start": "769600",
    "end": "776399"
  },
  {
    "text": "thing you want to care about is that it's inquired in the same web request so",
    "start": "776399",
    "end": "781760"
  },
  {
    "text": "you have access to the same like request headers response headers whatever similarly in blazer because we are",
    "start": "781760",
    "end": "788560"
  },
  {
    "text": "running in javascript mode then we need to inject everything into the javascript like this one single fret pumping",
    "start": "788560",
    "end": "795600"
  },
  {
    "text": "mechanism so this is why the synchronization context needs to take care of that and hands up if you ever",
    "start": "795600",
    "end": "801760"
  },
  {
    "text": "heard about synchronization context there are a couple of hands that's great for all of you who never heard about",
    "start": "801760",
    "end": "807519"
  },
  {
    "text": "that that's the power of acing and await that is a service locator which you do not need to even think about however it",
    "start": "807519",
    "end": "814560"
  },
  {
    "text": "gives you tons of issues if you are trying to go with like multiple threads when it's expecting single level threads",
    "start": "814560",
    "end": "820320"
  },
  {
    "text": "so then you have deadlocks and all that stuff again referring due to some other sources but generally it can become",
    "start": "820320",
    "end": "825440"
  },
  {
    "text": "nasty and the third part of async in c sharp is that it has statically bound promise factories what does it tell us",
    "start": "825440",
    "end": "832880"
  },
  {
    "text": "the task type which we use in c sharp is known in multiple different languages like a promise like future depending on",
    "start": "832880",
    "end": "839920"
  },
  {
    "text": "which language you're using you have different nomenclature right but the thing is it has the statically bound",
    "start": "839920",
    "end": "845199"
  },
  {
    "text": "promise factories meaning that you have need to have a factory creating you this promise and then c-sharp it's statically",
    "start": "845199",
    "end": "852399"
  },
  {
    "text": "bound because you specify the type which is returned from the method you always need to specify that it's what it's a",
    "start": "852399",
    "end": "858959"
  },
  {
    "text": "task but at some point dotnetplatformer.net team realized that hey tasks are very heavy they are",
    "start": "858959",
    "end": "866320"
  },
  {
    "text": "garbage collected and all that they have all the draw like drawbacks of being like regular gc managed objects so let's",
    "start": "866320",
    "end": "874000"
  },
  {
    "text": "introduce something which is passed via stack so what happened we had to rewrite all our functions from task to val to",
    "start": "874000",
    "end": "880399"
  },
  {
    "text": "value task right again that's a nasty issue with async because hey it's statically bound so during this talk",
    "start": "880399",
    "end": "888000"
  },
  {
    "text": "we'll address all those three big pieces of async and 08 and see if we can do",
    "start": "888000",
    "end": "893920"
  },
  {
    "text": "better so let's move on the async important thing about async",
    "start": "893920",
    "end": "899680"
  },
  {
    "text": "the mechanism which was introduced in c-sharp was actually one of the first mechanisms out there in the enterprise",
    "start": "899680",
    "end": "907120"
  },
  {
    "text": "world it influenced multiple other languages obviously there were other like some niche languages which did",
    "start": "907120",
    "end": "914240"
  },
  {
    "text": "support things like that but c-sharp was the first big one to support those and",
    "start": "914240",
    "end": "919519"
  },
  {
    "text": "it influenced others for instance casco python javascript typescript etc all of",
    "start": "919519",
    "end": "924639"
  },
  {
    "text": "them implemented async and await basically in the same way meaning that there was this scoring transformation",
    "start": "924639",
    "end": "931199"
  },
  {
    "text": "there was some service locator for orchestrating continuations and there was some well-known type either like",
    "start": "931199",
    "end": "938160"
  },
  {
    "text": "more directly exposed or hidden via duct typing whatever else but generally there",
    "start": "938160",
    "end": "943279"
  },
  {
    "text": "was this type which supported the asynchronous programming however it does not need to be implemented this",
    "start": "943279",
    "end": "950079"
  },
  {
    "text": "way and when i was preparing this talk for the first time it was before java 17 was released which was couple years back",
    "start": "950079",
    "end": "957120"
  },
  {
    "text": "and they were working on a different approach which was called project loom now this project loom was already",
    "start": "957120",
    "end": "963360"
  },
  {
    "text": "released so what i'm going to show you is conceptually equivalent to what they",
    "start": "963360",
    "end": "968399"
  },
  {
    "text": "are doing in java so now they have their own async and await and it will work the way i'm going to show you today",
    "start": "968399",
    "end": "975360"
  },
  {
    "text": "obviously they are they implemented it with their own platform yada yada but generally conceptually indifferent and i",
    "start": "975360",
    "end": "982000"
  },
  {
    "text": "was always saying that well we don't know which approach is better when it comes to performance",
    "start": "982000",
    "end": "988240"
  },
  {
    "text": "usability etc we still do not know that because java released it quite uh quite",
    "start": "988240",
    "end": "993360"
  },
  {
    "text": "recently so we do not have all the data points however we already see that their approach may be way more efficient for",
    "start": "993360",
    "end": "1000880"
  },
  {
    "text": "for instance now there is there was a very interesting example released like literally a couple days ago that the guy",
    "start": "1000880",
    "end": "1008480"
  },
  {
    "text": "implemented a method or an application which is able to handle 50 million",
    "start": "1008480",
    "end": "1013920"
  },
  {
    "text": "concurrent connections on one single box this is something we cannot do with with",
    "start": "1013920",
    "end": "1019600"
  },
  {
    "text": "c sharp if you ever heard about c 10k problem or the challenge to handle 10 10",
    "start": "1019600",
    "end": "1025918"
  },
  {
    "text": "000 concurrent connections on one single machine this guy made a big step forward to see 50 million concurrent connections",
    "start": "1025919",
    "end": "1034079"
  },
  {
    "text": "so generally the thing is that this different approach may be way better in terms of performance but we'll actually see that",
    "start": "1034079",
    "end": "1040959"
  },
  {
    "text": "in like five years from now because we didn't know how it will perform how it will behave the same we didn't know",
    "start": "1040959",
    "end": "1047038"
  },
  {
    "text": "about async and await in c sharp now like a decade later we already know that c sharp's implementation has tons of",
    "start": "1047039",
    "end": "1053840"
  },
  {
    "text": "various problems when it comes to deadlocking when it comes to rewriting the code colorful functions but we",
    "start": "1053840",
    "end": "1059840"
  },
  {
    "text": "generally know it's beneficial if we don't know yet whether java's approach is better we'll get to know that in",
    "start": "1059840",
    "end": "1066080"
  },
  {
    "text": "couple of years moving on in order to understand all those three big pieces we'll need to go",
    "start": "1066080",
    "end": "1072480"
  },
  {
    "text": "through some theory so let's dwell into operating system level threat and what else we can use to implement",
    "start": "1072480",
    "end": "1078480"
  },
  {
    "text": "asynchronous programming so the native thread the first thing we need to know is whenever we actually",
    "start": "1078480",
    "end": "1084720"
  },
  {
    "text": "execute something at the very bottom of the runtime and execution platform there is there is a thing which is provided by",
    "start": "1084720",
    "end": "1091120"
  },
  {
    "text": "the operating system which is a native fret so this is the thread you create with your win api or p frets or whatever",
    "start": "1091120",
    "end": "1098080"
  },
  {
    "text": "else is basically a thread so a piece of machinery which allows you to run a task",
    "start": "1098080",
    "end": "1103679"
  },
  {
    "text": "something on the which is written or named by the cpu architecture as a task",
    "start": "1103679",
    "end": "1108720"
  },
  {
    "text": "so there are two different types of threads foregrounded background threads they need to have the stack so memory",
    "start": "1108720",
    "end": "1114880"
  },
  {
    "text": "allocated for the stack uh in windows when we are talking about like windows 10 or windows 11 64-bit a typical",
    "start": "1114880",
    "end": "1123440"
  },
  {
    "text": "application or a typical thread has three different stacks one for kernel space one for user space and one for the",
    "start": "1123440",
    "end": "1130880"
  },
  {
    "text": "windows on windows 64 execution mechanism and taking into account that by default user space stack consumes",
    "start": "1130880",
    "end": "1138320"
  },
  {
    "text": "around one megabyte of memory which may or may not be committed like from the from the very beginning but typically it",
    "start": "1138320",
    "end": "1145280"
  },
  {
    "text": "may be means that whenever you create a new fret it allocates one megabyte of memory",
    "start": "1145280",
    "end": "1150720"
  },
  {
    "text": "so that's why they are telling you hey do not create threads by hand because if you try to create 50 millions of them",
    "start": "1150720",
    "end": "1157960"
  },
  {
    "text": "250 millions concurrent connections you would have quite a lot of memory consumed right for doing nothing yet",
    "start": "1157960",
    "end": "1165520"
  },
  {
    "text": "important thing windows and the same goes for linux generally anything running on x86 architecture schedules",
    "start": "1165520",
    "end": "1173600"
  },
  {
    "text": "threats not processes meaning that the the threat has its own priority and its",
    "start": "1173600",
    "end": "1180080"
  },
  {
    "text": "own time slice and it's scheduled by the operating system uh on top of that dot net platform gives",
    "start": "1180080",
    "end": "1187200"
  },
  {
    "text": "you that managed thread so it takes the native thread and drops it into the system threading dot thread class which",
    "start": "1187200",
    "end": "1194720"
  },
  {
    "text": "handles the operating system level thread gives you quite a couple of interesting features like you can name a",
    "start": "1194720",
    "end": "1200480"
  },
  {
    "text": "thread you can attach an id to that so if you are dumping a memory and then",
    "start": "1200480",
    "end": "1205600"
  },
  {
    "text": "analyzing your memory dumps then you can see the the names of the threads so generally whenever you create a new",
    "start": "1205600",
    "end": "1211440"
  },
  {
    "text": "thread always give it a name give a name to it so then when you are trying to",
    "start": "1211440",
    "end": "1216480"
  },
  {
    "text": "like debug memory dumps you see what this thread was supposed to be doing and not only what it's doing",
    "start": "1216480",
    "end": "1222720"
  },
  {
    "text": "uh generally it pre-commits the stack when a thread is created meaning that",
    "start": "1222720",
    "end": "1227760"
  },
  {
    "text": "whenever you create a new thread in dot net it does allocate the memory for you and also if you have an unaccounted",
    "start": "1227760",
    "end": "1234640"
  },
  {
    "text": "exception on a thread it kills your application so generally whenever you create a thread always do try catch",
    "start": "1234640",
    "end": "1241840"
  },
  {
    "text": "catch everything so your application doesn't die give it a name and then let it go so this is",
    "start": "1241840",
    "end": "1247919"
  },
  {
    "text": "what we have at the very at the very bottom now the concept of operating system",
    "start": "1247919",
    "end": "1253760"
  },
  {
    "text": "level threat is very useful for us because well everything in user space needs to use some kind of threading",
    "start": "1253760",
    "end": "1260000"
  },
  {
    "text": "machinery however nothing stops us from implementing threads in like the user",
    "start": "1260000",
    "end": "1266159"
  },
  {
    "text": "space so what we do is we can create our own threads running entirely in net entirely",
    "start": "1266159",
    "end": "1273039"
  },
  {
    "text": "in c-sharp and not being run and managed by the operating system level threat and those are called green threads the name",
    "start": "1273039",
    "end": "1280720"
  },
  {
    "text": "green actually comes from java again because java started with their own",
    "start": "1280720",
    "end": "1286000"
  },
  {
    "text": "implementation on the frets and it was developed by the green team in sun",
    "start": "1286000",
    "end": "1291039"
  },
  {
    "text": "microsystems so that's why they called them green threads and their names stayed",
    "start": "1291039",
    "end": "1296640"
  },
  {
    "text": "around for a little longer so that's why we are calling them green threads the thing about green threads is they are",
    "start": "1296640",
    "end": "1302960"
  },
  {
    "text": "not scheduled by the os just like a couple slides back i told you that windows",
    "start": "1302960",
    "end": "1309039"
  },
  {
    "text": "schedule frets this is different here it's not with windows which schedules frets but it's there a runtime platform",
    "start": "1309039",
    "end": "1315919"
  },
  {
    "text": "so it would be net jvm javascript v8 engine whatever you you name and now the",
    "start": "1315919",
    "end": "1322240"
  },
  {
    "text": "important thing about that is you need to run those threads on top of something",
    "start": "1322240",
    "end": "1327679"
  },
  {
    "text": "so now you have the idea of mapping your green threads to operating system level",
    "start": "1327679",
    "end": "1333039"
  },
  {
    "text": "threads so you can go with multiple different mappings you can go with direct mapping one to one so one green",
    "start": "1333039",
    "end": "1339200"
  },
  {
    "text": "thread is one os fret or you could go with multiple frets going to a single os",
    "start": "1339200",
    "end": "1344559"
  },
  {
    "text": "fret or any way you wish so your threads can migrate can carry their their state",
    "start": "1344559",
    "end": "1350080"
  },
  {
    "text": "in between different os threats etc so generally we can re-implement anything",
    "start": "1350080",
    "end": "1355520"
  },
  {
    "text": "the important part is we need to take care of everything when we are doing that so that's why most platforms do not",
    "start": "1355520",
    "end": "1362240"
  },
  {
    "text": "want to do that but nothing stops us from doing so the advantages are first",
    "start": "1362240",
    "end": "1368640"
  },
  {
    "text": "if we are taking care of creating those threats this can be way faster because",
    "start": "1368640",
    "end": "1374240"
  },
  {
    "text": "we do not need to switch to the kernel thread and the user space kernel space user space back and forth right we can",
    "start": "1374240",
    "end": "1380720"
  },
  {
    "text": "do all the scheduling directly in the user space which can be faster so",
    "start": "1380720",
    "end": "1386240"
  },
  {
    "text": "depending on the which implementation you use you may actually see some performance gains with green threads",
    "start": "1386240",
    "end": "1393200"
  },
  {
    "text": "however there are also issues with that because we are just running those green",
    "start": "1393200",
    "end": "1398799"
  },
  {
    "text": "threads on top of native threads you cannot use actually multiple processors",
    "start": "1398799",
    "end": "1404960"
  },
  {
    "text": "depending on which scheme you have if you are mapping like n threads to a single os fret then at some point in",
    "start": "1404960",
    "end": "1412880"
  },
  {
    "text": "time only one green thread can be executed right because you're mapping to one os fret you cannot get true",
    "start": "1412880",
    "end": "1418880"
  },
  {
    "text": "parallelism with this approach with this mapping you need to go with something slightly more clever but generally the",
    "start": "1418880",
    "end": "1425520"
  },
  {
    "text": "the the outcome is you cannot get the full parallels move this way also when",
    "start": "1425520",
    "end": "1431279"
  },
  {
    "text": "it comes to the i o operations we have this drawback that whenever we have n threads which needs to be executed by",
    "start": "1431279",
    "end": "1438240"
  },
  {
    "text": "your runtime when a thread gets blocked for instance because you did file readal",
    "start": "1438240",
    "end": "1443840"
  },
  {
    "text": "text and you are waiting for the data to arrive then effectively all those end threads are being blocked why because",
    "start": "1443840",
    "end": "1451200"
  },
  {
    "text": "your operating system level threat is suspended waiting for the data so whenever you go with this approach you",
    "start": "1451200",
    "end": "1457360"
  },
  {
    "text": "always need to go with asynchronous operations all the way down otherwise you have issues and you you cannot get",
    "start": "1457360",
    "end": "1464159"
  },
  {
    "text": "the performance but that's the idea there are obviously different variations of this concept depending on the",
    "start": "1464159",
    "end": "1470159"
  },
  {
    "text": "language like erlang uses green processors because they do not share the memory it's generally julia uses",
    "start": "1470159",
    "end": "1476880"
  },
  {
    "text": "something different python uses tasks generally it's the same concept but there are details in implementation",
    "start": "1476880",
    "end": "1484000"
  },
  {
    "text": "moving on so we have operating system level frets on top of them we could build green frets what would the green",
    "start": "1484000",
    "end": "1491600"
  },
  {
    "text": "threads give us the idea is that we can assign work to different green threads",
    "start": "1491600",
    "end": "1497600"
  },
  {
    "text": "and whenever we want to await something we can switch to a different green thread right and operating system does",
    "start": "1497600",
    "end": "1504159"
  },
  {
    "text": "not need to know about that but we could take a different approach we can go with",
    "start": "1504159",
    "end": "1509279"
  },
  {
    "text": "thing called core routines instead of having a method which allows",
    "start": "1509279",
    "end": "1514640"
  },
  {
    "text": "us just to be executed like once from the very beginning to the very end when there is the return keyword what we can",
    "start": "1514640",
    "end": "1521360"
  },
  {
    "text": "do instead is we can come up with a method which can be suspended and resumed and the method which can return",
    "start": "1521360",
    "end": "1529200"
  },
  {
    "text": "a value multiple times and this is the code co routine so generally a single",
    "start": "1529200",
    "end": "1534880"
  },
  {
    "text": "routine is basically a very specific case of corrupting which returns just once",
    "start": "1534880",
    "end": "1540159"
  },
  {
    "text": "meaning that when we have a core routine a core routine can decide when it wants to return a value and the question is",
    "start": "1540159",
    "end": "1547919"
  },
  {
    "text": "how can that be useful for us and the answer is what we do have in",
    "start": "1547919",
    "end": "1553440"
  },
  {
    "text": "c-sharp is the yield keyword and this is basically a core routine what we do have",
    "start": "1553440",
    "end": "1559039"
  },
  {
    "text": "is we have a for loop counting from zero to whatever and we do want to return multiple values so we do yield return it",
    "start": "1559039",
    "end": "1566640"
  },
  {
    "text": "returns multiple values as you can see whenever you call yield return this method is suspended you can take the",
    "start": "1566640",
    "end": "1573440"
  },
  {
    "text": "value use it and then when someone wants to get another value it resumes the method and waits for another value now",
    "start": "1573440",
    "end": "1580320"
  },
  {
    "text": "the question is how is that implemented under the hood and couple slides back i told you that compiler uses core routine",
    "start": "1580320",
    "end": "1587279"
  },
  {
    "text": "transformation and this is exactly the place where the core routine transformation happens so when we have a",
    "start": "1587279",
    "end": "1593760"
  },
  {
    "text": "method like from the slide which we've seen which is just four lubely turning value this is what compiler creates for",
    "start": "1593760",
    "end": "1600000"
  },
  {
    "text": "you under the hood it gets the creates the class which has a method get counter",
    "start": "1600000",
    "end": "1606320"
  },
  {
    "text": "returning you i enumerator and what it does next is it creates a very nasty",
    "start": "1606320",
    "end": "1612960"
  },
  {
    "text": "class generated by the compiler which holds things like state current value",
    "start": "1612960",
    "end": "1618320"
  },
  {
    "text": "and all that stuff and provides a method which is called move next which does all",
    "start": "1618320",
    "end": "1623520"
  },
  {
    "text": "the heavy lifting so whenever you call this method if you see how the compiler generates",
    "start": "1623520",
    "end": "1630480"
  },
  {
    "text": "the code for you like the color of this method calls getcounter and gets the",
    "start": "1630480",
    "end": "1635559"
  },
  {
    "text": "ienumerator class ienumerator instance and then repeatedly calls move next",
    "start": "1635559",
    "end": "1641679"
  },
  {
    "text": "method on top of that and this move next method it knows where it is and it",
    "start": "1641679",
    "end": "1647120"
  },
  {
    "text": "reworks this whole forage loop the for loop here it reworks all the exception",
    "start": "1647120",
    "end": "1652640"
  },
  {
    "text": "handling all the stuff and just knows where to carry on from after you get the",
    "start": "1652640",
    "end": "1658080"
  },
  {
    "text": "value so you call move next it calculates the next value returns this",
    "start": "1658080",
    "end": "1663200"
  },
  {
    "text": "value which you can later get using the using the current property and this is",
    "start": "1663200",
    "end": "1669520"
  },
  {
    "text": "how you operate you get the innumerator from here you call move next it tells",
    "start": "1669520",
    "end": "1675200"
  },
  {
    "text": "you hey i do have another value returns you true then you go to current get the value then you call move next again and",
    "start": "1675200",
    "end": "1681919"
  },
  {
    "text": "so on this is what is happening with the yield keyword and interestingly enough",
    "start": "1681919",
    "end": "1688080"
  },
  {
    "text": "the same thingy is happening with async and await but we will get to that in a",
    "start": "1688080",
    "end": "1693919"
  },
  {
    "text": "sec so drawbacks of this idea of this approach is they introduce the so-called",
    "start": "1693919",
    "end": "1700080"
  },
  {
    "text": "function coloring whenever we have this yield return we cannot just go with",
    "start": "1700080",
    "end": "1706000"
  },
  {
    "text": "method returning integer right we need to return i enumerator of integer right",
    "start": "1706000",
    "end": "1711760"
  },
  {
    "text": "or i am numerable of integer we cannot go with just a single value we always",
    "start": "1711760",
    "end": "1716799"
  },
  {
    "text": "need to go with the collection so this is called function coloring we have colorless functions which can return",
    "start": "1716799",
    "end": "1723919"
  },
  {
    "text": "anything and we have colored functions which can return anything wrapped inside",
    "start": "1723919",
    "end": "1729679"
  },
  {
    "text": "the collection inside the i enumerable so the problem with that is",
    "start": "1729679",
    "end": "1734720"
  },
  {
    "text": "those methods can not necessarily be used in like void contexts right you",
    "start": "1734720",
    "end": "1740159"
  },
  {
    "text": "cannot await your method in a constructor right because if you do await it then you would need to call",
    "start": "1740159",
    "end": "1746960"
  },
  {
    "text": "await on the method however then you would need to return a task from the constructor but you cannot return a task",
    "start": "1746960",
    "end": "1752880"
  },
  {
    "text": "from the constructor because you're just returning the instance so there's one problem the other problem is well your",
    "start": "1752880",
    "end": "1758799"
  },
  {
    "text": "async methods they generally cannot return void i mean technically it's possible but gives you so many problems",
    "start": "1758799",
    "end": "1765440"
  },
  {
    "text": "that better not do that but generally this is something we can't do in in all",
    "start": "1765440",
    "end": "1770559"
  },
  {
    "text": "the contexts we would like to do also when it comes to exception handling they change a lot they also increase the",
    "start": "1770559",
    "end": "1776640"
  },
  {
    "text": "memory allocation because we need to create the intermediate collections etc",
    "start": "1776640",
    "end": "1781679"
  },
  {
    "text": "generally multiple problems even though this gives us quite a lot of benefits now how does it work with async if we",
    "start": "1781679",
    "end": "1788640"
  },
  {
    "text": "take a method like this and we have console.writeline await writeline await yada yada what the",
    "start": "1788640",
    "end": "1794960"
  },
  {
    "text": "compiler does under the hood is first it creates you this our async method so we",
    "start": "1794960",
    "end": "1801279"
  },
  {
    "text": "start with our async method here and we have a series of print lines and and the weights so it gives you this method",
    "start": "1801279",
    "end": "1808320"
  },
  {
    "text": "which looks very like straightforward right but what it does under the hood it utilizes again",
    "start": "1808320",
    "end": "1814559"
  },
  {
    "text": "some compiler generated type which does all the heavy lifting again we have the",
    "start": "1814559",
    "end": "1820000"
  },
  {
    "text": "move next method which handles all the different states which does the switch case which breaks which jumps around you",
    "start": "1820000",
    "end": "1827200"
  },
  {
    "text": "can even go to here so generally an sd code and it awaits all the stuff returns",
    "start": "1827200",
    "end": "1832399"
  },
  {
    "text": "you all these things so this is the code which is generated 130 lines for this",
    "start": "1832399",
    "end": "1837840"
  },
  {
    "text": "single method so this is the core routine transformation done for you by the shop compiler the",
    "start": "1837840",
    "end": "1844880"
  },
  {
    "text": "important thing is that this c-sharp compiler transformation is like transparent for the net platform meaning",
    "start": "1844880",
    "end": "1851120"
  },
  {
    "text": "that's the advantage of async your dot net platform does not need to know anything about asynchronous code because",
    "start": "1851120",
    "end": "1857519"
  },
  {
    "text": "compiler does the heavy lifting so this is why it's way simpler to implement because you can just do it in the",
    "start": "1857519",
    "end": "1863440"
  },
  {
    "text": "compiler you don't need to have any runtime support nor the operating system support",
    "start": "1863440",
    "end": "1870159"
  },
  {
    "text": "okay so that's yet another approach now when it comes to a different thing we",
    "start": "1870159",
    "end": "1875760"
  },
  {
    "text": "could do is we can go with a thing which is called continuation passing style instead of writing a method which gives",
    "start": "1875760",
    "end": "1883200"
  },
  {
    "text": "us a value we can write a method which gives the value to the continuation and",
    "start": "1883200",
    "end": "1889840"
  },
  {
    "text": "calls the continuation sounds tricky but generally is rather straightforward let's see this is the action let's say",
    "start": "1889840",
    "end": "1896399"
  },
  {
    "text": "that we would like to calculate a fibonacci number so the regular implementation would be hey give me a",
    "start": "1896399",
    "end": "1902080"
  },
  {
    "text": "fibonacci of n so n fibonacci number right what we do is some black magic",
    "start": "1902080",
    "end": "1908080"
  },
  {
    "text": "with switch case and then returning the fibonacci but the ultimately what we do is we just return the value okay this is",
    "start": "1908080",
    "end": "1915679"
  },
  {
    "text": "what we do we return the value so whenever we want to print this value what we do is we calculate we call the",
    "start": "1915679",
    "end": "1922559"
  },
  {
    "text": "fibonacci method here and then this value which is being returned is",
    "start": "1922559",
    "end": "1927679"
  },
  {
    "text": "actually passed to this point okay because we get the value and then pass it through with cps what we do is",
    "start": "1927679",
    "end": "1935279"
  },
  {
    "text": "we ask the method to continue for us so that's the difference this method knows",
    "start": "1935279",
    "end": "1940960"
  },
  {
    "text": "now not only gets the parameter hey which fibonacci would like to calculate",
    "start": "1940960",
    "end": "1946240"
  },
  {
    "text": "but also what would you like to do next so this is the cps continuation passing",
    "start": "1946240",
    "end": "1952320"
  },
  {
    "text": "style and the difference is we call the fibonacci passing it the parameter we",
    "start": "1952320",
    "end": "1957600"
  },
  {
    "text": "want the 10th fibonacci number and we also ask the method hey when you are done",
    "start": "1957600",
    "end": "1963200"
  },
  {
    "text": "do not get back to me do not give me the result what you should do instead is",
    "start": "1963200",
    "end": "1968240"
  },
  {
    "text": "just call this code code is lambda so this is the cps and you can obviously see this approach with the task wrapper",
    "start": "1968240",
    "end": "1975039"
  },
  {
    "text": "right task continue with when you are done don't give me the result by go with this continuation what does this give us",
    "start": "1975039",
    "end": "1981919"
  },
  {
    "text": "well this approach if we bend our minds a little more this allows us to implement",
    "start": "1981919",
    "end": "1987919"
  },
  {
    "text": "a thing which is called co-cc call with current continuation so what this allows",
    "start": "1987919",
    "end": "1993360"
  },
  {
    "text": "us is we can actually turn the things inside out to implement any construction",
    "start": "1993360",
    "end": "1999679"
  },
  {
    "text": "instruction controls we would like to have for instance to implement like the the break return or whatever else and",
    "start": "1999679",
    "end": "2006720"
  },
  {
    "text": "now how would the continue go with cc call with current continuation look like in c sharp",
    "start": "2006720",
    "end": "2012880"
  },
  {
    "text": "so let's say that we have a regular method which accepts the continuation",
    "start": "2012880",
    "end": "2018320"
  },
  {
    "text": "okay and what we do in this foo method is we first call this continuation",
    "start": "2018320",
    "end": "2023679"
  },
  {
    "text": "passing it number two or value two and then we return free and ultimately we print the value returned by the function",
    "start": "2023679",
    "end": "2030799"
  },
  {
    "text": "so this is a regular c sharp so this returns free right like the continuation",
    "start": "2030799",
    "end": "2036399"
  },
  {
    "text": "here which is passed here is basically the empty lambda so it doesn't matter okay but now if we had call with cc in",
    "start": "2036399",
    "end": "2044240"
  },
  {
    "text": "c-sharp what we would do is we could call cc sorry for that we could call cc",
    "start": "2044240",
    "end": "2050480"
  },
  {
    "text": "foo this way so then the compiler what it would do or the runtime what it would do is it would",
    "start": "2050480",
    "end": "2057280"
  },
  {
    "text": "take everything following the full execution so everything following the",
    "start": "2057280",
    "end": "2062398"
  },
  {
    "text": "full execution is probably a thing like this one so then this mingy is ultimately wrapped",
    "start": "2062399",
    "end": "2068960"
  },
  {
    "text": "into a lambda continuation which is then passed as this bar okay so now when fu",
    "start": "2068960",
    "end": "2076079"
  },
  {
    "text": "calls the bar continuation so when we call bar with number two what happens next is the foo is being terminated and",
    "start": "2076079",
    "end": "2083358"
  },
  {
    "text": "we continue with the continuation and the continuation is this thingy so the console.writeline so then it prints two",
    "start": "2083359",
    "end": "2090158"
  },
  {
    "text": "so this is the pattern which we can take and this is exactly like async and await is yet another way of using this pattern",
    "start": "2090159",
    "end": "2098640"
  },
  {
    "text": "even in a very narrow context we just want to await the the thingy and then continue with it but this is what the",
    "start": "2098640",
    "end": "2105200"
  },
  {
    "text": "compiler does for us so this is when it comes to cps green",
    "start": "2105200",
    "end": "2110400"
  },
  {
    "text": "threads and all that stuff and now to get it a little more usable for us what we need to use is there is a",
    "start": "2110400",
    "end": "2117440"
  },
  {
    "text": "thingy there is a question i believe right",
    "start": "2117440",
    "end": "2121520"
  },
  {
    "text": "uh that's a made-up syntax because c sharp does not support call with current continuation this is",
    "start": "2126560",
    "end": "2133200"
  },
  {
    "text": "how it could look like in c sharp how you would call with parameters probably parenthesis and etc",
    "start": "2133200",
    "end": "2140400"
  },
  {
    "text": "cool uh moving on then so fibers we already covered operating system level threads we covered green",
    "start": "2140480",
    "end": "2147599"
  },
  {
    "text": "threads now windows provides you a thing which is called a fiber that's a",
    "start": "2147599",
    "end": "2153040"
  },
  {
    "text": "green level thread implemented by the win api the idea with fiber is that basically",
    "start": "2153040",
    "end": "2159359"
  },
  {
    "text": "it's a thread which is cooperatively multitasked meaning that a thread asks",
    "start": "2159359",
    "end": "2164720"
  },
  {
    "text": "to be rescheduled so similarly to what we have with coroutines you need to have async you",
    "start": "2164720",
    "end": "2171200"
  },
  {
    "text": "have to have an await keyword or yield return keyword to indicate where you",
    "start": "2171200",
    "end": "2176560"
  },
  {
    "text": "want to switch the context so this is the cooperative multitasking but it's implemented by the win api",
    "start": "2176560",
    "end": "2183359"
  },
  {
    "text": "so the problem of this approach is that gives you a significant memory usage because it's implemented in the windows",
    "start": "2183359",
    "end": "2190560"
  },
  {
    "text": "api so in the kernel mode so it cannot use um like it doesn't give you all the",
    "start": "2190560",
    "end": "2196000"
  },
  {
    "text": "performance benefits however it also have this drawback off because it's a green level thread when you have",
    "start": "2196000",
    "end": "2202320"
  },
  {
    "text": "multiple fibers you need to use the asynchronous programming model to do at the i o otherwise you block all the",
    "start": "2202320",
    "end": "2209040"
  },
  {
    "text": "fibers and you you cannot get the performance and you cannot use all the things for locking etc but generally",
    "start": "2209040",
    "end": "2215280"
  },
  {
    "text": "this allows us to implement the green thread approach like super simple because we have it already exposed so",
    "start": "2215280",
    "end": "2222640"
  },
  {
    "text": "what do we need to do imagine that we now want to implement async",
    "start": "2222640",
    "end": "2227680"
  },
  {
    "text": "knowing all the things about green level threats about the continuation passing style about the core routines we want to",
    "start": "2227680",
    "end": "2234720"
  },
  {
    "text": "use fibers of the green level threads to implement async how do we need to do that technically we need to call a",
    "start": "2234720",
    "end": "2241119"
  },
  {
    "text": "couple of win api methods to convert a threat to fiber and then we can use switch to fiber to switch between",
    "start": "2241119",
    "end": "2248079"
  },
  {
    "text": "threads how do we do that to do async this is the part next part of this talk so let's",
    "start": "2248079",
    "end": "2254560"
  },
  {
    "text": "see what we are going to do let's close this one let's start with the regular ac example and see what we",
    "start": "2254560",
    "end": "2262400"
  },
  {
    "text": "are doing so uh let's start this up first the important thing about async as i",
    "start": "2262400",
    "end": "2268720"
  },
  {
    "text": "mentioned is that we cannot block the operating system level threat that's the",
    "start": "2268720",
    "end": "2273920"
  },
  {
    "text": "crucial point of asynchronous programming if at any point of time we block the os fret then there is no using",
    "start": "2273920",
    "end": "2281760"
  },
  {
    "text": "ac at all what we are doing is we will have a demo uh an example code which",
    "start": "2281760",
    "end": "2287440"
  },
  {
    "text": "will use multiple times throughout the demo to show you what we are tweaking with so first thing we are doing is we",
    "start": "2287440",
    "end": "2293760"
  },
  {
    "text": "want to execute two tasks like in parallel concurrently side by side first",
    "start": "2293760",
    "end": "2298880"
  },
  {
    "text": "of them is run internal and then we have some interjected side job they don't do",
    "start": "2298880",
    "end": "2303920"
  },
  {
    "text": "anything special run internal is just a calling run internal nested which sleeps",
    "start": "2303920",
    "end": "2309200"
  },
  {
    "text": "for two seconds awaits the sleep returns some data yada yada nothing special okay",
    "start": "2309200",
    "end": "2314960"
  },
  {
    "text": "important part is it waits it takes some time for it to finish because it needs to block on something",
    "start": "2314960",
    "end": "2321280"
  },
  {
    "text": "and then we are just awaiting this okay so we are sleeping for two seconds that's the important part the second",
    "start": "2321280",
    "end": "2327280"
  },
  {
    "text": "important part is we are running a side job so in the time when we are sleeping",
    "start": "2327280",
    "end": "2332720"
  },
  {
    "text": "we would like this side job to be executed and this side job does nothing is just print okay",
    "start": "2332720",
    "end": "2338320"
  },
  {
    "text": "so what we want to see in all the examples is we want to have this output",
    "start": "2338320",
    "end": "2343839"
  },
  {
    "text": "that we are running that there's some nesting inside this regular job and then",
    "start": "2343839",
    "end": "2349839"
  },
  {
    "text": "somewhere in between we have our side job interjected okay you can see that we are effectively",
    "start": "2349839",
    "end": "2356400"
  },
  {
    "text": "sleeping for two seconds so this side job is executed in is like two seconds which we can use to do anything and then",
    "start": "2356400",
    "end": "2363520"
  },
  {
    "text": "the continuation finishes okay so that's the idea so this is the regular",
    "start": "2363520",
    "end": "2369359"
  },
  {
    "text": "regular async and the weight code you would be implementing without the correcting transformation etc now how",
    "start": "2369359",
    "end": "2375520"
  },
  {
    "text": "can we do exactly the same with yield keyword the important thing is that youth",
    "start": "2375520",
    "end": "2382320"
  },
  {
    "text": "keyword which was their like couple years back before uh before async and await allows us to",
    "start": "2382320",
    "end": "2389599"
  },
  {
    "text": "exact to do exactly the same so now we are going to reimplement async and await",
    "start": "2389599",
    "end": "2394800"
  },
  {
    "text": "with a reviewed keyword so first thing we'll need to do is we'll need to have",
    "start": "2394800",
    "end": "2400000"
  },
  {
    "text": "some bookkeeping which is done for you by the dotnet platform so whenever you do ac you use async and await when you",
    "start": "2400000",
    "end": "2407440"
  },
  {
    "text": "await something there is this continuation which is pushed on the synchronization context which is",
    "start": "2407440",
    "end": "2413280"
  },
  {
    "text": "basically put into some queue and then the thread observes the queue if there is a new message in the queue meaning",
    "start": "2413280",
    "end": "2419440"
  },
  {
    "text": "that hey you need to do some more work it takes the message from the queue does the work and carry on okay so that's the",
    "start": "2419440",
    "end": "2425599"
  },
  {
    "text": "idea we need to re-implement this part so what we have is we have dictionaries of all the jobs we'd like to be doing",
    "start": "2425599",
    "end": "2432079"
  },
  {
    "text": "some semaphore for synchronizing on top of the queue and then we also have the",
    "start": "2432079",
    "end": "2437119"
  },
  {
    "text": "enumerator so this is a kind of the regular enumerator you have in c sharp but with",
    "start": "2437119",
    "end": "2443280"
  },
  {
    "text": "flag whether there is some work more to be done and the idea is we'll stack those enumerators on top of the other so",
    "start": "2443280",
    "end": "2450560"
  },
  {
    "text": "whenever you do want to now you we want to bend our minds and instead of doing a weight on a method we",
    "start": "2450560",
    "end": "2458000"
  },
  {
    "text": "want to do yield return on a method and the thing is that the method which",
    "start": "2458000",
    "end": "2463200"
  },
  {
    "text": "we are yield returning it can also await inside so it can also do yield return so",
    "start": "2463200",
    "end": "2469280"
  },
  {
    "text": "when we are doing yield returns we need to return collections right so before",
    "start": "2469280",
    "end": "2474400"
  },
  {
    "text": "continuing with returning the external collection we need to return the internal connection which a collection",
    "start": "2474400",
    "end": "2480480"
  },
  {
    "text": "which was there so when we are doing guild return we need to understand there was this stack of enumerators built on",
    "start": "2480480",
    "end": "2486880"
  },
  {
    "text": "top of each other and this is why we have the the the enumerator with flag to",
    "start": "2486880",
    "end": "2491920"
  },
  {
    "text": "basically build this stack of thingies what we do is we have the move next",
    "start": "2491920",
    "end": "2498160"
  },
  {
    "text": "method in this enumerator which basically checks hey if i was already",
    "start": "2498160",
    "end": "2503280"
  },
  {
    "text": "done then i'm done otherwise i get the enumerator which was there and i call",
    "start": "2503280",
    "end": "2508480"
  },
  {
    "text": "move next in it if we've seen this move next method with the for loop for instance we are basically calculating",
    "start": "2508480",
    "end": "2513839"
  },
  {
    "text": "next integer right if there is nothing which we calculated then we try like unstacking the thing we",
    "start": "2513839",
    "end": "2521839"
  },
  {
    "text": "check whether we were stacked enumerator and we remove it from the top of the stack or we can obviously push something",
    "start": "2521839",
    "end": "2528000"
  },
  {
    "text": "more on the stack we'll see that in how we are going to implement the run internal so this is",
    "start": "2528000",
    "end": "2533920"
  },
  {
    "text": "the same thing in which we had with async and awaits so now we are what we are doing is we are calling the run",
    "start": "2533920",
    "end": "2539280"
  },
  {
    "text": "internal nested we are getting its enumerator and marking it hey you go ahead do your work and then instead of",
    "start": "2539280",
    "end": "2545680"
  },
  {
    "text": "doing a wait we can do yield return okay and this thing there's this run internal",
    "start": "2545680",
    "end": "2551760"
  },
  {
    "text": "nested is yet another thingy which returns us the i enumerable something instead of task and again when we are we",
    "start": "2551760",
    "end": "2559920"
  },
  {
    "text": "want to wait for it we just do yield return and because we are mixing this with tasks around then we have some",
    "start": "2559920",
    "end": "2566160"
  },
  {
    "text": "magic weight which is not important the general idea is instead of using a weight we do the yield return",
    "start": "2566160",
    "end": "2572400"
  },
  {
    "text": "so the way we do it is we have a run method so the main thread which has",
    "start": "2572400",
    "end": "2578480"
  },
  {
    "text": "those cues of the things to be executed okay so what we do is we loop through this",
    "start": "2578480",
    "end": "2585119"
  },
  {
    "text": "queue we get the thingy from this queue and while there is something to be done",
    "start": "2585119",
    "end": "2590880"
  },
  {
    "text": "we just get it and call the move next method from the enumerator and there if there is something new to be scheduled",
    "start": "2590880",
    "end": "2597599"
  },
  {
    "text": "new continuation then this new continuation is pushed into this queue again so this is how we implement it and",
    "start": "2597599",
    "end": "2605040"
  },
  {
    "text": "if we are all done then we just break nothing nothing important here so the important or the interesting part about",
    "start": "2605040",
    "end": "2612720"
  },
  {
    "text": "that let me just check yeah this compiled correctly you can see that hey with this approach we can also get",
    "start": "2612720",
    "end": "2619680"
  },
  {
    "text": "exactly the same thingy so we are now running with generators instead of the acing and await we can get the sorry we",
    "start": "2619680",
    "end": "2626480"
  },
  {
    "text": "can get this side job being interjected somewhere in between and we can get this",
    "start": "2626480",
    "end": "2632000"
  },
  {
    "text": "two seconds delay and this is actually something people were implementing before async and await was introduced to",
    "start": "2632000",
    "end": "2638480"
  },
  {
    "text": "the c-sharp you can go look over stack overflow and you'll find people asking how do i use yield to implement async",
    "start": "2638480",
    "end": "2644640"
  },
  {
    "text": "and await and they were doing that so this is something you can implement by hand and this is the way it's implemented",
    "start": "2644640",
    "end": "2651040"
  },
  {
    "text": "under the hood like all this queueing all this scheduling is done for you and now we enter a slightly different",
    "start": "2651040",
    "end": "2658160"
  },
  {
    "text": "world because the problem with those score routines is you can see it actually even clearer here that hey you",
    "start": "2658160",
    "end": "2665520"
  },
  {
    "text": "wanted to return something from this run internal and it needs to be i enumerable",
    "start": "2665520",
    "end": "2670720"
  },
  {
    "text": "again it cannot be just the integer right it needs to be the enumerator you need to go with all these bookkeeping",
    "start": "2670720",
    "end": "2677680"
  },
  {
    "text": "handling transformations yada yada i want to have an async where i can do return i can return anything and i don't",
    "start": "2677680",
    "end": "2685200"
  },
  {
    "text": "need to care about those that stuff how do i do that and this is how it comes",
    "start": "2685200",
    "end": "2691040"
  },
  {
    "text": "so now what we are going to do is we are going to use fibers so",
    "start": "2691040",
    "end": "2697040"
  },
  {
    "text": "to the recap we have this operating system level fret which is basically a single thread provided to us by the",
    "start": "2697040",
    "end": "2703119"
  },
  {
    "text": "operating system and on top of that we built green level threats we built fibers each fiber is basically one async",
    "start": "2703119",
    "end": "2711200"
  },
  {
    "text": "and a weight context which will execute so what we are doing is",
    "start": "2711200",
    "end": "2717040"
  },
  {
    "text": "we have again some bookkeeping for doing the queuing and all that stuff the same way field as as before and now what we",
    "start": "2717040",
    "end": "2724400"
  },
  {
    "text": "are doing is we submit two jobs to the to the uh to the execution logic the",
    "start": "2724400",
    "end": "2731040"
  },
  {
    "text": "first job is the regular run internal you can see is just a void method it",
    "start": "2731040",
    "end": "2737760"
  },
  {
    "text": "does run internal nested which gets the task.delay then instead of calling await on this",
    "start": "2737760",
    "end": "2744240"
  },
  {
    "text": "delay instead of calling a delay.weight what we do is we do the magic weight and",
    "start": "2744240",
    "end": "2750720"
  },
  {
    "text": "this is the method we all wanted to have this is the method which just stops the method waits for the result but allows",
    "start": "2750720",
    "end": "2757599"
  },
  {
    "text": "everything else to carry on how is this implemented we'll have three fibers in this application first fiber",
    "start": "2757599",
    "end": "2765280"
  },
  {
    "text": "so the first green thread is the green thread which is running this pumping",
    "start": "2765280",
    "end": "2770560"
  },
  {
    "text": "inside the queue so we get the message from the queue indicating hey there is some work to be done",
    "start": "2770560",
    "end": "2776800"
  },
  {
    "text": "and what we do next is we just switch to this fret so we do the context switch to",
    "start": "2776800",
    "end": "2782960"
  },
  {
    "text": "the other fiber we tell the operating system hey me i'm fiber numbered zero",
    "start": "2782960",
    "end": "2788400"
  },
  {
    "text": "i'm done you can carry on with executing this other fiber okay so at this point",
    "start": "2788400",
    "end": "2794000"
  },
  {
    "text": "the fiber number zero is basically stopped here like post entirely and then fiber number one",
    "start": "2794000",
    "end": "2801760"
  },
  {
    "text": "is being executed it goes on and on until it calls magic.weight and in",
    "start": "2801760",
    "end": "2806960"
  },
  {
    "text": "magic.weight what we do is we basically schedule a continuation",
    "start": "2806960",
    "end": "2812800"
  },
  {
    "text": "to schedule fibers again but we more importantly we ask the operating system",
    "start": "2812800",
    "end": "2817920"
  },
  {
    "text": "hey i'm done you can go to fiber zero so there is this fiber zero which goes",
    "start": "2817920",
    "end": "2823440"
  },
  {
    "text": "through the queue gets the messages and then tells the os hey go to fiber one to",
    "start": "2823440",
    "end": "2828800"
  },
  {
    "text": "do this method when this method on fiber one wants to wait wants to",
    "start": "2828800",
    "end": "2834400"
  },
  {
    "text": "await for something it tells the us hey i'm done go to fiber zero okay and then",
    "start": "2834400",
    "end": "2840000"
  },
  {
    "text": "there is continuation on this task which when it's done so when we are weight done waiting for the delay or whatever",
    "start": "2840000",
    "end": "2846800"
  },
  {
    "text": "else we tell we add this fiber to the queue indicating that hey this fiber is ready to be carried on again so then",
    "start": "2846800",
    "end": "2854079"
  },
  {
    "text": "fiber number zero will pick it up from the queue and tell the us claim i'm done go to fiber one and on fiber two what we",
    "start": "2854079",
    "end": "2861040"
  },
  {
    "text": "do is on fiber two we just submit the side job okay so this is the important",
    "start": "2861040",
    "end": "2866880"
  },
  {
    "text": "thing that we just submit the side job which is here okay and now to see this",
    "start": "2866880",
    "end": "2873119"
  },
  {
    "text": "in output you can see that hey we do have this running as expected so we have again sleeping for two",
    "start": "2873119",
    "end": "2880000"
  },
  {
    "text": "seconds okay and we have the side job being interjected somewhere in between",
    "start": "2880000",
    "end": "2885680"
  },
  {
    "text": "so this is what we can do with fibers now how do we implement that the part of the queuing here you already know there",
    "start": "2885680",
    "end": "2892559"
  },
  {
    "text": "were some cues with keyword the other part which we need to have is we need to have basically some i use c plus plus",
    "start": "2892559",
    "end": "2899280"
  },
  {
    "text": "cli to basically call the win api methods right so the only thing we need to do is we need to be able to",
    "start": "2899280",
    "end": "2905599"
  },
  {
    "text": "call the switch to fiber from the win api delete fiber and there is convert thread to fiber and that's all if you",
    "start": "2905599",
    "end": "2912640"
  },
  {
    "text": "have this you can actually go with the implementation of the async and await on top of green level threads and this is",
    "start": "2912640",
    "end": "2919040"
  },
  {
    "text": "exactly what java project loom does so instead of using this choruiting transformations we just go with green",
    "start": "2919040",
    "end": "2925599"
  },
  {
    "text": "threads on top of the os frets so the advantages of this well some of them are actually",
    "start": "2925599",
    "end": "2932200"
  },
  {
    "text": "strikingly clear there is no more task you can just return void you don't need",
    "start": "2932200",
    "end": "2938400"
  },
  {
    "text": "to rewrite all your synchronous code to async to have acing all the way down",
    "start": "2938400",
    "end": "2943920"
  },
  {
    "text": "continue configure a weight all the way up all the stuff the only thing you need to do is you just do the delay dot magic",
    "start": "2943920",
    "end": "2952160"
  },
  {
    "text": "weight that's it but that's not beyond the not the end of the story you remember this slide when i",
    "start": "2952160",
    "end": "2958640"
  },
  {
    "text": "was pointing out three most important parts of async and away first was coroutine transformation okay so this is",
    "start": "2958640",
    "end": "2965359"
  },
  {
    "text": "covered we got that covered the other part was service locator okay service",
    "start": "2965359",
    "end": "2970800"
  },
  {
    "text": "locator for orchestrating the continuations what we are going to do now is we are going to change the",
    "start": "2970800",
    "end": "2976960"
  },
  {
    "text": "service locator thingy and let me just tweak the code because it's quite a lot of code",
    "start": "2976960",
    "end": "2983280"
  },
  {
    "text": "changes now so let's run it and now what we are going to do is",
    "start": "2983280",
    "end": "2988480"
  },
  {
    "text": "we would like to use monad like approach for those of you who were sleeping for",
    "start": "2988480",
    "end": "2994079"
  },
  {
    "text": "the last decade and not reading yet another post explaining what the monad is",
    "start": "2994079",
    "end": "2999520"
  },
  {
    "text": "this is not a moment just telling you what we are going to do instead if we are just wrapping this thing in a monad",
    "start": "2999520",
    "end": "3005280"
  },
  {
    "text": "like structure so don't like play tricks on that it's not a moment however what",
    "start": "3005280",
    "end": "3010319"
  },
  {
    "text": "is important is we would like to have an execution environment and we would like to have two different builders for two",
    "start": "3010319",
    "end": "3016880"
  },
  {
    "text": "different monarchs so basically a monard is a box with something inside and this box takes care of how to deal with that",
    "start": "3016880",
    "end": "3023839"
  },
  {
    "text": "thing inside so we'll have two different boxes one of them being id builder like",
    "start": "3023839",
    "end": "3029040"
  },
  {
    "text": "id box which is identity and the other box is a synchronous box and now comes",
    "start": "3029040",
    "end": "3034400"
  },
  {
    "text": "the thing instead of doing the uh the any thing",
    "start": "3034400",
    "end": "3039680"
  },
  {
    "text": "with returning values directly now we want to do actually and take a step back",
    "start": "3039680",
    "end": "3044880"
  },
  {
    "text": "and put everything into those boxes so whenever we are dealing with the values we are not doing them like",
    "start": "3044880",
    "end": "3052800"
  },
  {
    "text": "linearly with a weight or like linear like code but we are more going with uh",
    "start": "3052800",
    "end": "3057920"
  },
  {
    "text": "with an approach of like continue with on a task okay so we have this box and instead of using continue wave we use",
    "start": "3057920",
    "end": "3064319"
  },
  {
    "text": "the map function we name him we name it map so we have a value so we have a",
    "start": "3064319",
    "end": "3069359"
  },
  {
    "text": "something which is away table or sleep label here and it's inside this box and",
    "start": "3069359",
    "end": "3074720"
  },
  {
    "text": "then when it's done sleeping we have continue with so it does something with the value okay so we wrap this thingy",
    "start": "3074720",
    "end": "3081200"
  },
  {
    "text": "here now the important thing is we have two different builders for that so we",
    "start": "3081200",
    "end": "3087599"
  },
  {
    "text": "run this application first with the asynchronous builder using async box and",
    "start": "3087599",
    "end": "3093200"
  },
  {
    "text": "when we run it we get the expected output right so we have the sleeping for two seconds in between and we also have",
    "start": "3093200",
    "end": "3100240"
  },
  {
    "text": "this side job being introdu introduced interjected somewhere okay however now the thing is we can replace",
    "start": "3100240",
    "end": "3108079"
  },
  {
    "text": "this box because we are using the factory which is not uh like located by",
    "start": "3108079",
    "end": "3113760"
  },
  {
    "text": "a service locator it is provided we can just change it to something like this so",
    "start": "3113760",
    "end": "3119599"
  },
  {
    "text": "we pass it as a parameter to the execution context we are dealing with and if we now change the asynchronous",
    "start": "3119599",
    "end": "3125520"
  },
  {
    "text": "builder to the synchronous one you can see that the side job was introduced at",
    "start": "3125520",
    "end": "3131440"
  },
  {
    "text": "the very end because it was waiting for the previous part to finish meaning that",
    "start": "3131440",
    "end": "3136880"
  },
  {
    "text": "just by changing this thingy here at the top of the application like in",
    "start": "3136880",
    "end": "3143040"
  },
  {
    "text": "your dependency injection container or whatever you can control how the async",
    "start": "3143040",
    "end": "3148440"
  },
  {
    "text": "asynchronicity is being executed you can control all the threading anything around you do not need to touch the code",
    "start": "3148440",
    "end": "3155599"
  },
  {
    "text": "the business logic which is there okay so this is great that's the second thing but the third thing which we want to fix",
    "start": "3155599",
    "end": "3162720"
  },
  {
    "text": "here which we really don't like is hey we took the step back and now we are wrapping everything inside this box okay",
    "start": "3162720",
    "end": "3169680"
  },
  {
    "text": "that's terrible let's get rid of that and the last part which we are going to do is we address this third cornerstone",
    "start": "3169680",
    "end": "3177040"
  },
  {
    "text": "of the async programming which was that statically bound promise factories so",
    "start": "3177040",
    "end": "3182800"
  },
  {
    "text": "now instead of using those boxes like directly what we are going to do is we",
    "start": "3182800",
    "end": "3188079"
  },
  {
    "text": "are going to use them in some more dynamic way thanks to again something",
    "start": "3188079",
    "end": "3193119"
  },
  {
    "text": "similar to higher kind of type so what we are going to do is a higher kind of type",
    "start": "3193119",
    "end": "3198559"
  },
  {
    "text": "is a generic method which is being generic not on the input type but",
    "start": "3198559",
    "end": "3204800"
  },
  {
    "text": "the output type like you have i enumerable of t that's a regular generic",
    "start": "3204800",
    "end": "3210079"
  },
  {
    "text": "but you could have t of integer that's a higher kind of type meaning that the kind of the the generic part is outside",
    "start": "3210079",
    "end": "3217280"
  },
  {
    "text": "something which c sharp does not provide for you directly you can emulate the dead with with various transformations",
    "start": "3217280",
    "end": "3223440"
  },
  {
    "text": "again but we are going this approach so now what we are going to do is we are going to have um this run",
    "start": "3223440",
    "end": "3230079"
  },
  {
    "text": "internal method run internal nested again they are like regular methods no",
    "start": "3230079",
    "end": "3235119"
  },
  {
    "text": "tasks around no boxes no continue with no map the only thing which it does is it gets this",
    "start": "3235119",
    "end": "3241359"
  },
  {
    "text": "type parameter t like generic parameter and this generic parameter is of some",
    "start": "3241359",
    "end": "3246480"
  },
  {
    "text": "builder yada yada just to get the call compiled and then you see that we are calling task delay like in this way",
    "start": "3246480",
    "end": "3252720"
  },
  {
    "text": "delay of t we don't care what this t was okay but we are just just passing it through",
    "start": "3252720",
    "end": "3259760"
  },
  {
    "text": "and again the idea is if we do it this way we can control it from the very top",
    "start": "3259760",
    "end": "3265680"
  },
  {
    "text": "so see you can we can again get the two second sleep as needed we can get the",
    "start": "3265680",
    "end": "3272319"
  },
  {
    "text": "side job interjected in between but just by changing this one little thingy like",
    "start": "3272319",
    "end": "3279119"
  },
  {
    "text": "this one parameter generic parameter from asynchronous box to synchronous box",
    "start": "3279119",
    "end": "3285280"
  },
  {
    "text": "what we get now is we get that the side job is executed synchronously at the",
    "start": "3285280",
    "end": "3291200"
  },
  {
    "text": "very end so this is what we can do now and you can see that we by doing all",
    "start": "3291200",
    "end": "3296480"
  },
  {
    "text": "those different transformations we ended up with code which is colorless there is",
    "start": "3296480",
    "end": "3302160"
  },
  {
    "text": "no task around here no task no value task if microsoft introduces yet another",
    "start": "3302160",
    "end": "3307200"
  },
  {
    "text": "magicking task you don't care you don't need to rewrite your code base anymore",
    "start": "3307200",
    "end": "3312240"
  },
  {
    "text": "you can control whether it's synchronous or not you can change the synchronous",
    "start": "3312240",
    "end": "3317599"
  },
  {
    "text": "mechanism you can change the number of threads fretboos whatever you wish without touching your business code you",
    "start": "3317599",
    "end": "3324720"
  },
  {
    "text": "control the synchronous parts directly in a place where they are executed because nothing stops you from",
    "start": "3324720",
    "end": "3331760"
  },
  {
    "text": "calling this method once with id builder and the other time with asynchronous",
    "start": "3331760",
    "end": "3337599"
  },
  {
    "text": "builder so you can change it in runtime dynamically the way you wish important thing is because it's a",
    "start": "3337599",
    "end": "3343920"
  },
  {
    "text": "generic parameter and this builder thingy is uh",
    "start": "3343920",
    "end": "3348960"
  },
  {
    "text": "sorry this uh those monarchs can be introduced by the compiler meaning that",
    "start": "3348960",
    "end": "3355760"
  },
  {
    "text": "if you do have those builders you could go with structures meaning that your compiler would understand that those",
    "start": "3355760",
    "end": "3363040"
  },
  {
    "text": "things can be heavily optimized there would be no need for you to introduce value task anymore or anything like this",
    "start": "3363040",
    "end": "3370319"
  },
  {
    "text": "because compiler would just get rid of the allocations for you and that's it so you don't need to change your business",
    "start": "3370319",
    "end": "3376000"
  },
  {
    "text": "code anymore you don't need to do any code rewriting into async and await",
    "start": "3376000",
    "end": "3381760"
  },
  {
    "text": "async all the way all the way up configure await false all the way down or whatever way it was you don't need to",
    "start": "3381760",
    "end": "3388640"
  },
  {
    "text": "change your methods you don't need to deal with synchronization context and deadlocks nothing like this the only",
    "start": "3388640",
    "end": "3394400"
  },
  {
    "text": "thing you do is you can just have it here with the green level threads and this is what project bloom does",
    "start": "3394400",
    "end": "3400400"
  },
  {
    "text": "obviously your compiler could hide those t parameters from you and that's done",
    "start": "3400400",
    "end": "3405920"
  },
  {
    "text": "so being all of that set we can wrap up this talk so we can see that core",
    "start": "3405920",
    "end": "3412559"
  },
  {
    "text": "routines even though they give us this very nice experience of acing and await",
    "start": "3412559",
    "end": "3418160"
  },
  {
    "text": "they generally give or bring quite a lot of overhead which we can get rid of by using",
    "start": "3418160",
    "end": "3423839"
  },
  {
    "text": "completely different approach we don't need to use global state anymore we don't need to use colorful functions we",
    "start": "3423839",
    "end": "3430319"
  },
  {
    "text": "don't need to pass tasks around from here and there we could go with something completely different based on",
    "start": "3430319",
    "end": "3435839"
  },
  {
    "text": "green level threads or whatever and it would work exactly the same way and could be as java suggests way more",
    "start": "3435839",
    "end": "3443359"
  },
  {
    "text": "performance being all of that said it's time for q a so this qr code points you to the slide",
    "start": "3443359",
    "end": "3450079"
  },
  {
    "text": "deck uh or actually to my blog to the blog with the slides and couple more materials and at the very end of this",
    "start": "3450079",
    "end": "3456720"
  },
  {
    "text": "slide deck there are more references for you like books blog links etc etc feel",
    "start": "3456720",
    "end": "3461920"
  },
  {
    "text": "free to take a look at them and that's it if do you if you have any questions now it's a perfect time to ask",
    "start": "3461920",
    "end": "3468000"
  },
  {
    "text": "them there is one yes",
    "start": "3468000",
    "end": "3474359"
  },
  {
    "text": "okay so the question is why isn't this what we did here why isn't that implemented in the operating system in",
    "start": "3483520",
    "end": "3489839"
  },
  {
    "text": "the very first place and that's actually a very good play a very good question on one hand we do not want to have these",
    "start": "3489839",
    "end": "3496000"
  },
  {
    "text": "things in the os itself because then well dotnet wants to support multiple platforms now so having that implemented",
    "start": "3496000",
    "end": "3503200"
  },
  {
    "text": "in windows only would need to mean that we need to implement this in linux by ourselves or whatever or need to have",
    "start": "3503200",
    "end": "3509040"
  },
  {
    "text": "exactly the same implementation in linux but the other other thing is that those things were",
    "start": "3509040",
    "end": "3514960"
  },
  {
    "text": "not implemented in this way like why they were not implemented in the dotnet runtime why they were implemented in the",
    "start": "3514960",
    "end": "3520799"
  },
  {
    "text": "c-sharp compiler the answer is because it's a choice to be made basically it's",
    "start": "3520799",
    "end": "3525839"
  },
  {
    "text": "a decision to be made so dotnet platform decided that they do not want to mess with the dotnet runtime to support all",
    "start": "3525839",
    "end": "3532400"
  },
  {
    "text": "of that they wanted to mess with the c-sharp compiler that's why they implemented it in this way they also",
    "start": "3532400",
    "end": "3538480"
  },
  {
    "text": "didn't want to mess with the operating system to add all those stuff java took a different route they decided",
    "start": "3538480",
    "end": "3544160"
  },
  {
    "text": "to change all the platform under the hood so all languages can benefit from there you do not have async and await in",
    "start": "3544160",
    "end": "3550160"
  },
  {
    "text": "vb.net right because it's not implemented in the compiler but if you do have multiple languages running on",
    "start": "3550160",
    "end": "3556000"
  },
  {
    "text": "java then in theory any of them can use all the benefits here now when it comes",
    "start": "3556000",
    "end": "3561040"
  },
  {
    "text": "to the american memory consumption etc generally if you are implementing things",
    "start": "3561040",
    "end": "3566319"
  },
  {
    "text": "in the operating system then you need to deal with the with the kernel switch context switch to the kernel mode which is always heavy",
    "start": "3566319",
    "end": "3573599"
  },
  {
    "text": "always very very expensive and generally you don't want to do not want to to do that and you cannot get rid of that",
    "start": "3573599",
    "end": "3580079"
  },
  {
    "text": "because of security and all the other implement implications so generally while it is",
    "start": "3580079",
    "end": "3585359"
  },
  {
    "text": "beneficial if you have those things provided for you it's actually very heavy for the os itself or the dependent",
    "start": "3585359",
    "end": "3591520"
  },
  {
    "text": "platforms to implement them and that's why you might want to consider implementing them by yourself",
    "start": "3591520",
    "end": "3598160"
  },
  {
    "text": "any other questions yep",
    "start": "3598160",
    "end": "3603000"
  },
  {
    "text": "okay so the question is i did convert the thread to fiber and the question is",
    "start": "3630799",
    "end": "3635920"
  },
  {
    "text": "how does it integrate with other things which can be around like dispatch context in that wpf",
    "start": "3635920",
    "end": "3641359"
  },
  {
    "text": "web requests etc etc the answer is microsoft or actually the dotnet",
    "start": "3641359",
    "end": "3646400"
  },
  {
    "text": "platform they did consider using fibers at some point they were supporting that in sql server and it's some clr version",
    "start": "3646400",
    "end": "3653119"
  },
  {
    "text": "but at some point that explicitly drop that support because fibers do not give",
    "start": "3653119",
    "end": "3659119"
  },
  {
    "text": "you like make your uh multi-threading code a little tricky because all your synchronization",
    "start": "3659119",
    "end": "3665760"
  },
  {
    "text": "primitives like mutexes semaphores they are always tied to the thread",
    "start": "3665760",
    "end": "3671839"
  },
  {
    "text": "so now if you have two green frets running on top of one os thread then in",
    "start": "3671839",
    "end": "3677440"
  },
  {
    "text": "one green fret takes a lock then the other green thread has this lock acquired as well so that's why they",
    "start": "3677440",
    "end": "3684400"
  },
  {
    "text": "wanted to drop it because support in multiple platforms in p invoke context",
    "start": "3684400",
    "end": "3689520"
  },
  {
    "text": "etc was tricky and they explicitly banned it not that they are not supporting fibers they are explicitly",
    "start": "3689520",
    "end": "3697040"
  },
  {
    "text": "unsupporting them okay so how does it integrate with wpf etc",
    "start": "3697040",
    "end": "3702240"
  },
  {
    "text": "this code does not because it's just a proof of concept you could go with the places when i'm doing those boxes like",
    "start": "3702240",
    "end": "3707680"
  },
  {
    "text": "id builder async builder you could introduce all your logic there it could be integrated this is why it took java",
    "start": "3707680",
    "end": "3713920"
  },
  {
    "text": "so long to implement this because they had to take care of all those things but the other question is okay i mentioned",
    "start": "3713920",
    "end": "3719599"
  },
  {
    "text": "that synchronization primitives are broken with green threads let's say but is it any different we're facing in",
    "start": "3719599",
    "end": "3725599"
  },
  {
    "text": "a weight and the answer is it is not if you do take a lock in your",
    "start": "3725599",
    "end": "3730720"
  },
  {
    "text": "asynchronous method then it is not migrating to the other thread you may be",
    "start": "3730720",
    "end": "3736079"
  },
  {
    "text": "running your continuation on if you do use async and await you need to forget about all the regular synchronization",
    "start": "3736079",
    "end": "3742079"
  },
  {
    "text": "primitives so the thing is microsoft didn't want to drop those primitives by moving to",
    "start": "3742079",
    "end": "3748319"
  },
  {
    "text": "fibers but they effectively dropped them the same way by moving to async and await and now there is no code which is",
    "start": "3748319",
    "end": "3755760"
  },
  {
    "text": "not async enabled in c sharp right there was this very long transition period like five years when we were rewriting",
    "start": "3755760",
    "end": "3762079"
  },
  {
    "text": "all the methods from regular to task async await yada yada now everything is async and the weight so you cannot use",
    "start": "3762079",
    "end": "3768160"
  },
  {
    "text": "your lock primitives anymore even if you try using lock construct in like async",
    "start": "3768160",
    "end": "3773440"
  },
  {
    "text": "method it may yell that you cannot await inside the lock right because it won't migrate to the other thingy so those are",
    "start": "3773440",
    "end": "3780240"
  },
  {
    "text": "exactly the same things the same issues for which microsoft didn't want to go with fibers but effectively went with",
    "start": "3780240",
    "end": "3786640"
  },
  {
    "text": "them when introducing async and await so to sum up this gives you a lot of troubles when it",
    "start": "3786640",
    "end": "3793359"
  },
  {
    "text": "goes to going with green threads but you have those issues the same with facing an l8 and i refer you to my other other",
    "start": "3793359",
    "end": "3799280"
  },
  {
    "text": "targeting biggest c-sharp mistake you can find it on youtube explaining all those issues but generally you do not",
    "start": "3799280",
    "end": "3805200"
  },
  {
    "text": "have any more troubles per my understanding there could be so much cases obviously but generally this is",
    "start": "3805200",
    "end": "3810480"
  },
  {
    "text": "equivalent when it comes to how many troubles you get and uh if you can integrate this with wpf dispatcher or",
    "start": "3810480",
    "end": "3816640"
  },
  {
    "text": "whatever else the answer is yes you just need to write a little more or sometimes way more code doing the whole the job",
    "start": "3816640",
    "end": "3824000"
  },
  {
    "text": "under the hood but it was done anyway for racing and await if you start compiling async and await you will see",
    "start": "3824000",
    "end": "3829599"
  },
  {
    "text": "tons of different synchronization contexts for wpf for blazer for old asp.net for newasp.net you'll find that",
    "start": "3829599",
    "end": "3837200"
  },
  {
    "text": "code being written anyway is just we would need to write this code having different mechanism in mind",
    "start": "3837200",
    "end": "3843520"
  },
  {
    "text": "that's it the code needs to be written anyway any other questions",
    "start": "3843520",
    "end": "3849519"
  },
  {
    "text": "okay i don't see any any of them if you had any other questions feel free to ask them after the presentation couple of",
    "start": "3850160",
    "end": "3857039"
  },
  {
    "text": "references for you you can find them in the slide deck and because we are out of time being all of that said i think it's",
    "start": "3857039",
    "end": "3863839"
  },
  {
    "text": "time to call it a day thank you for attending this talk hope you liked it hope you enjoyed thank you",
    "start": "3863839",
    "end": "3871160"
  },
  {
    "text": "you",
    "start": "3883440",
    "end": "3885520"
  }
]