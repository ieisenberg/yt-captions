[
  {
    "text": "right looks like it's creating down out there so I think we'll just start because we have a lot of material to go through welcome uh this talk is called",
    "start": "6899",
    "end": "14040"
  },
  {
    "text": "Siri makes beautiful programs I'm very happy with the title uh",
    "start": "14040",
    "end": "19140"
  },
  {
    "text": "uh quite happy with the talk as well it is uh",
    "start": "19140",
    "end": "24300"
  },
  {
    "text": "I mean Kate already brought it up in uh in um Keynote and it's it's",
    "start": "24300",
    "end": "31320"
  },
  {
    "text": "um it started out as a reflection of what I've been doing for the past few months",
    "start": "31320",
    "end": "36800"
  },
  {
    "text": "and The Inspirations and literally sources that that led to it that I wanted both to highlight and also some",
    "start": "36800",
    "end": "43440"
  },
  {
    "text": "of the wine insights that kind of came out of it as to how we developed software and",
    "start": "43440",
    "end": "48840"
  },
  {
    "text": "how we're sometimes doing it wrong the topic is going to be on mcdc which",
    "start": "48840",
    "end": "54480"
  },
  {
    "text": "is a terrible name uh it's an abbreviation for modified condition decision coverage and quickly I'd like",
    "start": "54480",
    "end": "60180"
  },
  {
    "text": "to do a poll like what industries people are from is anyone in in uh like Aero",
    "start": "60180",
    "end": "66360"
  },
  {
    "text": "clients fish okay good",
    "start": "66360",
    "end": "71760"
  },
  {
    "text": "um Automotive no um Rockets things that blow up",
    "start": "71760",
    "end": "80100"
  },
  {
    "text": "yeah okay good uh other I don't know Vision I guess anymore interesting Industries",
    "start": "80100",
    "end": "89720"
  },
  {
    "text": "some defense okay good so um it's kind of good because that means you've probably not been very exposed to",
    "start": "91439",
    "end": "97920"
  },
  {
    "text": "this and I would start really opening like that mcdc or courage in general or",
    "start": "97920",
    "end": "103259"
  },
  {
    "text": "condition coverage in general is probably one of the most overvalued and still underused",
    "start": "103259",
    "end": "109700"
  },
  {
    "text": "testing criteria that we have um so we're gonna very quick one on that",
    "start": "109700",
    "end": "115619"
  },
  {
    "text": "if you want a more sort of Hands-On tutorial and introduction to that I recommend coming to my other talk in a",
    "start": "115619",
    "end": "122340"
  },
  {
    "text": "few hours where we'll be a little bit more um on the action",
    "start": "122340",
    "end": "127500"
  },
  {
    "text": "I'm going to do a thorough description of an algorithm I designed in order to implement support for this type of",
    "start": "127500",
    "end": "132840"
  },
  {
    "text": "coverage in GCC and some Rumblings on thinking before typing",
    "start": "132840",
    "end": "138959"
  },
  {
    "text": "so start with the mcdc so why do we care about coverage what is it why is mcdc",
    "start": "138959",
    "end": "144540"
  },
  {
    "text": "different from the branch cupboard which you made on and be familiar with and what does Mass have to do with all of it",
    "start": "144540",
    "end": "149760"
  },
  {
    "text": "right so one reason to care if you're in one of the industries in particular I",
    "start": "149760",
    "end": "155099"
  },
  {
    "text": "mentioned is the lizard people which I would like to call the regulatory bodies so if you develop software for planes or",
    "start": "155099",
    "end": "161580"
  },
  {
    "text": "cars or anything that moves or may or may not kill people by accident or you know on purpose",
    "start": "161580",
    "end": "168360"
  },
  {
    "text": "um you might have to obey to these regulations and uh so do is I don't know",
    "start": "168360",
    "end": "175319"
  },
  {
    "text": "what it is but it's from for the Aerospace it's the FAA I think that ratified it for their safety critical",
    "start": "175319",
    "end": "181800"
  },
  {
    "text": "like level a software they mandate that 100 of your code has to pass this Criterion",
    "start": "181800",
    "end": "188220"
  },
  {
    "text": "for the highest safety levels in cars and that's typically those that um deal with the functions I mean you",
    "start": "188220",
    "end": "193319"
  },
  {
    "text": "don't care if your music player stops but you don't care if your brakes stop working right they also have to be",
    "start": "193319",
    "end": "198420"
  },
  {
    "text": "tested to the same criteria uh but I think even then it's it's underused in the General Industry uh as",
    "start": "198420",
    "end": "206280"
  },
  {
    "text": "a sort of specific probe we're going to very briefly cover the problem with brand coverage and I picked a way too",
    "start": "206280",
    "end": "213540"
  },
  {
    "text": "light color for the highlighted rows",
    "start": "213540",
    "end": "218540"
  },
  {
    "text": "um is that in order to satify Branch coverage you need two tasks and the",
    "start": "218760",
    "end": "224760"
  },
  {
    "text": "problem is here that you have way more than two inputs to this decision right",
    "start": "224760",
    "end": "230480"
  },
  {
    "text": "uh like notably you never actually test if a can be true",
    "start": "230480",
    "end": "235799"
  },
  {
    "text": "and then you go like oh I mean it's a billion so obviously it can be true but it may not may not be true if that's the",
    "start": "235799",
    "end": "241500"
  },
  {
    "text": "case or if you have broken parsing because you're dealing with IO right so so it can be deeper than that",
    "start": "241500",
    "end": "249599"
  },
  {
    "text": "formally modified condition decision coverage is satisfied if every entry and exit Point has been invoked every basic",
    "start": "249599",
    "end": "256139"
  },
  {
    "text": "condition has taken all possible outcomes and each of the basic conditions have been showed independently affect the outcome of the",
    "start": "256139",
    "end": "262800"
  },
  {
    "text": "decision uh so the first point every entry annexy point has been invoked this is Branch",
    "start": "262800",
    "end": "268620"
  },
  {
    "text": "coverage right so we can do is I mean this is Branch coverage everyone like",
    "start": "268620",
    "end": "274259"
  },
  {
    "text": "have you been in the uh then have you been in the Alps condition coverages have you pass true",
    "start": "274259",
    "end": "279600"
  },
  {
    "text": "and false to each one of the variables you put in",
    "start": "279600",
    "end": "284479"
  },
  {
    "text": "um the independence Criterion is what makes it different and it's a little bit hard to see but there are different rows",
    "start": "284759",
    "end": "291180"
  },
  {
    "text": "highlighted for every table and it's this Independence Criterion that makes it strong and actually that",
    "start": "291180",
    "end": "296580"
  },
  {
    "text": "makes it interesting so of course what you can do is you can test the power set of inputs but the",
    "start": "296580",
    "end": "302340"
  },
  {
    "text": "thing is it wouldn't actually give you more information about the behavior of your inputs or of your program",
    "start": "302340",
    "end": "307400"
  },
  {
    "text": "uh the motivation it requires M plus one test cases rather than two to the power of n and what happens sometimes is I I",
    "start": "307400",
    "end": "314460"
  },
  {
    "text": "write in a paper from NASA from early 90s that they'd found some cases in the wild",
    "start": "314460",
    "end": "320400"
  },
  {
    "text": "uh in avionics where there were 36 conditionals in an F and who does that",
    "start": "320400",
    "end": "326039"
  },
  {
    "text": "right but sometimes you have to because of rules like uh like Robert touched on the asinine",
    "start": "326039",
    "end": "331259"
  },
  {
    "text": "and interestingly uh you can catch some pieces of bad logic with mcpc",
    "start": "331259",
    "end": "336300"
  },
  {
    "text": "of course the problem is it only tests the implementation not the spec so if you're Pro like if you're spec or your",
    "start": "336300",
    "end": "342300"
  },
  {
    "text": "your algorithm is buggy doesn't matter if your implementation is correct because it's still the wrong program",
    "start": "342300",
    "end": "348000"
  },
  {
    "text": "it's possible to cheat it with restructuring we won't have time for that now but we'll do that in the other one",
    "start": "348000",
    "end": "354060"
  },
  {
    "text": "and if you look as a whole program analysis it you're gonna have to in like",
    "start": "354060",
    "end": "359340"
  },
  {
    "text": "in order to actually achieve full coverage you need a lot of test cases in not very interesting pieces of your code",
    "start": "359340",
    "end": "365699"
  },
  {
    "text": "base also it's awful to do without tooling this is absolutely awful",
    "start": "365699",
    "end": "372419"
  },
  {
    "text": "so I've wrote a patch for that for GCC um which uh the the work has been paid",
    "start": "372419",
    "end": "379800"
  },
  {
    "text": "for by involving planet where I'm employed uh in total italics up to about 3000",
    "start": "379800",
    "end": "385860"
  },
  {
    "text": "lines approximately half of that are tests some is documentation is a little bit of i o",
    "start": "385860",
    "end": "391680"
  },
  {
    "text": "uh the interesting changes are in the tree profile file which have 978 editions and about",
    "start": "391680",
    "end": "398100"
  },
  {
    "text": "a third of that are comments like this high level descriptions so I think that the total ends up to be",
    "start": "398100",
    "end": "404220"
  },
  {
    "text": "somewhere between M4 and 600 lines to implement this which is actually pretty dense largely",
    "start": "404220",
    "end": "410580"
  },
  {
    "text": "because GCC has some good internal interfaces but also because the program is short so this is what it looks like",
    "start": "410580",
    "end": "417240"
  },
  {
    "text": "when you do it right so you compile it with profile conditioners you run it with your inputs",
    "start": "417240",
    "end": "423300"
  },
  {
    "text": "and then you run g-cover on it and then it will tell you",
    "start": "423300",
    "end": "429600"
  },
  {
    "text": "what conditions are covered and what conditions are not covered under this Criterion",
    "start": "429600",
    "end": "436639"
  },
  {
    "text": "so the question is you obviously run this with a is true in the third demo",
    "start": "436800",
    "end": "443280"
  },
  {
    "text": "line right uh why isn't it covered any any good",
    "start": "443280",
    "end": "448740"
  },
  {
    "text": "instincts yes",
    "start": "448740",
    "end": "454380"
  },
  {
    "text": "yes exactly it's because B is false which is kind of unintuitive right because I mean you have it in the input",
    "start": "454380",
    "end": "460560"
  },
  {
    "text": "but it still doesn't get counted why not",
    "start": "460560",
    "end": "464300"
  },
  {
    "text": "because of this Criterion here it has to independently affect the decision and it turns out what we're witnessing",
    "start": "466860",
    "end": "472800"
  },
  {
    "text": "here is something called uh masking so if you look at this table and again",
    "start": "472800",
    "end": "478319"
  },
  {
    "text": "it's almost impossible to see the blue but it's line one and line five",
    "start": "478319",
    "end": "484319"
  },
  {
    "text": "they've been highlighted and you can see in the in the a column in the first case AES false and the",
    "start": "484319",
    "end": "491400"
  },
  {
    "text": "other case a is true but the outcome the decision is still",
    "start": "491400",
    "end": "496919"
  },
  {
    "text": "false in both cases obviously changing the value away didn't matter at all it didn't change the outcome so it's not",
    "start": "496919",
    "end": "502500"
  },
  {
    "text": "independently affecting the outcome of that case it's called masking and it happens on the right hand side",
    "start": "502500",
    "end": "508379"
  },
  {
    "text": "of conditions so in the next talk we're going to go through a lot of this but very quickly the observation is that",
    "start": "508379",
    "end": "516060"
  },
  {
    "text": "if you reverse the expression those masks become short-circuiting obviously because Boolean expressions",
    "start": "516060",
    "end": "523979"
  },
  {
    "text": "commute then you can reverse it without actually changing what values it will accept or",
    "start": "523979",
    "end": "529019"
  },
  {
    "text": "not assuming you have no side effects of course so this is going to go through later today",
    "start": "529019",
    "end": "534899"
  },
  {
    "text": "so let's talk about writing beautiful programs because what I realized when I did",
    "start": "534899",
    "end": "540839"
  },
  {
    "text": "is I started solving for the the simplest of cases like literally my first test case was if a",
    "start": "540839",
    "end": "546660"
  },
  {
    "text": "right which is already covered by Branch coverage because there's this general idea that",
    "start": "546660",
    "end": "553680"
  },
  {
    "text": "if you if you're targeting a general solution it has to always also solve the special cases and The Simple Solutions",
    "start": "553680",
    "end": "560220"
  },
  {
    "text": "so you can start by doing those and drawing some insides and eventually you add another test case",
    "start": "560220",
    "end": "565800"
  },
  {
    "text": "and you you this is all a classic tdd then you write the stupidest implementation possible because you know you're gonna have to change it",
    "start": "565800",
    "end": "572220"
  },
  {
    "text": "that would solve this this problem um",
    "start": "572220",
    "end": "577440"
  },
  {
    "text": "and then you walk back whenever you get a failing test case and you start understanding why and now it's not about twiddling you know that array access or",
    "start": "577440",
    "end": "584399"
  },
  {
    "text": "you know inverting accounts you need to actually understand what why doesn't this work from a sort of higher level",
    "start": "584399",
    "end": "591320"
  },
  {
    "text": "and what happened was that the more I started to to try this out the more",
    "start": "593459",
    "end": "600839"
  },
  {
    "text": "confident I became is that both the approach is viable and was correct because it started being based on set",
    "start": "600839",
    "end": "607080"
  },
  {
    "text": "theory and a little bit of graph Theory very like entry level but you know and",
    "start": "607080",
    "end": "612899"
  },
  {
    "text": "it turns out set theory works right and the program kind of wrote itself because once you had that description of",
    "start": "612899",
    "end": "618899"
  },
  {
    "text": "how things interacted with each other problem the program just falls out",
    "start": "618899",
    "end": "624060"
  },
  {
    "text": "so credit where it's due um the the title and the idea for the talk I uh next from Ross Cox right",
    "start": "624060",
    "end": "632880"
  },
  {
    "text": "who has this great post from sometime I think in the 90s which is called regular expression matching can be simple and",
    "start": "632880",
    "end": "638760"
  },
  {
    "text": "Fast And the tagline is but it's low in Python for all Java you know I list a bunch of languages",
    "start": "638760",
    "end": "645660"
  },
  {
    "text": "and in that he uses uh he discuss a theory called like he uses automaton",
    "start": "645660",
    "end": "651180"
  },
  {
    "text": "Theory to implement regular expressions and it becomes a very nice program reasonably short",
    "start": "651180",
    "end": "656339"
  },
  {
    "text": "quite easy to understand how it behaves the way it does and he does it in very plain C right",
    "start": "656339",
    "end": "663779"
  },
  {
    "text": "and for the GCC patch this has been a bunch of mostly simple relationships that I've just stacked on top of each",
    "start": "663779",
    "end": "670079"
  },
  {
    "text": "other right so we're going to go through those so let's start with the control flow graph I would say that there there was",
    "start": "670079",
    "end": "677940"
  },
  {
    "text": "publish an algorithm in 2000 9 or 13 I can't remember I think it's 13.",
    "start": "677940",
    "end": "684720"
  },
  {
    "text": "um that describes figuring out condition coverage from abstract syntax trees my algorithm does it on control programs",
    "start": "684720",
    "end": "692579"
  },
  {
    "text": "uh so it's it's a little bit different so the program on the left here is it's",
    "start": "692579",
    "end": "699420"
  },
  {
    "text": "but it simple uh well in a a part of as a compiler",
    "start": "699420",
    "end": "707160"
  },
  {
    "text": "transformation will be translated to something that is pretty similar to the code on the right you know you have your",
    "start": "707160",
    "end": "712500"
  },
  {
    "text": "label a and then there's a series of single condition go go-to's right single position tests with a go to",
    "start": "712500",
    "end": "720200"
  },
  {
    "text": "and this is what the compiler very quickly sees so when it does a lot of its optimizations it happens and I want",
    "start": "720300",
    "end": "726899"
  },
  {
    "text": "to intermediate representation that looks pretty much like that in GCC it's called gimple and RTL and",
    "start": "726899",
    "end": "734940"
  },
  {
    "text": "maybe one more uh llvm obviously uses llm ir and they're experimenting with",
    "start": "734940",
    "end": "740160"
  },
  {
    "text": "another one for C plus plus I think and if you draw it as a graph this is",
    "start": "740160",
    "end": "745200"
  },
  {
    "text": "what it looks like right",
    "start": "745200",
    "end": "748100"
  },
  {
    "text": "formerly the control flow graph is a directed graph where nodes represent uninterruptible sequence of instructions",
    "start": "752100",
    "end": "758459"
  },
  {
    "text": "if you have a bunch of arithmetic they're going to be in the same node right there's no control flow in",
    "start": "758459",
    "end": "763920"
  },
  {
    "text": "arithmetic um edges are the next possible Paths of",
    "start": "763920",
    "end": "769980"
  },
  {
    "text": "the execution and they are labeled fall through truth or false or conditional when you group",
    "start": "769980",
    "end": "776880"
  },
  {
    "text": "them complex there are a few more that are used for different kinds but they're not really relevant for this",
    "start": "776880",
    "end": "783480"
  },
  {
    "text": "and the final property is very important is that falter and conditional are mutually exclusive fall through just",
    "start": "783480",
    "end": "789540"
  },
  {
    "text": "means continue to the next node there's no decision to make uh whereas conditional obviously you can",
    "start": "789540",
    "end": "795000"
  },
  {
    "text": "go either way right so the first thing we need to do when",
    "start": "795000",
    "end": "801060"
  },
  {
    "text": "press enter with the control flow graph is we need to infer the decisions we need to figure out what exactly are the",
    "start": "801060",
    "end": "807180"
  },
  {
    "text": "Boolean Expressions now unlike the AST approach you don't actually have the concept of a Boolean",
    "start": "807180",
    "end": "813779"
  },
  {
    "text": "expression or even the concept of an expression anymore you have the flow of the program",
    "start": "813779",
    "end": "820399"
  },
  {
    "text": "so this is what we want this is the goal I have for the case just for illustrative purposes added the entry",
    "start": "822120",
    "end": "829079"
  },
  {
    "text": "node that you will find in all control for graphs but I've omitted it from the rest of the slides because it's not really relevant you can just assume it's",
    "start": "829079",
    "end": "835019"
  },
  {
    "text": "there or the previous section of the program or you know the previous something is that but what we want are there three",
    "start": "835019",
    "end": "841200"
  },
  {
    "text": "now is a b and c right because from the source code it's obvious that that's the expression and if you ask the AST then",
    "start": "841200",
    "end": "847860"
  },
  {
    "text": "the AST will know that this is the expression right from here on it gets a little bit heavy",
    "start": "847860",
    "end": "854160"
  },
  {
    "text": "on the notation please interrupt if something is very alien I'll try and make it as understandable as possible",
    "start": "854160",
    "end": "859260"
  },
  {
    "text": "but we need it to the end of it dance now what this says is one so this is the",
    "start": "859260",
    "end": "866700"
  },
  {
    "text": "first after I started doing the maths on this this is one of the first thing I realized and it turned out after a",
    "start": "866700",
    "end": "872880"
  },
  {
    "text": "little bit more work but this is probably the key observation that makes this algorithm work",
    "start": "872880",
    "end": "879540"
  },
  {
    "text": "and like when when you say it out loud it sounds so obvious right and it pretty",
    "start": "879540",
    "end": "884940"
  },
  {
    "text": "much says that for all of the nodes that make up a Boolean expression the B is one Boolean expression right",
    "start": "884940",
    "end": "892920"
  },
  {
    "text": "then the edges or the successors of that",
    "start": "892920",
    "end": "898800"
  },
  {
    "text": "will have to be in what's called a closed neighborhood of B now the neighborhood of a node or a",
    "start": "898800",
    "end": "906120"
  },
  {
    "text": "subgraph are all the nodes that are able to reach from that graph right so it's a",
    "start": "906120",
    "end": "911220"
  },
  {
    "text": "common thing in computer science and I mean the neighborhood is",
    "start": "911220",
    "end": "917180"
  },
  {
    "text": "in otherwise defined as the the Boolean expression itself to",
    "start": "917180",
    "end": "922680"
  },
  {
    "text": "know that make up the Boolean expression and the outcome of the expression so the",
    "start": "922680",
    "end": "928740"
  },
  {
    "text": "the start of the then and else blocks right and what what I really says is that",
    "start": "928740",
    "end": "934680"
  },
  {
    "text": "within a Boolean expression you can only evaluate or keep on evaluating the Boolean expression you can't really",
    "start": "934680",
    "end": "939959"
  },
  {
    "text": "Branch off to any or else right",
    "start": "939959",
    "end": "944000"
  },
  {
    "text": "so if you look at that in source it means that you the the when you start evaluating the",
    "start": "945720",
    "end": "952800"
  },
  {
    "text": "pair you have to continue to either you end up in one of the outcomes or to the end of C there are no other words there",
    "start": "952800",
    "end": "959519"
  },
  {
    "text": "aren't you can't go anywhere else this is not true in general especially",
    "start": "959519",
    "end": "965339"
  },
  {
    "text": "in C plus plus because you have exceptions but exceptions don't contribute to control flow coverage because you wouldn't complete like you",
    "start": "965339",
    "end": "971940"
  },
  {
    "text": "wouldn't finish evaluating the expression and so they're ignored leaving us with a much simpler graph we're simply ignoring them",
    "start": "971940",
    "end": "979940"
  },
  {
    "text": "but other than that like they can be considered interruptible now that's what this Greek thing means right",
    "start": "979980",
    "end": "988339"
  },
  {
    "text": "this is the same proposition slightly restated in in the context of edges",
    "start": "991980",
    "end": "998100"
  },
  {
    "text": "and it says that all of the edges that originate from one of the nodes",
    "start": "998100",
    "end": "1004519"
  },
  {
    "text": "in a Boolean expression will go to either another node in the",
    "start": "1004519",
    "end": "1009740"
  },
  {
    "text": "same expression or one of the two outcome nodes and it's a really long way of saying you",
    "start": "1009740",
    "end": "1016220"
  },
  {
    "text": "have two outcomes of a Boolean expression right turns out this is actually a very key Insight so in this",
    "start": "1016220",
    "end": "1022399"
  },
  {
    "text": "uh drawing on the right you have the outcome marked in Gray and the nodes of",
    "start": "1022399",
    "end": "1027860"
  },
  {
    "text": "the expression marked in blue right another property of that is that all of",
    "start": "1027860",
    "end": "1034100"
  },
  {
    "text": "the edges within a Boolean will be conditional right again that's not completely true because",
    "start": "1034100",
    "end": "1040160"
  },
  {
    "text": "you can have function calls as a that will then evaluate one of the booleans but that will just be a long chain of",
    "start": "1040160",
    "end": "1047360"
  },
  {
    "text": "single fold through edges that we can be contracted so you can simplify that to you know being one long conditional Edge",
    "start": "1047360",
    "end": "1054260"
  },
  {
    "text": "right so again the maths work out",
    "start": "1054260",
    "end": "1058480"
  },
  {
    "text": "and then the final Insight from this is that if you look at the last term in",
    "start": "1059360",
    "end": "1065539"
  },
  {
    "text": "a conditional expression it has to decide the outcome so you have short circuiting and the outcome can be",
    "start": "1065539",
    "end": "1071059"
  },
  {
    "text": "decided by pretty much any of the notes right or any of the terms in an expression but if it's not decided by c c will make",
    "start": "1071059",
    "end": "1078440"
  },
  {
    "text": "a decision for you right it sounds so obvious it is so obvious",
    "start": "1078440",
    "end": "1083960"
  },
  {
    "text": "and what that means is that the successors of the last term in an expression in the graph will always be",
    "start": "1083960",
    "end": "1090500"
  },
  {
    "text": "to the two outcomes whereas the short circuiting edges will be to either of the outcomes right",
    "start": "1090500",
    "end": "1098860"
  },
  {
    "text": "put another way it means that you can't have a go to that will end up in the middle of an expression right you can't",
    "start": "1100220",
    "end": "1106220"
  },
  {
    "text": "put a go to in or a label in front of B and go to it right it doesn't work because the expression is an atomic unit",
    "start": "1106220",
    "end": "1113000"
  },
  {
    "text": "right okay so that gave me the first draft you know",
    "start": "1113000",
    "end": "1120620"
  },
  {
    "text": "for the first phase and it's it's it's a BFS right so you do a breadth first or death first",
    "start": "1120620",
    "end": "1126860"
  },
  {
    "text": "search kind of doesn't matter so we're gonna do that now um this is the ground",
    "start": "1126860",
    "end": "1133600"
  },
  {
    "text": "um do you start with a and you say okay there's a condition Edge",
    "start": "1134120",
    "end": "1140780"
  },
  {
    "text": "um so we get B what we want to do is we want to gather all the nodes that we can reach by following only condition edges right",
    "start": "1140780",
    "end": "1148400"
  },
  {
    "text": "okay we can reach C condition Edge we can reach t with the condition Edge",
    "start": "1148400",
    "end": "1154940"
  },
  {
    "text": "we can reach C but we already have collected C so we ignore it we've already collected T to ignore that we",
    "start": "1154940",
    "end": "1160940"
  },
  {
    "text": "can reach f um and that's really it right because you",
    "start": "1160940",
    "end": "1166760"
  },
  {
    "text": "see um both false and true have a single edge which means that they're not conditional they're fall through right so we stop searching",
    "start": "1166760",
    "end": "1174460"
  },
  {
    "text": "this is what it looks like uh with the cases that you need to check in order to handle the complex control program thing",
    "start": "1175039",
    "end": "1183080"
  },
  {
    "text": "in GCC make a queue and while there is something in the queue",
    "start": "1183080",
    "end": "1188860"
  },
  {
    "text": "uh from your starting node check through its accessor right",
    "start": "1188860",
    "end": "1195559"
  },
  {
    "text": "if you've already seen it throw it away if this is you skip it",
    "start": "1195559",
    "end": "1201980"
  },
  {
    "text": "if it's a back Edge so a typical Loop edges right or at the end of the loop you will have a back Edge to the top of",
    "start": "1201980",
    "end": "1207740"
  },
  {
    "text": "the loop ignore those they they don't matter uh there's a dominated relationship",
    "start": "1207740",
    "end": "1213700"
  },
  {
    "text": "which uh we're not going to go into now because it doesn't really affect anything at this point",
    "start": "1213700",
    "end": "1221019"
  },
  {
    "text": "um and attitude I mean this is a BFFs right",
    "start": "1221059",
    "end": "1225460"
  },
  {
    "text": "okay so we have a slightly different program where the C is not an or in the in the",
    "start": "1226400",
    "end": "1234200"
  },
  {
    "text": "if but it's it's in the outcome block of the then where is a single conditional and the control for graph for that is on the",
    "start": "1234200",
    "end": "1240860"
  },
  {
    "text": "right so this is one of the I think this is",
    "start": "1240860",
    "end": "1245960"
  },
  {
    "text": "the fifth test I wrote for this so we do the same algorithm okay from",
    "start": "1245960",
    "end": "1251840"
  },
  {
    "text": "here we can conditionally reach R and B we add those",
    "start": "1251840",
    "end": "1257000"
  },
  {
    "text": "um I'm going to try and add c and e but oops C is not a part of the expression",
    "start": "1257000",
    "end": "1263840"
  },
  {
    "text": "right so it turns out the simple BF fans is not sufficient because I mean the program on the left area is a pretty",
    "start": "1263840",
    "end": "1270559"
  },
  {
    "text": "common program right and not handling that is not an option because we shouldn't include C in the",
    "start": "1270559",
    "end": "1276919"
  },
  {
    "text": "set we want it to just be a and b right",
    "start": "1276919",
    "end": "1280659"
  },
  {
    "text": "so I took a step back and I realized that what the BFS gave me",
    "start": "1283580",
    "end": "1289940"
  },
  {
    "text": "was a cut okay so a cut is a graph partitioning",
    "start": "1289940",
    "end": "1296200"
  },
  {
    "text": "um where you can you can almost imagine a line that goes through the",
    "start": "1296419",
    "end": "1302139"
  },
  {
    "text": "the past the red nodes or edges going into",
    "start": "1302539",
    "end": "1309140"
  },
  {
    "text": "the red nodes um that is immediately reachable with this",
    "start": "1309140",
    "end": "1316039"
  },
  {
    "text": "BFS and then those adjacent to that because we're in this neighborhood thing remember the identity from before",
    "start": "1316039",
    "end": "1323799"
  },
  {
    "text": "and then we have an observation turned out to be very useful",
    "start": "1325700",
    "end": "1330760"
  },
  {
    "text": "and is that for all the edges in the cut or in in the whatever we find by",
    "start": "1331039",
    "end": "1338059"
  },
  {
    "text": "reach right so the the reachable monster conditionals they will all be conditionals and what that means",
    "start": "1338059",
    "end": "1345140"
  },
  {
    "text": "is that our outcome will be a part of what we can reach",
    "start": "1345140",
    "end": "1350900"
  },
  {
    "text": "right because there has to be conditional edges into the outcomes this is a just a very precise way of",
    "start": "1350900",
    "end": "1357320"
  },
  {
    "text": "saying that what I also implies is that the graph",
    "start": "1357320",
    "end": "1362659"
  },
  {
    "text": "we're searching for the expression we're searching for has to be a part of what Rich can find right it might find more",
    "start": "1362659",
    "end": "1368600"
  },
  {
    "text": "so what we now need to use essentially filter this",
    "start": "1368600",
    "end": "1373760"
  },
  {
    "text": "and then you notice that there's not really a path from the done block to the else block and there is a teeny tiny",
    "start": "1377360",
    "end": "1384320"
  },
  {
    "text": "Edge case with the go-to with nothing then I think actually is a",
    "start": "1384320",
    "end": "1390559"
  },
  {
    "text": "control photograph construction plugin GCC that will maybe violate this but for the",
    "start": "1390559",
    "end": "1395659"
  },
  {
    "text": "most part you're still interruptible within the single Boolean expression and it always",
    "start": "1395659",
    "end": "1400820"
  },
  {
    "text": "has two outcomes and there's no real communication in between right",
    "start": "1400820",
    "end": "1405820"
  },
  {
    "text": "and if you formalize that",
    "start": "1409880",
    "end": "1413200"
  },
  {
    "text": "um you will see that what what these have in common if you would if you take this",
    "start": "1415460",
    "end": "1420799"
  },
  {
    "text": "picture and you would reverse the edges you'll see that the only way to get into c and e for the most part when starting",
    "start": "1420799",
    "end": "1427700"
  },
  {
    "text": "it or actually when starting at a the only way to get into then and else is to evaluate all of the Expressions right",
    "start": "1427700",
    "end": "1432919"
  },
  {
    "text": "and both blocks have the leading or the conditional expression in common",
    "start": "1432919",
    "end": "1439340"
  },
  {
    "text": "now formally it means that the ancestors to the then",
    "start": "1439340",
    "end": "1446259"
  },
  {
    "text": "uh like for all of the nodes in the then",
    "start": "1446840",
    "end": "1452299"
  },
  {
    "text": "the Boolean expression will be a part of its ancestor side so if you if you take any node in",
    "start": "1452299",
    "end": "1458000"
  },
  {
    "text": "like uh in in the outcome like in p and you walk it all the way up to the top of",
    "start": "1458000",
    "end": "1463580"
  },
  {
    "text": "the graph B will be a part of that because I mean in order you're able to reach the then",
    "start": "1463580",
    "end": "1469520"
  },
  {
    "text": "block from the Boolean expression right that's why we have it",
    "start": "1469520",
    "end": "1474820"
  },
  {
    "text": "and this is pretty cool because they both have this property right both of them and the else",
    "start": "1477679",
    "end": "1484000"
  },
  {
    "text": "in a way you could flip the arrows here and it would be just as an alien right",
    "start": "1487340",
    "end": "1492500"
  },
  {
    "text": "it's okay let's let's look at that let's look at the ancestors from here",
    "start": "1492500",
    "end": "1497840"
  },
  {
    "text": "well it's CBN a right you you you can like any path that will go into queue",
    "start": "1497840",
    "end": "1506419"
  },
  {
    "text": "might go through or even have to in this case a b and c",
    "start": "1506419",
    "end": "1512080"
  },
  {
    "text": "and some applies to P right which makes sense because they're both the outcome of C",
    "start": "1512539",
    "end": "1517720"
  },
  {
    "text": "but r has a and b assets its ancestors",
    "start": "1519020",
    "end": "1525820"
  },
  {
    "text": "and what turns out is that this is a very good way of of",
    "start": "1528799",
    "end": "1534740"
  },
  {
    "text": "figuring out what these have in common uh like if you look at the neighborhood which is the",
    "start": "1534740",
    "end": "1541159"
  },
  {
    "text": "first thing you get that isn't a conditional right if if you take all of those ancestors",
    "start": "1541159",
    "end": "1547820"
  },
  {
    "text": "and see what minimal set of ancestors do they have in common which is what the b equals",
    "start": "1547820",
    "end": "1553400"
  },
  {
    "text": "find their big cap says that will give you the Boolean",
    "start": "1553400",
    "end": "1558799"
  },
  {
    "text": "expression because that's the only thing they both will have in common right",
    "start": "1558799",
    "end": "1563980"
  },
  {
    "text": "there's a problem with that because our BFS needs to start at the topmost node right it has to include all the",
    "start": "1566360",
    "end": "1572179"
  },
  {
    "text": "expression which means it has to start to start from the top and the solution design is actually",
    "start": "1572179",
    "end": "1577640"
  },
  {
    "text": "remarkably simple is that you can just Traverse the order or Traverse the graph in depth first order",
    "start": "1577640",
    "end": "1584120"
  },
  {
    "text": "so if if V is just if a node you're evaluating is just a fall through node mark it skip it throw it out",
    "start": "1584120",
    "end": "1591440"
  },
  {
    "text": "if it's a conditional node it's the first conditional node you're getting to so it has to be the leading term right",
    "start": "1591440",
    "end": "1598730"
  },
  {
    "text": "[Music] um so you do this scan this reach and then",
    "start": "1598730",
    "end": "1603919"
  },
  {
    "text": "filter and then you mark it right and so all of these have now been processed",
    "start": "1603919",
    "end": "1609559"
  },
  {
    "text": "and if it's already marked in this DFS search it means that it was already processed by an earlier leading nodes",
    "start": "1609559",
    "end": "1614659"
  },
  {
    "text": "it's an internal node in a Boolean expression and you go through right so I was thinking about this for a while",
    "start": "1614659",
    "end": "1620779"
  },
  {
    "text": "again this lead to problems and it may be may lead to Expressions being processed out of order which means that",
    "start": "1620779",
    "end": "1626539"
  },
  {
    "text": "if you have a long program it might uh you know it might process deep inside",
    "start": "1626539",
    "end": "1632179"
  },
  {
    "text": "like either inside the block in the else before the then so it might not be completely in the order of your",
    "start": "1632179",
    "end": "1638720"
  },
  {
    "text": "program from top to down because it depends on how the the order of the edges in the control flow graph",
    "start": "1638720",
    "end": "1643820"
  },
  {
    "text": "representation but it doesn't matter because each of those are independent anyway so you know that the expression the",
    "start": "1643820",
    "end": "1650720"
  },
  {
    "text": "isolated Boolean expression themselves will be processed in the right order and then you don't care about the program being processed in in arbitrary",
    "start": "1650720",
    "end": "1657500"
  },
  {
    "text": "order if you put that together you get this",
    "start": "1657500",
    "end": "1663020"
  },
  {
    "text": "and this is pretty easy to translate to Super",
    "start": "1663020",
    "end": "1669340"
  },
  {
    "text": "dialect that GCC usage right it's it's not a very complicated program",
    "start": "1669340",
    "end": "1675020"
  },
  {
    "text": "it's too Loops right and this is defined decision this is",
    "start": "1675020",
    "end": "1681380"
  },
  {
    "text": "where you start by doing a BFS if it's just one node in the BFS then it's fine it's just it's a single single F so you",
    "start": "1681380",
    "end": "1687799"
  },
  {
    "text": "just throw it out or you just return it but if not you have to do this thing where you collect all of the ancestors",
    "start": "1687799",
    "end": "1694039"
  },
  {
    "text": "of each of the nodes in this neighborhood which are the deepest possible candidates",
    "start": "1694039",
    "end": "1699559"
  },
  {
    "text": "right and then you take the intersection",
    "start": "1699559",
    "end": "1706419"
  },
  {
    "text": "this is that function as it's implemented in GCC minus the setup and",
    "start": "1708559",
    "end": "1715760"
  },
  {
    "text": "actually minus the setup the tear down is there",
    "start": "1715760",
    "end": "1719919"
  },
  {
    "text": "so what's that 15 lines maybe 20 something like that",
    "start": "1721039",
    "end": "1727159"
  },
  {
    "text": "and this is it kind of materialized right and what's nice about that is that",
    "start": "1727159",
    "end": "1735020"
  },
  {
    "text": "all of these operations are pretty high level and they map one to one to the",
    "start": "1735020",
    "end": "1740059"
  },
  {
    "text": "relationship between the graph and the outcome right",
    "start": "1740059",
    "end": "1745360"
  },
  {
    "text": "so you have the ancestors of function it does it collects the ancestors and then",
    "start": "1745960",
    "end": "1751400"
  },
  {
    "text": "you do uh bitmaps or sets that's really it",
    "start": "1751400",
    "end": "1758919"
  },
  {
    "text": "any questions it's new style so my apologies",
    "start": "1759080",
    "end": "1766120"
  },
  {
    "text": "I don't like big news time okay putting that together with the whole program analysis you you get this",
    "start": "1766159",
    "end": "1773240"
  },
  {
    "text": "you just do this in DFS order and then collect each of them so now what you",
    "start": "1773240",
    "end": "1778279"
  },
  {
    "text": "have when you run this program this too is pretty easy to translate to C plus plus when you have this",
    "start": "1778279",
    "end": "1784880"
  },
  {
    "text": "it's like or rather when you have this typed up this way the the implementation",
    "start": "1784880",
    "end": "1790460"
  },
  {
    "text": "just falls out it's remarkable",
    "start": "1790460",
    "end": "1794860"
  },
  {
    "text": "okay so let's talk about masking and I would did not actually expect anyone to get it right that wasn't from the one of",
    "start": "1796460",
    "end": "1802700"
  },
  {
    "text": "the three aforementioned Industries but masking happens",
    "start": "1802700",
    "end": "1809559"
  },
  {
    "text": "when it turns out the left hand side doesn't matter because it doesn't change the decision",
    "start": "1809960",
    "end": "1816380"
  },
  {
    "text": "because I mean and that happens on the when the right hand side of an R is true and the left right hand side of side of",
    "start": "1816380",
    "end": "1822919"
  },
  {
    "text": "an and is false right and then false it'll always be false",
    "start": "1822919",
    "end": "1829059"
  },
  {
    "text": "so the first observation I made there is or pretty early on is that Boolean expressions are isomorphic under the",
    "start": "1829279",
    "end": "1836539"
  },
  {
    "text": "operator so these are the two expressions under respective control flow graphs and when",
    "start": "1836539",
    "end": "1843559"
  },
  {
    "text": "I if you just invert the labels you get the same graph",
    "start": "1843559",
    "end": "1850179"
  },
  {
    "text": "which is pretty neat so I wondered why and and this is where",
    "start": "1850340",
    "end": "1856520"
  },
  {
    "text": "the Theory comes in right because I mean it's fine that they have this property or it's they seem to have this property",
    "start": "1856520",
    "end": "1861620"
  },
  {
    "text": "but why understanding why means you can leverage it and the previous really just say the Morgan and then go out of there",
    "start": "1861620",
    "end": "1868279"
  },
  {
    "text": "and get out um that they have to be the implication of that is that we",
    "start": "1868279",
    "end": "1875000"
  },
  {
    "text": "actually don't need to understand the operator unlike in the AST approach that was discussed by the University of",
    "start": "1875000",
    "end": "1881179"
  },
  {
    "text": "Minnesota while I'm friends you only need to understand the shape",
    "start": "1881179",
    "end": "1888100"
  },
  {
    "text": "so if you look at what masking happens from a control photograph perspective",
    "start": "1892460",
    "end": "1897820"
  },
  {
    "text": "it's so very briefly masking happens",
    "start": "1898880",
    "end": "1904460"
  },
  {
    "text": "um or rather a a condition is independent if you can give the same input vector",
    "start": "1904460",
    "end": "1912860"
  },
  {
    "text": "change it change that one variable and while keeping all of the other elements in the vector effects like the function",
    "start": "1912860",
    "end": "1919340"
  },
  {
    "text": "inputs fixed and have the decision be different right",
    "start": "1919340",
    "end": "1926260"
  },
  {
    "text": "and it turns out in in graphs",
    "start": "1926480",
    "end": "1930940"
  },
  {
    "text": "this uh happens when taking another path still ends up with the same node right",
    "start": "1931539",
    "end": "1938419"
  },
  {
    "text": "so when you have a branch you can either go to the true to the false if you go to the false but you keep on making the",
    "start": "1938419",
    "end": "1944539"
  },
  {
    "text": "choices you otherwise would have made and you end up in the same note so I have an example of that here",
    "start": "1944539",
    "end": "1950539"
  },
  {
    "text": "in for a or b right on the right hand the the right one you can see it goes",
    "start": "1950539",
    "end": "1957260"
  },
  {
    "text": "through b but still ends up in true right because B was said to be true in the middle one B was had to be true",
    "start": "1957260",
    "end": "1965299"
  },
  {
    "text": "but it was never evaluated because you're a short circuit and this is actually a key insight",
    "start": "1965299",
    "end": "1972100"
  },
  {
    "text": "because masking can only happen at nodes that has multiple predecessors right",
    "start": "1972799",
    "end": "1979600"
  },
  {
    "text": "and if you have multiple predecessors that means that you are the destination of someone else's Short Circuit",
    "start": "1979640",
    "end": "1986240"
  },
  {
    "text": "an implication of that is that we know where to start looking for masking effects right",
    "start": "1986240",
    "end": "1992120"
  },
  {
    "text": "because remember when you're looking at this from a competitive perspective you're giving an arbitrary graph you",
    "start": "1992120",
    "end": "1997220"
  },
  {
    "text": "don't really know how you got there all you can do is maybe recognize the shape",
    "start": "1997220",
    "end": "2002760"
  },
  {
    "text": "it's a little bit of repetition from I guess sixth form uh it's the association right",
    "start": "2003519",
    "end": "2010659"
  },
  {
    "text": "um under the same Boolean operator you can remove the params it doesn't matter it doesn't change anything",
    "start": "2010659",
    "end": "2015820"
  },
  {
    "text": "this actually turns out to be very useful because that means that you can take any Boolean expression and rewrite it into",
    "start": "2015820",
    "end": "2022659"
  },
  {
    "text": "an alternate or canonical one I actually don't have a good name for it forum where you have a chain of Opera operands",
    "start": "2022659",
    "end": "2030580"
  },
  {
    "text": "with no parents and you have the parents every time the operator changes so you kind of get this",
    "start": "2030580",
    "end": "2036580"
  },
  {
    "text": "nesting effect right and it turns out that if you look at the control flow graph that will be",
    "start": "2036580",
    "end": "2042700"
  },
  {
    "text": "represented pretty much exactly like that that's that's how the control flow graph gets constructed because of this",
    "start": "2042700",
    "end": "2048158"
  },
  {
    "text": "relationship and masking will propagate until the",
    "start": "2048159",
    "end": "2054760"
  },
  {
    "text": "operator changes right so in this case if you have D equals true",
    "start": "2054760",
    "end": "2060520"
  },
  {
    "text": "then it doesn't matter what B and C are because the forensic expression the sub",
    "start": "2060520",
    "end": "2065800"
  },
  {
    "text": "expression will always be true right but a like an and expression will never",
    "start": "2065800",
    "end": "2070960"
  },
  {
    "text": "be masked by its right hand sign being true right so a is not mass but B and CR",
    "start": "2070960",
    "end": "2076898"
  },
  {
    "text": "because there's an operator change right",
    "start": "2076899",
    "end": "2080819"
  },
  {
    "text": "however the outcome of a sub-expression as a whole may still mask",
    "start": "2083919",
    "end": "2089138"
  },
  {
    "text": "outside of this again this is not very it if you just look at the proposition it's very intuitive right because you",
    "start": "2089139",
    "end": "2096700"
  },
  {
    "text": "can do substitution so if we would substitute b or c for f and then write it as a and F",
    "start": "2096700",
    "end": "2103060"
  },
  {
    "text": "I mean it's obvious that F can can mask right",
    "start": "2103060",
    "end": "2108780"
  },
  {
    "text": "so if C in this case would be evaluated to force that actually also implies that",
    "start": "2109839",
    "end": "2115180"
  },
  {
    "text": "b is false because otherwise C would be short-circuited and we wouldn't have this problem in the first place but it would then also mask a",
    "start": "2115180",
    "end": "2122260"
  },
  {
    "text": "however c will not mask B because you have to have a false B in order to get there in the first place and you never",
    "start": "2122260",
    "end": "2127480"
  },
  {
    "text": "must from the left hand side so this kind of follows from from the",
    "start": "2127480",
    "end": "2134800"
  },
  {
    "text": "observation from before is that uh s Omega means the last term in s right",
    "start": "2134800",
    "end": "2142480"
  },
  {
    "text": "s is now a sub expression whereas V was the full Boolean expression now the last term in a sub expression can short",
    "start": "2142480",
    "end": "2148420"
  },
  {
    "text": "circuit in the super expression that kind of follows from the same thing with the the the last term in an",
    "start": "2148420",
    "end": "2154780"
  },
  {
    "text": "expression will have to decide the expression right because there are no more terms to the",
    "start": "2154780",
    "end": "2160119"
  },
  {
    "text": "rights of it so I came up with this funky way of drawing it where you actually draw it in",
    "start": "2160119",
    "end": "2166720"
  },
  {
    "text": "nesting levels right so uh on top you will see it Ronin is",
    "start": "2166720",
    "end": "2173380"
  },
  {
    "text": "alternating form and the lower figure is where you're drawing this uh with as the operator alternates so in",
    "start": "2173380",
    "end": "2180700"
  },
  {
    "text": "but you can imagine in between all of the the terms in the top row there will be and and there will be ores in between",
    "start": "2180700",
    "end": "2187060"
  },
  {
    "text": "the second row and then ants again in the third row and it will go and it will alternate",
    "start": "2187060",
    "end": "2193680"
  },
  {
    "text": "and when you put it out on a paper like this you actually get some interesting things you can do with arrows",
    "start": "2194260",
    "end": "2201820"
  },
  {
    "text": "so if you if you make C through or H true you will see how short circulating",
    "start": "2201820",
    "end": "2207099"
  },
  {
    "text": "works right because you basically move one level up and go to the next one on the right",
    "start": "2207099",
    "end": "2212619"
  },
  {
    "text": "and it doesn't matter what level you're at because remember that this propagation is firewalled by the change",
    "start": "2212619",
    "end": "2220119"
  },
  {
    "text": "of the operator",
    "start": "2220119",
    "end": "2222720"
  },
  {
    "text": "when D is true in this case it will keep on evaluating e because the",
    "start": "2226300",
    "end": "2233380"
  },
  {
    "text": "sub expression C or D is evaluated to true and true does not short circuit or uh sorry and right it keeps on",
    "start": "2233380",
    "end": "2240520"
  },
  {
    "text": "evaluating but if it is false it short circuits all",
    "start": "2240520",
    "end": "2246520"
  },
  {
    "text": "the way here but if these phones they will also do",
    "start": "2246520",
    "end": "2252280"
  },
  {
    "text": "one more thing right because it will mask A and B",
    "start": "2252280",
    "end": "2259680"
  },
  {
    "text": "and there you have this interesting effect that when you see a lower level short circuit it's super expression then",
    "start": "2261099",
    "end": "2267460"
  },
  {
    "text": "there will also be a masking effect because you're now with the wrong value at the right operator if you will right",
    "start": "2267460",
    "end": "2276000"
  },
  {
    "text": "turns out this observation is very useful",
    "start": "2277599",
    "end": "2281700"
  },
  {
    "text": "so when you're evaluating a condition you have two possible outcomes like either",
    "start": "2282940",
    "end": "2288460"
  },
  {
    "text": "you Short Circuit the right operands or you keep on evaluating right this it sounds silly to have to to repeat it but",
    "start": "2288460",
    "end": "2295300"
  },
  {
    "text": "it's actually very useful and the implication here is that if one of the edges is short",
    "start": "2295300",
    "end": "2301359"
  },
  {
    "text": "circuiting the other one has to be a masking Edge right",
    "start": "2301359",
    "end": "2308760"
  },
  {
    "text": "because this relationship is so intimate",
    "start": "2309040",
    "end": "2313200"
  },
  {
    "text": "and now we can finally State our problem right so given a path of incoming edges which one is masking and which one is",
    "start": "2315280",
    "end": "2321220"
  },
  {
    "text": "short circuiting how can you tell",
    "start": "2321220",
    "end": "2324420"
  },
  {
    "text": "and the implications we kind of need of or rather what we would get from being able to answer that as an ordering",
    "start": "2326260",
    "end": "2333099"
  },
  {
    "text": "where if you have two nodes then one is less than the other if it's a left off",
    "start": "2333099",
    "end": "2338740"
  },
  {
    "text": "Rand right because we it has to go that way",
    "start": "2338740",
    "end": "2343260"
  },
  {
    "text": "um and it's writer if it's the right operand within the same expression",
    "start": "2345160",
    "end": "2351780"
  },
  {
    "text": "and add in how to figure that out",
    "start": "2351820",
    "end": "2356520"
  },
  {
    "text": "the resolution is topological sort which is really just a DFS like you do a",
    "start": "2360700",
    "end": "2366400"
  },
  {
    "text": "depth first search and you record them as you go",
    "start": "2366400",
    "end": "2370500"
  },
  {
    "text": "so now we have that right this relationship will get the the",
    "start": "2372099",
    "end": "2378520"
  },
  {
    "text": "this is like the implication is pretty much the the definition of the topological sort right",
    "start": "2378520",
    "end": "2384520"
  },
  {
    "text": "and writing a topological story is easy because you go to Wikipedia and you search top sort and you copy it from",
    "start": "2384520",
    "end": "2390640"
  },
  {
    "text": "there okay so now given a pair of notes",
    "start": "2390640",
    "end": "2398140"
  },
  {
    "text": "which happen to be the predecessors of the third node right then you will be able to compare them",
    "start": "2398140",
    "end": "2404320"
  },
  {
    "text": "and order them right then you will have that the lower one of",
    "start": "2404320",
    "end": "2411579"
  },
  {
    "text": "those will have to be some sub-expressions",
    "start": "2411579",
    "end": "2418660"
  },
  {
    "text": "final term or last term as an implicational bias that you now",
    "start": "2418660",
    "end": "2425680"
  },
  {
    "text": "also know the outcomes of that expression and just further notation s is one of",
    "start": "2425680",
    "end": "2433359"
  },
  {
    "text": "the sub-expressions of of B so just go back here then s could be G or H or an i",
    "start": "2433359",
    "end": "2442300"
  },
  {
    "text": "or J or something right any of these most of those are single term but you have a couple of multi-term ones",
    "start": "2442300",
    "end": "2450000"
  },
  {
    "text": "and the other implication is that the other one then taking the M taking the Higher One the deeper one in the graph",
    "start": "2451300",
    "end": "2459339"
  },
  {
    "text": "uh when you take that one that uh the the nodes in s will be masked right",
    "start": "2459339",
    "end": "2469380"
  },
  {
    "text": "it's a bit of repetition inside the closed neighborhood of the",
    "start": "2470619",
    "end": "2476020"
  },
  {
    "text": "is just you know pick all of the successors of the nodes in B this is assuming in OB",
    "start": "2476020",
    "end": "2481359"
  },
  {
    "text": "then you get the uh the close neighborhood and the open neighborhood is it's the",
    "start": "2481359",
    "end": "2487119"
  },
  {
    "text": "outcome so anything that was true for B the full Boolean expression will obviously be",
    "start": "2487119",
    "end": "2493359"
  },
  {
    "text": "true for a sub-expression which is still a valid Boolean expression in its own right you know",
    "start": "2493359",
    "end": "2499260"
  },
  {
    "text": "and now we can Define the final problem which is to figure out given this Edge",
    "start": "2500500",
    "end": "2505599"
  },
  {
    "text": "I'm taking what nodes will be masked what terms will be masked",
    "start": "2505599",
    "end": "2512079"
  },
  {
    "text": "there is one intermediate problem in that is that you might have more incoming edges and this is always if you have a bazillion terms you will have a",
    "start": "2512079",
    "end": "2518380"
  },
  {
    "text": "lot of short circuiting and if you're a lot of short circuiting you have a lot of masking effects because you can't have one without the",
    "start": "2518380",
    "end": "2524740"
  },
  {
    "text": "other which again is shown by reversing the expression right",
    "start": "2524740",
    "end": "2530880"
  },
  {
    "text": "and the solution to that is really to do a Cartesian product and filter because we can order we can compare in",
    "start": "2531280",
    "end": "2537280"
  },
  {
    "text": "constant time it's very easy to just I mean sort them right and process them",
    "start": "2537280",
    "end": "2544859"
  },
  {
    "text": "so let's do that for this A and B and C program",
    "start": "2545440",
    "end": "2552000"
  },
  {
    "text": "this is one pair of short circuits on masking Edge and you if you apply the",
    "start": "2553720",
    "end": "2558940"
  },
  {
    "text": "masking thing so if you take C to false obviously a didn't matter",
    "start": "2558940",
    "end": "2563980"
  },
  {
    "text": "right because a is on the left hand there are all ants between right and the same thing applies to B if if",
    "start": "2563980",
    "end": "2570700"
  },
  {
    "text": "you take The Edge C to F then it didn't matter that B to C was true",
    "start": "2570700",
    "end": "2579240"
  },
  {
    "text": "but also um if you take B is false then it didn't",
    "start": "2580060",
    "end": "2585099"
  },
  {
    "text": "matter what a was and otherwise all that put together I first see you can just combine these two",
    "start": "2585099",
    "end": "2591819"
  },
  {
    "text": "right this is the same Expressions before but",
    "start": "2591819",
    "end": "2596859"
  },
  {
    "text": "I've substituted the B for an S because now we're on the on the sub expression",
    "start": "2596859",
    "end": "2602818"
  },
  {
    "text": "so this relationship has a surprisingly useful implication",
    "start": "2604420",
    "end": "2610020"
  },
  {
    "text": "and that is that if you define the first um I don't know start S I don't know the",
    "start": "2610480",
    "end": "2617740"
  },
  {
    "text": "first s s0 to be the outcome which you now have because you have the last term",
    "start": "2617740",
    "end": "2624700"
  },
  {
    "text": "and the outcome right you have the successor function",
    "start": "2624700",
    "end": "2630240"
  },
  {
    "text": "then you can and really when you think about this is",
    "start": "2630339",
    "end": "2637540"
  },
  {
    "text": "the same problem we did when we found the expressions in the first and isolated the decisions in the first place but in Reverse now we have the",
    "start": "2637540",
    "end": "2643780"
  },
  {
    "text": "outcomes and we need to figure out what terms are a part of this sub-expression right",
    "start": "2643780",
    "end": "2649240"
  },
  {
    "text": "but now we know what the outcomes are we didn't know anything about it other than the leading term when we went it from above right",
    "start": "2649240",
    "end": "2656440"
  },
  {
    "text": "um so then if you look at what nodes",
    "start": "2656440",
    "end": "2662380"
  },
  {
    "text": "have both of their successors in the set of nodes I've already seen or collected",
    "start": "2662380",
    "end": "2668680"
  },
  {
    "text": "and if you start with the outcome because of this property that all of the nodes in an expression will have its",
    "start": "2668680",
    "end": "2674740"
  },
  {
    "text": "edges either to some other node in the expression or one of the outcomes you eventually get a fixed point",
    "start": "2674740",
    "end": "2682740"
  },
  {
    "text": "by repeatedly seeing you know what nodes have all of their successors in the large the growing s",
    "start": "2682900",
    "end": "2692400"
  },
  {
    "text": "where there are no more notes to add right so this is a very",
    "start": "2692400",
    "end": "2698680"
  },
  {
    "text": "you know notation heavy weight off denoting something is actually pretty easy to do by hand so we can have this",
    "start": "2698680",
    "end": "2704319"
  },
  {
    "text": "Expression A and B and C or D",
    "start": "2704319",
    "end": "2708900"
  },
  {
    "text": "and this is our short circuiting Target the short circuit is C2",
    "start": "2710260",
    "end": "2716579"
  },
  {
    "text": "D so D is short-circuited then we have the CTS as a short",
    "start": "2716579",
    "end": "2723579"
  },
  {
    "text": "circuiting Edge and D to T is our masking Edge so taking the edge B to T",
    "start": "2723579",
    "end": "2729160"
  },
  {
    "text": "wood mask BNC and here you can tell immediately you know from being human where you want to end up you want to end",
    "start": "2729160",
    "end": "2736240"
  },
  {
    "text": "up with b and c right so let's do it",
    "start": "2736240",
    "end": "2742140"
  },
  {
    "text": "we know that the last term in the expression we're looking for",
    "start": "2742660",
    "end": "2747880"
  },
  {
    "text": "is C right because it's the lower ranked of the two",
    "start": "2747880",
    "end": "2754480"
  },
  {
    "text": "nodes in the topological sort",
    "start": "2754480",
    "end": "2758760"
  },
  {
    "text": "and we know that the outcome are are the successives of this node which are DNT",
    "start": "2761079",
    "end": "2767560"
  },
  {
    "text": "right so this is the outcome we start by marking which means that our initial zero",
    "start": "2767560",
    "end": "2773920"
  },
  {
    "text": "is D and T and now I'm Mark the edges gray to our those ideas that go into our",
    "start": "2773920",
    "end": "2780280"
  },
  {
    "text": "s n and you can see C now is is an offline",
    "start": "2780280",
    "end": "2785500"
  },
  {
    "text": "no sorry it's not an option it's it has no children anyway what's the term for that",
    "start": "2785500",
    "end": "2790660"
  },
  {
    "text": "anyone else pardon Leaf thank you it's a leaf so",
    "start": "2790660",
    "end": "2796060"
  },
  {
    "text": "that's really what you're doing you know you pick the leaf you remove the edge obviously it's almost like doing it from",
    "start": "2796060",
    "end": "2802060"
  },
  {
    "text": "a tree and then you look for new leaves so that's what we're doing",
    "start": "2802060",
    "end": "2808960"
  },
  {
    "text": "so S1 as you know you add the C and then you remove the edge C to B you need the",
    "start": "2808960",
    "end": "2814180"
  },
  {
    "text": "same thing for B but a still has an outgoing Edge right so uh that's our",
    "start": "2814180",
    "end": "2819940"
  },
  {
    "text": "limit this is our fixed point you can do this however many times you want and you will never get a larger set than S2 which is",
    "start": "2819940",
    "end": "2826180"
  },
  {
    "text": "DTC and B and then we remove our initial two outcomes because obviously they aren't a",
    "start": "2826180",
    "end": "2832300"
  },
  {
    "text": "part of the sub-expression they're the outcomes what we're left with are B and C turns",
    "start": "2832300",
    "end": "2838599"
  },
  {
    "text": "out this works for any graph",
    "start": "2838599",
    "end": "2841680"
  },
  {
    "text": "if you put it together in sort of algorithmic notation if that's the thing it looks something",
    "start": "2844180",
    "end": "2851619"
  },
  {
    "text": "like this where the first two lines are pretty much specifying what and how to interact",
    "start": "2851619",
    "end": "2858339"
  },
  {
    "text": "right but I think it's much easier to look at it in terms of you know remove the edges from the graph",
    "start": "2858339",
    "end": "2863859"
  },
  {
    "text": "uh when there or remove the leaves and then obviously the edges that would go through that leaf and then keep on",
    "start": "2863859",
    "end": "2869260"
  },
  {
    "text": "removing until you're at the fixed points",
    "start": "2869260",
    "end": "2872760"
  },
  {
    "text": "this too is pretty easy to just straight up map to C plus I would do the",
    "start": "2874900",
    "end": "2880300"
  },
  {
    "text": "Cartesian product is a nested for Loop over the predecessors",
    "start": "2880300",
    "end": "2886900"
  },
  {
    "text": "where you do the if smaller or larger than continue right",
    "start": "2886900",
    "end": "2893800"
  },
  {
    "text": "the program just fell out",
    "start": "2893800",
    "end": "2897720"
  },
  {
    "text": "so I look at some consequences and drawbacks of the algorithm and of the approach so the good is that if you",
    "start": "2899140",
    "end": "2904780"
  },
  {
    "text": "implement this in the middle and it's useful for more languages so it's largely been tested with c and",
    "start": "2904780",
    "end": "2910240"
  },
  {
    "text": "some C plus plus because C plus plus have fun things like exceptions and primarily exceptions but also classes",
    "start": "2910240",
    "end": "2916300"
  },
  {
    "text": "that can sometimes obscure things I tested it for d uh and D has checked",
    "start": "2916300",
    "end": "2922619"
  },
  {
    "text": "array access like bounce tracks which means that every array access now gets a conditional check which is nice",
    "start": "2922619",
    "end": "2929079"
  },
  {
    "text": "or not defending uh which it does pick up on and it's",
    "start": "2929079",
    "end": "2934359"
  },
  {
    "text": "consistent with highgco operates for this Branch coverage the ban is that it's very sensitive to",
    "start": "2934359",
    "end": "2940540"
  },
  {
    "text": "control for graphic construction and that also means that currently it is useless in go because go uses a",
    "start": "2940540",
    "end": "2946359"
  },
  {
    "text": "different strategy for constructing the control flow graph where it constantly calls booleans",
    "start": "2946359",
    "end": "2952380"
  },
  {
    "text": "I have an idea of viewing doing data flow analysis on top of that to undo the",
    "start": "2952380",
    "end": "2958240"
  },
  {
    "text": "work that the go frontenders and also to uh to stop some programmers from",
    "start": "2958240",
    "end": "2964180"
  },
  {
    "text": "cheating coverage doing that which would be pretty cool it would be an even stricter form of mcdc",
    "start": "2964180",
    "end": "2970420"
  },
  {
    "text": "uh and again the bad is that it does pick up on an implicit conditionals because may or may not want to to",
    "start": "2970420",
    "end": "2976660"
  },
  {
    "text": "have bounce check of every array access in your test Suite and some experiences are",
    "start": "2976660",
    "end": "2982119"
  },
  {
    "text": "indistinguishable because they're controllable control flow graphs are the same that may or may not be a feature",
    "start": "2982119",
    "end": "2987160"
  },
  {
    "text": "you can expect your compiler to do some term rewriting for you so maybe that's",
    "start": "2987160",
    "end": "2992200"
  },
  {
    "text": "cool thank you and then there's the Beautiful",
    "start": "2992200",
    "end": "2998460"
  },
  {
    "text": "so I'm actually very happy with this program I the the first first draft which was before I started trying to do",
    "start": "2998859",
    "end": "3005099"
  },
  {
    "text": "the maths on this was absolutely terrible awful uh and really didn't work it was way too",
    "start": "3005099",
    "end": "3011880"
  },
  {
    "text": "complicated and it handled most of the special cases until I added one tiny one",
    "start": "3011880",
    "end": "3017880"
  },
  {
    "text": "that broke the entire model right because it turned out the algorithm was wrong because I didn't actually understand the",
    "start": "3017880",
    "end": "3023700"
  },
  {
    "text": "relationship in the graphs programs then has this natural way of becoming way much like higher level so",
    "start": "3023700",
    "end": "3031020"
  },
  {
    "text": "most of the operations in the actual algorithm itself in the code in civil Plus",
    "start": "3031020",
    "end": "3036300"
  },
  {
    "text": "or like they're various sets operations and graph traversals and searches right they're",
    "start": "3036300",
    "end": "3043500"
  },
  {
    "text": "easy to understand and then you can combine these higher level operations which are now simple function calls",
    "start": "3043500",
    "end": "3048599"
  },
  {
    "text": "rather than having to master or you know what through hundreds of lines of Loops in special cases and checks that don't",
    "start": "3048599",
    "end": "3055319"
  },
  {
    "text": "really make sense to anyone unless you're deeply familiar with how it works",
    "start": "3055319",
    "end": "3060740"
  },
  {
    "text": "it turns uh too that this is a pretty good opportunity for good naming because now you actually have an intent that",
    "start": "3061680",
    "end": "3067980"
  },
  {
    "text": "you're able to put into the name and it makes code almost more malleable because now you can do some implementation",
    "start": "3067980",
    "end": "3073740"
  },
  {
    "text": "changes but you also know that you need to say um Implement whatever variants that sets",
    "start": "3073740",
    "end": "3080160"
  },
  {
    "text": "operations would do so you can do something other than a bit mask",
    "start": "3080160",
    "end": "3085500"
  },
  {
    "text": "that would map back to some node array you can do literally this with standard",
    "start": "3085500",
    "end": "3091380"
  },
  {
    "text": "set if you'd like to but you still have to obey the rules of the set not of some maybe obscure implementation detail it",
    "start": "3091380",
    "end": "3097260"
  },
  {
    "text": "also leaves a lot of room for cool optimizations that you can do because they they optimization that are possible",
    "start": "3097260",
    "end": "3103200"
  },
  {
    "text": "because of these set relationships rather than uh maybe a cool trick that happened to",
    "start": "3103200",
    "end": "3109260"
  },
  {
    "text": "work because of representation and honestly it's pretty fast to complete programs notice I didn't say",
    "start": "3109260",
    "end": "3115380"
  },
  {
    "text": "right programs but Complete because I think if you consider writing plus the",
    "start": "3115380",
    "end": "3120540"
  },
  {
    "text": "debugging and testing you have to do when you don't have a strong theoretical theoretical foundation for what you're doing",
    "start": "3120540",
    "end": "3126720"
  },
  {
    "text": "it's faster to type but I think they're slower to complete",
    "start": "3126720",
    "end": "3132980"
  },
  {
    "text": "we do have a few minutes I would like to also mention how it's instrumented but to be fair this approach isn't mine this",
    "start": "3134040",
    "end": "3140760"
  },
  {
    "text": "I installed from the University of Minnesota and there are violin and his guys",
    "start": "3140760",
    "end": "3146880"
  },
  {
    "text": "better observation is that instrumentation has to be fast right in particular because those that care",
    "start": "3146880",
    "end": "3153540"
  },
  {
    "text": "the most for mcdc tend to also Target embedded which means that there are limitations to how",
    "start": "3153540",
    "end": "3159720"
  },
  {
    "text": "intrusive instrumentation can be and the good thing is that you really only need a handful of bitwise",
    "start": "3159720",
    "end": "3165540"
  },
  {
    "text": "instructions in order to make this work so remember that there is an ordering",
    "start": "3165540",
    "end": "3171300"
  },
  {
    "text": "like you can sort the nodes because of this topological sort which also means that we can sort B",
    "start": "3171300",
    "end": "3179400"
  },
  {
    "text": "right so if you have a Boolean expression you have a bunch of nodes that you know belong to the same Boolean expression",
    "start": "3179400",
    "end": "3185040"
  },
  {
    "text": "then you can sort them right",
    "start": "3185040",
    "end": "3189980"
  },
  {
    "text": "and that also means that there is a bijection from the natural numbers to",
    "start": "3190319",
    "end": "3195839"
  },
  {
    "text": "the nodes in b",
    "start": "3195839",
    "end": "3199099"
  },
  {
    "text": "so what we're doing is that we initialize two Global accumulators for every decision and roughly speaking",
    "start": "3200940",
    "end": "3207900"
  },
  {
    "text": "that's an if but you get them in the Wilds you get them in the do Wireless in the fort like anything that would change control flow",
    "start": "3207900",
    "end": "3214079"
  },
  {
    "text": "you get two Global accumulators you can fold these if you want to save even more",
    "start": "3214079",
    "end": "3220140"
  },
  {
    "text": "on space into one and then use a protocol for which bit means one so here they're represented by a 4-bit",
    "start": "3220140",
    "end": "3227819"
  },
  {
    "text": "integer uh in GCC they typically use 64-bit for",
    "start": "3227819",
    "end": "3233280"
  },
  {
    "text": "Intel it's a variable with the type so it depends on your target architecture",
    "start": "3233280",
    "end": "3239880"
  },
  {
    "text": "um and then there's an expression on the right A and B or C okay",
    "start": "3239880",
    "end": "3244920"
  },
  {
    "text": "and since there is a simple injection we can do this there's not a the first term is the",
    "start": "3244920",
    "end": "3250559"
  },
  {
    "text": "least significant that b is the second month you know blah blah",
    "start": "3250559",
    "end": "3255920"
  },
  {
    "text": "so if you then run it with zero zero one you now see what bits you set right",
    "start": "3256079",
    "end": "3262980"
  },
  {
    "text": "so this is how the global accumulators work and these are stored and persistently in between functions and eventually this is what gets written to",
    "start": "3262980",
    "end": "3269220"
  },
  {
    "text": "the G color file so you run it again for zero zero zero",
    "start": "3269220",
    "end": "3275520"
  },
  {
    "text": "and now you've set um a for false",
    "start": "3275520",
    "end": "3281119"
  },
  {
    "text": "and then for uh",
    "start": "3281520",
    "end": "3286460"
  },
  {
    "text": "a and not b or c then you set the SE two",
    "start": "3287220",
    "end": "3294619"
  },
  {
    "text": "the local accumulators pretty much behave in the same way but remember that we have the masking thing oh yeah oh so",
    "start": "3294960",
    "end": "3302040"
  },
  {
    "text": "by the way so since these are integers updating these masses is a simple bit a bit twice or right",
    "start": "3302040",
    "end": "3310220"
  },
  {
    "text": "for the local accumulators we need to do a little bit more so what we do is that whenever you take",
    "start": "3310260",
    "end": "3315839"
  },
  {
    "text": "and this is what happens in the function so you have because",
    "start": "3315839",
    "end": "3321180"
  },
  {
    "text": "a function is pretty much single threaded all the way down conceptually it is sufficient to have",
    "start": "3321180",
    "end": "3328200"
  },
  {
    "text": "two accumulators one for three and one for false for all of the conditions in a function so here we do save some space",
    "start": "3328200",
    "end": "3335600"
  },
  {
    "text": "[Music] um so then what we need to do is that whenever we we take an edge in",
    "start": "3335600",
    "end": "3342000"
  },
  {
    "text": "the control flow graph as we evaluate one value to true or false uh we record that index",
    "start": "3342000",
    "end": "3349680"
  },
  {
    "text": "of the edge that corresponds to it right and then we look into this masking",
    "start": "3349680",
    "end": "3356640"
  },
  {
    "text": "Vector this table of masks and then we see will this trigger masking operation",
    "start": "3356640",
    "end": "3362160"
  },
  {
    "text": "and we just remove the things that had previously been set that would have been that are not masked",
    "start": "3362160",
    "end": "3369420"
  },
  {
    "text": "away so in in this case e is The Edge taken",
    "start": "3369420",
    "end": "3375960"
  },
  {
    "text": "and M of the are the notes that will be masked when taking marriage",
    "start": "3375960",
    "end": "3381859"
  },
  {
    "text": "this is what it would look like in the binary for the function A or B I picked up",
    "start": "3382740",
    "end": "3388079"
  },
  {
    "text": "two term one to just keep the example smaller so you would have a Prelude which would reset your accumulators",
    "start": "3388079",
    "end": "3397140"
  },
  {
    "text": "the local accumulators and then you just run the program right so you see if you take the edge a if a",
    "start": "3397140",
    "end": "3403680"
  },
  {
    "text": "is true then you update the true array with one right",
    "start": "3403680",
    "end": "3409440"
  },
  {
    "text": "and then otherwise you update the false array for a with one",
    "start": "3409440",
    "end": "3415040"
  },
  {
    "text": "and then you either go to the true or to the B depending on the value right",
    "start": "3415200",
    "end": "3421559"
  },
  {
    "text": "and B has a masking effect so it's B if B is true then you need to remove the",
    "start": "3421559",
    "end": "3426900"
  },
  {
    "text": "value that would have been set um",
    "start": "3426900",
    "end": "3432960"
  },
  {
    "text": "by a so that's where you do the and",
    "start": "3432960",
    "end": "3440579"
  },
  {
    "text": "before finally updating it with yourself and of course at the end of the Boolean",
    "start": "3440579",
    "end": "3446700"
  },
  {
    "text": "expression uh these are flushed right",
    "start": "3446700",
    "end": "3452940"
  },
  {
    "text": "to the global ones in in implementation wise you need to",
    "start": "3452940",
    "end": "3458940"
  },
  {
    "text": "add the instrumentation code whenever you're taking an edge to the outcome in order to satisfy you know exceptions and",
    "start": "3458940",
    "end": "3465599"
  },
  {
    "text": "it doesn't matter too much but that's where we insert instrumentation code so just a handful of bitwise instructions",
    "start": "3465599",
    "end": "3471480"
  },
  {
    "text": "no branching it's very fast",
    "start": "3471480",
    "end": "3475338"
  },
  {
    "text": "um yeah that's that's really it any questions oh yeah I have this one though so",
    "start": "3477059",
    "end": "3482880"
  },
  {
    "text": "some graphs will be indistinguishable so A and B and C and if a b c in order if",
    "start": "3482880",
    "end": "3489960"
  },
  {
    "text": "there are no alpses will be the same control flow graph and therefore have the same coverage report",
    "start": "3489960",
    "end": "3496200"
  },
  {
    "text": "which is not necessarily what you expect when you type it because again we've thrown away the syntax but semantically",
    "start": "3496200",
    "end": "3502980"
  },
  {
    "text": "this makes sense right semantically these two are identical all right",
    "start": "3502980",
    "end": "3509460"
  },
  {
    "text": "um that's lunch uh if you have any questions uh or if you want to see how it works on the computer",
    "start": "3509460",
    "end": "3516420"
  },
  {
    "text": "uh grab me at lunch or between sessions or come to the talk in a few hours thank",
    "start": "3516420",
    "end": "3521520"
  },
  {
    "text": "you very much",
    "start": "3521520",
    "end": "3523880"
  }
]