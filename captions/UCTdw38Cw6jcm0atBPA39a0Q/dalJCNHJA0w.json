[
  {
    "text": "um yeah so I'm Arno um I'm always amazed how beautiful a country in Norway is whenever I come here I am from think",
    "start": "2280",
    "end": "10160"
  },
  {
    "text": "cell we are in Berlin uh I'm the the technical guy there and well one of the",
    "start": "10160",
    "end": "15360"
  },
  {
    "text": "technical guys the head technical guy um I'll be talking about iterators",
    "start": "15360",
    "end": "20480"
  },
  {
    "text": "iterators have been with us since the Stone Age of C++ and there is still conceptually",
    "start": "20480",
    "end": "28199"
  },
  {
    "text": "something weird about them and I'll tell you what that is originally of course they were modeled after pointers so",
    "start": "28199",
    "end": "35000"
  },
  {
    "text": "people were doing C and C had arrays and they had pointers and and they would point at objects and they just",
    "start": "35000",
    "end": "40760"
  },
  {
    "text": "transferred that to Modern C++ with data structures and they said well we now have something like pointers but we call",
    "start": "40760",
    "end": "46800"
  },
  {
    "text": "them iterators because they're not all just pointers now iterators can be elements",
    "start": "46800",
    "end": "54920"
  },
  {
    "text": "right so if you have Vector here 3 2 13 and you calculate the minimum element of",
    "start": "54920",
    "end": "60120"
  },
  {
    "text": "this Vector you get an iterator back and it's pretty clear that that iterator",
    "start": "60120",
    "end": "66040"
  },
  {
    "text": "means an element it points to this element it means an element semantically",
    "start": "66040",
    "end": "71080"
  },
  {
    "text": "it's pointing at the one but it can also mean borders between",
    "start": "71080",
    "end": "76119"
  },
  {
    "text": "elements so if you have an upper bound of a vector 0 011 then and you calculate you you the",
    "start": "76119",
    "end": "84640"
  },
  {
    "text": "the upper bound of zero you also get a pointer to this or an iterator to this one but in this case really what it",
    "start": "84640",
    "end": "91640"
  },
  {
    "text": "semantically means is the border between the zeros and the ones it separates these",
    "start": "91640",
    "end": "97280"
  },
  {
    "text": "two now we have ranges um and ranges are really anything that has iterators at",
    "start": "97280",
    "end": "102960"
  },
  {
    "text": "least according to the standard so you can write for Loops um ranges come in",
    "start": "102960",
    "end": "111399"
  },
  {
    "text": "two distinct flavors one are containers containers own their elements they have",
    "start": "111399",
    "end": "117439"
  },
  {
    "text": "deep copying semantics usually takes then or of n to copy uh and they have deep constness so if the if the",
    "start": "117439",
    "end": "123560"
  },
  {
    "text": "container is const you can't mutate the elements and there are also views views",
    "start": "123560",
    "end": "129360"
  },
  {
    "text": "are kind of references to Containers or to other views they reference their",
    "start": "129360",
    "end": "135160"
  },
  {
    "text": "elements they have shallow copying so you can usually copy an O of one and they have shallow constness if the view",
    "start": "135160",
    "end": "141480"
  },
  {
    "text": "is Con that doesn't mean that that directly um has any effect on the elements quite similar to iterators",
    "start": "141480",
    "end": "148120"
  },
  {
    "text": "where you have a iterator that is itself cons it may still mutate whatever it is pointing to or pointers behave the same",
    "start": "148120",
    "end": "155599"
  },
  {
    "text": "way now here is the prototypical view it's essentially just a pair of",
    "start": "155599",
    "end": "161200"
  },
  {
    "text": "iterators that puts these two iterators together and offers a beginning and end",
    "start": "161200",
    "end": "167640"
  },
  {
    "text": "that just passes out these iterators now what does that allow you to do well with iterators things kind of get a little",
    "start": "167640",
    "end": "174159"
  },
  {
    "text": "bit wordy because quite frequently you're passing in these pairs of begin and end um and with ranges you can do",
    "start": "174159",
    "end": "181480"
  },
  {
    "text": "this quite a bit more succinctly so you don't have to mention begin and end quite as much now the last",
    "start": "181480",
    "end": "189599"
  },
  {
    "text": "thing here that one is uh we can still eliminate even more um because what",
    "start": "189599",
    "end": "197120"
  },
  {
    "text": "we're really doing is we're eliminating duplicates and um I want to ask you",
    "start": "197120",
    "end": "204959"
  },
  {
    "text": "there is something wrong with these two lines subtly conceptually what is",
    "start": "204959",
    "end": "212360"
  },
  {
    "text": "it imagine you have",
    "start": "213400",
    "end": "217159"
  },
  {
    "text": "yeah no so you are your range unique the the range unique will give you something",
    "start": "220480",
    "end": "226560"
  },
  {
    "text": "back that is iterators into the original sequence so they are going to be",
    "start": "226560",
    "end": "231599"
  },
  {
    "text": "compatible that's going to be",
    "start": "231599",
    "end": "235280"
  },
  {
    "text": "okay uh maybe it should be end end um maybe it should be end and end",
    "start": "237439",
    "end": "244120"
  },
  {
    "text": "well you no one ever pointed this out having this talk for quite a while but yes probably it should be",
    "start": "244120",
    "end": "249879"
  },
  {
    "text": "internet um something else even",
    "start": "249879",
    "end": "256078"
  },
  {
    "text": "more but the",
    "start": "256160",
    "end": "259560"
  },
  {
    "text": "comparators sort sorts by less unique removes by equal",
    "start": "262759",
    "end": "270280"
  },
  {
    "text": "if these don't two don't agree this code is wrong so it's really",
    "start": "270280",
    "end": "276840"
  },
  {
    "text": "you whenever you writing this you that's that's why have we have this in our library and I'll give you the Earl at",
    "start": "276840",
    "end": "282240"
  },
  {
    "text": "the end you you really want to write this if you if you want to have some sort of abstraction in your in your code",
    "start": "282240",
    "end": "288479"
  },
  {
    "text": "because you have to make sure that the predicate that's used here is the same predicate that's then later used for the",
    "start": "288479",
    "end": "294880"
  },
  {
    "text": "for the unique otherwise it doesn't work right you first need to S sort then",
    "start": "294880",
    "end": "300039"
  },
  {
    "text": "you you need to unique and and yeah you have to turn around the less predicate but it it's okay but you should still",
    "start": "300039",
    "end": "306600"
  },
  {
    "text": "use the less um okay then there are other views",
    "start": "306600",
    "end": "311720"
  },
  {
    "text": "range adapters um when you are writing without range adapters you you want to",
    "start": "311720",
    "end": "317039"
  },
  {
    "text": "find a particular value you use use just range as find um and it returns an",
    "start": "317039",
    "end": "322280"
  },
  {
    "text": "iterator of the to the first element now let's say we want to do something very similar we have now a pair not of",
    "start": "322280",
    "end": "328840"
  },
  {
    "text": "numbers but we have we have a pair not of not just a single number but we have a pair of a number and a character and",
    "start": "328840",
    "end": "335199"
  },
  {
    "text": "we want to still search the zero but in that case in the first part of that",
    "start": "335199",
    "end": "340319"
  },
  {
    "text": "pair um and if you do that the syntax as you can see is very very different you",
    "start": "340319",
    "end": "347600"
  },
  {
    "text": "suddenly need to use range if you can't use range anymore um and and your zero",
    "start": "347600",
    "end": "353199"
  },
  {
    "text": "is also completely elsewhere somewhere in the predicate now that's kind of ugly right so the the the problem is that the",
    "start": "353199",
    "end": "361319"
  },
  {
    "text": "projection where we basically turn the pair into its first element and then the",
    "start": "361319",
    "end": "367199"
  },
  {
    "text": "actual search the comparison is lump together is lump together in this predicate here and while here there's",
    "start": "367199",
    "end": "373520"
  },
  {
    "text": "essentially just this this find implies that comparison and it's but it's operating only on that on that number it",
    "start": "373520",
    "end": "380199"
  },
  {
    "text": "doesn't can operate on the first so what do we do enter the transform adapter we",
    "start": "380199",
    "end": "385960"
  },
  {
    "text": "separate these two we first just say okay the vector gets transformed into a",
    "start": "385960",
    "end": "392000"
  },
  {
    "text": "sequence of numbers and it's happening lazily who's using ranges and Views and",
    "start": "392000",
    "end": "398880"
  },
  {
    "text": "stuff on the daily basis basically still surprisingly few I would",
    "start": "398880",
    "end": "404560"
  },
  {
    "text": "say if you I'm assuming you're all doing C++ so these ranges are very very useful I mean for us it's like great",
    "start": "404560",
    "end": "411240"
  },
  {
    "text": "abstraction it it greatly simplifies the readability improves the readability of the code I would highly recommend using",
    "start": "411240",
    "end": "417680"
  },
  {
    "text": "them um so here you are turning the vector into a sequence of numbers and",
    "start": "417680",
    "end": "423080"
  },
  {
    "text": "then you find in that sequence of numbers your zero now you don't pay pretty much",
    "start": "423080",
    "end": "430400"
  },
  {
    "text": "anything because this is all lazy right this is this doesn't do anything just puts together a little little object it",
    "start": "430400",
    "end": "435599"
  },
  {
    "text": "doesn't doesn't copy anything it just it just um references uh the views transform so you only pay for what you",
    "start": "435599",
    "end": "442240"
  },
  {
    "text": "der reference and you don't allocate anything on the heat",
    "start": "442240",
    "end": "447919"
  },
  {
    "text": "now if you do this is um you say find if that's the old syntax you have your",
    "start": "447919",
    "end": "454440"
  },
  {
    "text": "predicate and then you call second on it of course you get the corresponding element you get an A now what if happens",
    "start": "454440",
    "end": "461120"
  },
  {
    "text": "if you do the same thing with our new fangled transform well this doesn't quite work",
    "start": "461120",
    "end": "468440"
  },
  {
    "text": "because the iterator that you're getting back from the find fairly enough points to ins we are running it on a sequence",
    "start": "468440",
    "end": "475560"
  },
  {
    "text": "of numbers so you can't just call second on it because there's no second what we",
    "start": "475560",
    "end": "481039"
  },
  {
    "text": "need to do is kind of peel off this transform and the way you do this is",
    "start": "481039",
    "end": "486919"
  },
  {
    "text": "called base and then that iterator is basically transformed it's it's it's it's revealing its inner self which is",
    "start": "486919",
    "end": "494039"
  },
  {
    "text": "an iterator to these pairs and then on that inner self you can call second so",
    "start": "494039",
    "end": "499080"
  },
  {
    "text": "this is really what's happening you have a iterator here on the Zero it gets turned an iterator onto the pairs and",
    "start": "499080",
    "end": "504319"
  },
  {
    "text": "then the second one is taken okay um",
    "start": "504319",
    "end": "510599"
  },
  {
    "text": "rang is find Returns the iterator in role of an element so the base that you call must",
    "start": "510599",
    "end": "518200"
  },
  {
    "text": "preserve the identity of the element that you found otherwise you get a completely different element that that's",
    "start": "518200",
    "end": "525240"
  },
  {
    "text": "not helpful now if you for example run ranges upper bound on a similarly",
    "start": "525240",
    "end": "531240"
  },
  {
    "text": "transformed range then there is also a base call and this base call has to",
    "start": "531240",
    "end": "537760"
  },
  {
    "text": "preserve the identity of the border because remember upper bound semantically gives you a border so so",
    "start": "537760",
    "end": "543800"
  },
  {
    "text": "the death base has to preserve the the identity of this border which it does so here this is the base the iterator the",
    "start": "543800",
    "end": "550800"
  },
  {
    "text": "the the element stays the element and this element which really means this border gets transformed into that",
    "start": "550800",
    "end": "557160"
  },
  {
    "text": "element and again the the border is right before the element that the iterator is pointing to which is the",
    "start": "557160",
    "end": "562720"
  },
  {
    "text": "semantics that the iterator has okay let's uh look at a filter",
    "start": "562720",
    "end": "568079"
  },
  {
    "text": "adapter that's kind of the second frequently used adapter um it just well it does what the",
    "start": "568079",
    "end": "576360"
  },
  {
    "text": "name says it filters out certain elements from its range so you have the filter um and if you filter here by",
    "start": "576360",
    "end": "583519"
  },
  {
    "text": "second should be B then you only get the two B elements now let's transform this again",
    "start": "583519",
    "end": "589240"
  },
  {
    "text": "so you have a transform of a filter um and which again projects the",
    "start": "589240",
    "end": "596480"
  },
  {
    "text": "uh the result onto the uh the uh the B so you got zero and one and then you",
    "start": "596480",
    "end": "603200"
  },
  {
    "text": "again we run find so now we have this stack we first have an iterator pointing to a zero then we do dot base and is now",
    "start": "603200",
    "end": "612360"
  },
  {
    "text": "pointing to the zero B we unwrapped the transform and now we unwrap the filter",
    "start": "612360",
    "end": "617440"
  },
  {
    "text": "and then it's pointing to z b in in the in the complete range now range is find",
    "start": "617440",
    "end": "623760"
  },
  {
    "text": "again is an iterator in the role of an element and that element this zero here came from the that z b now that's",
    "start": "623760",
    "end": "631720"
  },
  {
    "text": "different than running the initial find on the whole sequence than we would have found that guy but that's okay because",
    "start": "631720",
    "end": "638600"
  },
  {
    "text": "that's the semantics of the filter it it just gives you this iterator back which has to be so that that identity is",
    "start": "638600",
    "end": "644320"
  },
  {
    "text": "preserved is is is correct it's fine now let's do the same thing but for",
    "start": "644320",
    "end": "652480"
  },
  {
    "text": "upper bound we have a we again transform then calculate the upper bound now we",
    "start": "652480",
    "end": "657880"
  },
  {
    "text": "have an iterator that's pointing here it's pointing now to the filter to",
    "start": "657880",
    "end": "664120"
  },
  {
    "text": "the to the unfiltered ver to the untransformed version and then it will go to the original Vector now we had a",
    "start": "664120",
    "end": "671880"
  },
  {
    "text": "the the meaning here was a border between these two elements and now the meaning of this",
    "start": "671880",
    "end": "678360"
  },
  {
    "text": "iterator here is a border between these two elements is that",
    "start": "678360",
    "end": "684240"
  },
  {
    "text": "okay not really because",
    "start": "684240",
    "end": "689600"
  },
  {
    "text": "this element it's not really clear if you have a filter sequence and you determine any sort of boundary in that",
    "start": "689600",
    "end": "695200"
  },
  {
    "text": "filter sequence you say this goes in this on this side and that goes on that side suddenly the the undoing of the",
    "start": "695200",
    "end": "700839"
  },
  {
    "text": "filter adds elements and you don't really know which side they should go so",
    "start": "700839",
    "end": "706560"
  },
  {
    "text": "this is really not well defined if you write this in a program it would probably be",
    "start": "706560",
    "end": "713079"
  },
  {
    "text": "wrong now you could say well don't don't do this right you have to understand",
    "start": "713079",
    "end": "718639"
  },
  {
    "text": "that that doesn't work work okay let's keep going let's look at the reverse",
    "start": "718639",
    "end": "725839"
  },
  {
    "text": "adapter again we turn around the elements lazily and we play the same game we run",
    "start": "725839",
    "end": "735079"
  },
  {
    "text": "transform of the reverse find now we have that element",
    "start": "735079",
    "end": "740959"
  },
  {
    "text": "and then we peel off basically the the the again the transform so the z b",
    "start": "740959",
    "end": "746720"
  },
  {
    "text": "should probably point at that guy because this this is the corresponding z b and when you turn it around that's",
    "start": "746720",
    "end": "752920"
  },
  {
    "text": "still the z b and the iterator should point at this at this guy so we have it right for",
    "start": "752920",
    "end": "758320"
  },
  {
    "text": "elements okay now let's try for lower",
    "start": "758320",
    "end": "763440"
  },
  {
    "text": "bound so in this case we have again the same iterator we",
    "start": "763440",
    "end": "769800"
  },
  {
    "text": "get the same iterator back that we got for find it's not pointing here which means this border not pointing there",
    "start": "769800",
    "end": "775600"
  },
  {
    "text": "this border and it's still pointing there oops the Border should be over",
    "start": "775600",
    "end": "781760"
  },
  {
    "text": "here because we separated the ones from the zeros when we undo the reverse it",
    "start": "781760",
    "end": "787360"
  },
  {
    "text": "should separate the zeros from the ones now this should be the outcome of the",
    "start": "787360",
    "end": "792839"
  },
  {
    "text": "base call we should have turned the iterator into a different iterator based",
    "start": "792839",
    "end": "798040"
  },
  {
    "text": "on how we got this iterator originally but that information is gone at this point we don't really know",
    "start": "798040",
    "end": "805360"
  },
  {
    "text": "anymore H so we would need kind of two different bases but we only have",
    "start": "805360",
    "end": "811160"
  },
  {
    "text": "one so before we look at how we solve this",
    "start": "811160",
    "end": "816720"
  },
  {
    "text": "problem let's see how the reverse why the reverse adapter has this problem how",
    "start": "816720",
    "end": "822040"
  },
  {
    "text": "does this come about and we look at the implementation of the reverse adapter it has a base iterator it has an increment",
    "start": "822040",
    "end": "829440"
  },
  {
    "text": "that really does a decrement and an decrement that really does an increment so far so easy and the beginning and end",
    "start": "829440",
    "end": "835920"
  },
  {
    "text": "is end and begin okay that's pretty clear but the iterator at begin of the reverse",
    "start": "835920",
    "end": "845000"
  },
  {
    "text": "stores the base end when you dreference that iterator you don't want to",
    "start": "845000",
    "end": "851320"
  },
  {
    "text": "dreference end you cannot D reference End you have to go one before that so you have to calculate base n minus one",
    "start": "851320",
    "end": "857560"
  },
  {
    "text": "and der reference that okay now the same thing at end the",
    "start": "857560",
    "end": "863360"
  },
  {
    "text": "end stores begin and now we say oh when we do reference we decrement by one it's like",
    "start": "863360",
    "end": "869920"
  },
  {
    "text": "oh we have we iterated at at begin and then we decrement by one but no the end will never be referenced so we don't",
    "start": "869920",
    "end": "875759"
  },
  {
    "text": "have any problem so here if the iterator is to end minus",
    "start": "875759",
    "end": "883440"
  },
  {
    "text": "one then we are exactly the it's the the the begin plus one is then stored",
    "start": "883440",
    "end": "888920"
  },
  {
    "text": "internally and then we subtract one again and we get begin and that's exactly right so this is already the",
    "start": "888920",
    "end": "894759"
  },
  {
    "text": "reference this is already the reference we need to implement the reference with decrementing by one",
    "start": "894759",
    "end": "899800"
  },
  {
    "text": "H so here I did it so if we call Base because the",
    "start": "899800",
    "end": "906600"
  },
  {
    "text": "iterator is is the the the the um the de referencing der references iterator",
    "start": "906600",
    "end": "912959"
  },
  {
    "text": "minus one so this is the base this is the base for the element it",
    "start": "912959",
    "end": "920199"
  },
  {
    "text": "has to do 8 minus one because that's what we do reference but the border is still it begin has to map to end and end",
    "start": "920199",
    "end": "927639"
  },
  {
    "text": "has to map to begin so there there's no decrement and this creates that discrepancy by",
    "start": "927639",
    "end": "934680"
  },
  {
    "text": "one okay so what is the if we now look bigger what is the scope of this problem",
    "start": "934800",
    "end": "941440"
  },
  {
    "text": "we now saw it with reverse let's see where else that problem May lur now if",
    "start": "941440",
    "end": "947959"
  },
  {
    "text": "an adapter changes the order of elements you could have a crazy adapter like sorts or does something then the base of",
    "start": "947959",
    "end": "955720"
  },
  {
    "text": "elements is always going to be well defined we have a corresponding element in the base range but we don't have a",
    "start": "955720",
    "end": "961399"
  },
  {
    "text": "border in general because we jumbled these these these elements around so the border is is a meaningless Concept in",
    "start": "961399",
    "end": "967959"
  },
  {
    "text": "this case going from you you can't map one border to another border if you for example had a sword",
    "start": "967959",
    "end": "974199"
  },
  {
    "text": "adapter the reverse adapter is special because everything changes size you turn everything around then the base of the",
    "start": "974199",
    "end": "980720"
  },
  {
    "text": "border is well defined but it's different from the base of the element now let's say we remove",
    "start": "980720",
    "end": "989360"
  },
  {
    "text": "elements we already had this with the filter then these elements May",
    "start": "989360",
    "end": "995319"
  },
  {
    "text": "collapse and then the base of the element is still well defined whatever we have in the filter we can always find",
    "start": "995319",
    "end": "1001319"
  },
  {
    "text": "the original element back but we can't do this for the Border it's ambiguous we already saw that with a filter so that",
    "start": "1001319",
    "end": "1007040"
  },
  {
    "text": "is for filter sorted intersection sorted difference there may also be an adapter that adds elements now interestingly",
    "start": "1007040",
    "end": "1014560"
  },
  {
    "text": "here it's exactly the other way around if you have a border in the original one and added elements got added then there",
    "start": "1014560",
    "end": "1022519"
  },
  {
    "text": "is still a corresponding Border in the original sequence because you can just remove all these elements in between the",
    "start": "1022519",
    "end": "1028360"
  },
  {
    "text": "border is still a border but for elements that's not true because we added elements you may be pointing at an element that just got added so in this",
    "start": "1028360",
    "end": "1035438"
  },
  {
    "text": "case the base of borders is well defined the base of elements is",
    "start": "1035439",
    "end": "1040520"
  },
  {
    "text": "not okay so what do we do about this",
    "start": "1040520",
    "end": "1045600"
  },
  {
    "text": "problem the least we have to do is we have to separate functions border base",
    "start": "1045600",
    "end": "1051000"
  },
  {
    "text": "and Border element these can't be the same functions we need to be able to say",
    "start": "1051000",
    "end": "1057080"
  },
  {
    "text": "what kind of Base do I want do I want a border base or element base It's a Small Change uh but there's no safety against",
    "start": "1057080",
    "end": "1064160"
  },
  {
    "text": "the wrong choice what that you could make",
    "start": "1064160",
    "end": "1069919"
  },
  {
    "text": "now we can also go one step further and say is the concept of an iterator really",
    "start": "1069919",
    "end": "1077559"
  },
  {
    "text": "what we have in our head and I would claim no I would say there are either elements or they borders and in the",
    "start": "1077559",
    "end": "1084480"
  },
  {
    "text": "program we should say whether they are Borders or there elements what do we mean and then we can just call base if",
    "start": "1084480",
    "end": "1091760"
  },
  {
    "text": "these two things have two different types base would always do the right thing now the question is do iterators",
    "start": "1091760",
    "end": "1099960"
  },
  {
    "text": "really have assigned roles of border and element can we tell can we look at our code and say this iterator is a border",
    "start": "1099960",
    "end": "1106679"
  },
  {
    "text": "this iterator is an element can you do this well luckily we had 1 million lines of Cloe lying around and we just took a",
    "start": "1106679",
    "end": "1114000"
  },
  {
    "text": "look and we classified each one of them into either border or",
    "start": "1114000",
    "end": "1119200"
  },
  {
    "text": "element so let's see we did a find we we we checked for",
    "start": "1119200",
    "end": "1125159"
  },
  {
    "text": "find and find produces we had we had",
    "start": "1125159",
    "end": "1130559"
  },
  {
    "text": "almost 300 finds 200 of them actually interestingly enough that's this",
    "start": "1130559",
    "end": "1136520"
  },
  {
    "text": "classification we also did they were only looking for a single match we didn't we not really interested in in",
    "start": "1136520",
    "end": "1142960"
  },
  {
    "text": "multiple matches we we we knew that there would only be one thing to find so it's not like we found the first one we",
    "start": "1142960",
    "end": "1149159"
  },
  {
    "text": "found the only one 2011 times one actually had a border role so this you",
    "start": "1149159",
    "end": "1155520"
  },
  {
    "text": "could call a trim really you found something which it's really the reverse",
    "start": "1155520",
    "end": "1160559"
  },
  {
    "text": "is is true where you you have a certain prefix that does not fulfill your role and you want to cut it off so that that",
    "start": "1160559",
    "end": "1166880"
  },
  {
    "text": "that's really more like a a trim now there was also one other case where you got the Border afterwards so you",
    "start": "1166880",
    "end": "1174919"
  },
  {
    "text": "actually were finding an element you wanted to get the Border after that one that is essentially Trimm from behind",
    "start": "1174919",
    "end": "1180559"
  },
  {
    "text": "all the other men's had element roll 98 times we wanted the first snatch seven",
    "start": "1180559",
    "end": "1185960"
  },
  {
    "text": "of them border roll five the Border after everyone else element",
    "start": "1185960",
    "end": "1192200"
  },
  {
    "text": "roll now find if similar story 67 single ones all element roll borders are in",
    "start": "1192200",
    "end": "1199600"
  },
  {
    "text": "vast major minority uh 75 times first match three of them border everything",
    "start": "1199600",
    "end": "1205000"
  },
  {
    "text": "else element lower bound",
    "start": "1205000",
    "end": "1211000"
  },
  {
    "text": "um the first two times twice we had no further use of the predicate so this was",
    "start": "1211000",
    "end": "1217919"
  },
  {
    "text": "clearly a border but 89 times actually the",
    "start": "1217919",
    "end": "1224240"
  },
  {
    "text": "predicate that we stuck into the lower bound was used afterwards on that element to check whether that element is",
    "start": "1224240",
    "end": "1231679"
  },
  {
    "text": "really the one that we want to look at this is really a binary search that we did we found an element we did not find",
    "start": "1231679",
    "end": "1238679"
  },
  {
    "text": "a border we found an element um and 19 times that was",
    "start": "1238679",
    "end": "1244240"
  },
  {
    "text": "actually also the first match so that was basically a range of items we wanted to",
    "start": "1244240",
    "end": "1250400"
  },
  {
    "text": "find upper bound similar interestingly you're never interested in the element",
    "start": "1250400",
    "end": "1255480"
  },
  {
    "text": "at the upper bound because that's basically outside of you know lower bound upper bound is the equal range and",
    "start": "1255480",
    "end": "1261600"
  },
  {
    "text": "you always want to find something inside the equal range outside of the equal range not that interesting so um it was either border",
    "start": "1261600",
    "end": "1269360"
  },
  {
    "text": "or it was an the element inside the equal range so I would say iterator instances have these distinct roles",
    "start": "1269360",
    "end": "1275640"
  },
  {
    "text": "we've seen this in our code base they empirically it's true um",
    "start": "1275640",
    "end": "1281279"
  },
  {
    "text": "and iterators were always ugly I mean how many C++ books have shown you this",
    "start": "1281279",
    "end": "1288159"
  },
  {
    "text": "picture where there's begin and then there was this ugly end going like like fell off the range it's like so ugly that make it",
    "start": "1288159",
    "end": "1295760"
  },
  {
    "text": "nice and symmetric you have borders and you have elements there's no element up here there just a border right there now",
    "start": "1295760",
    "end": "1302720"
  },
  {
    "text": "everything is nice and symmetric now um there's another problem or",
    "start": "1302720",
    "end": "1309520"
  },
  {
    "text": "another pet peeve of mine that I always have to the find gives me end why does",
    "start": "1309520",
    "end": "1316080"
  },
  {
    "text": "it give me end when something's not been found it's it should be Singleton right like",
    "start": "1316080",
    "end": "1323200"
  },
  {
    "text": "optional so um because otherwise we have to mention this range twice which is",
    "start": "1323200",
    "end": "1329039"
  },
  {
    "text": "particularly ugly because now we have all these range adapters they we we produce Expressions much more than than",
    "start": "1329039",
    "end": "1335760"
  },
  {
    "text": "you know writing giving things names we just have expressions and you don't want to mention things twice so why can't I",
    "start": "1335760",
    "end": "1342400"
  },
  {
    "text": "write this okay you just have an iterator and it it's nullable so it's",
    "start": "1342400",
    "end": "1348240"
  },
  {
    "text": "you can check you can do a explicit cast Bo on it and and then it will tell you",
    "start": "1348240",
    "end": "1354400"
  },
  {
    "text": "am I pointing something or I'm not pointing something and not to point something and um is is a pretty clear",
    "start": "1354400",
    "end": "1359919"
  },
  {
    "text": "concept if you're talking about elements either you're pointing at an element or you're not pointing at an element so why why not make it simple um the border is",
    "start": "1359919",
    "end": "1368360"
  },
  {
    "text": "again like an iterator but you can't reference it what does that mean you can't reference a border um it has an",
    "start": "1368360",
    "end": "1375440"
  },
  {
    "text": "element before an element after and you have to decide you want the one before or the one",
    "start": "1375440",
    "end": "1381278"
  },
  {
    "text": "after uh clearly begin and end are borders right because we are talking about the eliminations of the",
    "start": "1381400",
    "end": "1388640"
  },
  {
    "text": "range um and also all the algor all the iterators that go into algorithms are",
    "start": "1388640",
    "end": "1394480"
  },
  {
    "text": "infect borders it's always this begin end pair so it's all here it starts here it",
    "start": "1394480",
    "end": "1400080"
  },
  {
    "text": "ends um an output iterator little bit old school but output iterators are conceptually borders because you are",
    "start": "1400080",
    "end": "1407000"
  },
  {
    "text": "really eliminating what delineating what is the end of your current range and then you just add on to",
    "start": "1407000",
    "end": "1415000"
  },
  {
    "text": "that um now for the iterators that are returned from algorithm it depends on",
    "start": "1415000",
    "end": "1421000"
  },
  {
    "text": "the algorithm here are the algorithms that return borders mism search lower",
    "start": "1421000",
    "end": "1427400"
  },
  {
    "text": "bound upper bound equal range partion point unique um now let's look at the element",
    "start": "1427400",
    "end": "1435200"
  },
  {
    "text": "concept elements are like iterators but they never end and you cannot plus plus",
    "start": "1435200",
    "end": "1440960"
  },
  {
    "text": "beyond the last element you you shouldn't and you can now go from the element to the border before or the",
    "start": "1440960",
    "end": "1447679"
  },
  {
    "text": "Border after and we have find if and Max Min element these are the two algorithms",
    "start": "1447679",
    "end": "1452799"
  },
  {
    "text": "that I found that are clearly returning elements and maybe we need a range of elements so that you can when you do a",
    "start": "1452799",
    "end": "1459240"
  },
  {
    "text": "for each you can actually get the elements if you don't want to get",
    "start": "1459240",
    "end": "1465039"
  },
  {
    "text": "borders um we should also make make the elements nullable so that that if looks",
    "start": "1465520",
    "end": "1471480"
  },
  {
    "text": "nice um would be compatible with pointers so pointers are clearly",
    "start": "1471480",
    "end": "1476520"
  },
  {
    "text": "elements um and so we make them convertible to Bull and the N state is is reached",
    "start": "1476520",
    "end": "1484080"
  },
  {
    "text": "through through value initialization so you can just default value initialize them and you get a null um and any",
    "start": "1484080",
    "end": "1491880"
  },
  {
    "text": "functions that return an element should we really return a null instead of end so we can do the if",
    "start": "1491880",
    "end": "1499320"
  },
  {
    "text": "now if we already go there we can go one step further we can say the find if I",
    "start": "1499320",
    "end": "1506440"
  },
  {
    "text": "classifi it into do we want a first the first element that satisfies the predicate or do we want the only one",
    "start": "1506440",
    "end": "1513399"
  },
  {
    "text": "that satisfies the predicate of course the code in optimized code is the same",
    "start": "1513399",
    "end": "1518600"
  },
  {
    "text": "but still when you read the code it is very interesting to know whether there are more elements or whether the",
    "start": "1518600",
    "end": "1524279"
  },
  {
    "text": "programmer expects that element to be the only one and of course in De bug you can just put in check code that verifies",
    "start": "1524279",
    "end": "1531440"
  },
  {
    "text": "that that's actually the case so it's a valuable information to have and and at think cell we we have this throughout",
    "start": "1531440",
    "end": "1536880"
  },
  {
    "text": "the code base you always have to say what do you want do you want a unique unique match or do you want the first",
    "start": "1536880",
    "end": "1541919"
  },
  {
    "text": "match um and we can also introduce a trim left trim right that where turns",
    "start": "1541919",
    "end": "1547440"
  },
  {
    "text": "borders so you can you can you can also they say where what do you want you want",
    "start": "1547440",
    "end": "1552720"
  },
  {
    "text": "do you want uh do you want elements or do you want borders now lower bound should really",
    "start": "1552720",
    "end": "1557880"
  },
  {
    "text": "get about of companions for doing binary find because binary find is such a",
    "start": "1557880",
    "end": "1563360"
  },
  {
    "text": "frequent operation that it really should be a single function call uh and and now",
    "start": "1563360",
    "end": "1569399"
  },
  {
    "text": "we have the null so it's very easy to find out whether you found something in your binary search and and again you",
    "start": "1569399",
    "end": "1575960"
  },
  {
    "text": "have the unique you have the first and the last um variants of",
    "start": "1575960",
    "end": "1581840"
  },
  {
    "text": "that and yeah remember you're never stuck with elements you can always use border before border after to convert",
    "start": "1581840",
    "end": "1589200"
  },
  {
    "text": "and the unique functions assert now the idea is of course to as I said",
    "start": "1589200",
    "end": "1597679"
  },
  {
    "text": "for this for this nullable iterators the idea is to mention range only",
    "start": "1597679",
    "end": "1602799"
  },
  {
    "text": "once and we can one case where we actually would",
    "start": "1602799",
    "end": "1608200"
  },
  {
    "text": "need to range need to mention the range more times is if you want to use the",
    "start": "1608200",
    "end": "1614200"
  },
  {
    "text": "border that you got for example to cut off a part of the original range so you really want the prefix of the range up",
    "start": "1614200",
    "end": "1621240"
  },
  {
    "text": "to your border or you want the suffix from that border to the end and it would be nice if you could",
    "start": "1621240",
    "end": "1628320"
  },
  {
    "text": "just tell the algorithm not to give you an iterator back but the prefix or the suffix well why not do that so here it",
    "start": "1628320",
    "end": "1635880"
  },
  {
    "text": "is you have a lower bound and you can specify I want the Border back and you get a border back you can say well I",
    "start": "1635880",
    "end": "1642799"
  },
  {
    "text": "want the prefix return take and then you get the prefix or return drop then you",
    "start": "1642799",
    "end": "1648039"
  },
  {
    "text": "get the suffix um if you are getting if you want",
    "start": "1648039",
    "end": "1653960"
  },
  {
    "text": "actually the elements you could also specify that you get a border so you can directly say don't give me the Border",
    "start": "1653960",
    "end": "1659000"
  },
  {
    "text": "give me the element before or give me the element after",
    "start": "1659000",
    "end": "1664039"
  },
  {
    "text": "now here is the whole the whole zoo of things uh for algorithms returning",
    "start": "1664039",
    "end": "1670080"
  },
  {
    "text": "elements um there's actually one missing which we have also which is return bu",
    "start": "1670080",
    "end": "1677760"
  },
  {
    "text": "tell me if you found something that's quite frequent in binary search it's not you're not even interested in the element you just want to see what it's",
    "start": "1677760",
    "end": "1683919"
  },
  {
    "text": "there so you could say that that's that's another one um you can you can",
    "start": "1683919",
    "end": "1689600"
  },
  {
    "text": "say I want my element or I want to my I I want my element or nothing or I just",
    "start": "1689600",
    "end": "1696519"
  },
  {
    "text": "want the element that means I'm not expecting a null here you very very",
    "start": "1696519",
    "end": "1701679"
  },
  {
    "text": "frequently you would write assert blah blah blah not end right because you're not well you expect it's it's not end",
    "start": "1701679",
    "end": "1709159"
  },
  {
    "text": "it's it's it's being found well why not write that in your function call you just annotate your function",
    "start": "1709159",
    "end": "1714760"
  },
  {
    "text": "call um and here again for you to do get",
    "start": "1714760",
    "end": "1719799"
  },
  {
    "text": "the adjacent borders um in case they're not there which you know which uh does",
    "start": "1719799",
    "end": "1725600"
  },
  {
    "text": "it happen yeah it does happen if you don't find anything right then you have to pick a border do you want the the",
    "start": "1725600",
    "end": "1731960"
  },
  {
    "text": "begin or the end so you you found you didn't find the element what's the alternative um and here is similar for",
    "start": "1731960",
    "end": "1740120"
  },
  {
    "text": "for for basically suffixes and prefixes we could also say well if either the element and I want the element anything",
    "start": "1740120",
    "end": "1747399"
  },
  {
    "text": "that goes up to the element not including the element or including the element again suffix or prefix or you",
    "start": "1747399",
    "end": "1753559"
  },
  {
    "text": "can say well if you don't find it what do you want do you want an empty range or do you want everything are the",
    "start": "1753559",
    "end": "1759559"
  },
  {
    "text": "typically the two choices you have um this is how these specifications are actually implemented we have these",
    "start": "1759559",
    "end": "1766440"
  },
  {
    "text": "little structs and they are essentially saying well what happens if I found an element how",
    "start": "1766440",
    "end": "1773000"
  },
  {
    "text": "can I pack it how can you how do you want me to package this thing and you can specify for example by calling TC",
    "start": "1773000",
    "end": "1779240"
  },
  {
    "text": "take or when you don't have an element you just take for example from the begin",
    "start": "1779240",
    "end": "1786000"
  },
  {
    "text": "and then it's it's type compatible with with the out in the output so you can",
    "start": "1786000",
    "end": "1791159"
  },
  {
    "text": "get a single type but that would then mean well you're you you take everything up to begin which is empty so this",
    "start": "1791159",
    "end": "1798640"
  },
  {
    "text": "that's why it's or empty all right uh that leads me to the end so iterators are modeled after",
    "start": "1798640",
    "end": "1806200"
  },
  {
    "text": "pointers they were in originally a quite a lowlevel machine concept or quite",
    "start": "1806200",
    "end": "1811720"
  },
  {
    "text": "derived from a lowlevel concept and I think we it would be good to have something that has stronger semantics",
    "start": "1811720",
    "end": "1817399"
  },
  {
    "text": "elements and borders and I think we already think in these terms we don't need to reintroduce them it's nothing",
    "start": "1817399",
    "end": "1822960"
  },
  {
    "text": "nothing fundamentally new but we don't have it in the language we can't express",
    "start": "1822960",
    "end": "1828080"
  },
  {
    "text": "what we already have in our head and arguably that's always bad and for some functions it's needed",
    "start": "1828080",
    "end": "1833840"
  },
  {
    "text": "for correctness that that base function um the things cell range Library implements lots of that so elements are",
    "start": "1833840",
    "end": "1841519"
  },
  {
    "text": "nullable we have algorithmic these refinements uh return specifications um",
    "start": "1841519",
    "end": "1846799"
  },
  {
    "text": "what we don't have have yet is you specify whether you want an element or a border but we don't have it to have a",
    "start": "1846799",
    "end": "1852720"
  },
  {
    "text": "distinct type yet um that's something that we still want to do but um yeah so",
    "start": "1852720",
    "end": "1858240"
  },
  {
    "text": "thank you very much uh and of course I wouldn't be here if you wouldn't be hiring um there's some Leets outside",
    "start": "1858240",
    "end": "1865440"
  },
  {
    "text": "thank you very",
    "start": "1865440",
    "end": "1867840"
  },
  {
    "text": "much and if there are any questions go ahead",
    "start": "1871399",
    "end": "1877399"
  }
]