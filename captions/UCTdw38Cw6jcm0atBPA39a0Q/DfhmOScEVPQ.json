[
  {
    "text": "all right well I know we've got the attendee part so I don't want to get started late and",
    "start": "7059",
    "end": "13370"
  },
  {
    "text": "I probably won't run long either but I'm",
    "start": "13370",
    "end": "21689"
  },
  {
    "text": "glad you guys came up here today we're gonna talk about pattern matching this is a feature in c-sharp 7 that I have",
    "start": "21689",
    "end": "27210"
  },
  {
    "text": "been excited about since long before it was ever actually in the language I'm an",
    "start": "27210",
    "end": "32460"
  },
  {
    "text": "f-sharp fan I wouldn't say I'm an f-sharp developer because when I hang out with",
    "start": "32460",
    "end": "37800"
  },
  {
    "text": "real-life sharp developers they're way better than me but from playing with pattern matching in F sharp I've always",
    "start": "37800",
    "end": "43110"
  },
  {
    "text": "wanted it in c-sharp and now we finally have it so we take some time today to",
    "start": "43110",
    "end": "48239"
  },
  {
    "text": "look at what it is and how cool it is and why you want to use it my name is",
    "start": "48239",
    "end": "54449"
  },
  {
    "text": "Eric Potter you can follow me on twitter at potter eric when i'm here in london i",
    "start": "54449",
    "end": "61080"
  },
  {
    "text": "get asked about my family quite a bit yes i am related to harry potter i got",
    "start": "61080",
    "end": "69270"
  },
  {
    "text": "to visit him and his wife Jenny it was a good time but weird stuff always happens",
    "start": "69270",
    "end": "74280"
  },
  {
    "text": "I was telling him about my pattern-matching talk but he doesn't care about c-sharp",
    "start": "74280",
    "end": "80010"
  },
  {
    "text": "he's a parcel mouth so he only ever wants to do Python",
    "start": "80010",
    "end": "84260"
  },
  {
    "text": "this is some code from the Roslyn",
    "start": "87710",
    "end": "93210"
  },
  {
    "text": "codebase actually so this runs in your c-sharp six compiler and it's c-sharp",
    "start": "93210",
    "end": "99479"
  },
  {
    "text": "six code and it's totally fine there's",
    "start": "99479",
    "end": "104700"
  },
  {
    "text": "nothing wrong with it other than it doesn't use pattern matching because we didn't have it then",
    "start": "104700",
    "end": "110119"
  },
  {
    "text": "but what we can do with pattern matching is say reduce EO and we can shrink it",
    "start": "110119",
    "end": "117300"
  },
  {
    "text": "down to this just looking at a quick side-by-side comparison you can see that",
    "start": "117300",
    "end": "123210"
  },
  {
    "text": "this is much cleaner much tercer code",
    "start": "123210",
    "end": "127700"
  },
  {
    "text": "here's another block of code this is from a different open source project and",
    "start": "129080",
    "end": "134519"
  },
  {
    "text": "don't worry about it I'll get into the details of this later I just want to show you why this is so cool but I can",
    "start": "134519",
    "end": "140610"
  },
  {
    "text": "take all of this code from c-sharp 6 and reduce it down to that in c-sharp 7 it's",
    "start": "140610",
    "end": "151140"
  },
  {
    "text": "pretty good so what is pattern matching",
    "start": "151140",
    "end": "156420"
  },
  {
    "text": "exactly if we think about it it is a",
    "start": "156420",
    "end": "162269"
  },
  {
    "text": "language construct that we've not had before when I talk about language constructs I could say things like we",
    "start": "162269",
    "end": "168299"
  },
  {
    "text": "have iteration constructs like while and for and selection constructs like if and",
    "start": "168299",
    "end": "175320"
  },
  {
    "text": "switch and since the beginning of c-sharp we've had these more powerful",
    "start": "175320",
    "end": "180359"
  },
  {
    "text": "structures or a more powerful structure for iteration in the for each loop and",
    "start": "180359",
    "end": "187440"
  },
  {
    "text": "we've never really had a more powerful selection statement until now this is",
    "start": "187440",
    "end": "192810"
  },
  {
    "text": "what pattern matching gives us in the same way that a for each loop doesn't",
    "start": "192810",
    "end": "199019"
  },
  {
    "text": "really give c-sharp developers anything that you couldn't do with a do-while loop pattern matching doesn't give us",
    "start": "199019",
    "end": "205290"
  },
  {
    "text": "anything that we simply couldn't do before but in the same way that I'm",
    "start": "205290",
    "end": "211170"
  },
  {
    "text": "guessing you guys use for each loops all the time pattern matching is one of those features that you'll start to use",
    "start": "211170",
    "end": "217290"
  },
  {
    "text": "a lot once you understand and understand how it can benefit your codebase to get a better idea of the",
    "start": "217290",
    "end": "227250"
  },
  {
    "text": "importance of this feature I wanted to step back just for a second and talk about some history and this goes back to",
    "start": "227250",
    "end": "232860"
  },
  {
    "text": "1972 where Dijkstra said that we have now seen three types of decomposition",
    "start": "232860",
    "end": "239490"
  },
  {
    "text": "and we could call them concatenation selection and repetition that's kind of hard to understand Uncle Bob is set it",
    "start": "239490",
    "end": "246210"
  },
  {
    "text": "more modern lis where he says once you strip away all the syntactic sugar our programming language has essentially",
    "start": "246210",
    "end": "251640"
  },
  {
    "text": "boiled down to three things sequence selection and iteration every construct",
    "start": "251640",
    "end": "256859"
  },
  {
    "text": "within these languages a combination of these so these are like the three",
    "start": "256860",
    "end": "262019"
  },
  {
    "text": "fundamental building blocks of any programming language you've ever seen and what pattern matching gives you is",
    "start": "262020",
    "end": "269010"
  },
  {
    "text": "an improvement in one of those three fundamental constructs so it is",
    "start": "269010",
    "end": "276270"
  },
  {
    "text": "simultaneously not something that you couldn't do before but something that really improves a language at a very",
    "start": "276270",
    "end": "282390"
  },
  {
    "text": "core level so let's look at some code",
    "start": "282390",
    "end": "289220"
  },
  {
    "text": "let's say that you are working on a WPF application and you need to be able to",
    "start": "289220",
    "end": "295460"
  },
  {
    "text": "reset all the controls on a given form user has entered some data for whatever",
    "start": "295460",
    "end": "302280"
  },
  {
    "text": "reason they don't like it you just want to set it back to back to the default State well what we can do is loop",
    "start": "302280",
    "end": "310260"
  },
  {
    "text": "through those controls and depending on the type of control we're gonna have",
    "start": "310260",
    "end": "315660"
  },
  {
    "text": "some different behavior so we can get the main grid children and just loop",
    "start": "315660",
    "end": "323010"
  },
  {
    "text": "through them and then check their types and given the type we will then cast it",
    "start": "323010",
    "end": "329340"
  },
  {
    "text": "from the control which is our iteration variable to the more specific type of",
    "start": "329340",
    "end": "335430"
  },
  {
    "text": "either textbox radio button or combo box but because we want to say is checked",
    "start": "335430",
    "end": "344210"
  },
  {
    "text": "can't it's not enough simply to know that the control is a radio box we have to keep it as a pickle button",
    "start": "344210",
    "end": "353479"
  },
  {
    "text": "nothing really wrong with this code but with pattern match you write it like",
    "start": "353479",
    "end": "359400"
  },
  {
    "text": "this there's a couple things going on",
    "start": "359400",
    "end": "365430"
  },
  {
    "text": "here that I want you to recognize the first is that we are switching on an object that is not either an int or a",
    "start": "365430",
    "end": "374699"
  },
  {
    "text": "string in c-sharp 6 switch statements only worked on things that could be",
    "start": "374699",
    "end": "380340"
  },
  {
    "text": "resolved to integers or strings now we can switch on anything and what we're",
    "start": "380340",
    "end": "387930"
  },
  {
    "text": "going to match on in this case is the type of that variable and it's going to",
    "start": "387930",
    "end": "393030"
  },
  {
    "text": "switch on the dynamic type so the static type of the variable named control is",
    "start": "393030",
    "end": "398750"
  },
  {
    "text": "control we want to know what the the dynamic type is what you know what's the",
    "start": "398750",
    "end": "405270"
  },
  {
    "text": "more specific type here this is called the type pattern where I'm actually",
    "start": "405270",
    "end": "410550"
  },
  {
    "text": "going to match on the type and so now I can say text box text box and if control",
    "start": "410550",
    "end": "420660"
  },
  {
    "text": "is a text box that variable we've populated and we'll be given that type",
    "start": "420660",
    "end": "428840"
  },
  {
    "text": "so we now have a text box variable whose type is text box or we would have a",
    "start": "428840",
    "end": "435300"
  },
  {
    "text": "radio button variable whose type is radio button and so I could say a radio button that is checked so there's no",
    "start": "435300",
    "end": "441270"
  },
  {
    "text": "need to have that additional cast in there so this cleans up our code quite a",
    "start": "441270",
    "end": "448620"
  },
  {
    "text": "bit the old way is on let's see my right",
    "start": "448620",
    "end": "453690"
  },
  {
    "text": "your left the new ways over here this code would be significantly shorter if it wasn't for the break statements we",
    "start": "453690",
    "end": "459300"
  },
  {
    "text": "have to have but you can see how this code is is cleaner and more readable",
    "start": "459300",
    "end": "466199"
  },
  {
    "text": "it's yeah",
    "start": "466199",
    "end": "469789"
  },
  {
    "text": "okay so you're asking about what if a control if we had a variable that",
    "start": "483059",
    "end": "489009"
  },
  {
    "text": "matched at two different levels in the heritance hierarchy that's a great question how about I promise you I'll answer it",
    "start": "489009",
    "end": "496089"
  },
  {
    "text": "in like 15 minutes no it is a very it's an important question and there are some interesting",
    "start": "496089",
    "end": "502180"
  },
  {
    "text": "ramifications which is why we'll circle back around to it so there's another new",
    "start": "502180",
    "end": "510699"
  },
  {
    "text": "language feature that we have that goes along with this this is another",
    "start": "510699",
    "end": "515828"
  },
  {
    "text": "variation of the pattern matching code we just looked at but if you've done any",
    "start": "515829",
    "end": "520839"
  },
  {
    "text": "WPF you know that a combo box could be editable or not and so we might need to",
    "start": "520839",
    "end": "526060"
  },
  {
    "text": "have different behaviors based on whether or not it's editable so we now",
    "start": "526060",
    "end": "532209"
  },
  {
    "text": "have this new when statement this one statement is called a guard and so what",
    "start": "532209",
    "end": "538660"
  },
  {
    "text": "I'm saying now with this line of code is I don't want to match simply when the type matches but I want to match when",
    "start": "538660",
    "end": "545620"
  },
  {
    "text": "the type matches and this other expression evaluates to true so I now",
    "start": "545620",
    "end": "552220"
  },
  {
    "text": "have two cases for combo box yeah so the",
    "start": "552220",
    "end": "561850"
  },
  {
    "text": "question was if it would match - which one would it match on yes so it's going",
    "start": "561850",
    "end": "568750"
  },
  {
    "text": "to match on the first one that's true if the order of these two was flipped we",
    "start": "568750",
    "end": "575589"
  },
  {
    "text": "would actually get a compiler error because or a compiler warning because it would say that there's two two that",
    "start": "575589",
    "end": "581139"
  },
  {
    "text": "match and the second one would net the more specific one would never be reached",
    "start": "581139",
    "end": "587100"
  },
  {
    "text": "but if we put the one with a guard first it could match and if if excuse me",
    "start": "587100",
    "end": "596310"
  },
  {
    "text": "one about that they read yeah some other property I believe so yeah so the",
    "start": "597530",
    "end": "605250"
  },
  {
    "text": "question was could you have multiple cases with guards and I believe so I",
    "start": "605250",
    "end": "610980"
  },
  {
    "text": "mean as long as the guard has the eval",
    "start": "610980",
    "end": "616170"
  },
  {
    "text": "evaluates to a boolean expression you can put almost anything you want in this case I'm using my type pattern variable",
    "start": "616170",
    "end": "623430"
  },
  {
    "text": "in the guard I don't have to do that I could have a guard that depends on a",
    "start": "623430",
    "end": "628530"
  },
  {
    "text": "variable somewhere else in scope so this",
    "start": "628530",
    "end": "636330"
  },
  {
    "text": "is what makes pattern matching absolutely magical is that it combines type validation",
    "start": "636330",
    "end": "644690"
  },
  {
    "text": "variable evaluation and variable assignments into a single statement",
    "start": "644690",
    "end": "651230"
  },
  {
    "text": "going back to this I am validating the type of control when I see if it matches",
    "start": "651350",
    "end": "659130"
  },
  {
    "text": "the combo box I am evaluating it by",
    "start": "659130",
    "end": "666570"
  },
  {
    "text": "checking its property and if those things are true it will populate that",
    "start": "666570",
    "end": "671700"
  },
  {
    "text": "variable combo box this is why we can reduce the amount of code so much is",
    "start": "671700",
    "end": "678020"
  },
  {
    "text": "that I'm able to do multiple things in one place and it all makes sense it's not like some kind of wizardry where",
    "start": "678020",
    "end": "684870"
  },
  {
    "text": "we're doing a bunch of stuff and making the code more complex it just makes it",
    "start": "684870",
    "end": "691500"
  },
  {
    "text": "simpler and more compact",
    "start": "691500",
    "end": "694520"
  },
  {
    "text": "one way you can think of it and let me preface this by saying this is not valid code but it kind of you could think of",
    "start": "697560",
    "end": "704550"
  },
  {
    "text": "it kind of like a tryparse if you could also pass in a lambda because the tryparse will evaluate the input and if",
    "start": "704550",
    "end": "714480"
  },
  {
    "text": "it's valid assigned a variable which is in this case the output variable but it also does the selection it",
    "start": "714480",
    "end": "721290"
  },
  {
    "text": "returns true or false based on the parsing and if it were like pattern matching you would also be able to pass",
    "start": "721290",
    "end": "727649"
  },
  {
    "text": "in a lambda in the based on whether or not that lambda evaluated to true or",
    "start": "727649",
    "end": "733499"
  },
  {
    "text": "false you could you would parse it or not again just this is not valid code",
    "start": "733499",
    "end": "741029"
  },
  {
    "text": "don't try and do that so one of the reasons I like pattern matching so much",
    "start": "741029",
    "end": "747240"
  },
  {
    "text": "like I said it allows you to do multiple things it's kind of like we put a switch",
    "start": "747240",
    "end": "752249"
  },
  {
    "text": "statement and an is operator and as operator and like a try parser regex and a blender mash them together and got a",
    "start": "752249",
    "end": "760740"
  },
  {
    "text": "language feature at the bottom more generally it's a mixture of selection",
    "start": "760740",
    "end": "768079"
  },
  {
    "text": "assignment and evaluation so it's a nice",
    "start": "768079",
    "end": "775559"
  },
  {
    "text": "little it's kind of like a three-headed monster you know like fluffy let's look",
    "start": "775559",
    "end": "781740"
  },
  {
    "text": "at some code here",
    "start": "781740",
    "end": "784339"
  },
  {
    "text": "so you guys are all familiar with the fizzbuzz problem it's kind of a classic",
    "start": "792430",
    "end": "798450"
  },
  {
    "text": "programming kata and I could have a",
    "start": "799410",
    "end": "804640"
  },
  {
    "text": "method like resolve that is going to check each integer for either fizzbuzz",
    "start": "804640",
    "end": "811330"
  },
  {
    "text": "fizz buzz or just the integer number and",
    "start": "811330",
    "end": "816750"
  },
  {
    "text": "this code is fine you can see all my unit tests are passing but it's a little",
    "start": "816750",
    "end": "824140"
  },
  {
    "text": "esoteric because we have to kind of know what the mod operator is doing there",
    "start": "824140",
    "end": "830430"
  },
  {
    "text": "with pattern matching and another C sharp 7 feature we could reduce it down",
    "start": "831420",
    "end": "841120"
  },
  {
    "text": "to this let me kick the font up here for",
    "start": "841120",
    "end": "848350"
  },
  {
    "text": "you",
    "start": "848350",
    "end": "850470"
  },
  {
    "text": "so I've got a method called resolve pattern matching and the first thing",
    "start": "857920",
    "end": "863300"
  },
  {
    "text": "it's gonna do is gonna call another method called is multiple of three multiple of five and that's actually",
    "start": "863300",
    "end": "870290"
  },
  {
    "text": "going to return a tuple this is one of the other language features in c-sharp",
    "start": "870290",
    "end": "875510"
  },
  {
    "text": "seven if you haven't seen this you should really go check it out it allows us to package up two variables that",
    "start": "875510",
    "end": "882440"
  },
  {
    "text": "travel together without needing to create a class for them and we don't have to use generics and so I can simply",
    "start": "882440",
    "end": "891200"
  },
  {
    "text": "do the one evaluation of my input variable I for mod 3 and mod 5 and",
    "start": "891200",
    "end": "900530"
  },
  {
    "text": "return those two boolean x' back together the other cool thing here is that I can",
    "start": "900530",
    "end": "906440"
  },
  {
    "text": "name the members of the tuple so I can have multiple of three and multiple of",
    "start": "906440",
    "end": "914150"
  },
  {
    "text": "five as a boolean as boolean names so",
    "start": "914150",
    "end": "921470"
  },
  {
    "text": "now what I can do I call that method I'm going to switch on the result and this",
    "start": "921470",
    "end": "932300"
  },
  {
    "text": "is using a different pattern to match in the previous example we were looking at the type pattern this is what's called",
    "start": "932300",
    "end": "939350"
  },
  {
    "text": "the VAR pattern which basically means that we are going to match on any type",
    "start": "939350",
    "end": "947080"
  },
  {
    "text": "but we're going to evaluate a guard to",
    "start": "947080",
    "end": "952760"
  },
  {
    "text": "decide whether or not it matches or not and that kind of makes sense because",
    "start": "952760",
    "end": "958460"
  },
  {
    "text": "we're evaluating on the return type of that method so it's always going to be the same type it's going to be that",
    "start": "958460",
    "end": "963530"
  },
  {
    "text": "tuple so I can say now is for the case of status when status multiple of three",
    "start": "963530",
    "end": "971720"
  },
  {
    "text": "and status multiple of five return fizzbuzz I can do similar things for",
    "start": "971720",
    "end": "976970"
  },
  {
    "text": "when the status or just checking multiple three just checking multiple five and then we still have the default",
    "start": "976970",
    "end": "982850"
  },
  {
    "text": "case or we're going to return a string this code also works it works just fine",
    "start": "982850",
    "end": "991080"
  },
  {
    "text": "we in fact we can change this around so we're using the pattern matching code",
    "start": "991080",
    "end": "998130"
  },
  {
    "text": "instead of the older way if I run my unit tests then they should all pass",
    "start": "998130",
    "end": "1007940"
  },
  {
    "text": "again yep Oh yep they all passed so",
    "start": "1007940",
    "end": "1015440"
  },
  {
    "text": "functionally it's the same but I would",
    "start": "1015440",
    "end": "1021350"
  },
  {
    "text": "argue that this code is much more readable and the code is much more",
    "start": "1021350",
    "end": "1026410"
  },
  {
    "text": "expressive of the problem we're trying to solve and you can almost read the",
    "start": "1026410",
    "end": "1031699"
  },
  {
    "text": "requirements out of that code it's great",
    "start": "1031699",
    "end": "1035500"
  },
  {
    "text": "this one here yeah so this is the function call two is",
    "start": "1038110",
    "end": "1045230"
  },
  {
    "text": "multiple of three or five which is defined here and this is the syntax for returning a tuple that's where we're",
    "start": "1045230",
    "end": "1051260"
  },
  {
    "text": "putting the names on him and this is the syntax for composing the tuple",
    "start": "1051260",
    "end": "1058870"
  },
  {
    "text": "well when we have when so the question was do we need to have this variable",
    "start": "1074200",
    "end": "1080300"
  },
  {
    "text": "declaration here and we do because that's how the variable pattern works we",
    "start": "1080300",
    "end": "1085460"
  },
  {
    "text": "could actually have cases where inside of a single switch statement we match on",
    "start": "1085460",
    "end": "1091430"
  },
  {
    "text": "type patterns and the variable patterns and so it's kind of important that you say this is the VAR variable name this",
    "start": "1091430",
    "end": "1102260"
  },
  {
    "text": "example might not show that as clear as others but it is there",
    "start": "1102260",
    "end": "1109510"
  },
  {
    "text": "so the examples I've shown so far were kind of contrived what I thought would",
    "start": "1117350",
    "end": "1127460"
  },
  {
    "text": "be really interesting would be to look at some real-world examples and the neat",
    "start": "1127460",
    "end": "1132769"
  },
  {
    "text": "thing about this is that Microsoft is now developing a lot of their code in",
    "start": "1132769",
    "end": "1137870"
  },
  {
    "text": "the open it's up on github and a lot of those projects were started before c-sharp 7 was a thing so we can look at",
    "start": "1137870",
    "end": "1146139"
  },
  {
    "text": "how the Microsoft teams implemented code without pattern matching and see how",
    "start": "1146139",
    "end": "1152659"
  },
  {
    "text": "they've changed it now that pattern matching is available so I wrote a",
    "start": "1152659",
    "end": "1158769"
  },
  {
    "text": "little search tool using Rosalind to you know it compiled the code and then I",
    "start": "1158769",
    "end": "1164389"
  },
  {
    "text": "just searched for the syntax nodes for the pattern matching we're able to pull",
    "start": "1164389",
    "end": "1169580"
  },
  {
    "text": "some of these examples out of either asp net core any framework or net core or",
    "start": "1169580",
    "end": "1175129"
  },
  {
    "text": "the Rosalind project the ones in Rosalind are really interesting because you're seeing how the language",
    "start": "1175129",
    "end": "1182149"
  },
  {
    "text": "implementers are using their features so we'll see a handful of those so this is",
    "start": "1182149",
    "end": "1192110"
  },
  {
    "text": "some code from the entity framework code base or the EF core code base I should",
    "start": "1192110",
    "end": "1198110"
  },
  {
    "text": "say and they're getting this column and",
    "start": "1198110",
    "end": "1203620"
  },
  {
    "text": "basically we the first thing they have to do is check for null on both the",
    "start": "1203620",
    "end": "1209809"
  },
  {
    "text": "column and the property with c-sharp 7",
    "start": "1209809",
    "end": "1215419"
  },
  {
    "text": "they actually added functionality and so there is the code gets a little bit",
    "start": "1215419",
    "end": "1223399"
  },
  {
    "text": "bigger but it's doing more and what they can do is they can remove that null check so here's the new version of the",
    "start": "1223399",
    "end": "1232669"
  },
  {
    "text": "code and you can see that we're matching on that expression the same way but now",
    "start": "1232669",
    "end": "1240080"
  },
  {
    "text": "we're just matching on the types and that null check is nowhere to be found",
    "start": "1240080",
    "end": "1245110"
  },
  {
    "text": "one of the reasons for that is in pattern matching the type will only match if the variable",
    "start": "1245110",
    "end": "1253390"
  },
  {
    "text": "is not null and so if expression is null",
    "start": "1253390",
    "end": "1258970"
  },
  {
    "text": "it's gonna fall through to the default case it's actually really useful it gets",
    "start": "1258970",
    "end": "1265660"
  },
  {
    "text": "us out of a lot of places where you have to see is this null well it doesn't matter it's gonna fall through the default I can handle null for any of",
    "start": "1265660",
    "end": "1271360"
  },
  {
    "text": "those cases because it'll fall through",
    "start": "1271360",
    "end": "1277470"
  },
  {
    "text": "here's a larger example of code that's using guards and this actually is",
    "start": "1281640",
    "end": "1292540"
  },
  {
    "text": "already C sharp 7 with pattern matching but the thing that I wanted to point out",
    "start": "1292540",
    "end": "1299230"
  },
  {
    "text": "in this code is that we can match on the type and we populate that variable and",
    "start": "1299230",
    "end": "1306090"
  },
  {
    "text": "we can use it straight away in the guard so we match in the case and then in the",
    "start": "1306090",
    "end": "1313270"
  },
  {
    "text": "when we can already use that variable and then of course we can use the variable once we're into that block",
    "start": "1313270",
    "end": "1322620"
  },
  {
    "text": "here's another interesting bit of code again already using pattern matching but",
    "start": "1325710",
    "end": "1334210"
  },
  {
    "text": "I wanted to show you a couple of things one is that just like before with switch statements we can stack up a couple",
    "start": "1334210",
    "end": "1340480"
  },
  {
    "text": "different cases and have them result in the same block but this is a case where",
    "start": "1340480",
    "end": "1349990"
  },
  {
    "text": "I'm going to look at the type and I don't need that variable and so the new",
    "start": "1349990",
    "end": "1357880"
  },
  {
    "text": "syntax here is actually that guy that's an underscore and it's now the discard operator so what I want to do is I want",
    "start": "1357880",
    "end": "1368020"
  },
  {
    "text": "to inspect the type of the variable that I'm switching on but if I don't care",
    "start": "1368020",
    "end": "1373030"
  },
  {
    "text": "about using that variable again I just throw it away so the underscore is basically saying I",
    "start": "1373030",
    "end": "1379270"
  },
  {
    "text": "don't care what this is the discard operator doesn't only work",
    "start": "1379270",
    "end": "1385600"
  },
  {
    "text": "in pattern matching it actually works in other places it is very valuable in",
    "start": "1385600",
    "end": "1391180"
  },
  {
    "text": "pattern matching but for example if you want to call tryparse and you don't",
    "start": "1391180",
    "end": "1397540"
  },
  {
    "text": "actually care about their output value you can just discard it now and accept",
    "start": "1397540",
    "end": "1403300"
  },
  {
    "text": "the boolean result of the try it's worth",
    "start": "1403300",
    "end": "1408910"
  },
  {
    "text": "noting that before c-sharp seven and a single underscore was a valid variable",
    "start": "1408910",
    "end": "1416440"
  },
  {
    "text": "name or a very valid identifier and so",
    "start": "1416440",
    "end": "1421750"
  },
  {
    "text": "if you have code that uses a single underscore as an identifier you don't",
    "start": "1421750",
    "end": "1428110"
  },
  {
    "text": "have access to the discard operator anymore if you have code that uses a",
    "start": "1428110",
    "end": "1434410"
  },
  {
    "text": "single underscore as an identifier you might want to ask yourself some questions about that to begin with",
    "start": "1434410",
    "end": "1441059"
  },
  {
    "text": "with the exception fake it easy actually uses the single underscore for very",
    "start": "1441630",
    "end": "1448300"
  },
  {
    "text": "similar reasons basically to saying we don't care about this but just be aware",
    "start": "1448300",
    "end": "1453790"
  },
  {
    "text": "that that's like it's a funny little language thing where it could be an",
    "start": "1453790",
    "end": "1459070"
  },
  {
    "text": "operator or it could be a variable name I I think it wouldn't necessarily",
    "start": "1459070",
    "end": "1474720"
  },
  {
    "text": "because in fake it easy the underscore I think is a property and so it rescanned",
    "start": "1474720",
    "end": "1483400"
  },
  {
    "text": "not just like a bear identifier yeah",
    "start": "1483400",
    "end": "1488490"
  },
  {
    "text": "here's some code taken right out of the asp net core code base and in this we",
    "start": "1490380",
    "end": "1496510"
  },
  {
    "text": "are going to switch on one of the attributes that we found in the markup",
    "start": "1496510",
    "end": "1504000"
  },
  {
    "text": "remember when I said I promised I would come back to the whole ordering thing okay now we're back in this case the",
    "start": "1504810",
    "end": "1512860"
  },
  {
    "text": "class attribute that value could be in HTML string and the HTML string",
    "start": "1512860",
    "end": "1517889"
  },
  {
    "text": "implements I HTML content so in theory",
    "start": "1517889",
    "end": "1523629"
  },
  {
    "text": "both of those could match on a given input variable the new thing about",
    "start": "1523629",
    "end": "1532960"
  },
  {
    "text": "switch statements is that the order that they're listed in is now important in",
    "start": "1532960",
    "end": "1539909"
  },
  {
    "text": "c-sharp six and previous because things always evaluated two strings or numeric",
    "start": "1539909",
    "end": "1547480"
  },
  {
    "text": "values there's no way you could have these collisions and so the order really",
    "start": "1547480",
    "end": "1553389"
  },
  {
    "text": "didn't matter now because multiple of these things could match the order is",
    "start": "1553389",
    "end": "1560500"
  },
  {
    "text": "important so basically it will evaluate to the one that it finds first the",
    "start": "1560500",
    "end": "1567399"
  },
  {
    "text": "exception being the default block is always essentially at the bottom so if",
    "start": "1567399",
    "end": "1573879"
  },
  {
    "text": "you start with the default block that won't like match every single time other",
    "start": "1573879",
    "end": "1579940"
  },
  {
    "text": "than that order is now important",
    "start": "1579940",
    "end": "1584278"
  },
  {
    "text": "this is one of the examples I showed at the beginning and it's actually one of",
    "start": "1589140",
    "end": "1594850"
  },
  {
    "text": "the most useful ways to use pattern matching remember I said that pattern",
    "start": "1594850",
    "end": "1601809"
  },
  {
    "text": "matching is essentially a way to do evaluation and assignment in the same statement and so when we have code like",
    "start": "1601809",
    "end": "1608410"
  },
  {
    "text": "this where we are going to take a variable and try and cast it which would",
    "start": "1608410",
    "end": "1615910"
  },
  {
    "text": "be the assignment and then see if that cast worked which would be the selection",
    "start": "1615910",
    "end": "1622890"
  },
  {
    "text": "then this becomes a prime candidate for pattern matching so in this case I've got this expression and I'm going to do",
    "start": "1622890",
    "end": "1630100"
  },
  {
    "text": "an as operation on it which as you know if the as fails it's going to return",
    "start": "1630100",
    "end": "1635620"
  },
  {
    "text": "null so we then we have to do this expression or we have to check for null and we're actually going to do that",
    "start": "1635620",
    "end": "1641860"
  },
  {
    "text": "three different times for the three different types the expression syntax the statement syntax and the global",
    "start": "1641860",
    "end": "1647200"
  },
  {
    "text": "statement syntax but we can see now with",
    "start": "1647200",
    "end": "1654160"
  },
  {
    "text": "pattern matching we can clean this code up right down to this because now",
    "start": "1654160",
    "end": "1660780"
  },
  {
    "text": "instead of having to check the type we can just match on it so if the node",
    "start": "1660780",
    "end": "1666280"
  },
  {
    "text": "matches expression syntax we're going to evaluate in that we don't have to do the as cast because the pattern will",
    "start": "1666280",
    "end": "1674590"
  },
  {
    "text": "populate the variable already so that gets you know a fairly significant",
    "start": "1674590",
    "end": "1681280"
  },
  {
    "text": "reduction in code there",
    "start": "1681280",
    "end": "1684330"
  },
  {
    "text": "this is another one of those places where we're doing something similar where we're going to do an evaluation",
    "start": "1688740",
    "end": "1694960"
  },
  {
    "text": "with an is statement and then if the is evaluates to true we'll do the cast this",
    "start": "1694960",
    "end": "1701259"
  },
  {
    "text": "also can be cleaned up and now the pattern will populate the expression",
    "start": "1701259",
    "end": "1707499"
  },
  {
    "text": "variable and we can use it right away but there's another interesting piece of",
    "start": "1707499",
    "end": "1714129"
  },
  {
    "text": "this that I haven't talked about so far and that's that this doesn't use a",
    "start": "1714129",
    "end": "1719769"
  },
  {
    "text": "switch statement so pattern matching primarily gets used",
    "start": "1719769",
    "end": "1726100"
  },
  {
    "text": "inside switch statements but it can also be used as the expression following in",
    "start": "1726100",
    "end": "1731350"
  },
  {
    "text": "is statement so here I'm saying node is",
    "start": "1731350",
    "end": "1737759"
  },
  {
    "text": "expression syntax and expression syntax expression is the pattern and we can",
    "start": "1737759",
    "end": "1745269"
  },
  {
    "text": "just use it right here right outside of that cast",
    "start": "1745269",
    "end": "1749220"
  },
  {
    "text": "lastly and this is yet another example from the Rosalind codebase we can switch",
    "start": "1753680",
    "end": "1760650"
  },
  {
    "text": "on enews and have guards so everything",
    "start": "1760650",
    "end": "1766980"
  },
  {
    "text": "we've shown this up to this point was switching on objects the switch",
    "start": "1766980",
    "end": "1772050"
  },
  {
    "text": "statement in this case is the same as in C sharp six because we've always been able to switch on in ohms they result in",
    "start": "1772050",
    "end": "1777120"
  },
  {
    "text": "numeric values but I can now have my case statement on the enum and have the",
    "start": "1777120",
    "end": "1784470"
  },
  {
    "text": "guard so the guard doesn't have to follow a tight pattern or a variable",
    "start": "1784470",
    "end": "1790590"
  },
  {
    "text": "pattern alright any questions on any of",
    "start": "1790590",
    "end": "1797130"
  },
  {
    "text": "the code we've just looked at yeah so",
    "start": "1797130",
    "end": "1806670"
  },
  {
    "text": "the question was can you put a guard on an is statement let's find out so if we",
    "start": "1806670",
    "end": "1819240"
  },
  {
    "text": "had a method",
    "start": "1819240",
    "end": "1821929"
  },
  {
    "text": "and we'll say that it's going to pass in a control oh I don't have oh it's not in",
    "start": "1831929",
    "end": "1841090"
  },
  {
    "text": "scope will say object actually let's",
    "start": "1841090",
    "end": "1850240"
  },
  {
    "text": "let's return a bool and we will return",
    "start": "1850240",
    "end": "1860429"
  },
  {
    "text": "is oh is straying s when yes",
    "start": "1860429",
    "end": "1877120"
  },
  {
    "text": "Oh apparently can't do it'd be a cool",
    "start": "1877120",
    "end": "1882130"
  },
  {
    "text": "feature though good question",
    "start": "1882130",
    "end": "1888000"
  },
  {
    "text": "when that case is is returning a bool either way so right now the is returns a",
    "start": "1891809",
    "end": "1901390"
  },
  {
    "text": "bool based on the type and so we're just talking about extending that bullet to also evaluate the guard right so I could",
    "start": "1901390",
    "end": "1919030"
  },
  {
    "text": "just do a boolean yeah so I could I",
    "start": "1919030",
    "end": "1928450"
  },
  {
    "text": "could say a stun length grand 0 yeah so",
    "start": "1928450",
    "end": "1938020"
  },
  {
    "text": "I could do that that's not necessarily pattern matching other than we I mean",
    "start": "1938020",
    "end": "1943950"
  },
  {
    "text": "this is still the pattern matching but then this is just the evaluation",
    "start": "1943950",
    "end": "1950190"
  },
  {
    "text": "all right any other questions about c-sharp yeah yeah so you're asking does",
    "start": "1956340",
    "end": "1974799"
  },
  {
    "text": "the performance improve using pattern matching I don't know that's a really interesting question I'll do some",
    "start": "1974799",
    "end": "1983409"
  },
  {
    "text": "research on that and I'll throw something up on Twitter about it because",
    "start": "1983409",
    "end": "1989049"
  },
  {
    "text": "the guys that would know are in the building so I'll find out for you yeah other",
    "start": "1989049",
    "end": "1995529"
  },
  {
    "text": "question over here",
    "start": "1995529",
    "end": "1997980"
  },
  {
    "text": "yeah so you what you're saying is it's just syntactic sugar I think that's the case but I don't want to say for sure",
    "start": "2005389",
    "end": "2011789"
  },
  {
    "text": "because I don't know but let's find out I'm curious now",
    "start": "2011789",
    "end": "2017750"
  },
  {
    "text": "all right so pattern matching is new in c-sharp but it's actually been around in",
    "start": "2022700",
    "end": "2030360"
  },
  {
    "text": "some other languages for a while and when you see a presentation by a guy",
    "start": "2030360",
    "end": "2037260"
  },
  {
    "text": "that has an f-sharp sticker or two on his laptop you know you're gonna see",
    "start": "2037260",
    "end": "2044309"
  },
  {
    "text": "some F sharp at some point so let's look at what you can do an F sharp",
    "start": "2044309",
    "end": "2051560"
  },
  {
    "text": "so an f-sharp we can have this match operator and I can match on variable I",
    "start": "2067899",
    "end": "2077309"
  },
  {
    "text": "and the thing that I want to show you here is that while this probably does",
    "start": "2077309",
    "end": "2082749"
  },
  {
    "text": "kind of what you think it does where this gets more interesting is let's say that I take out the default match so",
    "start": "2082749",
    "end": "2092769"
  },
  {
    "text": "this line basically says if nothing else matches fall through it's kind of like a default let's say that that goes away",
    "start": "2092769",
    "end": "2101338"
  },
  {
    "text": "I'm now getting a little green squiggly and if I hover over it you'll see I'm",
    "start": "2103589",
    "end": "2114819"
  },
  {
    "text": "getting a error that says incomplete pattern match on this expression so the",
    "start": "2114819",
    "end": "2119920"
  },
  {
    "text": "compiler will actually run through and see is the bonehead programmer writing",
    "start": "2119920",
    "end": "2125499"
  },
  {
    "text": "this code missing something and as a bonehead programmer this makes me really",
    "start": "2125499",
    "end": "2131170"
  },
  {
    "text": "happy this is something I don't know how",
    "start": "2131170",
    "end": "2136269"
  },
  {
    "text": "hard it would be to do in c-sharp it would be really cool I would like it",
    "start": "2136269",
    "end": "2141150"
  },
  {
    "text": "where this gets a little more interesting is if we were using",
    "start": "2141960",
    "end": "2147220"
  },
  {
    "text": "something like enums f-sharp has a construct called discriminated types let's say that another color got added",
    "start": "2147220",
    "end": "2157230"
  },
  {
    "text": "I'm now getting that same error because another possibility was introduced you",
    "start": "2158099",
    "end": "2166900"
  },
  {
    "text": "could see how in a large code base this would be incredibly useful and one part of the code base I add a new enum and",
    "start": "2166900",
    "end": "2175380"
  },
  {
    "text": "another part of the code base that I've never seen somebody's switching on what they think is all the e-news or was all",
    "start": "2175380",
    "end": "2181299"
  },
  {
    "text": "the enums at the type at the time and so now that becomes an error to me and I",
    "start": "2181299",
    "end": "2187420"
  },
  {
    "text": "know that hey I change I added something to this enumeration here's this other place I need to go make some",
    "start": "2187420",
    "end": "2193420"
  },
  {
    "text": "modifications I think that's really cool",
    "start": "2193420",
    "end": "2198930"
  },
  {
    "text": "another pattern type that f-sharp is called a list comprehension and so what",
    "start": "2205520",
    "end": "2214710"
  },
  {
    "text": "I'm doing in this code here is I've got a method called what might my list be in",
    "start": "2214710",
    "end": "2221810"
  },
  {
    "text": "that it's actually going to match on the different values that are in the list so",
    "start": "2221810",
    "end": "2230220"
  },
  {
    "text": "if the list that's passed in starts with zero and then has one and one and two",
    "start": "2230220",
    "end": "2235560"
  },
  {
    "text": "and three and five and eight and thirteen and then some tail some continuation of the list I will return",
    "start": "2235560",
    "end": "2242760"
  },
  {
    "text": "this string Fibonacci and then I have a similar one for Prime's this is",
    "start": "2242760",
    "end": "2249930"
  },
  {
    "text": "something I find really fascinating where I can actually match on members of",
    "start": "2249930",
    "end": "2255510"
  },
  {
    "text": "the list an example that might be a little more relevant is trying to",
    "start": "2255510",
    "end": "2260760"
  },
  {
    "text": "evaluate command-line parameters to my application so this is the main method",
    "start": "2260760",
    "end": "2268710"
  },
  {
    "text": "and I've get this list of arguments I'm going to cast it to a list and so now I",
    "start": "2268710",
    "end": "2275010"
  },
  {
    "text": "can match on the argument list and I can either look for - help or - V or - greed",
    "start": "2275010",
    "end": "2281430"
  },
  {
    "text": "and in the same way that in c-sharp I could assign values in F sharp what I",
    "start": "2281430",
    "end": "2289590"
  },
  {
    "text": "can do is I can look for constants but also populate variables so in this case",
    "start": "2289590",
    "end": "2295470"
  },
  {
    "text": "tail is a variable greet is a constant and so I can use this variable in my",
    "start": "2295470",
    "end": "2302640"
  },
  {
    "text": "output so if we ran this and you and I passed in dot greet Eric it would say",
    "start": "2302640",
    "end": "2308100"
  },
  {
    "text": "hello Eric so",
    "start": "2308100",
    "end": "2312620"
  },
  {
    "text": "so if so you're asking what if I called",
    "start": "2315790",
    "end": "2322010"
  },
  {
    "text": "this application and and did - greet and didn't have anything else so then this",
    "start": "2322010",
    "end": "2327470"
  },
  {
    "text": "pattern wouldn't match and so we would fall through - the default case just",
    "start": "2327470",
    "end": "2333470"
  },
  {
    "text": "like in c-sharp if the pattern doesn't match the variables don't get populated",
    "start": "2333470",
    "end": "2338500"
  },
  {
    "text": "so you're asking could I could I match on the middle of something so what I",
    "start": "2352870",
    "end": "2359600"
  },
  {
    "text": "could do is throw some discarded operators in here which the underscore",
    "start": "2359600",
    "end": "2366290"
  },
  {
    "text": "kind of works like the discard operator",
    "start": "2366290",
    "end": "2369580"
  },
  {
    "text": "and I could you know blank out some of these and so this would achieve what",
    "start": "2375270",
    "end": "2382290"
  },
  {
    "text": "you're talking about so now I'm simply not going to look at those first four and then match on three five and eight",
    "start": "2382290",
    "end": "2388770"
  },
  {
    "text": "and thirteen so could I could I with",
    "start": "2388770",
    "end": "2399869"
  },
  {
    "text": "pattern matching look for anything in the middle that matches you could do",
    "start": "2399869",
    "end": "2408930"
  },
  {
    "text": "that enough sharp but not with pattern matching so if you guys want to talk",
    "start": "2408930",
    "end": "2415050"
  },
  {
    "text": "about F sharp I would love to talk about it more with you but we will get out of the scope of this talk believe me",
    "start": "2415050",
    "end": "2422460"
  },
  {
    "text": "there's nothing that would make the attendee party more fun than for me to talk about F star for three hours are",
    "start": "2422460",
    "end": "2438360"
  },
  {
    "text": "you guys familiar with the rust language rust is a really new language it's it's",
    "start": "2438360",
    "end": "2446220"
  },
  {
    "text": "cool it's really low level it's actually the language they're using to implement some of the core bits of Firefox and",
    "start": "2446220",
    "end": "2452670"
  },
  {
    "text": "it's one of the reasons why they're getting such good performance improvements in Firefox right now but",
    "start": "2452670",
    "end": "2458940"
  },
  {
    "text": "they also through pattern matching in there it was interesting to me that they did that because pattern matching is",
    "start": "2458940",
    "end": "2464550"
  },
  {
    "text": "traditionally a functional programming language construct and rust is a low-level language it's a lot like C but",
    "start": "2464550",
    "end": "2471810"
  },
  {
    "text": "they did throw pattern matching in there they have the match keyword and a lot of the pattern matching looks similar to",
    "start": "2471810",
    "end": "2477930"
  },
  {
    "text": "c-sharp but they have this this is the range pattern so now if I have a",
    "start": "2477930",
    "end": "2486030"
  },
  {
    "text": "function that's passing in a grade which is a 32-bit integer I can match on",
    "start": "2486030",
    "end": "2491640"
  },
  {
    "text": "anything in that range so ninety to a hundred would match on that first one so if I had 93 it would match that range",
    "start": "2491640",
    "end": "2498480"
  },
  {
    "text": "I'd print a if the value that was passed in was 75 it would match on that third",
    "start": "2498480",
    "end": "2504290"
  },
  {
    "text": "statement and print C I think this is kind of cool there's",
    "start": "2504290",
    "end": "2509339"
  },
  {
    "text": "a lot of times and my coding career that I've written code that's like if a value",
    "start": "2509339",
    "end": "2515219"
  },
  {
    "text": "is greater than or equal to this and also less than equal to that and one",
    "start": "2515219",
    "end": "2523920"
  },
  {
    "text": "thing that's really cool is that this is almost a c-sharp feature if you go up on",
    "start": "2523920",
    "end": "2529170"
  },
  {
    "text": "github and look at the c-sharp Lang or posit ory you'll see that this is something that they're seriously",
    "start": "2529170",
    "end": "2534690"
  },
  {
    "text": "considering for c-sharp 7-3 it is still a proposal might not be there but yeah",
    "start": "2534690",
    "end": "2542160"
  },
  {
    "text": "here's the URL you can go out and follow the status see if it makes it in or not",
    "start": "2542160",
    "end": "2548749"
  },
  {
    "text": "interestingly the thing that they're hung up on right now is whether zero to ten should be inclusive or exclusive and",
    "start": "2548749",
    "end": "2558319"
  },
  {
    "text": "actually rust I think if you use the two dots for the range is inclusive and",
    "start": "2558319",
    "end": "2564809"
  },
  {
    "text": "three dots is exclusive maybe it's a low era but I asked Bill Wagner yesterday",
    "start": "2564809",
    "end": "2571829"
  },
  {
    "text": "about that and he said that they didn't like that in c-sharp they didn't think having like a two dot operator and three",
    "start": "2571829",
    "end": "2576839"
  },
  {
    "text": "dot operator made a lot of sense another newish language that has become",
    "start": "2576839",
    "end": "2583650"
  },
  {
    "text": "really popular really fast as swift and their pattern matching looks a lot like",
    "start": "2583650",
    "end": "2589829"
  },
  {
    "text": "c-sharp but they have an additional feature that I really like which is where you can pattern match in your",
    "start": "2589829",
    "end": "2598259"
  },
  {
    "text": "iteration so let's say that I have an array of optional intz which if you've",
    "start": "2598259",
    "end": "2605369"
  },
  {
    "text": "not looked at it Swift before optional is kind of like nillable nil is analogous to null and so I have this",
    "start": "2605369",
    "end": "2614910"
  },
  {
    "text": "array that I'm declaring they're on line one that has five slots in it two of",
    "start": "2614910",
    "end": "2621569"
  },
  {
    "text": "them are nil where the pattern matching comes in is this question mark right",
    "start": "2621569",
    "end": "2628499"
  },
  {
    "text": "here that guy",
    "start": "2628499",
    "end": "2633289"
  },
  {
    "text": "so what I can say is for case let number question mark in array of optional intz and I'm just gonna say print found a and",
    "start": "2634570",
    "end": "2642860"
  },
  {
    "text": "then the number what's cool is that that means that the iteration skips over all",
    "start": "2642860",
    "end": "2648020"
  },
  {
    "text": "the Nils so I don't have to have a nil check every time I go through the loop",
    "start": "2648020",
    "end": "2654200"
  },
  {
    "text": "it's just gonna skip right over pretty cool all right how many guys have ever",
    "start": "2654200",
    "end": "2663980"
  },
  {
    "text": "played with a lick sir so if you haven't played with elixir you really ought to",
    "start": "2663980",
    "end": "2669620"
  },
  {
    "text": "go check this language out it's really cool it takes pattern matching further than",
    "start": "2669620",
    "end": "2677390"
  },
  {
    "text": "just about any other language that I've ever seen it does some things that I will not be",
    "start": "2677390",
    "end": "2685730"
  },
  {
    "text": "able to explain in the next 10 minutes I'd encourage you to go look at it if",
    "start": "2685730",
    "end": "2690830"
  },
  {
    "text": "you have a plural site subscription there is a course called getting started",
    "start": "2690830",
    "end": "2695990"
  },
  {
    "text": "with a lick sir by Nate Taylor that I recommend if you want some more",
    "start": "2695990",
    "end": "2701540"
  },
  {
    "text": "interactive material Rob Connery has put out some some tutorials where you're",
    "start": "2701540",
    "end": "2707510"
  },
  {
    "text": "actually kind of writing code as you go it's pretty cool as well and look that up but as a c-sharp developer when I",
    "start": "2707510",
    "end": "2717740"
  },
  {
    "text": "look at this code I think that those functions are overloaded I have two functions named first that they're in",
    "start": "2717740",
    "end": "2727550"
  },
  {
    "text": "the same scope and they seem to do the same thing but they're not really overloaded because they actually take",
    "start": "2727550",
    "end": "2734210"
  },
  {
    "text": "the same number and types of parameters this is probably foreign to you but this",
    "start": "2734210",
    "end": "2740240"
  },
  {
    "text": "square brackets indicates that something is a list so I have two functions",
    "start": "2740240",
    "end": "2745420"
  },
  {
    "text": "it looks like named first that both take a list what that means is that I'm",
    "start": "2745420",
    "end": "2753410"
  },
  {
    "text": "actually pattern matching on the arguments and then selecting which",
    "start": "2753410",
    "end": "2758690"
  },
  {
    "text": "clause to execute based on the contents of the list not on whether or not it's a list right in c-sharp we can overload a",
    "start": "2758690",
    "end": "2764990"
  },
  {
    "text": "method and the right one will be selected based on the argument types or the",
    "start": "2764990",
    "end": "2770240"
  },
  {
    "text": "number of the arguments basically what is happening here is if I call first and",
    "start": "2770240",
    "end": "2776240"
  },
  {
    "text": "I pass in an empty list it's going to return nil there's nothing in between the square brackets of the list is empty",
    "start": "2776240",
    "end": "2783069"
  },
  {
    "text": "the second Clause is going to look at the head or the first element in the",
    "start": "2783069",
    "end": "2789470"
  },
  {
    "text": "list and then it will look and make sure that there is a tail which we're discarding here oops",
    "start": "2789470",
    "end": "2796059"
  },
  {
    "text": "again the underscores the discard operator and then since the method is named first you could expect we just",
    "start": "2796059",
    "end": "2802339"
  },
  {
    "text": "can't return the first item or the head but I found this to be really fascinating that I could actually pick",
    "start": "2802339",
    "end": "2809720"
  },
  {
    "text": "which what these clauses I'm going to execute this is called multi Clause functions it's not really overloading",
    "start": "2809720",
    "end": "2816680"
  },
  {
    "text": "because they take the same argument list but it's multi Clause functions and one",
    "start": "2816680",
    "end": "2822230"
  },
  {
    "text": "thing that's really common is to have a bunch of clauses so again going back to",
    "start": "2822230",
    "end": "2828770"
  },
  {
    "text": "that list example I had earlier I could match on things like match on whether or not the list starts with 1 3 & 5 or 2 3",
    "start": "2828770",
    "end": "2835849"
  },
  {
    "text": "& 5 or 1 2 3 & 5 now I'm going to return a string based on which one it is",
    "start": "2835849",
    "end": "2841390"
  },
  {
    "text": "now I've got three clauses but the way that you would typically do this in a",
    "start": "2841390",
    "end": "2847819"
  },
  {
    "text": "lick sir the idiomatic way that you would do it in the cinah lick sir is to shrink it down to this we're going to",
    "start": "2847819",
    "end": "2854869"
  },
  {
    "text": "have each method Clause have the pattern and then the return type just on that",
    "start": "2854869",
    "end": "2861410"
  },
  {
    "text": "same line this starts to look kind of foreign to c-sharp programmers but I",
    "start": "2861410",
    "end": "2867380"
  },
  {
    "text": "think it's really neat you're doing some really powerful evaluation there in a",
    "start": "2867380",
    "end": "2874190"
  },
  {
    "text": "very small bit of code if you think",
    "start": "2874190",
    "end": "2879529"
  },
  {
    "text": "about why this works it helps you understand what pattern matching is in c-sharp because really what we have is a",
    "start": "2879529",
    "end": "2887480"
  },
  {
    "text": "couple of different clauses and we need to select which one of them we're going to do right so we've got our selection",
    "start": "2887480",
    "end": "2893799"
  },
  {
    "text": "and when we pass arguments into a method",
    "start": "2893799",
    "end": "2899240"
  },
  {
    "text": "the parameters essentially get a sign and so we have that assignment piece",
    "start": "2899240",
    "end": "2904890"
  },
  {
    "text": "that we have in c-sharp as well right so you have the selection you have the assignment elixir also has guards that",
    "start": "2904890",
    "end": "2911970"
  },
  {
    "text": "you can put on methods but that's actually a little bit outside of pattern matching you can put a guard in any",
    "start": "2911970",
    "end": "2917370"
  },
  {
    "text": "method and so you have that same evaluation piece like c-sharp has and",
    "start": "2917370",
    "end": "2924630"
  },
  {
    "text": "it's pattern matching so let's switch",
    "start": "2924630",
    "end": "2930450"
  },
  {
    "text": "gears back to c-sharp I think those are the language that are awesome they help us think about pattern matching but",
    "start": "2930450",
    "end": "2936420"
  },
  {
    "text": "let's be real when I get back to the office I'm gonna be writing c-sharp code",
    "start": "2936420",
    "end": "2944720"
  },
  {
    "text": "so let's talk about when you should think about using it when you have different behaviors based on the type of",
    "start": "2944900",
    "end": "2951690"
  },
  {
    "text": "an input variable consider using pattern matching with the type pattern I say",
    "start": "2951690",
    "end": "2958500"
  },
  {
    "text": "consider because this isn't like a law this isn't always going to be the case",
    "start": "2958500",
    "end": "2963780"
  },
  {
    "text": "there are going to be other situations where you have different types and you want different behaviors and what you",
    "start": "2963780",
    "end": "2969630"
  },
  {
    "text": "actually want to do is use object orientation right you say have the default behavior in a base class and you",
    "start": "2969630",
    "end": "2976140"
  },
  {
    "text": "override that behavior in the child classes if you don't control those",
    "start": "2976140",
    "end": "2981600"
  },
  {
    "text": "classes you might want to consider using pattern matching that's why I use WPF in",
    "start": "2981600",
    "end": "2986790"
  },
  {
    "text": "the example I don't control the code for textbox and so I need to switch on it and get the right behavior for given the",
    "start": "2986790",
    "end": "2995040"
  },
  {
    "text": "type when you have a case statement with",
    "start": "2995040",
    "end": "3000200"
  },
  {
    "text": "nested if blocks consider rewriting the blocks to have guards this is an easy",
    "start": "3000200",
    "end": "3006710"
  },
  {
    "text": "one to pick up visually if you have a case and then immediately have an if a",
    "start": "3006710",
    "end": "3012980"
  },
  {
    "text": "lot of times that might be an if variable equals null or it could be some other you know if something else about",
    "start": "3012980",
    "end": "3019490"
  },
  {
    "text": "the variable very frequently you can't combine that just into a case with a",
    "start": "3019490",
    "end": "3026510"
  },
  {
    "text": "guard and that will clean up your code get rid of some of those unnecessary if",
    "start": "3026510",
    "end": "3032030"
  },
  {
    "text": "statements when you have an is check immediately",
    "start": "3032030",
    "end": "3037370"
  },
  {
    "text": "followed by an as cast consider just using the is statement with pattern",
    "start": "3037370",
    "end": "3042680"
  },
  {
    "text": "matching this is probably the most obvious one this is the one that's like",
    "start": "3042680",
    "end": "3048500"
  },
  {
    "text": "if you see this you should almost certainly use pattern matching because that ad as cast is now completely",
    "start": "3048500",
    "end": "3055070"
  },
  {
    "text": "superfluous just use the type pattern you get the variable signed in the right time it'll be fine in in a similar way",
    "start": "3055070",
    "end": "3063620"
  },
  {
    "text": "if you have an AZ cast followed by a null check combine that into the type pattern with the is statement there's no",
    "start": "3063620",
    "end": "3071660"
  },
  {
    "text": "reason to use that more of our but the more verbose way to evaluate that I",
    "start": "3071660",
    "end": "3078340"
  },
  {
    "text": "really enjoy this feature I really love pattern matching it's why I'm talking",
    "start": "3079540",
    "end": "3085550"
  },
  {
    "text": "about it but this is the one thing that I want you to remember this is the most important slide in the whole thing just",
    "start": "3085550",
    "end": "3092050"
  },
  {
    "text": "appreciate the fact that you now have one construct that represents three different functionalities it allows you",
    "start": "3092050",
    "end": "3100430"
  },
  {
    "text": "to really clean up your code it makes it more expressive it makes it easier to understand all those illah T's that we",
    "start": "3100430",
    "end": "3107750"
  },
  {
    "text": "want in our code pattern matching helps you get I know we've got the attendee",
    "start": "3107750",
    "end": "3117200"
  },
  {
    "text": "party coming up so I won't run any longer if you have further questions please let's come up and talk about it",
    "start": "3117200",
    "end": "3123590"
  },
  {
    "text": "or find me at the attendee party or find me tomorrow I'll be here all day I'd love to talk to you more about this stuff if you have questions later you",
    "start": "3123590",
    "end": "3132170"
  },
  {
    "text": "can certainly hit me up on Twitter that's the easiest way to find me online if you want to see any of the code that",
    "start": "3132170",
    "end": "3138950"
  },
  {
    "text": "I ship it today it's up on my github also at Potter Eric I've blogged about a lot of these topics",
    "start": "3138950",
    "end": "3145220"
  },
  {
    "text": "if you want to see further explanations my blog is at humble tool Smith comm and you can find the pattern matching tag",
    "start": "3145220",
    "end": "3151700"
  },
  {
    "text": "there so I hope you guys take this I",
    "start": "3151700",
    "end": "3157100"
  },
  {
    "text": "hope you guys start using it is great it's one of those features that really makes the language moving forward or",
    "start": "3157100",
    "end": "3165050"
  },
  {
    "text": "move forward in awesome awesome ways so thanks guys [Applause]",
    "start": "3165050",
    "end": "3177939"
  }
]