[
  {
    "start": "0",
    "end": "73000"
  },
  {
    "text": "all right everyone thanks for coming good morning my name is Daniel chambers",
    "start": "9740",
    "end": "15930"
  },
  {
    "text": "and I'm a developer at Liberty financial my roots are as a.net developer having",
    "start": "15930",
    "end": "21750"
  },
  {
    "text": "worked on projects in both C sharp F sharp and JavaScript and I've also spent",
    "start": "21750",
    "end": "27149"
  },
  {
    "text": "a year or so writing Haskell in production and that was a lot of fun so I joined Liberty financial last year in",
    "start": "27149",
    "end": "34230"
  },
  {
    "text": "order to help them upscale and functional programming in particular the f-sharp language and one of the things",
    "start": "34230",
    "end": "40110"
  },
  {
    "text": "that struck me when I first started teaching the team at Liberty about f-sharp and functional programming is how much assumed knowledge there is that",
    "start": "40110",
    "end": "47880"
  },
  {
    "text": "one builds up over time and takes for granted although I two started learning FP after having already learned",
    "start": "47880",
    "end": "54270"
  },
  {
    "text": "imperative object-oriented programming I'd forgotten how unfamiliar FP techniques and jargon are to those who",
    "start": "54270",
    "end": "60930"
  },
  {
    "text": "have never explored the space before and this is what has prompted me to make this talk to help decode and explain",
    "start": "60930",
    "end": "67680"
  },
  {
    "text": "some of the very basic terminology and jargon that you'll encounter when you first start out in FP now one of the",
    "start": "67680",
    "end": "75750"
  },
  {
    "start": "73000",
    "end": "198000"
  },
  {
    "text": "first questions I got asked by a curious product manager was what is functional programming exactly well functional",
    "start": "75750",
    "end": "82440"
  },
  {
    "text": "programming doesn't usually refer to an exact concrete definition like object-oriented programming it refers to",
    "start": "82440",
    "end": "88350"
  },
  {
    "text": "a set of programming techniques and ideas that are all related so different",
    "start": "88350",
    "end": "93990"
  },
  {
    "text": "languages will implement more or fewer of these ideas but there's a few basic tenants that I think we can all agree on",
    "start": "93990",
    "end": "101720"
  },
  {
    "text": "Eric Meyer once referred to functional programming as a style of programming where expressions are more important",
    "start": "101720",
    "end": "108180"
  },
  {
    "text": "than statements and I think that's a really good place to start in FP you always write code in terms of",
    "start": "108180",
    "end": "113670"
  },
  {
    "text": "expressions that return a value as opposed to statements that don't return anything but perform some sort of side",
    "start": "113670",
    "end": "119130"
  },
  {
    "text": "effect this style of programming allows you to write programs in a declarative compositional style and a great example",
    "start": "119130",
    "end": "126210"
  },
  {
    "text": "is of this is the fundamental if-then-else language construct in F sharp it doesn't behave like a regular",
    "start": "126210",
    "end": "132480"
  },
  {
    "text": "if-then-else like you'd find in a language like C sharp instead it behaves more like C sharp ternary operator it's an expression and",
    "start": "132480",
    "end": "140219"
  },
  {
    "text": "it evaluates to a result that you can assign to something as opposed to two branches that perform",
    "start": "140219",
    "end": "145680"
  },
  {
    "text": "two different side effects based on what your condition is like a regular C sharp if then else another",
    "start": "145680",
    "end": "154680"
  },
  {
    "text": "must have in FP first-class functions and this is where we treat functions the same as we treat other values in a",
    "start": "154680",
    "end": "161700"
  },
  {
    "text": "language like strings and integers we can give them names we can pass them to other functions and we can return them",
    "start": "161700",
    "end": "168209"
  },
  {
    "text": "from functions and functional programming is all about combining expressions into functions and functions",
    "start": "168209",
    "end": "173219"
  },
  {
    "text": "into wider programs the other major tenant of functional programming is",
    "start": "173219",
    "end": "178470"
  },
  {
    "text": "purity and the elimination of side-effects and this means that an expression in your code when given the",
    "start": "178470",
    "end": "183989"
  },
  {
    "text": "same inputs should always return the same value some FP programming languages",
    "start": "183989",
    "end": "189239"
  },
  {
    "text": "encourage purity but allow impure and side-effect aful code while others disallow impurity entirely and force you",
    "start": "189239",
    "end": "196049"
  },
  {
    "text": "to write 100% pure code now you've probably looked at that last slide I",
    "start": "196049",
    "end": "201719"
  },
  {
    "start": "198000",
    "end": "225000"
  },
  {
    "text": "went ah you've already started with the jargon and it were only two slides in unfortunately jargon is hard to avoid in",
    "start": "201719",
    "end": "208049"
  },
  {
    "text": "fact all of us object-oriented programmers are already steeped in our own fair share of jargon we've got",
    "start": "208049",
    "end": "213510"
  },
  {
    "text": "objects classes interfaces methods overloading variables attributes iterators decorators strategies",
    "start": "213510",
    "end": "219870"
  },
  {
    "text": "factories and if you're very unlucky abstract service factory builder basis",
    "start": "219870",
    "end": "225739"
  },
  {
    "text": "jargon is useful jargon is a shared language it allows speakers of it to",
    "start": "225739",
    "end": "230909"
  },
  {
    "text": "communicate complex ideas concisely and precisely however with all things",
    "start": "230909",
    "end": "236579"
  },
  {
    "text": "there's always a downside jargon makes it harder for newcomers to understand some things until they learn to speak",
    "start": "236579",
    "end": "242639"
  },
  {
    "text": "that shared language now FB is a different paradigm to object-oriented programming and it has its own set of",
    "start": "242639",
    "end": "248400"
  },
  {
    "text": "jargon bindings purity impurity referential transparency immutability",
    "start": "248400",
    "end": "254519"
  },
  {
    "text": "currying partial application algebraic data types some types product types folding tail",
    "start": "254519",
    "end": "260849"
  },
  {
    "text": "calls and much more and look just like we all learned that imperative oo jargon",
    "start": "260849",
    "end": "266250"
  },
  {
    "text": "we too can learn FP jargon so we're going to walk through all of that basic FP jargon and probably pick up a little",
    "start": "266250",
    "end": "272070"
  },
  {
    "text": "bit of F sharp along the way so in functional programming data is",
    "start": "272070",
    "end": "279540"
  },
  {
    "start": "275000",
    "end": "311000"
  },
  {
    "text": "immutable by default in some languages like Haskell there's no mutability allowed at all",
    "start": "279540",
    "end": "284870"
  },
  {
    "text": "immutability means that when we construct data we can't change it in place the only way to affect change is",
    "start": "284870",
    "end": "291450"
  },
  {
    "text": "to make a copy of the data with your changes made to it at copy time and this means data in FP behaves like instant",
    "start": "291450",
    "end": "298860"
  },
  {
    "text": "strings do in c-sharp and this can sound difficult to work with but in practice it actually simplifies things",
    "start": "298860",
    "end": "304700"
  },
  {
    "text": "immutability makes it much harder to make tangled messes that we've all seen rampant mutability allow an f-sharp we",
    "start": "304700",
    "end": "313020"
  },
  {
    "start": "311000",
    "end": "375000"
  },
  {
    "text": "can define record types which are an immutable data type that has a number of properties and you can see the syntax",
    "start": "313020",
    "end": "318990"
  },
  {
    "text": "for defining the movie type up on the slide it's got three properties name year and studio now we can construct an",
    "start": "318990",
    "end": "326400"
  },
  {
    "text": "immutable value of the movie type by using the curly braces and assigning a value to all properties now it's not",
    "start": "326400",
    "end": "332280"
  },
  {
    "text": "possible to make a half initialized movie value because it's immutable there'd be no way to set the rest of the",
    "start": "332280",
    "end": "337890"
  },
  {
    "text": "properties after construction to finish initializing it we must assign all the properties now when we want to change",
    "start": "337890",
    "end": "345270"
  },
  {
    "text": "that movie object we can use the curly braces again but this time we put down the name of the value that we want a",
    "start": "345270",
    "end": "351180"
  },
  {
    "text": "copy so in the case up on the slide we're using infinity war and then we're using the width keyword and assigning",
    "start": "351180",
    "end": "356580"
  },
  {
    "text": "any properties that we want to change any properties that we don't put there such as studio I copied from the",
    "start": "356580",
    "end": "363270"
  },
  {
    "text": "infinity war value as is and this is very useful because it means we don't have to manually list all those other",
    "start": "363270",
    "end": "369030"
  },
  {
    "text": "properties then update that code every time we add new properties to that movie type now is all this copying inefficient",
    "start": "369030",
    "end": "378540"
  },
  {
    "text": "in some cases it can be however there are many data structures techniques and technologies that can be used to make",
    "start": "378540",
    "end": "384510"
  },
  {
    "text": "immutability efficient an immutable list is a really good example of a data structure that seems likely to be",
    "start": "384510",
    "end": "390330"
  },
  {
    "text": "inefficient on the surface if we had to copy the whole list every time we wanted to add something to it that would be",
    "start": "390330",
    "end": "395820"
  },
  {
    "text": "very expensive c-sharp lists do do some copying behind the scenes as they grow their internal arrays but most of the",
    "start": "395820",
    "end": "402060"
  },
  {
    "text": "time when you're adding something to one you aren't copying the whole array and you're just mutating a pre-allocated array element",
    "start": "402060",
    "end": "407470"
  },
  {
    "text": "that's quite efficient in FP immutable lists are created using a linked list data structure and this means they can",
    "start": "407470",
    "end": "414370"
  },
  {
    "text": "be both immutable and can allow cheap additions to the list let's see how that works a linked list is actually made up",
    "start": "414370",
    "end": "421120"
  },
  {
    "text": "of two things a single item plus a reference to the rest of the list so",
    "start": "421120",
    "end": "426640"
  },
  {
    "text": "when we start with a list of one the rest of the list reference is not pointing to another list because it's just a list of one thing you can see the",
    "start": "426640",
    "end": "433330"
  },
  {
    "text": "syntax that f-sharp uses to create a list up on the slide it's the square brackets so when we wet let's let's add",
    "start": "433330",
    "end": "440140"
  },
  {
    "text": "one item to that list so we're going to add a B to it to make a list of two things and an f-sharp we can do this",
    "start": "440140",
    "end": "445960"
  },
  {
    "text": "using the cons operator and which is that double colon operator it takes the item that we want to add on the left and",
    "start": "445960",
    "end": "452410"
  },
  {
    "text": "then adds it to a list on the right hand side of the operator and you can see from the diagram that we've now made a",
    "start": "452410",
    "end": "458050"
  },
  {
    "text": "new list with its item part containing the beef and the rest of the list is pointing to a list of one",
    "start": "458050",
    "end": "463870"
  },
  {
    "text": "notice how list of one hasn't been mutated at all it's still the same we've reused it inside our list of two without",
    "start": "463870",
    "end": "470110"
  },
  {
    "text": "changing it it remains immutable and we can do this again this time adding a C to make a",
    "start": "470110",
    "end": "475960"
  },
  {
    "text": "list of three and again list of two is not mutated list of three simply points to a list of two for the rest of the",
    "start": "475960",
    "end": "482350"
  },
  {
    "text": "list and creating a list of four is exactly the same each list reuses the",
    "start": "482350",
    "end": "487630"
  },
  {
    "text": "nodes from the previous list inside itself and doesn't require copying the entire list and this is how we can have",
    "start": "487630",
    "end": "494050"
  },
  {
    "text": "immutability and efficient lists at the same time lists are basically Turtles all the way down now because everything",
    "start": "494050",
    "end": "503890"
  },
  {
    "start": "501000",
    "end": "563000"
  },
  {
    "text": "is immutable we don't have variables in pure functional programming variables imply",
    "start": "503890",
    "end": "509470"
  },
  {
    "text": "that values can vary and immutability will prevent this in FP instead we have",
    "start": "509470",
    "end": "515169"
  },
  {
    "text": "bindings a binding binds a name to a value so up on the slide we can see a",
    "start": "515169",
    "end": "521409"
  },
  {
    "text": "couple of f-sharp bindings where we're using the let keyword to bind the name first name to the value of Steve and the",
    "start": "521409",
    "end": "528370"
  },
  {
    "text": "name surname to the value of Rogers we can also use bindings to define",
    "start": "528370",
    "end": "533560"
  },
  {
    "text": "functions we can see on the slide that the concat name is bound to a function that takes two parameters first and",
    "start": "533560",
    "end": "539860"
  },
  {
    "text": "second and the function body will concur them together now this could be expressed as a regular let binding by",
    "start": "539860",
    "end": "546319"
  },
  {
    "text": "using a lambda function instead so in F sharp the fun keyword and the arrow of how we define a lambda function so you",
    "start": "546319",
    "end": "553369"
  },
  {
    "text": "can see how this now looks very similar to the original let bindings we've got let the name equals the value",
    "start": "553369",
    "end": "559699"
  },
  {
    "text": "which is a function purely and impure",
    "start": "559699",
    "end": "565759"
  },
  {
    "start": "563000",
    "end": "685000"
  },
  {
    "text": "functions other pieces of jargon that you'll hear talked about a lot when it comes to functional programming a pure",
    "start": "565759",
    "end": "571369"
  },
  {
    "text": "function is one that when given the same input will always return the same value every single time as a contrast in pure",
    "start": "571369",
    "end": "579169"
  },
  {
    "text": "functions when given the same input might produce something different this reproducibility of pure functions makes",
    "start": "579169",
    "end": "585619"
  },
  {
    "text": "them much more easy to reason about pure functions also don't mutate their input",
    "start": "585619",
    "end": "591859"
  },
  {
    "text": "values but impure functions might and this means pure functions can be can be",
    "start": "591859",
    "end": "596929"
  },
  {
    "text": "used safely whereas impure functions have to be treated a little bit more carefully because they might unexpectedly modify",
    "start": "596929",
    "end": "603979"
  },
  {
    "text": "what you're passing to them purity and immutability go hand-in-hand pure functions can't mutate anything but they",
    "start": "603979",
    "end": "610339"
  },
  {
    "text": "can calculate new immutable copies of values and return them pure functions",
    "start": "610339",
    "end": "617809"
  },
  {
    "text": "cannot depend upon a global mutable state since this might cause them to change their output given the same input",
    "start": "617809",
    "end": "623720"
  },
  {
    "text": "values since the global state might have changed and now they make a different decision input impure functions have no",
    "start": "623720",
    "end": "630589"
  },
  {
    "text": "such restriction which makes them much more unpredictable and all this means",
    "start": "630589",
    "end": "636019"
  },
  {
    "text": "that pure functions are much simpler and easier to reason about they behave predictably and reproducibly in contrast",
    "start": "636019",
    "end": "642979"
  },
  {
    "text": "impure functions may not to understand how they will behave you have to understand the inner workings and if",
    "start": "642979",
    "end": "648919"
  },
  {
    "text": "they depend upon some shared mutable state you not need to understand all the other code that shares that same mutable",
    "start": "648919",
    "end": "654349"
  },
  {
    "text": "state in order to figure out how that whole mess will interact as I'm sure we've all encountered at some point in a",
    "start": "654349",
    "end": "660139"
  },
  {
    "text": "code base somewhere when this is done poorly it becomes a nightmare to debug and to change safely now that this",
    "start": "660139",
    "end": "668269"
  },
  {
    "text": "reproducibility and simplicity of pure functions makes them trivially easy to test you simply pass in your input",
    "start": "668269",
    "end": "674149"
  },
  {
    "text": "parameters and assert your output there's no need for complicated mutable state to mock manage and reset between",
    "start": "674149",
    "end": "680570"
  },
  {
    "text": "test runs which can often be the case with impure functions so let's look at",
    "start": "680570",
    "end": "687290"
  },
  {
    "start": "685000",
    "end": "832000"
  },
  {
    "text": "an example of a classic impure function in c-sharp this add family members",
    "start": "687290",
    "end": "692540"
  },
  {
    "text": "function will take a family and mutate the mother and father properties on it it also mutates the children list on the",
    "start": "692540",
    "end": "699800"
  },
  {
    "text": "family to add a few extra children it then returns the same family object as was passed in probably to help with some",
    "start": "699800",
    "end": "706490"
  },
  {
    "text": "sort of fluent soil syntax unfortunately this makes it look like it might return a new family but you're not really sure",
    "start": "706490",
    "end": "712580"
  },
  {
    "text": "you'd have to look at the implementation to see that it actually doesn't it just returns what you passed it but it's",
    "start": "712580",
    "end": "717920"
  },
  {
    "text": "mutated it so really it would be better if it returned void because then it'd be obviously to be doing a side-effect but",
    "start": "717920",
    "end": "724370"
  },
  {
    "text": "then you probably wouldn't get your nice fluent syntax so what does a pure version of this function look like turns",
    "start": "724370",
    "end": "731120"
  },
  {
    "text": "out it's very similar but instead of mutating the input family we use F sharps with keyword to make a copy of",
    "start": "731120",
    "end": "736730"
  },
  {
    "text": "the family and then we change the mother father and children properties to new values the children property gets a new",
    "start": "736730",
    "end": "742640"
  },
  {
    "text": "list that immutably adds to the existing children list using that double colon cons operator so here's another example",
    "start": "742640",
    "end": "752660"
  },
  {
    "text": "we've got a new transaction function that takes an amount it returns a brand",
    "start": "752660",
    "end": "757940"
  },
  {
    "text": "new transaction but it reads the current time from daytime to UTC now now UTC now",
    "start": "757940",
    "end": "763400"
  },
  {
    "text": "is a global mutable variable that is constantly changing as it tracks the current time this function also reads",
    "start": "763400",
    "end": "769340"
  },
  {
    "text": "the current user off some global user context now given the same input which",
    "start": "769340",
    "end": "774950"
  },
  {
    "text": "would be the same amount value this function will always return something different and therefore is impure it'd",
    "start": "774950",
    "end": "781400"
  },
  {
    "text": "also be pretty hard to test because date created would always end up as a different value and the user property",
    "start": "781400",
    "end": "786590"
  },
  {
    "text": "would require to set up some global current state before calling the function otherwise you'd end up with a null reference exception as a contrast",
    "start": "786590",
    "end": "794930"
  },
  {
    "text": "here's the pure version instead of reading the global state in the function the pure version of the function takes",
    "start": "794930",
    "end": "800360"
  },
  {
    "text": "that state as arguments and then when we pass that same input we always get the",
    "start": "800360",
    "end": "807140"
  },
  {
    "text": "same result but at the top of your program near where you do your i/o probably in your API",
    "start": "807140",
    "end": "812420"
  },
  {
    "text": "controller or somewhere similar you'd read your global state like the time in the current user context and you pass it",
    "start": "812420",
    "end": "817550"
  },
  {
    "text": "into your pure functions that means all your pure functions are now very easy to test because given the same input values",
    "start": "817550",
    "end": "823910"
  },
  {
    "text": "you always return the same thing you can assert against there's no global state making the return value of your",
    "start": "823910",
    "end": "829520"
  },
  {
    "text": "functions and moving target now purity",
    "start": "829520",
    "end": "834560"
  },
  {
    "start": "832000",
    "end": "904000"
  },
  {
    "text": "immutability and bindings give arrives to a concept called referential transparency now referential",
    "start": "834560",
    "end": "840860"
  },
  {
    "text": "transparency is where you can substitute a binding name for its value and the program still remains the same the name",
    "start": "840860",
    "end": "846680"
  },
  {
    "text": "and the value are effectively interchangeable because the name the value can't be mutated and the name can't be changed to point at a different",
    "start": "846680",
    "end": "853250"
  },
  {
    "text": "value now we can use referential transparency to reason about our program",
    "start": "853250",
    "end": "858440"
  },
  {
    "text": "and effectively execute it by replacing names with values so let's try that out when creating a full name binding so",
    "start": "858440",
    "end": "865220"
  },
  {
    "text": "we're going to conk at the first name and surname values the first substitution we can do is to replace",
    "start": "865220",
    "end": "871070"
  },
  {
    "text": "that concat name with its value so we can literally just replace concat with its value which is that map function so",
    "start": "871070",
    "end": "878900"
  },
  {
    "text": "the next substitution we can do is to call the lambda function by basically just replacing its parameters with",
    "start": "878900",
    "end": "884600"
  },
  {
    "text": "what's being passed as arguments so we're going to replace first and second with first name and surname then we can",
    "start": "884600",
    "end": "893360"
  },
  {
    "text": "substitute the first name and surname names with their values and finally we",
    "start": "893360",
    "end": "898970"
  },
  {
    "text": "can execute our plus operators and get our final string now referential",
    "start": "898970",
    "end": "905990"
  },
  {
    "text": "transparency is very useful when refactoring because it makes it very very easy to extract parts of parts of",
    "start": "905990",
    "end": "912110"
  },
  {
    "text": "functions out as named values whether they be concrete data values or other functions and we can do this safely",
    "start": "912110",
    "end": "918290"
  },
  {
    "text": "because we know referential transparency means that the refactoring is simply a rearrangement of code and it doesn't",
    "start": "918290",
    "end": "924350"
  },
  {
    "text": "actually change the behavior of the code so let's see a contrived example here's some code that's up on the slide that we",
    "start": "924350",
    "end": "930530"
  },
  {
    "text": "all don't understand including myself but thanks to referential transparency we kind of don't need to I don't need to",
    "start": "930530",
    "end": "937400"
  },
  {
    "text": "know what all those functions do under the covers and what all the values are I can extract any expression",
    "start": "937400",
    "end": "942800"
  },
  {
    "text": "out from that piece of code and give it a name and it won't change the result of this program so let's say I want to extract this big chunk out in the middle",
    "start": "942800",
    "end": "949369"
  },
  {
    "text": "and give it a name I can rip it out give it a name say extracted thing then I can",
    "start": "949369",
    "end": "954499"
  },
  {
    "text": "identify what its inputs are make those parameters to the function and then I can just call the new function from the",
    "start": "954499",
    "end": "960739"
  },
  {
    "text": "site of the extraction I'm guaranteed this does not change the program I'm even guaranteed that if I use this new",
    "start": "960739",
    "end": "967040"
  },
  {
    "text": "extracted thing functions somewhere else it'll behave exactly the same and this guarantee is really nice to have when",
    "start": "967040",
    "end": "973189"
  },
  {
    "text": "refactoring now referential transparency only works when your code is pure and immutable if there's impurity and",
    "start": "973189",
    "end": "980480"
  },
  {
    "text": "mutation going on in your code referential transparency doesn't apply so without referential transparency it's",
    "start": "980480",
    "end": "987350"
  },
  {
    "text": "much harder to safely rip out and move chunks of code during refactoring without reading it all very carefully to",
    "start": "987350",
    "end": "992449"
  },
  {
    "text": "make sure that the refactoring won't change something so here's an example we're doing a select off of a list and",
    "start": "992449",
    "end": "998989"
  },
  {
    "text": "we're at we're adding the result of calling get number to each list element if we do a little refactor and we",
    "start": "998989",
    "end": "1005139"
  },
  {
    "text": "extract the call to get number out and we give it its resultant name we've no guarantee that we haven't changed the",
    "start": "1005139",
    "end": "1010660"
  },
  {
    "text": "behavior of this code this is because we don't know if get number returns the same value every time because it's",
    "start": "1010660",
    "end": "1016809"
  },
  {
    "text": "impure if it returns something different we've just broken this code now if",
    "start": "1016809",
    "end": "1022119"
  },
  {
    "text": "everything was immutable and pure get number would always be returning the same number because it's always being",
    "start": "1022119",
    "end": "1027370"
  },
  {
    "text": "passed the same thing which is nothing and this would be a safe refactoring that wouldn't change behavior thanks to",
    "start": "1027370",
    "end": "1033909"
  },
  {
    "text": "referential transparency sorry you may",
    "start": "1033909",
    "end": "1041860"
  },
  {
    "start": "1039000",
    "end": "1116000"
  },
  {
    "text": "have heard the functions as first-class values soundbite before maybe even at the beginning of this very presentation",
    "start": "1041860",
    "end": "1047589"
  },
  {
    "text": "what it actually means is very very simple it's basically saying you can treat a function just like any other",
    "start": "1047589",
    "end": "1053740"
  },
  {
    "text": "value in the language and this means being able to assign it to a variable in a mutable language or name it with a",
    "start": "1053740",
    "end": "1058990"
  },
  {
    "text": "binding and an immutable one in fact we've already seen an example of that with our concat function from before now",
    "start": "1058990",
    "end": "1065940"
  },
  {
    "text": "being a first-class value functions must be able to be passed to other functions and returned from them so the only odds",
    "start": "1065940",
    "end": "1073299"
  },
  {
    "text": "binding that's up on the slide is an example of passing a function as an argument we're passing",
    "start": "1073299",
    "end": "1078430"
  },
  {
    "text": "that is odd function to the list filter function as an argument the list filter function will then use it to filter the",
    "start": "1078430",
    "end": "1084760"
  },
  {
    "text": "list down to only odd numbers first class values should also be able to re",
    "start": "1084760",
    "end": "1090520"
  },
  {
    "text": "returned from functions so the list filter or function is an example of a function that itself returns another",
    "start": "1090520",
    "end": "1097060"
  },
  {
    "text": "function and that function will take a list and filter it using that predicate function that was initially provided",
    "start": "1097060",
    "end": "1104100"
  },
  {
    "text": "functions as first-class values are very common in modern programming languages c-sharp JavaScript C++ F sharp they all",
    "start": "1104100",
    "end": "1111610"
  },
  {
    "text": "have this core functional programming characteristic now if the term currying",
    "start": "1111610",
    "end": "1120280"
  },
  {
    "start": "1116000",
    "end": "1247000"
  },
  {
    "text": "makes you think of a delicious meal and not functional programming then this slide is for you the simplest form of a",
    "start": "1120280",
    "end": "1127300"
  },
  {
    "text": "function is one that will take a single input parameter and return a single output result so the type signature for",
    "start": "1127300",
    "end": "1135100"
  },
  {
    "text": "such a function is up on the slide this function takes an integer and returns a",
    "start": "1135100",
    "end": "1140260"
  },
  {
    "text": "string currying a function is the process of taking a multi-parameter",
    "start": "1140260",
    "end": "1145360"
  },
  {
    "text": "function and changing it so that it is in this simplest form a function taking a single parameter and returning a",
    "start": "1145360",
    "end": "1152050"
  },
  {
    "text": "single result so let's take a look at the example of an add function the add",
    "start": "1152050",
    "end": "1157240"
  },
  {
    "text": "function takes two integer parameters so obviously that's not its simplest form because it takes two things not one",
    "start": "1157240",
    "end": "1162730"
  },
  {
    "text": "thing we needed to take one thing so let's take a look at the type signature",
    "start": "1162730",
    "end": "1167830"
  },
  {
    "text": "of the curried version of the add function we can see that it now takes a single parameter it takes one integer",
    "start": "1167830",
    "end": "1174750"
  },
  {
    "text": "however it returns one thing and that thing is another function and that",
    "start": "1174750",
    "end": "1179860"
  },
  {
    "text": "function takes the second integer and it returns the result now in F sharp all",
    "start": "1179860",
    "end": "1188650"
  },
  {
    "text": "functions are carried by default so our let add XY function is actually shorthand for this add function where",
    "start": "1188650",
    "end": "1197320"
  },
  {
    "text": "you can explicitly see that the add name is actually a function that takes a single X that returns a function that",
    "start": "1197320",
    "end": "1204820"
  },
  {
    "text": "takes the Y that then adds the x and y together and returns the result",
    "start": "1204820",
    "end": "1210510"
  },
  {
    "text": "now in that function type of signature we don't usually show those parentheses that are there we usually write the type",
    "start": "1210730",
    "end": "1218390"
  },
  {
    "text": "signatures without them and this is because those function arrow operators are right associative which means the the brackets go around the right the the",
    "start": "1218390",
    "end": "1225200"
  },
  {
    "text": "second and the third integers if it was left associative there'd be around the first and the second ends now the",
    "start": "1225200",
    "end": "1232070"
  },
  {
    "text": "currying name if you're wondering where that came from comes from an American mathematician named Haskell curry and it's not the",
    "start": "1232070",
    "end": "1237500"
  },
  {
    "text": "food unfortunately the programming language Haskell was also named after curry and courier was best known for his",
    "start": "1237500",
    "end": "1243560"
  },
  {
    "text": "work in combinatorial logic partial",
    "start": "1243560",
    "end": "1248930"
  },
  {
    "start": "1247000",
    "end": "1302000"
  },
  {
    "text": "application uses curried functions in order to partially call a function and",
    "start": "1248930",
    "end": "1254110"
  },
  {
    "text": "this means you can call a function and not pass all the parameters and you will thanks to careen get back a function",
    "start": "1254110",
    "end": "1261350"
  },
  {
    "text": "that returns that will take the remainder of those parameters so let's look at the example of our add function",
    "start": "1261350",
    "end": "1266840"
  },
  {
    "text": "again we can call it normally with two parameters like two and three and we'll get back the value of five but we can we",
    "start": "1266840",
    "end": "1274880"
  },
  {
    "text": "can only call it with a single parameter as well like just one and we'll get back",
    "start": "1274880",
    "end": "1280280"
  },
  {
    "text": "a function that takes the second parameter and adds one to it so by partially applying the add function",
    "start": "1280280",
    "end": "1286100"
  },
  {
    "text": "we've actually built ourselves a little increment function and these partially applied functions like the increment",
    "start": "1286100",
    "end": "1292280"
  },
  {
    "text": "function are just like any other function there's nothing special about them so we can call it with this a value",
    "start": "1292280",
    "end": "1297740"
  },
  {
    "text": "of two and we'll get back a three now",
    "start": "1297740",
    "end": "1303980"
  },
  {
    "start": "1302000",
    "end": "1549000"
  },
  {
    "text": "partial application is very useful because what it lets us do is compose functions together in nice readable ways",
    "start": "1303980",
    "end": "1309610"
  },
  {
    "text": "so let's work through an example where we'll create a list of numbers from one to ten and we'll filter that down to",
    "start": "1309610",
    "end": "1315590"
  },
  {
    "text": "only odd numbers and then we'll convert all of those numbers into streams so",
    "start": "1315590",
    "end": "1320930"
  },
  {
    "text": "let's start by creating a list from 1 to 10 so the square brackets remember is how we create a lists in F sharp and the",
    "start": "1320930",
    "end": "1327050"
  },
  {
    "text": "dot dot gives us the range of numbers from 1 to 10 so the first thing we're going to do is we're going to partially",
    "start": "1327050",
    "end": "1333080"
  },
  {
    "text": "apply the list filter function with the is odd function to create a filter by odds function so let's look at how this",
    "start": "1333080",
    "end": "1339590"
  },
  {
    "text": "works in detail we can see the type signature on the slide the filter function it takes the",
    "start": "1339590",
    "end": "1345450"
  },
  {
    "text": "predicate function a to ball and what that little function is going to do is check each a and see whether it's",
    "start": "1345450",
    "end": "1350610"
  },
  {
    "text": "something we want to keep so true or false the second parameter it's going to take is the list of A's that we want to",
    "start": "1350610",
    "end": "1356160"
  },
  {
    "text": "filter and it's going to return the filter list of A's now when we pass that",
    "start": "1356160",
    "end": "1363300"
  },
  {
    "text": "is odd function we're going to make those generic type parameters concrete so the a becomes the int now we've only",
    "start": "1363300",
    "end": "1374460"
  },
  {
    "text": "passed one parameter to this two parameter function so what we're going to get back we're going to be partially",
    "start": "1374460",
    "end": "1379950"
  },
  {
    "text": "applying it we're going to get back a function that takes a list of int and returns a list of int so it's going to",
    "start": "1379950",
    "end": "1385980"
  },
  {
    "text": "take the list we want to filter filter it by only odd numbers and return a new list so the next thing we can do is",
    "start": "1385980",
    "end": "1396510"
  },
  {
    "text": "create a convert list to strings function and we're going to do that by using the list map function and we're",
    "start": "1396510",
    "end": "1403200"
  },
  {
    "text": "going to partially apply it with the to string function so the map function is like a link select so by only passing",
    "start": "1403200",
    "end": "1411900"
  },
  {
    "text": "that to string function to the list map function we're going to get back at the rest of the function so that the",
    "start": "1411900",
    "end": "1417540"
  },
  {
    "text": "parameters that we didn't apply there and that function is now going to convert a list of intz into a list of",
    "start": "1417540",
    "end": "1423180"
  },
  {
    "text": "strings for us let's walk through how that works so on the bottom of the slide we can see a type signature so the the",
    "start": "1423180",
    "end": "1430350"
  },
  {
    "text": "top line there would be the type signature for map we can see the first parameter is a function that will convert an A into a B so that's our",
    "start": "1430350",
    "end": "1437160"
  },
  {
    "text": "mapping function the second parameter is a list of a's and it's going to return a list of b so it's going to convert each",
    "start": "1437160",
    "end": "1442920"
  },
  {
    "text": "a and the list into a b and return it so when we pass our two string function",
    "start": "1442920",
    "end": "1449970"
  },
  {
    "text": "we're going to make those type parameters concrete so a becomes int and b becomes stream then because we're only",
    "start": "1449970",
    "end": "1456990"
  },
  {
    "text": "passing one parameter we're going to get back a function that takes the rest of them so now we're getting back a",
    "start": "1456990",
    "end": "1462270"
  },
  {
    "text": "function that takes a list of int and will return us a list of strings so now",
    "start": "1462270",
    "end": "1469470"
  },
  {
    "text": "we've got our convert list two strings function we can compose all of the three things together that we've got now using",
    "start": "1469470",
    "end": "1474990"
  },
  {
    "text": "the pipe operator which is piping greater than operator up on the slide and this pipeline operator is",
    "start": "1474990",
    "end": "1480600"
  },
  {
    "text": "going to call the function on the right hand side of the operator with the value on the left so it's basically feeding",
    "start": "1480600",
    "end": "1486720"
  },
  {
    "text": "the result of the left into the thing on the right and this allows us to easily read the code from left to right you can",
    "start": "1486720",
    "end": "1493559"
  },
  {
    "text": "think of it a little bit like a UNIX primer so what we're going to do is we're going to feed our list of 1 to 10",
    "start": "1493559",
    "end": "1499289"
  },
  {
    "text": "into our filter by odds function we're going to take the output of that function and we're going to feed it into convert list of strings function and",
    "start": "1499289",
    "end": "1506009"
  },
  {
    "text": "then finally we're going to get back our list of odd-numbered strings now we've",
    "start": "1506009",
    "end": "1512249"
  },
  {
    "text": "written this out extremely verbose ly so that we can walk through that partial application very carefully but in",
    "start": "1512249",
    "end": "1517409"
  },
  {
    "text": "practice we'd write the code like this new snippet at the bottom left of the slide so we can see partial application",
    "start": "1517409",
    "end": "1525299"
  },
  {
    "text": "allows us this nice readable style that is very reminiscent of fluent style syntax in c-sharp except that we can do",
    "start": "1525299",
    "end": "1531480"
  },
  {
    "text": "it anywhere with any functions and not just the extension methods that happen to have been provided for a particular",
    "start": "1531480",
    "end": "1536580"
  },
  {
    "text": "type partial application and function composition is one of the reasons why",
    "start": "1536580",
    "end": "1541950"
  },
  {
    "text": "functional programming makes it really easy to write code that composes together in Nice readable ways now let's",
    "start": "1541950",
    "end": "1551730"
  },
  {
    "start": "1549000",
    "end": "1638000"
  },
  {
    "text": "switch gears and talk about algebraic data types algebraic data types are named after their basis in mathematics",
    "start": "1551730",
    "end": "1558509"
  },
  {
    "text": "but that doesn't mean they're complicated if you know addition and multiplication you'll be on board there are two types",
    "start": "1558509",
    "end": "1565230"
  },
  {
    "text": "of algebraic data types product types and some types let's first look at product types product types are those",
    "start": "1565230",
    "end": "1572009"
  },
  {
    "text": "that are made up of multiple values multiple other types and values at the same time you can think of them as like",
    "start": "1572009",
    "end": "1578460"
  },
  {
    "text": "an end of types so record types are product types and tuples are also",
    "start": "1578460",
    "end": "1584249"
  },
  {
    "text": "product types so in any instance of the my record product type that's up on the slide we have a bite a ball and a second",
    "start": "1584249",
    "end": "1591960"
  },
  {
    "text": "ball now they're called product types because the total number of possible values of a product type is the product",
    "start": "1591960",
    "end": "1599399"
  },
  {
    "text": "or the multiplication of its parts so for my record product type it can have a thousand and twenty four possible values",
    "start": "1599399",
    "end": "1605549"
  },
  {
    "text": "because a byte has 256 possible values and a ball can have two all values so 256 by two by two is a",
    "start": "1605549",
    "end": "1613350"
  },
  {
    "text": "thousand and 24 and this is why the syntax for tuples in f-sharp uses that star operator like you can see for that",
    "start": "1613350",
    "end": "1620640"
  },
  {
    "text": "my tuple product type because tuples are product x so here's what it looks like",
    "start": "1620640",
    "end": "1627330"
  },
  {
    "text": "to create a record type and a tuple in F sharp and we've seen it before it's pretty simple remember that we must set",
    "start": "1627330",
    "end": "1632700"
  },
  {
    "text": "all those properties upfront because these things are immutable",
    "start": "1632700",
    "end": "1636919"
  },
  {
    "start": "1638000",
    "end": "1760000"
  },
  {
    "text": "product types are kind of normal you can make something that looks like them in pretty much every language but some",
    "start": "1639590",
    "end": "1646169"
  },
  {
    "text": "types of something that aren't widely available outside of fp' languages some",
    "start": "1646169",
    "end": "1651360"
  },
  {
    "text": "types let us define a choice between other types you can think of them as the",
    "start": "1651360",
    "end": "1656880"
  },
  {
    "text": "or of types so while product types were this and that some types are this or that F",
    "start": "1656880",
    "end": "1665400"
  },
  {
    "text": "sharps version of some types are called discriminated unions on the slide we can see a definition of a discriminated",
    "start": "1665400",
    "end": "1671880"
  },
  {
    "text": "union called my some type it defines three alternatives a bite a ball and another ball now some types are called",
    "start": "1671880",
    "end": "1680100"
  },
  {
    "text": "some types because the total number of possible values of a particular some type is made by adding up so summing the",
    "start": "1680100",
    "end": "1688049"
  },
  {
    "text": "number of possible values of its parts so in my some types case it has 260",
    "start": "1688049",
    "end": "1693840"
  },
  {
    "text": "possible values because a byte has 256 possible values and a ball has two so",
    "start": "1693840",
    "end": "1699059"
  },
  {
    "text": "256 plus two plus two is 260 now some",
    "start": "1699059",
    "end": "1704520"
  },
  {
    "text": "types are super useful at modeling a closed set of alternatives so here's an example of using an F sharp match",
    "start": "1704520",
    "end": "1710520"
  },
  {
    "text": "expression to determine at run time which alternative we have at hand and you can think of a match like a very",
    "start": "1710520",
    "end": "1715860"
  },
  {
    "text": "fancy switch statement so what's great about some types is that if you add another alternative to them later the",
    "start": "1715860",
    "end": "1722880"
  },
  {
    "text": "compiler will admit warnings that all the places in the code where you need to add new code to handle that new alternative and that's really good for",
    "start": "1722880",
    "end": "1729390"
  },
  {
    "text": "code maintainability here's how we create values of this sum type we can",
    "start": "1729390",
    "end": "1736020"
  },
  {
    "text": "use those case constructor names and pass them what they contain and so for example we create value 1 by passing 120",
    "start": "1736020",
    "end": "1743460"
  },
  {
    "text": "a bight constructor and we create value to by passing false to a ball",
    "start": "1743460",
    "end": "1748950"
  },
  {
    "text": "constructor so to create a value of my sum type we must use one of those constructors and that's how we pick",
    "start": "1748950",
    "end": "1754440"
  },
  {
    "text": "between which alternative we want when we create values so let's talk about",
    "start": "1754440",
    "end": "1762510"
  },
  {
    "start": "1760000",
    "end": "1839000"
  },
  {
    "text": "value semantics types behave with value semantics when two different instances of the same value can be compared for",
    "start": "1762510",
    "end": "1769770"
  },
  {
    "text": "equality so for example in c-sharp strings and integers have value",
    "start": "1769770",
    "end": "1774870"
  },
  {
    "text": "semantics you can have two instances of the same string in memory but if they're compared with equals they're considered",
    "start": "1774870",
    "end": "1780870"
  },
  {
    "text": "to be the same however in c-sharp we need to find new classes they behaviour",
    "start": "1780870",
    "end": "1786149"
  },
  {
    "text": "of reference semantics and not with value semantics and this means you can't compare two instances of a class with",
    "start": "1786149",
    "end": "1791760"
  },
  {
    "text": "same values in its properties and see if they're the same if we look at the example up on the slide we've got a",
    "start": "1791760",
    "end": "1796919"
  },
  {
    "text": "class that defines a first name and a surname property and if I make two instances with the same names and",
    "start": "1796919",
    "end": "1802080"
  },
  {
    "text": "compare them with equals they'll be considered to be in equal and this is because reference semantics are enforced",
    "start": "1802080",
    "end": "1807899"
  },
  {
    "text": "these are two different instances in memory so they're considered to be different",
    "start": "1807899",
    "end": "1813080"
  },
  {
    "text": "unfortunately in c-sharp it's kind of difficult to get value semantics for classes you need to override equals and",
    "start": "1813080",
    "end": "1819270"
  },
  {
    "text": "the two equality operators override get hash code and implement I equatable and worse you need to maintain that",
    "start": "1819270",
    "end": "1826140"
  },
  {
    "text": "implementation so that if someone adds a property they need to be very careful that they update their comparisons and",
    "start": "1826140",
    "end": "1831419"
  },
  {
    "text": "in their equals implementation and also in there get hash code because if they don't you're going to end up with a very",
    "start": "1831419",
    "end": "1836490"
  },
  {
    "text": "subtle bug enough sharp you get value",
    "start": "1836490",
    "end": "1841770"
  },
  {
    "text": "semantics for free on both your record and Union types so if we define a full",
    "start": "1841770",
    "end": "1847169"
  },
  {
    "text": "name record type create two instances with the same values we can compare them for quality for free and the compiler",
    "start": "1847169",
    "end": "1853260"
  },
  {
    "text": "will generate the necessary comparison code for us and keep it up to date as we add and remove properties so where is",
    "start": "1853260",
    "end": "1860460"
  },
  {
    "text": "value semantics useful well tests become trivially easy to write because you can",
    "start": "1860460",
    "end": "1865980"
  },
  {
    "text": "simply compare entire data structures for equality there's no need for manually asserting each property or",
    "start": "1865980",
    "end": "1871440"
  },
  {
    "text": "using reflection to make some sort of deep equals function so if we look at the example we've got",
    "start": "1871440",
    "end": "1877110"
  },
  {
    "text": "on the slide we can imagine we're writing a test for some sort of named generator function that takes a list of first names and a list of surnames and",
    "start": "1877110",
    "end": "1883890"
  },
  {
    "text": "we want to make sure that it's generating the the rightful memes we can generate the names by calling the",
    "start": "1883890",
    "end": "1889470"
  },
  {
    "text": "function and then we can simply do an equality comparison on the expected list of names f-sharp lists created by using",
    "start": "1889470",
    "end": "1895890"
  },
  {
    "text": "those square brackets have value semantics as well so you can compare two lists for equality just by using equals",
    "start": "1895890",
    "end": "1902220"
  },
  {
    "text": "in other languages you might need to assert the list length and then each item in the list and/or resort to a",
    "start": "1902220",
    "end": "1908760"
  },
  {
    "text": "library that does that for you in F sharp and other functional languages value semantics makes it super easy to",
    "start": "1908760",
    "end": "1914970"
  },
  {
    "text": "just assert that an expected result equals an actual result in your test just by using equals and that's it now",
    "start": "1914970",
    "end": "1926309"
  },
  {
    "start": "1925000",
    "end": "2146000"
  },
  {
    "text": "in imperative languages doing something repeatedly requires writing a 4 or a while loop these loops by definition",
    "start": "1926309",
    "end": "1933150"
  },
  {
    "text": "mutate state let's take a look at a simple snippet of code that sums up integers in an array we use a basic for",
    "start": "1933150",
    "end": "1940500"
  },
  {
    "text": "loop and each time around the loop we mutate the value of index and we accumulate the sum by mutating the value",
    "start": "1940500",
    "end": "1946380"
  },
  {
    "text": "of the sum variable and this mutation is what allows us to maintain the state of our loop so if looping requires mutation",
    "start": "1946380",
    "end": "1954299"
  },
  {
    "text": "how do we loop in a functional language we're immutability is king and the answer is that we use recursion",
    "start": "1954299",
    "end": "1960890"
  },
  {
    "text": "recursion is where a function invokes itself over and over until eventually it",
    "start": "1960890",
    "end": "1966390"
  },
  {
    "text": "stops and that over and over aspect is what makes it a suitable substitution",
    "start": "1966390",
    "end": "1971429"
  },
  {
    "text": "for immutable loops so let's look at how we could implement summing using",
    "start": "1971429",
    "end": "1977040"
  },
  {
    "text": "recursion instead on the slide we've implemented a recursive function in F sharp called sum let rec are the",
    "start": "1977040",
    "end": "1984179"
  },
  {
    "text": "keywords that we use to tell the compiler that this will be a recursive function so the parameters of the",
    "start": "1984179",
    "end": "1989730"
  },
  {
    "text": "function are the array and the index value the body of the function simply",
    "start": "1989730",
    "end": "1995160"
  },
  {
    "text": "checks to see whether the index value has passed the end of the array if it hasn't we're going to read that current",
    "start": "1995160",
    "end": "2000830"
  },
  {
    "text": "array element and we're going to add it to the number returned from recursively calling ourselves but when we",
    "start": "2000830",
    "end": "2007490"
  },
  {
    "text": "recursively call sum we pass the next index and this is the important part unlike",
    "start": "2007490",
    "end": "2013460"
  },
  {
    "text": "normal lips where we used mutation to maintain state when doing recursion we passed this new state forward into the",
    "start": "2013460",
    "end": "2020299"
  },
  {
    "text": "next recursive call and this way we can change state without mutating anything",
    "start": "2020299",
    "end": "2026049"
  },
  {
    "text": "now eventually that index will fall outside the array and we need to stop recursively calling ourselves so at that",
    "start": "2026049",
    "end": "2032779"
  },
  {
    "text": "point we just return zero every recursive algorithm has this particular feature a branch where under some",
    "start": "2032779",
    "end": "2039230"
  },
  {
    "text": "condition we will stop recurring because if we don't we'll end up with an infinite loop so let's see how this",
    "start": "2039230",
    "end": "2045980"
  },
  {
    "text": "evaluates on the right hand side of the slide you can start we're going to start the first call by passing in the zero",
    "start": "2045980",
    "end": "2051770"
  },
  {
    "text": "index and an array of numbers from 1 to 3 so that syntax with the square brackets in the and the bar is how we",
    "start": "2051770",
    "end": "2057530"
  },
  {
    "text": "create an array in F sharp the first step will give us 1 plus the recursive",
    "start": "2057530",
    "end": "2063260"
  },
  {
    "text": "call to the next step and you can see that the index we're going to pass to that recursive call is 0 plus 1 I'm",
    "start": "2063260",
    "end": "2069290"
  },
  {
    "text": "going to use colors on the slides you can keep track of these recursive calls so the blue step is going to result in 1",
    "start": "2069290",
    "end": "2075290"
  },
  {
    "text": "plus 2 plus another recursive call and this gets a new index of 1 plus 1 and this results in 1 plus 3 1 plus 2 Plus 3",
    "start": "2075290",
    "end": "2082368"
  },
  {
    "text": "plus another recursive call and the index past of that will be 2 plus 1 now",
    "start": "2082369",
    "end": "2089179"
  },
  {
    "text": "that recursive call is going to hit the end of the array so it's going to stop recurring and it's just going to return a 0 so we end up with 1 plus 2 Plus 3",
    "start": "2089179",
    "end": "2096169"
  },
  {
    "text": "plus 0 which gives us our value of 6 so",
    "start": "2096169",
    "end": "2101990"
  },
  {
    "text": "see how we've been able to perform a loop without any mutation at all that's pretty neat now there's a few practical",
    "start": "2101990",
    "end": "2108559"
  },
  {
    "text": "issues with this particular implementation but we'll resolve those in future slides recursion as a concept",
    "start": "2108559",
    "end": "2117589"
  },
  {
    "text": "is not just used for in functions it's also useful in data structures in fact we've seen a recursive data structure",
    "start": "2117589",
    "end": "2124309"
  },
  {
    "text": "before the immutable linked list now just like that dudes gin you can see a",
    "start": "2124309",
    "end": "2129710"
  },
  {
    "text": "repeating repeating structure in this linked list the linked list will contain itself until at some point it stops just",
    "start": "2129710",
    "end": "2137240"
  },
  {
    "text": "like our sum algorithm so to work with these sorts of immutable recursive data structures in FP we use recursive",
    "start": "2137240",
    "end": "2144330"
  },
  {
    "text": "of algorithms so let's look at our sum function again but this time we're going",
    "start": "2144330",
    "end": "2150300"
  },
  {
    "start": "2146000",
    "end": "2273000"
  },
  {
    "text": "to use an immutable list instead of an array so on the slide we've defined a",
    "start": "2150300",
    "end": "2155820"
  },
  {
    "text": "sum function that takes a list our function uses a match expression to",
    "start": "2155820",
    "end": "2160950"
  },
  {
    "text": "inspect the structure of the list and this is where F sharp match expressions become much more powerful than switch",
    "start": "2160950",
    "end": "2166950"
  },
  {
    "text": "statements they can decompose data structures into their parts so in this",
    "start": "2166950",
    "end": "2172470"
  },
  {
    "text": "example we have two cases in the first where matching against a list that has an element which we're calling the head",
    "start": "2172470",
    "end": "2178890"
  },
  {
    "text": "and the rest of the list which we're calling the tail remember the structure of a list it's made up of an element and",
    "start": "2178890",
    "end": "2184800"
  },
  {
    "text": "a reference to another list so head is the element and tail is that other list in the second case we're simply matching",
    "start": "2184800",
    "end": "2192000"
  },
  {
    "text": "the empty list which will indicate the end of the list so in the first case we're going to add that head that head",
    "start": "2192000",
    "end": "2198780"
  },
  {
    "text": "value to the value returned from the recursive call to ourselves now when we call ourselves we're going to pass in",
    "start": "2198780",
    "end": "2204840"
  },
  {
    "text": "the tail of the list and this means the next iteration of the recursion will pick the head off the tail which is",
    "start": "2204840",
    "end": "2211230"
  },
  {
    "text": "effectively the second element in the list and so on and so forth and that recursive looping will continue until",
    "start": "2211230",
    "end": "2216660"
  },
  {
    "text": "the end of the list where upon which will stop recurring and we'll just return zero so let's look at the",
    "start": "2216660",
    "end": "2224220"
  },
  {
    "text": "execution of this function on the right hand side of the slide we're going to call the function with a list of numbers",
    "start": "2224220",
    "end": "2229440"
  },
  {
    "text": "from 1 to 3 in fact this square bracket syntax is just shorthand for this longer syntax on",
    "start": "2229440",
    "end": "2235920"
  },
  {
    "text": "the second line here so when we write the list out this way we're using that double colon cons operator we can see",
    "start": "2235920",
    "end": "2241770"
  },
  {
    "text": "that recursive structure more easily so in the first step we decompose the head",
    "start": "2241770",
    "end": "2246840"
  },
  {
    "text": "off the list which is 1 and we add it to the recursive call to sum and we're going to pass in the rest of the list so",
    "start": "2246840",
    "end": "2253950"
  },
  {
    "text": "that would be our two cons 3 cons empty list and we're going to do it again and again until eventually we hit the end of",
    "start": "2253950",
    "end": "2262350"
  },
  {
    "text": "the list in which case we're going to return 0 then we've got 1 + 2 + 3 + 0",
    "start": "2262350",
    "end": "2267780"
  },
  {
    "text": "and that equals 6",
    "start": "2267780",
    "end": "2271220"
  },
  {
    "text": "let's take a look at another function we can write recursively the filter",
    "start": "2273880",
    "end": "2279589"
  },
  {
    "text": "function and it's going to take a predicate as its first parameter which is itself a function that will take a",
    "start": "2279589",
    "end": "2285200"
  },
  {
    "text": "list item and figure out whether or not it's something we want to keep the second parameter of course is going to",
    "start": "2285200",
    "end": "2290960"
  },
  {
    "text": "be the list we want to filter so the implementation is actually quite similar to some we're going to match on that",
    "start": "2290960",
    "end": "2296839"
  },
  {
    "text": "list to extract the head element and the tail of the list then we're going to use the predicate function to see if that",
    "start": "2296839",
    "end": "2303049"
  },
  {
    "text": "head value is something we actually want to keep if it is something we want to keep what we're going to do is we're going to add it to the front of the list",
    "start": "2303049",
    "end": "2309410"
  },
  {
    "text": "that's returned by calling ourselves recursively and we're going to pass the tail into that recursive call now if",
    "start": "2309410",
    "end": "2315890"
  },
  {
    "text": "it's not something we want to keep we're just going to ignore it drop it on the floor and do a recursive call directly",
    "start": "2315890",
    "end": "2321140"
  },
  {
    "text": "and just return whatever that returns so",
    "start": "2321140",
    "end": "2326390"
  },
  {
    "text": "let's see how this executes oh and I should say at the end of the list we just return an empty list so on the",
    "start": "2326390",
    "end": "2332660"
  },
  {
    "text": "right hand side we're gonna see how we execute this algorithm so we're going to call the filter function and again we're going to expand that list syntax list",
    "start": "2332660",
    "end": "2339619"
  },
  {
    "text": "syntax out so that we can see that recursive structure so the first call is",
    "start": "2339619",
    "end": "2344960"
  },
  {
    "text": "going to result in one and we're going to keep it because it's an odd number and we're going to add it to the front of the list that's returned by calling",
    "start": "2344960",
    "end": "2351470"
  },
  {
    "text": "filter again so that's that double colon cons operator so you can see we're passing the tail into that recursive",
    "start": "2351470",
    "end": "2357980"
  },
  {
    "text": "call so the tail being two cons three cons empty lists so the next step is",
    "start": "2357980",
    "end": "2363470"
  },
  {
    "text": "going to drop to because it's not int it's not sorry it's not an odd number so we're going to just keep the same we're",
    "start": "2363470",
    "end": "2369710"
  },
  {
    "text": "gonna have one constitute the recursive call but now you can see we've got another tail the next tail which is just",
    "start": "2369710",
    "end": "2375319"
  },
  {
    "text": "three cons empty list another call we're going to end up with one cons three cons",
    "start": "2375319",
    "end": "2380539"
  },
  {
    "text": "filter and filtering on the empty list now and that is going to return the",
    "start": "2380539",
    "end": "2386630"
  },
  {
    "text": "empty list so now we end up with a list of two items one and three which are all our odd numbers and that's pretty cool",
    "start": "2386630",
    "end": "2395019"
  },
  {
    "text": "now I mentioned there was a slight problem with these recursive algorithms let's see how they execute on the stack",
    "start": "2395440",
    "end": "2402289"
  },
  {
    "text": "so here's the sum function again and we can see the the first function call in that first duck frame so we're going",
    "start": "2402289",
    "end": "2408710"
  },
  {
    "text": "to call into the first recursive step and the next and the next and the next until eventually we get to the end and",
    "start": "2408710",
    "end": "2415190"
  },
  {
    "text": "we're going to pop back down the stack returning as we go and eventually we get our value of six",
    "start": "2415190",
    "end": "2420819"
  },
  {
    "text": "now unfortunately as you can see the depth of the stack scales with the size",
    "start": "2420819",
    "end": "2426259"
  },
  {
    "text": "of the list that we're carrying over I love that gift man so good this is",
    "start": "2426259",
    "end": "2432499"
  },
  {
    "text": "obviously a problem because if we have massive lists we could very easily blow",
    "start": "2432499",
    "end": "2437869"
  },
  {
    "text": "our stack and get a stack overflow exception and that's obviously not something we want so when you call",
    "start": "2437869",
    "end": "2445849"
  },
  {
    "start": "2443000",
    "end": "2589000"
  },
  {
    "text": "functions normally the stack is used to keep the value of your variables so that when you return from a function call you",
    "start": "2445849",
    "end": "2451999"
  },
  {
    "text": "can continue from where you left off now if you look at the definition of the sum function that's up on the slide you can",
    "start": "2451999",
    "end": "2458869"
  },
  {
    "text": "see that after we do our recursive call to sum and we return from it we're adding the head to that accumulated",
    "start": "2458869",
    "end": "2464450"
  },
  {
    "text": "value that we get back from the recursive call and we're returning that so we're using stack space to store that",
    "start": "2464450",
    "end": "2470119"
  },
  {
    "text": "value of the head so that is therefore when we get back from our recursive call so that we can add it to the result and",
    "start": "2470119",
    "end": "2475339"
  },
  {
    "text": "return it so how can we avoid using the stack to store state during our",
    "start": "2475339",
    "end": "2480769"
  },
  {
    "text": "recursive call and therefore prevent stack overflows and the answer to that is to use a specific type of recursion",
    "start": "2480769",
    "end": "2486950"
  },
  {
    "text": "called tail recursion and this is a type of occasion that can be optimized by the compiler and runtime to use no stack",
    "start": "2486950",
    "end": "2493609"
  },
  {
    "text": "space tarek tail recursive function is one that will simply return the result of a",
    "start": "2493609",
    "end": "2500059"
  },
  {
    "text": "recursive call in other words it does no work after the function call returns so",
    "start": "2500059",
    "end": "2505519"
  },
  {
    "text": "let's see how we could rewrite our sum function using tear occasion so this new",
    "start": "2505519",
    "end": "2510680"
  },
  {
    "text": "tail sum function on the right hand side here takes a new accumulation parameter and it does the same pattern match that",
    "start": "2510680",
    "end": "2517519"
  },
  {
    "text": "we did on the list before so we extract that head off the list and have the tail but this time we add the value of the",
    "start": "2517519",
    "end": "2524150"
  },
  {
    "text": "head to the value of that new accumulation parameter and we pass that to the recursive call to tail some along",
    "start": "2524150",
    "end": "2529400"
  },
  {
    "text": "with the tail of the list and the value of this recursive call is immediately returned and you can see that no work is",
    "start": "2529400",
    "end": "2535880"
  },
  {
    "text": "being done after the recursive call at all we just return its result directly and what this means is that any state",
    "start": "2535880",
    "end": "2542600"
  },
  {
    "text": "that we're storing on the stack is not required after we've done that recursive call because we're not doing any more",
    "start": "2542600",
    "end": "2547670"
  },
  {
    "text": "work after it and this allows the compiler and the runtime to perform a tail call optimization where either that",
    "start": "2547670",
    "end": "2554000"
  },
  {
    "text": "recursion is rewritten into a loop by the compiler or the runtime will perform a tail call instead of a regular call",
    "start": "2554000",
    "end": "2560030"
  },
  {
    "text": "and a tail call will just overwrite the current stack frame so that the stack doesn't grow now I'll tell some function",
    "start": "2560030",
    "end": "2567260"
  },
  {
    "text": "now has this extra parameter honor that our calls don't really care about so we usually nest this function inside",
    "start": "2567260",
    "end": "2572870"
  },
  {
    "text": "another function and seed that accumulation so you can see that we're seeding the accumulation with a",
    "start": "2572870",
    "end": "2578660"
  },
  {
    "text": "parameter we're seeding it with a value of 0 so in that first iteration of the recursion we'll be adding our list head",
    "start": "2578660",
    "end": "2585080"
  },
  {
    "text": "to 0 let's see what tail recursion looks",
    "start": "2585080",
    "end": "2591470"
  },
  {
    "text": "like on the stack so we start with calling our sum function with a list of 1 2 3 and this is going to call tail sum",
    "start": "2591470",
    "end": "2599030"
  },
  {
    "text": "and it's going to start that accumulation with 0 it's then going to call tell some recursively with a new",
    "start": "2599030",
    "end": "2605060"
  },
  {
    "text": "accumulation of 1 plus 0 so notice how we didn't get a new stack frame there we",
    "start": "2605060",
    "end": "2610520"
  },
  {
    "text": "just overrode the current one this is a tail call in action so the next step is",
    "start": "2610520",
    "end": "2615650"
  },
  {
    "text": "going to do another tail call and this time our we're going to be adding our head value of 2 to a new accumulation of",
    "start": "2615650",
    "end": "2622430"
  },
  {
    "text": "1 again no stack frame is required because of the tail call so this step",
    "start": "2622430",
    "end": "2627980"
  },
  {
    "text": "now is going to add our head of 3 to our accumulation of 3 and the next step will hit the end of the list so it's simply",
    "start": "2627980",
    "end": "2634340"
  },
  {
    "text": "going to return the accumulation which is now 6 and that is going to return to",
    "start": "2634340",
    "end": "2639350"
  },
  {
    "text": "the original caller you can see that by writing our recursive function using",
    "start": "2639350",
    "end": "2646400"
  },
  {
    "text": "tail recursion we've eliminated the stack overflow problem that regular recursion can run into and we've done",
    "start": "2646400",
    "end": "2652280"
  },
  {
    "text": "this this by passing all of our state forward into the next function call instead of relying on the stack to store",
    "start": "2652280",
    "end": "2657830"
  },
  {
    "text": "some state for us if we contrast this to the mutable version of sum we can see some similarities in the mutable version",
    "start": "2657830",
    "end": "2665060"
  },
  {
    "text": "we're storing our accumulation state in a mutable variable and we mutate it on each loop iteration in the immutable",
    "start": "2665060",
    "end": "2671750"
  },
  {
    "text": "tail recursive we're also accumulating state but we're passing that state forward into the next",
    "start": "2671750",
    "end": "2677720"
  },
  {
    "text": "function call rather than mutating it in place so let's look at another function",
    "start": "2677720",
    "end": "2684890"
  },
  {
    "start": "2682000",
    "end": "2755000"
  },
  {
    "text": "we can implement using tear occasion reversing an immutable list this function looks very similar to our sum",
    "start": "2684890",
    "end": "2691640"
  },
  {
    "text": "function but instead of doing addition we're going to concatenate to a list so you can see we've got an accumulation",
    "start": "2691640",
    "end": "2697130"
  },
  {
    "text": "parameter which we're going to start on that last line with an empty list then in style inside tail reverse we're going",
    "start": "2697130",
    "end": "2704090"
  },
  {
    "text": "to pan match the head of the input list and we're going to add it to the front of that accumulation list that new",
    "start": "2704090",
    "end": "2711200"
  },
  {
    "text": "accumulation is then passed to the next recursive call to towel reverse and eventually we're going to run out of",
    "start": "2711200",
    "end": "2716359"
  },
  {
    "text": "list items and when that happens we're going to return the final accumulation value again see how we're never doing",
    "start": "2716359",
    "end": "2724580"
  },
  {
    "text": "any work after doing that our recursive call to tower reverse we simply return its value ourselves and this ensures",
    "start": "2724580",
    "end": "2730700"
  },
  {
    "text": "that we're tell recursive and we won't overflow on long lists now you can see",
    "start": "2730700",
    "end": "2735950"
  },
  {
    "text": "the pattern of what it what happens to list and accumulation at the bottom of the slide you can see as we tear down the list we build up accumulation in",
    "start": "2735950",
    "end": "2743930"
  },
  {
    "text": "fact it's very much like that post-it notes gif we're just taking off the front of one list and adding to another and the very nature of doing so is what",
    "start": "2743930",
    "end": "2750530"
  },
  {
    "text": "reverses the list for us now we",
    "start": "2750530",
    "end": "2756680"
  },
  {
    "text": "previously implemented a recursive filter function now let's do the tail recursive version again a very similar",
    "start": "2756680",
    "end": "2763310"
  },
  {
    "text": "form of function we have an accumulation parameter which we're going to start out with an empty list we're doing a pattern",
    "start": "2763310",
    "end": "2769250"
  },
  {
    "text": "match to extract the head but this time we're going to use that predicate function to test if we want to keep that head value or throw it away and if we",
    "start": "2769250",
    "end": "2775730"
  },
  {
    "text": "want to keep it we're going to add it to our accumulation list otherwise we're just going to ignore it and just return",
    "start": "2775730",
    "end": "2781040"
  },
  {
    "text": "the the same accumulation list and we're going to pass that new accumulation list into our tail recursive call to",
    "start": "2781040",
    "end": "2787520"
  },
  {
    "text": "ourselves and we're going to keep going eventually we're going to run out of Lists and at that point we have a new wrinkle here instead of returning the",
    "start": "2787520",
    "end": "2795050"
  },
  {
    "text": "accumulation directly we're going to reverse it before we return it now why are we doing that",
    "start": "2795050",
    "end": "2800650"
  },
  {
    "text": "well let's have a look at how we let's all have a look at how our list and our accumulation build up",
    "start": "2800650",
    "end": "2806750"
  },
  {
    "text": "through that recursion on the right-hand side of a slide notice how we're accumulating the list in reverse order",
    "start": "2806750",
    "end": "2812420"
  },
  {
    "text": "as we're reading through it we exploited that behavior in our reverse function in",
    "start": "2812420",
    "end": "2817910"
  },
  {
    "text": "order to reverse a list but this time we don't actually want to reverse the list filter functions typically don't change",
    "start": "2817910",
    "end": "2823460"
  },
  {
    "text": "the order of the the list that they filter through so to counteract the reversing of the list weari reverse it",
    "start": "2823460",
    "end": "2830030"
  },
  {
    "text": "before we return it now you may have",
    "start": "2830030",
    "end": "2835040"
  },
  {
    "text": "recognized a very consistent pattern in all of our tail recursive functions with lists let's look more closely at the",
    "start": "2835040",
    "end": "2841970"
  },
  {
    "text": "similarities all three have an accumulation parameter that starts with a base value all three extract the head",
    "start": "2841970",
    "end": "2849620"
  },
  {
    "text": "off the list all three combined that head value into the accumulation in some",
    "start": "2849620",
    "end": "2854780"
  },
  {
    "text": "sort of way and then it passes that new accumulation forward into the tower recursive call to itself and also",
    "start": "2854780",
    "end": "2860960"
  },
  {
    "text": "passing in the tail all three will return the accumulation when they reach",
    "start": "2860960",
    "end": "2866450"
  },
  {
    "text": "the end of the list turns out that this",
    "start": "2866450",
    "end": "2871490"
  },
  {
    "start": "2869000",
    "end": "2952000"
  },
  {
    "text": "sort of algorithm can be generalized into something called a fold a fold looks like what's up on the slide so",
    "start": "2871490",
    "end": "2877490"
  },
  {
    "text": "let's walk through that carefully together the fold function takes another function which we're going to call",
    "start": "2877490",
    "end": "2882560"
  },
  {
    "text": "combined this combined function takes an accumulation value and one of the items from the list which we're calling T and",
    "start": "2882560",
    "end": "2888980"
  },
  {
    "text": "it's going to return a new accumulation value the second parameter is going to",
    "start": "2888980",
    "end": "2894380"
  },
  {
    "text": "be our starting accumulation value and the third parameter is the list we're going to go through and the return value",
    "start": "2894380",
    "end": "2901910"
  },
  {
    "text": "will be our final accumulation result so let's see how this fold function",
    "start": "2901910",
    "end": "2907220"
  },
  {
    "text": "implements all those three comment those three or four common elements that we identified before it has an accumulation",
    "start": "2907220",
    "end": "2913430"
  },
  {
    "text": "parameter that we pass to the bit that we pass with some sort of base value it",
    "start": "2913430",
    "end": "2918470"
  },
  {
    "text": "extracts the head off the list it then combines that head into the accumulator",
    "start": "2918470",
    "end": "2923540"
  },
  {
    "text": "using the combiner function and then it passes that new accumulation into the tower recursive call to itself and once",
    "start": "2923540",
    "end": "2931280"
  },
  {
    "text": "it's reached the end of the list it will return that final accumulation now the",
    "start": "2931280",
    "end": "2936290"
  },
  {
    "text": "fold function is named a fold because you're taking a list and you're folding it up bit by bit into a single accumulation value and I like",
    "start": "2936290",
    "end": "2942880"
  },
  {
    "text": "to visualize that in my head as like as if your list was a long piece of paper and you're folding it into squares and",
    "start": "2942880",
    "end": "2948460"
  },
  {
    "text": "at the end you end up like a stack of paper all right so now that we've",
    "start": "2948460",
    "end": "2954070"
  },
  {
    "text": "extracted all that common logic out into a new fold function let's see how we can implement our previous some reverse and",
    "start": "2954070",
    "end": "2959950"
  },
  {
    "text": "filter functions using our new fold function so starting with our thumb",
    "start": "2959950",
    "end": "2965950"
  },
  {
    "text": "function we're going to first combine our combined function and that's going to take an accumulator and combine it",
    "start": "2965950",
    "end": "2971710"
  },
  {
    "text": "with an item from the list and so in simply in this case we're just going to do an addition we're gonna add the two together and we're going to return that",
    "start": "2971710",
    "end": "2979110"
  },
  {
    "text": "so now we've got our very simple combined function and we can simply call fold pass in our combined function are",
    "start": "2979110",
    "end": "2985930"
  },
  {
    "text": "starting a value of zero and the list we want to sum up and that's it it's done how about reverse again we define our",
    "start": "2985930",
    "end": "2994090"
  },
  {
    "text": "combined function this time we take the item and we add it to the front of the",
    "start": "2994090",
    "end": "2999250"
  },
  {
    "text": "accumulation list we then take this combine function and we give it two fold we give it our starting accumulation of",
    "start": "2999250",
    "end": "3005820"
  },
  {
    "text": "an empty list and we give it a list two fold over and done we put a reverse function what about filter well again we",
    "start": "3005820",
    "end": "3014520"
  },
  {
    "text": "define our combined function it just uses the predicate to see whether we want to keep that particular item or not",
    "start": "3014520",
    "end": "3020910"
  },
  {
    "text": "if we do want to keep it we add it to the front of the accumulation list otherwise we drop it on the floor and return the same accumulation list then",
    "start": "3020910",
    "end": "3029070"
  },
  {
    "text": "we call our fold function we pass in our combined function we pass in the empty list to start our accumulation and we",
    "start": "3029070",
    "end": "3035820"
  },
  {
    "text": "pass in the list we want to filter but here remember we're also doing a reverse",
    "start": "3035820",
    "end": "3041010"
  },
  {
    "text": "to make sure that we get back our original list ordering and boom we've",
    "start": "3041010",
    "end": "3047250"
  },
  {
    "text": "just used a general fold function to implement our three tail recursive functions so while recursion is crucial in",
    "start": "3047250",
    "end": "3053550"
  },
  {
    "text": "functional programming as a way to loop over data you can see that most of the time we can use folds to perform that",
    "start": "3053550",
    "end": "3059940"
  },
  {
    "text": "loop for us one time that you might want to still use manual recursion is if you",
    "start": "3059940",
    "end": "3065760"
  },
  {
    "text": "want to quit your looping early our fold will always recur to the end of the list so if you only want to recur certain",
    "start": "3065760",
    "end": "3071610"
  },
  {
    "text": "away and then stop then you might still want to write recursion yourself folding isn't new in",
    "start": "3071610",
    "end": "3079260"
  },
  {
    "start": "3077000",
    "end": "3101000"
  },
  {
    "text": "fact you've probably used it before in your favorite language and perhaps not even realized it folding in c-sharp goes by the name",
    "start": "3079260",
    "end": "3085650"
  },
  {
    "text": "aggragate in from the link extension methods in other languages like JavaScript it's sometimes called reduce",
    "start": "3085650",
    "end": "3091520"
  },
  {
    "text": "most languages have an implementation of fold for their collection types so you don't need to implement it yourself like",
    "start": "3091520",
    "end": "3097290"
  },
  {
    "text": "what we did you can just use what's built in alright sorry let's wrap up all",
    "start": "3097290",
    "end": "3104970"
  },
  {
    "start": "3101000",
    "end": "3226000"
  },
  {
    "text": "the FP jargon that we've gone through today we started by talking about immutability and how FP languages make",
    "start": "3104970",
    "end": "3111390"
  },
  {
    "text": "it easy to work with immutable data and we looked at how immutable lists were created we then looked at bindings and",
    "start": "3111390",
    "end": "3118140"
  },
  {
    "text": "saw how they differed from variables in that they give a name to a value and that they don't change we looked at pure",
    "start": "3118140",
    "end": "3124470"
  },
  {
    "text": "and impure functions pure functions being ones that always return the same results given the same input and don't",
    "start": "3124470",
    "end": "3130590"
  },
  {
    "text": "we take their inputs nor do they depend upon global mutable state we saw how immutability bindings and pure functions",
    "start": "3130590",
    "end": "3138120"
  },
  {
    "text": "allow us to substitute names for values with a concept called referential transparency we also saw how referential",
    "start": "3138120",
    "end": "3144360"
  },
  {
    "text": "transparency allows us to refactor code more easily by allowing us to safely extract and move code around we touched",
    "start": "3144360",
    "end": "3152370"
  },
  {
    "text": "on how in FP languages and in many modern languages functions are treated as first-class values and can be passed",
    "start": "3152370",
    "end": "3158460"
  },
  {
    "text": "to other functions and returned from them we looked at curried functions and how this enables partial application of",
    "start": "3158460",
    "end": "3165390"
  },
  {
    "text": "functions where we can pass only some of the parameters and get back a function that takes the rest of the parameters we",
    "start": "3165390",
    "end": "3172980"
  },
  {
    "text": "compared to different types of algebraic data types product types and sometimes product types being the combination of",
    "start": "3172980",
    "end": "3179640"
  },
  {
    "text": "more than one value like a record type or a tuple and some types allowing us to model the alternative between different",
    "start": "3179640",
    "end": "3186150"
  },
  {
    "text": "types we walk through value semantics and we saw how it offers the ability to",
    "start": "3186150",
    "end": "3191610"
  },
  {
    "text": "compare two instances of something that have the same values easily and this makes our tests much easier to write we",
    "start": "3191610",
    "end": "3199110"
  },
  {
    "text": "then spent a bunch of time exploring recursion and we implemented some and filter recursively and then we",
    "start": "3199110",
    "end": "3204270"
  },
  {
    "text": "discovered that we have got a stack overflow problem in our regular recursion so we introduced tail recursion so that",
    "start": "3204270",
    "end": "3209850"
  },
  {
    "text": "we could stop using unbounded stack space and implemented some reverse and filter tell recursively and finally we",
    "start": "3209850",
    "end": "3217800"
  },
  {
    "text": "extracted all our common tail recursion logic out into a general fold function and we simplified our sum reverse and",
    "start": "3217800",
    "end": "3224280"
  },
  {
    "text": "filter functions so if you liked what you saw today and you're looking for",
    "start": "3224280",
    "end": "3229590"
  },
  {
    "start": "3226000",
    "end": "3319000"
  },
  {
    "text": "some more I highly recommend checking out Scott lashings website F sharp for fun and profit he walks through AFP",
    "start": "3229590",
    "end": "3236070"
  },
  {
    "text": "techniques and the F sharp language in a very approachable way so I do recommend you check that out mark Simmons blog",
    "start": "3236070",
    "end": "3241980"
  },
  {
    "text": "also has some really good content he's been going through a lot of functional fundamental patterns recently so check",
    "start": "3241980",
    "end": "3247500"
  },
  {
    "text": "that out if you liked this talk but you thought it was just getting good at the end then you might be interested in",
    "start": "3247500",
    "end": "3253350"
  },
  {
    "text": "seeing the sequel talk that came out before this one at NDC 2017 in that one",
    "start": "3253350",
    "end": "3258780"
  },
  {
    "text": "I talked about functor applicative and monad FP patterns so the video recording and the slides are online",
    "start": "3258780",
    "end": "3264840"
  },
  {
    "text": "thanks to NDC so you can check that out if you want and of course there are other people here at NEC Sydney giving",
    "start": "3264840",
    "end": "3271440"
  },
  {
    "text": "talks Don sign who's the creator of F sharp is giving a talk tomorrow about F sharp code that he likes at 11:40 unless",
    "start": "3271440",
    "end": "3278190"
  },
  {
    "text": "the schedule is changed and I don't think it has and matias brando winder is giving a talk tomorrow at 1:40 about",
    "start": "3278190",
    "end": "3285000"
  },
  {
    "text": "where he'll model dungeons and dragons rules with F sharp and I'm definitely gonna be in that one because that sounds sick so if you're the sort of person who",
    "start": "3285000",
    "end": "3293190"
  },
  {
    "text": "likes to learn things from principles and fundamentals i'd suggest you check out Haskell programming from first",
    "start": "3293190",
    "end": "3298920"
  },
  {
    "text": "principles as a text book it starts from scratch and it builds up very slowly it has a very gentle learning curve it's a",
    "start": "3298920",
    "end": "3305220"
  },
  {
    "text": "very big book so it might be a gentle learning curve but it's a very long one but by the end of it you'll be eating monads for breakfast and as there won't",
    "start": "3305220",
    "end": "3311430"
  },
  {
    "text": "be a problem it's actually a very good book but if you're the sort of person who just likes to get in and get their hands dirty quickly f-sharp from front",
    "start": "3311430",
    "end": "3317460"
  },
  {
    "text": "end profit is probably a better place to start so thank you for listening I hope you enjoyed the talk and you got",
    "start": "3317460",
    "end": "3324270"
  },
  {
    "start": "3319000",
    "end": "3600000"
  },
  {
    "text": "something out of it the slides will be available upon online at the link and NSE obviously makes these talks",
    "start": "3324270",
    "end": "3330660"
  },
  {
    "text": "available as videos after the conference so if you felt like you needed a pause button so you could just stare at the code for a bit check out the video when",
    "start": "3330660",
    "end": "3337260"
  },
  {
    "text": "it comes out we do have time for a few questions so if there's something that can phew do you have some question about FP feel",
    "start": "3337260",
    "end": "3343810"
  },
  {
    "text": "free to pop up your hand and I'll do my best to help thank you any questions oh",
    "start": "3343810",
    "end": "3364470"
  },
  {
    "text": "there it I got that I got the troll question from not my friends I will say",
    "start": "3364470",
    "end": "3374829"
  },
  {
    "text": "that you don't actually have to understand any of that to understand monads they're actually not that complicated",
    "start": "3374829",
    "end": "3379930"
  },
  {
    "text": "when you dig into them so I think probably how would I explain a monad in",
    "start": "3379930",
    "end": "3387099"
  },
  {
    "text": "like a couple of couple of words I think probably the best the best the best like",
    "start": "3387099",
    "end": "3395700"
  },
  {
    "text": "metaphor for one that I heard was one that John told me in the past as a motor is like a type amplifier so if you think",
    "start": "3395700",
    "end": "3401950"
  },
  {
    "text": "about you've got a particular type like a string if you want to give it some sort of additional behavior to amplify",
    "start": "3401950",
    "end": "3407200"
  },
  {
    "text": "the type a motor is a way you can you can do that so for example like the",
    "start": "3407200",
    "end": "3412630"
  },
  {
    "text": "option type something that models the absence or the presence of something you can have a option of string so you're",
    "start": "3412630",
    "end": "3418869"
  },
  {
    "text": "amplifying a string to have the ability to be there or not or a list is also a monad so you can amplify a string in a",
    "start": "3418869",
    "end": "3426369"
  },
  {
    "text": "list of strings you can have more than 1 or 0 to 1 you know 0 too many strings and there are many more cases that we",
    "start": "3426369",
    "end": "3432849"
  },
  {
    "text": "can use them I find the best way to understand a monad is not to actually try and think about it from an abstract",
    "start": "3432849",
    "end": "3438220"
  },
  {
    "text": "perspective like what is it it's easier to look at all the concrete ways you can build monads and then once you've seen",
    "start": "3438220",
    "end": "3444339"
  },
  {
    "text": "like a list as a monad and an option as a monad you know and async is a monad",
    "start": "3444339",
    "end": "3450430"
  },
  {
    "text": "then you start to see the common pattern between them and you realize it's actually not that complicated so I",
    "start": "3450430",
    "end": "3456369"
  },
  {
    "text": "didn't directly answer your question but hopefully that was enough",
    "start": "3456369",
    "end": "3461579"
  },
  {
    "text": "so if you're in a case where you basically want to let's say you've got a",
    "start": "3476380",
    "end": "3481900"
  },
  {
    "text": "record type that has a whole bunch of properties on it and you want to be able to only initialize some of them what you",
    "start": "3481900",
    "end": "3486970"
  },
  {
    "text": "probably end up doing is model the fact that at some point in your program you don't have all of the values you only",
    "start": "3486970",
    "end": "3493180"
  },
  {
    "text": "have some of them so you might create a new type that has for example only the values you have at that point in time",
    "start": "3493180",
    "end": "3499270"
  },
  {
    "text": "and then when you get the other values you there might take the values off that particular record and put them on the new record or if you might have all of",
    "start": "3499270",
    "end": "3506710"
  },
  {
    "text": "the values at any point in time you might make another record type which has option whatever type for all of the",
    "start": "3506710",
    "end": "3512200"
  },
  {
    "text": "properties and that way you can say well I have these ones and I don't have these ones and then at some point in the code if you're using that final record type",
    "start": "3512200",
    "end": "3519400"
  },
  {
    "text": "that must have everything you've got to write some validation code I know that's not a functional thing that's just programming at some point you're gonna",
    "start": "3519400",
    "end": "3525190"
  },
  {
    "text": "have to write some code to check do I have this do I have this do I have this and at that point you transform from one time to the other so the nice thing",
    "start": "3525190",
    "end": "3531730"
  },
  {
    "text": "about the record type is that because it forces you to initialize everything it actually also forces you to model what's",
    "start": "3531730",
    "end": "3537790"
  },
  {
    "text": "happening in your domain more accurately so it's pretty easy to get sloppy in a language like C sharp and you know we",
    "start": "3537790",
    "end": "3543549"
  },
  {
    "text": "can just use the same type for both but then at certain points in the code where you expect everything to be there you",
    "start": "3543549",
    "end": "3549670"
  },
  {
    "text": "don't have a guarantee and it's easy for bugs as they've been but when you're using an immutable type like a record type you're forced to make that explicit",
    "start": "3549670",
    "end": "3556030"
  },
  {
    "text": "so at some point in the code I don't have everything and at some point in the code I will have everything that's explicit in the types and it means you",
    "start": "3556030",
    "end": "3562599"
  },
  {
    "text": "don't have to write all this null checking stuff that you do in regular C sharp which is pretty nice yep",
    "start": "3562599",
    "end": "3571650"
  },
  {
    "text": "yeah so the question was about when you're writing a pure function will the compiler give you any way to say this",
    "start": "3588470",
    "end": "3594960"
  },
  {
    "text": "must be a pure function versus this doesn't have to be a pure function well that depends on the language so an",
    "start": "3594960",
    "end": "3601380"
  },
  {
    "text": "f-sharp no there's no way to write there's no rate or to get the compiler to validate that a particular function",
    "start": "3601380",
    "end": "3606810"
  },
  {
    "text": "is pure which is a shame because it would be nice but f-sharp is a dotnet language so it participates in an",
    "start": "3606810",
    "end": "3613350"
  },
  {
    "text": "ecosystem which is extremely mutable so mutation is kind of expected an f-sharp and so you try to write most of your",
    "start": "3613350",
    "end": "3620370"
  },
  {
    "text": "code purely and then you know it's sort of based on trust there so but there are",
    "start": "3620370",
    "end": "3626100"
  },
  {
    "text": "languages which force you to be pure so Haskell is one of those everything you write in Haskell has to be pure and",
    "start": "3626100",
    "end": "3631470"
  },
  {
    "text": "impurity is managed through monads and IO and stuff so you can obviously still do side effects in Haskell but the code",
    "start": "3631470",
    "end": "3638100"
  },
  {
    "text": "that you write must be pure and if you you literally can't mutate anything there's no there's no like mutation",
    "start": "3638100",
    "end": "3645180"
  },
  {
    "text": "operator there are types that let you do something similar to that but yeah they model in a very different way there so",
    "start": "3645180",
    "end": "3651300"
  },
  {
    "text": "if like guaranteed purity is something that you want and it's something that I want then task was pretty good like that",
    "start": "3651300",
    "end": "3659900"
  },
  {
    "text": "so the question was is there like a convention that helps you know whether a function is pure or not in a sharp not",
    "start": "3675870",
    "end": "3682390"
  },
  {
    "text": "that I've come across usually if a function is just using F sharp types so",
    "start": "3682390",
    "end": "3688510"
  },
  {
    "text": "things like F sharp lists sets maps and record types and sometimes well those",
    "start": "3688510",
    "end": "3693910"
  },
  {
    "text": "are all immutables so if you can see in the type parameters that it's using only those types then you're pretty much sure",
    "start": "3693910",
    "end": "3701050"
  },
  {
    "text": "that it's not going to be doing that because hopefully the people are writing the code have done the right thing but",
    "start": "3701050",
    "end": "3706510"
  },
  {
    "text": "of course there's nothing stopping someone from using date/time and UTC now and stuffing it up so that is that is",
    "start": "3706510",
    "end": "3712240"
  },
  {
    "text": "something got to watch out for so and on my projects we typically catch those things at code review time so if I'm",
    "start": "3712240",
    "end": "3717940"
  },
  {
    "text": "reviewing a PR and I see someone slip in a dirty little daytime but UTC now and they I'll be like no no no we're gonna",
    "start": "3717940",
    "end": "3724060"
  },
  {
    "text": "pass that one in so yeah unfortunately the tooling doesn't help you with that and I haven't seen a convention because",
    "start": "3724060",
    "end": "3729310"
  },
  {
    "text": "it again a convention they're easy to break so it's not really a guarantee yeah",
    "start": "3729310",
    "end": "3736590"
  },
  {
    "text": "and that's the that's the sort of the middle the middle ground that f-sharp plays as a language it it is by design a",
    "start": "3749770",
    "end": "3757520"
  },
  {
    "text": "language that sits sort of in between the pure hardcore FP paradigm and the OO",
    "start": "3757520",
    "end": "3762710"
  },
  {
    "text": "paradigm because it's a dotnet language so that's one of its strengths and also obviously there's a there's a downside to it depending upon your perspective",
    "start": "3762710",
    "end": "3769250"
  },
  {
    "text": "but the good thing is that you can just go off and use a bunch of c-sharp libraries if you need to so the question",
    "start": "3769250",
    "end": "3779330"
  },
  {
    "text": "was what do I think the downside of functional programming is I think to me the biggest downside is that most people",
    "start": "3779330",
    "end": "3786619"
  },
  {
    "text": "don't know it so it's very unfamiliar to people who haven't seen it before and it kind of scares people off so I think",
    "start": "3786619",
    "end": "3793280"
  },
  {
    "text": "that's to me that's probably the biggest hurdle that it has and the biggest disadvantage is that if I write a piece",
    "start": "3793280",
    "end": "3798680"
  },
  {
    "text": "of FP code I can't just give it to any developer and they'll immediately be able to Crockett like pretty much every other language and that's I think that's",
    "start": "3798680",
    "end": "3805220"
  },
  {
    "text": "just more of a function of history than anything else most people when they go through uni or they teach themselves",
    "start": "3805220",
    "end": "3810770"
  },
  {
    "text": "online start with an imperative mutable oo ish language and that's just where",
    "start": "3810770",
    "end": "3816109"
  },
  {
    "text": "they come from other than that sometimes sometimes that",
    "start": "3816109",
    "end": "3823660"
  },
  {
    "text": "like I what I was saying before about being forced to model things correctly sometimes you just want to hack together",
    "start": "3823660",
    "end": "3829550"
  },
  {
    "text": "something quickly just to prove a concept and being forced to handle every",
    "start": "3829550",
    "end": "3835280"
  },
  {
    "text": "case correctly like you'd want to do in production code is painful it's like I'm",
    "start": "3835280",
    "end": "3840410"
  },
  {
    "text": "just hacking together something to see if something kind of works sort of you know just rip some data that I know is a certain way yeah okay this feels might",
    "start": "3840410",
    "end": "3846350"
  },
  {
    "text": "be missing but I know it's not because I can view the whole file and I know it's not missing so that sort of stuff sometimes when you've got a strict type",
    "start": "3846350",
    "end": "3851990"
  },
  {
    "text": "system it can get in the way and you'll be like oh god I don't want whatever in",
    "start": "3851990",
    "end": "3857060"
  },
  {
    "text": "in F sharp that's not so much of a big deal because you do have the ability to do all the dotnet stuff and you know",
    "start": "3857060",
    "end": "3862760"
  },
  {
    "text": "cast you're way ahead of things and do mutation if you want to so like prototyping quickly isn't too bad in our",
    "start": "3862760",
    "end": "3870140"
  },
  {
    "text": "shop but in Haskell it becomes a little bit harder because it will try to force you to write good production code that's",
    "start": "3870140",
    "end": "3876980"
  },
  {
    "text": "you know I've got all the properties a good production code bit maybe you don't want to write that right now could you just want to you know do a",
    "start": "3876980",
    "end": "3882349"
  },
  {
    "text": "little prototype or something and it's painful cool that seems like it so thank",
    "start": "3882349",
    "end": "3888680"
  },
  {
    "text": "you for coming enjoy your lunch [Applause]",
    "start": "3888680",
    "end": "3894020"
  }
]