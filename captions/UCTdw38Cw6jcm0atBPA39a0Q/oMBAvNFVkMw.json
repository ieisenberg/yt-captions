[
  {
    "text": "welcome everybody um there a C++ features you might not know and um who here has attended the",
    "start": "6640",
    "end": "14440"
  },
  {
    "text": "quiz yesterday evening was a lot of fun um just to give you some baselines for the expectations",
    "start": "14440",
    "end": "21519"
  },
  {
    "text": "of this talk I've presented some YouTube comments when I gave it before um so this person liked",
    "start": "21519",
    "end": "27000"
  },
  {
    "text": "it um this person didn't like some of the features I presented um this person put it more",
    "start": "27000",
    "end": "35079"
  },
  {
    "text": "strongly and um yeah so look at for X",
    "start": "35079",
    "end": "40399"
  },
  {
    "text": "but this isn't is might might not be something that you can really use in your day job um or if you want to lose",
    "start": "40399",
    "end": "47160"
  },
  {
    "text": "your day job so there's a reason you don't know these features so but it's really useful for quiz and stuff like",
    "start": "47160",
    "end": "53239"
  },
  {
    "text": "that so let's begin um this is a classic we've got an array uh we can index into that array and assign it how however",
    "start": "53239",
    "end": "60519"
  },
  {
    "text": "according to the standard array index on a raw array like that is defined to be exactly equivalent to arithmetic and",
    "start": "60519",
    "end": "67040"
  },
  {
    "text": "poter D reference and the addition is commutative so you might just WR that",
    "start": "67040",
    "end": "73040"
  },
  {
    "text": "and if you apply the definition backwards you end up with that this does the exactly all four lines do the exact",
    "start": "73040",
    "end": "81040"
  },
  {
    "text": "same thing just a bit be syntax the the end um if you have stood away I not that",
    "start": "81040",
    "end": "87040"
  },
  {
    "text": "this one does not work because here the array access is equivalent to calling the member function and um this is a",
    "start": "87040",
    "end": "93520"
  },
  {
    "text": "compiler error sadly because um there is no member function dot operator um that takes a stood array on 17 so um ra",
    "start": "93520",
    "end": "100960"
  },
  {
    "text": "errors are much better than stood array I I never like code like that so",
    "start": "100960",
    "end": "107159"
  },
  {
    "text": "we've got two variables one initialized to one one initialized to negative one this is misaligned um luckily we can fix",
    "start": "107159",
    "end": "112840"
  },
  {
    "text": "that and just Ty plus one and the plus isn't actually part of the number syntax this is an operator just like negative",
    "start": "112840",
    "end": "119159"
  },
  {
    "text": "one um so we can use it um the standard says that it's um requires arithmetic",
    "start": "119159",
    "end": "125479"
  },
  {
    "text": "type and Returns the value of the argument unchanged so it does nothing however it changes the type it does",
    "start": "125479",
    "end": "130640"
  },
  {
    "text": "integral promotion on the type what this means is if you have an unsigned short s",
    "start": "130640",
    "end": "135680"
  },
  {
    "text": "and we write plus s the result will be an INT this is because whenever we have an integer type that is smaller than int",
    "start": "135680",
    "end": "142280"
  },
  {
    "text": "we will just get an INT so you cannot do any arithmetic on short you will always do arithmetic on int so if you write",
    "start": "142280",
    "end": "147640"
  },
  {
    "text": "plus s the type will change to an INT but the value will remain unchanged um if you have an enum uh you",
    "start": "147640",
    "end": "155080"
  },
  {
    "text": "will trigger like the conversion to the underlying integer type so plus a will be an",
    "start": "155080",
    "end": "160680"
  },
  {
    "text": "INT and if you have an array you will trigger pointer to array Decay and return the pointer to the first",
    "start": "160680",
    "end": "167200"
  },
  {
    "text": "element uh this is a Lambda a Lambda that doesn't capture anything is implicitly convertible to a function pointer and we write plus we will",
    "start": "167200",
    "end": "173200"
  },
  {
    "text": "trigger that conversion to the function point so how can we use this operator well we can convert an unced to underly",
    "start": "173200",
    "end": "180599"
  },
  {
    "text": "type uh but they stood to underly since I believe C++ 17 or 20 there we can convert an area to an",
    "start": "180599",
    "end": "187799"
  },
  {
    "text": "pointer but that's implicit we can convert a Lambda to a function pointer and the last one's",
    "start": "187799",
    "end": "192840"
  },
  {
    "text": "actually useful for example here we've got a type the template that takes a function pointer and we cannot directly",
    "start": "192840",
    "end": "199080"
  },
  {
    "text": "give it a Lambda but we can write plus and then give it a Lambda and this will trigger the conversion and we will be able to just pass in a Lambda to a",
    "start": "199080",
    "end": "205480"
  },
  {
    "text": "template parameter in C++ 11 um in C++ 20 we don't need it we can just an auto template parameter and can pass the",
    "start": "205480",
    "end": "211439"
  },
  {
    "text": "Lambda that directly due to the general generalization of template",
    "start": "211439",
    "end": "217159"
  },
  {
    "text": "parameter so but maybe if you're writing 3++ 20 code this pick can be",
    "start": "217159",
    "end": "222680"
  },
  {
    "text": "useful speaking of be operators this is the comma operator uh and by this I mean",
    "start": "222680",
    "end": "227799"
  },
  {
    "text": "the in the end of the for Loop the comma between plus plus left and minus minus right that's the comma operator all other commas in the slide are just",
    "start": "227799",
    "end": "233959"
  },
  {
    "text": "commas um so what does the comma operator do and this is sort of like the main motivation for the comma operator",
    "start": "233959",
    "end": "239920"
  },
  {
    "text": "um it essentially you have two expressions separated by comma and we will evaluate the left expression then discard its",
    "start": "239920",
    "end": "246480"
  },
  {
    "text": "value and then evaluate the white expression and return the value so it's just a way to put multiple Expressions",
    "start": "246480",
    "end": "251760"
  },
  {
    "text": "into one place where we would normally only have one um like the increment and F like we can put multiple expressions",
    "start": "251760",
    "end": "257160"
  },
  {
    "text": "in there separated using the commor this is a bit esoteric but since C++ um 17",
    "start": "257160",
    "end": "262680"
  },
  {
    "text": "there are be a able to do um Port expressions and then the comma operator is really useful so this function takes",
    "start": "262680",
    "end": "269080"
  },
  {
    "text": "a function and parameter pack and it will invoke that function uh on each element of the parameter pack using the",
    "start": "269080",
    "end": "274520"
  },
  {
    "text": "comma operator and because the comma operator has like defined evaluation order this will be invoked in order so",
    "start": "274520",
    "end": "280240"
  },
  {
    "text": "this will invoke the function on the first element then the second and then the third and so on um there a bunch of Tricks um about F Expressions I've",
    "start": "280240",
    "end": "286400"
  },
  {
    "text": "blocked about them you don't need to copy the URL all links are also at the end so that is definitely useful",
    "start": "286400",
    "end": "293919"
  },
  {
    "text": "trick operators can be overloaded and normally you will overload operators like assignment or compar",
    "start": "293919",
    "end": "300280"
  },
  {
    "text": "note that since we Plus+ 20 we don't need to overload overload not equals ever again because it is implicit the",
    "start": "300280",
    "end": "306039"
  },
  {
    "text": "compiler will just do the rewrite for you this is my favorite feature of C++ 20 just stop writing operator not equals",
    "start": "306039",
    "end": "311639"
  },
  {
    "text": "just great um you can also write the over spaceshop operators in C++ 20 um",
    "start": "311639",
    "end": "316919"
  },
  {
    "text": "you can have um D reference operators if you're writing an iterator or something like that or smart pointer uh and",
    "start": "316919",
    "end": "322240"
  },
  {
    "text": "arithmetic operators this is normal overloading however we can also overload more operators like a classic as we can",
    "start": "322240",
    "end": "328880"
  },
  {
    "text": "if you have a custom Bo we can overload logical and and logical or however those ones um do not short circuit so it's",
    "start": "328880",
    "end": "337000"
  },
  {
    "text": "usually recommended to never overload those operators because you will use this short circuit behavior that is expected however the C++ 26 standard",
    "start": "337000",
    "end": "344759"
  },
  {
    "text": "Library will have overloaded um operators for those in simd so simd of T",
    "start": "344759",
    "end": "350039"
  },
  {
    "text": "is just essentially an array of T's and then we can do member wise operations on them for example we can do a member",
    "start": "350039",
    "end": "355759"
  },
  {
    "text": "comparison and this will return a simd mask and this is essentially an array of pool so we have two arrays of ins for",
    "start": "355759",
    "end": "361000"
  },
  {
    "text": "example we can compare them and we get back an array of buol where like each index does like the element wise comparison and then we can do a logical",
    "start": "361000",
    "end": "367919"
  },
  {
    "text": "end on those and this will just do an element wise logical end and it expect",
    "start": "367919",
    "end": "373240"
  },
  {
    "text": "like it's fine that this one doesn't do short circuit because there isn't a lot you can do to Short Circuit because you want to do like compare each one anyway",
    "start": "373240",
    "end": "380120"
  },
  {
    "text": "so it's a perfect fine way to use um overload logical and and logical or",
    "start": "380120",
    "end": "386479"
  },
  {
    "text": "answer we can also overload the comma operator um this one is particularly nice if you combine it with um custom",
    "start": "386560",
    "end": "392560"
  },
  {
    "text": "iterators so if you overload the comma operator for your iterator you will catch a standard library that uses a for",
    "start": "392560",
    "end": "397759"
  },
  {
    "text": "Loop that does multiple increments to your iterator and then you get a nice output so if you want to annoy your standard Library implementers try that",
    "start": "397759",
    "end": "404400"
  },
  {
    "text": "see whether they will invoke the um comma operator which they shouldn't and then you can file a bu report and annoy",
    "start": "404400",
    "end": "409840"
  },
  {
    "text": "them like the msvc standard library is pretty robust against it it cast everything to void to prevent calling",
    "start": "409840",
    "end": "415199"
  },
  {
    "text": "userdefined comma operators but you might be able to find some other generic code that doesn't Do It um see what",
    "start": "415199",
    "end": "422639"
  },
  {
    "text": "happens we can also overload that operator so what the hell is that",
    "start": "422639",
    "end": "428720"
  },
  {
    "text": "operator um this is It's related to member pointers so if you have a member pointer you can write object do star to",
    "start": "428720",
    "end": "435080"
  },
  {
    "text": "D reference the member pointer or a pointer to object eror star to the Ence the member pointer and uh just like with",
    "start": "435080",
    "end": "441759"
  },
  {
    "text": "the regular error operators um the dot version cannot be overloaded but we can overload the error one so for example",
    "start": "441759",
    "end": "447919"
  },
  {
    "text": "when you have a smart pointer um like unique pointer you can use erar to derence the member pointer um exact this",
    "start": "447919",
    "end": "454479"
  },
  {
    "text": "one doesn't compile because nobody bother to actually overload the erar operator um you have to dreference the smart pointer and then you st star and I",
    "start": "454479",
    "end": "462160"
  },
  {
    "text": "guess like this is a defect in the standard library that you can't do that directly with a smart pointer like",
    "start": "462160",
    "end": "467360"
  },
  {
    "text": "there's no reason why this shouldn't work they can implement it but it's also like nobody noticed it I guess right um",
    "start": "467360",
    "end": "475960"
  },
  {
    "text": "I've actually found um a use case for that operator in our code space um so I work at think cell we have a use C++",
    "start": "475960",
    "end": "483720"
  },
  {
    "text": "extensively and we have got like a scope exit Ma so this takes an expression and",
    "start": "483720",
    "end": "489360"
  },
  {
    "text": "we'll execute it at scope exit and the basic implementation you can do is quite simple so we just have a struct that",
    "start": "489360",
    "end": "495199"
  },
  {
    "text": "invols from like inherit from a function and just invokes it on scope exit um and then we just create a variable of that",
    "start": "495199",
    "end": "501159"
  },
  {
    "text": "type give it the Lambda rep the expression in a Lambda pass that to the thing and it will just in um this will",
    "start": "501159",
    "end": "506639"
  },
  {
    "text": "just work and it will can use like so so you've got a to a file and then the scope exit you want to close the handle",
    "start": "506639",
    "end": "512159"
  },
  {
    "text": "and it just works however the syntax isn't quite nice um what would be a",
    "start": "512159",
    "end": "518599"
  },
  {
    "text": "nicer syntax record like that so scope exit and then you've got a block and then you can put some statements in",
    "start": "518599",
    "end": "524560"
  },
  {
    "text": "there and this almost looks like a language feature right that's a the first statement essentially and we can",
    "start": "524560",
    "end": "530040"
  },
  {
    "text": "do that um we can have scope exit is a macro",
    "start": "530040",
    "end": "535760"
  },
  {
    "text": "that expands to something so we need to create a variable and then we can use the braces to create a Lambda and then",
    "start": "535760",
    "end": "541720"
  },
  {
    "text": "we need to put something in front um and this something can we Rec",
    "start": "541720",
    "end": "546959"
  },
  {
    "text": "create like a tech type and then we use a binary operator and when we have the tech type and the binary operator this",
    "start": "546959",
    "end": "552839"
  },
  {
    "text": "will then create our scope exit object that will invoke the Lambda so in the middle we need a b overload binary",
    "start": "552839",
    "end": "558680"
  },
  {
    "text": "operator with five precedence just so that no there's no way to mess it up if you put other Expressions at the end and",
    "start": "558680",
    "end": "566880"
  },
  {
    "text": "if you look at the Oppo procedence table um right there we've got the AAR operator um andl 4 this is the first",
    "start": "566880",
    "end": "574480"
  },
  {
    "text": "operator that we can overload um so we can use that here I will leave this table up it will become important later",
    "start": "574480",
    "end": "581279"
  },
  {
    "text": "in the talk so just give you some moments to remember the",
    "start": "581279",
    "end": "587120"
  },
  {
    "text": "content there will be a quiz okay um I've got that there are",
    "start": "587120",
    "end": "594160"
  },
  {
    "text": "bunch more operators but they didn't fit on SL so um this is the implementation so we've got our type that overloads the",
    "start": "594160",
    "end": "600640"
  },
  {
    "text": "AAR operator that takes a function on the right hand side and then we can Define our macro to invoke that and this",
    "start": "600640",
    "end": "606360"
  },
  {
    "text": "will then web take the Lambda wrap it into the scope exit input returns it stores in a varable and this will then",
    "start": "606360",
    "end": "612399"
  },
  {
    "text": "be invoked in scope exit and that way we essentially WR the first statement just using a bit of creative operator",
    "start": "612399",
    "end": "617760"
  },
  {
    "text": "overloading and maos so this was almost too useful so let's talk about El if as if doesn't",
    "start": "617760",
    "end": "624200"
  },
  {
    "text": "actually exist and this is the grammar for if statements we've got an if if and we've",
    "start": "624200",
    "end": "629839"
  },
  {
    "text": "got an if else there is no El if but you can write if right so what's",
    "start": "629839",
    "end": "636880"
  },
  {
    "text": "actually going on here what's actually going on here is that the else the the else if is actually an else whose body",
    "start": "636880",
    "end": "643480"
  },
  {
    "text": "is another if else so if you put in braces everywhere this is equivalent to that so we've got an if else and the",
    "start": "643480",
    "end": "649000"
  },
  {
    "text": "else itself is another if else and it's just convention that be sort of treat it",
    "start": "649000",
    "end": "655680"
  },
  {
    "text": "as if it were a single statement like we just combine the braces if you have guide lines that require braces around",
    "start": "655680",
    "end": "660760"
  },
  {
    "text": "every statement you're not following them consistently because you're not putting braces here right so we give El",
    "start": "660760",
    "end": "666600"
  },
  {
    "text": "if the special treatment but by stop at El if this is an El switch this is the",
    "start": "666600",
    "end": "672040"
  },
  {
    "text": "exact same thing we just don't write it for some reason right but it's really beautiful like who need F matching when",
    "start": "672040",
    "end": "677839"
  },
  {
    "text": "we've got the El switch we all do but switch itself has a",
    "start": "677839",
    "end": "683120"
  },
  {
    "text": "lot of fun so this is switch um multiple cases a default fall through all the all",
    "start": "683120",
    "end": "688639"
  },
  {
    "text": "the nice stuff um first thing the order of the cases and the default doesn't matter at all so",
    "start": "688639",
    "end": "694240"
  },
  {
    "text": "we can put the default in front looks a bit weird does the exact same thing order doesn't",
    "start": "694240",
    "end": "699519"
  },
  {
    "text": "matter um the grammar also allows for stuff like that so this is a switch and it begins with a statement and because",
    "start": "699519",
    "end": "705880"
  },
  {
    "text": "this statement is not preceded by any case or default it will never be executed it's essentially like a comment",
    "start": "705880",
    "end": "711000"
  },
  {
    "text": "we've put in there for later and that one actually has a use so you're constantly writing",
    "start": "711000",
    "end": "718120"
  },
  {
    "text": "functions like that because you do not have a reflection like convert an enom to a string and if it's a scoped enum",
    "start": "718120",
    "end": "723399"
  },
  {
    "text": "you have to repeat the name which is annoying however luckily since 20 we've got using enum and this will bring all",
    "start": "723399",
    "end": "728760"
  },
  {
    "text": "the names into scope and then we don't need to remove them but we don't need to put the using enum in the top there",
    "start": "728760",
    "end": "734880"
  },
  {
    "text": "right this will make it available throughout the entire function and we only need them inside the switch so we can put the statement right there it",
    "start": "734880",
    "end": "741440"
  },
  {
    "text": "doesn't matter that it's never executed because it doesn't do anything when executed it will just still affect name look up in that scope and by the way",
    "start": "741440",
    "end": "748440"
  },
  {
    "text": "that was the only useful thing the YouTube commenter um part of the talk",
    "start": "748440",
    "end": "753560"
  },
  {
    "text": "so here you go you can now get up and",
    "start": "753560",
    "end": "758240"
  },
  {
    "text": "leave because um this is my next slide um this is the switch if you have a single statement you don't need braces",
    "start": "758600",
    "end": "765279"
  },
  {
    "text": "uh so this is a switch it has a single statement and then the second statement there's after the switch so if I is one",
    "start": "765279",
    "end": "771000"
  },
  {
    "text": "two or three we will print it and then we print the other thing and otherwise we will just do nothing and go immediately to the end you don't need",
    "start": "771000",
    "end": "777160"
  },
  {
    "text": "braces so want to switch you can also sort of combine switch with other",
    "start": "777160",
    "end": "783920"
  },
  {
    "text": "controlflow um so this is a switch that had a match conflict with an if else um",
    "start": "783920",
    "end": "789079"
  },
  {
    "text": "so we' got the switch if I zero we directly jump to the case and print I zero and again the if condition is never",
    "start": "789079",
    "end": "795120"
  },
  {
    "text": "executed because there's no label before that um with that you can write this",
    "start": "795120",
    "end": "800399"
  },
  {
    "text": "classic um so this is how C programmers in the 18s used to write M Copy um this will copy memory from one to the other",
    "start": "800399",
    "end": "806920"
  },
  {
    "text": "and the thing is we want to copy eight at a time but what if it's not divisible by eight well easy we compute the",
    "start": "806920",
    "end": "812040"
  },
  {
    "text": "remainder we jump directly to the middle of the loop do the appropriate number of increments now it's divisible by eight",
    "start": "812040",
    "end": "817760"
  },
  {
    "text": "we ignore all the cases and just do a loop until we're done so I guess this was idiomatic code um C code back in the",
    "start": "817760",
    "end": "824920"
  },
  {
    "text": "day all that um can also be combined to a macro um that we use in our code base",
    "start": "824920",
    "end": "830519"
  },
  {
    "text": "and the coworker that show me the implementation was really proud um so we've got macro switch no default it",
    "start": "830519",
    "end": "835800"
  },
  {
    "text": "essentially automatically does an default case that doesn't thir fults and the way it's implemented is using a",
    "start": "835800",
    "end": "841560"
  },
  {
    "text": "switch without any braces that begins with a default case that has an e so what's going on if I is one two or three",
    "start": "841560",
    "end": "849079"
  },
  {
    "text": "we will ignore the default case um and directly jump to the case and not that the braces are part of the a right so",
    "start": "849079",
    "end": "854800"
  },
  {
    "text": "all the bra a child child of the L statement so we'll directly jump to the appropriate case however if we don't hit",
    "start": "854800",
    "end": "861079"
  },
  {
    "text": "them we will hit the default start executing the if else and because if two is true we will directly jump to the",
    "start": "861079",
    "end": "867800"
  },
  {
    "text": "assertion and that way if we want to have a one-time check that we don't hit",
    "start": "867800",
    "end": "873079"
  },
  {
    "text": "the default case we just write switch no default instead of switch and it just works like as I said the coworker was",
    "start": "873079",
    "end": "878759"
  },
  {
    "text": "really proud when we show me ma the C++ standard L has like fixed",
    "start": "878759",
    "end": "886120"
  },
  {
    "text": "size integer types um it also has the same thing for float so we've got float",
    "start": "886120",
    "end": "891680"
  },
  {
    "text": "T and Double T and this is defined to be like the fastest float or double um on your system it's usually float and",
    "start": "891680",
    "end": "898000"
  },
  {
    "text": "double respectively but it both could be double um this is the idea behind that and if you start looking at float",
    "start": "898000",
    "end": "905199"
  },
  {
    "text": "stuff in the standard Library especially the C standard libr there's a lot of weird stuff um so we've got this macros",
    "start": "905199",
    "end": "910600"
  },
  {
    "text": "that Define rounding modes so we can say that we want to have floating operations be rounded um downwards toward negative",
    "start": "910600",
    "end": "917040"
  },
  {
    "text": "infinity or upwards always W up um the default is round toward zero so this",
    "start": "917040",
    "end": "923040"
  },
  {
    "text": "will round positive values down but negative values up um or we can also do like actual arithmetic rounding we will",
    "start": "923040",
    "end": "929480"
  },
  {
    "text": "just round to the newest R and then as this function if you set round this sets the current rounding",
    "start": "929480",
    "end": "935920"
  },
  {
    "text": "mode it's a global State you give it one of those flexs and it will change the rounding mode of certain standard Library floating Point",
    "start": "935920",
    "end": "943279"
  },
  {
    "text": "operations so we've got these um integer rounding functions in the standard Library one for each rounding mode but",
    "start": "943279",
    "end": "949720"
  },
  {
    "text": "if you want to have more Global state in your program you can also use nearby in and this uses whatever you've set in the global variable as the current rounding",
    "start": "949720",
    "end": "956120"
  },
  {
    "text": "mode so for some reason you want to change the rounding mode in one central place in your program you can just nearby in enter this will affect all",
    "start": "956120",
    "end": "962839"
  },
  {
    "text": "ring mod operation I guess this was useful for",
    "start": "962839",
    "end": "967839"
  },
  {
    "text": "something uh important Carri if you start using this um if you use round on 2.5 what will will the result be so be",
    "start": "967880",
    "end": "975360"
  },
  {
    "text": "round 2.5 will it be rounded so this rounds to nearest is the nearest two or is the nearest three three okay um and",
    "start": "975360",
    "end": "983240"
  },
  {
    "text": "then the other one we also want to nearest and use nearby in and as expected we print three and two and um",
    "start": "983240",
    "end": "988680"
  },
  {
    "text": "this is is because um stood round always on on dot five it will always round up but nearby in with every to nearest it",
    "start": "988680",
    "end": "995399"
  },
  {
    "text": "will round to the even integer so 2.5 will be rounded down to two but 3.5 will be rounded up to four so I guess now you",
    "start": "995399",
    "end": "1005240"
  },
  {
    "text": "know we've also got something called floating Point exceptions um so there are five of them um that happen on",
    "start": "1005240",
    "end": "1012480"
  },
  {
    "text": "various operations that might fail for example we can have an overflow um when the floating point value is too large or we can have an underflow which is when",
    "start": "1012480",
    "end": "1018680"
  },
  {
    "text": "we too close to zero that it just turned into zero so um if you want to annoy your co-workers um integer underflow",
    "start": "1018680",
    "end": "1025280"
  },
  {
    "text": "doesn't exist um if you have a integer value that is to negative that is still integer overflow underflow is only when",
    "start": "1025280",
    "end": "1031520"
  },
  {
    "text": "you truncate something down to zero that is non zero so um and before you think",
    "start": "1031520",
    "end": "1036798"
  },
  {
    "text": "exceptions I know what exceptions are now you don't um while you have a function to throw an exception uh you",
    "start": "1036799",
    "end": "1043240"
  },
  {
    "text": "need to call a function to check whether an exception was done so it's essentially a global flag uh that sets",
    "start": "1043240",
    "end": "1048280"
  },
  {
    "text": "when an operation occurs and then you need to frequently check that if you want to react to the exceptions so it's",
    "start": "1048280",
    "end": "1053679"
  },
  {
    "text": "part of the C library they're not really exceptions um the way they can be used this as follow so we first of all have",
    "start": "1053679",
    "end": "1059320"
  },
  {
    "text": "to clear the global flag because it's Global um then we do an operation and then afterwards we can check whether we had a division by",
    "start": "1059320",
    "end": "1065880"
  },
  {
    "text": "zero H okay okay um so if we have one divided by zero we will print infinity",
    "start": "1065880",
    "end": "1072280"
  },
  {
    "text": "and say this is a division by zero what happens if you divide Zero by",
    "start": "1072280",
    "end": "1077520"
  },
  {
    "text": "zero who knows what the result of 0 divid by Z is inting point operations n i n yeah",
    "start": "1077520",
    "end": "1084480"
  },
  {
    "text": "it's almost correct it's negative n actually and then we still print division by zero um so why is it",
    "start": "1084480",
    "end": "1091039"
  },
  {
    "text": "negative n well Nan just like any other floting point Valu has a sign bit and on Intel CPUs whenever you create a nan out",
    "start": "1091039",
    "end": "1097440"
  },
  {
    "text": "of an operation the sign bit is set so it will be printed as negative Nan but there are a couple more Nan um",
    "start": "1097440",
    "end": "1103600"
  },
  {
    "text": "because this is sort of the bit pattern of a nan the exponents is all one then you've got the sign bit and then the xit",
    "start": "1103600",
    "end": "1109480"
  },
  {
    "text": "there there can be anything um which means that on a 32-bit float you've got over 60 million different NS that you",
    "start": "1109480",
    "end": "1115640"
  },
  {
    "text": "can use so how do you get one of those n well the standard L provides a function",
    "start": "1115640",
    "end": "1120679"
  },
  {
    "text": "you give it a payload which is string and it will return a nan that will store that string essentially in the exess so",
    "start": "1120679",
    "end": "1126919"
  },
  {
    "text": "you can create a very customized n and that one is actually really useful um it's called Nan boxing so for example",
    "start": "1126919",
    "end": "1133400"
  },
  {
    "text": "consider a JavaScript interpreter it needs to store the current value which is either a number or a pointer or",
    "start": "1133400",
    "end": "1139000"
  },
  {
    "text": "something well it just turns out that you can put a pointer essentially in the Nan bits of a 64-bit FL so I can just",
    "start": "1139000",
    "end": "1145520"
  },
  {
    "text": "need to store all the values are just doubles and if they are not Nan then they are number otherwise they're",
    "start": "1145520",
    "end": "1150880"
  },
  {
    "text": "pointer to the actual data so you can just store everything every JavaScript object can fit in a double using n",
    "start": "1150880",
    "end": "1157400"
  },
  {
    "text": "boxing again Link at the end so East const versus best const",
    "start": "1157400",
    "end": "1165120"
  },
  {
    "text": "right we've got declaration specifiers const and in and we can write constant or",
    "start": "1165120",
    "end": "1170799"
  },
  {
    "text": "Inc we can also write conext for explicit or explicit Conex for but for some reason um there is no big divide in",
    "start": "1170799",
    "end": "1177520"
  },
  {
    "text": "the community which one is correct because I don't think anybody remembers which way they put it they just write",
    "start": "1177520",
    "end": "1183039"
  },
  {
    "text": "whatever they think at the moment but both are valid um you can also same with in",
    "start": "1183039",
    "end": "1188919"
  },
  {
    "text": "insigned you can have like East unsigned or west unsigned but again um there's Market potential",
    "start": "1188919",
    "end": "1194919"
  },
  {
    "text": "here and in fact the grammar just says a declaration starts with sequence of De specifiers like in or con orign and they",
    "start": "1194919",
    "end": "1202159"
  },
  {
    "text": "can be in any order so you can by that this a is a type def",
    "start": "1202159",
    "end": "1208200"
  },
  {
    "text": "in um this is a volatile flat that is also inline and static this is East con exper um which",
    "start": "1208200",
    "end": "1216600"
  },
  {
    "text": "what we're actually using in our code base because it's consistent with like const I guess um I'm not a big fan but",
    "start": "1216600",
    "end": "1222200"
  },
  {
    "text": "you know um and that one uh that is an unsigned long long uh but the unsign is",
    "start": "1222200",
    "end": "1227360"
  },
  {
    "text": "in the middle and the Longs are split up part by the fat local at the",
    "start": "1227360",
    "end": "1231720"
  },
  {
    "text": "Exon so um here's my guideline for you might advice for a company cing",
    "start": "1233000",
    "end": "1238720"
  },
  {
    "text": "guideline uh sort all declaration specifiers alphabetically that way you WR the East const and West const because",
    "start": "1238720",
    "end": "1244000"
  },
  {
    "text": "you write constant but Auto con right just sort them alphabetically it's valid",
    "start": "1244000",
    "end": "1249520"
  },
  {
    "text": "code after that we've got our DEC specifi and then we've got what's called a declarator so here the declarator is",
    "start": "1249520",
    "end": "1255880"
  },
  {
    "text": "name and the idea here is that they sort of mirror the expression sent so when you",
    "start": "1255880",
    "end": "1262919"
  },
  {
    "text": "want a pointer to an in you write a declarator that is just star pointer just like you would have in the expression or array 10 and then you do",
    "start": "1262919",
    "end": "1270039"
  },
  {
    "text": "array index or function you give it a function so it sort of like mirrors the expression synex which was the big philosophy behind C's declaration syntax",
    "start": "1270039",
    "end": "1277159"
  },
  {
    "text": "um of course then C++ V Hadad and edit references and you don't need to use an m to use a reference um so it sort of",
    "start": "1277159",
    "end": "1283720"
  },
  {
    "text": "broke that philosophy and now just random tokens you put in front of the name but",
    "start": "1283720",
    "end": "1290039"
  },
  {
    "text": "um interesting thing because it mirrors the expression syntax um you also sometimes need parent FS so the top line",
    "start": "1290039",
    "end": "1296480"
  },
  {
    "text": "is an array of pointers because if you write star array of pointers index you will get that way you will get the in uh",
    "start": "1296480",
    "end": "1302760"
  },
  {
    "text": "but the second one is a pointer to an array because likewise when you access it you first need to do reference and so you can use parentheses to control what",
    "start": "1302760",
    "end": "1309200"
  },
  {
    "text": "it means um so the gram alls that um this is a variable parents of type in",
    "start": "1309200",
    "end": "1316440"
  },
  {
    "text": "and you just put extra parentheses in there and of course by stop at one right um this is a function that returns an",
    "start": "1316440",
    "end": "1322000"
  },
  {
    "text": "INT and takes no arguments and of course um this also means that this is not a",
    "start": "1322000",
    "end": "1327559"
  },
  {
    "text": "Constructor call or something um but this is a function um that takes a variable called C of type B and returns",
    "start": "1327559",
    "end": "1334400"
  },
  {
    "text": "an in which is why you sometimes need to use curly braces for that so this is where that came from you can just put",
    "start": "1334400",
    "end": "1340559"
  },
  {
    "text": "extra parentheses around anything at the compiler essentially as a rule that when it could be a declaration it is a declaration so this is a function so",
    "start": "1340559",
    "end": "1347919"
  },
  {
    "text": "this is a function um and not a construct so you can put multiple",
    "start": "1347919",
    "end": "1354320"
  },
  {
    "text": "declarators in a line using comma so this is to In A and B um then we've got a pointer to an in C and because the",
    "start": "1354320",
    "end": "1361320"
  },
  {
    "text": "star is part of the clator not of the de specifier sequence um this code only has one pointer A and B is a regular in",
    "start": "1361320",
    "end": "1367760"
  },
  {
    "text": "because the star is not part of the type so to speak it's part of the name itself um you can initialize variables",
    "start": "1367760",
    "end": "1374679"
  },
  {
    "text": "so D is now 42 um you can also call the default Constructor except oops this is",
    "start": "1374679",
    "end": "1380360"
  },
  {
    "text": "a function call so e is a function and that takes no arguments and returns an in so you can just declare functions in",
    "start": "1380360",
    "end": "1385960"
  },
  {
    "text": "the middle of your variables um by stop at one um f is a function that takes an",
    "start": "1385960",
    "end": "1391080"
  },
  {
    "text": "INT and returns an INT and we can just write so if you want to declare a lot of function that all return an in for",
    "start": "1391080",
    "end": "1396159"
  },
  {
    "text": "example just declare them in one line using Comm I've seen that once actually",
    "start": "1396159",
    "end": "1402039"
  },
  {
    "text": "in code my uni Professor once with about to do some passing stuff it was um",
    "start": "1402039",
    "end": "1408039"
  },
  {
    "text": "surprising um and yeah then we've got this thing um so I didn't put it in my speaker notes",
    "start": "1408039",
    "end": "1414200"
  },
  {
    "text": "what it is so now I don't know um it's something like it's function that returns a function po or something um",
    "start": "1414200",
    "end": "1419679"
  },
  {
    "text": "but we can this is valid syntax um so function poters right nice",
    "start": "1419679",
    "end": "1426120"
  },
  {
    "text": "syntax this is a function pointer um this is a function thats a function",
    "start": "1426120",
    "end": "1431360"
  },
  {
    "text": "pointer right so you just need to put parenthesis around there put the star in the middle and then get an extra",
    "start": "1431360",
    "end": "1437000"
  },
  {
    "text": "argument list at the end for free um this is an array function",
    "start": "1437000",
    "end": "1443039"
  },
  {
    "text": "pointers but there's one final Place we've got Lambda and lambas are implicitly convertible to function",
    "start": "1443039",
    "end": "1448120"
  },
  {
    "text": "pointers when they don't um capture anything so the comparable generates",
    "start": "1448120",
    "end": "1454000"
  },
  {
    "text": "something like that this is a Lambda that doesn't capture anything implicitly convertible to function pointer except",
    "start": "1454000",
    "end": "1459240"
  },
  {
    "text": "that's not the correct syntax to for conversion operator to function pointer",
    "start": "1459240",
    "end": "1464320"
  },
  {
    "text": "um maybe that um so we put extra parentheses put the star in the middle so we sort of the name is operator and",
    "start": "1464320",
    "end": "1470840"
  },
  {
    "text": "then the arguments and then the star means it Returns the function pointer um that one isn't right either um okay",
    "start": "1470840",
    "end": "1477679"
  },
  {
    "text": "maybe that maybe we put the operator in front and just the name is empty and we just have that so the middle empty this",
    "start": "1477679",
    "end": "1483080"
  },
  {
    "text": "is the argument list of the conversion operator um but that one isn't right either uh so then you get creative and",
    "start": "1483080",
    "end": "1488960"
  },
  {
    "text": "try that um msbc actually accepts that um but the other compilers look at that and say no um so this is also not the",
    "start": "1488960",
    "end": "1496399"
  },
  {
    "text": "thing and the reason there actually is no Syntax for a conversion op function you just cannot",
    "start": "1496399",
    "end": "1503559"
  },
  {
    "text": "write the type there and it's an overset in the grammar if you want to write a conversion operator to function pointer",
    "start": "1503559",
    "end": "1509000"
  },
  {
    "text": "you have to use a type diff um or you have to use Auto and then have the compiler figure out what the type is right that this is again an oversight in",
    "start": "1509000",
    "end": "1516360"
  },
  {
    "text": "the grammar there is no grammar that allows you to put a function pointer there um similar thing you can also that",
    "start": "1516360",
    "end": "1521760"
  },
  {
    "text": "can't have a conversion operator to a reference to an aay or something it's just no way to write that in",
    "start": "1521760",
    "end": "1526960"
  },
  {
    "text": "C++ which again is an oversight but then again like it's whatever the syntax is",
    "start": "1526960",
    "end": "1532600"
  },
  {
    "text": "like it wouldn't be readable anyway so just use a type or",
    "start": "1532600",
    "end": "1538159"
  },
  {
    "text": "AO so we finally managed to get our function pointer now we want to use it and correctly we would write it like so",
    "start": "1538159",
    "end": "1543960"
  },
  {
    "text": "so we take the address of a function store it in a function pointer and then de reference it to get it however uh we",
    "start": "1543960",
    "end": "1549559"
  },
  {
    "text": "don't need to write all this noise we can just write it like so so we don't need an EMP when we get the address of a",
    "start": "1549559",
    "end": "1555360"
  },
  {
    "text": "function and we don't need a star when we want to call through a function point and this is because of two two rules the",
    "start": "1555360",
    "end": "1560880"
  },
  {
    "text": "first one says there's an implicit conversion from a function to a pointer to a function so this allows the first line and then the second rule says that",
    "start": "1560880",
    "end": "1567799"
  },
  {
    "text": "a function call either needs to be a function pointer or a function so essentially the compiler will implicitly D reference a function pointer when you",
    "start": "1567799",
    "end": "1573760"
  },
  {
    "text": "call it so you can get the noise however the first world is interesting a function type can be implicitly",
    "start": "1573760",
    "end": "1579960"
  },
  {
    "text": "converted to a type pointer to itself so when we call a function we",
    "start": "1579960",
    "end": "1586480"
  },
  {
    "text": "might as well write it like that right we put the star there because the compiler will implicitly then convert it to the address we de reference it to get",
    "start": "1586480",
    "end": "1592760"
  },
  {
    "text": "the function back and then we can call it and um then we can do it again so again each time before the start the",
    "start": "1592760",
    "end": "1598720"
  },
  {
    "text": "compiler protect the address and WR by two we can do it three times or however",
    "start": "1598720",
    "end": "1603919"
  },
  {
    "text": "many times you want it just implicitly converts D reference converts D reference and so on so if you want to do",
    "start": "1603919",
    "end": "1609120"
  },
  {
    "text": "extra you know I don't know stars in your program um here you",
    "start": "1609120",
    "end": "1615480"
  },
  {
    "text": "go um um this is um some code that uses some Global declarations and we don't",
    "start": "1617080",
    "end": "1624520"
  },
  {
    "text": "actually need to put the Declarations of the global variables at Global scope um we can put them inside the function and",
    "start": "1624520",
    "end": "1630240"
  },
  {
    "text": "this does the exact same thing um because int Global is marked as extern it is still like a statically linked has",
    "start": "1630240",
    "end": "1636600"
  },
  {
    "text": "static lifetime it's not a local VAR and functions are implicitly extern so this will just work um so there is this is",
    "start": "1636600",
    "end": "1643399"
  },
  {
    "text": "because there is no link between the visibility of a name",
    "start": "1643399",
    "end": "1648480"
  },
  {
    "text": "and the linkage and Lifetime and so on so there is no difference between this code and that code except now the names",
    "start": "1648480",
    "end": "1654559"
  },
  {
    "text": "are not visible outside of F and if you wanted to call them you have to declare them again but this is allowed you can",
    "start": "1654559",
    "end": "1660320"
  },
  {
    "text": "just put them inside for greater encapsulation or something um and this also means that people always say that",
    "start": "1660320",
    "end": "1666120"
  },
  {
    "text": "static static has so many meanings um this is true in C++ but it is not true in C because in C the only difference",
    "start": "1666120",
    "end": "1673480"
  },
  {
    "text": "between a static at file scope and a static at function scope is the visibility of the decaration static just",
    "start": "1673480",
    "end": "1679039"
  },
  {
    "text": "means this this thing has internal linkage and static station and whether",
    "start": "1679039",
    "end": "1684120"
  },
  {
    "text": "we put it outside the function or inside the function doesn't make any difference right so static just means one thing and",
    "start": "1684120",
    "end": "1689919"
  },
  {
    "text": "the rest is just the consequence of other language features and this is because unlike in C++ um the initializer",
    "start": "1689919",
    "end": "1695240"
  },
  {
    "text": "of a static has to be like a constant expression so both variables are always initialized at compile time and not the first time you call the function so",
    "start": "1695240",
    "end": "1701399"
  },
  {
    "text": "there really is no difference in between file Statics and function Statics in C it's the same thing it's just the",
    "start": "1701399",
    "end": "1707480"
  },
  {
    "text": "consequence of other that so we've got a main function a main",
    "start": "1707480",
    "end": "1714960"
  },
  {
    "text": "function has a tration and um this is comment better you have some code and then you want to",
    "start": "1714960",
    "end": "1720880"
  },
  {
    "text": "catch an exception and lock an error um you can sort of write it a bit more compactly using a function TR block so",
    "start": "1720880",
    "end": "1726919"
  },
  {
    "text": "essentially you sort of get rid of the outter parentheses um out outter braces",
    "start": "1726919",
    "end": "1732480"
  },
  {
    "text": "and just write it like so so you've got a main and then you immediately got a try with the tri block and then you got",
    "start": "1732480",
    "end": "1738279"
  },
  {
    "text": "catch blocks at the end of the function and that way you can save a bit of time when you want to write a main that essentially tce everything um the",
    "start": "1738279",
    "end": "1744760"
  },
  {
    "text": "motivation for this feature actually um member initializers list so what to do if a member initializer thows how do you",
    "start": "1744760",
    "end": "1751240"
  },
  {
    "text": "catch that exception right you there's no scope convered to catch block except a function TR catch block so um that way",
    "start": "1751240",
    "end": "1757880"
  },
  {
    "text": "you can catch an exception C in a member initial the list and still react to it um this is sort of like it's a bit of a",
    "start": "1757880",
    "end": "1763399"
  },
  {
    "text": "weird syntax but it's a bit of a special case",
    "start": "1763399",
    "end": "1768159"
  },
  {
    "text": "so we've got struct and we've got class and the only difference is the visibility right in a struct everything is public and in a class everything is",
    "start": "1769880",
    "end": "1775840"
  },
  {
    "text": "private but there are a couple of more places where you can use the keyboard class so for example you've got an enim",
    "start": "1775840",
    "end": "1782000"
  },
  {
    "text": "class um you can also write an enom spct and they mean the exact same thing it's",
    "start": "1782000",
    "end": "1787120"
  },
  {
    "text": "just that the grammar just allows the keyboard class or the keyboard so you can mean the exact same thing no",
    "start": "1787120",
    "end": "1792320"
  },
  {
    "text": "difference um you can pick either one you have template parameters you can",
    "start": "1792320",
    "end": "1798039"
  },
  {
    "text": "you can have a type name t uh or you can have a class T what about template struct",
    "start": "1798039",
    "end": "1806360"
  },
  {
    "text": "T so is that legal code we've got a template that takes a stru t like",
    "start": "1806360",
    "end": "1812880"
  },
  {
    "text": "similar as it did a class T is that allow who thinks that is legal code okay the majority thinks this is a",
    "start": "1812880",
    "end": "1820080"
  },
  {
    "text": "trick question and don't want to answer I think um this is in fact legal code but it is also a trick question because",
    "start": "1820080",
    "end": "1827159"
  },
  {
    "text": "this doesn't do what you think it does um the way you instantiate the template is you give it an object of type T of",
    "start": "1827159",
    "end": "1834080"
  },
  {
    "text": "course um so the struct t is an unnamed non-type template parameter of type",
    "start": "1834080",
    "end": "1840480"
  },
  {
    "text": "struct T it's it does not affect it doesn't get a type it gets an object of type T and so if you want to instantiate",
    "start": "1840480",
    "end": "1847360"
  },
  {
    "text": "it you have to give it an object of type T and this only happens with struct if you have a class this is still you give",
    "start": "1847360",
    "end": "1853080"
  },
  {
    "text": "it a type um but if you write Str T this is a non- type template parameter of type t",
    "start": "1853080",
    "end": "1859200"
  },
  {
    "text": "right there there's a name missing in there it's just somebody pointed out to me um when I told them that I'm giving a",
    "start": "1859200",
    "end": "1864799"
  },
  {
    "text": "talk about C++ features you might not know and they were like oh you try out struct T in a template um",
    "start": "1864799",
    "end": "1871799"
  },
  {
    "text": "yeah so if you want to really confuse people um how to use your template this is the way to",
    "start": "1871799",
    "end": "1878279"
  },
  {
    "text": "go um when you've got classes you can build a class hierarchy and then you can use Dynamic cast to do cast in that",
    "start": "1878279",
    "end": "1884440"
  },
  {
    "text": "classy for example with Dynamic cast you can do a checkdown cast to check whether we really have a deived",
    "start": "1884440",
    "end": "1890120"
  },
  {
    "text": "class um you can also do what's called a side cast so you've got dived that has two bases base one and base two and",
    "start": "1890120",
    "end": "1896240"
  },
  {
    "text": "you've got a pointer to base one and you want to get a pointer to base two and then you can use a dynamic cast and will",
    "start": "1896240",
    "end": "1901480"
  },
  {
    "text": "sort of go down to derived and then back up to base two and again this is checked only if you really have a derived object",
    "start": "1901480",
    "end": "1906559"
  },
  {
    "text": "so this is a checked Side cast and there's a third use for damic cast a dynamic cast to void star and what this",
    "start": "1906559",
    "end": "1913639"
  },
  {
    "text": "one does it gets you the address of the mouse Drive type so here again same same deal we've got two base classes and then",
    "start": "1913639",
    "end": "1920039"
  },
  {
    "text": "a div class that inherits from both of them and we've got a pointer to base two and we want to get a pointer to the",
    "start": "1920039",
    "end": "1925240"
  },
  {
    "text": "beginning of the derived object so like the pointer to base tool points in the middle of the object and we want to get a pointer to the actual derived object",
    "start": "1925240",
    "end": "1931760"
  },
  {
    "text": "and then we can use Dynamic C to void star which gives us essentially the same address as the entire object so it will",
    "start": "1931760",
    "end": "1937200"
  },
  {
    "text": "just offset the pointer to the appropriate place and of course it has to return a void star because it the the",
    "start": "1937200",
    "end": "1942760"
  },
  {
    "text": "type is has to be known at compile time but like the dynamic type of the thing is known at one time so it the best it",
    "start": "1942760",
    "end": "1948639"
  },
  {
    "text": "can give you the address and then you need something else to know how to cast that to the propop type so um this one is really Niche",
    "start": "1948639",
    "end": "1956880"
  },
  {
    "text": "feature but it can be useful in cases like for example um we've got St any in the standard Library which owns any",
    "start": "1956880",
    "end": "1962399"
  },
  {
    "text": "object of type T and you may want to have an any which is a pointer to any object um you can construct it directly",
    "start": "1962399",
    "end": "1969000"
  },
  {
    "text": "from a reference and then you will just take the address and get typ ID to have like the type of the thing uh but you",
    "start": "1969000",
    "end": "1974720"
  },
  {
    "text": "can also give it like a base class reference and then you want to type Ed just works but if you want to store the",
    "start": "1974720",
    "end": "1981039"
  },
  {
    "text": "address you cannot just take the address of Base because this might be in the middle of an object and then you do a Down cast and to the thing not on the",
    "start": "1981039",
    "end": "1987840"
  },
  {
    "text": "initial address but like of a sub object and this will just break so you have to use Dynamic cast to void star and this",
    "start": "1987840",
    "end": "1993159"
  },
  {
    "text": "will give you the actual address of the dynamic object at that point it's a really neich situation but if you know",
    "start": "1993159",
    "end": "1998799"
  },
  {
    "text": "about it it can be useful",
    "start": "1998799",
    "end": "2002518"
  },
  {
    "text": "so um if you don't want to use any uh you might want to use Union so this is a union you want to sort of window events",
    "start": "2009519",
    "end": "2016720"
  },
  {
    "text": "right so we've got an event kind and then we've got various payload um so for keyboard event it's the key code we've clicked on and",
    "start": "2016720",
    "end": "2022840"
  },
  {
    "text": "so and um the size of this thing is the size of three un 32s because we've got a",
    "start": "2022840",
    "end": "2029440"
  },
  {
    "text": "un 8 and then each payload are two un 32s but we need to have pading between the un8 and the union so we've got like",
    "start": "2029440",
    "end": "2035679"
  },
  {
    "text": "three bites of padding in the middle and this is a bit frustrating for me I like",
    "start": "2035679",
    "end": "2040960"
  },
  {
    "text": "to pick my types uh tightly and like there is enough space in the payload to also store the event kind so as some I",
    "start": "2040960",
    "end": "2047120"
  },
  {
    "text": "want to get rid of the pening and one way to do it is to store the event kind not outside of the Union but inside of",
    "start": "2047120",
    "end": "2053000"
  },
  {
    "text": "each um Union member so then we can tightly Peg it inside the payload and don't need the petting um and we can do",
    "start": "2053000",
    "end": "2060040"
  },
  {
    "text": "that because of a quirk about Union exess World um so in standard C++ you're only allowed to access the union member",
    "start": "2060040",
    "end": "2066000"
  },
  {
    "text": "that is currently active but there's one exception and that exception has to do when you have um when you want to read a",
    "start": "2066000",
    "end": "2073079"
  },
  {
    "text": "member of the active Union member that is also present in another Union member there standard I put it on there it's a",
    "start": "2073079",
    "end": "2079118"
  },
  {
    "text": "bit convoluted it talks about the common initial sequence which is just a sequence of members and so on that the",
    "start": "2079119",
    "end": "2084280"
  },
  {
    "text": "layout compatible details don't matter what the end effect is is that you've got the union where each alternative",
    "start": "2084280",
    "end": "2091240"
  },
  {
    "text": "starts with the event kind and then you can access the event kind through any",
    "start": "2091240",
    "end": "2096599"
  },
  {
    "text": "Union member regard of which one is active because everyone has it right um so you can just write Mouse click. even",
    "start": "2096599",
    "end": "2103480"
  },
  {
    "text": "though you're a keyboard event you can write keyboard. even though you're mouse event or you can just write union. kind",
    "start": "2103480",
    "end": "2109000"
  },
  {
    "text": "because it's also in there right it's the same member in everyone and you're allowed to read it through every",
    "start": "2109000",
    "end": "2114400"
  },
  {
    "text": "alternative and that way um you can sort of you get rid of the padding essentially you can Tech your pack your",
    "start": "2114400",
    "end": "2120000"
  },
  {
    "text": "union more closely um because you don't need the Ping bites by inlining this thing so if You' got this pattern in a",
    "start": "2120000",
    "end": "2125320"
  },
  {
    "text": "code base of a union of essentially like a an enom tag and then some payload uh consider whether you might be able to",
    "start": "2125320",
    "end": "2131040"
  },
  {
    "text": "move the enom tag into the payload as long as you do it in the same place in every member like it has to be the first member and everything for the trick to",
    "start": "2131040",
    "end": "2137560"
  },
  {
    "text": "work obviously um then you're able to do that and this is completely well formed C++ code um no",
    "start": "2137560",
    "end": "2145200"
  },
  {
    "text": "issues um this trick can also be used to do something really cool um so we have a",
    "start": "2145359",
    "end": "2151800"
  },
  {
    "text": "type that doesn't have a default Constructor it's an empty type without a default Constructor and then we can write this function legally create",
    "start": "2151800",
    "end": "2158240"
  },
  {
    "text": "object that returns an object of the type even though the type doesn't have a default Constructor or any other",
    "start": "2158240",
    "end": "2163599"
  },
  {
    "text": "Constructor we allowed to legally create an object and this was really useful back in the day back in the day I think",
    "start": "2163599",
    "end": "2169480"
  },
  {
    "text": "before C++ 20 U where captal lambas didn't have a default Constructor uh but they are the captal list so they should",
    "start": "2169480",
    "end": "2176079"
  },
  {
    "text": "have one so they're empty types so you can legally create them and the trick Lou gave a lightning talk at now about",
    "start": "2176079",
    "end": "2182119"
  },
  {
    "text": "it um essentially the trick revolves the fact that um if you have an empty type it doesn't affect the common initial",
    "start": "2182119",
    "end": "2187200"
  },
  {
    "text": "sequence the union so you put it in the union with something else construct another alternative you're allowed to",
    "start": "2187200",
    "end": "2192240"
  },
  {
    "text": "construct then read it through the other alternative and it's a beautiful trick again read the uh watch the lightning",
    "start": "2192240",
    "end": "2198839"
  },
  {
    "text": "talk Link at the end and while we at unions um unions can",
    "start": "2198839",
    "end": "2205319"
  },
  {
    "text": "be be private they can have member functions they can have Constructors they can have destructors just like any other class um so this is Union with",
    "start": "2205319",
    "end": "2212640"
  },
  {
    "text": "private members and member functions and all the other the thing so this is complete a",
    "start": "2212640",
    "end": "2219839"
  },
  {
    "text": "lot now the um standard library has a couple of um dynamically sized container",
    "start": "2221800",
    "end": "2227000"
  },
  {
    "text": "Vector deck list forward list um we've also got Vector bu which is different from Vector t for KN reasons uh and then",
    "start": "2227000",
    "end": "2234240"
  },
  {
    "text": "we've got valay now Val is an interesting contor Val is an actual Vector right you can create Val a float",
    "start": "2234240",
    "end": "2240960"
  },
  {
    "text": "and then you can do arithmetic on them um remember similar to the",
    "start": "2240960",
    "end": "2246040"
  },
  {
    "text": "proposed um you can also use it for matrices and then you can index them so this will",
    "start": "2246040",
    "end": "2252319"
  },
  {
    "text": "compute the phas by indexing into the diagonal and then you've got member by Sum and so on it has a bunch of useful",
    "start": "2252319",
    "end": "2257760"
  },
  {
    "text": "operations um wide range of mathematical operations it has overloads for S and cosine and whatever um they implicitly",
    "start": "2257760",
    "end": "2264160"
  },
  {
    "text": "restrict so if you have pass two by reference to a function the compiler is allowed to assume that they don't Al us to do more optimizations it can use",
    "start": "2264160",
    "end": "2270839"
  },
  {
    "text": "expression templates to do like fused multiply ads and so on so it's a pretty nifty type but nobody uses it",
    "start": "2270839",
    "end": "2278240"
  },
  {
    "text": "um it's been in the standard Library since 98 and it's sort of been forgotten about um and because it's forgotten",
    "start": "2278240",
    "end": "2283440"
  },
  {
    "text": "about the stand libr venders don't spend time optimizing it um so it's not sort of like chicken in the egg",
    "start": "2283440",
    "end": "2291160"
  },
  {
    "text": "problem nobody uses it so they're not optimized and because it's not optimized nobody uses it um but it's there like in",
    "start": "2291160",
    "end": "2296960"
  },
  {
    "text": "principle if you want to do like math and dynamically sized vectors right this is like a baseline a pretty easy thing",
    "start": "2296960",
    "end": "2304200"
  },
  {
    "text": "right there just include the head up the standard IB also has exceptions",
    "start": "2304200",
    "end": "2310240"
  },
  {
    "text": "um this is St time this is the full interface of St time uh then you can use",
    "start": "2310240",
    "end": "2315880"
  },
  {
    "text": "it by using throwing it and formatting a message in there now notice anything odd",
    "start": "2315880",
    "end": "2321880"
  },
  {
    "text": "about the interface of St one",
    "start": "2321880",
    "end": "2325400"
  },
  {
    "text": "time in the fail function we're giving it the St string so we invoking the first",
    "start": "2327880",
    "end": "2333720"
  },
  {
    "text": "Constructor um and because the string is a temporary like one time errow has to",
    "start": "2333720",
    "end": "2339480"
  },
  {
    "text": "store that string somewhere yet the copy Constructor has no accept so where's the string actually stored that the copy",
    "start": "2339480",
    "end": "2346079"
  },
  {
    "text": "doesn't involve Dynamic keep allocation and there's no accept and the answer for that is the Run error is ref count",
    "start": "2346079",
    "end": "2352040"
  },
  {
    "text": "string so when you copy it you don't copy the string you just copy a ref count it's essentially like a share",
    "start": "2352040",
    "end": "2358800"
  },
  {
    "text": "pointer of a string like an immutable share pointer of string so if you need a we count string in your application um",
    "start": "2358800",
    "end": "2364760"
  },
  {
    "text": "here you go um the interface is a bit weird so suppose you use a bit of a weer class um but here we go easy ref cont",
    "start": "2364760",
    "end": "2372520"
  },
  {
    "text": "string in five code of course you might want to use",
    "start": "2372520",
    "end": "2378280"
  },
  {
    "text": "exceptions um and for that you so this is code that uses exceptions using a",
    "start": "2378280",
    "end": "2383760"
  },
  {
    "text": "function f block or the thing but you might want to use exceptions before performance reasons and um because in",
    "start": "2383760",
    "end": "2389640"
  },
  {
    "text": "exceptions essentially goto right so we when they throw an exception you want to go to the catch block um so let's try",
    "start": "2389640",
    "end": "2395440"
  },
  {
    "text": "using go to um we want to go to the catch block um that one doesn't work um because you cannot use go to to jump to",
    "start": "2395440",
    "end": "2401520"
  },
  {
    "text": "another function you have to use um long",
    "start": "2401520",
    "end": "2406720"
  },
  {
    "text": "jump so long jump jumping of the C standard Library um you need a global variable to store the label um that's",
    "start": "2406720",
    "end": "2413760"
  },
  {
    "text": "the first thing and then main you call set jump and this will remember the current position and store it in the",
    "start": "2413760",
    "end": "2419800"
  },
  {
    "text": "label and then it will return zero and when it returns zero you can do your actual book you call compute and if",
    "start": "2419800",
    "end": "2426359"
  },
  {
    "text": "there's an error you use long jump and you give it a label and some payload um this has to be non zero well if it is",
    "start": "2426359",
    "end": "2433040"
  },
  {
    "text": "zero it will just be turned into one so just give it the number and what this means is it will jump to the label uh to",
    "start": "2433040",
    "end": "2439319"
  },
  {
    "text": "the address do in the label which is the set jump call and now set jump will return the number that you gave it so",
    "start": "2439319",
    "end": "2445240"
  },
  {
    "text": "the second time when set jump returns because it's a function that returns twice um it will give return one and we",
    "start": "2445240",
    "end": "2450560"
  },
  {
    "text": "will enter the clean up case so this is essentially exceptions without using exceptions and but just by using goto to",
    "start": "2450560",
    "end": "2457359"
  },
  {
    "text": "the function and in fact like early exception implementations were implemented in top of setup um the only thing you need to do is you need to",
    "start": "2457359",
    "end": "2463480"
  },
  {
    "text": "ensure that the destructors are called and you've got proper exceptions because this one will not call D structors it just directly jump to the set jump and",
    "start": "2463480",
    "end": "2472040"
  },
  {
    "text": "the implementation is actually pretty cool if you're interested in that so essentially set jump just needs to save the current execution registers and then",
    "start": "2472040",
    "end": "2478440"
  },
  {
    "text": "long jump just restores them and the CPU will continue in the new St um again at the end there's a block post that talks",
    "start": "2478440",
    "end": "2483560"
  },
  {
    "text": "about the implementation using assembly and so on so if you're interested in that um I pretty",
    "start": "2483560",
    "end": "2489799"
  },
  {
    "text": "cool so this is a function that takes two and it will do um addition on them",
    "start": "2491520",
    "end": "2497319"
  },
  {
    "text": "does this F function have any undefined Behavior that's not a question I mean",
    "start": "2497319",
    "end": "2502800"
  },
  {
    "text": "the title is right there on top of the slide so yes this can have integer overflow um what about",
    "start": "2502800",
    "end": "2509880"
  },
  {
    "text": "multiplication yeah same thing and Sean P actually comput uh calculated it and",
    "start": "2510079",
    "end": "2515160"
  },
  {
    "text": "there's overflow on 99.99999 3% of all possible inputs you can give to the function because there are not that many",
    "start": "2515160",
    "end": "2522440"
  },
  {
    "text": "ins that multiplied still fit in an INT so essentially this function basically always does UB right if you give it just",
    "start": "2522440",
    "end": "2529680"
  },
  {
    "text": "something it will be UB makes it easier to do analysis what about division is the",
    "start": "2529680",
    "end": "2535119"
  },
  {
    "text": "undefined behavior and division yeah divide by zero um B is non zero is the undefined behavior in this",
    "start": "2535119",
    "end": "2542520"
  },
  {
    "text": "function yes there is because of two compx",
    "start": "2542520",
    "end": "2547920"
  },
  {
    "text": "so in two complement um positive value start with a zero and then we've got some bits and negative value start with",
    "start": "2547920",
    "end": "2553160"
  },
  {
    "text": "a one what about zero itself well zero is",
    "start": "2553160",
    "end": "2559480"
  },
  {
    "text": "thought as all zeros which means that we have more POS negative values and positive values right so 8 bit goes down",
    "start": "2559480",
    "end": "2565960"
  },
  {
    "text": "to 28 but up only to 127 because the zero pattern is positive so we got one",
    "start": "2565960",
    "end": "2571520"
  },
  {
    "text": "more negative value this means that inmin divided by negative one is integ overflow because",
    "start": "2571520",
    "end": "2577960"
  },
  {
    "text": "the result would be negative in Min but that is one more than in Max so you will have integer overflow using division but",
    "start": "2577960",
    "end": "2584319"
  },
  {
    "text": "only those those combination of inputs everything else is fine but those ones are",
    "start": "2584319",
    "end": "2590040"
  },
  {
    "text": "into and I mean in practice is a bad thing to say about UB but in practice in Min",
    "start": "2590040",
    "end": "2596319"
  },
  {
    "text": "divided by negative one will just stay in Min which is a fun property to have",
    "start": "2596319",
    "end": "2601720"
  },
  {
    "text": "um okay um division as a cous modul a modul b is there undefined Behavior",
    "start": "2601720",
    "end": "2609960"
  },
  {
    "text": "there well yes there is inmin modu negative one is integ Overflow even",
    "start": "2610160",
    "end": "2615480"
  },
  {
    "text": "though in module negative 1 is zero because inmin is divisible by negative one so what's going on here well it's U",
    "start": "2615480",
    "end": "2622480"
  },
  {
    "text": "because the standard say so um if the result is representable of division then this is the behavior otherwise both A",
    "start": "2622480",
    "end": "2629359"
  },
  {
    "text": "and B and a module of B are defined Behavior so if division is undefined behavior modul is as well and this is a",
    "start": "2629359",
    "end": "2635960"
  },
  {
    "text": "good reason the standard just does didn't put it just in there just to annoy you um this is because for example",
    "start": "2635960",
    "end": "2641280"
  },
  {
    "text": "on Intel when you want to do a division you compute both Division and modulo and then just read different results from",
    "start": "2641280",
    "end": "2647720"
  },
  {
    "text": "different registers so of course if division has an integer overflow then modulo like does the same so it also has",
    "start": "2647720",
    "end": "2654520"
  },
  {
    "text": "to beend behavior and on arm it's even more obvious because well not if you read the assembly but if you read the P",
    "start": "2654520",
    "end": "2660480"
  },
  {
    "text": "code um arm doesn't have modul so it does a division and then computes the remainder so if the division already",
    "start": "2660480",
    "end": "2666640"
  },
  {
    "text": "triggers undefined Behavior then the modul does as well so in me modul negative one even though the result",
    "start": "2666640",
    "end": "2672319"
  },
  {
    "text": "would be zero and there all the everything's fine because inin divided by negative one would be undefined",
    "start": "2672319",
    "end": "2677960"
  },
  {
    "text": "Behavior so is module and again this is only only this combination of inputs triggers undefined",
    "start": "2677960",
    "end": "2684720"
  },
  {
    "text": "Behavior it's pretty fun uh if you want to debug it um then you look at lb and",
    "start": "2684720",
    "end": "2691280"
  },
  {
    "text": "then lb says we've got a floating Point exception which is a weird name integer division by zero which is not at all",
    "start": "2691280",
    "end": "2698200"
  },
  {
    "text": "what we're doing but doing modular in modular negative one so this is a bit",
    "start": "2698200",
    "end": "2704119"
  },
  {
    "text": "confusing so um I told you there was going to be a quiz at the end um so I'm",
    "start": "2704359",
    "end": "2709920"
  },
  {
    "text": "going to show you my favorite C++ quiz um this is a tweet by Richard Smith",
    "start": "2709920",
    "end": "2715960"
  },
  {
    "text": "um qu time we are assuming an lp64 or lp64 system what does this print think",
    "start": "2715960",
    "end": "2723680"
  },
  {
    "text": "about it for the moment I told you everything um you needed to know to understand do um and let talk just just",
    "start": "2723680",
    "end": "2729480"
  },
  {
    "text": "give you a moment think about it what will this code",
    "start": "2729480",
    "end": "2733800"
  },
  {
    "text": "print okay I've heard somebody is ready so let's um go through it um so we've",
    "start": "2744040",
    "end": "2750160"
  },
  {
    "text": "got a string letter um string L let's have type con",
    "start": "2750160",
    "end": "2757040"
  },
  {
    "text": "a is a short un plus do integer promotion remember so the result is going to be an",
    "start": "2757559",
    "end": "2766200"
  },
  {
    "text": "in size of returns a size T um the standard doesn't give a lot of guarantees it says the size of char is",
    "start": "2766200",
    "end": "2772200"
  },
  {
    "text": "one regardless of the actual bit width of CH otherwise it's implementation you find however um Richard told us we on",
    "start": "2772200",
    "end": "2779079"
  },
  {
    "text": "lp64 and they size of in equator four um so we're using the built-in",
    "start": "2779079",
    "end": "2785480"
  },
  {
    "text": "array index operator because the right hand side is a CH array and this is commutative so we can swap it around for",
    "start": "2785480",
    "end": "2791680"
  },
  {
    "text": "index because that's result of size of into the string is the same thing as swwa around so the results six um and in",
    "start": "2791680",
    "end": "2798520"
  },
  {
    "text": "fact if you look at the poll results um majority six we're good um just to",
    "start": "2798520",
    "end": "2804160"
  },
  {
    "text": "double check let's actually run the program and see what it prints and it prints",
    "start": "2804160",
    "end": "2810000"
  },
  {
    "text": "one you didn't remember the operator procedence table I've showed you before",
    "start": "2811880",
    "end": "2818440"
  },
  {
    "text": "then we've got subscript and then we got cof cof is actually a un operator it's a",
    "start": "2818839",
    "end": "2824880"
  },
  {
    "text": "un operator whose precedence is lower than array ending so this code is equivalent to",
    "start": "2824880",
    "end": "2832400"
  },
  {
    "text": "that code which if you put in parentheses I want it is that",
    "start": "2832400",
    "end": "2837520"
  },
  {
    "text": "code and the standard says the result of size of apply to any of the Nar character types is one so the code was",
    "start": "2837520",
    "end": "2844240"
  },
  {
    "text": "completely posable to begin with and the that he gave for the platform isn't really",
    "start": "2844240",
    "end": "2849839"
  },
  {
    "text": "important so this is why this is my favorite plus plus question okay um I've got a bit of time",
    "start": "2849839",
    "end": "2856160"
  },
  {
    "text": "left so I I will annoy you with something that I'm really annoyed by and",
    "start": "2856160",
    "end": "2861240"
  },
  {
    "text": "sorry about that I just need to get it out system um what is 10 Modo",
    "start": "2861240",
    "end": "2868200"
  },
  {
    "text": "7 three okay um what is 10 modus 7",
    "start": "2869000",
    "end": "2876760"
  },
  {
    "text": "I mean it's St three right um 10 id7 is1 and then you've got a remain of",
    "start": "2879800",
    "end": "2886599"
  },
  {
    "text": "three what isus 10id by 7 now here's where it gets",
    "start": "2886599",
    "end": "2891839"
  },
  {
    "text": "interesting so um this is what the standard guarantees about modulo and",
    "start": "2891839",
    "end": "2897920"
  },
  {
    "text": "division um if you do a modul b and Aid B this formula holds so a is equal to a/",
    "start": "2897920",
    "end": "2904839"
  },
  {
    "text": "B * B plus the remainder and the absolute value of a module to B is less than b so will you will not have a",
    "start": "2904839",
    "end": "2911599"
  },
  {
    "text": "remainder that that could have fit in b um but that gives at least four",
    "start": "2911599",
    "end": "2917400"
  },
  {
    "text": "options depending on how you define Division and model um you can use tration so a",
    "start": "2917400",
    "end": "2923839"
  },
  {
    "text": "divided by B and then you truncate um that means that you will R the quion toward zero uh the remainder will copy",
    "start": "2923839",
    "end": "2930400"
  },
  {
    "text": "the sign of a and will be in the interval either 0 to a or a um to zero depending on what the sign of a is",
    "start": "2930400",
    "end": "2938359"
  },
  {
    "text": "um you can use FL division so you always round down towards inmin and then we will have the sign of B and like so the",
    "start": "2938359",
    "end": "2945440"
  },
  {
    "text": "remainder interal just flips a bit depending on the sign of b um you can do the opposite um round up",
    "start": "2945440",
    "end": "2952040"
  },
  {
    "text": "and then you will all always have the opposite sign of B which is a bit of not Choice um and then again the interval or",
    "start": "2952040",
    "end": "2959000"
  },
  {
    "text": "you can do actual wounding you w to the closest integer and then the reer can either be positive or negative depending",
    "start": "2959000",
    "end": "2964799"
  },
  {
    "text": "on whether you w it up or down uh and and the interval will be between minus Bales and positive Bales so sort of like",
    "start": "2964799",
    "end": "2970960"
  },
  {
    "text": "symmetric and zero and except for oh yeah and then we've got ukan",
    "start": "2970960",
    "end": "2979000"
  },
  {
    "text": "there you want depending on the sign of B to ensure essentially that the sign is always positive so a module B is always",
    "start": "2979000",
    "end": "2984119"
  },
  {
    "text": "a positive value which means it will be in the interval 0 to Absolute a and except for bounded and seing division",
    "start": "2984119",
    "end": "2990319"
  },
  {
    "text": "the other three are used by different programming languages at different times and they all make sense and what this",
    "start": "2990319",
    "end": "2997000"
  },
  {
    "text": "means is um C++ just dis SPO does truncator division um lu does FL Division and D or hcal or I think Excel",
    "start": "2997000",
    "end": "3005920"
  },
  {
    "text": "also does ukan division for positive values they all agree um if you do modul on division by",
    "start": "3005920",
    "end": "3013880"
  },
  {
    "text": "negative values um truncated C agrees but fla division it it's less than you",
    "start": "3013880",
    "end": "3021000"
  },
  {
    "text": "expect because 10 divid by - 7 will be minus one plus some remainder so we will round it down to- two and that means",
    "start": "3021000",
    "end": "3027880"
  },
  {
    "text": "that the remainder now you're overshooting you're you're now at4 so you're uh you're now at 14 so you have",
    "start": "3027880",
    "end": "3034240"
  },
  {
    "text": "to subtract four to get back to seven um the interesting thing is so",
    "start": "3034240",
    "end": "3040480"
  },
  {
    "text": "minus 10 divid by 7 in C++ it will be min-1 and then -3 just to make it all",
    "start": "3040480",
    "end": "3046160"
  },
  {
    "text": "back out so you will - 10/ 7 7 * -1 is - 7 and then you need to subtract another",
    "start": "3046160",
    "end": "3052040"
  },
  {
    "text": "three so this is where that came from um and then FL and ukian Division",
    "start": "3052040",
    "end": "3057200"
  },
  {
    "text": "um minus two and then you add four to get up so you overshoot it a bit and then finally if both are",
    "start": "3057200",
    "end": "3063319"
  },
  {
    "text": "negative um you've got the missing combination in the table so now truncated and fla agrees and ukian ensures that because the modu always",
    "start": "3063319",
    "end": "3069760"
  },
  {
    "text": "should be positive we have to overshoot it uh and then add something back and",
    "start": "3069760",
    "end": "3075640"
  },
  {
    "text": "this is like there is no reason why programming languages should do the same operation differently but they all",
    "start": "3075640",
    "end": "3082000"
  },
  {
    "text": "picked something different and now you have to deal with it it's just like Division and modle by negative numbers is just you have to check your language",
    "start": "3082000",
    "end": "3088440"
  },
  {
    "text": "documentation if you want to do it um ukan is really nice um because um this",
    "start": "3088440",
    "end": "3093520"
  },
  {
    "text": "is when you want to St something you can use ukian division because the result will always be in the appropriate",
    "start": "3093520",
    "end": "3098720"
  },
  {
    "text": "remainder um truncated is nice because that's what the hardware does so it's the first one um I don't know by L",
    "start": "3098720",
    "end": "3104880"
  },
  {
    "text": "wanted to be special um I think maybe that one is also the one Exel uses so Exel doesn't use trated it uses one of",
    "start": "3104880",
    "end": "3111839"
  },
  {
    "text": "those two I don't know um anyways this really bucks me um there's a nice table",
    "start": "3111839",
    "end": "3117520"
  },
  {
    "text": "on Wikipedia that lists all the different programming languages and what Behavior they have it's like uh yeah",
    "start": "3117520",
    "end": "3123680"
  },
  {
    "text": "anyways so that was my talk about C++ features you might not know hope you find the using enom trick useful um if",
    "start": "3123680",
    "end": "3131880"
  },
  {
    "text": "you promise not to use some of those code um we are hiring at thingsa we do a lot of C++ code and also we've got a",
    "start": "3131880",
    "end": "3137599"
  },
  {
    "text": "booth we've got a lot of free stuff at the booth please go over there just after the talk grab anything I don't",
    "start": "3137599",
    "end": "3142839"
  },
  {
    "text": "want to take it all back home with me um so thank you very much all the URL links at the um that link um thank you",
    "start": "3142839",
    "end": "3152880"
  }
]