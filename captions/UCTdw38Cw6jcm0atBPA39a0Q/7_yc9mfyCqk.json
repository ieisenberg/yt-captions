[
  {
    "text": "hello world good evening London thank you very much for joining",
    "start": "9080",
    "end": "15240"
  },
  {
    "text": "this session this is the last write of the day welcome to null and void",
    "start": "15240",
    "end": "20480"
  },
  {
    "text": "everything about nothing in net I will be spending 60 minutes to talk about",
    "start": "20480",
    "end": "25599"
  },
  {
    "text": "pretty much nothing um we will talk about the billion doll mistake and how",
    "start": "25599",
    "end": "31439"
  },
  {
    "text": "we can avoid it with the c 8 feature nullable reference types we'll also um",
    "start": "31439",
    "end": "37120"
  },
  {
    "text": "understand the difference to the previously existing nullable value types we also take a look at other forms of",
    "start": "37120",
    "end": "43320"
  },
  {
    "text": "nothing like void and nulls when we talk about bwe instead of by value we will",
    "start": "43320",
    "end": "50520"
  },
  {
    "text": "take a look behind the scenes of how the nullable reference types feature is implemented in C so that we could use it",
    "start": "50520",
    "end": "56719"
  },
  {
    "text": "for our own um waslin based or or onetime V reflection based tooling we",
    "start": "56719",
    "end": "63239"
  },
  {
    "text": "also take a look at interop for example how the brand new FSH 9 is now also inter oping allowing nullable reference",
    "start": "63239",
    "end": "69880"
  },
  {
    "text": "types as well and how we can with nulls cross the process boundary with",
    "start": "69880",
    "end": "75000"
  },
  {
    "text": "Json and at the end we're going to close things with trying to introduce patterns",
    "start": "75000",
    "end": "80119"
  },
  {
    "text": "to avoid null in the very first",
    "start": "80119",
    "end": "84360"
  },
  {
    "text": "place hello my name is Stefan I'm from Austria I a um Microsoft MVP uh Chad",
    "start": "87079",
    "end": "95439"
  },
  {
    "text": "brains Community contributor and a CO organizer of the net meetups in",
    "start": "95439",
    "end": "100840"
  },
  {
    "text": "Vienna I am also a co-host of a live stream and I am a lead software engineer",
    "start": "100840",
    "end": "108439"
  },
  {
    "text": "at trenes we built a tool called TSA and endtoend no code software testing suit",
    "start": "108439",
    "end": "115920"
  },
  {
    "text": "and in the service that we are working on WE extensively use nullable reference",
    "start": "115920",
    "end": "120960"
  },
  {
    "text": "types and the warnings that they produce actually shifting this to compile time errors so that we don't or either don't",
    "start": "120960",
    "end": "130280"
  },
  {
    "text": "at all or reduce significantly nullable reference uh null reference exceptions at one time I'm wondering who has who",
    "start": "130280",
    "end": "138080"
  },
  {
    "text": "has observed in their production environments a null reference exception somewhat",
    "start": "138080",
    "end": "144400"
  },
  {
    "text": "recently I see a lot of hands I can actually lower this hand however well",
    "start": "144400",
    "end": "149879"
  },
  {
    "text": "recently I I made a bit of an embarrassing mistake if a keynote found exception so other types of exceptions",
    "start": "149879",
    "end": "157080"
  },
  {
    "text": "my goal is here to make all of you just a little bit more n aware when it comes to the C language so that we can all",
    "start": "157080",
    "end": "162640"
  },
  {
    "text": "drop this number lower or perhaps even reduce it in in the",
    "start": "162640",
    "end": "168560"
  },
  {
    "text": "future I assume mostly net developers who is not developing with",
    "start": "168560",
    "end": "175560"
  },
  {
    "text": "net who is not developing with",
    "start": "177040",
    "end": "182840"
  },
  {
    "text": "cop some fop wa go cool I do not know how go is",
    "start": "182840",
    "end": "190319"
  },
  {
    "text": "dealing with nullability but perhaps there are some patterns that um apply here as well wonderful um this QR code",
    "start": "190319",
    "end": "198080"
  },
  {
    "text": "links to my to my GitHub page where I list all my socials if there are any questions about nothing that I am not",
    "start": "198080",
    "end": "204560"
  },
  {
    "text": "able to answer for you here tonight",
    "start": "204560",
    "end": "209000"
  },
  {
    "text": "so let's start with void void",
    "start": "214400",
    "end": "220920"
  },
  {
    "text": "is the return type that we use for methods or local functions or delegates",
    "start": "220920",
    "end": "226680"
  },
  {
    "text": "to indicate that this doesn't return anything can also be used for pointers to an unknown",
    "start": "226680",
    "end": "232680"
  },
  {
    "text": "type now did you know that the type void actually exists in the type system",
    "start": "232680",
    "end": "240000"
  },
  {
    "text": "when we take a look at a record I'm putting this into",
    "start": "240000",
    "end": "247239"
  },
  {
    "text": "oops sharp. which is compiling the",
    "start": "248319",
    "end": "254879"
  },
  {
    "text": "code to ilil and then decompiling it back to to C so we get we basically",
    "start": "255400",
    "end": "261359"
  },
  {
    "text": "obliterate all the syntactic sugar and when we have a record it emits a lot of",
    "start": "261359",
    "end": "266880"
  },
  {
    "text": "um members for this type for example it becomes equatable and tell all of the equality",
    "start": "266880",
    "end": "272960"
  },
  {
    "text": "operators and it also emits a deconstruct method that we can use in order to deconstruct this type into a",
    "start": "272960",
    "end": "279720"
  },
  {
    "text": "value tub we the parenthesis syntax and this deconstruct method is",
    "start": "279720",
    "end": "287199"
  },
  {
    "text": "void if you would like to be",
    "start": "287199",
    "end": "292639"
  },
  {
    "text": "reflection understand if a specific method returns void we can do this by",
    "start": "292639",
    "end": "298440"
  },
  {
    "text": "well getting the method from this record type and this method the deconstruct",
    "start": "298440",
    "end": "306759"
  },
  {
    "text": "method the return type of it we can actually um assert that it is type of",
    "start": "306759",
    "end": "312400"
  },
  {
    "text": "void if we can actually F12 or go to definition of void this is a type that exists in the runtime system. void but",
    "start": "312400",
    "end": "319960"
  },
  {
    "text": "we actually cannot use it from C it's prohibited to use from C if we were try to write system. void that's illegal the",
    "start": "319960",
    "end": "327319"
  },
  {
    "text": "sh compiler says no we need to use the void",
    "start": "327319",
    "end": "332360"
  },
  {
    "text": "keyword now let's go into the world of null and",
    "start": "335520",
    "end": "341520"
  },
  {
    "text": "nothing I tend to start my demos uh recently",
    "start": "341919",
    "end": "347199"
  },
  {
    "text": "always with a Visual Basic application because the syntax um is very descriptive it says exactly what it does",
    "start": "347199",
    "end": "354240"
  },
  {
    "text": "I have here a string and I assign nothing to it I have of a string that",
    "start": "354240",
    "end": "360680"
  },
  {
    "text": "contains something if I try to get the length of the string that has something in this",
    "start": "360680",
    "end": "366120"
  },
  {
    "text": "case we get 30 characters that hello comma space world exclamation mark has",
    "start": "366120",
    "end": "372360"
  },
  {
    "text": "if you try to dreference the null string exactly here and we try to get the",
    "start": "372360",
    "end": "378720"
  },
  {
    "text": "length of the string that is referencing null we get the null reference exception",
    "start": "378720",
    "end": "384479"
  },
  {
    "text": "the billion dollar mistake now jumping into",
    "start": "384479",
    "end": "391560"
  },
  {
    "text": "shop Let's declare a string and if we have say hello we can",
    "start": "401560",
    "end": "409199"
  },
  {
    "text": "do the same thing say console. wh line and print the length of the",
    "start": "409199",
    "end": "415520"
  },
  {
    "text": "string to the terminal and this should give us six characters if I C it",
    "start": "415520",
    "end": "422919"
  },
  {
    "text": "correctly I'm running the wrong",
    "start": "422919",
    "end": "427319"
  },
  {
    "text": "application and here we go six characters not not what if this string is",
    "start": "434680",
    "end": "440280"
  },
  {
    "text": "null we have the very same problem we will run into the null reference exception because we try to dreference",
    "start": "440280",
    "end": "446319"
  },
  {
    "text": "an instance of string that is null and there is no length property to access so",
    "start": "446319",
    "end": "451560"
  },
  {
    "text": "we have the null we exception now wouldn't it be cool if we could get warnings ahead of",
    "start": "451560",
    "end": "457400"
  },
  {
    "text": "time um nullable reference types is an opt-in feature so with existing code",
    "start": "457400",
    "end": "463360"
  },
  {
    "text": "bases it per default it's not enabled you need to opt in it if you use the",
    "start": "463360",
    "end": "469800"
  },
  {
    "text": "from the latest net sdks the template for libraries web applications console applications you will always get this",
    "start": "469800",
    "end": "476759"
  },
  {
    "text": "property by default if you take a look there will be nullable enable and with that flag we now opt in to the nullable",
    "start": "476759",
    "end": "484560"
  },
  {
    "text": "reference types features and now we can place question marks to indicate",
    "start": "484560",
    "end": "491159"
  },
  {
    "text": "nullability to our reference types and I'm here already getting a",
    "start": "491159",
    "end": "496759"
  },
  {
    "text": "warning this warning says converting the null literal or possible null value into",
    "start": "496759",
    "end": "502440"
  },
  {
    "text": "non-nullable type this string here we have not annotated it with a question mark so we",
    "start": "502440",
    "end": "508800"
  },
  {
    "text": "intended it to null non-nullable but if we try to assign null to it we get this",
    "start": "508800",
    "end": "515518"
  },
  {
    "text": "warning and this is what the null reference nullable reference type feature is all about to annotate your",
    "start": "515519",
    "end": "522959"
  },
  {
    "text": "instances with a question mark or not and to produce warnings if you",
    "start": "522959",
    "end": "530920"
  },
  {
    "text": "um do not adhere to the nullability contract so we can now question mark",
    "start": "530920",
    "end": "537360"
  },
  {
    "text": "here and now we have the war warning down there on when we use it",
    "start": "537360",
    "end": "543880"
  },
  {
    "text": "oops we not get the warning a d reference of a possibly null",
    "start": "543880",
    "end": "549399"
  },
  {
    "text": "reference and this is not indicating that here we may run in a null reference exception well from this code it's quite",
    "start": "549399",
    "end": "556079"
  },
  {
    "text": "obvious because it's just in the next line I see it the line above that we say null but what if this was a parameter to",
    "start": "556079",
    "end": "561800"
  },
  {
    "text": "a method and to calling another method and we have an immense stack Trace difficult to trace where this null is",
    "start": "561800",
    "end": "568160"
  },
  {
    "text": "maybe originating form so when we annotate our Fields our properties our arguments with nullability correctly we",
    "start": "568160",
    "end": "575640"
  },
  {
    "text": "can then also indicate to the consumer whether null may be",
    "start": "575640",
    "end": "582640"
  },
  {
    "text": "passed but as I mentioned it's an opin feature if we have for example a type A",
    "start": "587279",
    "end": "592880"
  },
  {
    "text": "called it the null oblivious type this type was not built with um",
    "start": "592880",
    "end": "601040"
  },
  {
    "text": "nullability in mind so this feature was not",
    "start": "601040",
    "end": "606600"
  },
  {
    "text": "enabled um let's ask the instance this type has let's take a quick peek at it a",
    "start": "606600",
    "end": "613839"
  },
  {
    "text": "number and a text I do have a default Constructor which leaves the number to",
    "start": "613839",
    "end": "620079"
  },
  {
    "text": "zero in is a value type the default of an in zero and the string the default of",
    "start": "620079",
    "end": "626680"
  },
  {
    "text": "every reference type is null so again if we try to D reference text",
    "start": "626680",
    "end": "633320"
  },
  {
    "text": "instance maybe again let's get the length of it we will just again run into the null",
    "start": "633320",
    "end": "639880"
  },
  {
    "text": "reference exception but we didn't get any warning because in this case for this",
    "start": "639880",
    "end": "646880"
  },
  {
    "text": "type we actually disabled the feature you can also enable and disable this feature on a source um type on the",
    "start": "646880",
    "end": "653560"
  },
  {
    "text": "source file level if we switch to the same type but that two similar type with",
    "start": "653560",
    "end": "660800"
  },
  {
    "text": "the same shape but that was built with nullability in mind the null aware type now we do again get the warning where we",
    "start": "660800",
    "end": "668639"
  },
  {
    "text": "potentially D reference something that may be null here and it's warning us we still at one time have the very same",
    "start": "668639",
    "end": "674800"
  },
  {
    "text": "behavior at one time nullable reference types doesn't really have an impact it's all at compile time so we can shift",
    "start": "674800",
    "end": "681639"
  },
  {
    "text": "warnings to compile time before they occur in one time",
    "start": "681639",
    "end": "687680"
  },
  {
    "text": "now because when yeah when we take a look at the text this property is actually annotated with uh the nullable",
    "start": "692320",
    "end": "698800"
  },
  {
    "text": "if I weren't doing that if I would say this text this string is non-nullable we",
    "start": "698800",
    "end": "704120"
  },
  {
    "text": "now get a warning here in the default con or the parameterless Constructor because this parameterless Constructor",
    "start": "704120",
    "end": "710639"
  },
  {
    "text": "lets the backing field of this Auto implemented property to null so we here",
    "start": "710639",
    "end": "715880"
  },
  {
    "text": "now get the warning that the null the non-nullable property text is uninitialized and we could fix this by",
    "start": "715880",
    "end": "722760"
  },
  {
    "text": "saying text equals to empty string here now we don't have any warnings",
    "start": "722760",
    "end": "728519"
  },
  {
    "text": "anymore or we remove this Constructor all together and now we move the",
    "start": "728519",
    "end": "734440"
  },
  {
    "text": "responsibility to not pass in null to pass something that is n null to the caller so now here I need to invoke The",
    "start": "734440",
    "end": "741320"
  },
  {
    "text": "Constructor that has two parameters let's say we call in 100 for the number and text well again if a pass in null we",
    "start": "741320",
    "end": "749360"
  },
  {
    "text": "do get the nullable warning if we pass in something non-null for example an",
    "start": "749360",
    "end": "754399"
  },
  {
    "text": "empty string the warning",
    "start": "754399",
    "end": "758160"
  },
  {
    "text": "disappears now we have seen the syntax before nullable reference types the question mark that we add to types to",
    "start": "759720",
    "end": "766920"
  },
  {
    "text": "type names we have seen this with value types for example I'm taking look at",
    "start": "766920",
    "end": "773560"
  },
  {
    "text": "interor just string that's a reference type so it's a class ner that's a struct",
    "start": "773560",
    "end": "779600"
  },
  {
    "text": "so it's a value type and we had before nullable value types already so we could",
    "start": "779600",
    "end": "784720"
  },
  {
    "text": "write in question mark and then could assign null to",
    "start": "784720",
    "end": "791079"
  },
  {
    "text": "it but nullable there is a significant difference between nullable value types and nullable reference types because a",
    "start": "792399",
    "end": "799440"
  },
  {
    "text": "nullable value type is not is not totally different if we were to dot",
    "start": "799440",
    "end": "805120"
  },
  {
    "text": "into the value we have two properties we have the value prop property and the has",
    "start": "805120",
    "end": "810519"
  },
  {
    "text": "value property so where are these coming from when we jump into uh the Declaration we actually see we're now in",
    "start": "810519",
    "end": "816920"
  },
  {
    "text": "a totally different type this is no longer an instance of int it's not an instance of nullable of T where the t is",
    "start": "816920",
    "end": "824880"
  },
  {
    "text": "now the int so nullable value types when you add the question mark really at one",
    "start": "824880",
    "end": "830759"
  },
  {
    "text": "time it's a totally different type n reference types there is no different",
    "start": "830759",
    "end": "835920"
  },
  {
    "text": "type we later on inspect what's going on under the hood but it's the very same type so nullable reference types have no",
    "start": "835920",
    "end": "841399"
  },
  {
    "text": "impact at one time and in order to use now this nullable reference nullable value type",
    "start": "841399",
    "end": "847240"
  },
  {
    "text": "correctly I could do my null check uh my has value check and only if it has a value we then access the value if we",
    "start": "847240",
    "end": "856120"
  },
  {
    "text": "were to access the value without doing the check in case this integer is null",
    "start": "856120",
    "end": "862519"
  },
  {
    "text": "we don't get a null reference exception because the thing is with structs the thing with value types is they always",
    "start": "862519",
    "end": "868720"
  },
  {
    "text": "have a value a value type can never be null so a nullable value type is a bit",
    "start": "868720",
    "end": "875240"
  },
  {
    "text": "of an oxymoron but synta syntactically it makes sense because we can assign",
    "start": "875240",
    "end": "880959"
  },
  {
    "text": "null to it but a value type can never be null so if we have a nullable value type and try to get the value of it without",
    "start": "880959",
    "end": "888480"
  },
  {
    "text": "checking if it has a value we may run into an invalid operation exception it's",
    "start": "888480",
    "end": "893720"
  },
  {
    "text": "not a null reference exception because value types can never be null",
    "start": "893720",
    "end": "900120"
  },
  {
    "text": "another form of null are WS per default when we have a field a",
    "start": "901880",
    "end": "911680"
  },
  {
    "text": "property a argument to a to um method we",
    "start": "911680",
    "end": "917920"
  },
  {
    "text": "usually they're usually copied by value if you have the we keyword then we call them by reference there's also",
    "start": "917920",
    "end": "925120"
  },
  {
    "text": "nullability when it comes to reference those managed references I have here an example in my type I have",
    "start": "925120",
    "end": "932920"
  },
  {
    "text": "a value and I'm getting here a copy of that value I'm just assigning it to",
    "start": "932920",
    "end": "938880"
  },
  {
    "text": "another local variable so it's an in it's a value type so we copy this value",
    "start": "938880",
    "end": "943959"
  },
  {
    "text": "over and I'm also getting a ref of this value type whenever we have a ref this",
    "start": "943959",
    "end": "949800"
  },
  {
    "text": "is now an alias to the original value so in this case value W is an alias to",
    "start": "949800",
    "end": "957120"
  },
  {
    "text": "value now when we modify the copy the original",
    "start": "957120",
    "end": "962680"
  },
  {
    "text": "value remains unchanged when we modify the ref so the",
    "start": "962680",
    "end": "968839"
  },
  {
    "text": "Alias the original value is changing respectively because it's a reference to",
    "start": "968839",
    "end": "974680"
  },
  {
    "text": "this value to this memory location directly it's not a copy when we deal with refs we can also",
    "start": "974680",
    "end": "981160"
  },
  {
    "text": "have null refs um in this case when we want to check if a we is null we need to",
    "start": "981160",
    "end": "989079"
  },
  {
    "text": "use the method unsafe is null we then pass this we to this method and in this",
    "start": "989079",
    "end": "995279"
  },
  {
    "text": "case we get false because this is not a null we in order to produce a null we we",
    "start": "995279",
    "end": "1001040"
  },
  {
    "text": "say null unsafe. null you may see this example um having",
    "start": "1001040",
    "end": "1008199"
  },
  {
    "text": "an example of a dictionary we initializing it with a key and a",
    "start": "1008199",
    "end": "1013399"
  },
  {
    "text": "value and if I have the use case of um trying to",
    "start": "1013399",
    "end": "1019959"
  },
  {
    "text": "um trying to get a value without as trying to set a Val trying to add a",
    "start": "1019959",
    "end": "1025558"
  },
  {
    "text": "value if it doesn't exist yet so that we don't override existing values um we would need to first check does this",
    "start": "1025559",
    "end": "1031600"
  },
  {
    "text": "dictionary container key and if it does not then adds the value and in some cases uh a dictionary may contain bigger",
    "start": "1031600",
    "end": "1039640"
  },
  {
    "text": "structs well I just have an integer here nure is very small it is copied by value",
    "start": "1039640",
    "end": "1045678"
  },
  {
    "text": "so the copying is super fast in very rare cases you may have biger bigger strs and if we copy big STS around they",
    "start": "1045679",
    "end": "1052559"
  },
  {
    "text": "may show up in in performance Diagnostics so in order to avoid that we",
    "start": "1052559",
    "end": "1058919"
  },
  {
    "text": "could not we could avoid getting a copy of this value but actually getting a ref to this value and a ref on 64-bit",
    "start": "1058919",
    "end": "1065480"
  },
  {
    "text": "systems um that's a 64bit integer so it's you copy it super quickly and for",
    "start": "1065480",
    "end": "1072559"
  },
  {
    "text": "example if we now there is a method in collections Marshall where we can get a ref to that value or a null we if it",
    "start": "1072559",
    "end": "1080200"
  },
  {
    "text": "doesn't exist so I'm asking here for the other key this other key doesn't exist",
    "start": "1080200",
    "end": "1085400"
  },
  {
    "text": "so we get a null we and in this case now null we returns true you may need this in some cases or",
    "start": "1085400",
    "end": "1092120"
  },
  {
    "text": "may see this in some cases in the BCL this is used quite a bit because if we",
    "start": "1092120",
    "end": "1098000"
  },
  {
    "text": "for example check into dictionary. try get value and jump into the code this is",
    "start": "1098000",
    "end": "1105320"
  },
  {
    "text": "what they use internally they have some internal find Value method that returns this value by W and then does a null we",
    "start": "1105320",
    "end": "1112360"
  },
  {
    "text": "on it if it is a null that means the value has not been found if there not a",
    "start": "1112360",
    "end": "1117840"
  },
  {
    "text": "n r the value was found so much for the different um",
    "start": "1117840",
    "end": "1124280"
  },
  {
    "text": "manifestations of null and",
    "start": "1124280",
    "end": "1128679"
  },
  {
    "text": "nothingness when we design our types we need to be now mindful about placing question marks or not",
    "start": "1131240",
    "end": "1139840"
  },
  {
    "text": "um I believe I forgot to include a",
    "start": "1165200",
    "end": "1170720"
  },
  {
    "text": "no there it is excuse me so um for example I have here this",
    "start": "1171400",
    "end": "1177440"
  },
  {
    "text": "base type an abstract class which has a get method that may return null now",
    "start": "1177440",
    "end": "1185200"
  },
  {
    "text": "other types may overwhite this derived class maybe this derived class will",
    "start": "1185200",
    "end": "1191400"
  },
  {
    "text": "never return null so we can actually over wide this get but we move the null",
    "start": "1191400",
    "end": "1198480"
  },
  {
    "text": "blade notation so from a contractual level in this case we can actually return something that is not",
    "start": "1198480",
    "end": "1205159"
  },
  {
    "text": "null but it doesn't work the other way around if we have on the base class if we say on the base class level this is",
    "start": "1205159",
    "end": "1211559"
  },
  {
    "text": "not null but on the derve type we say this",
    "start": "1211559",
    "end": "1217200"
  },
  {
    "text": "maybe null we now get a warning here because",
    "start": "1217200",
    "end": "1222880"
  },
  {
    "text": "we're getting less strict because if we were to instantiate a type of arrived",
    "start": "1222880",
    "end": "1229400"
  },
  {
    "text": "and assigned this to an instance of type base at compile time it says well get",
    "start": "1229400",
    "end": "1235440"
  },
  {
    "text": "returns a non-nullable string but at one time it's actually theive type and it may return null so we wouldn't produce a",
    "start": "1235440",
    "end": "1242880"
  },
  {
    "text": "warning but still get potential null reference exceptions and therefore we get here yet another nullable reference",
    "start": "1242880",
    "end": "1249360"
  },
  {
    "text": "exception so be mindful when you when you expect something to not accept null",
    "start": "1249360",
    "end": "1256200"
  },
  {
    "text": "then avoid the question mark If there may it if it may be null and you have null checks in your method then you can",
    "start": "1256200",
    "end": "1262559"
  },
  {
    "text": "do a string question mark now is the compiler figuring out",
    "start": "1262559",
    "end": "1269720"
  },
  {
    "text": "where to place the warnings and this is happening via the static flow",
    "start": "1269720",
    "end": "1275600"
  },
  {
    "text": "analysis again I have here a small example we have a type that has a property and non nullable",
    "start": "1279200",
    "end": "1286039"
  },
  {
    "text": "property we have one Constructor that that property so this one does not produce a Constructor uh an air warning",
    "start": "1286039",
    "end": "1294039"
  },
  {
    "text": "if I were to add a question mark here I would be assigning a non-nullable string",
    "start": "1294039",
    "end": "1299559"
  },
  {
    "text": "to a uh excuse me a nullable string to a non-nullable string therefore we get the warning",
    "start": "1299559",
    "end": "1306320"
  },
  {
    "text": "here uh but this default Constructor does not set text so just leave it",
    "start": "1306360",
    "end": "1311880"
  },
  {
    "text": "uninitialized leaves it to null and therefore we get the warning in this Constructor and with this information",
    "start": "1311880",
    "end": "1318039"
  },
  {
    "text": "now the compiler is enhancing these types and information with a bunch of",
    "start": "1318039",
    "end": "1325320"
  },
  {
    "text": "attributes if we were to put this code again into",
    "start": "1325320",
    "end": "1330760"
  },
  {
    "text": "sharl we see that if I search for question mark in the decompiled code there is no question mark So this",
    "start": "1331840",
    "end": "1337960"
  },
  {
    "text": "question mark is just a c syntactic sugar that doesn't really exist so this",
    "start": "1337960",
    "end": "1343360"
  },
  {
    "text": "feature is working by adding attributes to your code",
    "start": "1343360",
    "end": "1349840"
  },
  {
    "text": "so when we have nullability we actually add those nullable context and nullable attributes to all of our",
    "start": "1349960",
    "end": "1357400"
  },
  {
    "text": "types if I were to disable the feature n disable those attributes are now gone",
    "start": "1357400",
    "end": "1366159"
  },
  {
    "text": "let's enable it again and here they are so the compiler is placing these attributes and informing then the",
    "start": "1366159",
    "end": "1373520"
  },
  {
    "text": "consumer whether something may be null or is not null",
    "start": "1373520",
    "end": "1380080"
  },
  {
    "text": "there is a bunch of magic numbers here um a zero means",
    "start": "1381559",
    "end": "1387960"
  },
  {
    "text": "oblivious that means we do not know so this code was not compiled with nullability in",
    "start": "1387960",
    "end": "1393320"
  },
  {
    "text": "mind we have one that means not annotated oh sorry that means",
    "start": "1393320",
    "end": "1398799"
  },
  {
    "text": "annotated uh annotated not annotated so uh one means",
    "start": "1398799",
    "end": "1405000"
  },
  {
    "text": "not annotated so that's not nullable two means",
    "start": "1405000",
    "end": "1411000"
  },
  {
    "text": "annotated so this is nullable so there is a question mark on that and in this case we have a nullable",
    "start": "1411200",
    "end": "1418520"
  },
  {
    "text": "context of one which now applies to the entire type and therefore this string is",
    "start": "1418520",
    "end": "1423679"
  },
  {
    "text": "non nullable if we were to place a question mark here on the second",
    "start": "1423679",
    "end": "1429840"
  },
  {
    "text": "Constructor we get here now because this nullable context up there um applies to the entire ire type",
    "start": "1432279",
    "end": "1439520"
  },
  {
    "text": "but there is now another um nullable context that is close that only applies to this Constructor therefore is closer",
    "start": "1439520",
    "end": "1446880"
  },
  {
    "text": "to the thing that this attribut is added to and therefore wins and we have the two here and the two means it is",
    "start": "1446880",
    "end": "1453080"
  },
  {
    "text": "annotated which indicates this question mark so we have our producing types that",
    "start": "1453080",
    "end": "1460240"
  },
  {
    "text": "now have those attributes and the consumer when we for example dot into something or try to assign something",
    "start": "1460240",
    "end": "1466000"
  },
  {
    "text": "that maybe or may or may not be null we then get this warnings due to these attributes and the C compiler is",
    "start": "1466000",
    "end": "1472520"
  },
  {
    "text": "consuming these attributes and the F compiler now since F 9 as",
    "start": "1472520",
    "end": "1478480"
  },
  {
    "text": "well now we talked about defaults the default of a reference type is null the",
    "start": "1480840",
    "end": "1486000"
  },
  {
    "text": "default of a value type is zero initializing all its",
    "start": "1486000",
    "end": "1491919"
  },
  {
    "text": "Fields I'm having here a my class this my class has",
    "start": "1493200",
    "end": "1499080"
  },
  {
    "text": "a number and a string text and we ensure that in this Constructor we also set the",
    "start": "1499080",
    "end": "1505520"
  },
  {
    "text": "reference type to something so we do not have any warnings so we fulfill here the nullable contract it's",
    "start": "1505520",
    "end": "1513360"
  },
  {
    "text": "non-nullable if we do the default of this instance",
    "start": "1513360",
    "end": "1521000"
  },
  {
    "text": "Now the default of a reference type since my class is a class is basically the equivalent to null so this is always",
    "start": "1521000",
    "end": "1528360"
  },
  {
    "text": "is null and therefore this instance is null the thing about",
    "start": "1528360",
    "end": "1535320"
  },
  {
    "text": "structs I have here another a struct it's the same type that only different is this is now a Str struct it also has",
    "start": "1535320",
    "end": "1542039"
  },
  {
    "text": "a non-nullable field or non-nullable reference field and a non-nullable value",
    "start": "1542039",
    "end": "1548120"
  },
  {
    "text": "field but if we were to default initialize this struct can never be null",
    "start": "1548120",
    "end": "1555399"
  },
  {
    "text": "so all its fields are zero initialized which in the case of the reference type",
    "start": "1555399",
    "end": "1562200"
  },
  {
    "text": "here will be null now we don't get any nullable warning but still we may run here in a",
    "start": "1562200",
    "end": "1570520"
  },
  {
    "text": "null reference exception if we try to dreference this this text is indeed null",
    "start": "1570520",
    "end": "1575919"
  },
  {
    "text": "at one time the compiler does not emit any nullable warnings for structs",
    "start": "1575919",
    "end": "1582840"
  },
  {
    "text": "because for a struct you can always call default you can always Z initialize all",
    "start": "1582840",
    "end": "1588480"
  },
  {
    "text": "of its Fields so even if I have the parameterless Constructor here this",
    "start": "1588480",
    "end": "1593880"
  },
  {
    "text": "parameterless Constructor is not called if we do",
    "start": "1593880",
    "end": "1599000"
  },
  {
    "text": "default that's different with reference types because a reference type we can um",
    "start": "1599000",
    "end": "1604919"
  },
  {
    "text": "just design null to it it may be null the reference but the value type always",
    "start": "1604919",
    "end": "1610159"
  },
  {
    "text": "has a value so with this default um it can be that reference types may be null",
    "start": "1610159",
    "end": "1618080"
  },
  {
    "text": "and and but the compiler doesn't Emmit warnings here because it would be very noisy and there's nothing really you can do about it because a value type always",
    "start": "1618080",
    "end": "1624559"
  },
  {
    "text": "has this default zero initializing way of constructing it another thing is about",
    "start": "1624559",
    "end": "1631799"
  },
  {
    "text": "arrays when we have arrays now initializing here in a way oops with the length of",
    "start": "1631799",
    "end": "1639159"
  },
  {
    "text": "two and I'm only setting the zero index element to",
    "start": "1639159",
    "end": "1644919"
  },
  {
    "text": "one now the zero index element will indeed one but the one index element",
    "start": "1644919",
    "end": "1652039"
  },
  {
    "text": "will be null but we don't get a warning here again if I were to say element.",
    "start": "1652039",
    "end": "1658200"
  },
  {
    "text": "length here trying to dreference it um well this assertion doesn't make sense",
    "start": "1658200",
    "end": "1663919"
  },
  {
    "text": "let's say we were to check if this element is one we do not get a nullable",
    "start": "1663919",
    "end": "1669840"
  },
  {
    "text": "warning here but we would one here in a null reference exception because we have not",
    "start": "1669840",
    "end": "1675919"
  },
  {
    "text": "initialized the element at index one",
    "start": "1675919",
    "end": "1681399"
  },
  {
    "text": "this is another bit of a caveat when it comes to arrays the compiler doesn't produce warnings here either if you if",
    "start": "1681399",
    "end": "1688080"
  },
  {
    "text": "you produce the arrays yourself if you were to use for",
    "start": "1688080",
    "end": "1693360"
  },
  {
    "text": "example um collection",
    "start": "1693360",
    "end": "1698919"
  },
  {
    "text": "initializers uh one and maybe null we now do indeed get the warning so the",
    "start": "1699279",
    "end": "1704880"
  },
  {
    "text": "compiler can check that here but those are those two caveats where we may not get nullable warnings when it comes to",
    "start": "1704880",
    "end": "1712200"
  },
  {
    "text": "reference fields instructs and when it comes to arrays that we create ourself",
    "start": "1712200",
    "end": "1718120"
  },
  {
    "text": "um with a specific length of these we need to be mindful",
    "start": "1718120",
    "end": "1723880"
  },
  {
    "text": "of so now when we have this nullable warning what can we do about it well we",
    "start": "1724799",
    "end": "1730880"
  },
  {
    "text": "can do good old null checks so if we have just having an",
    "start": "1730880",
    "end": "1738360"
  },
  {
    "text": "instance here of a record we check if this record equals null and then we have",
    "start": "1738360",
    "end": "1745120"
  },
  {
    "text": "the if and the else in the case if it's null or not a very common null check is well doing equals equals",
    "start": "1745120",
    "end": "1752559"
  },
  {
    "text": "null I'm casting this one here to object because there is a there's there's a fine difference between equality",
    "start": "1752559",
    "end": "1759480"
  },
  {
    "text": "operators if your types overload the equality operator or not because again",
    "start": "1759480",
    "end": "1766159"
  },
  {
    "text": "this record type is a record and record overloads all the equality operators if",
    "start": "1766159",
    "end": "1771679"
  },
  {
    "text": "we jump back to just example of the record type there it",
    "start": "1771679",
    "end": "1779159"
  },
  {
    "text": "is the record type actually overloads this equality so if we call equals",
    "start": "1779159",
    "end": "1786799"
  },
  {
    "text": "equals null of an instance that overloads the operator then we do call indeed in this",
    "start": "1786799",
    "end": "1794120"
  },
  {
    "text": "operator if we first upcast this instance to object now we are on object",
    "start": "1794120",
    "end": "1802039"
  },
  {
    "text": "and this is now a war null check so if we take a look at the IL code this is as much as a null check as it can",
    "start": "1802039",
    "end": "1808679"
  },
  {
    "text": "be but this is a little bit tedious so in order to get a raw null check these",
    "start": "1808679",
    "end": "1814679"
  },
  {
    "text": "days we just",
    "start": "1814679",
    "end": "1818158"
  },
  {
    "text": "write um yeah our code like so",
    "start": "1824880",
    "end": "1829919"
  },
  {
    "text": "with the with pattern matching we say is null or the opposite is not null and the",
    "start": "1829919",
    "end": "1836399"
  },
  {
    "text": "compiler can now figure out for example if we were to assign this to null and say please be",
    "start": "1836399",
    "end": "1842600"
  },
  {
    "text": "null and let's reference this record in both",
    "start": "1842600",
    "end": "1849799"
  },
  {
    "text": "cases in the if check we say record is not null so the compiler now knows that",
    "start": "1854679",
    "end": "1861080"
  },
  {
    "text": "in this block record is not null so it's safe to Der reference but everywhere",
    "start": "1861080",
    "end": "1867240"
  },
  {
    "text": "else this record may be null so we get the warning down here this could end up",
    "start": "1867240",
    "end": "1873799"
  },
  {
    "text": "in a null reference exception there's many more operators",
    "start": "1873799",
    "end": "1879679"
  },
  {
    "text": "when it comes to null",
    "start": "1879679",
    "end": "1883638"
  },
  {
    "text": "let's say we do again a string nullable text set to",
    "start": "1889320",
    "end": "1894600"
  },
  {
    "text": "null if it want to safely D reference it we could say text question mark dot",
    "start": "1894600",
    "end": "1903159"
  },
  {
    "text": "length in this case now this is an expression that will produce null in the case of this text",
    "start": "1903159",
    "end": "1910720"
  },
  {
    "text": "being null and we could uh combine this with the null kesing operator and maybe",
    "start": "1910720",
    "end": "1916679"
  },
  {
    "text": "then say something like here uh sorry that's a length um that's an integer",
    "start": "1916679",
    "end": "1921840"
  },
  {
    "text": "let's say minus one so in this case if the text is not null we get its length",
    "start": "1921840",
    "end": "1927799"
  },
  {
    "text": "if the text is null we get negative one in Array when we have an",
    "start": "1927799",
    "end": "1935679"
  },
  {
    "text": "array we can also use question mark um a question mark",
    "start": "1941039",
    "end": "1946600"
  },
  {
    "text": "indexer again asking for the length here where we will only now index into",
    "start": "1946600",
    "end": "1953840"
  },
  {
    "text": "this array if the array is not null if the array is null if this expression",
    "start": "1953840",
    "end": "1959799"
  },
  {
    "text": "produces null there's also the I need to look at",
    "start": "1959799",
    "end": "1966519"
  },
  {
    "text": "the name the coalescing assignment operator so we can write array equals equals question mark and let's then say",
    "start": "1966519",
    "end": "1974320"
  },
  {
    "text": "array. empty",
    "start": "1974320",
    "end": "1978320"
  },
  {
    "text": "where this expression now ass signs the empty array in case array is null so in",
    "start": "1980559",
    "end": "1987600"
  },
  {
    "text": "this case after both Expressions array would be empty but if this array is not",
    "start": "1987600",
    "end": "1993279"
  },
  {
    "text": "empty uh is not null let's say it's empty well let's fill it with three elements now this expression would not",
    "start": "1993279",
    "end": "2001320"
  },
  {
    "text": "be executed because it's basically an if check if the array is null then assign the right hand side to it if it's not do",
    "start": "2001320",
    "end": "2009120"
  },
  {
    "text": "nothing and in C 14 we will get a new operator when it comes to nullability",
    "start": "2009120",
    "end": "2015919"
  },
  {
    "text": "going now to the Roston repository where we can check out the features that are currently being worked on for F 14 T 14",
    "start": "2015919",
    "end": "2024240"
  },
  {
    "text": "so this may change um but we will also get a um this",
    "start": "2024240",
    "end": "2030760"
  },
  {
    "text": "nullable assignment where we could do the a question mark do dot operator and then on the right hand side assign",
    "start": "2030760",
    "end": "2037200"
  },
  {
    "text": "something to this with C 13 this will produce an compiler error this may work",
    "start": "2037200",
    "end": "2042919"
  },
  {
    "text": "if it's released in C",
    "start": "2042919",
    "end": "2045919"
  },
  {
    "text": "14 another thing about AR raay when it comes to AR raise we can have two question marks",
    "start": "2049480",
    "end": "2056320"
  },
  {
    "text": "actually we can have a question",
    "start": "2056320",
    "end": "2061159"
  },
  {
    "text": "mark on the elements type and we can have question marks on the array itself",
    "start": "2062240",
    "end": "2068440"
  },
  {
    "text": "self so this last question mark says may there array be null and the inner question mark after",
    "start": "2068440",
    "end": "2075079"
  },
  {
    "text": "the ref after the element type says elements of this array may be null so in",
    "start": "2075079",
    "end": "2081079"
  },
  {
    "text": "this case we could write we also could have a null as an element in this array",
    "start": "2081079",
    "end": "2086800"
  },
  {
    "text": "if I were to remove the question mark from the element type now this one again is flagged as a warning because each",
    "start": "2086800",
    "end": "2093440"
  },
  {
    "text": "elements should not be null they array itself however with this question",
    "start": "2093440",
    "end": "2100119"
  },
  {
    "text": "mark may be null so yeah the warning we get here is because we're not using this",
    "start": "2100680",
    "end": "2108880"
  },
  {
    "text": "array one more thing when it comes to configuring nullability",
    "start": "2117000",
    "end": "2122640"
  },
  {
    "text": "there is actually two different nullable contexts there's The nullable annotation",
    "start": "2125520",
    "end": "2131640"
  },
  {
    "text": "context that is producing those attributes that we saw and the nullable warning context which is warning us when",
    "start": "2131640",
    "end": "2138599"
  },
  {
    "text": "we try to derence something which is annotated with being null or",
    "start": "2138599",
    "end": "2143960"
  },
  {
    "text": "nullable and we can we can use this individually we can use them individually from each other when when",
    "start": "2143960",
    "end": "2150720"
  },
  {
    "text": "we jump back to the C project we enabled when we say nullable enable we enable both nullable annotations and nullable",
    "start": "2150720",
    "end": "2157359"
  },
  {
    "text": "warning Wars on the entire project level we could for example say only enable",
    "start": "2157359",
    "end": "2163599"
  },
  {
    "text": "annotations on this level so we can actually write string question mark but there would be no warnings when",
    "start": "2163599",
    "end": "2171839"
  },
  {
    "text": "it comes to knowability we could say only enable the warnings in this case we",
    "start": "2171839",
    "end": "2176920"
  },
  {
    "text": "cannot use string question mark in this assembly but we would get nullable warnings from types that we use that",
    "start": "2176920",
    "end": "2183720"
  },
  {
    "text": "have been annotated with it from third party libraries or from the BCL for",
    "start": "2183720",
    "end": "2189359"
  },
  {
    "text": "example and we can disable the feature all together which is the",
    "start": "2189359",
    "end": "2195720"
  },
  {
    "text": "default now when we enable this on a project level or whatever the default on",
    "start": "2195720",
    "end": "2202200"
  },
  {
    "text": "a project level is we can override this default on a on a source file level so",
    "start": "2202200",
    "end": "2208400"
  },
  {
    "text": "in this case well I have a Constructor uh if I make this I have here a required",
    "start": "2208400",
    "end": "2214160"
  },
  {
    "text": "text which is non-nullable but I have a Constructor that doesn't set this non-nullable",
    "start": "2214160",
    "end": "2220800"
  },
  {
    "text": "string so we would get a warning here but we can via nullable disabled warnings from this point on and Below",
    "start": "2220800",
    "end": "2228839"
  },
  {
    "text": "disable nullable warnings which means The nullable annotation context is still",
    "start": "2228839",
    "end": "2235040"
  },
  {
    "text": "active we still can use question marks here for example string text equals to",
    "start": "2235040",
    "end": "2241079"
  },
  {
    "text": "null that's still allowed if I were if I were also to enable the nullable",
    "start": "2241079",
    "end": "2246160"
  },
  {
    "text": "annotations so nullable disable annotations we now get a warning here in",
    "start": "2246160",
    "end": "2251720"
  },
  {
    "text": "this question mark because it says the annotations for nullable reference types are not",
    "start": "2251720",
    "end": "2257560"
  },
  {
    "text": "enabled a short hand for disabling both warnings and annotations is just seeing",
    "start": "2257560",
    "end": "2263720"
  },
  {
    "text": "nullable disable which disables both contexts so we can enable and disable them individually on a file by file",
    "start": "2263720",
    "end": "2270880"
  },
  {
    "text": "level um which can come in handy when you adopt this feature in your existing code bases",
    "start": "2270880",
    "end": "2277880"
  },
  {
    "text": "when we do a restore we get whatever was set on the project level so in this case",
    "start": "2278800",
    "end": "2283880"
  },
  {
    "text": "when we restore the warnings we get the default that is on the project level on the project level we enabled both so",
    "start": "2283880",
    "end": "2291280"
  },
  {
    "text": "theable annotations theable warnings in this case are enabled again for the rest",
    "start": "2291280",
    "end": "2297800"
  },
  {
    "text": "of this file until this next pre-processor directive occurs",
    "start": "2297800",
    "end": "2304160"
  },
  {
    "text": "now tools like system text Json is already making use of this feature",
    "start": "2308640",
    "end": "2314599"
  },
  {
    "text": "heavily let's take a look at a web app",
    "start": "2314599",
    "end": "2319520"
  },
  {
    "text": "example so I'm starting up an asp.net core web",
    "start": "2319800",
    "end": "2325079"
  },
  {
    "text": "app and the system cannot find the file specified now that's embarrassing",
    "start": "2325079",
    "end": "2331119"
  },
  {
    "text": "um oops let me just",
    "start": "2356480",
    "end": "2363319"
  },
  {
    "text": "quickly we some changes because I broke something down there is it just",
    "start": "2366040",
    "end": "2372920"
  },
  {
    "text": "that and let's build again",
    "start": "2391960",
    "end": "2396720"
  },
  {
    "text": "what is now hopefully starting is a small esp. net core minimal API web application I'm afraid",
    "start": "2423000",
    "end": "2431720"
  },
  {
    "text": "um can't load some assembly uh please apologize that um but this would show",
    "start": "2431720",
    "end": "2438520"
  },
  {
    "text": "yeah a little Earp on the cor web application and for",
    "start": "2438520",
    "end": "2443680"
  },
  {
    "text": "the system text Chas and dilzer we can enable options such as",
    "start": "2443680",
    "end": "2450520"
  },
  {
    "text": "respect nullable annotations which now enables the the",
    "start": "2450520",
    "end": "2456160"
  },
  {
    "text": "cizer and D izer in particular the dyer to yeah respect those annotations and if",
    "start": "2456160",
    "end": "2461720"
  },
  {
    "text": "you try to assign something null that was not annotated as null then we would",
    "start": "2461720",
    "end": "2467079"
  },
  {
    "text": "get the theer realizer would throw a Jason exception so with this in",
    "start": "2467079",
    "end": "2474920"
  },
  {
    "text": "place taking a look at the dto we have the",
    "start": "2474920",
    "end": "2480319"
  },
  {
    "text": "title is not annotated as nullable so this is non nullable but the message is",
    "start": "2480319",
    "end": "2487880"
  },
  {
    "text": "so if we were now to invoke the post API to create a new um to-do item this",
    "start": "2487880",
    "end": "2496079"
  },
  {
    "text": "request would succeed title is not annotated as nullable message is so this",
    "start": "2496079",
    "end": "2501560"
  },
  {
    "text": "null is fine I could add a message because it's just adding um it's",
    "start": "2501560",
    "end": "2508400"
  },
  {
    "text": "annotated as non-nullable but we can add something that is not null but if I were to set null for this message or leave it",
    "start": "2508400",
    "end": "2517640"
  },
  {
    "text": "out entirely so that's on ajacent level it's undefined this would now on a dzer level throw an exception and this",
    "start": "2517640",
    "end": "2524480"
  },
  {
    "text": "request would fail with I think a bad request exception so when we cross the process",
    "start": "2524480",
    "end": "2533240"
  },
  {
    "text": "boundary we don't have we don't have the yeah nullable warnings they only in this",
    "start": "2533240",
    "end": "2539520"
  },
  {
    "text": "in the um assembly uh in the in the metadata of the net assembly when we",
    "start": "2539520",
    "end": "2544960"
  },
  {
    "text": "cross the boundaries and we have annotation for example exposed VI open API and such we need then tools that",
    "start": "2544960",
    "end": "2551280"
  },
  {
    "text": "respect these annotations and in most cases the defaults",
    "start": "2551280",
    "end": "2556720"
  },
  {
    "text": "are not strict but we can opt into stricter uh Behavior such as respecting",
    "start": "2556720",
    "end": "2564880"
  },
  {
    "text": "this nullable invitations and therefore failing civilization or decivilization if this nullable contract is violated",
    "start": "2564880",
    "end": "2574319"
  },
  {
    "text": "in some cases you know better than the compiler",
    "start": "2578520",
    "end": "2584000"
  },
  {
    "text": "does and you want to suppress this nullable warnings we can do this with the",
    "start": "2584000",
    "end": "2590240"
  },
  {
    "text": "opposite of the question mark with the exclamation point so whenever we do an exclamation point we can suppress",
    "start": "2590240",
    "end": "2597040"
  },
  {
    "text": "nullable warnings in this example I have a type that has a private",
    "start": "2597040",
    "end": "2603559"
  },
  {
    "text": "Constructor and a non-nullable string if I were to remove this we get of",
    "start": "2603559",
    "end": "2609920"
  },
  {
    "text": "course the warning at the Constructor because this Constructor does not initialize the non-nullable string so we",
    "start": "2609920",
    "end": "2616480"
  },
  {
    "text": "can say here I want to suppress this warning that's called the null forgiving operator so we don't get a warning here",
    "start": "2616480",
    "end": "2623079"
  },
  {
    "text": "now or no nullable warning um because yeah the Constructor is private nobody could call it we have",
    "start": "2623079",
    "end": "2630240"
  },
  {
    "text": "in this example here a static create method a factory method that does create this instance and then always sets this",
    "start": "2630240",
    "end": "2637920"
  },
  {
    "text": "text it's a bit of a contrived example but yeah the compiler cannot figure out here with the static flow analysis that",
    "start": "2637920",
    "end": "2646240"
  },
  {
    "text": "this Constructor can practically not called by somebody else and the only path that can be called is here and it",
    "start": "2646240",
    "end": "2652440"
  },
  {
    "text": "ensures that this text this non-nullable string will not be null so we can suppress this warning here because in",
    "start": "2652440",
    "end": "2658000"
  },
  {
    "text": "this case we know better than the static flow analysis of the compiler another very common example is",
    "start": "2658000",
    "end": "2663920"
  },
  {
    "text": "for example in link we have here a array that accepts both as that accepts a",
    "start": "2663920",
    "end": "2670119"
  },
  {
    "text": "nullable array which it right elements may be null and this method should the",
    "start": "2670119",
    "end": "2676559"
  },
  {
    "text": "entire array be null we turn an empty array and if the array is nonnull then",
    "start": "2676559",
    "end": "2682520"
  },
  {
    "text": "filter all null elements out of this array and return a new array that",
    "start": "2682520",
    "end": "2688160"
  },
  {
    "text": "doesn't have these null elements so I'm just using a link filter here where we",
    "start": "2688160",
    "end": "2694319"
  },
  {
    "text": "say where these elements are not null but in this case if I remove the null",
    "start": "2694319",
    "end": "2700119"
  },
  {
    "text": "forgiving operator again we get a nullable warning because this array here this",
    "start": "2700119",
    "end": "2705960"
  },
  {
    "text": "elements of this array annotated as n non as nullable",
    "start": "2705960",
    "end": "2711040"
  },
  {
    "text": "therefore the rare also produces nullable strings but in our return we",
    "start": "2711040",
    "end": "2718520"
  },
  {
    "text": "say it's non-nullable so we transform from non-nullable string elements to nullable",
    "start": "2718520",
    "end": "2724359"
  },
  {
    "text": "string array elements well I could make them nullable so the warning disappears but I",
    "start": "2724359",
    "end": "2730040"
  },
  {
    "text": "want to annotate it correctly and in this case again I know better than the compiler because the compiler can't um",
    "start": "2730040",
    "end": "2736920"
  },
  {
    "text": "understand what this wear filter is doing and in this case functionally is removing all of the elements that are",
    "start": "2736920",
    "end": "2742680"
  },
  {
    "text": "null and then creating a newer wave from it so again in this case we know we also have unit tests that confirm this",
    "start": "2742680",
    "end": "2749680"
  },
  {
    "text": "Behavior we can say please suppress this warning this is not null",
    "start": "2749680",
    "end": "2756880"
  },
  {
    "text": "in cases when we deal with generated code when you who has already seen a",
    "start": "2758880",
    "end": "2766520"
  },
  {
    "text": "source generator in action or took a look at source code that was autogenerated by a",
    "start": "2766520",
    "end": "2772800"
  },
  {
    "text": "tool see 20 30% um a lot of the autogenerator",
    "start": "2772800",
    "end": "2780640"
  },
  {
    "text": "code has needs to opt into to this nullable Behavior because by default",
    "start": "2780640",
    "end": "2785920"
  },
  {
    "text": "nullable reference type are disabled in autogenerated code irregardless of what",
    "start": "2785920",
    "end": "2792079"
  },
  {
    "text": "we have set on the project level so what you see in a lot of project is that we",
    "start": "2792079",
    "end": "2798000"
  },
  {
    "text": "do enable uh the nullable feature and then in this case need to correctly yeah fix",
    "start": "2798000",
    "end": "2804760"
  },
  {
    "text": "the problem and return something that is not null an autogenerated file is a file",
    "start": "2804760",
    "end": "2810800"
  },
  {
    "text": "that has this autogenerated comment on top or ends in a dog. CS or do",
    "start": "2810800",
    "end": "2817079"
  },
  {
    "text": "generated. CS there is more rules um what the compiler is um registering as a",
    "start": "2817079",
    "end": "2823880"
  },
  {
    "text": "generated file but those are the the most common versions of it so this is a very common pattern you see the",
    "start": "2823880",
    "end": "2829520"
  },
  {
    "text": "autogenerated comment and then immediately an enable nullable to opt in to this",
    "start": "2829520",
    "end": "2836000"
  },
  {
    "text": "feature now we discussed the significant difference between nullable reference types and nullable value types before",
    "start": "2840160",
    "end": "2848520"
  },
  {
    "text": "four one is only compiler annotations the other one is a totally different",
    "start": "2848520",
    "end": "2853599"
  },
  {
    "text": "type at one time so when it comes to generic there are some caveats to this",
    "start": "2853599",
    "end": "2860160"
  },
  {
    "text": "so let's go into a generic example well when we have an",
    "start": "2860160",
    "end": "2865440"
  },
  {
    "text": "unconstrained generic class or would also be the same for a method where we just have a generic of T there is no um",
    "start": "2865440",
    "end": "2873559"
  },
  {
    "text": "generic constraint here so this one is unconstrained therefore we could use pretty much anything we can have a",
    "start": "2873559",
    "end": "2880119"
  },
  {
    "text": "nullable value type a non-nullable value type we can have a non-nullable",
    "start": "2880119",
    "end": "2886200"
  },
  {
    "text": "reference type and a nullable reference type everything goes if we want to constraint is to be",
    "start": "2886200",
    "end": "2893280"
  },
  {
    "text": "not null we can use the new this is new also",
    "start": "2893280",
    "end": "2898559"
  },
  {
    "text": "in C8 the not null constraint so in this case now only non-nullable value types",
    "start": "2898559",
    "end": "2904960"
  },
  {
    "text": "and non-nullable reference types are allowed",
    "start": "2904960",
    "end": "2908760"
  },
  {
    "text": "so this one produces no warning if I were to use a non-nullable value type we now get a warning here because we",
    "start": "2912119",
    "end": "2918640"
  },
  {
    "text": "valuate this constraint same with a nullable string we may see this constraint on the",
    "start": "2918640",
    "end": "2926599"
  },
  {
    "text": "dictionary when we jump into the implementation of dictionary and PR to the right side we",
    "start": "2928559",
    "end": "2936359"
  },
  {
    "text": "see the where T key is not null so we cannot add a null key to a dictionary",
    "start": "2936359",
    "end": "2941559"
  },
  {
    "text": "this would throw an exception because the dictionary is Hash based we need something to create this",
    "start": "2941559",
    "end": "2946799"
  },
  {
    "text": "Hash k off and now doesn't really have a hash",
    "start": "2946799",
    "end": "2951680"
  },
  {
    "text": "code so if I were to write a dictionary that has let's say string question mark",
    "start": "2951920",
    "end": "2957799"
  },
  {
    "text": "as a key now we get the warning here and we",
    "start": "2957799",
    "end": "2963480"
  },
  {
    "text": "are violating um the nullable contract",
    "start": "2963480",
    "end": "2968440"
  },
  {
    "text": "we can also constraint um T's to only be reference types with the r t is class this has",
    "start": "2968680",
    "end": "2975920"
  },
  {
    "text": "already existed before but when we enable nullable reference types this now means non-nullable",
    "start": "2975920",
    "end": "2982520"
  },
  {
    "text": "classes and if we want to have nullable classes we can also add a class question",
    "start": "2982520",
    "end": "2987839"
  },
  {
    "text": "mark to that so the non-null class well it of",
    "start": "2987839",
    "end": "2996280"
  },
  {
    "text": "course does allow ins because that's not a reference type but it also doesn't allow well it allows but it's a warning",
    "start": "2996280",
    "end": "3003319"
  },
  {
    "text": "um it produces a warning if we have a nullable reference type but for the generic that may be null where we say",
    "start": "3003319",
    "end": "3009960"
  },
  {
    "text": "class question mark we can have a nullable reference type without a",
    "start": "3009960",
    "end": "3016319"
  },
  {
    "text": "warning there is also the struct constraint now this can also be can only be value types but there is no struct",
    "start": "3016319",
    "end": "3023400"
  },
  {
    "text": "question mark constraints because of the difference um",
    "start": "3023400",
    "end": "3029119"
  },
  {
    "text": "of the difference between a nullable value type and a regular value type is significant there's a totally different",
    "start": "3029119",
    "end": "3035280"
  },
  {
    "text": "type in place one has this has value value appear the other one does not",
    "start": "3035280",
    "end": "3041359"
  },
  {
    "text": "because it just has a value and so this is the yeah the difference between uh",
    "start": "3041359",
    "end": "3046760"
  },
  {
    "text": "those two nullable reference and value types now don't allow this scenario and",
    "start": "3046760",
    "end": "3052440"
  },
  {
    "text": "in some cases we need to help the compiler to figure out more about the",
    "start": "3052440",
    "end": "3057480"
  },
  {
    "text": "nullability and for these we have a bunch of nullable",
    "start": "3057480",
    "end": "3062559"
  },
  {
    "text": "attributes they have been added in I think in net standard 2.1 and in net",
    "start": "3062559",
    "end": "3068200"
  },
  {
    "text": "core 3.0 I believe or one we have additional",
    "start": "3068200",
    "end": "3074920"
  },
  {
    "text": "attributes that we can use to annotate our to enhance our nullable um",
    "start": "3074920",
    "end": "3082680"
  },
  {
    "text": "annotations for example if we have a property that returns a string now the backing field is also",
    "start": "3082680",
    "end": "3089240"
  },
  {
    "text": "non-nullable but if I want to allow null to be set but ensure that the getter does not",
    "start": "3089240",
    "end": "3096280"
  },
  {
    "text": "return null we could now put the allow null attribute on top of",
    "start": "3096280",
    "end": "3103440"
  },
  {
    "text": "it and this now enables us to assign null to it Al without this attribute we",
    "start": "3103440",
    "end": "3110799"
  },
  {
    "text": "would here try to assign null to something that is not annotated with a question mark therefore we get the warning but we have ensured in the",
    "start": "3110799",
    "end": "3118640"
  },
  {
    "text": "setter that should a null come in we actually set string empty so the backing",
    "start": "3118640",
    "end": "3124319"
  },
  {
    "text": "field text Will Never Be null and therefore we can basically um",
    "start": "3124319",
    "end": "3130680"
  },
  {
    "text": "annotate this property with the allow null attribute this also works the other",
    "start": "3130680",
    "end": "3135960"
  },
  {
    "text": "way around with the disallow null where we have a nullable reference type as a",
    "start": "3135960",
    "end": "3143119"
  },
  {
    "text": "return type and is a backing field type but we do not allow null to be set so",
    "start": "3143119",
    "end": "3148280"
  },
  {
    "text": "this is not the other way we get the warning here because this will actually now throw this",
    "start": "3148280",
    "end": "3153520"
  },
  {
    "text": "exception there's a bunch of more attributes um I've listed them this repository is on GitHub and I've listed",
    "start": "3153520",
    "end": "3160559"
  },
  {
    "text": "all of them also with a page where this all is documented but a very common um annotation I would like to",
    "start": "3160559",
    "end": "3167760"
  },
  {
    "text": "briefly cover which is on the dictionary on a dictionary well pretty much a lot of these try",
    "start": "3167760",
    "end": "3175079"
  },
  {
    "text": "get methods that return a Boolean and in case the Boolean returns true we then have this",
    "start": "3175079",
    "end": "3183359"
  },
  {
    "text": "out value set we have the maybe null when",
    "start": "3183359",
    "end": "3188480"
  },
  {
    "text": "attribute and with this attribute we can now help the compiler",
    "start": "3188480",
    "end": "3193640"
  },
  {
    "text": "allthough um we have here the out string question mark because it may be null in",
    "start": "3193640",
    "end": "3199280"
  },
  {
    "text": "the case of this Tri get returns true in this block we don't get the warning due",
    "start": "3199280",
    "end": "3205079"
  },
  {
    "text": "to this attribute in the else block of course well it still maybe null because of The",
    "start": "3205079",
    "end": "3211480"
  },
  {
    "text": "annotation here there's there's a two handfuls of these attributes with which you can further enhance your",
    "start": "3211480",
    "end": "3219920"
  },
  {
    "text": "annotations now these annotations can be used also for your own tools at run time",
    "start": "3222599",
    "end": "3228480"
  },
  {
    "text": "because those attributes that are placed on all of these members they're just attributes you could read them as they",
    "start": "3228480",
    "end": "3234960"
  },
  {
    "text": "are there is a type in the BCL was added in",
    "start": "3234960",
    "end": "3240040"
  },
  {
    "text": "Net 5 the nullability info context and with this nullability info",
    "start": "3240040",
    "end": "3246640"
  },
  {
    "text": "context we can ask um reflection based",
    "start": "3246640",
    "end": "3252400"
  },
  {
    "text": "questions for example we could create the so-called nullability info of this",
    "start": "3252400",
    "end": "3258520"
  },
  {
    "text": "parameter info type so that's a parameter to a method that comes in and then query its nullable state and we saw",
    "start": "3258520",
    "end": "3266680"
  },
  {
    "text": "with this attributes we could have we could disjoint the nullability when it comes to the get and the set and this um",
    "start": "3266680",
    "end": "3273920"
  },
  {
    "text": "shows in the read and the right state so they could have different forms of nullability",
    "start": "3273920",
    "end": "3279640"
  },
  {
    "text": "and with this with this information we could have an",
    "start": "3279640",
    "end": "3286280"
  },
  {
    "text": "application that",
    "start": "3286799",
    "end": "3290799"
  },
  {
    "text": "no uh this one yes with a",
    "start": "3310960",
    "end": "3316040"
  },
  {
    "text": "class we see that this class has various combinations of nullability passed in",
    "start": "3319079",
    "end": "3327440"
  },
  {
    "text": "and if we pass this class now to this code that is O sorry wrong",
    "start": "3327440",
    "end": "3333838"
  },
  {
    "text": "application that is now utilizing this nullability info context and reading at one time this",
    "start": "3334039",
    "end": "3341280"
  },
  {
    "text": "attributes we can now get basically A visual representation of this",
    "start": "3341280",
    "end": "3347599"
  },
  {
    "text": "code such as we see that this first string it's a nullable string red at one",
    "start": "3350480",
    "end": "3359400"
  },
  {
    "text": "time we can also via wlin read this information at compile time so we can",
    "start": "3359400",
    "end": "3365640"
  },
  {
    "text": "write our own analyzers that help us with nullable",
    "start": "3365640",
    "end": "3371280"
  },
  {
    "text": "annotations for example in one project uh that I was working on we using we were using data contracts heavily and we",
    "start": "3371280",
    "end": "3377359"
  },
  {
    "text": "wanted to connect them with nullable annotations so if this data member is",
    "start": "3377359",
    "end": "3383000"
  },
  {
    "text": "required we introduced an analyzer that when we we have an nullable reference type or a",
    "start": "3383000",
    "end": "3390480"
  },
  {
    "text": "nullable type with a data member that is required we now produce a warning also",
    "start": "3390480",
    "end": "3396760"
  },
  {
    "text": "the other way around if this was not required this should be op this should",
    "start": "3396760",
    "end": "3402440"
  },
  {
    "text": "be nullable if it was not nullable again it's a little bit ambiguous it's not required but non-nullable something's",
    "start": "3402440",
    "end": "3408440"
  },
  {
    "text": "wrong so a flag of warning and that's an analyzer with an analyzer you can also",
    "start": "3408440",
    "end": "3413880"
  },
  {
    "text": "have a fixer um where you then have an Alt Enter or control dot experience in your",
    "start": "3413880",
    "end": "3419559"
  },
  {
    "text": "IDE um in this case change nullable which is now changing the source code",
    "start": "3419559",
    "end": "3425039"
  },
  {
    "text": "and properly adapting it so if is required is true but the string is",
    "start": "3425039",
    "end": "3431200"
  },
  {
    "text": "nullable we could invoke this fixer and it now changes it to match this",
    "start": "3431200",
    "end": "3437160"
  },
  {
    "text": "annotation up here and those there's a whole set of Wason compiler plugins that",
    "start": "3437160",
    "end": "3442319"
  },
  {
    "text": "you can write ourself uh yourself now for the last point I would like to",
    "start": "3442319",
    "end": "3447880"
  },
  {
    "text": "talk about how to adopt nullable reference types for existing projects if we have big code bases that",
    "start": "3447880",
    "end": "3456000"
  },
  {
    "text": "existed before nullable reference types and you haven't opt into this feature you it's pretty much not possible",
    "start": "3456000",
    "end": "3462720"
  },
  {
    "text": "to to um like in one big commit or in one day fix all of the nullable warnings",
    "start": "3462720",
    "end": "3468640"
  },
  {
    "text": "and properly anoti all of the types so one strategy is to do this um over",
    "start": "3468640",
    "end": "3474839"
  },
  {
    "text": "multiple um multiple commits over multiple days weeks perhaps even years you",
    "start": "3474839",
    "end": "3482559"
  },
  {
    "text": "could enable this feature on the project level but then",
    "start": "3482559",
    "end": "3488760"
  },
  {
    "text": "still disable this",
    "start": "3488760",
    "end": "3492400"
  },
  {
    "text": "feature another little disable this feature on all of your um uh types so",
    "start": "3495119",
    "end": "3503760"
  },
  {
    "text": "this doesn't change really any Behavior but I'm wondering it's not a way oh yes",
    "start": "3503760",
    "end": "3509400"
  },
  {
    "text": "I should also opt into C",
    "start": "3509400",
    "end": "3515078"
  },
  {
    "text": "8 or higher and then whenever you touch a",
    "start": "3515520",
    "end": "3522200"
  },
  {
    "text": "file that has this nullability disabled you could then remove one of these um",
    "start": "3522200",
    "end": "3528520"
  },
  {
    "text": "pre-processor directives go through the type fix all the warnings in this case we return null",
    "start": "3528520",
    "end": "3535240"
  },
  {
    "text": "so we should also add a question mark here and do this on a file by file level until you have your entire source code",
    "start": "3535240",
    "end": "3542480"
  },
  {
    "text": "annotated and then you C and then you're done this is I think what the what the",
    "start": "3542480",
    "end": "3547760"
  },
  {
    "text": "net team did to step by step null enable their types the other way is you do the",
    "start": "3547760",
    "end": "3555400"
  },
  {
    "text": "opposite you basically go to each and every file as so you you leave your code unchanged but when you touch a file you",
    "start": "3555400",
    "end": "3562280"
  },
  {
    "text": "can then go to nullable enable and again enable them on the file by file basis",
    "start": "3562280",
    "end": "3567359"
  },
  {
    "text": "until you have nullable annotated and fixed all the nullable warnings in your entire",
    "start": "3567359",
    "end": "3573440"
  },
  {
    "text": "project if we are in a net standard",
    "start": "3573440",
    "end": "3577960"
  },
  {
    "text": "project the net standard project doesn't have this nullable attribute types available just yet so how can we get",
    "start": "3583480",
    "end": "3590880"
  },
  {
    "text": "them there's multiple ways you could add them yourself but that's a little bit tedious",
    "start": "3590880",
    "end": "3596799"
  },
  {
    "text": "there is one project that I like is poly sharp which is basically poly filling for lower Target Frameworks and it now",
    "start": "3596799",
    "end": "3604599"
  },
  {
    "text": "has a source generator that produces these attributes",
    "start": "3604599",
    "end": "3610559"
  },
  {
    "text": "for us so if we go into the net standard 2.0 output there is a bunch of generators and one of these generators",
    "start": "3610559",
    "end": "3617799"
  },
  {
    "text": "is for example this allow this allow null attribute that is",
    "start": "3617799",
    "end": "3623319"
  },
  {
    "text": "emitted by the compiler uh you can also use polyfill for other features like if you on a lower Target",
    "start": "3623319",
    "end": "3629760"
  },
  {
    "text": "framework that hasn't types like range index um and other types yet this",
    "start": "3629760",
    "end": "3634839"
  },
  {
    "text": "polyfill package can help to enhance your net standard 2.0 um libraries with newer to to enable newer C",
    "start": "3634839",
    "end": "3644319"
  },
  {
    "text": "features and the very last will be how can we avoid null in the very first",
    "start": "3644319",
    "end": "3650799"
  },
  {
    "text": "place we could have a so-called null object pattern",
    "start": "3650799",
    "end": "3657920"
  },
  {
    "text": "applied a null",
    "start": "3658839",
    "end": "3662359"
  },
  {
    "text": "object Lo there we go a null object is a type that implements a specific",
    "start": "3666720",
    "end": "3673559"
  },
  {
    "text": "interface implement it all doesn't throw any exception doesn't have null anywhere",
    "start": "3673559",
    "end": "3679200"
  },
  {
    "text": "but does nothing or something is close to nothing so for example when we have a",
    "start": "3679200",
    "end": "3685559"
  },
  {
    "text": "logger that's from Microsoft extensions. logging and we want to implement a null logger now we implement this interface",
    "start": "3685559",
    "end": "3693319"
  },
  {
    "text": "we have the begin scope method which should return something it shouldn't return null that is enabled returns",
    "start": "3693319",
    "end": "3700119"
  },
  {
    "text": "false because when a logger isn't enabled that's close to nothing and the log method since the void method just",
    "start": "3700119",
    "end": "3707160"
  },
  {
    "text": "doesn't do anything the begin scope meth the begin scope method however needs to return",
    "start": "3707160",
    "end": "3712440"
  },
  {
    "text": "something so again we can create now a disposable object which is the same",
    "start": "3712440",
    "end": "3717559"
  },
  {
    "text": "thing it implements the I disposable interface but it's dispose does nothing",
    "start": "3717559",
    "end": "3723720"
  },
  {
    "text": "now since nullable uh no since null object types don't really have any state",
    "start": "3723720",
    "end": "3729599"
  },
  {
    "text": "we can use the um the what are they called",
    "start": "3729599",
    "end": "3737799"
  },
  {
    "text": "um Singleton thank you very much we can apply the Singleton pattern because they",
    "start": "3737799",
    "end": "3743000"
  },
  {
    "text": "don't have any state and we can avoid allocating a lot of objects that don't",
    "start": "3743000",
    "end": "3748039"
  },
  {
    "text": "have any stat so we can reuse the same instance thanks for helping me",
    "start": "3748039",
    "end": "3752920"
  },
  {
    "text": "out and in some projects um you can also see something like optional this for",
    "start": "3753279",
    "end": "3759240"
  },
  {
    "text": "examp for example something that um I believe FSH is using well not really to",
    "start": "3759240",
    "end": "3765079"
  },
  {
    "text": "avoid null because F avoids null on a on a language level itself um but similar pattern and we could for example have",
    "start": "3765079",
    "end": "3772160"
  },
  {
    "text": "optional types that also work with reference types and we have again something like a has value and a value",
    "start": "3772160",
    "end": "3780200"
  },
  {
    "text": "um property to check but yeah what would happen if we access the value without checking for has value it's still not",
    "start": "3780200",
    "end": "3787559"
  },
  {
    "text": "really um 100% safe from a compile level to make it more safe on a compile",
    "start": "3787559",
    "end": "3794039"
  },
  {
    "text": "level we could change the nullable warnings that we took a look at to be actually",
    "start": "3794039",
    "end": "3799839"
  },
  {
    "text": "errors so what we can do is say warnings as errors and we can pass nullable here",
    "start": "3799839",
    "end": "3807240"
  },
  {
    "text": "doing this for the release build so if we were to build this project in release build we would get a bunch of Errors it",
    "start": "3807240",
    "end": "3813480"
  },
  {
    "text": "wouldn't compile this for examp this is something that we have in our project so we don't even allow any nullable uh",
    "start": "3813480",
    "end": "3819720"
  },
  {
    "text": "warning violations into our source code and this is how we achieved to avoid",
    "start": "3819720",
    "end": "3825319"
  },
  {
    "text": "null in the first place and should you since I mentioned",
    "start": "3825319",
    "end": "3830920"
  },
  {
    "text": "it f should you open a new F project in net 9 and F 9",
    "start": "3830920",
    "end": "3837599"
  },
  {
    "text": "F Sharna also allows null annotations you will see them something like this",
    "start": "3837599",
    "end": "3843760"
  },
  {
    "text": "this is to not only allow nicer interop with C because in C we have null all over the place F doesn't have null but",
    "start": "3843760",
    "end": "3851200"
  },
  {
    "text": "when it calls C methods then there may be null and this is now how they could",
    "start": "3851200",
    "end": "3856680"
  },
  {
    "text": "annotate um F code to also be null aware and the same the same pattern we need to",
    "start": "3856680",
    "end": "3863680"
  },
  {
    "text": "enable this feature via um the nullable enable",
    "start": "3863680",
    "end": "3873279"
  },
  {
    "text": "property but not only for intop with FSH code or with C code um this is also",
    "start": "3873279",
    "end": "3879359"
  },
  {
    "text": "valid when for example you have F code that goes we Chason beyond the process boundary and yeah to have null bations",
    "start": "3879359",
    "end": "3886680"
  },
  {
    "text": "because we Chason we can actually get two levels of null null and undefined",
    "start": "3886680",
    "end": "3894079"
  },
  {
    "text": "I'm listing here the repository with all of the examples should be interested in it I also have a bit of an interactive",
    "start": "3898920",
    "end": "3905880"
  },
  {
    "text": "demo where you could click through the thing and maybe assign null here run the",
    "start": "3905880",
    "end": "3913119"
  },
  {
    "text": "code and then get reference exceptions if you would like to go through this presentation at your own",
    "start": "3913119",
    "end": "3920240"
  },
  {
    "text": "pace and with that there's nothing else left to say then thank you very much for trying this session uh do enjoy",
    "start": "3920240",
    "end": "3928720"
  },
  {
    "text": "tomorrow's last day at the conference and I think now is party time isn't itk",
    "start": "3928720",
    "end": "3935519"
  }
]