[
  {
    "start": "0",
    "end": "66000"
  },
  {
    "text": "my name is Daniel chambers I'm making seniors alternate ratify my roots our is a.net",
    "start": "9940",
    "end": "16430"
  },
  {
    "text": "developer I've worked on projects in C sharp F sharp and JavaScript my current",
    "start": "16430",
    "end": "21800"
  },
  {
    "text": "day job has been interesting it has me writing Haskell and pure script working",
    "start": "21800",
    "end": "26930"
  },
  {
    "text": "in these pure FP languages on a day to day basis has forced me to confront functional programming patterns head-on",
    "start": "26930",
    "end": "33800"
  },
  {
    "text": "it's allowed me to look back at C sharp F sharp and JavaScript and see places where those patterns occur even in those",
    "start": "33800",
    "end": "40460"
  },
  {
    "text": "more imperative style languages it allowed me to see why these patterns are",
    "start": "40460",
    "end": "45559"
  },
  {
    "text": "valuable to have in my day-to-day toolkit and today I hope to communicate to you what I've learned and allow you",
    "start": "45559",
    "end": "52160"
  },
  {
    "text": "to identify these FP patterns out in the wild and see how they can make your code",
    "start": "52160",
    "end": "57500"
  },
  {
    "text": "more expressive by reducing boilerplate the three patterns we're going to look at today the functor applicative and the",
    "start": "57500",
    "end": "65119"
  },
  {
    "text": "monad so as software developers we know",
    "start": "65119",
    "end": "70610"
  },
  {
    "start": "66000",
    "end": "158000"
  },
  {
    "text": "that patterns are important to our software architectures and the maintainability and understandability of",
    "start": "70610",
    "end": "76280"
  },
  {
    "text": "our code bases just like how libraries enable code reuse patterns enable",
    "start": "76280",
    "end": "81350"
  },
  {
    "text": "experience reuse by basically allowing us to rely on the lessons and learn from",
    "start": "81350",
    "end": "86840"
  },
  {
    "text": "the lessons of developers who have come before us developers who understand",
    "start": "86840",
    "end": "92149"
  },
  {
    "text": "these patterns they basically can solve more problems quickly by leaning on those that experience of those who have",
    "start": "92149",
    "end": "97819"
  },
  {
    "text": "come before and so if you look at typical examples from the OO programming space program is a taught about the",
    "start": "97819",
    "end": "104240"
  },
  {
    "text": "strategy pattern very early on and you know that solves particular sets of problems and that those problems come up",
    "start": "104240",
    "end": "110090"
  },
  {
    "text": "again and again when looking at unfamiliar code patterns enable developers to quickly recognize what's",
    "start": "110090",
    "end": "116659"
  },
  {
    "text": "going on by identifying patterns in use and that enables them to understand original the original intent of the code",
    "start": "116659",
    "end": "122479"
  },
  {
    "text": "very quickly so for example if you see something visit a class you probably",
    "start": "122479",
    "end": "127670"
  },
  {
    "text": "have a good hint there that the visitor patterns in use and therefore you're already 80% of the way there to",
    "start": "127670",
    "end": "132709"
  },
  {
    "text": "understanding what's going on patterns are also used to hot to hide",
    "start": "132709",
    "end": "138530"
  },
  {
    "text": "implementation details very encapsulation so software is complicated and it's easier to think and communicate",
    "start": "138530",
    "end": "144530"
  },
  {
    "text": "big picture when we're using patterns to abstract away in patient details for example observers in",
    "start": "144530",
    "end": "151610"
  },
  {
    "text": "the observer pattern don't really have to care about the implementation of the subjects they just receive notifications",
    "start": "151610",
    "end": "158860"
  },
  {
    "start": "158000",
    "end": "249000"
  },
  {
    "text": "now functional programming is a very wide and loose classification at its",
    "start": "158860",
    "end": "164209"
  },
  {
    "text": "looseness definition it means programming with functions as first-class entities but stricter",
    "start": "164209",
    "end": "169519"
  },
  {
    "text": "definitions incorporate immutability constraints many imperative languages are taking on functional characteristics",
    "start": "169519",
    "end": "176180"
  },
  {
    "text": "as the value of functional programming is is more and more recognized functional programming techniques can be",
    "start": "176180",
    "end": "183530"
  },
  {
    "text": "used in mainly object-oriented languages like C sharp and Java and prototypical",
    "start": "183530",
    "end": "188780"
  },
  {
    "text": "languages like JavaScript and then there are those FP hybrid languages like F sharp and Scala which support many more",
    "start": "188780",
    "end": "195739"
  },
  {
    "text": "FP features then at the far end of the scale we have full-blown functional programming languages like Haskell and",
    "start": "195739",
    "end": "202069"
  },
  {
    "text": "pure script so many of the basic FP patterns are useful when doing FP in all",
    "start": "202069",
    "end": "208280"
  },
  {
    "text": "languages some patterns are more useful in certain languages than others and the patterns are at their most powerful in",
    "start": "208280",
    "end": "214400"
  },
  {
    "text": "FP languages that support high kind of types like Scala Haskell and pure script because you can write code that's",
    "start": "214400",
    "end": "220040"
  },
  {
    "text": "abstract over these patterns and that can enable some good code reuse however even if your language of choice doesn't",
    "start": "220040",
    "end": "226310"
  },
  {
    "text": "support higher kind of types these patterns are still extremely useful non",
    "start": "226310",
    "end": "231530"
  },
  {
    "text": "FP languages have been quietly incorporating FP patterns so some of these patterns will actually feel familiar to you even if you don't do FP",
    "start": "231530",
    "end": "239030"
  },
  {
    "text": "on a day-to-day basis they don't tend to use the same names for the patterns but the idea is similar if not the same and",
    "start": "239030",
    "end": "245810"
  },
  {
    "text": "I'll be pointing out these cases as we go through the patterns so before we",
    "start": "245810",
    "end": "251870"
  },
  {
    "start": "249000",
    "end": "324000"
  },
  {
    "text": "jump into the patterns let's make sure everyone's on the same page with some functional basics so we don't leave",
    "start": "251870",
    "end": "257060"
  },
  {
    "text": "anybody behind I'm going to borrow the Haskell syntax for specifying types in",
    "start": "257060",
    "end": "262490"
  },
  {
    "text": "the talk because it's nice and simple you can see the c-sharp equivalent of the the types of the add function when",
    "start": "262490",
    "end": "268039"
  },
  {
    "text": "it's been curried up on the right it's not quite as nice as the arrow style that you can get out of something like",
    "start": "268039",
    "end": "273770"
  },
  {
    "text": "Haskell or F sharp so the smallest definition of a function is one that",
    "start": "273770",
    "end": "279349"
  },
  {
    "text": "takes a single parameter and a single value carried functions are",
    "start": "279349",
    "end": "284400"
  },
  {
    "text": "ones where the function is reduced to its smallest definition automatically by the compiler so in the case of the add",
    "start": "284400",
    "end": "290250"
  },
  {
    "text": "function it takes two parameters but really after its being curried it takes one parameter a single input that first",
    "start": "290250",
    "end": "296760"
  },
  {
    "text": "integer and it returns a single output which is another function that takes the second parameter adds it to the first",
    "start": "296760",
    "end": "302970"
  },
  {
    "text": "and returns the result so if we step through it we can basically call the add",
    "start": "302970",
    "end": "308040"
  },
  {
    "text": "function with a single parameter and that's known as partial application when you partially apply function we get back",
    "start": "308040",
    "end": "314280"
  },
  {
    "text": "a function that when pass an integer will add one to it the increment function so if we call that with a value",
    "start": "314280",
    "end": "319710"
  },
  {
    "text": "of two we get back our expected value of three another important functional",
    "start": "319710",
    "end": "326370"
  },
  {
    "start": "324000",
    "end": "402000"
  },
  {
    "text": "programming concept is some types or as they're known in F sharp discriminated unions as some type lets you define a",
    "start": "326370",
    "end": "332790"
  },
  {
    "text": "choice between different things so a typical example is modeling the presence or the absence of a value haskell does",
    "start": "332790",
    "end": "339960"
  },
  {
    "text": "this with the may be type which can either be just or just if the value exists or nothing if the value doesn't",
    "start": "339960",
    "end": "346980"
  },
  {
    "text": "exist f sharp has an identical type called option and they pair sharp uses",
    "start": "346980",
    "end": "353040"
  },
  {
    "text": "the labels some and none so some if you've got the value and none if you don't have the value languages with some",
    "start": "353040",
    "end": "360510"
  },
  {
    "text": "types have pattern matching to allow you to branch between the different the different labels",
    "start": "360510",
    "end": "365580"
  },
  {
    "text": "depending upon what which one it is in the case of maybe we've got a pattern match up on the slide which test if that",
    "start": "365580",
    "end": "371760"
  },
  {
    "text": "maybe val is just or nothing or in the case of f sharp is some or none another",
    "start": "371760",
    "end": "378750"
  },
  {
    "text": "very typical some type is the either type which models the choice between a value of type a and a choice and a value",
    "start": "378750",
    "end": "385530"
  },
  {
    "text": "of type B in F sharp that's called the choice type so either is often used to",
    "start": "385530",
    "end": "391290"
  },
  {
    "text": "model error cases so where the left is used when there's an error and what the right is used if you have a successful",
    "start": "391290",
    "end": "397590"
  },
  {
    "text": "value so the next thing we should",
    "start": "397590",
    "end": "403770"
  },
  {
    "start": "402000",
    "end": "482000"
  },
  {
    "text": "reinforce is the concept of higher kind of types and the syntax that we'll use to express them because high kind of",
    "start": "403770",
    "end": "409320"
  },
  {
    "text": "types that syntax is very useful when we're talking about patterns in and abstract way so you can think about",
    "start": "409320",
    "end": "415949"
  },
  {
    "text": "kinds as a way of expressing types of types types without generics",
    "start": "415949",
    "end": "421979"
  },
  {
    "text": "they're just types but when you introduce generics you change the kind of a type to be a type function I a type",
    "start": "421979",
    "end": "429150"
  },
  {
    "text": "that takes another type in order to produce a type and that's why the type may be a has a kind of type arrow type",
    "start": "429150",
    "end": "437550"
  },
  {
    "text": "because it's a type function that takes a type and returns a type so if you call",
    "start": "437550",
    "end": "442830"
  },
  {
    "text": "them a B type with int written as maybe int then you've invoked a type function",
    "start": "442830",
    "end": "448650"
  },
  {
    "text": "and you've just made a new type that's may be specialized to int high kind of",
    "start": "448650",
    "end": "454949"
  },
  {
    "text": "types is we can write generics code where the generic type parameters can be higher kind and that means type arrow",
    "start": "454949",
    "end": "461400"
  },
  {
    "text": "type or type arrow type arrow type and so on this isn't possible in dotnet unfortunately but it is possible in",
    "start": "461400",
    "end": "468030"
  },
  {
    "text": "languages like Scala in high school we'll be using high kind of types to express our functional patterns but keep",
    "start": "468030",
    "end": "473789"
  },
  {
    "text": "in mind that just because your language doesn't support high kind of types doesn't mean you can't use the patterns and I'll explain that a bit further once",
    "start": "473789",
    "end": "480539"
  },
  {
    "text": "we've covered our first pattern so the packet that the pattern will begin with",
    "start": "480539",
    "end": "485970"
  },
  {
    "start": "482000",
    "end": "579000"
  },
  {
    "text": "is called the functor but first let's start by looking at some motivating examples of some code that we could",
    "start": "485970",
    "end": "492539"
  },
  {
    "text": "clean up and then we'll dive into how functions work and circle back to how we could clean up that code by using what",
    "start": "492539",
    "end": "498330"
  },
  {
    "text": "we've learned about functors so imagine we have a maybe int and all we want to",
    "start": "498330",
    "end": "505110"
  },
  {
    "text": "do is just convert that into a string if it exists right so if there maybe is just we want to convert its value to a",
    "start": "505110",
    "end": "511650"
  },
  {
    "text": "string so you can see up on the slide we're doing a pattern match between just and nothing if it's just we take the",
    "start": "511650",
    "end": "517200"
  },
  {
    "text": "value out we run it through two string wrap it back up and adjust and return it if it's nothing we just return nothing",
    "start": "517200",
    "end": "524270"
  },
  {
    "text": "it's simple but it is fairly verbose we can do a similar thing with either's so",
    "start": "524270",
    "end": "530100"
  },
  {
    "text": "if the either is right we can take out the the the integer run it through two string wrap it back up in a write return",
    "start": "530100",
    "end": "536070"
  },
  {
    "text": "it if it's left we return the left unchanged",
    "start": "536070",
    "end": "541399"
  },
  {
    "text": "what about if we have a list of intz and we want to get a list of strings this is another similar function where we're",
    "start": "541879",
    "end": "548189"
  },
  {
    "text": "recurring through that list converting each integer to a string in turn and reconstructing the list now notice how",
    "start": "548189",
    "end": "555149"
  },
  {
    "text": "in all these examples we're transforming the value inside the structure while",
    "start": "555149",
    "end": "560279"
  },
  {
    "text": "leaving the actual structure alone so we've got just going to just nothing going to nothing right going to right",
    "start": "560279",
    "end": "566189"
  },
  {
    "text": "left going to lift and that list transformation leaves the the length of a list done unchanged this pattern of",
    "start": "566189",
    "end": "572550"
  },
  {
    "text": "boilerplate code is something that functors encapsulate s-- and simplifies for you let's see how that works so a",
    "start": "572550",
    "end": "581459"
  },
  {
    "start": "579000",
    "end": "703000"
  },
  {
    "text": "type that's a functor is able to transform a value without altering its structure so the function that can do",
    "start": "581459",
    "end": "589589"
  },
  {
    "text": "that is called map and its type signature is up on the slide let's let's break that down so the first bit is",
    "start": "589589",
    "end": "595259"
  },
  {
    "text": "saying if must be a functor then we're saying given a function that can",
    "start": "595259",
    "end": "600959"
  },
  {
    "text": "transform a to B's and a structure F of a is the map function will give us back",
    "start": "600959",
    "end": "608819"
  },
  {
    "text": "a structure F of B's now that's all very abstract so let's look at a concrete",
    "start": "608819",
    "end": "614730"
  },
  {
    "text": "example to help pin this down maybe is a functor so let's look at how we could implement the map function of them maybe",
    "start": "614730",
    "end": "621179"
  },
  {
    "text": "we can see the FS and the type signature now have been replaced with maybe and",
    "start": "621179",
    "end": "626189"
  },
  {
    "text": "what we're doing here is we're just doing a pattern match on that maybe if it's just we take the the X out of the",
    "start": "626189",
    "end": "631740"
  },
  {
    "text": "just we run it through the function wrap it back up and adjust and return it if it's nothing we ignore the function and",
    "start": "631740",
    "end": "637769"
  },
  {
    "text": "just return nothing now as you can see map is simply transforming the value",
    "start": "637769",
    "end": "644040"
  },
  {
    "text": "inside the maybe while retaining that map that also maybe structure unchanged this is an important feature of the map",
    "start": "644040",
    "end": "651540"
  },
  {
    "text": "function its structure preserving lists",
    "start": "651540",
    "end": "656759"
  },
  {
    "text": "are also functors and therefore a map function for lists exists we can see the",
    "start": "656759",
    "end": "661769"
  },
  {
    "text": "implementation up on the slide instead of maybe we're using the list syntax so in Haskell words the square brackets",
    "start": "661769",
    "end": "667740"
  },
  {
    "text": "around the type so here what we're doing is we're deconstructing the list that's",
    "start": "667740",
    "end": "672749"
  },
  {
    "text": "the x : x is part the x is the head the lists the exes is the tailored list and we recruit recursively going through",
    "start": "672749",
    "end": "679110"
  },
  {
    "text": "that list converting each X using our a to be function and then recursively just",
    "start": "679110",
    "end": "685770"
  },
  {
    "text": "going through that list until the end and reconstructing it again we can say that map is simply transforming each",
    "start": "685770",
    "end": "692580"
  },
  {
    "text": "list element individually but it's not changing the list structure in any way that list length stays the same so if we",
    "start": "692580",
    "end": "698490"
  },
  {
    "text": "pass in a list of length two we get back a list of length 2 either is also a",
    "start": "698490",
    "end": "706560"
  },
  {
    "text": "functor with one crucial difference to maybe in list you'll remember that either has to type parameters it it's",
    "start": "706560",
    "end": "713430"
  },
  {
    "text": "either ei right so this means that has a kind of type 2 type 2 type however F in",
    "start": "713430",
    "end": "719850"
  },
  {
    "text": "map has a kind of type 2 type as you can see because it doesn't take two type parameters it's only taking one either",
    "start": "719850",
    "end": "726690"
  },
  {
    "text": "takes a or it takes B it doesn't take both but either needs to now this means the",
    "start": "726690",
    "end": "732000"
  },
  {
    "text": "kinds don't match so we can't just substitute either for F in that expression it won't work but we can work",
    "start": "732000",
    "end": "738150"
  },
  {
    "text": "around that what we can say is we can take either E and either E's kind is type 2 type so we can substitute either",
    "start": "738150",
    "end": "746490"
  },
  {
    "text": "e 4f in that and that's how we implement that's how we implement map for either",
    "start": "746490",
    "end": "752810"
  },
  {
    "text": "so looking at the concrete example we can see it's either e a and either e B",
    "start": "752810",
    "end": "758850"
  },
  {
    "text": "so that is fixed so in this particular implementation it's again very simple if",
    "start": "758850",
    "end": "764970"
  },
  {
    "text": "we've got a left we leave it unchanged we don't use that function but if we have it right we take the X out at the",
    "start": "764970",
    "end": "770550"
  },
  {
    "text": "right we run it through the function and wrap it back up in that right and return it so again we can see structure",
    "start": "770550",
    "end": "778320"
  },
  {
    "text": "preserving left goes to left right goes to right we haven't changed the IVA structure but we have transformed the value inside it now let's take our",
    "start": "778320",
    "end": "787710"
  },
  {
    "text": "original boilerplate code and use functors instead maybe into string",
    "start": "787710",
    "end": "794030"
  },
  {
    "text": "that's just a map so all we're doing is we're taking the map function we're passing our transformation function",
    "start": "794030",
    "end": "800310"
  },
  {
    "text": "which in this case is our to string so we have it needs a function a to B in this case we've got an int to string",
    "start": "800310",
    "end": "806100"
  },
  {
    "text": "function we're passing that in we're also passing the in which is the maybe and getting back",
    "start": "806100",
    "end": "811350"
  },
  {
    "text": "out transformed maybe either into string also just a map list interest ring also",
    "start": "811350",
    "end": "819510"
  },
  {
    "text": "a map so in reality we wouldn't even have this with interest ring and either",
    "start": "819510",
    "end": "825029"
  },
  {
    "text": "into string functions we just inline the use of map into the call sites and so we",
    "start": "825029",
    "end": "830160"
  },
  {
    "text": "basically eliminate all of the boilerplate code that we have up on the slide and that's a pretty nice thing to do so let's have a look at another",
    "start": "830160",
    "end": "838709"
  },
  {
    "start": "836000",
    "end": "923000"
  },
  {
    "text": "example and this time we'll look at it through the lens of some F sharp code so",
    "start": "838709",
    "end": "843810"
  },
  {
    "text": "in this case we've got a function called get user avatar URL and what this is going to do is it's going to take a user",
    "start": "843810",
    "end": "850110"
  },
  {
    "text": "ID and it's going to asynchronously return a URL to its avatar so the",
    "start": "850110",
    "end": "855600"
  },
  {
    "text": "implementation is pretty simple it calls get user async passing in that ID and",
    "start": "855600",
    "end": "861630"
  },
  {
    "text": "then it uses let bang to get the user out of the async passes that user in to grab its avatar ID passes it to make CD",
    "start": "861630",
    "end": "869579"
  },
  {
    "text": "and URL to create that URL and then returns it wrapped up inside the async so it's fairly simple code but it is",
    "start": "869579",
    "end": "876540"
  },
  {
    "text": "fairly verbose and we can simplify this by relying on the fact that async is also a functor so in the functor eyes",
    "start": "876540",
    "end": "883380"
  },
  {
    "text": "version we can simply use map over the async returned by get user async passing",
    "start": "883380",
    "end": "889470"
  },
  {
    "text": "in a lambda that takes the user and makes the URL so remember if async is a",
    "start": "889470",
    "end": "894540"
  },
  {
    "text": "functor we can use the map function on it so they think we get back from get user async is async of user but we want",
    "start": "894540",
    "end": "901920"
  },
  {
    "text": "an async of URL so we have a function that can take a user and produce a URL that's such utter a to be function and",
    "start": "901920",
    "end": "908699"
  },
  {
    "text": "that's what we've passed is the lambda to async map so this is a pretty",
    "start": "908699",
    "end": "913829"
  },
  {
    "text": "standard pattern you can identify if you're doing a let bang and then a return you can probably replace that",
    "start": "913829",
    "end": "920190"
  },
  {
    "text": "with map instead so if functors crop up all over the",
    "start": "920190",
    "end": "925649"
  },
  {
    "start": "923000",
    "end": "982000"
  },
  {
    "text": "place if you have a look at c-sharp innumerable select is basically map with",
    "start": "925649",
    "end": "931319"
  },
  {
    "text": "a different name this means i near abalzer functors same for observables tasks and nullable types are also",
    "start": "931319",
    "end": "938310"
  },
  {
    "text": "functors if you care to write the the map function for them in F sharp option choice list and async",
    "start": "938310",
    "end": "945280"
  },
  {
    "text": "are all functors the standard F sharp libraries often have map functions otherwise you can get them from the F",
    "start": "945280",
    "end": "950710"
  },
  {
    "text": "sharp X project which is an open source project that adds a whole bunch of really F P stuff in JavaScript arrays a",
    "start": "950710",
    "end": "959230"
  },
  {
    "text": "functors and you can get a nice functional style map function from the low - FP library now everyone in this",
    "start": "959230",
    "end": "967090"
  },
  {
    "text": "room has probably used at least one of these map functions before so I'm sure it's feeling familiar the takeaway here",
    "start": "967090",
    "end": "972910"
  },
  {
    "text": "is that more things than just lists and I enumerables are functors and you can have a similar style map function for",
    "start": "972910",
    "end": "978730"
  },
  {
    "text": "them as well so I mentioned before that",
    "start": "978730",
    "end": "983860"
  },
  {
    "text": "high kind of types can make these patterns even more useful on languages that support them here's an example of a",
    "start": "983860",
    "end": "989320"
  },
  {
    "text": "place in net where you wouldn't get code reuse because of the lack of high kind of types but notice it doesn't mean we",
    "start": "989320",
    "end": "994780"
  },
  {
    "text": "can't use it we can't use those patterns it's just we don't get a bit of reuse that we might get elsewhere so in this",
    "start": "994780",
    "end": "1001140"
  },
  {
    "text": "case we've got a method here that takes an onion rule of mints and adds one to each item and convert it to an English",
    "start": "1001140",
    "end": "1006570"
  },
  {
    "text": "word and returns a results at owner of also we're using the functor pattern we're using select which is map if we",
    "start": "1006570",
    "end": "1013740"
  },
  {
    "text": "wanted to do the same thing for a observables we would have to re-implement the the method unfortunately in high school because you",
    "start": "1013740",
    "end": "1021780"
  },
  {
    "text": "support because it supports height kind of types we can write the function once and it works for all functors so it can",
    "start": "1021780",
    "end": "1028470"
  },
  {
    "text": "be used for lists for maybes for either x' for i/o for parsers basically any type that's a functor we can use that",
    "start": "1028470",
    "end": "1034890"
  },
  {
    "text": "same function for and that's pretty nice if you've got it alright so the next",
    "start": "1034890",
    "end": "1043050"
  },
  {
    "start": "1040000",
    "end": "1064000"
  },
  {
    "text": "pattern we'll look at is called the applicator applicatives are similar to functors however instead",
    "start": "1043050",
    "end": "1049440"
  },
  {
    "text": "of transforming values inside a structure while leaving that structure alone applicative transform both the",
    "start": "1049440",
    "end": "1056010"
  },
  {
    "text": "value and the structure together so Before we jump into them let's take a look at a motivating example of where",
    "start": "1056010",
    "end": "1061800"
  },
  {
    "text": "applicatives could help us simplify our code so imagine we have a record type to",
    "start": "1061800",
    "end": "1067680"
  },
  {
    "start": "1064000",
    "end": "1222000"
  },
  {
    "text": "represent a person we captured their first name their surname and optionally their age we also have a couple of",
    "start": "1067680",
    "end": "1074370"
  },
  {
    "text": "validation function so we have one called required that takes a maybe and returns an either that",
    "start": "1074370",
    "end": "1080500"
  },
  {
    "text": "represents a validation result so either a list of validation errors or the contents of them maybe we've got another",
    "start": "1080500",
    "end": "1086950"
  },
  {
    "text": "one called integer which takes a maybe string and returns a validation result with either an error if the string can't",
    "start": "1086950",
    "end": "1093940"
  },
  {
    "text": "be paused in to an int or maybe int if it could be now we want to write a",
    "start": "1093940",
    "end": "1099970"
  },
  {
    "text": "validation function that takes unvalidated user input so maybe a first name maybe a surname maybe an age but",
    "start": "1099970",
    "end": "1107260"
  },
  {
    "text": "we'll have it as a string because the user would have typed it in and what we want to do is return an either with that",
    "start": "1107260",
    "end": "1112690"
  },
  {
    "text": "contains either all the errors if there were validation errors or the constructed person if there were no",
    "start": "1112690",
    "end": "1119260"
  },
  {
    "text": "validation errors and we were able to do that validation and make a person record",
    "start": "1119260",
    "end": "1125310"
  },
  {
    "text": "so the code to write that without applicatives it's a bit ugly so the first thing we",
    "start": "1125310",
    "end": "1132100"
  },
  {
    "text": "have to do is validate all of our inputs and get back our validation results then",
    "start": "1132100",
    "end": "1137140"
  },
  {
    "text": "we want to do a pattern match and that's the case of so what we're doing here is a pattern match on all of the all of the",
    "start": "1137140",
    "end": "1143560"
  },
  {
    "text": "validation results and if they're all if they all passed so if they're all right we take the the validated result we pass",
    "start": "1143560",
    "end": "1150340"
  },
  {
    "text": "them into the person constructor we create that person we put it wrap it up into a write because we were successful",
    "start": "1150340",
    "end": "1155950"
  },
  {
    "text": "and return it however if one or more of those validation results were left then",
    "start": "1155950",
    "end": "1162790"
  },
  {
    "text": "we fall down into the next pattern match statement so in this particular part",
    "start": "1162790",
    "end": "1168400"
  },
  {
    "text": "we're saying okay we don't know exactly which ones were left versus right so what we're going to do is we're going to",
    "start": "1168400",
    "end": "1173860"
  },
  {
    "text": "use the from left function and what that does is that you give it an either and it gives you back the contents of the",
    "start": "1173860",
    "end": "1179320"
  },
  {
    "text": "left if the either was left but if it was right then obviously it can't give you back the contents to the left so it",
    "start": "1179320",
    "end": "1184360"
  },
  {
    "text": "returns the first parameter so from this will either get an empty list if there are no errors or the list of errors if",
    "start": "1184360",
    "end": "1190480"
  },
  {
    "text": "there were some we could take those errors and then we use plus plus to match them all together into one big",
    "start": "1190480",
    "end": "1196240"
  },
  {
    "text": "list that's just doing this depends we wrap that up in the left because we failed and return it so that's how we",
    "start": "1196240",
    "end": "1202720"
  },
  {
    "text": "can get our either list of errors or a constructed person",
    "start": "1202720",
    "end": "1207920"
  },
  {
    "text": "unfortunately it was fairly complex and annoying for something that's conceptually quite simple and that code",
    "start": "1207920",
    "end": "1213500"
  },
  {
    "text": "smells very boilerplate II let's dig into how applicatives work and once we've got that we'll circle back to how",
    "start": "1213500",
    "end": "1218900"
  },
  {
    "text": "we could use a bucket of stew clean up this code now applicatives are similar",
    "start": "1218900",
    "end": "1226010"
  },
  {
    "start": "1222000",
    "end": "1386000"
  },
  {
    "text": "to functors however instead of transforming values inside a structure with while we leave that structure alone",
    "start": "1226010",
    "end": "1232210"
  },
  {
    "text": "applicatives transform both the structure and the value so for type two",
    "start": "1232210",
    "end": "1237830"
  },
  {
    "text": "be an applicative it needs to have two functions it needs to have pure and apply so let's look at pure first pure",
    "start": "1237830",
    "end": "1245120"
  },
  {
    "text": "is a very very simple function let's have a look at its type signature so basically where F is an applicative if",
    "start": "1245120",
    "end": "1250520"
  },
  {
    "text": "we're given an a we can basically wrap that up inside the structure F and return it now the implementation for",
    "start": "1250520",
    "end": "1259070"
  },
  {
    "text": "maybe is very very simple all we do is we take in that X wrap it up and adjust and return it that's it now let's look",
    "start": "1259070",
    "end": "1267770"
  },
  {
    "text": "at the other function for applicatives and this is where the real meat of applicatives lies the apply function",
    "start": "1267770",
    "end": "1273280"
  },
  {
    "text": "let's break it down so the first bit is saying that f must be an applicative then given a function that can convert a",
    "start": "1273280",
    "end": "1281420"
  },
  {
    "text": "x' into B's and that function is wrapped inside the structure F and given a",
    "start": "1281420",
    "end": "1287450"
  },
  {
    "text": "structure F of A's apply will give us back a structure F of B's now a very",
    "start": "1287450",
    "end": "1294080"
  },
  {
    "text": "abstract again so let's look at the implementation for maybe so we've",
    "start": "1294080",
    "end": "1300080"
  },
  {
    "text": "substituted maybe for F here so if we have if we look at the the pattern matches there we're saying that",
    "start": "1300080",
    "end": "1305780"
  },
  {
    "text": "if the function we've got is inside a just and the value of God is also inside it just we can take the function invoke",
    "start": "1305780",
    "end": "1313250"
  },
  {
    "text": "it with the value and then wrap it back up and adjust and return it but here's",
    "start": "1313250",
    "end": "1318560"
  },
  {
    "text": "the crucial part if either the function or the value is nothing we return",
    "start": "1318560",
    "end": "1324230"
  },
  {
    "text": "nothing and this means what we're doing is we're combining the structure of the first parameter of the function with the",
    "start": "1324230",
    "end": "1330560"
  },
  {
    "text": "structure of the second parameter which is the value right so this is unlike functor where if we gotta just in we",
    "start": "1330560",
    "end": "1337010"
  },
  {
    "text": "always return to just if we've got a nothing in we always return to nothing and case if we get a nothing and adjust we",
    "start": "1337010",
    "end": "1342600"
  },
  {
    "text": "return nothing we transform it into a nothing and vice versa if we get if we get a we get adjust for the function and",
    "start": "1342600",
    "end": "1349049"
  },
  {
    "text": "the the value comes in is a nothing we just return nothing with and we throw that just away whatever it was now you",
    "start": "1349049",
    "end": "1357299"
  },
  {
    "text": "may have noticed that apply they apply functions type signature looks pretty similar to what we saw from map from",
    "start": "1357299",
    "end": "1364230"
  },
  {
    "text": "functor so if we put them side by side the similarities are even more apparent right so map takes a function from A to",
    "start": "1364230",
    "end": "1371400"
  },
  {
    "text": "B but apply has that function wrapped inside the structure so it turns out",
    "start": "1371400",
    "end": "1377190"
  },
  {
    "text": "that applicant any applicative is also a functor so the similarity between those signatures is less surprising than you'd",
    "start": "1377190",
    "end": "1383610"
  },
  {
    "text": "think so you're saying well that's nice",
    "start": "1383610",
    "end": "1390150"
  },
  {
    "start": "1386000",
    "end": "1806000"
  },
  {
    "text": "but it's all very abstract how can I use that well let's walk through a very simple practical example imagine we may",
    "start": "1390150",
    "end": "1398280"
  },
  {
    "text": "or may not have two strings so we've got string a and string B both of which are maybe strings so that we may have a string or we may not have a string for",
    "start": "1398280",
    "end": "1404580"
  },
  {
    "text": "either one and what we want to do is we want to take both of those strings and if we have them both we want to separate",
    "start": "1404580",
    "end": "1409710"
  },
  {
    "text": "them with a space so we've got a space separate function but it takes strings it doesn't take maybe strings but we",
    "start": "1409710",
    "end": "1416220"
  },
  {
    "text": "have maybe strings so how can we make this work and this is where applicative",
    "start": "1416220",
    "end": "1421350"
  },
  {
    "text": "can help us so we have a combined string function that uses pure and apply to effectively invoke space separate even",
    "start": "1421350",
    "end": "1429390"
  },
  {
    "text": "though we have maybes and we get back a maybe from that but that's not a very nice function to read there's too many",
    "start": "1429390",
    "end": "1435240"
  },
  {
    "text": "parentheses in there something for my taste and that's because usually apply is invoked in in fixed position",
    "start": "1435240",
    "end": "1442350"
  },
  {
    "text": "so in Haskell if you put back ticks around the function name you can invoke it like an operator like an in fixed",
    "start": "1442350",
    "end": "1447480"
  },
  {
    "text": "position as opposed to the usual place where we invoke a function which is prefix position when we do that suddenly",
    "start": "1447480",
    "end": "1454590"
  },
  {
    "text": "that expression becomes way easier to read so let's break that down and see how those types click together so pure",
    "start": "1454590",
    "end": "1462270"
  },
  {
    "text": "space separate is giving me this back and maybe string to string to string just so space separate is that function",
    "start": "1462270",
    "end": "1469230"
  },
  {
    "text": "and remember what pure does it takes foot whatever you pass it and wraps it in the structure so we're base we've taken that function and wrapped it",
    "start": "1469230",
    "end": "1475270"
  },
  {
    "text": "inside of maybe then what we're going to do is we're going to use apply string a",
    "start": "1475270",
    "end": "1480730"
  },
  {
    "text": "and what that's going to do is basically remember what the implementation does it",
    "start": "1480730",
    "end": "1485830"
  },
  {
    "text": "unwraps the function that we pass into first and then invokes it with the value that's in what we pass in and that's",
    "start": "1485830",
    "end": "1491560"
  },
  {
    "text": "what's happening here we invoke it and because it's a it's effectively a partial application we get back and maybe string to string we do it again",
    "start": "1491560",
    "end": "1499630"
  },
  {
    "text": "with this time with string B and we get back our final maybe string now we can",
    "start": "1499630",
    "end": "1508750"
  },
  {
    "text": "actually simplify this expression even further by relying on the fact that all the placate eaves are also functors",
    "start": "1508750",
    "end": "1514480"
  },
  {
    "text": "which means we have the map function available to us so we can replace that pure then apply with a single call to",
    "start": "1514480",
    "end": "1522280"
  },
  {
    "text": "map and let's look at the types to see how that works because that's a bit of a leap space separate map string a is",
    "start": "1522280",
    "end": "1530200"
  },
  {
    "text": "maybe string to string now that's a bit unintuitive so let's see how that kind of works so space separate is the",
    "start": "1530200",
    "end": "1537370"
  },
  {
    "text": "function with pasture map so up on the slide we've got the concrete type of map and the abstract type of it underneath",
    "start": "1537370",
    "end": "1543430"
  },
  {
    "text": "so we can see that when we use space separate a is string and B is string to string so our F of a which is string a",
    "start": "1543430",
    "end": "1550810"
  },
  {
    "text": "is maybe string and we get back an F of B which is our maybe string to string so that's how we've ended up when we've",
    "start": "1550810",
    "end": "1556840"
  },
  {
    "text": "used spaced separate map string a that's how we've ended up with maybe string to string so the next thing we can do is",
    "start": "1556840",
    "end": "1564070"
  },
  {
    "text": "call apply string B and we get back our final maybe string now that sort of",
    "start": "1564070",
    "end": "1570370"
  },
  {
    "text": "thing is very common when we write Haskell so Haskell has operators for map and apply which makes that expression",
    "start": "1570370",
    "end": "1576580"
  },
  {
    "text": "even more terse than it already was this takes a bit of getting used to with the crazy symbols so I'll try to avoid using",
    "start": "1576580",
    "end": "1583390"
  },
  {
    "text": "them where I can and where I can't I'll put a comment next to it because it's much easier to understand when you're",
    "start": "1583390",
    "end": "1588670"
  },
  {
    "text": "learning when you've actually got an English word to latch on to",
    "start": "1588670",
    "end": "1592650"
  },
  {
    "text": "all right so either is also in applicative and it's it's similar it's",
    "start": "1594020",
    "end": "1600710"
  },
  {
    "text": "similar it's in the way that it's also a functor right so we can say the implementation of apply and pure up on",
    "start": "1600710",
    "end": "1605870"
  },
  {
    "text": "the slide so when we're for the implementation of apply if both the function and the value come in is rights",
    "start": "1605870",
    "end": "1612770"
  },
  {
    "text": "then we can take that function run it run it with the value we've got and wrap it back up and a write and return it",
    "start": "1612770",
    "end": "1618860"
  },
  {
    "text": "however if we get a left for either the for either the function or the value we",
    "start": "1618860",
    "end": "1624560"
  },
  {
    "text": "transform it into a let and return it but notice how we preference the left from the function so if both of them",
    "start": "1624560",
    "end": "1631310"
  },
  {
    "text": "come in is left we hit the first pad match the left sorry that's the second statement in the past the second",
    "start": "1631310",
    "end": "1637760"
  },
  {
    "text": "expression in the pattern matched so the first left there and we return that left we don't return the error we throw away",
    "start": "1637760",
    "end": "1644240"
  },
  {
    "text": "that error from the from the value and this is this is an important thing to just hold that in the back of your head for a second pure is very simple all we",
    "start": "1644240",
    "end": "1653480"
  },
  {
    "text": "do is we take our X wrap it up in a right and return it okay so now let's",
    "start": "1653480",
    "end": "1659780"
  },
  {
    "text": "circle back to our original validate person function that we saw before that was kind of gross and ugly Haskell has a",
    "start": "1659780",
    "end": "1667940"
  },
  {
    "text": "library that provides us the acceleration type and which is a very similar to either in that it's a some",
    "start": "1667940",
    "end": "1674000"
  },
  {
    "text": "type that either gives you a successful value or a failure failure value that",
    "start": "1674000",
    "end": "1679610"
  },
  {
    "text": "with some errors similar validation functions are available if you're",
    "start": "1679610",
    "end": "1685130"
  },
  {
    "text": "writing if you're writing f-sharp the f-sharp X library gives you a way to use choice in a similar way as we're going",
    "start": "1685130",
    "end": "1691310"
  },
  {
    "text": "to use a crevalle addition here so the key here is that act validation is also",
    "start": "1691310",
    "end": "1697010"
  },
  {
    "text": "a functor and an applicative so we've got the same person record type before",
    "start": "1697010",
    "end": "1702760"
  },
  {
    "text": "but this time our validation functions instead of returning either will return act validation instead and the reason",
    "start": "1702760",
    "end": "1709760"
  },
  {
    "text": "that we're using AK validation here instead of either even though we saw just before that either is an applicative is that the ACT validations",
    "start": "1709760",
    "end": "1716570"
  },
  {
    "text": "applicative implementation retains all of the errors where as we saw before with either it throws away one of the",
    "start": "1716570",
    "end": "1722690"
  },
  {
    "text": "errors if both the function and the value come in as as left's we toss one of the values and one of the areas and we don't want",
    "start": "1722690",
    "end": "1728399"
  },
  {
    "text": "that we want to keep all of our areas and that's something that acts validation will do that either doesn't",
    "start": "1728399",
    "end": "1733760"
  },
  {
    "text": "so what we're going to do now is we're going to use the the functor and applicative patterns to compose together",
    "start": "1733760",
    "end": "1739710"
  },
  {
    "text": "all of these pieces in a very clean and readable way in order to validate that user input and construct a person record",
    "start": "1739710",
    "end": "1746309"
  },
  {
    "text": "or get our back our list of of errors so what we're doing is we're taking those three maybe strings and then we're",
    "start": "1746309",
    "end": "1752580"
  },
  {
    "text": "validating them using that same map apply apply pattern that we saw before so we've got our person constructor it",
    "start": "1752580",
    "end": "1758279"
  },
  {
    "text": "takes a string and another string and a maybe int and we're basically going map required first name apply required",
    "start": "1758279",
    "end": "1764639"
  },
  {
    "text": "second surname apply into J age and the ACT validation functor and applicative we'll make sure",
    "start": "1764639",
    "end": "1771870"
  },
  {
    "text": "that we get back an AK validation of errors or a successful person and this",
    "start": "1771870",
    "end": "1777690"
  },
  {
    "text": "code is so much more simple and much more readable than the original and it scales a lot better if you have a person",
    "start": "1777690",
    "end": "1783779"
  },
  {
    "text": "that has more than three properties isn't as most person people what most people do have more than three properties so if we had ten there you",
    "start": "1783779",
    "end": "1790049"
  },
  {
    "text": "can imagine with the original code how many how much wider that that that like Pat match would be how many more lines",
    "start": "1790049",
    "end": "1796470"
  },
  {
    "text": "we'd need in there with this we just add more more applies at the end and so it scales much more nicely it's and it",
    "start": "1796470",
    "end": "1802980"
  },
  {
    "text": "still stays very readable so applicative",
    "start": "1802980",
    "end": "1808139"
  },
  {
    "start": "1806000",
    "end": "1849000"
  },
  {
    "text": "is a bit rarer in the wild mainly because it's a very functional pattern and it relies heavily on curried",
    "start": "1808139",
    "end": "1813720"
  },
  {
    "text": "functions so you'll usually not see this show up in an imperative language however it does show up in functional",
    "start": "1813720",
    "end": "1820200"
  },
  {
    "text": "languages like f-sharp though in F sharp you need to pull in the F sharp X library and that adds a bunch of",
    "start": "1820200",
    "end": "1825330"
  },
  {
    "text": "implementations for pure and apply to many types so f sharp X we'll call pure return in and apply app so I put some",
    "start": "1825330",
    "end": "1834029"
  },
  {
    "text": "examples up on the slide of it in action so we've got one for option and we've got for choice and for validation choice",
    "start": "1834029",
    "end": "1839639"
  },
  {
    "text": "so f sharp x will let you do that validation thing that we just saw using the choice type and it is also for async",
    "start": "1839639",
    "end": "1849110"
  },
  {
    "start": "1849000",
    "end": "1951000"
  },
  {
    "text": "so let's have a look at an F shop example for applicatives so let's imagine a simple function which needs to",
    "start": "1850420",
    "end": "1856300"
  },
  {
    "text": "load a bunch of data to populate a view model in this case it loads some user data a bunch of categories and the",
    "start": "1856300",
    "end": "1863500"
  },
  {
    "text": "particular item for whatever page this is and it's using F sharks I think so we're using let bang to load each of those things asynchronously in turn then",
    "start": "1863500",
    "end": "1870700"
  },
  {
    "text": "we're passing all of them in to make your model and returning it this is a perfect place where we can use",
    "start": "1870700",
    "end": "1876340"
  },
  {
    "text": "applicatives to make this code even less well I can make it slightly less noisy",
    "start": "1876340",
    "end": "1882240"
  },
  {
    "text": "so the F sharp X library gives us some operators we can use it in fixed position so that we can keep that",
    "start": "1882240",
    "end": "1888370"
  },
  {
    "text": "readability because remember when it was with parentheses it was kind of ugly and we can use those operators to use that",
    "start": "1888370",
    "end": "1894220"
  },
  {
    "text": "same applicative map apply apply style to effectively invoke that make make view model function by just you know",
    "start": "1894220",
    "end": "1902800"
  },
  {
    "text": "using that map apply style and we don't need to have the computation expression or we don't need that return and what",
    "start": "1902800",
    "end": "1908710"
  },
  {
    "text": "this makes evident to us immediately when we can see that expression is that there is no relationship between any of",
    "start": "1908710",
    "end": "1914380"
  },
  {
    "text": "those three async calls they're completely independent so there's potential that we could actually run those a syncs in parallel so if this was",
    "start": "1914380",
    "end": "1921310"
  },
  {
    "text": "done in Haskell there's actually a concurrently type that you can put in there that's also an applicative that",
    "start": "1921310",
    "end": "1926350"
  },
  {
    "text": "magically makes all of that run in parallel for us and we don't really have to change the shape of our code at all we just use concurrently as your",
    "start": "1926350",
    "end": "1933190"
  },
  {
    "text": "applicative instead of the original IO which is Haskell's ish version of of async now I'm not aware of a similar",
    "start": "1933190",
    "end": "1942220"
  },
  {
    "text": "thing in f-sharp but I think it'll be pretty easy to write something similar so you can just stick an additional type",
    "start": "1942220",
    "end": "1947950"
  },
  {
    "text": "in there and have things run in parallel all right so now got a little example of",
    "start": "1947950",
    "end": "1954760"
  },
  {
    "start": "1951000",
    "end": "2250000"
  },
  {
    "text": "how we could do command-line argument pausing and use the same applicative pattern to compose together different",
    "start": "1954760",
    "end": "1960460"
  },
  {
    "text": "pauses so I'm going to switch out of the slides and hop into Adam so this example",
    "start": "1960460",
    "end": "1968200"
  },
  {
    "text": "is in high school because in this particular library octopi as applicative is a haskell library I don't expect",
    "start": "1968200",
    "end": "1974290"
  },
  {
    "text": "everyone to entirely grok what's going on in this file because I'm not gonna explain how the the optimizer",
    "start": "1974290",
    "end": "1980530"
  },
  {
    "text": "applicative library works in detail but you should be able to get a general sense of how it kind of pieces together and then",
    "start": "1980530",
    "end": "1986260"
  },
  {
    "text": "hopefully you'll be able to see at the end where we use that same map apply apply applicative style to compose the",
    "start": "1986260",
    "end": "1992470"
  },
  {
    "text": "other bits so what we've got here is basically an application that defines a configuration record so it's going to",
    "start": "1992470",
    "end": "1999190"
  },
  {
    "text": "take some configuration from the command line we've got an API URI is one of the",
    "start": "1999190",
    "end": "2004410"
  },
  {
    "text": "things that we're going to want from the command line we've got a dry run flag so a ball whether we want to run and try",
    "start": "2004410",
    "end": "2010140"
  },
  {
    "text": "run mode or not and we've also got a verbose flag so maybe you want to do some of our voice logging we want to be able to turn it on",
    "start": "2010140",
    "end": "2015630"
  },
  {
    "text": "and off so here we're basically defined apposite",
    "start": "2015630",
    "end": "2022130"
  },
  {
    "text": "API URI from the command line so a positive purgative has this option function and that what that means is",
    "start": "2022280",
    "end": "2028559"
  },
  {
    "text": "that we're gonna be configuring a parser for an option where you you basically can submit a value so that'll be our URL",
    "start": "2028559",
    "end": "2033720"
  },
  {
    "text": "that we type in right because it's a URI and the command line just has strings on",
    "start": "2033720",
    "end": "2039840"
  },
  {
    "text": "it we need a way of parsing that URI into into like from a string into a URI and validating it so there's a paas you",
    "start": "2039840",
    "end": "2046140"
  },
  {
    "text": "are a function that will do that so we're using that here we want on the command line for it to be - - API URI in",
    "start": "2046140",
    "end": "2052919"
  },
  {
    "text": "the long form so if that's how we're telling the the library to use that the meta VAR URI is like a little bit of",
    "start": "2052919",
    "end": "2059878"
  },
  {
    "text": "documentation so you know when it prints out the help text it'll say - - API URI and then you need to pass a URI here and",
    "start": "2059879",
    "end": "2067740"
  },
  {
    "text": "there's some help text we've got a parser for the dry run flag so we're saying this we want we want to parse for",
    "start": "2067740",
    "end": "2074429"
  },
  {
    "text": "a flag the flag can either be false or true so if false if you don't pass it the flag and true if you do the short",
    "start": "2074429",
    "end": "2080790"
  },
  {
    "text": "form of a flag is just dash D and the long form is - - dry run and a bit of help text and we've got a similar",
    "start": "2080790",
    "end": "2086638"
  },
  {
    "text": "structure for the verbose flags we've got another paz' this one will be - v + - - verbose now",
    "start": "2086639",
    "end": "2095158"
  },
  {
    "text": "we've got this record here that takes a URI a ball and a ball and and we've got",
    "start": "2095159",
    "end": "2101190"
  },
  {
    "text": "parses for URI ball and ball but what we actually want is a positive for configuration because at the end of the",
    "start": "2101190",
    "end": "2106380"
  },
  {
    "text": "day we want to take a command line off the from you know and take our string from our command line pause it into a configuration record so we can come we",
    "start": "2106380",
    "end": "2113820"
  },
  {
    "text": "can basically compose together this these three parses into a positive that creates configuration for us so if I scroll down",
    "start": "2113820",
    "end": "2121470"
  },
  {
    "text": "here we've got our configuration parser which is just a composition of the three previous pauses that we saw using the",
    "start": "2121470",
    "end": "2128640"
  },
  {
    "text": "same map apply apply so we're taking our function for configuration so if I hover",
    "start": "2128640",
    "end": "2134160"
  },
  {
    "text": "over this you can see if configuration is simply a constructor function that takes a URI a ball in a ball and",
    "start": "2134160",
    "end": "2139710"
  },
  {
    "text": "produces a configuration and we're doing map API URI apply dry run flag apply for",
    "start": "2139710",
    "end": "2149249"
  },
  {
    "text": "both flag and we get back a positive configuration so it's the same applicative pattern that used in many",
    "start": "2149249",
    "end": "2154680"
  },
  {
    "text": "different situations in this case for pauses and down at the bottom there's a",
    "start": "2154680",
    "end": "2159749"
  },
  {
    "text": "bit of magic invocation to positive asically take that string off the command line and then we're going to print out that configuration so I'll",
    "start": "2159749",
    "end": "2166769"
  },
  {
    "text": "just demonstrate that so you can see how that works in reality so I've already compiled this guy so we can go args",
    "start": "2166769",
    "end": "2172559"
  },
  {
    "text": "example XE and if we pass - - help that library will print out some help text",
    "start": "2172559",
    "end": "2178229"
  },
  {
    "text": "for us based on all those parameters we pass so you can see it we've got an executable it takes API URI",
    "start": "2178229",
    "end": "2183809"
  },
  {
    "text": "there's our meta bar and then you can optionally pass - d or - - dry run or -",
    "start": "2183809",
    "end": "2189749"
  },
  {
    "text": "vo verbose and I hope text is here so if I go - - it's a - - API URI and then",
    "start": "2189749",
    "end": "2199200"
  },
  {
    "text": "pass say local Eddy and then let's say",
    "start": "2199200",
    "end": "2207420"
  },
  {
    "text": "we want to run in for burst mode we can see we've got a there's the printout of our configuration so we've got our API",
    "start": "2207420",
    "end": "2212549"
  },
  {
    "text": "URI and have a boost flag set of course we could use - - dry run and we'd have",
    "start": "2212549",
    "end": "2219660"
  },
  {
    "text": "our dry run flag set and of course we could pass them some crap in here as well and it would break so if we just",
    "start": "2219660",
    "end": "2224849"
  },
  {
    "text": "pass in junk for the URI we're gonna get a parse failure so that's pretty cool we",
    "start": "2224849",
    "end": "2230849"
  },
  {
    "text": "can use that same a pattern to do parsing we can use the same pattern to you know combine together maybe as we",
    "start": "2230849",
    "end": "2237239"
  },
  {
    "text": "can use the same pattern to combine together either's and you know basically any type that's an applicative we can use that same pattern alright",
    "start": "2237239",
    "end": "2247969"
  },
  {
    "start": "2250000",
    "end": "2312000"
  },
  {
    "text": "so now we probably get to the most famous of functional programming patterns the one that for some reason is",
    "start": "2251380",
    "end": "2256870"
  },
  {
    "text": "told by developer parents to scare their children into using JavaScript or something however you shouldn't be",
    "start": "2256870",
    "end": "2262870"
  },
  {
    "text": "worried we'll see that the big bad monad is basically just an extension of what we've seen before in functions functors",
    "start": "2262870",
    "end": "2269440"
  },
  {
    "text": "and applicatives now you often hear people describe monads with metaphors",
    "start": "2269440",
    "end": "2274480"
  },
  {
    "text": "like a monad is a burrito or monads let you do side effects or monad is is how",
    "start": "2274480",
    "end": "2279790"
  },
  {
    "text": "you do imperative programming in a functional language now all of these are true except for maybe the burrito one I",
    "start": "2279790",
    "end": "2285700"
  },
  {
    "text": "don't when I get that one but I don't think you should try to rationalize monads like that monads are a very",
    "start": "2285700",
    "end": "2291400"
  },
  {
    "text": "abstract concept that's used for applying structure applying functions over structure similar to an applicative",
    "start": "2291400",
    "end": "2297280"
  },
  {
    "text": "but because it's so powerful it can be used to do things like side effects and to do things like imperative style",
    "start": "2297280",
    "end": "2303220"
  },
  {
    "text": "programming but it itself isn't those things they're just something that the monads pattern can enable you to do so",
    "start": "2303220",
    "end": "2308500"
  },
  {
    "text": "don't try and box it into just one of those things so first let's look at some",
    "start": "2308500",
    "end": "2313930"
  },
  {
    "start": "2312000",
    "end": "2399000"
  },
  {
    "text": "crappy code this is a kind of a contrived example for simplicity sake but imagine we have a user ID and we",
    "start": "2313930",
    "end": "2319990"
  },
  {
    "text": "want to get a user's rolls display name we've got a map or a dictionary of users",
    "start": "2319990",
    "end": "2325030"
  },
  {
    "text": "by their ID we've got a map of users to roles and we've got a map of roles to string where the string is thatis by",
    "start": "2325030",
    "end": "2330400"
  },
  {
    "text": "name and what we want to do is basically navigate these maps in order and if we can't find a key at any point we just",
    "start": "2330400",
    "end": "2336430"
  },
  {
    "text": "want to return nothing and if we can if we make it off make it the whole way through we want to return the the users",
    "start": "2336430",
    "end": "2343600"
  },
  {
    "text": "roles display name now you can see the code that we have to write to do that",
    "start": "2343600",
    "end": "2348820"
  },
  {
    "text": "we're using our lookup function which takes a map you can take a key and return a maybe value so it's the keys",
    "start": "2348820",
    "end": "2354850"
  },
  {
    "text": "not in the map you get nothing if it is you get a just in the value and that lookup codes kind of ugly right because",
    "start": "2354850",
    "end": "2360490"
  },
  {
    "text": "what we're doing is we're basically doing a map we're doing a lookup of our user ID in the first map then we get",
    "start": "2360490",
    "end": "2366520"
  },
  {
    "text": "maybe back so we have to do a pattern match we get back the user if we've got it we do the next lookup we do a pattern",
    "start": "2366520",
    "end": "2372340"
  },
  {
    "text": "match we do the next lookup it's kind of you get that crappy indenting style and you know if we're getting nothing at any",
    "start": "2372340",
    "end": "2379180"
  },
  {
    "text": "point we have to do a short-circuit and just return nothing so",
    "start": "2379180",
    "end": "2384700"
  },
  {
    "text": "scale well if we need to do more lookups the indenting gets even worse this is a sort of code that we can clean up this",
    "start": "2384700",
    "end": "2391000"
  },
  {
    "text": "is one Wales one other sorts of code we can clean up very beautifully with the use of monads so let's dig into them and",
    "start": "2391000",
    "end": "2396490"
  },
  {
    "text": "we'll come back to this and see how we can clean it up so the best way to understand monads is to look at its",
    "start": "2396490",
    "end": "2403599"
  },
  {
    "start": "2399000",
    "end": "2538000"
  },
  {
    "text": "function type signature and compare it to functor and applicative then see how it's implemented for different types",
    "start": "2403599",
    "end": "2408700"
  },
  {
    "text": "because it is different for different types you can see the map and apply functions from functor and applicative",
    "start": "2408700",
    "end": "2414400"
  },
  {
    "text": "up on the slide all monads are functors and duplicative so all monads have the functions we've looked at previously so",
    "start": "2414400",
    "end": "2420490"
  },
  {
    "text": "map apply impure however monads go one step further in that they also have the",
    "start": "2420490",
    "end": "2426130"
  },
  {
    "text": "bind function so if we line the bind functions type up next to map and apply you can see some structural similarities",
    "start": "2426130",
    "end": "2432849"
  },
  {
    "text": "already so let's break down bind so we're saying F is a monad and given a",
    "start": "2432849",
    "end": "2440410"
  },
  {
    "text": "function that can take an A and produce a structure F with B's inside it and",
    "start": "2440410",
    "end": "2445859"
  },
  {
    "text": "give it a structure F of S bind will give us back a structure F of B's now",
    "start": "2445859",
    "end": "2454210"
  },
  {
    "text": "notice the difference between this and map and apply map basically takes a",
    "start": "2454210",
    "end": "2460030"
  },
  {
    "text": "function that can convert from a convert AIDS to B's applicative so apply will",
    "start": "2460030",
    "end": "2466060"
  },
  {
    "text": "basically take that function ace to B's but it will have it wrapped inside a structure bind takes a function that can",
    "start": "2466060",
    "end": "2474160"
  },
  {
    "text": "take an A and produce a new structure FB and this is why it's so much more",
    "start": "2474160",
    "end": "2479859"
  },
  {
    "text": "powerful than both both map and apply the function that you pass can return those new structures that bind will",
    "start": "2479859",
    "end": "2486400"
  },
  {
    "text": "combine back into that main structure neither map or apply can do that they can't combine structures like like like",
    "start": "2486400",
    "end": "2493720"
  },
  {
    "text": "they can't bind combine these nested structures like like like bind can so",
    "start": "2493720",
    "end": "2499630"
  },
  {
    "text": "let's start looking at some concrete examples here to make that make that more real there may be type is a monad",
    "start": "2499630",
    "end": "2505569"
  },
  {
    "text": "so you can see from the implementation that it's extremely simple in fact this is probably the simplest implementation",
    "start": "2505569",
    "end": "2511150"
  },
  {
    "text": "short of pure that we've seen so far all we're doing is we're saying OK we get a maybe in if it's just",
    "start": "2511150",
    "end": "2517850"
  },
  {
    "text": "got a function we run the we run the the contents of the just through the function which produces them maybe that we need to return job done however if we",
    "start": "2517850",
    "end": "2525950"
  },
  {
    "text": "were if we get a nothing we just return nothing and we don't use that function so you can see in the Pat match is just",
    "start": "2525950",
    "end": "2531410"
  },
  {
    "text": "under school we don't care about that function we just throw it away don't use it so given that",
    "start": "2531410",
    "end": "2538490"
  },
  {
    "start": "2538000",
    "end": "2760000"
  },
  {
    "text": "implementation let's have a look at how we can clean up our previously ugly lookup code with monads and see how the",
    "start": "2538490",
    "end": "2544370"
  },
  {
    "text": "monad can give us a bit more power than applicative now what we want to do is",
    "start": "2544370",
    "end": "2549890"
  },
  {
    "text": "given that user ID we want to do a lookup and we want to use that user ID in that first lookup to get the user if",
    "start": "2549890",
    "end": "2556640"
  },
  {
    "text": "it exists if it doesn't exist we're gonna get back a nothing so you can see the code up on the slide we've just",
    "start": "2556640",
    "end": "2562370"
  },
  {
    "text": "tried to take that maybe and jam it into the lookup and obviously we get a type error because we need a user but we've got a maybe user now in the previous",
    "start": "2562370",
    "end": "2568970"
  },
  {
    "text": "example we use the pattern match to get that user out but he would just put it in and doesn't work map and apply can't",
    "start": "2568970",
    "end": "2575030"
  },
  {
    "text": "help us here because you can see from there type signatures neither of them allow us to pass a function that returns a maybe and we have a maybe so we can",
    "start": "2575030",
    "end": "2583640"
  },
  {
    "text": "fix this error by passing lookup to bind after partially applying the map to it",
    "start": "2583640",
    "end": "2589100"
  },
  {
    "text": "so see that after partially applying lookup what we're doing is we're passing we're passing well the function we're",
    "start": "2589100",
    "end": "2595280"
  },
  {
    "text": "passing a bind is a function that matches what binds needs so remember bind needs an a and it produces an FB so",
    "start": "2595280",
    "end": "2600890"
  },
  {
    "text": "in this case the partially apply the lookup user role map is the key so key is our a and maybe is our F and value is",
    "start": "2600890",
    "end": "2608690"
  },
  {
    "text": "our B so that matches what we need so in high school and in and in F sharp to",
    "start": "2608690",
    "end": "2616250"
  },
  {
    "text": "some extent we usually use the bind function with its to its two parameters",
    "start": "2616250",
    "end": "2621800"
  },
  {
    "text": "flipped around the other way so FA comes first and then amend the function and we generally use it as an operator and",
    "start": "2621800",
    "end": "2628670"
  },
  {
    "text": "that's that famous symbol that we've probably seen before that kind of makes up the Haskell logo as well so you can",
    "start": "2628670",
    "end": "2636770"
  },
  {
    "text": "see that once we do that and we have bind as an operator like this we can get that nice terse fluent style and you can",
    "start": "2636770",
    "end": "2643070"
  },
  {
    "text": "see that at the bottom right of the slide and we've used bind here to join together those lookups and so you can",
    "start": "2643070",
    "end": "2648740"
  },
  {
    "text": "keep adding additional binds there nice fluent way and you get that desired behavior of either getting your final",
    "start": "2648740",
    "end": "2655940"
  },
  {
    "text": "result as adjust or getting a nothing if any of the lookups failed so you can see",
    "start": "2655940",
    "end": "2661700"
  },
  {
    "text": "that we've trivially added that final look up for the rolled name the roll display name map we've added that to the",
    "start": "2661700",
    "end": "2667099"
  },
  {
    "text": "end and you know that code is still neat and readable and we could keep adding lookups here and we wouldn't be I don't",
    "start": "2667099",
    "end": "2672170"
  },
  {
    "text": "have that indenting problem where it just gets out of control this scales very nicely and it's still readable so",
    "start": "2672170",
    "end": "2678410"
  },
  {
    "text": "bind works for us here because the bind for back bind for maybe is basically implementing fail-fast for us remember",
    "start": "2678410",
    "end": "2685640"
  },
  {
    "text": "the implementation from before if the maybe comes in is nothing then we don't use that function we just throw it away so in this case if the lookup returns",
    "start": "2685640",
    "end": "2692839"
  },
  {
    "text": "nothing we return nothing and we don't do any of the subsequent lookup so it just happens for us that plumbing is is",
    "start": "2692839",
    "end": "2698809"
  },
  {
    "text": "handled for us by bind and this is this means we have much cleaner code than our original indented pattern matching code",
    "start": "2698809",
    "end": "2708010"
  },
  {
    "text": "now either E is also a monad and its implementation is very similar to maybe so likes a functor and applicatives we",
    "start": "2708520",
    "end": "2716089"
  },
  {
    "text": "need to fix that first type parameter so for either to be a monad we're actually saying either is the monad not either",
    "start": "2716089",
    "end": "2722920"
  },
  {
    "text": "for writes in the implementation all we're doing is if we have that right we take the X out of the right we run it",
    "start": "2722920",
    "end": "2729650"
  },
  {
    "text": "through the function and return it because remember that function is going to create the either that we need to return the left's similar to maybe we",
    "start": "2729650",
    "end": "2736640"
  },
  {
    "text": "just ignore the function and return the left and this makes the ELA monad very useful for modeling error handling in a",
    "start": "2736640",
    "end": "2743930"
  },
  {
    "text": "type safe way so remember how I said before right at the beginning of the presentation we can often use the either",
    "start": "2743930",
    "end": "2749390"
  },
  {
    "text": "type to model errors so left would be our errors and right would be our successful results so in the cases where",
    "start": "2749390",
    "end": "2755210"
  },
  {
    "text": "we have left's we don't run the next step we just return the error so let's",
    "start": "2755210",
    "end": "2761059"
  },
  {
    "start": "2760000",
    "end": "3014000"
  },
  {
    "text": "see a small example of that and for a change let's do it in F sharp so in this example we've got a transfer money",
    "start": "2761059",
    "end": "2767450"
  },
  {
    "text": "function it takes an amount a from account and a to account and for what",
    "start": "2767450",
    "end": "2773720"
  },
  {
    "text": "the very first step we're going to do is we're going to withdraw some money but this might fail because maybe you don't have enough money in your account or",
    "start": "2773720",
    "end": "2779839"
  },
  {
    "text": "something so it returns a choice which is F sharps either it's a choice between either successful withdrawal receipt or an",
    "start": "2779839",
    "end": "2787790"
  },
  {
    "text": "error if there was a problem what we do next is we use bind and we used bind",
    "start": "2787790",
    "end": "2793339"
  },
  {
    "text": "with a lambda to receive the withdrawal receipt if it was successful right remember that bind won't call our lambda",
    "start": "2793339",
    "end": "2800510"
  },
  {
    "text": "if our choice comes back with an error so automatically we don't try to do a",
    "start": "2800510",
    "end": "2805550"
  },
  {
    "text": "deposit if withdrawal failed so we then deposit some money but of",
    "start": "2805550",
    "end": "2811940"
  },
  {
    "text": "course depositing money might fail so it returns a choice as well and we do another bind to receive the the deposit",
    "start": "2811940",
    "end": "2818060"
  },
  {
    "text": "receipt and if we get a deposit receipt then we send a notification involving all that information of course that might fail because everything can fail",
    "start": "2818060",
    "end": "2824060"
  },
  {
    "text": "and that returns a choice so bind for choice here is basically ensuring that",
    "start": "2824060",
    "end": "2829910"
  },
  {
    "text": "for each subsequent lambda it doesn't run if the previous part failed and out",
    "start": "2829910",
    "end": "2836180"
  },
  {
    "text": "of the end we either get a successful result or we get the first error that occurred so you can see that syntax",
    "start": "2836180",
    "end": "2843230"
  },
  {
    "text": "again is pretty yucky there's too many parentheses so f-sharp actually has a syntax sugar called computation",
    "start": "2843230",
    "end": "2849650"
  },
  {
    "text": "expression that we've seen before but it's usually used with icing that's the most common example of it but in this",
    "start": "2849650",
    "end": "2854810"
  },
  {
    "text": "case f-sharp X can give us the choose computation expression that basically gives you that nice let bang syntax but",
    "start": "2854810",
    "end": "2863329"
  },
  {
    "text": "for the for the choose the either monad so what's happening here is those LED",
    "start": "2863329",
    "end": "2869990"
  },
  {
    "text": "bangs exec are actually doing binds behind the scenes Haskell also has its own syntax sugar like this called do",
    "start": "2869990",
    "end": "2876950"
  },
  {
    "text": "called do notation and this has made our functional code actually quite says it's",
    "start": "2876950",
    "end": "2882410"
  },
  {
    "text": "made of functional code look quite imperative again and I think maybe this is where that that that myth that monads",
    "start": "2882410",
    "end": "2888589"
  },
  {
    "text": "are for imperative style coding in functional languages and I think maybe that's the best that that comes from that's one thing they can enable when",
    "start": "2888589",
    "end": "2895730"
  },
  {
    "text": "we've kind of seen it here but a moaner is a much more general abstraction and it's behavior depends on how the type",
    "start": "2895730",
    "end": "2901369"
  },
  {
    "text": "implementing the pattern has chosen to implemented so the monad implementation",
    "start": "2901369",
    "end": "2906710"
  },
  {
    "text": "for lists is a really good example of this it has nothing to do with imperative programming at all in fact this is the one monad you've all",
    "start": "2906710",
    "end": "2912950"
  },
  {
    "text": "probably used without even knowing it but we'll get to that in a moment let's first see how whist",
    "start": "2912950",
    "end": "2918589"
  },
  {
    "text": "be a monad so we can see the implementation for bind up on the slide so we can see what binders doing here is",
    "start": "2918589",
    "end": "2924829"
  },
  {
    "text": "basically recurring through that list so again xx's is doing that list list decomposition so we're basically taking",
    "start": "2924829",
    "end": "2931519"
  },
  {
    "text": "each item from the list and running it through the function and producing a sub list which were then appending onto the",
    "start": "2931519",
    "end": "2937160"
  },
  {
    "text": "recursive call to the rest of the list right so what this is effectively doing is going through the list one and for",
    "start": "2937160",
    "end": "2942739"
  },
  {
    "text": "each item we produce a sub list which were then joining back together into one big list at the end and this is why this",
    "start": "2942739",
    "end": "2950029"
  },
  {
    "text": "implementation bind for lists is often called collect or flatmap when we find it in other languages other than Haskell",
    "start": "2950029",
    "end": "2957759"
  },
  {
    "text": "so what's interesting here is if we compare what calling map instead of bind would do to our lists if we use that a -",
    "start": "2957759",
    "end": "2964789"
  },
  {
    "text": "list of B function so if we if you have a look at nested lists up on the bottom the bottom left of the slide we can see",
    "start": "2964789",
    "end": "2971450"
  },
  {
    "text": "that we've got a function that takes AIDS and returns a list of B's and we've passed that to map instead of passing it",
    "start": "2971450",
    "end": "2977869"
  },
  {
    "text": "to bind and what we're getting back from that is a nested list of B's if we use bind instead of map we would get back a",
    "start": "2977869",
    "end": "2984259"
  },
  {
    "text": "flattened list of B's this is the power that bind gives you it basically allows",
    "start": "2984259",
    "end": "2991369"
  },
  {
    "text": "you to combine new structures together in this case it will combine the the list of B's that our passed in function",
    "start": "2991369",
    "end": "2997039"
  },
  {
    "text": "is producing back into a final flat list of B's right map can't do that because member its structure preserving so we",
    "start": "2997039",
    "end": "3003430"
  },
  {
    "text": "can't change the original list structure that list length has to remain the same but bind doesn't have that restriction",
    "start": "3003430",
    "end": "3008769"
  },
  {
    "text": "it can do more and in this case it will flatten our lists for us so let's have a",
    "start": "3008769",
    "end": "3016450"
  },
  {
    "start": "3014000",
    "end": "3117000"
  },
  {
    "text": "look at how monads power async computation expressions in F sharp this time it's well we'll do a bit of an",
    "start": "3016450",
    "end": "3023200"
  },
  {
    "text": "example and D sugar it and start with our async expressions and do sugar it down into the binds that are actually",
    "start": "3023200",
    "end": "3029469"
  },
  {
    "text": "happening here so we've got a register a new user async function and what this guy is doing is basically well the first",
    "start": "3029469",
    "end": "3036999"
  },
  {
    "text": "step it does is it creates a user asynchronously it gets back that user ID so if we do sugar that down what we can",
    "start": "3036999",
    "end": "3042910"
  },
  {
    "text": "see is that let bang is actually a bind where where the next step is a lambda that receives that that user ID when it",
    "start": "3042910",
    "end": "3049719"
  },
  {
    "text": "comes and it eventually arrives they sink and so the next step we're doing is a is a",
    "start": "3049719",
    "end": "3055539"
  },
  {
    "text": "do bang where we're signing that defaults fine assigning some default permissions for that new user and of",
    "start": "3055539",
    "end": "3061539"
  },
  {
    "text": "course a do bang is also a bind but in this case because it's a do bang the lambda that we're passing to bind just",
    "start": "3061539",
    "end": "3068109"
  },
  {
    "text": "ignores whatever's passed to it because du doesn't do throws away the result of an async the next step we're going to do",
    "start": "3068109",
    "end": "3076569"
  },
  {
    "text": "is return our user ID but remember the the form of of bind up at the top we",
    "start": "3076569",
    "end": "3081819"
  },
  {
    "text": "have a function that takes an Abe and it has to return an FB so in this case we need to return an async but a user ID is",
    "start": "3081819",
    "end": "3088960"
  },
  {
    "text": "just a user ID aslam an async we need to return an async if we wanted to fit the form so here what we're doing is we're",
    "start": "3088960",
    "end": "3095349"
  },
  {
    "text": "using pure which is called return in in in F sharp we're using pure to take that",
    "start": "3095349",
    "end": "3100510"
  },
  {
    "text": "user ID and wrap it up in an async because remember pure takes a and returns FB so in this case it's going to",
    "start": "3100510",
    "end": "3105940"
  },
  {
    "text": "take a user ID and return an async user ID it's gonna and now we've got a we've got something which fits the form that",
    "start": "3105940",
    "end": "3112119"
  },
  {
    "text": "we need to return from that return from that lambda function so in monads crop",
    "start": "3112119",
    "end": "3119650"
  },
  {
    "start": "3117000",
    "end": "3204000"
  },
  {
    "text": "up all over the place though many implementations don't have exactly the type same type signatures we've looked at or and sometimes they",
    "start": "3119650",
    "end": "3126400"
  },
  {
    "text": "require a bit of squinting to see the Monad the one that everyone has probably used is select many from ienumerable",
    "start": "3126400",
    "end": "3132640"
  },
  {
    "text": "that's basically bind from the list monad if you've used link link syntax with two",
    "start": "3132640",
    "end": "3138369"
  },
  {
    "text": "from clauses that also do sugars into into a select many and observable select",
    "start": "3138369",
    "end": "3143680"
  },
  {
    "text": "many is also effectively bind see Sharps a weight also acts very much like bind",
    "start": "3143680",
    "end": "3149349"
  },
  {
    "text": "from monad with some syntax sugar a bit like let bang and actually F sharp has monads all over the place bind exists",
    "start": "3149349",
    "end": "3156700"
  },
  {
    "text": "for option for choice for list though the list it's called collect and of course we've got async so f-sharp",
    "start": "3156700",
    "end": "3164829"
  },
  {
    "text": "computation expressions give us that nice way of writing in imperative style binds and I think is probably the most",
    "start": "3164829",
    "end": "3171609"
  },
  {
    "text": "common example where you tend to use that that style to give you a nicer syntax and of course you can create your",
    "start": "3171609",
    "end": "3177970"
  },
  {
    "text": "own custom computation expressions we saw before that f-sharp X would give us that choose computation expressions so",
    "start": "3177970",
    "end": "3183670"
  },
  {
    "text": "that we could use choice do that either monads our stuff in JavaScript lodash will give",
    "start": "3183670",
    "end": "3190030"
  },
  {
    "text": "us a flat map function for arrays and that's basically bind from list and Java",
    "start": "3190030",
    "end": "3196120"
  },
  {
    "text": "scripts promises a kind of moan a douche as well if you squint a bit with then being similar to bind so now we're",
    "start": "3196120",
    "end": "3205930"
  },
  {
    "start": "3204000",
    "end": "3600000"
  },
  {
    "text": "basically going to jump into a little example of how we can use parses applicatives and monads all together in",
    "start": "3205930",
    "end": "3213630"
  },
  {
    "text": "to basically pass someone's phone number so if I jump out to this code we'll see",
    "start": "3213630",
    "end": "3223660"
  },
  {
    "text": "how quickly we can nip through this so basically what we're trying to do is",
    "start": "3223660",
    "end": "3228780"
  },
  {
    "text": "pass a string from the command line into this phone number structure so we've got an area code a number and a number type",
    "start": "3228780",
    "end": "3236380"
  },
  {
    "text": "where a number type can be Victorian New South Wales and mobile so we have a",
    "start": "3236380",
    "end": "3241450"
  },
  {
    "text": "function here that can determine the type of given an area code so if we give it an area code string we can do a",
    "start": "3241450",
    "end": "3247390"
  },
  {
    "text": "pattern match if it's oh three it's Victoria if it's owed to its New South Wales and it's oh four it's a mobile if it's if it's something else then I can't",
    "start": "3247390",
    "end": "3253930"
  },
  {
    "text": "be bothered writing the code for it so we'll just say I don't know what that is so we then what we're doing here is",
    "start": "3253930",
    "end": "3261760"
  },
  {
    "text": "we're going to produce passes and this is where if PASOK will give us a whole bunch of functions we can use to build",
    "start": "3261760",
    "end": "3267190"
  },
  {
    "text": "parses so if parsec will give us this map many are so many min/max satisfy and",
    "start": "3267190",
    "end": "3273340"
  },
  {
    "text": "what this is going to do is produce produce a possible concern a minimum of two characters and a maximum of two",
    "start": "3273340",
    "end": "3279970"
  },
  {
    "text": "characters that must be digits and it will be and this thing here produces a",
    "start": "3279970",
    "end": "3285370"
  },
  {
    "text": "positive string where that string would be two digits right that bit there is",
    "start": "3285370",
    "end": "3290380"
  },
  {
    "text": "just adding a bit of debugging help code so it's marking up the posit so if it fails you get back a nice message that",
    "start": "3290380",
    "end": "3296260"
  },
  {
    "text": "says this should have been a two-digit area code now we need to determine the phone number type and if we don't know",
    "start": "3296260",
    "end": "3302650"
  },
  {
    "text": "what the phone number type is we want our parsing to fail so the way we do that is we use bind so we need to get",
    "start": "3302650",
    "end": "3308260"
  },
  {
    "text": "out that string out and have a look at it so we've got a positive string how can we get the string well we can use bind and bind will get give you the a",
    "start": "3308260",
    "end": "3314560"
  },
  {
    "text": "from inside the the positive in this case it'll give us our string which is a area code and we can do a match on that",
    "start": "3314560",
    "end": "3320980"
  },
  {
    "text": "to determine the type if we can determine the type so we get back a sum we can do a peer a turn which is pure",
    "start": "3320980",
    "end": "3327030"
  },
  {
    "text": "and so P return will create us a parser a successfully parse depositor that will",
    "start": "3327030",
    "end": "3333460"
  },
  {
    "text": "contain our area code as a string and our number type put together in a in a in a tuple so you can see the the type",
    "start": "3333460",
    "end": "3340119"
  },
  {
    "text": "up here with Basel is a tuple of string and phone number type now we can't",
    "start": "3340119",
    "end": "3345730"
  },
  {
    "text": "determine the type then we can just produce a failed parser so that's what that does so this expression here is returning a positive so it's taking in",
    "start": "3345730",
    "end": "3351970"
  },
  {
    "text": "our a which is a string and returning a parser of string tabled with phone number type which may either have",
    "start": "3351970",
    "end": "3357640"
  },
  {
    "text": "successfully passed or failed now because we're programming functionally",
    "start": "3357640",
    "end": "3363430"
  },
  {
    "text": "composition is everything so we can use that area code pause and make a version of it which can pause area codes when",
    "start": "3363430",
    "end": "3369970"
  },
  {
    "text": "they've got parentheses around them so P char will make a positive that would pass an open parenthesis here because",
    "start": "3369970",
    "end": "3376780"
  },
  {
    "text": "I've passed it there so we're saying here pause an open parenthesis then pause the area code then pass a closed",
    "start": "3376780",
    "end": "3383950"
  },
  {
    "text": "parenthesis and these different operators here are basically saying this one is saying ignore whatever's on the left so pause it and throw it away and",
    "start": "3383950",
    "end": "3390400"
  },
  {
    "text": "then keep whatever's on the right so that's the area code and this one is saying keep what is whatever's on the",
    "start": "3390400",
    "end": "3395890"
  },
  {
    "text": "left so keep the area code but pause and then toss whatever's on the right which is the the parenthesis we've then got a",
    "start": "3395890",
    "end": "3403090"
  },
  {
    "text": "very simple positive parse the main number so an eight digit phone number and then we've got our main phone number",
    "start": "3403090",
    "end": "3409090"
  },
  {
    "text": "passage so you can see from the type just above the left there it's a positive phone number and what it's",
    "start": "3409090",
    "end": "3414820"
  },
  {
    "text": "going to do is create a couple of sub puzzles so this one the parens area code is going to attempt to pause with",
    "start": "3414820",
    "end": "3421840"
  },
  {
    "text": "parentheses so it'll use our it'll try our first deposit with parentheses and if that doesn't work it's going to fall",
    "start": "3421840",
    "end": "3427180"
  },
  {
    "text": "back to trying without parentheses just the raw area code then we're saying how",
    "start": "3427180",
    "end": "3433240"
  },
  {
    "text": "about a parser that can parse our main number but after the main number we expect the end of strings so that prevents us from having any crap after",
    "start": "3433240",
    "end": "3439630"
  },
  {
    "text": "the main number we just we expect that the there'd be nothing after that at all and then we've got a function called",
    "start": "3439630",
    "end": "3447070"
  },
  {
    "text": "make phone number that's going to allows it allow us to compose together our parses so we've got a positive which",
    "start": "3447070",
    "end": "3452500"
  },
  {
    "text": "uses that tupled area code num type so we've got a parameter that takes that tuple here and a parameter which will",
    "start": "3452500",
    "end": "3458410"
  },
  {
    "text": "take our main number and we construct that record type we saw up the top containing all of those pieces then we",
    "start": "3458410",
    "end": "3464890"
  },
  {
    "text": "can compose all that together so we've got our make phone number function from here composed with map and apply with",
    "start": "3464890",
    "end": "3472060"
  },
  {
    "text": "our parens area code Pazza here and our main number Pazza from here into one",
    "start": "3472060",
    "end": "3477070"
  },
  {
    "text": "thing which is our parser or phone number so that's where we're using our applicative and functor patterns so once",
    "start": "3477070",
    "end": "3483820"
  },
  {
    "text": "we've got that Pazza we can basically run it passing in a string and it will give us back a positive positive result",
    "start": "3483820",
    "end": "3489610"
  },
  {
    "text": "and if I jump to the entry point of this application you can see we use that Paz for a number function here where we just",
    "start": "3489610",
    "end": "3495220"
  },
  {
    "text": "grab the first argument from the command line and push it through that Pazza and then just print it out so if I run this",
    "start": "3495220",
    "end": "3500710"
  },
  {
    "text": "guy if I switch this sample then here",
    "start": "3500710",
    "end": "3510880"
  },
  {
    "text": "we've got sick example XE and to this we",
    "start": "3510880",
    "end": "3517330"
  },
  {
    "text": "can pass a phone number and that will",
    "start": "3517330",
    "end": "3522520"
  },
  {
    "text": "pause as a mobile number so we can see we've got our area code a number and our number type we can put parentheses",
    "start": "3522520",
    "end": "3528820"
  },
  {
    "text": "around this so it's PowerShell so have to put quotes if I use parentheses and it still works but of course if we",
    "start": "3528820",
    "end": "3535810"
  },
  {
    "text": "mangle it we get rid of one of those parentheses it's going to fail if we put letters in there it's also going to fail",
    "start": "3535810",
    "end": "3543510"
  },
  {
    "text": "if we make it too long that's where our end of input is going to prevent it from working and it's going to fail so you",
    "start": "3543510",
    "end": "3550570"
  },
  {
    "text": "can see how we've used the same patterns that we've looked at before but this time they also apply to pauses so we can use bind from monads and map and apply",
    "start": "3550570",
    "end": "3557350"
  },
  {
    "text": "from functor and applicative to compose together our pauses and a nice in a nice readable way",
    "start": "3557350",
    "end": "3563670"
  },
  {
    "text": "all right so in summary patterns capture proven ways of structuring software they",
    "start": "3570189",
    "end": "3576529"
  },
  {
    "text": "help us communicate our codes intention through well-known patterns that help us encapsulate and in kept and abstract",
    "start": "3576529",
    "end": "3583549"
  },
  {
    "text": "functionalities in in ways that make it more digestible to for us in today's talk we've looked at three major",
    "start": "3583549",
    "end": "3589849"
  },
  {
    "text": "functional programming patterns the first was the functor which enables us to transform values in a structure",
    "start": "3589849",
    "end": "3595519"
  },
  {
    "text": "without changing that structure functors have that map function which we've all probably used in its guise as the eye",
    "start": "3595519",
    "end": "3600559"
  },
  {
    "text": "numerable select function the second pattern we looked at was the applicatives which enables us to",
    "start": "3600559",
    "end": "3607099"
  },
  {
    "text": "transform both values and structures together we saw that applicatives have that pure function that enables us to",
    "start": "3607099",
    "end": "3612380"
  },
  {
    "text": "take a value and wrap it up in a structure and an apply function that conceptually invokes a function inside a",
    "start": "3612380",
    "end": "3618349"
  },
  {
    "text": "structure we saw how applicatives allowed us to enable allow us to",
    "start": "3618349",
    "end": "3624079"
  },
  {
    "text": "basically eliminate a whole bunch of noisy boilerplate code from our validation example and allowed us to",
    "start": "3624079",
    "end": "3629209"
  },
  {
    "text": "express the essence of those validation rules in a nice readable way finally we",
    "start": "3629209",
    "end": "3634849"
  },
  {
    "text": "looked at the monad and we saw how it was simply an extension of functors and applicatives with a bit more power since the function",
    "start": "3634849",
    "end": "3640759"
  },
  {
    "text": "pass turbine is able to return a new structure which bind combines with the old structures we saw how this very",
    "start": "3640759",
    "end": "3647599"
  },
  {
    "text": "abstract pattern could fulfill many roles from unfolding lists with select many to doing failure handling with",
    "start": "3647599",
    "end": "3655159"
  },
  {
    "text": "maybes and eaters to doing asynchronous execution with c-sharp tasks and F",
    "start": "3655159",
    "end": "3660349"
  },
  {
    "text": "sharps async so hopefully now you've got at least some understanding of these three patterns and can identify where",
    "start": "3660349",
    "end": "3666439"
  },
  {
    "text": "you might have used them before out in the wild with your new understanding I hope you go off and explore more about",
    "start": "3666439",
    "end": "3671749"
  },
  {
    "text": "these things because once you become familiar with them you'll see that there are many ways you can use them to improve your functional programming code",
    "start": "3671749",
    "end": "3677839"
  },
  {
    "text": "and eliminate boilerplate replacing it with expressive readable code that more",
    "start": "3677839",
    "end": "3683150"
  },
  {
    "text": "clearly expresses your intention if you'd like to learn more about what",
    "start": "3683150",
    "end": "3688489"
  },
  {
    "text": "you've seen here today I'm totally gonna hand boyyou to Scott lation who's got his functional design",
    "start": "3688489",
    "end": "3693589"
  },
  {
    "text": "patterns talk at 1:40 p.m. so I think that's straight after lunch Scott is a really good speaker so I",
    "start": "3693589",
    "end": "3699049"
  },
  {
    "text": "highly recommend you go to talk squad also has a website called f-sharp for fun and profit which you may",
    "start": "3699049",
    "end": "3704370"
  },
  {
    "text": "have been to before and he's got an article up there called map bind and a play it's a series of articles and so if",
    "start": "3704370",
    "end": "3711570"
  },
  {
    "text": "you want to learn more about what you've seen here today and you probably you know probably need some time to stare at those types and",
    "start": "3711570",
    "end": "3717180"
  },
  {
    "text": "let it sort of settle that's a good way to do it if you need a more visual way",
    "start": "3717180",
    "end": "3722340"
  },
  {
    "text": "of seeing how the either monad works his railway oriented programming talk with as a video up on his site that's really",
    "start": "3722340",
    "end": "3728580"
  },
  {
    "text": "good in fact while you're honest like you mail or just read everything because it's pretty good stuff and if you're",
    "start": "3728580",
    "end": "3734760"
  },
  {
    "text": "looking for a textbook to help learn I recommend the Haskell programming from first principles textbook I will warn",
    "start": "3734760",
    "end": "3740940"
  },
  {
    "text": "you it's very slow and methodical it starts from the basics but because it's slow and methodical it doesn't have like",
    "start": "3740940",
    "end": "3747300"
  },
  {
    "text": "a ridiculous learning curve we just get lost it holds you by the hand the whole way and by the end of the journey you will",
    "start": "3747300",
    "end": "3753900"
  },
  {
    "text": "be a god among functional programmers and monads will just be like some cereal you eat for breakfast in this just like",
    "start": "3753900",
    "end": "3759810"
  },
  {
    "text": "second nature so thanks for listening today I hope I haven't melted too many",
    "start": "3759810",
    "end": "3767220"
  },
  {
    "text": "brains in the room so if you have any questions I think we've do we have any time we're",
    "start": "3767220",
    "end": "3774030"
  },
  {
    "text": "just a little over so I'll let you run off to lunch and if anyone wants to ask a question come and check to me afterwards all to stick around for a bit",
    "start": "3774030",
    "end": "3780000"
  },
  {
    "text": "thanks guys [Applause]",
    "start": "3780000",
    "end": "3787339"
  }
]