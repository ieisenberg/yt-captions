[
  {
    "start": "0",
    "end": "70000"
  },
  {
    "text": "good my name is Nikolai Azotus I am",
    "start": "4279",
    "end": "9680"
  },
  {
    "text": "trying to enable the pointer so I'm",
    "start": "9680",
    "end": "14790"
  },
  {
    "text": "involved in the Cephas pasteurization for 20-25 years written some books from the beginning and in the beginning I",
    "start": "14790",
    "end": "23610"
  },
  {
    "text": "kept mostly for the library now I care for everything the problem is they",
    "start": "23610",
    "end": "29489"
  },
  {
    "text": "screwed up the language that much theater I have to deal with that so because I had problems using it in the",
    "start": "29489",
    "end": "36179"
  },
  {
    "text": "library no just kidding oh this is recorded too bad good now we",
    "start": "36179",
    "end": "42870"
  },
  {
    "text": "do a good job we are 200 people now standardized in C++ please note this is not chief",
    "start": "42870",
    "end": "49710"
  },
  {
    "text": "architect behind we have 200 programmers with different ideas different interests",
    "start": "49710",
    "end": "55589"
  },
  {
    "text": "different experience and we do the best we can and if you want to complain about",
    "start": "55589",
    "end": "60690"
  },
  {
    "text": "the C++ standard I will always say it's your fault because you haven't been",
    "start": "60690",
    "end": "66600"
  },
  {
    "text": "there so come there and help us to make it even better that's it umm that's not",
    "start": "66600",
    "end": "73080"
  },
  {
    "start": "70000",
    "end": "339000"
  },
  {
    "text": "the end of the talk that begin the end of the beginning of the talk it doesn't",
    "start": "73080",
    "end": "81090"
  },
  {
    "text": "work that way I have to put up my jacket smart pointers No yeah let's talk about",
    "start": "81090",
    "end": "89580"
  },
  {
    "text": "smart pointers why do we have smart pointers well because we're all pointers",
    "start": "89580",
    "end": "94710"
  },
  {
    "text": "suck we have a lot of big problems with that one of the biggest problems we have",
    "start": "94710",
    "end": "100500"
  },
  {
    "text": "is polymorphism in C++ although i yesterday introduced that we have a new",
    "start": "100500",
    "end": "107670"
  },
  {
    "text": "option called variant where we can avoid using pointers when we want to have",
    "start": "107670",
    "end": "113790"
  },
  {
    "text": "polymorphism and heterogeneous collections we still need it in various",
    "start": "113790",
    "end": "119820"
  },
  {
    "text": "ways so let's look at the motivational example for smart pointers here I assume",
    "start": "119820",
    "end": "126720"
  },
  {
    "text": "we have a hierarchy for polymorphism so base class geometric objects and then",
    "start": "126720",
    "end": "131730"
  },
  {
    "text": "circle and line as a concrete class derived from that and the pointers",
    "start": "131730",
    "end": "138230"
  },
  {
    "text": "you only have polymorphism in collections if you use references or",
    "start": "138230",
    "end": "143580"
  },
  {
    "text": "pointers references are not allowed so we have to use pointers in for example a",
    "start": "143580",
    "end": "149640"
  },
  {
    "text": "vector and when we initialize a vector of elements that looks like the",
    "start": "149640",
    "end": "156390"
  },
  {
    "text": "following let's create the vector of the elements the elements are pointer as I",
    "start": "156390",
    "end": "162090"
  },
  {
    "text": "said let's create the elements don't create them on the stack because if you",
    "start": "162090",
    "end": "167280"
  },
  {
    "text": "create them on the stack and at the address of this element in the vector the abject we refer to is gone when we",
    "start": "167280",
    "end": "174540"
  },
  {
    "text": "return the vector so we have to create it on the heap here a line and circle we",
    "start": "174540",
    "end": "182430"
  },
  {
    "text": "push them back into the vector and we return the whole thing to the caller and",
    "start": "182430",
    "end": "188970"
  },
  {
    "text": "the column might initialize an object and see here that all local objects are gone but fortunately we created the",
    "start": "188970",
    "end": "195930"
  },
  {
    "text": "objects are in the heap so we still have them and we can use them and perform our",
    "start": "195930",
    "end": "204270"
  },
  {
    "text": "polymorphic code for example here called draw and at runtime there is a decision",
    "start": "204270",
    "end": "210360"
  },
  {
    "text": "which draw function to call depending on whether we can t have a circle or line",
    "start": "210360",
    "end": "215910"
  },
  {
    "text": "here okay so far so good so the only problem we have left is",
    "start": "215910",
    "end": "221370"
  },
  {
    "text": "let's remove the element and there's important thing here it's not enough to",
    "start": "221370",
    "end": "227970"
  },
  {
    "text": "just to call clear if you call clear you have a memory leak you have to make sure",
    "start": "227970",
    "end": "233070"
  },
  {
    "text": "that before we remove the element with the only raw pointers we have called",
    "start": "233070",
    "end": "240540"
  },
  {
    "text": "delete for the corresponding new call here you see one example to do it just start a loop over all the elements with",
    "start": "240540",
    "end": "248100"
  },
  {
    "text": "our pointers we might not only call the lead we might also want to ensure that",
    "start": "248100",
    "end": "254310"
  },
  {
    "text": "all the elements are now point us now so we iterate by reference over pointers so",
    "start": "254310",
    "end": "261780"
  },
  {
    "text": "that we can call delete and then assign to the pointers the null pointer so things like that happen if you use",
    "start": "261780",
    "end": "268650"
  },
  {
    "text": "polymorphism with Rob - so how can we do better there's one",
    "start": "268650",
    "end": "274450"
  },
  {
    "text": "principle in C++ which is very important our AI I resource acquisition is",
    "start": "274450",
    "end": "280120"
  },
  {
    "text": "initialization which means put something you have to clean up in an object so",
    "start": "280120",
    "end": "286450"
  },
  {
    "text": "that a destructor can call the corresponding cleanup when it goes out",
    "start": "286450",
    "end": "291880"
  },
  {
    "text": "of scope so what we need here is something like a smart pointer that says whenever this pointer goes out of scope",
    "start": "291880",
    "end": "299160"
  },
  {
    "text": "let's then automatically call delete and that's roughly the idea of smart",
    "start": "299160",
    "end": "304810"
  },
  {
    "text": "pointers that we have a way to say well instead of us calling delete which might",
    "start": "304810",
    "end": "311950"
  },
  {
    "text": "create some trouble we might call it too late or too early so let's decide the pointers what to do",
    "start": "311950",
    "end": "321580"
  },
  {
    "text": "and one thing we provided even before C++ 11 well shared pointers",
    "start": "321580",
    "end": "328030"
  },
  {
    "text": "well you could do that and yet pointers also had another benefit you could still",
    "start": "328030",
    "end": "334210"
  },
  {
    "text": "have different owners different pointers referring to the same object so by using",
    "start": "334210",
    "end": "340660"
  },
  {
    "text": "smart pointers we implement a way that the compiler doesn't work for us and we",
    "start": "340660",
    "end": "347620"
  },
  {
    "text": "make less mistakes so we have two concepts of set of smart pointers in C++",
    "start": "347620",
    "end": "354310"
  },
  {
    "text": "since C++ 11 we are a third one called Auto pointer please don't use it we come to there later and share pointers and",
    "start": "354310",
    "end": "361630"
  },
  {
    "text": "unique pointers that I both introduced with C++ 11 let's look at them so the first example is let's use a shared",
    "start": "361630",
    "end": "368080"
  },
  {
    "text": "pointer here and a shared pointer we",
    "start": "368080",
    "end": "373150"
  },
  {
    "text": "introduced a type here for that just the type definition clear pointer is a share point of geometric object so this is a",
    "start": "373150",
    "end": "379810"
  },
  {
    "text": "smart pointer now and the smart pointer changes the behavior a little bit first",
    "start": "379810",
    "end": "385540"
  },
  {
    "text": "of all the usual way to create it is use make share and what happens here is we",
    "start": "385540",
    "end": "391090"
  },
  {
    "text": "create the vector and then when we call make shared two things happen we create",
    "start": "391090",
    "end": "397900"
  },
  {
    "text": "an object on the heap and we create a counter",
    "start": "397900",
    "end": "403090"
  },
  {
    "text": "the counter might be bound to the object or might be not make sure it usually",
    "start": "403090",
    "end": "408430"
  },
  {
    "text": "bounce them together which is a little bit misleading in this picture here because they look like two different objects we come to that later but the",
    "start": "408430",
    "end": "415990"
  },
  {
    "text": "key thing is beside creating an object on the heap we create a counter somewhere somewhere available over the",
    "start": "415990",
    "end": "424000"
  },
  {
    "text": "lifetime of this returned pointer share pointer so it also has to be created on",
    "start": "424000",
    "end": "430720"
  },
  {
    "text": "the heap so the two things there the counter and the objects are on the reheat the rest is on the stack I should",
    "start": "430720",
    "end": "437980"
  },
  {
    "text": "use different colors here to make that clear and then let's call another make",
    "start": "437980",
    "end": "444160"
  },
  {
    "text": "share call which does the same thing for a circle and now the trick is that this pointer is Matt and that means that it",
    "start": "444160",
    "end": "452410"
  },
  {
    "text": "finds out how many owners we have and when the last owner dies the object the",
    "start": "452410",
    "end": "458350"
  },
  {
    "text": "delete for the object will automatically be called so we pass both shared",
    "start": "458350",
    "end": "464830"
  },
  {
    "text": "pointers into the vector and you see that this increases the owner count so",
    "start": "464830",
    "end": "471190"
  },
  {
    "text": "we now we share from two different positions we refer we point to this",
    "start": "471190",
    "end": "476710"
  },
  {
    "text": "object and when we then return it we might even temporarily create a third",
    "start": "476710",
    "end": "484200"
  },
  {
    "text": "pointer that temporarily also refers to the object but this might be the return",
    "start": "484200",
    "end": "490600"
  },
  {
    "text": "vector if you create a new one and copy all the elements but on the other hand we leave the function and that means",
    "start": "490600",
    "end": "497890"
  },
  {
    "text": "that we remove all the local objects on the stack which is both the LP and CP",
    "start": "497890",
    "end": "504190"
  },
  {
    "text": "shared pointer single objects and the local vector of pointers here this might",
    "start": "504190",
    "end": "509770"
  },
  {
    "text": "be optimized yes I know but the point is yeah we have a counter we know always",
    "start": "509770",
    "end": "515950"
  },
  {
    "text": "know how many owners we have and here for example Crowley we only have one",
    "start": "515950",
    "end": "521560"
  },
  {
    "text": "owner for each object we have so we can use it as an ordinary pointer so if we",
    "start": "521560",
    "end": "528040"
  },
  {
    "text": "iterate over all the elements you can still iterate the datatype is cons to",
    "start": "528040",
    "end": "533470"
  },
  {
    "text": "the pointer but you can still use Auto here Auto and even Nazi that you use a",
    "start": "533470",
    "end": "539269"
  },
  {
    "text": "slightly different type here and we have polymorphic cards because the error",
    "start": "539269",
    "end": "544459"
  },
  {
    "text": "operator in smart pointer has overloaded that we over a row pointer internally",
    "start": "544459",
    "end": "551180"
  },
  {
    "text": "use call the right draw and decide at runtime which draw to call that's it and",
    "start": "551180",
    "end": "557329"
  },
  {
    "text": "the good thing is at the end we clear all the elements and the vector and now",
    "start": "557329",
    "end": "562579"
  },
  {
    "text": "the magic happens as you just saw it clear just removes the elements so we",
    "start": "562579",
    "end": "567709"
  },
  {
    "text": "call the destructive hunter which is the last owner of the element so as we are",
    "start": "567709",
    "end": "574130"
  },
  {
    "text": "the last owner the moment we decrement the own account to zero we automatically",
    "start": "574130",
    "end": "579649"
  },
  {
    "text": "called in it and we have no memory leak we need it at the moment we no longer",
    "start": "579649",
    "end": "584990"
  },
  {
    "text": "need it that's to some extent just an implementation of reference counting in",
    "start": "584990",
    "end": "590170"
  },
  {
    "text": "a data type good so far by the way look",
    "start": "590170",
    "end": "595310"
  },
  {
    "text": "at that we use make shared here make sure it has its drawbacks there is a",
    "start": "595310",
    "end": "600740"
  },
  {
    "text": "rumor in the community that makes share it is always good that's not true",
    "start": "600740",
    "end": "606769"
  },
  {
    "text": "we will come also to that so instead of using make sure you might do two steps",
    "start": "606769",
    "end": "612620"
  },
  {
    "text": "you might first call a new and the end for the objects and then pass the return",
    "start": "612620",
    "end": "618949"
  },
  {
    "text": "draw a pointer to a sharepoint ax and we will see why this is sometimes better",
    "start": "618949",
    "end": "624260"
  },
  {
    "text": "than using make shirt what is the alternative the alternative is using a",
    "start": "624260",
    "end": "631940"
  },
  {
    "start": "627000",
    "end": "747000"
  },
  {
    "text": "unique pointer and maybe we go to this",
    "start": "631940",
    "end": "636980"
  },
  {
    "text": "alternative later i already change the order of my slides it happens from time to time so let's look first now into",
    "start": "636980",
    "end": "646639"
  },
  {
    "text": "details of shared pointers so what's",
    "start": "646639",
    "end": "651709"
  },
  {
    "text": "your point us as i said you can call new to create an object so if you have a set",
    "start": "651709",
    "end": "658819"
  },
  {
    "text": "pointer and later on create new call new you have this object created and return",
    "start": "658819",
    "end": "663889"
  },
  {
    "text": "a raw point and then you pass the ownership of this from this raw pointer to a sharepoint and that cree",
    "start": "663889",
    "end": "670320"
  },
  {
    "text": "this control block and the control block is created on the heap and each",
    "start": "670320",
    "end": "675570"
  },
  {
    "text": "operation you call is an indirect access to the underlying object so far so good",
    "start": "675570",
    "end": "682200"
  },
  {
    "text": "so if we assign this object to another shared pointer like here the other share",
    "start": "682200",
    "end": "688800"
  },
  {
    "text": "pointer can also access the element and the owner counter goes to two if we",
    "start": "688800",
    "end": "694620"
  },
  {
    "text": "leave the scope the inner scope we only have left the outer scope pointer and if",
    "start": "694620",
    "end": "700680"
  },
  {
    "text": "we leave that we delete the pointer so far so good that's a basic principle of",
    "start": "700680",
    "end": "705720"
  },
  {
    "text": "a shared pointer there are some good things like you can define your own delete us so that means that you not",
    "start": "705720",
    "end": "712860"
  },
  {
    "text": "only can use it for resources created with new you can also use that for resources created for example with an F",
    "start": "712860",
    "end": "720720"
  },
  {
    "text": "or P open call where we return another kind of pointer where we need some",
    "start": "720720",
    "end": "726270"
  },
  {
    "text": "cleanup at deletion time so here for example on the top we call P open to",
    "start": "726270",
    "end": "733440"
  },
  {
    "text": "open the pipe and then we can specify ideally as a lambda or as an example in",
    "start": "733440",
    "end": "740850"
  },
  {
    "text": "a lambda that we call pre close to clean up the resource there's one concept here",
    "start": "740850",
    "end": "751350"
  },
  {
    "start": "747000",
    "end": "1114000"
  },
  {
    "text": "called weak pointers so beside off her pointers we have another brother or",
    "start": "751350",
    "end": "757380"
  },
  {
    "text": "sister of shared pointers which is a weak pointer a part of the concept of share pointers it is an observer that",
    "start": "757380",
    "end": "766110"
  },
  {
    "text": "does not count as an owner and so it uses the principle of shared owner and",
    "start": "766110",
    "end": "772530"
  },
  {
    "text": "of smart pointers but if you use it it does not count as an owner so an object",
    "start": "772530",
    "end": "780600"
  },
  {
    "text": "will die if the last shared pointed eyes even if weak pointers still referred to them but the good thing is you can find",
    "start": "780600",
    "end": "787230"
  },
  {
    "text": "out when the weak pointer daggits so you can ask the weak pointer is there still in an object so far why do you use that",
    "start": "787230",
    "end": "795360"
  },
  {
    "text": "first of all to resolve cyclic references cyclic pointers because",
    "start": "795360",
    "end": "800430"
  },
  {
    "text": "otherwise you would never clean up a combination of multiple objects",
    "start": "800430",
    "end": "805660"
  },
  {
    "text": "because there's always one owner like here resource a points to resource B and resource B parts to resource a and we",
    "start": "805660",
    "end": "813970"
  },
  {
    "text": "only have a set point outside point into resource a so somebody needs resource a",
    "start": "813970",
    "end": "819160"
  },
  {
    "text": "and resource a needs resource B but they have a back pointer which is a very common case here we also use an observer",
    "start": "819160",
    "end": "827290"
  },
  {
    "text": "to observe is there still a resource a so the moment we delete here the shared pointer we have deleted the last owner",
    "start": "827290",
    "end": "834489"
  },
  {
    "text": "of resource a because the back pointer from resource B is not a shared pointer does not count as an owner it's a weak",
    "start": "834489",
    "end": "840879"
  },
  {
    "text": "pointer so that means we delete resource a or indirectly so automatically the",
    "start": "840879",
    "end": "847179"
  },
  {
    "text": "destructor will D call delete for the resource a and that will delete the last",
    "start": "847179",
    "end": "852970"
  },
  {
    "text": "owner is of resource B so that will be leader and that's the effect of deleting",
    "start": "852970",
    "end": "859629"
  },
  {
    "text": "the shared pointer on the left side there's still the weak pointer and you can ask the weak pointer is there still",
    "start": "859629",
    "end": "866079"
  },
  {
    "text": "something available or not this is important that we have the concept of weak pointer there's a reason you have",
    "start": "866079",
    "end": "873069"
  },
  {
    "text": "to take that into account as you will see in a moment let's see how to use a",
    "start": "873069",
    "end": "881769"
  },
  {
    "text": "weak pointer a weak pointer looks like it is also share pointer so you might assume to use it we need a pointer API",
    "start": "881769",
    "end": "889689"
  },
  {
    "text": "but that's not true it does not use a pointer API so here if we create",
    "start": "889689",
    "end": "898059"
  },
  {
    "text": "something and have a SharePoint as an owner and then we have a weak pointer as an observer you can't directly use the",
    "start": "898059",
    "end": "904660"
  },
  {
    "text": "arrow operator to access the object you're pointing to you have first to",
    "start": "904660",
    "end": "911139"
  },
  {
    "text": "lock the object and the lock will give you a shared pointer back why that",
    "start": "911139",
    "end": "917199"
  },
  {
    "text": "because of multi-threading because if we why we are from an observer dealing with",
    "start": "917199",
    "end": "925569"
  },
  {
    "text": "the resource are and then the last shared pointer dies why we are using it",
    "start": "925569",
    "end": "930939"
  },
  {
    "text": "we are in big trouble so the trick is that lock creates a new SharePoint at",
    "start": "930939",
    "end": "936520"
  },
  {
    "text": "early or not temporarily and that means even if SP now dies and we still have an",
    "start": "936520",
    "end": "943420"
  },
  {
    "text": "owner which is P as long as we have P we can use it and that safe code even in",
    "start": "943420",
    "end": "949480"
  },
  {
    "text": "multi-threading environments so now with P we can call a member function and you",
    "start": "949480",
    "end": "956470"
  },
  {
    "text": "can do that also in one step creating a shared pointer from a weak pointer but here you get an exception if the weak",
    "start": "956470",
    "end": "964990"
  },
  {
    "text": "pointer refers to some object that is already gone please don't program it that way there's",
    "start": "964990",
    "end": "972130"
  },
  {
    "text": "also a member function is there still a shared pointer is there still an object and because the answer might be old if",
    "start": "972130",
    "end": "980470"
  },
  {
    "text": "you use it so if the answer is true then you call lock-on comment without",
    "start": "980470",
    "end": "987490"
  },
  {
    "text": "checking the return value of LOC you are using a null pointer here this is not",
    "start": "987490",
    "end": "994060"
  },
  {
    "text": "thread safe because between the core of expired and lock that somebody might",
    "start": "994060",
    "end": "999400"
  },
  {
    "text": "have deleted the last owner of the object so do it the other way around",
    "start": "999400",
    "end": "1005030"
  },
  {
    "text": "good this weak pointer has consequences for the concept and implementation of",
    "start": "1005030",
    "end": "1011340"
  },
  {
    "text": "shared pointers so let's look at this example we have outside a weak pointer we have outside the share pointer and",
    "start": "1011340",
    "end": "1018420"
  },
  {
    "text": "then we have a shared pointer which we directly initialize with the return value of a call of mu and the point is",
    "start": "1018420",
    "end": "1028260"
  },
  {
    "text": "we have in fact two counters now because of weak point us in the control block in",
    "start": "1028260",
    "end": "1034620"
  },
  {
    "text": "the control block we have to count how many owners we have and we have to count how many weak pointers we have and the",
    "start": "1034620",
    "end": "1041160"
  },
  {
    "text": "reason is pretty clear at the moment we use this example we have one owner so",
    "start": "1041160",
    "end": "1046860"
  },
  {
    "text": "let's assign this to another owner so we have two owners now and now let's assign",
    "start": "1046860",
    "end": "1051930"
  },
  {
    "text": "this tool to an observer to a weak pointer so far so good so why do we have different contests because if we delete",
    "start": "1051930",
    "end": "1059220"
  },
  {
    "text": "if the first owner nothing happens just we decrement the own account but if we",
    "start": "1059220",
    "end": "1065010"
  },
  {
    "text": "delete the last owner we can deal the resource but I can't delete the",
    "start": "1065010",
    "end": "1070279"
  },
  {
    "text": "control block because the control block contains the information the weak pointer has to give us to explain is",
    "start": "1070279",
    "end": "1076700"
  },
  {
    "text": "there still an object or not otherwise we have no memory to hold this information so that means we still have",
    "start": "1076700",
    "end": "1086779"
  },
  {
    "text": "to keep the control box alive and now the weak pointer can tell us no there is",
    "start": "1086779",
    "end": "1093590"
  },
  {
    "text": "no longer a resource so if we try loc try to call lock it will again self give if as an ID pointer as a shed pointer on",
    "start": "1093590",
    "end": "1101299"
  },
  {
    "text": "non initialized yet pointer so only if the last weak pointer dies the object of",
    "start": "1101299",
    "end": "1109399"
  },
  {
    "text": "the control block is gone ok so we have two pointers fine so now we come to make",
    "start": "1109399",
    "end": "1116899"
  },
  {
    "start": "1114000",
    "end": "1316000"
  },
  {
    "text": "sure so in the internet and maybe also in the community you always learn that's",
    "start": "1116899",
    "end": "1122929"
  },
  {
    "text": "always use make sure it's always better that's a lie that's not correct because",
    "start": "1122929",
    "end": "1132370"
  },
  {
    "text": "look at the same example I just went through by using SharePoint",
    "start": "1132370",
    "end": "1140230"
  },
  {
    "text": "excuse me make share so the point is the trick of make share this and that's one",
    "start": "1140230",
    "end": "1146570"
  },
  {
    "text": "benefit of it it calls not new twice because we call new for the results and",
    "start": "1146570",
    "end": "1153860"
  },
  {
    "text": "we call new for the counter it calls new only once so it creates something like",
    "start": "1153860",
    "end": "1160220"
  },
  {
    "text": "this it elekid's memory for both the control block and the resource so we",
    "start": "1160220",
    "end": "1167090"
  },
  {
    "text": "save in the control plug a pointer and we save a call of new so that's a good",
    "start": "1167090",
    "end": "1173360"
  },
  {
    "text": "thing that that is faster and therefore usually better so however we have",
    "start": "1173360",
    "end": "1180830"
  },
  {
    "text": "introduced a problem now if we now copy",
    "start": "1180830",
    "end": "1186799"
  },
  {
    "text": "the shared pointer to another set pointer and introduce an observer to this resource okay everything is fine",
    "start": "1186799",
    "end": "1194710"
  },
  {
    "text": "but now let's delete the first owner so by leaving the scope here the inner",
    "start": "1194710",
    "end": "1200720"
  },
  {
    "text": "scope and now let's leave the middle scope where the last owner is valid so now we",
    "start": "1200720",
    "end": "1209270"
  },
  {
    "text": "have an interesting situation we can delete the resource but we have to keep",
    "start": "1209270",
    "end": "1214640"
  },
  {
    "text": "the control Vogel life because there is the information for the weak part to give us an answer for does this object",
    "start": "1214640",
    "end": "1222170"
  },
  {
    "text": "still exist or not so we have to keep this control book alive but the lifetime",
    "start": "1222170",
    "end": "1228080"
  },
  {
    "text": "of the control block is bound to the memory of the resource because we only have a located in one memory one piece",
    "start": "1228080",
    "end": "1234740"
  },
  {
    "text": "of memory so that means we can't delete the memory we can call the destructor",
    "start": "1234740",
    "end": "1241250"
  },
  {
    "text": "and we do it but we can't delete the memory or free the memory of the whole",
    "start": "1241250",
    "end": "1246740"
  },
  {
    "text": "thing which means if you use meg shared and you're using weak pointers and your",
    "start": "1246740",
    "end": "1253669"
  },
  {
    "text": "resources allocate a huge amount of memory you have an interesting logical",
    "start": "1253669",
    "end": "1259070"
  },
  {
    "text": "resource leak by not deleting or destroying all your weak pointers if you",
    "start": "1259070",
    "end": "1264740"
  },
  {
    "text": "just keep the weak pointers alive the memory of your resources will never be freed and I've seen that and at least",
    "start": "1264740",
    "end": "1271940"
  },
  {
    "text": "one project where we thought we have a memory leak but it was just a logical error that we never destroyed the weak",
    "start": "1271940",
    "end": "1278540"
  },
  {
    "text": "pointer still observing the object so beware of that if you have that",
    "start": "1278540",
    "end": "1283700"
  },
  {
    "text": "situation don't use make shared do it in two steps call new and then assign the",
    "start": "1283700",
    "end": "1292100"
  },
  {
    "text": "ownership to a shared pointer so that over a long period of time when the",
    "start": "1292100",
    "end": "1297500"
  },
  {
    "text": "object was destroyed the last owner was destroyed you can still use a weak",
    "start": "1297500",
    "end": "1302990"
  },
  {
    "text": "pointer and you give up the memory ok good so only if we then destroy the last",
    "start": "1302990",
    "end": "1311299"
  },
  {
    "text": "weak point us then we will free the whole memory so that's the first thing",
    "start": "1311299",
    "end": "1317260"
  },
  {
    "start": "1316000",
    "end": "1517000"
  },
  {
    "text": "let's talk about a few other things I'm one of my things is well we came from an",
    "start": "1317260",
    "end": "1323000"
  },
  {
    "text": "example motivating about polymorphism so we had an example where we have two",
    "start": "1323000",
    "end": "1329030"
  },
  {
    "text": "objects circle and nine so interesting question is",
    "start": "1329030",
    "end": "1335270"
  },
  {
    "text": "first of all can we use smart pointers",
    "start": "1335270",
    "end": "1342200"
  },
  {
    "text": "like ordinary pointers and as one thing you might know that which you see is a",
    "start": "1342200",
    "end": "1347630"
  },
  {
    "text": "relationship we can say a circle isn't geometric object align is a geometric",
    "start": "1347630",
    "end": "1353360"
  },
  {
    "text": "object so we can use them as that one there's an important rule when you use",
    "start": "1353360",
    "end": "1360920"
  },
  {
    "text": "inheritance which is is air relations",
    "start": "1360920",
    "end": "1366580"
  },
  {
    "text": "inheritance relationships don't propagate to collections of the types so",
    "start": "1366580",
    "end": "1373400"
  },
  {
    "text": "if you have a base class like geometric object and you can say a circle is a",
    "start": "1373400",
    "end": "1379490"
  },
  {
    "text": "geometric object it does not mean that the collection of circles is a",
    "start": "1379490",
    "end": "1386150"
  },
  {
    "text": "collection of geometric objects because a key API of the is air relationship a",
    "start": "1386150",
    "end": "1396590"
  },
  {
    "text": "key feature of it is a relationship is that you can do everything with the",
    "start": "1396590",
    "end": "1402290"
  },
  {
    "text": "derived class you can do with the base class so if you have a collection of geometric objects what can you insert a",
    "start": "1402290",
    "end": "1410440"
  },
  {
    "text": "circle and a line if you have a collection of circles it would not be",
    "start": "1410440",
    "end": "1417740"
  },
  {
    "text": "very well if we could insert a line so that's the usual logical rule we have",
    "start": "1417740",
    "end": "1424550"
  },
  {
    "text": "and that applies to inheritance and the is a relationship in general and thanks",
    "start": "1424550",
    "end": "1429950"
  },
  {
    "text": "goodness we have implemented that in C++ you can see that so if you create a",
    "start": "1429950",
    "end": "1435740"
  },
  {
    "text": "vector of geometric objects if you use a",
    "start": "1435740",
    "end": "1440750"
  },
  {
    "text": "base term so a geometric object pointer you can push back a circle pointer and",
    "start": "1440750",
    "end": "1446960"
  },
  {
    "text": "the line pointer that's fine but if you create a vector of circle pointers you cannot push back a line",
    "start": "1446960",
    "end": "1455090"
  },
  {
    "text": "pointer and that is implemented in the logic of templates the way the standard",
    "start": "1455090",
    "end": "1462860"
  },
  {
    "text": "there the the the language can do that as I say if there is",
    "start": "1462860",
    "end": "1469010"
  },
  {
    "text": "and is a relationship between types this relationship does not propagate if I",
    "start": "1469010",
    "end": "1476270"
  },
  {
    "text": "pass these types as a template parameter that's the way we realize this rule and",
    "start": "1476270",
    "end": "1483250"
  },
  {
    "text": "that applies to everything that even applies that we if we use a collection",
    "start": "1483250",
    "end": "1490370"
  },
  {
    "text": "or just any template if we use any template that there is no relationship",
    "start": "1490370",
    "end": "1497300"
  },
  {
    "text": "anymore between types like being inheriting or saying this is the",
    "start": "1497300",
    "end": "1503330"
  },
  {
    "text": "conversion so there's an implicit conversion from a non cons object to a con subject etc so we have to implement",
    "start": "1503330",
    "end": "1511040"
  },
  {
    "text": "that in our types which we do and sometimes and so we need some support some support of the in the in the in the",
    "start": "1511040",
    "end": "1519080"
  },
  {
    "start": "1517000",
    "end": "1641000"
  },
  {
    "text": "template code to program that and that's a safety feature that this does not work",
    "start": "1519080",
    "end": "1524450"
  },
  {
    "text": "yeah that's not to blame you so therefore we had to implement new dynamic cast",
    "start": "1524450",
    "end": "1532160"
  },
  {
    "text": "operations for shared pointers so and we had to introduce a dynamic pointer cast",
    "start": "1532160",
    "end": "1539720"
  },
  {
    "text": "because a shared pointer is also just taking the type of the elements so we",
    "start": "1539720",
    "end": "1545450"
  },
  {
    "text": "have a problem with propagating there is a relationship to the template types to",
    "start": "1545450",
    "end": "1551720"
  },
  {
    "text": "the template file types so here is if you create a vector of shared pointers",
    "start": "1551720",
    "end": "1559880"
  },
  {
    "text": "and you push them back and the element you have if you ask it what are you I'm",
    "start": "1559880",
    "end": "1565100"
  },
  {
    "text": "a shared pointer to a geometric object and you can't directly use it as a",
    "start": "1565100",
    "end": "1570830"
  },
  {
    "text": "shared point of circle as it's always the case with pointers but you can also",
    "start": "1570830",
    "end": "1576560"
  },
  {
    "text": "not dynamic cast so downcast it with the key word dynamic has to its downcast to",
    "start": "1576560",
    "end": "1584330"
  },
  {
    "text": "the type of circle again to implement some special behavior we had to",
    "start": "1584330",
    "end": "1591200"
  },
  {
    "text": "introduce a new dynamic pointer cos a new operator and with that things work",
    "start": "1591200",
    "end": "1596870"
  },
  {
    "text": "and that own does not only apply to downcast that also applies",
    "start": "1596870",
    "end": "1602930"
  },
  {
    "text": "to the other castes so therefore we have in SharePoint a static point occurs consequent occurs and since C++ 17 we",
    "start": "1602930",
    "end": "1611270"
  },
  {
    "text": "also have introduced reinterpret pointer cast which I what always the which is at",
    "start": "1611270",
    "end": "1617150"
  },
  {
    "text": "least as much as a smell as reinterpret cast alone okay",
    "start": "1617150",
    "end": "1625310"
  },
  {
    "text": "yeah this slide you should not see yet I",
    "start": "1625310",
    "end": "1632020"
  },
  {
    "text": "school am the aura good anything else to talk about",
    "start": "1632170",
    "end": "1638680"
  },
  {
    "text": "yes there's one problem left one problem is don't create multiple shared pointers",
    "start": "1638680",
    "end": "1646430"
  },
  {
    "start": "1641000",
    "end": "1716000"
  },
  {
    "text": "of the same raw pointer because then you have two objects thinking they are the",
    "start": "1646430",
    "end": "1652760"
  },
  {
    "text": "only owner of this pointer that's another good reason to use make sure that if you don't use weak pointers",
    "start": "1652760",
    "end": "1659810"
  },
  {
    "text": "because you don't see raw pointers at all so you don't fall into this trap",
    "start": "1659810",
    "end": "1665470"
  },
  {
    "text": "however the problem is we can't easily avoid this trap if we just use objects",
    "start": "1665470",
    "end": "1671840"
  },
  {
    "text": "and for example a member function of our object shall return a pointer to this",
    "start": "1671840",
    "end": "1677540"
  },
  {
    "text": "object we want to avoid row pointers so let's return a shared pointer of the object and that's not supported because",
    "start": "1677540",
    "end": "1685430"
  },
  {
    "text": "a share point as a wrapper around an object and now we are asking for that",
    "start": "1685430",
    "end": "1691160"
  },
  {
    "text": "the object returns this Reppert I'm so we have a cyclic dependency between",
    "start": "1691160",
    "end": "1696670"
  },
  {
    "text": "things here the way to support that which is a workaround and it does not",
    "start": "1696670",
    "end": "1702980"
  },
  {
    "text": "always work well is that we have a base class and able shared from this and this",
    "start": "1702980",
    "end": "1710000"
  },
  {
    "text": "enable shared from this class let me see let me animate what it does so this",
    "start": "1710000",
    "end": "1719150"
  },
  {
    "start": "1716000",
    "end": "1802000"
  },
  {
    "text": "means that you have to derive your data type from a base class and able shared",
    "start": "1719150",
    "end": "1724940"
  },
  {
    "text": "from this and what it does in the base class it creates a weak pointer for you",
    "start": "1724940",
    "end": "1730490"
  },
  {
    "text": "which is initialized with an ID pointer and then",
    "start": "1730490",
    "end": "1736419"
  },
  {
    "text": "if you then create your first shared pointer this weak pointer becomes a",
    "start": "1736419",
    "end": "1742179"
  },
  {
    "text": "shared pointer or becomes a point of their own to this memory it doesn't become shared pointer so by the way that",
    "start": "1742179",
    "end": "1752950"
  },
  {
    "text": "means before you didn't create a shared pointer you can access useful the the",
    "start": "1752950",
    "end": "1760750"
  },
  {
    "text": "share pointer from this object but the moment you have it you can call chat from this and if you call chat from this",
    "start": "1760750",
    "end": "1767559"
  },
  {
    "text": "for an object then this will give you a new SharePoint are using the same",
    "start": "1767559",
    "end": "1774850"
  },
  {
    "text": "control block as I said that's a workaround it has some impact because",
    "start": "1774850",
    "end": "1781179"
  },
  {
    "text": "for example you have to derive from another class now it has interesting problems if you have multi inheritance",
    "start": "1781179",
    "end": "1788519"
  },
  {
    "text": "it's a rock around it's it's kind of a heck it works in many cases but not in",
    "start": "1788519",
    "end": "1793929"
  },
  {
    "text": "all so yeah we are feeling a little bit uncomfortable I'm uncomfortable already",
    "start": "1793929",
    "end": "1800110"
  },
  {
    "text": "with shared pointers but it gets worse performance let's look at performance so",
    "start": "1800110",
    "end": "1808840"
  },
  {
    "start": "1802000",
    "end": "2211000"
  },
  {
    "text": "first of all we have some overhead we have this control block object which has to be allocated on the heap something",
    "start": "1808840",
    "end": "1815470"
  },
  {
    "text": "like I don't know I measured somewhere but that's not approved 16 bytes maybe 4 additional",
    "start": "1815470",
    "end": "1821799"
  },
  {
    "text": "bytes if you have a non-trivial deleter there and using make shared usually",
    "start": "1821799",
    "end": "1828100"
  },
  {
    "text": "saves 4 bytes and usually a deriving from enabler shared from this you might",
    "start": "1828100",
    "end": "1833500"
  },
  {
    "text": "add 8 bytes to each object something like this something around this corner so some overhead and for each chat point",
    "start": "1833500",
    "end": "1840340"
  },
  {
    "text": "I have one call on the heap if you don't combine them with make sure twitch head which has its own problem so but we have",
    "start": "1840340",
    "end": "1849549"
  },
  {
    "text": "another problem and the other problem we have to talk about this multi-threading",
    "start": "1849549",
    "end": "1857250"
  },
  {
    "text": "if we have the following situation we have a share pointer declared SP here",
    "start": "1857250",
    "end": "1867279"
  },
  {
    "text": "and this red pointer is used at the same time in two different threats on the left on the right so the",
    "start": "1867279",
    "end": "1874810"
  },
  {
    "text": "threat on the Left pushes it back into a vector the vector creates a copy therefore and the threat on the right",
    "start": "1874810",
    "end": "1882300"
  },
  {
    "text": "passes it by value to a function which also means we copy the shared pointer so",
    "start": "1882300",
    "end": "1890040"
  },
  {
    "text": "the problem we run into is a following we have an object owning the resource",
    "start": "1890040",
    "end": "1896050"
  },
  {
    "text": "and now at the same time two threads try to copy this shared pointer which mean",
    "start": "1896050",
    "end": "1903580"
  },
  {
    "text": "at the same time they want to increase the ownership of this pointer that's not",
    "start": "1903580",
    "end": "1910870"
  },
  {
    "text": "good distributed programming and multi-threading is good as long as you",
    "start": "1910870",
    "end": "1917650"
  },
  {
    "text": "don't have to share the same object otherwise you pay a price because you have to send around the data and even",
    "start": "1917650",
    "end": "1924070"
  },
  {
    "text": "worse you might have to synchronize the access to that data and that's the case here and the we discussed whether we",
    "start": "1924070",
    "end": "1931780"
  },
  {
    "text": "want to have it or not in the early implementations of shared pointers at boost",
    "start": "1931780",
    "end": "1936880"
  },
  {
    "text": "this was not synchronized but during the standardization we came up with the",
    "start": "1936880",
    "end": "1943270"
  },
  {
    "text": "defect you see it here 896 it is and this defect was discussed and before C++",
    "start": "1943270",
    "end": "1950440"
  },
  {
    "text": "11 we decided that we give the guarantee that you can use that you can account on",
    "start": "1950440",
    "end": "1957070"
  },
  {
    "text": "the fact that it is safe to copy your share pointer that's not that in general",
    "start": "1957070",
    "end": "1963280"
  },
  {
    "text": "share pointers are thread safe so all the operations or the other operations you have to synchronize but just copying",
    "start": "1963280",
    "end": "1970180"
  },
  {
    "text": "a shared pointer is Fredd safe you see it in the last sentence here changes in the use count",
    "start": "1970180",
    "end": "1977200"
  },
  {
    "text": "do not reflect modifications that can introduce a data race data raises our",
    "start": "1977200",
    "end": "1983320"
  },
  {
    "text": "time term for race undefined behavior due to a race condition good so that's",
    "start": "1983320",
    "end": "1990700"
  },
  {
    "text": "new good what is the prize well the prices we have to improve something with",
    "start": "1990700",
    "end": "1997180"
  },
  {
    "text": "the implementation because that means that if you go back to the slide here",
    "start": "1997180",
    "end": "2003840"
  },
  {
    "text": "that means that our counters have to somehow synchronize the access which",
    "start": "2003840",
    "end": "2009600"
  },
  {
    "text": "means they have to become something like Atomics or mutexes just a side note what",
    "start": "2009600",
    "end": "2017670"
  },
  {
    "text": "can happen is that one thread deletes the last owner and another threat",
    "start": "2017670",
    "end": "2023100"
  },
  {
    "text": "deletes the last week pointer so both threads think there's another thing when",
    "start": "2023100",
    "end": "2030510"
  },
  {
    "text": "they decrement but at the end we have the zeros real situation where we had to",
    "start": "2030510",
    "end": "2035730"
  },
  {
    "text": "delete the control block so therefore we not only have to synchronize between",
    "start": "2035730",
    "end": "2041670"
  },
  {
    "text": "threads the own account and the week counter we even have a dependency between them so we need some logic of a",
    "start": "2041670",
    "end": "2048270"
  },
  {
    "text": "protected region between them so that whenever one of the threads is the last",
    "start": "2048270",
    "end": "2053790"
  },
  {
    "text": "thread so that both owner and week pointer gets to zero then we have to",
    "start": "2053790",
    "end": "2059850"
  },
  {
    "text": "delete the control block the that can be improved usually you don't use mutexes",
    "start": "2059850",
    "end": "2065310"
  },
  {
    "text": "because they are pretty expensive so a way to do that is that the week pointer",
    "start": "2065310",
    "end": "2070379"
  },
  {
    "text": "in practice is not a weak pointer it is a pointer that also counts how many",
    "start": "2070380",
    "end": "2076470"
  },
  {
    "text": "owners we have or says I add one for at least one owner so we say we have an",
    "start": "2076470",
    "end": "2083730"
  },
  {
    "text": "owner counter and we have a week and owner counter because then we don't need",
    "start": "2083730",
    "end": "2090090"
  },
  {
    "text": "a protected region to decide whether we have to delete the control block then it's enough to see whether the week end",
    "start": "2090090",
    "end": "2096870"
  },
  {
    "text": "owner counter decrements to zero okay so it's tricky most Fricke then than we",
    "start": "2096870",
    "end": "2104460"
  },
  {
    "text": "think so we have that in the standard and Atomics and synchronization between",
    "start": "2104460",
    "end": "2112920"
  },
  {
    "text": "threats and mutexes are expensive so the question is how expensive are they I",
    "start": "2112920",
    "end": "2120110"
  },
  {
    "text": "have provided a program here and the program let's see the program does",
    "start": "2120110",
    "end": "2130770"
  },
  {
    "text": "roughly the following I have 1,000 elements I have",
    "start": "2130770",
    "end": "2137230"
  },
  {
    "text": "counter for 1 million iterations and what I do I initialize a vector of 1,000",
    "start": "2137230",
    "end": "2144640"
  },
  {
    "text": "elements or 1000 shared pointers referring to an object and then I start",
    "start": "2144640",
    "end": "2149920"
  },
  {
    "text": "a loop and in this loop I do 1 million iterations over these 1000 objects and I",
    "start": "2149920",
    "end": "2157270"
  },
  {
    "text": "perform a simple increment call in all these objects I make sure that the",
    "start": "2157270",
    "end": "2162849"
  },
  {
    "text": "objects are not shared but the the iterations of the share pointers might be might be passed or used by different",
    "start": "2162849",
    "end": "2174010"
  },
  {
    "text": "threads and now the key point is while I'm iterating over the SharePoint as I",
    "start": "2174010",
    "end": "2180579"
  },
  {
    "text": "can switch between a loop using auto reference and a loop using auto without",
    "start": "2180579",
    "end": "2187180"
  },
  {
    "text": "a reference without a reference we would copy all the SharePoint us without with",
    "start": "2187180",
    "end": "2194800"
  },
  {
    "text": "without reference we would copy the SharePoint us with the reference we would never copy any share pointer and",
    "start": "2194800",
    "end": "2202260"
  },
  {
    "text": "that's an example program I have and that's compile and run it so here we",
    "start": "2202260",
    "end": "2212170"
  },
  {
    "start": "2211000",
    "end": "2585000"
  },
  {
    "text": "have it oh wait a minute I switch I switch to the mode because I don't see what I doing here I don't have a monitor",
    "start": "2212170",
    "end": "2219910"
  },
  {
    "text": "here for me so I come back so yeah now I",
    "start": "2219910",
    "end": "2226720"
  },
  {
    "text": "see it good so let's compile it make",
    "start": "2226720",
    "end": "2232200"
  },
  {
    "text": "shared pointer loop dot 14 that will use",
    "start": "2232200",
    "end": "2238540"
  },
  {
    "text": "GCC 5 5 as you see with - OH - and again",
    "start": "2238540",
    "end": "2244630"
  },
  {
    "text": "C++ version 13 compiler and now we can use this program shared pointer loop it",
    "start": "2244630",
    "end": "2255970"
  },
  {
    "text": "has a couple of options so let's start with having one thread and iterating by",
    "start": "2255970",
    "end": "2261880"
  },
  {
    "text": "reference once again we iterate over 1 million times over vector of 1000 shared",
    "start": "2261880",
    "end": "2268240"
  },
  {
    "text": "pointers and I made sure that the operation is not optimized away there is an optimal operation that is called and",
    "start": "2268240",
    "end": "2274930"
  },
  {
    "text": "that gives a result and here is the current output for milliseconds let's",
    "start": "2274930",
    "end": "2285910"
  },
  {
    "text": "switch to iterate by value that's a",
    "start": "2285910",
    "end": "2300970"
  },
  {
    "text": "little bit slower so maybe you have",
    "start": "2300970",
    "end": "2307540"
  },
  {
    "text": "heard about the overhead but maybe it surprises you a little bit how big the overhead is please note that there's a",
    "start": "2307540",
    "end": "2314620"
  },
  {
    "text": "one I only use one thread that means",
    "start": "2314620",
    "end": "2319890"
  },
  {
    "text": "here you see how expensive it is to generate a semblance incrementally",
    "start": "2319890",
    "end": "2330250"
  },
  {
    "text": "threats yeah and now you know why they",
    "start": "2330250",
    "end": "2335350"
  },
  {
    "text": "include guys who introduced this new feature that they don't synchronize",
    "start": "2335350",
    "end": "2341470"
  },
  {
    "text": "threads unless they have to they suddenly got effect of 10 or 100 or 1000",
    "start": "2341470",
    "end": "2349619"
  },
  {
    "text": "so let's use four threads by reference",
    "start": "2351210",
    "end": "2356230"
  },
  {
    "text": "first pretty much the same as before",
    "start": "2356230",
    "end": "2361660"
  },
  {
    "text": "you see that the output is screwed up now from the for threat it seems that",
    "start": "2361660",
    "end": "2369400"
  },
  {
    "text": "here the amount of the cost of starting",
    "start": "2369400",
    "end": "2374560"
  },
  {
    "text": "additional threat pays off with the fact that each threat has to be less and we",
    "start": "2374560",
    "end": "2380230"
  },
  {
    "text": "can do things in parallel so I divided the 1 billion 1 million iterations",
    "start": "2380230",
    "end": "2385300"
  },
  {
    "text": "through the four threats so each for each threat has only 250,000 iterations",
    "start": "2385300",
    "end": "2392740"
  },
  {
    "text": "so now let me task that they let me start a task manager because that's",
    "start": "2392740",
    "end": "2400300"
  },
  {
    "text": "funny [Music]",
    "start": "2400300",
    "end": "2405470"
  },
  {
    "text": "it is now let's use for threat and it's",
    "start": "2405470",
    "end": "2414300"
  },
  {
    "text": "a right by value",
    "start": "2414300",
    "end": "2417350"
  },
  {
    "text": "yeah let's drink a coffee and but you also see another problem yeah the CPU",
    "start": "2425520",
    "end": "2433300"
  },
  {
    "text": "saw it what you see is what it takes for",
    "start": "2433300",
    "end": "2439119"
  },
  {
    "text": "CPU now constantly sending the counters around the 1,000 candles around back and",
    "start": "2439119",
    "end": "2446380"
  },
  {
    "text": "forth between the different costs that's",
    "start": "2446380",
    "end": "2452859"
  },
  {
    "text": "the price of a share pointer and it's a funny story how I created this talk when",
    "start": "2452859",
    "end": "2460570"
  },
  {
    "text": "I created this talk the reason I created this talk I was sitting in a conference press conference in Aspen and on stage",
    "start": "2460570",
    "end": "2469380"
  },
  {
    "text": "somebody was saying here this is a cool spare pointer and you know what some",
    "start": "2469380",
    "end": "2475540"
  },
  {
    "text": "people pass shared pointers by reference but that makes no sense because it's",
    "start": "2475540",
    "end": "2482050"
  },
  {
    "text": "just the share pointer it's a pointer so why should you pass it by reference so I phoned up my chief architect from a",
    "start": "2482050",
    "end": "2489790"
  },
  {
    "text": "project I was currently in and I said why do we have the rule always pass the shared pointer by reference because they",
    "start": "2489790",
    "end": "2496720"
  },
  {
    "text": "say that stupid and he answered they have no clue and here's a reason you saw",
    "start": "2496720",
    "end": "2502720"
  },
  {
    "text": "that and and and there's a real story behind it was a project where they invented a new database based on many",
    "start": "2502720",
    "end": "2510460"
  },
  {
    "text": "many many using many threats and this database had to scale and they used",
    "start": "2510460",
    "end": "2517210"
  },
  {
    "text": "shared pointers and everywhere because they thought it's a good programming paradigm and it turned out when they",
    "start": "2517210",
    "end": "2525220"
  },
  {
    "text": "started to use it in real practice the database got on hold because of they",
    "start": "2525220",
    "end": "2531550"
  },
  {
    "text": "were only sending around shared pointers and this is not the first project I know now that that happened to a couple of",
    "start": "2531550",
    "end": "2539440"
  },
  {
    "text": "projects that they thought Oh share pointers there's no problem let's use them everywhere and that's good so you",
    "start": "2539440",
    "end": "2546220"
  },
  {
    "text": "see the price here so yes it's it's not against share pointers use them but use",
    "start": "2546220",
    "end": "2552099"
  },
  {
    "text": "them with care and especially don't pass him around by value if you can't pass them around by",
    "start": "2552099",
    "end": "2557710"
  },
  {
    "text": "reference because they're not they are as fast as Rob pointers good so that's a",
    "start": "2557710",
    "end": "2566170"
  },
  {
    "text": "price that's a real price of shared pointers and you should know it wait a",
    "start": "2566170",
    "end": "2571180"
  },
  {
    "text": "minute I want to switch back to my normal presentation mode now the interesting",
    "start": "2571180",
    "end": "2578140"
  },
  {
    "text": "thing is that my presentation is gone so",
    "start": "2578140",
    "end": "2583569"
  },
  {
    "text": "and we have different numbers it's not the exact factor that counts we have",
    "start": "2583569",
    "end": "2589390"
  },
  {
    "start": "2585000",
    "end": "2629000"
  },
  {
    "text": "different numbers here's a in the project where I just talked about we also did some measurements and we saw",
    "start": "2589390",
    "end": "2596440"
  },
  {
    "text": "that the overhead was about factor of 40 and with - all three it became effect of",
    "start": "2596440",
    "end": "2602859"
  },
  {
    "text": "80 this was using 8 threads on the end will cost something and and you could",
    "start": "2602859",
    "end": "2610510"
  },
  {
    "text": "see there 20 82 percent of the time the CPU was waiting to get access to an",
    "start": "2610510",
    "end": "2616720"
  },
  {
    "text": "owner counter that was a problem so it was stalled and if we pass - I found us",
    "start": "2616720",
    "end": "2622900"
  },
  {
    "text": "by Reverend we were only waiting 16 percent of the time so that's a point with red pointers",
    "start": "2622900",
    "end": "2629859"
  },
  {
    "start": "2629000",
    "end": "2914000"
  },
  {
    "text": "good so passing by shared pointers that's the first lesson Oh",
    "start": "2629859",
    "end": "2635290"
  },
  {
    "text": "is there something better yes there is something better that's unique pointers",
    "start": "2635290",
    "end": "2641640"
  },
  {
    "text": "so let's look at them first how we can unique use unique pointers here at some",
    "start": "2641640",
    "end": "2648660"
  },
  {
    "text": "let's start with our basic example polymorphism here we have them with",
    "start": "2648660",
    "end": "2654790"
  },
  {
    "text": "shared pointers but let's switch to unique pointers so what's the difference with unit pointers unique pointers you",
    "start": "2654790",
    "end": "2662609"
  },
  {
    "text": "can use like SharePoint us instead of make sure you call make unique the type",
    "start": "2662609",
    "end": "2667780"
  },
  {
    "text": "is unique pointers that are shared pointer but there's a difference they don't count and they don't have to count",
    "start": "2667780",
    "end": "2675849"
  },
  {
    "text": "or the question is when they don't count how do they know when the last owner dies the trick they use is there can't",
    "start": "2675849",
    "end": "2683260"
  },
  {
    "text": "be a second owner that's all they do they say we make sure",
    "start": "2683260",
    "end": "2689140"
  },
  {
    "text": "that there's always only one owner and that's an interesting trick because you",
    "start": "2689140",
    "end": "2697000"
  },
  {
    "text": "can enforce this trick at compile time you don't have to do anything at run",
    "start": "2697000",
    "end": "2702820"
  },
  {
    "text": "time all you do is you disable copying and that's what they do and that's why",
    "start": "2702820",
    "end": "2710920"
  },
  {
    "text": "this from program now needs you see that and move because it would not compile if",
    "start": "2710920",
    "end": "2717400"
  },
  {
    "text": "I call push back to push back this pointer into a vector we make sure that",
    "start": "2717400",
    "end": "2722980"
  },
  {
    "text": "if you push back the unique pointer into the vector this will be moved the",
    "start": "2722980",
    "end": "2729460"
  },
  {
    "text": "ownership will be moved into the vector and the ownership of the circle pointer",
    "start": "2729460",
    "end": "2736840"
  },
  {
    "text": "will be moved and when we then return the whole thing then because we have",
    "start": "2736840",
    "end": "2743500"
  },
  {
    "text": "moved semantics here when we return a vector of elements we have moved semantics and that means that we move",
    "start": "2743500",
    "end": "2751030"
  },
  {
    "text": "the elements to the one who gets the result because the elements and the",
    "start": "2751030",
    "end": "2758500"
  },
  {
    "text": "vector are dying that where we move the elements from so we don't have to do",
    "start": "2758500",
    "end": "2764410"
  },
  {
    "text": "anything here so let's use them as before let's iterate over them with",
    "start": "2764410",
    "end": "2769540"
  },
  {
    "text": "polymorphism and please note that you can all can now not compile iterating by",
    "start": "2769540",
    "end": "2777430"
  },
  {
    "text": "value you have to iterate by reference because it's not allowed to copy a unique pointer and the good thing is now",
    "start": "2777430",
    "end": "2784510"
  },
  {
    "text": "when we call clear it's easy each Pro teach element each unique pointer knows",
    "start": "2784510",
    "end": "2789730"
  },
  {
    "text": "whether it is an own or not and if it's an owner it can only be the only one because it's not possible to to screw",
    "start": "2789730",
    "end": "2796750"
  },
  {
    "text": "there up well it is if you pass a row pointer to twice to two different unique pointers but then it's your fault so we",
    "start": "2796750",
    "end": "2805090"
  },
  {
    "text": "can then safely delete the pointer okay and if you don't like move create call",
    "start": "2805090",
    "end": "2813040"
  },
  {
    "text": "make unique and pass it directly to push back and you have the same effect",
    "start": "2813040",
    "end": "2818790"
  },
  {
    "text": "so that that's a cheap rock partner that's a one",
    "start": "2818790",
    "end": "2825130"
  },
  {
    "text": "of the few cases where we create more significant more safety without overhead",
    "start": "2825130",
    "end": "2831640"
  },
  {
    "text": "without performance overhead because the type system is our friend and we",
    "start": "2831640",
    "end": "2838680"
  },
  {
    "text": "introduce that and seabass was 11 we couldn't introduce that before c+ was 11 because we needed move semantics for",
    "start": "2838680",
    "end": "2845529"
  },
  {
    "text": "that our first try to implement move semantics in a shared pointer was called Auto pointer that was a nightmare",
    "start": "2845529",
    "end": "2851710"
  },
  {
    "text": "because we thought we could implement move semantics in the copy constructor",
    "start": "2851710",
    "end": "2857289"
  },
  {
    "text": "of an auto pointer and that created some interesting problems so if you have an",
    "start": "2857289",
    "end": "2866829"
  },
  {
    "text": "auto pointer replaces by unique pointer if it still compiles fine if not fix",
    "start": "2866829",
    "end": "2872019"
  },
  {
    "text": "this the places which might either need a move or you have a code smell or you",
    "start": "2872019",
    "end": "2877029"
  },
  {
    "text": "have abused an outer part and we are you have found it back ok that's a unique",
    "start": "2877029",
    "end": "2884589"
  },
  {
    "text": "pointer unique pointer to explain a unique pointer that's easy we can create",
    "start": "2884589",
    "end": "2890829"
  },
  {
    "text": "it we can create a resource we can pass the ownership to a unique pointer you can't pass the ownership to another",
    "start": "2890829",
    "end": "2897910"
  },
  {
    "text": "object but you can move the ownership to another object and that's a benefit of",
    "start": "2897910",
    "end": "2903670"
  },
  {
    "text": "unique point no overhead everything is decided at compile time good so the",
    "start": "2903670",
    "end": "2913960"
  },
  {
    "text": "trick the unique pointers implemented is simple we have deleted copying so we",
    "start": "2913960",
    "end": "2919869"
  },
  {
    "start": "2914000",
    "end": "2944000"
  },
  {
    "text": "have no copy constructor and no assignment operator no copying assignment operator we only have the",
    "start": "2919869",
    "end": "2926680"
  },
  {
    "text": "moving operations that do what you just saw by the way make unique was not",
    "start": "2926680",
    "end": "2932200"
  },
  {
    "text": "available in C++ 11 we added it in C++ 14 so before C++ 11 you have had to call",
    "start": "2932200",
    "end": "2939400"
  },
  {
    "text": "new and pass then the ownership to unique porta so are there any problems",
    "start": "2939400",
    "end": "2946930"
  },
  {
    "start": "2944000",
    "end": "3154000"
  },
  {
    "text": "of course they are always there it's not a performance problem but we have some",
    "start": "2946930",
    "end": "2952239"
  },
  {
    "text": "restrictions I think the biggest description restriction we have is it's not that",
    "start": "2952239",
    "end": "2958810"
  },
  {
    "text": "easy to have polymorphism well that's easy but to have a downcast back to the",
    "start": "2958810",
    "end": "2965350"
  },
  {
    "text": "original type so if we have that here everything works fine create a unique pointer push back",
    "start": "2965350",
    "end": "2972010"
  },
  {
    "text": "everything is fine but if you then assign this to not oh my goodness this slide is wrong but I'm pretty sure",
    "start": "2972010",
    "end": "2979900"
  },
  {
    "text": "I made it this morning at five o'clock and I've fixed it but it seems I didn't",
    "start": "2979900",
    "end": "2987870"
  },
  {
    "text": "let's see probably it's here this is screwed up let's hope the best yes good",
    "start": "2987870",
    "end": "2994810"
  },
  {
    "text": "so yeah so if you then access the first element and first of all ultra would not",
    "start": "2994810",
    "end": "3000810"
  },
  {
    "text": "work here because you would create a copy so you have to use cards out of reference and the type is a unique",
    "start": "3000810",
    "end": "3006810"
  },
  {
    "text": "pointer and but you can't cast down and",
    "start": "3006810",
    "end": "3012030"
  },
  {
    "text": "we also can't create something like a dynamic pointer cast or dynamic unique",
    "start": "3012030",
    "end": "3017940"
  },
  {
    "text": "pointer cast because what is the essence of a dynamic cast it down casts you the",
    "start": "3017940",
    "end": "3025800"
  },
  {
    "text": "point and gives you a second pointer referring to the same object that's by intentionally exactly what we don't want",
    "start": "3025800",
    "end": "3032400"
  },
  {
    "text": "to have in unique pointers we don't want to have to own us so we simply can't provide a down cast operation for unique",
    "start": "3032400",
    "end": "3041610"
  },
  {
    "text": "pointers so that's probably the biggest drawback and that means that you have to",
    "start": "3041610",
    "end": "3047130"
  },
  {
    "text": "use dynamic cast and the way you can use it you can access the raw pointer behind",
    "start": "3047130",
    "end": "3053430"
  },
  {
    "text": "the unique pointer and then call downcast and please be aware that you",
    "start": "3053430",
    "end": "3059220"
  },
  {
    "text": "don't use it longer than necessary so because we have lifetime image issues",
    "start": "3059220",
    "end": "3064500"
  },
  {
    "text": "and never pass this to something like to something like a another location where",
    "start": "3064500",
    "end": "3072000"
  },
  {
    "text": "people might create a unique pointer or share pointer from that so that's the",
    "start": "3072000",
    "end": "3077670"
  },
  {
    "text": "way you have to do it and to make it a little bit more safe you might say let's",
    "start": "3077670",
    "end": "3082890"
  },
  {
    "text": "do it in one expression so in the if statement you can declare without all",
    "start": "3082890",
    "end": "3089819"
  },
  {
    "text": "the circle pointer and use it but this make sure that at the end of the if",
    "start": "3089819",
    "end": "3096720"
  },
  {
    "text": "statement the lifetime of the raw pointer is God so beware and it's a",
    "start": "3096720",
    "end": "3105540"
  },
  {
    "text": "problem to return a unique pointer for an object that exists we don't have support for that",
    "start": "3105540",
    "end": "3111650"
  },
  {
    "text": "yeah that's surprise there's always a price there's no free lunch but the good",
    "start": "3111650",
    "end": "3117450"
  },
  {
    "text": "news is there is regarding performance no overhead and that's a very important",
    "start": "3117450",
    "end": "3124349"
  },
  {
    "text": "aspect in our programming community because one reason we have C++ often is",
    "start": "3124349",
    "end": "3130980"
  },
  {
    "text": "performance so if you can use unique pointers use them and of discussion you",
    "start": "3130980",
    "end": "3138290"
  },
  {
    "text": "have to explain me if I see a small share pointer that's a smell you have to",
    "start": "3138290",
    "end": "3144420"
  },
  {
    "text": "explain me why you don't use a unique pointer there's another interesting",
    "start": "3144420",
    "end": "3151619"
  },
  {
    "text": "issue here a last issue here as you can",
    "start": "3151619",
    "end": "3158849"
  },
  {
    "start": "3154000",
    "end": "3329000"
  },
  {
    "text": "ownership move around ownership for unique pointers you can do the following",
    "start": "3158849",
    "end": "3163950"
  },
  {
    "text": "you can say hey wait a minute I inside a function I create a resource",
    "start": "3163950",
    "end": "3170069"
  },
  {
    "text": "I pass the ownership to a unique pointer and I passed the ownership to the calling side so that's easily to do you",
    "start": "3170069",
    "end": "3178859"
  },
  {
    "text": "don't need any move there just return it by value because this return by value is",
    "start": "3178859",
    "end": "3185190"
  },
  {
    "text": "a call with move semantics because local object is about to die so the calling",
    "start": "3185190",
    "end": "3192839"
  },
  {
    "text": "side can in a loop call this function each time it called sauce it gets the",
    "start": "3192839",
    "end": "3198930"
  },
  {
    "text": "ownership of the created resource that was created there and can use it and the",
    "start": "3198930",
    "end": "3204810"
  },
  {
    "text": "next time you in the loop call source again you am delete because you are the",
    "start": "3204810",
    "end": "3211890"
  },
  {
    "text": "owner of the previously returned return value you delete the ownership so you'll",
    "start": "3211890",
    "end": "3216930"
  },
  {
    "text": "call the need for the created resource and you then become owner of the next",
    "start": "3216930",
    "end": "3224370"
  },
  {
    "text": "return value that's fine that's safe programming and it's also possible the",
    "start": "3224370",
    "end": "3229590"
  },
  {
    "text": "other way around you can say let's pass my ownership to a function what you do",
    "start": "3229590",
    "end": "3237000"
  },
  {
    "text": "then is a place out here in sync you declare that you take the ownership of a",
    "start": "3237000",
    "end": "3244620"
  },
  {
    "text": "unique pointer so the caller then has to pass an ownership by calling mafia",
    "start": "3244620",
    "end": "3252480"
  },
  {
    "text": "without the move it wouldn't compile because then you would create a copy here now there's an interesting there",
    "start": "3252480",
    "end": "3262950"
  },
  {
    "text": "there has been an interest interesting discussion in our community between two",
    "start": "3262950",
    "end": "3269490"
  },
  {
    "text": "of the guys we usually ask if we ask for style and good programming practice so",
    "start": "3269490",
    "end": "3277200"
  },
  {
    "text": "this is he hops arrest I I call it because have supper said that's the way",
    "start": "3277200",
    "end": "3283170"
  },
  {
    "text": "you should do it declare the unique pointer in the sink to take the unique pointer by to take it",
    "start": "3283170",
    "end": "3290640"
  },
  {
    "text": "by be taken by value and then time Scott",
    "start": "3290640",
    "end": "3296760"
  },
  {
    "text": "Myers and said no no that's not the way you should do it you should pass it by a",
    "start": "3296760",
    "end": "3303420"
  },
  {
    "text": "value reference because obviously we have your move semantics so you should",
    "start": "3303420",
    "end": "3309900"
  },
  {
    "text": "signal that in the signature and they started to discuss that and I think",
    "start": "3309900",
    "end": "3318690"
  },
  {
    "text": "finally perhaps that Scott Myers were right but I don't agree with them I",
    "start": "3318690",
    "end": "3326430"
  },
  {
    "text": "think it's more complicated because this is a nice demonstration of the feature",
    "start": "3326430",
    "end": "3333750"
  },
  {
    "start": "3329000",
    "end": "3600000"
  },
  {
    "text": "move semantics first of all both as possible the difference is if you pass a",
    "start": "3333750",
    "end": "3341970"
  },
  {
    "text": "unique pointer to a function taking it by value you will give up the ownership",
    "start": "3341970",
    "end": "3350270"
  },
  {
    "text": "okay because you create and you are Jack this object gets the ownership this",
    "start": "3350630",
    "end": "3356500"
  },
  {
    "text": "object is destroyed at the end of the function call so as a result in the",
    "start": "3356500",
    "end": "3362140"
  },
  {
    "text": "first part if you call if you pass it by value you no longer are the owner of the",
    "start": "3362140",
    "end": "3369580"
  },
  {
    "text": "resource and it was freed in the second",
    "start": "3369580",
    "end": "3376240"
  },
  {
    "text": "part you only pass a reference and if you pass a reference that means you",
    "start": "3376240",
    "end": "3381700"
  },
  {
    "text": "refer to the original unique pointer but it depends on the implementation of this",
    "start": "3381700",
    "end": "3388000"
  },
  {
    "text": "function whether you use the ownership or not so it's funny with mu semantics",
    "start": "3388000",
    "end": "3394630"
  },
  {
    "text": "if you don't signal move here so not having to ampersand it will move if your",
    "start": "3394630",
    "end": "3401530"
  },
  {
    "text": "signal move here it might move that's one of the interesting aspects of MU",
    "start": "3401530",
    "end": "3409750"
  },
  {
    "text": "semantics there are good reasons for that but in general the the lesson down",
    "start": "3409750",
    "end": "3415780"
  },
  {
    "text": "here is pretty easy the lesson is if you have marked something with move it might",
    "start": "3415780",
    "end": "3424780"
  },
  {
    "text": "or might not be moved because the specification is after a call after",
    "start": "3424780",
    "end": "3432400"
  },
  {
    "text": "using a move from object the object is an invalid but unspecified state well",
    "start": "3432400",
    "end": "3439600"
  },
  {
    "text": "four unique pointers we even specify the state but I think it's good style not to",
    "start": "3439600",
    "end": "3445090"
  },
  {
    "text": "not to break this rule in C++ just four unique pointers which by the way some",
    "start": "3445090",
    "end": "3452200"
  },
  {
    "text": "people try now by even adding more interesting interfaces so if it's",
    "start": "3452200",
    "end": "3457990"
  },
  {
    "text": "important for you that the ownership was gone don't count on the fact that thing",
    "start": "3457990",
    "end": "3467109"
  },
  {
    "text": "takes the argument by value or don't count on the implementation of this",
    "start": "3467109",
    "end": "3473950"
  },
  {
    "text": "function if you pass it by reference make it clear that this is your",
    "start": "3473950",
    "end": "3480100"
  },
  {
    "text": "assumption and you will and the way to do that is after calling sync with move",
    "start": "3480100",
    "end": "3485350"
  },
  {
    "text": "you say I'm no longer interested in the resource in this value so the right way to call sing well",
    "start": "3485350",
    "end": "3493380"
  },
  {
    "text": "however it is declared and however it is implemented is called move and then",
    "start": "3493380",
    "end": "3498570"
  },
  {
    "text": "called unique pointer release that way you make sure and you have expressed",
    "start": "3498570",
    "end": "3504450"
  },
  {
    "text": "explicitly that is it is your will that you are no longer interested in the",
    "start": "3504450",
    "end": "3509790"
  },
  {
    "text": "value of this object and the corresponding resource should be freed and you can be sure that it is free",
    "start": "3509790",
    "end": "3517310"
  },
  {
    "text": "please keep that in mind star guides are like this are really",
    "start": "3517310",
    "end": "3522330"
  },
  {
    "text": "missing we are for problem in C++ we have many many new techniques but we",
    "start": "3522330",
    "end": "3527700"
  },
  {
    "text": "don't have corresponding style guides which we only learned over the past years we had very early a book called",
    "start": "3527700",
    "end": "3534870"
  },
  {
    "text": "more effective effective modern C++ but that was written eight seven years ago",
    "start": "3534870",
    "end": "3542100"
  },
  {
    "text": "we need a new book as a lot of things have changed looking back with C++ 11 which we should",
    "start": "3542100",
    "end": "3549960"
  },
  {
    "text": "have teach to users now as especially regarding move semantics good find a",
    "start": "3549960",
    "end": "3558390"
  },
  {
    "text": "command yes there is an intentionally very different approach and design for",
    "start": "3558390",
    "end": "3566010"
  },
  {
    "text": "your shared pointers and unique pointers shared pointers were implemented and",
    "start": "3566010",
    "end": "3571320"
  },
  {
    "text": "designed to have no performance overhead end of discussion",
    "start": "3571320",
    "end": "3577910"
  },
  {
    "text": "why share point us anyway needed",
    "start": "3577910",
    "end": "3583440"
  },
  {
    "text": "overhead because of the reference counting that had to be stored somewhere there's no way to go around that so we",
    "start": "3583440",
    "end": "3591630"
  },
  {
    "text": "could say yeah it's safe and we have we can share ownership between different",
    "start": "3591630",
    "end": "3597420"
  },
  {
    "text": "places which you use a couple of times in your programs but they have an ownership and you see the difference in",
    "start": "3597420",
    "end": "3604650"
  },
  {
    "text": "the way you pass a bolita if you are possibly later your own deleter to a",
    "start": "3604650",
    "end": "3611460"
  },
  {
    "text": "shared pointer it's enough to pass us the leader and the constructor so here",
    "start": "3611460",
    "end": "3617670"
  },
  {
    "text": "again the P Clause which we pass to the shed pointer despite calling peel",
    "start": "3617670",
    "end": "3624900"
  },
  {
    "text": "if you have to pass the Delita",
    "start": "3624900",
    "end": "3630420"
  },
  {
    "text": "to a unique pointer you have to pass it twice because that the type of the",
    "start": "3630420",
    "end": "3636240"
  },
  {
    "text": "unique pointer has to transfer it somewhere you need to make sure not to confuse different unique pointers having",
    "start": "3636240",
    "end": "3642569"
  },
  {
    "text": "different deal eaters you have it should become part of the type and also to be",
    "start": "3642569",
    "end": "3649319"
  },
  {
    "text": "able to starve there so that the unique pointer suddenly has some memory some member for this type for this member so",
    "start": "3649319",
    "end": "3656510"
  },
  {
    "text": "therefore you have to pass it twice once as an additional argument that type of",
    "start": "3656510",
    "end": "3661769"
  },
  {
    "text": "the deleter and once in the constructor which can be improved with c++ 20",
    "start": "3661769",
    "end": "3668250"
  },
  {
    "text": "because if c++ 20 it's allowed that we instantiate a lambda later on we're",
    "start": "3668250",
    "end": "3677190"
  },
  {
    "text": "provided it has not captured every anything so there ii you don't have to",
    "start": "3677190",
    "end": "3684240"
  },
  {
    "text": "pass it in the constructor but the difference will remain the shared pointer needs Adelita in the",
    "start": "3684240",
    "end": "3690269"
  },
  {
    "text": "constructor the unique pointer gets Adelita as a template parameter that's a",
    "start": "3690269",
    "end": "3696150"
  },
  {
    "text": "difference and yes we know that difference and yes we apologize but it's",
    "start": "3696150",
    "end": "3701970"
  },
  {
    "text": "the price of having very different interests and implementation mechanisms",
    "start": "3701970",
    "end": "3708269"
  },
  {
    "text": "for shared pointer and unique pointer that's the way it is we can't resolve that easily that's it thank you very",
    "start": "3708269",
    "end": "3716789"
  },
  {
    "text": "much I hope this was useful I'm not long time here around but for some questions",
    "start": "3716789",
    "end": "3723779"
  },
  {
    "text": "I'm around here for a few minutes and yeah Merry Christmas and to pay if we",
    "start": "3723779",
    "end": "3729539"
  },
  {
    "text": "don't see until then thank you very much [Applause]",
    "start": "3729539",
    "end": "3742750"
  }
]