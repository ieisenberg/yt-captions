[
  {
    "start": "0",
    "end": "165000"
  },
  {
    "text": "hello folks uh I have a little bit of a quandry uh over exactly what I'm going",
    "start": "2320",
    "end": "7560"
  },
  {
    "text": "to present uh this isn't as bad as it sounds as I have far far more code than I could possibly show in an hour uh if",
    "start": "7560",
    "end": "14440"
  },
  {
    "text": "any of you were at my c 7 presentation yesterday then I had just more code than",
    "start": "14440",
    "end": "19720"
  },
  {
    "text": "I could present in an hour quite clearly today I have way way more code um part",
    "start": "19720",
    "end": "25359"
  },
  {
    "text": "of the problem is I know I've done abusing C at NDC before",
    "start": "25359",
    "end": "30599"
  },
  {
    "text": "but I'm not sure whether it was NDC Oslo NDC London or NDC Sydney or which NDC",
    "start": "30599",
    "end": "36480"
  },
  {
    "text": "Oslo it would have been so could you put your hand up if you've been to one of my abusing C talks",
    "start": "36480",
    "end": "42520"
  },
  {
    "text": "before okay I'm Reckoning that's still under half which means I might pull out some of the old great glorious ones that",
    "start": "42520",
    "end": "49920"
  },
  {
    "text": "are some of my favorites um but which you may have seen before AP poies if so",
    "start": "49920",
    "end": "55600"
  },
  {
    "text": "um a word of warning uh do not use any of this code in production the point of this talk isn't have bad",
    "start": "55600",
    "end": "63600"
  },
  {
    "text": "code cuz anyone can write bad code and you know just look at my day today pull request to see bad code um this is code",
    "start": "63600",
    "end": "72080"
  },
  {
    "text": "which looks quite appealing and you may be tempted and think oh how clever and",
    "start": "72080",
    "end": "78080"
  },
  {
    "text": "anytime you find yourself saying gosh that code looks clever that should be the time that you scream and run in the",
    "start": "78080",
    "end": "83720"
  },
  {
    "text": "opposite direction um however it's really fun to do for a talk uh I used to",
    "start": "83720",
    "end": "90240"
  },
  {
    "text": "say this was great because I didn't commit any real C code but now I write C",
    "start": "90240",
    "end": "96040"
  },
  {
    "text": "at Google for Google Cloud platform so you know that's that's awesome having got one advert out of the way uh quickly",
    "start": "96040",
    "end": "103320"
  },
  {
    "text": "the other one is for my book um some of you may already have C in depth the",
    "start": "103320",
    "end": "108479"
  },
  {
    "text": "fourth edition is being worked on when I'm not speaking at conferences um and",
    "start": "108479",
    "end": "114200"
  },
  {
    "text": "for this week you can get 40% off any Manning book um using the code ctw NDC",
    "start": "114200",
    "end": "120320"
  },
  {
    "text": "ow 177 um so please buy you know you could buy um C in depth you could buy",
    "start": "120320",
    "end": "126079"
  },
  {
    "text": "other books you could buy lots of copies of C in depth it's all good without further",
    "start": "126079",
    "end": "133160"
  },
  {
    "text": "Ado um and yesterday I was saying to blame blowdart on Twitter if any demos",
    "start": "133160",
    "end": "139360"
  },
  {
    "text": "um go badly uh today you take your pick Rob connory um Damen Edwards David",
    "start": "139360",
    "end": "145080"
  },
  {
    "text": "Fowler um any of those three to blame if any of this goes wrong and this talk usually does go wrong because I make the",
    "start": "145080",
    "end": "151840"
  },
  {
    "text": "mistake of trying to add lib a bit of the code and some of this code is so hairy and bizarre that if I haven't",
    "start": "151840",
    "end": "158879"
  },
  {
    "text": "looked at it really recently I have no idea what's going on anymore um it's a voyage of Discovery for us all um I",
    "start": "158879",
    "end": "166400"
  },
  {
    "start": "165000",
    "end": "375000"
  },
  {
    "text": "would like to start off with uh my favorite Unicode character so I'm sure",
    "start": "166400",
    "end": "171760"
  },
  {
    "text": "we all have um favorite Unicode characters mine is the Mongolian vow",
    "start": "171760",
    "end": "177239"
  },
  {
    "text": "separator um the the Unicode Consortium occasionally run a little uh sort of",
    "start": "177239",
    "end": "183519"
  },
  {
    "text": "sponsorship drive and they let you sponsor a character and every time they",
    "start": "183519",
    "end": "188840"
  },
  {
    "text": "do this I go and I try to sponsor the Mongolian vow separator I'm quite happy to give the Unicode Consortium you know",
    "start": "188840",
    "end": "195440"
  },
  {
    "text": "$2 or whatever uh to have a bit of paper saying I sponsor the Mongolian V separator they never let me do it it's",
    "start": "195440",
    "end": "202920"
  },
  {
    "text": "really sad um but let's let's see what it is when we've thought about this code",
    "start": "202920",
    "end": "210680"
  },
  {
    "text": "so if anyone other than myself showed you this code what would you expect it",
    "start": "210680",
    "end": "215879"
  },
  {
    "text": "to do when we run it what's it going to print out hint",
    "start": "215879",
    "end": "222319"
  },
  {
    "text": "it's either going to print out string x equals an initializer or string x equals in",
    "start": "222319",
    "end": "228080"
  },
  {
    "text": "main any",
    "start": "228080",
    "end": "231360"
  },
  {
    "text": "thoughts okay I'm I'm hearing enough muttering I can't actually tell what people are thinking uh but it it's clear",
    "start": "233680",
    "end": "240560"
  },
  {
    "text": "that people have thought about it enough so the answer is you can't really for",
    "start": "240560",
    "end": "246040"
  },
  {
    "text": "sure tell uh because you don't know what's in my text editor um we appear to",
    "start": "246040",
    "end": "252480"
  },
  {
    "text": "have a variable declaration here a variable uh assignment here and then um",
    "start": "252480",
    "end": "261079"
  },
  {
    "text": "a variable read access here and this this middle one is where things get slightly",
    "start": "261079",
    "end": "267040"
  },
  {
    "text": "tricky if any of you nearer the front can have a look down here at the whole",
    "start": "267040",
    "end": "272360"
  },
  {
    "text": "column and character bit uh you may not notice something interesting if I just write Arrow over",
    "start": "272360",
    "end": "281880"
  },
  {
    "text": "then things are fine column 18 character 18 and then we get to column 19",
    "start": "281880",
    "end": "287840"
  },
  {
    "text": "character 19 and then column 19 character 20 and then colum 20 character 21 it's",
    "start": "287840",
    "end": "296080"
  },
  {
    "text": "probably no surprise at this point that the Mongolian Val separator is a",
    "start": "296080",
    "end": "301400"
  },
  {
    "text": "character between string and X here so the next question that that",
    "start": "301400",
    "end": "306840"
  },
  {
    "text": "isn't the good bit okay um the next question is what does",
    "start": "306840",
    "end": "312120"
  },
  {
    "text": "that mean what's that going to do so I'm sure all of you have read the um C",
    "start": "312120",
    "end": "319639"
  },
  {
    "text": "specification and the ecma standard which are different things I I have to say this evening uh I hope I still have",
    "start": "319639",
    "end": "326800"
  },
  {
    "text": "some voice left because from 10 p.m. till midnight if you can believe it I'm convening what I hope is going to be the",
    "start": "326800",
    "end": "333360"
  },
  {
    "text": "last meeting of egma standardizing C 5 I know we're a little bit out of to date but until now it's been c 2 and we are",
    "start": "333360",
    "end": "341639"
  },
  {
    "text": "finally finally getting there um however the C spec and the C standard slightly",
    "start": "341639",
    "end": "349240"
  },
  {
    "text": "disagree on which version of Unicode they support and this makes a huge",
    "start": "349240",
    "end": "355639"
  },
  {
    "text": "difference I believe and it doesn't really matter if I've got these the wrong way around that the ecma standard says that c uses",
    "start": "355639",
    "end": "364720"
  },
  {
    "text": "um Unicode version three and the C 5 specification says that c uses um",
    "start": "364720",
    "end": "372000"
  },
  {
    "text": "Unicode version 2 and it matters because of the history",
    "start": "372000",
    "end": "378000"
  },
  {
    "start": "375000",
    "end": "621000"
  },
  {
    "text": "here oh in fact oh I've even read it written it down so ecma says four um the C spec says three and the important",
    "start": "378000",
    "end": "385639"
  },
  {
    "text": "thing is that the Unicode Val Val separator u+1 0 e didn't exist in",
    "start": "385639",
    "end": "391680"
  },
  {
    "text": "Unicode 2 in Unicode 3 it was a formatting character this CF is that's",
    "start": "391680",
    "end": "397199"
  },
  {
    "text": "the unicco category for formatting character in 4 five and six it was Zs",
    "start": "397199",
    "end": "404440"
  },
  {
    "text": "which is sort of some kind of white space I'm not sure whether it's all Whit spaces Zs and then for seven eight and N",
    "start": "404440",
    "end": "412400"
  },
  {
    "text": "it's back to being a formatting character the reason that's really really important is although the",
    "start": "412400",
    "end": "418840"
  },
  {
    "text": "standard and the spec disagree on which versions of Unicode they're going to use they do agree on one thing which is an",
    "start": "418840",
    "end": "425520"
  },
  {
    "text": "identifier can contain a formatting character and when you use an identifier",
    "start": "425520",
    "end": "431599"
  },
  {
    "text": "with a formatting character it's sort of normalized away it's as if the uh the C",
    "start": "431599",
    "end": "436680"
  },
  {
    "text": "compiler does a a replacement of all formatting characters with nothing which",
    "start": "436680",
    "end": "441960"
  },
  {
    "text": "means that the identifier string x with nothing else in it is equal you know is",
    "start": "441960",
    "end": "449639"
  },
  {
    "text": "viewed the same as a string identifier of string x with a formatting character",
    "start": "449639",
    "end": "455879"
  },
  {
    "text": "in however if we put regular Whit space in",
    "start": "455879",
    "end": "461720"
  },
  {
    "text": "that's clearly no longer an assignment that's now a declaration of a",
    "start": "461720",
    "end": "467720"
  },
  {
    "text": "new variable I'm not sure why I'm getting a a squiggly there the type or namespace string could",
    "start": "467720",
    "end": "474919"
  },
  {
    "text": "not be found that's kind of interesting my guess is I've left the Mongolian Val",
    "start": "474919",
    "end": "480000"
  },
  {
    "text": "separator in there and if I do that may what the",
    "start": "480000",
    "end": "486479"
  },
  {
    "text": "hell oh no i' still left it there okay there's there's a couple of bits and pieces um so it seems",
    "start": "486479",
    "end": "493879"
  },
  {
    "text": "that I'm going to have to check the spec after this it seems that you can't have oh no that the string keyword because",
    "start": "493879",
    "end": "501120"
  },
  {
    "text": "it's a keyword not an identifier can't have the Mongolian V separator in it if I let me copy and",
    "start": "501120",
    "end": "507759"
  },
  {
    "text": "paste the Mongolian separator I think I am doing so yeah",
    "start": "507759",
    "end": "513320"
  },
  {
    "text": "then it goes wrong so keywords aren't identifiers important oh I've just worked out a",
    "start": "513320",
    "end": "520120"
  },
  {
    "text": "whole other thing I can do with yield because is yield an identifier or",
    "start": "520120",
    "end": "526279"
  },
  {
    "text": "is it a keyword well it's a contextual keyword so maybe sometimes it's oh I'm",
    "start": "526279",
    "end": "531839"
  },
  {
    "text": "not going to try to do it in front of you because it'll be far more fun to do it later on um I would love to be able to show",
    "start": "531839",
    "end": "538760"
  },
  {
    "text": "you comp iling this code uh in with different versions of a c compiler and",
    "start": "538760",
    "end": "544800"
  },
  {
    "text": "it's actually doing different things I have not yet found any version of a compiler that actually treats it as",
    "start": "544800",
    "end": "551839"
  },
  {
    "text": "whitespace which is what the ecma specs says it should be treated as um the",
    "start": "551839",
    "end": "557200"
  },
  {
    "text": "reality is that Roslin just uses whatever version of Unicode comes with",
    "start": "557200",
    "end": "563600"
  },
  {
    "text": "um the version of net that you're using and I think the",
    "start": "563600",
    "end": "569839"
  },
  {
    "text": "previous despite the fact that uh the C 5 spec says three yeah no um the old C",
    "start": "569839",
    "end": "578320"
  },
  {
    "text": "you know csc.exe before Rosen came along came with its own version of Unicode presumably version three in there so it",
    "start": "578320",
    "end": "585920"
  },
  {
    "text": "would have thought it was for um formatting and I haven't got a version of Roslin that will work on a version of",
    "start": "585920",
    "end": "593640"
  },
  {
    "text": "net older than 2014 in theory if I use the monoc compiler it sort of should use this to",
    "start": "593640",
    "end": "600000"
  },
  {
    "text": "be ecma compliant and view it as a different um identifier but actually it doesn't that's still one of my favorite",
    "start": "600000",
    "end": "607200"
  },
  {
    "text": "things and that's why the Mongolian V separator is my favorite character because just changing from being a",
    "start": "607200",
    "end": "612600"
  },
  {
    "text": "formatting character to a whes space character and then back again is wonderfully evil you how can a character",
    "start": "612600",
    "end": "618519"
  },
  {
    "text": "be evil that's that's how right we're not going to leave strings though um I want to give you",
    "start": "618519",
    "end": "626720"
  },
  {
    "start": "621000",
    "end": "857000"
  },
  {
    "text": "some tools here for what I'm sure is a very very common situation which is you",
    "start": "626720",
    "end": "633040"
  },
  {
    "text": "want to write a string literal um but you don't have the shift",
    "start": "633040",
    "end": "639240"
  },
  {
    "text": "key working at the moment or sorry your your shift two for for a quote at least it's shift two on my keyboard um maybe",
    "start": "639240",
    "end": "646160"
  },
  {
    "text": "it's shift quote for um us keyboards and things so suppose you can't type double",
    "start": "646160",
    "end": "652760"
  },
  {
    "text": "quote this happens all the time of course um but you really want to initialize a constant string",
    "start": "652760",
    "end": "659839"
  },
  {
    "text": "well prior to C 6 you were stuck um but now we have the name of operator so it's",
    "start": "659839",
    "end": "666519"
  },
  {
    "text": "great if I want to do hello world and I want a constant I I want to",
    "start": "666519",
    "end": "672440"
  },
  {
    "text": "print out hello world to the console um without any spaces because spaces make it awkward frankly um I can",
    "start": "672440",
    "end": "681040"
  },
  {
    "text": "do that with C 6 just with the name of operator you know this isn't teaching you anything",
    "start": "681040",
    "end": "687519"
  },
  {
    "text": "that you probably don't know already let's just prove that that does print hello world and it will then print is",
    "start": "687519",
    "end": "694000"
  },
  {
    "text": "null or empty as well uh so that's the name of intro",
    "start": "694000",
    "end": "700360"
  },
  {
    "text": "hello world and is null of null or empty and the letter of these proves that you can print the name of a member it",
    "start": "700360",
    "end": "708800"
  },
  {
    "text": "doesn't matter that X is null we're not really accessing the member at all all",
    "start": "708800",
    "end": "714360"
  },
  {
    "text": "we're doing is saying well it must exist um and I think it has to be accessible as well",
    "start": "714360",
    "end": "721200"
  },
  {
    "text": "however if I wanted to print out hello world at the moment I have to declare a",
    "start": "721200",
    "end": "726680"
  },
  {
    "text": "method or a variable or something and that's that's just annoying having to",
    "start": "726680",
    "end": "732079"
  },
  {
    "text": "declare something bring some a variable into scope or whatever fortunately it",
    "start": "732079",
    "end": "737120"
  },
  {
    "text": "turns out that name of works with the dynamic keyword as",
    "start": "737120",
    "end": "742920"
  },
  {
    "text": "well so we can put whatever we like in here",
    "start": "742920",
    "end": "749199"
  },
  {
    "text": "this isn't going to access anything it's not going to do any Dynamic member access to try to find Hello World um it",
    "start": "750120",
    "end": "757240"
  },
  {
    "text": "will just print out hello world and then it's going to do print out the Mongolian V separator and the length of Mongolian",
    "start": "757240",
    "end": "765279"
  },
  {
    "text": "valve separator um now as you might guess there's a Mongolian valve",
    "start": "765279",
    "end": "771079"
  },
  {
    "text": "separator here between yep between the n and the V and there's another one",
    "start": "771079",
    "end": "776199"
  },
  {
    "text": "between the L and the S um and just to prove not that you can actually see that I'm copy pasting but I really am paste",
    "start": "776199",
    "end": "783360"
  },
  {
    "text": "into there and paste into there and the great thing is that not only is the name",
    "start": "783360",
    "end": "789519"
  },
  {
    "text": "of operator allowing us to um use almost whatever string we want in here it's",
    "start": "789519",
    "end": "795880"
  },
  {
    "text": "also doing um removing formatting characters for us so when we print",
    "start": "795880",
    "end": "802120"
  },
  {
    "text": "Mongol name of Mongolian Val separator do length that will print it without the",
    "start": "802120",
    "end": "807360"
  },
  {
    "text": "formatting character whereas here we've got a string with all those pesky formatting characters that we don't",
    "start": "807360",
    "end": "812600"
  },
  {
    "text": "really want we only want the length of what we can see so if we just run that",
    "start": "812600",
    "end": "818120"
  },
  {
    "text": "uh we should see that they print different lengths uh that's entirely the wrong one apologies",
    "start": "818120",
    "end": "825440"
  },
  {
    "text": "no uh name of anything yes so Mongolian",
    "start": "825440",
    "end": "830519"
  },
  {
    "text": "valve separator after removing the Mongolian valve separators has length 25",
    "start": "830519",
    "end": "835959"
  },
  {
    "text": "and with it it still has um sorry with out is 23 with is 25 I'm just going to",
    "start": "835959",
    "end": "841959"
  },
  {
    "text": "bump the font up a bit because otherwise people at the back may be hard to hard",
    "start": "841959",
    "end": "848120"
  },
  {
    "text": "press see hopefully that okay yep cool thank you folks right I'm going to go",
    "start": "848120",
    "end": "853880"
  },
  {
    "text": "back to the agenda so I don't forget some of my favorite bits um right",
    "start": "853880",
    "end": "859519"
  },
  {
    "start": "857000",
    "end": "1028000"
  },
  {
    "text": "deconstructors any of you who came yesterday to c 7 know all about deconstructors um and in particular that",
    "start": "859519",
    "end": "867399"
  },
  {
    "text": "we can use extension methods to deconstruct things uh into their composite parts and the fact that we can",
    "start": "867399",
    "end": "874680"
  },
  {
    "text": "use extension methods rather than just regular methods means that we can do it on other people's types like date",
    "start": "874680",
    "end": "881360"
  },
  {
    "text": "time however there's a bit of a cultural problem here because suppose we weren't",
    "start": "881360",
    "end": "887360"
  },
  {
    "text": "sensible if you're sensible you deconstruct a year month day but suppose you were a rigidly UK oriented developer",
    "start": "887360",
    "end": "895920"
  },
  {
    "text": "and out of interest in Norway how do you format the dates is it day month year",
    "start": "895920",
    "end": "901160"
  },
  {
    "text": "yeah okay it's the halfway sensible thing it's clearly not as sensible as year month day going in you know the",
    "start": "901160",
    "end": "907759"
  },
  {
    "text": "same decreasing order of um importance as you know numbers but at least it's",
    "start": "907759",
    "end": "913079"
  },
  {
    "text": "not the American approach okay I think we can all agree that the American apprach to date formatting is just plain",
    "start": "913079",
    "end": "921240"
  },
  {
    "text": "weird so suppose I work with some code that is UK based and some code that is",
    "start": "921240",
    "end": "929360"
  },
  {
    "text": "us-based I've got some fiercely American um friends who do some some work and we",
    "start": "929360",
    "end": "936279"
  },
  {
    "text": "want to always deconstruct dates and times into the appropriate version for",
    "start": "936279",
    "end": "942839"
  },
  {
    "text": "what we're fiddling with at the time there are a couple of ways we can do this",
    "start": "942839",
    "end": "948759"
  },
  {
    "text": "so this is just date deconstruction we take today and we're going into I've",
    "start": "948759",
    "end": "953959"
  },
  {
    "text": "tried not to give things away they're just x y and Zed and the question is what this is",
    "start": "953959",
    "end": "959600"
  },
  {
    "text": "going to do well let's I can't remember which way around it prints at the moment uh because I fiddle with this code all",
    "start": "959600",
    "end": "965160"
  },
  {
    "text": "the time um okay it's doing it as the American month day year let's see if we",
    "start": "965160",
    "end": "972600"
  },
  {
    "text": "can work out why and I have no idea whether there's some Shortcut in Visual Studio you how do you navigate to to",
    "start": "972600",
    "end": "981160"
  },
  {
    "text": "deconstruction I don't know whether there is a shortcut I'll just go to where I know it is",
    "start": "981160",
    "end": "986440"
  },
  {
    "text": "so depending on whether the uh UK date format compiler symbol is",
    "start": "986440",
    "end": "994480"
  },
  {
    "text": "defined or the US date format you can see that we must have us St format",
    "start": "994480",
    "end": "999800"
  },
  {
    "text": "defined at the moment let's just use different overloads they're not actually overloads",
    "start": "999800",
    "end": "1006160"
  },
  {
    "text": "in that um there only one of these will will actually be built but if we decide",
    "start": "1006160",
    "end": "1013560"
  },
  {
    "text": "that today we want to be more UK oriented let's just Define UK date format instead and now when we run the",
    "start": "1013560",
    "end": "1020920"
  },
  {
    "text": "exact same sort of client code it comes up in a slightly more",
    "start": "1020920",
    "end": "1026120"
  },
  {
    "text": "pleasant format so that's fine if you're um doing",
    "start": "1026120",
    "end": "1031880"
  },
  {
    "start": "1028000",
    "end": "1254000"
  },
  {
    "text": "uh a single you want your whole project to take on one kind of formatting but what if you've got different modules",
    "start": "1031880",
    "end": "1039038"
  },
  {
    "text": "different class uh bits that want to get different formats well we don't have to",
    "start": "1039039",
    "end": "1044678"
  },
  {
    "text": "be quite as single you know one format will rule forever we can do it on a per class basis",
    "start": "1044679",
    "end": "1052440"
  },
  {
    "text": "because instead of importing the whole of the extension methods for a namespace",
    "start": "1052440",
    "end": "1058960"
  },
  {
    "text": "with C 6 we can use using static so we can just say at the top of this one",
    "start": "1058960",
    "end": "1064400"
  },
  {
    "text": "we're going to use isodate format and I could have another class without changing any project-wide properties",
    "start": "1064400",
    "end": "1070919"
  },
  {
    "text": "that used us dat format so this means that I can keep my American friends",
    "start": "1070919",
    "end": "1077640"
  },
  {
    "text": "Happy by saying right you can work on the code over there and you can use um year uh month day year I can't even",
    "start": "1077640",
    "end": "1085120"
  },
  {
    "text": "think about it properly I'll use Daymon year and really sensible people will Define isodate formatting and they'll",
    "start": "1085120",
    "end": "1092000"
  },
  {
    "text": "get the right way of doing things which is year month day so everyone wins and no one will",
    "start": "1092000",
    "end": "1097799"
  },
  {
    "text": "possibly be confused by looking at any of that code ever again am I right yeah",
    "start": "1097799",
    "end": "1103120"
  },
  {
    "text": "I did say never to use any of this stuff uh",
    "start": "1103120",
    "end": "1110760"
  },
  {
    "text": "asout separated I'll leave pre-processor ER Oddities let's look at one of",
    "start": "1112360",
    "end": "1119240"
  },
  {
    "text": "these there are two conflicting bits of language a lot of these um I sort of",
    "start": "1119240",
    "end": "1125559"
  },
  {
    "text": "found while doing the ecma standardization they were bits of the language that I wasn't aware of before",
    "start": "1125559",
    "end": "1132200"
  },
  {
    "text": "and one of the interesting things is there are two ways of ignoring whole chunks of code there are slashstar",
    "start": "1132200",
    "end": "1140120"
  },
  {
    "text": "comments and hash if you know pre-process a bits so the question is which wins and",
    "start": "1140120",
    "end": "1147880"
  },
  {
    "text": "ideally I would show this by sort of removing all kinds of coloration um in Visual Studio but we can see in this",
    "start": "1147880",
    "end": "1155520"
  },
  {
    "text": "case we have a hashif Fu and two hash eles which sort of looks a bit",
    "start": "1155520",
    "end": "1161679"
  },
  {
    "text": "odd but one of them is commented out if and only F fu is defined",
    "start": "1161679",
    "end": "1169400"
  },
  {
    "text": "but if we don't Define Fu if I just remove",
    "start": "1169400",
    "end": "1174919"
  },
  {
    "text": "that at that point this part of the code is defined instead and this else is",
    "start": "1174919",
    "end": "1182360"
  },
  {
    "text": "within the comments and this little sort of slash star slash that's a really helpful thing",
    "start": "1182360",
    "end": "1188360"
  },
  {
    "text": "when you're writing code like this because it is end or start a",
    "start": "1188360",
    "end": "1194600"
  },
  {
    "text": "comment you know just whichever think of it as toggle comment the toggle comment",
    "start": "1194600",
    "end": "1201600"
  },
  {
    "text": "operator and it's great and the nice thing is because because of the way it round that it works the bit that would",
    "start": "1201600",
    "end": "1209280"
  },
  {
    "text": "be the end of the closing part is just ignored because it's within a comment now if we're starting and otherwise if",
    "start": "1209280",
    "end": "1216679"
  },
  {
    "text": "we're ending a comment well we're ending with a slash instead um so yeah good ways to confuse",
    "start": "1216679",
    "end": "1222520"
  },
  {
    "text": "your colleagues right uh um let's talk a bit",
    "start": "1222520",
    "end": "1230280"
  },
  {
    "text": "about string interpolation everyone fairly familiar with string interpolation from C 6 um I do want to",
    "start": "1230280",
    "end": "1235960"
  },
  {
    "text": "give a bit of a health warning at this point it's possible you'll learn something in the next 10 minutes um I",
    "start": "1235960",
    "end": "1241919"
  },
  {
    "text": "know that's not why you came here I apologize but you",
    "start": "1241919",
    "end": "1247080"
  },
  {
    "text": "know it happens sometimes just occasionally so let's look uh string interpolation",
    "start": "1247080",
    "end": "1253440"
  },
  {
    "text": "project in case you missed it before all of this is on GitHub under J skdo code",
    "start": "1253440",
    "end": "1259240"
  },
  {
    "start": "1254000",
    "end": "1551000"
  },
  {
    "text": "um along with c 7 stuff and all kinds of bits and pieces um so let's start first",
    "start": "1259240",
    "end": "1265600"
  },
  {
    "text": "with Lambda Expressions so we know that um we can use General Expressions within",
    "start": "1265600",
    "end": "1273880"
  },
  {
    "text": "interpolated string literals so you know you can put f.x and it will get the the",
    "start": "1273880",
    "end": "1279400"
  },
  {
    "text": "X property or whatever but wouldn't it be lovely if we could just write arbitrary code in strings that's clearly",
    "start": "1279400",
    "end": "1285720"
  },
  {
    "text": "what the world has been waiting for ever since you know code behind and um or avoiding code",
    "start": "1285720",
    "end": "1292080"
  },
  {
    "text": "behind so we can't just put things in",
    "start": "1292080",
    "end": "1297600"
  },
  {
    "text": "braces that's just not allowed um so maybe lambar expressions are the",
    "start": "1298440",
    "end": "1305440"
  },
  {
    "text": "way forward and you might guess this by Lambda Expressions being the the title of the the class here however if we just",
    "start": "1305440",
    "end": "1311760"
  },
  {
    "text": "try to use Lambda Expressions on their own that doesn't work because Lambda",
    "start": "1311760",
    "end": "1317240"
  },
  {
    "text": "Expressions have no type um I won't go into why Lambda",
    "start": "1317240",
    "end": "1322520"
  },
  {
    "text": "Expressions don't have a type right now but instead they are assignable or convertible to any appropriate delegate",
    "start": "1322520",
    "end": "1329480"
  },
  {
    "text": "type or expression tree type any compatible one so all we need to do is",
    "start": "1329480",
    "end": "1335000"
  },
  {
    "text": "cast a Lambda expression to say action or Funk of string because we do need to",
    "start": "1335000",
    "end": "1340960"
  },
  {
    "text": "produce um a value to be printed so if we cast this this Lambda expression to a",
    "start": "1340960",
    "end": "1348159"
  },
  {
    "text": "funk of string and then invoke it all within the interpolated string literal",
    "start": "1348159",
    "end": "1353840"
  },
  {
    "text": "it will work so there we go um now you I don't think that's",
    "start": "1353840",
    "end": "1361520"
  },
  {
    "text": "terribly readable I think we can do better than that um so it's the casting",
    "start": "1361520",
    "end": "1367679"
  },
  {
    "text": "that's the problem and even though Lambda Expressions don't have a type",
    "start": "1367679",
    "end": "1372880"
  },
  {
    "text": "they can still have the type inferred if you're doing something with them so I could have had",
    "start": "1372880",
    "end": "1379000"
  },
  {
    "text": "you know Funk string Funk equals and",
    "start": "1379000",
    "end": "1384760"
  },
  {
    "text": "then this that's fine I don't need to cast at",
    "start": "1384760",
    "end": "1391799"
  },
  {
    "text": "that point so I was only having to cast because we didn't have any sort of",
    "start": "1391799",
    "end": "1397600"
  },
  {
    "text": "context of how we were trying to use this thing and at the same time if we're",
    "start": "1397600",
    "end": "1403200"
  },
  {
    "text": "going to have a context in which we're using this why not just invoke the method as well",
    "start": "1403200",
    "end": "1409000"
  },
  {
    "text": "the the delegate so all I've done is introduced um a local function here it's",
    "start": "1409000",
    "end": "1415919"
  },
  {
    "text": "only a local function so that I can fit it all on one screen without revealing other things um but now when we call",
    "start": "1415919",
    "end": "1423480"
  },
  {
    "text": "F we pass in a Lambda expression and that can be implicitly",
    "start": "1423480",
    "end": "1430520"
  },
  {
    "text": "converted to Funk of string so that's fine and as a byproduct you know we really wanted type inference here but",
    "start": "1430520",
    "end": "1437799"
  },
  {
    "text": "while we're here we might as well invoke the delegate and return the string so that we can get rid of the invoke call",
    "start": "1437799",
    "end": "1443440"
  },
  {
    "text": "afterwards and now this is starting to look significantly like a more readable way of writing",
    "start": "1443440",
    "end": "1449360"
  },
  {
    "text": "code um and the great thing is you can have whole programs like this so look",
    "start": "1449360",
    "end": "1455960"
  },
  {
    "text": "you know you can have user input and everything so what this code is going to",
    "start": "1455960",
    "end": "1462760"
  },
  {
    "text": "do I'll run this in a sec so it will first",
    "start": "1462760",
    "end": "1469880"
  },
  {
    "text": "it's got to evaluate the interpolated string literal which",
    "start": "1469880",
    "end": "1475080"
  },
  {
    "text": "involves evaluating this so the first thing we will see is",
    "start": "1475080",
    "end": "1482279"
  },
  {
    "text": "what's your name will'll then get to write something and then when that's",
    "start": "1482279",
    "end": "1488000"
  },
  {
    "text": "returned we can invoke it I'm using the cast this time just for fun and just so that we can have the maximum number of",
    "start": "1488000",
    "end": "1494559"
  },
  {
    "text": "um braces and brackets at the end um anytime that you want to find out how drunk you are uh maybe see whether you",
    "start": "1494559",
    "end": "1501520"
  },
  {
    "text": "can get this right first time without a compiler um actually I don't think it",
    "start": "1501520",
    "end": "1506960"
  },
  {
    "text": "has anything to do with how drunk you are it's just complete luck um so let's",
    "start": "1506960",
    "end": "1512640"
  },
  {
    "text": "let's just prove that that works so we'll see one of the other ones as well so uh NDC",
    "start": "1512640",
    "end": "1518480"
  },
  {
    "text": "Oslo and it prints it hooray so in fact you could have your whole main method",
    "start": "1518480",
    "end": "1524240"
  },
  {
    "text": "could be within here if you wanted um I haven't tried yeah you you could even do",
    "start": "1524240",
    "end": "1530600"
  },
  {
    "text": "it not in a method at all and just have an empty main method and then um static",
    "start": "1530600",
    "end": "1537360"
  },
  {
    "text": "string x equals and then an interpolated string literal that just did everything why",
    "start": "1537360",
    "end": "1544480"
  },
  {
    "text": "not okay so that that was part one of interpolated string literals um next I want to talk about",
    "start": "1545120",
    "end": "1551880"
  },
  {
    "start": "1551000",
    "end": "2094000"
  },
  {
    "text": "lazy evaluation so let's look at link first so we we think of string",
    "start": "1551880",
    "end": "1559080"
  },
  {
    "text": "interpolation in a little bit of a way of Link in terms of well we can use",
    "start": "1559080",
    "end": "1564799"
  },
  {
    "text": "variables that are within you know use local variables and all kinds of things um even though we're calling into",
    "start": "1564799",
    "end": "1571600"
  },
  {
    "text": "string. format and things but link has lazy evaluation so",
    "start": "1571600",
    "end": "1577919"
  },
  {
    "text": "um I won't bother running this code because I'm sure you'll all understand what it's trying to do so we have some",
    "start": "1577919",
    "end": "1583000"
  },
  {
    "text": "minimum value and then the query that we are not reassigning later just select",
    "start": "1583000",
    "end": "1591240"
  },
  {
    "text": "all the values from this values which are greater than equal to",
    "start": "1591240",
    "end": "1597039"
  },
  {
    "text": "Min so uh initially it will pick four five and six so when we print the count",
    "start": "1597039",
    "end": "1604039"
  },
  {
    "text": "that will print three when we change Min to two because we're using lazy",
    "start": "1604039",
    "end": "1610399"
  },
  {
    "text": "evaluation and because the Min itself has been captured when we call query.",
    "start": "1610399",
    "end": "1616200"
  },
  {
    "text": "count it will re-evaluate the whole query and we'll get four instead because it will now find the two as well okay",
    "start": "1616200",
    "end": "1622919"
  },
  {
    "text": "everyone with me so far good otherwise you're kind of nine years out of date um",
    "start": "1622919",
    "end": "1630919"
  },
  {
    "text": "so the big question is clearly we want to be able to do this in interpolated string literals because why",
    "start": "1630919",
    "end": "1638880"
  },
  {
    "text": "not and at this point we have to start talking about formattable string uh out",
    "start": "1639399",
    "end": "1645159"
  },
  {
    "text": "of Interest how many of you have run across formattable string before no very very few okay right you really",
    "start": "1645159",
    "end": "1651679"
  },
  {
    "text": "will learn um and this will be actually useful stuff for formattable string is",
    "start": "1651679",
    "end": "1656880"
  },
  {
    "text": "used where you want to do some of the string interpolation now but not",
    "start": "1656880",
    "end": "1662320"
  },
  {
    "text": "probably not the final formatting because you want to be able to specify either immediately afterwards or later",
    "start": "1662320",
    "end": "1669360"
  },
  {
    "text": "on a different culture in particular you almost always want the invariant culture",
    "start": "1669360",
    "end": "1675320"
  },
  {
    "text": "um because interpolated string literals For Better or Worse just use string. format without any format provider so",
    "start": "1675320",
    "end": "1682360"
  },
  {
    "text": "you get the current thread's current culture I could rent for a long time",
    "start": "1682360",
    "end": "1689880"
  },
  {
    "text": "about the design decisions around string. format um but let's leave that for another time so that's why",
    "start": "1689880",
    "end": "1696320"
  },
  {
    "text": "formattable string exists but the interesting thing is what it does or",
    "start": "1696320",
    "end": "1701360"
  },
  {
    "text": "rather what the compiler does with it um there's actually a formattable string Factory class that the compiler uses and",
    "start": "1701360",
    "end": "1708440"
  },
  {
    "text": "you can even plug in your own ones um I think you do get nasty clashes if you're",
    "start": "1708440",
    "end": "1714120"
  },
  {
    "text": "already using a version of net that's got formattable string Factory but otherwise you can create your own and and the compiler will use it fine it's",
    "start": "1714120",
    "end": "1720760"
  },
  {
    "text": "all pattern based um or it's all based on I know that this type should",
    "start": "1720760",
    "end": "1726799"
  },
  {
    "text": "exist so what formattable string does is it evaluates the Expressions within the",
    "start": "1726799",
    "end": "1733679"
  },
  {
    "text": "interpolated string literal so here um it's going to evaluate this highlighted",
    "start": "1733679",
    "end": "1740679"
  },
  {
    "text": "expression which calls my underscore",
    "start": "1740679",
    "end": "1747279"
  },
  {
    "text": "method um and in fact is it that underscore",
    "start": "1747279",
    "end": "1752600"
  },
  {
    "text": "method how is that",
    "start": "1752600",
    "end": "1756240"
  },
  {
    "text": "getting I'm trying to work out how that's in scope oh I've got a I've got a using",
    "start": "1759320",
    "end": "1765600"
  },
  {
    "text": "static yes because using static is awesome right okay yes sorry I was so focused down here um so it will",
    "start": "1765600",
    "end": "1773640"
  },
  {
    "text": "call this method passing in the delegate that capture method just",
    "start": "1773640",
    "end": "1782640"
  },
  {
    "text": "returns an instance of capture that remembers the delegate it does not invoke the delegate so we are",
    "start": "1782640",
    "end": "1791559"
  },
  {
    "text": "evaluating this expression but that in turn is not yet",
    "start": "1792320",
    "end": "1798720"
  },
  {
    "text": "calling this so we've got a Lambda expression that's converted into a funk of object",
    "start": "1798720",
    "end": "1805880"
  },
  {
    "text": "and we're remembering that funk of object and then when we try to turn the",
    "start": "1805880",
    "end": "1812360"
  },
  {
    "text": "formattable string into a string and I can call do string if I want yeah same",
    "start": "1812360",
    "end": "1818039"
  },
  {
    "text": "deal um then it will call into because I'm implementing I",
    "start": "1818039",
    "end": "1824799"
  },
  {
    "text": "formattable it will call into our to string code here and at this point we",
    "start": "1824799",
    "end": "1830679"
  },
  {
    "text": "call the delegate and the important thing is we can call to string multiple",
    "start": "1830679",
    "end": "1838440"
  },
  {
    "text": "times and because we've captured the value variable rather than the value of",
    "start": "1838440",
    "end": "1844760"
  },
  {
    "text": "the value variable um if we change value and then implicitly call to string again",
    "start": "1844760",
    "end": "1852080"
  },
  {
    "text": "we'll get a different result and I've even gone you know above above and beyond here that you can even",
    "start": "1852080",
    "end": "1859039"
  },
  {
    "text": "pass in a format string so that if your delegate happens to return something that can be formatted like a date and",
    "start": "1859039",
    "end": "1865399"
  },
  {
    "text": "time we can format things appropriately so if I run this code I believe it should print current value before",
    "start": "1865399",
    "end": "1872399"
  },
  {
    "text": "current value after and then take 10 times of printing out the current time",
    "start": "1872399",
    "end": "1877960"
  },
  {
    "text": "in UTC um with hour minute second Etc let's check that it works lazy",
    "start": "1877960",
    "end": "1885480"
  },
  {
    "text": "evaluation woohoo again completely pointless but it's",
    "start": "1885480",
    "end": "1890960"
  },
  {
    "text": "quite fun to to think about when things are executed now the bit that I'm going to",
    "start": "1890960",
    "end": "1897720"
  },
  {
    "text": "ask you to vote later on whether you think this is abuse or a good use of C",
    "start": "1897720",
    "end": "1903200"
  },
  {
    "text": "features so this comes on to um Builds",
    "start": "1903200",
    "end": "1909080"
  },
  {
    "text": "on what we've just learned about formattable string but also um SQL injection now you",
    "start": "1909080",
    "end": "1916159"
  },
  {
    "text": "sort of you probably have some idea of what's coming but if you saw something",
    "start": "1916159",
    "end": "1922519"
  },
  {
    "text": "like that in most code in particular imagine that I didn't yet have the envar",
    "start": "1922519",
    "end": "1928039"
  },
  {
    "text": "which sort of hints that something weird is going on if I had that",
    "start": "1928039",
    "end": "1934919"
  },
  {
    "text": "code is it fair to say most of you would run a mile or you know um find the",
    "start": "1935000",
    "end": "1940679"
  },
  {
    "text": "junior developer who has introduced a SQL injection attack actually I'm not going to assume it's a junior developer",
    "start": "1940679",
    "end": "1946399"
  },
  {
    "text": "I think there are plenty of senior Developers who um have become Blas and whether they knew about SEL injection",
    "start": "1946399",
    "end": "1952279"
  },
  {
    "text": "attack or um vulnerabilities before or not have forgotten over time this looks",
    "start": "1952279",
    "end": "1958960"
  },
  {
    "text": "like terrible code on the other hand it also looks quite appealing this is the core of what",
    "start": "1958960",
    "end": "1965840"
  },
  {
    "text": "I love about abusing c as a talk um this is appealing because the",
    "start": "1965840",
    "end": "1971760"
  },
  {
    "text": "alternative the sort of normal safe boring version um would be to constru",
    "start": "1971760",
    "end": "1979519"
  },
  {
    "text": "struct uh you'd have V SQL equals let's copy",
    "start": "1979519",
    "end": "1985799"
  },
  {
    "text": "that um and make that ER come on at name at",
    "start": "1987320",
    "end": "1996320"
  },
  {
    "text": "ID and then we'd have um let's move SQL connection",
    "start": "1996320",
    "end": "2002120"
  },
  {
    "text": "up there um we'd have our Command CMD",
    "start": "2002120",
    "end": "2007200"
  },
  {
    "text": "equals new SQL command uh and give it the SQL and the",
    "start": "2007200",
    "end": "2014519"
  },
  {
    "text": "connection and then we'd have um",
    "start": "2014519",
    "end": "2020120"
  },
  {
    "text": "sorry CMD dop parameters. add and then we'd be repeating things so there'd be",
    "start": "2020840",
    "end": "2026039"
  },
  {
    "text": "the room for typos um SQL dbtype",
    "start": "2026039",
    "end": "2031440"
  },
  {
    "text": "mvar uh value equals name assuming that we've got name in scope and things and",
    "start": "2031440",
    "end": "2039080"
  },
  {
    "text": "I don't like this it's ugly um it it's sort of separating where",
    "start": "2039080",
    "end": "2045159"
  },
  {
    "text": "I'm using things from uh where I'm declaring",
    "start": "2045159",
    "end": "2050240"
  },
  {
    "text": "them so in that situation this really has significant",
    "start": "2050240",
    "end": "2057079"
  },
  {
    "text": "appeal particularly when I specify the type so I'm not even using the old",
    "start": "2057079",
    "end": "2063158"
  },
  {
    "text": "parameter you know add with value effectively so let's see whether whether we can get this to work so I've started",
    "start": "2063159",
    "end": "2070200"
  },
  {
    "text": "off by this is a new SQL command instead of calling new SQL command we're calling",
    "start": "2070200",
    "end": "2075960"
  },
  {
    "text": "the new SQL command extension method um you know you might want new uh safe for",
    "start": "2075960",
    "end": "2083599"
  },
  {
    "text": "interpolated strings SQL command but we'll leave it for the",
    "start": "2083599",
    "end": "2090800"
  },
  {
    "text": "moment and that is this extension method so that only takes a formattable",
    "start": "2091359",
    "end": "2099680"
  },
  {
    "start": "2094000",
    "end": "2229000"
  },
  {
    "text": "string and what I didn't mention before was that um an interpolated string",
    "start": "2099680",
    "end": "2105440"
  },
  {
    "text": "literal does have a type of string but is also implicitly convertible to um",
    "start": "2105440",
    "end": "2112200"
  },
  {
    "text": "formattable string so if you use VAR with an interpolated string literal that",
    "start": "2112200",
    "end": "2117280"
  },
  {
    "text": "still works fine and you get a string however if you do formattable string f",
    "start": "2117280",
    "end": "2123320"
  },
  {
    "text": "equals and then an interpolated string literal it does not um turn it into a",
    "start": "2123320",
    "end": "2128800"
  },
  {
    "text": "string and then turn it back into formattable string it does that just the first bit of the evaluation evaluate the",
    "start": "2128800",
    "end": "2135040"
  },
  {
    "text": "arguments and pass the formattable string the arguments and the format",
    "start": "2135040",
    "end": "2140720"
  },
  {
    "text": "string with the formatting removed and sort of curly brace zero the same thing you would pass into string. format so we",
    "start": "2140720",
    "end": "2147839"
  },
  {
    "text": "can use that here so we'll have been given in formattable string uh get",
    "start": "2147839",
    "end": "2153119"
  },
  {
    "text": "arguments will return the bits that we've got the uh name and ID from the",
    "start": "2153119",
    "end": "2159960"
  },
  {
    "text": "variables so that's from the expression evaluation and uh the format string will",
    "start": "2159960",
    "end": "2167280"
  },
  {
    "text": "be this well it'll be the whole of this but the important thing to focus on is",
    "start": "2167280",
    "end": "2172680"
  },
  {
    "text": "we've got zero here and one here so this is ready to pass into string do format",
    "start": "2172680",
    "end": "2178960"
  },
  {
    "text": "although this envar Char has been left alone and is kind of what are we going",
    "start": "2178960",
    "end": "2184599"
  },
  {
    "text": "to do with that well let's think backwards how could we",
    "start": "2184599",
    "end": "2189760"
  },
  {
    "text": "possibly get this to work we need something we're going to call string. format because there's no way that we're going to pause the format string",
    "start": "2189760",
    "end": "2195640"
  },
  {
    "text": "ourselves that would be crazy talk when string. format does it itself what we",
    "start": "2195640",
    "end": "2201160"
  },
  {
    "text": "want out is some SQL that looks like the SQL I typed before where name equals at",
    "start": "2201160",
    "end": "2207359"
  },
  {
    "text": "name and ID equals at ID or at least at something doesn't have to be at name",
    "start": "2207359",
    "end": "2213280"
  },
  {
    "text": "doesn't have to be at ID at P0 would be fine and at P1 in other words whatever",
    "start": "2213280",
    "end": "2219960"
  },
  {
    "text": "the position is within the format string that's perfectly fine as the name of the SQL",
    "start": "2219960",
    "end": "2226000"
  },
  {
    "text": "parameter the mvar does not affect the SQL that we're",
    "start": "2226000",
    "end": "2231760"
  },
  {
    "start": "2229000",
    "end": "2289000"
  },
  {
    "text": "going to produce but it does affect the parameters that we're going to produce",
    "start": "2231760",
    "end": "2237000"
  },
  {
    "text": "to pass into the SQL command and this is where things are a little bit funky if they weren't funky already so let's",
    "start": "2237000",
    "end": "2244920"
  },
  {
    "text": "generate some SQL parameters first okay okay so uh we're we're using an overload",
    "start": "2244920",
    "end": "2250079"
  },
  {
    "text": "of Select that gives us the um gives us the value but it also gives us the",
    "start": "2250079",
    "end": "2255880"
  },
  {
    "text": "position within the sequence the index if we want and so we're creating a new",
    "start": "2255880",
    "end": "2262160"
  },
  {
    "text": "SQL parameter with a name of position and we're giving it a value Okay so we've",
    "start": "2262160",
    "end": "2268960"
  },
  {
    "text": "got our SQL parameters and their values already sorted we haven't yet got the",
    "start": "2268960",
    "end": "2276119"
  },
  {
    "text": "SQL itself or the types of the SQL parameters so that's just from the",
    "start": "2276119",
    "end": "2283960"
  },
  {
    "text": "arguments if we transform each SQL parameter to just a new format capturing",
    "start": "2284200",
    "end": "2291920"
  },
  {
    "start": "2289000",
    "end": "2399000"
  },
  {
    "text": "parameter that's an extra class that I've introduced all it does is remember",
    "start": "2291920",
    "end": "2297079"
  },
  {
    "text": "the SQL parameter in the Constructor but we are expecting these to be formatted we know that we're going",
    "start": "2297079",
    "end": "2304480"
  },
  {
    "text": "to be calling string. format and passing in this array of format capturing",
    "start": "2304480",
    "end": "2310440"
  },
  {
    "text": "parameters and we know that string. format is going to look at the SQL that we've got or rather the format string",
    "start": "2310440",
    "end": "2317920"
  },
  {
    "text": "that's got the curly brace with a zero colon nvar and say ah that corresponds",
    "start": "2317920",
    "end": "2323319"
  },
  {
    "text": "to the first of these arguments and this implements I formattable therefore I",
    "start": "2323319",
    "end": "2330400"
  },
  {
    "text": "will call I formattable do to string passing in um",
    "start": "2330400",
    "end": "2336200"
  },
  {
    "text": "the Val value of the formattable string parameter",
    "start": "2336200",
    "end": "2342160"
  },
  {
    "text": "uh sorry the sure I'm I'm now not with it",
    "start": "2342160",
    "end": "2347599"
  },
  {
    "text": "myself yeah no no no it will call to string passing in the format because",
    "start": "2347599",
    "end": "2352720"
  },
  {
    "text": "it's expecting the value to have its its own value as it were um it will pass in the mvar charar and a format provider we",
    "start": "2352720",
    "end": "2361119"
  },
  {
    "text": "don't care about the format provider at all that could be the invariant culture that could be some completely different",
    "start": "2361119",
    "end": "2366359"
  },
  {
    "text": "format provider but but we do care about this format because this is where we get narar and it'll be null or an empty",
    "start": "2366359",
    "end": "2373240"
  },
  {
    "text": "string we don't really care if you haven't specified it so at that point we",
    "start": "2373240",
    "end": "2378760"
  },
  {
    "text": "can take the SQL parameter that we previously captured and poke at the type so we're",
    "start": "2378760",
    "end": "2385760"
  },
  {
    "text": "using the format string not to affect the result of formatting but to affect the parameter that we captured earlier",
    "start": "2385760",
    "end": "2393920"
  },
  {
    "text": "on I'm spending longer on this because I think it's actually",
    "start": "2395520",
    "end": "2400599"
  },
  {
    "start": "2399000",
    "end": "2519000"
  },
  {
    "text": "useful let's run the code so we're going to print out the command text uh the",
    "start": "2400599",
    "end": "2406280"
  },
  {
    "text": "parameter DB type and value for parameter one and",
    "start": "2406280",
    "end": "2411920"
  },
  {
    "text": "zero parameter SQL I hope this still works yes so we have perfectly",
    "start": "2411920",
    "end": "2417400"
  },
  {
    "text": "reasonable this Now does not look like it's vulnerable to SQL injection there are no values there no apostrophes",
    "start": "2417400",
    "end": "2425119"
  },
  {
    "text": "nothing we have p Z and we've got the right database type admittedly it would",
    "start": "2425119",
    "end": "2432560"
  },
  {
    "text": "probably have been inferred to be narar anyway um just by default let's see if",
    "start": "2432560",
    "end": "2438040"
  },
  {
    "text": "we can change that if we make that text then yeah so so our our paing is",
    "start": "2438040",
    "end": "2445480"
  },
  {
    "text": "working um I think the fact that t string is modifying something is using",
    "start": "2445480",
    "end": "2451760"
  },
  {
    "text": "the format string to modify the SQL parameter and not affecting the formatting itself is by far the most",
    "start": "2451760",
    "end": "2457640"
  },
  {
    "text": "evil parts of this however I would like to take a vote on this now and I I always do this and I've had mixed",
    "start": "2457640",
    "end": "2463240"
  },
  {
    "text": "results how many people would be happy to use something like",
    "start": "2463240",
    "end": "2468680"
  },
  {
    "text": "this oh not very many not very many I've seen more sort of 50/50 splits um to my",
    "start": "2469880",
    "end": "2476960"
  },
  {
    "text": "mind it really depends on what team what kind of team you're working on working with um if there's a fairly small team",
    "start": "2476960",
    "end": "2484359"
  },
  {
    "text": "and it's reasonably easy to keep everyone up to speed and make sure understand this is okay but new SQL",
    "start": "2484359",
    "end": "2492400"
  },
  {
    "text": "command stuff would not be okay um if they're a with it bunch then I think the",
    "start": "2492400",
    "end": "2498839"
  },
  {
    "text": "readability benefits of this are quite nice um if you're doing anything else if you have any doubt in your own or your",
    "start": "2498839",
    "end": "2506359"
  },
  {
    "text": "colleague's ability to remember that this is okay and other things aren't um then stay well well",
    "start": "2506359",
    "end": "2513040"
  },
  {
    "text": "away okay um didn't mean to close that cool let's look",
    "start": "2513040",
    "end": "2519440"
  },
  {
    "start": "2519000",
    "end": "2594000"
  },
  {
    "text": "at some performance um I actually ran this code earlier on uh because every",
    "start": "2519440",
    "end": "2526079"
  },
  {
    "text": "time I run it it seems to give different results or rather every time I come back to this talk uh the results are slightly",
    "start": "2526079",
    "end": "2531920"
  },
  {
    "text": "different and I have to demonstrate some slight different things this is another case where maybe it's useful um it's",
    "start": "2531920",
    "end": "2539079"
  },
  {
    "text": "sufficiently useful that I do actually use this in no time let's look at the background okay we have a large struct",
    "start": "2539079",
    "end": "2547800"
  },
  {
    "text": "it's readon uh as in it's immutable as all structs should be unless their system.",
    "start": "2547800",
    "end": "2553559"
  },
  {
    "text": "Valle um and it's quite large so it's 256 bits wide and ignore the fact that",
    "start": "2553559",
    "end": "2560359"
  },
  {
    "text": "it says in 256 as if I've implemented operators and all kinds of things I've implemented absolutely nothing it's just",
    "start": "2560359",
    "end": "2566240"
  },
  {
    "text": "a way of demonstrating a largish um structure so this is now 16 bytes um",
    "start": "2566240",
    "end": "2576119"
  },
  {
    "text": "it's getting into the large territory but in no time um my day and time Library I do have strs that are this",
    "start": "2576119",
    "end": "2583200"
  },
  {
    "text": "large or even a little bit larger um sorry it's uh it's 32 bytes",
    "start": "2583200",
    "end": "2589000"
  },
  {
    "text": "not 16 I think the largest one I've got is 40 So within the large struct class and",
    "start": "2589000",
    "end": "2597160"
  },
  {
    "text": "this is where we're going to be running code I have a field called value and I initialize it it's a readon",
    "start": "2597160",
    "end": "2604520"
  },
  {
    "text": "field I initialize it and I have a property called total value which um I'm",
    "start": "2604520",
    "end": "2610400"
  },
  {
    "text": "going to leave this not as an expression body member just because I'm going to want to be adding some code in a",
    "start": "2610400",
    "end": "2616599"
  },
  {
    "text": "minute this is all totally fine there are there aren't any tricks at this",
    "start": "2616960",
    "end": "2622520"
  },
  {
    "start": "2619000",
    "end": "2719000"
  },
  {
    "text": "point okay um I'm going to run a performance test",
    "start": "2622520",
    "end": "2627640"
  },
  {
    "text": "I'm very keen on performance for for no time so I bench mark things quite significantly and you may notice that",
    "start": "2627640",
    "end": "2635319"
  },
  {
    "text": "you there's a lot of iterations here so that's uh what do you know what I can",
    "start": "2635319",
    "end": "2641319"
  },
  {
    "text": "use hey it's a billion I should keep that in that's uh that's helpful so I'm",
    "start": "2641319",
    "end": "2646720"
  },
  {
    "text": "going to iterate a billion times and add the total value property each time let's",
    "start": "2646720",
    "end": "2654440"
  },
  {
    "text": "run it as it is so this is going to take about 12",
    "start": "2654440",
    "end": "2661119"
  },
  {
    "text": "seconds um if it was running as it was before admittedly I'm now Plugged In which I wasn't when I was running tests",
    "start": "2661119",
    "end": "2667520"
  },
  {
    "text": "before I don't know how much difference that makes on a Surface Book um 13 seconds okay that's a reasonably long",
    "start": "2667520",
    "end": "2674960"
  },
  {
    "text": "time let me show you the optimization I used to show that made a significant",
    "start": "2674960",
    "end": "2680119"
  },
  {
    "text": "difference and I don't know why it doesn't",
    "start": "2680119",
    "end": "2684759"
  },
  {
    "text": "now I can tell you a suspicion in a minute but um it's only a suspicion let's see maybe it'll be faster now",
    "start": "2691119",
    "end": "2697599"
  },
  {
    "text": "for no obvious reason so yeah it looks like this is",
    "start": "2697599",
    "end": "2703520"
  },
  {
    "text": "going to take about 12 13 seconds again while it does I will start expl",
    "start": "2703520",
    "end": "2709119"
  },
  {
    "text": "explaining why it's so 12 seconds okay what does temp. bit0",
    "start": "2709119",
    "end": "2718160"
  },
  {
    "text": "do does it invoke the bits zero property on the value of the value or well back",
    "start": "2718240",
    "end": "2726680"
  },
  {
    "start": "2719000",
    "end": "2769000"
  },
  {
    "text": "when we're using value if I undo everything does it invoke it on the",
    "start": "2726680",
    "end": "2732480"
  },
  {
    "text": "value of the field not quite it takes a copy and then invokes the property so",
    "start": "2732480",
    "end": "2740440"
  },
  {
    "text": "back when we had this okay this code was somewhat equivalent to vum equals value",
    "start": "2740440",
    "end": "2748359"
  },
  {
    "text": "um long in fact vum 2 equals value vum 3 equals value temp",
    "start": "2748359",
    "end": "2757680"
  },
  {
    "text": "four equals value and then temp 1 bit0 temp 2",
    "start": "2757680",
    "end": "2764480"
  },
  {
    "text": "bit it could the compiler could optimize things a little bit better than this um",
    "start": "2764480",
    "end": "2770200"
  },
  {
    "start": "2769000",
    "end": "2829000"
  },
  {
    "text": "because it could reuse the same stack bit and just be uh keeping the sum but",
    "start": "2770200",
    "end": "2775599"
  },
  {
    "text": "that's effectively what it was having to do why did it have to do this because this is read",
    "start": "2775599",
    "end": "2780920"
  },
  {
    "text": "only okay the C specification is very clear that if you call a function member",
    "start": "2780920",
    "end": "2786920"
  },
  {
    "text": "such as a property on a readon field it has to take a copy and that's",
    "start": "2786920",
    "end": "2795079"
  },
  {
    "text": "because you know you know I'm a nice person but I could be",
    "start": "2795079",
    "end": "2802359"
  },
  {
    "text": "doing something evil uh where let's",
    "start": "2802359",
    "end": "2807880"
  },
  {
    "text": "make okay this is um well I've got the syntax",
    "start": "2815599",
    "end": "2824800"
  },
  {
    "text": "right uh bits one equals value whatever the important thing is we have a getter",
    "start": "2825319",
    "end": "2831599"
  },
  {
    "start": "2829000",
    "end": "2874000"
  },
  {
    "text": "an appallingly formatted getor um which mutates the value if we call that",
    "start": "2831599",
    "end": "2837920"
  },
  {
    "text": "directly on the field then our readon field would be mutated that's bad okay",
    "start": "2837920",
    "end": "2844520"
  },
  {
    "text": "and this is why um you can't call on um readon Fields because there's an",
    "start": "2844520",
    "end": "2850800"
  },
  {
    "text": "assumption that if you invoke a Setter it's going to mutate things it's a pretty weird set if it",
    "start": "2850800",
    "end": "2857720"
  },
  {
    "text": "doesn't so let's go back to what we had so we know that um our original code",
    "start": "2858480",
    "end": "2865559"
  },
  {
    "text": "was taking a",
    "start": "2865559",
    "end": "2868319"
  },
  {
    "text": "copy each time before it calls the property and it can't even unless the",
    "start": "2871960",
    "end": "2877680"
  },
  {
    "text": "jit is being really clever it can't take the copy once and then invoke bits zero",
    "start": "2877680",
    "end": "2882720"
  },
  {
    "text": "on the copy and then bits one on the copy and then bits two on the copy because if we had our evil code from",
    "start": "2882720",
    "end": "2888160"
  },
  {
    "text": "before invoking bits one sorry bits zero would have mutated bits one and that's",
    "start": "2888160",
    "end": "2893520"
  },
  {
    "text": "bad for if we take the mutated version so if this is taking four copies",
    "start": "2893520",
    "end": "2901079"
  },
  {
    "text": "I had expected V equals value and then using temp. bit0 Etc",
    "start": "2901079",
    "end": "2907079"
  },
  {
    "text": "to be a bit faster because it would be taking one copy instead of four and I'm pretty sure that used to be the case but",
    "start": "2907079",
    "end": "2915000"
  },
  {
    "text": "I now suspect that the jit compiler says oh you're using temp equals value and",
    "start": "2915000",
    "end": "2921640"
  },
  {
    "text": "then using tump I'll just optimize that as if you'd use value directly no that's",
    "start": "2921640",
    "end": "2927480"
  },
  {
    "text": "doing too many copies fortunately there's an",
    "start": "2927480",
    "end": "2933119"
  },
  {
    "text": "alternative let's make it re read right",
    "start": "2933799",
    "end": "2938720"
  },
  {
    "text": "boom about two seconds six times as fast um this is why I have an attribute",
    "start": "2941599",
    "end": "2949440"
  },
  {
    "start": "2944000",
    "end": "2959000"
  },
  {
    "text": "in no time so I would have something like this and read write for",
    "start": "2949440",
    "end": "2956240"
  },
  {
    "text": "efficiency where the um I can't remember that I ever got round to writing it but I was going to",
    "start": "2956240",
    "end": "2962480"
  },
  {
    "start": "2959000",
    "end": "3074000"
  },
  {
    "text": "write a Rosen analyzer that would ensure that um I would only assign a value to",
    "start": "2962480",
    "end": "2969839"
  },
  {
    "text": "Value here if uh if I'm in the Constructor and I would assume that um",
    "start": "2969839",
    "end": "2976680"
  },
  {
    "text": "anything I was doing they were all pure structs um so I wouldn't be able to mutate them so it's probably not useful",
    "start": "2976680",
    "end": "2984440"
  },
  {
    "text": "for most of you but if you are dealing with large structs and you do have readon fields of those",
    "start": "2984440",
    "end": "2990160"
  },
  {
    "text": "structs if this is a tight Loop then consider making them readwrite but do protect yourself somehow you really",
    "start": "2990160",
    "end": "2997240"
  },
  {
    "text": "really don't want to be accidentally mutating things when they were meant to be",
    "start": "2997240",
    "end": "3003760"
  },
  {
    "text": "readon 10 minutes left right uh I'm going to have a look now at Old",
    "start": "3003880",
    "end": "3010880"
  },
  {
    "text": "staff what's what's going to be the most fun",
    "start": "3012160",
    "end": "3017640"
  },
  {
    "text": "um let's have a look at this code so what's this going to do",
    "start": "3018200",
    "end": "3026520"
  },
  {
    "text": "any thoughts well you you can just read it so it sets limit to 10 and then it sets",
    "start": "3029760",
    "end": "3036000"
  },
  {
    "text": "limit to five um and then it iterates from X being zero to limit so you know",
    "start": "3036000",
    "end": "3042760"
  },
  {
    "text": "that's going to be until it's five and then prints X and it seems to print X",
    "start": "3042760",
    "end": "3047799"
  },
  {
    "text": "twice so we expect to sort of see Z 0 1 1 22 3 3",
    "start": "3047799",
    "end": "3053920"
  },
  {
    "text": "44 um in the obvious way",
    "start": "3053920",
    "end": "3058640"
  },
  {
    "text": "what we might not expect is that it prints zero and then zero one and then",
    "start": "3059720",
    "end": "3066920"
  },
  {
    "text": "one two and then two three and then three four and then",
    "start": "3066920",
    "end": "3072160"
  },
  {
    "text": "four now you can see you know all I've got here is uh",
    "start": "3072599",
    "end": "3079160"
  },
  {
    "start": "3074000",
    "end": "3089000"
  },
  {
    "text": "program.cs packages. config that's just got some config um what can possibly be",
    "start": "3079160",
    "end": "3085040"
  },
  {
    "text": "going on any ideas pardon VAR is a class well where are we",
    "start": "3085040",
    "end": "3092920"
  },
  {
    "start": "3089000",
    "end": "3139000"
  },
  {
    "text": "defining where are we declaring VAR sorry in the project properties",
    "start": "3092920",
    "end": "3098480"
  },
  {
    "text": "there's just assembly info and it it's possible that assembly info declares a ver a class called",
    "start": "3098480",
    "end": "3103780"
  },
  {
    "text": "[Applause] VAR maybe um it does and it has implicit",
    "start": "3103780",
    "end": "3113400"
  },
  {
    "text": "operator conversions so there's an implicit um operator converting string to",
    "start": "3113400",
    "end": "3118960"
  },
  {
    "text": "VAR uh where we basically just take the index of that and check that it's okay so that will set our number to five when",
    "start": "3118960",
    "end": "3126720"
  },
  {
    "text": "we say limit equals five okay so that that's a",
    "start": "3126720",
    "end": "3134599"
  },
  {
    "text": "start how is this doing different things",
    "start": "3134599",
    "end": "3140839"
  },
  {
    "start": "3139000",
    "end": "3179000"
  },
  {
    "text": "pardon scroll right no um this time I don't have anything there's just more lensy stuff but good thought and that's",
    "start": "3140839",
    "end": "3148040"
  },
  {
    "text": "certainly been the case before I've had to scroll left um I've got a",
    "start": "3148040",
    "end": "3153760"
  },
  {
    "text": "whole no I'm not going to bother showing you um so the interesting thing here is",
    "start": "3153760",
    "end": "3159799"
  },
  {
    "text": "overload resolution so console. right line here takes a string and an object array or an",
    "start": "3159799",
    "end": "3168559"
  },
  {
    "text": "object or an object and an object or object object object or object array but either way they're all objects",
    "start": "3168559",
    "end": "3177079"
  },
  {
    "text": "it then calls to string on those values so that's going to call whatever our VAR",
    "start": "3177079",
    "end": "3182680"
  },
  {
    "start": "3179000",
    "end": "3219000"
  },
  {
    "text": "doctor string does what about this call here though",
    "start": "3182680",
    "end": "3188000"
  },
  {
    "text": "there are lots and lots of overloads of console. right line there's bite in Long",
    "start": "3188000",
    "end": "3193319"
  },
  {
    "text": "object string etc etc and if there's happens to be a",
    "start": "3193319",
    "end": "3200200"
  },
  {
    "text": "conversion from the to int then that ends up being more",
    "start": "3200200",
    "end": "3207440"
  },
  {
    "text": "specific than the uh implicit conversion the reference conversion from V to",
    "start": "3207440",
    "end": "3216520"
  },
  {
    "text": "object so this implicit conversion here gets",
    "start": "3216880",
    "end": "3221960"
  },
  {
    "start": "3219000",
    "end": "3239000"
  },
  {
    "text": "called when we if we stick a break point on here we'll see it",
    "start": "3221960",
    "end": "3229200"
  },
  {
    "text": "uh I'm okay fine I wanted to be in release",
    "start": "3229200",
    "end": "3234400"
  },
  {
    "text": "mode for the performance things obviously um right so we'll see here it's being",
    "start": "3234400",
    "end": "3242359"
  },
  {
    "start": "3239000",
    "end": "3264000"
  },
  {
    "text": "called the the integer conversion is being called directly oh it's sorry it's",
    "start": "3242359",
    "end": "3247880"
  },
  {
    "text": "also being called in order to make the limit work uh but it's now the second",
    "start": "3247880",
    "end": "3255480"
  },
  {
    "text": "time",
    "start": "3255480",
    "end": "3258480"
  },
  {
    "text": "hello it's possible I've given you entirely the wrong explanation let's have a look at the overload no it it is",
    "start": "3261000",
    "end": "3266880"
  },
  {
    "start": "3264000",
    "end": "3279000"
  },
  {
    "text": "calling the overload with x value my guess is that um for some bizarre",
    "start": "3266880",
    "end": "3274119"
  },
  {
    "text": "reason uh when it's evaluating the implicit",
    "start": "3274119",
    "end": "3279839"
  },
  {
    "text": "conversion sometimes Visual Studio will say yep you definitely want to stop on those things and sometimes it will say I",
    "start": "3279839",
    "end": "3286480"
  },
  {
    "text": "was doing it in a a different format but it definitely is using uh this conversion let's just prove that by if",
    "start": "3286480",
    "end": "3293760"
  },
  {
    "text": "we make that return number time 2 so we'll",
    "start": "3293760",
    "end": "3299000"
  },
  {
    "text": "see half as many numbers now but we should see not you the the digit",
    "start": "3299000",
    "end": "3304960"
  },
  {
    "text": "02 4 and the the words 012 I",
    "start": "3304960",
    "end": "3311680"
  },
  {
    "text": "think",
    "start": "3311680",
    "end": "3314680"
  },
  {
    "text": "026 I have no idea why that's happening",
    "start": "3322119",
    "end": "3328078"
  },
  {
    "text": "oh yeah yes I've got it anyone else got",
    "start": "3328760",
    "end": "3334599"
  },
  {
    "text": "it yep Oh you're saying I'm nearly out of time yes two minutes um but someone",
    "start": "3334599",
    "end": "3340680"
  },
  {
    "text": "else it sounded like someone shout loudly six and more than five y um but",
    "start": "3340680",
    "end": "3346119"
  },
  {
    "text": "that's fine we only have the value uh three at that point so it I agree with",
    "start": "3346119",
    "end": "3352160"
  },
  {
    "text": "when it's stopping but why is it going 026 instead of 024",
    "start": "3352160",
    "end": "3357319"
  },
  {
    "text": "any thoughts any thoughts come on yeah but but why did we miss out so",
    "start": "3357319",
    "end": "3364640"
  },
  {
    "text": "let me show you again right I would I had expected Zer",
    "start": "3364640",
    "end": "3370079"
  },
  {
    "text": "one and two but it turns out the this implicit conversion and this implicit",
    "start": "3370079",
    "end": "3376079"
  },
  {
    "text": "conversion are happening all over the place so it's happening there in order",
    "start": "3376079",
    "end": "3382000"
  },
  {
    "text": "to compare it but it's also really importantly happening there we're converting we're taking zero and",
    "start": "3382000",
    "end": "3389000"
  },
  {
    "text": "doubling it and getting zero and adding one to it and setting that as the number fine that's the first iteration of the",
    "start": "3389000",
    "end": "3394400"
  },
  {
    "text": "loop on the second iteration of the loop the increment is saying oh well your",
    "start": "3394400",
    "end": "3399480"
  },
  {
    "text": "underlying value is one I'll double that and return that as two plus plus gets",
    "start": "3399480",
    "end": "3404599"
  },
  {
    "text": "you to three set that as the value again oh we've got three um so that teaches me",
    "start": "3404599",
    "end": "3411799"
  },
  {
    "text": "not to do really really crazy stuff in there I'm going to undo that before I forget because it would be terrible to",
    "start": "3411799",
    "end": "3418799"
  },
  {
    "text": "okay there we go um so all of that was to talk about the implicit conversion is",
    "start": "3418799",
    "end": "3423920"
  },
  {
    "text": "being used in there so you might think that a reference conversion which is something that is uh does not change the",
    "start": "3423920",
    "end": "3431000"
  },
  {
    "text": "representation at all is always more specific than anything else but no it turns out that if you've got an implicit",
    "start": "3431000",
    "end": "3437520"
  },
  {
    "text": "conversion certainly to a value type um I'd have to look at the exact details of the spec as to what ends up being",
    "start": "3437520",
    "end": "3444200"
  },
  {
    "text": "counting as a better conversion that's better than conversion to object okay I",
    "start": "3444200",
    "end": "3450000"
  },
  {
    "text": "have three minutes left um let's find",
    "start": "3450000",
    "end": "3455520"
  },
  {
    "text": "what what else was on the actual agenda okay null conditional very",
    "start": "3455520",
    "end": "3461520"
  },
  {
    "text": "briefly I'll only have time to show one of these um no no no",
    "start": "3461520",
    "end": "3470039"
  },
  {
    "text": "logging logging can be uh nice or annoying you don't want to evaluate um a",
    "start": "3470039",
    "end": "3479400"
  },
  {
    "start": "3474000",
    "end": "3600000"
  },
  {
    "text": "detailed error message unless you're going to log it on the other hand you don't want to log a rubbish error",
    "start": "3479400",
    "end": "3485920"
  },
  {
    "text": "message because you couldn't be bothered to do the the right um the right logging",
    "start": "3485920",
    "end": "3492599"
  },
  {
    "text": "and interpolated strings are a lovely way of putting all kinds of information",
    "start": "3492599",
    "end": "3498319"
  },
  {
    "text": "in an error message however if you just did the normal um if I had supposing",
    "start": "3498319",
    "end": "3505520"
  },
  {
    "text": "this compile CU it probably won't logger.log",
    "start": "3505520",
    "end": "3509599"
  },
  {
    "text": "um log level dbug that okay suppose that were",
    "start": "3511440",
    "end": "3518559"
  },
  {
    "text": "even slightly valid in an obvious way then the fact that we're using",
    "start": "3518559",
    "end": "3524240"
  },
  {
    "text": "formattable string or imagine that we had an overload taking formattable string would not help us we would still",
    "start": "3524240",
    "end": "3531119"
  },
  {
    "text": "be evaluating this and we'd still be evaluating that we wouldn't be doing the string for formatting ahead of time so",
    "start": "3531119",
    "end": "3537240"
  },
  {
    "text": "we could save some code there but we'd still be evaluating stuff and we really don't want to evaluate stuff",
    "start": "3537240",
    "end": "3545680"
  },
  {
    "text": "however the null conditional operator so uh yes um can come to our rescue here if",
    "start": "3545680",
    "end": "3553160"
  },
  {
    "text": "you write an API which relies on people being able to use the null conditional operator you can basically turn an if",
    "start": "3553160",
    "end": "3560640"
  },
  {
    "text": "block into a single statement so normally the way of avoiding things is to say if",
    "start": "3560640",
    "end": "3566640"
  },
  {
    "text": "logger do is debug enabled logger do debug and then",
    "start": "3566640",
    "end": "3575079"
  },
  {
    "text": "stuff or you write things um and pass the arguments separately and let it do",
    "start": "3575079",
    "end": "3581200"
  },
  {
    "text": "the string formatting and neither of those are nice because they're not as readable if on the other hand you have a",
    "start": "3581200",
    "end": "3589400"
  },
  {
    "text": "logger as I've got here with debug and info properties which return either",
    "start": "3589400",
    "end": "3596079"
  },
  {
    "text": "something that will really do logging or null if that log level is not",
    "start": "3596079",
    "end": "3602000"
  },
  {
    "text": "enabled if we say I don't know what the the Deb the default level is for this",
    "start": "3602000",
    "end": "3608280"
  },
  {
    "text": "well I've kind of hardcoded it but you can imagine that it would be based on configuration so debug is going to",
    "start": "3608280",
    "end": "3613720"
  },
  {
    "text": "return null info and warn will return actual active",
    "start": "3613720",
    "end": "3620760"
  },
  {
    "text": "loggers which means if I very quickly I know I'm out of time I'm so nearly there",
    "start": "3620880",
    "end": "3626520"
  },
  {
    "text": "wrong one wrong one uh I'll just run okay if I run",
    "start": "3626520",
    "end": "3633520"
  },
  {
    "text": "logging demo it will log the info that I",
    "start": "3633520",
    "end": "3638599"
  },
  {
    "text": "had but not the debug in I believe the most readable code that you could have",
    "start": "3638599",
    "end": "3645359"
  },
  {
    "text": "that never evaluates the the log string unless you want it to that's another one that's sort of on",
    "start": "3645359",
    "end": "3652319"
  },
  {
    "text": "the cusp of is that abuse or not it's really relying on people being happy to use the null conditional operator you",
    "start": "3652319",
    "end": "3658520"
  },
  {
    "text": "don't want to use it without um however it's just so",
    "start": "3658520",
    "end": "3665559"
  },
  {
    "text": "pretty and on that note uh I hope you've enjoyed it uh please go away and look at",
    "start": "3665559",
    "end": "3671119"
  },
  {
    "text": "the code and then invent your own abuses because I can tell you this is so so much fun to do it really is see if you",
    "start": "3671119",
    "end": "3678599"
  },
  {
    "text": "can fool your colleagues give them clever code that looks beguiling but is awful or that looks straightforward but",
    "start": "3678599",
    "end": "3685960"
  },
  {
    "text": "actually does gruesome things with VAR or you know dynamic is only a contextual keyword I've got a whole other example",
    "start": "3685960",
    "end": "3692880"
  },
  {
    "text": "that deal deals with that anyway enjoy the rest of NDC I'm John Ski thank you [Applause]",
    "start": "3692880",
    "end": "3700969"
  }
]