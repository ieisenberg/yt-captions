[
  {
    "text": "hello everyone welcome to my talk about",
    "start": "1860",
    "end": "6960"
  },
  {
    "text": "what will be upcoming in C plus plus 23",
    "start": "6960",
    "end": "12740"
  },
  {
    "text": "I will tell you a little bit about the plans that had been in the committee about what we would like to see in C",
    "start": "13679",
    "end": "20640"
  },
  {
    "text": "plus plus 23 and what compiler features actually made",
    "start": "20640",
    "end": "26160"
  },
  {
    "text": "it in so far and what library features are voted in as of today",
    "start": "26160",
    "end": "33540"
  },
  {
    "text": "this doesn't mean it will really end up in C plus plus 23 the final vote is",
    "start": "33540",
    "end": "40140"
  },
  {
    "text": "still not done yet but we pretty much know what C plus plus 23",
    "start": "40140",
    "end": "47460"
  },
  {
    "text": "would look like so I'm an electrically engineer I'm doing",
    "start": "47460",
    "end": "53460"
  },
  {
    "text": "software development for quite some time and I'm also kind of a part of DC plus 23 C plus plus",
    "start": "53460",
    "end": "61800"
  },
  {
    "text": "language committee this talk is meant to be highly",
    "start": "61800",
    "end": "67680"
  },
  {
    "text": "interactive it depends upon you what you will be",
    "start": "67680",
    "end": "72840"
  },
  {
    "text": "learn learning and will be seeing in his presentation C plus plus",
    "start": "72840",
    "end": "79740"
  },
  {
    "text": "23 is not a minor version of C plus plus as it turns out it has lots and lots of",
    "start": "79740",
    "end": "86820"
  },
  {
    "text": "new features the material is probably worth four hours of talk",
    "start": "86820",
    "end": "92159"
  },
  {
    "text": "I have only 60 minutes so it's totally up to you",
    "start": "92159",
    "end": "98060"
  },
  {
    "text": "so what was the plan about C plus plus 23",
    "start": "98700",
    "end": "103939"
  },
  {
    "text": "there has been a paper about what should be in there and",
    "start": "104400",
    "end": "111000"
  },
  {
    "text": "yeah the idea was Library support for core routines it was",
    "start": "111000",
    "end": "118560"
  },
  {
    "text": "a modular standard Library it was executive and it was networking",
    "start": "118560",
    "end": "124079"
  },
  {
    "text": "these were the most important features that had been lacking",
    "start": "124079",
    "end": "129660"
  },
  {
    "text": "from C plus plus 20. and",
    "start": "129660",
    "end": "135540"
  },
  {
    "text": "at least we should make a little bit progress on reflection pattern matching and contracts",
    "start": "135540",
    "end": "141720"
  },
  {
    "text": "you probably know contracts has has been in C plus plus 20 but it didn't",
    "start": "141720",
    "end": "148920"
  },
  {
    "text": "make it in the end so let's do it in the next round",
    "start": "148920",
    "end": "154020"
  },
  {
    "text": "and there have been a lot of missing features in C plus plus 20 because C plus plus 20 was so large we couldn't",
    "start": "154020",
    "end": "161280"
  },
  {
    "text": "finalize everything in time so we had a lot of backlog in C plus 20 maybe we can",
    "start": "161280",
    "end": "169440"
  },
  {
    "text": "clean up all our backlog this",
    "start": "169440",
    "end": "175379"
  },
  {
    "text": "was at February 2020 in Prague",
    "start": "175379",
    "end": "181620"
  },
  {
    "text": "when we were about to finalize C plus plus",
    "start": "181620",
    "end": "186900"
  },
  {
    "text": "20. lots of people I'm somewhere in the crowd",
    "start": "186900",
    "end": "192480"
  },
  {
    "text": "and this is what came afterwards",
    "start": "192480",
    "end": "197300"
  },
  {
    "text": "people were totally separate from each other working on the standard is",
    "start": "199920",
    "end": "206340"
  },
  {
    "text": "not an easy task and doing it in a pandemic is even more challenging",
    "start": "206340",
    "end": "212700"
  },
  {
    "text": "so let's see what actually is in the envelope right now",
    "start": "212700",
    "end": "220040"
  },
  {
    "text": "so we plan for three similarious 23 once again Library support for core routines",
    "start": "220620",
    "end": "226739"
  },
  {
    "text": "yes we did it actually it's more like quote on third they did",
    "start": "226739",
    "end": "234500"
  },
  {
    "text": "we have a modular standard Library this is also done now",
    "start": "234959",
    "end": "240799"
  },
  {
    "text": "executors yeah we made some progress made of lots of discussion about",
    "start": "240799",
    "end": "246840"
  },
  {
    "text": "executors but nothing is finalized networking just the same but at least we",
    "start": "246840",
    "end": "253200"
  },
  {
    "text": "have something since quite some time with the networking TS and there's no",
    "start": "253200",
    "end": "258299"
  },
  {
    "text": "progress any further than that reflection here we have really good",
    "start": "258299",
    "end": "263580"
  },
  {
    "text": "proportions on reflection but nothing is in a final stage that he",
    "start": "263580",
    "end": "270060"
  },
  {
    "text": "could say that it's maybe in 26 I'm I'm not too",
    "start": "270060",
    "end": "275940"
  },
  {
    "text": "optimistic about it reflection contracts nothing is in there",
    "start": "275940",
    "end": "283500"
  },
  {
    "text": "and so C plus percentage is also mostly",
    "start": "283500",
    "end": "288960"
  },
  {
    "text": "completed but not at the point where we wanted to be you know",
    "start": "288960",
    "end": "295460"
  },
  {
    "text": "so let's talk about core language features if some really interesting major",
    "start": "295500",
    "end": "302940"
  },
  {
    "text": "features like deducing this also known under the term of explicit object",
    "start": "302940",
    "end": "308160"
  },
  {
    "text": "parameters if a multi-dimensional subscript operator now",
    "start": "308160",
    "end": "313979"
  },
  {
    "text": "interestingly we have Lambda enhancements what I really don't like",
    "start": "313979",
    "end": "319919"
  },
  {
    "text": "about Lambda Expressions this is so much ceremony we can get rid of a part of",
    "start": "319919",
    "end": "325620"
  },
  {
    "text": "this ceremony we have a consistent scope in there and we finally have also",
    "start": "325620",
    "end": "331080"
  },
  {
    "text": "attributes with Lambda expressions we also did something on uh increasing",
    "start": "331080",
    "end": "339600"
  },
  {
    "text": "the portability of C plus plus even as Robert was telling just an hour ago C",
    "start": "339600",
    "end": "346139"
  },
  {
    "text": "plus plus is not about portability we I think portability is is important",
    "start": "346139",
    "end": "353280"
  },
  {
    "text": "so now the identifiers follow and have to follow the Unicode standard Annex 31",
    "start": "353280",
    "end": "361320"
  },
  {
    "text": "also a work of quarantor I really highly appreciate it",
    "start": "361320",
    "end": "367100"
  },
  {
    "text": "and also the encoding kind of stuff there's much work done in the study group 16",
    "start": "367100",
    "end": "373740"
  },
  {
    "text": "about all these encoding kind of things we have a bunch of minor new features",
    "start": "373740",
    "end": "379020"
  },
  {
    "text": "like the size T suffix that makes our for",
    "start": "379020",
    "end": "384240"
  },
  {
    "text": "Loops now much safer if we actually going to be using it we have a few",
    "start": "384240",
    "end": "391220"
  },
  {
    "text": "lesser restrictions in contact with functions maybe in the next round we got",
    "start": "391220",
    "end": "396600"
  },
  {
    "text": "we may get rid of all of them and I hope we also will get rid of const",
    "start": "396600",
    "end": "402840"
  },
  {
    "text": "expert at all in a future standard of C plus plus it should be default",
    "start": "402840",
    "end": "410419"
  },
  {
    "text": "and he even did something in the free processor",
    "start": "411060",
    "end": "417479"
  },
  {
    "text": "even if you want to get rid of the preprocessor then some a lot of things that felt more",
    "start": "417479",
    "end": "424620"
  },
  {
    "text": "like bug likes fetus like narrowing contextual conversions to Bool it makes",
    "start": "424620",
    "end": "429660"
  },
  {
    "text": "your life a little bit more easier and we actually did remove something",
    "start": "429660",
    "end": "436520"
  },
  {
    "text": "so what about image and new features and the com implementation status on the",
    "start": "437400",
    "end": "442860"
  },
  {
    "text": "rights column you see in alphabetical order clang GCC and msvc and",
    "start": "442860",
    "end": "450419"
  },
  {
    "text": "the current status of implementation they're doing this this is probably the",
    "start": "450419",
    "end": "456960"
  },
  {
    "text": "the signature feature of C plus plus 23 is implemented in msvc you can use it",
    "start": "456960",
    "end": "463020"
  },
  {
    "text": "today with current compilers and clang and Jesus he is catching up",
    "start": "463020",
    "end": "470699"
  },
  {
    "text": "on the other hand multi-dimensional subscript operators if constable and dedicate copy in the",
    "start": "470699",
    "end": "478319"
  },
  {
    "text": "language is only implemented in GCC and clang and msvc is not that far ahead in",
    "start": "478319",
    "end": "485759"
  },
  {
    "text": "the implementation and there's also a new kind of thing the extended floating Point types that may",
    "start": "485759",
    "end": "491940"
  },
  {
    "text": "be interesting to all those people more in scientific programming",
    "start": "491940",
    "end": "496979"
  },
  {
    "text": "um this is a very recent addition to the C plus plus 20 free standard",
    "start": "496979",
    "end": "503879"
  },
  {
    "text": "no compiler has it yet this is something like the B float 16 type that you may",
    "start": "503879",
    "end": "509639"
  },
  {
    "text": "heard about neural network inferencing and this kind of stuff and actually",
    "start": "509639",
    "end": "514740"
  },
  {
    "text": "giving floating points to the exact number of bits that they should be",
    "start": "514740",
    "end": "520279"
  },
  {
    "text": "represented with up to float 128 as far",
    "start": "520279",
    "end": "525779"
  },
  {
    "text": "as I know from 16 to 128 is this is quite a future",
    "start": "525779",
    "end": "531060"
  },
  {
    "text": "if you're in the scientific programming or signal processing on this kind of stuff",
    "start": "531060",
    "end": "537120"
  },
  {
    "text": "so let's start with the first major feature deducing this in C plus plus 20",
    "start": "537120",
    "end": "545360"
  },
  {
    "text": "many of these um member functions that observe values",
    "start": "547200",
    "end": "554040"
  },
  {
    "text": "for example operator error or operator star need to have a lot of overloads",
    "start": "554040",
    "end": "562140"
  },
  {
    "text": "to be complete you have to deal with consciousness",
    "start": "562140",
    "end": "568140"
  },
  {
    "text": "volatile and probably also",
    "start": "568140",
    "end": "573770"
  },
  {
    "text": "[Music] um reference qualification all L value reference qualification r value",
    "start": "573770",
    "end": "579600"
  },
  {
    "text": "reference qualification if you count all of them together you're at 12",
    "start": "579600",
    "end": "586019"
  },
  {
    "text": "overloads you have to implement this is no fun and most people are lazy at least I am",
    "start": "586019",
    "end": "594720"
  },
  {
    "text": "and usually I don't Implement all of them but now in C plus 23",
    "start": "594720",
    "end": "602160"
  },
  {
    "text": "we have the opportunity to explicitly get access",
    "start": "602160",
    "end": "609540"
  },
  {
    "text": "to the object parameter up to 20",
    "start": "609540",
    "end": "615480"
  },
  {
    "text": "it has been a hidden parameter it's called this",
    "start": "615480",
    "end": "620820"
  },
  {
    "text": "because it's hidden you have no control over it you can't do anything other than use it and it has",
    "start": "620820",
    "end": "628140"
  },
  {
    "text": "to be a pointer pointer is just a mistake it never has been meant to be appointed had meant to be a reference",
    "start": "628140",
    "end": "634440"
  },
  {
    "text": "but at the time the device pointer came into the language C plus plus had no references at the",
    "start": "634440",
    "end": "641580"
  },
  {
    "text": "time this is the reason why we have this pointer and yeah but now you can declare",
    "start": "641580",
    "end": "648899"
  },
  {
    "text": "your object parameter just as you like to maybe you say you wanted",
    "start": "648899",
    "end": "657420"
  },
  {
    "text": "completely deduced then you say Titan himself and call this object parameter",
    "start": "657420",
    "end": "665519"
  },
  {
    "text": "um here as a forwarding reference and now",
    "start": "665519",
    "end": "673680"
  },
  {
    "text": "the value categories over is that used you don't need any more overloads",
    "start": "673680",
    "end": "679019"
  },
  {
    "text": "and you give it actually a type",
    "start": "679019",
    "end": "684060"
  },
  {
    "text": "that can be deduced you can also give it an explicit type and now with one single",
    "start": "684060",
    "end": "690720"
  },
  {
    "text": "line you have access to all the overloads that you have been forced to implement before",
    "start": "690720",
    "end": "699740"
  },
  {
    "text": "you see it here in an optional the typical implementation that is",
    "start": "699779",
    "end": "705300"
  },
  {
    "text": "only dealing with Constance and reference qualification you will see",
    "start": "705300",
    "end": "713100"
  },
  {
    "text": "this more or less identical implementations of all these various overloads here",
    "start": "713100",
    "end": "720480"
  },
  {
    "text": "tedious and error-prone many programmers just copy it over and",
    "start": "720480",
    "end": "726360"
  },
  {
    "text": "forget something and even better",
    "start": "726360",
    "end": "733980"
  },
  {
    "text": "you no longer have to use them as a reference type you can make it a",
    "start": "733980",
    "end": "739440"
  },
  {
    "text": "value type so for example if you have a less than operator",
    "start": "739440",
    "end": "745980"
  },
  {
    "text": "uh the less than a function object",
    "start": "745980",
    "end": "751140"
  },
  {
    "text": "then you can declare the function object parameter as",
    "start": "751140",
    "end": "757980"
  },
  {
    "text": "unnamed so the compiler knows it's not used here you only dealing with the additional",
    "start": "757980",
    "end": "766940"
  },
  {
    "text": "left hand side and right hand side parameter in this operator call function",
    "start": "766940",
    "end": "774120"
  },
  {
    "text": "and now you don't have to have this Hidden Object the",
    "start": "774120",
    "end": "779339"
  },
  {
    "text": "compiler has to create an object somewhere just to form a",
    "start": "779339",
    "end": "785700"
  },
  {
    "text": "reference to it and no longer you have to do that and this is an um an optimization opportunity for the",
    "start": "785700",
    "end": "792959"
  },
  {
    "text": "compiler even more so if you want to",
    "start": "792959",
    "end": "800820"
  },
  {
    "text": "um do something like mix-ins you have certain types of functionality",
    "start": "800820",
    "end": "807540"
  },
  {
    "text": "that you want to inject into your classes many times you usually use it by",
    "start": "807540",
    "end": "814620"
  },
  {
    "text": "implementing it with the crtp pattern you make it this",
    "start": "814620",
    "end": "819720"
  },
  {
    "text": "this class in this particular case I'm sorry",
    "start": "819720",
    "end": "825860"
  },
  {
    "text": "postfix increment what do you want to add to your arithmetic classes and you",
    "start": "825860",
    "end": "832380"
  },
  {
    "text": "implemented only once as a template and derived from it using the crtp pattern",
    "start": "832380",
    "end": "840000"
  },
  {
    "text": "the spoilerplate implementing this kind of thing is really",
    "start": "840000",
    "end": "846779"
  },
  {
    "text": "difficult to understand in particular for Less experienced programmers and",
    "start": "846779",
    "end": "853380"
  },
  {
    "text": "it's really not how you want to express this",
    "start": "853380",
    "end": "859740"
  },
  {
    "text": "kind of idea in C plus 23 you can make it a templated",
    "start": "859740",
    "end": "867320"
  },
  {
    "text": "operator plus plus even did used object type",
    "start": "867320",
    "end": "873600"
  },
  {
    "text": "this gives the opportunity that when you derive your class from this Base Class",
    "start": "873600",
    "end": "881699"
  },
  {
    "text": "here which provides the functionality and the implementation of it the compiler will figure out what the",
    "start": "881699",
    "end": "889800"
  },
  {
    "text": "actual derived type is so you no longer have to use all this boilerplate in the upper example here",
    "start": "889800",
    "end": "898560"
  },
  {
    "text": "so this is the the um the intent that you want to express here",
    "start": "898560",
    "end": "905940"
  },
  {
    "text": "is much more clearly formulated and it's always correct",
    "start": "905940",
    "end": "911180"
  },
  {
    "text": "the next thing probably also interesting for scientific operations is the",
    "start": "914639",
    "end": "920899"
  },
  {
    "text": "multi-dimensional subscript operator also a work of current time",
    "start": "920899",
    "end": "926459"
  },
  {
    "text": "foreign",
    "start": "926459",
    "end": "929240"
  },
  {
    "text": "we could index with only one",
    "start": "932579",
    "end": "939740"
  },
  {
    "text": "value as in an indexing parameter so",
    "start": "940320",
    "end": "945420"
  },
  {
    "text": "people resorted resorted to using the function call Operator because you have",
    "start": "945420",
    "end": "950699"
  },
  {
    "text": "as many parameters as you like to but the function call is not actually what",
    "start": "950699",
    "end": "956339"
  },
  {
    "text": "you want to uh want to use here this is not a function called the subscripting is something",
    "start": "956339",
    "end": "961680"
  },
  {
    "text": "completely different and in 20 we got rid of or actually we",
    "start": "961680",
    "end": "969060"
  },
  {
    "text": "we deprecated the comma operator within the angle at the square brackets so that",
    "start": "969060",
    "end": "975540"
  },
  {
    "text": "you can re-grab our syntax syntactic landscape and use",
    "start": "975540",
    "end": "984380"
  },
  {
    "text": "multiple values into these square brackets with a any number of arguments as we",
    "start": "984380",
    "end": "993420"
  },
  {
    "text": "like separated by a comma Now so we actually can express a",
    "start": "993420",
    "end": "999320"
  },
  {
    "text": "multi-dimensional subscripting with the correct operator type and as many arguments as we want to",
    "start": "999320",
    "end": "1007839"
  },
  {
    "text": "so instead of the function call Operator we do it like this and are done",
    "start": "1008000",
    "end": "1015820"
  },
  {
    "text": "if constable yeah this is more interesting for people who do constant compile time programming",
    "start": "1015820",
    "end": "1025660"
  },
  {
    "text": "um who sees the problem here",
    "start": "1026600",
    "end": "1032058"
  },
  {
    "text": "is anybody who sees the error in this example",
    "start": "1032059",
    "end": "1037900"
  },
  {
    "text": "yeah you know it nobody",
    "start": "1038120",
    "end": "1045640"
  },
  {
    "text": "we have ifcon's expert and a",
    "start": "1047600",
    "end": "1053240"
  },
  {
    "text": "function from the standard Library which is asking the compiler is this",
    "start": "1053240",
    "end": "1058760"
  },
  {
    "text": "expression here evaluated at con at compile time",
    "start": "1058760",
    "end": "1064640"
  },
  {
    "text": "of course it is we said it so if once the expert is a",
    "start": "1064640",
    "end": "1070280"
  },
  {
    "text": "compiled Timex construct the answer to this question is always",
    "start": "1070280",
    "end": "1075500"
  },
  {
    "text": "true all the optimized implementation for runtime will never be executed",
    "start": "1075500",
    "end": "1083380"
  },
  {
    "text": "this is a trap now we have",
    "start": "1086480",
    "end": "1093200"
  },
  {
    "text": "if const evil",
    "start": "1093200",
    "end": "1096760"
  },
  {
    "text": "we can now say that",
    "start": "1101240",
    "end": "1106960"
  },
  {
    "text": "that if you want to call a const evil",
    "start": "1107539",
    "end": "1112880"
  },
  {
    "text": "which is an immediate function which access exists only at compile time",
    "start": "1112880",
    "end": "1119740"
  },
  {
    "text": "can be called",
    "start": "1120260",
    "end": "1123340"
  },
  {
    "text": "no no okay this is a little bit um you can call Immediate functions from an",
    "start": "1125600",
    "end": "1131960"
  },
  {
    "text": "immediate context this is what I'm saying here in the in the middle part of the of the code examples here you can",
    "start": "1131960",
    "end": "1139760"
  },
  {
    "text": "call the function f from the function H because you're already in a in an immediate function context but you",
    "start": "1139760",
    "end": "1147260"
  },
  {
    "text": "cannot call it here because you are not in an immediate function context which means",
    "start": "1147260",
    "end": "1153080"
  },
  {
    "text": "um the the um question if you are actually",
    "start": "1153080",
    "end": "1159700"
  },
  {
    "text": "executing this code at compile time",
    "start": "1159700",
    "end": "1165159"
  },
  {
    "text": "cannot be determined aesthetically and this means",
    "start": "1165820",
    "end": "1172700"
  },
  {
    "text": "the argument e that's coming in here",
    "start": "1172700",
    "end": "1178520"
  },
  {
    "text": "the um it's difficult to explain if you're not in the in the in the committee here",
    "start": "1178520",
    "end": "1186200"
  },
  {
    "text": "um the origin of the eye must come from a a",
    "start": "1186200",
    "end": "1194559"
  },
  {
    "text": "constant value known at compile time but this function doesn't know that here it",
    "start": "1194559",
    "end": "1202400"
  },
  {
    "text": "knows it is executed at compile time but it doesn't know if the parameter I",
    "start": "1202400",
    "end": "1208520"
  },
  {
    "text": "that's used here in the in the function call is actually coming from a",
    "start": "1208520",
    "end": "1215140"
  },
  {
    "text": "constant that is evaluated and available compile time so",
    "start": "1215140",
    "end": "1222260"
  },
  {
    "text": "this is illegal in C plus plus 20 you cannot express it this way",
    "start": "1222260",
    "end": "1227419"
  },
  {
    "text": "you're not in an immediate function context you cannot call Immediate functions here in C plus 23 we have a new if",
    "start": "1227419",
    "end": "1236720"
  },
  {
    "text": "um if construct this is called if const eval this has no",
    "start": "1236720",
    "end": "1242539"
  },
  {
    "text": "condition there it's just saying okay compiler if this code is",
    "start": "1242539",
    "end": "1251620"
  },
  {
    "text": "manifestly executed at compile time you know it",
    "start": "1251620",
    "end": "1258159"
  },
  {
    "text": "you know can say okay this function call to F is now valid",
    "start": "1258200",
    "end": "1267140"
  },
  {
    "text": "because the call to T has to come with an argument that is",
    "start": "1267140",
    "end": "1272539"
  },
  {
    "text": "constantly evaluated at compile time",
    "start": "1272539",
    "end": "1277700"
  },
  {
    "text": "the difference is a little bit hard to get around but it's actually",
    "start": "1277700",
    "end": "1284620"
  },
  {
    "text": "really really I have to go back a little bit um this is really important and this is",
    "start": "1284720",
    "end": "1290900"
  },
  {
    "text": "one of the major additions to the formatting Library where you can now",
    "start": "1290900",
    "end": "1296720"
  },
  {
    "text": "um formulates that the the",
    "start": "1296720",
    "end": "1302120"
  },
  {
    "text": "um deformatting expression and",
    "start": "1302120",
    "end": "1307880"
  },
  {
    "text": "these parameters here are actually all constant and come from the compile time and now you can validate your format",
    "start": "1307880",
    "end": "1314900"
  },
  {
    "text": "strings at compile time and this is the one of the reasons why you can do that now",
    "start": "1314900",
    "end": "1321159"
  },
  {
    "text": "the next one um",
    "start": "1321159",
    "end": "1326080"
  },
  {
    "text": "it's doesn't sound that much but if you look at",
    "start": "1326360",
    "end": "1334220"
  },
  {
    "text": "the first three lines here you want to erase all members",
    "start": "1334220",
    "end": "1341120"
  },
  {
    "text": "in the collection here that have the same value as the first",
    "start": "1341120",
    "end": "1347299"
  },
  {
    "text": "member in this collection does anybody see the problem here",
    "start": "1347299",
    "end": "1355299"
  },
  {
    "text": "okay nobody if you ask for the",
    "start": "1356780",
    "end": "1363980"
  },
  {
    "text": "first element in this collection you get a reference",
    "start": "1363980",
    "end": "1368500"
  },
  {
    "text": "and erase takes a reference so at each round of the erase Loop",
    "start": "1369919",
    "end": "1378460"
  },
  {
    "text": "it sees a different first element if you happen to erase something",
    "start": "1380059",
    "end": "1387760"
  },
  {
    "text": "so the outcome is completely undefined",
    "start": "1388220",
    "end": "1393700"
  },
  {
    "text": "what you have to do you need to take a copy",
    "start": "1393860",
    "end": "1400100"
  },
  {
    "text": "and put that in SD value that you want to erase from your container",
    "start": "1400100",
    "end": "1406000"
  },
  {
    "text": "in C plus 23 now you can say explicitly give me a copy of the first",
    "start": "1406220",
    "end": "1413000"
  },
  {
    "text": "one snpr value without knowing the type this is the the",
    "start": "1413000",
    "end": "1418880"
  },
  {
    "text": "key takeaway from this functionality here if you want to do it manually",
    "start": "1418880",
    "end": "1426080"
  },
  {
    "text": "this is the correct implementation if you want to know the exact type of the first element in your container",
    "start": "1426080",
    "end": "1435039"
  },
  {
    "text": "this comes in probably very difficult situation there you have just wanted to",
    "start": "1439360",
    "end": "1446659"
  },
  {
    "text": "do something like In-Place operations and pass them on after the",
    "start": "1446659",
    "end": "1452240"
  },
  {
    "text": "transformation into your functions um",
    "start": "1452240",
    "end": "1457460"
  },
  {
    "text": "now you can do these kinds of things much more efficiently because these PR",
    "start": "1457460",
    "end": "1463039"
  },
  {
    "text": "values have also the the ability just to Decay into the the copying of the of the",
    "start": "1463039",
    "end": "1470179"
  },
  {
    "text": "function parameter and so you get Best of Both Worlds here",
    "start": "1470179",
    "end": "1476419"
  },
  {
    "text": "this is designs behind it maybe it's it's a little bit less interesting if",
    "start": "1476419",
    "end": "1481940"
  },
  {
    "text": "this was one of the the missing pieces in up to C plus plus 20 now you have it",
    "start": "1481940",
    "end": "1488860"
  },
  {
    "text": "this extended floating Point types I've been talking before up until C plus plus 20 we had double",
    "start": "1489159",
    "end": "1497179"
  },
  {
    "text": "float and long double on msvc you didn't even have long double",
    "start": "1497179",
    "end": "1502640"
  },
  {
    "text": "and now you can have float 16t up to float 128",
    "start": "1502640",
    "end": "1507919"
  },
  {
    "text": "T and V float 16 but these are not mandatory please keep",
    "start": "1507919",
    "end": "1514460"
  },
  {
    "text": "this in mind",
    "start": "1514460",
    "end": "1517000"
  },
  {
    "text": "Lambda into X and enhancements well",
    "start": "1519799",
    "end": "1525679"
  },
  {
    "text": "let's look at these examples here",
    "start": "1528140",
    "end": "1533860"
  },
  {
    "text": "these three examples here return an INT",
    "start": "1537260",
    "end": "1543140"
  },
  {
    "text": "and this int is seduced from the return value that's the J in",
    "start": "1543140",
    "end": "1549260"
  },
  {
    "text": "here the J is an INT because we're capturing the J and initializing it with a zero",
    "start": "1549260",
    "end": "1555919"
  },
  {
    "text": "literal you see in some cases you have to put the",
    "start": "1555919",
    "end": "1563360"
  },
  {
    "text": "parenthesis in then if you want it mutable you say mutable",
    "start": "1563360",
    "end": "1570039"
  },
  {
    "text": "if you just you have to say mutable because by default it's const so you can't increment it",
    "start": "1570140",
    "end": "1578019"
  },
  {
    "text": "but if you want to increment it and won't",
    "start": "1579679",
    "end": "1585620"
  },
  {
    "text": "don't want to give it a parameter this is invalid syntax in C plus 20.",
    "start": "1585620",
    "end": "1592279"
  },
  {
    "text": "as soon as you qualified with mutable you have to put the parenthesis in here",
    "start": "1592279",
    "end": "1597740"
  },
  {
    "text": "even if you don't use any of the parameters and",
    "start": "1597740",
    "end": "1603140"
  },
  {
    "text": "maybe you want to make sure that you have certain attributes like no discard this is a made up example this is not",
    "start": "1603140",
    "end": "1609980"
  },
  {
    "text": "valid syntax you had no chance to express this",
    "start": "1609980",
    "end": "1615158"
  },
  {
    "text": "now",
    "start": "1616039",
    "end": "1618700"
  },
  {
    "text": "if you explicitly say what the return type is supposed to be you no longer",
    "start": "1623840",
    "end": "1629720"
  },
  {
    "text": "deduce it from the return of the expression here in this particular example you say",
    "start": "1629720",
    "end": "1636620"
  },
  {
    "text": "tackle type J everything is fine still",
    "start": "1636620",
    "end": "1642799"
  },
  {
    "text": "but what happens if you introduce a variable called J in the surrounding",
    "start": "1642799",
    "end": "1649340"
  },
  {
    "text": "context the problem with that is this tackle type J does not bind to the capture J",
    "start": "1649340",
    "end": "1658520"
  },
  {
    "text": "in the capture clause but it does bind so suddenly",
    "start": "1658520",
    "end": "1664820"
  },
  {
    "text": "your Lambda expression is no longer returning an INT as before",
    "start": "1664820",
    "end": "1670940"
  },
  {
    "text": "but now it's a double and this is completely surprising to",
    "start": "1670940",
    "end": "1675980"
  },
  {
    "text": "almost everybody who is using Lambda expressions",
    "start": "1675980",
    "end": "1681500"
  },
  {
    "text": "in C plus plus 23 now we kept we bind this decal type",
    "start": "1681500",
    "end": "1689720"
  },
  {
    "text": "to the capture tray in the capture expression unfortunately we can't do it in a",
    "start": "1689720",
    "end": "1698059"
  },
  {
    "text": "perfect way foreign",
    "start": "1698059",
    "end": "1701919"
  },
  {
    "text": "there are some edge cases that this doesn't work and because of syntax but",
    "start": "1703760",
    "end": "1709520"
  },
  {
    "text": "now you usually can take it for granted that you get exactly the result what you're",
    "start": "1709520",
    "end": "1716240"
  },
  {
    "text": "expecting so that is that the J in a technical type actually binds to the J in the capture because it's nearer to",
    "start": "1716240",
    "end": "1723380"
  },
  {
    "text": "the to the core of the of the Lambda expression and the resulting closure",
    "start": "1723380",
    "end": "1728960"
  },
  {
    "text": "type you can also get rid of the unnecessary parenthesis even if you have",
    "start": "1728960",
    "end": "1736039"
  },
  {
    "text": "qualifications like mutable and you can put attributes in here",
    "start": "1736039",
    "end": "1743620"
  },
  {
    "text": "the portability thing they identifier syntax they have been",
    "start": "1744860",
    "end": "1751039"
  },
  {
    "text": "actually talking about it this is also in defect report against t plus 20. so",
    "start": "1751039",
    "end": "1757460"
  },
  {
    "text": "you expect your compilers to to switch the behavior here",
    "start": "1757460",
    "end": "1763880"
  },
  {
    "text": "foreign other improvements like handing of wine",
    "start": "1763880",
    "end": "1772279"
  },
  {
    "text": "spaces at the end of spliced lines or literal concatenation",
    "start": "1772279",
    "end": "1779059"
  },
  {
    "text": "and literally encoding and all this kind of stuff and utf-8 encoding as a mandatory",
    "start": "1779059",
    "end": "1787159"
  },
  {
    "text": "supported source code encoding White characters and encoding there have",
    "start": "1787159",
    "end": "1794179"
  },
  {
    "text": "been so many places where the your source code probably didn't",
    "start": "1794179",
    "end": "1803779"
  },
  {
    "text": "do what you wanted it to do you believed it to do because you were depending on implementation defined Behavior",
    "start": "1803779",
    "end": "1812260"
  },
  {
    "text": "and yeah the last part",
    "start": "1812299",
    "end": "1816820"
  },
  {
    "text": "W charity is no longer required",
    "start": "1818419",
    "end": "1824779"
  },
  {
    "text": "to encode all code points that you have in unicode",
    "start": "1824779",
    "end": "1831500"
  },
  {
    "text": "Maybe nobody knew that all C plus plus code",
    "start": "1831500",
    "end": "1836600"
  },
  {
    "text": "compiled by Visual Studio was actually not valid C plus plus code",
    "start": "1836600",
    "end": "1843500"
  },
  {
    "text": "because it was violating this particular requirements that has been in place up",
    "start": "1843500",
    "end": "1848659"
  },
  {
    "text": "until C plus 20.",
    "start": "1848659",
    "end": "1852740"
  },
  {
    "text": "so it is as an example of this identifier syntax quite famous in conference lights",
    "start": "1854539",
    "end": "1863539"
  },
  {
    "text": "this is no longer valid code",
    "start": "1863539",
    "end": "1867879"
  },
  {
    "text": "resist the problem in this particular example",
    "start": "1872360",
    "end": "1877539"
  },
  {
    "text": "Michael case is pointing it",
    "start": "1878480",
    "end": "1882100"
  },
  {
    "text": "at the end of the line you have a space and right before the space you have a backslash",
    "start": "1885140",
    "end": "1892360"
  },
  {
    "text": "so the backslash usually indicates a line continuation",
    "start": "1892399",
    "end": "1899059"
  },
  {
    "text": "so line 9 becomes concatenated",
    "start": "1899059",
    "end": "1904279"
  },
  {
    "text": "to the end of line eight but only if the compiler ignores the",
    "start": "1904279",
    "end": "1912620"
  },
  {
    "text": "space at the end of the line so depending on the compiler",
    "start": "1912620",
    "end": "1918500"
  },
  {
    "text": "the value is either zero or Elite",
    "start": "1918500",
    "end": "1925720"
  },
  {
    "text": "up until C plus 20 you could concatenate strings",
    "start": "1932600",
    "end": "1940340"
  },
  {
    "text": "with different encodings does it make sense",
    "start": "1940340",
    "end": "1947179"
  },
  {
    "text": "probably not each compiler is handling this differently",
    "start": "1947179",
    "end": "1953019"
  },
  {
    "text": "luckily enough in C plus 23 none of this is legally anymore your compiler will",
    "start": "1953539",
    "end": "1960020"
  },
  {
    "text": "complaint hopefully",
    "start": "1960020",
    "end": "1963440"
  },
  {
    "text": "here in this particular example we are testing if",
    "start": "1969860",
    "end": "1976399"
  },
  {
    "text": "if a is actually encoded within value of hex",
    "start": "1976399",
    "end": "1981679"
  },
  {
    "text": "4 and 1. once at a preprocessor and once at a",
    "start": "1981679",
    "end": "1988279"
  },
  {
    "text": "language level nobody guarantees that the outcome",
    "start": "1988279",
    "end": "1994399"
  },
  {
    "text": "of this equality comparison is the same",
    "start": "1994399",
    "end": "2000399"
  },
  {
    "text": "actually some implementations took this",
    "start": "2000399",
    "end": "2006580"
  },
  {
    "text": "to differentiate between aptitic encoding and ASCII encoding",
    "start": "2006580",
    "end": "2013380"
  },
  {
    "text": "now because required to return the same result by",
    "start": "2014440",
    "end": "2020320"
  },
  {
    "text": "this comparison um",
    "start": "2020320",
    "end": "2025980"
  },
  {
    "text": "Expressions no matter if you're doing it in the preprocessor or if you're doing",
    "start": "2026159",
    "end": "2031659"
  },
  {
    "text": "it at a language level yeah then there are many other things",
    "start": "2031659",
    "end": "2038919"
  },
  {
    "text": "that are that are less interesting here the the most",
    "start": "2038919",
    "end": "2044980"
  },
  {
    "text": "important key takeaway from here your compiler",
    "start": "2044980",
    "end": "2050800"
  },
  {
    "text": "must provide a means to take source code",
    "start": "2050800",
    "end": "2058179"
  },
  {
    "text": "as utfn 8 encoded character stream third",
    "start": "2058179",
    "end": "2063700"
  },
  {
    "text": "there was a lot of discussions around it are the streams now character streams",
    "start": "2063700",
    "end": "2070300"
  },
  {
    "text": "yeah okay just thanks",
    "start": "2070300",
    "end": "2077200"
  },
  {
    "text": "if you happen to have your source code encoded in utf-8 now you are safe and",
    "start": "2077200",
    "end": "2082658"
  },
  {
    "text": "the meaning of the of your resource code is well defined and no longer implementation defined or whatever it",
    "start": "2082659",
    "end": "2089320"
  },
  {
    "text": "has been in the past then we had all these weird encodings",
    "start": "2089320",
    "end": "2095560"
  },
  {
    "text": "all of these were not doing what you probably expected it to do",
    "start": "2095560",
    "end": "2102160"
  },
  {
    "text": "now we say all of that is ill-formed",
    "start": "2102160",
    "end": "2106980"
  },
  {
    "text": "this is quite a surprise it was also a surprise to me",
    "start": "2107800",
    "end": "2113040"
  },
  {
    "text": "line one in the upper example is one character",
    "start": "2113920",
    "end": "2121200"
  },
  {
    "text": "even though a chart can never have a value",
    "start": "2122320",
    "end": "2127839"
  },
  {
    "text": "that can be expressed by this hexadecimal encoding of",
    "start": "2127839",
    "end": "2135579"
  },
  {
    "text": "a string this is not possible",
    "start": "2135579",
    "end": "2141180"
  },
  {
    "text": "actually in the documentation of the Microsoft compiler they say express it",
    "start": "2141640",
    "end": "2146920"
  },
  {
    "text": "this way that you really mean these are two characters",
    "start": "2146920",
    "end": "2152380"
  },
  {
    "text": "now you have syntax to actually Express okay this is character one this is",
    "start": "2152380",
    "end": "2157480"
  },
  {
    "text": "character two without ambiguity in there",
    "start": "2157480",
    "end": "2163200"
  },
  {
    "text": "yeah and if you're really into",
    "start": "2164079",
    "end": "2169560"
  },
  {
    "text": "be explicit about what kind of character you're referring to you can now use the",
    "start": "2170260",
    "end": "2178240"
  },
  {
    "text": "names from the Unicode standard and say okay you want to letting Capital lever",
    "start": "2178240",
    "end": "2183520"
  },
  {
    "text": "letter with a macro or combine it with a graph accent you can",
    "start": "2183520",
    "end": "2190420"
  },
  {
    "text": "express it without resorting to hexadecimal lookups from any table",
    "start": "2190420",
    "end": "2197880"
  },
  {
    "text": "suffixes for size T's here foreign",
    "start": "2199900",
    "end": "2206578"
  },
  {
    "text": "but it will probably take too much time the problem",
    "start": "2211300",
    "end": "2218400"
  },
  {
    "text": "if current code is if you",
    "start": "2218619",
    "end": "2225838"
  },
  {
    "text": "want to have an for Loop that takes",
    "start": "2229000",
    "end": "2236520"
  },
  {
    "text": "a initializer and it USD type with an auto",
    "start": "2236520",
    "end": "2242320"
  },
  {
    "text": "detuse type is not the same type as the return the result from the size",
    "start": "2242320",
    "end": "2247540"
  },
  {
    "text": "operation of the container depending on the um the business the bit with that you're",
    "start": "2247540",
    "end": "2254140"
  },
  {
    "text": "compiling for this is either a truncation or",
    "start": "2254140",
    "end": "2260200"
  },
  {
    "text": "it can run into um",
    "start": "2260200",
    "end": "2266760"
  },
  {
    "text": "if you if you don't want to to to to run into the problem with the",
    "start": "2267099",
    "end": "2273420"
  },
  {
    "text": "64-bit truncation here and you say okay people say use an INT",
    "start": "2273420",
    "end": "2279760"
  },
  {
    "text": "then you have to problem with mixed comparisons between ins and and",
    "start": "2279760",
    "end": "2285940"
  },
  {
    "text": "unsigned ins and it also depends on the on the promotions and this kind of thing",
    "start": "2285940",
    "end": "2291339"
  },
  {
    "text": "so this is not called a secure coding in the face of",
    "start": "2291339",
    "end": "2297400"
  },
  {
    "text": "various businesses and so you should not do that and to help",
    "start": "2297400",
    "end": "2302740"
  },
  {
    "text": "you in doing this we have now um a way to actually Express size T types",
    "start": "2302740",
    "end": "2311200"
  },
  {
    "text": "which match all this the bitness of your compilation if it's 32-bit or if it's",
    "start": "2311200",
    "end": "2318099"
  },
  {
    "text": "64-bit it all gives you the correct size now",
    "start": "2318099",
    "end": "2322680"
  },
  {
    "text": "yeah we will probably skip this here this is not too interesting",
    "start": "2325540",
    "end": "2332740"
  },
  {
    "text": "um implicit moves yeah we have a lot of",
    "start": "2332740",
    "end": "2340559"
  },
  {
    "text": "things that we actually automatically move since up until C plus plus 20 but",
    "start": "2340839",
    "end": "2347800"
  },
  {
    "text": "there are still some Corner cases where you would would prefer to really move",
    "start": "2347800",
    "end": "2353500"
  },
  {
    "text": "the return values out but if you can't in C plus 23 now there are more use",
    "start": "2353500",
    "end": "2360940"
  },
  {
    "text": "cases where this happens all automatically but",
    "start": "2360940",
    "end": "2366060"
  },
  {
    "text": "explaining them all here is way too much please look at the paper if you're interested in",
    "start": "2366060",
    "end": "2373140"
  },
  {
    "text": "also the static operator is not that much portable assumption is Timo here",
    "start": "2373260",
    "end": "2381220"
  },
  {
    "text": "okay if not we skip it",
    "start": "2381220",
    "end": "2385200"
  },
  {
    "text": "um compatibility with c yeah we have new directives like alif deaf and L if and",
    "start": "2387520",
    "end": "2395619"
  },
  {
    "text": "Dev this is probably not too interesting here we have now the ability with hash",
    "start": "2395619",
    "end": "2402579"
  },
  {
    "text": "warning to give warnings during the compilation for",
    "start": "2402579",
    "end": "2408820"
  },
  {
    "text": "example okay this is deprecated will be probably going away at some time you can",
    "start": "2408820",
    "end": "2415599"
  },
  {
    "text": "express it now in your code and this will not stop the compilation anymore because if you do have been doing this",
    "start": "2415599",
    "end": "2423280"
  },
  {
    "text": "with an hash error or a static assert it would immediately stop your compilation now you can can put a warning into your",
    "start": "2423280",
    "end": "2431040"
  },
  {
    "text": "output of the compiler yeah the rest is more or less",
    "start": "2431040",
    "end": "2439660"
  },
  {
    "text": "Expendable and",
    "start": "2439660",
    "end": "2443500"
  },
  {
    "text": "narrowing her textual conversions to Boolean here",
    "start": "2444880",
    "end": "2449940"
  },
  {
    "text": "if you had expressions like these here all of them are evaluated at compile",
    "start": "2451000",
    "end": "2459040"
  },
  {
    "text": "time but up until 20 many of these compile",
    "start": "2459040",
    "end": "2466240"
  },
  {
    "text": "time expressions in particular the Boolean ones were considered",
    "start": "2466240",
    "end": "2472260"
  },
  {
    "text": "narrowing conversions and narrowing conversions are not allowed at compile",
    "start": "2472260",
    "end": "2478480"
  },
  {
    "text": "time so you had to resort to",
    "start": "2478480",
    "end": "2484020"
  },
  {
    "text": "really awkward formulations to check for",
    "start": "2484359",
    "end": "2489760"
  },
  {
    "text": "Boolean Flags or um yeah sizes of",
    "start": "2489760",
    "end": "2496480"
  },
  {
    "text": "other outcomes of integral operations",
    "start": "2496480",
    "end": "2501420"
  },
  {
    "text": "now you can express it like you would it do at runtime code and no longer have to",
    "start": "2501579",
    "end": "2506920"
  },
  {
    "text": "go through all of these hoops",
    "start": "2506920",
    "end": "2510420"
  },
  {
    "text": "I I really don't want to talk about this one here",
    "start": "2513220",
    "end": "2518560"
  },
  {
    "text": "just a it's a gotcha",
    "start": "2518560",
    "end": "2522359"
  },
  {
    "text": "this is more important now you have you can have compile time argument detection",
    "start": "2525040",
    "end": "2530140"
  },
  {
    "text": "from inherited Constructors in C plus plus 20 if you've",
    "start": "2530140",
    "end": "2536339"
  },
  {
    "text": "using um derived types where you were actually",
    "start": "2536339",
    "end": "2542220"
  },
  {
    "text": "relying on on inheriting Constructors from the base classes",
    "start": "2542220",
    "end": "2548380"
  },
  {
    "text": "compile time argument detection wouldn't work",
    "start": "2548380",
    "end": "2552660"
  },
  {
    "text": "strange reasons it's actually only about wording in C plus plus 23 this is fixed now",
    "start": "2553720",
    "end": "2562140"
  },
  {
    "text": "this is probably less interesting for",
    "start": "2563800",
    "end": "2568900"
  },
  {
    "text": "the actual here this is a question that you'd have",
    "start": "2568900",
    "end": "2574960"
  },
  {
    "text": "to be aware of in C plus plus 20. if you have an equality or inequality",
    "start": "2574960",
    "end": "2581800"
  },
  {
    "text": "operator in your class and you forget to",
    "start": "2581800",
    "end": "2588099"
  },
  {
    "text": "const qualify this operator functions",
    "start": "2588099",
    "end": "2594579"
  },
  {
    "text": "line six the outcome of the inequality",
    "start": "2594579",
    "end": "2602099"
  },
  {
    "text": "comparison between two PR values constructed here",
    "start": "2602099",
    "end": "2608220"
  },
  {
    "text": "is totally undefined Behavior actually it's more like implementation defined but it's no",
    "start": "2608220",
    "end": "2614980"
  },
  {
    "text": "different one compiler would say okay these two PR values are the same probably what you",
    "start": "2614980",
    "end": "2622180"
  },
  {
    "text": "were expecting other compilers would say no there are different instances they're not the same",
    "start": "2622180",
    "end": "2628660"
  },
  {
    "text": "and the problem is tilak of the quantity qualification of The",
    "start": "2628660",
    "end": "2634000"
  },
  {
    "text": "Operators here good for pop quizzes",
    "start": "2634000",
    "end": "2639819"
  },
  {
    "text": "in C plus 23 now we got rid of all of this is no longer ambiguous",
    "start": "2639819",
    "end": "2647578"
  },
  {
    "text": "charity has been a has a long long history of",
    "start": "2648460",
    "end": "2653920"
  },
  {
    "text": "discussions and",
    "start": "2653920",
    "end": "2658960"
  },
  {
    "text": "actually many changes has been happening in 2017 and 20.",
    "start": "2658960",
    "end": "2667900"
  },
  {
    "text": "and you've had curtitious incompatibilities with c",
    "start": "2667900",
    "end": "2674859"
  },
  {
    "text": "and now we say okay at least for the most",
    "start": "2674859",
    "end": "2680200"
  },
  {
    "text": "obvious um situations where you want to have",
    "start": "2680200",
    "end": "2686079"
  },
  {
    "text": "tar eight utf-8 encoded literals we can",
    "start": "2686079",
    "end": "2693280"
  },
  {
    "text": "we avoid all these discussions and say okay this is fine now you can assign",
    "start": "2693280",
    "end": "2698800"
  },
  {
    "text": "u8 encoded strings to unsigned Char arrays and this is probably what you really",
    "start": "2698800",
    "end": "2706240"
  },
  {
    "text": "want if you have header files from from C",
    "start": "2706240",
    "end": "2711720"
  },
  {
    "text": "did you know that they had garbage collection in C plus plus",
    "start": "2715900",
    "end": "2721720"
  },
  {
    "text": "since C plus plus 11. nobody implemented it",
    "start": "2721720",
    "end": "2727960"
  },
  {
    "text": "hmm",
    "start": "2727960",
    "end": "2730560"
  },
  {
    "text": "did you know that the layout order in your classes was probably not what you were expected",
    "start": "2734140",
    "end": "2742599"
  },
  {
    "text": "them to be this particular example can has has",
    "start": "2742599",
    "end": "2747880"
  },
  {
    "text": "six different authorings of the members in the class layout",
    "start": "2747880",
    "end": "2753599"
  },
  {
    "text": "at least according to the standard but",
    "start": "2755380",
    "end": "2761220"
  },
  {
    "text": "no compiler took advantage of this so we got rid of this now it's clear it's the first order",
    "start": "2761260",
    "end": "2768220"
  },
  {
    "text": "foreign let's come to the library and I will probably differ to call on top because",
    "start": "2768220",
    "end": "2773859"
  },
  {
    "text": "he's on the library working group we have a couple of new major features",
    "start": "2773859",
    "end": "2779680"
  },
  {
    "text": "like stack Trace expected generator print and the modular standard Library",
    "start": "2779680",
    "end": "2786520"
  },
  {
    "text": "we have increased the compatibility to see improve Chrono format string and string",
    "start": "2786520",
    "end": "2793119"
  },
  {
    "text": "view the string is the endless story every standard we have more member",
    "start": "2793119",
    "end": "2799000"
  },
  {
    "text": "functions in string we have lots of fixes and ranges and in particular in use",
    "start": "2799000",
    "end": "2805180"
  },
  {
    "text": "we had made progress on const explore all the things",
    "start": "2805180",
    "end": "2810579"
  },
  {
    "text": "we had a lot of usability improvements when it comes to optional and and",
    "start": "2810579",
    "end": "2816420"
  },
  {
    "text": "heterogeneous arrays and lookups and two percent Pairs and this kind of things and the library also decided we no",
    "start": "2816420",
    "end": "2824560"
  },
  {
    "text": "longer want to support garbage collection so stack Trace Library",
    "start": "2824560",
    "end": "2831838"
  },
  {
    "text": "this is modeled after the booth stacked through his Library maybe some of you are",
    "start": "2831880",
    "end": "2838540"
  },
  {
    "text": "familiar with this Tech Trace Library",
    "start": "2838540",
    "end": "2842700"
  },
  {
    "text": "so we have it in the standard now if you want to use this for example if you're",
    "start": "2843940",
    "end": "2849520"
  },
  {
    "text": "at a certain point and want to put on sectors into the lock now you can do it",
    "start": "2849520",
    "end": "2854980"
  },
  {
    "text": "with that with just the standard functionality in there",
    "start": "2854980",
    "end": "2861299"
  },
  {
    "text": "expected one of my favorites here",
    "start": "2861640",
    "end": "2866099"
  },
  {
    "text": "I guess all of you are familiar with optional",
    "start": "2867339",
    "end": "2873220"
  },
  {
    "text": "in with optional you can return a value of a certain type and also can",
    "start": "2873220",
    "end": "2878619"
  },
  {
    "text": "return the fact that you don't have a value",
    "start": "2878619",
    "end": "2883660"
  },
  {
    "text": "available at the return but with expected you can express a",
    "start": "2883660",
    "end": "2890859"
  },
  {
    "text": "little bit more you can ever return the expected value type",
    "start": "2890859",
    "end": "2897000"
  },
  {
    "text": "and if you happen to not be able to produce a result",
    "start": "2897000",
    "end": "2905140"
  },
  {
    "text": "you can explicitly express your disappointment by some type",
    "start": "2905140",
    "end": "2911440"
  },
  {
    "text": "that you want to use here in this maybe use this is a string that you can",
    "start": "2911440",
    "end": "2919240"
  },
  {
    "text": "write in what's what's the problem why you can't produce a result or to use a stud error code or whatever",
    "start": "2919240",
    "end": "2927640"
  },
  {
    "text": "it has you can decide on how you express your disappointment why you can't",
    "start": "2927640",
    "end": "2932859"
  },
  {
    "text": "produce a valid result you have all the",
    "start": "2932859",
    "end": "2939119"
  },
  {
    "text": "accesses to figure out if you have the valid I have a valid result or you have",
    "start": "2939119",
    "end": "2944140"
  },
  {
    "text": "a problem and you can also use it in if",
    "start": "2944140",
    "end": "2950020"
  },
  {
    "text": "Expressions so that you put um",
    "start": "2950020",
    "end": "2955980"
  },
  {
    "text": "process the result only if we have actually got one",
    "start": "2955980",
    "end": "2961380"
  },
  {
    "text": "another function that is interesting in particular for people who",
    "start": "2963099",
    "end": "2969040"
  },
  {
    "text": "have to communicate data structures between systems with different",
    "start": "2969040",
    "end": "2974260"
  },
  {
    "text": "architectures one of them maybe",
    "start": "2974260",
    "end": "2980020"
  },
  {
    "text": "a big Indie and the other one maybe little Indian and you want to",
    "start": "2980260",
    "end": "2988060"
  },
  {
    "text": "move these data structures across the network connection or whatever it has might be",
    "start": "2988060",
    "end": "2994720"
  },
  {
    "text": "in this particular case now you can bite swap using the standard Library",
    "start": "2994720",
    "end": "3002579"
  },
  {
    "text": "and the advantages over the C library th2 is",
    "start": "3002579",
    "end": "3010079"
  },
  {
    "text": "and H to n and all these C functions that you have been using in the past for that is this is const expert doesn't",
    "start": "3010079",
    "end": "3019099"
  },
  {
    "text": "introduce the undefined behavior and it works only with integral types where",
    "start": "3019099",
    "end": "3025440"
  },
  {
    "text": "it's safe to use move only function is one of is also",
    "start": "3025440",
    "end": "3032579"
  },
  {
    "text": "interesting I'm using this right now in my code because now you can say in your",
    "start": "3032579",
    "end": "3038220"
  },
  {
    "text": "callbacks that you probably pass into your different parts of your code that",
    "start": "3038220",
    "end": "3044280"
  },
  {
    "text": "you expect them to be no except you couldn't do that they've stood function",
    "start": "3044280",
    "end": "3049380"
  },
  {
    "text": "he had no guarantee that the the function that you were calling on behalf",
    "start": "3049380",
    "end": "3054660"
  },
  {
    "text": "of these function wrappers is actually not producing",
    "start": "3054660",
    "end": "3062300"
  },
  {
    "text": "exception while you were calling into that now you can express it you accept only functions that",
    "start": "3062300",
    "end": "3068760"
  },
  {
    "text": "will not produce exceptions during the function call",
    "start": "3068760",
    "end": "3076700"
  },
  {
    "text": "there are even more aspects to to use move only functions",
    "start": "3077220",
    "end": "3084260"
  },
  {
    "text": "um I will not go into details here this unreachable Library function",
    "start": "3084660",
    "end": "3091980"
  },
  {
    "text": "is interesting if you want to squeeze the last part last bit of performance out of your switch statements",
    "start": "3091980",
    "end": "3099540"
  },
  {
    "text": "because in the C plus 20 example here the compiler had to put extra code in in",
    "start": "3099540",
    "end": "3107400"
  },
  {
    "text": "here if they happen to be inputs that are not one two",
    "start": "3107400",
    "end": "3114420"
  },
  {
    "text": "zero one two or three because of implementation details in C",
    "start": "3114420",
    "end": "3121500"
  },
  {
    "text": "plus 23 you can say you guarantee that no invalid value will come in here and",
    "start": "3121500",
    "end": "3128040"
  },
  {
    "text": "you say stood unreachable and the compiler say okay I believe you I will not",
    "start": "3128040",
    "end": "3133200"
  },
  {
    "text": "produce any code for handling out of bound values in the parameter",
    "start": "3133200",
    "end": "3141540"
  },
  {
    "text": "this is my particular favorite foreign",
    "start": "3143880",
    "end": "3148920"
  },
  {
    "text": "output to the terminal",
    "start": "3148920",
    "end": "3155780"
  },
  {
    "text": "but only you get compile time checking for the format string",
    "start": "3156359",
    "end": "3161640"
  },
  {
    "text": "but also you get with the stood print function in",
    "start": "3161640",
    "end": "3166859"
  },
  {
    "text": "C plus 23 a guaranteed encoding so the Emoji bucket that you're seeing",
    "start": "3166859",
    "end": "3174240"
  },
  {
    "text": "in the upper example will no longer happen if you outputting",
    "start": "3174240",
    "end": "3180420"
  },
  {
    "text": "formatted strings to the terminal",
    "start": "3180420",
    "end": "3184338"
  },
  {
    "text": "this means also Unicode handling is really baked into the library but this",
    "start": "3185880",
    "end": "3192119"
  },
  {
    "text": "point and this is a common theme throughout um 20 23 to implement much more unicode",
    "start": "3192119",
    "end": "3202980"
  },
  {
    "text": "handling in a in a safe Manner and in a consistent manner",
    "start": "3202980",
    "end": "3208619"
  },
  {
    "text": "yeah I really have to say study group 16 is has been extremely productive here",
    "start": "3208619",
    "end": "3216980"
  },
  {
    "text": "currently is there still anything left to do okay expect more on that in C plus plus",
    "start": "3217440",
    "end": "3224640"
  },
  {
    "text": "26. and",
    "start": "3224640",
    "end": "3231859"
  },
  {
    "text": "now we have it yes standard Library modules",
    "start": "3232020",
    "end": "3238579"
  },
  {
    "text": "in C plus 20 yeah you need a fold operation",
    "start": "3240300",
    "end": "3246300"
  },
  {
    "text": "and fold algorithm oh it doesn't",
    "start": "3246300",
    "end": "3251760"
  },
  {
    "text": "is not called fold it's called accumulate and it's not in the algorithm",
    "start": "3251760",
    "end": "3258059"
  },
  {
    "text": "header but in the numeric header for news",
    "start": "3258059",
    "end": "3263300"
  },
  {
    "text": "now with the library modules the whole Library",
    "start": "3264119",
    "end": "3269520"
  },
  {
    "text": "is in one module you no longer have to figure out which headers you have to",
    "start": "3269520",
    "end": "3274920"
  },
  {
    "text": "include and you also get the performance benefit",
    "start": "3274920",
    "end": "3280380"
  },
  {
    "text": "of using modules here so you have two flavors of it flavor one",
    "start": "3280380",
    "end": "3287040"
  },
  {
    "text": "is just import stood probably what most people will be using in the future it's",
    "start": "3287040",
    "end": "3293040"
  },
  {
    "text": "everything of the C plus plus headers NDC wrapper",
    "start": "3293040",
    "end": "3298319"
  },
  {
    "text": "if you really need the semantics and the namings from the",
    "start": "3298319",
    "end": "3304619"
  },
  {
    "text": "from the C standard libraries which is also part of the C",
    "start": "3304619",
    "end": "3311160"
  },
  {
    "text": "plus plus standard you can use a stood compact so you'll get all of the headers",
    "start": "3311160",
    "end": "3317640"
  },
  {
    "text": "that are actually standardized in C plus plus",
    "start": "3317640",
    "end": "3321680"
  },
  {
    "text": "another thing really important in my opinion and also a reference implementation by",
    "start": "3323040",
    "end": "3330059"
  },
  {
    "text": "corenta once again",
    "start": "3330059",
    "end": "3333619"
  },
  {
    "text": "it's the generator who is familiar with core routines",
    "start": "3336300",
    "end": "3343339"
  },
  {
    "text": "okay quite a few",
    "start": "3343559",
    "end": "3346940"
  },
  {
    "text": "what do you think about the Library support in C plus plus 20 when",
    "start": "3350460",
    "end": "3356040"
  },
  {
    "text": "it comes to co-routines are you happy",
    "start": "3356040",
    "end": "3362180"
  },
  {
    "text": "correct answer it doesn't exist with",
    "start": "3364619",
    "end": "3371339"
  },
  {
    "text": "generator you can put a range facade in front of your core routines",
    "start": "3371339",
    "end": "3378540"
  },
  {
    "text": "which means",
    "start": "3378540",
    "end": "3381559"
  },
  {
    "text": "if you have a core routine that produces a sequence of values",
    "start": "3384839",
    "end": "3392960"
  },
  {
    "text": "you can now just say this this function for coroutine is a function it's",
    "start": "3393420",
    "end": "3399059"
  },
  {
    "text": "returning a generator and on the call side you can for example",
    "start": "3399059",
    "end": "3405540"
  },
  {
    "text": "put the range generated lazily by the core",
    "start": "3405540",
    "end": "3410700"
  },
  {
    "text": "routine can be passed into a piece of code that's",
    "start": "3410700",
    "end": "3418260"
  },
  {
    "text": "operates on this range for example puts it into a container or",
    "start": "3418260",
    "end": "3424500"
  },
  {
    "text": "transforms it or whatever it has to do with it even can use it in a Range based",
    "start": "3424500",
    "end": "3430200"
  },
  {
    "text": "for Loop and at each iterations step the co-routine",
    "start": "3430200",
    "end": "3435839"
  },
  {
    "text": "behind this generator for that will produce a new result",
    "start": "3435839",
    "end": "3441420"
  },
  {
    "text": "so the usage of core routines to produce and find it or even an infinite amount",
    "start": "3441420",
    "end": "3449400"
  },
  {
    "text": "of return values can now be expressed through the standard Library",
    "start": "3449400",
    "end": "3454619"
  },
  {
    "text": "and this is extremely helpful if you want to do lazy operations",
    "start": "3454619",
    "end": "3462799"
  },
  {
    "text": "we also have flat maps and flat sets everybody who is familiar with the Boost",
    "start": "3466559",
    "end": "3471780"
  },
  {
    "text": "flat map and Flat set we have it now in the standard library with a slightly different ordering where",
    "start": "3471780",
    "end": "3480000"
  },
  {
    "text": "how we started kind of things yeah the standard always has to be a",
    "start": "3480000",
    "end": "3485160"
  },
  {
    "text": "little bit different yeah then have a lot of C comparability",
    "start": "3485160",
    "end": "3492359"
  },
  {
    "text": "things but it's this is not that interesting unless",
    "start": "3492359",
    "end": "3498960"
  },
  {
    "text": "you're really a use case for that this is interesting for people who have",
    "start": "3498960",
    "end": "3504420"
  },
  {
    "text": "to deal with um with C Parts in their code",
    "start": "3504420",
    "end": "3511500"
  },
  {
    "text": "nope I don't know if you have been aware that the",
    "start": "3511500",
    "end": "3517500"
  },
  {
    "text": "C headers in C plus plus were officially",
    "start": "3517500",
    "end": "3523079"
  },
  {
    "text": "deprecated so if your lawyers in the company",
    "start": "3523079",
    "end": "3530540"
  },
  {
    "text": "said you can't use deprecated things in your code well probably not that happy and this is",
    "start": "3531000",
    "end": "3538260"
  },
  {
    "text": "the reason why we decided to no longer discard it deprecated but we officially",
    "start": "3538260",
    "end": "3545240"
  },
  {
    "text": "discarded only so this is more a loyalty kind of thing",
    "start": "3545240",
    "end": "3552319"
  },
  {
    "text": "let me see her foreign yeah",
    "start": "3557819",
    "end": "3562819"
  },
  {
    "text": "probably at the end of the talk but",
    "start": "3563579",
    "end": "3568740"
  },
  {
    "text": "this is something that it will go through because I think it's really interesting",
    "start": "3568740",
    "end": "3574500"
  },
  {
    "text": "dysfunction called stood to underlining for enumerations",
    "start": "3574500",
    "end": "3580220"
  },
  {
    "text": "assume in the beginning we had an enum class with some values we had a function",
    "start": "3580220",
    "end": "3587400"
  },
  {
    "text": "that takes in these enorm class as a parameter and is",
    "start": "3587400",
    "end": "3593160"
  },
  {
    "text": "unwrapping it and putting it into a unsafe function that",
    "start": "3593160",
    "end": "3598920"
  },
  {
    "text": "takes just an integral type like an INT here we usually do this with an static cast",
    "start": "3598920",
    "end": "3607799"
  },
  {
    "text": "and yeah at this point it's it's mostly harmless",
    "start": "3607799",
    "end": "3617099"
  },
  {
    "text": "but some point later somebody changes the enumeration",
    "start": "3617099",
    "end": "3623520"
  },
  {
    "text": "has an additional value in there so that the the amount of bits that have",
    "start": "3623520",
    "end": "3630660"
  },
  {
    "text": "to be allocated to the representation of this enum changes silently",
    "start": "3630660",
    "end": "3637980"
  },
  {
    "text": "and to accommodate for that it said the person said okay I give it an explicit",
    "start": "3637980",
    "end": "3643559"
  },
  {
    "text": "type I say this is a new in 23 now foreign",
    "start": "3643559",
    "end": "3649740"
  },
  {
    "text": "but the implementation of the function wasn't changed it still says static has",
    "start": "3649740",
    "end": "3655859"
  },
  {
    "text": "end undefined Behavior",
    "start": "3655859",
    "end": "3660559"
  },
  {
    "text": "even further along no",
    "start": "3663059",
    "end": "3668579"
  },
  {
    "text": "yep",
    "start": "3668579",
    "end": "3671119"
  },
  {
    "text": "the foreign",
    "start": "3677220",
    "end": "3683700"
  },
  {
    "text": "the type of the enumeration in there is changed",
    "start": "3689579",
    "end": "3695780"
  },
  {
    "text": "the problem is before that is here we said",
    "start": "3696660",
    "end": "3703680"
  },
  {
    "text": "um this is not highlighted here in the in the in the upper example we cast it to",
    "start": "3703680",
    "end": "3710220"
  },
  {
    "text": "an to the underlining type to underlying type explicitly ABC and",
    "start": "3710220",
    "end": "3717180"
  },
  {
    "text": "if this changes later on and you have another enumeration type here which is no longer",
    "start": "3717180",
    "end": "3723540"
  },
  {
    "text": "the same as has been before and we still have these underlying type unchanged",
    "start": "3723540",
    "end": "3728940"
  },
  {
    "text": "here now we have another problem so the correct solution in C plus 23 is",
    "start": "3728940",
    "end": "3736799"
  },
  {
    "text": "let the compiler deduce everything here use the function to underline type and",
    "start": "3736799",
    "end": "3743480"
  },
  {
    "text": "now the conversion from the enumeration type if it's a class time if it's an",
    "start": "3743480",
    "end": "3751160"
  },
  {
    "text": "non-class type or if it's if the um there's explicit underlying type given",
    "start": "3751160",
    "end": "3758940"
  },
  {
    "text": "their is no longer important here so",
    "start": "3758940",
    "end": "3765299"
  },
  {
    "text": "using this will give you all rusty the correct answer",
    "start": "3765299",
    "end": "3770780"
  },
  {
    "text": "yeah and I think I have squeezed as much as I possibly",
    "start": "3774420",
    "end": "3780599"
  },
  {
    "text": "could into this talk but as far as I see",
    "start": "3780599",
    "end": "3786660"
  },
  {
    "text": "we are out of time",
    "start": "3786660",
    "end": "3791059"
  },
  {
    "text": "if you have questions about additional new features",
    "start": "3791940",
    "end": "3800220"
  },
  {
    "text": "I've been giving a list yeah then come up to me I can explain",
    "start": "3800220",
    "end": "3806160"
  },
  {
    "text": "probably more of it but unfortunately I don't have four hours of",
    "start": "3806160",
    "end": "3814140"
  },
  {
    "text": "time to explain everything in all detail and nobody was raising a question",
    "start": "3814140",
    "end": "3822720"
  },
  {
    "text": "I am probably done with telling you at least parts of the new",
    "start": "3822720",
    "end": "3831000"
  },
  {
    "text": "language features of C plus plus 23 thank you very much",
    "start": "3831000",
    "end": "3836340"
  },
  {
    "text": "[Applause]",
    "start": "3836340",
    "end": "3846219"
  }
]