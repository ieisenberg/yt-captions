[
  {
    "text": "all right so let's get started so thank you for being here that early in the morning I know it's it's always hard",
    "start": "5279",
    "end": "11799"
  },
  {
    "text": "also for me it's a little bit hard to be here that early but um let's let's try to make this fun so in the next around",
    "start": "11799",
    "end": "18560"
  },
  {
    "text": "like one hour I'd like to give you a brief introduction about what virtual threats are used for in chaa 21 and how",
    "start": "18560",
    "end": "24760"
  },
  {
    "text": "you can use them really easy in your application to make make your application much faster so short",
    "start": "24760",
    "end": "30920"
  },
  {
    "text": "introduction to myself my name is Christian I've been working as a software engineer for like the last 15",
    "start": "30920",
    "end": "36200"
  },
  {
    "text": "years um started a with Java 6 back then then switched over around 7 years ago to",
    "start": "36200",
    "end": "42879"
  },
  {
    "text": "more of a fullstack role where I mainly currently I'm coding with typescript JavaScript and Java on a daily basis I",
    "start": "42879",
    "end": "49960"
  },
  {
    "text": "also do some trainings on the side and yeah I really like to speak about",
    "start": "49960",
    "end": "55120"
  },
  {
    "text": "different different topics at conferences and I also do some like do some stuff on YouTube where I talk about",
    "start": "55120",
    "end": "61640"
  },
  {
    "text": "like advanced typescript stuff and you can find everything I will talk about today on my website type. Ro and there",
    "start": "61640",
    "end": "67759"
  },
  {
    "text": "you also find the GitHub and you also find um the LinkedIn and everything to my YouTube channel and so on so when you",
    "start": "67759",
    "end": "74520"
  },
  {
    "text": "want to stay in contact just visit the website now if you have questions you",
    "start": "74520",
    "end": "79640"
  },
  {
    "text": "can ask them all the time uh you can just go to type. roqa there will be then",
    "start": "79640",
    "end": "84960"
  },
  {
    "text": "uh redirect to a website where you can just answer a question when we don't have enough time at the end of The Talk talk I will answer the questions later",
    "start": "84960",
    "end": "91799"
  },
  {
    "text": "but of course when we have time left at the end of the talk just just ask them right",
    "start": "91799",
    "end": "97240"
  },
  {
    "text": "away so what will be the topics we will talk about we will talk about like three different topics here so we will build a",
    "start": "97240",
    "end": "103520"
  },
  {
    "text": "spring boot application and first we will build them in a blocking approach then we will switch over to it being",
    "start": "103520",
    "end": "109640"
  },
  {
    "text": "reactive and then we will migrate it to using project Loom and virtual threats",
    "start": "109640",
    "end": "115280"
  },
  {
    "text": "so first so the blocking approach so when we started it like in the early",
    "start": "115280",
    "end": "120560"
  },
  {
    "text": "days we only had the possibility to use the blocking approach so for example we have a rest template when we make an",
    "start": "120560",
    "end": "126439"
  },
  {
    "text": "HTTP request then the thread will block and many of us maybe are still using it",
    "start": "126439",
    "end": "131800"
  },
  {
    "text": "to this day because I'm also still using it mainly because often you don't have applications we need that high of a",
    "start": "131800",
    "end": "138319"
  },
  {
    "text": "throughput you have like for example it's an internal application which has maybe 100 user a day and if you only",
    "start": "138319",
    "end": "144120"
  },
  {
    "text": "have like a simple crot application then you don't need it to be like reactive and have this additional um add",
    "start": "144120",
    "end": "150720"
  },
  {
    "text": "additional overhead of reactivity now because of that let's build this blocking",
    "start": "150720",
    "end": "156599"
  },
  {
    "text": "application so we will go into intellig and what I'm currently having here is",
    "start": "156599",
    "end": "162319"
  },
  {
    "text": "just an EMP an empty application uh which has just pom XML which is on",
    "start": "162319",
    "end": "168200"
  },
  {
    "text": "version 3.2 uh 3.3.1 and I'm currently on version Java 22 but of course you can",
    "start": "168200",
    "end": "175040"
  },
  {
    "text": "also do this with Java 21 so what we first will do is we we will just create a new",
    "start": "175040",
    "end": "183400"
  },
  {
    "text": "controller like this and now what what we will build here is we will have like",
    "start": "183480",
    "end": "190319"
  },
  {
    "text": "an API where we can access the speakers of the conference but I will not have",
    "start": "190319",
    "end": "195680"
  },
  {
    "text": "the real speakers because then I would have to call like an htpm point and sometimes the Wi-Fi isn't really working",
    "start": "195680",
    "end": "201159"
  },
  {
    "text": "so I will create a fake one so let's have our rest controller here and we",
    "start": "201159",
    "end": "206480"
  },
  {
    "text": "have a request mapping like this and the first thing we will say is we have our get mapping where we say we have our",
    "start": "206480",
    "end": "213319"
  },
  {
    "text": "speakers here now what will this return it will give you a list of speaker and we say get speakers here now let's",
    "start": "213319",
    "end": "221239"
  },
  {
    "text": "create this speaker record and we'll keep this really uh really easy so we",
    "start": "221239",
    "end": "226799"
  },
  {
    "text": "will just say this has just a name so and now let's import this now to fake",
    "start": "226799",
    "end": "233439"
  },
  {
    "text": "this HTP request so that we can send some fake rest API call I will create",
    "start": "233439",
    "end": "239519"
  },
  {
    "text": "this service so we have here an autowired private fake HTP",
    "start": "239519",
    "end": "246200"
  },
  {
    "text": "service and let's build this and we will keep this really simple as well we will",
    "start": "246200",
    "end": "251840"
  },
  {
    "text": "just say this is a service here and we will then say here in the get speakers we call fake HTP service retrieve",
    "start": "251840",
    "end": "259720"
  },
  {
    "text": "speakers like this and what we now can do in here",
    "start": "259720",
    "end": "265199"
  },
  {
    "text": "is we have of course to return this here and the first thing we will do here is",
    "start": "265199",
    "end": "271880"
  },
  {
    "text": "we will say we have a threat. sleep of a th000 milliseconds because this",
    "start": "271880",
    "end": "277560"
  },
  {
    "text": "basically is what happens when we call an endpoint in a blocking manner the thread will block until the response",
    "start": "277560",
    "end": "283720"
  },
  {
    "text": "comes back from our endpoint so let's just say we have here a sneaky throw so that we do not have to",
    "start": "283720",
    "end": "291560"
  },
  {
    "text": "to handle this and now we have to create uh our our speaker list so we have our private final list of speaker and this",
    "start": "291560",
    "end": "300160"
  },
  {
    "text": "is the speaker list and we will create like a small one with 10 speakers in there and we will say map to object and",
    "start": "300160",
    "end": "307360"
  },
  {
    "text": "for each of these uh inte teers we will create a new speaker and have the",
    "start": "307360",
    "end": "312560"
  },
  {
    "text": "speaker like this so what we then will do is we will",
    "start": "312560",
    "end": "317840"
  },
  {
    "text": "just return this speaker list now this is everything we need to do to make our application running so what we did is we",
    "start": "317840",
    "end": "325440"
  },
  {
    "text": "created an endpoint and we just called this retrieve speakers which fakes this block in API request so let's run",
    "start": "325440",
    "end": "332960"
  },
  {
    "text": "this and what we now can do is we can open J meter J meter is like an application to Performance check your",
    "start": "332960",
    "end": "340120"
  },
  {
    "text": "application and we will keep this really easy we will say we want to have a th000 concurrent users to access this",
    "start": "340120",
    "end": "346080"
  },
  {
    "text": "application we have a ramp up time of 10 seconds so we will only start checking the performance after the initial 10",
    "start": "346080",
    "end": "353199"
  },
  {
    "text": "seconds and we will do this for 20 seconds all in all so let's run this",
    "start": "353199",
    "end": "358319"
  },
  {
    "text": "here and let's see we have the API SL speakers in there so when we run this we",
    "start": "358319",
    "end": "363400"
  },
  {
    "text": "can see here the Thousand threats gets created and then it starts accessing our endpoint and what we now will check is",
    "start": "363400",
    "end": "370759"
  },
  {
    "text": "what will be the performance of this endpoint when a huge amount of users access our endpoint because we don't",
    "start": "370759",
    "end": "378479"
  },
  {
    "text": "have a th000 threats aailable in our endpoint currently so let's see what happens here so we have a th000 and we",
    "start": "378479",
    "end": "384560"
  },
  {
    "text": "have 20 seconds over and we can see here it's quite slow because we can see here",
    "start": "384560",
    "end": "389680"
  },
  {
    "text": "it starts with over 2 seconds of time needed for the first request and at last",
    "start": "389680",
    "end": "395360"
  },
  {
    "text": "it needs almost 5 Seconds now why is this well the problem is that in Java",
    "start": "395360",
    "end": "402759"
  },
  {
    "text": "for each of these platform threads for each of these normal threat uh threats which get created when you for example",
    "start": "402759",
    "end": "408639"
  },
  {
    "text": "call new threat it will create an operating system threat and an operating system threat is quite expensive and",
    "start": "408639",
    "end": "415160"
  },
  {
    "text": "this is why Tomcat or any server basically which is used for example in Spring or in other Frameworks has a",
    "start": "415160",
    "end": "421720"
  },
  {
    "text": "thread pool which reuses these threats and so let's create some threads and",
    "start": "421720",
    "end": "426840"
  },
  {
    "text": "let's see what what the issue here is so we will go in back into intellig and I",
    "start": "426840",
    "end": "432240"
  },
  {
    "text": "have here a test which I can use and this test um has this Sleep",
    "start": "432240",
    "end": "438319"
  },
  {
    "text": "Method in it just so that I can wrap my thread dot sleep so that I don't have to handle the the checked exception now",
    "start": "438319",
    "end": "445319"
  },
  {
    "text": "let's create this test here and we have the test and what we will do is we will create a thousand threads to start with",
    "start": "445319",
    "end": "451879"
  },
  {
    "text": "so we say we have a list of threads and we have this thread list and we say",
    "start": "451879",
    "end": "457240"
  },
  {
    "text": "instream range of0 to 1,000 so we will create a th000 threats and we could do",
    "start": "457240",
    "end": "463960"
  },
  {
    "text": "this now with new thread like this but in Java 21 there is now a new way of doing this we can say threat. off",
    "start": "463960",
    "end": "472080"
  },
  {
    "text": "platform and what this does is basically the same like new thread but the only difference is it will make it easier for",
    "start": "472080",
    "end": "478479"
  },
  {
    "text": "us to just switch one thing later so we say we want an unstarted threat something which is not running and we",
    "start": "478479",
    "end": "484960"
  },
  {
    "text": "will then say we have a sleep of 20 seconds so what this will do when this",
    "start": "484960",
    "end": "491440"
  },
  {
    "text": "threat gets executed it will just wait for TW just sleep for 20 seconds and",
    "start": "491440",
    "end": "496560"
  },
  {
    "text": "then it will be done so we can say thread list dot for each so let's start",
    "start": "496560",
    "end": "502159"
  },
  {
    "text": "each thread and then of course you have to wait until these threads are done so",
    "start": "502159",
    "end": "507240"
  },
  {
    "text": "what we will say is thread list four and we'll then say thread. join so we",
    "start": "507240",
    "end": "512360"
  },
  {
    "text": "wait until each thread is done with its work so what I now can do is I will now",
    "start": "512360",
    "end": "518560"
  },
  {
    "text": "open the the terminal and I have here a function a little script which I can use count",
    "start": "518560",
    "end": "524760"
  },
  {
    "text": "threads from java what this does is it basically just checks how many threats on the operating system level were",
    "start": "524760",
    "end": "530680"
  },
  {
    "text": "started from a Java from the jdk from a Java process so I will now watch this",
    "start": "530680",
    "end": "537920"
  },
  {
    "text": "threats here and let's now start these thousand threads so let's start them and",
    "start": "537920",
    "end": "543680"
  },
  {
    "text": "what we will see is that we here now have a th more operating system threads",
    "start": "543680",
    "end": "548760"
  },
  {
    "text": "and this is exactly what I mentioned that for each Java thread a thread on the operating system gets created so",
    "start": "548760",
    "end": "556560"
  },
  {
    "text": "let's now stop this and we can see the threats will go away again now what's the problem with this well when I change",
    "start": "556560",
    "end": "563800"
  },
  {
    "text": "this to for example 1 million threads and I rerun this we will we will see in",
    "start": "563800",
    "end": "570399"
  },
  {
    "text": "just like one or two seconds that we get an out of memory exception because let's",
    "start": "570399",
    "end": "576120"
  },
  {
    "text": "stop this here we can see here unable to create native threat out of memory error",
    "start": "576120",
    "end": "581760"
  },
  {
    "text": "and when we check here we can see for example stack size of 2 megabytes to 2,000 kilobytes and the threat 4,000",
    "start": "581760",
    "end": "589040"
  },
  {
    "text": "could not be created now this is exactly why we can't just create more threats",
    "start": "589040",
    "end": "595920"
  },
  {
    "text": "because when we have a stack size of 2 megabyte or for example also 1 Megabyte in certain cases because you can change",
    "start": "595920",
    "end": "602120"
  },
  {
    "text": "the stack size if you want then it would take to have like 1 million threat you would need one terabyte of memory and",
    "start": "602120",
    "end": "608640"
  },
  {
    "text": "this would be way too expensive to be able to do for like just one application",
    "start": "608640",
    "end": "614040"
  },
  {
    "text": "but we need we would need 1 million threats to have a CPU usage of",
    "start": "614040",
    "end": "619240"
  },
  {
    "text": "100% but why do maybe you think well well what is this CPU usage of 100 100%",
    "start": "619240",
    "end": "625120"
  },
  {
    "text": "why do we need 1 million threats well when we check what the what the threat is mainly doing is it's mainly waiting",
    "start": "625120",
    "end": "631440"
  },
  {
    "text": "because when we think of let's say you have only one threat in your in your application as soon as request comes in",
    "start": "631440",
    "end": "637440"
  },
  {
    "text": "the threat will handle this request and then for example in our case it will call this fake API but everything",
    "start": "637440",
    "end": "644720"
  },
  {
    "text": "between that when it calls the API and and before the result comes back the threat is just waiting so in this time",
    "start": "644720",
    "end": "651600"
  },
  {
    "text": "when the CPU has hasn't something to do then it will just wait so the real usage",
    "start": "651600",
    "end": "657880"
  },
  {
    "text": "of CPU on a threat is really really small so that's why we need to have a huge amount of threats to be able to",
    "start": "657880",
    "end": "664440"
  },
  {
    "text": "really keep our CPU busy so we were here in these early days",
    "start": "664440",
    "end": "670120"
  },
  {
    "text": "where we said well this was this is nice because it's fast enough in our cases but then we went to well we need more",
    "start": "670120",
    "end": "677279"
  },
  {
    "text": "threats to be able to handle these these these throughputs we have so we then",
    "start": "677279",
    "end": "682680"
  },
  {
    "text": "went back and went well how can we fix this because we can't just have more threats we need to change this somehow",
    "start": "682680",
    "end": "688959"
  },
  {
    "text": "so and this is where we switched over at Java 8 to being able to use reactive",
    "start": "688959",
    "end": "694079"
  },
  {
    "text": "also with streams of course but also with like things like completable future and let's now see how we can make our",
    "start": "694079",
    "end": "700560"
  },
  {
    "text": "application much faster by using a reactivity so we go in there and let's",
    "start": "700560",
    "end": "707079"
  },
  {
    "text": "go back here to our main controller and we will create a new endpoint here a get",
    "start": "707079",
    "end": "713320"
  },
  {
    "text": "mapping here and we'll say slash speakers async and what we now now we'll do is",
    "start": "713320",
    "end": "719880"
  },
  {
    "text": "instead of returning a list of speakers we return a completable future list of",
    "start": "719880",
    "end": "725959"
  },
  {
    "text": "speaker and I will use here the the Java approach from the jdk of course you could use like project reactor or like",
    "start": "725959",
    "end": "733279"
  },
  {
    "text": "Vertex or RX Java but this is like baked in for for any framework you use for example for quarcus or other stuff so I",
    "start": "733279",
    "end": "740320"
  },
  {
    "text": "will use this one and let's say we have get speakers async now we will call fake",
    "start": "740320",
    "end": "746440"
  },
  {
    "text": "HTP service retrieve speakers async think now of course we have to create",
    "start": "746440",
    "end": "752000"
  },
  {
    "text": "this first now we can see here we need to return a list of complete complet fut",
    "start": "752000",
    "end": "758079"
  },
  {
    "text": "completable future list now what we can't do is we can't say threat. sleep",
    "start": "758079",
    "end": "763920"
  },
  {
    "text": "because the problem with this is that thread sleep would is not reactive so this will also block the threat so we",
    "start": "763920",
    "end": "770240"
  },
  {
    "text": "don't want to have this so we need to say return completable future Supply async so we say here we want to like",
    "start": "770240",
    "end": "778760"
  },
  {
    "text": "basically create a completable future and Supply it with this speaker list but",
    "start": "778760",
    "end": "784480"
  },
  {
    "text": "we need to add this delay we had so we need to add a delayed executor like this",
    "start": "784480",
    "end": "789920"
  },
  {
    "text": "which enables us to say basically the same the same thing we did with the threat sleep but in a non-blocking",
    "start": "789920",
    "end": "795800"
  },
  {
    "text": "manner so we say here again we want to wait a th000 milliseconds and now we have basically",
    "start": "795800",
    "end": "802160"
  },
  {
    "text": "the same as we have with this retrieve speakers so we fake the delay of getting a response for example in our case it",
    "start": "802160",
    "end": "809360"
  },
  {
    "text": "would be when you use spring like a web client where you wait for this response but in a in a non-blocking manner so",
    "start": "809360",
    "end": "816720"
  },
  {
    "text": "let's now go back into our controller here we can see everything compiles and now let's rerun this",
    "start": "816720",
    "end": "824880"
  },
  {
    "text": "application and we will now go back into J meter and let's remove everything we've collected so far and now I switch",
    "start": "825079",
    "end": "832240"
  },
  {
    "text": "it to using speakers async now let's run this and what we now will do is again",
    "start": "832240",
    "end": "837759"
  },
  {
    "text": "just call our speakers async endpoint but but with the one difference that we will call this in a non-blocking manner",
    "start": "837759",
    "end": "843800"
  },
  {
    "text": "so what should happen is when we call our speakers async endpoint as soon as our thread will block it will be be",
    "start": "843800",
    "end": "851199"
  },
  {
    "text": "freed to be used by another thread so we can see here 20 seconds are over and",
    "start": "851199",
    "end": "856600"
  },
  {
    "text": "let's now see what the response here is and we can see it takes 1 second for all the calls because this is basically what",
    "start": "856600",
    "end": "863639"
  },
  {
    "text": "we we have expected because this takes these 200 threats but as soon as something blocks it will freed to do",
    "start": "863639",
    "end": "869839"
  },
  {
    "text": "something else and this is the huge improvement with compatable futures or with reactive programming but the",
    "start": "869839",
    "end": "876759"
  },
  {
    "text": "problem here of course is which we'll see later that it's a little bit more complex but just just for you to keep in",
    "start": "876759",
    "end": "883959"
  },
  {
    "text": "mind if you can't use Java 21 maybe some of you can't use Java 21 because you are",
    "start": "883959",
    "end": "889279"
  },
  {
    "text": "still stuck with with earlier versions and when you have problems using then the blocking approach because it's too",
    "start": "889279",
    "end": "895720"
  },
  {
    "text": "slow maybe give this completable future here a try because when you you have like simple end points it's really easy",
    "start": "895720",
    "end": "901440"
  },
  {
    "text": "to make this really really much faster now but the problem is that let's",
    "start": "901440",
    "end": "907639"
  },
  {
    "text": "go back here we were here in yeah we say we were in the early days we say well this is",
    "start": "907639",
    "end": "914519"
  },
  {
    "text": "really fast it's really nice to use now the problem is what we discovered later",
    "start": "914519",
    "end": "919880"
  },
  {
    "text": "is we also need Simplicity Simplicity and easy to use and easy to read code so",
    "start": "919880",
    "end": "925639"
  },
  {
    "text": "what do I mean with this let me show you how we can make things little a bit more complex let's say we want to have for",
    "start": "925639",
    "end": "931959"
  },
  {
    "text": "each of the speaker his talk so for the sake of Simplicity we will just say we have one talk per speaker now let's say",
    "start": "931959",
    "end": "939279"
  },
  {
    "text": "we have this here for our blocking approach we say we have slash talks and",
    "start": "939279",
    "end": "944720"
  },
  {
    "text": "we have a list of talk and we say get talks here now after we've created this",
    "start": "944720",
    "end": "951600"
  },
  {
    "text": "record here of talk we will just say this is has a speaker in there to to",
    "start": "951600",
    "end": "957399"
  },
  {
    "text": "keep it really easy and now what we need to do first of course is we have to get all the speakers so we say fake HTP",
    "start": "957399",
    "end": "964279"
  },
  {
    "text": "service retrieve speakers now for each of the speakers we call map and then",
    "start": "964279",
    "end": "970240"
  },
  {
    "text": "what we do is for each of them we will call a new method we will create so",
    "start": "970240",
    "end": "975440"
  },
  {
    "text": "retrieve retrieve talk and we pass in our speaker now what will this retrieve talk",
    "start": "975440",
    "end": "982600"
  },
  {
    "text": "do here let's create this this will return a talk and we will say here threat. sleep",
    "start": "982600",
    "end": "991160"
  },
  {
    "text": "of 500 milliseconds so a little bit shorter and we'll say return new talk",
    "start": "991160",
    "end": "996880"
  },
  {
    "text": "where pass in the speaker now the problem with this approach is that when",
    "start": "996880",
    "end": "1002240"
  },
  {
    "text": "we go back here we can see that this even if this will not block at all this will take 6 seconds for each request",
    "start": "1002240",
    "end": "1009839"
  },
  {
    "text": "because this one takes 1 second and this one takes 10 times 500 milliseconds",
    "start": "1009839",
    "end": "1016399"
  },
  {
    "text": "which is 5 seconds in our case now of course you may be say we could change this to parallel stream but you have to",
    "start": "1016399",
    "end": "1022639"
  },
  {
    "text": "be you have to always think about that parallel streams work on like a also work on a threat pool and this threat",
    "start": "1022639",
    "end": "1029240"
  },
  {
    "text": "pool is the size of your amount of cores you have in your application minus one so for example in my case I think I have",
    "start": "1029240",
    "end": "1035400"
  },
  {
    "text": "10 cores in there then it would only have a parallelism of nine threads so",
    "start": "1035400",
    "end": "1041360"
  },
  {
    "text": "this is also of course this would make it in this case faster but if you have like 100 speakers like we have here at",
    "start": "1041360",
    "end": "1047400"
  },
  {
    "text": "at the conference then this would just not be as fast as it could be but we can",
    "start": "1047400",
    "end": "1052600"
  },
  {
    "text": "see here it's basically easy to understand what the code does we could make this even shorter by using a method",
    "start": "1052600",
    "end": "1058360"
  },
  {
    "text": "reference here but I will leave this so what's the problem when we change this",
    "start": "1058360",
    "end": "1063480"
  },
  {
    "text": "to make it non-blocking so we have our talks as syn like this and we have a",
    "start": "1063480",
    "end": "1070520"
  },
  {
    "text": "list of talk but now what we need to do is we need to wrap this in a completable",
    "start": "1070520",
    "end": "1075880"
  },
  {
    "text": "future list of talks and we say get talks async like this and now it gets a",
    "start": "1075880",
    "end": "1082120"
  },
  {
    "text": "little bit more complicating because we are not allowed to break this this chain of reactivity so what we need to do is",
    "start": "1082120",
    "end": "1089440"
  },
  {
    "text": "we have our final war speaker future in this case and we say fake HTTP service",
    "start": "1089440",
    "end": "1095440"
  },
  {
    "text": "retrieve speakers async and now we need to also map over these speakers but in a",
    "start": "1095440",
    "end": "1100799"
  },
  {
    "text": "like different manner we need to say return speaker future and then of course we can see here we have so many",
    "start": "1100799",
    "end": "1106679"
  },
  {
    "text": "different options to use but we want to map over these over our completable",
    "start": "1106679",
    "end": "1111760"
  },
  {
    "text": "future so it's really hard to really know what it does because we can see basically everything here Returns the",
    "start": "1111760",
    "end": "1118720"
  },
  {
    "text": "same as we pass in here so it's it's it's really hard everything here um returns this completable future now in",
    "start": "1118720",
    "end": "1124880"
  },
  {
    "text": "our case we use then apply async then apply sorry not not async here and what",
    "start": "1124880",
    "end": "1130480"
  },
  {
    "text": "this will do what this will do is it will take the response here we get back as soon as we get it the speakers here",
    "start": "1130480",
    "end": "1137440"
  },
  {
    "text": "which is a list of speakers and what we then will do is we have to map over this like we did here in our",
    "start": "1137440",
    "end": "1143799"
  },
  {
    "text": "speakers so we say here we have our final war talk Futures and we say",
    "start": "1143799",
    "end": "1150280"
  },
  {
    "text": "speakers. map and what we then will say is for",
    "start": "1150280",
    "end": "1155320"
  },
  {
    "text": "each of the speaker we will say fake HTTP service retrieve talk async because you also",
    "start": "1155320",
    "end": "1163400"
  },
  {
    "text": "need to do this asynchronously because if we do this blocking then this will it will still block again in our in our our",
    "start": "1163400",
    "end": "1168919"
  },
  {
    "text": "call so let's just say here we have a tool list and let's create this method",
    "start": "1168919",
    "end": "1175480"
  },
  {
    "text": "here so this of course will also be again return a completable future of talk now we can just copy this from up",
    "start": "1175480",
    "end": "1182600"
  },
  {
    "text": "here from the supply async can just copy this here and put this down there and",
    "start": "1182600",
    "end": "1187960"
  },
  {
    "text": "the only thing we need to change is of course we don't need to return a list of speakers but we need to return a talk",
    "start": "1187960",
    "end": "1194000"
  },
  {
    "text": "basically the same as we did here we pass in the speaker and of course these are five 100 milliseconds in case",
    "start": "1194000",
    "end": "1201159"
  },
  {
    "text": "instead so now but when we now say return talk Futures we will see that we",
    "start": "1201159",
    "end": "1206520"
  },
  {
    "text": "get an error when you say talk Futures we will see this does not work well why",
    "start": "1206520",
    "end": "1211640"
  },
  {
    "text": "is this and this is like the another thing which is really complicating with reactive stuff because this here when we",
    "start": "1211640",
    "end": "1219039"
  },
  {
    "text": "check when we get the real type we can see this is a list of completable Futures of talk so what we really need",
    "start": "1219039",
    "end": "1225679"
  },
  {
    "text": "is we need this the other way around we need to have this in one comp completable future so what we have to do",
    "start": "1225679",
    "end": "1230720"
  },
  {
    "text": "here additionally is we have to say return talk Futures map we have our",
    "start": "1230720",
    "end": "1236400"
  },
  {
    "text": "completable future join here because we want to wait until all the completable Futures are done and then we use to list",
    "start": "1236400",
    "end": "1243039"
  },
  {
    "text": "here and in this case now we can see that our code now compiles now I now I",
    "start": "1243039",
    "end": "1248520"
  },
  {
    "text": "will not run this in in in J meter but of course this will be much faster it will be like 1 and a half seconds but",
    "start": "1248520",
    "end": "1256120"
  },
  {
    "text": "when we compare these two this is much more complex and it also has so much",
    "start": "1256120",
    "end": "1261760"
  },
  {
    "text": "more boiler play code around it so so what are the problems with this reactive",
    "start": "1261760",
    "end": "1267600"
  },
  {
    "text": "approach the problem is it's in my opinion it's hard to write and I also like as mentioned I work like since 89",
    "start": "1267600",
    "end": "1274799"
  },
  {
    "text": "years I also work as heavily with JavaScript and typescript and we also have there of course only like um a we",
    "start": "1274799",
    "end": "1281240"
  },
  {
    "text": "work with asynchro um with asynchronous code heavily but even there we switched over to using like this asyn approach so",
    "start": "1281240",
    "end": "1288960"
  },
  {
    "text": "that we don't have to wrap everything like in this in this callbacks or in This Promise stand blocks because it's",
    "start": "1288960",
    "end": "1295760"
  },
  {
    "text": "really hard to understand these these wrapped code constructs it's also hard of course to write it but maybe you can",
    "start": "1295760",
    "end": "1302400"
  },
  {
    "text": "do this and but some sometimes later you have to read your code again and this is really hard to do because it has like a",
    "start": "1302400",
    "end": "1309320"
  },
  {
    "text": "steep learning curve because you have many different Frameworks you can use so",
    "start": "1309320",
    "end": "1314400"
  },
  {
    "text": "every framework has its own functions every every framework has its own like ways of handling things and it's also",
    "start": "1314400",
    "end": "1322200"
  },
  {
    "text": "really hard to test the code because the business code almost gets like secondary when we when we code with reactive code",
    "start": "1322200",
    "end": "1328799"
  },
  {
    "text": "because you have to rep basically your your code to make it like synchronous again in your tests so that you can",
    "start": "1328799",
    "end": "1335480"
  },
  {
    "text": "really test your code and last but not least it's also like the compatibility when you have you need to have",
    "start": "1335480",
    "end": "1342320"
  },
  {
    "text": "reactivity from from the first part until the database to really keep this",
    "start": "1342320",
    "end": "1347440"
  },
  {
    "text": "in in a reactive flow so you need to have like r2dbc connections you need to have you also have different Frameworks",
    "start": "1347440",
    "end": "1353960"
  },
  {
    "text": "different implementations you need to use so it's it's really hard in my opinion so we went now from like the",
    "start": "1353960",
    "end": "1360559"
  },
  {
    "text": "early days of reactive to say well this is cool this is fast but now we are later back here we say well this is way",
    "start": "1360559",
    "end": "1366440"
  },
  {
    "text": "too complex because they went and so they went back and they were thinking",
    "start": "1366440",
    "end": "1371520"
  },
  {
    "text": "okay well what was the problem why we went away from this blocking approach",
    "start": "1371520",
    "end": "1376919"
  },
  {
    "text": "and this is where they started look into project Loom like 2019 and back then it",
    "start": "1376919",
    "end": "1382240"
  },
  {
    "text": "was also called project fiber and what this and they were thinking well we need",
    "start": "1382240",
    "end": "1388000"
  },
  {
    "text": "more threats basically we need to make sure that our our CPU is is always",
    "start": "1388000",
    "end": "1393440"
  },
  {
    "text": "working and the problem why we went away from this blocking approach is that we",
    "start": "1393440",
    "end": "1398919"
  },
  {
    "text": "couldn't afford more threats so they checked how many threats do we really need or want and they said well we need",
    "start": "1398919",
    "end": "1405840"
  },
  {
    "text": "1 million threats basically to be as fast as reactive programming because",
    "start": "1405840",
    "end": "1411640"
  },
  {
    "text": "when we have a CPU usage of less than 100% reactive programming will always be fast because it can ensure that when we",
    "start": "1411640",
    "end": "1418679"
  },
  {
    "text": "have enough traffic that that really the CPU usage is as high as possible so and they went on and they",
    "start": "1418679",
    "end": "1426279"
  },
  {
    "text": "found the solution the virtual threats so to keep it simple what are virtual threats the important thing to",
    "start": "1426279",
    "end": "1432919"
  },
  {
    "text": "understand is that virtal threats are only a Java construct like they only exist in in the jvm like in the in the",
    "start": "1432919",
    "end": "1439640"
  },
  {
    "text": "jdk itself so we have then the platform threats which are when you nowadays read",
    "start": "1439640",
    "end": "1446200"
  },
  {
    "text": "from platform threads in Java these are like these Legacy threads these normal threads where you when you create one it",
    "start": "1446200",
    "end": "1452080"
  },
  {
    "text": "creates an operating system thread now let me show you how they work so we",
    "start": "1452080",
    "end": "1458480"
  },
  {
    "text": "have here our virtual thread and the important part is how they work is let's say we have our speaker example and a",
    "start": "1458480",
    "end": "1465520"
  },
  {
    "text": "request comes into our SL speaker endpoint the Tomcat so the server which is running will create with it with with",
    "start": "1465520",
    "end": "1472720"
  },
  {
    "text": "its executor service a new virtual thread because virtual threats should not be pulled virtual threats are like",
    "start": "1472720",
    "end": "1479200"
  },
  {
    "text": "single units of work they get created and then thrown away as soon as you are done with them and as soon as they have",
    "start": "1479200",
    "end": "1485000"
  },
  {
    "text": "done their work now the virtual thread as soon as it gets created it looks for",
    "start": "1485000",
    "end": "1490080"
  },
  {
    "text": "a worker thread now the worker thread we can see here these are platform threads and they are connected of course with",
    "start": "1490080",
    "end": "1496640"
  },
  {
    "text": "the operating system now the the virtual thread looks for this one of these work threads in a pool",
    "start": "1496640",
    "end": "1503320"
  },
  {
    "text": "because the work threads are not just like in the hundreds but they have like a fixed pool size of at most like 40",
    "start": "1503320",
    "end": "1509880"
  },
  {
    "text": "threads because mostly these are enough for the virtual threads so the request",
    "start": "1509880",
    "end": "1515320"
  },
  {
    "text": "comes in it looks for a worker thread and it connects itself to this worker",
    "start": "1515320",
    "end": "1520799"
  },
  {
    "text": "now it does its work for example it creates the request to our endpoint and then it sends out the request but as",
    "start": "1520799",
    "end": "1527200"
  },
  {
    "text": "soon as it figures out okay I'm blocking currently so I don't have any so I have nothing to do I'm just waiting it will",
    "start": "1527200",
    "end": "1534200"
  },
  {
    "text": "remove itself from the worker threats and will just put itself onto the Heap",
    "start": "1534200",
    "end": "1540200"
  },
  {
    "text": "so it will remove it from so that the worker can do other stuff now the cool",
    "start": "1540200",
    "end": "1545679"
  },
  {
    "text": "part is also that as soon as the response comes back from like for example our htpm point and the signal",
    "start": "1545679",
    "end": "1552559"
  },
  {
    "text": "comes in from the operating system that the data is available the virtual threat will tell hey I need another worker",
    "start": "1552559",
    "end": "1559159"
  },
  {
    "text": "thread to continue my work so it will then look for another worker thread which is available so it doesn't have to",
    "start": "1559159",
    "end": "1566039"
  },
  {
    "text": "be the same because for us when we program when we use this thread we don't have to care if it's a worker or a",
    "start": "1566039",
    "end": "1572600"
  },
  {
    "text": "virtual thread these virtual threats are like normal threats in our case but they are much cheaper to create like they",
    "start": "1572600",
    "end": "1578760"
  },
  {
    "text": "cost only like in the kilobytes so you can always think of they are like a thousand times cheaper than a a normal",
    "start": "1578760",
    "end": "1586399"
  },
  {
    "text": "thread so this is why you can create like a thousand times more threats so let's create now some threats",
    "start": "1586399",
    "end": "1593520"
  },
  {
    "text": "and let me show you how this how this works so we will go back here in intell and we will open our virtual threads",
    "start": "1593520",
    "end": "1600440"
  },
  {
    "text": "test here now we can see here when we started last time 1 million threats then",
    "start": "1600440",
    "end": "1605480"
  },
  {
    "text": "our code blocked so let's try this again but we will change something we will change this from off platform to off",
    "start": "1605480",
    "end": "1613200"
  },
  {
    "text": "virtual and we can see here nothing else changed we still can use the nor normal",
    "start": "1613200",
    "end": "1618520"
  },
  {
    "text": "threat it's still a normal threat when you're working with this so what we will do here is we will call watch count",
    "start": "1618520",
    "end": "1624039"
  },
  {
    "text": "threats from java we can see currently 12 120 threats are running so let's now start this",
    "start": "1624039",
    "end": "1630279"
  },
  {
    "text": "here and we will see here that only like 40 threats got created it's a little bit",
    "start": "1630279",
    "end": "1635480"
  },
  {
    "text": "more but like these are from intell because the J unit needs to run but we can see here there are only 40 threats",
    "start": "1635480",
    "end": "1641960"
  },
  {
    "text": "for these 1 million threat virtual threats which got created so what this means is that it's enough for for 1",
    "start": "1641960",
    "end": "1649799"
  },
  {
    "text": "million threats to only need 40 worker threats to be able to really really do",
    "start": "1649799",
    "end": "1655000"
  },
  {
    "text": "their work now let's stop this again and we can see it went back to",
    "start": "1655000",
    "end": "1662080"
  },
  {
    "text": "122 now let's also stop this here now but how does this work well let's change",
    "start": "1662080",
    "end": "1669679"
  },
  {
    "text": "this here up a little bit and let's say we say we have if I equals",
    "start": "1669679",
    "end": "1675159"
  },
  {
    "text": "z in this case we have a threat Dot current threat and we output this and we",
    "start": "1675159",
    "end": "1682159"
  },
  {
    "text": "then have a sleep again of 20 milliseconds and let's do this two more times so what we do here is we basically",
    "start": "1682159",
    "end": "1690720"
  },
  {
    "text": "say We call we want to know okay what is the current we want to get the the",
    "start": "1690720",
    "end": "1697559"
  },
  {
    "text": "thread which was created first then we wait for 20 milliseconds with a thread dot sleep and then we will do this again",
    "start": "1697559",
    "end": "1703880"
  },
  {
    "text": "and again and let's now run this test so what we now can see is when I scroll",
    "start": "1703880",
    "end": "1710760"
  },
  {
    "text": "this up a little bit we can see here that we have a worker one which gets we",
    "start": "1710760",
    "end": "1716559"
  },
  {
    "text": "have this virtual thread 22 which is attached to worker one the first time when it gets called but as soon as this",
    "start": "1716559",
    "end": "1723600"
  },
  {
    "text": "blocks the first time it it disconnects from the worker thread and what it then",
    "start": "1723600",
    "end": "1729480"
  },
  {
    "text": "does is it looks after 20 20 milliseconds for another worker thread and we can see here worker 1 worker 10",
    "start": "1729480",
    "end": "1736720"
  },
  {
    "text": "and worker 4 but the virtual thread is always still the same that's important you don't have to to worry about if this",
    "start": "1736720",
    "end": "1743120"
  },
  {
    "text": "is another threat it's still the same thread and but to make this work what",
    "start": "1743120",
    "end": "1748679"
  },
  {
    "text": "Java had to do is we can go into our let's go into our sleep here and in this",
    "start": "1748679",
    "end": "1754840"
  },
  {
    "text": "thread Sleep Method and we can see here we can go into the Sleep Nanos and when",
    "start": "1754840",
    "end": "1761760"
  },
  {
    "text": "you check earlier versions like version 17 or even earlier you will not find",
    "start": "1761760",
    "end": "1767240"
  },
  {
    "text": "this if check here but what they did is they checking okay if the current threat is a virtual threat then we handle this",
    "start": "1767240",
    "end": "1774159"
  },
  {
    "text": "differently but they of course not only have done it in the Sleep Nanos they have done it everywhere in the jdk so",
    "start": "1774159",
    "end": "1780480"
  },
  {
    "text": "they did like a change with over 100,000 changes in their pull request to change",
    "start": "1780480",
    "end": "1786519"
  },
  {
    "text": "this in the jdk and it had to be done of course in one in in one pull request",
    "start": "1786519",
    "end": "1792399"
  },
  {
    "text": "because otherwise stuff would not have worked as before so really crazy that they um even",
    "start": "1792399",
    "end": "1798640"
  },
  {
    "text": "try to do this and they that it really worked that well so there were no real there were no real issues with this so",
    "start": "1798640",
    "end": "1806760"
  },
  {
    "text": "but this is how this works basically everywhere threats were used now also virtual threats are",
    "start": "1806760",
    "end": "1812159"
  },
  {
    "text": "supported so and now let's go back and",
    "start": "1812159",
    "end": "1817360"
  },
  {
    "text": "re and migrate our blocking application to use Virtual threads so what we will",
    "start": "1817360",
    "end": "1823000"
  },
  {
    "text": "do now is we will go into our application properties file and because",
    "start": "1823000",
    "end": "1828120"
  },
  {
    "text": "we're using springing boot 3.2 or later the only thing we have to change is we have to say spring threats virtual",
    "start": "1828120",
    "end": "1834480"
  },
  {
    "text": "enabled true and what this will do is it will change besides some other stuff it",
    "start": "1834480",
    "end": "1840120"
  },
  {
    "text": "will change the executor service which is used by Tomcat so what do I what do I",
    "start": "1840120",
    "end": "1845480"
  },
  {
    "text": "mean with this let me show you when we are when normally when we have Tomcat we",
    "start": "1845480",
    "end": "1851279"
  },
  {
    "text": "have an Executor service which has a threat pool so we have this threat pool",
    "start": "1851279",
    "end": "1857159"
  },
  {
    "text": "from like around 200 threats which are at mostly running and these threats are",
    "start": "1857159",
    "end": "1862799"
  },
  {
    "text": "pulled and not thrown away when they are done so they're just staying there and waiting but now there is this virtual",
    "start": "1862799",
    "end": "1869039"
  },
  {
    "text": "threat per task executor because these virtual threats as mentioned should not be pulled so each time um an Executor",
    "start": "1869039",
    "end": "1875679"
  },
  {
    "text": "service creates a new thread or gets called it creates a new virtual thread",
    "start": "1875679",
    "end": "1880880"
  },
  {
    "text": "so this is basically what changes but of course there are some other stuff but this is like the most important",
    "start": "1880880",
    "end": "1886240"
  },
  {
    "text": "important thing which changes and what we now will do is we will just rerun our application without any changes to our",
    "start": "1886240",
    "end": "1894440"
  },
  {
    "text": "code and we will do we'll go now back into our J meter and we will call our",
    "start": "1894440",
    "end": "1900519"
  },
  {
    "text": "speaker endpoint again but not the async one but the one which uh with like we",
    "start": "1900519",
    "end": "1906000"
  },
  {
    "text": "did before which was blocking and now the difference what we will see is that because we are using this these virtual",
    "start": "1906000",
    "end": "1912600"
  },
  {
    "text": "threads we now as we have enabled them here in our application properties file the",
    "start": "1912600",
    "end": "1919440"
  },
  {
    "text": "difference now will be that for each of the threats a virtual threat gets created and not from the from the",
    "start": "1919440",
    "end": "1925159"
  },
  {
    "text": "connection pool so there will always be enough threats available so we can see here we are already done let's check the",
    "start": "1925159",
    "end": "1931799"
  },
  {
    "text": "response and we can see it takes one second for all of the requests to finish in in in this amount of time so we",
    "start": "1931799",
    "end": "1938799"
  },
  {
    "text": "didn't need to change anything but just to change the the normal threats to Virtual threats and now this of course is is",
    "start": "1938799",
    "end": "1948279"
  },
  {
    "text": "nice and all but what is here with this example with the talks Endo because as",
    "start": "1948279",
    "end": "1955080"
  },
  {
    "text": "already mentioned even if this will not block it will still take 6 seconds because we have these speakers here",
    "start": "1955080",
    "end": "1961480"
  },
  {
    "text": "which takes 1 second and this retrieve talk which also takes 500 millisecond",
    "start": "1961480",
    "end": "1966600"
  },
  {
    "text": "per per talk so this is where we could of course use parallel stream but as",
    "start": "1966600",
    "end": "1972159"
  },
  {
    "text": "mentioned when we have more speakers like 100 this will still be this will be much much slower and this is where you",
    "start": "1972159",
    "end": "1978919"
  },
  {
    "text": "can use the structur task scope structured task scope basically is like",
    "start": "1978919",
    "end": "1983960"
  },
  {
    "text": "its own executor service where it can just pass them new new tasks and it will",
    "start": "1983960",
    "end": "1990399"
  },
  {
    "text": "it will call each of these tasks in its own virtual thread so we will now use this to rewrite this so that it's as",
    "start": "1990399",
    "end": "1997960"
  },
  {
    "text": "fast as as it can be so how can we do this the first thing",
    "start": "1997960",
    "end": "2004519"
  },
  {
    "text": "is we create a tri with resources block here and and we say we have a scope and",
    "start": "2004519",
    "end": "2009559"
  },
  {
    "text": "we can create a structured task scope like this and we say we want to pass to",
    "start": "2009559",
    "end": "2016279"
  },
  {
    "text": "this to this executor service a talk or more talks like we can pass as many talk",
    "start": "2016279",
    "end": "2022600"
  },
  {
    "text": "requests as we want now what we will do is we will wrap this here inside but of course this is",
    "start": "2022600",
    "end": "2030440"
  },
  {
    "text": "not everything we need to do we need to change some stuff so what we now need to do is I will just remove this here we",
    "start": "2030440",
    "end": "2036519"
  },
  {
    "text": "will say we have inside of this map we will use scope.",
    "start": "2036519",
    "end": "2042919"
  },
  {
    "text": "Fork because what this will do is this allows to pass in a Lambda which then",
    "start": "2042919",
    "end": "2048480"
  },
  {
    "text": "wraps our retrieve talk because this now will take care of calling this this this",
    "start": "2048480",
    "end": "2054960"
  },
  {
    "text": "callable in here but in its own virtual thread so that it will not block now",
    "start": "2054960",
    "end": "2060000"
  },
  {
    "text": "because of that of course we no longer get back a list of talks but we get back",
    "start": "2060000",
    "end": "2065079"
  },
  {
    "text": "a list of subtasks which are which are talks like this and",
    "start": "2065079",
    "end": "2070358"
  },
  {
    "text": "let's call this talk tasks and can remove this here and what",
    "start": "2070359",
    "end": "2076679"
  },
  {
    "text": "this is this subtask here this is something we get back from the scope Fork so let's check what the subtask",
    "start": "2076679",
    "end": "2082440"
  },
  {
    "text": "here is this subtask here is um like basically it's it's an interface which",
    "start": "2082440",
    "end": "2088480"
  },
  {
    "text": "also has an enum in there and it has a state of unavailable success or failed",
    "start": "2088480",
    "end": "2093679"
  },
  {
    "text": "and unavailable basically is it's still running success means it's it was successful and failed means that there",
    "start": "2093679",
    "end": "2100960"
  },
  {
    "text": "was an exception or an error happening the cool part about this is because this is like sequential or or like it's not",
    "start": "2100960",
    "end": "2107560"
  },
  {
    "text": "reactive we can handle these errors really nicely because for example we can call the do exception and can then see",
    "start": "2107560",
    "end": "2113560"
  },
  {
    "text": "what the what the throwable was which got which got thrown so but in our case of course what",
    "start": "2113560",
    "end": "2119960"
  },
  {
    "text": "we will do is we will we think that everything will work fine so we say here",
    "start": "2119960",
    "end": "2125359"
  },
  {
    "text": "when we have passed everything to our to our um scope we wanted to we just call",
    "start": "2125359",
    "end": "2131240"
  },
  {
    "text": "scope. join because you want to wait until all these virtual threats we we",
    "start": "2131240",
    "end": "2136440"
  },
  {
    "text": "sent were done um either had an error or finished successfully and we can see",
    "start": "2136440",
    "end": "2142040"
  },
  {
    "text": "here we have a join until to have like a a deadline but we will just use chin",
    "start": "2142040",
    "end": "2147200"
  },
  {
    "text": "because we know that it will be fast enough for us so and this join as you have seen is also throws an exception so",
    "start": "2147200",
    "end": "2154319"
  },
  {
    "text": "you could also handle this here of course now then the last thing we need to do is we need to say return and then",
    "start": "2154319",
    "end": "2161800"
  },
  {
    "text": "we have our talk tasks here and we map over them and we say subtask doget",
    "start": "2161800",
    "end": "2167240"
  },
  {
    "text": "because we need to get all the results from this list of subtasks and now we are done with this",
    "start": "2167240",
    "end": "2173960"
  },
  {
    "text": "and now let's run our code again and we'll go back into J meter and what we",
    "start": "2173960",
    "end": "2179960"
  },
  {
    "text": "will do here is we will say we have API SL talks and what we now hope to achieve",
    "start": "2179960",
    "end": "2186760"
  },
  {
    "text": "is that this will take only 1 and a half seconds because when we think of about",
    "start": "2186760",
    "end": "2193280"
  },
  {
    "text": "what happens here is this will take one second and this scope here we use this",
    "start": "2193280",
    "end": "2198800"
  },
  {
    "text": "scope Fork will take care of paralyzing all the requests to our speaker to our",
    "start": "2198800",
    "end": "2204280"
  },
  {
    "text": "talk endp point so let's go back into J meter we can see here we are done and",
    "start": "2204280",
    "end": "2209480"
  },
  {
    "text": "let's see the response time graph and we can see it takes one and a half seconds because every request to just retrieve",
    "start": "2209480",
    "end": "2216160"
  },
  {
    "text": "talk endpoint was sent by its own virtual thread now maybe you think well this now",
    "start": "2216160",
    "end": "2222839"
  },
  {
    "text": "looks strangely similar to this completable future yes it doesn't this is why we will rewrite this to make this",
    "start": "2222839",
    "end": "2229319"
  },
  {
    "text": "look much much better because the cool part about this is this structure task scope here we can extend the structure",
    "start": "2229319",
    "end": "2236720"
  },
  {
    "text": "task scope and create our own one and we will create a really easy one we have",
    "start": "2236720",
    "end": "2241800"
  },
  {
    "text": "our class here and let's call this class collection task scope and we say extends",
    "start": "2241800",
    "end": "2248640"
  },
  {
    "text": "structure task scope and we pass in this this generic and the cool part about",
    "start": "2248640",
    "end": "2254280"
  },
  {
    "text": "this structure task scope is we have this handle complete function we can override and this will get called every",
    "start": "2254280",
    "end": "2261160"
  },
  {
    "text": "time a subtask ends even if it's um successful or if it there was an issue",
    "start": "2261160",
    "end": "2266960"
  },
  {
    "text": "so we could now in there of course check for its state and if it's an error we could pass it to an exception list and",
    "start": "2266960",
    "end": "2273000"
  },
  {
    "text": "so on but we will make this much much easier in our case because we know that nothing will fail here so we will say we",
    "start": "2273000",
    "end": "2279440"
  },
  {
    "text": "have our private final collection of T and we say this is our q and we have to",
    "start": "2279440",
    "end": "2285520"
  },
  {
    "text": "use like a concurrent collection because we are accessing this class from different threads so we will use a",
    "start": "2285520",
    "end": "2291400"
  },
  {
    "text": "concurrent linked queue and in this handle complete we will just say okay our queue adds this subtask do getet",
    "start": "2291400",
    "end": "2300119"
  },
  {
    "text": "because we will get the result from our subtask from our retrieve talk and now",
    "start": "2300119",
    "end": "2305280"
  },
  {
    "text": "the only thing which is missing is how can we access it so we will have our list of T here of course and we say get",
    "start": "2305280",
    "end": "2314079"
  },
  {
    "text": "results and now what we need to do here we we need to say we have our this. join",
    "start": "2314079",
    "end": "2320079"
  },
  {
    "text": "because we want to make sure of course that when we call this get results that all the tasks are are done so we will",
    "start": "2320079",
    "end": "2327280"
  },
  {
    "text": "just call it like this and now we say return list copy of",
    "start": "2327280",
    "end": "2334240"
  },
  {
    "text": "Q and this will now return basically do the same as we had in our",
    "start": "2334240",
    "end": "2339760"
  },
  {
    "text": "structure task scope now because of that we can remove some code here so what we",
    "start": "2339760",
    "end": "2345040"
  },
  {
    "text": "no longer need is first we don't need the structure task scope we need our collection task scope which is a talk",
    "start": "2345040",
    "end": "2352280"
  },
  {
    "text": "now what we also don't don't need is we don't need this stream list and so on we can just use scope. get results we don't",
    "start": "2352280",
    "end": "2360520"
  },
  {
    "text": "need the scope join here anymore we also don't need this final list here we don't",
    "start": "2360520",
    "end": "2366280"
  },
  {
    "text": "need this to list because we don't have to Edge right over it we don't need this to be map stream we can just use for",
    "start": "2366280",
    "end": "2374520"
  },
  {
    "text": "each because we just pass it to it and after it we call the scope and this is",
    "start": "2374520",
    "end": "2380480"
  },
  {
    "text": "already everything we need in to to make it work again so we can see here we now",
    "start": "2380480",
    "end": "2385960"
  },
  {
    "text": "have like four or five lines of code or like in this case four lines of code we had to create to make this uh to make",
    "start": "2385960",
    "end": "2393480"
  },
  {
    "text": "this use Virtual threats let's rerun this application and let's see if this is working as",
    "start": "2393480",
    "end": "2400079"
  },
  {
    "text": "expected let's go back into J meter here and do this one more time let's run this",
    "start": "2400079",
    "end": "2406079"
  },
  {
    "text": "and I think we can see here that this is now much easier to understand in my opinion than what we did here because we",
    "start": "2406079",
    "end": "2413119"
  },
  {
    "text": "have just our collection task scope which can be used of course not only for that but for many different approaches",
    "start": "2413119",
    "end": "2419079"
  },
  {
    "text": "where we have to pass in a list of of elements or we want to retrieve a list",
    "start": "2419079",
    "end": "2424319"
  },
  {
    "text": "of elements now we could make this of course even short shorter by for example saying we want to have our own scope.",
    "start": "2424319",
    "end": "2431640"
  },
  {
    "text": "Fork all function but I think this is much easier to understand so we are now",
    "start": "2431640",
    "end": "2437280"
  },
  {
    "text": "done here we are now done here and let's now see and we can see it still takes",
    "start": "2437280",
    "end": "2443119"
  },
  {
    "text": "one and a half seconds so this still works as expected",
    "start": "2443119",
    "end": "2448319"
  },
  {
    "text": "so let's um before we go to the conclusion let's talk a little bit about threat locals because threat locals",
    "start": "2448319",
    "end": "2454640"
  },
  {
    "text": "basically work the same as before but the problem um which we always have to think about",
    "start": "2454640",
    "end": "2460079"
  },
  {
    "text": "is that thread locals are basically used normally on like on like a thread pool",
    "start": "2460079",
    "end": "2467200"
  },
  {
    "text": "so when you use this thread local every time you create a new thread then it will add basically a new object to it",
    "start": "2467200",
    "end": "2474920"
  },
  {
    "text": "and if you don't use remove on your thread locals then it these can get huge",
    "start": "2474920",
    "end": "2480079"
  },
  {
    "text": "especially with the virtual threads because like when you create 1 million threads and you create one new thread every time you call um have a request",
    "start": "2480079",
    "end": "2487880"
  },
  {
    "text": "then this will this it can happen that the the thread L variable gets huge and you have a memory leak so first of",
    "start": "2487880",
    "end": "2494480"
  },
  {
    "text": "course you always need to use the dot remove to remove elements from to remove these elements you don't know you no",
    "start": "2494480",
    "end": "2501520"
  },
  {
    "text": "longer need but if you have really expensive objects and take a look into",
    "start": "2501520",
    "end": "2506560"
  },
  {
    "text": "scoped values because scoped values are like the the replacement for threat",
    "start": "2506560",
    "end": "2512240"
  },
  {
    "text": "locals especially when you use Virtual threads now r now some restrictions",
    "start": "2512240",
    "end": "2518680"
  },
  {
    "text": "first one is synchronized so when you have synchronized blocks then you should",
    "start": "2518680",
    "end": "2523880"
  },
  {
    "text": "of course only when you have heavy IO tasks in there you should replace them with re-entrant locks because",
    "start": "2523880",
    "end": "2530119"
  },
  {
    "text": "synchronized is cannot be patched to use Virtual threads and for example Apache",
    "start": "2530119",
    "end": "2535440"
  },
  {
    "text": "Tomcat had huge problems with synchronized blocks when they switched over to Virtual threats but they just",
    "start": "2535440",
    "end": "2541280"
  },
  {
    "text": "exchanged everything with re-entrant locks so what this means is you can just",
    "start": "2541280",
    "end": "2546800"
  },
  {
    "text": "say um new re-entrant lock here this is a like a normal Java class and can then",
    "start": "2546800",
    "end": "2552359"
  },
  {
    "text": "use it to basically make um achieve the same as you have with with synchronized",
    "start": "2552359",
    "end": "2559200"
  },
  {
    "text": "so and the next thing which you can't really solve is native calls because",
    "start": "2559200",
    "end": "2565440"
  },
  {
    "text": "when you have native calls to for example um C code then it's possible that the that they access addresses or",
    "start": "2565440",
    "end": "2571880"
  },
  {
    "text": "memory addresses and because the virtual threads move itself into the Heat",
    "start": "2571880",
    "end": "2577680"
  },
  {
    "text": "this will get Complicated by accessing the the memory so then it will be pinned in the viral thread and the virtual",
    "start": "2577680",
    "end": "2584559"
  },
  {
    "text": "thread will be pinned together and the last thing of course is when you have CPU heavy tasks so when you're doing",
    "start": "2584559",
    "end": "2590359"
  },
  {
    "text": "something which takes which the where the threat does not block but really does work then this will of course not",
    "start": "2590359",
    "end": "2597079"
  },
  {
    "text": "give any speed Improvement because the as long as the thread is busy it needs a worker thread and it cannot disconnect",
    "start": "2597079",
    "end": "2603839"
  },
  {
    "text": "itself from the from the worker now what's the conclusion and I think this is a real alternative to",
    "start": "2603839",
    "end": "2610359"
  },
  {
    "text": "reactive because it makes it so much easier to create a proof of concept because you can simply like even if you",
    "start": "2610359",
    "end": "2616839"
  },
  {
    "text": "have your own framework you can change your executor service to the virtual threat per task executor and can then",
    "start": "2616839",
    "end": "2623200"
  },
  {
    "text": "see if your application is still running and you don't have to like rebuild everything from scratch to reactive to",
    "start": "2623200",
    "end": "2629160"
  },
  {
    "text": "see if this really works the next thing is it's also done in the jdk it's not like a thirdparty library so you can",
    "start": "2629160",
    "end": "2636160"
  },
  {
    "text": "really just use what's inside jdk and there is nothing to build around",
    "start": "2636160",
    "end": "2641640"
  },
  {
    "text": "existing issues with the with the jdk and the last thing is also it's much less spiler plate so have you have",
    "start": "2641640",
    "end": "2648000"
  },
  {
    "text": "simple patterns you can use like for example with the structure task scope and they really took their time to to",
    "start": "2648000",
    "end": "2653599"
  },
  {
    "text": "think about what could possibly go wrong and fix that beforehand so yeah we are currently now",
    "start": "2653599",
    "end": "2660880"
  },
  {
    "text": "at Java 21 and I think we went full circle back from from the blocking approach so that",
    "start": "2660880",
    "end": "2667880"
  },
  {
    "text": "we went from blocking to the reactive and then we understood that well this is a little bit too complicated and I think",
    "start": "2667880",
    "end": "2673599"
  },
  {
    "text": "with Cher 21 we have a real new nice feature in in our tool belt to",
    "start": "2673599",
    "end": "2679720"
  },
  {
    "text": "use so that it's much easier to work with this blocking code without having to change our like our whole code",
    "start": "2679720",
    "end": "2686240"
  },
  {
    "text": "base and of course we don't know what the future will bring but I think Chia 21 really is made it easier and made it",
    "start": "2686240",
    "end": "2694599"
  },
  {
    "text": "is now ready for the future to be used even when you have all the applications and you",
    "start": "2694599",
    "end": "2700240"
  },
  {
    "text": "update so we are almost done so just just a quick did I found this is",
    "start": "2700240",
    "end": "2705359"
  },
  {
    "text": "interesting because when I gave this talk like earlier um this year and sometimes my ID just froze the complete",
    "start": "2705359",
    "end": "2712079"
  },
  {
    "text": "computer just my complete MacBook just froze and then later they released such an an update of of of um of Mac OS where",
    "start": "2712079",
    "end": "2720920"
  },
  {
    "text": "they said well prior to that the apps that include Java May quit unexpectedly now they finally fixed this so we went",
    "start": "2720920",
    "end": "2726960"
  },
  {
    "text": "through this this whole stuff really really smoothly so I really really enjoyed that and now let's see if there",
    "start": "2726960",
    "end": "2733720"
  },
  {
    "text": "are some questions maybe not yeah maybe there are some questions in the in the",
    "start": "2733720",
    "end": "2739720"
  },
  {
    "text": "audience or just ask me later on on LinkedIn or on on Twitter if you'd like",
    "start": "2739720",
    "end": "2746319"
  },
  {
    "text": "cool then yeah if you leave and I think for everyone and for all the other talks you also will um see this um today",
    "start": "2746319",
    "end": "2754240"
  },
  {
    "text": "please um put in some feedback because it's it's really helps also like the conference to see what you liked and",
    "start": "2754240",
    "end": "2760280"
  },
  {
    "text": "what you did not like yeah thanks you for joining and wish you an awesome last day at the",
    "start": "2760280",
    "end": "2766640"
  },
  {
    "text": "developer conference thank you",
    "start": "2766640",
    "end": "2771240"
  }
]