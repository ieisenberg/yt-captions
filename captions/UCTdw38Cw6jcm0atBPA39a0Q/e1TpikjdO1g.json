[
  {
    "text": "okay can yeah microphone works so good morning uh I'm Jonathan Miller I'm a",
    "start": "1920",
    "end": "7040"
  },
  {
    "text": "software engineer think and I'm here to give a very incomplete guide to C++ object lifetimes as it turns out because",
    "start": "7040",
    "end": "13639"
  },
  {
    "text": "this topic is incredibly complicated and even the C++ standard is wrong so we're",
    "start": "13639",
    "end": "19199"
  },
  {
    "text": "just going to get started a little bit here so it's a guide about object lifetime so the obvious question is um",
    "start": "19199",
    "end": "25720"
  },
  {
    "text": "what the objects and what is Lifetime objects are fundamental in C++ um this",
    "start": "25720",
    "end": "33280"
  },
  {
    "text": "is a quote from the standard you're going to see those a lot uh intro. object paragraph one the constructs in a",
    "start": "33280",
    "end": "38360"
  },
  {
    "text": "C++ program create destroy refer to access and manipulate objects so",
    "start": "38360",
    "end": "43680"
  },
  {
    "text": "everything you do in a C++ program is you change objects in some way and by objects um the C++ standard doesn't mean",
    "start": "43680",
    "end": "50360"
  },
  {
    "text": "objects in the term object oriented um it's a term of art from the C++ standard and to understand that we need to",
    "start": "50360",
    "end": "56079"
  },
  {
    "text": "understand three other things um the first is storage uh the second is volume and the third is",
    "start": "56079",
    "end": "62399"
  },
  {
    "text": "type so let's begin with storage um the fundamental storage unit is a bite um and then the memory is just",
    "start": "62399",
    "end": "69920"
  },
  {
    "text": "a sequence of bytes which have a unique address so see are some memory we've got some bytes um and each of those bites",
    "start": "69920",
    "end": "77479"
  },
  {
    "text": "contain a specific configuration of bits you have highlighted the one that is Ox 41 right it's just some bite that",
    "start": "77479",
    "end": "83479"
  },
  {
    "text": "contains some bits and that a storage now value is about the meaning of Oaks for one you",
    "start": "83479",
    "end": "90360"
  },
  {
    "text": "just have a bite it has some bits what does it mean it could be an 8bit integer",
    "start": "90360",
    "end": "96040"
  },
  {
    "text": "65 and then it has the value 65 it could be the character uppercase",
    "start": "96040",
    "end": "102119"
  },
  {
    "text": "a it could be the start of the string that begins with uppercase a or some other character in the middle of the",
    "start": "102119",
    "end": "108399"
  },
  {
    "text": "string it couldn't actually be something on its own but just part of the 32-bit integer and you have to look at the",
    "start": "108399",
    "end": "113560"
  },
  {
    "text": "surrounding bites in order to figure out what it means and so on there are very different ways of uh figuring F",
    "start": "113560",
    "end": "121079"
  },
  {
    "text": "out so elements of programming um says that a datum is a finite sequence of Zer",
    "start": "121079",
    "end": "126680"
  },
  {
    "text": "and one and then if we interpret it in a particular way that is a value so I've just got a sequence of bits and then we",
    "start": "126680",
    "end": "132599"
  },
  {
    "text": "have some interpretation like this is an 8bit unsend integer and then we get the value out of that",
    "start": "132599",
    "end": "139800"
  },
  {
    "text": "bite and now a type simply is this interpretation so if the type unsign",
    "start": "139800",
    "end": "146879"
  },
  {
    "text": "Char means that we take one bite of memory and we interpret it as an bit unsign integer if you take ins we need to take",
    "start": "146879",
    "end": "153239"
  },
  {
    "text": "four bytes and interpret them as a 32bit to complement integer and types can be more complex for example still string",
    "start": "153239",
    "end": "158959"
  },
  {
    "text": "means we take 24 bytes of memory and we interpret them as pointers to a n-terminated sequence of char so now we",
    "start": "158959",
    "end": "164239"
  },
  {
    "text": "have to follow and look at some more bytes in order to get the full value um a size and a",
    "start": "164239",
    "end": "170040"
  },
  {
    "text": "capacity and so a storage contains some datum a value is um is the like",
    "start": "170040",
    "end": "175360"
  },
  {
    "text": "mathematical thing when you get an interpretation uh and the type is that interpretation",
    "start": "175360",
    "end": "180480"
  },
  {
    "text": "a non object is simply something that has a particular type occupies a region of storage at some address and contains",
    "start": "180480",
    "end": "186519"
  },
  {
    "text": "a value so we've got a couple of objects uh the first object is called X and has",
    "start": "186519",
    "end": "191959"
  },
  {
    "text": "Type int and it currently stores the value for2 so it lifts at some address where occupy some bytes and those bytes",
    "start": "191959",
    "end": "198280"
  },
  {
    "text": "will if interpreted as an INT will be 42 the second object is a float y um it",
    "start": "198280",
    "end": "204440"
  },
  {
    "text": "currently stores 3.14 and then in the last statement we can change the value of the object so we have the object we",
    "start": "204440",
    "end": "210560"
  },
  {
    "text": "just change the byes to know they to a different datum which now represents 11 now it's important to point out that",
    "start": "210560",
    "end": "217560"
  },
  {
    "text": "for example functions aren't objects even though a function has like some storage logically on your CPU um they",
    "start": "217560",
    "end": "224120"
  },
  {
    "text": "are not objects in the terms of the C++ standard so a function f isn't an object but they can be implicitly converted to",
    "start": "224120",
    "end": "229959"
  },
  {
    "text": "function pointers which themselves can become objects right so F isn't an object but PF which is a pointer to F is",
    "start": "229959",
    "end": "236920"
  },
  {
    "text": "an object similarly references aren't objects um references are just aliases",
    "start": "236920",
    "end": "242200"
  },
  {
    "text": "to other objects so we've got an object X and then we've got an alias for X called ref and this isn't a new object",
    "start": "242200",
    "end": "248720"
  },
  {
    "text": "it's just an alias to refer to an existing object using another name so those are objects now what is",
    "start": "248720",
    "end": "255599"
  },
  {
    "text": "Life Time Well objects have properties and one of those properties is the lifetime it's a pretty important",
    "start": "255599",
    "end": "261639"
  },
  {
    "text": "property because all other properties only will apply while an object is in its",
    "start": "261639",
    "end": "266800"
  },
  {
    "text": "lifetime and in particular um there are significant restrictions on the use before the lifetime has started and",
    "start": "266800",
    "end": "272240"
  },
  {
    "text": "after the lifetime has ended that's pretty important to figure out when the lifetime of an object begins and",
    "start": "272240",
    "end": "278919"
  },
  {
    "text": "ends so at a very high level overview this is sort of the life cycle of an object objects occupy storage so the",
    "start": "278919",
    "end": "285160"
  },
  {
    "text": "first step is always occupy some storage for the object we then need to initialize the",
    "start": "285160",
    "end": "290440"
  },
  {
    "text": "object U this is in codes we will see why later um and this starts the lifetime of the object so now we've got",
    "start": "290440",
    "end": "295639"
  },
  {
    "text": "an object whose lifetime has started we can then freely use it we can read its value we can change value we can do whatever we want eventually the object",
    "start": "295639",
    "end": "303000"
  },
  {
    "text": "will be destroyed and this will end the lifetime and finally if we don't want a memory League we then have to dealate the",
    "start": "303000",
    "end": "308520"
  },
  {
    "text": "storage and this is a very high level overview of what's going on and we're going to look at many specific examples",
    "start": "308520",
    "end": "314080"
  },
  {
    "text": "of how that works throughout the talk now some terminology uh the",
    "start": "314080",
    "end": "319240"
  },
  {
    "text": "standard says that object can be created and this isn't an operation that actually starts the lifetime it just",
    "start": "319240",
    "end": "324880"
  },
  {
    "text": "means now we've got an object we can talk about um that like like it's just like a declaration of a thing we're",
    "start": "324880",
    "end": "331560"
  },
  {
    "text": "going to have an object um and it will have a lifetime at some other point it's not an operation that starts the",
    "start": "331560",
    "end": "336919"
  },
  {
    "text": "lifetime but confusingly the standard says destroyed which sort of is the opposite curve created but this is",
    "start": "336919",
    "end": "341960"
  },
  {
    "text": "actually the name for the operation that ends the lifetime so I try to be careful and not say create to mean start the lifetime",
    "start": "341960",
    "end": "349120"
  },
  {
    "text": "and instead say start the lifetime but it's the opposite of destroy it so it slips",
    "start": "349120",
    "end": "355319"
  },
  {
    "text": "through also to point out that lifetime is something the standard invented to describe semantics on the abstract machine it has absolutely nothing to do",
    "start": "355319",
    "end": "362000"
  },
  {
    "text": "with your CPU right your CPU doesn't care about lifetime it's purely a terms of art for the C standard to define",
    "start": "362000",
    "end": "369440"
  },
  {
    "text": "semantics so with that let's get started and let's begin with the simplest way we can start life STS using variable",
    "start": "369440",
    "end": "376639"
  },
  {
    "text": "declarations. object paragraph one an object is created by a definition so here we've got a",
    "start": "376639",
    "end": "382319"
  },
  {
    "text": "definition of variable X and as we will see um this will both create the object allocate storage for it and start the",
    "start": "382319",
    "end": "388280"
  },
  {
    "text": "lifetime there we can then use the object um and then at the closing base it will be destroyed which will end the",
    "start": "388280",
    "end": "393680"
  },
  {
    "text": "lifetime and also deallocate the storage to figure out when exactly um the storage allocation and the lifetime",
    "start": "393680",
    "end": "399680"
  },
  {
    "text": "starts we have to uh look at a property which is called storage duration so the",
    "start": "399680",
    "end": "405720"
  },
  {
    "text": "storage duration is a property of an object that defines the minimal potential life term of the storage containing the object and it depends on",
    "start": "405720",
    "end": "411479"
  },
  {
    "text": "how we created it and for definitions there are three storage durations uh static threat and automatic storage",
    "start": "411479",
    "end": "418160"
  },
  {
    "text": "duration so let's look at those automatic stor duration is the simplest on if you have a varable that",
    "start": "418160",
    "end": "424960"
  },
  {
    "text": "just in a block scope or parameter scope without any special keywords it has automatic station um and the storage",
    "start": "424960",
    "end": "431759"
  },
  {
    "text": "essentially is allocated when we encounter the definition and then deallocated when the block",
    "start": "431759",
    "end": "438160"
  },
  {
    "text": "ends so here we've got our two objects and as soon as control FL reaches those lines we will allocate storage for them",
    "start": "438160",
    "end": "444360"
  },
  {
    "text": "again on the actual CPU we will probably allocate storage before that but this isn't about the CPU this is about the model of of the C++ abstruct machine so",
    "start": "444360",
    "end": "451879"
  },
  {
    "text": "now we've got storage for A and B uh we then enter another block allocate storage for c um deallocate the storage",
    "start": "451879",
    "end": "458120"
  },
  {
    "text": "at the closing brace and then deallocate A and B when we reach the end of",
    "start": "458120",
    "end": "463360"
  },
  {
    "text": "main static storage varation is variables that are in globos scope using static or extern um and their storage",
    "start": "463800",
    "end": "469960"
  },
  {
    "text": "station is even simpler it's essentially the storage exists all the time so the storage is allocated sometime before the",
    "start": "469960",
    "end": "475360"
  },
  {
    "text": "program starts and deallocated sometime after the program ends so we've got a whole bunch of global variables one",
    "start": "475360",
    "end": "481440"
  },
  {
    "text": "regular one one uh with like static linkage um then one function local static and then a declaration of a",
    "start": "481440",
    "end": "488039"
  },
  {
    "text": "global inside a function and all of those have static storage duration which means the storage exists all the time we",
    "start": "488039",
    "end": "493159"
  },
  {
    "text": "don't have to worry about it related to that is threat local so if you use threat local they have threat",
    "start": "493159",
    "end": "499599"
  },
  {
    "text": "storage duration um there are static storage duration lifetime exists throughout the program threat local means throughout the threat and there's",
    "start": "499599",
    "end": "505479"
  },
  {
    "text": "also a copy for each threat so when we have a a variable with thread local storage um when we start",
    "start": "505479",
    "end": "511560"
  },
  {
    "text": "main we've got one copy of this uh for the main thread and then we launch another thread we will allocate another",
    "start": "511560",
    "end": "516800"
  },
  {
    "text": "copy for that um start storage for that um and then when the threat is destroyed we decate the",
    "start": "516800",
    "end": "522760"
  },
  {
    "text": "copy but that's a storage station and it's important to point out that storage duration is not the same as the lifetime",
    "start": "522760",
    "end": "529240"
  },
  {
    "text": "of an object it's a super set but not necessarily the same the lifetime only starts after",
    "start": "529240",
    "end": "535680"
  },
  {
    "text": "we've done two things the first is we've allocated the storage we've looked at that and then we completed the",
    "start": "535680",
    "end": "540839"
  },
  {
    "text": "initialization if there is any and only then do we start the lifetime and these things generally happen at different",
    "start": "540839",
    "end": "548519"
  },
  {
    "text": "times the good news is for automatic station they don't they happen at the same time there are some terms and",
    "start": "548519",
    "end": "554320"
  },
  {
    "text": "condition that we will see later on but in general when we have a variable of automatic storage station when we allocate the storage we also start the",
    "start": "554320",
    "end": "561079"
  },
  {
    "text": "lifetime for static and thir storage station it's incredibly complicated um then we have to look at function local",
    "start": "561079",
    "end": "566279"
  },
  {
    "text": "static with this Global scope we've got const in it we've got Dynamic initialization Nifty counters the module dependency graph inline variables it's",
    "start": "566279",
    "end": "573200"
  },
  {
    "text": "entirely separate talk like I gave a 60 Minute talk just about that you can find that if you look on YouTube like I'm not",
    "start": "573200",
    "end": "579600"
  },
  {
    "text": "going to go into that now I just say automatic storage station it's easy static and thread storage station watch",
    "start": "579600",
    "end": "585120"
  },
  {
    "text": "another talk so it the standard says initialization if any is complete",
    "start": "585120",
    "end": "591720"
  },
  {
    "text": "because in general an object can have the lifetime start without a known value so when we've got allocated",
    "start": "591720",
    "end": "599920"
  },
  {
    "text": "and the object has an indeterminate value until we do initialization essentially and so what this means is",
    "start": "599920",
    "end": "606480"
  },
  {
    "text": "then when we got something like an inex it has no Constructor we don't provide initializer um then we immediately done",
    "start": "606480",
    "end": "612839"
  },
  {
    "text": "because we don't need to do initialization so we start the livetime with an indeterminate value and if we then try to read from that value we've",
    "start": "612839",
    "end": "618959"
  },
  {
    "text": "got undefined Behavior because we're reading an indeterminant value however however you can read it",
    "start": "618959",
    "end": "625600"
  },
  {
    "text": "after the assignment and the assignment in the third line is only okay because we already started the lifetime of an",
    "start": "625600",
    "end": "631200"
  },
  {
    "text": "object right the first line starts the lifetime of an object which means that we can assign it however we cannot read",
    "start": "631200",
    "end": "636399"
  },
  {
    "text": "it yet because we don't have a value but but if the first line didn't start the lifetime of the object then even the",
    "start": "636399",
    "end": "642040"
  },
  {
    "text": "assignment would be unrefined Behavior because we don't have an object to assign to right so this is the idea and this behavior is going to",
    "start": "642040",
    "end": "648720"
  },
  {
    "text": "change in C++ 26 so instead of being undefined Behavior line two it's no going to become erroneous and erroneous",
    "start": "648720",
    "end": "655360"
  },
  {
    "text": "is a new kind of behavior it's sort of like undefined Behavior but the compiler is supposed to be less aggressive about",
    "start": "655360",
    "end": "661079"
  },
  {
    "text": "it um so it's essentially it's still an error to do it but the compiler cannot optimize based on the assumption that it",
    "start": "661079",
    "end": "667079"
  },
  {
    "text": "didn't happen so it cannot eliminate branches based on that and things like that essentially it's only allowed to",
    "start": "667079",
    "end": "672160"
  },
  {
    "text": "like either give you an indeterminant value or like issue a diagnostic but not do further optimization so it's sort of",
    "start": "672160",
    "end": "677519"
  },
  {
    "text": "a tamed down version of undefined Behavior to have like less problems with that and that concludes variable",
    "start": "677519",
    "end": "684240"
  },
  {
    "text": "declarations are there any questions so far",
    "start": "684240",
    "end": "689399"
  },
  {
    "text": "okay so let's look at new and delete an object is created by new",
    "start": "691880",
    "end": "697399"
  },
  {
    "text": "expression and then we've got a corresponding delete expression which destroys an object so what we can do here is we can",
    "start": "697399",
    "end": "704200"
  },
  {
    "text": "write new in um this will create the object allocate storage for it and start the life time um because uh it will new both",
    "start": "704200",
    "end": "711800"
  },
  {
    "text": "allocate storage and because it also does initialization it will also start the lifetime because we've did two of those things um we can then use the",
    "start": "711800",
    "end": "718399"
  },
  {
    "text": "object um at the end we can destroy it which will end the lifetime and decate the storage and note that there are two",
    "start": "718399",
    "end": "725320"
  },
  {
    "text": "objects one is the in on the Heap and the other one is the in pointer on the stack which governs by the rule that we",
    "start": "725320",
    "end": "730959"
  },
  {
    "text": "had before it's also possible to create one with indeterminate values right so this",
    "start": "730959",
    "end": "736800"
  },
  {
    "text": "does the left time with an indeterminant value um reading it is undefined Behavior but the sign through makes it",
    "start": "736800",
    "end": "742360"
  },
  {
    "text": "fine exactly like that like in the previous section but we've got more control over when we do the initialization when we do the",
    "start": "742360",
    "end": "748360"
  },
  {
    "text": "destruction so that is pretty straightforward so something more",
    "start": "748360",
    "end": "753720"
  },
  {
    "text": "interesting are level two temporary objects an object is created when a temporary object is created which is a",
    "start": "753720",
    "end": "761240"
  },
  {
    "text": "topology so consider this code we've got our function f which takes an INT",
    "start": "761240",
    "end": "766680"
  },
  {
    "text": "reference and then we call it the 42 now 42 isn't an object 42 is a value right",
    "start": "766680",
    "end": "771959"
  },
  {
    "text": "it doesn't have a storage it doesn't live anywhere it's just the number 42 but references are a this as to objects",
    "start": "771959",
    "end": "777279"
  },
  {
    "text": "so we need some object in order to bind the reference to so the call creates a temporary",
    "start": "777279",
    "end": "783160"
  },
  {
    "text": "object uh this process is called temporary materialization conversion which is a great phrase for hangman and",
    "start": "783160",
    "end": "788959"
  },
  {
    "text": "the standard says A P value of type T can be converted to an x value of type T this conversion initiates a temporary",
    "start": "788959",
    "end": "794440"
  },
  {
    "text": "object of type T from the pr value by evaluating the pr value with the temporary object as its result object and produces an x value denoting the",
    "start": "794440",
    "end": "800600"
  },
  {
    "text": "temporary object these are a lot of sentences to mean when we need an object and we have a PR value we create a",
    "start": "800600",
    "end": "806880"
  },
  {
    "text": "temporary object initialized by that Val value so be right um this happens for",
    "start": "806880",
    "end": "812560"
  },
  {
    "text": "example when we buy into a reference to a PR value as we see in the previous example it also means when we do member",
    "start": "812560",
    "end": "817680"
  },
  {
    "text": "access on a PR value so when we want to call a member function we need a this pointer the this pointer needs to point some address so we cannot have a PR",
    "start": "817680",
    "end": "824279"
  },
  {
    "text": "value of that like a just literal we have to store it somewhere in memory in order to have an",
    "start": "824279",
    "end": "829360"
  },
  {
    "text": "address similarly when we use arrays like arrays really don't want really want to be pointer so we need some",
    "start": "829360",
    "end": "834480"
  },
  {
    "text": "storage so whenever you have like an AR PR value it will be created in a temporary object",
    "start": "834480",
    "end": "840720"
  },
  {
    "text": "interestingly also when you like call a function that returns a PR value for example um the function that returns a",
    "start": "840720",
    "end": "846199"
  },
  {
    "text": "St string by value when you call that and ignore the result you will still need to run the destructor of the St string otherwise you will have a memory",
    "start": "846199",
    "end": "852759"
  },
  {
    "text": "leak and to run the destructor we need a this pointer so the compiler will create a temporary object initialize it with",
    "start": "852759",
    "end": "858160"
  },
  {
    "text": "the result of the function call and immediately you destroy it so what is the lifetime of a",
    "start": "858160",
    "end": "865120"
  },
  {
    "text": "temporary when the temporary is created the lifetime starts immediately this instuction happens after we done",
    "start": "865120",
    "end": "872320"
  },
  {
    "text": "evaluating the full expression essentially at the semicolon so we've got a function f which contains the whole bunch of references and then we're",
    "start": "872320",
    "end": "878519"
  },
  {
    "text": "calling it with two PR values 11 and the result of G right so two literal values and because we bind those references we",
    "start": "878519",
    "end": "885000"
  },
  {
    "text": "need to create temporary objects initialized to those references to make that work and then while we inside the body of f the references the objects",
    "start": "885000",
    "end": "891920"
  },
  {
    "text": "stay valid so we can freely use the references and they only destroyed at the semicolon so after we're done with f",
    "start": "891920",
    "end": "897639"
  },
  {
    "text": "which is good which means that that if a function takes something by reference it's always guaranteed that the argument stays valid throughout the entire",
    "start": "897639",
    "end": "903480"
  },
  {
    "text": "execution of the function but you have to be careful by taking its address and storing it somewhere else because it could be a temporary that is then",
    "start": "903480",
    "end": "909079"
  },
  {
    "text": "destroyed by that part this is the basic rule there are two exceptions um and those are called",
    "start": "909079",
    "end": "915279"
  },
  {
    "text": "temporary lifetime extension so the first happens when you bind a reference directly to a temporary the lifetime of",
    "start": "915279",
    "end": "921800"
  },
  {
    "text": "the temporary is extended to the lifetime of the reference so here in the first line we create a temporary object because if we bind the reference to a t",
    "start": "921800",
    "end": "928440"
  },
  {
    "text": "like to a p and under without lifetime extension it would we would then reach the semicolon",
    "start": "928440",
    "end": "934560"
  },
  {
    "text": "and immediately destroy the temporary object and then we just have a dangling reference this would be incredibly useless so instead life term extension",
    "start": "934560",
    "end": "941199"
  },
  {
    "text": "kicks in and the temporary is only destroyed when we like the reference go goes out of scope so the the entire",
    "start": "941199",
    "end": "948560"
  },
  {
    "text": "execution of main ref is valid and it can be used while this seems nice you have to",
    "start": "948560",
    "end": "955480"
  },
  {
    "text": "be incredibly careful it has to be a reference that directly binds to the pr value so for example um get strings",
    "start": "955480",
    "end": "962440"
  },
  {
    "text": "returns a vector of string by value which makes it the pr value in the first line we're binding the entire Vector to",
    "start": "962440",
    "end": "967639"
  },
  {
    "text": "a reference here we're binding a reference directly to a PR value so we get a temporary lifetime extension we",
    "start": "967639",
    "end": "973480"
  },
  {
    "text": "don't get it in the second line this is because we're calling the subscript operator and the subscript operator",
    "start": "973480",
    "end": "979399"
  },
  {
    "text": "returns a reference so in order to call the subscript operator we do the temporary materialization create a temporary object call the subscript",
    "start": "979399",
    "end": "985880"
  },
  {
    "text": "operator and return a reference this reference depends on the the life ter of the temporary object but then the second",
    "start": "985880",
    "end": "991279"
  },
  {
    "text": "line just initializes a reference based on another reference at no point do we bind the reference directly to PR value",
    "start": "991279",
    "end": "997199"
  },
  {
    "text": "right we just bind the reference to the reference returned by the square bracket operator which could come from anywhere right so we don't get temporary lifetime",
    "start": "997199",
    "end": "1003600"
  },
  {
    "text": "extension and string immediately dangles and must not be used so you really shouldn't rely on temporary left",
    "start": "1003600",
    "end": "1009639"
  },
  {
    "text": "extension right because it's incredibly finicky um and only works in a very specific use",
    "start": "1009639",
    "end": "1016360"
  },
  {
    "text": "case the second case for temporary lifetime extension is much nicer um when you do range W for Loop um it might",
    "start": "1016360",
    "end": "1022839"
  },
  {
    "text": "create some Temporaries in order to call begin and end and so on um and all of those are destroyed at the end of the",
    "start": "1022839",
    "end": "1028079"
  },
  {
    "text": "follow Loop and this is the actual safe Behavior so this works re iterating over",
    "start": "1028079",
    "end": "1034280"
  },
  {
    "text": "the entire Vector the temporary is destroyed after we're done with the follow Loop but this one also works",
    "start": "1034280",
    "end": "1039678"
  },
  {
    "text": "because we create a temporary object in order to iterate it and All Temporary objects created while doing so are",
    "start": "1039679",
    "end": "1045319"
  },
  {
    "text": "destroyed at the end of the followup so even though we don't do the other case of temporary lifetime extension this",
    "start": "1045319",
    "end": "1050640"
  },
  {
    "text": "one's actually safe um this is new in 23 or something and I've been told not all compilers Implement that but I'm not",
    "start": "1050640",
    "end": "1056880"
  },
  {
    "text": "talking about compilers I'm talking about the standard so I don't care about that um and it essentially means you don't have to worry when you do a range",
    "start": "1056880",
    "end": "1062640"
  },
  {
    "text": "based followup um no matter how many tempers are created and they're perfectly safe to use without this rule",
    "start": "1062640",
    "end": "1069280"
  },
  {
    "text": "the second line um would would essentially immediately dangle because we itating over something that's Destro",
    "start": "1069280",
    "end": "1074720"
  },
  {
    "text": "but we good here um this just works okay questions about temporary",
    "start": "1074720",
    "end": "1081240"
  },
  {
    "text": "objects okay so let's talk about placement",
    "start": "1082120",
    "end": "1087760"
  },
  {
    "text": "new an object is created by new expression there's a special kind of new expression placement new placement new",
    "start": "1087760",
    "end": "1094799"
  },
  {
    "text": "is an explicit Constructor call if you've got some memory you can call placement new on that memory to",
    "start": "1094799",
    "end": "1100799"
  },
  {
    "text": "create an object in that storage not that I'm using um double",
    "start": "1100799",
    "end": "1106520"
  },
  {
    "text": "colon and the void star this is intentional because placement new can be overloaded you can overload it for your own pointer types and in your own",
    "start": "1106520",
    "end": "1113039"
  },
  {
    "text": "namespace so if you don't call it all the time by casting to voidstar and using like the glob scope you might call",
    "start": "1113039",
    "end": "1119280"
  },
  {
    "text": "a user defined placement new that can do whatever um there is a standard Library function construct ad which just calls",
    "start": "1119280",
    "end": "1125240"
  },
  {
    "text": "Place menu for you in a safe way um but because like it just would make some of the examples more bigger so I'm not",
    "start": "1125240",
    "end": "1132440"
  },
  {
    "text": "using that here but like in actual code you should use construct add instead of placement new in order to avoid the",
    "start": "1132440",
    "end": "1138000"
  },
  {
    "text": "double colon and static C there when we manually create an object by manually starting a SL time um the",
    "start": "1138000",
    "end": "1144919"
  },
  {
    "text": "compiler will not destroy it for us so we also need to destroy it and for that we can manually call the destructor uh",
    "start": "1144919",
    "end": "1150080"
  },
  {
    "text": "the Syntax for that is object do tiller and then the name of the type and due to some weird Quirk of the grammar the name",
    "start": "1150080",
    "end": "1156520"
  },
  {
    "text": "of the type has to be an identifier this means that t cannot be int because int is a keyword it also means that t can be",
    "start": "1156520",
    "end": "1163360"
  },
  {
    "text": "stood string because this isn't a single identify right but this is just a syntactic restriction um if you use for",
    "start": "1163360",
    "end": "1169679"
  },
  {
    "text": "example a type Dev you can always destroy an in you just cannot write till the in you have to write first write using my int equals ins and then you can",
    "start": "1169679",
    "end": "1176520"
  },
  {
    "text": "write do till my in it's just a weird CK of the grammar that it doesn't allow only allows an identifier so instead I",
    "start": "1176520",
    "end": "1183600"
  },
  {
    "text": "am going to use St destroyed which works for everything because here T is a template parameter right and the grammar",
    "start": "1183600",
    "end": "1189720"
  },
  {
    "text": "allows that we can put T in there even though T is actually like an in it's just a syntactic restriction um and it",
    "start": "1189720",
    "end": "1195000"
  },
  {
    "text": "works out fine so this actually destroys the destructor C++ is such a weird language sometimes but anyways so now",
    "start": "1195000",
    "end": "1202440"
  },
  {
    "text": "we've got some memory and we can destroy create objects in that memory how do we get the memory right how do we get",
    "start": "1202440",
    "end": "1208320"
  },
  {
    "text": "memory that doesn't already create contain objects right um we can use Malo",
    "start": "1208320",
    "end": "1213400"
  },
  {
    "text": "Malo simply allocate storage then we've got a pointer to some storage and then we can call place New to start the",
    "start": "1213400",
    "end": "1219039"
  },
  {
    "text": "lifetime create object and move on both lives right we can then move it uh use it um and in the end we have to destroy",
    "start": "1219039",
    "end": "1225240"
  },
  {
    "text": "the lifetime um and then free the memory right and so now we've got the full",
    "start": "1225240",
    "end": "1230559"
  },
  {
    "text": "object life cycle completely manual control right we can decide when to allocate when to start when to end the",
    "start": "1230559",
    "end": "1235720"
  },
  {
    "text": "lifetime and when to De allocate a more C++ version would be to use operate a new so again you have to",
    "start": "1235720",
    "end": "1242000"
  },
  {
    "text": "call it in globos scope it's just like Meo it just allocates to right start the lifetime use it",
    "start": "1242000",
    "end": "1248520"
  },
  {
    "text": "destroy it and then call Operator delete to decate the storage you can also use storage on the",
    "start": "1248520",
    "end": "1255720"
  },
  {
    "text": "St by using an array of unsign chars B so this allocate storage suitable",
    "start": "1255720",
    "end": "1260760"
  },
  {
    "text": "aligned and big enough on it we can then call placement new remember the static art um or use construct it um in order",
    "start": "1260760",
    "end": "1268520"
  },
  {
    "text": "to start the left time we can use it uh we can end the left time um and then",
    "start": "1268520",
    "end": "1273679"
  },
  {
    "text": "it's delocated automatically because it's like automatic storage more interesting as this case we",
    "start": "1273679",
    "end": "1281480"
  },
  {
    "text": "can reuse the memory of an existing object so we've got our int allocated the storage start at the left we then",
    "start": "1281480",
    "end": "1287360"
  },
  {
    "text": "destroy it so now we've ended the lifetime of in object but we still have storage and in the storage we can create",
    "start": "1287360",
    "end": "1293480"
  },
  {
    "text": "a new object alternate right with a different value we start an entirely new object that just happens to live at the",
    "start": "1293480",
    "end": "1299960"
  },
  {
    "text": "same storage as the original one we can then use that freely and then something interesting happens at the closing Bas",
    "start": "1299960",
    "end": "1306039"
  },
  {
    "text": "because we end the lifetime of Which object exactly the original X or the second one we will get back to that",
    "start": "1306039",
    "end": "1312559"
  },
  {
    "text": "later now when you do that you have to be incredibly careful first of all const means con",
    "start": "1312559",
    "end": "1319520"
  },
  {
    "text": "if you create a new object in a storage that is const the behavior is undefined right so we've got a con in we destroy",
    "start": "1319520",
    "end": "1326600"
  },
  {
    "text": "the lifetime this is fine right the object is not destroyed but when we place Men new something in there this is undefined Behavior because const means",
    "start": "1326600",
    "end": "1333120"
  },
  {
    "text": "const we cannot change the value of a const object const is const mostly um",
    "start": "1333120",
    "end": "1339559"
  },
  {
    "text": "only for static threat automatic station so if you've got a constant on the Heap this is totally",
    "start": "1339559",
    "end": "1345720"
  },
  {
    "text": "fine like we allocated the constant on the Heap we we destroy it and then we put something new in the place Con on",
    "start": "1345720",
    "end": "1351159"
  },
  {
    "text": "the Heap doesn't mean anything which is interesting also the destructor still",
    "start": "1351159",
    "end": "1358000"
  },
  {
    "text": "runs um the compiler doesn't care that we call destroy it the compiler will still end the L time of the original",
    "start": "1358000",
    "end": "1363679"
  },
  {
    "text": "object if it's responsible for that so when we destroy for example St string or the destructor and we then we don't put",
    "start": "1363679",
    "end": "1369760"
  },
  {
    "text": "anything back in its place the destructor will run again by the compiler and people have undefined Behavior because we're destroying a",
    "start": "1369760",
    "end": "1374799"
  },
  {
    "text": "string price so after you've called destroy it you have to be really careful and put put something back in",
    "start": "1374799",
    "end": "1381158"
  },
  {
    "text": "there now this code Works we've got a int we destroy it put something new in there we use the new",
    "start": "1382440",
    "end": "1390039"
  },
  {
    "text": "pointer what happens if you now use the original object that's this also",
    "start": "1390640",
    "end": "1395880"
  },
  {
    "text": "work well the answer is it depends so if we",
    "start": "1395880",
    "end": "1403320"
  },
  {
    "text": "do exactly that after the LI of an object has ended a new object is created at the same location a pointer that",
    "start": "1403320",
    "end": "1408559"
  },
  {
    "text": "pointed to original object a reference that refer to the original object or the name of the original object will",
    "start": "1408559",
    "end": "1414039"
  },
  {
    "text": "automatically refer to the new object if the original object is transparently replaceable by the new object so when",
    "start": "1414039",
    "end": "1420600"
  },
  {
    "text": "we've got transparent replacement we're good we can just use the old names the old pointers and the old references as",
    "start": "1420600",
    "end": "1425799"
  },
  {
    "text": "if nothing has happened and this is the definition um a is transparently replaceable by B if a",
    "start": "1425799",
    "end": "1432000"
  },
  {
    "text": "and b use the same storage which makes sense and AFB of the same type and then there are three edge cases",
    "start": "1432000",
    "end": "1438279"
  },
  {
    "text": "uh con objects cannot be transparently replaced base classes and no unique address members and then when we talk about sub",
    "start": "1438279",
    "end": "1445279"
  },
  {
    "text": "objects like member variables uh it applies recursively to the pent object so what this means is here we",
    "start": "1445279",
    "end": "1452400"
  },
  {
    "text": "okay like we this is a transparent replacement because we're using the same storage and the same type and we are not",
    "start": "1452400",
    "end": "1458679"
  },
  {
    "text": "in one of those weird edge cases put a new in in there we can just use the old name as if nothing has happened because",
    "start": "1458679",
    "end": "1463720"
  },
  {
    "text": "it will sort of automatically point to the new object which makes sense because it lives at the same address",
    "start": "1463720",
    "end": "1470360"
  },
  {
    "text": "this one is also potentially fine right if you do the assignment by calling the destructor and then calling placement",
    "start": "1471559",
    "end": "1476880"
  },
  {
    "text": "new this is transparent replacement if who isn't like a no unique address member or Base Class of some other type",
    "start": "1476880",
    "end": "1483640"
  },
  {
    "text": "right so it's just the Standalone object somewhere on the Stak this is totally fine it's a transparent replacement nobody will even know that he did it but",
    "start": "1483640",
    "end": "1490520"
  },
  {
    "text": "they still shouldn't do it because Fu could be like a base class and then the aut",
    "start": "1490520",
    "end": "1495399"
  },
  {
    "text": "of similarly thing uh goes on for like and you can also do that with individual members you're totally fine nobody will",
    "start": "1496000",
    "end": "1504398"
  },
  {
    "text": "K but for example non transparent is we've got our const in on the Heap we can do a placement new on it because",
    "start": "1504520",
    "end": "1510760"
  },
  {
    "text": "const on the Heap doesn't matter but because it's a const object this is a nonpar replacement so if we then use the",
    "start": "1510760",
    "end": "1517200"
  },
  {
    "text": "old pointer this is undefined behavior and this makes sense because the compiler look at the at the first line",
    "start": "1517200",
    "end": "1522960"
  },
  {
    "text": "it says okay so pointer points to a const object this means that star pointer cannot change since it points to",
    "start": "1522960",
    "end": "1528440"
  },
  {
    "text": "a const object and so every time I see Star pointer I can just replace it with 11 because it's a const object it cannot",
    "start": "1528440",
    "end": "1535039"
  },
  {
    "text": "change and then we change it this is fine it's just the compiler still assumes the star pointer is 11 and so on",
    "start": "1535039",
    "end": "1541520"
  },
  {
    "text": "an optimizing compiler um depending on how Val you hide the placement new this can print",
    "start": "1541520",
    "end": "1546679"
  },
  {
    "text": "11 so this is undefined Behavior but what if you really want to do this for some reason is there any way you can",
    "start": "1546679",
    "end": "1552720"
  },
  {
    "text": "continue using Point well you can use La so la is a MAG",
    "start": "1552720",
    "end": "1558440"
  },
  {
    "text": "identity function it takes a pointer and it Returns the same pointer unchanged but now it's essentially forces the",
    "start": "1558440",
    "end": "1564799"
  },
  {
    "text": "compiler to do reload so if you laun our pointer this is fine it essentially means hey",
    "start": "1564799",
    "end": "1571080"
  },
  {
    "text": "compiler there might be like a new object at this place now so forget everything you knew about the pointer uh and try again right and this makes it",
    "start": "1571080",
    "end": "1579840"
  },
  {
    "text": "better and you can also use St with with references so we've got a reference to the old object we then destroy it put a",
    "start": "1580240",
    "end": "1586000"
  },
  {
    "text": "new one in space um we the reference directly is undefined Behavior because it's not automatically updated but if we",
    "start": "1586000",
    "end": "1592120"
  },
  {
    "text": "take the address of the reference La the pointer and D reference it do is then fine so you can use LA to do like",
    "start": "1592120",
    "end": "1598679"
  },
  {
    "text": "nontransparent replacement want to point out that like La isn't like a magic get out of Ja free",
    "start": "1598679",
    "end": "1604600"
  },
  {
    "text": "card right um it does not prevent undefined behavior in general right so we've got a float on the Heap we assume",
    "start": "1604600",
    "end": "1610399"
  },
  {
    "text": "float and in are the same size um we destroy the float we put a new INT in this place this is a non-transparent",
    "start": "1610399",
    "end": "1616120"
  },
  {
    "text": "replacement um because ins and flat at different types so it's nontransparent we can use the pointer return from",
    "start": "1616120",
    "end": "1622159"
  },
  {
    "text": "placement new we cannot return the pointer from F because we did a nonr transpar replacement and Laing doesn't",
    "start": "1622159",
    "end": "1628240"
  },
  {
    "text": "help because we don't have a float right we have names right it's laund does a very specific thing it does not",
    "start": "1628240",
    "end": "1634360"
  },
  {
    "text": "magically make everything okay this is still undefined Behavior so when do you need to use the",
    "start": "1634360",
    "end": "1640080"
  },
  {
    "text": "laund when you want to re use the storage of con Heap objects remember if then it's not on the Heap you can't",
    "start": "1640080",
    "end": "1645480"
  },
  {
    "text": "replace it at all um base classes are no un address members so never we will get",
    "start": "1645480",
    "end": "1652000"
  },
  {
    "text": "back to that later on questions about placement new",
    "start": "1652000",
    "end": "1659960"
  },
  {
    "text": "okay yes yes every time you want to access the point because otherwise the compiler doesn't know um what you can do",
    "start": "1660399",
    "end": "1666919"
  },
  {
    "text": "is you can launder it then reassign it back in the RW potentially M but",
    "start": "1666919",
    "end": "1673518"
  },
  {
    "text": "yeah like like it's La not like Mark as LA or whatever and then implicitly",
    "start": "1673840",
    "end": "1679200"
  },
  {
    "text": "gen okay so let's talk about implicit object creation another toy an object is",
    "start": "1679200",
    "end": "1686399"
  },
  {
    "text": "created by an operation that implicitly creates objects and the idea is called like",
    "start": "1686399",
    "end": "1691440"
  },
  {
    "text": "this this is like C like C++ you call Melo to get an INT we get a pointer and",
    "start": "1691440",
    "end": "1697360"
  },
  {
    "text": "then we assign that and this really should not be undefined Behavior because this is our CW but under all the rules",
    "start": "1697360",
    "end": "1704960"
  },
  {
    "text": "we've discussed so far this would be undefined Behavior because there's our end object we've just allocated some storage so where do we get the in right",
    "start": "1704960",
    "end": "1711760"
  },
  {
    "text": "what makes this okay and the standard essentially says okay don't",
    "start": "1711760",
    "end": "1717120"
  },
  {
    "text": "worry some operations are specified as implicity creating objects and that means that if we are like the compiler",
    "start": "1717120",
    "end": "1725399"
  },
  {
    "text": "will implicitly create and start the life term of objects if doing so would make the program have defined behavior",
    "start": "1725399",
    "end": "1731159"
  },
  {
    "text": "in other words if it helps you the compiler creates objects for you this is I think the only instance where the",
    "start": "1731159",
    "end": "1737080"
  },
  {
    "text": "compiler goes out of it way to prevent undefined behavior from occurring by implicitly doing something for you uh to",
    "start": "1737080",
    "end": "1742519"
  },
  {
    "text": "make your code well formed so certain sometimes it will implicitly create an in for you in order",
    "start": "1742519",
    "end": "1749000"
  },
  {
    "text": "to make your code well formed um it's important to find out this only applies to types of implicit",
    "start": "1749000",
    "end": "1754880"
  },
  {
    "text": "lifetime this is the definition it's a lot words to say construction and destruction do nothing as we will see",
    "start": "1754880",
    "end": "1761120"
  },
  {
    "text": "this makes sense um because the compiler will not implicitly create an object if that calls some function right it if it",
    "start": "1761120",
    "end": "1766760"
  },
  {
    "text": "does something if it not insert side effects but it will implicit create an INT or any",
    "start": "1766760",
    "end": "1772519"
  },
  {
    "text": "trivial so when does it do that well any allocation functions so for example St",
    "start": "1772519",
    "end": "1777960"
  },
  {
    "text": "Moc um operate a new allocator allocate and so on they are specified as at implicitly creating an object and so",
    "start": "1777960",
    "end": "1784519"
  },
  {
    "text": "when we do this line and we write star pointer equals 11 the comper goes ah this is undefined Behavior but I can",
    "start": "1784519",
    "end": "1789600"
  },
  {
    "text": "implicitly create an INT to make this okay and so the compiler does it to prevent undefined",
    "start": "1789600",
    "end": "1795840"
  },
  {
    "text": "Behavior similarly anything that starts the lifetime of an unsend shs bite away",
    "start": "1796039",
    "end": "1801240"
  },
  {
    "text": "so here the comp looks at this go and say ah we're accessing an INT but we don't have an INT so let me implicitly create an INT inside the buffer to make",
    "start": "1801240",
    "end": "1807919"
  },
  {
    "text": "this well form except not quite because there's a",
    "start": "1807919",
    "end": "1813760"
  },
  {
    "text": "buck in the C++ standard you technically have to use laund to make this SP formed um I don't really like that because this",
    "start": "1813760",
    "end": "1819600"
  },
  {
    "text": "is just clearly a wording issue in the standard Let's Pretend the laer isn't there I still don't want to show you incorrect code but like if this paper is",
    "start": "1819600",
    "end": "1826640"
  },
  {
    "text": "merged we don't need the laer it's supposed to work otherwise this wool is uh totally unnecessary so ignore",
    "start": "1826640",
    "end": "1832399"
  },
  {
    "text": "the laund similarly M Copy and may move right so here we got a Char buffer a",
    "start": "1832399",
    "end": "1839519"
  },
  {
    "text": "Char buffer is not an unsigned ch. bite buffer so this will not implicitly create objects but when we M Copy the",
    "start": "1839519",
    "end": "1844880"
  },
  {
    "text": "INT in there and then later need an in the compiler will say ah we did a M Copy M Copy can complicit create objects so",
    "start": "1844880",
    "end": "1851360"
  },
  {
    "text": "let me create an INT in there to make it well forms and again the laund is shouldn't really be necessary it's just",
    "start": "1851360",
    "end": "1856679"
  },
  {
    "text": "a backend the standard and then some set of like implementation defined functions like presumably map or",
    "start": "1856679",
    "end": "1862880"
  },
  {
    "text": "virtual aloc or some I don't know socket functions or whatever they will implicitly create objects um just like",
    "start": "1862880",
    "end": "1868440"
  },
  {
    "text": "the other way now how does the compiler actually know to create an object right um like",
    "start": "1868440",
    "end": "1876919"
  },
  {
    "text": "at the time we're doing the map it doesn't know that we need an object like we could call placement new on the second line and then we don't need the",
    "start": "1876919",
    "end": "1882960"
  },
  {
    "text": "implicit object equation so what the compiler is actually doing is using time travel",
    "start": "1882960",
    "end": "1888760"
  },
  {
    "text": "so we've got a buffer and then we R the dice and again the laund is unnecessary",
    "start": "1888760",
    "end": "1894200"
  },
  {
    "text": "um but like if the dice ball is even we we require an INT and if the dice ball",
    "start": "1894200",
    "end": "1899760"
  },
  {
    "text": "is odd we require a float so how this is specified is the first line doesn't do anything we then W the dice discover",
    "start": "1899760",
    "end": "1907120"
  },
  {
    "text": "that oh this would be undefined Behavior if we don't have an INT but I just created a buffer so let me travel back",
    "start": "1907120",
    "end": "1912760"
  },
  {
    "text": "in time put an in in the buffer and continue execution right and it's important by the only does it once if we",
    "start": "1912760",
    "end": "1919000"
  },
  {
    "text": "then later need a float um it will not do that and put a float in there because we it already puts an INT in there like",
    "start": "1919000",
    "end": "1924799"
  },
  {
    "text": "there's always no an INT there always has been an in like it just us this time travel um to do that um alternatively",
    "start": "1924799",
    "end": "1931000"
  },
  {
    "text": "you can see like Quantum Dynamics say the buffer contains both an INT or float and then when you observe it it collapses and creates either an INT or a",
    "start": "1931000",
    "end": "1937360"
  },
  {
    "text": "float um this is also why implicit lifetime types cannot have anything do in the Constructor because time travel",
    "start": "1937360",
    "end": "1944240"
  },
  {
    "text": "isn't actually implementable and then you would have like different observable side effects um that would compiler writers probably",
    "start": "1944240",
    "end": "1950399"
  },
  {
    "text": "wouldn't like that so this is just like the abstract machine semantics require time travel at this point on the actual",
    "start": "1950399",
    "end": "1955960"
  },
  {
    "text": "CPU they don't care about lifetime at all so it doesn't actually do anything it's just the wording specified in such",
    "start": "1955960",
    "end": "1961159"
  },
  {
    "text": "a way uh to make it b f and again just like St laer implicit",
    "start": "1961159",
    "end": "1968039"
  },
  {
    "text": "object creation is not a UB prevention card um like this is an INT we reinterpret cast as a float we Lear that",
    "start": "1968039",
    "end": "1974159"
  },
  {
    "text": "for good measure because why not um this is still undefined Behavior because only the specified operations implicitly",
    "start": "1974159",
    "end": "1980399"
  },
  {
    "text": "create an objects and here we don't do any of those right it's not the reinterpret cast that implicitly creates",
    "start": "1980399",
    "end": "1985480"
  },
  {
    "text": "the objects right it's memory allocation like buffer creation so here nothing will implicit to create a float object",
    "start": "1985480",
    "end": "1991519"
  },
  {
    "text": "this is just undefined",
    "start": "1991519",
    "end": "1994360"
  },
  {
    "text": "Behavior the existence of implicit object equation means that code like this is potentially fine but it might",
    "start": "1997919",
    "end": "2005399"
  },
  {
    "text": "not be right so we've got some triv struct this is an implicit LIF and then we have some buffer and we just want to",
    "start": "2005399",
    "end": "2012320"
  },
  {
    "text": "we assume it's data in and if buffer came from one of those operations that implicitly create objects we're good",
    "start": "2012320",
    "end": "2018919"
  },
  {
    "text": "right as soon as we access it the compiler will travel back in time to the operation to create a data object in there uh and then we can read",
    "start": "2018919",
    "end": "2026600"
  },
  {
    "text": "it but if buffer came from some other operation this might be undefined Behavior right because then they compil",
    "start": "2026600",
    "end": "2031880"
  },
  {
    "text": "has nothing to time travel back to in order to create our data object so what we want is a way to like",
    "start": "2031880",
    "end": "2036960"
  },
  {
    "text": "sort of expit L do the implicit object creation and you might say Okay easy just call placement new um data doesn't",
    "start": "2036960",
    "end": "2044559"
  },
  {
    "text": "have a Constructor so this doesn't change the btes I can just read the values right they because presumably those like the buffer came from the",
    "start": "2044559",
    "end": "2050760"
  },
  {
    "text": "network and they want to actually read the btes but even though like data doesn't have a Constructor that does",
    "start": "2050760",
    "end": "2055878"
  },
  {
    "text": "anything like logically placement new creates an entirely new object with an entirely new value like that is",
    "start": "2055879",
    "end": "2061440"
  },
  {
    "text": "completely disjoined from any byes that were there before so while this probably doesn't change the value it's like",
    "start": "2061440",
    "end": "2066919"
  },
  {
    "text": "semantically Chang changes the value so this doesn't do what you",
    "start": "2066919",
    "end": "2071720"
  },
  {
    "text": "want so instead we call another metric Library function start live Time s and start live Time s essentially says hey",
    "start": "2072879",
    "end": "2080320"
  },
  {
    "text": "this is some buffer please implicitly create an object of type data in there it doesn't change the bites it just",
    "start": "2080320",
    "end": "2086679"
  },
  {
    "text": "allows you to read the object as like as if it was over and there's also a version for",
    "start": "2086679",
    "end": "2093000"
  },
  {
    "text": "ARs and that way you can sort of explicitly create an object without changing the underlying",
    "start": "2093000",
    "end": "2099880"
  },
  {
    "text": "storage and while it is a magic standard Library function we can actually Implement an approximation for it so",
    "start": "2099880",
    "end": "2106720"
  },
  {
    "text": "that's a starts we take some pointer and then we move the pointer size of T byes to itself this doesn't actually change",
    "start": "2106720",
    "end": "2113960"
  },
  {
    "text": "the bites but me is one of those operation that implicitly creates objects so if you then later need the T",
    "start": "2113960",
    "end": "2119480"
  },
  {
    "text": "star the compiler will travel back in time to the m to implicitly create the object and that way we've got an object",
    "start": "2119480",
    "end": "2125119"
  },
  {
    "text": "without actually touching the bites the standard implementation is probably like some compiler build that also works with",
    "start": "2125119",
    "end": "2130480"
  },
  {
    "text": "like con storage and is an actual no up and not just a branch and then a no up um and things like that but like in",
    "start": "2130480",
    "end": "2136480"
  },
  {
    "text": "principle it's implementable so now we've got our objects they implicitly created when are",
    "start": "2136480",
    "end": "2142640"
  },
  {
    "text": "they destroyed well objects like are destroyed when we",
    "start": "2142640",
    "end": "2148320"
  },
  {
    "text": "like the destructor calls or when we release or reuse the",
    "start": "2148320",
    "end": "2153680"
  },
  {
    "text": "storage so what this means is that here we got our int object uh when we call",
    "start": "2153680",
    "end": "2159720"
  },
  {
    "text": "placement on it we don't need the destroy ad because the ReUse of the storage will end the lifetime of the",
    "start": "2159720",
    "end": "2164920"
  },
  {
    "text": "original int object and start the lifetime with the new one and this doesn't run the",
    "start": "2164920",
    "end": "2170560"
  },
  {
    "text": "destructor um similarly when we've got an unsend show buffer this actually starts the lifetime of an unsend shway",
    "start": "2171240",
    "end": "2177480"
  },
  {
    "text": "and then we R call placement new over it we end the lifetime of that unsend show away and in that start the lifetime of",
    "start": "2177480",
    "end": "2184280"
  },
  {
    "text": "N and as a consequence like memory leaks aren't undefined by yeah so we've got string and then repl Men new a different",
    "start": "2184280",
    "end": "2191040"
  },
  {
    "text": "string in it without calling the destructor this will end the lifetime without running the destructor so the string will just leak but this is",
    "start": "2191040",
    "end": "2197480"
  },
  {
    "text": "perfectly fine it's just a memor leak right and then also when we do the closing bra um this will destroy the",
    "start": "2197480",
    "end": "2204359"
  },
  {
    "text": "original string objects but because of transfer replacement we're good there too so we will just leak the original",
    "start": "2204359",
    "end": "2209800"
  },
  {
    "text": "string in there because we implicitly Ender the lifetime of the object by using the",
    "start": "2209800",
    "end": "2215359"
  },
  {
    "text": "stage so I'm I'm assuming they're probably questions about this chapter",
    "start": "2215359",
    "end": "2220800"
  },
  {
    "text": "now",
    "start": "2222640",
    "end": "2225640"
  },
  {
    "text": "yeah uh yeah so is it possible to query whether we've got an object at some location essentially uh no because again",
    "start": "2235520",
    "end": "2241839"
  },
  {
    "text": "like the CPU doesn't care about object lifetime so there is no data anywhere to indicate whether you've got an object",
    "start": "2241839",
    "end": "2247599"
  },
  {
    "text": "object um it's you you know that you've got an object when you run your program and it doesn't do weird things that",
    "start": "2247599",
    "end": "2253440"
  },
  {
    "text": "would indicate that you have undefined behavior um that's the on the",
    "start": "2253440",
    "end": "2260560"
  },
  {
    "text": "equation okay let's talk about",
    "start": "2263480",
    "end": "2269599"
  },
  {
    "text": "Provence so consider this code um we've got an two objects X and Y we set y to",
    "start": "2270839",
    "end": "2276760"
  },
  {
    "text": "11 then we then do something with the address of X like pass it to a function and then we return y every compiler is",
    "start": "2276760",
    "end": "2283000"
  },
  {
    "text": "going to look at it and say hey uh Y is 11 we return y we don't change Y in between return 11 right this is a pretty",
    "start": "2283000",
    "end": "2289319"
  },
  {
    "text": "basic optimization that compilers are expected to do but what if this is the definition of",
    "start": "2289319",
    "end": "2294359"
  },
  {
    "text": "do something so do something goes ahead and takes the address adds one to it and sets that to 42 and let's say the St is",
    "start": "2294359",
    "end": "2300599"
  },
  {
    "text": "set up in set such a way that this sort of like even though we gave it X like this reaches y right this changes y then",
    "start": "2300599",
    "end": "2307560"
  },
  {
    "text": "the optimization would be invalid so okay maybe we're just not allowed to like why do something like",
    "start": "2307560",
    "end": "2312760"
  },
  {
    "text": "that right because we don't know that pointer plus one points to Y but what if",
    "start": "2312760",
    "end": "2317920"
  },
  {
    "text": "we do this now whenever we call do something X+ one is the address of",
    "start": "2317920",
    "end": "2325280"
  },
  {
    "text": "Y so the D reference is always fine right because it is the address of Y",
    "start": "2325280",
    "end": "2330760"
  },
  {
    "text": "right that's the same value like we we've checked that before we call it is the comper then still allowed to",
    "start": "2330760",
    "end": "2336480"
  },
  {
    "text": "do the optimization and if it like isn't it's required to like know everything about all the functions that are called",
    "start": "2336480",
    "end": "2342520"
  },
  {
    "text": "which would be pretty bad so and but the answer is yes the compiler is allowed to do the",
    "start": "2342520",
    "end": "2347839"
  },
  {
    "text": "optimization so we're doing something wrong and do something but how are we doing something wrong and do something since just like explicitly check that",
    "start": "2347839",
    "end": "2354599"
  },
  {
    "text": "we've got the same address and the answer is pointers are't just addresses just because two pointers",
    "start": "2354599",
    "end": "2360960"
  },
  {
    "text": "are equal doesn't mean they point for the same object it matters how we got the object",
    "start": "2360960",
    "end": "2367640"
  },
  {
    "text": "and this is called perence so logically again like for the abstract machine not for the actual CPU I point us two things",
    "start": "2367640",
    "end": "2374119"
  },
  {
    "text": "the actual address and the provenance the address is the thing that is physically observable this is what equal",
    "start": "2374119",
    "end": "2379960"
  },
  {
    "text": "equals Compares and then the provenance sort of identifies the object or allocation the pointer was derived",
    "start": "2379960",
    "end": "2385839"
  },
  {
    "text": "from so that remembers how we obtained that particular address and the point of",
    "start": "2385839",
    "end": "2391000"
  },
  {
    "text": "reference is only valid if the address matches like the range of allowed addresses for that particular Providence",
    "start": "2391000",
    "end": "2396680"
  },
  {
    "text": "and the current at that address still matches the provence of the pointer and Cally it doesn't matter how",
    "start": "2396680",
    "end": "2403440"
  },
  {
    "text": "many pointer arithmetics or checks you do you cannot change the pointer perence the pointer always remembers where it",
    "start": "2403440",
    "end": "2409079"
  },
  {
    "text": "came from so what's going on here is even though like the address of X plus one",
    "start": "2409079",
    "end": "2415040"
  },
  {
    "text": "matches the address of Y it's the same address those two pointers have different provinces and that means the",
    "start": "2415040",
    "end": "2420319"
  },
  {
    "text": "out of bound speed is invalid because like pointer plus one is not in the lowerable range of pointers derived from",
    "start": "2420319",
    "end": "2426520"
  },
  {
    "text": "X right it's just pointer the pointer we cannot the pointer arithmetic is invalid",
    "start": "2426520",
    "end": "2432240"
  },
  {
    "text": "because pointer remembers that it points to X and that pointer plus one we no longer have X it's what's going on here",
    "start": "2432240",
    "end": "2438960"
  },
  {
    "text": "and this is what makes it un effect right so the pointer arithmetic didn't",
    "start": "2438960",
    "end": "2444040"
  },
  {
    "text": "change it it's still a pointer to X and now we just out of bounds and aren't allowed to De reference it and this",
    "start": "2444040",
    "end": "2449160"
  },
  {
    "text": "enables the compiler to observe that nobody takes the address like address y doesn't change for anything and it can",
    "start": "2449160",
    "end": "2454920"
  },
  {
    "text": "do the optimization and if we attempt to change it it is undefined",
    "start": "2454920",
    "end": "2461000"
  },
  {
    "text": "beh and now we can also understand what's going on here so we've got a constant on the Heap this is some object",
    "start": "2461680",
    "end": "2467640"
  },
  {
    "text": "with Provence a we then destroy it and put a new object in there and this is",
    "start": "2467640",
    "end": "2473400"
  },
  {
    "text": "now has a different Provence and so reading new pointer is fine but reading star pointer is undefined Behavior",
    "start": "2473400",
    "end": "2479400"
  },
  {
    "text": "because pointer has the provence a and we currently have an object of Provence B right so the destruction and the",
    "start": "2479400",
    "end": "2486760"
  },
  {
    "text": "placement new change the provence at that location which makes the old DE reference",
    "start": "2486760",
    "end": "2492079"
  },
  {
    "text": "invalid and now we can also understand what La is doing it's an identity function for the address but it updates",
    "start": "2492079",
    "end": "2497640"
  },
  {
    "text": "the provence the resulting pointer will get the currently correct Provence for that particular",
    "start": "2497640",
    "end": "2504040"
  },
  {
    "text": "address and this makes it fine and point point out that we cannot use La out type",
    "start": "2504040",
    "end": "2509240"
  },
  {
    "text": "in the previous case because the pointer like the precondition is essentially that the",
    "start": "2509240",
    "end": "2515319"
  },
  {
    "text": "that there was an object at that location sort of before and we can use launder to make something out of bound",
    "start": "2515319",
    "end": "2520599"
  },
  {
    "text": "suddenly be valet and look at a different object it just sort of is meant for this situation and we can also Now understand",
    "start": "2520599",
    "end": "2527119"
  },
  {
    "text": "the difference between transparent and nontransparent replacement If This Were a transparent replacement we wouldn't",
    "start": "2527119",
    "end": "2532560"
  },
  {
    "text": "change the provence and then all the old names and identifies and so on will still remain valid but it's because it's",
    "start": "2532560",
    "end": "2537920"
  },
  {
    "text": "nontransparent we changeed the provence and we need to use launder to sort of get the current",
    "start": "2537920",
    "end": "2543720"
  },
  {
    "text": "provance and provance also Place references um so this is the example of references",
    "start": "2544000",
    "end": "2550160"
  },
  {
    "text": "um because the reference has the old Provence and not the new one directly reading it is undefined but if you la it",
    "start": "2550160",
    "end": "2555240"
  },
  {
    "text": "we get the new Provence and they free to use so every object has unique Provence",
    "start": "2555240",
    "end": "2563599"
  },
  {
    "text": "um all objects in an array have the same forance this allows us to do Point arithmetic for arrays right but not for",
    "start": "2563599",
    "end": "2569440"
  },
  {
    "text": "single objects and then we you reuse the memory this changes the provence unless we do transparent",
    "start": "2569440",
    "end": "2575440"
  },
  {
    "text": "replacement and in that case we can use the LA to update the perence but not in the out of bounds",
    "start": "2575440",
    "end": "2581119"
  },
  {
    "text": "case and this sort of explains a bit why like La is an identity function it doesn't do anything but it actually does",
    "start": "2581119",
    "end": "2586720"
  },
  {
    "text": "something it's because like Provence isn't actually something the CPU cares about it's purely something the standard",
    "start": "2586720",
    "end": "2592119"
  },
  {
    "text": "talks about and remember just because two pointers are equal they do not",
    "start": "2592119",
    "end": "2597680"
  },
  {
    "text": "necessarily point to the same thing which is weird",
    "start": "2597680",
    "end": "2603559"
  },
  {
    "text": "but we want that otherwise we wouldn't have any optimization going on questions about that",
    "start": "2603559",
    "end": "2611318"
  },
  {
    "text": "yes yeah um I don't want to get into that I don't know so like conversion",
    "start": "2613440",
    "end": "2618839"
  },
  {
    "text": "pointers to integers and then back to pointers is an entirely thing that yeah it's",
    "start": "2618839",
    "end": "2624359"
  },
  {
    "text": "complicated",
    "start": "2624359",
    "end": "2627359"
  },
  {
    "text": "yes right",
    "start": "2629640",
    "end": "2634200"
  },
  {
    "text": "yeah yes yes so um you can do the I mean the comparison like you can always write",
    "start": "2635319",
    "end": "2640559"
  },
  {
    "text": "equals equals between any two Ms right um but like perence applies to D reference and if you are within the same",
    "start": "2640559",
    "end": "2647319"
  },
  {
    "text": "array you can do Point arithmetic reach another sub object of that array and de reference it because they have the same",
    "start": "2647319",
    "end": "2652839"
  },
  {
    "text": "provent but if you sort of don't like cross in a different array then it's um",
    "start": "2652839",
    "end": "2658880"
  },
  {
    "text": "also there is like it's not like directly so if you for example have like",
    "start": "2658880",
    "end": "2664599"
  },
  {
    "text": "an array of structs and then all the structs have the same Provence but if you've got a pointer to like some member",
    "start": "2664599",
    "end": "2669920"
  },
  {
    "text": "of that struct you cannot go back to the to the array based on that and the pointer arithmetic based on that because",
    "start": "2669920",
    "end": "2676440"
  },
  {
    "text": "the sort of like the Providence going the other way is different because it's not directly like a linear",
    "start": "2676440",
    "end": "2681480"
  },
  {
    "text": "thing if that makes sense if it doesn't it's not don't",
    "start": "2681480",
    "end": "2686720"
  },
  {
    "text": "worry let's finally then look at type hunting so type hunting we've got some",
    "start": "2689720",
    "end": "2696000"
  },
  {
    "text": "bites they are St in an object of type T1 and we want to interpret that as an object of type",
    "start": "2696000",
    "end": "2701480"
  },
  {
    "text": "T2 and as you probably know you just cannot like re interpret cast doesn't work right so int and Float same size in",
    "start": "2701480",
    "end": "2708680"
  },
  {
    "text": "alignment we've got an INT we've got a pointer to an INT perfectly fine we rein cast that to a float and then derence",
    "start": "2708680",
    "end": "2714760"
  },
  {
    "text": "the float uh the float the float reference un Behavior because we do not have a",
    "start": "2714760",
    "end": "2719920"
  },
  {
    "text": "float we have an in right um but the reinterpret cast is actually fine so like Cally the this is the",
    "start": "2719920",
    "end": "2727480"
  },
  {
    "text": "strict eding Rule and like Cally you say you can't reinterpret cast between unrelated tys um this actually like",
    "start": "2727480",
    "end": "2734119"
  },
  {
    "text": "incorrect the problem is the D reference so the access is the undefined Behavior",
    "start": "2734119",
    "end": "2739480"
  },
  {
    "text": "not the cast right you can't access an object to a pointer of an unrelated type",
    "start": "2739480",
    "end": "2744720"
  },
  {
    "text": "this is because in general rule like the type of a pointer or reference doesn't really matter until you access it and",
    "start": "2744720",
    "end": "2750119"
  },
  {
    "text": "you can freely reinterpret cast between different types and you can store all your pointers as pointers to floats right if you feel like it as long as you",
    "start": "2750119",
    "end": "2756319"
  },
  {
    "text": "reinterpret back before X's you're all good somebody pointed out or when you do",
    "start": "2756319",
    "end": "2761359"
  },
  {
    "text": "pointer arithmetic then they do the offset based on the type but in other situations like the type of the pointer",
    "start": "2761359",
    "end": "2767040"
  },
  {
    "text": "doesn't matter now this is the strict Al Sy um there are some exceptions um for example",
    "start": "2767040",
    "end": "2774480"
  },
  {
    "text": "you can if you have an INT you can reinast it as an unsigned for some reason and vice versa",
    "start": "2774480",
    "end": "2781040"
  },
  {
    "text": "and when you've got the and you can also always re interpret this as a Char and S Char or bite and the idea behind the last one is",
    "start": "2781040",
    "end": "2788720"
  },
  {
    "text": "it allows you to access the object representation the sequence of byes the object represent in memory so we've got",
    "start": "2788720",
    "end": "2794200"
  },
  {
    "text": "our in object we obtain a poter to bite and then we can sort of iterate over the btes that make up the in object and",
    "start": "2794200",
    "end": "2799880"
  },
  {
    "text": "print the individual bites right uh and this is well formed in theory uh in",
    "start": "2799880",
    "end": "2805319"
  },
  {
    "text": "practice this is undefined Behavior because there's a bug in the standards um the because like some drive by",
    "start": "2805319",
    "end": "2812240"
  },
  {
    "text": "wording changes essentially the problem is like we doing pointer arithmetic but the standard doesn't say we've got an",
    "start": "2812240",
    "end": "2817319"
  },
  {
    "text": "array of bites so the pointer arithmetic is undefined Behavior but this is like purely a",
    "start": "2817319",
    "end": "2822400"
  },
  {
    "text": "technical thing like it's meant to be well formed it's just like somebody did some drive by change to some building and know this is accidentally undef",
    "start": "2822400",
    "end": "2828480"
  },
  {
    "text": "behavior um there is um yeah don't worry about it so we cannot use reinet cast to do",
    "start": "2828480",
    "end": "2835839"
  },
  {
    "text": "type hunting less for those situations and not even for this one but ignore that um what we can do",
    "start": "2835839",
    "end": "2843359"
  },
  {
    "text": "uh is I mean what we also can't do is placement new because like Place menu again like logically changes things",
    "start": "2843359",
    "end": "2850119"
  },
  {
    "text": "right this reads an indeterminate value um which makes it um and then we",
    "start": "2850119",
    "end": "2855200"
  },
  {
    "text": "also can't read even with the int because we no longer have an INT we reuse the storage which ends the lifetime of the int so this is undefined",
    "start": "2855200",
    "end": "2863319"
  },
  {
    "text": "behavor um now if you do placement new like that um and then actually just like",
    "start": "2865520",
    "end": "2871920"
  },
  {
    "text": "we use the storage um going back to some earlier thing this you have to then be careful how you got the pointer",
    "start": "2871920",
    "end": "2878640"
  },
  {
    "text": "right because this code is actually undefined behavior um so you got a float pointer that points to the address of",
    "start": "2878640",
    "end": "2886319"
  },
  {
    "text": "the in we then put a float in there and then we Defence the float pointer even though we have a float at that address",
    "start": "2886319",
    "end": "2891480"
  },
  {
    "text": "and we have a point at to float the Prov changed right the float pointer logically is still a pointer to int so",
    "start": "2891480",
    "end": "2898040"
  },
  {
    "text": "the D reference still has the D reference of the int which makes this undefined behavior um it also doesn't",
    "start": "2898040",
    "end": "2904200"
  },
  {
    "text": "matter if we do it afterwards right this is still undefined Behavior because the float pointer still points to an INT even though it is a pointer to float and",
    "start": "2904200",
    "end": "2910200"
  },
  {
    "text": "you have a float at that address it's still a pointer to in right because the provence didn't",
    "start": "2910200",
    "end": "2915440"
  },
  {
    "text": "change you either have to use the pointer directly uh or La",
    "start": "2915440",
    "end": "2920559"
  },
  {
    "text": "it but anyways uh back to we we trying to do type hting here and plac menu doesn't work because it changes the",
    "start": "2920559",
    "end": "2926200"
  },
  {
    "text": "value even when we do all the laundering correctly um another D apparently um I",
    "start": "2926200",
    "end": "2933880"
  },
  {
    "text": "I've moved some slides around at the end and I should have anyway um this also applies to char this behavior um if you",
    "start": "2933880",
    "end": "2941079"
  },
  {
    "text": "got appointed to char and you then reinterpret cast it this is still a poter to an un buffer this is an poter",
    "start": "2941079",
    "end": "2947000"
  },
  {
    "text": "to an in this is the back in the standard this is where you need laund right um there's a paper that says",
    "start": "2947000",
    "end": "2953400"
  },
  {
    "text": "in one of those situation you don't need laer but this is why you currently need launder because the in pointer logically is still a pointer to un",
    "start": "2953400",
    "end": "2960680"
  },
  {
    "text": "centure uh and this means that this is the final use case W laer when you want to reuse memory or storage for different",
    "start": "2960680",
    "end": "2966559"
  },
  {
    "text": "typ type uh which means never but there are some terms and conditions anyways uh sorry about the SL detour back to type",
    "start": "2966559",
    "end": "2973839"
  },
  {
    "text": "Hunning um we can use typ huning with start life time which is unusual but it works right",
    "start": "2973839",
    "end": "2980760"
  },
  {
    "text": "so we've got a in we start the life time of a float this doesn't change the bites it ends the lifetime of the int object",
    "start": "2980760",
    "end": "2986280"
  },
  {
    "text": "start the lifetime of the float object and now we can read it as a float we just no longer have an in right",
    "start": "2986280",
    "end": "2994839"
  },
  {
    "text": "um if you want an INT we have to start an in uh but then because we did",
    "start": "2994839",
    "end": "3000359"
  },
  {
    "text": "like Provence changes we know it like Provence C and not Provence a right so we've got Provence a but then we start a",
    "start": "3000359",
    "end": "3005880"
  },
  {
    "text": "FL with Provence B and then we start another int even though we like transitively back to int like we at",
    "start": "3005880",
    "end": "3011200"
  },
  {
    "text": "Provence C and no long Provence a so the I is undefined Behavior you have to Lear that but like in principle this works",
    "start": "3011200",
    "end": "3017000"
  },
  {
    "text": "like this is typ punning um in the in a really weird way so how do we actually",
    "start": "3017000",
    "end": "3023319"
  },
  {
    "text": "do typ huning uh well we can use M Copy so we got a in we've got a float we copy the bites over the good news here is um",
    "start": "3023319",
    "end": "3030359"
  },
  {
    "text": "this doesn't interact with object lifetime rules at all right we've got an in object we've got a completely separate float objects and then we just",
    "start": "3030359",
    "end": "3036040"
  },
  {
    "text": "copy the bites over so afterwards we still have a float and an INT object because we didn't touch the lifetime of anything we just copied",
    "start": "3036040",
    "end": "3042680"
  },
  {
    "text": "bites the fantasy plus verion oh I press the button and now",
    "start": "3042680",
    "end": "3051480"
  },
  {
    "text": "I've got",
    "start": "3051480",
    "end": "3054680"
  },
  {
    "text": "okay um apparently I have a button to hide like turn off the projector but I",
    "start": "3056920",
    "end": "3062359"
  },
  {
    "text": "don't have a button to turn back on on the",
    "start": "3062359",
    "end": "3069760"
  },
  {
    "text": "so you never learn I have this thing for like eight years um never pressed that",
    "start": "3072760",
    "end": "3078920"
  },
  {
    "text": "button okay um right uh so the C++ version of M Copy is bcast uh bcast is",
    "start": "3078920",
    "end": "3084720"
  },
  {
    "text": "essentially M Copy that works at compile time it's also like a compiler buildin so you like optimized out the actual",
    "start": "3084720",
    "end": "3090119"
  },
  {
    "text": "copy operation and it just just a register thing like it does actual type huning at the CPU but like logically",
    "start": "3090119",
    "end": "3095240"
  },
  {
    "text": "they are different objects so this is how you can do typ ping you can also do typ ping in a very",
    "start": "3095240",
    "end": "3103119"
  },
  {
    "text": "specific situation with reinterpret cast so we've got a struct a that contains an in member and then we can reinterpret",
    "start": "3103119",
    "end": "3110480"
  },
  {
    "text": "cast that Str a to an in pointer and use that because this now refers to the",
    "start": "3110480",
    "end": "3115960"
  },
  {
    "text": "pointer of the first member and then also when we have appointed to the first member we we interpret cast it back to the",
    "start": "3115960",
    "end": "3123119"
  },
  {
    "text": "struct and this exception um is explained in the pointer interconvertible rules so when two",
    "start": "3123119",
    "end": "3130040"
  },
  {
    "text": "objects are pointer like a pointer interconvertible then they have the same address and you can just reinterpret cast to go between one and the other um",
    "start": "3130040",
    "end": "3137760"
  },
  {
    "text": "and then like in the following situations when they are the same objects then they obviously interconvertible uh when one is a union",
    "start": "3137760",
    "end": "3144119"
  },
  {
    "text": "and the other is a member of the Union so we can get from Union member to a union or in the previous example we've got the standard layout class object and",
    "start": "3144119",
    "end": "3150559"
  },
  {
    "text": "one is the First non-static Data member and then we convert a pointer to a class to a pointer to the first member and a pointer to the first member back to the",
    "start": "3150559",
    "end": "3156400"
  },
  {
    "text": "pointer to the class right um this is similar canver a pointer to a base class right but just for the first member in",
    "start": "3156400",
    "end": "3162720"
  },
  {
    "text": "standard layout c um and bonus points in the case with the answer sh buffer where",
    "start": "3162720",
    "end": "3167760"
  },
  {
    "text": "we need launder um the paper just adds another Clause here where it says that an unsent sh buffer is interconvertible",
    "start": "3167760",
    "end": "3173079"
  },
  {
    "text": "with objects inside it and this makes it okay it's just missing the cross there and so and go like this when we've got a",
    "start": "3173079",
    "end": "3180280"
  },
  {
    "text": "standard layer struct we've got a member of the first thing we can reinterpret cast between them this does right and",
    "start": "3180280",
    "end": "3186640"
  },
  {
    "text": "this also doesn't like affect the lifetimes of objects or anything it just we've got our a object it has an in sub object and they just happen to have the",
    "start": "3186640",
    "end": "3193079"
  },
  {
    "text": "same address and we can just convert between pointers between them right this doesn't really do type punning it also only applies to the",
    "start": "3193079",
    "end": "3199799"
  },
  {
    "text": "first member so if you got another in you cannot do Point arithmetic to get the first in and then we interpret cast",
    "start": "3199799",
    "end": "3204839"
  },
  {
    "text": "it because then we've got the provence problem again right so it's a very specific situation U that's probably",
    "start": "3204839",
    "end": "3210040"
  },
  {
    "text": "there for some use Cas and finally the last case where we got object is when we implicitly create",
    "start": "3210040",
    "end": "3216480"
  },
  {
    "text": "the active member of a union which means type hunting by a union also doesn't work Union in and Float initialize the",
    "start": "3216480",
    "end": "3223559"
  },
  {
    "text": "float assign the int uh initialize to int assign the float reading the float is okay because we've this assignment",
    "start": "3223559",
    "end": "3230079"
  },
  {
    "text": "creates the float object at that address um and destroys the in so when we read the in we've got undefined Behavior",
    "start": "3230079",
    "end": "3236119"
  },
  {
    "text": "because we don't have an in object we have a float right changing the active member of a union implicitly um like",
    "start": "3236119",
    "end": "3241920"
  },
  {
    "text": "destroys the old object and creates a new one in a space which means that type ping via Union also does not work so if",
    "start": "3241920",
    "end": "3247799"
  },
  {
    "text": "you want to do type Hunning you have to use bit cast or M Copy because all other situations implicitly ended the life",
    "start": "3247799",
    "end": "3253000"
  },
  {
    "text": "term or never started the life term of the original thing it wouldn't be C++ if there",
    "start": "3253000",
    "end": "3258240"
  },
  {
    "text": "weren't exceptions so there's another exception for this case um the common initial sequence so if you got two types and",
    "start": "3258240",
    "end": "3264760"
  },
  {
    "text": "they both start with an in for example you're permitted to read that in through other member in the union um this is the",
    "start": "3264760",
    "end": "3270520"
  },
  {
    "text": "wording this is the code so Union u struct a struct three both start with an in right then we initialize the a object",
    "start": "3270520",
    "end": "3278000"
  },
  {
    "text": "and read the perf from the a object this is fine because the a object is valid anyway right it's the active one that's",
    "start": "3278000",
    "end": "3283839"
  },
  {
    "text": "good but the second line is also fine right even though we're accessing the B object we only accessing members that",
    "start": "3283839",
    "end": "3289599"
  },
  {
    "text": "are part of the a object anyway right um and so essentially what's going on here",
    "start": "3289599",
    "end": "3294640"
  },
  {
    "text": "is the compiler will at one time we XIs to refer to the currently active one and then the u.b. prefix means the same",
    "start": "3294640",
    "end": "3301440"
  },
  {
    "text": "as u. a. prefix and we just read the a object right um because they both start with the same one and as I said this",
    "start": "3301440",
    "end": "3308640"
  },
  {
    "text": "doesn't change the lifetime of anything the compiler just does the correct access for you which I guess makes it the set situation where the compiler",
    "start": "3308640",
    "end": "3314520"
  },
  {
    "text": "helps you overid undefined beh uh and with that I",
    "start": "3314520",
    "end": "3321640"
  },
  {
    "text": "think yeah I want have turned to do into the other thing so with that I'm done um",
    "start": "3321640",
    "end": "3327200"
  },
  {
    "text": "I want to end some guidelines don't rely on AIT AB creation right it's like really weird really finicky um",
    "start": "3327200",
    "end": "3334599"
  },
  {
    "text": "explicitly use placement new if you want to start an inside a new object or call start lifetime s if you've got some",
    "start": "3334599",
    "end": "3339880"
  },
  {
    "text": "bites and you want to say there's an in in there please give me that end right so if you read some bites from the",
    "start": "3339880",
    "end": "3344960"
  },
  {
    "text": "network call start lifetime s directly into your struct and then you're good whenever possible like placement",
    "start": "3344960",
    "end": "3351920"
  },
  {
    "text": "new and start life give you pointer use those pointers right then you don't have",
    "start": "3351920",
    "end": "3357240"
  },
  {
    "text": "to worry about laund at all right if you directly just use the pointer from placement new and ignore all the old pointers then you're good you don't have",
    "start": "3357240",
    "end": "3363599"
  },
  {
    "text": "to worry about it and use unions instead of unen buffer",
    "start": "3363599",
    "end": "3369599"
  },
  {
    "text": "because un buffer if you got the re cast you potentially need to use launder depending on when this paper lands and",
    "start": "3369599",
    "end": "3374760"
  },
  {
    "text": "how strict you want to avoid undefined Behavior that's really undefined Behavior because the standard has a buck and not because we intended it to be",
    "start": "3374760",
    "end": "3381599"
  },
  {
    "text": "this way just use unit right they're just they work in Contex more easily um it's just nicer you don't have to deal",
    "start": "3381599",
    "end": "3387880"
  },
  {
    "text": "with this and with that how do I get to the",
    "start": "3387880",
    "end": "3393240"
  },
  {
    "text": "last slide now this okay okay",
    "start": "3393240",
    "end": "3399318"
  },
  {
    "text": "sorry I'm too afraid to press shortcuts again so um I work at things cell we're hiring um you don't need to know all the",
    "start": "3400079",
    "end": "3406880"
  },
  {
    "text": "details about object lifetime but if you're interested um I've also got some socks the L value r value socks um you",
    "start": "3406880",
    "end": "3413480"
  },
  {
    "text": "will find them by the slide where you put in the like vote on the how good the talk was and I also have some more here",
    "start": "3413480",
    "end": "3420039"
  },
  {
    "text": "so um keep that in mind when you anyways um thank",
    "start": "3420039",
    "end": "3425359"
  },
  {
    "text": "you are there any other questions",
    "start": "3430839",
    "end": "3436359"
  },
  {
    "text": "yes yeah",
    "start": "3440240",
    "end": "3444240"
  }
]