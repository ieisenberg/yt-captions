[
  {
    "text": "this is second breakfast implicit and mutation based serialization vulnerabilities",
    "start": "4880",
    "end": "10040"
  },
  {
    "text": "in.net I'm Jonathan Burch I hack office for Microsoft if you'd like to talk to me about this presentation or anything",
    "start": "10040",
    "end": "16640"
  },
  {
    "text": "else security related please contact me on Mastadon in this talk I'm going to",
    "start": "16640",
    "end": "22279"
  },
  {
    "text": "describe remote code execution vulnerabilities I found in several net nosql engines I'll describe what I'm",
    "start": "22279",
    "end": "28080"
  },
  {
    "text": "calling a mutation-based serialization vulnerability I'll tell you some techniques for bypassing calization",
    "start": "28080",
    "end": "33719"
  },
  {
    "text": "binders that people usually use to secure sterilizers and then I'm going to tell",
    "start": "33719",
    "end": "39480"
  },
  {
    "text": "you a way to use mutation attacks against binary formatter to bypass calization binders there that's based",
    "start": "39480",
    "end": "44840"
  },
  {
    "text": "off of new research I've done in just the last couple months and I'll also tell you how to defend against all of those",
    "start": "44840",
    "end": "51160"
  },
  {
    "text": "attacks to give a bit of background about what led to this talk part of my day job at Microsoft involves using a",
    "start": "51160",
    "end": "57640"
  },
  {
    "text": "lot of doing a lot of security design reviews so 6 to eight times per week I have a meeting where I'm looking at a",
    "start": "57640",
    "end": "63960"
  },
  {
    "text": "data flow diagram about some product or feature I've never heard of before and telling people how they could design it",
    "start": "63960",
    "end": "69159"
  },
  {
    "text": "more securely and something I try to do in those meetings is I'll also open the repo look at whatever code they've",
    "start": "69159",
    "end": "74280"
  },
  {
    "text": "already written try to identify security anti- patterns or vulnerabilities they've already introduced so I can",
    "start": "74280",
    "end": "79680"
  },
  {
    "text": "discuss those with them too so I've gotten a lot of practice at having maybe 30 minutes to figure out where the",
    "start": "79680",
    "end": "85240"
  },
  {
    "text": "vulnerability is in some giant repo and it's happened that I've done this enough now that I've started doing it outside",
    "start": "85240",
    "end": "91119"
  },
  {
    "text": "of work for fun so the year before last I saw this article on a certain orange",
    "start": "91119",
    "end": "96840"
  },
  {
    "text": "colored website this is an article about light DB light DB is a net nosql",
    "start": "96840",
    "end": "102240"
  },
  {
    "text": "database and so I thought well I'll look at their repo it's open source and when I did that I pretty quickly found this",
    "start": "102240",
    "end": "108159"
  },
  {
    "text": "code and what jumps out about this code is this line this call to type get type",
    "start": "108159",
    "end": "113280"
  },
  {
    "text": "that's being passed a string now when I see that in any repo that makes me unhappy that's a really bad sign but why",
    "start": "113280",
    "end": "120200"
  },
  {
    "text": "is that bad so type get type in net is a method that's used to take a string",
    "start": "120200",
    "end": "126119"
  },
  {
    "text": "that's the name of a type and convert it into a type object the type object for that you've just named essentially and",
    "start": "126119",
    "end": "132800"
  },
  {
    "text": "usually when an application is calling type get type with a string what they're doing is they're setting up to make an",
    "start": "132800",
    "end": "138040"
  },
  {
    "text": "object of that type and that probably means they're either doing some sort of sketchy marshalling or they're writing their own polymorphic serializer and so",
    "start": "138040",
    "end": "146120"
  },
  {
    "text": "the scenario here is essentially that you've got some user providing you a string that says what type your application is going to make and if a",
    "start": "146120",
    "end": "152360"
  },
  {
    "text": "user can choose which types of objects your application's making they can tell your application to sent you what code to run so if a malicious user comes",
    "start": "152360",
    "end": "159319"
  },
  {
    "text": "along they can give you bad code and bad things are happening but let's look at the bigger picture here again let's look",
    "start": "159319",
    "end": "165519"
  },
  {
    "text": "back at how light DB uses typ get type so light DB is a net no SQL engine so no",
    "start": "165519",
    "end": "172840"
  },
  {
    "text": "SQL engines in general as far as databases you're not giving them records you're just throwing objects at them so an application using light DB says store",
    "start": "172840",
    "end": "179680"
  },
  {
    "text": "this object with this index maybe with these extra properties and what light DB is going to do is it's going to take",
    "start": "179680",
    "end": "185400"
  },
  {
    "text": "that object and it's going to serialize it into a bon stream using their own serializer called bon mapper and when",
    "start": "185400",
    "end": "191680"
  },
  {
    "text": "the application says Okay I want the object back then light DB is going to deserialize that b stream with B mapper",
    "start": "191680",
    "end": "197519"
  },
  {
    "text": "to create that object again and give it back to the application so that B that light DB is",
    "start": "197519",
    "end": "203799"
  },
  {
    "text": "creating from the objects that it's storing in a file somewhere B is just a binary encoding of Json so you can",
    "start": "203799",
    "end": "209959"
  },
  {
    "text": "decode it back into Json and look at it and if you decode the Bon that J that light DB creates it looks sort of like",
    "start": "209959",
    "end": "215879"
  },
  {
    "text": "this and if you look at this Json there's this underscore type key followed by a net type name and what",
    "start": "215879",
    "end": "222640"
  },
  {
    "text": "light DB is doing with this is when it's going to turn that be in back into an object it calls type get type it passes",
    "start": "222640",
    "end": "228959"
  },
  {
    "text": "the value for that type key to type get type to create the object of whatever type that set is going to be in the",
    "start": "228959",
    "end": "234560"
  },
  {
    "text": "database and that means that b and mapper and light DB in general is just a polymorphic seral",
    "start": "234560",
    "end": "240560"
  },
  {
    "text": "which means that all of the standard vulnerabilities that occur with polymorphic serializers occur with light DP but what are those well I'll give you",
    "start": "240560",
    "end": "248040"
  },
  {
    "text": "a little bit of background now on net serialization vulnerabilities and why polymorphic serializers are a bad",
    "start": "248040",
    "end": "253959"
  },
  {
    "text": "idea so when I talk about a polymorphic serializer I'm talking about a serializer where the data gets to",
    "start": "253959",
    "end": "259280"
  },
  {
    "text": "describe itself and say what type it wants to be when it's der steralized so here we have some self-describing data",
    "start": "259280",
    "end": "265199"
  },
  {
    "text": "this box and it's labeled cat cat is the type it says it wants to to be so when the",
    "start": "265199",
    "end": "270880"
  },
  {
    "text": "serializer says okay I'm going to turn this into an object it says well the label says cat that's the type I'll make",
    "start": "270880",
    "end": "276479"
  },
  {
    "text": "a cat object and then I'll look at the contents of this box and set the properties of that cat and the problem",
    "start": "276479",
    "end": "283039"
  },
  {
    "text": "with this is say you have a box instead that's labeled pain that someone gives you well then your serializer says well",
    "start": "283039",
    "end": "289080"
  },
  {
    "text": "it says it's pain I guess I'm making some pain and you're having a bad time and to sort of break out of that that",
    "start": "289080",
    "end": "295960"
  },
  {
    "text": "analogy a bit pain here is what we're calling a serialization gadget so in",
    "start": "295960",
    "end": "301120"
  },
  {
    "text": "pretty much any framework in net but also in Java and python in lots of other places there are types where if you",
    "start": "301120",
    "end": "306680"
  },
  {
    "text": "create them or set their properties or sometimes when their Destructor happens they'll have a side effect they'll do",
    "start": "306680",
    "end": "312960"
  },
  {
    "text": "something additional because there's some additional code that runs there and so serialization gadgets are types where",
    "start": "312960",
    "end": "318080"
  },
  {
    "text": "that additional side effect can achieve some attacker goal and so what you're doing with a",
    "start": "318080",
    "end": "324039"
  },
  {
    "text": "serialization exploit is you're trying to get that serializer to create a type that's going to do something you want when you set its properties",
    "start": "324039",
    "end": "330880"
  },
  {
    "text": "if you want a bit more background on serialization exploits in general I suggest the Friday the 13th talks from",
    "start": "330880",
    "end": "337440"
  },
  {
    "text": "black hat 17 it's a pretty good primer but as far as serialization gadgets go there's a couple I'm going to use a lot",
    "start": "337440",
    "end": "343759"
  },
  {
    "text": "in this talk one is assembly installer assembly installer is a net type that has a property called path when you set",
    "start": "343759",
    "end": "350120"
  },
  {
    "text": "the Path property it just calls load library on the string you give it so if you've got a malicious DL you've been",
    "start": "350120",
    "end": "356039"
  },
  {
    "text": "able to plant somewhere you can just get it loaded get code injection that way way but an interesting trick with",
    "start": "356039",
    "end": "361360"
  },
  {
    "text": "assembly installer is If instead you give it an HTTP URL for that path it'll go and try to download a dll from that",
    "start": "361360",
    "end": "367639"
  },
  {
    "text": "URL it won't load it but it will make that request so you can use this to get pingbacks if you've got a server",
    "start": "367639",
    "end": "373400"
  },
  {
    "text": "somewhere and you want to see if some sort of a serialization payload will work on it there's also object data",
    "start": "373400",
    "end": "379560"
  },
  {
    "text": "provider object data provider has a set of properties that when you set them you get to choose a type a static method on",
    "start": "379560",
    "end": "386160"
  },
  {
    "text": "the type and a series of string and integer param for that method and when you set all of those it will call that",
    "start": "386160",
    "end": "392639"
  },
  {
    "text": "method with those parameters so usually this is used to call process. start just to Pivot at the Shell",
    "start": "392639",
    "end": "398759"
  },
  {
    "text": "injection okay so that's how serialization vulnerabilities work at a really high level now let's go back to",
    "start": "398759",
    "end": "405280"
  },
  {
    "text": "light DB and what I'm calling implicit serialization vulnerabilities so here's an rce payload for light DB so here",
    "start": "405280",
    "end": "413039"
  },
  {
    "text": "we've got some Json this Json looks a lot like that Json we got out of the Bon from light DV before we have this",
    "start": "413039",
    "end": "419759"
  },
  {
    "text": "element here that's got an underscore type key where it's then got a DOT that type name for object data provider",
    "start": "419759",
    "end": "425680"
  },
  {
    "text": "that's that Gadget that just lets us call any static method and this Json is going to call process. start to launch",
    "start": "425680",
    "end": "431759"
  },
  {
    "text": "calc.exe and what we're going to do to exploit this is we're just going to convert this Json into B and then tell B",
    "start": "431759",
    "end": "437759"
  },
  {
    "text": "mapper in light DB deserialize that b and that'll launch Cal now there's a",
    "start": "437759",
    "end": "443199"
  },
  {
    "text": "trick here because if you look at this deserialized Co it actually has an expected type and it doesn't matter so",
    "start": "443199",
    "end": "449840"
  },
  {
    "text": "you tell that serializer what type You're Expecting and what's going to happen is light DB will look at the type",
    "start": "449840",
    "end": "455479"
  },
  {
    "text": "that's in the Bon stream it will actually go create an instance of that type it'll set as properties your remote",
    "start": "455479",
    "end": "461319"
  },
  {
    "text": "code execution exploit will run and then after all of that happens it will then see if it can cast that object it",
    "start": "461319",
    "end": "467039"
  },
  {
    "text": "created to the type you asked it for and maybe that cast fails maybe you get an exception but it doesn't matter your rce",
    "start": "467039",
    "end": "473159"
  },
  {
    "text": "already happened so the type that you tell it that you're expecting in this D serialization doesn't matter at all so",
    "start": "473159",
    "end": "479680"
  },
  {
    "text": "okay I'm showing you here that the B mapper that serializer used by light DB is an unsafe serializer but there's a",
    "start": "479680",
    "end": "485400"
  },
  {
    "text": "bigger problem here so remember light DB uses B mapper to read its own storage",
    "start": "485400",
    "end": "491120"
  },
  {
    "text": "that means that anything that lets you put like unsafe data or some sort of a payload in the database gives you rce",
    "start": "491120",
    "end": "498639"
  },
  {
    "text": "and it's worth noting that a client using light DB doesn't know what's using a serializer probably you're almost",
    "start": "498639",
    "end": "504360"
  },
  {
    "text": "never going to call B and mapper you're just going to tell light DB store this object or give me an object but clients",
    "start": "504360",
    "end": "510080"
  },
  {
    "text": "that use light DB are still vulnerable to rce because that serializer is there and there's a few different ways that",
    "start": "510080",
    "end": "516000"
  },
  {
    "text": "comes up first of all light DB stores the database as a local file so if you go look on GitHub you can find lots of",
    "start": "516000",
    "end": "522959"
  },
  {
    "text": "applications where they're just trying to use light DB to create some sort of a file format maybe they're like a word",
    "start": "522959",
    "end": "529440"
  },
  {
    "text": "processing application they use light DB to actually write a document format or there's games out there that use light",
    "start": "529440",
    "end": "534640"
  },
  {
    "text": "DB to create save files if you provide a file that's opened with light DB it can",
    "start": "534640",
    "end": "539959"
  },
  {
    "text": "just do code execution when it's opened so that's problematic but light DB is",
    "start": "539959",
    "end": "545920"
  },
  {
    "text": "also a nosql database so it's got queries so if you can manage query injection you can put a malicious record",
    "start": "545920",
    "end": "551680"
  },
  {
    "text": "in the database and also get rce that way and there's an additional sort of interesting way you can get rce out of",
    "start": "551680",
    "end": "558200"
  },
  {
    "text": "this that I will come back to later because I discovered it later so okay this is a pretty bad vulnerability and a",
    "start": "558200",
    "end": "564600"
  },
  {
    "text": "somewhat significant open source library and what do you do when you find one of those well you look at the other",
    "start": "564600",
    "end": "569839"
  },
  {
    "text": "libraries that are similar and get exactly the same vulnerability so here's exactly the same vulnerability in",
    "start": "569839",
    "end": "575720"
  },
  {
    "text": "mongodb so here we've got some Json and this Json says what type it wants to be",
    "start": "575720",
    "end": "580959"
  },
  {
    "text": "it says it wants to be an object data provider note that the key name is different but it doesn't really make a difference we're going to again call",
    "start": "580959",
    "end": "586800"
  },
  {
    "text": "Process start start to launch Kelk and what we're going to do here is use mongodb serializer so we're going to",
    "start": "586800",
    "end": "592720"
  },
  {
    "text": "turn this into B and then just deserialize it with mongod DB's B serializer and that will again launch",
    "start": "592720",
    "end": "598399"
  },
  {
    "text": "Cal now there's an important difference here because this type matters so mongodb",
    "start": "598399",
    "end": "605600"
  },
  {
    "text": "when it's doing that dilize it will check that the type the data says it wants to be is assignable to the type",
    "start": "605600",
    "end": "611079"
  },
  {
    "text": "you asked it to get out of the D serialization before it creates it so in order to exploit this you have to have",
    "start": "611079",
    "end": "617320"
  },
  {
    "text": "something something open-ended in the expected object graph whatever you're trying to read with your application",
    "start": "617320",
    "end": "623079"
  },
  {
    "text": "from the database has to have a member in it that you can fit a serialization gadget into but because this un this vulnerable",
    "start": "623079",
    "end": "631000"
  },
  {
    "text": "serializer is there mongodb has these in same these same implicit serialization",
    "start": "631000",
    "end": "636480"
  },
  {
    "text": "vulnerabilities so like like DB with mongodb if you can get a malicious",
    "start": "636480",
    "end": "642399"
  },
  {
    "text": "record into a database that then gets R you've got RC because mongodb is often used in a client server fashion you can",
    "start": "642399",
    "end": "649519"
  },
  {
    "text": "have one client write a malicious record to a database a different client reads it and you're getting rce on that other",
    "start": "649519",
    "end": "655959"
  },
  {
    "text": "client also query injection lets you put malicious records in the database that also lets you get rce like I was saying",
    "start": "655959",
    "end": "663040"
  },
  {
    "text": "assignability is checked which makes it a little more difficult to exploit but it in practice it's actually usually not",
    "start": "663040",
    "end": "668839"
  },
  {
    "text": "that hard so if you go looking at the sort of data different applications put into no SQL databases it's pretty common",
    "start": "668839",
    "end": "675959"
  },
  {
    "text": "that somewhere in there there's a type that has a member of type object or dynamic or like an interface member",
    "start": "675959",
    "end": "682279"
  },
  {
    "text": "where you can fit something pretty open-ended into it and you can get an rce payload to work there I will say I",
    "start": "682279",
    "end": "687800"
  },
  {
    "text": "was only able to exploit the DOT net version of mongodb there's a Java and python driver I looked at them I tried I",
    "start": "687800",
    "end": "694320"
  },
  {
    "text": "couldn't make it work I won't say it's not possible just that I couldn't get an exploit to work so that's no that's two",
    "start": "694320",
    "end": "700680"
  },
  {
    "text": "no SQL engines and here's a third so here's an rce payload for Raven DB Raven",
    "start": "700680",
    "end": "706399"
  },
  {
    "text": "DB is another net nosql engine and here again we've got some Json it says what",
    "start": "706399",
    "end": "712040"
  },
  {
    "text": "type it wants to be it says it wants to be a Windows identity Windows identity specifically is an rce gadget for",
    "start": "712040",
    "end": "719240"
  },
  {
    "text": "json.net serialization and it specifically has this claims identity actor property such",
    "start": "719240",
    "end": "724800"
  },
  {
    "text": "that when you set it it's going to get deserialized with binary formatter and then you can do a binary formatter",
    "start": "724800",
    "end": "729839"
  },
  {
    "text": "exploit if you want more information on that I suggest looking up the CL Windows identity gadget on yso serial but what",
    "start": "729839",
    "end": "736240"
  },
  {
    "text": "we're going to do with this Json is we're going to actually make a connection to the Raven DB database server and just make a put request to",
    "start": "736240",
    "end": "743279"
  },
  {
    "text": "stick it in the database So Raven DB despite being a nosql engine lets you",
    "start": "743279",
    "end": "748360"
  },
  {
    "text": "also just write the Jason that's representing the objects directly so you can write or read Json or you can and",
    "start": "748360",
    "end": "754000"
  },
  {
    "text": "you can write or read objects so if you write the malicious Json and then read it as an object that gets you",
    "start": "754000",
    "end": "761000"
  },
  {
    "text": "rce and so because Raven DB has a vulnerable serializer that is using to read its storage it also has implicit",
    "start": "761880",
    "end": "768440"
  },
  {
    "text": "serialization vulnerabilities it's just using json.net with unsafe settings so anything that's",
    "start": "768440",
    "end": "774720"
  },
  {
    "text": "a serialization gadget for json.net works so if you can write a malicious record to the database someone else",
    "start": "774720",
    "end": "780320"
  },
  {
    "text": "reads it you've got rce if you can do query injection you can write a malicious record you get rce and that",
    "start": "780320",
    "end": "786440"
  },
  {
    "text": "special method I mentioned for light DB also works for Raven DB it does care about assignability you have to figure",
    "start": "786440",
    "end": "792720"
  },
  {
    "text": "out a way to get your payload to fit into what the expected object graph is so like what the application is",
    "start": "792720",
    "end": "798240"
  },
  {
    "text": "expecting it has to fit in there but like I was saying with mongodb it's usually not that hard to",
    "start": "798240",
    "end": "803480"
  },
  {
    "text": "do and no SQL is not just databases so once I got into this research I looked",
    "start": "803480",
    "end": "808800"
  },
  {
    "text": "at other things that were nosql so here's an exploit for service stock. Rus service stock. Rus is a nosql front end",
    "start": "808800",
    "end": "816000"
  },
  {
    "text": "to a redus cache it lets you read and write objects to a reddis cache and what we're doing here again is",
    "start": "816000",
    "end": "822320"
  },
  {
    "text": "we're saying what type it wants to be this will be an assembly installer that's that Gadget that lets you call load Library we're setting us path to",
    "start": "822320",
    "end": "829279"
  },
  {
    "text": "just a malicious dll this could be a URL to your server somewhere and what we're going to do with this is we are just",
    "start": "829279",
    "end": "835839"
  },
  {
    "text": "going to write it to the red as cache when it gets red as an object later that'll be",
    "start": "835839",
    "end": "842040"
  },
  {
    "text": "rce so service stock. rdus is also vulnerable to those implicit serialization",
    "start": "842040",
    "end": "848519"
  },
  {
    "text": "vulnerabilities and it's worth noting again that the actual type you're asking for matters so most nosql engines when",
    "start": "848519",
    "end": "855720"
  },
  {
    "text": "you're telling it you want to get a certain type out of the database it will do this assignability check service stack. Rus is one of those so again you",
    "start": "855720",
    "end": "863079"
  },
  {
    "text": "got to fit your Gadget into the expected object structure but service. is exploitable if",
    "start": "863079",
    "end": "870279"
  },
  {
    "text": "you as an attacker can write malicious data to the red as cache that later gets red as an object or if for some reason your",
    "start": "870279",
    "end": "876880"
  },
  {
    "text": "application just uses the service stack serializer directly to deserialize user provided data that's",
    "start": "876880",
    "end": "882680"
  },
  {
    "text": "exploitable because service stack has a built-in unsafe sterilizer and that extra pattern that I keep mentioning",
    "start": "882680",
    "end": "888240"
  },
  {
    "text": "will work here too and now I'll explain how I found that extra pattern so there was one",
    "start": "888240",
    "end": "893839"
  },
  {
    "text": "other net nosql engine I looked at and that was Martin DB so Martin DB also",
    "start": "893839",
    "end": "899600"
  },
  {
    "text": "uses json.net with unsafe settings to read and write to its storage so it should be exploitable that's the same pattern that",
    "start": "899600",
    "end": "906360"
  },
  {
    "text": "we saw with Raven DB but in Raven DB you could just write Jason to the database Martin DB doesn't let you do that it",
    "start": "906360",
    "end": "911959"
  },
  {
    "text": "just says you can give it objects or you can get objects back so I tried just trying to",
    "start": "911959",
    "end": "917320"
  },
  {
    "text": "store serialization gadgets directly as objects into the database and it always choked on everyone I tried it has one",
    "start": "917320",
    "end": "924079"
  },
  {
    "text": "problem or another with them for each one so then I just came up with a different way entirely to attack it and",
    "start": "924079",
    "end": "929279"
  },
  {
    "text": "that's what I'm calling a serialization mutation attack so here is a a",
    "start": "929279",
    "end": "934680"
  },
  {
    "text": "serialization rce uh exploit from Martin DB and this is kind of weird so I'm",
    "start": "934680",
    "end": "940040"
  },
  {
    "text": "going to create in net in C a dictionary that Maps a string to a string and I'm going to put two things in that",
    "start": "940040",
    "end": "946040"
  },
  {
    "text": "dictionary the first one is going to have a key named dollar type which is at type specifier for json.net and it's",
    "start": "946040",
    "end": "952079"
  },
  {
    "text": "going to have a type name in it this is a workflow designer that's another json.net serialization Gadget it's got a",
    "start": "952079",
    "end": "959040"
  },
  {
    "text": "property on it where when you set it you can just get it to do um an open-ended",
    "start": "959040",
    "end": "964319"
  },
  {
    "text": "zaml parse and in general parsing untrusted zaml gets you rce so the second entry we're putting into this",
    "start": "964319",
    "end": "969519"
  },
  {
    "text": "dictionary is just that zaml payload and what we're going to do with Martin DB is just store that dictionary in the",
    "start": "969519",
    "end": "975600"
  },
  {
    "text": "database and that get this rce we just stick it in there and when it gets read again later that code will execute and",
    "start": "975600",
    "end": "982079"
  },
  {
    "text": "that feels really weird we're putting a dictionary in the database and when we read it back it's going to run code and why is that so Marb is using json.net to",
    "start": "982079",
    "end": "990040"
  },
  {
    "text": "read and write its storage so let's look a little bit on how json.net serialization works for a dictionary like this if you've got a dictionary",
    "start": "990040",
    "end": "997519"
  },
  {
    "text": "mapping a string to a string then let's say you have like a key named fruit and a value named pair and you serialize",
    "start": "997519",
    "end": "1003560"
  },
  {
    "text": "that what Jason donet will do is it will just use that key name directly as a key it uses in the Json it produces so",
    "start": "1003560",
    "end": "1011319"
  },
  {
    "text": "whatever your key names are in your dictionary those are the key names that actually get put into the Json now if you compare that with what a",
    "start": "1011319",
    "end": "1018240"
  },
  {
    "text": "serialization payload looks like for json.net that gets you rce like this you've got this dollar type key that's",
    "start": "1018240",
    "end": "1024480"
  },
  {
    "text": "going to be the type specifier that's telling json.net what type that Jason's going to turn into when it's",
    "start": "1024480",
    "end": "1029520"
  },
  {
    "text": "deserialized and the important trick here is that there's nothing special about that dollar type key so there's",
    "start": "1029520",
    "end": "1035720"
  },
  {
    "text": "nothing that prevents you from making a dictionary where one of the keys in the dictionary is named dollar type and if you serialize a dictionary where one of",
    "start": "1035720",
    "end": "1041880"
  },
  {
    "text": "the keys in the dictionary is named dollar type json.net will just output a key called dollar type with that value",
    "start": "1041880",
    "end": "1047959"
  },
  {
    "text": "you gave it but when you serialize it that's going to tell it what type of object it's going to make and this means",
    "start": "1047959",
    "end": "1054000"
  },
  {
    "text": "that it's going to mutate into that type of object when it serialized and then deserialized this doesn't just work for",
    "start": "1054000",
    "end": "1059160"
  },
  {
    "text": "dictionaries this works for anything in net that has a key value structure so dictionaries hash tables J objects",
    "start": "1059160",
    "end": "1064880"
  },
  {
    "text": "expando objects and like 20 other types that nobody uses but this pattern this ability to",
    "start": "1064880",
    "end": "1072280"
  },
  {
    "text": "have data that mutates into an rce payload opens up a lot of attack patterns that aren't traditionally",
    "start": "1072280",
    "end": "1077679"
  },
  {
    "text": "considered possible so let's say you have an application that just has a web form that lets you put some key value",
    "start": "1077679",
    "end": "1083240"
  },
  {
    "text": "data into it this is a screenshot of an application you may or may not recognize that lets you put key value data into it",
    "start": "1083240",
    "end": "1089320"
  },
  {
    "text": "this is not one that was vulnerable to this exploit but I can say that this gets stuck into a dictionary and what",
    "start": "1089320",
    "end": "1095000"
  },
  {
    "text": "we're going to do here with this key value data in this web form is we're going to put one of these payloads into it we're going to say okay the first key",
    "start": "1095000",
    "end": "1101200"
  },
  {
    "text": "value pair is dollar type and the name of a net type assembly installer and the second one is going to be a path that's",
    "start": "1101200",
    "end": "1107240"
  },
  {
    "text": "a URL to our server so we can see a ping back happening we make a form post with that form and on some web front end",
    "start": "1107240",
    "end": "1115320"
  },
  {
    "text": "somewhere that gets stuck into a dictionary or a hash table then it's going to get serialized let's say with",
    "start": "1115320",
    "end": "1121200"
  },
  {
    "text": "some sort of unsafe serializer like json.net into a database or a cache later on when it gets read from",
    "start": "1121200",
    "end": "1128400"
  },
  {
    "text": "that database or Cache with that same unsafe serializer it's now an rceo and code executes so here you've got a",
    "start": "1128400",
    "end": "1136200"
  },
  {
    "text": "serialization exploit where you never got to touch the serialized dat the application serialized the data and",
    "start": "1136200",
    "end": "1141520"
  },
  {
    "text": "deserialized the data but because you were able to put some malicious strings into that data that gets serialized you",
    "start": "1141520",
    "end": "1147440"
  },
  {
    "text": "still get rce and this is that extra pattern I've been mentioning for all of those nosql databases so here's essentially that",
    "start": "1147440",
    "end": "1154240"
  },
  {
    "text": "exploit against light DB we're going to make a dictionary mapping a string to a string we're going to put key value",
    "start": "1154240",
    "end": "1159760"
  },
  {
    "text": "pairs in there so we've got that underscore type key which is uh which is light DB's type specifier that says what",
    "start": "1159760",
    "end": "1167120"
  },
  {
    "text": "type it's going to be when it's der serialized we're setting a path and all we're going to do with this dictionary is we're going to stick it in the",
    "start": "1167120",
    "end": "1173240"
  },
  {
    "text": "database in light DB if you just store that dictionary in light DB and then it gets read out later that gets you",
    "start": "1173240",
    "end": "1179120"
  },
  {
    "text": "rce and this is kind of a ridiculous exploit because light DB also doesn't care about assignability so if there's",
    "start": "1179120",
    "end": "1185320"
  },
  {
    "text": "key value data anywhere in any object that gets sorted in a light dbd database",
    "start": "1185320",
    "end": "1190919"
  },
  {
    "text": "and an attacker can control any key value pair in that dictionary or whatever it is that's enough to get rce",
    "start": "1190919",
    "end": "1197600"
  },
  {
    "text": "they just have to be able to give you two strings and you stick them in a database and this works for a lot of",
    "start": "1197600",
    "end": "1204240"
  },
  {
    "text": "serializers in net here's a list of all the ones I know of there's different",
    "start": "1204240",
    "end": "1210400"
  },
  {
    "text": "requirements to get an exploit to work some of these are hard to exploit some of them are really easy and you'll notice that there's both",
    "start": "1210400",
    "end": "1218280"
  },
  {
    "text": "the no SQL engines but also the serializers themselves so json.net is exploitable Javascript serializer is",
    "start": "1218280",
    "end": "1223440"
  },
  {
    "text": "exploitable if you have a simple type resolver there's an addition at the bottom of this list binary form is",
    "start": "1223440",
    "end": "1228960"
  },
  {
    "text": "exploitable last time I talked about this sort of thing I didn't think so but it is I was not able to figure out a way to",
    "start": "1228960",
    "end": "1235760"
  },
  {
    "text": "get mutation to work with mongod to be I can't guarantee 100% it's impossible but",
    "start": "1235760",
    "end": "1240960"
  },
  {
    "text": "it's a lot harder to pull off this sort of attack has a lot of",
    "start": "1240960",
    "end": "1246280"
  },
  {
    "text": "limitations so depending on the particular serializer you're looking at it can be harder or easier json.net",
    "start": "1246280",
    "end": "1251400"
  },
  {
    "text": "attacks only work if you're using json.net with unsafe settings so you've set type name handling to something other than none but you also o have to",
    "start": "1251400",
    "end": "1259080"
  },
  {
    "text": "control the first key value pair in something in a dictionary or a hash table if that type key shows up later on",
    "start": "1259080",
    "end": "1265799"
  },
  {
    "text": "it's ignored and when you serialize it you have to serialize it in such a way that json.net doesn't double the keys so",
    "start": "1265799",
    "end": "1272000"
  },
  {
    "text": "sometimes when you've got that dollar type key in your dictionary it'll put another one in there and that'll just break everything it really just requires",
    "start": "1272000",
    "end": "1279039"
  },
  {
    "text": "experimenting with different scenarios to figure out where that will happen or not but some serializers this is really easy like I was showing you light DB is",
    "start": "1279039",
    "end": "1286000"
  },
  {
    "text": "very easy to exploit so is Javascript serializer if you're using JavaScript serializer with a simple type resolver",
    "start": "1286000",
    "end": "1292240"
  },
  {
    "text": "it's really easy to exploit you just need to be able to control one key value pair in addictionary somewhere and",
    "start": "1292240",
    "end": "1298039"
  },
  {
    "text": "that's good enough it'll actually put that key value pair first when you serialize it so it will conveniently always get",
    "start": "1298039",
    "end": "1305240"
  },
  {
    "text": "urce you can actually scan actively for this sort of vulnerability so that",
    "start": "1305679",
    "end": "1310720"
  },
  {
    "text": "example I was showing with a web form where you putting key value data into it you can do that in general if you've got",
    "start": "1310720",
    "end": "1315799"
  },
  {
    "text": "some sort of net application on the web that's got an API or a form or something that takes key value data you can put",
    "start": "1315799",
    "end": "1322400"
  },
  {
    "text": "that assembly installer payload in there give the URL to a server you control and if it gets deserialized later you'll get",
    "start": "1322400",
    "end": "1327960"
  },
  {
    "text": "a ping back and you can just scan for this sort of exploit on surfaces out there on the",
    "start": "1327960",
    "end": "1334360"
  },
  {
    "text": "internet this is also useful for dynamic scanning inside of your organization so if you want to defend",
    "start": "1334360",
    "end": "1340840"
  },
  {
    "text": "against this sort of attack and this is something I'm going to say a lot in this presentation use a safe serializer use a",
    "start": "1340840",
    "end": "1346200"
  },
  {
    "text": "serializer where the data doesn't get to tell you what type it wants to be use a serializer that doesn't do any sort of",
    "start": "1346200",
    "end": "1352720"
  },
  {
    "text": "polymorphism system. text. json. Json serializer works really nicely for this but people like polymorphism so it",
    "start": "1352720",
    "end": "1358919"
  },
  {
    "text": "doesn't get used as much you can also use a serialization binder to secure things a serialization binder is going",
    "start": "1358919",
    "end": "1365080"
  },
  {
    "text": "to let you decide what types are allowed to be created during der calization that said the next section I'm going to tell",
    "start": "1365080",
    "end": "1370840"
  },
  {
    "text": "you how to bypass serialization binders so definitely a grain of salt with that recommendation",
    "start": "1370840",
    "end": "1376200"
  },
  {
    "text": "so bypassing serialization by ERS so I mentioned serialization binders in that",
    "start": "1376200",
    "end": "1381840"
  },
  {
    "text": "last slide in general a serialization binder is going to be a type that you can Define which implements a method",
    "start": "1381840",
    "end": "1387279"
  },
  {
    "text": "called bind to type and what that's what that method is going to do is every time a type is going to be created during",
    "start": "1387279",
    "end": "1393559"
  },
  {
    "text": "distalization It'll ask you is it okay to create this type and then you can either say yes here's the type for that",
    "start": "1393559",
    "end": "1399440"
  },
  {
    "text": "type name you gave me or throw an exception so if you're doing it right you can create an allow list and the",
    "start": "1399440",
    "end": "1404480"
  },
  {
    "text": "serialization binder acts like a filter so when you're taking this maybe untrusted data and deserializing it you",
    "start": "1404480",
    "end": "1410520"
  },
  {
    "text": "get to say well okay cat I know about cat is in my allow list I'll will make Cat objects pain I don't know what that",
    "start": "1410520",
    "end": "1416200"
  },
  {
    "text": "is I'll throw an exception and then you never make a pain object and things are a little bit better the problem is nobody writes",
    "start": "1416200",
    "end": "1422200"
  },
  {
    "text": "these correctly so this is the right way to write a serialization binder this is a strict allow list based off of the",
    "start": "1422200",
    "end": "1428480"
  },
  {
    "text": "strings for type names and if you run into a type name you don't recognize it throws an exception but a lot of times",
    "start": "1428480",
    "end": "1434720"
  },
  {
    "text": "when I see serialization binderies in code they look more like this so this serialization binder what it's saying is",
    "start": "1434720",
    "end": "1441000"
  },
  {
    "text": "okay I've got some dll or assembly I've written I know all of the types I put in that aren't malicious serialization",
    "start": "1441000",
    "end": "1447039"
  },
  {
    "text": "gadgets or dangerous things to Der serialize so I will say every type in my dll is just Allowed by the serialization",
    "start": "1447039",
    "end": "1453440"
  },
  {
    "text": "binder and the trick is this is almost always exploitable this will almost always be something you can bypass to",
    "start": "1453440",
    "end": "1459120"
  },
  {
    "text": "get rce the reason for that is because in part generics so say you've got a type",
    "start": "1459120",
    "end": "1466720"
  },
  {
    "text": "in that trusted assembly that looks like this this is initialized List It inherits from the net list generic and it just",
    "start": "1466720",
    "end": "1473200"
  },
  {
    "text": "adds an additional property called is initialized at the Boolean this seems like it should be pretty harmless but",
    "start": "1473200",
    "end": "1479240"
  },
  {
    "text": "that serialization binder I was showing you where we're saying everything for our trusted dlll is okay you can",
    "start": "1479240",
    "end": "1484919"
  },
  {
    "text": "actually exploit with this here's how you do it so here's a json. net rce payload that bypasses that",
    "start": "1484919",
    "end": "1491720"
  },
  {
    "text": "serialization binder using this type so the type that this says it wants to be is an initialized list inside of the",
    "start": "1491720",
    "end": "1499000"
  },
  {
    "text": "template F that generic we've got assembly installer but when the serialization binder is asked about this",
    "start": "1499000",
    "end": "1504559"
  },
  {
    "text": "type it's asked about initialized list with that internal type and this comes from your dll so this is allowed",
    "start": "1504559",
    "end": "1511120"
  },
  {
    "text": "initialized list is in your dll and it doesn't matter what's inside of that generic but even though assembly",
    "start": "1511120",
    "end": "1517799"
  },
  {
    "text": "installer is not itself listed independently as a type here the serializer can infer the type because it",
    "start": "1517799",
    "end": "1524320"
  },
  {
    "text": "knows this is a list of assembly installers so when you get to the values array and you saying okay I'm going to actually create elements for this well",
    "start": "1524320",
    "end": "1531240"
  },
  {
    "text": "it's going to create assembly installer objects and when you set the path on one of those values when you're setting the path on an assembly installer and you've",
    "start": "1531240",
    "end": "1537520"
  },
  {
    "text": "got rce it's interesting to note that this is not what Jason dunet will serialize",
    "start": "1537520",
    "end": "1544480"
  },
  {
    "text": "if you serialize this object if you serialize this object it will actually put the assembly installer type there in the values list but if you don't put it",
    "start": "1544480",
    "end": "1551120"
  },
  {
    "text": "there it's fine it can figure it out and it doesn't care and so the key thing to understand",
    "start": "1551120",
    "end": "1556960"
  },
  {
    "text": "here is that your serialization bu is only ever going to get asked about types that are directly mentioned in the serialized stream this gives you other",
    "start": "1556960",
    "end": "1564159"
  },
  {
    "text": "ways to bypass serialization binders as well so here's a technique I'm referring to as a contagion attack against",
    "start": "1564159",
    "end": "1570559"
  },
  {
    "text": "serialization binders so say there's some specific type you're trying to block you have a list of serialization",
    "start": "1570559",
    "end": "1576720"
  },
  {
    "text": "gadgets you know are dangerous that you're going to just make a block list for because that's easier than making an allow list for your application well",
    "start": "1576720",
    "end": "1583880"
  },
  {
    "text": "json.net and lots of other serializers only care like I said about the types mentioned directly in the serialized",
    "start": "1583880",
    "end": "1590159"
  },
  {
    "text": "stream but all of your types have members they've got Constructor arguments they've got properties and all of those things have types too and you",
    "start": "1590159",
    "end": "1597600"
  },
  {
    "text": "can mention those types but you don't have to the serializer can figure them out so if you create if you can create",
    "start": "1597600",
    "end": "1603320"
  },
  {
    "text": "situations where the serializer can figure out that there's something that should be a type that's dangerous it won't ask you about it it will just go",
    "start": "1603320",
    "end": "1609640"
  },
  {
    "text": "make it so if you've got some sort of type that's dangerous and it's the type",
    "start": "1609640",
    "end": "1614919"
  },
  {
    "text": "of a member of some other type then you can deserialize that other Ty type and because you've got that member in there",
    "start": "1614919",
    "end": "1620480"
  },
  {
    "text": "it'll make an object of that dangerous type as well but it won't ask you about it and that chains so if there's",
    "start": "1620480",
    "end": "1625880"
  },
  {
    "text": "something you can use for a serialization exploit that's a member of a member of a property of a Constructor",
    "start": "1625880",
    "end": "1631240"
  },
  {
    "text": "argument of some other type that's good enough to actually get rce with it and",
    "start": "1631240",
    "end": "1636360"
  },
  {
    "text": "here's an example of that so the windows identity type I used earlier that's an rce gadget for json.net it lets you",
    "start": "1636360",
    "end": "1642480"
  },
  {
    "text": "pivot to Binary formatter and let's say you've got a serialization binder that says okay we're going to block windows identity we know it's dous what other",
    "start": "1642480",
    "end": "1649320"
  },
  {
    "text": "types are there that let you get that in there well there's the windows authentication event args type in net",
    "start": "1649320",
    "end": "1656159"
  },
  {
    "text": "and it has a Constructor argument called identity whose type is Windows identity so if you deserialize a Windows",
    "start": "1656159",
    "end": "1661760"
  },
  {
    "text": "authentication event arcs type that's the only type your bind your serialization binder gets asked about",
    "start": "1661760",
    "end": "1667840"
  },
  {
    "text": "but when you deserialize that identity property of it it won't ask your binder do you want to make a Windows identity",
    "start": "1667840",
    "end": "1674080"
  },
  {
    "text": "but it will make a Windows identity object and you can set the properties of it which is good enough to get rce",
    "start": "1674080",
    "end": "1679240"
  },
  {
    "text": "so if you're going to try to create a block list you have to create a block list that considers every type that might contain the types you're trying to",
    "start": "1679240",
    "end": "1685240"
  },
  {
    "text": "block and it turns out that's kind of impossible so serialization binders that are block lists do not",
    "start": "1685240",
    "end": "1692799"
  },
  {
    "text": "work and with all of that as background now I'm going to tell you how you can use mutation attacks against binary",
    "start": "1692799",
    "end": "1698480"
  },
  {
    "text": "formatter to bypass serialization binders there so when I've talked about this",
    "start": "1698480",
    "end": "1704320"
  },
  {
    "text": "issue before I was of the belief that binary form matter was safe for mutation it should be binary format does not",
    "start": "1704320",
    "end": "1710720"
  },
  {
    "text": "serialize to a text format it serializes to a format called msnr BF which is an",
    "start": "1710720",
    "end": "1716640"
  },
  {
    "text": "awful format which it it's binary records so it's essentially a bunch of records that say okay here's a bite",
    "start": "1716640",
    "end": "1723159"
  },
  {
    "text": "that's a record type the record type is the length of the rest of the records in this thing that sort of deal and you've",
    "start": "1723159",
    "end": "1729600"
  },
  {
    "text": "got elements in there that are like here's a record that's the actual type information for an object but there's a different record that's the data for the",
    "start": "1729600",
    "end": "1735360"
  },
  {
    "text": "object so the key here is that when we've been doing mutation attacks against like Json or B",
    "start": "1735360",
    "end": "1741720"
  },
  {
    "text": "payloads the problem is that some of that data can suddenly",
    "start": "1741720",
    "end": "1747039"
  },
  {
    "text": "be the type information for the object you can have some key value pair in there and the data is turning into sort",
    "start": "1747039",
    "end": "1753279"
  },
  {
    "text": "of the metadata but that shouldn't be able to be possible with binary form matter because the metadata is kept",
    "start": "1753279",
    "end": "1758600"
  },
  {
    "text": "separately from the actual data but interestingly enough while I was last talking about this set of",
    "start": "1758600",
    "end": "1764919"
  },
  {
    "text": "issues at Defcon last year a of the dev div team at Microsoft was opening a bug",
    "start": "1764919",
    "end": "1770320"
  },
  {
    "text": "about binary formatter so L prek on the dev div team opened this bug binary",
    "start": "1770320",
    "end": "1775480"
  },
  {
    "text": "formatter serialization does not round trip with eye convertible fields and this is a really neat bug but it's kind",
    "start": "1775480",
    "end": "1783360"
  },
  {
    "text": "of complicated so to go into what that's about if you're serializing an object",
    "start": "1783360",
    "end": "1789120"
  },
  {
    "text": "with binary form matter and that object has a member whose type is an interface but what you've assigned to that",
    "start": "1789120",
    "end": "1794360"
  },
  {
    "text": "interface member is essentially a boxed value type A Primitive type so you've got an interface member where you're",
    "start": "1794360",
    "end": "1800279"
  },
  {
    "text": "just throwing an integer in it or a string or something like that binary formatter doesn't serialize that correctly it doesn't create msnr BF what",
    "start": "1800279",
    "end": "1808519"
  },
  {
    "text": "it does instead is it just takes that bite or the btes for that primitive type and sticks them directly in the Stream",
    "start": "1808519",
    "end": "1813840"
  },
  {
    "text": "with no metadata so instead of having these records that say okay we're going to have an integer here the integer has",
    "start": "1813840",
    "end": "1819919"
  },
  {
    "text": "this many bytes and then here's the integer data it just says here's the integer data which means that all of",
    "start": "1819919",
    "end": "1825360"
  },
  {
    "text": "that metadata is just not present and that means on deserialization when it's trying to read those bytes it's",
    "start": "1825360",
    "end": "1831760"
  },
  {
    "text": "expecting that MSN RBF and instead it's just got the bytes for your string or integer or whatever and that means that",
    "start": "1831760",
    "end": "1838559"
  },
  {
    "text": "a lot of scenarios are just going to break so here's a basic proof of concept",
    "start": "1838559",
    "end": "1843960"
  },
  {
    "text": "that lets you sort of Repro that bug here we have a class it's got a member of with an interface type this I convert",
    "start": "1843960",
    "end": "1850120"
  },
  {
    "text": "Vol com and we're just going to stick five in there for the value of that when we serialize this that five is just",
    "start": "1850120",
    "end": "1856600"
  },
  {
    "text": "going to get written directly to the serialized data and then when you try to deserialize it well it's going to say",
    "start": "1856600",
    "end": "1861760"
  },
  {
    "text": "well five doesn't make sense here as MSN RBF metadata and it's going to throw an exception so okay that's a functional",
    "start": "1861760",
    "end": "1868480"
  },
  {
    "text": "bug that's problematic for someone but this is a security conference and this is a security talk so how is this a",
    "start": "1868480",
    "end": "1874159"
  },
  {
    "text": "security bug well I'm going to show you a very slight modification of this code",
    "start": "1874159",
    "end": "1879720"
  },
  {
    "text": "here we again have that type that has an interface member this I convertible and",
    "start": "1879720",
    "end": "1886039"
  },
  {
    "text": "instead of assigning five to it we're going to assign assign a very carefully chosen u64 value that number and then",
    "start": "1886039",
    "end": "1893519"
  },
  {
    "text": "for the second element in this object because that matters to we have just an object member and we're going to put a",
    "start": "1893519",
    "end": "1899559"
  },
  {
    "text": "bite array in it and when we serialize this and deserialize it we don't get an",
    "start": "1899559",
    "end": "1904720"
  },
  {
    "text": "exception instead what happens is it will la well yes there's a suspicious by way we don't get an exception instead",
    "start": "1904720",
    "end": "1910600"
  },
  {
    "text": "what happens is it will launch Cal if you serialize that object and then deserialize it so this particular",
    "start": "1910600",
    "end": "1918559"
  },
  {
    "text": "exploit was discovered by Levi brck on the net team he has given me his Blessing to explain it here but I want",
    "start": "1918559",
    "end": "1924320"
  },
  {
    "text": "to give him credit because this is pretty cool and that bite Ray I've truncated it in this slide if you want",
    "start": "1924320",
    "end": "1929919"
  },
  {
    "text": "to get a picture of it here's the whole thing I've also put it on my Mastadon if you want to copy paste it rather than",
    "start": "1929919",
    "end": "1934960"
  },
  {
    "text": "typing in that whole giant mess but I'll explain how that exploit works here so that u64 value that's",
    "start": "1934960",
    "end": "1944000"
  },
  {
    "text": "actually valid MSN RBF so before I was saying that when binary forer tries to",
    "start": "1944000",
    "end": "1949480"
  },
  {
    "text": "serialize something like a u64 but it's assigned to an interface member it doesn't put the metadata around it it",
    "start": "1949480",
    "end": "1955200"
  },
  {
    "text": "just sticks that data straight in there so this integer value is actually valid MSN RBF and what is the valid medata to",
    "start": "1955200",
    "end": "1962600"
  },
  {
    "text": "four is a string of a specific length in particular it's a string that's long enough such that when binary formator is",
    "start": "1962600",
    "end": "1969240"
  },
  {
    "text": "reading the bytes from the stream to deserialize it will read the next few bytes of metadata as part of the string",
    "start": "1969240",
    "end": "1976120"
  },
  {
    "text": "so when this gets read it consumes the next set of metadata which means when it starts trying to read more msnr BF for",
    "start": "1976120",
    "end": "1982360"
  },
  {
    "text": "the next object it's actually reading in the middle of that bite array and the contents of that bite array are more",
    "start": "1982360",
    "end": "1988080"
  },
  {
    "text": "valid MSN RBF and that's actually the serialized data for essentially a binary",
    "start": "1988080",
    "end": "1994399"
  },
  {
    "text": "format or exploit so the object graph you get when you deserialize it looks like this you have a string that string",
    "start": "1994399",
    "end": "2001159"
  },
  {
    "text": "has a bunch of nonsense data in it because it's just consuming that metadata that wasn't supposed to be a string but then you have a sorted set",
    "start": "2001159",
    "end": "2007799"
  },
  {
    "text": "and that sorted set has a confused delegate exploit a confused delegate exploit is a classic way of getting rce",
    "start": "2007799",
    "end": "2013679"
  },
  {
    "text": "out of binary formatter James Forshaw talked about this in his rum my type talk but it's also there on Yo serial so",
    "start": "2013679",
    "end": "2021519"
  },
  {
    "text": "okay that's interesting it's kind of weird that that works this pattern really isn't exploitable though so okay",
    "start": "2021519",
    "end": "2028679"
  },
  {
    "text": "if you imagine this scenario where okay there's an application somewhere and it's letting you provide the value for",
    "start": "2028679",
    "end": "2033720"
  },
  {
    "text": "that u64 and the contents of that bite array and then it's serializing them this and then deserializing them with",
    "start": "2033720",
    "end": "2039120"
  },
  {
    "text": "binary form yes that gives you rce but that application would never work except when you're giving it rce payloads so no",
    "start": "2039120",
    "end": "2045840"
  },
  {
    "text": "one has an application like that it's also worth pointing out that binary formatter has been around for a long",
    "start": "2045840",
    "end": "2051599"
  },
  {
    "text": "time this buug has always been there and it was only discovered last year because no one ever does this so that scenario",
    "start": "2051599",
    "end": "2059679"
  },
  {
    "text": "as I just described it is not exploitable but that does not mean binary formatter is safe so I was just",
    "start": "2059679",
    "end": "2066599"
  },
  {
    "text": "showing you that binary form matter will serialize things incorrectly when you're assigning a value type to an interface",
    "start": "2066599",
    "end": "2071839"
  },
  {
    "text": "member but that doesn't mean there isn't a way to serialize that data so you can create MSN RBF such that it means here's",
    "start": "2071839",
    "end": "2079638"
  },
  {
    "text": "an interface member and we've assigned a box value type to it and if you create that",
    "start": "2079639",
    "end": "2085440"
  },
  {
    "text": "data binary formatter will deserialize it but you can set it up so that when it's serialized and then deserialized",
    "start": "2085440",
    "end": "2091398"
  },
  {
    "text": "again now it's an rce payload so you have this flow you're providing serialized data to an somewhere it",
    "start": "2091399",
    "end": "2098760"
  },
  {
    "text": "deserializes it it gets a u64 and a b array but if it serializes and deserializes it again now it's",
    "start": "2098760",
    "end": "2105280"
  },
  {
    "text": "rce so you have an attack pattern that looks like this you've got a web friend end somewhere where it's expecting data",
    "start": "2105280",
    "end": "2112440"
  },
  {
    "text": "that serialized with binary formatter and that's not a great idea but let's say it's going to be deserializing it",
    "start": "2112440",
    "end": "2118240"
  },
  {
    "text": "with a serialization binder what you're going to do then is you're going to give it data so that when it's first",
    "start": "2118240",
    "end": "2123440"
  },
  {
    "text": "deserialized it's harmless it's a un 64 and a bite array those are primitive types serialization binders don't even",
    "start": "2123440",
    "end": "2129160"
  },
  {
    "text": "get asked about them they just go by and so then it gets that un 64 in bite array",
    "start": "2129160",
    "end": "2134640"
  },
  {
    "text": "but say it's going to take that object and then serialize it again like it's going to put it in a message cue or a",
    "start": "2134640",
    "end": "2141079"
  },
  {
    "text": "cache or view State because of course view State just uses binary formatter behind the scenes to do writing and reading when it does that it's going to",
    "start": "2141079",
    "end": "2148320"
  },
  {
    "text": "turn into something else it's going to turn into an rce payload that's now just hanging out in that cache or in your view state so when when it gets read",
    "start": "2148320",
    "end": "2155560"
  },
  {
    "text": "again that payload goes off this is cool but it's also really hard",
    "start": "2155560",
    "end": "2162760"
  },
  {
    "text": "to pull off so this exploit only works if you have that pattern of deserialize",
    "start": "2162760",
    "end": "2169240"
  },
  {
    "text": "serialize deserialize again also because binary formatter",
    "start": "2169240",
    "end": "2175000"
  },
  {
    "text": "cares about assignability there's only a handful of interface members or of interfaces that you can actually use for",
    "start": "2175000",
    "end": "2180960"
  },
  {
    "text": "this the only interfaces you can assign a un 642 are I comparable I formattable and I convertible that doesn't show up a",
    "start": "2180960",
    "end": "2188720"
  },
  {
    "text": "lot in expected data but there's kind of a trick here say that web friend end",
    "start": "2188720",
    "end": "2193960"
  },
  {
    "text": "that's expecting binary format or serialized data say the object draph it's expecting has some sort of an",
    "start": "2193960",
    "end": "2199440"
  },
  {
    "text": "open-ended member in it say it's got some member somewhere of type object and they're saying well that's okay that's not going to be a problem because we've",
    "start": "2199440",
    "end": "2205240"
  },
  {
    "text": "got the serialization binder so the serialization binder will mean that whatever that object gets assigned it",
    "start": "2205240",
    "end": "2210560"
  },
  {
    "text": "can't be something dangerous well in that case what you assign to that object is tupple and then the types you put in",
    "start": "2210560",
    "end": "2216079"
  },
  {
    "text": "the tupple are I comparable and either object or a bite array and then inside of that tupple you put that magic u64",
    "start": "2216079",
    "end": "2223319"
  },
  {
    "text": "you put your bite array that's got your serialized payload when it gets deserialized the only type the",
    "start": "2223319",
    "end": "2228560"
  },
  {
    "text": "serialization binder gets asked about is tupple and it says are you going to allow tupple and maybe the serialization",
    "start": "2228560",
    "end": "2234680"
  },
  {
    "text": "binder allows that and that works for all of the other like generic types that let you collect types together so key",
    "start": "2234680",
    "end": "2241920"
  },
  {
    "text": "value pair for example also works for this and then it gets by that serialization binder and if you've got",
    "start": "2241920",
    "end": "2247760"
  },
  {
    "text": "that serialized and re and deserialized again on the back end you've got an exploit so that's a lot of problems what",
    "start": "2247760",
    "end": "2256440"
  },
  {
    "text": "if this has already been fixed what have this do you not have to worry about so much so mongodb made a pretty good fix",
    "start": "2256440",
    "end": "2262280"
  },
  {
    "text": "for this like I reported all of these issues to these nosql developers and so on mongodb made a fix where they",
    "start": "2262280",
    "end": "2268400"
  },
  {
    "text": "actually made it so you have to now give an allow list for the types that can get read from the database during der",
    "start": "2268400",
    "end": "2273520"
  },
  {
    "text": "serialization and this is not so great for application developers cuz they have to make a list of all of the types that",
    "start": "2273520",
    "end": "2279520"
  },
  {
    "text": "they want to read from the database in their application but it means that I don't know a way to exploit this anymore from mongodb light DB made a fix where",
    "start": "2279520",
    "end": "2288440"
  },
  {
    "text": "they now check assignability so if you use a more recent version of light DB that whole business where it doesn't",
    "start": "2288440",
    "end": "2294160"
  },
  {
    "text": "care what type it's expecting it will actually check that it's assign it's assignable first which puts it sort of",
    "start": "2294160",
    "end": "2299200"
  },
  {
    "text": "on par with those other nosql engines and then all of these engines except Martin DB also added a block list a list",
    "start": "2299200",
    "end": "2306560"
  },
  {
    "text": "of types they're saying well we don't want to deserialize this because we know it's a serialization gadget but remember I showed you how to bypass block lists",
    "start": "2306560",
    "end": "2312480"
  },
  {
    "text": "block lists are worthless so that doesn't do anything Martin DB did not do anything um I contacted them they sent",
    "start": "2312480",
    "end": "2320119"
  },
  {
    "text": "me a lot of emails saying we probably should fix this last I checked they still haven't so it's just like",
    "start": "2320119",
    "end": "2326200"
  },
  {
    "text": "that it's maybe not a good idea to be using any of these except at this point",
    "start": "2326200",
    "end": "2331680"
  },
  {
    "text": "honestly json.net because json.net itself has this mutation issue won't be fixed I talked to James Newton King who",
    "start": "2331680",
    "end": "2339040"
  },
  {
    "text": "is the maintainer of json.net he actually works for Microsoft now he said it's essentially supposed to do that",
    "start": "2339040",
    "end": "2344880"
  },
  {
    "text": "don't use Jason donet to serialize with unsafe settings if any user data could be going in there at all so that",
    "start": "2344880",
    "end": "2350960"
  },
  {
    "text": "mutation is just going to stick that's just how json.net is going to work JavaScript serializer won't be fixed the",
    "start": "2350960",
    "end": "2358079"
  },
  {
    "text": "net folks said don't use Simple type resolver with JavaScript serializer essentially so they're not going to fix",
    "start": "2358079",
    "end": "2363520"
  },
  {
    "text": "this if you're using JavaScript serializer with simple type resolver don't you've almost certainly got rce",
    "start": "2363520",
    "end": "2370160"
  },
  {
    "text": "vulnerabilities binary formatter will not be fixed binary formatter is",
    "start": "2370160",
    "end": "2375560"
  },
  {
    "text": "deprecated net has said they're not going to fix that bug even though it's technically a functional bug in the",
    "start": "2375560",
    "end": "2380599"
  },
  {
    "text": "serializer they want you to just not use it there's other good reasons to be fair not to use binary",
    "start": "2380599",
    "end": "2387160"
  },
  {
    "text": "formatter well okay that's a lot of problems how do you prevent this from being an issue in your application what",
    "start": "2387319",
    "end": "2393240"
  },
  {
    "text": "are some best practices to avoid these issues first the thing I keep saying don't use polymorphic serializers and",
    "start": "2393240",
    "end": "2399440"
  },
  {
    "text": "don't write your own so if there's a serializer where you can just stick whatever types you want in it and then",
    "start": "2399440",
    "end": "2405000"
  },
  {
    "text": "get them back out of it and you don't have to make an allow list it's dangerous don't do that similarly if",
    "start": "2405000",
    "end": "2410480"
  },
  {
    "text": "you've got a database that does the same thing a no SQL engine where you can put things in it like that it's dangerous",
    "start": "2410480",
    "end": "2415520"
  },
  {
    "text": "don't do it don't call type get type if you're calling type get type and putting a string into it in net you're probably",
    "start": "2415520",
    "end": "2421920"
  },
  {
    "text": "making a polymorphic serializer even if that's not what you think you're doing in Java the same thing is true for with",
    "start": "2421920",
    "end": "2427800"
  },
  {
    "text": "class. forame you can do exactly the same set of issues there because mutation attacks are a thing you can't",
    "start": "2427800",
    "end": "2434480"
  },
  {
    "text": "have unsafe serializers even on your back end because if user data is going in there and there's just some strings",
    "start": "2434480",
    "end": "2439760"
  },
  {
    "text": "someone can control that might be able to be something that can turn into an rce issue this one kind of hurts but don't",
    "start": "2439760",
    "end": "2446280"
  },
  {
    "text": "read un trusted data from no SQL engines so in general the pattern with no SQL",
    "start": "2446280",
    "end": "2451839"
  },
  {
    "text": "that you can stick any object type you want into it and then get it back means that if someone can write a malicious record to your database and then you're",
    "start": "2451839",
    "end": "2458560"
  },
  {
    "text": "going to read it later that's probably going to give you rce mongodb might be safe I don't know how to exploit it all",
    "start": "2458560",
    "end": "2465160"
  },
  {
    "text": "of the other ones seem to not be safe and this is probably an issue in no",
    "start": "2465160",
    "end": "2470440"
  },
  {
    "text": "SQL libraries that are not built for net as well if you want to research topic that's a cool one to go into I haven't",
    "start": "2470440",
    "end": "2476319"
  },
  {
    "text": "looked at them too much don't use serialization binders lots of applications out there",
    "start": "2476319",
    "end": "2483480"
  },
  {
    "text": "try to secure themselves with serialization binders you probably can't write a secure one it's very very hard",
    "start": "2483480",
    "end": "2488960"
  },
  {
    "text": "instead what you want to do is rearchitecturing",
    "start": "2488960",
    "end": "2492318"
  },
  {
    "text": "this then if you make it a strict allow list based on strings that only allows pods types that might be okay I don't",
    "start": "2499839",
    "end": "2507680"
  },
  {
    "text": "know a way to exploit that as long as you have a binder everywhere and don't use binary",
    "start": "2507680",
    "end": "2514599"
  },
  {
    "text": "formatter binary formatter is deprecated net is not making fixes to it this stuff I will say is not just",
    "start": "2514599",
    "end": "2522520"
  },
  {
    "text": "exploitable in NET Framework it's exploitable in later versions of net as well so that doesn't protect you and if",
    "start": "2522520",
    "end": "2528760"
  },
  {
    "text": "you have a serialization binder just on your frontend use of binary formatter you can still get bitten by it because you're using it on the back end because",
    "start": "2528760",
    "end": "2534599"
  },
  {
    "text": "of those mutation issues and this went faster than I",
    "start": "2534599",
    "end": "2539640"
  },
  {
    "text": "intended but that's all I had for this talk um are there any questions at this",
    "start": "2539640",
    "end": "2545559"
  },
  {
    "text": "point um okay several I'll we'll start with",
    "start": "2545559",
    "end": "2550800"
  },
  {
    "text": "you the question is do I have any exploits for Cosmos DB I've looked at Cosmos DB some I have not actually built",
    "start": "2553720",
    "end": "2560480"
  },
  {
    "text": "a proof of concept exploit for it I I can't guarantee it's safe but I did not see a way to exploit it um I think",
    "start": "2560480",
    "end": "2567200"
  },
  {
    "text": "you're",
    "start": "2567200",
    "end": "2569480"
  },
  {
    "text": "next um the question was that the gadgets I've been listing are for NET Framework are there gadgets for net",
    "start": "2574880",
    "end": "2581880"
  },
  {
    "text": "core there are gadgets for net core um I",
    "start": "2581880",
    "end": "2587200"
  },
  {
    "text": "won't tell you one that gives you remote code execution but there's quite a few that will at least give you",
    "start": "2587200",
    "end": "2592839"
  },
  {
    "text": "ssrf I've talked about this previously and now I'm trying to remember some of them off the top of my head",
    "start": "2592839",
    "end": "2599640"
  },
  {
    "text": "um let me talk to you after or I'll put it on my madon but like I know some gadgets that give ssrf I talked about",
    "start": "2599640",
    "end": "2605240"
  },
  {
    "text": "before but but net core and it's not called well yes net core is not safe",
    "start": "2605240",
    "end": "2611000"
  },
  {
    "text": "it's just that people who are not me haven't figured out how to do it yet so I'm not giving away too much um yes have",
    "start": "2611000",
    "end": "2618280"
  },
  {
    "text": "you at systems um the question is have I looked",
    "start": "2618280",
    "end": "2624359"
  },
  {
    "text": "at other serializations like systems like protuff um yes there are",
    "start": "2624359",
    "end": "2630040"
  },
  {
    "text": "implementations of protuff that are exploitable and there are implementations that are not",
    "start": "2630040",
    "end": "2635079"
  },
  {
    "text": "exploitable um if you want to talk to me afterwards I could give you specifics",
    "start": "2635079",
    "end": "2641680"
  },
  {
    "text": "um and I suppose that's it well okay thank",
    "start": "2641680",
    "end": "2647000"
  },
  {
    "text": "you",
    "start": "2651800",
    "end": "2654800"
  }
]