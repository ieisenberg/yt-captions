[
  {
    "text": "okay so if you're using C++ atomics or atomics in any language then you're",
    "start": "4520",
    "end": "11799"
  },
  {
    "text": "really going for the low level and it's far too easy to do something wrong shoot",
    "start": "11799",
    "end": "18119"
  },
  {
    "text": "yourself in the foot so we're going to try and show some sort of guidelines that that are going to help with approaches when you're using atomics to",
    "start": "18119",
    "end": "24119"
  },
  {
    "text": "try and avoid shooting yourself in the foot but so to start with we're going to",
    "start": "24119",
    "end": "30599"
  },
  {
    "text": "go through what the types are that we've got what operations you can do in C++ and then we're going to do some",
    "start": "30599",
    "end": "36719"
  },
  {
    "text": "worked examples and then lead up to know these guidelines by the",
    "start": "36719",
    "end": "43160"
  },
  {
    "text": "end so I'm just going to say before we actually get into the things that",
    "start": "44960",
    "end": "50039"
  },
  {
    "text": "fundamentally most of the time you're using Atomic operations rather than locks because you hoping that it's an",
    "start": "50039",
    "end": "55719"
  },
  {
    "text": "optimization and like any other optimization you're doing in your system you want a",
    "start": "55719",
    "end": "62079"
  },
  {
    "text": "profile particularly in in this case because if you're skipping to the lower",
    "start": "62079",
    "end": "67479"
  },
  {
    "text": "level and using know lock free data structures and and atomics then there's so much scope for getting things wrong",
    "start": "67479",
    "end": "72840"
  },
  {
    "text": "in a way that won't manifest in tests because it's multi- code that you really really want to be",
    "start": "72840",
    "end": "80200"
  },
  {
    "text": "sure that it's that it's going to be a benefit because the cost in terms of Maintenance complexity and code",
    "start": "80200",
    "end": "87360"
  },
  {
    "text": "complexity is so high that that you need to be sure it's worth it",
    "start": "87360",
    "end": "94079"
  },
  {
    "text": "and so when you're profiling you need to think about the sort of things that you care about for your application is it",
    "start": "94079",
    "end": "99439"
  },
  {
    "text": "the throughput know the total number of data um items processed per unit time or",
    "start": "99439",
    "end": "106320"
  },
  {
    "text": "is it the latency how long it takes between when you get some input before you get some",
    "start": "106320",
    "end": "111920"
  },
  {
    "text": "output or is it something else know something that's specific to your application some know measure that",
    "start": "111920",
    "end": "117759"
  },
  {
    "text": "you've got specific so you need to decide what your measure is and then measure it with the simple",
    "start": "117759",
    "end": "125159"
  },
  {
    "text": "reliable mechanism or easier to use mechanism of using locks locks and so",
    "start": "125159",
    "end": "131039"
  },
  {
    "text": "forth then Implement your hopeful optimization using atomics and then",
    "start": "131040",
    "end": "136920"
  },
  {
    "text": "profile again and check that you have actually improved the thing you're trying to",
    "start": "136920",
    "end": "143000"
  },
  {
    "text": "do so the atomic types we've got in",
    "start": "147120",
    "end": "152400"
  },
  {
    "text": "C++ fundamentally we're looking at the standard atomic of T class",
    "start": "152400",
    "end": "158959"
  },
  {
    "text": "template and for this you can store any type which is bitwise copyable if you",
    "start": "158959",
    "end": "165200"
  },
  {
    "text": "can use M Copy on your type then you can stick it in a standard atomic know if it's a struct a plane",
    "start": "165200",
    "end": "171879"
  },
  {
    "text": "value whatever you can do it if it's a one of the built-in integer types",
    "start": "171879",
    "end": "180480"
  },
  {
    "text": "then you get an extra set of operations on it but and but you can you get the",
    "start": "180480",
    "end": "186560"
  },
  {
    "text": "basic operations whatever your type is and one of one of the operations you want that you might want to do is a",
    "start": "186560",
    "end": "192760"
  },
  {
    "text": "compare and exchange and for this then we also need it to be",
    "start": "192760",
    "end": "198879"
  },
  {
    "text": "bitwise comparable so if you can use mCP on your type to compare compare values",
    "start": "198879",
    "end": "204799"
  },
  {
    "text": "then you can do your compare Exchange and of course if you use um",
    "start": "204799",
    "end": "211680"
  },
  {
    "text": "well it can be true for any type whatever type you put in atomic te it might not be lock free on any given",
    "start": "211680",
    "end": "216760"
  },
  {
    "text": "platform it might actually use an internal mutex under the hood so this is one of the reasons why you might want to",
    "start": "216760",
    "end": "223040"
  },
  {
    "text": "profile because you're replacing a nice high level mutex that you're in control of with a lowlevel one that the",
    "start": "223040",
    "end": "228319"
  },
  {
    "text": "compiler's in control of and you just made your code more compax so know you don't don't want to do that if that",
    "start": "228319",
    "end": "233519"
  },
  {
    "text": "turns out to be the",
    "start": "233519",
    "end": "236239"
  },
  {
    "text": "case there is only one type in the C++ standard that is guaranteed to be Lock",
    "start": "238680",
    "end": "244720"
  },
  {
    "text": "Free and that is standard atomic flag which is the most cut down Boolean flag",
    "start": "244720",
    "end": "250040"
  },
  {
    "text": "you can possibly imagine and it only has two operations on so we'll have a look at those in just a sec um but you can it",
    "start": "250040",
    "end": "257600"
  },
  {
    "text": "is sufficient to build a spin lock and therefore everything else on top of",
    "start": "257600",
    "end": "264440"
  },
  {
    "text": "it in the concurrency TS we've got two new Atomic types Atomic shared pointer",
    "start": "265040",
    "end": "270840"
  },
  {
    "text": "and atomic weak pointer now Shar pointer and weak pointer normally they're not you can't copy them with M Copy or",
    "start": "270840",
    "end": "276720"
  },
  {
    "text": "compare them with M because you've got to deal with reference counting so we've got special types to deal with those",
    "start": "276720",
    "end": "283440"
  },
  {
    "text": "again they may not be lock free in any given implementation so you need to Hope",
    "start": "283440",
    "end": "288960"
  },
  {
    "text": "if you if you want to use these you need to check but if it does turn out to be lck",
    "start": "288960",
    "end": "296080"
  },
  {
    "text": "free it can greatly simplify your code",
    "start": "296080",
    "end": "301560"
  },
  {
    "text": "so yeah what why are we talking about Atomic well the point is that it's a simple irreducible operation so",
    "start": "302400",
    "end": "310520"
  },
  {
    "text": "operations on our Atomic types can't be divided up any given thread we'll only see either before the operation or after",
    "start": "310520",
    "end": "316639"
  },
  {
    "text": "the operation no there's no possible Middle Ground no scope for races on the",
    "start": "316639",
    "end": "322840"
  },
  {
    "text": "actual value um no data rases no undefined behavior for your Atomic",
    "start": "322840",
    "end": "328479"
  },
  {
    "text": "types",
    "start": "328479",
    "end": "331479"
  },
  {
    "text": "okay so what operations have we got well for everything well we can load our values we can store new values we can",
    "start": "333600",
    "end": "340319"
  },
  {
    "text": "exchange swap one value for another and if they're bitwise comparable we can do",
    "start": "340319",
    "end": "346520"
  },
  {
    "text": "compare exchange which is I've got an existing value if and then I've got an",
    "start": "346520",
    "end": "352039"
  },
  {
    "text": "expected value what I think it might be and a new value I wish to put in and if the it will compare our expectation with",
    "start": "352039",
    "end": "358720"
  },
  {
    "text": "what's actually there and if our expectation matches what's actually in there it will exchange our new value in",
    "start": "358720",
    "end": "365919"
  },
  {
    "text": "and this is a single Atomic operation so you don't have to worry about it doing the compare and then somebody slipping",
    "start": "365919",
    "end": "372240"
  },
  {
    "text": "in and and changing the values in the meantime but again that requires that",
    "start": "372240",
    "end": "377800"
  },
  {
    "text": "it's a bitwise comparable type um there's two variants there weak and strong the strong will only fail if the",
    "start": "377800",
    "end": "387120"
  },
  {
    "text": "values were different if the comparison failed whereas the week might fail due to",
    "start": "387120",
    "end": "392639"
  },
  {
    "text": "running on a weekly ordered architecture like arm or power and if the OS scheduling meant that the operation got",
    "start": "392639",
    "end": "399599"
  },
  {
    "text": "interrupted because the um those platforms don't have a things like x86",
    "start": "399599",
    "end": "405639"
  },
  {
    "text": "have a single instruction for this so you can say I want to do an automic compare exchange bam the compiler just",
    "start": "405639",
    "end": "411319"
  },
  {
    "text": "does it the processor just does it whereas other architectures don't and",
    "start": "411319",
    "end": "416800"
  },
  {
    "text": "because it's now multiple instructions your thread might get be get suspended by the scheduler or",
    "start": "416800",
    "end": "422039"
  },
  {
    "text": "various other effects across multia might cause the operation to fail by the time it hits the final instruction so a",
    "start": "422039",
    "end": "429840"
  },
  {
    "text": "the compare exchange strong then has to Loop whereas the compare exchange weak just says well I failed for no apparent",
    "start": "429840",
    "end": "434879"
  },
  {
    "text": "reason so you will have to then decide whether you wish to try again or adjust your values before you try",
    "start": "434879",
    "end": "441280"
  },
  {
    "text": "again we have assignment now most types when you do assignment then you're",
    "start": "441280",
    "end": "446800"
  },
  {
    "text": "assigning from the same value but with atomics you're assigning from the contained V so Atomic of T you're",
    "start": "446800",
    "end": "453520"
  },
  {
    "text": "assigning from a t Atomic of int you assign from an INT if you can't you can't copy assign an atomic event",
    "start": "453520",
    "end": "459800"
  },
  {
    "text": "because that's now would require Atomic oration as two values and most",
    "start": "459800",
    "end": "465360"
  },
  {
    "text": "implementations can't manage to do that because they're in separate places in memory so you need to explicitly say I",
    "start": "465360",
    "end": "471759"
  },
  {
    "text": "want to load from that one and then assign to the other",
    "start": "471759",
    "end": "476639"
  },
  {
    "text": "one",
    "start": "478319",
    "end": "481319"
  },
  {
    "text": "if we've got integral types or pointers we can do arithmetic so you can know do effect and",
    "start": "486120",
    "end": "493319"
  },
  {
    "text": "add which is add a value atomically to the Val the values that's there and return what the old value was or a",
    "start": "493319",
    "end": "500759"
  },
  {
    "text": "subtract which does the same then we've got operators that do this we've got the plus plus and minus minus both prefix",
    "start": "500759",
    "end": "507120"
  },
  {
    "text": "and postfix variant and no plus equals and minus equals so you can do atomic operations",
    "start": "507120",
    "end": "515640"
  },
  {
    "text": "these are short hands for doing a compare exchange with the relevant",
    "start": "515640",
    "end": "522640"
  },
  {
    "text": "values if you've got um an integral type rather than rather than a poter then you",
    "start": "523320",
    "end": "529279"
  },
  {
    "text": "can also do bitwise operations which again know you say you've got and and or and exclusive or and then the operator",
    "start": "529279",
    "end": "536839"
  },
  {
    "text": "variance yes they'd all be equivalent to the strong",
    "start": "536839",
    "end": "542440"
  },
  {
    "text": "compar exchange so uh is possible On Any Given platform there might be a nice Atomic operation to do it um so if the",
    "start": "542440",
    "end": "550440"
  },
  {
    "text": "compiler is being smart on an x86 if you're not using the return value then",
    "start": "550440",
    "end": "555920"
  },
  {
    "text": "fetch ad might use an in construction a locked variant of the in construction to increment the value but if you need the",
    "start": "555920",
    "end": "562079"
  },
  {
    "text": "return value it can't do that because so actually has to do the exchange",
    "start": "562079",
    "end": "567320"
  },
  {
    "text": "um and then of course on our Atomic flag I said we've only got two operations",
    "start": "567320",
    "end": "572959"
  },
  {
    "text": "there is test and set or clear you can't just set it you can't test and clear it",
    "start": "572959",
    "end": "579519"
  },
  {
    "text": "you can only test and set and you and if you want to test what the value is you",
    "start": "579519",
    "end": "584959"
  },
  {
    "text": "have to set it there is no no query it without setting so there's only these two it's the bare minimum that was",
    "start": "584959",
    "end": "591079"
  },
  {
    "text": "guaranteed to be supported us across all the platforms we wanted to support C++ 11 on and it's enough to build the",
    "start": "591079",
    "end": "597800"
  },
  {
    "text": "higher level structures with an internal lock so of course all this lot might not",
    "start": "597800",
    "end": "605120"
  },
  {
    "text": "be lock free but these ones are um there is an an is loock free",
    "start": "605120",
    "end": "610920"
  },
  {
    "text": "member function on your Atomic types which you can use out runtime at startup in your application to test whether any",
    "start": "610920",
    "end": "617240"
  },
  {
    "text": "given um Atomic of te is lock free on the current running",
    "start": "617240",
    "end": "622880"
  },
  {
    "text": "platform uh there are also some macros that you can use at compile time which will tell you whether it's always Lock",
    "start": "622880",
    "end": "629519"
  },
  {
    "text": "Free never lock free or sometimes um the reason it might be sometimes is because you can compile a single um process that",
    "start": "629519",
    "end": "637320"
  },
  {
    "text": "a single application that you might be able to use the same binary on multiple different um CPUs and depending on the",
    "start": "637320",
    "end": "644920"
  },
  {
    "text": "properties of the CPU so for example old um x86 on 64-bit platforms don't have a 16",
    "start": "644920",
    "end": "653680"
  },
  {
    "text": "by compare exchange whereas new ones do so you can't then have 16 by atomics",
    "start": "653680",
    "end": "659200"
  },
  {
    "text": "on an old version of an x86 platform but you can on the newer",
    "start": "659200",
    "end": "665079"
  },
  {
    "text": "ones and when I say newer I mean anything that can run Windows 8 so we're not talking epically new",
    "start": "665079",
    "end": "671519"
  },
  {
    "text": "but it's it is still something there are know systems in the wild that don't have",
    "start": "671519",
    "end": "677600"
  },
  {
    "text": "that",
    "start": "677600",
    "end": "679839"
  },
  {
    "text": "operation okay so when you're doing your Atomic operations then you can put constraints on them without the memory",
    "start": "686240",
    "end": "692720"
  },
  {
    "text": "ordering now there are six different values that you can put you can the default if you don't",
    "start": "692720",
    "end": "700000"
  },
  {
    "text": "specify anything and which you get if you use any of the operator variants you don't have any choice because operators",
    "start": "700000",
    "end": "705240"
  },
  {
    "text": "you can't add extra parameters so and it always uses sequentially consistent which is the top one the the strongest",
    "start": "705240",
    "end": "711000"
  },
  {
    "text": "ordering constraint um if you use one of the function operations then you can add",
    "start": "711000",
    "end": "716800"
  },
  {
    "text": "additional constraints which are increasingly relaxed in the in the requirements that they put on you um so",
    "start": "716800",
    "end": "723200"
  },
  {
    "text": "you can have do acquire and release so acquire is for load operations to say now I want to be able to see changes",
    "start": "723200",
    "end": "731320"
  },
  {
    "text": "that were made by other threads to other variables that that have been I'm acquiring the synchronization through",
    "start": "731320",
    "end": "736760"
  },
  {
    "text": "this load um release is the store part of that so I'm when I do a store with release then that's saying the changes",
    "start": "736760",
    "end": "743600"
  },
  {
    "text": "that I've made to other variables I'm publishing to anyone that's that's doing that's synchronizing through an acquire on this",
    "start": "743600",
    "end": "749560"
  },
  {
    "text": "value um acquire release is the um read modify right operation version so if",
    "start": "749560",
    "end": "756120"
  },
  {
    "text": "you're doing a compare exchange which is both a load and a store then you use acquire release to do both halves though",
    "start": "756120",
    "end": "762240"
  },
  {
    "text": "you can only use only say I'm only synchronizing one way I I only want to do release or only an",
    "start": "762240",
    "end": "768199"
  },
  {
    "text": "acquire and then relaxed which is fxos only is don't do any synchronization",
    "start": "768199",
    "end": "775399"
  },
  {
    "text": "other than on this specific value so the specific value that I've got my Atomic of te that I'm using then that value is",
    "start": "775399",
    "end": "781279"
  },
  {
    "text": "going to be safely accessed but I'm not going to put any ordering with regards to what um other operations are visible",
    "start": "781279",
    "end": "787079"
  },
  {
    "text": "to other threads so and when you put these on your on your operations it it controls",
    "start": "787079",
    "end": "794320"
  },
  {
    "text": "precisely the details of the instruction that it generates so um whether or not",
    "start": "794320",
    "end": "800760"
  },
  {
    "text": "there might be additional fence operations and on x86 then if you do a",
    "start": "800760",
    "end": "806440"
  },
  {
    "text": "sequentially consistent store then it will use a stronger know an exchange operation rather than a plain store um",
    "start": "806440",
    "end": "813800"
  },
  {
    "text": "in order to guarantee that the um Global synchronization properties are",
    "start": "813800",
    "end": "819240"
  },
  {
    "text": "met okay now down here in tiny type which hopefully you can't actually read um it says memory order consume now this",
    "start": "819240",
    "end": "825600"
  },
  {
    "text": "is a special variant of memory order require which only synchronizes some values and there are probably only three",
    "start": "825600",
    "end": "833360"
  },
  {
    "text": "people who know how this works and they keep disagreeing on what they what what it actually does so de think shaking his",
    "start": "833360",
    "end": "840360"
  },
  {
    "text": "head I think he thinks there might not be anybody who knows how it works um",
    "start": "840360",
    "end": "846839"
  },
  {
    "text": "nobody well it if it if it works how some",
    "start": "846839",
    "end": "852759"
  },
  {
    "text": "people think it was then it would also be applicable to some other systems other than Alpha but there is disagreement so yeah maybe",
    "start": "852759",
    "end": "859880"
  },
  {
    "text": "nobody actually knows but so really really you don't want to use it um but it's there just to confuse",
    "start": "859880",
    "end": "867680"
  },
  {
    "text": "you might actually beated in well if it is then that's",
    "start": "867680",
    "end": "874959"
  },
  {
    "text": "great okay so if you're doing sequentially consistent ordering then",
    "start": "877600",
    "end": "883800"
  },
  {
    "text": "sequentially consistent operations they work how you might think things work which is really nice you can",
    "start": "883800",
    "end": "892000"
  },
  {
    "text": "in your mental image think I've got all these operations across all these threads and I can I'm going to rearrange",
    "start": "892000",
    "end": "899120"
  },
  {
    "text": "them into this happens first then that one over there then that one over there then this one down here in some nice",
    "start": "899120",
    "end": "905240"
  },
  {
    "text": "order and that's what we get with sequentially consistent operations is some single Global total order of all",
    "start": "905240",
    "end": "911240"
  },
  {
    "text": "our operations across all our threads and obviously you don't know in advance what the order is going to be but when",
    "start": "911240",
    "end": "916560"
  },
  {
    "text": "you look at the your variable operations and you look at the values you get you will be able to construct that order the",
    "start": "916560",
    "end": "923519"
  },
  {
    "text": "compiler and the and the processor and the runtime work together to ensure that there is such an order and then you can",
    "start": "923519",
    "end": "929639"
  },
  {
    "text": "reason about it so if we've got four threads we've",
    "start": "929639",
    "end": "934839"
  },
  {
    "text": "got one thread over here that is storing a value to some variable X and another",
    "start": "934839",
    "end": "940720"
  },
  {
    "text": "thread over there that's storing a value to some variable y then we've got two threads in the middle that are reading X and Y but in",
    "start": "940720",
    "end": "946720"
  },
  {
    "text": "different orders so this one reads X and finds that it's value one so it must be after",
    "start": "946720",
    "end": "955480"
  },
  {
    "text": "this store so that's great this this value reads y This Thread reads Y and sees that it's value",
    "start": "955480",
    "end": "961360"
  },
  {
    "text": "one and that must be after that store so that's great but over here with the second",
    "start": "961360",
    "end": "967199"
  },
  {
    "text": "order load we're now loading from X if we load zero here now we've got a single Global total order so this load here",
    "start": "967199",
    "end": "974880"
  },
  {
    "text": "must be before that before the store to X in that order because if you've only",
    "start": "974880",
    "end": "980639"
  },
  {
    "text": "got the one store then if you read the value that was there before it well that's read must have happened before the",
    "start": "980639",
    "end": "986440"
  },
  {
    "text": "store and so then we can think well we've got a single Global total order so we can follow the arrows around we've",
    "start": "986440",
    "end": "992519"
  },
  {
    "text": "got our y store to Y is before our load from Y which is before our load from X",
    "start": "992519",
    "end": "998040"
  },
  {
    "text": "which is before our store to X which is before our load of X so when we load y",
    "start": "998040",
    "end": "1003199"
  },
  {
    "text": "over here we must get one if this thread reads Y is 1 X is",
    "start": "1003199",
    "end": "1008600"
  },
  {
    "text": "zero we must get X um Y is one if we got X is one over here there if you've got",
    "start": "1008600",
    "end": "1014600"
  },
  {
    "text": "single sequentially consistent operations there is no other way that this can work",
    "start": "1014600",
    "end": "1020480"
  },
  {
    "text": "so if you're doing release acquire synchronization then the um synchronization is a bit",
    "start": "1024439",
    "end": "1031760"
  },
  {
    "text": "more limited it works on specific variables and the operations that are",
    "start": "1031760",
    "end": "1038678"
  },
  {
    "text": "visible to given threads so there's no longer this Global single total order but a specific set of",
    "start": "1038679",
    "end": "1047280"
  },
  {
    "text": "operations and and things that were visible to one thread become visible to",
    "start": "1047280",
    "end": "1052960"
  },
  {
    "text": "another so the specific case that we will start is if we've got a store to some variable X now this one doesn't",
    "start": "1053160",
    "end": "1059039"
  },
  {
    "text": "have to be Atomic I know for for this synchronization to work we've got a store of to some variable X and then",
    "start": "1059039",
    "end": "1066080"
  },
  {
    "text": "we've got a store to some Atomic variable y with a release operation memory Order",
    "start": "1066080",
    "end": "1073080"
  },
  {
    "text": "release on the on this other thread we've got a load and we're reading that",
    "start": "1073080",
    "end": "1079159"
  },
  {
    "text": "value of from y with a memory order acquire now if the value that we see is",
    "start": "1079159",
    "end": "1084400"
  },
  {
    "text": "one is the value that we stored over here then we have a synchronization",
    "start": "1084400",
    "end": "1090640"
  },
  {
    "text": "relationship here if we don't see that see the value that was written then we haven't got that oper that that",
    "start": "1090640",
    "end": "1096080"
  },
  {
    "text": "synchronization it's not there and so then you can subsequently",
    "start": "1096080",
    "end": "1102360"
  },
  {
    "text": "you will you will see the this value was stored over here it was before the store with the release",
    "start": "1102360",
    "end": "1109080"
  },
  {
    "text": "and so when you do the load with acquire then a read that's done afterwards will see the value from up",
    "start": "1109080",
    "end": "1115200"
  },
  {
    "text": "here you can follow the arrows and you get the value that you're",
    "start": "1115200",
    "end": "1122600"
  },
  {
    "text": "expected the difference from sequential consistency is that unrelated reads do",
    "start": "1123679",
    "end": "1129320"
  },
  {
    "text": "not synchronize so we've got our same four threads as we had before we've got a store to X and a",
    "start": "1129320",
    "end": "1135720"
  },
  {
    "text": "store to Y we've got two threads doing a load of x and load of Y in different",
    "start": "1135720",
    "end": "1140760"
  },
  {
    "text": "orders but this time we're doing release operations on the store and acquire on the",
    "start": "1140760",
    "end": "1145919"
  },
  {
    "text": "loads if we get our load of x's zero over here you it doesn't now have to be",
    "start": "1145919",
    "end": "1153600"
  },
  {
    "text": "a global total order so from the point of view of this thread here the store to",
    "start": "1153600",
    "end": "1158679"
  },
  {
    "text": "X hasn't happened yet but from the store to from the point of view of this thread over here it doesn't care what that",
    "start": "1158679",
    "end": "1164880"
  },
  {
    "text": "thread thinks it thinks the store TX has happened but the but the store to Y hasn't so you can now whereas",
    "start": "1164880",
    "end": "1172080"
  },
  {
    "text": "before we had that we if we get Y is 1 X is0 X is one means we must have y is one",
    "start": "1172080",
    "end": "1179600"
  },
  {
    "text": "over here now we're allowed to have y is z x is one y is z or why and Y is 1 X is",
    "start": "1179600",
    "end": "1187559"
  },
  {
    "text": "zero so you can get inconsistency from the views between threads",
    "start": "1187559",
    "end": "1193360"
  },
  {
    "text": "so you know you really need to think about what it is you're trying to synchronize if you're going to relax the",
    "start": "1193360",
    "end": "1198840"
  },
  {
    "text": "operations even from sequentially consistent to just acquire",
    "start": "1198840",
    "end": "1203320"
  },
  {
    "text": "release of course if you're using relaxed operations then anything can happen now even with just the two",
    "start": "1209360",
    "end": "1214679"
  },
  {
    "text": "threads know you store to X and store to Y and if you load from y with relaxed",
    "start": "1214679",
    "end": "1220960"
  },
  {
    "text": "ordering then when you load from X I mean in this case there would if it was if x wasn't Atomic there would be a Race",
    "start": "1220960",
    "end": "1226919"
  },
  {
    "text": "So assume X is Atomic then um you can get any value from from X because it",
    "start": "1226919",
    "end": "1232520"
  },
  {
    "text": "doesn't there's no ordering the the store to Y the load from load from y doesn't apply any ordering at",
    "start": "1232520",
    "end": "1240440"
  },
  {
    "text": "all we've also got fences two kinds of fences there's a",
    "start": "1245000",
    "end": "1250960"
  },
  {
    "text": "thread fence and a signal fence now the the thread fence is what",
    "start": "1250960",
    "end": "1256600"
  },
  {
    "text": "one might always think of as a fence and the signal fence is specifically for Signal synchronizing between a thread and a signal Handler in the same thread",
    "start": "1256600",
    "end": "1264360"
  },
  {
    "text": "which for most most purposes you can probably completely ignore I've just put it on here for for completion if you're",
    "start": "1264360",
    "end": "1270679"
  },
  {
    "text": "doing signal handlers and using Atomic operations then you can read up about",
    "start": "1270679",
    "end": "1276039"
  },
  {
    "text": "signal fence but otherwise just ignore it and in C++ whereas in if you're",
    "start": "1276039",
    "end": "1283919"
  },
  {
    "text": "looking at um processor documentation then fences might have global global SN",
    "start": "1283919",
    "end": "1289600"
  },
  {
    "text": "um properties in C++ then specifically fences modify the ordering",
    "start": "1289600",
    "end": "1296360"
  },
  {
    "text": "constraints on the surrounding Atomic operations so if we've got a load with a",
    "start": "1296360",
    "end": "1303080"
  },
  {
    "text": "relaxed memory order and then we apply a thread fence with a chir then it is as",
    "start": "1303080",
    "end": "1310320"
  },
  {
    "text": "if we've said load with memory order require and no fence um whether the can process a gener",
    "start": "1310320",
    "end": "1318120"
  },
  {
    "text": "Ates the same instructions for the two cases it may or may not the compiler might decide that actually know I need",
    "start": "1318120",
    "end": "1324400"
  },
  {
    "text": "to if you specify explicit with a fence you will get different instructions so it's not completely the same but it can",
    "start": "1324400",
    "end": "1331200"
  },
  {
    "text": "implement it identically if it can see that that's what it's doing and likewise if you have a release fence before a",
    "start": "1331200",
    "end": "1338320"
  },
  {
    "text": "relaxed store then it's equivalent to a memory Order release on the",
    "start": "1338320",
    "end": "1343480"
  },
  {
    "text": "store so no mo mostly you no um I would say mostly you don't need to use the",
    "start": "1343480",
    "end": "1349679"
  },
  {
    "text": "fences but there are a few cases particularly if you end up if you think there's only conditional synchronization I want to do so you might um only",
    "start": "1349679",
    "end": "1356240"
  },
  {
    "text": "conditionally do your fences okay for completeness I mean and",
    "start": "1356240",
    "end": "1362880"
  },
  {
    "text": "acquire release fence is both an acquire fence and a release fence so it will deal with um stores before it",
    "start": "1362880",
    "end": "1371360"
  },
  {
    "text": "and um stores after it and loads before it and sequentially consistent fences",
    "start": "1371360",
    "end": "1378039"
  },
  {
    "text": "they fit in your single total order of sequentially consistent operations so they provide a little bit more of um an",
    "start": "1378039",
    "end": "1385039"
  },
  {
    "text": "ordering constraint but it's can be quite hard to make it to",
    "start": "1385039",
    "end": "1392159"
  },
  {
    "text": "make it work right if if and if you end up really relying on where that fits in your ordering list then you're probably doing something wrong",
    "start": "1392159",
    "end": "1399240"
  },
  {
    "text": "so no it's not necessarily a good plan but it is",
    "start": "1399240",
    "end": "1404960"
  },
  {
    "text": "there okay so let's look at some lot free",
    "start": "1406880",
    "end": "1413039"
  },
  {
    "text": "examples and why would you use atomics I mean obviously this the simple case you can use atom is youve got a single variable and like an atomic like a bull",
    "start": "1413039",
    "end": "1420600"
  },
  {
    "text": "variable that you're protecting with a lock and you say well I I can get rid of that lock I'll just have an atomic bull instead so if you're in Andre's talk",
    "start": "1420600",
    "end": "1427600"
  },
  {
    "text": "short time ago then rather than having synchronized of an INT or synchronized of a bu then you could just use Atomic",
    "start": "1427600",
    "end": "1434880"
  },
  {
    "text": "of an INT or Atomic of a b but if you're doing larger scope things then we talk",
    "start": "1434880",
    "end": "1442039"
  },
  {
    "text": "about lock free code lock free data structures so we got three sorts of",
    "start": "1442039",
    "end": "1448919"
  },
  {
    "text": "guarantees that the um know researchers like to talk about with your lot free",
    "start": "1448919",
    "end": "1456320"
  },
  {
    "text": "things first is obstruction free which is that if we've got lots of threads",
    "start": "1456320",
    "end": "1461840"
  },
  {
    "text": "accessing our data structure and we pause know the OS decides that they're all going to stop apart from our one",
    "start": "1461840",
    "end": "1468399"
  },
  {
    "text": "now maybe we're on a single core machine we using lock free data structures on a single core machine so everything stops",
    "start": "1468399",
    "end": "1473840"
  },
  {
    "text": "except this one can it finish its operation and if it can if there's a if",
    "start": "1473840",
    "end": "1479440"
  },
  {
    "text": "if it can finish in a bounded number of steps it's obstruction free and that doesn't mean matter regardless where the",
    "start": "1479440",
    "end": "1485880"
  },
  {
    "text": "other where in their operations the other threads were",
    "start": "1485880",
    "end": "1490120"
  },
  {
    "text": "suspended if know if you want to step up on that and you say okay we're not going to",
    "start": "1491320",
    "end": "1496559"
  },
  {
    "text": "suspend any of our threads they all going to access um but they and so they're all going to try and compete on",
    "start": "1496559",
    "end": "1502559"
  },
  {
    "text": "our data structure but they might get in each other's way so know we've got",
    "start": "1502559",
    "end": "1508240"
  },
  {
    "text": "compare exchange compare exchange might fail because another thread is swapped in the value you were trying to Sol to",
    "start": "1508240",
    "end": "1513520"
  },
  {
    "text": "try and put in so then you have to Loop and so if you've got multiple threads and",
    "start": "1513520",
    "end": "1521520"
  },
  {
    "text": "they and within a bounding number of steps one of them is going to actually get to the end then it's now a lock free",
    "start": "1521520",
    "end": "1527000"
  },
  {
    "text": "data structure but you don't know it might any given thread might have to keep looping it might be really unlucky and that know",
    "start": "1527000",
    "end": "1533919"
  },
  {
    "text": "you it's um that that one thread will have to keep looping a million times whilst I know a million other threads",
    "start": "1533919",
    "end": "1540120"
  },
  {
    "text": "get all the way through their operations without without interruption but that still lock free",
    "start": "1540120",
    "end": "1547520"
  },
  {
    "text": "and that's the most common guarantee you're going to see in lock free code because it's the one that ideally you",
    "start": "1547520",
    "end": "1554520"
  },
  {
    "text": "you you're going to want cuz most of the time your other threads are not going to be paused they're not going to be stopped by the sedula so obstruction",
    "start": "1554520",
    "end": "1560799"
  },
  {
    "text": "Free Will mean that you'll actually end up with things getting in each other's way you'll get live lock whereas the",
    "start": "1560799",
    "end": "1566440"
  },
  {
    "text": "strongest guarantee at the bottom weight free is really hard to get weight free essentially means there",
    "start": "1566440",
    "end": "1573039"
  },
  {
    "text": "are no unbounded Loops in your code and every thread that is accessing",
    "start": "1573039",
    "end": "1578919"
  },
  {
    "text": "the data structure has to be able to get to the end in a known upper bound on",
    "start": "1578919",
    "end": "1584799"
  },
  {
    "text": "number of steps it might be that if it's the only thread accessing data structure it can get through in three steps but if",
    "start": "1584799",
    "end": "1590120"
  },
  {
    "text": "there's other threads then it now takes 20 but that's okay because we know there's a top limit of 20 but if there's",
    "start": "1590120",
    "end": "1595679"
  },
  {
    "text": "no known top limit then it's not weit",
    "start": "1595679",
    "end": "1599919"
  },
  {
    "text": "free and if you're doing Real Time stuff where you've got hard time boundaries",
    "start": "1600840",
    "end": "1606600"
  },
  {
    "text": "then you need weight free operations because then you can know that know my operation is going to complete and",
    "start": "1606600",
    "end": "1613399"
  },
  {
    "text": "within a certain time quter that I can then put into all my calculations of whether or not I can do",
    "start": "1613399",
    "end": "1620000"
  },
  {
    "text": "things so in order to know demonstrate some examples let's talk about",
    "start": "1622919",
    "end": "1629640"
  },
  {
    "text": "q's and q's are a core facility for communication between threads there might be many types and know you might",
    "start": "1630399",
    "end": "1637039"
  },
  {
    "text": "have single producer single consumer cues multiple producers and single consumers multiple producers and",
    "start": "1637039",
    "end": "1643279"
  },
  {
    "text": "multiple consumers or the other way one producer and then loads of thread reading values off the other",
    "start": "1643279",
    "end": "1649640"
  },
  {
    "text": "end you might have bounded cues where there's a maximum number of elements that can be in Flight in the queue at a",
    "start": "1649640",
    "end": "1655240"
  },
  {
    "text": "time or unbounded cues where you just keep allocating off the heat um as long",
    "start": "1655240",
    "end": "1660279"
  },
  {
    "text": "as you've got heat memory then you there's no bound now you might have know various",
    "start": "1660279",
    "end": "1665919"
  },
  {
    "text": "properties fifo cues lifeo cues priority cues unordered",
    "start": "1665919",
    "end": "1671159"
  },
  {
    "text": "um and then again they might be intrusive and non-intrusive so if you want to put it in a queue you've got to",
    "start": "1671159",
    "end": "1676799"
  },
  {
    "text": "actually do something something per in intrusive to your data structure or otherwise and they core to",
    "start": "1676799",
    "end": "1683600"
  },
  {
    "text": "multi-threaded stuff and they're quite good for demonstrating lots of the",
    "start": "1683600",
    "end": "1689200"
  },
  {
    "text": "issues so let's start with a no a lock based unbounded multi- producer multi",
    "start": "1690200",
    "end": "1696440"
  },
  {
    "text": "consumer fifo q and to do this well we're going to wrap a standard Q object",
    "start": "1696440",
    "end": "1701880"
  },
  {
    "text": "with a mutex and a condition variable so to push back we just lock",
    "start": "1701880",
    "end": "1709159"
  },
  {
    "text": "the mutex push our value onto our ramp q and notify anyone who's waiting that",
    "start": "1709159",
    "end": "1714880"
  },
  {
    "text": "there is now a value and if we're popping front popping",
    "start": "1714880",
    "end": "1720679"
  },
  {
    "text": "off the front then we can know lock our mutex we can wait with our on our",
    "start": "1720679",
    "end": "1728200"
  },
  {
    "text": "condition variable using our know with our lock and we're checking for the case that the the wrapped queue is not",
    "start": "1728200",
    "end": "1735640"
  },
  {
    "text": "empty and when the r Q is not empty we can then take the front value remove it",
    "start": "1735640",
    "end": "1741399"
  },
  {
    "text": "from the Q and return okay so can we do this Lock Free",
    "start": "1741399",
    "end": "1748039"
  },
  {
    "text": "okay well let's start simple we're going to have one producer thread one consumer",
    "start": "1748039",
    "end": "1753279"
  },
  {
    "text": "thread and bounded operations so there's only a",
    "start": "1753279",
    "end": "1759039"
  },
  {
    "text": "specified number of items in IQ if we get too many then it's full and somebody has to wait and then we're going to",
    "start": "1759039",
    "end": "1764640"
  },
  {
    "text": "assume that we can copy our values without exceptions because that make things easier and if you're look know a",
    "start": "1764640",
    "end": "1770480"
  },
  {
    "text": "que of in or a que of pointers that is the case",
    "start": "1770480",
    "end": "1774518"
  },
  {
    "text": "so it's not a Dar assumption okay so we're going to have",
    "start": "1777760",
    "end": "1784200"
  },
  {
    "text": "an array with some entries our entries we're going to have",
    "start": "1784200",
    "end": "1790240"
  },
  {
    "text": "this is a basically this this complex bit at the top aign storage we're going to say we're going to create a buffer",
    "start": "1790240",
    "end": "1796200"
  },
  {
    "text": "that's big enough to hold and and appropriately aligned to hold the values that we want to put in our q but we but",
    "start": "1796200",
    "end": "1801679"
  },
  {
    "text": "we're not going to put the values there yet it's just some storage and then we've got the atomic bull to say is it",
    "start": "1801679",
    "end": "1808360"
  },
  {
    "text": "initialized or not is there actually a value in this given",
    "start": "1808360",
    "end": "1812440"
  },
  {
    "text": "entry so when we we're going to um push values on then we're going to have a",
    "start": "1814440",
    "end": "1822000"
  },
  {
    "text": "position where we're pushing now we've said that there's only one thread that's pushing so we this doesn't need to be",
    "start": "1822000",
    "end": "1829600"
  },
  {
    "text": "Atomic we just take so we take the current value we find the entry in the buffer if it's already initialized then",
    "start": "1829600",
    "end": "1836960"
  },
  {
    "text": "we're going to throw that with full because it means we've wrapped all the way round and and the threads haven't been taken out yet um values haven't",
    "start": "1836960",
    "end": "1843880"
  },
  {
    "text": "been taken out by the consuming thread if it wasn't full then we're going to increment the value but with a",
    "start": "1843880",
    "end": "1849880"
  },
  {
    "text": "rat round and then we populate the value and set and say yeah this V's ready",
    "start": "1849880",
    "end": "1859240"
  },
  {
    "text": "okay so just on the side now we This Thread doesn't actually do any",
    "start": "1862240",
    "end": "1868639"
  },
  {
    "text": "waiting it just says if the que is full then you're going to throw and which means that if you want to um if you're",
    "start": "1868639",
    "end": "1875440"
  },
  {
    "text": "trying to push on a a queue that's full then you've got to do something above it because you could now you can catch the",
    "start": "1875440",
    "end": "1882240"
  },
  {
    "text": "exception and try again but then you end up essentially with a busy weight Loop so we'd like to avoid those if possible",
    "start": "1882240",
    "end": "1888559"
  },
  {
    "text": "but so you prob you if the if there is a danger of the thread being the queue being full because you're producer",
    "start": "1888559",
    "end": "1895399"
  },
  {
    "text": "consumer threads are running at different different speeds then you need to think about waiting um the only case",
    "start": "1895399",
    "end": "1901960"
  },
  {
    "text": "where I know where you really want have a sort of loop is like if You' got a compare exchange weak and so you're just",
    "start": "1901960",
    "end": "1907240"
  },
  {
    "text": "you're just looping around and you actually want that Loop to be really small most of the time because you don't",
    "start": "1907240",
    "end": "1912720"
  },
  {
    "text": "want it to be interrupted so you want to make sure that you complete your operations",
    "start": "1912720",
    "end": "1917919"
  },
  {
    "text": "um but otherwise you need to use an external weight mechanism external to what we're showing here like a condition variable which does add complexity um",
    "start": "1917919",
    "end": "1924799"
  },
  {
    "text": "but you might be able to use something that's a bit uh lighter weight if you depending on your",
    "start": "1924799",
    "end": "1931760"
  },
  {
    "text": "platform okay so now skip over to removing values so we again we've got an",
    "start": "1933799",
    "end": "1940639"
  },
  {
    "text": "A nonatomic position that we're popping from so we're going to check that our",
    "start": "1940639",
    "end": "1946240"
  },
  {
    "text": "buffer going to check we're initialized in the buffer and if that if the if the current entry is doesn't have one then",
    "start": "1946240",
    "end": "1953840"
  },
  {
    "text": "the queue is empty so we're going to throw otherwise we're going to cast our our storage to get a pointer to the the",
    "start": "1953840",
    "end": "1961320"
  },
  {
    "text": "the T value that's there um take the value out destroy the",
    "start": "1961320",
    "end": "1966519"
  },
  {
    "text": "one that's stored clear the flag and check move the",
    "start": "1966519",
    "end": "1972880"
  },
  {
    "text": "pointer it's nice and straightforward but it's single producer single",
    "start": "1972880",
    "end": "1980440"
  },
  {
    "text": "consumer if we were going to try and extend that to have multiple producers",
    "start": "1983639",
    "end": "1989399"
  },
  {
    "text": "multiple threads being allowed to push onto onto your Cur anyer one time then things get a bit more tricky you might",
    "start": "1989399",
    "end": "1995960"
  },
  {
    "text": "think that you could just make it an atomic on your push position and so we load the value and",
    "start": "1995960",
    "end": "2003200"
  },
  {
    "text": "then we sort of um try and do an atomic increment but we couldn't just use fetch ad",
    "start": "2003200",
    "end": "2010039"
  },
  {
    "text": "because we need to do with the r round so we do a compare exchange weak Loop you might think that this would be",
    "start": "2010039",
    "end": "2016799"
  },
  {
    "text": "good but it isn't it's it's too naive and this is one of the know the the",
    "start": "2016799",
    "end": "2022679"
  },
  {
    "text": "first things that you find if you trying if you're doing um lock free stuff then the simple cases all nice and good you",
    "start": "2022679",
    "end": "2029919"
  },
  {
    "text": "try and extend things to more threads and no things go",
    "start": "2029919",
    "end": "2035080"
  },
  {
    "text": "wrong it's still broken so the particular sequence of operations",
    "start": "2035080",
    "end": "2040919"
  },
  {
    "text": "that can get things wrong we've got an empty Q push POS is",
    "start": "2040919",
    "end": "2046240"
  },
  {
    "text": "zero so thread one calls push back it gets a position of gets the position is",
    "start": "2046240",
    "end": "2052638"
  },
  {
    "text": "zero and increments the position to one nicely the compare exchange just works there's no other competing threads it",
    "start": "2052639",
    "end": "2058919"
  },
  {
    "text": "checks the cell is empty and gets suspended then now suppose we've got",
    "start": "2058919",
    "end": "2065200"
  },
  {
    "text": "another thread which pushes back until we've got a full buffer so the push",
    "start": "2065200",
    "end": "2070358"
  },
  {
    "text": "position is now wrapped all the way back around and he's now pointing our first entry",
    "start": "2070359",
    "end": "2075440"
  },
  {
    "text": "again and thread two pushes then one more",
    "start": "2077320",
    "end": "2083358"
  },
  {
    "text": "item so it's actually trying to push our know buffer size plus one item onto the",
    "start": "2083359",
    "end": "2091078"
  },
  {
    "text": "que but the first threade hasn't actually put an item in its slot yet",
    "start": "2091720",
    "end": "2097920"
  },
  {
    "text": "so thread two gets the same position and checks that the cell is empty and it is",
    "start": "2097920",
    "end": "2103040"
  },
  {
    "text": "it is empty because the first thread hasn't done anything yet it's got it it was allocated the cell but it got",
    "start": "2103040",
    "end": "2108520"
  },
  {
    "text": "suspended before it could put a put anything in the cell",
    "start": "2108520",
    "end": "2114240"
  },
  {
    "text": "so thread 2 checks that the cell is empty puts a value in in the cell and",
    "start": "2114240",
    "end": "2119320"
  },
  {
    "text": "it's done but thread one is then woken up and it says well I just checked this cell this cell's empty so I'm going to",
    "start": "2119320",
    "end": "2125920"
  },
  {
    "text": "put my value in the cell and now we have unsynchronized access to a a value",
    "start": "2125920",
    "end": "2135560"
  },
  {
    "text": "um which is being accessed by multiple threads and we've got a data race and the queue is",
    "start": "2135560",
    "end": "2141280"
  },
  {
    "text": "broken and even if that was an atomic value that you being then you would have overwritten a value that hadn't yet been",
    "start": "2141280",
    "end": "2146960"
  },
  {
    "text": "removed so the naive attempt of just making the push position Atomic doesn't",
    "start": "2146960",
    "end": "2154839"
  },
  {
    "text": "work so you might think well that only happens if we were trying to push know",
    "start": "2155800",
    "end": "2163359"
  },
  {
    "text": "buffer size plus one elements because the buffer was already full can we prevent this by checking the size for a",
    "start": "2163359",
    "end": "2168880"
  },
  {
    "text": "full buffer can we add an atomic size know we load the size if the size is the",
    "start": "2168880",
    "end": "2174520"
  },
  {
    "text": "buffer size then we we keep looping we put some sort of busy weight in there um",
    "start": "2174520",
    "end": "2181800"
  },
  {
    "text": "otherwise we're going to increment because we're going to push we're adding a new value but now we're not even obstruction",
    "start": "2181800",
    "end": "2188359"
  },
  {
    "text": "free because as soon as the um if the if you get thread no in",
    "start": "2188359",
    "end": "2194960"
  },
  {
    "text": "our in our example if thread one was suspended with it waiting to put value in it cell the buffer is now full and no",
    "start": "2194960",
    "end": "2201319"
  },
  {
    "text": "no thread would now be allowed to populate that that cell because the the um retrieving thread will will get",
    "start": "2201319",
    "end": "2209599"
  },
  {
    "text": "blocked because the cell's empty and the other pushing threads are blocked because the Buffer's",
    "start": "2209599",
    "end": "2215680"
  },
  {
    "text": "full so if you suspend all but one thread",
    "start": "2215680",
    "end": "2220839"
  },
  {
    "text": "unless the one thread that's awake is the one that's that hasn't got a cell that it's trying to populate that's it's",
    "start": "2220839",
    "end": "2227599"
  },
  {
    "text": "holding everybody up unless that is the one that's awake then nobody makes progress this is not even obstruction",
    "start": "2227599",
    "end": "2233920"
  },
  {
    "text": "free okay so can we fix it now and to do that we need to think",
    "start": "2235599",
    "end": "2241520"
  },
  {
    "text": "about what the problem is U that we're actually trying to address",
    "start": "2241520",
    "end": "2247520"
  },
  {
    "text": "and the thing is that so pushing a value has three steps we need to find a free slot we need to construct the pushed",
    "start": "2247520",
    "end": "2254560"
  },
  {
    "text": "value in that slot and we need to mark that value as available to whichever",
    "start": "2254560",
    "end": "2260480"
  },
  {
    "text": "thread's going to consume the consume the thing so and if we get those in the",
    "start": "2260480",
    "end": "2266000"
  },
  {
    "text": "wrong order then know we we don't even get",
    "start": "2266000",
    "end": "2271680"
  },
  {
    "text": "obstruction free or we just end up with data races so what we need to do is is we",
    "start": "2271680",
    "end": "2276880"
  },
  {
    "text": "need to publish the availability of the data",
    "start": "2276880",
    "end": "2282839"
  },
  {
    "text": "um at the end of step three rather than acquiring our cell at step one and now",
    "start": "2282839",
    "end": "2288319"
  },
  {
    "text": "that cell is now blocked from the rest of all the other threads in the system we need to now if we do that at step three at",
    "start": "2288319",
    "end": "2296400"
  },
  {
    "text": "the end then thing no then we can deal with that so is there a way that we can",
    "start": "2296400",
    "end": "2301720"
  },
  {
    "text": "manage that and to do that we need to sort of separate the buff ordering from the que",
    "start": "2301720",
    "end": "2307560"
  },
  {
    "text": "ordering so we need to redo the the steps and so you might think okay can we",
    "start": "2307560",
    "end": "2312880"
  },
  {
    "text": "hunt the buffer for a free slot and then construct the push value into the slot and then link that entry into the que is",
    "start": "2312880",
    "end": "2319839"
  },
  {
    "text": "there a way of doing that you might think and fundamentally the answer is well you're going to have to end up",
    "start": "2319839",
    "end": "2326280"
  },
  {
    "text": "using some form of Link list it makes it the if you stick with an array and you",
    "start": "2326280",
    "end": "2332520"
  },
  {
    "text": "hunt through for free slots then you end up with ever such a lot of complexity and then you still now got okay well",
    "start": "2332520",
    "end": "2338480"
  },
  {
    "text": "that was the slot that I added but which order was it in the que and now I need to put it on a q to show which order my",
    "start": "2338480",
    "end": "2345200"
  },
  {
    "text": "buffers were in no so let's just use a link list so link list are easy no you just",
    "start": "2345200",
    "end": "2354000"
  },
  {
    "text": "stick a list on the tail and pop them off the head but we still got two occations to update the next point no so",
    "start": "2354000",
    "end": "2361319"
  },
  {
    "text": "we've got link list which has a node with a pointer to the next node",
    "start": "2361319",
    "end": "2367280"
  },
  {
    "text": "um so we've got the title pointer that says this is the last node in the list we",
    "start": "2367280",
    "end": "2372760"
  },
  {
    "text": "want to add a new nde we need to change the tail pointer to point to our new node and we need to change the next pointer from the existing one to point",
    "start": "2372760",
    "end": "2379920"
  },
  {
    "text": "to our new node there's two things to update and whichever order you try and do them then you can end up with a Race",
    "start": "2379920",
    "end": "2388440"
  },
  {
    "text": "So it's still not",
    "start": "2388440",
    "end": "2391280"
  },
  {
    "text": "straightforward so one possible option is actually to say I'm not going",
    "start": "2395400",
    "end": "2402599"
  },
  {
    "text": "to update the next pointers I'm going to update the next pointers from the one and only pop thread and instead I'm",
    "start": "2402599",
    "end": "2410839"
  },
  {
    "text": "going to make it a doubly link list with a previous pointer because that we can not safely do so we have our new node",
    "start": "2410839",
    "end": "2418800"
  },
  {
    "text": "and we say well the previous node was the one that's currently",
    "start": "2418800",
    "end": "2424000"
  },
  {
    "text": "last and if we then SU sucessfully change tail to point to our new node then we know that that was the case",
    "start": "2424000",
    "end": "2432720"
  },
  {
    "text": "because we're changing tail from what we think was the previous node toour node and if it doesn't if the compare",
    "start": "2432720",
    "end": "2438319"
  },
  {
    "text": "exchange fails then we can re we've got the the new tale that we can try",
    "start": "2438319",
    "end": "2445000"
  },
  {
    "text": "again so we allocate our entry by some",
    "start": "2445000",
    "end": "2450160"
  },
  {
    "text": "means we know create put our objects in our storage",
    "start": "2450160",
    "end": "2457079"
  },
  {
    "text": "we clear out the next pointer because we don't know what it's going to be we say the previous one is the current tail and",
    "start": "2457079",
    "end": "2463520"
  },
  {
    "text": "we repeatedly try and and update the tail to point to our new node now if",
    "start": "2463520",
    "end": "2468960"
  },
  {
    "text": "this fails then it will the compare exchange actually reloads the first value so we don't need to repeatedly",
    "start": "2468960",
    "end": "2474040"
  },
  {
    "text": "call tail. load okay so then when we're",
    "start": "2474040",
    "end": "2482880"
  },
  {
    "text": "popping then if we find that there isn't a value at ahead of the ahead of the list then that's because the um then",
    "start": "2482880",
    "end": "2492040"
  },
  {
    "text": "that might be because well we haven't set up all the next pointers yet so let's go and Chase start at the tail and",
    "start": "2492040",
    "end": "2498560"
  },
  {
    "text": "Chase down filling in the next pointers we've only got one consumer thread so we don't have to worry about races on",
    "start": "2498560",
    "end": "2506119"
  },
  {
    "text": "that so we'll look at how you do that in a second but once we once we have got the now chased chased through the the",
    "start": "2507319",
    "end": "2514079"
  },
  {
    "text": "tail then we can then load the next pointer get the value destroy the old",
    "start": "2514079",
    "end": "2520720"
  },
  {
    "text": "and then recycle that node back onto no ready ready for know ready for reallocating for the",
    "start": "2520720",
    "end": "2527560"
  },
  {
    "text": "next push okay so chasing the tail is quite",
    "start": "2527560",
    "end": "2533680"
  },
  {
    "text": "straightforward so we we take the current tail and we're going to exchange it we're going to swap it swap it for null there's no end of the list because",
    "start": "2533680",
    "end": "2540119"
  },
  {
    "text": "we we've just taken it on we've taken ownership of that and then if there",
    "start": "2540119",
    "end": "2545200"
  },
  {
    "text": "really wasn't anything we return a null and and make sure we deal with that in",
    "start": "2545200",
    "end": "2550319"
  },
  {
    "text": "the uh in the pop code but then then we can just go through from our tail",
    "start": "2550319",
    "end": "2556480"
  },
  {
    "text": "and allocate point now we've got a node which is pointing back to a previous node and then we just say well take the",
    "start": "2556480",
    "end": "2565160"
  },
  {
    "text": "the next point of this one and make it point that way and now we've relink them back in the correct order and so then",
    "start": "2565160",
    "end": "2571800"
  },
  {
    "text": "the pop can now proceed with just a singly link list that way",
    "start": "2571800",
    "end": "2578160"
  },
  {
    "text": "so this queue is obstruction free because there's no one one thread that",
    "start": "2583200",
    "end": "2588760"
  },
  {
    "text": "can be that will hold up all the others know if the if any of the push",
    "start": "2588760",
    "end": "2595200"
  },
  {
    "text": "pushing threads gets gets interrupted then it's not going to cause a global",
    "start": "2595200",
    "end": "2601599"
  },
  {
    "text": "stop um and if if the one popping thread gets interrupted it's not going to",
    "start": "2601599",
    "end": "2607040"
  },
  {
    "text": "prevent any of the pushing threads operating so it's it's definitely obstruction free but is it lock",
    "start": "2607040",
    "end": "2614800"
  },
  {
    "text": "free now if it's full then we're going to have to wait so now you you're going to know so one",
    "start": "2618440",
    "end": "2626319"
  },
  {
    "text": "thing is that then you you might want to use a lock free allocator instead of fixed buffer and if we've got a fixed",
    "start": "2626319",
    "end": "2632680"
  },
  {
    "text": "buffer size then we've got issues on fullness um and likewise you've got issues on emptiness but generally if",
    "start": "2632680",
    "end": "2638079"
  },
  {
    "text": "you're thinking about Lock Free versus weight free then you can disregard those if you got just got a test no so if it's",
    "start": "2638079",
    "end": "2644480"
  },
  {
    "text": "full then I throw I have returned in a bounded number of steps um the the",
    "start": "2644480",
    "end": "2649640"
  },
  {
    "text": "higher level up I might have to put some higher level waiting in but that's not know so but but we do have waiting and",
    "start": "2649640",
    "end": "2657359"
  },
  {
    "text": "compare exchange loops and there's no upper limit so it cannot be weight",
    "start": "2657359",
    "end": "2662960"
  },
  {
    "text": "free and then just so but um then but we also are using compare",
    "start": "2663720",
    "end": "2671800"
  },
  {
    "text": "exchange week well what if you're using any compare exchange then if you are on an implementation which doesn't do it as",
    "start": "2671800",
    "end": "2679000"
  },
  {
    "text": "a single instruction then that compare exchange might be an",
    "start": "2679000",
    "end": "2684760"
  },
  {
    "text": "unbounded series of steps in itself and so then actually it's not technically",
    "start": "2684760",
    "end": "2692000"
  },
  {
    "text": "Lock Free if that's the case and we can only be obstruction free cuz no there's not a there's not never an upper limit",
    "start": "2692000",
    "end": "2698680"
  },
  {
    "text": "on how many threads um can make progress and so the whether things can ever be",
    "start": "2698680",
    "end": "2705160"
  },
  {
    "text": "Lock Free really does depend on our implementation of compare exchange week",
    "start": "2705160",
    "end": "2710520"
  },
  {
    "text": "but as an algorithm then it's a lock free algorithm assuming that the steps are",
    "start": "2710520",
    "end": "2718319"
  },
  {
    "text": "individually yes okay so one thing to think about then is how",
    "start": "2719079",
    "end": "2724280"
  },
  {
    "text": "does it perform no and know one of the big issues with um",
    "start": "2724280",
    "end": "2731839"
  },
  {
    "text": "lock free stuff is Cash ping pong where you've got one processor is accessing a",
    "start": "2731839",
    "end": "2739680"
  },
  {
    "text": "shared value over know some on some cach line and then the other processor wants",
    "start": "2739680",
    "end": "2746599"
  },
  {
    "text": "to modify either the same atomic variable or one right next to it that's on the same cach line so it needs to",
    "start": "2746599",
    "end": "2752400"
  },
  {
    "text": "grab ownership of the cach line over to the other processor and then the first one tries to do it",
    "start": "2752400",
    "end": "2758440"
  },
  {
    "text": "back again and so it has to take The Cash Line ownership back over here if",
    "start": "2758440",
    "end": "2763480"
  },
  {
    "text": "you've got different processes in the same system with different cach or even if they're on the same core but they've got a different level two cache or no",
    "start": "2763480",
    "end": "2770920"
  },
  {
    "text": "then you can find that that can be a real issue and the cash The Cash Line is",
    "start": "2770920",
    "end": "2777599"
  },
  {
    "text": "continuously shuttled back and forth between your two",
    "start": "2777599",
    "end": "2782558"
  },
  {
    "text": "processes and you've got know cash ping pong it's called and the the uh this can",
    "start": "2782720",
    "end": "2789240"
  },
  {
    "text": "have a big effect on your performance now this can happen if you've got the same atomic variable that",
    "start": "2789240",
    "end": "2795160"
  },
  {
    "text": "you're doing but or alternatively others on the same cach line and that that can be a big issue because cach lines might",
    "start": "2795160",
    "end": "2801520"
  },
  {
    "text": "be 64 128 bytes so if you've know got a load of atomic inss right next to each",
    "start": "2801520",
    "end": "2807119"
  },
  {
    "text": "other then actually they're all on the same cach line and you might end up",
    "start": "2807119",
    "end": "2812599"
  },
  {
    "text": "having know having performance issues with that",
    "start": "2812599",
    "end": "2817800"
  },
  {
    "text": "okay so this queue that we were looking at has got many threads that can the call",
    "start": "2822720",
    "end": "2829079"
  },
  {
    "text": "push back and one more that can that can be called in pop front",
    "start": "2829079",
    "end": "2834680"
  },
  {
    "text": "so if we look at what the data that we've got we've got a now a push",
    "start": "2834680",
    "end": "2841520"
  },
  {
    "text": "position we've got our head pointer we've got our atomic",
    "start": "2841520",
    "end": "2846599"
  },
  {
    "text": "list of um now the tail which is our head of our link the tail of our link list and then we've got all know our our",
    "start": "2846599",
    "end": "2853760"
  },
  {
    "text": "buffer that we were we were using now the head and tail are right",
    "start": "2853760",
    "end": "2859880"
  },
  {
    "text": "right next to each other here so they're probably on the same on the same cach line but they're accessed by different",
    "start": "2859880",
    "end": "2865559"
  },
  {
    "text": "threads so know even though accesses to head and",
    "start": "2865559",
    "end": "2870800"
  },
  {
    "text": "tail are not going to race in any way because they're accessed by separate threads it's going to shuttle the The",
    "start": "2870800",
    "end": "2877240"
  },
  {
    "text": "Cash Line back and forth know the the pushing threads are going to be updating tail and the popping threads are going",
    "start": "2877240",
    "end": "2883160"
  },
  {
    "text": "to be updating head but know the The Cash Line shuttling back and forth and there's quite a few know potential ways",
    "start": "2883160",
    "end": "2891520"
  },
  {
    "text": "places in this data structure that that could be you know like if your if your entries are small enough then each of the individual entries might um end up",
    "start": "2891520",
    "end": "2898200"
  },
  {
    "text": "being on the same cach line and then the entry accesses um can be uh can also",
    "start": "2898200",
    "end": "2904319"
  },
  {
    "text": "cause cash ping pong and so forth and the way that we deal with cash ping",
    "start": "2904319",
    "end": "2910680"
  },
  {
    "text": "pong if we if we don't want to change our structure is just to stick some padding in great big wodies of padding",
    "start": "2910680",
    "end": "2917319"
  },
  {
    "text": "know Char arrays with that we're not going to do anything with but that pad",
    "start": "2917319",
    "end": "2922599"
  },
  {
    "text": "out your data structure so now there is a whole cach line between each of the",
    "start": "2922599",
    "end": "2928680"
  },
  {
    "text": "values and you're not going to get cash ping pong due to accesses to separate",
    "start": "2928680",
    "end": "2933760"
  },
  {
    "text": "values obviously no the threads pushing values on are all going to access tail so that's going to have to be have to be",
    "start": "2933760",
    "end": "2939920"
  },
  {
    "text": "shuttled back and forth for that but there's no that's a core part of the algorithm whereas the the ping pong due",
    "start": "2939920",
    "end": "2947359"
  },
  {
    "text": "to the popping from the head then we can avoid that by sticking the padding in but and this trades memory space for",
    "start": "2947359",
    "end": "2955359"
  },
  {
    "text": "performance yesr",
    "start": "2955359",
    "end": "2961520"
  },
  {
    "text": "figure not currently but there are proposals for it I think the um the there's going to be two values",
    "start": "2961520",
    "end": "2969640"
  },
  {
    "text": "which is if I remember rightly is",
    "start": "2969640",
    "end": "2975160"
  },
  {
    "text": "um yeah constructive yes so there's con",
    "start": "2975520",
    "end": "2981160"
  },
  {
    "text": "there's two values for constructive interference and destructive so it's like the minimum value spacing that you have to put things to guarantee they",
    "start": "2981160",
    "end": "2987440"
  },
  {
    "text": "won't touch and the maximum value that size that you can put together that guaranteed will be on the same Cash Line",
    "start": "2987440",
    "end": "2994319"
  },
  {
    "text": "CU sometimes that's important that you want things on the same cach line so there's two values for the two things",
    "start": "2994319",
    "end": "3001880"
  },
  {
    "text": "Hubert yeah so if you want if you want cach line boundaries things I me the",
    "start": "3014760",
    "end": "3019920"
  },
  {
    "text": "alignments of the individual values will be nicely aligned so the the accesses work so it doesn't matter what the",
    "start": "3019920",
    "end": "3025760"
  },
  {
    "text": "padding size is for that but if you want um if you've got thing things like this",
    "start": "3025760",
    "end": "3031400"
  },
  {
    "text": "next to some other value in memory then you want to make sure that the it starts on its own cach line and doesn't share",
    "start": "3031400",
    "end": "3037680"
  },
  {
    "text": "with something that's previous in memory so you might want to take the whole structure and make sure that it's",
    "start": "3037680",
    "end": "3043119"
  },
  {
    "text": "aligned to a cach line size um but yeah so if if you don't have the nice new constants then picking a value like 128",
    "start": "3043119",
    "end": "3050319"
  },
  {
    "text": "for your padding size is pretty likely to be um good enough for most systems if you know know where you're targeting",
    "start": "3050319",
    "end": "3056760"
  },
  {
    "text": "then you could look it up um but cach line sizes do vary because the",
    "start": "3056760",
    "end": "3062839"
  },
  {
    "text": "processors and the memory architectures know change all the time and they say oh well actually no sometimes 64 bytes",
    "start": "3062839",
    "end": "3068960"
  },
  {
    "text": "works really well no 256 that's what we need and depending on the details of the processor then it might vary so know you",
    "start": "3068960",
    "end": "3077400"
  },
  {
    "text": "if you know what you're targeting you can look it up if you've got a compiler that provides a new constants you can use that um otherwise take a punt on 64",
    "start": "3077400",
    "end": "3086079"
  },
  {
    "text": "128 or something like that so okay so if we stick those in does it",
    "start": "3086079",
    "end": "3092799"
  },
  {
    "text": "make a difference yes we Ed I I I ran no 10,000 times uh",
    "start": "3092799",
    "end": "3102760"
  },
  {
    "text": "10 million times pushing values on three threads and popping value on a fourth",
    "start": "3102760",
    "end": "3107799"
  },
  {
    "text": "thread because I got four core um system I was testing it on we timed it against",
    "start": "3107799",
    "end": "3112839"
  },
  {
    "text": "the lock variant that we had right at the beginning so with no padding no we",
    "start": "3112839",
    "end": "3118680"
  },
  {
    "text": "had sort of comparable times to the lock based one but if you stuck the padding in then",
    "start": "3118680",
    "end": "3126440"
  },
  {
    "text": "it was really know quite a significant difference so that cash ping pong is a real effect it's not just marginal know",
    "start": "3126440",
    "end": "3133839"
  },
  {
    "text": "that that's half the time",
    "start": "3133839",
    "end": "3140160"
  },
  {
    "text": "so okay so far we've all been using",
    "start": "3140160",
    "end": "3145880"
  },
  {
    "text": "memory order sequentially consistent and I'm just going to say you really really ought to unless you have a strong reason",
    "start": "3145880",
    "end": "3151400"
  },
  {
    "text": "not to um it's possible to Edge out some Corner cases of performance by relaxing",
    "start": "3151400",
    "end": "3158319"
  },
  {
    "text": "your constraints but no a don't B if you really really",
    "start": "3158319",
    "end": "3164680"
  },
  {
    "text": "want to profile and profile some more and review your code know for like 3",
    "start": "3164680",
    "end": "3171200"
  },
  {
    "text": "weeks solid even if you've only made one change to know con convince yourself that it's correct and then profile some",
    "start": "3171200",
    "end": "3177000"
  },
  {
    "text": "more and get somebody else to RW it if you're going to relax constraints you need to be sure um and also test on a",
    "start": "3177000",
    "end": "3183680"
  },
  {
    "text": "weekly ordered architecture if you're testing it on x86 the memory order underneath is really strong test it on",
    "start": "3183680",
    "end": "3189720"
  },
  {
    "text": "arm or power or if you've got access to an alpha then use that but um the if you're relaxing memory",
    "start": "3189720",
    "end": "3196680"
  },
  {
    "text": "ordering then it's very easy for things to work in test and then fail in",
    "start": "3196680",
    "end": "3203240"
  },
  {
    "text": "production so yeah so and on x86 only the store really is affected um but",
    "start": "3204160",
    "end": "3210599"
  },
  {
    "text": "power and arm then actually can affect all the operations so yeah make sure you test on",
    "start": "3210599",
    "end": "3216400"
  },
  {
    "text": "on a weekly ordered system if you're going to try and relax the ordering",
    "start": "3216400",
    "end": "3221359"
  },
  {
    "text": "constraints okay quick dive through Stacks only got a few minutes left so",
    "start": "3221880",
    "end": "3227880"
  },
  {
    "text": "it's going to be Speedy a stack is a simpler data structure than a que it's great for",
    "start": "3227880",
    "end": "3234200"
  },
  {
    "text": "examples but mostly you're going to reuse it um in multi-threaded code because if you got multiple threads",
    "start": "3234200",
    "end": "3240960"
  },
  {
    "text": "accessing everyone's piling on the head there's only the one point of access uh accessing the top of Stack but we going",
    "start": "3240960",
    "end": "3248280"
  },
  {
    "text": "to use it for a specific demonstration of a specific problem the ab",
    "start": "3248280",
    "end": "3253599"
  },
  {
    "text": "problem so assume we put we've got a stack which has got nodes with next",
    "start": "3254640",
    "end": "3261359"
  },
  {
    "text": "pointers we've got Atomic value to hold the head head of our head of our",
    "start": "3261359",
    "end": "3266760"
  },
  {
    "text": "stack stick create a new node compare exchange to stick it on we can just Loop",
    "start": "3266760",
    "end": "3271839"
  },
  {
    "text": "Round it's it's nice if we've only got one consumer popping it's all nice we",
    "start": "3271839",
    "end": "3277920"
  },
  {
    "text": "can just take the head and do a compare exchange if it works then we take the",
    "start": "3277920",
    "end": "3283880"
  },
  {
    "text": "value and delete the old head there's only know the new values are pushed on there's only one thread popping it off",
    "start": "3283880",
    "end": "3289280"
  },
  {
    "text": "there's no partic um the pushers are not accessing the contents of the nodes so",
    "start": "3289280",
    "end": "3296480"
  },
  {
    "text": "we can safely delete them and",
    "start": "3296480",
    "end": "3302119"
  },
  {
    "text": "but it's a single consumer for a reason and the answer is this ABA problem the ABA is you've got a value in",
    "start": "3302119",
    "end": "3310680"
  },
  {
    "text": "your data structure that holds value a you read it it's say it's a some other",
    "start": "3310680",
    "end": "3316119"
  },
  {
    "text": "thread then does your thread get suspended and other threads do stuff it gets changed to some other value B and",
    "start": "3316119",
    "end": "3323039"
  },
  {
    "text": "then changed back to a again but now that has a different meaning from your data structure and so when you look at",
    "start": "3323039",
    "end": "3329559"
  },
  {
    "text": "it it's a still but it now has a different meaning and when you then make your make your operations based on that",
    "start": "3329559",
    "end": "3336720"
  },
  {
    "text": "you do something wrong so in this particular case if we then said multiple",
    "start": "3336720",
    "end": "3342200"
  },
  {
    "text": "threads can pop what's going to happen Okay thread one calls pop it",
    "start": "3342200",
    "end": "3348520"
  },
  {
    "text": "reads the old head and gets a value a it reads the next pointer from its old head",
    "start": "3348520",
    "end": "3354200"
  },
  {
    "text": "and is then suspended thread two pops two items head now has a new value which",
    "start": "3354200",
    "end": "3361480"
  },
  {
    "text": "you're going to call B and then we push two two items but",
    "start": "3361480",
    "end": "3368119"
  },
  {
    "text": "because we just freed some values then the allocator says well I'm going to give",
    "start": "3368119",
    "end": "3373599"
  },
  {
    "text": "you the same object that you just freed because often it does that if you call new and then call delete and then call",
    "start": "3373599",
    "end": "3378799"
  },
  {
    "text": "New Again with an object of the same size you might well get exactly the same point of value and so so know we've got when we",
    "start": "3378799",
    "end": "3387599"
  },
  {
    "text": "stick the items on the Queue the new one that we just allocated has the same address as the old one we",
    "start": "3387599",
    "end": "3393520"
  },
  {
    "text": "just freed but it's a new node so head head now has the original value of",
    "start": "3393520",
    "end": "3400319"
  },
  {
    "text": "a but it's a new Noe a and not the",
    "start": "3400319",
    "end": "3407039"
  },
  {
    "text": "original so when our first thread resumes its compare exchange will succeed because it's got the same value",
    "start": "3407119",
    "end": "3415559"
  },
  {
    "text": "that it thought that it's expecting but it's now referring to a new node so the next pointer that it",
    "start": "3415559",
    "end": "3422599"
  },
  {
    "text": "loaded up here is now pointing off into a deleted node and your you know your",
    "start": "3422599",
    "end": "3431079"
  },
  {
    "text": "your know we when we change the data structure to point to our deleted node here which is just broken data structure",
    "start": "3431079",
    "end": "3438839"
  },
  {
    "text": "now so rather than having the cor correct um setting that we wanted we've",
    "start": "3438839",
    "end": "3445359"
  },
  {
    "text": "just messed everything up and that's the general set toop we",
    "start": "3445359",
    "end": "3451720"
  },
  {
    "text": "have no value changes from A to B and back to a but the global State means that that a now is based on a a",
    "start": "3451720",
    "end": "3459280"
  },
  {
    "text": "wrong-headed um a wrong view of the of the global data structure and and so everything",
    "start": "3459280",
    "end": "3465559"
  },
  {
    "text": "goes wrong quick solution is to use a struct um so we stick in a count value you",
    "start": "3465559",
    "end": "3471880"
  },
  {
    "text": "increment your count every time and then you've got a um know you know that it might have the",
    "start": "3471880",
    "end": "3478799"
  },
  {
    "text": "same pointer value but it's got a different count value so that's okay we can spot that the difference is there",
    "start": "3478799",
    "end": "3484799"
  },
  {
    "text": "alternatively you can use ensure that things are not recycled whil they're still accessible if you've got an atomic",
    "start": "3484799",
    "end": "3491599"
  },
  {
    "text": "shed pointer implementation that you can use then use that um if you've got if you can use Hazard pointers do that uh",
    "start": "3491599",
    "end": "3499039"
  },
  {
    "text": "it's possible to do know other things but it can be quite tricky um the",
    "start": "3499039",
    "end": "3505359"
  },
  {
    "text": "things like this I me it can still be locked free so on now like I said at the",
    "start": "3505359",
    "end": "3510680"
  },
  {
    "text": "beginning on 64-bit x86 platforms this is a 16 by structure um it may or may",
    "start": "3510680",
    "end": "3516400"
  },
  {
    "text": "not be locked free depending on precisely whether your um Library supports it and whether or not the",
    "start": "3516400",
    "end": "3522319"
  },
  {
    "text": "processor that you've got supports it on on different different platforms then whether or not that lock free will",
    "start": "3522319",
    "end": "3529480"
  },
  {
    "text": "vary okay so what guidelines can we pull from all this",
    "start": "3529480",
    "end": "3535480"
  },
  {
    "text": "first one I'd say is don't use atomics unless you have to profile your code um before and after make sure that",
    "start": "3535480",
    "end": "3542920"
  },
  {
    "text": "this really is a beneficial change that you're making now firstly well a is it the bottleneck of your code that you're",
    "start": "3542920",
    "end": "3549359"
  },
  {
    "text": "actually wanting to update if this data if the data structure you're trying to update isn't actually the bottleneck",
    "start": "3549359",
    "end": "3555240"
  },
  {
    "text": "don't do that do something else um but if it is then profile it before profile",
    "start": "3555240",
    "end": "3560599"
  },
  {
    "text": "it afterwards make sure you've actually improved things make sure you test on a weekly",
    "start": "3560599",
    "end": "3566200"
  },
  {
    "text": "ordered architecture such as power and arm um and again don't use atomics if",
    "start": "3566200",
    "end": "3571240"
  },
  {
    "text": "you have to and as a final one which isn't on the slide just a reminder then things like the P if you if you pad",
    "start": "3571240",
    "end": "3577280"
  },
  {
    "text": "things out where there's contention then that can actually have a dramatic performance",
    "start": "3577280",
    "end": "3583038"
  },
  {
    "text": "Improvement so more General guidelines um if you think in Con in",
    "start": "3583480",
    "end": "3589440"
  },
  {
    "text": "transactions then you could know then that can improve things if you do your work off to the side and commit with one",
    "start": "3589440",
    "end": "3596280"
  },
  {
    "text": "Atomic operation there's now only the one operation to think about so uh no",
    "start": "3596280",
    "end": "3602480"
  },
  {
    "text": "that can have a big benefit in terms of making sure that things working",
    "start": "3602480",
    "end": "3607318"
  },
  {
    "text": "correctly if you if your operation is Big then if you can split it into",
    "start": "3608079",
    "end": "3614559"
  },
  {
    "text": "smaller steps which can in themselves be done as an atomic operation know possibly off to the side",
    "start": "3614559",
    "end": "3620720"
  },
  {
    "text": "and then committed then that can make things work uh it can help you rain if if you can manage to retain the data",
    "start": "3620720",
    "end": "3626480"
  },
  {
    "text": "structure in variance between each step then that can be good um there's so there's various things you can do with know insert",
    "start": "3626480",
    "end": "3632680"
  },
  {
    "text": "inserting marker marker values that says I'm not a real value yet but I'm going to be here as a placeholder so if you're",
    "start": "3632680",
    "end": "3640160"
  },
  {
    "text": "if if you're a reader thread just skip over me for now um and then then when",
    "start": "3640160",
    "end": "3645200"
  },
  {
    "text": "the value really is is then set as a separate operation um then obviously we saw limit your use",
    "start": "3645200",
    "end": "3652720"
  },
  {
    "text": "cases if it only works with the a single consumer thread say it only works with a single consumer thread and just declare",
    "start": "3652720",
    "end": "3658760"
  },
  {
    "text": "that as part of your documentation and then if people try and use multiple consumers that's they're tough um and",
    "start": "3658760",
    "end": "3664480"
  },
  {
    "text": "but then if if that's something you need is the multiple consumers then you can't limit that and you've got to think know",
    "start": "3664480",
    "end": "3670039"
  },
  {
    "text": "a new approach um oh and watch out for the ABA",
    "start": "3670039",
    "end": "3675480"
  },
  {
    "text": "problems I mean the chances are that it won't happen in testing as ever because",
    "start": "3675480",
    "end": "3680880"
  },
  {
    "text": "the things have to align just right for you to actually get the same value back again but if you're if this is a heavily",
    "start": "3680880",
    "end": "3687480"
  },
  {
    "text": "used thing then it will happen at some point and undoubtedly with any of these things it will happen at the worst",
    "start": "3687480",
    "end": "3693480"
  },
  {
    "text": "possible point you know you're trying to demonstrate demonstrate to a crucial customer and it will all go",
    "start": "3693480",
    "end": "3700079"
  },
  {
    "text": "wrong avoid your cash ping pong with um padding use sequentially consistent",
    "start": "3702039",
    "end": "3708119"
  },
  {
    "text": "memory ordering unless you really really really have a know a strong idea of what",
    "start": "3708119",
    "end": "3713880"
  },
  {
    "text": "it is you're trying to to achieve um and you really want the performance gain and then package up your whole Lock",
    "start": "3713880",
    "end": "3721839"
  },
  {
    "text": "Free structure and then know use it from the outside through an API so it's just a queue as far as anybody else is",
    "start": "3721839",
    "end": "3728119"
  },
  {
    "text": "concerned and then you can fiddle with the implementation make the implementation um thoroughly tested and",
    "start": "3728119",
    "end": "3734799"
  },
  {
    "text": "thoroughly reviewed and then switch and and but from the outside world you just use it as a Quee and it might as well be",
    "start": "3734799",
    "end": "3741279"
  },
  {
    "text": "a lock based one aim for lock free code rather than",
    "start": "3741279",
    "end": "3747720"
  },
  {
    "text": "obstruction free if you need it then wait you go for wait free code but it's really really complex um because trying",
    "start": "3747720",
    "end": "3755079"
  },
  {
    "text": "to avoid any unbounded Loops is actually really hard and don't use busy weights unless",
    "start": "3755079",
    "end": "3761480"
  },
  {
    "text": "you have to so I've got questions we're we're over time as it is but if anybody does",
    "start": "3761480",
    "end": "3767079"
  },
  {
    "text": "have any questions then feel free to talk to me",
    "start": "3767079",
    "end": "3772960"
  },
  {
    "text": "so startop that [Applause]",
    "start": "3772960",
    "end": "3782960"
  },
  {
    "text": "other",
    "start": "3791799",
    "end": "3794279"
  }
]