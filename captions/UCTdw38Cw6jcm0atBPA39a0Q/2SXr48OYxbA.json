[
  {
    "text": "hello yes we're working good afternoon uh big thank you to everyone that's come",
    "start": "4560",
    "end": "9960"
  },
  {
    "text": "along great to see uh so many people here to learn about turbocharging our net code uh with some high performance",
    "start": "9960",
    "end": "16880"
  },
  {
    "text": "apis that have been available for a while now actually um but hopefully might be new to some of you in the room",
    "start": "16880",
    "end": "22000"
  },
  {
    "text": "my name is Steve I'm a Microsoft MVP blite offer and engineer at elastic uh",
    "start": "22000",
    "end": "27640"
  },
  {
    "text": "you can find me at stevej Gordon on most of the social media platforms and I blog at stevej gordon. co.uk um and I will",
    "start": "27640",
    "end": "35239"
  },
  {
    "text": "just highlight this resources link I've got at the bottom there that will take you to a copy of the slides and also uh",
    "start": "35239",
    "end": "41280"
  },
  {
    "text": "the GitHub repo where the code I'm going to show you is contained so grab that link now if you can I'll leave it up for",
    "start": "41280",
    "end": "47280"
  },
  {
    "text": "a second um I'll also show it again at the end for anyone that misses it I'll talk about the next slide while",
    "start": "47280",
    "end": "53680"
  },
  {
    "text": "you're taking photos so I'm going to just briefly set the agenda and set the scene uh for what we're going to cover",
    "start": "53680",
    "end": "59440"
  },
  {
    "text": "today so the main things I'm going to talk about are um a little bit about what is performance because I want to",
    "start": "59440",
    "end": "65720"
  },
  {
    "text": "make sure that we're all talking about the same thing and thinking about the same things as we go through this session then we'll talk a little bit",
    "start": "65720",
    "end": "71840"
  },
  {
    "text": "about measuring performance in application code and why that's important then we'll start looking at",
    "start": "71840",
    "end": "77040"
  },
  {
    "text": "some of the the high performance apis that you can use for both uh efficient and low allocation code in.net so things",
    "start": "77040",
    "end": "83720"
  },
  {
    "text": "like span of te um array PS uh a little bit about system IO pipelines and and at",
    "start": "83720",
    "end": "90320"
  },
  {
    "text": "the end hopefully if I can get through it quick enough uh we'll talk about system text Json briefly as",
    "start": "90320",
    "end": "95439"
  },
  {
    "text": "well so the first thing is what are we talking about when we're talking about performance in application code the",
    "start": "95439",
    "end": "102040"
  },
  {
    "text": "first thing I think of and that most people tend to think of is just how quickly the code executes how long it",
    "start": "102040",
    "end": "107320"
  },
  {
    "text": "takes for maybe the method or the entire process uh that you're you're doing in",
    "start": "107320",
    "end": "112560"
  },
  {
    "text": "that code base uh maybe processing a message from a queue what is the execution time of that code and it might be measured in a few seconds it might be",
    "start": "112560",
    "end": "119360"
  },
  {
    "text": "millisecond it could even be as low as nanc when we start talking about specific portions of code typically if",
    "start": "119360",
    "end": "125799"
  },
  {
    "text": "we can make the code run faster then it's going to have a better experience for our user base um and it might mean that we can get more work done on that",
    "start": "125799",
    "end": "132520"
  },
  {
    "text": "machine and that's where throughput as another measure comes in because this is more about how much uh an actual",
    "start": "132520",
    "end": "138879"
  },
  {
    "text": "application can do of a given task in a given time frame so we might be talking about things like request per second in",
    "start": "138879",
    "end": "144720"
  },
  {
    "text": "an asbet core application or maybe how many messages we can process of a service bus in a given fr of time with a",
    "start": "144720",
    "end": "150519"
  },
  {
    "text": "given application and this can be tied to execution time if we can reduce the execution time of our code sometimes we",
    "start": "150519",
    "end": "156760"
  },
  {
    "text": "can increase our throughput not always um but they can be linked in that way um and throughput is just um a sort of good",
    "start": "156760",
    "end": "163239"
  },
  {
    "text": "measure that you can also track in production as well and then the final aspect that not",
    "start": "163239",
    "end": "168760"
  },
  {
    "text": "everyone thinks about when you start thinking about performan is around memory allocations um memory allocations",
    "start": "168760",
    "end": "174120"
  },
  {
    "text": "in net are very cheap uh we have the Heap pre-allocated block of memory that is being managed for us by the Run time",
    "start": "174120",
    "end": "180720"
  },
  {
    "text": "and it's basically just bumping a pointer when we allocate new objects on there so that's very fast very efficient",
    "start": "180720",
    "end": "186120"
  },
  {
    "text": "but at some point in time those objects are no longer used uh a GC a garbage collection process needs to run to",
    "start": "186120",
    "end": "191440"
  },
  {
    "text": "reclaim that memory and although that's a highly efficient process it's highly optimized there's a lot of horis STS",
    "start": "191440",
    "end": "197080"
  },
  {
    "text": "that go into how that runs to try and avoid pausing our application for any undue amounts of time it's not entirely",
    "start": "197080",
    "end": "202680"
  },
  {
    "text": "free and so one of the things we can see in applications that allocate a lot particularly larger objects um is we can",
    "start": "202680",
    "end": "209239"
  },
  {
    "text": "see that those GC pause time start to impact uh the performance of high frer",
    "start": "209239",
    "end": "214760"
  },
  {
    "text": "applications it's important also to point that uh performance is contextural right not every application has the same",
    "start": "214760",
    "end": "220920"
  },
  {
    "text": "performance requirements and characteristics a lot of what I'm going to show you today doesn't apply to most",
    "start": "220920",
    "end": "226760"
  },
  {
    "text": "applications in terms of the types of code that you might be writing um but in a few percent of your applications in",
    "start": "226760",
    "end": "233159"
  },
  {
    "text": "high frit systems in areas where you're having to do a lot of processing and you have to have a lot of scale to achieve",
    "start": "233159",
    "end": "238840"
  },
  {
    "text": "that starting to look at optimizing your code can start to bring down uh the amount you have to scale your applications and potentially the costs",
    "start": "238840",
    "end": "245560"
  },
  {
    "text": "that associated with them but it doesn't mean that you need to apply these code examples that I'm going to show you",
    "start": "245560",
    "end": "250959"
  },
  {
    "text": "today in every scenario there's also an important tradeoff to warn you about when it comes",
    "start": "250959",
    "end": "256519"
  },
  {
    "text": "to some I'm going to show you today and we'll see this when we look at some of the more advanced code samples there's a bit of a trade-off between the",
    "start": "256519",
    "end": "262360"
  },
  {
    "text": "performant code and the readability of that code um and this can affect how easy it is to maintain applications so",
    "start": "262360",
    "end": "268919"
  },
  {
    "text": "if you've got a code based that's changing often and it's being maintained by lots of different Engineers within your business it might be more important",
    "start": "268919",
    "end": "275680"
  },
  {
    "text": "that the codee's readable uh concise and clear and something that they can achange very easily without having to",
    "start": "275680",
    "end": "281560"
  },
  {
    "text": "worry about affecting the performance of the application and so it might be more important that you focus on that readability of the code versus actually",
    "start": "281560",
    "end": "288320"
  },
  {
    "text": "trying to highly optimize the code base for performance but in those scenarios where you do need the performance then",
    "start": "288320",
    "end": "294120"
  },
  {
    "text": "you need to start accepting that trade-off that the code might become more Vose slightly harder to read read and maybe your senior Engineers can sort",
    "start": "294120",
    "end": "301160"
  },
  {
    "text": "of go in there and not be scared of that code base not sure why that's done that okay",
    "start": "301160",
    "end": "307840"
  },
  {
    "text": "so I wanted to talk about the optimization cycle um this is how we go about optimizing a sort of application",
    "start": "307840",
    "end": "314080"
  },
  {
    "text": "that we already have and the important starting point for any optimization is that we measure first the reason we",
    "start": "314080",
    "end": "320000"
  },
  {
    "text": "measure first is it gives us guidance as to where we should be focusing our time and also gives us our starting",
    "start": "320000",
    "end": "325880"
  },
  {
    "text": "measurements to see if the changes we're making are having a positive impact so the high level this would be things like",
    "start": "325880",
    "end": "331440"
  },
  {
    "text": "profiling the application doing maybe CPU profiling to see where are the hot Paths of your application under given",
    "start": "331440",
    "end": "337880"
  },
  {
    "text": "workloads uh what are the methods that get called most often and of those how long are some of those taking to execute",
    "start": "337880",
    "end": "344240"
  },
  {
    "text": "and then focusing in maybe also on the memory side and profiling the memory of those methods to understand where are the allocations that occur within them",
    "start": "344240",
    "end": "351400"
  },
  {
    "text": "once you've got that you can guide where you spend your time because you want to be focusing on those hot paths uh",
    "start": "351400",
    "end": "356880"
  },
  {
    "text": "they're the ones that are going to give you the best gain if you can optimize them once you've measured and you've got that data you want to start focusing on",
    "start": "356880",
    "end": "363880"
  },
  {
    "text": "code level measurements and this is where we start using things like benchmarking to measure the portions of code that we're going to change to see",
    "start": "363880",
    "end": "370720"
  },
  {
    "text": "how those particular portions of code run and that might be individual methods or even individual lines of code that we're starting to focus in on but once",
    "start": "370720",
    "end": "377840"
  },
  {
    "text": "we've got those starting point measurements then we can actually do the optimization work what we want to focus",
    "start": "377840",
    "end": "383039"
  },
  {
    "text": "on is trying to do this in an iterative way and in small changes um if you make a whole heap of changes at once a lot of",
    "start": "383039",
    "end": "390039"
  },
  {
    "text": "high performance techniques and then you take your measurement afterwards you don't know if all of those changes had a",
    "start": "390039",
    "end": "395479"
  },
  {
    "text": "positive impact whereas if you change individual small pieces and then measure again you can revalidate your",
    "start": "395479",
    "end": "400960"
  },
  {
    "text": "assumptions as you go forward so measure do a small optimization measure again check that that has the impact you",
    "start": "400960",
    "end": "407280"
  },
  {
    "text": "expect and then move on and complete the cycle and so this can continue as many times as you need until you get to",
    "start": "407280",
    "end": "414080"
  },
  {
    "text": "either whatever goal you set yourself in terms of your optimization or maybe you think there's no further gains for a",
    "start": "414080",
    "end": "419560"
  },
  {
    "text": "particular method and you want to move on to a different area um it's quite easy to get trapped in optimization",
    "start": "419560",
    "end": "424599"
  },
  {
    "text": "looking for really small gains at the kind of tail end of the optimization and sometimes those don't give you a huge",
    "start": "424599",
    "end": "430400"
  },
  {
    "text": "amount of value so try and draw a line once you've achieved a reasonable amount of of progress and look at other areas",
    "start": "430400",
    "end": "436759"
  },
  {
    "text": "perhaps that will give you bigger wins so how do we measure application performance well there's several tools",
    "start": "436759",
    "end": "443639"
  },
  {
    "text": "that we might have daily available to us so if you're using visual studio and you turn on the diagnostic tool when you're",
    "start": "443639",
    "end": "449840"
  },
  {
    "text": "debugging you already have quite a good set of information uh you can see when uh gc's are occurring how much heat",
    "start": "449840",
    "end": "456080"
  },
  {
    "text": "memory you're consuming in an application you can take snapshots to see where that memory is being allocated",
    "start": "456080",
    "end": "461879"
  },
  {
    "text": "um the only sort of caveat with this is that you are in debug mode so you're not running the highly optimized runtime",
    "start": "461879",
    "end": "467039"
  },
  {
    "text": "code base necessarily so it's a good indicator but it's not necessarily scientifically accurate for your runtime",
    "start": "467039",
    "end": "473520"
  },
  {
    "text": "code um to do more accurate measurements on runtime code you want to use either",
    "start": "473520",
    "end": "478599"
  },
  {
    "text": "the visual studio profiling tools there's a whole sve of them now that you can use to analyze both memory CPU time",
    "start": "478599",
    "end": "484919"
  },
  {
    "text": "async time threading Etc there's also perfu which is an extremely Advanced tool um very powerful quite a steep",
    "start": "484919",
    "end": "492759"
  },
  {
    "text": "learning curve I haven't really conquered it yet in my own time I use it a little bit uh and then kind of get a",
    "start": "492759",
    "end": "498360"
  },
  {
    "text": "bit scared um and move to things that I'm more familiar with and I find that the jetbrains products. trace. memory",
    "start": "498360",
    "end": "503720"
  },
  {
    "text": "for me uh give a nice balance of exactly what I need to see a nice user interface",
    "start": "503720",
    "end": "509159"
  },
  {
    "text": "um and uh as I say you get the measurements that you need that you can work with um but pick the tooling that",
    "start": "509159",
    "end": "514399"
  },
  {
    "text": "works for you um and works for you and your team really sometimes not not often",
    "start": "514399",
    "end": "519880"
  },
  {
    "text": "but sometimes it can be useful to dig into the IL code as well so when you compile C in most cases you're compiling",
    "start": "519880",
    "end": "526279"
  },
  {
    "text": "to Intermediate Language code that then gets executed by the just in time compiler when you run your application",
    "start": "526279",
    "end": "532800"
  },
  {
    "text": "and sometimes you can view that I code to get a view of how many I instructions your code compiles down into if you can",
    "start": "532800",
    "end": "538560"
  },
  {
    "text": "reduce the instruction often you increase reduce sorry the execution time um and also you can look",
    "start": "538560",
    "end": "544480"
  },
  {
    "text": "out for things like the boxing of value types sometimes those sharp in il um tools as well so these are all free so",
    "start": "544480",
    "end": "550200"
  },
  {
    "text": "you can grab that at any time and take a look at the I code as well and the important one not to forget",
    "start": "550200",
    "end": "557320"
  },
  {
    "text": "is that it's always worth having production um metrics and monitoring in place uh for your applications",
    "start": "557320",
    "end": "563000"
  },
  {
    "text": "particularly if you're doing optimization on an existing app because sometimes some of the optimizations we do in development don't necessarily",
    "start": "563000",
    "end": "569399"
  },
  {
    "text": "translate to production and sometimes they can even regress performance in production because it's hard to match that production workload in an",
    "start": "569399",
    "end": "575880"
  },
  {
    "text": "environment where you're doing development so having these measures in place before you start things like request per second Heap usage maybe",
    "start": "575880",
    "end": "583600"
  },
  {
    "text": "you're tracking the GC metrics um means that you can actually check once you deploy your changes that you see the",
    "start": "583600",
    "end": "590040"
  },
  {
    "text": "same um sort of improvements that you were expecting and I worked for elastic we have a bunch of tools including the",
    "start": "590040",
    "end": "595560"
  },
  {
    "text": "elastic APM agent or our new uh drro for open telemetry uh that you can go and get for uh application performance",
    "start": "595560",
    "end": "601920"
  },
  {
    "text": "monitoring needs including metrics like the ones I discussed or you can use any sort of vendor product uh that gives you",
    "start": "601920",
    "end": "608360"
  },
  {
    "text": "the metrics you need to measure your applications when it comes to the specific code level measurements the",
    "start": "608360",
    "end": "614640"
  },
  {
    "text": "tool of choice today is",
    "start": "614640",
    "end": "617680"
  },
  {
    "text": "benchmark.com benchmarking this is measuring small amounts of code and tracking the changes even down to the",
    "start": "619720",
    "end": "626320"
  },
  {
    "text": "nanc measurements um it can be used for more macro level measurements but it's as I say sort of designed specifically",
    "start": "626320",
    "end": "632640"
  },
  {
    "text": "for micro benchmarking scenarios and it gives highly precise measurements so you could in theory just put a stop rch",
    "start": "632640",
    "end": "639120"
  },
  {
    "text": "around some code and measure that a few times and you would get a rough indicator of how long that code takes to execute but doing that isn't that",
    "start": "639120",
    "end": "645800"
  },
  {
    "text": "scientific whereas benchmark.us before it starts taking",
    "start": "645800",
    "end": "651200"
  },
  {
    "text": "measurements to make sure that the code is jitted to the most optimized jit version um it also makes sure it",
    "start": "651200",
    "end": "656560"
  },
  {
    "text": "measures its own overhead to remove that from the measurements it's Tak and it will run each Benchmark tens even",
    "start": "656560",
    "end": "662079"
  },
  {
    "text": "hundreds of thousands of times so that it can get a good statistical average of the data because if you're measuring down to nanc level measurements anything",
    "start": "662079",
    "end": "669519"
  },
  {
    "text": "that else that happens on your machine like a antivirus kicking in or another application starting up could affect the",
    "start": "669519",
    "end": "674720"
  },
  {
    "text": "measurements so benchmark.us out the outliers to get you um as accurate a number as it can for what you're",
    "start": "674720",
    "end": "681680"
  },
  {
    "text": "measuring um you can do uh enrichment of data through this thing called diagnosis there's a bunch of them uh in there so",
    "start": "681680",
    "end": "688040"
  },
  {
    "text": "we can get memory information during the benchmarking process we can look at the jit uh process uh we can get a",
    "start": "688040",
    "end": "694880"
  },
  {
    "text": "disassembly of the code um we can look at threading and and etw events as well so there's a bunch of things you can",
    "start": "694880",
    "end": "700600"
  },
  {
    "text": "collect during the benchmarking process if you want them um You can compare your benchmarks across different platforms",
    "start": "700600",
    "end": "707000"
  },
  {
    "text": "different architectures you can try changing GC modes and see how that affects your results and this is the",
    "start": "707000",
    "end": "712480"
  },
  {
    "text": "tool that's used extensively within Microsoft for their benchmarking of the net runtime and the asp.net so this is",
    "start": "712480",
    "end": "719680"
  },
  {
    "text": "pretty much now the defacto tool for benchmarking net code um it's maintained by a bunch of people including some",
    "start": "719680",
    "end": "725399"
  },
  {
    "text": "people that work at Microsoft so this is what a a sort of hello world Benchmark app might look",
    "start": "725399",
    "end": "731880"
  },
  {
    "text": "like so we have a a program class here with a main method and that's just invoking this static run method on The",
    "start": "731880",
    "end": "737199"
  },
  {
    "text": "Benchmark Runner and it's passing in the type that contains the benchmarks now there's several ways you can configure",
    "start": "737199",
    "end": "744399"
  },
  {
    "text": "inter active mode where when you start it you can choose which benchmarks you want to run this just sort of this hello",
    "start": "749160",
    "end": "754760"
  },
  {
    "text": "world example will just run everything within that class so our Benchmark class is defined below regular class I've",
    "start": "754760",
    "end": "761279"
  },
  {
    "text": "added this attribute to say that I want to collect memory information through the memory diagnoser uh so that we can see how much memory is allocated while",
    "start": "761279",
    "end": "768160"
  },
  {
    "text": "we're benchmarking there's a bit of setup code this isn't stuff that I want to Benchmark it's just stuff I need in",
    "start": "768160",
    "end": "774120"
  },
  {
    "text": "place to perform the Benchmark so it's done in this case as as static data so",
    "start": "774120",
    "end": "779199"
  },
  {
    "text": "create an instance of this name paer and we create an instance of a string that we're going to use um the actual",
    "start": "779199",
    "end": "784600"
  },
  {
    "text": "Benchmark itself is below and it's a regular method has the Benchmark attribute on it and then within there",
    "start": "784600",
    "end": "789839"
  },
  {
    "text": "the code there is what we're measuring that's what's we're going to get the measurement of the Benchmark for and in this case it's this call to the get last",
    "start": "789839",
    "end": "796079"
  },
  {
    "text": "name method on that uh name paer that's what we're measuring to see what its overhead is with that given input",
    "start": "796079",
    "end": "802880"
  },
  {
    "text": "string so we run this on our machine uh we need to run this in release build we traditionally ideally want to turn turn",
    "start": "802880",
    "end": "809240"
  },
  {
    "text": "off every other application so that it doesn't interfere with the results um if you can disable antivirus that's even",
    "start": "809240",
    "end": "814440"
  },
  {
    "text": "better um it will take a while to run because it will as I say do all of those warm-up phases and then many thousands",
    "start": "814440",
    "end": "820240"
  },
  {
    "text": "of runs to make sure it gets you good results but eventually it will give you this report and for our single Benchmark",
    "start": "820240",
    "end": "826480"
  },
  {
    "text": "we can see a few results here so the first is that we know that the mean execution time that it measured for that",
    "start": "826480",
    "end": "832360"
  },
  {
    "text": "method was 116 NS we don't know if that's necessarily good or bad it's pretty fast um but that's our starting",
    "start": "832360",
    "end": "839360"
  },
  {
    "text": "point knowledge about how long that method takes to execute it also includes some memory information because I added",
    "start": "839360",
    "end": "844680"
  },
  {
    "text": "the memory diagnoser so this First Column here gives us an indication of per thousand operations how many gen",
    "start": "844680",
    "end": "850399"
  },
  {
    "text": "zero collections might this introduce now this isn't 100% scientific because",
    "start": "850399",
    "end": "855600"
  },
  {
    "text": "the garbage collection process is sort of tweaking itself all the time based on knowledge of your app at runtime but",
    "start": "855600",
    "end": "861880"
  },
  {
    "text": "this is saying basically it's around 29,000 operations before we would introduce enough uh gen zero data that",
    "start": "861880",
    "end": "869880"
  },
  {
    "text": "might trigger a GC in this application the important thing here is that we can tell we're not having any long lived",
    "start": "869880",
    "end": "875040"
  },
  {
    "text": "objects because there's nothing being reported for Gen one or gen two so nothing would be promoted so every allocation for this method is probably",
    "start": "875040",
    "end": "881800"
  },
  {
    "text": "shortlived and um we can see the actual allocation amount there as 144 bytes so",
    "start": "881800",
    "end": "887399"
  },
  {
    "text": "this gives us again that indication that starting point knowledge of how many bytes that code allocates in the process",
    "start": "887399",
    "end": "892880"
  },
  {
    "text": "of executing so we'll start looking at some of the high performance code scenarios",
    "start": "892880",
    "end": "899280"
  },
  {
    "text": "[Music] um and the first one I want to start with is span of te question I always",
    "start": "899280",
    "end": "904959"
  },
  {
    "text": "like to ask is how many people in the room have heard of span of tea it's pretty good number say most um how many",
    "start": "904959",
    "end": "911720"
  },
  {
    "text": "people have used it in a real world application for something far far fewer which is also",
    "start": "911720",
    "end": "917199"
  },
  {
    "text": "about what I expected maybe I don't know 5 to 10% of the room have maybe used it",
    "start": "917199",
    "end": "922480"
  },
  {
    "text": "for something that's kind of what I expect so Microsoft talked a lot about this type when they introduced it and",
    "start": "922480",
    "end": "927680"
  },
  {
    "text": "they still do the reason they talk about it a lot is because it introduced massive improvements to what they could",
    "start": "927680",
    "end": "933880"
  },
  {
    "text": "optimize in the net runtime itself so this sort of open the door for some of the work that's happened since kind of",
    "start": "933880",
    "end": "939880"
  },
  {
    "text": "net core 21 era um for all of those high performance things and if any of you look at sort of like Steven Tal's blog",
    "start": "939880",
    "end": "946680"
  },
  {
    "text": "posts every year where he talks about all the high performance optimizations and where they've reduced memory allocations or increased the performance",
    "start": "946680",
    "end": "954199"
  },
  {
    "text": "of code a lot of that starts to talk back to the fact that span of te exists because it opens door for that but also",
    "start": "954199",
    "end": "960560"
  },
  {
    "text": "not many people have used it and I think partly because Microsoft did caution against most developers needing to use",
    "start": "960560",
    "end": "965839"
  },
  {
    "text": "Span in their code bases that message has been I think DED down a bit now and I agree it shouldn't be the general",
    "start": "965839",
    "end": "972079"
  },
  {
    "text": "message I think this has its uses and as you'll see in the code it doesn't necessarily always make it overly",
    "start": "972079",
    "end": "977519"
  },
  {
    "text": "complex and can give you quite good wins so what span of te um when span of te",
    "start": "977519",
    "end": "983319"
  },
  {
    "text": "was introduced it was built into net core 2.1 so that's like six years ago",
    "start": "983319",
    "end": "988560"
  },
  {
    "text": "now um so it's been around a while it was also released as a a new get package so system. memory that you can bring",
    "start": "988560",
    "end": "994759"
  },
  {
    "text": "into framework applications as well the optimizations aren't quite as sufficient uh or efficient sorry on um framework",
    "start": "994759",
    "end": "1002800"
  },
  {
    "text": "because there were runtime changes made in doet core to get the full performance gains but it's still a pretty good use",
    "start": "1002800",
    "end": "1008560"
  },
  {
    "text": "case even if you're using Framework apps ultimately what span does is provide a read write view over some",
    "start": "1008560",
    "end": "1014920"
  },
  {
    "text": "contiguous region of memory um the important thing is that it doesn't care where that memory is so it doesn't mind",
    "start": "1014920",
    "end": "1021079"
  },
  {
    "text": "if that memory is on the Heap traditional contiguous regions of memory would be things like strings or arrays",
    "start": "1021079",
    "end": "1026160"
  },
  {
    "text": "which are a block of memory on the Heap but it can also reference um stack allocated memory um and even unmanaged",
    "start": "1026160",
    "end": "1032959"
  },
  {
    "text": "native memory um but all through a single API and it does this in a type safe memory safe way so you don't have",
    "start": "1032959",
    "end": "1039079"
  },
  {
    "text": "to think about all of the the possible on caveats with doing that and drop down to unsafe code it's all safe code that",
    "start": "1039079",
    "end": "1045558"
  },
  {
    "text": "you don't have to have those unsafe keywords to use um you can iterate through this",
    "start": "1045559",
    "end": "1051080"
  },
  {
    "text": "contiguous memory you can index through it you can sort of pause through it um just as you would with a traditional array really um and it's almost as",
    "start": "1051080",
    "end": "1058440"
  },
  {
    "text": "efficient like there's maybe like sub single digit nanc performance overhead",
    "start": "1058440",
    "end": "1063600"
  },
  {
    "text": "to having a span versus a native array but a lot of work went into making this highly efficient um in Corr in",
    "start": "1063600",
    "end": "1070679"
  },
  {
    "text": "particular so one of the key operations once you've got a span is this idea of slicing so slicing is really just",
    "start": "1070679",
    "end": "1076679"
  },
  {
    "text": "changing the view over an existing blocker of memory so in this scenario we start by creating a new array of nine",
    "start": "1076679",
    "end": "1082679"
  },
  {
    "text": "elements um we then call as span to get the span representation of that memory",
    "start": "1082679",
    "end": "1088200"
  },
  {
    "text": "you'll see it returns a span of int um you might there be thinking oh well that's an allocation we've got a problem",
    "start": "1088200",
    "end": "1093880"
  },
  {
    "text": "but actually span is a type that's guaranteed never to be Heap allocated and we'll talk a little bit more about why and how um but the main thing is",
    "start": "1093880",
    "end": "1101000"
  },
  {
    "text": "that there's no Heap allocation cost there's no overhead to creating this span so it's a highly efficient type so",
    "start": "1101000",
    "end": "1106400"
  },
  {
    "text": "once we've got our span we can do something like SL icing and slicing just takes a start position and optionally a",
    "start": "1106400",
    "end": "1112559"
  },
  {
    "text": "length for how we want to slice that data and it just Returns the same data that exists already in that memory",
    "start": "1112559",
    "end": "1118080"
  },
  {
    "text": "region but sliced to that new view I kind of give the analogy of this of um",
    "start": "1118080",
    "end": "1123640"
  },
  {
    "text": "photography so if any of you you know take photographs when you visit a new city we've been out um my family and I",
    "start": "1123640",
    "end": "1129600"
  },
  {
    "text": "in Oslo we've taken some nice pictures from across the water of the Opera house and then at some point in time we think",
    "start": "1129600",
    "end": "1135280"
  },
  {
    "text": "actually it' be nice to see that a bit closer so one option is that we could walk around the water the front we can get closer and we can take a nice",
    "start": "1135280",
    "end": "1141120"
  },
  {
    "text": "close-up image but it takes some time takes some effort or we can just pinch zoom on our camera most of the time that",
    "start": "1141120",
    "end": "1146360"
  },
  {
    "text": "gives us the view we want um and it takes almost no time at all and that's kind of what slicing is it's we've",
    "start": "1146360",
    "end": "1151679"
  },
  {
    "text": "already got the data we're just changing our view over it and the important thing about slicing is it's a constant time",
    "start": "1151679",
    "end": "1157520"
  },
  {
    "text": "constant cost operation and know of one and so this means that even if that array is nine elements or 9 million",
    "start": "1157520",
    "end": "1163200"
  },
  {
    "text": "elements slicing just takes the same amount of time because we're not creating any new memory we're not copying memory we're just changing a",
    "start": "1163200",
    "end": "1169400"
  },
  {
    "text": "view over it so let's look at optimizing some code I will warn you this first example is",
    "start": "1169400",
    "end": "1174799"
  },
  {
    "text": "extremely contrived and trivial just to get the point across we'll look at some more real world code um shortly but",
    "start": "1174799",
    "end": "1180919"
  },
  {
    "text": "imagine that tomorrow or Monday when you return to the office uh your manager comes to you and says look if we can",
    "start": "1180919",
    "end": "1186960"
  },
  {
    "text": "develop a method that accepts an array of even number elements that can um we can return a quarter of those element",
    "start": "1186960",
    "end": "1193080"
  },
  {
    "text": "starting from the middle we're going to make some money somehow probably not but let's imagine that's a scenario that",
    "start": "1193080",
    "end": "1198480"
  },
  {
    "text": "you're given I'm sure you're all hoping that's the most complex thing you're given on Monday morning um many",
    "start": "1198480",
    "end": "1204400"
  },
  {
    "text": "developers given something like that might opt to just use something like link where you you get the existing length and then you say well we'll skip",
    "start": "1204400",
    "end": "1210679"
  },
  {
    "text": "halfway into that we'll take a cord of the elements and then we'll just return the aray and job done right and that's",
    "start": "1210679",
    "end": "1217080"
  },
  {
    "text": "fine that's reasonable code for the requirement that's been given but then our manager comes to us and says hang on",
    "start": "1217080",
    "end": "1222600"
  },
  {
    "text": "no we can make a lot more money if you can make this quicker so let's go ahead and think about that so the first thing",
    "start": "1222600",
    "end": "1227799"
  },
  {
    "text": "as we learned earlier is that we should measure before we make any assumptions about what we're doing so here this is a",
    "start": "1227799",
    "end": "1233240"
  },
  {
    "text": "slightly more advanced version of uh benchmarking so this is our setup um for our benchmarks so the First new thing on",
    "start": "1233240",
    "end": "1239919"
  },
  {
    "text": "this slide is this uh size parameter um um or size property that has a pram",
    "start": "1239919",
    "end": "1245120"
  },
  {
    "text": "attribute and this has three different values and what this allows us to do is say to",
    "start": "1245120",
    "end": "1250320"
  },
  {
    "text": "benchmark.us it can of often get tricked by just testing one scenario and assuming that's giving us like the",
    "start": "1255039",
    "end": "1261360"
  },
  {
    "text": "coverage for our entire um possibilities of what could happen in our application so it's best to test around the edges as",
    "start": "1261360",
    "end": "1268360"
  },
  {
    "text": "well so maybe we always assume that our array is going to be about a thousand elements but sometimes it can be a",
    "start": "1268360",
    "end": "1273919"
  },
  {
    "text": "little bit bigger or a little bit smaller so we start to measure both sides just to see if our changes apply in all scenarios so once we've set that",
    "start": "1273919",
    "end": "1280919"
  },
  {
    "text": "up uh we need a way of populating that um array and so this setup method here which is attributed with global setup is",
    "start": "1280919",
    "end": "1288080"
  },
  {
    "text": "basically going to run once per Benchmark and it just allows us to initialize the array of the right size based on that size property that will be",
    "start": "1288080",
    "end": "1294240"
  },
  {
    "text": "populated by benchmark.us uh fill it up um so none of this contributes to the measurement of",
    "start": "1294240",
    "end": "1300520"
  },
  {
    "text": "the Benchmark it's all setup work the actual Benchmark is very simple we're just testing that link uh code that we",
    "start": "1300520",
    "end": "1307360"
  },
  {
    "text": "had um the only difference from the last example is that we now have this Baseline equals true set on there which",
    "start": "1307360",
    "end": "1313080"
  },
  {
    "text": "says this is our starting point so all other Benchmark measurements will be benchmarked against this and so when we",
    "start": "1313080",
    "end": "1319000"
  },
  {
    "text": "run this we get three results this time one for each of those different sizes and we can see that okay it's about 100",
    "start": "1319000",
    "end": "1325520"
  },
  {
    "text": "NS on 100 elements and we allocated 224 bytes it got slower uh for the next size",
    "start": "1325520",
    "end": "1332240"
  },
  {
    "text": "up and it allocated a bit more and again factors more increase uh in execution",
    "start": "1332240",
    "end": "1337279"
  },
  {
    "text": "time and allocations as we go up not that unexpected we're creating a new array and we're filling it up and the",
    "start": "1337279",
    "end": "1342640"
  },
  {
    "text": "bigger the size the bigger the array the more copy needed so the first theory that one of",
    "start": "1342640",
    "end": "1348080"
  },
  {
    "text": "our engineers has is well I've heard that link can have some overhead to it so maybe we shouldn't use Link and we should try and avoid that so we can do",
    "start": "1348080",
    "end": "1353919"
  },
  {
    "text": "that by just creating a new array of the appropriate size using something like array. copy to copy the memory in uh",
    "start": "1353919",
    "end": "1360480"
  },
  {
    "text": "from the appropriate point and then just return the new array and so we measure this and for the first result of 100",
    "start": "1360480",
    "end": "1366960"
  },
  {
    "text": "elements 86% reduction in execution time this that sounds good and it looks like we've almost halved our allocations so",
    "start": "1366960",
    "end": "1374240"
  },
  {
    "text": "on on that row alone it looks pretty good but we can see that for a th000 elements the the execution time gain is",
    "start": "1374240",
    "end": "1381400"
  },
  {
    "text": "still there but the allocation gain is far less significant and as we drop down to 10,000 elements we're now only 1%",
    "start": "1381400",
    "end": "1388240"
  },
  {
    "text": "improved and that's because all we've really shaved off is the 96 bytes of Link overhead of the expression being",
    "start": "1388240",
    "end": "1394159"
  },
  {
    "text": "compiled down but everything else you know we're still creating an array we're still having to copy memory and so um",
    "start": "1394159",
    "end": "1399799"
  },
  {
    "text": "there's still the allocations from that so the final option and this is where the example is a bit contrived and",
    "start": "1399799",
    "end": "1406039"
  },
  {
    "text": "trival assumes that we can change our return type of this method or introduce a new method that returns a span but and",
    "start": "1406039",
    "end": "1411559"
  },
  {
    "text": "our caller can work with that but if they can then we can just drop down to slicing the existing memory to change",
    "start": "1411559",
    "end": "1417760"
  },
  {
    "text": "the view so that our caller can then work with that piece of memory and do some further processing and so in this",
    "start": "1417760",
    "end": "1423200"
  },
  {
    "text": "scenario we're just uh you know add span and then slice so then when we're using span on",
    "start": "1423200",
    "end": "1430000"
  },
  {
    "text": "my machine that's less than a nanc on the measurement so a pretty dramatic execution time Improvement and we've not",
    "start": "1430000",
    "end": "1436400"
  },
  {
    "text": "got any allocation cost we've not created any new array to return we' just given someone a new view over that",
    "start": "1436400",
    "end": "1441960"
  },
  {
    "text": "existing data and you can see that that then is roughly consistent um you know when we're down to sub nanc measurements",
    "start": "1441960",
    "end": "1448720"
  },
  {
    "text": "the variation is quite significant um but about 6.7 on my machine nanocs for",
    "start": "1448720",
    "end": "1454200"
  },
  {
    "text": "that to run and this is where we can see that regardless of the array size that goes in there's a constant time constant",
    "start": "1454200",
    "end": "1459760"
  },
  {
    "text": "cost operation to slicing that data and changing the view on it we can also work with strings using",
    "start": "1459760",
    "end": "1466080"
  },
  {
    "text": "spans so we can call as span on a string literal or on a variable that points to a string and that returns to us a read",
    "start": "1466080",
    "end": "1472159"
  },
  {
    "text": "only span of char so Char because strings are made up of characters uh so that's the element that we're going to",
    "start": "1472159",
    "end": "1477320"
  },
  {
    "text": "look at and read only because strings are immutable and if we were given a span that's a read right view over the",
    "start": "1477320",
    "end": "1483480"
  },
  {
    "text": "memory contained by the string uh we could break that immutability of strings and basically break every apps",
    "start": "1483480",
    "end": "1488960"
  },
  {
    "text": "assumptions everywhere and probably most apps would fall apart so the runtime enforces this readon nature where we can",
    "start": "1488960",
    "end": "1495200"
  },
  {
    "text": "view that String's memory we can pause our way through it we can sort of learn and process that String's memory but we",
    "start": "1495200",
    "end": "1501559"
  },
  {
    "text": "can't change the characters and so once we do that we could do something like you know in this trivial example say if",
    "start": "1501559",
    "end": "1507919"
  },
  {
    "text": "we wanted to just get the data that represents the surname we could find the index of the last space in this string",
    "start": "1507919",
    "end": "1513000"
  },
  {
    "text": "and then slice from there and then we're viewing the surname portion and we could do some further processing now on this",
    "start": "1513000",
    "end": "1518520"
  },
  {
    "text": "string this isn't going to give you a huge advantage over using something like string split but on a large string um",
    "start": "1518520",
    "end": "1524320"
  },
  {
    "text": "processing with spans can be really optimal now there are some some important limitations of span that um",
    "start": "1524320",
    "end": "1530480"
  },
  {
    "text": "it's worth highlighting I'll come back to that point I mentioned earlier where I said",
    "start": "1530480",
    "end": "1535600"
  },
  {
    "text": "that span can never be allocated on the Heap um and it's done and enforced through this new keyword that was",
    "start": "1535600",
    "end": "1541720"
  },
  {
    "text": "introduced in C 7.2 where we have this ref struct uh type now so regular struct",
    "start": "1541720",
    "end": "1548880"
  },
  {
    "text": "types as most of you know will generally end up being stack allocated but there are various ways that they could either",
    "start": "1548880",
    "end": "1554080"
  },
  {
    "text": "be boxed onto the Heap or they could be contained in an object that's stored on the Heap and so that memory is on the",
    "start": "1554080",
    "end": "1559760"
  },
  {
    "text": "Heap ref structs are enforced by the runtime that they can never that never can never happen and that's important",
    "start": "1559760",
    "end": "1565960"
  },
  {
    "text": "because it might point at um stack allocated memory so we don't want this span to outlive the memory that it's",
    "start": "1565960",
    "end": "1572200"
  },
  {
    "text": "giving you a view over and there's various other sort of internal implementation details about R this matters around struct tearing um and the",
    "start": "1572200",
    "end": "1579840"
  },
  {
    "text": "sort of Biore like nature of these types that could introduce um overhead for the GC as well but by enforcing them as this",
    "start": "1579840",
    "end": "1586840"
  },
  {
    "text": "special ref struct all those risks go away and that means the team could optimize the type very well but it does",
    "start": "1586840",
    "end": "1592720"
  },
  {
    "text": "mean that the type cannot be boxed which can be a problem it can't be a filled in a regular class because that class is on",
    "start": "1592720",
    "end": "1599360"
  },
  {
    "text": "the Heap and it's its data structures are also therefore on the Heap and it can't be a filled in a regular struct",
    "start": "1599360",
    "end": "1604440"
  },
  {
    "text": "because that could be boxed onto the Heap it can't be used as an argument or a local within an async method this is",
    "start": "1604440",
    "end": "1610600"
  },
  {
    "text": "the one that probably most people are concerned about and we'll see how you work around it in a moment um this is important because those async methods",
    "start": "1610600",
    "end": "1617799"
  },
  {
    "text": "end up being being sort of recompiled on behind the scenes to uh State machine classes or strs um and those again sort",
    "start": "1617799",
    "end": "1625200"
  },
  {
    "text": "of break the earlier rules because any of those locals or V arguments end up as fields on those um State machines uh for",
    "start": "1625200",
    "end": "1632760"
  },
  {
    "text": "a similar reason it can't be captured inside a Lambda expression because of the closure types that get generated uh",
    "start": "1632760",
    "end": "1638279"
  },
  {
    "text": "can't be used as a generic type argument and there's more um but so it's at this point you're probably thinking well hang",
    "start": "1638279",
    "end": "1643880"
  },
  {
    "text": "on this is really really limited where can I actually use this thing but it's most places is you can work around most",
    "start": "1643880",
    "end": "1649440"
  },
  {
    "text": "of these and that's because there's a sister type called memory of T which has a lot of the same apis and doesn't have",
    "start": "1649440",
    "end": "1655760"
  },
  {
    "text": "the quite the same requirements so it can live on the Heap um it's slightly less versatile than using span and it's",
    "start": "1655760",
    "end": "1662039"
  },
  {
    "text": "slightly less performant um it's defined as a rening struct not a ref",
    "start": "1662039",
    "end": "1667240"
  },
  {
    "text": "struct so doing things like slicing into a memory of te is slightly slower than compared to span um but at any point in",
    "start": "1667240",
    "end": "1674399"
  },
  {
    "text": "time once you've got that memory of te you can call it span property and then get the span rep presentation of the data that it's looking at and so what",
    "start": "1674399",
    "end": "1681360"
  },
  {
    "text": "this means is in this scenario say where we want to have this async method except a span of of of bite here uh the",
    "start": "1681360",
    "end": "1688080"
  },
  {
    "text": "compiler is upset and says no you can't um for the reasons I've already discussed and so what we can do in this",
    "start": "1688080",
    "end": "1694279"
  },
  {
    "text": "method our signature here can accept a memory of bite instead and so what our code could do is just work with that and",
    "start": "1694279",
    "end": "1700720"
  },
  {
    "text": "it's got the same apis for slicing as we saw with span or if we do really want to highly optimize this code and rely on",
    "start": "1700720",
    "end": "1706840"
  },
  {
    "text": "span we can create a non-async method that does accept a spanner bite and then call into that at any point we're",
    "start": "1706840",
    "end": "1712440"
  },
  {
    "text": "outside of the async flow of that code because async is only really needed for Io you're calling you know Network um",
    "start": "1712440",
    "end": "1719799"
  },
  {
    "text": "sockets or you're reading from files but as soon as you've got that data and it's buffered into memory in some form inside",
    "start": "1719799",
    "end": "1725240"
  },
  {
    "text": "a stream or a memory you know memory stream or something at that point you can switch to non-async code and so in",
    "start": "1725240",
    "end": "1730880"
  },
  {
    "text": "this application here the first thought might be that you could create a local or you can't uh by slicing the data that",
    "start": "1730880",
    "end": "1736240"
  },
  {
    "text": "you want to pass in there so the way we work around this is just passing directly that slice expression in um and",
    "start": "1736240",
    "end": "1741919"
  },
  {
    "text": "this is totally fine for the compiler and it can handle all of that and then all of our optimized code can be spam based in that a non-async",
    "start": "1741919",
    "end": "1749120"
  },
  {
    "text": "method so I want to put this one into practice with um a slightly more real world",
    "start": "1749120",
    "end": "1754480"
  },
  {
    "text": "example um so actually if I just go through this",
    "start": "1754480",
    "end": "1760279"
  },
  {
    "text": "slide just so you know what the example talks about that would help um so this comes from a previous job I worked out",
    "start": "1760279",
    "end": "1765640"
  },
  {
    "text": "where we did uh a lot of message and event uh microservices that were processing stuff and so in this sample it read from",
    "start": "1765640",
    "end": "1773159"
  },
  {
    "text": "a sqsq read the message it needed to deserialize that message and then we basically stored a copy of the the Json",
    "start": "1773159",
    "end": "1780519"
  },
  {
    "text": "message onto S3 which is the Amazon blob store and to form the object key which is basically the file name the unique",
    "start": "1780519",
    "end": "1787159"
  },
  {
    "text": "file name on there we use certain properties from the message to derive the object key and so I promise we did",
    "start": "1787159",
    "end": "1793600"
  },
  {
    "text": "all of the things I said we benchmarked we measured we profiled before we did the work and I'll show you the results",
    "start": "1793600",
    "end": "1798960"
  },
  {
    "text": "afterwards but this is uh it's not the exact code but it's close to what was in the original",
    "start": "1798960",
    "end": "1805159"
  },
  {
    "text": "application so the first thing is this accepts this event context here so this is basically the",
    "start": "1805159",
    "end": "1810559"
  },
  {
    "text": "deserialized um Json message from um uh the sqsq in this example it has a few",
    "start": "1810559",
    "end": "1817440"
  },
  {
    "text": "properties in the real example it had several hundred but we were only using a few of them to derive the object key um",
    "start": "1817440",
    "end": "1823799"
  },
  {
    "text": "there was a caveat in the app at the time that we didn't always guarantee that there would be a date on one of the fields so we had to handle that scenario",
    "start": "1823799",
    "end": "1830080"
  },
  {
    "text": "so I've kept that in because it keeps the sample a bit more real world so basically the original code um worked",
    "start": "1830080",
    "end": "1836200"
  },
  {
    "text": "out if um if the date was present we were going to have five elements making up the object key otherwise it would be",
    "start": "1836200",
    "end": "1841799"
  },
  {
    "text": "four we then created a string array of that number of elements so we were going to hold five strings or four strings",
    "start": "1841799",
    "end": "1847919"
  },
  {
    "text": "depending on that scenario and then we populated each of those elements in that array of strings using this get part me",
    "start": "1847919",
    "end": "1854240"
  },
  {
    "text": "for taking a string get part basically did a quick null or empty check to check if the",
    "start": "1854240",
    "end": "1859440"
  },
  {
    "text": "input was null or empty and if it was it would use unknown as the the value in its place we then remove the spaces and",
    "start": "1859440",
    "end": "1866399"
  },
  {
    "text": "remove spaces down here just use string replace so remove a space character and replace it with an underscore and then",
    "start": "1866399",
    "end": "1873159"
  },
  {
    "text": "the is part valid code was just using basically a Rex match to say is this valid um values that can be used in an",
    "start": "1873159",
    "end": "1881039"
  },
  {
    "text": "object key in AWS um and if not we'd use an invalid part otherwise it would return the the",
    "start": "1881039",
    "end": "1886639"
  },
  {
    "text": "part so this would build up those um this array of strings that were going to fil form the portions of the object",
    "start": "1886639",
    "end": "1893200"
  },
  {
    "text": "key we're going to populate we' also if the date was present just do a two string on there to get the string",
    "start": "1893200",
    "end": "1898919"
  },
  {
    "text": "elements that we wanted in there the final element was the message ID with the Json suffix and then these were",
    "start": "1898919",
    "end": "1904799"
  },
  {
    "text": "joined using string join to join all those elements together with the uh Slash character as the separator and",
    "start": "1904799",
    "end": "1911200"
  },
  {
    "text": "then it was lowercase and then that produced the object key so a lot of you might be able to spot where there would be some intermediate allocations this",
    "start": "1911200",
    "end": "1918159"
  },
  {
    "text": "code for most apps that's probably okay in arario we wanted to try and work around some of those costs and so in",
    "start": "1918159",
    "end": "1925279"
  },
  {
    "text": "this code which if I just scroll it first so the new code is a little more of a Bose but not too much more there's",
    "start": "1925279",
    "end": "1931639"
  },
  {
    "text": "some weird stuff that goes on at the top um so the first thing so I've updated this demo at the time I did it we were",
    "start": "1931639",
    "end": "1937679"
  },
  {
    "text": "doing it in like I think it was net 31 I want to say um but I've updated this code recently for net 8 so I'm taking",
    "start": "1937679",
    "end": "1944039"
  },
  {
    "text": "advantage of reject Source generators here which is one of the uh game that Steven tabber talked about around where",
    "start": "1944039",
    "end": "1950760"
  },
  {
    "text": "the compiler does the Rex work upfront as part of the compilation process rather than a runtime through reflection",
    "start": "1950760",
    "end": "1957720"
  },
  {
    "text": "and that's uh going to give you quite a good performance gain this weird stuff here this static readon span of char",
    "start": "1957720",
    "end": "1963919"
  },
  {
    "text": "with this array um or what looks like array of characters is a special optimization that the compiler has and",
    "start": "1963919",
    "end": "1971080"
  },
  {
    "text": "the runtime has around storing this data into the metadata into the kind of blob of the binary um so that we don't have",
    "start": "1971080",
    "end": "1977559"
  },
  {
    "text": "any he appications and these are basically just some of the pre um constructed string values that I want to",
    "start": "1977559",
    "end": "1982720"
  },
  {
    "text": "use like the invalid and the unknown um that we can optimize in the main work",
    "start": "1982720",
    "end": "1987919"
  },
  {
    "text": "happens down here the first thing that happens is the length is calculated so I'm using a feature here called string.c",
    "start": "1987919",
    "end": "1993559"
  },
  {
    "text": "create um what this basically lets us do is create a or or essentially mutate individual characters of the memory of a",
    "start": "1993559",
    "end": "2000120"
  },
  {
    "text": "string during its creation which allows us to use high performance techniques like span um but it's before the",
    "start": "2000120",
    "end": "2006760"
  },
  {
    "text": "String's returned which which is why we're allowed to sort of mutate that data but we need to know how long that string is going to be um upfront so this",
    "start": "2006760",
    "end": "2013919"
  },
  {
    "text": "calculate length which I don't need to show you just does that and then string.c create takes that length so it",
    "start": "2013919",
    "end": "2019120"
  },
  {
    "text": "can pre-allocate some memory for the characters it takes in some state in this case our event context and then it",
    "start": "2019120",
    "end": "2024440"
  },
  {
    "text": "takes in this special span action this key Builder action from down below which is an action here of um characters and",
    "start": "2024440",
    "end": "2032120"
  },
  {
    "text": "the event context so ultimately what this means is that we get access to this span that represents the memory for the",
    "start": "2032120",
    "end": "2038039"
  },
  {
    "text": "string uh in a read write form um and our data and so what we're doing here is",
    "start": "2038039",
    "end": "2043880"
  },
  {
    "text": "we start by starting at position zero we do a build part taking in our input data",
    "start": "2043880",
    "end": "2049200"
  },
  {
    "text": "for the first piece of the object key the the span that we're writing into and then the current",
    "start": "2049200",
    "end": "2055040"
  },
  {
    "text": "position in build part what that did did is basically do the same checks we did in the previous code but uh we're using",
    "start": "2055040",
    "end": "2061560"
  },
  {
    "text": "a higher performance technique so rather than is n or empty we just check the length is if the length is zero or using",
    "start": "2061560",
    "end": "2068000"
  },
  {
    "text": "this memory extensions all of the data is Whit space then we use unknown so that unknown part data that we stored in",
    "start": "2068000",
    "end": "2073679"
  },
  {
    "text": "the blob gets copied into our span otherwise the validation Rex gets called",
    "start": "2073679",
    "end": "2078960"
  },
  {
    "text": "and then eventually if it's valid we use this memory extensions to lower invariant to basically copy from our",
    "start": "2078960",
    "end": "2084760"
  },
  {
    "text": "input string into the span um and lowercase at the same time and the span",
    "start": "2084760",
    "end": "2090800"
  },
  {
    "text": "that we're writing into we're using this range operator behind here to move our way through it so as we write each",
    "start": "2090800",
    "end": "2096440"
  },
  {
    "text": "object key in we're going to update position or part of the object key we update our position by updating the",
    "start": "2096440",
    "end": "2101720"
  },
  {
    "text": "length here um for the date we use Tri format which also accepts a span as the",
    "start": "2101720",
    "end": "2107800"
  },
  {
    "text": "destination so this is an optimized version of essentially two string um on a date um this takes the format that we",
    "start": "2107800",
    "end": "2114839"
  },
  {
    "text": "want to use it Returns the byes written that we can use again to update How Far We've written into that span we copying",
    "start": "2114839",
    "end": "2120880"
  },
  {
    "text": "the message ID and then finally five characters in the end we copy in the Json suffix so basically all this codee",
    "start": "2120880",
    "end": "2126720"
  },
  {
    "text": "has moved us to to using span um as a method for uh writing our string um and",
    "start": "2126720",
    "end": "2133079"
  },
  {
    "text": "as we'll see in the results this does actually lead to some performance gains so in the original code uh this",
    "start": "2133079",
    "end": "2140880"
  },
  {
    "text": "was taking around 300 NS to run and you can see that we've made a 26% Improvement um on that by moving to this",
    "start": "2140880",
    "end": "2148200"
  },
  {
    "text": "now we weren't really looking for execution time gains we were mostly focused on allocations and so we can see that",
    "start": "2148200",
    "end": "2154560"
  },
  {
    "text": "actually the allocation reduction on this is about 74% so from 728 bytes down",
    "start": "2154560",
    "end": "2159640"
  },
  {
    "text": "to 192 um you might be thinking is that that useful um but at scale this was",
    "start": "2159640",
    "end": "2165839"
  },
  {
    "text": "doing around 18 million messages a day so that's 10 gig of allocations in this service just for this piece of code",
    "start": "2165839",
    "end": "2171880"
  },
  {
    "text": "alone that we dropped out uh by doing this and that actually meant that we did see a reduction in sort of gen zero Heap",
    "start": "2171880",
    "end": "2177800"
  },
  {
    "text": "um collections from the garbage collector um the actual benefits were far better at the time we did this at 31",
    "start": "2177800",
    "end": "2184359"
  },
  {
    "text": "I think um the ratio of performance Improvement was near 80% on the execution time but Don's got so much",
    "start": "2184359",
    "end": "2190400"
  },
  {
    "text": "improved that the gains in this Benchmark are starting to go away so you don't have to necessarily change your code as much to get the gains from net",
    "start": "2190400",
    "end": "2197240"
  },
  {
    "text": "as you did when we wrote that original code the next type that I want to look at is the array pole um the name kind of",
    "start": "2197240",
    "end": "2204480"
  },
  {
    "text": "gives this away it's a pool of arrays for reuse so in a lot of applications you might have scenarios where you're",
    "start": "2204480",
    "end": "2210119"
  },
  {
    "text": "allocating an array shortlived array for some kind of buffer uh particularly if you're doing stream using the streaming",
    "start": "2210119",
    "end": "2216079"
  },
  {
    "text": "apis you need these buffers you pass in but it can happen all over code bases where you just need a you know block of",
    "start": "2216079",
    "end": "2221680"
  },
  {
    "text": "bites or a block of characters and you're doing some work within that data um and ultimately producing a string or",
    "start": "2221680",
    "end": "2227319"
  },
  {
    "text": "passing that data somewhere else by using a Rayle we can get the advantage of just avoiding those shortlived",
    "start": "2227319",
    "end": "2233920"
  },
  {
    "text": "allocations and the pool means that we are going to use arrays that are going to be shared um amongst other areas of",
    "start": "2233920",
    "end": "2240200"
  },
  {
    "text": "application and this basically means that we can amortize the cost of those shortlived allocations so you do end up",
    "start": "2240200",
    "end": "2246560"
  },
  {
    "text": "with slightly long well slightly more um long lived objects will eventually end up in Gen 2 because they will be held by",
    "start": "2246560",
    "end": "2253280"
  },
  {
    "text": "the pool and and reused um but in most applications that will be uh worthwhile",
    "start": "2253280",
    "end": "2259359"
  },
  {
    "text": "because you'll be seeing far fewer short-lived allocations of those so this is found in the system buffers name",
    "start": "2259359",
    "end": "2265000"
  },
  {
    "text": "space um there's a shared implementation which is the one you're recommended to use for most scenarios so you call array",
    "start": "2265000",
    "end": "2271720"
  },
  {
    "text": "pool of tea shared and then you rent from that the array that you want uh the length that you want",
    "start": "2271720",
    "end": "2278599"
  },
  {
    "text": "the important thing to tell you is that you are likely to get an array that's larger than that length which might at",
    "start": "2278599",
    "end": "2284480"
  },
  {
    "text": "first sound a bit weird but that's kind of how the array pulls optimized um if it could return you an array of any",
    "start": "2284480",
    "end": "2290400"
  },
  {
    "text": "length then it's going to be pulling a lot of arrays that will never be uh reused uh across other parts of the app",
    "start": "2290400",
    "end": "2296040"
  },
  {
    "text": "so it has different bucket sizes of arrays that it's going to try and find the most suitable one from uh that it",
    "start": "2296040",
    "end": "2302119"
  },
  {
    "text": "can hand out to you to use when we're done with it we return",
    "start": "2302119",
    "end": "2307760"
  },
  {
    "text": "the array uh to the array pool we can optionally clear it so by default the array isn't cleared um which is again",
    "start": "2307760",
    "end": "2314599"
  },
  {
    "text": "something to be aware of so any data that you've written into that array will then be visible to whoever Rents It next",
    "start": "2314599",
    "end": "2320000"
  },
  {
    "text": "and it also means that when you're renting arrays you need to be aware of it because again you don't necessarily want to read all of that data assuming",
    "start": "2320000",
    "end": "2325280"
  },
  {
    "text": "you've written it and so when you work with um arrays that are rented from the pool you do need to track how much data",
    "start": "2325280",
    "end": "2331960"
  },
  {
    "text": "you've written into it how many uh elements of that have you you know from zero have you actually filled and then",
    "start": "2331960",
    "end": "2337839"
  },
  {
    "text": "typically what you're going to do is slice to that position when you're then processing that data and that ensures",
    "start": "2337839",
    "end": "2343000"
  },
  {
    "text": "that your codebase is only ever reading the portion of that rented array that you know is your own your own",
    "start": "2343000",
    "end": "2349040"
  },
  {
    "text": "data um so that's yeah an important warning um that can trip a few people up but otherwise switching to array PS is",
    "start": "2349040",
    "end": "2355520"
  },
  {
    "text": "pretty trivial uh and so in this again very simple simplified example we have a",
    "start": "2355520",
    "end": "2361000"
  },
  {
    "text": "method that's going to get called very often by some of our code maybe from a loop somewhere further up and in there",
    "start": "2361000",
    "end": "2366200"
  },
  {
    "text": "it needs to create a bite over a thousand elements that it passes into another method then they done some processing using that buffer now this",
    "start": "2366200",
    "end": "2373839"
  },
  {
    "text": "code obviously allocates that array every time so if it is called from a tight loop we're going to create these short-lived um thousand by arrays fairly",
    "start": "2373839",
    "end": "2381720"
  },
  {
    "text": "regularly um so we can switch away from that by instead moving to using the shared array pole and then renting so in",
    "start": "2381720",
    "end": "2389200"
  },
  {
    "text": "this case we rent a th now because of the way the sharol is implemented I know",
    "start": "2389200",
    "end": "2394319"
  },
  {
    "text": "that the first bucket size that could possibly be fulfill that need is going to be 1,24 elements long um and but it",
    "start": "2394319",
    "end": "2400920"
  },
  {
    "text": "might be even bigger than that if the next size up happens to have a free array um and 1024 is already empty in",
    "start": "2400920",
    "end": "2407160"
  },
  {
    "text": "the array pool then it might give you a larger one so we need to make sure that in our code further down that we are",
    "start": "2407160",
    "end": "2413040"
  },
  {
    "text": "tracking our position within that array and either slicing it or or processing only the portion of it that we're",
    "start": "2413040",
    "end": "2418359"
  },
  {
    "text": "writing into we also need to make sure that we return it um because otherwise what's the point of having the Rayle if",
    "start": "2418359",
    "end": "2424400"
  },
  {
    "text": "the data just is going to you know never be returned to the pole so typically the pattern for doing this is using a trif",
    "start": "2424400",
    "end": "2429920"
  },
  {
    "text": "finally block um to make sure that we always return it the next type I want to touch on I",
    "start": "2429920",
    "end": "2435400"
  },
  {
    "text": "won't go too deep into this because it's a little bit more Niche where you might use this but system IO pipelines was introduced um originally by the aspet",
    "start": "2435400",
    "end": "2442280"
  },
  {
    "text": "core team so their main scenario is that they're in their kestal web server for",
    "start": "2442280",
    "end": "2447400"
  },
  {
    "text": "aset core they're receiving a lot of bites off the wire and then those have to be paed for the HTTP content uh to",
    "start": "2447400",
    "end": "2454119"
  },
  {
    "text": "then further process that within aspnet core and so that process means traditionally that would go through a",
    "start": "2454119",
    "end": "2459839"
  },
  {
    "text": "number of sort of intermediary streams within aset core the team worked out that they could optimize all of that",
    "start": "2459839",
    "end": "2465680"
  },
  {
    "text": "stream usage to try and remove a lot of the overhead and the allocations but it was a lot of complex code and so what",
    "start": "2465680",
    "end": "2471640"
  },
  {
    "text": "they did is packaged that up into this um pipelines package that in their scenario at least for asbet core was",
    "start": "2471640",
    "end": "2477800"
  },
  {
    "text": "giving them around a 2X performance over using traditional streams in the kind of traditional way but as I say it's",
    "start": "2477800",
    "end": "2483200"
  },
  {
    "text": "packaged up for us so that we would we can reuse that same sort of Improvement if we're doing streaming data without",
    "start": "2483200",
    "end": "2489760"
  },
  {
    "text": "having to write that code ourselves we could technically write it um but it's a lot of boiler plate and so it's it's just available in this package the main",
    "start": "2489760",
    "end": "2497560"
  },
  {
    "text": "difference versus using streams yourself for this stuff is that with streams you use you create the buffers you create",
    "start": "2497560",
    "end": "2504200"
  },
  {
    "text": "the memory that you pass into them and then the data is handled within those streams pipeline does all of the buffer management for you and so it can",
    "start": "2504200",
    "end": "2510680"
  },
  {
    "text": "optimize that it uses the array pool for uh where it's getting that data um that",
    "start": "2510680",
    "end": "2515960"
  },
  {
    "text": "memory for you um and it ensures that that's all sort of returned as soon as possible um behind the",
    "start": "2515960",
    "end": "2521480"
  },
  {
    "text": "scenes there's as you might assume two ends to a pipe there's a writing end and a reading end so on the writing side",
    "start": "2521480",
    "end": "2528920"
  },
  {
    "text": "what we get is this pipewrench",
    "start": "2528920",
    "end": "2532920"
  },
  {
    "text": "um because we're likely to be in an async method reading off of a network you know or off of a file or something",
    "start": "2547280",
    "end": "2552480"
  },
  {
    "text": "so we get memory of bite but you can use the same techniques I showed you earlier to switch to non-async code and span F",
    "start": "2552480",
    "end": "2557800"
  },
  {
    "text": "filling that if you want to once you've written some data in you advance by the number of bytes that have been written",
    "start": "2557800",
    "end": "2563480"
  },
  {
    "text": "and then you flush in an async way so that flushes the data into the pipe on the reading",
    "start": "2563480",
    "end": "2569960"
  },
  {
    "text": "end the reader has this Ray sync method that we can call and so this is a non-blocking way of saying as soon as",
    "start": "2569960",
    "end": "2575680"
  },
  {
    "text": "there's data in this pipe available you know give me give me the data that's been written or or flushed in so that I",
    "start": "2575680",
    "end": "2580880"
  },
  {
    "text": "can start processing it so that we can highly efficiently stream through this data with both ends sort of reading and",
    "start": "2580880",
    "end": "2585960"
  },
  {
    "text": "writing at the same time the read async method returns a read result and on the read result we can access this thing",
    "start": "2585960",
    "end": "2591680"
  },
  {
    "text": "called a buffer and this gives us this readon sequence of bite so why readon",
    "start": "2591680",
    "end": "2596720"
  },
  {
    "text": "sequence of bite on the way out but a memory on the way in the main reason is that the pipe in advance doesn't know",
    "start": "2596720",
    "end": "2602760"
  },
  {
    "text": "how much data you're going to give it so it's going to rent some memory from the array pool um but it's going to sort of",
    "start": "2602760",
    "end": "2608240"
  },
  {
    "text": "pick a pick a block of memory that's available and start filling it but you might stream you know a 100 bytes or you",
    "start": "2608240",
    "end": "2615280"
  },
  {
    "text": "might stream 100,000 bytes off the network and so at some point that little block of memory that's been rented could",
    "start": "2615280",
    "end": "2620319"
  },
  {
    "text": "fill up and so internally what this looks like is basically the pipe during the writing side is just going to keep",
    "start": "2620319",
    "end": "2625920"
  },
  {
    "text": "renting these blocks returning them as memories of te to you that you're filling up but it handles all of that",
    "start": "2625920",
    "end": "2631520"
  },
  {
    "text": "internally and then on the reading end what it gives you is essentially a linked list of those blocks of memory",
    "start": "2631520",
    "end": "2637079"
  },
  {
    "text": "refer to as this readon sequence and so that's the data that you can then pass through in the correct",
    "start": "2637079",
    "end": "2643079"
  },
  {
    "text": "order so the next scenario that sort of demonstrates this uh again from a previous role um and from pretty much",
    "start": "2643079",
    "end": "2649680"
  },
  {
    "text": "the same microservice I think um was where we were receiving um an object from S3 The Blob store in AWS uh it was",
    "start": "2649680",
    "end": "2656480"
  },
  {
    "text": "a tab separated file uh in sort of compressed format and so our job was to",
    "start": "2656480",
    "end": "2661599"
  },
  {
    "text": "open the file decompress it and pause out three of the 25 columns within there that were going to then be stored as an",
    "start": "2661599",
    "end": "2667920"
  },
  {
    "text": "object into elastic search so again I'll show you the before and after code just so that we can kind of get a feel",
    "start": "2667920",
    "end": "2674319"
  },
  {
    "text": "for uh what that looks like so the before code is actually",
    "start": "2674319",
    "end": "2680440"
  },
  {
    "text": "pretty T it's just that um blocker code there um if you reading ahead of what",
    "start": "2680440",
    "end": "2688760"
  },
  {
    "text": "I'm talking about you'll probably start seeing where there are problems here so this was written by colleag we hadn't",
    "start": "2688760",
    "end": "2693960"
  },
  {
    "text": "you know we hadn't noticed this code going in um the the first indication that this service had some memory issues",
    "start": "2693960",
    "end": "2700240"
  },
  {
    "text": "was that it was starting to hit container limits this was running as a scaled container um and we had a sort of",
    "start": "2700240",
    "end": "2706160"
  },
  {
    "text": "reasonably High memory limit set but we kept hitting that we're like this doesn't make any sense we keep increasing the memory limit and we keep",
    "start": "2706160",
    "end": "2711680"
  },
  {
    "text": "hitting it uh so we looked at the code and we can you can kind of see the problem if you stare at it so in this",
    "start": "2711680",
    "end": "2717319"
  },
  {
    "text": "case I'm using a file stream rather than AWS but basically if you read a file from AWS you get back a a stream we then",
    "start": "2717319",
    "end": "2723119"
  },
  {
    "text": "use gzip to decompress it that's fair enough where things got a little weird was this creation of a memory Steam and",
    "start": "2723119",
    "end": "2729359"
  },
  {
    "text": "then this copy from the decompress stream into the memory stream sorry that's happening here and then this decompressed stream",
    "start": "2729359",
    "end": "2736359"
  },
  {
    "text": "that we've copied into is then cast to an array or stored as an array in order to pass it into UTF encoding utf8 to get",
    "start": "2736359",
    "end": "2743280"
  },
  {
    "text": "a string so at this point We've Ended up after various copies of this memory with a string that represents the entire",
    "start": "2743280",
    "end": "2749079"
  },
  {
    "text": "contents of the file these files were 10 to 20,000 lines long of You Know Tab separated data so that's a reasonably",
    "start": "2749079",
    "end": "2756079"
  },
  {
    "text": "large string so all of these are actually large object Heap uh style allocations then that data was passed",
    "start": "2756079",
    "end": "2762640"
  },
  {
    "text": "into this cloudwatch paa and the reason I think at the time for the string allocation stuff was that the author of",
    "start": "2762640",
    "end": "2768480"
  },
  {
    "text": "this code was using tiny CSV piler which I think at the time maybe only dealt with strings I'm sure it doesn't now um",
    "start": "2768480",
    "end": "2775280"
  },
  {
    "text": "this tiny CSV piler made it very easy to pass CSV or tab separated files by basically using this sort of Link style",
    "start": "2775280",
    "end": "2782720"
  },
  {
    "text": "syntax here to read through split on the lines and then had this mapping syntax down below to say map me from these",
    "start": "2782720",
    "end": "2789240"
  },
  {
    "text": "columns uh 0 1 and 10 onto this object and give me the object back so it's quite simple code that's easy to use",
    "start": "2789240",
    "end": "2797000"
  },
  {
    "text": "because of the use of this Library um but if you look at you know just look at the code above you can kind of see where",
    "start": "2797000",
    "end": "2802440"
  },
  {
    "text": "there's a lot of copying going on so we had a crack at rewriting this and the new",
    "start": "2802440",
    "end": "2807720"
  },
  {
    "text": "code is uh yeah a little bit longer uh might be a little harder to understand",
    "start": "2807720",
    "end": "2812800"
  },
  {
    "text": "what it's doing um but we optimize the way a lot of the the overhead so we still have to decompress the file",
    "start": "2812800",
    "end": "2819760"
  },
  {
    "text": "so that still kind of happens as before but as soon as we got that decompression stream we use pipe reader create here to",
    "start": "2819760",
    "end": "2825480"
  },
  {
    "text": "actually start creating a pipe now strictly speaking probably didn't need a pipe in this scenario um because we only",
    "start": "2825480",
    "end": "2830599"
  },
  {
    "text": "dealt with that data once but actually um we did think we were going to do some further processing through further parts",
    "start": "2830599",
    "end": "2837079"
  },
  {
    "text": "of that pipe reading process that made it more reasonable at the time but it uses the same code that we just looked",
    "start": "2837079",
    "end": "2842400"
  },
  {
    "text": "at so we call Ray sync we access the buffer once we've got some data and then this PA line method here takes that",
    "start": "2842400",
    "end": "2849079"
  },
  {
    "text": "buffer the buffer is that readon sequence of bite um to make it easier to",
    "start": "2849079",
    "end": "2854720"
  },
  {
    "text": "work with these sequences because there's a little bit of complexity about understanding if there's one element within there or multiple parts of that",
    "start": "2854720",
    "end": "2861040"
  },
  {
    "text": "sequence uh this sequence reader struct was introduced and we can create an instance of that to help us read through",
    "start": "2861040",
    "end": "2866760"
  },
  {
    "text": "the sequence so that has convenience methods on it like um try read to any so",
    "start": "2866760",
    "end": "2871920"
  },
  {
    "text": "we can say try read to any instance of a new line character and if you find that we know we've got enough data within",
    "start": "2871920",
    "end": "2877240"
  },
  {
    "text": "this current sequence that gives us a line from the file and so it returns us that line and so this Loop here is",
    "start": "2877240",
    "end": "2883960"
  },
  {
    "text": "basically going to read until there's nothing further available from that sequence reader if we don't have a line we break and then we wait for more data",
    "start": "2883960",
    "end": "2890240"
  },
  {
    "text": "to be flushed in but once we have at least enough data for one line we can pause it and at this point we're working",
    "start": "2890240",
    "end": "2895920"
  },
  {
    "text": "with a readon span of those bytes and then this new code basically pre-re Ates",
    "start": "2895920",
    "end": "2901040"
  },
  {
    "text": "the in the type that's going to be stored into elastic search that gets populated with this code it then loops",
    "start": "2901040",
    "end": "2906960"
  },
  {
    "text": "um checking for the index of the tab character and then it takes the strings that we need the three columns we care",
    "start": "2906960",
    "end": "2912720"
  },
  {
    "text": "about so at tab count 0 1 and 10 we're going to extract the string by slicing that data that precedes that tab",
    "start": "2912720",
    "end": "2919520"
  },
  {
    "text": "character this code below um is just going to update our view over that uh",
    "start": "2919520",
    "end": "2925640"
  },
  {
    "text": "line as we move forward so it keeps slicing it so as we've as we sliced the tab it gives us a new view containing",
    "start": "2925640",
    "end": "2931319"
  },
  {
    "text": "the remainder and then we update the tab count on it each iteration and this Loop can break after we've read the first 11",
    "start": "2931319",
    "end": "2937480"
  },
  {
    "text": "tabs because that that's the ones we care about after that we don't need to pass the file or the line any further um",
    "start": "2937480",
    "end": "2943400"
  },
  {
    "text": "that's pretty much it for the code so I'll go over to the",
    "start": "2943400",
    "end": "2948480"
  },
  {
    "text": "results so in the original uh uh processing or benchmarking of this we we",
    "start": "2950079",
    "end": "2956440"
  },
  {
    "text": "use one file of 10,000 rows to give us a vaguely uh reasonable real world measurement of the overhead so you can",
    "start": "2956440",
    "end": "2963000"
  },
  {
    "text": "see the the execution time has gone down but we're still only talking milliseconds so execution time wasn't",
    "start": "2963000",
    "end": "2968119"
  },
  {
    "text": "our issue but we've got a nice 80% gain anyway the issue for us was the allocations and you can see over here",
    "start": "2968119",
    "end": "2974280"
  },
  {
    "text": "that original code just for that one file allocating 100 megabytes uh as I say most of those on the large object",
    "start": "2974280",
    "end": "2980480"
  },
  {
    "text": "Heap as well requiring a Gen 2 collection later on to clear them up um and uh as you can see from the numbers",
    "start": "2980480",
    "end": "2987119"
  },
  {
    "text": "in that Gen 2 column you know there's a lot more allocations occurring in Gen 2 in that original Benchmark in the new",
    "start": "2987119",
    "end": "2993599"
  },
  {
    "text": "example we were down to 3.32 Meg so a good 90 7% reduction you might think oh",
    "start": "2993599",
    "end": "2999079"
  },
  {
    "text": "well 3.32 Meg still pretty high but actually once we then did uh memory profiling of the optimized code we",
    "start": "2999079",
    "end": "3005400"
  },
  {
    "text": "checked and actually 2.85 are the strings that we expect to create we needed three strings from each object",
    "start": "3005400",
    "end": "3010520"
  },
  {
    "text": "from each row that we then used to create the object that we store into elastic search and at the time those were unavoidable so those we accept the",
    "start": "3010520",
    "end": "3017440"
  },
  {
    "text": "remaining overhead 45 Meg some of that's coming from pipelines some of that somewhere else um I was quite Keen to",
    "start": "3017440",
    "end": "3025000"
  },
  {
    "text": "dig deeper but uh colleague pulled me back and said actually we don't care about that little extra uh allocation I",
    "start": "3025000",
    "end": "3031040"
  },
  {
    "text": "wish I still had access to the code because I'm still curious to see if we could get down to nearly zero overhead",
    "start": "3031040",
    "end": "3036440"
  },
  {
    "text": "um but you know sometimes as I say once you've optimized to a certain point your goals achieved moved on um so I I thank",
    "start": "3036440",
    "end": "3043119"
  },
  {
    "text": "my colleague for stopping me going down that that rabbit hole so the final API is system Tex Jason uh how are we doing",
    "start": "3043119",
    "end": "3050079"
  },
  {
    "text": "on time good we're doing we're doing well um so we we'll quickly talk about system text Jason",
    "start": "3050079",
    "end": "3057599"
  },
  {
    "text": "so this again has been introduced around for a while this was introduced I think in netore 3 and it's a new set of in",
    "start": "3058359",
    "end": "3065480"
  },
  {
    "text": "thebox apis for working with Jason data I think most people have probably heard about them now at the time there was a",
    "start": "3065480",
    "end": "3071599"
  },
  {
    "text": "big controversy because we had Newton soft Json nice open source library for Json processing that nearly every app",
    "start": "3071599",
    "end": "3077280"
  },
  {
    "text": "used if it worked with Json and and this was a sort of a a sort of a flag that",
    "start": "3077280",
    "end": "3082920"
  },
  {
    "text": "Microsoft was sort of stamping on open source and and creating their own thing now James Newton King who created Newton",
    "start": "3082920",
    "end": "3089440"
  },
  {
    "text": "soft Json uh did sort of validate that this had Merit um now partly he was",
    "start": "3089440",
    "end": "3094559"
  },
  {
    "text": "employed by Microsoft already at that point so you know maybe he had to say that but um there were some good reasons",
    "start": "3094559",
    "end": "3100160"
  },
  {
    "text": "so one of the things was newtoft Json was written well before things like span of tea and pipelines were available um",
    "start": "3100160",
    "end": "3106319"
  },
  {
    "text": "and so it would be a big rewrite to fully optimize it using those new new Concepts the other thing was by this",
    "start": "3106319",
    "end": "3113040"
  },
  {
    "text": "point in time you know Jason has really kind of become de facto in most applications many apps particularly",
    "start": "3113040",
    "end": "3118559"
  },
  {
    "text": "aspnet core apps that are doing web apis for example they're all going to be needing some kind of Json paing and so",
    "start": "3118559",
    "end": "3125200"
  },
  {
    "text": "having something in the box from from net supported by Microsoft optimized maintained by Microsoft does have some",
    "start": "3125200",
    "end": "3131240"
  },
  {
    "text": "Merit in that regard because it's quite an important set of apis that most other languages or most other Frameworks",
    "start": "3131240",
    "end": "3136400"
  },
  {
    "text": "package for you but whether or not you're happy with the idea um the performance gains do um do tend to make",
    "start": "3136400",
    "end": "3143400"
  },
  {
    "text": "it worthwhile so it's made up actually of three main levels there's this low-level apis the utf8 Json reader and",
    "start": "3143400",
    "end": "3150440"
  },
  {
    "text": "the utf8 Json writer um if you drop down this far you can get to almost or",
    "start": "3150440",
    "end": "3155480"
  },
  {
    "text": "generally zero allocation overhead sometimes on paring uh bites of Json data in an application but as we'll see",
    "start": "3155480",
    "end": "3163520"
  },
  {
    "text": "when we look at the demo it can be quite complex or or quite deep code there's a mid-level offered for reading uh Json",
    "start": "3163520",
    "end": "3170160"
  },
  {
    "text": "data in this Json document format so that allows us to more easily work our way through a Json documents format",
    "start": "3170160",
    "end": "3176200"
  },
  {
    "text": "looking at the elements that we want to find locating a particular property within a structure of Jason in a quite",
    "start": "3176200",
    "end": "3181359"
  },
  {
    "text": "efficient uh sort of single read way and then there's this high level um",
    "start": "3181359",
    "end": "3187559"
  },
  {
    "text": "API Json serializer and on there we have the things like serialize async and deserialize async the traditional types",
    "start": "3187559",
    "end": "3193359"
  },
  {
    "text": "of apis you'd expect from ad Jason uh Library most people will just use the",
    "start": "3193359",
    "end": "3198839"
  },
  {
    "text": "high level and that will give you generally performance gains over something like Newton softas because under the hood it's already been",
    "start": "3198839",
    "end": "3204839"
  },
  {
    "text": "Rewritten to use things like spans and um you know pipelines and efficient sort of memory processing behind the scenes",
    "start": "3204839",
    "end": "3211760"
  },
  {
    "text": "and so just by switching to this Library uh you can get the gains it used to be the case that the apis in system textas",
    "start": "3211760",
    "end": "3218599"
  },
  {
    "text": "were quite limited um since that sort of Freo time frame the team have really sort of built on them and so a lot of",
    "start": "3218599",
    "end": "3224960"
  },
  {
    "text": "the functionality that was available in Newton soft Json is now possible uh in system taxt Json I'm not saying the apis",
    "start": "3224960",
    "end": "3231480"
  },
  {
    "text": "are 100% compatible you're going to have to rewrite your code and update it uh if you do the migration but most of what",
    "start": "3231480",
    "end": "3237440"
  },
  {
    "text": "you needed to do is probably possible now so to put this one into uh sort of",
    "start": "3237440",
    "end": "3243079"
  },
  {
    "text": "practice uh the example we had for this was we were um at the time working with elastic search and we were indexing a",
    "start": "3243079",
    "end": "3249119"
  },
  {
    "text": "lot of data from these messages into elastic search and we used its bulk API to do that and in short the bulk API",
    "start": "3249119",
    "end": "3255240"
  },
  {
    "text": "allows you to send a new line Del limited uh set of Json data of operations to perform so rather than",
    "start": "3255240",
    "end": "3261720"
  },
  {
    "text": "sending uh a right request for every document you want to store every uh of piece of data you want to store you",
    "start": "3261720",
    "end": "3268040"
  },
  {
    "text": "could package those up into you know 100 or a thousand right operations to send in one HTTP core and so you're reducing",
    "start": "3268040",
    "end": "3274880"
  },
  {
    "text": "your HTTP overhead quite significantly if you've got a lot of data to Index this bulk API returns you a Jason",
    "start": "3274880",
    "end": "3281319"
  },
  {
    "text": "response and on that response it tells you did any of those operations fail because it's going to try and do all of",
    "start": "3281319",
    "end": "3287559"
  },
  {
    "text": "them for you um and if one of them fails um but 99 out of 100 succeed you need to",
    "start": "3287559",
    "end": "3292839"
  },
  {
    "text": "know about that and so you need to check that errors property to see if the errors it tells you also how long it all",
    "start": "3292839",
    "end": "3298119"
  },
  {
    "text": "took and it gives you the detail for each item for each operation um the specific details of its success or",
    "start": "3298119",
    "end": "3303960"
  },
  {
    "text": "failure status codes and things so what we needed to do is check that bulk response and look at all the IDS that",
    "start": "3303960",
    "end": "3310319"
  },
  {
    "text": "failed so that we could put them into essentially a dead Le letter q for further investigation didn't expect that",
    "start": "3310319",
    "end": "3316000"
  },
  {
    "text": "to happen very often but it was still needed to be considered so uh oh don't want to don't",
    "start": "3316000",
    "end": "3322880"
  },
  {
    "text": "want to steal the funer and give you the results early I want to show you the code so the original code for this is is",
    "start": "3322880",
    "end": "3328079"
  },
  {
    "text": "like super it fits on one screen even at this stupid font size um so basically this is newon oft",
    "start": "3328079",
    "end": "3334599"
  },
  {
    "text": "Json so we ultimately ended up creating this Json serializer and deserialize using that into this bulk response so",
    "start": "3334599",
    "end": "3341319"
  },
  {
    "text": "this says you know give me the bites that have come over the wire and then deserialize them into this type and you can see it has the how long it took the",
    "start": "3341319",
    "end": "3348000"
  },
  {
    "text": "errors and then the items which would be the results for each operation so we first deserialized that response into",
    "start": "3348000",
    "end": "3354720"
  },
  {
    "text": "that object model with then check um were there any errors so if there were no errors then this method which return",
    "start": "3354720",
    "end": "3360720"
  },
  {
    "text": "returns this value tpol here can return success true and an empty string for the",
    "start": "3360720",
    "end": "3366000"
  },
  {
    "text": "number of for the errors that were reported so in the happy path which we expect most of the time that's what's going to happen if there were errors",
    "start": "3366000",
    "end": "3372920"
  },
  {
    "text": "then we need to look through the items that were returned find those with the 400 status code for example find the IDS",
    "start": "3372920",
    "end": "3379559"
  },
  {
    "text": "and then return those so that we can identify which of those messages failed so pretty tur code pretty",
    "start": "3379559",
    "end": "3385319"
  },
  {
    "text": "straightforward the new code as you can see is longer um and this is why you",
    "start": "3385319",
    "end": "3392760"
  },
  {
    "text": "know this is important around this readability versus maintainability if you don't need to optimize and newtoft",
    "start": "3392760",
    "end": "3398359"
  },
  {
    "text": "Json is working fine and the app's perfectly happy probably stick with it or or most switch to the high level API",
    "start": "3398359",
    "end": "3404559"
  },
  {
    "text": "of system text Json um but if you really want to try and get the high performance as we did just for an exercise I think",
    "start": "3404559",
    "end": "3411119"
  },
  {
    "text": "at the time and then what we do is basically we're working with the streaming API we could have use",
    "start": "3411119",
    "end": "3416599"
  },
  {
    "text": "pipelines here but we're using the array pool to rent a buffer it's hardcoded in the demo because I know how much the",
    "start": "3416599",
    "end": "3421799"
  },
  {
    "text": "data is going to be um we read from the stream into that buffer ultimately then",
    "start": "3421799",
    "end": "3427640"
  },
  {
    "text": "we go into this pause errors code here which takes a bunch of State essentially",
    "start": "3427640",
    "end": "3433200"
  },
  {
    "text": "and then it uses the lowlevel utf8 Json reader API here to start reading from that um uh readon span of bytes from the",
    "start": "3433200",
    "end": "3441359"
  },
  {
    "text": "the Json data bytes and so what this does it's a re-entrant type so it can take um some state of its own so you can",
    "start": "3441359",
    "end": "3449160"
  },
  {
    "text": "keep calling it as you if you're streaming data as you're getting more bytes from The Wire and what you can do",
    "start": "3449160",
    "end": "3454240"
  },
  {
    "text": "on there is call read to read the next Json token and then in here this code is basically switching then on specific",
    "start": "3454240",
    "end": "3460400"
  },
  {
    "text": "Json tokens like start object start array Etc and because we know the structure of the Json we're expecting we",
    "start": "3460400",
    "end": "3466920"
  },
  {
    "text": "can highly optimize this code and so basically what this is doing is working its way through tracking its position",
    "start": "3466920",
    "end": "3472200"
  },
  {
    "text": "until we've read a property which is got the name errors so we know we found the errors property and once we've got that",
    "start": "3472200",
    "end": "3479039"
  },
  {
    "text": "which we set the States of flag that we have that um once we're in this the next token we're going to get is either true",
    "start": "3479039",
    "end": "3485039"
  },
  {
    "text": "or false the the value for that and so we're hoping that it's going to be errors false and at that point we can",
    "start": "3485039",
    "end": "3491240"
  },
  {
    "text": "set this other piece of state and so what this code will do is break once we found the errors property and we' found",
    "start": "3491240",
    "end": "3497720"
  },
  {
    "text": "that there are no errors it breaks otherwise it has to keep going because it's going to need to read all the items to find all of the IDS of the failures",
    "start": "3497720",
    "end": "3504039"
  },
  {
    "text": "but that's essentially I won't go through all of the code what that's doing um and so this code above then",
    "start": "3504039",
    "end": "3509920"
  },
  {
    "text": "after reading part of the data that's been streamed in if we found the errors and there are no errors we don't even stream the rest of the data because we",
    "start": "3509920",
    "end": "3516240"
  },
  {
    "text": "know we don't care about it and we can just stop streaming in other scenarios we have to stream further so quickly",
    "start": "3516240",
    "end": "3522200"
  },
  {
    "text": "show you the results before I wrap up so in the failure scenario the um",
    "start": "3522200",
    "end": "3528920"
  },
  {
    "text": "Improvement Optimizer code was 67% in execution time again mostly we were concerned on allocations and you can see",
    "start": "3528920",
    "end": "3536240"
  },
  {
    "text": "we've gone from about 100K to about 16k um allocation overhead but that's the",
    "start": "3536240",
    "end": "3541359"
  },
  {
    "text": "failure response that's the response we don't expect very often the one we do expect most of the time is that it",
    "start": "3541359",
    "end": "3546720"
  },
  {
    "text": "succeeds and that's what we wanted to optimize for and so in that scenario because of that short circuiting code",
    "start": "3546720",
    "end": "3553039"
  },
  {
    "text": "that basically just ends up reading the first property of Json that comes back and then breaking out and no longer streaming it we're down 99.9% in",
    "start": "3553039",
    "end": "3560680"
  },
  {
    "text": "execution time because we just short circuit in 200 NS out of this this processing code and the overhead is now",
    "start": "3560680",
    "end": "3566720"
  },
  {
    "text": "zero because we've just we've already streamed the data the actual processing overhead is zero because we're just reading through those tokens using the",
    "start": "3566720",
    "end": "3573119"
  },
  {
    "text": "lowlevel API so that was a pretty good gain that we could get there by dropping to those so I've got like a minute or so",
    "start": "3573119",
    "end": "3581359"
  },
  {
    "text": "left uh so quickly to say how we get business buying to do this you maybe like what you've seen today so when you",
    "start": "3581359",
    "end": "3587799"
  },
  {
    "text": "go back to your office start thinking about where you've got quick wins if you got an app that's always you know people are always complaining about how slow it",
    "start": "3587799",
    "end": "3593559"
  },
  {
    "text": "is or how slow a particular part of it is maybe that's somewhere to look at optimizing be scientific about how you",
    "start": "3593559",
    "end": "3599200"
  },
  {
    "text": "do it so you know get the benchmarks get the profiling to validate where you should improve and how long the existing",
    "start": "3599200",
    "end": "3606079"
  },
  {
    "text": "code takes to run if you're going to them business management though don't just say I can save 87% of the bite",
    "start": "3606079",
    "end": "3612319"
  },
  {
    "text": "allocations on this method because most managers above engineering are probably going to go yeah I don't care so show",
    "start": "3612319",
    "end": "3618839"
  },
  {
    "text": "them some money they can save give them a cost to benefit ratio so a very basic example of that for the service we were",
    "start": "3618839",
    "end": "3624200"
  },
  {
    "text": "looking at where we could use a lot of examples I've shown you today we worked out we could reduce about 50% of our",
    "start": "3624200",
    "end": "3630280"
  },
  {
    "text": "allocations using those techniques and we could roughly uh double or per instance throughput of those container",
    "start": "3630280",
    "end": "3636240"
  },
  {
    "text": "services when they were doing processing what that ultimately led to is saying that we could drop one VM from the",
    "start": "3636240",
    "end": "3641599"
  },
  {
    "text": "cluster a year that was under that container cluster saving about $1,700 that might not be enough to",
    "start": "3641599",
    "end": "3647960"
  },
  {
    "text": "justify the engineering time that went into it so do be aware of that but if this can be scaled in our microservice",
    "start": "3647960",
    "end": "3653240"
  },
  {
    "text": "environment where we had hundreds of these doing very similar things then we worked out that maybe we could save it",
    "start": "3653240",
    "end": "3659000"
  },
  {
    "text": "10x or 100x times across those services and that game might be more important and my daughter's coming to the stage",
    "start": "3659000",
    "end": "3665559"
  },
  {
    "text": "hello yeah Daddy's nearly finished um so quick summary byebye um",
    "start": "3665559",
    "end": "3672440"
  },
  {
    "text": "sorry about that uh so the important thing is uh when you're doing your code do you want to come here yes okay um",
    "start": "3672440",
    "end": "3679000"
  },
  {
    "text": "measure your code don't assume um don't make assumptions with benchmarks it's dangerous uh be scientific about how you",
    "start": "3679000",
    "end": "3686559"
  },
  {
    "text": "analyze the results so use you know techniques that are like",
    "start": "3686559",
    "end": "3692440"
  },
  {
    "text": "benchmark.us on the hot paths I'm glad she's agreeing uh focus on the hot paths don't spend your time on methods that",
    "start": "3693720",
    "end": "3699280"
  },
  {
    "text": "are called once or twice in your application lifetime those hot paths are where you want to focus on the time uh",
    "start": "3699280",
    "end": "3704640"
  },
  {
    "text": "don't copy memory slice it and that will ensure that you're um avoiding a lot of the overhead and the time spent working",
    "start": "3704640",
    "end": "3710960"
  },
  {
    "text": "with that data uh array pools are really useful and an easy switch to avoid short lived array",
    "start": "3710960",
    "end": "3716920"
  },
  {
    "text": "allocations yes um pipelines can be quite good if you're in a niche scenario where you do a lot of data streaming and",
    "start": "3716920",
    "end": "3723960"
  },
  {
    "text": "consider system text Json apis for um high performance Json data so the last",
    "start": "3723960",
    "end": "3730039"
  },
  {
    "text": "thing I want to show you is this book uh I learned a lot of the techniques about memory management from this book it's",
    "start": "3730039",
    "end": "3735400"
  },
  {
    "text": "about that thick it's about 1,100 pages in English uh it's written by Conrad it's a really good book to have I have",
    "start": "3735400",
    "end": "3741200"
  },
  {
    "text": "the physical copy because it's also good as a weapon if someone breaks in at night um and uh yeah tells you a lot",
    "start": "3741200",
    "end": "3747119"
  },
  {
    "text": "about how memory works inet but also talks about span and how the implementation works yes you can go so",
    "start": "3747119",
    "end": "3753559"
  },
  {
    "text": "thank you for listening um I'm going to pop you down there goes mommy um and if you want to",
    "start": "3753559",
    "end": "3760760"
  },
  {
    "text": "follow me or ask questions afterwards that's where you can find me and that link is all the slides so thank you very",
    "start": "3760760",
    "end": "3766279"
  },
  {
    "text": "much um I don't have time for questions on stage but grab me I'll I'll hang around if you have questions um thank",
    "start": "3766279",
    "end": "3771839"
  },
  {
    "text": "you very much for coming",
    "start": "3771839",
    "end": "3775359"
  }
]