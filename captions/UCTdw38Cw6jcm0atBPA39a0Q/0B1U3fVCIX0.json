[
  {
    "text": "all right so thank you all for coming it's a pleasure to be up here in front of you today to be able to talk about",
    "start": "8580",
    "end": "14430"
  },
  {
    "text": "building hybrid rust and c-sharp apps without sacrificing safety or too much",
    "start": "14430",
    "end": "20490"
  },
  {
    "text": "sanity there's a little sanity loss but I promise it's not too much our first a little bit about me my name is ash you",
    "start": "20490",
    "end": "27119"
  },
  {
    "text": "can find me around on github and Twitter and various other channels under the code Arras handle part of the rust lips",
    "start": "27119",
    "end": "33300"
  },
  {
    "text": "team and an engineer at data lust where we work on a Diagnostics platform called seek so we're going to be looking at",
    "start": "33300",
    "end": "40230"
  },
  {
    "text": "running rust in c-sharp together in a single application I'm not going to try",
    "start": "40230",
    "end": "45390"
  },
  {
    "text": "and convince you today that this is actually something that you're going to want to do because while C sharp and rust or independently memory safe",
    "start": "45390",
    "end": "51210"
  },
  {
    "text": "languages the only way we can stitch them together is by pretending that they're C and so that means throwing out",
    "start": "51210",
    "end": "57000"
  },
  {
    "text": "all the safety that we're used to working within them and having to rebuild that ourselves and doing that",
    "start": "57000",
    "end": "62579"
  },
  {
    "text": "requires a fairly deep understanding of both the doughnut runtime and the rust language what I am going to try and do",
    "start": "62579",
    "end": "69060"
  },
  {
    "text": "is use the process of having to explicitly work with language and runtime features that are normally at",
    "start": "69060",
    "end": "75660"
  },
  {
    "text": "work for us implicitly to offer a fresh perspective on these languages so if",
    "start": "75660",
    "end": "81090"
  },
  {
    "text": "you've mostly been working in safe c-sharp for a long time then there are aspects of the c-sharp language and the",
    "start": "81090",
    "end": "87330"
  },
  {
    "text": "dotnet runtime that you might not have actually come across before even though those will be at work somewhere in the stack that you're",
    "start": "87330",
    "end": "93420"
  },
  {
    "text": "working with and so having a look at those explicitly may give us a fresh appreciation for this workhorse",
    "start": "93420",
    "end": "99660"
  },
  {
    "text": "languages that we use every day and the kinds of things that somebody has had to do in order to make the code that we",
    "start": "99660",
    "end": "105090"
  },
  {
    "text": "write safe similarly for rusty if you've had a look at the language in the past we've tried",
    "start": "105090",
    "end": "110640"
  },
  {
    "text": "to pick it up and couldn't quite get why the language is designed the way it is what it's actually trying to achieve why",
    "start": "110640",
    "end": "116220"
  },
  {
    "text": "various features work the way that they do are then seeing them at work for us today in the real world context of",
    "start": "116220",
    "end": "124050"
  },
  {
    "text": "rebuilding safety in a hybrid app may help us build additional context and a",
    "start": "124050",
    "end": "129899"
  },
  {
    "text": "deeper understanding of this language so that we can feel more productive when we use it so I'm not going to be assuming",
    "start": "129899",
    "end": "136980"
  },
  {
    "text": "too much familiarity of rust coming into this but we're going to be looking at weird and unsafe",
    "start": "136980",
    "end": "142050"
  },
  {
    "text": "for the most part so we're not gonna spend a lot of time fussing on syntax we're going to be focusing on concepts",
    "start": "142050",
    "end": "149490"
  },
  {
    "text": "how those broader concepts map to language features and how how those language features help us build safety",
    "start": "149490",
    "end": "156180"
  },
  {
    "text": "so this is going to be less a gentle introduction to rust and Maura firehose of rust right to the face but we should",
    "start": "156180",
    "end": "163680"
  },
  {
    "text": "be able to follow along just fine okay so let's start with a little bit of background so I mentioned I work on a",
    "start": "163680",
    "end": "169050"
  },
  {
    "text": "Diagnostics platform called seek this is seek it's really a database you send a",
    "start": "169050",
    "end": "174330"
  },
  {
    "text": "diagnostic data in the form of buckets of structured logs sequel and organize those on disk for you and allow you to",
    "start": "174330",
    "end": "180930"
  },
  {
    "text": "query them back using its sequel like query language so seek is a database that is specialized to a very particular",
    "start": "180930",
    "end": "187410"
  },
  {
    "text": "workload and that's ordered range queries over semi structured time series data that's really what seek is at the",
    "start": "187410",
    "end": "195420"
  },
  {
    "text": "side of 2018 C equals a Windows product built on the full dotnet framework and",
    "start": "195420",
    "end": "200610"
  },
  {
    "text": "c-sharp with some fairly deep ties to the Windows platform over the course of that year we broke that dependency on",
    "start": "200610",
    "end": "206520"
  },
  {
    "text": "Windows and we shipped a new version of the seek product with support for Linux and Windows based on that core so six",
    "start": "206520",
    "end": "215520"
  },
  {
    "text": "dependency on Windows went right to the heart of the data base in the heart of a database is its storage engine so seek",
    "start": "215520",
    "end": "222450"
  },
  {
    "text": "would be organizing its data on disk using Assent your centers this database suite that's baked into Windows it's",
    "start": "222450",
    "end": "229020"
  },
  {
    "text": "used by various windows features and so we would have our high-level events or organizing data into seven day blocks",
    "start": "229020",
    "end": "235320"
  },
  {
    "text": "each block would be in each sent database so we had to break that dependency but it wasn't just a matter",
    "start": "235320",
    "end": "242370"
  },
  {
    "text": "of breaking our dependency on his hat in order to move to cross-platform one of the issues with you sent is that",
    "start": "242370",
    "end": "248430"
  },
  {
    "text": "as like a disk backed b-tree it wasn't really ideal for seeks workload of semi structured data so rather than just",
    "start": "248430",
    "end": "257430"
  },
  {
    "text": "replacing his sent with some equivalent cross-platform solution and accepting exactly the same trade-offs that we already had we thought it would be",
    "start": "257430",
    "end": "264480"
  },
  {
    "text": "better to lower in storage engine because why not you know copy our HUD so",
    "start": "264480",
    "end": "269940"
  },
  {
    "text": "that's what we did we built a storage engine and we built it in rust so now we have a c-sharp database",
    "start": "269940",
    "end": "275900"
  },
  {
    "text": "and a rust storage engine and we can see now that we get visibility all the way from the high level c-sharp events store",
    "start": "275900",
    "end": "281930"
  },
  {
    "text": "right through to the individual rust components in the storage engine and then down to actual files on disk so",
    "start": "281930",
    "end": "288050"
  },
  {
    "text": "what we're looking at here is a hybrid app but what is a hybrid app in the general sense we can think of a hybrid",
    "start": "288050",
    "end": "295370"
  },
  {
    "text": "app as many languages many run times and many paradigms all bundled up together in a single f5 experience so to give you",
    "start": "295370",
    "end": "303680"
  },
  {
    "text": "an idea of what I mean if you're mostly working on line of business applications and dotnet then you might be familiar with this kind of stack you have",
    "start": "303680",
    "end": "310310"
  },
  {
    "text": "something like a c-sharp server a JavaScript or a typescript client and the two are connected via HTTP API",
    "start": "310310",
    "end": "317229"
  },
  {
    "text": "oftentimes the JavaScript client is the only consumer of your c-sharp server so they're logically one system that a",
    "start": "317229",
    "end": "324050"
  },
  {
    "text": "coupled via an API and they present a single experience at the end-user but there's separate runtimes the kind",
    "start": "324050",
    "end": "332630"
  },
  {
    "text": "of hybrid app we're going to be talking about today is having c-sharp code and russ code coexisting within the same",
    "start": "332630",
    "end": "338479"
  },
  {
    "text": "actual process and rather than communicating via HTTP api they",
    "start": "338479",
    "end": "343520"
  },
  {
    "text": "communicate via shared application binary interface that allows the dot near runtime to call russ functions so",
    "start": "343520",
    "end": "351830"
  },
  {
    "text": "why would we actually want to do this it kind of sounds like a lot of work already so why would we take our",
    "start": "351830",
    "end": "357250"
  },
  {
    "text": "existing c-sharp database and then throw rust into it why didn't we build our",
    "start": "357250",
    "end": "362780"
  },
  {
    "text": "storage engine in c-sharp or alternatively why didn't we go the big bang rewrite it in rust path throw out",
    "start": "362780",
    "end": "368600"
  },
  {
    "text": "all of our existing code and try and build a new seek from scratch and rust the answer for us comes down to language",
    "start": "368600",
    "end": "376430"
  },
  {
    "text": "trade-offs fundamentally all languages are designed with trade-offs in mind there are no free lunches so there is no",
    "start": "376430",
    "end": "383360"
  },
  {
    "text": "universally perfect language as much as we might like to think there is and so",
    "start": "383360",
    "end": "388669"
  },
  {
    "text": "seek is a fairly large product has different requirements for different components our storage engine sets the",
    "start": "388669",
    "end": "396650"
  },
  {
    "text": "low-water mark for our performance characteristics and it sets the high-water mark for our safety so what",
    "start": "396650",
    "end": "404060"
  },
  {
    "text": "we need is for the runtime performance impact of our storage engine to be as low as possible so we have as",
    "start": "404060",
    "end": "409520"
  },
  {
    "text": "much room to move as we can for high-level features on top and we can't build a database on top of our storage",
    "start": "409520",
    "end": "416780"
  },
  {
    "text": "engine that's any safer than a storage engine itself is because while reliability doesn't guarantee safety if",
    "start": "416780",
    "end": "423710"
  },
  {
    "text": "we have a none and unsafe or unreliable storage engine then it's going to be very hard to build a safe database on",
    "start": "423710",
    "end": "429560"
  },
  {
    "text": "top of it and rust is really geared to that kind of code that's safety and performance critical code but not all of",
    "start": "429560",
    "end": "437210"
  },
  {
    "text": "siik is like that we also have higher level features we have domain entities we have migrations we have components",
    "start": "437210",
    "end": "443690"
  },
  {
    "text": "that need to interact and deal with versioning over time we have a Web API and all of that stuff is bread and",
    "start": "443690",
    "end": "450349"
  },
  {
    "text": "butter for c-sharp because it's a very concise and productive language with great dev time tooling and it has a lot",
    "start": "450349",
    "end": "457130"
  },
  {
    "text": "of mature libraries like it or not though it's not just a case of being",
    "start": "457130",
    "end": "462919"
  },
  {
    "text": "able to pick and choose languages that you want from the language tree take the things that you like out of those and ignore the constraints because there are",
    "start": "462919",
    "end": "470870"
  },
  {
    "text": "no free lunches we can't build a hybrid app without accepting new trade-offs there's real complexity in stitching two",
    "start": "470870",
    "end": "477590"
  },
  {
    "text": "language runtimes together but what's important is how this complexity manifests itself throughout",
    "start": "477590",
    "end": "483050"
  },
  {
    "text": "our system so what we end up with is localized concentrated complexity in the",
    "start": "483050",
    "end": "489800"
  },
  {
    "text": "stitching layer that doesn't need to permeate through the rest of the code bases so what we end up with in seek is",
    "start": "489800",
    "end": "495889"
  },
  {
    "text": "this very large safe idiomatic c-sharp code base a large safe idiomatic rust code base and then this thin slice of",
    "start": "495889",
    "end": "502340"
  },
  {
    "text": "insanity in the middle and it's that thin slice I've been saying they were going to be looking at today",
    "start": "502340",
    "end": "508000"
  },
  {
    "text": "so why rust I've kind of implied up to this point that rust has something to",
    "start": "508000",
    "end": "513500"
  },
  {
    "text": "offer us from building a storage engine that we felt made it more appropriate than c-sharp so I mentioned that our",
    "start": "513500",
    "end": "522110"
  },
  {
    "text": "storage engine sets the low-water mark for our performance characteristics in",
    "start": "522110",
    "end": "527240"
  },
  {
    "text": "order to build high-performance c-sharp code we need to limit GC work limiting GC work means relying on value types as",
    "start": "527240",
    "end": "534020"
  },
  {
    "text": "a bit of a thought exercise let's pretend the c-sharp I only have value types so exactly c-sharp but no classes if you",
    "start": "534020",
    "end": "541160"
  },
  {
    "text": "try to build a system in this language what kinds of limitations would you expect to hit if you've tried to build",
    "start": "541160",
    "end": "546590"
  },
  {
    "text": "code based on strikes you can probably think of a few already the answer though is fewer limitations in c-sharp today",
    "start": "546590",
    "end": "553700"
  },
  {
    "text": "than in the c-sharp of yesterday say between c-sharp 5 and c-sharp 8 with the introduction of ref strikes disposable",
    "start": "553700",
    "end": "560240"
  },
  {
    "text": "ref strikes ref read-only fields ref locals reference all of these things make value types more capable and make",
    "start": "560240",
    "end": "566930"
  },
  {
    "text": "working with some more ergonomic if you keep following that path along into the future you might end up with a language",
    "start": "566930",
    "end": "573290"
  },
  {
    "text": "that looks like rust we'll see sharp 15 have a bar checker you know it's so we can really think of",
    "start": "573290",
    "end": "579620"
  },
  {
    "text": "rust as dotnet value types with special superpowers because rust is fundamentally data types of",
    "start": "579620",
    "end": "586510"
  },
  {
    "text": "fundamentally value types it makes them nice to work with so anything that you wish you could do with value types in",
    "start": "586510",
    "end": "592790"
  },
  {
    "text": "c-sharp but felt like you couldn't you probably can't do in rust what that means is that when we're writing rust we",
    "start": "592790",
    "end": "599180"
  },
  {
    "text": "get the benefits of writing with value types we get a stable runtime with low overhead we have zero cost abstractions",
    "start": "599180",
    "end": "604970"
  },
  {
    "text": "because things are stack based when you're writing performance sensitive rust code you can use closures you can",
    "start": "604970",
    "end": "610340"
  },
  {
    "text": "use iterators which are rust version of link so we don't have to work in a subset of the language and compound the",
    "start": "610340",
    "end": "616280"
  },
  {
    "text": "inherent complexity of building a storage engine with the complexity of knowing what features of the language",
    "start": "616280",
    "end": "621320"
  },
  {
    "text": "were allowed to use rust also has a strong safety culture so there's a lot of knowledge sharing about what kinds of",
    "start": "621320",
    "end": "627860"
  },
  {
    "text": "unsafe code or ok to write and what kind aren't and why and that's important when you're writing this kind of code as well",
    "start": "627860",
    "end": "634600"
  },
  {
    "text": "alright so let's actually take a look at this lat rust language and we're going to do that with some c-sharp equivalents",
    "start": "634600",
    "end": "639980"
  },
  {
    "text": "the goal isn't really to do our rust versity Sharpe kind of thing there's not very useful the idea is assuming that you're more",
    "start": "639980",
    "end": "647060"
  },
  {
    "text": "familiar with c-sharp we can build some context around how rust approaches the same kinds of problems all right so",
    "start": "647060",
    "end": "654500"
  },
  {
    "text": "let's have a look at some strokes so in c-sharp we declare a value type as a structure can have fields in rust we",
    "start": "654500",
    "end": "659960"
  },
  {
    "text": "declare a value type as a struct and you can have fields so far they're fairly similar but there is one difference",
    "start": "659960",
    "end": "665210"
  },
  {
    "text": "already and that's that little derive annotation in rust that hash derive is an attribute and like attributes in",
    "start": "665210",
    "end": "671780"
  },
  {
    "text": "dotnet they allow us to annotate our items with additional semantics in this case that derive",
    "start": "671780",
    "end": "677250"
  },
  {
    "text": "makes the semantics of our russet struct equivalent to the dotnet struct so in dotnet all value types have a",
    "start": "677250",
    "end": "685080"
  },
  {
    "text": "initial default value value that you can initialize them to even if that default doesn't make semantic sense flat struct",
    "start": "685080",
    "end": "691440"
  },
  {
    "text": "in rust we have to opt into that by deriving default in dotnet we say that",
    "start": "691440",
    "end": "696570"
  },
  {
    "text": "value types have copy semantics when you pass a value type by value into a method a copy of that value is made and that's",
    "start": "696570",
    "end": "703620"
  },
  {
    "text": "what you work with a method when the method runs out you can add a scope there any changes you made to that struct will be lost in rust we say that",
    "start": "703620",
    "end": "711360"
  },
  {
    "text": "strikes have moved semantics by default so when you pass a value type by value into a method a copy is still made but",
    "start": "711360",
    "end": "718440"
  },
  {
    "text": "the original is invalidated and the one true version of that instance is passed into that method when it goes out of",
    "start": "718440",
    "end": "724890"
  },
  {
    "text": "scope then rust will destroy it we can opt in to copy semantics in rust though by deriving clone and copy so we see",
    "start": "724890",
    "end": "732300"
  },
  {
    "text": "immediately some differences between how value types behave by default and rust in c-sharp but we don't just declare",
    "start": "732300",
    "end": "739200"
  },
  {
    "text": "values and pass them around by value we share them so ignoring object references",
    "start": "739200",
    "end": "744630"
  },
  {
    "text": "which are overwhelmingly the most common way that we share data in c-sharp what does dotnet give us to share value",
    "start": "744630",
    "end": "750930"
  },
  {
    "text": "types it gives us managed pointers which are a feature that you might not have actually looked at directly because",
    "start": "750930",
    "end": "756960"
  },
  {
    "text": "c-sharp doesn't expose them directly that's that little T and in the left hand side there that is a managed",
    "start": "756960",
    "end": "763020"
  },
  {
    "text": "pointer it is a stack-based GC aware reference to some data that may be on the stack on the managed heap or it may",
    "start": "763020",
    "end": "769920"
  },
  {
    "text": "be unmanaged altogether so while c-sharp doesn't expose them directly it has a bunch of features that",
    "start": "769920",
    "end": "775320"
  },
  {
    "text": "use them ref parameters are like a shared mutable reference and we have a recent addition in T which is a shared",
    "start": "775320",
    "end": "781800"
  },
  {
    "text": "mutable reference ref lockerz ref returns and ref fields those are all based on manage pointers they allow us",
    "start": "781800",
    "end": "788490"
  },
  {
    "text": "to share data in a memory safe way rust has its own safe way of sharing value",
    "start": "788490",
    "end": "795000"
  },
  {
    "text": "types and those are references so we talked about the own T move semantics rust has shared immutable references and",
    "start": "795000",
    "end": "802710"
  },
  {
    "text": "it has exclusive mutable references and so the rules in rust are you may have a",
    "start": "802710",
    "end": "808080"
  },
  {
    "text": "bunch of shared immutable references or you may have single exclusive mutable one and you can only mutate data through a mutable",
    "start": "808080",
    "end": "814540"
  },
  {
    "text": "reference so we also see that rust references don't just track mutability they also track lifetimes if you're",
    "start": "814540",
    "end": "822610"
  },
  {
    "text": "familiar with f-sharp you might recognize that TK which is a lifetime as a generic type parameter",
    "start": "822610",
    "end": "828750"
  },
  {
    "text": "it's not really a coincidence because lifetimes in rust are types the types that tell us the points in our program",
    "start": "828750",
    "end": "835389"
  },
  {
    "text": "for which that reference is valid and can be used we track that lifetime explicitly through the type of the",
    "start": "835389",
    "end": "842019"
  },
  {
    "text": "reference what does that actually give us though so as an example to see what",
    "start": "842019",
    "end": "848860"
  },
  {
    "text": "explicit lifetime tracking buys us let's have a look at value types that borrowed data in c-sharp if we want a value type",
    "start": "848860",
    "end": "855670"
  },
  {
    "text": "that contains a manager two pointer internally we declare it as a ref struct we can then give it a span of bytes",
    "start": "855670",
    "end": "861279"
  },
  {
    "text": "which is borrowing from somewhere else in rust an equivalent struct looks like the one on the right we have a borrowed",
    "start": "861279",
    "end": "867970"
  },
  {
    "text": "type it takes a lifetime which we've called kick ref as a generic type parameter and we can then use that",
    "start": "867970",
    "end": "874149"
  },
  {
    "text": "lifetime for references in its fields so that and you eight there is a slice it's",
    "start": "874149",
    "end": "880149"
  },
  {
    "text": "pretty much the same thing as a span of bytes and so in rust we say that a",
    "start": "880149",
    "end": "886630"
  },
  {
    "text": "struct inherits the lifetime of its fields so because borrowed has a lifetime tik ref the borrowed struct",
    "start": "886630",
    "end": "892930"
  },
  {
    "text": "itself can't outlive that lifetime otherwise we're pointing to invalid data so we say that borrowed leaves fatigue",
    "start": "892930",
    "end": "899290"
  },
  {
    "text": "ref managed pointers in dotnet manage",
    "start": "899290",
    "end": "904810"
  },
  {
    "text": "their lifetime heuristic ly by being bound to the stack you can't box a",
    "start": "904810",
    "end": "910269"
  },
  {
    "text": "managed pointer because it may point to stack data and then you would invalidate it because in dotnet when we box a value",
    "start": "910269",
    "end": "917860"
  },
  {
    "text": "we talk about promoting it to the managed heap we change the semantics of its lifetime when we box a value the GC",
    "start": "917860",
    "end": "925060"
  },
  {
    "text": "takes ownership of it and it won't reclaim that value until it's no longer reachable so we say it has an",
    "start": "925060",
    "end": "930339"
  },
  {
    "text": "arbitrarily long lifetime whereas on the stack it has an arbitrarily short one so it's not valid for us to box borrowed",
    "start": "930339",
    "end": "937209"
  },
  {
    "text": "structs in c-sharp as a consequence of that we can't use borrowed value types",
    "start": "937209",
    "end": "943779"
  },
  {
    "text": "as Gennaro type parameters because in dotnet we assume that it's valid to box a generic",
    "start": "943779",
    "end": "950980"
  },
  {
    "text": "rust doesn't have that same restriction it's totally okay for you to box bio-data in rust because rusts heat",
    "start": "950980",
    "end": "958130"
  },
  {
    "text": "doesn't add semantics it's just an allocation space our allocation there won't outlive the borrow of some slice",
    "start": "958130",
    "end": "964940"
  },
  {
    "text": "that we pass in it's a bit of a pointless box but you can still do it we",
    "start": "964940",
    "end": "970550"
  },
  {
    "text": "also have no problem passing borrowed data in rust as generic type parameters because the lifetime becomes part of the",
    "start": "970550",
    "end": "977030"
  },
  {
    "text": "type rather than assuming saying net where it's valid for us to extend the lifetime of a generic type in rust we",
    "start": "977030",
    "end": "984950"
  },
  {
    "text": "assume that that T value is only valid for the block although the scope of takes generic so we have restrictive",
    "start": "984950",
    "end": "992720"
  },
  {
    "text": "default type constraints rather than permissive ones so that's a whole lot of",
    "start": "992720",
    "end": "998150"
  },
  {
    "text": "words but what does it really mean so to give you an example of what these things",
    "start": "998150",
    "end": "1003580"
  },
  {
    "text": "that we've just talked about get us when writing real code let's have a look at some bad code that I wrote so this is a",
    "start": "1003580",
    "end": "1010270"
  },
  {
    "text": "method in c-sharp it has a bug in it it's not even a very long method and I still managed to screw it up by adding",
    "start": "1010270",
    "end": "1016450"
  },
  {
    "text": "my defense I didn't actually write it broken to begin with I refactored it broken which I don't know I guess I",
    "start": "1016450",
    "end": "1022630"
  },
  {
    "text": "makes it a little better if you're looking for the bug just follow the sunglasses then the problem there is we",
    "start": "1022630",
    "end": "1028360"
  },
  {
    "text": "rent a buffer from our memory pool and we need to dispose it to return it so we",
    "start": "1028360",
    "end": "1033579"
  },
  {
    "text": "make a using statement in there and we then logically move ownership of that rented buffer into our data that we",
    "start": "1033580",
    "end": "1039910"
  },
  {
    "text": "returned but before we return our data we're going to return the buffer to the pool if we do sugar that code we can see",
    "start": "1039910",
    "end": "1046870"
  },
  {
    "text": "it a bit more clearly we create our data that we're going to return disposed the buffer and then return the result somebody else is going to rent that",
    "start": "1046870",
    "end": "1052930"
  },
  {
    "text": "buffer we're both going to be slapping bytes into it at the same time and we have a data race and that's a bad time",
    "start": "1052930",
    "end": "1059070"
  },
  {
    "text": "the problem here is that we see Sharpe is relying on us to be good programmers",
    "start": "1059070",
    "end": "1066040"
  },
  {
    "text": "which I am at least not so I end up writing bugs like this and have a bad",
    "start": "1066040",
    "end": "1072580"
  },
  {
    "text": "time if I translate this code directly into rust it actually looks very similar",
    "start": "1072580",
    "end": "1077830"
  },
  {
    "text": "because my see Karp is kind of rusty it looks pretty much the same but there's one difference",
    "start": "1077830",
    "end": "1082860"
  },
  {
    "text": "and the difference is that we don't have the same bug because rust tracks ownership explicitly it knows that when",
    "start": "1082860",
    "end": "1089670"
  },
  {
    "text": "we pass ownership of our rented buffer into the data that we return it shouldn't return it to the pool until",
    "start": "1089670",
    "end": "1096090"
  },
  {
    "text": "data goes out of scope and that's move semantics at work for us the compiler",
    "start": "1096090",
    "end": "1101760"
  },
  {
    "text": "generates the right code rather than relying on us to do it what if we try",
    "start": "1101760",
    "end": "1106830"
  },
  {
    "text": "and dietra our rust the same way as the c-sharp though in this case we get a",
    "start": "1106830",
    "end": "1112440"
  },
  {
    "text": "compile error and the problem here is move semantics at work again for us rust",
    "start": "1112440",
    "end": "1117480"
  },
  {
    "text": "knows that we moved our buffer into Darla's it's not valid for us to try and drop it so drop is kind of similar to",
    "start": "1117480",
    "end": "1123660"
  },
  {
    "text": "dispose in rust so we get a compile error instead of a data race up till now",
    "start": "1123660",
    "end": "1130440"
  },
  {
    "text": "though it might feel like I've been picking on c-sharp a bit that's not what I mean to do there's a reason that seek",
    "start": "1130440",
    "end": "1136020"
  },
  {
    "text": "is predominantly written in c-sharp and that's because it gives us a lot - and one thing that we can't overstate is the",
    "start": "1136020",
    "end": "1141840"
  },
  {
    "text": "maturity of its ecosystem so we get asp net core which is this vast capable",
    "start": "1141840",
    "end": "1147660"
  },
  {
    "text": "mature web framework that's suitable not only for our high-throughput ingestion needs but also our more standard web api",
    "start": "1147660",
    "end": "1155460"
  },
  {
    "text": "calls the power of the UI and there just isn't that same level of maturity and rust web frameworks yet cuz Aspen has",
    "start": "1155460",
    "end": "1161010"
  },
  {
    "text": "been going for like 15 or years or something we also get mature projects in the ecosystem like stereo for logging",
    "start": "1161010",
    "end": "1166830"
  },
  {
    "text": "and auto fact for IRC I think Auto fact deserves its own slide because it",
    "start": "1166830",
    "end": "1172950"
  },
  {
    "text": "captures pattern that allows us to scale c-sharp code bases really effectively so",
    "start": "1172950",
    "end": "1179250"
  },
  {
    "text": "what we're looking at here is auto FAQ at work not just mapping abstractions to",
    "start": "1179250",
    "end": "1184440"
  },
  {
    "text": "implementations which is the least interesting thing that noisy container will do for you but it describes",
    "start": "1184440",
    "end": "1189710"
  },
  {
    "text": "relationships between the components in our system and how those come together",
    "start": "1189710",
    "end": "1194900"
  },
  {
    "text": "so in this case we collect all of our server tasks at runtime along with some metadata about how to schedule them",
    "start": "1194900",
    "end": "1201210"
  },
  {
    "text": "except for our metrics tasks which we deal with explicitly and without reflection you just kind of can't write",
    "start": "1201210",
    "end": "1206940"
  },
  {
    "text": "the same code in rust you have to know everything up front something else that we get from C sharp",
    "start": "1206940",
    "end": "1212679"
  },
  {
    "text": "is the compile time the dev time tooling so as an example our C sharp set code",
    "start": "1212679",
    "end": "1217690"
  },
  {
    "text": "base is about twice the size of our rusty code base compiling C sharp compiling our seek project in a fresh",
    "start": "1217690",
    "end": "1224619"
  },
  {
    "text": "debug build takes about three seconds for our Rosco base it takes about two minutes and the reason they're different",
    "start": "1224619",
    "end": "1230349"
  },
  {
    "text": "is that in C sharp we compile ahead of time to an intermediate language and",
    "start": "1230349",
    "end": "1235929"
  },
  {
    "text": "then get it at run time into machine code whereas in rust we compile ahead of",
    "start": "1235929",
    "end": "1241749"
  },
  {
    "text": "time using an optimizing compiler LLVM straight into machine code so this is really an apples to oranges comparison",
    "start": "1241749",
    "end": "1248099"
  },
  {
    "text": "but that's also kind of the point because sometimes you want apples and sometimes you want oranges all right so",
    "start": "1248099",
    "end": "1255940"
  },
  {
    "text": "we've had a look at what a hybrid app is why we might want to build one why we",
    "start": "1255940",
    "end": "1261159"
  },
  {
    "text": "decided to build one and what we think rust and c-sharp each bring to the table so now let's have a little look at how",
    "start": "1261159",
    "end": "1268450"
  },
  {
    "text": "we go about stitching them together in a single application so to do that what I've done is I've wasted now FF I",
    "start": "1268450",
    "end": "1275710"
  },
  {
    "text": "infrastructure out of seek our friend up on github with a sample c-sharp API on one side and a sample rust database",
    "start": "1275710",
    "end": "1282099"
  },
  {
    "text": "based on a project called sled on the other side which you should also check out and and I'll put that up so that we",
    "start": "1282099",
    "end": "1289599"
  },
  {
    "text": "can have a look at how we go about doing this it's permissively licensed so you can pill for it to your heart's content this is what it looks like so it is a",
    "start": "1289599",
    "end": "1297549"
  },
  {
    "text": "fairly extensive example it covers a whole lot of things that we can't cover directly today like how to integrate",
    "start": "1297549",
    "end": "1302649"
  },
  {
    "text": "cargo with msbuild how to debug dotnet code using lldp all that kind of stuff",
    "start": "1302649",
    "end": "1309389"
  },
  {
    "text": "so I encourage you to check it out if you're interested in exploring this stuff further so it includes a c-sharp",
    "start": "1309389",
    "end": "1315399"
  },
  {
    "text": "Web API and a rust database and this user interface which deserves no further",
    "start": "1315399",
    "end": "1322839"
  },
  {
    "text": "discussion this is not sick this is my amazing playing around with angular but",
    "start": "1322839",
    "end": "1329139"
  },
  {
    "text": "what it allows us to do is create a document in your database and we're going to have a quick tour of how our",
    "start": "1329139",
    "end": "1335589"
  },
  {
    "text": "hybrid app works by creating a document so we'll say hello Oslo and it's called",
    "start": "1335589",
    "end": "1343210"
  },
  {
    "text": "here even though it's I don't know if anyone else's - brush",
    "start": "1343210",
    "end": "1348730"
  },
  {
    "text": "will have exactly the same temperature in Australia at the moment even though we're in the middle of winter and we get",
    "start": "1348730",
    "end": "1354130"
  },
  {
    "text": "you guys get like 18 hours of Sun limit since then so when we set that okay so",
    "start": "1354130",
    "end": "1360970"
  },
  {
    "text": "here we are in our sample app we're on the C sharp Web API at the moment so what we've done is we've posted a JSON",
    "start": "1360970",
    "end": "1367539"
  },
  {
    "text": "document to this endpoint we're going to collect that up with its key and we're going to write that to a database so",
    "start": "1367539",
    "end": "1374679"
  },
  {
    "text": "what we do is we read into an eye memory owner this is a new API in c-sharp it represents some owned piece of dumb",
    "start": "1374679",
    "end": "1381190"
  },
  {
    "text": "memory that we're responsible for reclaiming so we transfer ownership of",
    "start": "1381190",
    "end": "1386830"
  },
  {
    "text": "the memory into our data struct now we need to begin a write transaction so to",
    "start": "1386830",
    "end": "1392500"
  },
  {
    "text": "do that we call into rust so this bindings dot DB write begin here this is a rust function and it's going",
    "start": "1392500",
    "end": "1398590"
  },
  {
    "text": "to return a write transaction for us to use so here we are now we're in rust in",
    "start": "1398590",
    "end": "1404350"
  },
  {
    "text": "order to begin our write transaction we allocate a handle in rust heap allocating that handle means calling",
    "start": "1404350",
    "end": "1411100"
  },
  {
    "text": "into our idiomatic rust database which in this case is fairly simple we just create a clone of it so once we've",
    "start": "1411100",
    "end": "1418480"
  },
  {
    "text": "allocated our handle we return okay now we have a write transaction we can begin",
    "start": "1418480",
    "end": "1424090"
  },
  {
    "text": "we can actually set our document so to do that we copy the data key into a",
    "start": "1424090",
    "end": "1431470"
  },
  {
    "text": "stack local in this example database our keys are a fixed to 16 byte value",
    "start": "1431470",
    "end": "1436500"
  },
  {
    "text": "because it's on the stack it's OK for us to take a pointer to it we get a fixed pointer to the value which we can see",
    "start": "1436500",
    "end": "1443490"
  },
  {
    "text": "has the content and now we're going to call in our rust function so back on the",
    "start": "1443490",
    "end": "1451299"
  },
  {
    "text": "rust side we rematerializing a view of the data based on the inputs that we got from c-sharp and we set it in our",
    "start": "1451299",
    "end": "1457720"
  },
  {
    "text": "database that's not very interesting so I'll just skip over that we return ok so",
    "start": "1457720",
    "end": "1463240"
  },
  {
    "text": "now that we've set our document we dispose our write transaction and that",
    "start": "1463240",
    "end": "1469090"
  },
  {
    "text": "means calling spose because we had it in a using block calling back into rust we call complete that flushes the bytes",
    "start": "1469090",
    "end": "1475870"
  },
  {
    "text": "that we just wrote to disk we then complete our action and now we",
    "start": "1475870",
    "end": "1482789"
  },
  {
    "text": "have a document saved in our database so that's a quick view of this sample app",
    "start": "1482789",
    "end": "1488279"
  },
  {
    "text": "that we're going to be looking at and I cannot I cannot into gestures so there",
    "start": "1488279",
    "end": "1494850"
  },
  {
    "text": "are a few pieces in there we have a c-sharp API we have some c-sharp",
    "start": "1494850",
    "end": "1500700"
  },
  {
    "text": "bindings we have some rough bindings and we have a rust database so the first",
    "start": "1500700",
    "end": "1506190"
  },
  {
    "text": "thing we're going to look at are the bindings the c-sharp and the rough slide and these are the fundamental way that",
    "start": "1506190",
    "end": "1511710"
  },
  {
    "text": "we stitch these two languages together there are effectively C functions what",
    "start": "1511710",
    "end": "1516720"
  },
  {
    "text": "we do is we declare them and implement them in rust and we then import and call them in c-sharp what's important is that",
    "start": "1516720",
    "end": "1523799"
  },
  {
    "text": "various parts and aspects of these functions line up they need to have the same calling convention so we know who's",
    "start": "1523799",
    "end": "1529769"
  },
  {
    "text": "responsible for cleaning up the stack they need to have the same name so that M in c-sharp we can find them that's",
    "start": "1529769",
    "end": "1535769"
  },
  {
    "text": "what that little no mangle attribute does it stops us from messing with the name of the function that we export in",
    "start": "1535769",
    "end": "1541590"
  },
  {
    "text": "they need to have the same arguments and those arguments need to have the same ABI that means they need to have the",
    "start": "1541590",
    "end": "1546749"
  },
  {
    "text": "same representation in c-sharp as they do in rust so what actually happens when",
    "start": "1546749",
    "end": "1554539"
  },
  {
    "text": "we execute a rust function in c-sharp we don't just call it directly there's a",
    "start": "1554539",
    "end": "1560129"
  },
  {
    "text": "feature of the.net runtime called P invoke that comes into play here and what P invoke does is when the runtime",
    "start": "1560129",
    "end": "1566429"
  },
  {
    "text": "encounters an unmanaged call it generates a whole lot of code around it to make sure that that unmanaged code",
    "start": "1566429",
    "end": "1572789"
  },
  {
    "text": "integrates into the dollar at runtime correctly so believe it or not your",
    "start": "1572789",
    "end": "1577859"
  },
  {
    "text": "c-sharp code that you write that is executing in the.net runtime has a specific ABI that it has to conform to",
    "start": "1577859",
    "end": "1584869"
  },
  {
    "text": "because the dotnet runtime needs to be able to work with that managed code in order to do GC reporting dotnet will",
    "start": "1584869",
    "end": "1592859"
  },
  {
    "text": "walk all of your manage stack frames and try and find GC roots in specific locations so that it can report them to",
    "start": "1592859",
    "end": "1598440"
  },
  {
    "text": "the garbage collector we can't guarantee that unmanaged code is going to report",
    "start": "1598440",
    "end": "1603629"
  },
  {
    "text": "it stack frames correctly similarly manage our threads that are running managed code need to cooperate in the",
    "start": "1603629",
    "end": "1609690"
  },
  {
    "text": "runtime to decide when it see could actually occur once again our managed code isn't necessarily going to",
    "start": "1609690",
    "end": "1614940"
  },
  {
    "text": "do that so what we do is before our unmanaged code we tell a runtime that we're going to enter an unmanaged",
    "start": "1614940",
    "end": "1620940"
  },
  {
    "text": "context it knows to skip all those unmanaged frames when it does a stack walk it knows not to block on that",
    "start": "1620940",
    "end": "1626610"
  },
  {
    "text": "thread if it needs to do what you see and when we return then the doughnut runtime will check whether a GC using",
    "start": "1626610",
    "end": "1632610"
  },
  {
    "text": "progress and make sure that it waits appropriately for it so the P invoke is",
    "start": "1632610",
    "end": "1637620"
  },
  {
    "text": "that little il stub P invoke there we don't actually write that that is generated for us by the dotnet runtime",
    "start": "1637620",
    "end": "1644150"
  },
  {
    "text": "and that's also a place for special marshalling to occur for arguments that need to be converted into an ABI",
    "start": "1644150",
    "end": "1650340"
  },
  {
    "text": "compatible representation so below that P invoke we have our C sharp stack trace",
    "start": "1650340",
    "end": "1655470"
  },
  {
    "text": "and above that P invoke we have our rough stack trace for the function that we actually called so P invoke",
    "start": "1655470",
    "end": "1663050"
  },
  {
    "text": "introduces costs on executing unmanaged code you're probably not going to be",
    "start": "1663050",
    "end": "1670320"
  },
  {
    "text": "able to build a hybrid app with piecemeal functions written in rust if you think it's going to make your code faster the reason is that the cost of",
    "start": "1670320",
    "end": "1677610"
  },
  {
    "text": "the PM VOC may well just do off the cost of the unmanaged function call and then you've just wasted your time",
    "start": "1677610",
    "end": "1683490"
  },
  {
    "text": "in our case pretty much every unmanaged function call means pulling data from disk or writing it to disk so that's",
    "start": "1683490",
    "end": "1691080"
  },
  {
    "text": "gonna oblivia the cost of pretty well anything that we can do on either end so",
    "start": "1691080",
    "end": "1697430"
  },
  {
    "text": "right now we have bindings diff effectively C functions we have no safety around them in order to rebuild",
    "start": "1697430",
    "end": "1704340"
  },
  {
    "text": "safety in these bindings we use some special types on the rough side because rust is really nice for modeling safety",
    "start": "1704340",
    "end": "1710760"
  },
  {
    "text": "contracts that's the place where we rebuild our safety so there's a couple here that we're gonna look up there's",
    "start": "1710760",
    "end": "1715950"
  },
  {
    "text": "this ref type there's an out type let's handle share thing and a DB result so",
    "start": "1715950",
    "end": "1721230"
  },
  {
    "text": "let's have a look at the DB result first DB result is about error management internet our mechanism for error",
    "start": "1721230",
    "end": "1728070"
  },
  {
    "text": "management exceptions methods can throw exceptions we can catch them refrozen we have finally blocks where we can execute",
    "start": "1728070",
    "end": "1733920"
  },
  {
    "text": "code regardless of exceptions that's how we do it and on there in rust error",
    "start": "1733920",
    "end": "1739740"
  },
  {
    "text": "management is done through result we declare a method as fallible explicit",
    "start": "1739740",
    "end": "1745049"
  },
  {
    "text": "l√©a by making it return a result which may be one variant okay in this case unit will void or some error we can't",
    "start": "1745049",
    "end": "1753779"
  },
  {
    "text": "get at the okay result we've got exhaustively matching on the on the result that we get in handling the",
    "start": "1753779",
    "end": "1759480"
  },
  {
    "text": "potential error case the overwhelmingly most common thing that you're going to want to do if you get an error in rust",
    "start": "1759480",
    "end": "1765149"
  },
  {
    "text": "you simply punt it upstream for somebody else to do with and that's what that little question mark operator does when",
    "start": "1765149",
    "end": "1770700"
  },
  {
    "text": "we were in the body of a fallible method we can call other fallible methods we can use the question mark to early",
    "start": "1770700",
    "end": "1775980"
  },
  {
    "text": "return with an error and at that point we know if we're continuing then it's okay so we can use the okay variant and",
    "start": "1775980",
    "end": "1782190"
  },
  {
    "text": "that's how here error management and rust so what we really want is to use the idiomatic error management strategy",
    "start": "1782190",
    "end": "1789509"
  },
  {
    "text": "in either language we want to be able to return errors with Rask using question mark and we want those errors to throw",
    "start": "1789509",
    "end": "1795989"
  },
  {
    "text": "as exceptions in c-sharp that we might want to catch doing that demonstrates a",
    "start": "1795989",
    "end": "1803519"
  },
  {
    "text": "problem with our FFR though and that is that we're restricted in the kinds of data that we can send to and from the",
    "start": "1803519",
    "end": "1810059"
  },
  {
    "text": "boundary rusts result is as percent a special kind of enum that doesn't have a",
    "start": "1810059",
    "end": "1815429"
  },
  {
    "text": "representation in dotnet even though I'm sure you'd all really like there to be one so we can't just send the rest",
    "start": "1815429",
    "end": "1822299"
  },
  {
    "text": "result over the FFI boundary we have to declare our own and so that's what we do",
    "start": "1822299",
    "end": "1827309"
  },
  {
    "text": "that's what DB result is that Reaper see there is an attribute that says lay this thing out the same way that C would so",
    "start": "1827309",
    "end": "1833220"
  },
  {
    "text": "that we have a common ABI that we can use on c-sharp so DB result has a kind which is a",
    "start": "1833220",
    "end": "1838739"
  },
  {
    "text": "32-bit value it can be okay or an internal error or a couple of other variants depending on and what's going",
    "start": "1838739",
    "end": "1845249"
  },
  {
    "text": "on it also has a 32-bit ID so in totally our DB result is a 64-bit value that we",
    "start": "1845249",
    "end": "1851039"
  },
  {
    "text": "return from our FFA on its own though that DB result doesn't actually give us",
    "start": "1851039",
    "end": "1857369"
  },
  {
    "text": "a lot of information if we get an internal error that doesn't really tell us why we got one or what we can actually do about it so in order to send",
    "start": "1857369",
    "end": "1865769"
  },
  {
    "text": "diagnostic information across the FFI boundary we do the same thing that Windows does which is when an error",
    "start": "1865769",
    "end": "1871950"
  },
  {
    "text": "occurs we set some more diagnostic information in the last result a thread local buffer if we get an error in",
    "start": "1871950",
    "end": "1877649"
  },
  {
    "text": "c-sharp it could then read contents of their buffer and format them into an exception message so that's what this last result is all about what that",
    "start": "1877649",
    "end": "1885700"
  },
  {
    "text": "means is now in our binding function we can use the question mark operator which we hook into so if we're returning a DB",
    "start": "1885700",
    "end": "1892900"
  },
  {
    "text": "result and we question mark we automatically format that error into our thread local buffer and return with DB",
    "start": "1892900",
    "end": "1900130"
  },
  {
    "text": "result internal error on the c-sharp side we have an equivalent implementation of DB result it has a",
    "start": "1900130",
    "end": "1906430"
  },
  {
    "text": "kind and an ID it has a struct layout of sequential so it's laid out the same way that the rust one is and when we",
    "start": "1906430",
    "end": "1912520"
  },
  {
    "text": "encounter DB result we check it if it's okay we just return otherwise we get the",
    "start": "1912520",
    "end": "1918820"
  },
  {
    "text": "contents of that thread local buffer and we check the IDS match that's why it has an ID on it because if we don't check in",
    "start": "1918820",
    "end": "1925030"
  },
  {
    "text": "between an error then we won't we might end up formatting the wrong error message into our exception and things",
    "start": "1925030",
    "end": "1932380"
  },
  {
    "text": "will just get even more confusing so that's what DB result is all about it's",
    "start": "1932380",
    "end": "1937450"
  },
  {
    "text": "about error management and then let's have a look at ref so ref is about how we share data from c-sharp across the",
    "start": "1937450",
    "end": "1945400"
  },
  {
    "text": "boundary to rust so rust doesn't understand nets manage",
    "start": "1945400",
    "end": "1951970"
  },
  {
    "text": "pointers which we talked about before and c-sharp doesn't understand rusts references so in order to share data",
    "start": "1951970",
    "end": "1959260"
  },
  {
    "text": "across the boundary we use unmanaged pointers and on net we have this T star variant which is typed and we have the",
    "start": "1959260",
    "end": "1966310"
  },
  {
    "text": "untyped int pointer variant there are some subtleties with unmanaged pointers",
    "start": "1966310",
    "end": "1972550"
  },
  {
    "text": "though because as they are so named they are unmanaged whereas with manage pointers they integrate with the GC in",
    "start": "1972550",
    "end": "1978910"
  },
  {
    "text": "two interesting ways the first is that manage pointers participate in",
    "start": "1978910",
    "end": "1985570"
  },
  {
    "text": "determining the liveness of the point e so when we're checking whether or not our value is reachable if we can reach",
    "start": "1985570",
    "end": "1992320"
  },
  {
    "text": "it through a managed pointer we know that it is secondly when the GC performs the collection it may move objects",
    "start": "1992320",
    "end": "1998140"
  },
  {
    "text": "around in order to prevent fragmentation that means the actual address of a value can change basically between any two",
    "start": "1998140",
    "end": "2004620"
  },
  {
    "text": "statements when that does happen we will update manage pointers automatically so",
    "start": "2004620",
    "end": "2010320"
  },
  {
    "text": "you don't even need to know unmanaged pointers don't participate in any of that and if you end up running",
    "start": "2010320",
    "end": "2016610"
  },
  {
    "text": "afoul of either of those things then you create what's called a GC halt so in order to get the unmanaged address of",
    "start": "2016610",
    "end": "2023360"
  },
  {
    "text": "some managed data we have to be in an unsafe context and we use this fixed statement it means that within the body",
    "start": "2023360",
    "end": "2031160"
  },
  {
    "text": "of that fixed statement we won't collect the value that we've got the address of and we won't move it if a collection",
    "start": "2031160",
    "end": "2036980"
  },
  {
    "text": "occurs so that pointer is only valid for the scope of that fixed block once we",
    "start": "2036980",
    "end": "2043550"
  },
  {
    "text": "have one we can pass it to our FF I rust has its own version of unmanaged",
    "start": "2043550",
    "end": "2049310"
  },
  {
    "text": "pointers they're just rule pointers we have the star quantity version and we have a star",
    "start": "2049310",
    "end": "2054379"
  },
  {
    "text": "mutti version besides variants over t where star quantity is variant in star mutti is",
    "start": "2054380",
    "end": "2059540"
  },
  {
    "text": "invariant they're more or less the same thing you can freely coerce for a star constant to a star mute what they give",
    "start": "2059540",
    "end": "2066139"
  },
  {
    "text": "us is documentation as type style thing where you treat a star constants so you",
    "start": "2066140",
    "end": "2072860"
  },
  {
    "text": "shouldn't mutate it and if you have a star mute then you probably own it or at least have an exclusive reference so you can mutate it raw pointers in rust have",
    "start": "2072860",
    "end": "2082280"
  },
  {
    "text": "their own weird interactions with the safe memory management system in this case we can convert a raw pointer into a",
    "start": "2082280",
    "end": "2089210"
  },
  {
    "text": "safe reference but there is a subtlety and that is in that lifetime so we call",
    "start": "2089210",
    "end": "2095210"
  },
  {
    "text": "that lifetime tick unbounded because that's what it is typically in rust when you borrow data you borrow it based on a",
    "start": "2095210",
    "end": "2101840"
  },
  {
    "text": "borrow of something on the input in this case we don't have that so that lifetime is kind of hallucination it comes out of",
    "start": "2101840",
    "end": "2108290"
  },
  {
    "text": "nowhere and what or us will do if it encounters one of those is it will just use any lifetime that makes the code",
    "start": "2108290",
    "end": "2113870"
  },
  {
    "text": "compile so it's actually not a useful lifetime at all we could accidentally extend that value and use it after it's",
    "start": "2113870",
    "end": "2120200"
  },
  {
    "text": "valid which would be a really bad time so the ref type is here to fix that it",
    "start": "2120200",
    "end": "2126440"
  },
  {
    "text": "has a Reaper of transparent which in rust means that it has the same ABI as it's one sized field so in this case",
    "start": "2126440",
    "end": "2133220"
  },
  {
    "text": "when we receive a real pointer we simply interpret it as a ref and we get safety there's no there's no other changes to",
    "start": "2133220",
    "end": "2141980"
  },
  {
    "text": "the way that we passed the type that are needed we see that ref has a life tick fixed we call that lifetime tick",
    "start": "2141980",
    "end": "2148680"
  },
  {
    "text": "fixed because that represents the lifetime of the fixed block from which that real pointer was acquired and if we",
    "start": "2148680",
    "end": "2156269"
  },
  {
    "text": "remember from before we say that strikes in Rusk have a lifetime bound to the lifetimes of their fields then we say",
    "start": "2156269",
    "end": "2162480"
  },
  {
    "text": "that Ref can't outlive that fixed block from C sharp for which the real pointer is valid similarly rather than returning a",
    "start": "2162480",
    "end": "2170960"
  },
  {
    "text": "reference from our Ref that has an unbounded lifetime we bind it to a",
    "start": "2170960",
    "end": "2176279"
  },
  {
    "text": "borrow of the ref and if we remember the borrow the ref itself is only valid for the fixed block so the borrow of the",
    "start": "2176279",
    "end": "2182730"
  },
  {
    "text": "data we get out of it can only be valid for the fixed block and so that prevents us from being able to borrow data that",
    "start": "2182730",
    "end": "2188670"
  },
  {
    "text": "would outlive the point from which that data is actually valid then we go from C sharp so that's ref ref is about sharing",
    "start": "2188670",
    "end": "2197609"
  },
  {
    "text": "readable data from dotnet into rust now let's have a look at out so after is",
    "start": "2197609",
    "end": "2203759"
  },
  {
    "text": "about writer and the arguments or out parameters in c-sharp we have our parameters we usually use them because",
    "start": "2203759",
    "end": "2209309"
  },
  {
    "text": "we wish we had enums but we don't so we use our parameters but they're fairly",
    "start": "2209309",
    "end": "2214799"
  },
  {
    "text": "interesting in their own right because we're expected to initialize an out parameter as an optimization they may be",
    "start": "2214799",
    "end": "2221670"
  },
  {
    "text": "pointing to uninitialized memory to begin with because we can't read it without initializing it Russ doesn't",
    "start": "2221670",
    "end": "2229289"
  },
  {
    "text": "actually have a concept of out explicitly at least not yet so we declare our own out pointer it looks",
    "start": "2229289",
    "end": "2236789"
  },
  {
    "text": "fairly similar to ref it has that same tick fixed lifetime which once again represents a fixed block in c-sharp but",
    "start": "2236789",
    "end": "2243539"
  },
  {
    "text": "it's a little different because uninitialized memory in rust is rather",
    "start": "2243539",
    "end": "2248730"
  },
  {
    "text": "weird and tricky compared to uninitialized memory in net which is actually fairly hard to get ahold of so",
    "start": "2248730",
    "end": "2254910"
  },
  {
    "text": "in rust there is a lot of undefined behavior to be found by creating references to uninitialized data",
    "start": "2254910",
    "end": "2261480"
  },
  {
    "text": "it's especially undefined behavior to dereference uninitialized data but russ",
    "start": "2261480",
    "end": "2266759"
  },
  {
    "text": "may be doing that without you knowing him so for instance if we simply write a value bar through an exclusive reference",
    "start": "2266759",
    "end": "2273869"
  },
  {
    "text": "into an uninitialized value rust will move out of what was already there which is not valid because it was garbage",
    "start": "2273869",
    "end": "2279569"
  },
  {
    "text": "so for any arbitrary value the only valid way to initialize it and rust is by using this pointer right method it's",
    "start": "2279569",
    "end": "2285989"
  },
  {
    "text": "quite subtle so we create this out type to encapsulate that so we don't accidentally dereference uninitialized",
    "start": "2285989",
    "end": "2291839"
  },
  {
    "text": "memory and do something really weird there's one exception though that's fairly significant and that's this reed",
    "start": "2291839",
    "end": "2298559"
  },
  {
    "text": "trait so in rusts we can think of reed as like the reed side of streams in dotnet they allow us to pass a mutable",
    "start": "2298559",
    "end": "2305670"
  },
  {
    "text": "byte buffer that data will be read into and we can then use that we really want",
    "start": "2305670",
    "end": "2310920"
  },
  {
    "text": "to be able to pass an uninitialized byte buffer into this though because we don't want to have to initialize this enormous",
    "start": "2310920",
    "end": "2316259"
  },
  {
    "text": "buffer full of zeros only to immediately initialize it with some other values right away so this guy has to be defined",
    "start": "2316259",
    "end": "2322890"
  },
  {
    "text": "behavior even though there are some people in Ross community who would really like it not to be so what we say",
    "start": "2322890",
    "end": "2329099"
  },
  {
    "text": "is that when an out parameter is pointing just two raw bytes we have additional things that we can do with",
    "start": "2329099",
    "end": "2334589"
  },
  {
    "text": "them that we're sure are going to be ok we can get an exclusive reference to that uninitialized memory if we pinky",
    "start": "2334589",
    "end": "2341099"
  },
  {
    "text": "promise that we're not going to read it we can also initialize it with a slice of bytes because there's no drop",
    "start": "2341099",
    "end": "2346979"
  },
  {
    "text": "semantics associated with those bytes we're not going to create two copies of the same thing so that's what art is all",
    "start": "2346979",
    "end": "2355079"
  },
  {
    "text": "about referee out are about short-lived references from c-sharp data that we",
    "start": "2355079",
    "end": "2360299"
  },
  {
    "text": "share in rust and now let's have a look at this handle shared so it handles",
    "start": "2360299",
    "end": "2365880"
  },
  {
    "text": "really the meat and potatoes of how we build safety in the FFI we've looked at",
    "start": "2365880",
    "end": "2371039"
  },
  {
    "text": "short-lived data so far handles are for long live data data that is valid across",
    "start": "2371039",
    "end": "2376170"
  },
  {
    "text": "multiple MFI calls so we think of our handles as a pair there's a c-sharp component and a rust component to them",
    "start": "2376170",
    "end": "2383099"
  },
  {
    "text": "the c-sharp component manages ownership of some resource that was allocated in rust heap and the rust component manages",
    "start": "2383099",
    "end": "2389910"
  },
  {
    "text": "access to that resource so on the c-sharp side we take ownership of the rust value we make sure that it's",
    "start": "2389910",
    "end": "2396359"
  },
  {
    "text": "reclaimed using the tools that are available to dotnet that is using garbage collector we make sure that if",
    "start": "2396359",
    "end": "2402719"
  },
  {
    "text": "that resource is reclaimed it is only reclaimed once but c-sharp doesn't guarantee synchronization of access to",
    "start": "2402719",
    "end": "2409920"
  },
  {
    "text": "that resource so that's the responsibility of rust so the way that we declare our handles",
    "start": "2409920",
    "end": "2415679"
  },
  {
    "text": "in c-sharp to satisfy the contract is by using safe handle this is a thing that's been around Annette since like dawn",
    "start": "2415679",
    "end": "2421529"
  },
  {
    "text": "there too it's been out for a long time it's a class that wraps up a untyped",
    "start": "2421529",
    "end": "2428219"
  },
  {
    "text": "handle pointer to a handle it gives us some point to implement and how to know",
    "start": "2428219",
    "end": "2433380"
  },
  {
    "text": "whether or not the handle is valid and it gives us some code to implement to actually release the handle which will",
    "start": "2433380",
    "end": "2438959"
  },
  {
    "text": "mean calling some rust function to deallocate it we can't deallocate rust from c-sharp we have to call in to rust",
    "start": "2438959",
    "end": "2445079"
  },
  {
    "text": "to do it what hand what safe handle gives us is an implementation of dispose that",
    "start": "2445079",
    "end": "2451439"
  },
  {
    "text": "synchronizes the calling of that release handle that we can call manually and it gives us a finalizar",
    "start": "2451439",
    "end": "2457099"
  },
  {
    "text": "if you haven't worked with unmanaged data in dotnet before you might not have seen a finalizar",
    "start": "2457099",
    "end": "2462659"
  },
  {
    "text": "that's that little Tilda safe handle at the bottom there finalizar is really a way that we can plug code into the GC so",
    "start": "2462659",
    "end": "2470130"
  },
  {
    "text": "that we can run our own code when a collection runs over our value and in this case the finalizar make sure that",
    "start": "2470130",
    "end": "2476189"
  },
  {
    "text": "we call release handle so even if we don't manually dispose it it will get cleaned up for us safe handle inherits",
    "start": "2476189",
    "end": "2483839"
  },
  {
    "text": "from the sting called critical finalizer object in.net as a general rule pretty much anything that inherits from",
    "start": "2483839",
    "end": "2489869"
  },
  {
    "text": "critical something has some kind of runtime semantics associated with it in this case it makes sure that if we do",
    "start": "2489869",
    "end": "2495989"
  },
  {
    "text": "reach finalization then the finalizer aver handle runs after everything else just in case there are other objects we",
    "start": "2495989",
    "end": "2502199"
  },
  {
    "text": "collected that still need to access it so there's a lot of subtlety around cleaning up unmanaged resources and safe",
    "start": "2502199",
    "end": "2508199"
  },
  {
    "text": "handle takes care of those for us there's actually another subtlety as well around the synchronization of",
    "start": "2508199",
    "end": "2514409"
  },
  {
    "text": "Reclamation and that is safe handle make sure that we can't reclaim an unmanaged",
    "start": "2514409",
    "end": "2519599"
  },
  {
    "text": "resource while there might be unmanaged code using it and the way it does that is through reference counting so",
    "start": "2519599",
    "end": "2525719"
  },
  {
    "text": "internally our safe handle as a reference count because safe handle is understood by the dotnet runtime in the",
    "start": "2525719",
    "end": "2531899"
  },
  {
    "text": "P and VOC stub that we generated earlier it will generate code around our unmanaged function to increment the ref",
    "start": "2531899",
    "end": "2538199"
  },
  {
    "text": "count before our unmanaged call and then decrement it afterwards so that if we're",
    "start": "2538199",
    "end": "2543329"
  },
  {
    "text": "within DB read next here we can't release the handle it'll wait until we return so as an",
    "start": "2543329",
    "end": "2551100"
  },
  {
    "text": "example here's what one of our handles looks like it's fairly simple and we just say the handles invalid if it's",
    "start": "2551100",
    "end": "2556440"
  },
  {
    "text": "zero and calm releasing it call means calling a rust function even if that",
    "start": "2556440",
    "end": "2561930"
  },
  {
    "text": "function fails we guarantee that we've D allocated the resulting rust so return true in previous versions of death net",
    "start": "2561930",
    "end": "2568560"
  },
  {
    "text": "there used to be a whole lot of other fluffing around that you would have to do with handles like around constrained",
    "start": "2568560",
    "end": "2574560"
  },
  {
    "text": "execution regions and Hum managed code security those things don't exist in dotnet core so this is pretty much what",
    "start": "2574560",
    "end": "2579690"
  },
  {
    "text": "we need to do we don't guarantee that our handle will be reclaimed but neither does rust so that's probably okay so",
    "start": "2579690",
    "end": "2586590"
  },
  {
    "text": "that's what the c-sharp panels do they manage ownership the rest handles perform the actual allocation",
    "start": "2586590",
    "end": "2591660"
  },
  {
    "text": "de-allocation and they ensure that access is requested by c-sharp are free from data races because c-sharp doesn't",
    "start": "2591660",
    "end": "2598890"
  },
  {
    "text": "guarantee data race freedom on its own we have to do that on the rest side so",
    "start": "2598890",
    "end": "2604410"
  },
  {
    "text": "the way that we do that in rust is by using two traits and those traits are send in sync they both model part of",
    "start": "2604410",
    "end": "2611190"
  },
  {
    "text": "rust concurrency story that make sure at compile time that data is only used in ways that are",
    "start": "2611190",
    "end": "2616440"
  },
  {
    "text": "valid if you've written rust before you might have encountered send and sync but you might have only encountered them",
    "start": "2616440",
    "end": "2622110"
  },
  {
    "text": "because you didn't satisfy them and got some weird compiler error that didn't make a lot of sense salmon sink are what are called auto",
    "start": "2622110",
    "end": "2628620"
  },
  {
    "text": "traits auto traits in rust are automatically implemented for you based on the contents of your type so you",
    "start": "2628620",
    "end": "2634230"
  },
  {
    "text": "don't need to manually implement these unless you're doing something kind of weird which is exactly what we're doing so intuitively send and sync work like",
    "start": "2634230",
    "end": "2643380"
  },
  {
    "text": "this so send tells us whether or not it's safe to transfer ownership of some",
    "start": "2643380",
    "end": "2648390"
  },
  {
    "text": "value to another thread so on the left hand side we create some state and we move ownership into another thread from",
    "start": "2648390",
    "end": "2654330"
  },
  {
    "text": "that move keyword that requires send some types that aren't send include",
    "start": "2654330",
    "end": "2659640"
  },
  {
    "text": "unsynchronized ref counts like RC or types that use thread local state that's not actually going to make sense on the",
    "start": "2659640",
    "end": "2665370"
  },
  {
    "text": "other thread sink on the other hand tells us whether or not it's safe to concurrently access a value so on the",
    "start": "2665370",
    "end": "2671880"
  },
  {
    "text": "right hand side we don't reverse a ship into the thread we send a reference and we try and use it because both threads",
    "start": "2671880",
    "end": "2677160"
  },
  {
    "text": "may be accessing their value at the same time we require sync so some types that don't implement sync",
    "start": "2677160",
    "end": "2685470"
  },
  {
    "text": "by default of types that have unsynchronized interior mutability which",
    "start": "2685470",
    "end": "2690900"
  },
  {
    "text": "we're going to have a look at so we can think of send in sync they seem kind of",
    "start": "2690900",
    "end": "2695940"
  },
  {
    "text": "weird at the moment but we can think of them as modeling roughs concurrency story as relationships between its",
    "start": "2695940",
    "end": "2702810"
  },
  {
    "text": "fundamental reference types so send in sync tell us something about own types",
    "start": "2702810",
    "end": "2708990"
  },
  {
    "text": "and references to them so what thing tells us is that if an underlying value",
    "start": "2708990",
    "end": "2714540"
  },
  {
    "text": "is safe to access concurrently then a shared reference to that value is safe to send to other threads and this is",
    "start": "2714540",
    "end": "2720900"
  },
  {
    "text": "kind of the crux of how Rus guarantees data race freedom because if we can't send shared references to other threads",
    "start": "2720900",
    "end": "2727050"
  },
  {
    "text": "then we can't access a value concurrently and we're going to see that",
    "start": "2727050",
    "end": "2732120"
  },
  {
    "text": "exclusive references behave basically the same as owned values in this case so we say that an exclusive reference to T",
    "start": "2732120",
    "end": "2738300"
  },
  {
    "text": "is sync if the T itself is sync you may think that that actually gives us a",
    "start": "2738300",
    "end": "2743310"
  },
  {
    "text": "place to create a data race where we might have a shared reference to an exclusive reference so we can have shared exclusive references passed",
    "start": "2743310",
    "end": "2749850"
  },
  {
    "text": "around rus doesn't work like that an exclusive reference behind a shared reference becomes immutable so we don't",
    "start": "2749850",
    "end": "2756870"
  },
  {
    "text": "have a data race there one of the subtle ones is send so if an underlying value",
    "start": "2756870",
    "end": "2762510"
  },
  {
    "text": "is sent that doesn't tell us anything about a shared reference because it's not necessarily safe to access concurrently but we require that an",
    "start": "2762510",
    "end": "2769650"
  },
  {
    "text": "underlying value ascends if we want to send an exclusive reference to it to another thread which may seem kind of",
    "start": "2769650",
    "end": "2775590"
  },
  {
    "text": "weird because we're not actually sending the value we're sending a reference but in rust it's impossible for us to move",
    "start": "2775590",
    "end": "2781680"
  },
  {
    "text": "out of an exclusive reference using something like mem replace we can move out of it and replace it with a new value and that would only be valid to do",
    "start": "2781680",
    "end": "2788430"
  },
  {
    "text": "if the underlying value itself can be sent or moved into the thread that has the reference so that's what's and in",
    "start": "2788430",
    "end": "2796380"
  },
  {
    "text": "sync are all about if we think about what we need or what contract were given",
    "start": "2796380",
    "end": "2802500"
  },
  {
    "text": "by don't net we can figure out what our handles in rust with our values and rust need to do to satisfy data race freedom",
    "start": "2802500",
    "end": "2808650"
  },
  {
    "text": "so in dotnet we don't guarantee synchronization of values you can use the lock statement but",
    "start": "2808650",
    "end": "2814710"
  },
  {
    "text": "can also just use it incorrectly which is something we've done in the past so we need sync we need to guarantee that",
    "start": "2814710",
    "end": "2821940"
  },
  {
    "text": "whatever c-sharp does because it will try and access values concurrently that it's safe for that to be done similarly",
    "start": "2821940",
    "end": "2829369"
  },
  {
    "text": "finalization is an interesting case because even if we manually dispose a value and it doesn't reach finalization",
    "start": "2829369",
    "end": "2836460"
  },
  {
    "text": "sometimes we might forget and it will and dotnet will run that finalization code on another thread so it will move",
    "start": "2836460",
    "end": "2842730"
  },
  {
    "text": "out of our own managed resource from a different thread than the one that allocated it and so to do that we need",
    "start": "2842730",
    "end": "2848940"
  },
  {
    "text": "send so our handles need sand and sync and that leads us to two different",
    "start": "2848940",
    "end": "2854310"
  },
  {
    "text": "handle designs that achieve these bounds in different ways so we'll look at handles shared first it achieves send",
    "start": "2854310",
    "end": "2860580"
  },
  {
    "text": "and sink through interior mutability what that means is that it's just a simple pointer it relies on the",
    "start": "2860580",
    "end": "2865859"
  },
  {
    "text": "underlying value being send in sync it doesn't add any semantics of its own it's kind of what it looks like it looks",
    "start": "2865859",
    "end": "2871470"
  },
  {
    "text": "a bit like ref but there are some impulse here because our handle shed is semantically a shared reference we say",
    "start": "2871470",
    "end": "2878760"
  },
  {
    "text": "that our handle shared is send when I shared reference to the underlying value is in similarly for sync when our handle",
    "start": "2878760",
    "end": "2885390"
  },
  {
    "text": "shared satisfies these bounds then we can get and a shared reference to the underlying value so that's handle shed",
    "start": "2885390",
    "end": "2893630"
  },
  {
    "text": "handle exclusive is a bit different it achieves send and sink through inherited mutability it allows us to pull an",
    "start": "2893630",
    "end": "2900510"
  },
  {
    "text": "exclusive reference out of our handle exclusive value without creating data",
    "start": "2900510",
    "end": "2906540"
  },
  {
    "text": "races so it looks kind of similar to handle shared but there's a difference",
    "start": "2906540",
    "end": "2911970"
  },
  {
    "text": "it has this thread bound of thing in it you might be able to guess what that's about just from the name but we use it",
    "start": "2911970",
    "end": "2917520"
  },
  {
    "text": "to satisfy send in sync instead of the underlying value so we say that our candle exclusiva send when a thread",
    "start": "2917520",
    "end": "2923400"
  },
  {
    "text": "bound is sent and a handling squib is sync when a thread bound to sink and when they are we can get an exclusive",
    "start": "2923400",
    "end": "2928890"
  },
  {
    "text": "reference so how does that actually work how are we able to get an exclusive reference out of a handle that might be",
    "start": "2928890",
    "end": "2935910"
  },
  {
    "text": "shared from multiple threads the answer is three thread band so thread bound is this kind of weird type it allows us to",
    "start": "2935910",
    "end": "2944119"
  },
  {
    "text": "share values without creating data races by binding them to the thread that",
    "start": "2944119",
    "end": "2950700"
  },
  {
    "text": "originally created them so it's only possible to pull a reference out of our thread bound from a thread that",
    "start": "2950700",
    "end": "2955950"
  },
  {
    "text": "originally allocated it does√§√¥t by using a thread ID it stores the inner value in an unsafe cell which in rust allows us",
    "start": "2955950",
    "end": "2962700"
  },
  {
    "text": "to convert a shared reference to an exclusive reference otherwise it's undefined behavior and so we say that a",
    "start": "2962700",
    "end": "2969210"
  },
  {
    "text": "thread band is always sync because we synchronize on thread ID if they're not",
    "start": "2969210",
    "end": "2974250"
  },
  {
    "text": "the same then we don't give you a reference so we use this in seek because our read and write transactions are",
    "start": "2974250",
    "end": "2981270"
  },
  {
    "text": "naturally synchronous they're bound to a thread already we don't want to have to synchronize on them so the thread bound",
    "start": "2981270",
    "end": "2986760"
  },
  {
    "text": "just gives us a way to guarantee that we're doing the right thing and if we so",
    "start": "2986760",
    "end": "2993540"
  },
  {
    "text": "because we're fairly confident that we do the right thing and seek we also just compile a check out in release builds and so it just catches us in debug so in",
    "start": "2993540",
    "end": "3001310"
  },
  {
    "text": "getting a ROI we return a star mutti from an exclusive or from a shared borrow in rust that's important because",
    "start": "3001310",
    "end": "3008480"
  },
  {
    "text": "we need the exclusive borrow of the underlying value to be disjoint from the shared borrow that checks thread ID it's",
    "start": "3008480",
    "end": "3015650"
  },
  {
    "text": "a fairly subtle issue but if they weren't disjoint then we would have a shared reference that overlaps how",
    "start": "3015650",
    "end": "3021770"
  },
  {
    "text": "exclusive reference and that's undefined behavior so that's kind of subtle typically you don't need to build these",
    "start": "3021770",
    "end": "3027800"
  },
  {
    "text": "things though you can just use mutex so there was one additional subtlety with",
    "start": "3027800",
    "end": "3033380"
  },
  {
    "text": "thread bound it gives us sync but it doesn't give us sinned because we store the value in loan if our value reaches",
    "start": "3033380",
    "end": "3040370"
  },
  {
    "text": "finalization we still need for that underlying value to be safe to move into that finalization thread so some types",
    "start": "3040370",
    "end": "3048350"
  },
  {
    "text": "just aren't like that they have some thread local state so in comes deferred cleanup which is like thread bound",
    "start": "3048350",
    "end": "3055250"
  },
  {
    "text": "weirdness plus plus it's additionally odd it allows us to drop values that",
    "start": "3055250",
    "end": "3060350"
  },
  {
    "text": "aren't send without creating data races it looks kind of similar to our thread bounder has a thread ID but it doesn't",
    "start": "3060350",
    "end": "3067010"
  },
  {
    "text": "store the value inline it allocates it in thread local storage so we require to use to ecstatic because the underlying",
    "start": "3067010",
    "end": "3073850"
  },
  {
    "text": "value may live for the duration of that thread so we don't store it in line so",
    "start": "3073850",
    "end": "3079460"
  },
  {
    "text": "it's always safe to send the deferred cleanup which is itself a here to another thread you know accessing",
    "start": "3079460",
    "end": "3085010"
  },
  {
    "text": "underlying value we check it in the thread local storage which is only going to be correct for the thread that it was",
    "start": "3085010",
    "end": "3090110"
  },
  {
    "text": "allocated on we're deferred cleanup comes into its own is during cleanup so",
    "start": "3090110",
    "end": "3098390"
  },
  {
    "text": "when we drop lon deferred cleanup if we did it through disposing c-sharp in the happy path",
    "start": "3098390",
    "end": "3104000"
  },
  {
    "text": "we're on the correct thread we simply move out of our thread local storage if we're on a finalization thread then we",
    "start": "3104000",
    "end": "3110180"
  },
  {
    "text": "send a message to the original thread saying that it's got some garbage to clean up but it'll come back and deal",
    "start": "3110180",
    "end": "3115580"
  },
  {
    "text": "with later so we may end up having our values living for a lot longer than they otherwise would have",
    "start": "3115580",
    "end": "3121010"
  },
  {
    "text": "but projects like karate use a similar strategy like this already it's better",
    "start": "3121010",
    "end": "3126890"
  },
  {
    "text": "than creating data racism better than leaking data all together all right",
    "start": "3126890",
    "end": "3132170"
  },
  {
    "text": "so just to give you some examples of some handles that we have we have like a DB store this is an instance of our",
    "start": "3132170",
    "end": "3137900"
  },
  {
    "text": "database it's naturally Sam sink so we can stick it in handle shared we have a DB writer it is safe to send because it",
    "start": "3137900",
    "end": "3144200"
  },
  {
    "text": "hasn't a thread local state but it's not safe to access concurrently so we stick in a handle exclusive and it's bound to",
    "start": "3144200",
    "end": "3149870"
  },
  {
    "text": "a thread then we have something like a reader it has thread local state so we can't send it to another thread and we can't",
    "start": "3149870",
    "end": "3157220"
  },
  {
    "text": "access it concurrently so we need to stick it in an exclusive handle behind the deferred cleanup so that's a whole",
    "start": "3157220",
    "end": "3164900"
  },
  {
    "text": "lot of code that we've just looked at and a whole lot of concepts so let me give you an example of I'll show you",
    "start": "3164900",
    "end": "3172580"
  },
  {
    "text": "those concepts at work through our sample code base so we created a document perform through our UI this",
    "start": "3172580",
    "end": "3179840"
  },
  {
    "text": "time we will go and read that document back out and we'll see some of these Pete and own pieces in action okay so",
    "start": "3179840",
    "end": "3188750"
  },
  {
    "text": "I've issued a request a get request so the first thing that we do is we begin a retranslation in our c-sharp api doing",
    "start": "3188750",
    "end": "3197990"
  },
  {
    "text": "that means calling a binding function like we did before so this is what the bindings look like we have this maybe",
    "start": "3197990",
    "end": "3203780"
  },
  {
    "text": "check function and what maybe check does is it calls check on the DB result that we looked at earlier for us and so we",
    "start": "3203780",
    "end": "3210980"
  },
  {
    "text": "have our DLL import we have our calling convention we also specify exact spelling because you know",
    "start": "3210980",
    "end": "3216079"
  },
  {
    "text": "that does some stuff for us so back over on the rest side we're in our binding",
    "start": "3216079",
    "end": "3221150"
  },
  {
    "text": "code now what we're going to do is allocate our reader handle and so in",
    "start": "3221150",
    "end": "3228229"
  },
  {
    "text": "this case remember our reader is not safe to finalize on its own so we",
    "start": "3228229",
    "end": "3233660"
  },
  {
    "text": "allocated a deferred cleanup we're not going to have a look at the new the implementation of deferred cleanup new",
    "start": "3233660",
    "end": "3238939"
  },
  {
    "text": "goods really ugly and I don't want you see it so we allocated every return okay",
    "start": "3238939",
    "end": "3244959"
  },
  {
    "text": "now we're going to use some new bits from the dotnet core 3 SDK in order to",
    "start": "3244959",
    "end": "3254359"
  },
  {
    "text": "write our document back into the response stream so what we do is we",
    "start": "3254359",
    "end": "3259880"
  },
  {
    "text": "start an array we're going to enumerate all the documents in our database that",
    "start": "3259880",
    "end": "3266509"
  },
  {
    "text": "means calling a binding function so we call our binding function and now we're",
    "start": "3266509",
    "end": "3273109"
  },
  {
    "text": "back over in rust what we do is we get a reference to our reader handle we then",
    "start": "3273109",
    "end": "3279769"
  },
  {
    "text": "pull a document out and we read it into the C char provide buffer which in this case isn't out and so if we recall from",
    "start": "3279769",
    "end": "3286999"
  },
  {
    "text": "before it's OK for us to get a reference those uninitialized bytes from the out because we're going to read into them",
    "start": "3286999",
    "end": "3294109"
  },
  {
    "text": "without writing we're going to write into them in that reading so we've written our document so we return ok we",
    "start": "3294109",
    "end": "3302299"
  },
  {
    "text": "then return that we had some data so the buffer wasn't too small and we're not finished yet so we materialize some data",
    "start": "3302299",
    "end": "3310429"
  },
  {
    "text": "so in this case we have an eye memory owner and we have a range of the data that we wrote because data takes",
    "start": "3310429",
    "end": "3315619"
  },
  {
    "text": "ownership of the underlying buffer we don't just give it a span we give it the own memory we then write it as a value",
    "start": "3315619",
    "end": "3324249"
  },
  {
    "text": "so that means calling this writers write the string as a key all right the key as",
    "start": "3324249",
    "end": "3329839"
  },
  {
    "text": "a string and write the value as a property so this is part of the new system text JSON stuff so now we're",
    "start": "3329839",
    "end": "3337309"
  },
  {
    "text": "going to try and read the next document so we call our binding function we get a reference to our reader there are no",
    "start": "3337309",
    "end": "3344749"
  },
  {
    "text": "documents we only created one so we say that we're done so we end the array we've finished our",
    "start": "3344749",
    "end": "3351740"
  },
  {
    "text": "for each loop and now we dispose our read transaction because we're finished with it so we call another binding",
    "start": "3351740",
    "end": "3359660"
  },
  {
    "text": "function and we complete the reader and now we're going to drop out of fare",
    "start": "3359660",
    "end": "3366350"
  },
  {
    "text": "cleanup because we did the right thing we're on the right thread we call dispose and then we just move out of the",
    "start": "3366350",
    "end": "3373520"
  },
  {
    "text": "in a value we don't need to create any garbage on the queue and there's that document that we wrote earlier in the",
    "start": "3373520",
    "end": "3379700"
  },
  {
    "text": "session okay so we've looked at what a",
    "start": "3379700",
    "end": "3386420"
  },
  {
    "text": "hybrid app is why you might want to write one we've had a look at rust and we've had a look at c-sharp and some",
    "start": "3386420",
    "end": "3393440"
  },
  {
    "text": "features of the dotnet runtime so what might be coming up next for hybrid apps",
    "start": "3393440",
    "end": "3399050"
  },
  {
    "text": "in the future you might think that's something like wisdom as the technologies allows you to take your",
    "start": "3399050",
    "end": "3405380"
  },
  {
    "text": "favorite language in more places might give you no real need to create hybrid",
    "start": "3405380",
    "end": "3412790"
  },
  {
    "text": "apps so you can just take c-sharp everywhere and if that's aweso you if that's what floats your boat then that's awesome",
    "start": "3412790",
    "end": "3418970"
  },
  {
    "text": "it also gives us an opportunity to create more hybrid apps we can share components between c-sharp no JavaScript",
    "start": "3418970",
    "end": "3424880"
  },
  {
    "text": "runtime like if you have a query language for instance that you want to share an implementational you could do",
    "start": "3424880",
    "end": "3430190"
  },
  {
    "text": "that similarly shared compiled platforms like LLVM make it possible for us to stitch",
    "start": "3430190",
    "end": "3436100"
  },
  {
    "text": "languages together more tightly than ever before so those demos that I was showing you before where we could step",
    "start": "3436100",
    "end": "3441740"
  },
  {
    "text": "through c-sharp and rust in a single debug session where possible because we were using karate to compile our c-sharp",
    "start": "3441740",
    "end": "3448880"
  },
  {
    "text": "ahead of time statically linking in our rust library and so they're effectively one binary and so we debugging then",
    "start": "3448880",
    "end": "3456020"
  },
  {
    "text": "using ll DB rather than the core CLR debugger so that's that's pretty well",
    "start": "3456020",
    "end": "3464030"
  },
  {
    "text": "yep I hope you got something out of that that was a pretty whirlwind tour of rust so please come and find me we'll reach",
    "start": "3464030",
    "end": "3469430"
  },
  {
    "text": "out on Twitter or anywhere if you have any questions and thank you all very much",
    "start": "3469430",
    "end": "3474680"
  },
  {
    "text": "[Applause]",
    "start": "3474680",
    "end": "3482819"
  }
]