[
  {
    "start": "0",
    "end": "422000"
  },
  {
    "text": "hello ndc london good morning good afternoon good evening depending on wherever in the world you're watching it's just gone three o'clock in the uk",
    "start": "6799",
    "end": "13040"
  },
  {
    "text": "and it's time to talk about dependency injection just a quick introduction from me before",
    "start": "13040",
    "end": "18080"
  },
  {
    "text": "we get going my name is steve collins i've been programming in one form or another since the early 1980s",
    "start": "18080",
    "end": "23359"
  },
  {
    "text": "but professionally i've been doing it since the early 90s started with vb3 right the way through to now using.5",
    "start": "23359",
    "end": "28960"
  },
  {
    "text": "there's as many people on the internet with the same name as me i go by the alias of steve talks code for both my blog and my twitter handle",
    "start": "28960",
    "end": "36079"
  },
  {
    "text": "i've got a lot to packing in the next 55 minutes so i'll be leaving questions until the end of the talk and you can message me later in track",
    "start": "36079",
    "end": "42239"
  },
  {
    "text": "three slack channel so with the introductions out the way let's take a deep dive into dependency injection",
    "start": "42239",
    "end": "47280"
  },
  {
    "text": "and i promise no more pictures of needles hearing",
    "start": "47280",
    "end": "51360"
  },
  {
    "text": "as i say i've got a lot that i want to pack in so i've had to make a few assumptions about what you already know about dependency injection in dot net",
    "start": "54559",
    "end": "60559"
  },
  {
    "text": "core first is that most of you are familiar with using a hose builder of one flavor or another to go and create a container whilst you",
    "start": "60559",
    "end": "67439"
  },
  {
    "text": "can also create the container directly from the services collection without a hose builder i'm not going to focus on that too much in this talk",
    "start": "67439",
    "end": "75759"
  },
  {
    "text": "the next assumption is that you're familiar with using a startup class to register your services you'll be doing that using the configure",
    "start": "75920",
    "end": "82159"
  },
  {
    "text": "services method and then pointing the host builder to use your startup class",
    "start": "82159",
    "end": "87840"
  },
  {
    "text": "next there are various types of dependency injections supported by many ioc containers but for now you just need to be aware",
    "start": "89280",
    "end": "95360"
  },
  {
    "text": "that out of the box the dotnet call container only supports constructor injection now when i say donate core in the rest",
    "start": "95360",
    "end": "101840"
  },
  {
    "text": "of this talk i'm also including dot net 5 and beyond in that term though i will be calling out a couple of dot net 5 and c sharp 9 specifics later",
    "start": "101840",
    "end": "108880"
  },
  {
    "text": "on in the talk if you're using asp.net core you do get",
    "start": "108880",
    "end": "115040"
  },
  {
    "text": "to take advantage of method parameter injection as you can see here all you need to do is add the from services",
    "start": "115040",
    "end": "121040"
  },
  {
    "text": "attribute to the parameters you want injected from the container this means if you have many actions on",
    "start": "121040",
    "end": "126479"
  },
  {
    "text": "your controller that have different dependencies you can avoid injecting them all into the constructor of your controller that",
    "start": "126479",
    "end": "133599"
  },
  {
    "text": "makes your controllers and your action methods more aligned with the single responsibility principle from solid",
    "start": "133599",
    "end": "139920"
  },
  {
    "text": "usually if you want to go beyond the basic out the box experience of the microsoft container you need to go looking at using other containers which",
    "start": "139920",
    "end": "145680"
  },
  {
    "text": "i'll cover shortly as i mentioned there are other injection types that aren't supported in the",
    "start": "145680",
    "end": "152000"
  },
  {
    "text": "microsoft implementation these include property injection this is where a class is a parameter-less",
    "start": "152000",
    "end": "158160"
  },
  {
    "text": "constructor so dependencies have to be set via properties once the instance has been created",
    "start": "158160",
    "end": "163200"
  },
  {
    "text": "once all the properties have been set you then call a method typically use called something like initialize to go",
    "start": "163200",
    "end": "168239"
  },
  {
    "text": "and prepare the object for use next we have the named or key based valk",
    "start": "168239",
    "end": "174319"
  },
  {
    "text": "named or key based injection this is where you identify the dependency you need by using some key",
    "start": "174319",
    "end": "179760"
  },
  {
    "text": "value typically something like a string or an enum value whilst on the list we have the automated",
    "start": "179760",
    "end": "186080"
  },
  {
    "text": "service registration by convention which is a bit of a mouthful but in sure the container scans an assembly and",
    "start": "186080",
    "end": "191360"
  },
  {
    "text": "pulls out classes and interfaces to register based on a set of conventions or rules that you specify when you're setting it",
    "start": "191360",
    "end": "197040"
  },
  {
    "text": "up the good news is that whilst it's not supported in the outer box container",
    "start": "197040",
    "end": "202959"
  },
  {
    "text": "i'll be showing you some workarounds that you can implement so you don't have to go using another container",
    "start": "202959",
    "end": "210000"
  },
  {
    "text": "but why are there those other styles of injection not supported well the microsoft container is what's",
    "start": "210560",
    "end": "215680"
  },
  {
    "text": "known as a conforming container which is a fancy way of saying that it only supports the lowest common denominator of functionality",
    "start": "215680",
    "end": "222080"
  },
  {
    "text": "but it also acts as an abstraction that other containers can hook into via a common interface",
    "start": "222080",
    "end": "227280"
  },
  {
    "text": "you're probably aware that there are a number of other container frameworks out there that can be used with dot net and in this slide i show the ones that",
    "start": "227280",
    "end": "233200"
  },
  {
    "text": "are listed on the microsoft docs website as having been adapted or extended to work with the isos provider interface",
    "start": "233200",
    "end": "240159"
  },
  {
    "text": "the downside is that if you want to use the functionality that's not directly supported by the microsoft container",
    "start": "240159",
    "end": "245280"
  },
  {
    "text": "you have to manage your interactions with both containers side by side this means that you need to know how and",
    "start": "245280",
    "end": "251280"
  },
  {
    "text": "who is resolving your dependencies for you",
    "start": "251280",
    "end": "255840"
  },
  {
    "text": "historically if you were using.net core 2 you would usually wire up one of these containers in the configure services",
    "start": "256479",
    "end": "262479"
  },
  {
    "text": "method somewhere in the startup class and return an instance in the iservice provider",
    "start": "262479",
    "end": "268560"
  },
  {
    "text": "in the example here i'm using an autofag to register an autofocus module and return a new autofat container this",
    "start": "268560",
    "end": "275680"
  },
  {
    "text": "will change with.net call 3 but before i come on to that let's look at how your typical service registrations work",
    "start": "275680",
    "end": "283600"
  },
  {
    "text": "in this snippet here we have code that you're likely to be familiar with in this example we are just registering",
    "start": "283600",
    "end": "288800"
  },
  {
    "text": "some classes with the service collection and giving them different lifetimes as we've covered in most applications you'll be using the",
    "start": "288800",
    "end": "295360"
  },
  {
    "text": "host builder that initializes the service collection for you and add some default services once this",
    "start": "295360",
    "end": "300960"
  },
  {
    "text": "has been done it will then call your startup classes configure services method to add the registrations you have",
    "start": "300960",
    "end": "306479"
  },
  {
    "text": "specified as shown here after that it will then call the build service provider method on the service",
    "start": "306479",
    "end": "312639"
  },
  {
    "text": "collection to go and create the container instance based on the service registrations you've given in your method",
    "start": "312639",
    "end": "318400"
  },
  {
    "text": "once built the container is then used to resolve instances of services whenever they're required",
    "start": "318400",
    "end": "325280"
  },
  {
    "text": "now on the previous slide i said that when moving from.net call 2 to 3 or now.net 5 we are no longer",
    "start": "325280",
    "end": "331440"
  },
  {
    "text": "required to return the service provider in fact it's now actively discouraged if",
    "start": "331440",
    "end": "336800"
  },
  {
    "text": "you try and return the service provider from configure services you'll get a roslyn analyzer of warning",
    "start": "336800",
    "end": "341919"
  },
  {
    "text": "the reason for this is that since call 3 the way the service provider is created by the host builder has changed",
    "start": "341919",
    "end": "348000"
  },
  {
    "text": "what this also means is that whilst in asp.ket.net core core2 there was a small performance boost by",
    "start": "348000",
    "end": "353440"
  },
  {
    "text": "implementing the i startup interface when using the web host builder this is no longer supported in the generic host model",
    "start": "353440",
    "end": "361360"
  },
  {
    "text": "if you want to use an alternative container there is a used service provider factory extension method that you can",
    "start": "362720",
    "end": "368000"
  },
  {
    "text": "call when setting up the hose builder and that gets you the alternative container to resolve instances for",
    "start": "368000",
    "end": "373360"
  },
  {
    "text": "from your microsoft obstruction whilst that will register the custom",
    "start": "373360",
    "end": "379280"
  },
  {
    "text": "container you still need to go and perform any container specific configuration with the configure container method",
    "start": "379280",
    "end": "385120"
  },
  {
    "text": "you can do this using the configure container extension method on the host builder but to be honest it's a lot easier to do",
    "start": "385120",
    "end": "391039"
  },
  {
    "text": "in the startup class as shown here with an example for autofag whichever way you choose to do this",
    "start": "391039",
    "end": "396960"
  },
  {
    "text": "you receive a builder instance that's specific to the third-party container and allows you to use that container's own registration methods",
    "start": "396960",
    "end": "403680"
  },
  {
    "text": "so for example here autofact will provide a container builder where you can register its modules",
    "start": "403680",
    "end": "409360"
  },
  {
    "text": "it's important to note though that as the container is built by the host builder you cannot access the created container",
    "start": "409360",
    "end": "414880"
  },
  {
    "text": "until you get to the configure method where you where you access it from through the application services",
    "start": "414880",
    "end": "420840"
  },
  {
    "text": "property so having covered how the container gets built let's give some consideration to",
    "start": "420840",
    "end": "427199"
  },
  {
    "start": "422000",
    "end": "599000"
  },
  {
    "text": "the lifetimes of the object instances you want the container to create for you",
    "start": "427199",
    "end": "432560"
  },
  {
    "text": "now i'm sure that this is familiar territory but i've included it to make sure is that everyone is up to the same level of understanding before we start",
    "start": "433039",
    "end": "439199"
  },
  {
    "text": "delving a bit deeper firstly we have singletons these are created only once and live for the",
    "start": "439199",
    "end": "445199"
  },
  {
    "text": "duration of the container lifetime next we have transients our fair weather",
    "start": "445199",
    "end": "450560"
  },
  {
    "text": "friends that come and go as and when needed and last but not least we have scoped lifetimes",
    "start": "450560",
    "end": "455919"
  },
  {
    "text": "these stand between the other two but i'll cover them in more depth a little bit later the thing to consider with these",
    "start": "455919",
    "end": "462000"
  },
  {
    "text": "different lifetimes is that some play well with each other and others really should be kept apart so let's break it down",
    "start": "462000",
    "end": "469680"
  },
  {
    "text": "starting with the shortest lift of the lifetimes the transient can accept objects created with any of the three",
    "start": "469840",
    "end": "474879"
  },
  {
    "text": "lifetimes moving up through the lifetimes we next have the scope lifetime",
    "start": "474879",
    "end": "480160"
  },
  {
    "text": "which because it's slightly longer lived than a transient shouldn't have a transient lifetime in objects injected into it lastly",
    "start": "480160",
    "end": "488240"
  },
  {
    "text": "as the singleton is the longest lift of all this should only have other singletons injected into it and not the other two now i try to",
    "start": "488240",
    "end": "495520"
  },
  {
    "text": "choose my words carefully but when describing these relationships because there's a general misconception that it's not possible to inject",
    "start": "495520",
    "end": "501520"
  },
  {
    "text": "incompatible lifetimes into each other but that's not strictly true i can't speak for the other containers but the",
    "start": "501520",
    "end": "507680"
  },
  {
    "text": "microsoft container will not stop you if you have a singleton and its constructor requires an instance of",
    "start": "507680",
    "end": "512959"
  },
  {
    "text": "something that has been registered with a shorter lifetime transient or scoped the container will happily give you that instance",
    "start": "512959",
    "end": "519518"
  },
  {
    "text": "the problem is the instance that you get will have its lifetime promoted up to become the same as that as the receiving",
    "start": "519519",
    "end": "524800"
  },
  {
    "text": "instance in other words a transient instance will be locked into a singleton and not released until the singleton is disposed",
    "start": "524800",
    "end": "530720"
  },
  {
    "text": "of and that doesn't happen until the container is done and dusted this is known as a catching dependency",
    "start": "530720",
    "end": "537519"
  },
  {
    "text": "where the transient or scoped instance like the insect in amber shown here is imprisoned in an outer shell",
    "start": "537519",
    "end": "542720"
  },
  {
    "text": "which in our case is the singleton but you may be wanting to hit the pause button and go hang on",
    "start": "542720",
    "end": "548880"
  },
  {
    "text": "when i've done this before i've got an exception well yep that can happen by default it",
    "start": "548880",
    "end": "554399"
  },
  {
    "text": "only happens when your asp.net core environment variable variable even is set to development",
    "start": "554399",
    "end": "561600"
  },
  {
    "text": "this is done by some hidden magic that lies in the host builder however you can explicitly turn this behavior on",
    "start": "561600",
    "end": "567279"
  },
  {
    "text": "by setting the optional validate scopes parameter to true when creating the service provider",
    "start": "567279",
    "end": "572880"
  },
  {
    "text": "but this has a performance hit at startup so the general guidance is not to do it in production",
    "start": "572880",
    "end": "578160"
  },
  {
    "text": "and that's why the um hose builder only sets it for the development environment",
    "start": "578160",
    "end": "584160"
  },
  {
    "text": "also i haven't got time to cover it here today there's also a validate on build method that you can use to try and help",
    "start": "584160",
    "end": "589680"
  },
  {
    "text": "identify any registration problems at build time but it's fairly limited in the problems it can identify so how much",
    "start": "589680",
    "end": "595920"
  },
  {
    "text": "it gains you well not really sure so moving on given that singletons live",
    "start": "595920",
    "end": "603200"
  },
  {
    "text": "a long time and can be dangerous when mixing with other lifetimes let's consider why we actually use singletons in the typical use cases",
    "start": "603200",
    "end": "611839"
  },
  {
    "text": "given singletons can be accessed anywhere within the application things get a bit tricky if your application uses multiple threads",
    "start": "612399",
    "end": "619040"
  },
  {
    "text": "therefore singleton should ideally be stateless so you avoid threading complications",
    "start": "619040",
    "end": "624320"
  },
  {
    "text": "sometimes however you may well have some sort of state that you need to share these might be puzzled resources in",
    "start": "624320",
    "end": "630079"
  },
  {
    "text": "memory queues or some other type where you're in control of a limited resource that multiple things are dependent upon",
    "start": "630079",
    "end": "637120"
  },
  {
    "text": "factory classes i'll talk about later but typically these are created once and then their methods are called to create shorter lived instances of some",
    "start": "637120",
    "end": "644160"
  },
  {
    "text": "other dependency when required you may have an ambient singleton",
    "start": "644160",
    "end": "649519"
  },
  {
    "text": "which hides the complexity of accessing shorter lived objects something like the http context accessor",
    "start": "649519",
    "end": "654959"
  },
  {
    "text": "in asp.net core and that uses async local storage behind the scenes to avoid capture dependency",
    "start": "654959",
    "end": "660399"
  },
  {
    "text": "problems the last of the cases shown here is a mutable state",
    "start": "660399",
    "end": "665680"
  },
  {
    "text": "this is where you don't want to have to recreate a resource object over and over again when you know that the data within it",
    "start": "665680",
    "end": "671680"
  },
  {
    "text": "won't change while the application is running for example you might have some lookup data that you only want to read once from a slow repository",
    "start": "671680",
    "end": "677760"
  },
  {
    "text": "such as a database a file or a network service",
    "start": "677760",
    "end": "682639"
  },
  {
    "text": "if you really must have state give some thought to letting.net do some of the heavy lifting for you",
    "start": "684000",
    "end": "689920"
  },
  {
    "text": "if you have collections consider the concurrent collections namespace where the thread safe safety stuff has",
    "start": "689920",
    "end": "695440"
  },
  {
    "text": "been already done for you for read only properties make the underlying field read-only",
    "start": "695440",
    "end": "701519"
  },
  {
    "text": "so that if someone comes along later and makes it a read write property at least you're forcing them to have to do some work and give that",
    "start": "701519",
    "end": "707920"
  },
  {
    "text": "make them sort of stop and think about why am i changing this read-only property to a read write for those properties",
    "start": "707920",
    "end": "714880"
  },
  {
    "text": "that really must be read right you should maybe consider using a thread lock",
    "start": "714880",
    "end": "720880"
  },
  {
    "text": "so in this slide we can see that we're ensuring all property access is managed by the thread lock",
    "start": "721120",
    "end": "726240"
  },
  {
    "text": "that way we can ensure that the value is only changed by one thread at a time now the problem with this approach is",
    "start": "726240",
    "end": "732079"
  },
  {
    "text": "that by serializing the access of the property you will be getting a major performance hit as you're forcing everything that",
    "start": "732079",
    "end": "737920"
  },
  {
    "text": "touches that property down a narrow one at a time alleyway and you end up with threads queuing or even worse you may have a thread",
    "start": "737920",
    "end": "743760"
  },
  {
    "text": "deadlock so you may want to give some consideration to your design and maybe give some thought as to",
    "start": "743760",
    "end": "750959"
  },
  {
    "text": "whether you should need to use a thread lock or maybe use async local",
    "start": "750959",
    "end": "756160"
  },
  {
    "text": "i don't have a here for this but i'm just warning that if you've got that in your design and say a very multi-threaded application you",
    "start": "756160",
    "end": "763760"
  },
  {
    "text": "may want to go back and look at your design because it's very much a code smell lastly consider the impact of having",
    "start": "763760",
    "end": "770639"
  },
  {
    "text": "disposables in a singleton the problem here is that if you expose the disposed method and a consumer can",
    "start": "770639",
    "end": "777040"
  },
  {
    "text": "cause a hit everything else has lost access to the disposed resource which can cause an object disposed",
    "start": "777040",
    "end": "782399"
  },
  {
    "text": "exception to be raised elsewhere in the application you do still need to make sure the the",
    "start": "782399",
    "end": "788320"
  },
  {
    "text": "dispose method is there for the container to clean up after itself when it's done with the resource to get",
    "start": "788320",
    "end": "794320"
  },
  {
    "text": "around this maybe you should consider abstracting the class with an interface that exposes all the members except the dispose method that way if",
    "start": "794320",
    "end": "802079"
  },
  {
    "text": "the interface is registered as a service and not the concrete class when the instance is served up from the container",
    "start": "802079",
    "end": "807920"
  },
  {
    "text": "you have to put some you've put some guard rails in place that make it difficult for a consumer to accidentally call the disposed",
    "start": "807920",
    "end": "813680"
  },
  {
    "text": "on the instance that doesn't stop someone who wants to vandalize it and go and",
    "start": "813680",
    "end": "818959"
  },
  {
    "text": "cast it into the right type and call to spokes but there you go",
    "start": "818959",
    "end": "823920"
  },
  {
    "text": "for transients there's not really a lot to say other than just be careful about doing a lot of work in the constructor",
    "start": "824480",
    "end": "830560"
  },
  {
    "text": "the reason for this is you don't have control over when the instance is being created by the container this could have",
    "start": "830560",
    "end": "836560"
  },
  {
    "text": "a major performance hit on your application if they're doing lots of work getting data from a database say each time",
    "start": "836560",
    "end": "841600"
  },
  {
    "text": "they're created and there's lots of them being created if if you're transient must go off and",
    "start": "841600",
    "end": "847040"
  },
  {
    "text": "do some database work maybe do it through an explicit method call rather than in the constructor",
    "start": "847040",
    "end": "853920"
  },
  {
    "start": "853000",
    "end": "878000"
  },
  {
    "text": "moving on to scope lifetimes these need to be approached with caution and handle with care",
    "start": "855199",
    "end": "860399"
  },
  {
    "text": "in fact i've seen various blog posts and tweets where people have said that they abandoned from use on their projects",
    "start": "860399",
    "end": "866320"
  },
  {
    "text": "now i think that is a little bit drastic but i understand the reticence as they can come back and bite you when",
    "start": "866320",
    "end": "871600"
  },
  {
    "text": "you least expect it if used incorrectly so hopefully i can try and clear up some of the pain points",
    "start": "871600",
    "end": "878880"
  },
  {
    "text": "we've already covered how scoped instances should be used with other lifetimes but what exactly is a scope lifetime commonly you'll get",
    "start": "879199",
    "end": "887680"
  },
  {
    "text": "a quoted answer that they are created by asp.net core for an http request response lifetime",
    "start": "887680",
    "end": "892959"
  },
  {
    "text": "but that's not really the whole story whilst that is a common use case the",
    "start": "892959",
    "end": "898000"
  },
  {
    "text": "scope is not tied to asp you can go create your own scopes but that still doesn't answer what a scope",
    "start": "898000",
    "end": "903360"
  },
  {
    "text": "is as far as i'm concerned the scope is really there to ensure that objects created and resolved",
    "start": "903360",
    "end": "909360"
  },
  {
    "text": "are within a single unit of work and that they're consistent",
    "start": "909360",
    "end": "913839"
  },
  {
    "text": "so say you have several classes that all interact with each other and all depend on receiving the say an i widget instance in their",
    "start": "914800",
    "end": "920880"
  },
  {
    "text": "constructor you want to make sure that they all receive the same instance from the container rather than a transient which",
    "start": "920880",
    "end": "926240"
  },
  {
    "text": "will give you a new instance every time you want it so in that respect a scope lifetime is a bit like a",
    "start": "926240",
    "end": "931759"
  },
  {
    "text": "singleton in that you get the same instance that can be shared however outside that unit of work",
    "start": "931759",
    "end": "937759"
  },
  {
    "text": "boundary you expect to get a different instance so in that way it's a bit like transient",
    "start": "937759",
    "end": "942959"
  },
  {
    "text": "so to come back to the common use case of a web request if both bill and ted go and make a web request those request response pipelines",
    "start": "942959",
    "end": "950079"
  },
  {
    "text": "are individual units of work and are separated from each other therefore the scope instances that get",
    "start": "950079",
    "end": "955600"
  },
  {
    "text": "resolved for each of those pipeline requests are confined to each request response pipeline and they don't see each other",
    "start": "955600",
    "end": "961440"
  },
  {
    "text": "so very they're very much like transients in that way",
    "start": "961440",
    "end": "965759"
  },
  {
    "text": "away from the web you might be writing say a xamarin app or a console app you may want to manually go and create a",
    "start": "966639",
    "end": "972000"
  },
  {
    "text": "scope yourself this can be done by calling the create scope method on the iservice provider",
    "start": "972000",
    "end": "977120"
  },
  {
    "text": "instance this gives you back an eye service scope with a single property of service",
    "start": "977120",
    "end": "982399"
  },
  {
    "text": "provider which in turn is an instance of i service provider again but this time you've created a boundary",
    "start": "982399",
    "end": "988720"
  },
  {
    "text": "that can serve up scope services that's a bit of a mouthful to explain so maybe looking at how asp.net core does",
    "start": "988720",
    "end": "995199"
  },
  {
    "text": "it will provide some clarity as i say in asp.net call the creation of",
    "start": "995199",
    "end": "1000560"
  },
  {
    "text": "scopes is taken care of for you when the request response lifetime has started the server will create a load of service",
    "start": "1000560",
    "end": "1006880"
  },
  {
    "text": "features but the one we're interested in is the request service feature as i've described just now the scope",
    "start": "1006880",
    "end": "1013440"
  },
  {
    "text": "factory is used to create the scope as highlighted here that scope is then used to create the scope",
    "start": "1013440",
    "end": "1019759"
  },
  {
    "text": "service provider which is then accessed from http's contexts request services property as someone",
    "start": "1019759",
    "end": "1027120"
  },
  {
    "text": "writing an asp.net controller all of this is hidden away from you you don't really care",
    "start": "1027120",
    "end": "1032880"
  },
  {
    "text": "all you care about is specifying your dependencies in the constructor or the action method of your controller",
    "start": "1032880",
    "end": "1038400"
  },
  {
    "text": "or endpoint however there is one area in asp.net core where it's worth knowing what's",
    "start": "1038400",
    "end": "1043918"
  },
  {
    "text": "going on under the hood and that's middleware",
    "start": "1043919",
    "end": "1048480"
  },
  {
    "text": "when we talk about middleware we think about intercepting the hat and handling http requests and responses",
    "start": "1049840",
    "end": "1056000"
  },
  {
    "text": "now because you might not might assume that middleware is a scope sorry now because of that you might",
    "start": "1056000",
    "end": "1061679"
  },
  {
    "text": "assume that the middleware is escaped registration but that's not strictly true this is two different ways of writing middleware",
    "start": "1061679",
    "end": "1068720"
  },
  {
    "text": "the one that most people are familiar with is convention based middleware as shown here with this type of middleware you accept",
    "start": "1068720",
    "end": "1075120"
  },
  {
    "text": "a requested delegate in the constructor and then call it from within the invite async method to move to the next",
    "start": "1075120",
    "end": "1081200"
  },
  {
    "text": "middleware in the pipeline either before or after the delegate call is where you may go off and do your own",
    "start": "1081200",
    "end": "1087280"
  },
  {
    "text": "work for example you may go off and do some blogging in some cases you might be writing a",
    "start": "1087280",
    "end": "1092960"
  },
  {
    "text": "terminating middleware where you generate the response and you don't call the delegate next down the chain because you're handling it",
    "start": "1092960",
    "end": "1100400"
  },
  {
    "text": "the only time you might have passed it on is if you can't handle it",
    "start": "1100400",
    "end": "1105760"
  },
  {
    "text": "that's something like the static file middleware works if you have dependencies other than http",
    "start": "1105760",
    "end": "1111760"
  },
  {
    "text": "context you can add those as parameters to the ea invoke eighting method and they magically appear when the",
    "start": "1111760",
    "end": "1117600"
  },
  {
    "text": "method is called by the pipeline but how does this all happen",
    "start": "1117600",
    "end": "1123520"
  },
  {
    "text": "when you register middleware it's done in the configure method of the startup class at this point the container is already",
    "start": "1123520",
    "end": "1130000"
  },
  {
    "text": "baked so you're not adding the middleware to the container that's a sealed unit you can't go and mess about with it anymore",
    "start": "1130000",
    "end": "1136480"
  },
  {
    "text": "instead what you're doing is inserting a delegate into the invoke async method sorry a delegate to the invoke aging",
    "start": "1136480",
    "end": "1143520"
  },
  {
    "text": "method and that will be doing the actual work in the pipeline to do that a single instance of the",
    "start": "1143520",
    "end": "1149120"
  },
  {
    "text": "middleware class is created by the use middleware method when that single instance is created any",
    "start": "1149120",
    "end": "1154720"
  },
  {
    "text": "dependencies are resolved from the root container that's where the container stores your singletons and your transients",
    "start": "1154720",
    "end": "1162400"
  },
  {
    "text": "now as we saw earlier if the constructor is only called once when you request your transient scope dependency into the constructor they'll",
    "start": "1162400",
    "end": "1168799"
  },
  {
    "text": "become a capture dependency what you also need to bear in mind is",
    "start": "1168799",
    "end": "1174640"
  },
  {
    "text": "that the pipeline is created before the first request so you won't be able to access anything related to http context in the",
    "start": "1174640",
    "end": "1180720"
  },
  {
    "text": "constructor of your middleware as it doesn't exist at that point you're still building the pipeline as you're going if you do try that",
    "start": "1180720",
    "end": "1189039"
  },
  {
    "text": "you'll get an invalid operation exception because at that point the http context",
    "start": "1189039",
    "end": "1194799"
  },
  {
    "text": "doesn't exist so nothing can resolve it and kaboom it blows up in your face other scope",
    "start": "1194799",
    "end": "1201360"
  },
  {
    "text": "dependencies that are not part of the pipeline may well resolve but as i say they may become a capture",
    "start": "1201360",
    "end": "1207919"
  },
  {
    "text": "dependency so how does the request in that scope that is scoped get dealt with",
    "start": "1207919",
    "end": "1213679"
  },
  {
    "text": "well as the request moves through each layer of middleware and a pipeline the invocation method gets called",
    "start": "1213679",
    "end": "1219600"
  },
  {
    "text": "through the delegate chain not through some interface or an abstract contract to do this when the metaware is added to",
    "start": "1219600",
    "end": "1225840"
  },
  {
    "text": "the pipeline the request delegate is created the acts as a wrapper over your invoke",
    "start": "1225840",
    "end": "1231360"
  },
  {
    "text": "async method so as you can see here the request delegate is passed as a parameter to the middleware constructor",
    "start": "1231360",
    "end": "1237600"
  },
  {
    "text": "to enable the request to be passed down to the next one in the chain you're free to go and add any scopes and",
    "start": "1237600",
    "end": "1242960"
  },
  {
    "text": "transient dependencies parameters to the invoke async method if you need them to do some work so",
    "start": "1242960",
    "end": "1249039"
  },
  {
    "text": "rather than the the constructor by doing it in the average async that's being called",
    "start": "1249039",
    "end": "1254960"
  },
  {
    "text": "through by the middleware and you've got a scope at that point so we can resolve",
    "start": "1254960",
    "end": "1259919"
  },
  {
    "text": "them in the previous example i demonstrated how dependency injection works with the",
    "start": "1260840",
    "end": "1266000"
  },
  {
    "text": "convention-based middleware but what's less know well known is that there's also an interface way of doing",
    "start": "1266000",
    "end": "1271760"
  },
  {
    "text": "middleware the interface is eye middleware that interface is just one method in vocation which has the context and",
    "start": "1271760",
    "end": "1278640"
  },
  {
    "text": "request delegate passed in as parameters as this is a fixed signature of the interface you can't add your scope",
    "start": "1278640",
    "end": "1284799"
  },
  {
    "text": "parameters here so you have to go back and doing the constructor now i say don't do that for a convention",
    "start": "1284799",
    "end": "1291360"
  },
  {
    "text": "but what's happening is that it works in the opposite way round to convention",
    "start": "1291360",
    "end": "1296960"
  },
  {
    "text": "based because what you do is you go and register your new middleware with the container and behind the scenes",
    "start": "1296960",
    "end": "1303679"
  },
  {
    "text": "the use middleware will go and look at the container if it detects an eye middleware and get the container to create it",
    "start": "1303679",
    "end": "1309919"
  },
  {
    "text": "rather than do it all through reflection as it does with convention based",
    "start": "1309919",
    "end": "1314640"
  },
  {
    "text": "now i mentioned being careful with disposables earlier but i'd want to dig into it a little bit deeper with some edge cases",
    "start": "1316240",
    "end": "1323440"
  },
  {
    "text": "earlier i said you should hide the disposed method from consumers as the container will take care of disposing your singleton or your transient or",
    "start": "1324240",
    "end": "1331120"
  },
  {
    "text": "scoped when it's finished with it the last bit of the statement is true in",
    "start": "1331120",
    "end": "1337440"
  },
  {
    "text": "most cases as you can see here there are a couple of extension methods for creating singletons",
    "start": "1337440",
    "end": "1342480"
  },
  {
    "text": "where you can create the instance yourself the container's not giving it up you're viewing it up and the container won't dispose of those",
    "start": "1342480",
    "end": "1348480"
  },
  {
    "text": "for you because it hasn't created them if you do create an instance of a disposable class in this way that's a",
    "start": "1348480",
    "end": "1354880"
  },
  {
    "text": "bit of a problem namely that out the box there's no obvious re-entry point back into your",
    "start": "1354880",
    "end": "1360480"
  },
  {
    "text": "class to get to the configure services method or the startup class itself to get a reference to the instance to",
    "start": "1360480",
    "end": "1366000"
  },
  {
    "text": "then go and dispose it so why would you take that approach",
    "start": "1366000",
    "end": "1371519"
  },
  {
    "text": "the reason you may be creating an object in startup is to pass arguments to the constructor where the parameters cannot be cons",
    "start": "1371840",
    "end": "1378320"
  },
  {
    "text": "created by the container that you may have some third-party thing that needs something special that you just cannot create from your container",
    "start": "1378320",
    "end": "1385760"
  },
  {
    "text": "if that is the case you should maybe consider using a factory which i'll talk about in a little bit",
    "start": "1385760",
    "end": "1391919"
  },
  {
    "text": "if you've got no other way of really getting around this and you really must create your your instance inside your startup you do",
    "start": "1391919",
    "end": "1398960"
  },
  {
    "text": "have one last get out of jail card behind the scenes there's an interface that is automatically registered by the",
    "start": "1398960",
    "end": "1404960"
  },
  {
    "text": "host builder called ihost application lifetime this can be injected into the configure",
    "start": "1404960",
    "end": "1410480"
  },
  {
    "text": "method by adding it to the parameter list here you can register a handler for the application shutdown",
    "start": "1410480",
    "end": "1416480"
  },
  {
    "text": "which is past the object that you want to dispose of that's fine if you've just got one object because you specify",
    "start": "1416480",
    "end": "1423600"
  },
  {
    "text": "within that application shutdown method and a bit like evoke async you can add as many as you want",
    "start": "1423600",
    "end": "1430480"
  },
  {
    "text": "but it does get messy if you've got lots of them so what i would say is if you've got",
    "start": "1430480",
    "end": "1436080"
  },
  {
    "text": "maybe some four or five different disposables that need to be done in this way you might want to create",
    "start": "1436080",
    "end": "1441520"
  },
  {
    "text": "one wrapping disposable class that then presents those clas class instances for",
    "start": "1441520",
    "end": "1447360"
  },
  {
    "text": "you and then goes and disposes of them just taking that in through the contract the parameter",
    "start": "1447360",
    "end": "1454720"
  },
  {
    "text": "coming back to hiding the displays method if you cannot change the classes you don't own the source code",
    "start": "1456799",
    "end": "1461919"
  },
  {
    "text": "but it doesn't already have some abstraction but highest disposed method you may want to consider some of the",
    "start": "1461919",
    "end": "1467039"
  },
  {
    "text": "gang of four patterns such as facade adapter bridge or proxy these are all",
    "start": "1467039",
    "end": "1472240"
  },
  {
    "text": "variations of a theme where you can't create some kind of rapid class that encapsulates",
    "start": "1472240",
    "end": "1477520"
  },
  {
    "text": "your thing that you need to dispose the last point i want to make is a rare",
    "start": "1477520",
    "end": "1482720"
  },
  {
    "text": "one and a code smell but if you have a class that is what's known as a control freak",
    "start": "1482720",
    "end": "1488559"
  },
  {
    "text": "and insists on disposing instances passed into you into it then instead of getting the container to",
    "start": "1488559",
    "end": "1493760"
  },
  {
    "text": "create those instances maybe consider using a factory and the patterns i've just mentioned",
    "start": "1493760",
    "end": "1501760"
  },
  {
    "start": "1500000",
    "end": "1664000"
  },
  {
    "text": "next we have some gotchas that can come up and bite you when registering or consuming services from the container",
    "start": "1501760",
    "end": "1508320"
  },
  {
    "text": "consider what happens when the same service type gets registered multiple times against multiple implementations",
    "start": "1508799",
    "end": "1514640"
  },
  {
    "text": "now you may well be doing this deliberately because you have several implementations that you want to iterate through",
    "start": "1514640",
    "end": "1520640"
  },
  {
    "text": "these might be set validation rules for example or maybe a collection of processing types",
    "start": "1520640",
    "end": "1525919"
  },
  {
    "text": "that form an enrichment pipeline that you train together using the visitor pattern but it can happen by accident for",
    "start": "1525919",
    "end": "1532880"
  },
  {
    "text": "example you may have a get source code merge that's gone wrong where you heard one old registration and you've got a new",
    "start": "1532880",
    "end": "1539679"
  },
  {
    "text": "registration and it's merged and gone wrong and both of them suddenly appear",
    "start": "1539679",
    "end": "1544720"
  },
  {
    "text": "you may you'd be using extension methods and behind the scenes without you knowing about it that's going off and",
    "start": "1544720",
    "end": "1549760"
  },
  {
    "text": "registering a different implementation to the same interface or service that you're registering and you don't know about it whatever the",
    "start": "1549760",
    "end": "1557520"
  },
  {
    "text": "reason there can be unintended consequences because of the way the container works namely it works on a lasting wins",
    "start": "1557520",
    "end": "1564480"
  },
  {
    "text": "principle so if you use an extension method after your registration it'll be the extension methods",
    "start": "1564480",
    "end": "1570320"
  },
  {
    "text": "implementation that'll be the one that gets resolved by the container so if you need so you need to give some",
    "start": "1570320",
    "end": "1576000"
  },
  {
    "text": "thought as to the order in which you set up your dependencies and configure services so you may want to go and call extension",
    "start": "1576000",
    "end": "1581600"
  },
  {
    "text": "methods first before your services of course",
    "start": "1581600",
    "end": "1586880"
  },
  {
    "text": "if you're writing an extension method especially if you're publishing it onto a wider audience and say new game the",
    "start": "1586880",
    "end": "1592159"
  },
  {
    "text": "onus is on you to play nicely as we know there needs to be care around lifetimes and things get messy if there",
    "start": "1592159",
    "end": "1598799"
  },
  {
    "text": "are multiple registrations with different lifetimes so you may think you have registered a singleton but something comes along and",
    "start": "1598799",
    "end": "1605200"
  },
  {
    "text": "trumps it with a transient or scope registration now maybe that as i mentioned just now",
    "start": "1605200",
    "end": "1610480"
  },
  {
    "text": "you deliberately want multiple implementations but if we do want to avoid that happening accidentally",
    "start": "1610480",
    "end": "1616480"
  },
  {
    "text": "registering the same service multiple times there are two ways out the box to do this the first is to",
    "start": "1616480",
    "end": "1623520"
  },
  {
    "text": "use the variations of triad methods where the first registration is kept and subsequent registrations are ignored",
    "start": "1623520",
    "end": "1629760"
  },
  {
    "text": "so effectively we're telling the container to flip its concept of lasting wind principle on its head and now the first",
    "start": "1629760",
    "end": "1636320"
  },
  {
    "text": "in wins principal wins once you've got something in there no one else can come and override it",
    "start": "1636320",
    "end": "1642320"
  },
  {
    "text": "the second approach is to use the triad and numerable methods where both the service type and the implementation type is taken into",
    "start": "1642320",
    "end": "1648640"
  },
  {
    "text": "account so any examples here the triad singleton will result in just one registration",
    "start": "1648640",
    "end": "1654320"
  },
  {
    "text": "even though it's been called six times but the triad in the numerable will result in three registrations as the",
    "start": "1654320",
    "end": "1659520"
  },
  {
    "text": "implementation type is also taken into account",
    "start": "1659520",
    "end": "1663919"
  },
  {
    "start": "1664000",
    "end": "2058000"
  },
  {
    "text": "so that's some of the gotchas let's try and come up with some helpful hints and tricks now",
    "start": "1665279",
    "end": "1671120"
  },
  {
    "text": "if we flip what we took well i've just talked about on its head and you deliberately do want to register multiple implementations",
    "start": "1671919",
    "end": "1678799"
  },
  {
    "text": "the callers that need to iterate over it they need to know about it",
    "start": "1678799",
    "end": "1685919"
  },
  {
    "text": "how do how how does the consumer know that you've got multiple implementations so the way to do it is",
    "start": "1687440",
    "end": "1695039"
  },
  {
    "text": "they have to explicitly request the innumerable of the service type to get all those implementations",
    "start": "1695039",
    "end": "1701600"
  },
  {
    "text": "if you don't do this the instance you receive will either be the last or the first implementation registered",
    "start": "1701600",
    "end": "1707440"
  },
  {
    "text": "with the container depending on whether you use triad or not if the order of the innumerable is",
    "start": "1707440",
    "end": "1713520"
  },
  {
    "text": "important there needs to be a way of differentiating each instance without that the consumer will have to",
    "start": "1713520",
    "end": "1719679"
  },
  {
    "text": "rely on the order that the registers registrations were performed there are",
    "start": "1719679",
    "end": "1725200"
  },
  {
    "text": "lots of ways of handling that one is to create a comparer that implements the i comparable",
    "start": "1725200",
    "end": "1730399"
  },
  {
    "text": "interface for your service type that can then be used with an order by in link when that receives the enumerable",
    "start": "1730399",
    "end": "1736399"
  },
  {
    "text": "so you could do that inside your controller you could create a dedicated class that implements iron durable",
    "start": "1736399",
    "end": "1742720"
  },
  {
    "text": "and then recall a request an instance of that but for that to work you would need to inject the iron numerables",
    "start": "1742720",
    "end": "1748320"
  },
  {
    "text": "of the service type into it and then have some ordering logic in there and then you have to register your class",
    "start": "1748320",
    "end": "1753600"
  },
  {
    "text": "so that the consumer can then go and request your class from the container so it still adds it adding yet more",
    "start": "1753600",
    "end": "1759679"
  },
  {
    "text": "boilerplate lastly you could just write a lambda expression for i enumerable inside your",
    "start": "1759679",
    "end": "1765919"
  },
  {
    "text": "container registration that then serves up instances in the required order",
    "start": "1765919",
    "end": "1772240"
  },
  {
    "text": "going the other way around you may have a single class that's got multiple interfaces",
    "start": "1775360",
    "end": "1780960"
  },
  {
    "text": "especially if you've gone down the interface segregation principle from solid if you register the type of each",
    "start": "1780960",
    "end": "1786559"
  },
  {
    "text": "interface individually each registration creates a distinct instance when really what you probably want is",
    "start": "1786559",
    "end": "1792080"
  },
  {
    "text": "the same instance returned just through different interfaces especially if it's a singleton or scoped",
    "start": "1792080",
    "end": "1798320"
  },
  {
    "text": "if you want to access the same instance through those different interfaces you should register the instance first by its actual concrete class type",
    "start": "1798320",
    "end": "1806720"
  },
  {
    "text": "then what you can also do is you can use in lambda expressions using the get required service method of the iservice",
    "start": "1806720",
    "end": "1813200"
  },
  {
    "text": "provider to go and resolve the main instance from the container and return it by the interface",
    "start": "1813200",
    "end": "1818720"
  },
  {
    "text": "as i've got shown here in some cases you may want to aggregate",
    "start": "1818720",
    "end": "1824080"
  },
  {
    "text": "the interfaces together into a composite interface as shown here this may be a benefit if you don't want",
    "start": "1824080",
    "end": "1829600"
  },
  {
    "text": "consumers to be able to request the concrete implementation directly if you think back to the eye disposable",
    "start": "1829600",
    "end": "1834720"
  },
  {
    "text": "issue i mentioned earlier where you don't want the dispose method to be accessible by clients then you don't want the concrete",
    "start": "1834720",
    "end": "1840799"
  },
  {
    "text": "there because the dispose method will be there so in the example here i've registered",
    "start": "1840799",
    "end": "1845840"
  },
  {
    "text": "my my implementation using an aggregated interface rather than the disposable concrete",
    "start": "1845840",
    "end": "1850880"
  },
  {
    "text": "class itself i've then also registered the same singleton instance against the individual interfaces",
    "start": "1850880",
    "end": "1856480"
  },
  {
    "text": "to receive the same instance but this time calling back into the container to ask for the aggregate instance",
    "start": "1856480",
    "end": "1862880"
  },
  {
    "text": "interface as the service",
    "start": "1862880",
    "end": "1866880"
  },
  {
    "text": "next we have open generics where you define a type on the class type sorry type parameter on the class type",
    "start": "1868480",
    "end": "1875039"
  },
  {
    "text": "now the pla place you may be familiar with this in from a di perspective is the generic i logger t interface where you may be using it in",
    "start": "1875039",
    "end": "1881919"
  },
  {
    "text": "your controller constructors to get an eye logger instance that's typed to your controller",
    "start": "1881919",
    "end": "1887919"
  },
  {
    "text": "similarly you may be familiar with the eye options interfaces that get registered when you use the configure method that binds configuration to objects",
    "start": "1887919",
    "end": "1896398"
  },
  {
    "text": "if you want to register your own generic type the c-sharp syntax doesn't lend itself to referencing open generics",
    "start": "1896960",
    "end": "1902399"
  },
  {
    "text": "within a generic declaration the syntax just isn't there so instead",
    "start": "1902399",
    "end": "1907519"
  },
  {
    "text": "we have to use a non-generic registration method where we use the type of keyword to get the service and implementation types",
    "start": "1907519",
    "end": "1914000"
  },
  {
    "text": "without giving a closing type parameter in the case shown here the i do",
    "start": "1914000",
    "end": "1919120"
  },
  {
    "text": "something generic interface and the do something generic interface are shown with the angle brackets but",
    "start": "1919120",
    "end": "1924240"
  },
  {
    "text": "without a closing type parameter as this will be supplied by the consumer think back to how you call i",
    "start": "1924240",
    "end": "1929360"
  },
  {
    "text": "logger when you write a constructor on a controller you ask for i logger and then",
    "start": "1929360",
    "end": "1934640"
  },
  {
    "text": "you pass the type of your controller behind the scenes the container makes",
    "start": "1934640",
    "end": "1939919"
  },
  {
    "text": "use of the make generic type method on the type class to go and create a closed generic type",
    "start": "1939919",
    "end": "1945360"
  },
  {
    "text": "so it's just taking your your open generic and making the clothes generic type for example you'll do something generics",
    "start": "1945360",
    "end": "1953600"
  },
  {
    "text": "would be a do something generic of strings it then uses the type with a bit of",
    "start": "1953600",
    "end": "1958640"
  },
  {
    "text": "reflection magic to go and create a close generic instance that's the thing that's going to get returned back to your controller through",
    "start": "1958640",
    "end": "1966080"
  },
  {
    "text": "the container if you have if you haven't moved to dot",
    "start": "1966080",
    "end": "1972000"
  },
  {
    "text": "net 5 yet you may well hit a problem if your type definition includes a constraint on the generic",
    "start": "1972000",
    "end": "1977919"
  },
  {
    "text": "type such as limited to maybe being a class or the generic",
    "start": "1977919",
    "end": "1982960"
  },
  {
    "text": "has to implement a particular interface the problem is that we can make generic type",
    "start": "1982960",
    "end": "1989360"
  },
  {
    "text": "in dot net call two and three was that if you had a constraint on there he was throwing an argument",
    "start": "1989360",
    "end": "1995279"
  },
  {
    "text": "exception luckily that's where jimmy bogard who also mapped her mediator famous come to",
    "start": "1995279",
    "end": "2001760"
  },
  {
    "text": "the rescue he did a pull request though added a try catch block around the mate generic type",
    "start": "2001760",
    "end": "2007519"
  },
  {
    "text": "and it swallows that argument exception now this allows constrained generics to be resolved in donet5",
    "start": "2007519",
    "end": "2013519"
  },
  {
    "text": "right except it took him four years to get his pull request to be accepted",
    "start": "2013519",
    "end": "2020799"
  },
  {
    "text": "if you read jimmy's blog you get to understand why there's been very little change in the microsoft container since the first version of dot net core",
    "start": "2021360",
    "end": "2027919"
  },
  {
    "text": "in short you must ensure that all those other containers container technologies sorry that",
    "start": "2027919",
    "end": "2033440"
  },
  {
    "text": "implement the i service provider interface don't break which in turns means that you just can't",
    "start": "2033440",
    "end": "2038559"
  },
  {
    "text": "just go and fix something you have to go and write a whole load of unit tests that are not only show that",
    "start": "2038559",
    "end": "2044320"
  },
  {
    "text": "your change fixes something or brings something new to the container you have to go and show that your change",
    "start": "2044320",
    "end": "2050398"
  },
  {
    "text": "doesn't break those containers or messes up the way that those containers work",
    "start": "2050399",
    "end": "2057598"
  },
  {
    "start": "2058000",
    "end": "2440000"
  },
  {
    "text": "next i want to talk about a couple of so-called gang of four design patterns that are really relevant in the di container world",
    "start": "2059280",
    "end": "2066560"
  },
  {
    "text": "now throughout this talk i've touched on the factory pattern and you may be thinking well steve hang",
    "start": "2067760",
    "end": "2073040"
  },
  {
    "text": "on surely the whole purpose of a container is to be a factory of instances for me",
    "start": "2073040",
    "end": "2078720"
  },
  {
    "text": "why would i have to go and write a factory class well as we've seen there's a few gotchas",
    "start": "2078720",
    "end": "2084079"
  },
  {
    "text": "and few deficiencies within the containers so sometimes you have to give it a helping hand",
    "start": "2084079",
    "end": "2089839"
  },
  {
    "text": "for example you may have a class where some some of the constructor parameters are not known until runtime as they may",
    "start": "2090159",
    "end": "2095679"
  },
  {
    "text": "be captured from a user input in those cases you can't get a container to create the instance for you because",
    "start": "2095679",
    "end": "2101599"
  },
  {
    "text": "well the container won't know it because the user hasn't input them yet",
    "start": "2101599",
    "end": "2106560"
  },
  {
    "text": "now there are some workarounds it's not it's hideous but you could do",
    "start": "2107440",
    "end": "2113440"
  },
  {
    "text": "some hack with async local but that's really nasty stuff",
    "start": "2113440",
    "end": "2118480"
  },
  {
    "text": "similarly you may have an instance that when it gets created it's such a resource hog you want to get rid of it",
    "start": "2118960",
    "end": "2125200"
  },
  {
    "text": "really really quickly and if you're leaving it to the container to do that it's kind of a bit like garbage collection you're not",
    "start": "2125200",
    "end": "2130960"
  },
  {
    "text": "really control of when the when it's going to get disposed of and you don't want something hogging up all the memory or resources on your web",
    "start": "2130960",
    "end": "2137280"
  },
  {
    "text": "server so in that case what you want to be able to do is say i want this thing and i",
    "start": "2137280",
    "end": "2143200"
  },
  {
    "text": "want to be in control of when i dispose it lastly at the side of the talk i",
    "start": "2143200",
    "end": "2149440"
  },
  {
    "text": "mentioned that the microsoft container doesn't support property injection but by using a factory we can",
    "start": "2149440",
    "end": "2154880"
  },
  {
    "text": "effectively simulate property injection by getting the container to instantiate the class and then set the property",
    "start": "2154880",
    "end": "2160240"
  },
  {
    "text": "values before returning the fully prepared instance these are just a few cases where the factory pattern comes into its own",
    "start": "2160240",
    "end": "2168320"
  },
  {
    "text": "so as a very quick and very contrived example we have a class here that will register as a singleton",
    "start": "2168320",
    "end": "2175599"
  },
  {
    "text": "next we're going to create a class that consumes that singleton but also requires a name parameter in the constructor",
    "start": "2176320",
    "end": "2182240"
  },
  {
    "text": "now given that the name parameter cannot be known by the container as it will be provided by the runtime of",
    "start": "2182240",
    "end": "2187280"
  },
  {
    "text": "our api we can't add it to the configure services you may notice that we i've",
    "start": "2187280",
    "end": "2192320"
  },
  {
    "text": "used an immutable class here well i could have used a c sharp nine record",
    "start": "2192320",
    "end": "2197280"
  },
  {
    "text": "now we're going to create a factory class first we take the single term and cache it in the field as",
    "start": "2197920",
    "end": "2203920"
  },
  {
    "text": "shown in the blue highlighted constructor we then have a creation method that will go a new up our short-lived thing for us",
    "start": "2203920",
    "end": "2211440"
  },
  {
    "text": "using the cache singleton and the value passed into the method as the name parameter",
    "start": "2211440",
    "end": "2217440"
  },
  {
    "text": "next we add the factory to the configure services as a single turn and finally we'll give our control we",
    "start": "2218079",
    "end": "2223920"
  },
  {
    "text": "have our controller that will take our factory and its constructor later in the get action will then make",
    "start": "2223920",
    "end": "2229440"
  },
  {
    "text": "call the make method to go and create the instance of the short live thing very contrived i know but i wanted to",
    "start": "2229440",
    "end": "2235280"
  },
  {
    "text": "give a flavor of using the factory apologies for the small photo if you're watching on small screen but i had a lot had to pick into that slide",
    "start": "2235280",
    "end": "2243520"
  },
  {
    "text": "so to summarize factories usually you will register the factory as a singleton as most of the time you want it to be",
    "start": "2243520",
    "end": "2248560"
  },
  {
    "text": "stateless the variations are the parameters in the create method",
    "start": "2248560",
    "end": "2254400"
  },
  {
    "text": "as it's a singleton the only other dependencies that should be injected into it are the other singletons",
    "start": "2255040",
    "end": "2261280"
  },
  {
    "text": "if you need transients or scope dependencies you could take the i service provider itself as a constructor parameter",
    "start": "2261280",
    "end": "2266880"
  },
  {
    "text": "but proceed with caution directories of the eye service provider is considered a version of the service locator",
    "start": "2266880",
    "end": "2272720"
  },
  {
    "text": "anti-pattern the reason it's an anti-pattern is that you're becoming a tight coupling to the container interfaces",
    "start": "2272720",
    "end": "2278960"
  },
  {
    "text": "which in most cases you don't really want to do you want your classes to be completely oblivious to the container you just want to say",
    "start": "2278960",
    "end": "2284720"
  },
  {
    "text": "i want this dependency however the factory pattern classes fall into a group that i refer to as",
    "start": "2284720",
    "end": "2291040"
  },
  {
    "text": "servicing classes these are plugging the gaps in the container functionality that are effectively an extension to the",
    "start": "2291040",
    "end": "2297040"
  },
  {
    "text": "container so with this in mind i think as long as the factory classes are seen in that context",
    "start": "2297040",
    "end": "2302400"
  },
  {
    "text": "and you don't go referencing our service provider wholesale through your application that your domain stuff i'm",
    "start": "2302400",
    "end": "2308240"
  },
  {
    "text": "fairly relaxed about doing this because it's being pragmatic rather than dogmatic",
    "start": "2308240",
    "end": "2313520"
  },
  {
    "text": "if you're worried about factory classes exposing that anti-pattern and the tight coupling you could always create an abstract",
    "start": "2313520",
    "end": "2319760"
  },
  {
    "text": "interface but make and make that class private inside your startup class",
    "start": "2319760",
    "end": "2325040"
  },
  {
    "text": "so that way you only get to see the factory create methods not how you've gone and created that factory",
    "start": "2325040",
    "end": "2332240"
  },
  {
    "text": "variation of the factory pattern is the builder pattern where rather than prescribing which dependencies are needed up front and creating the",
    "start": "2334000",
    "end": "2340079"
  },
  {
    "text": "instance immediately the build is much more flexible the way i like to think of it is like ordering",
    "start": "2340079",
    "end": "2345760"
  },
  {
    "text": "drinks in a fast food restaurant in some places the factory is like the person",
    "start": "2345760",
    "end": "2350880"
  },
  {
    "text": "asking a person for a cola where they got a standardized dispenser with a fixed set of options and they just make you a standard drink",
    "start": "2350880",
    "end": "2358079"
  },
  {
    "text": "with the builder it's much more like the modern dispensers that you find in these places where you can say well i'm going to",
    "start": "2358079",
    "end": "2363599"
  },
  {
    "text": "start i've got base cola and i want to add a dash of lime and a dash of vanilla and a dash of cherry gradually composing up as you go along",
    "start": "2363599",
    "end": "2370160"
  },
  {
    "text": "until you've got your finished drink so with the builder we started much like",
    "start": "2370160",
    "end": "2376000"
  },
  {
    "text": "the factory by registering with the container however this time we register it as a",
    "start": "2376000",
    "end": "2381119"
  },
  {
    "text": "transient because you're going to be mutating the state of the builder once it's been created",
    "start": "2381119",
    "end": "2386560"
  },
  {
    "text": "in its constructor we take in other dependencies from the container consuming classes take the builder as a",
    "start": "2386560",
    "end": "2392000"
  },
  {
    "text": "constructor parameter and then start using the methods and properties to build up a new instance to be constructed then once we have the",
    "start": "2392000",
    "end": "2398720"
  },
  {
    "text": "configured and we've configured our builder with everything that we want we can go and call the build method to",
    "start": "2398720",
    "end": "2405119"
  },
  {
    "text": "go and create our instance now you're probably familiar with the builder method from the web host builder on the i host",
    "start": "2405119",
    "end": "2411280"
  },
  {
    "text": "builder that you use in your main to go and go and create your host",
    "start": "2411280",
    "end": "2416960"
  },
  {
    "text": "typically the resulting instance will be immutable the last thing to mention is that like",
    "start": "2417040",
    "end": "2422800"
  },
  {
    "text": "the factory if the instance you created out of the builder is disposable it's the caller that's just asked for it",
    "start": "2422800",
    "end": "2428960"
  },
  {
    "text": "to be created that needs to be responsible for disposing it so it needs to wrap it with a try catch",
    "start": "2428960",
    "end": "2434160"
  },
  {
    "text": "finally or the using syntax it's not the container's responsibility",
    "start": "2434160",
    "end": "2441280"
  },
  {
    "text": "so in this final section i want to talk about plugging in some of the gaps in functionality that the microsoft container is missing",
    "start": "2442240",
    "end": "2447839"
  },
  {
    "text": "i mentioned earlier that property injection is not supported out the box by the microsoft container but you can get around that by using the",
    "start": "2447839",
    "end": "2453760"
  },
  {
    "text": "factory or building to create the instance and set the properties before returning the instance from a crate or build",
    "start": "2453760",
    "end": "2460160"
  },
  {
    "text": "another place the way this can be useful is if you need to create instances of struct values where some of the properties come from",
    "start": "2460160",
    "end": "2465680"
  },
  {
    "text": "the container now the problem here is that you simply cannot register a value type with the microsoft di",
    "start": "2465680",
    "end": "2471200"
  },
  {
    "text": "container it's just not supported so you need to go and get all your dependencies and instantiate the value type it yourself",
    "start": "2471200",
    "end": "2480000"
  },
  {
    "start": "2478000",
    "end": "2510000"
  },
  {
    "text": "so here you see i'm attempting to try and add a struct type registration using generica the generic ad transient and here's the",
    "start": "2480000",
    "end": "2487280"
  },
  {
    "text": "resolution error to tell me that that's a no can do",
    "start": "2487280",
    "end": "2492240"
  },
  {
    "text": "you could think aha maybe it's just because i'm using the generic registration i'll try and use the non-generic version",
    "start": "2493440",
    "end": "2500319"
  },
  {
    "text": "yeah nice try but you don't you don't get the compile-time error but all you've done is kick the problem down the road to",
    "start": "2500319",
    "end": "2505920"
  },
  {
    "text": "become a runtime error so how do we get around this we simply create a root factory or",
    "start": "2505920",
    "end": "2512319"
  },
  {
    "start": "2510000",
    "end": "2533000"
  },
  {
    "text": "builder that takes in all the parameters we need to populate the value types now the example here is very contrived",
    "start": "2512319",
    "end": "2518160"
  },
  {
    "text": "and offers no benefit of just creating the object in your own code however if some of the properties that",
    "start": "2518160",
    "end": "2523599"
  },
  {
    "text": "need to be taken from the container this is where the factory can grab them in the constructor or via an io service",
    "start": "2523599",
    "end": "2529200"
  },
  {
    "text": "provider and then put them together with the method parameters",
    "start": "2529200",
    "end": "2534078"
  },
  {
    "start": "2533000",
    "end": "2577000"
  },
  {
    "text": "which leads us from value types to c sharp nine record types now i won't go into a lot of detail here",
    "start": "2535119",
    "end": "2541119"
  },
  {
    "text": "as i'm sorry it's quarter to four and i'm running short of time um but basically there are reference types",
    "start": "2541119",
    "end": "2546800"
  },
  {
    "text": "that behave like value types",
    "start": "2546800",
    "end": "2551839"
  },
  {
    "text": "and as their reference types you can register them with the container however given that record types are",
    "start": "2552160",
    "end": "2558000"
  },
  {
    "text": "mainly there for entities you're more likely to use the factory pattern to get for the same reasons as",
    "start": "2558000",
    "end": "2563119"
  },
  {
    "text": "i've said said before you you're very unlikely to go and create records out of the container",
    "start": "2563119",
    "end": "2568880"
  },
  {
    "text": "if you're interested in find out more i do have a blog post that shows how to write a record factory and that's a lot of the ideas that i've",
    "start": "2568880",
    "end": "2575200"
  },
  {
    "text": "just explained in the last few slides are in there next we have something that no one",
    "start": "2575200",
    "end": "2580640"
  },
  {
    "start": "2577000",
    "end": "2767000"
  },
  {
    "text": "really talks about in dependency injection with c sharp it's our little secret we nearly always",
    "start": "2580640",
    "end": "2586160"
  },
  {
    "text": "talk about classes and interfaces being registered with the container but delegates are also first-class citizens and you can also register them",
    "start": "2586160",
    "end": "2594000"
  },
  {
    "text": "now in theory you can register the anonymous delegates from the funk t family but these are hard to distinguish from",
    "start": "2594000",
    "end": "2600160"
  },
  {
    "text": "each other because they're just generic function signatures so instead we go old",
    "start": "2600160",
    "end": "2605440"
  },
  {
    "text": "school right back to c-sharp one to something that goes doesn't get much attention and that's custom delegates",
    "start": "2605440",
    "end": "2612720"
  },
  {
    "text": "now i'll go into details on my blog but to give you a quick example i really hate system date time now",
    "start": "2612720",
    "end": "2619599"
  },
  {
    "text": "property without passion because it's non-deterministic and by its very nature of being real time you just can't unit",
    "start": "2619599",
    "end": "2625920"
  },
  {
    "text": "test it but what we can do is to create a",
    "start": "2625920",
    "end": "2631680"
  },
  {
    "text": "delegate function that will call the system date time now property on our behalf the signature of our delegate in this",
    "start": "2631680",
    "end": "2637839"
  },
  {
    "text": "case is a function with no input parameters and it just returns a value of date time now",
    "start": "2637839",
    "end": "2644160"
  },
  {
    "text": "by creating the the delegate they're creating an abstraction without all the ceremony of furthering to first go and",
    "start": "2645040",
    "end": "2650560"
  },
  {
    "text": "create an interface and go then go create a class and implement that class and have that class then wrap that dreadful",
    "start": "2650560",
    "end": "2656880"
  },
  {
    "text": "static now property this makes your registration code much",
    "start": "2656880",
    "end": "2662480"
  },
  {
    "text": "cleaner as you don't need all that plumbing work it also feeds into the single responsibility principle as the delegate",
    "start": "2662480",
    "end": "2669200"
  },
  {
    "text": "just does one thing if you have multiple date time related functions you may still want to",
    "start": "2669200",
    "end": "2675119"
  },
  {
    "text": "use an interface in class but if those functions don't share any logic you could just go and create",
    "start": "2675119",
    "end": "2680160"
  },
  {
    "text": "multiple delegates this is where the custom delegates have the advantage over the funk t family",
    "start": "2680160",
    "end": "2685760"
  },
  {
    "text": "as the delegates can all have their same signature but they're distinguished by the delegate name",
    "start": "2685760",
    "end": "2692240"
  },
  {
    "text": "if you try and do this with the funk t family they may all have the same function signature and then you fall into the trap of",
    "start": "2692240",
    "end": "2698560"
  },
  {
    "text": "multiple registrations that all look and smell the same so you'd only get the last one unless",
    "start": "2698560",
    "end": "2703839"
  },
  {
    "text": "you ask for an innumerable and then how do you know which of your numerable ones is the one you want",
    "start": "2703839",
    "end": "2710000"
  },
  {
    "text": "so using the custom delegate from a unit testing point of view the delegates are very easy to mock and",
    "start": "2710319",
    "end": "2715920"
  },
  {
    "text": "create your own implementations as they're just function definitions",
    "start": "2715920",
    "end": "2721359"
  },
  {
    "text": "so in this case the function just returns a date time which for a unit test you can set to a",
    "start": "2721359",
    "end": "2726480"
  },
  {
    "text": "fixed value and you can conv there you can convert compare your fixed value in your research statements",
    "start": "2726480",
    "end": "2733838"
  },
  {
    "text": "now you may notice that i've registered the delegate as a singleton and maybe thinking well hang on",
    "start": "2734880",
    "end": "2740480"
  },
  {
    "text": "that daytime that gets returned will be captured the first time it called but that's not the case because we're",
    "start": "2740480",
    "end": "2745760"
  },
  {
    "text": "catching the delegate not the delegate's results we're just saying i've got this object",
    "start": "2745760",
    "end": "2751040"
  },
  {
    "text": "that represents a function not the function result you don't get the result until you actually invoke",
    "start": "2751040",
    "end": "2757200"
  },
  {
    "text": "that delegate and this is the same principle that we saw when we were talking about registering middleware and having a",
    "start": "2757200",
    "end": "2763280"
  },
  {
    "text": "delegate that wraps the invoke async method",
    "start": "2763280",
    "end": "2768000"
  },
  {
    "start": "2767000",
    "end": "2810000"
  },
  {
    "text": "so in this very contrived example i consume the delegate in the control controller constructor and cache it in a",
    "start": "2769119",
    "end": "2774960"
  },
  {
    "text": "field i then invoke here the time the constructor is run and cache that result in the field so that's the first time",
    "start": "2774960",
    "end": "2780400"
  },
  {
    "text": "i've invoked it in the get action i forced a three second delay",
    "start": "2780400",
    "end": "2785680"
  },
  {
    "text": "and then i called the delegate again i then take take the return string of both values as",
    "start": "2785680",
    "end": "2792480"
  },
  {
    "text": "you can see the results show that even though the delegate is a single turn the result is not generated into two invoked the first implication is",
    "start": "2792480",
    "end": "2799760"
  },
  {
    "text": "in the constructor of my controller the second is in the method hence the three second difference shown",
    "start": "2799760",
    "end": "2804960"
  },
  {
    "text": "in the result this is the same principle i described earlier about how middleware pipeline works",
    "start": "2804960",
    "end": "2811759"
  },
  {
    "start": "2810000",
    "end": "2869000"
  },
  {
    "text": "a feature that is supported by other containers such as auto effect is being able to specify dependency",
    "start": "2812560",
    "end": "2817680"
  },
  {
    "text": "to be resolved by the container using a string name or key now it's considered a bit of an anti-pattern because it comes back to",
    "start": "2817680",
    "end": "2823839"
  },
  {
    "text": "the idea of your application code shouldn't know about the container's mechanics but what if you could get get your",
    "start": "2823839",
    "end": "2830319"
  },
  {
    "text": "container to do it with the class having no knowledge of the container whatsoever so this occurred to me a",
    "start": "2830319",
    "end": "2836880"
  },
  {
    "text": "while ago when i had a situation where the i had where the type of a mapping algorithm to",
    "start": "2836880",
    "end": "2842240"
  },
  {
    "text": "use was determined at runtime by the value being returned from a database and rather than some have some hard",
    "start": "2842240",
    "end": "2847920"
  },
  {
    "text": "coded switch statement inside my repository that would need to be updated each time a new value came along into the database",
    "start": "2847920",
    "end": "2854319"
  },
  {
    "text": "i wanted something that could be injected from the container just to give me the mapping functionality i need",
    "start": "2854319",
    "end": "2859839"
  },
  {
    "text": "it's a bit long windy to describe here especially as i've only got 10 minutes left so there's a link to my blog post but to",
    "start": "2859839",
    "end": "2865760"
  },
  {
    "text": "give you an idea of what's involved i do have an example",
    "start": "2865760",
    "end": "2870720"
  },
  {
    "start": "2869000",
    "end": "2892000"
  },
  {
    "text": "first off we create a common interface with some classes so here we have a temperature converter",
    "start": "2871680",
    "end": "2877280"
  },
  {
    "text": "that takes different uh scales of centigrade fahrenheit rankine and kelvin",
    "start": "2877280",
    "end": "2883040"
  },
  {
    "text": "and converts them to kelvins so kelvin will be a one to one and you've got the different formula and i haven't looked at those formulas for",
    "start": "2883040",
    "end": "2889599"
  },
  {
    "text": "many many years now we will then register them all with the container as their actual types",
    "start": "2889599",
    "end": "2897040"
  },
  {
    "start": "2892000",
    "end": "2943000"
  },
  {
    "text": "following on from what i was saying about using delegates we also have a delegate declared that takes a string",
    "start": "2897040",
    "end": "2902559"
  },
  {
    "text": "as its input parameter then returns the required implementation of the i kelvin mapper interface",
    "start": "2902559",
    "end": "2908400"
  },
  {
    "text": "now in the code here i've got a simple switch statement based on character values but i could have done something a bit",
    "start": "2908400",
    "end": "2913520"
  },
  {
    "text": "more advanced and more flexible using dictionaries or possibly custom attributes",
    "start": "2913520",
    "end": "2918960"
  },
  {
    "text": "or maybe sort of using pattern matching with c sharp nine whichever way you choose it the delegate",
    "start": "2918960",
    "end": "2927119"
  },
  {
    "text": "is the secret source in which which allows us to lift the logic out of the consumer and up into the container",
    "start": "2927119",
    "end": "2933599"
  },
  {
    "text": "the consumer will use the delegate to pass the string in and get back the correct mapper instance that it needs in other words we have",
    "start": "2933599",
    "end": "2939920"
  },
  {
    "text": "something along the lines of an abstract factory pattern so now we've got our consumer that the",
    "start": "2939920",
    "end": "2947119"
  },
  {
    "start": "2943000",
    "end": "2975000"
  },
  {
    "text": "class is called get temperatures that has a method to take the scale as a string and a decimal value of the depth",
    "start": "2947119",
    "end": "2953599"
  },
  {
    "text": "that you want to go and convert into kelvins our class has no knowledge of the",
    "start": "2953599",
    "end": "2958800"
  },
  {
    "text": "containers service provider at this point or how the required implementation will get chosen based on our string",
    "start": "2958800",
    "end": "2964800"
  },
  {
    "text": "it just knows that it can pass the delegate a string and it will go and get a converter that",
    "start": "2964800",
    "end": "2970160"
  },
  {
    "text": "will return it back in the scale as specified by the string",
    "start": "2970160",
    "end": "2975040"
  },
  {
    "start": "2975000",
    "end": "3027000"
  },
  {
    "text": "the decorator is another gang of four pattern that can be used to extend the functionality of the class it does",
    "start": "2976640",
    "end": "2982480"
  },
  {
    "text": "this by wrapping and then re-implementing all the members but where necessary intercepting the incoming parameters and outgoing results",
    "start": "2982480",
    "end": "2989599"
  },
  {
    "text": "to do something else now a common example of where you would likely to do this is if you've got maybe",
    "start": "2989599",
    "end": "2995359"
  },
  {
    "text": "say something that um logs what's coming and logs what's got out",
    "start": "2995359",
    "end": "3002640"
  },
  {
    "text": "now you may have that on every mythical you may choose to have it just on some of them that that's your prerogative and that's",
    "start": "3002720",
    "end": "3008400"
  },
  {
    "text": "what your decorator does you you're not baking in you're not having to do anything special to your original class",
    "start": "3008400",
    "end": "3015839"
  },
  {
    "text": "to do this when you write your your decorating class you need to have the original class",
    "start": "3016079",
    "end": "3021119"
  },
  {
    "text": "injected into the decorating class along with any other dependencies which in our case is going to be a logger",
    "start": "3021119",
    "end": "3028319"
  },
  {
    "text": "so in this example we have a class called do something that implements the i do something interface",
    "start": "3028319",
    "end": "3035119"
  },
  {
    "text": "first we register the class as a concrete type and not through its interface",
    "start": "3035280",
    "end": "3040400"
  },
  {
    "text": "we then have a decorating class called logging do something and that takes the original do something",
    "start": "3040400",
    "end": "3046800"
  },
  {
    "text": "class and also requests an instance of ilogger it then re-implements the get hello",
    "start": "3046800",
    "end": "3052319"
  },
  {
    "text": "message method this time with code that intercepts the input and output do somethings version and write those out to the log",
    "start": "3052319",
    "end": "3060000"
  },
  {
    "text": "we then go back and register the new do log do logging do something against the i do",
    "start": "3061920",
    "end": "3068240"
  },
  {
    "text": "something interface which is used by consumers and you'll notice that the original one",
    "start": "3068240",
    "end": "3074240"
  },
  {
    "text": "i haven't used the interface that's to avoid the innumerable problem",
    "start": "3074240",
    "end": "3079520"
  },
  {
    "start": "3079000",
    "end": "3138000"
  },
  {
    "text": "the last missing feature from the microsoft container that is supported by others is registration services by",
    "start": "3081119",
    "end": "3086559"
  },
  {
    "text": "convention and assembly scanning now i'm not personally a big fan of doing that",
    "start": "3086559",
    "end": "3092079"
  },
  {
    "text": "because i'm a bit of a control freak and i like to know exactly what's going on",
    "start": "3092079",
    "end": "3097839"
  },
  {
    "text": "as we saw earlier it's possible for registrations to stamp all over each other depending on the order that they're registered",
    "start": "3097839",
    "end": "3105200"
  },
  {
    "text": "so how however i do get it if you've got masses of",
    "start": "3105200",
    "end": "3110559"
  },
  {
    "text": "classes to register and that could be a really laborious task i totally understand why you might",
    "start": "3110559",
    "end": "3115839"
  },
  {
    "text": "be looking for a shortcut this is where there's several offerings out out there but probably the most well",
    "start": "3115839",
    "end": "3121599"
  },
  {
    "text": "known is scooter where you can define rules and criteria for registering classes and interfaces",
    "start": "3121599",
    "end": "3127359"
  },
  {
    "text": "one nice thing i do like in scripture is the ability to register decorating classes with a much simpler syntax than",
    "start": "3127359",
    "end": "3132559"
  },
  {
    "text": "the hand crank version i showed in the previous slide",
    "start": "3132559",
    "end": "3139520"
  },
  {
    "start": "3138000",
    "end": "3199000"
  },
  {
    "text": "my final topic i just want to give a brief mention too is about performance some of your",
    "start": "3139520",
    "end": "3145839"
  },
  {
    "text": "registered classes may take a while to be instantiated which will hit you when an object is created for the first time and may",
    "start": "3145839",
    "end": "3151760"
  },
  {
    "text": "impact on your users if this is the case you may want to consider having some sort of background",
    "start": "3151760",
    "end": "3156960"
  },
  {
    "text": "hosted service that goes and starts up with the application and it goes and requests all the registered services from the",
    "start": "3156960",
    "end": "3162480"
  },
  {
    "text": "container this has two benefits namely singletons get instantiated",
    "start": "3162480",
    "end": "3167839"
  },
  {
    "text": "and are ready to go when the first consumer get requests them the second is that the transient and",
    "start": "3167839",
    "end": "3173680"
  },
  {
    "text": "scope instances benefit from jit compilation so even though the instances that you're currently creating with your background",
    "start": "3173680",
    "end": "3178880"
  },
  {
    "text": "service just get thrown away you're not you're not making use of them future instances that get created",
    "start": "3178880",
    "end": "3185359"
  },
  {
    "text": "they'll get created a little bit faster because the jit compiler has already done some of the work and it knows how to go and create them",
    "start": "3185359",
    "end": "3191200"
  },
  {
    "text": "so andrew locke has a really good blog post on this and i highly recommend reading it",
    "start": "3191200",
    "end": "3196880"
  },
  {
    "text": "so i've got about five minutes left that just about wraps it up from me uh",
    "start": "3196880",
    "end": "3202880"
  },
  {
    "start": "3199000",
    "end": "3294000"
  },
  {
    "text": "thank you for coming to my talk and i hope i provided some value even if it's only just one or two nuggets of gold that are hidden away in.net call",
    "start": "3202880",
    "end": "3210240"
  },
  {
    "text": "if you want to hear any more of my ramblings i'm on twitter quite a bit i do have a blog where i've written mainly about dependency injection and",
    "start": "3210240",
    "end": "3216559"
  },
  {
    "text": "configuration um before i go a few honorable mentions because i've stood on the shoulders of",
    "start": "3216559",
    "end": "3222319"
  },
  {
    "text": "giants in in this talk that he hasn't all come out of my brain andrew locke is a brilliant blog that",
    "start": "3222319",
    "end": "3228079"
  },
  {
    "text": "covers a lot all sorts of.net core related things and he's currently writing writing the second edition of asp.net core in action",
    "start": "3228079",
    "end": "3234720"
  },
  {
    "text": "which is available as an early preview ebook from manning the microsoft docs pages are well worth",
    "start": "3234720",
    "end": "3240079"
  },
  {
    "text": "a look especially if you're migrating from dot net core to dot net 3 or net 5. last but not least least",
    "start": "3240079",
    "end": "3247839"
  },
  {
    "text": "mark siemens blogs and books are well worth looking at to get a bigger picture of ddi patterns and anti-patterns",
    "start": "3247839",
    "end": "3254480"
  },
  {
    "text": "so he covers all sorts of and the the book i've got there it goes",
    "start": "3254480",
    "end": "3259680"
  },
  {
    "text": "through each of the different open source ones that are commonly used and then compares them to each other a",
    "start": "3259680",
    "end": "3265680"
  },
  {
    "text": "lot once you he's discussed how um the anti-patterns and the good patterns and",
    "start": "3265680",
    "end": "3271040"
  },
  {
    "text": "why you shouldn't write your own container and all that so with that said and just",
    "start": "3271040",
    "end": "3278319"
  },
  {
    "text": "under four minutes left um thank you for coming to the talk",
    "start": "3278319",
    "end": "3293839"
  },
  {
    "text": "you",
    "start": "3293839",
    "end": "3295920"
  }
]