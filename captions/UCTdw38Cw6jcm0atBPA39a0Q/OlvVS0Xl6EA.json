[
  {
    "text": "so today we're here talking about angular and the case for rxjs so arcgis",
    "start": "5470",
    "end": "12290"
  },
  {
    "text": "is reactive extensions for javascript it's a library for working with strings",
    "start": "12290",
    "end": "17599"
  },
  {
    "text": "of values that usually change over time the ArcGIS operators enable you to write",
    "start": "17599",
    "end": "24050"
  },
  {
    "text": "complex asynchronous code in a more declarative and composable manner and so",
    "start": "24050",
    "end": "30410"
  },
  {
    "text": "this reactive programming model was originally created at Microsoft for dotnet but there's an implementation in",
    "start": "30410",
    "end": "37670"
  },
  {
    "text": "nearly every major language at this point so arcgis is not just for angular and it can be used independently or it",
    "start": "37670",
    "end": "45199"
  },
  {
    "text": "can also be integrated just as easily into other frameworks like view i've even heard of people wanting to use rxjs",
    "start": "45199",
    "end": "53149"
  },
  {
    "text": "with reacts just because they like the way that it works so there's even a tc39",
    "start": "53149",
    "end": "58809"
  },
  {
    "text": "proposal to add rxjs as main data type the observable to be included in a coma",
    "start": "58809",
    "end": "65210"
  },
  {
    "text": "script 7 as an integral part of java scripts that proposal has been sitting at stage 1 but the point that I'm trying",
    "start": "65210",
    "end": "72290"
  },
  {
    "text": "to make here is that this declarative stream based architecture approach is",
    "start": "72290",
    "end": "77360"
  },
  {
    "text": "quite popular and widely adopted so as I talked about Kristen Bell a little bit",
    "start": "77360",
    "end": "84260"
  },
  {
    "text": "here I just wanted to do a Content warning about the TV show Veronica Mars it does have some heavy plot points",
    "start": "84260",
    "end": "91700"
  },
  {
    "text": "where she's kind of a young teenager and then later in life you know grows up",
    "start": "91700",
    "end": "96710"
  },
  {
    "text": "into running the private private detective agency she's she's along for the ride here to help us crack the case",
    "start": "96710",
    "end": "103070"
  },
  {
    "text": "but this is about as spicy as we're gonna get we're not going to talk about any of those heavy stuff so this is also",
    "start": "103070",
    "end": "111800"
  },
  {
    "text": "from a show called hot ones it's on YouTube if you enjoy spice which like I",
    "start": "111800",
    "end": "118280"
  },
  {
    "text": "do they take there it's an interview show and they take the people through a",
    "start": "118280",
    "end": "125000"
  },
  {
    "text": "series of chicken wings covered in progressively hotter hot sauce although",
    "start": "125000",
    "end": "130190"
  },
  {
    "text": "number eight is probably the highest on the list and it goes up to ten so I don't know about the progression myself",
    "start": "130190",
    "end": "137030"
  },
  {
    "text": "but I don't that capsaicin extract so this was from",
    "start": "137030",
    "end": "142740"
  },
  {
    "text": "her episode of hot ones and it's quite a good interview show they get quite a lot of celebrities on there and because of",
    "start": "142740",
    "end": "148650"
  },
  {
    "text": "the endorphins from the hot sauce things can get pretty real so it's a pretty fun show to watch so anyway let's let's talk",
    "start": "148650",
    "end": "157140"
  },
  {
    "text": "about rxjs so when I first encountered",
    "start": "157140",
    "end": "163470"
  },
  {
    "text": "observables in angular I just I've got a confession I wasn't really totally sure what I was working with I'd work with",
    "start": "163470",
    "end": "169740"
  },
  {
    "text": "promises and react and angularjs and then that syntax of chaining operators and then subscribing for your final",
    "start": "169740",
    "end": "176250"
  },
  {
    "text": "result I was like okay that seems familiar like we're just doing HTTP requests and they they'll complete after",
    "start": "176250",
    "end": "183750"
  },
  {
    "text": "the one result instead of being a stream of values over time and it wasn't really",
    "start": "183750",
    "end": "189480"
  },
  {
    "text": "until I wrote my first type-ahead search that things really started to set in so there are a number of key differences",
    "start": "189480",
    "end": "196140"
  },
  {
    "text": "between observables and promises the main difference is that promises can",
    "start": "196140",
    "end": "201600"
  },
  {
    "text": "only ever yield a single value whereas observables can emit multiple values",
    "start": "201600",
    "end": "207450"
  },
  {
    "text": "over time another advantage of observables is that they are cancelable",
    "start": "207450",
    "end": "213360"
  },
  {
    "text": "with unsubscribe promises don't have a cancellation mechanism promises are",
    "start": "213360",
    "end": "219750"
  },
  {
    "text": "always asynchronous but the series of values emitted by observables it's",
    "start": "219750",
    "end": "224970"
  },
  {
    "text": "usually asynchronous but it can just as well be synchronous like a range of values promises are eager whereas",
    "start": "224970",
    "end": "233850"
  },
  {
    "text": "observables are lazy and what I mean by that is an initialized promise",
    "start": "233850",
    "end": "238860"
  },
  {
    "text": "represents some process that has already started happening but observables are",
    "start": "238860",
    "end": "245040"
  },
  {
    "text": "declarative so they're just the definition of how to handle an event stream they represent what would happen",
    "start": "245040",
    "end": "251940"
  },
  {
    "text": "but not how not when nothing happens until your observable has a subscriber",
    "start": "251940",
    "end": "258870"
  },
  {
    "text": "and that describes the how and when so observables have different chaining",
    "start": "258870",
    "end": "264420"
  },
  {
    "text": "mechanisms for different mechanisms for chaining and subscriptions where your",
    "start": "264420",
    "end": "269940"
  },
  {
    "text": "promises are only going to have then clauses and promises don't really differentiate as much between the",
    "start": "269940",
    "end": "276620"
  },
  {
    "text": "transformational than clauses and then clauses that are responsible for your final execution observables can be",
    "start": "276620",
    "end": "284340"
  },
  {
    "text": "reused by multiple subscribers and can also be set up to be retried but",
    "start": "284340",
    "end": "289650"
  },
  {
    "text": "promises will only execute once however promises are always multicast where the",
    "start": "289650",
    "end": "296880"
  },
  {
    "text": "same producer can be shared among multiple consumers but observables are",
    "start": "296880",
    "end": "301889"
  },
  {
    "text": "unicast by default we'll get more into that multicast versus unicast here in a",
    "start": "301889",
    "end": "306990"
  },
  {
    "text": "few so observables can be created and your transformations defined but they",
    "start": "306990",
    "end": "312780"
  },
  {
    "text": "won't run until there's a consumer or subscriber promises are going to execute immediately on creation here so this",
    "start": "312780",
    "end": "320280"
  },
  {
    "text": "just kind of describes what you do with each of the promises in each case and then unsubscribing from an observable",
    "start": "320280",
    "end": "327090"
  },
  {
    "text": "causes the listener not to receive anymore values and it will cancel the work but promises will complete once",
    "start": "327090",
    "end": "334590"
  },
  {
    "text": "they're rejected or resolved and they can't be cancelled once they're initialized there's nothing to do with",
    "start": "334590",
    "end": "340320"
  },
  {
    "text": "the unsubscribe observables are kind of more comparable to events in JavaScript",
    "start": "340320",
    "end": "347940"
  },
  {
    "text": "in that you define notification handlers and use them to process multiple values over time so if you want to compare some",
    "start": "347940",
    "end": "355349"
  },
  {
    "text": "point maybe that's a good one subscribing to an observable is a lot like adding an event listener one of the",
    "start": "355349",
    "end": "362460"
  },
  {
    "text": "main differences though is that observables don't tend to share the execution of event with multiple",
    "start": "362460",
    "end": "368820"
  },
  {
    "text": "listeners on their own that's more of a unicast versus multicast events just use",
    "start": "368820",
    "end": "375000"
  },
  {
    "text": "callbacks but observables do have the advantage of being able to transform values before passing them on to the",
    "start": "375000",
    "end": "381539"
  },
  {
    "text": "handler so to lay out some of this initial groundwork about observables",
    "start": "381539",
    "end": "388229"
  },
  {
    "text": "let's talk about the three main types in rxjs we've got the observable the",
    "start": "388229",
    "end": "393660"
  },
  {
    "text": "observer and the subscription that connects the two the observer is a",
    "start": "393660",
    "end": "398729"
  },
  {
    "text": "wrapper around the producer of events the subscription represents the",
    "start": "398729",
    "end": "405009"
  },
  {
    "text": "cick you ssin of those events and the observer is the consumer of those events",
    "start": "405009",
    "end": "410650"
  },
  {
    "text": "and the observer will have next error and complete notifications that it could",
    "start": "410650",
    "end": "415689"
  },
  {
    "text": "receive on that subscription from the observable so your observable is the",
    "start": "415689",
    "end": "422259"
  },
  {
    "text": "most basic building block of Arc's jeaious it's just a function that takes a consumer and connects it to a producer",
    "start": "422259",
    "end": "429039"
  },
  {
    "text": "when we subscribe to an observable with an observer we get back a subscription",
    "start": "429039",
    "end": "434289"
  },
  {
    "text": "that gives us a means to cancel the work and unsubscribe the observer is an",
    "start": "434289",
    "end": "441159"
  },
  {
    "text": "object that implements the observer interface by providing those next and",
    "start": "441159",
    "end": "446189"
  },
  {
    "text": "optionally your error and complete methods corresponding to those values or",
    "start": "446189",
    "end": "451899"
  },
  {
    "text": "notifications that observable can deliver next notifications are the most",
    "start": "451899",
    "end": "457209"
  },
  {
    "text": "important and most common type of value coming from an observable they represent",
    "start": "457209",
    "end": "462459"
  },
  {
    "text": "that actual data that's being delivered to an observer err incomplete notifications however can only happen",
    "start": "462459",
    "end": "469779"
  },
  {
    "text": "once during an observable execution and you'll only ever see one or the other",
    "start": "469779",
    "end": "474909"
  },
  {
    "text": "and nothing else can be delivered after you get an error or a complete so again",
    "start": "474909",
    "end": "482620"
  },
  {
    "text": "to reiterate an observable function is only executed then when that observer",
    "start": "482620",
    "end": "487689"
  },
  {
    "text": "subscribes to it so an observable is a lazy computation it only happens on",
    "start": "487689",
    "end": "493719"
  },
  {
    "text": "subscribe the subscription represents that ongoing execution the actual",
    "start": "493719",
    "end": "499509"
  },
  {
    "text": "reality of events so it has a minimal API that lets you unsubscribe and cancel",
    "start": "499509",
    "end": "506469"
  },
  {
    "text": "from that subscription ascription a subscription will live on until the observable terminates by completion or",
    "start": "506469",
    "end": "513219"
  },
  {
    "text": "error or until you manually unsubscribe every observable emits zero or more next",
    "start": "513219",
    "end": "520990"
  },
  {
    "text": "notifications and possibly one complete or error notification but never both",
    "start": "520990",
    "end": "526810"
  },
  {
    "text": "error and complete termination by error or completion is not guaranteed however",
    "start": "526810",
    "end": "533050"
  },
  {
    "text": "and again you're only going to see one or the other and once it happens",
    "start": "533050",
    "end": "538389"
  },
  {
    "text": "the observable execution will end so your producer is the source of values",
    "start": "538389",
    "end": "545379"
  },
  {
    "text": "for your observable so setting up the",
    "start": "545379",
    "end": "553059"
  },
  {
    "text": "producer isn't really a part of the observable definition again it's a rapper the observables only real job is",
    "start": "553059",
    "end": "560889"
  },
  {
    "text": "to set up the observer to listen to the producer observables are said to be",
    "start": "560889",
    "end": "567189"
  },
  {
    "text": "either hot or cold and this is multicast versus unicast an observable is cold",
    "start": "567189",
    "end": "575290"
  },
  {
    "text": "if subscribing to it creates the producer or activates the producer and",
    "start": "575290",
    "end": "580389"
  },
  {
    "text": "each observer gets a unique instance of that producer on subscribe' an",
    "start": "580389",
    "end": "585970"
  },
  {
    "text": "observable is hot if it closes over the producer and is capable of sharing those",
    "start": "585970",
    "end": "592749"
  },
  {
    "text": "producer notifications so hot is multicast cold observables are where the",
    "start": "592749",
    "end": "599649"
  },
  {
    "text": "producer is created inside the subscription I hope you can all read this example here this is from a really",
    "start": "599649",
    "end": "607480"
  },
  {
    "text": "good article by Ben Lesh describing hot versus cold observables and I'll have",
    "start": "607480",
    "end": "613269"
  },
  {
    "text": "the links to my slides so you can look up these articles and references throughout if you want to do that later",
    "start": "613269",
    "end": "620339"
  },
  {
    "text": "so and here in this example anything that subscribes to your source",
    "start": "620339",
    "end": "625449"
  },
  {
    "text": "observable will have its own instance of the WebSocket that makes it cold our source cannot be shared in a unicast and",
    "start": "625449",
    "end": "633999"
  },
  {
    "text": "can only send to a single observer also note observables should also return a",
    "start": "633999",
    "end": "641019"
  },
  {
    "text": "teardown mechanism so we can remove your listeners and here you'll see that it's",
    "start": "641019",
    "end": "646449"
  },
  {
    "text": "returning a function to close the WebSocket so when you call unsubscribe",
    "start": "646449",
    "end": "651459"
  },
  {
    "text": "that WebSockets going to get closed and you're going to clean up after yourself a hot observable on the other hand is",
    "start": "651459",
    "end": "659379"
  },
  {
    "text": "where the producer is created outside the subscription the observable shares a",
    "start": "659379",
    "end": "664839"
  },
  {
    "text": "reference to the producer and starts listening to it than on subscribe' in this example",
    "start": "664839",
    "end": "670449"
  },
  {
    "text": "anything that's scribes the short source shares the same instance of the websocket and now it can",
    "start": "670449",
    "end": "678160"
  },
  {
    "text": "multicast to all subscribers meaning that each mess is it emitted by that one",
    "start": "678160",
    "end": "683290"
  },
  {
    "text": "socket can be received by multiple observers but we do still kind of have",
    "start": "683290",
    "end": "688420"
  },
  {
    "text": "an issue here that we haven't really set up a way to tear down and disconnect our WebSocket so what we could do instead is",
    "start": "688420",
    "end": "696790"
  },
  {
    "text": "we could use a subject to make a cold observable hot we create a subject that",
    "start": "696790",
    "end": "702550"
  },
  {
    "text": "has subscribed to by the cold observe observable and then shared by the new",
    "start": "702550",
    "end": "707560"
  },
  {
    "text": "observable that we're gonna be returning a subject is kind of like a traditional",
    "start": "707560",
    "end": "712750"
  },
  {
    "text": "event bus it's a hot observable and one that can be shared by multiple subscribers and producers subjects have",
    "start": "712750",
    "end": "722680"
  },
  {
    "text": "all the same operators as observables and it will emit values that you next",
    "start": "722680",
    "end": "727750"
  },
  {
    "text": "into it so you can push values in and subscribe to get values out so a subject",
    "start": "727750",
    "end": "734110"
  },
  {
    "text": "is another type that's involved with rxjs subjects multicast and they keep",
    "start": "734110",
    "end": "739900"
  },
  {
    "text": "track also of an internal list of subscribers and subjects are mainly used",
    "start": "739900",
    "end": "745840"
  },
  {
    "text": "for multicast scene so what subjects have different from observables as they have state subjects can't be reused once",
    "start": "745840",
    "end": "754360"
  },
  {
    "text": "they're unsubscribed completed or an error occurs just like your observables subjects are pretty sweet and they're",
    "start": "754360",
    "end": "761110"
  },
  {
    "text": "very important concepts in r.j. rxjs but we really don't need to reuse them this",
    "start": "761110",
    "end": "767440"
  },
  {
    "text": "example isn't really how we would go to make a cold observable hot and and Ben Lesh will continue to describe that to",
    "start": "767440",
    "end": "774220"
  },
  {
    "text": "you in this article as we do here so we we do still have a bit of an issue with",
    "start": "774220",
    "end": "780160"
  },
  {
    "text": "our teardown we're not tracking our subscriptions so that cold source observable so we're gonna be leaking",
    "start": "780160",
    "end": "786030"
  },
  {
    "text": "subscriptions and we don't have a way to disconnect it so the thing is we don't",
    "start": "786030",
    "end": "791260"
  },
  {
    "text": "actually use subjects directly like this because rxjs provides a bunch of",
    "start": "791260",
    "end": "796960"
  },
  {
    "text": "operators to solve this problem and then some and we're going to be going over more of those operators here in a bit I",
    "start": "796960",
    "end": "803260"
  },
  {
    "text": "think operators are really the meat of ArcGIS for me the",
    "start": "803260",
    "end": "810130"
  },
  {
    "text": "important distinction then between the subject and the observable is that a subject has state it exists it has a",
    "start": "810130",
    "end": "818320"
  },
  {
    "text": "list of subscribers sometimes even keeps track of a number of values that have been next through the subject whereas an",
    "start": "818320",
    "end": "826570"
  },
  {
    "text": "observable it's just a function that sets up the observation it doesn't know anything about its subscribers it",
    "start": "826570",
    "end": "832540"
  },
  {
    "text": "doesn't remember any values that's not its job so I feel like and why I wanted",
    "start": "832540",
    "end": "840370"
  },
  {
    "text": "to develop this talk is because the rxjs learning curve is for me it was quite a",
    "start": "840370",
    "end": "846040"
  },
  {
    "text": "steep one it's a really broad API but I",
    "start": "846040",
    "end": "851920"
  },
  {
    "text": "think really the good news here is if that if you're newer to angular at this point I've been doing angular for about",
    "start": "851920",
    "end": "857710"
  },
  {
    "text": "three three and a half years modern angular and like back then there",
    "start": "857710",
    "end": "863470"
  },
  {
    "text": "was breaking changes retired api's painful configuration updates if you",
    "start": "863470",
    "end": "869170"
  },
  {
    "text": "want to talk about updates Sam Julian's right over there and she upgrade so now",
    "start": "869170",
    "end": "874780"
  },
  {
    "text": "that we've gathered some of this evidence about observables observer subscriptions and subjects let's keep",
    "start": "874780",
    "end": "881080"
  },
  {
    "text": "climbing that hill and see what we can put together with our agenda with arc",
    "start": "881080",
    "end": "891730"
  },
  {
    "text": "Jas is set up an observable data service I like to use this quite often when I'm not using ng rx so you can use this as a",
    "start": "891730",
    "end": "902380"
  },
  {
    "text": "store to provide data to multiple parts of your application components subscribe",
    "start": "902380",
    "end": "907390"
  },
  {
    "text": "to the data through this service to receive the latest values so the components the data is just a set of",
    "start": "907390",
    "end": "914080"
  },
  {
    "text": "values so here we're also abstract engaging",
    "start": "914080",
    "end": "919540"
  },
  {
    "text": "of this observable data service and injected it here as the to do HTTP service so then we can handle that",
    "start": "919540",
    "end": "926740"
  },
  {
    "text": "access separately and we can put our observed illogic in one place",
    "start": "926740",
    "end": "931780"
  },
  {
    "text": "and handle our application observer state here so this helps us not have to",
    "start": "931780",
    "end": "938110"
  },
  {
    "text": "be aware of where those values are coming from separating concerns and decoupling the",
    "start": "938110",
    "end": "944200"
  },
  {
    "text": "different application responsibilities so in our observable data service we're",
    "start": "944200",
    "end": "951160"
  },
  {
    "text": "going to be using a behavior subject to hold our store state when subscribe to",
    "start": "951160",
    "end": "956950"
  },
  {
    "text": "this type of subject returns the most recent value from the stream or the",
    "start": "956950",
    "end": "963220"
  },
  {
    "text": "initial state if no value has been set since the behavior subject has that",
    "start": "963220",
    "end": "969400"
  },
  {
    "text": "latest value in state it's possible to retrieve it directly instead of off of",
    "start": "969400",
    "end": "974560"
  },
  {
    "text": "an observable you can just use subject to get value but that's a very bad practice and is actually code smell so",
    "start": "974560",
    "end": "982810"
  },
  {
    "text": "we don't actually ever want to expose the subject from our observable data",
    "start": "982810",
    "end": "988930"
  },
  {
    "text": "service because we don't want consumers of that service to next values into it",
    "start": "988930",
    "end": "994600"
  },
  {
    "text": "so what we're going to be showing instead here is we'll use a private",
    "start": "994600",
    "end": "1000210"
  },
  {
    "text": "behavior subject and then we we give it a public observable using that as",
    "start": "1000210",
    "end": "1007170"
  },
  {
    "text": "observable from your subjects so that you that's what you expose to consumers",
    "start": "1007170",
    "end": "1012500"
  },
  {
    "text": "this this store here it'll get initialized at construction and that behavior subject will then let",
    "start": "1012500",
    "end": "1019050"
  },
  {
    "text": "components get the data when they get initialized and can subscribe even if",
    "start": "1019050",
    "end": "1024209"
  },
  {
    "text": "those components subscribe after that data has arrived that's really helpful for the timing of those asynchronous",
    "start": "1024209",
    "end": "1030360"
  },
  {
    "text": "events and in your angular application so using a behavior subjects is a great",
    "start": "1030360",
    "end": "1035880"
  },
  {
    "text": "way of writing code that works independently of the order of those asynchronous operations such as like",
    "start": "1035880",
    "end": "1044010"
  },
  {
    "text": "calling your back end and then binding your components to that data source our",
    "start": "1044010",
    "end": "1049830"
  },
  {
    "text": "components don't have to then know where that data comes from or how it gets loaded they just subscribe themselves to",
    "start": "1049830",
    "end": "1056850"
  },
  {
    "text": "the store right here so you want to make sure then that you're always cleaning up",
    "start": "1056850",
    "end": "1063420"
  },
  {
    "text": "after yourself when you subscribe to an observable so an NG ondestroy",
    "start": "1063420",
    "end": "1068640"
  },
  {
    "text": "you be sure to unsubscribe that component for the store because that subscription would then",
    "start": "1068640",
    "end": "1073980"
  },
  {
    "text": "otherwise live on for the life of the application HTTP observables on the",
    "start": "1073980",
    "end": "1079980"
  },
  {
    "text": "other hand though it will they complete after you get a response or there's an error so you don't really have to always",
    "start": "1079980",
    "end": "1086850"
  },
  {
    "text": "worry about leaving resources hanging around from your HTTP observables but",
    "start": "1086850",
    "end": "1091860"
  },
  {
    "text": "it's just a best practice try to always unsubscribe I don't like to leave my PR",
    "start": "1091860",
    "end": "1099570"
  },
  {
    "text": "reviewers hunting through my code and deciding whether or not my my subscription has completed I like to be",
    "start": "1099570",
    "end": "1106289"
  },
  {
    "text": "very explicit about that it doesn't cost you anything right our store subscription stays open for the duration",
    "start": "1106289",
    "end": "1113220"
  },
  {
    "text": "and so again we're gonna be sure to unsubscribe our components a cleaner and",
    "start": "1113220",
    "end": "1120899"
  },
  {
    "text": "more declarative way of using those observables in your components is with angular's async pipe instead of doing a",
    "start": "1120899",
    "end": "1127590"
  },
  {
    "text": "subscription directly in your component it's a pretty pretty handy way of making sure you don't have to mess with any of",
    "start": "1127590",
    "end": "1133769"
  },
  {
    "text": "that subscribe unsubscribe trace it through you know the async pipe in angular subscribes to an observable or",
    "start": "1133769",
    "end": "1140789"
  },
  {
    "text": "would also use a promise and it returns the latest value that is has been emitted the new values emitted the async",
    "start": "1140789",
    "end": "1148350"
  },
  {
    "text": "pipe also marks that component to be checked for changes so you can use angular's more performant on push change",
    "start": "1148350",
    "end": "1155850"
  },
  {
    "text": "detection strategy I think again the best thing about the async pipe is that",
    "start": "1155850",
    "end": "1161970"
  },
  {
    "text": "when the component gets destroyed the async pipe automatically unsubscribes and avoids all your memory leaks we",
    "start": "1161970",
    "end": "1168330"
  },
  {
    "text": "aren't keeping also any state variables in our components so we don't have any of that messiness maybe you know some",
    "start": "1168330",
    "end": "1175980"
  },
  {
    "text": "people like to change their state inside the component you're like what why would you do that here you know so we don't",
    "start": "1175980",
    "end": "1183269"
  },
  {
    "text": "need to use our own in it we don't need to use ondestroy setup and teardown our data the async",
    "start": "1183269",
    "end": "1188850"
  },
  {
    "text": "pipe handles all of that for us off of our observable another thing to know",
    "start": "1188850",
    "end": "1194340"
  },
  {
    "text": "here in this example is our - duze observable how its named with a dollar",
    "start": "1194340",
    "end": "1200669"
  },
  {
    "text": "sign at the end of the suffix this is a very common style convention",
    "start": "1200669",
    "end": "1205720"
  },
  {
    "text": "to help us distinguish those values as observables but it's not at all necessary to the observable",
    "start": "1205720",
    "end": "1211720"
  },
  {
    "text": "functionality just something that you'll tend to see or might want to use yourself so far in this year",
    "start": "1211720",
    "end": "1222610"
  },
  {
    "text": "investigation with Veronica we've gathered enough evidence to see that building our application in layers helps",
    "start": "1222610",
    "end": "1229390"
  },
  {
    "text": "us to decouple the applications responsibilities our observable data service or our store can provide data to",
    "start": "1229390",
    "end": "1237220"
  },
  {
    "text": "multiple parts of our application however even though we're calling it a store it is not the same thing as",
    "start": "1237220",
    "end": "1244570"
  },
  {
    "text": "centralized state management like redux for example if you are looking for a",
    "start": "1244570",
    "end": "1250030"
  },
  {
    "text": "Redux solution there's an excellent and very popular I love it Redux library for",
    "start": "1250030",
    "end": "1255250"
  },
  {
    "text": "angular called and grx so even though we're not doing centralized state",
    "start": "1255250",
    "end": "1261370"
  },
  {
    "text": "management with this observable data service though we do still have the advantages of unidirectional data flow",
    "start": "1261370",
    "end": "1267970"
  },
  {
    "text": "like using that on push change detection strategy so to make changes to our store",
    "start": "1267970",
    "end": "1273910"
  },
  {
    "text": "then what we're gonna need to do is use action methods to update the store similar as we would do in redux we would",
    "start": "1273910",
    "end": "1280780"
  },
  {
    "text": "send an action up and it would come down out the store action methods Save",
    "start": "1280780",
    "end": "1286330"
  },
  {
    "text": "Changes to the backend service and that then will return an HTTP observable so",
    "start": "1286330",
    "end": "1292990"
  },
  {
    "text": "in the stores action method we subscribe to the HTTP observable to update the",
    "start": "1292990",
    "end": "1298570"
  },
  {
    "text": "data in the store and then we're also going to return that observable too so",
    "start": "1298570",
    "end": "1303610"
  },
  {
    "text": "that calling components can subscribe to it for the duration of the HTTP request you know they usually want to know like",
    "start": "1303610",
    "end": "1310000"
  },
  {
    "text": "how long that request is ongoing and when it's ready to declaratively show",
    "start": "1310000",
    "end": "1315730"
  },
  {
    "text": "the values perhaps a loading spinner or something like that so then since we're gonna we",
    "start": "1315730",
    "end": "1321640"
  },
  {
    "text": "are subscribing to that observable twice once to update the store here and then",
    "start": "1321640",
    "end": "1328570"
  },
  {
    "text": "we're returning the observable and we're going to subscribe to it in the component for the eventual data we do",
    "start": "1328570",
    "end": "1335740"
  },
  {
    "text": "actually risk duplicating that HTTP call so the observable by itself is just a plain",
    "start": "1335740",
    "end": "1342250"
  },
  {
    "text": "cold observable setup to make a request when a consumer subscribes so",
    "start": "1342250",
    "end": "1348280"
  },
  {
    "text": "subscribing to post multiple times will actually perform one request for each",
    "start": "1348280",
    "end": "1355059"
  },
  {
    "text": "subscriber that's important thing to watch out for sometimes I just I just forget about it oops you know it's over",
    "start": "1355059",
    "end": "1361120"
  },
  {
    "text": "it's over here and the other concern so what we would do it to prevent this",
    "start": "1361120",
    "end": "1366400"
  },
  {
    "text": "scenario on the HTTP call we're going to use the rxjs operator share so that",
    "start": "1366400",
    "end": "1375490"
  },
  {
    "text": "share operator makes a cold observable hot and shares the underlying subscriptions between its listeners",
    "start": "1375490",
    "end": "1382240"
  },
  {
    "text": "that's how it works but just of in any way with share when the first observer",
    "start": "1382240",
    "end": "1390130"
  },
  {
    "text": "subscribes it listens to the HTTP observable triggering a single post",
    "start": "1390130",
    "end": "1395640"
  },
  {
    "text": "subscribers that start listening while that HTTP request is ongoing they're all",
    "start": "1395640",
    "end": "1401320"
  },
  {
    "text": "going to get the same result so when the source HTTP observable completes those",
    "start": "1401320",
    "end": "1406990"
  },
  {
    "text": "scripts subscriptions will be terminated as well",
    "start": "1406990",
    "end": "1411960"
  },
  {
    "text": "so the observable being the foundation of rxjs the the real magic I think is in those",
    "start": "1413580",
    "end": "1420549"
  },
  {
    "text": "operators like share operators are pure functions that take data or other",
    "start": "1420549",
    "end": "1426429"
  },
  {
    "text": "observables from an observable stream and transform them into new observables",
    "start": "1426429",
    "end": "1432780"
  },
  {
    "text": "they enable us to write that complex asynchronous code using declarative",
    "start": "1432780",
    "end": "1438760"
  },
  {
    "text": "composition there are two kinds of operators we've got the pipe a bowl",
    "start": "1438760",
    "end": "1443830"
  },
  {
    "text": "operators and the creation operators pipeable operators are those that can be",
    "start": "1443830",
    "end": "1450340"
  },
  {
    "text": "piped to observable and they'll take an input observable and transform it into a",
    "start": "1450340",
    "end": "1455500"
  },
  {
    "text": "separate output observable they're often composed with pipe as a chain of",
    "start": "1455500",
    "end": "1461140"
  },
  {
    "text": "operations you might have heard of pipe and other languages kind of similar pass it pass it on to the next chain right so",
    "start": "1461140",
    "end": "1468669"
  },
  {
    "text": "each one in line will receive input from the previous and share is an example of that pipe",
    "start": "1468669",
    "end": "1474860"
  },
  {
    "text": "operator as we saw earlier using that with pipe creation operators on the",
    "start": "1474860",
    "end": "1480770"
  },
  {
    "text": "other hand are standalone functions that can be called to create a new observable",
    "start": "1480770",
    "end": "1486520"
  },
  {
    "text": "the creation operators let you do things like create an observable that fires on",
    "start": "1486520",
    "end": "1491750"
  },
  {
    "text": "an interval a synchronous observable of any value an observable maybe from an event or even generate a new observable",
    "start": "1491750",
    "end": "1500000"
  },
  {
    "text": "by compatible observables for example operators are super super handy but I",
    "start": "1500000",
    "end": "1507260"
  },
  {
    "text": "think the thing about each one of them is there's a lot to learn under the hood about how they all work and what's",
    "start": "1507260",
    "end": "1514280"
  },
  {
    "text": "appropriate to use in each given instance so back to share one thing",
    "start": "1514280",
    "end": "1521210"
  },
  {
    "text": "about share and the underlying functionality that we want to be aware of is that in making a stream hot share",
    "start": "1521210",
    "end": "1529039"
  },
  {
    "text": "also makes observables retrial that's retrial not replayable so if we",
    "start": "1529039",
    "end": "1536000"
  },
  {
    "text": "subscribe after a value is produced we're not gonna get that first result so",
    "start": "1536000",
    "end": "1542270"
  },
  {
    "text": "luckily there's a different operator if we want the replay functionality we can use share replay with the argument one",
    "start": "1542270",
    "end": "1548630"
  },
  {
    "text": "that one is an argument of the number of next notifications to replay retry is",
    "start": "1548630",
    "end": "1556190"
  },
  {
    "text": "super great like if it's the thing you want you can set up your observables to retry on purpose here in our example",
    "start": "1556190",
    "end": "1564020"
  },
  {
    "text": "we're only going to be using our HTTP observable during the duration of the",
    "start": "1564020",
    "end": "1569780"
  },
  {
    "text": "request so we don't really risk duplicating those HTTP posts but just a",
    "start": "1569780",
    "end": "1576590"
  },
  {
    "text": "little bit about how share and the other multi casting operators like it work is what they do is they keep a ref count of",
    "start": "1576590",
    "end": "1584809"
  },
  {
    "text": "all their subscribers and four share when that ref count when the number of",
    "start": "1584809",
    "end": "1590360"
  },
  {
    "text": "subscribers drops to zero or the underlying observable completes causing",
    "start": "1590360",
    "end": "1595909"
  },
  {
    "text": "the subscribers to drop then the subject created by share cannot be reused but",
    "start": "1595909",
    "end": "1602360"
  },
  {
    "text": "the subject comes from a factory and if you new subscriber after your rough count",
    "start": "1602360",
    "end": "1608260"
  },
  {
    "text": "has dropped to zero and it goes back up a new subject is going to be created by",
    "start": "1608260",
    "end": "1613539"
  },
  {
    "text": "share retrying the original observable and that is going to potentially",
    "start": "1613539",
    "end": "1618610"
  },
  {
    "text": "duplicate your HTTP requests so this might seem like it's getting a little",
    "start": "1618610",
    "end": "1623980"
  },
  {
    "text": "complicated but it's just that there are some specific multi casting operators to solve for these different scenarios so",
    "start": "1623980",
    "end": "1632908"
  },
  {
    "text": "the big thing that you want to keep in mind when thinking about hot versus cold",
    "start": "1635190",
    "end": "1640809"
  },
  {
    "text": "observables and how we're going to be subscribing to them is kind of what's",
    "start": "1640809",
    "end": "1645940"
  },
  {
    "text": "happening on the underlying producer and that producers side effects so a side",
    "start": "1645940",
    "end": "1653649"
  },
  {
    "text": "effect in functional programming is an event that updates application state outside of the called function one of",
    "start": "1653649",
    "end": "1662350"
  },
  {
    "text": "the properties of pure functions is that they don't have side effects the side",
    "start": "1662350",
    "end": "1667389"
  },
  {
    "text": "effects in these examples would be the HTTP requests sometimes we need to make",
    "start": "1667389",
    "end": "1673899"
  },
  {
    "text": "an observable hot and share the execution and result or often we can",
    "start": "1673899",
    "end": "1679809"
  },
  {
    "text": "just use our cold observables carefully and subscribe to invoke them independently",
    "start": "1679809",
    "end": "1687059"
  },
  {
    "text": "so I'm going to show you this smaller kind of a stand-alone example to further emphasize the point about the acing pipe",
    "start": "1690910",
    "end": "1697760"
  },
  {
    "text": "and the potential for accidentally duplicating HTTP requests so we've got",
    "start": "1697760",
    "end": "1702980"
  },
  {
    "text": "everything going on here in this one component we're doing a get call to get",
    "start": "1702980",
    "end": "1709310"
  },
  {
    "text": "our list of two do's and we also want to show a total number of the to do's so",
    "start": "1709310",
    "end": "1717800"
  },
  {
    "text": "we're set up we set up a different observable piped off of the original observable and we've decided to get the",
    "start": "1717800",
    "end": "1724580"
  },
  {
    "text": "length property off of that list of to do's right so in the template we're then",
    "start": "1724580",
    "end": "1732800"
  },
  {
    "text": "using the async pipe to subscribe to those observables and here what we're",
    "start": "1732800",
    "end": "1739340"
  },
  {
    "text": "actually doing because we've got an async pipe on the total and we've got an async pipe on the to Do's we're actually",
    "start": "1739340",
    "end": "1746980"
  },
  {
    "text": "subscribing to the original observable twice with our async pipes and so that",
    "start": "1746980",
    "end": "1753290"
  },
  {
    "text": "is going to duplicate our HTTP requests and you might be thinking like why the",
    "start": "1753290",
    "end": "1759080"
  },
  {
    "text": "heck don't we just use that share thing that we just learned about right it isn't always necessary to share your",
    "start": "1759080",
    "end": "1766280"
  },
  {
    "text": "streams there was a really sweet feature that came out with angular 4 template syntax where you can use the ng if with",
    "start": "1766280",
    "end": "1774320"
  },
  {
    "text": "async as and you can assign the values coming off of your observable to a local",
    "start": "1774320",
    "end": "1780410"
  },
  {
    "text": "template variable so that you can then use that throughout your template block for the values so you aren't subscribing",
    "start": "1780410",
    "end": "1788270"
  },
  {
    "text": "with your async pipe twice it's something to look out for",
    "start": "1788270",
    "end": "1792910"
  },
  {
    "text": "additionally with the ng-if and async as you can add an ng else clause so you",
    "start": "1796750",
    "end": "1803930"
  },
  {
    "text": "might want to show an alternate template block when the observable hasn't yet admitted any values so what I've added",
    "start": "1803930",
    "end": "1810740"
  },
  {
    "text": "here is a loading block to kind of show off how the ng elf's would work this",
    "start": "1810740",
    "end": "1816860"
  },
  {
    "text": "reactive template Styles syntax really simplifies our code making it more",
    "start": "1816860",
    "end": "1823010"
  },
  {
    "text": "declarative easier to read and fewer state variables are going to be littering up our component classes so I",
    "start": "1823010",
    "end": "1831230"
  },
  {
    "text": "think reactive templates are pretty sweet y'all so not too long ago rxjs 5 5",
    "start": "1831230",
    "end": "1841400"
  },
  {
    "text": "introduced pipeable operators this was a shift in the rxjs api that changed the",
    "start": "1841400",
    "end": "1847970"
  },
  {
    "text": "syntax of chaining operators so instead of dot chaining the patched the",
    "start": "1847970",
    "end": "1853580"
  },
  {
    "text": "operators that are patched off of observable we're going to use the pipe herbal operators with the observable",
    "start": "1853580",
    "end": "1859610"
  },
  {
    "text": "pipe function this also changed the way that we import our Kaos GS operators and",
    "start": "1859610",
    "end": "1866000"
  },
  {
    "text": "really ease the burden on managing dependencies and improved our tree shaking capabilities so we can ship",
    "start": "1866000",
    "end": "1872240"
  },
  {
    "text": "smaller bundles to the browser so we're using observables pipe method to compose",
    "start": "1872240",
    "end": "1878390"
  },
  {
    "text": "a series of operations here each operation we've got filter map and scan results in",
    "start": "1878390",
    "end": "1886100"
  },
  {
    "text": "a new observable and pipe then produces an output observable that you can",
    "start": "1886100",
    "end": "1891410"
  },
  {
    "text": "subscribe to and perform your actions on so here what we're doing is we're",
    "start": "1891410",
    "end": "1897020"
  },
  {
    "text": "filtering the values by the even ones and then we want to take those even",
    "start": "1897020",
    "end": "1902930"
  },
  {
    "text": "values and double them and what scan is doing is accumulating some at each",
    "start": "1902930",
    "end": "1909170"
  },
  {
    "text": "result at each interval so marble",
    "start": "1909170",
    "end": "1914780"
  },
  {
    "text": "diagrams depict how reactive operators work with observable sequences we're gonna be",
    "start": "1914780",
    "end": "1921740"
  },
  {
    "text": "looking at a lot of marble diagrams for operators from here on out so I I want to just kind of describe how each one",
    "start": "1921740",
    "end": "1928370"
  },
  {
    "text": "one these work this is from the ArcGIS documentation it's their their diagram",
    "start": "1928370",
    "end": "1934700"
  },
  {
    "text": "and I think it really shows a really good description of what these marble",
    "start": "1934700",
    "end": "1939770"
  },
  {
    "text": "diagrams mean the top portion that",
    "start": "1939770",
    "end": "1945230"
  },
  {
    "text": "you've got above the box here we've got one input observable that represents the",
    "start": "1945230",
    "end": "1952670"
  },
  {
    "text": "series of values it reads from left to right and it ends there with a line with",
    "start": "1952670",
    "end": "1958910"
  },
  {
    "text": "the complete notification the observable operation usually is in the Box in the",
    "start": "1958910",
    "end": "1964880"
  },
  {
    "text": "middle here we're calling it multiply multiply by 10 the output observable is",
    "start": "1964880",
    "end": "1971360"
  },
  {
    "text": "shown then on the bottom observable sequences are shown as lines that emit",
    "start": "1971360",
    "end": "1977540"
  },
  {
    "text": "zero or more values in a perpendicular line for your completion or output",
    "start": "1977540",
    "end": "1983300"
  },
  {
    "text": "somehow has an X for error I'm not sure what happened Y multiplied by 10 got so",
    "start": "1983300",
    "end": "1988700"
  },
  {
    "text": "hard but you know things happen maybe maybe there was a side effect",
    "start": "1988700",
    "end": "1993920"
  },
  {
    "text": "so transformational operators like map are I think some of the most basic",
    "start": "1993920",
    "end": "1999530"
  },
  {
    "text": "building blocks in your rxjs dreams similar I think to the well-known array",
    "start": "1999530",
    "end": "2005470"
  },
  {
    "text": "map function you might want to compare it to that the map operator applies a projection to each value then it emits",
    "start": "2005470",
    "end": "2013390"
  },
  {
    "text": "to the output observable but I think a big difference in the way that map",
    "start": "2013390",
    "end": "2020200"
  },
  {
    "text": "operates on arrays versus how it operates on observables",
    "start": "2020200",
    "end": "2025390"
  },
  {
    "text": "that you want to keep track of is is map will operate all all of the operators",
    "start": "2025390",
    "end": "2030760"
  },
  {
    "text": "they operate on one value at a time as they're streamed through the input so",
    "start": "2030760",
    "end": "2036880"
  },
  {
    "text": "the array map function then on the other hand operates on the entire sequence at",
    "start": "2036880",
    "end": "2042460"
  },
  {
    "text": "once so it's kind of a paradigm shift and it really does make a difference when you're looking at these operations",
    "start": "2042460",
    "end": "2049419"
  },
  {
    "text": "and and thinking about how expensive it might be to operate on arrays vs.",
    "start": "2049419",
    "end": "2054730"
  },
  {
    "text": "composing streams with observable sequences so filter then is one of the",
    "start": "2054730",
    "end": "2061358"
  },
  {
    "text": "many filtering operator it filters items from the source observable and only emits those that",
    "start": "2061359",
    "end": "2067658"
  },
  {
    "text": "satisfy a given predicate function it's also very similar and can be compared to",
    "start": "2067659",
    "end": "2073779"
  },
  {
    "text": "the array filter function and that it filters those values from the final result again they're only being operated",
    "start": "2073779",
    "end": "2081069"
  },
  {
    "text": "on one at a time as an observable stream there are quite a few other filtering",
    "start": "2081069",
    "end": "2086919"
  },
  {
    "text": "operators including distinct debounce throttle last take until and then some",
    "start": "2086919",
    "end": "2093069"
  },
  {
    "text": "we'll get into a few more here in a while another operator that might be",
    "start": "2093069",
    "end": "2098289"
  },
  {
    "text": "familiar from arrays as they've provided a find operator it searches for the first item in the source observable that",
    "start": "2098289",
    "end": "2105279"
  },
  {
    "text": "matches the specified condition and then it will complete maybe although somewhat",
    "start": "2105279",
    "end": "2112839"
  },
  {
    "text": "controversial another operator that I wanted to talk about that's similar to arrays is reduce reduce is an aggregate",
    "start": "2112839",
    "end": "2120430"
  },
  {
    "text": "operator that outputs only when the input observable completes though on the",
    "start": "2120430",
    "end": "2126250"
  },
  {
    "text": "other hand what you might be wanting to reach for with observable is instead of reduce is the scan operator scan is a",
    "start": "2126250",
    "end": "2135089"
  },
  {
    "text": "transformational operator that emits an accumulated result at each interval so",
    "start": "2135089",
    "end": "2141789"
  },
  {
    "text": "frequently when you're working with streams you want an intermittent result rather than waiting for a single",
    "start": "2141789",
    "end": "2148200"
  },
  {
    "text": "aggregated result at completion so this",
    "start": "2148200",
    "end": "2153789"
  },
  {
    "text": "is another example that shows how you might create a type of head search I've got a link here to adjust that going to",
    "start": "2153789",
    "end": "2162400"
  },
  {
    "text": "show you this code we don't need to read all through it I'm gonna break down the pieces that are important so we're gonna",
    "start": "2162400",
    "end": "2169240"
  },
  {
    "text": "create a type-ahead search with rxjs kind of learning by example so on key up",
    "start": "2169240",
    "end": "2174460"
  },
  {
    "text": "here what we do is it processes the search text input into a subject stream",
    "start": "2174460",
    "end": "2180670"
  },
  {
    "text": "that is filtered through a chain of operations that check it for minimum length they d bounce the input or wait",
    "start": "2180670",
    "end": "2188650"
  },
  {
    "text": "for a break in the keystrokes that's what d bouncing means and it only emits then if the value has changed too",
    "start": "2188650",
    "end": "2196210"
  },
  {
    "text": "stinked until changed so writing these operations in plain JavaScript I think",
    "start": "2196210",
    "end": "2202089"
  },
  {
    "text": "would otherwise probably be quite involved so we do have the general idea",
    "start": "2202089",
    "end": "2207609"
  },
  {
    "text": "I think of filtering down but let's look at that debounce time and see what it's",
    "start": "2207609",
    "end": "2212859"
  },
  {
    "text": "actually doing for us waiting for the break in keystrokes debounce time delays",
    "start": "2212859",
    "end": "2218859"
  },
  {
    "text": "values emitted by the source observable and it will also drop previously pending",
    "start": "2218859",
    "end": "2225700"
  },
  {
    "text": "delayed emissions if a new value arrives before the specified time",
    "start": "2225700",
    "end": "2231910"
  },
  {
    "text": "so what rate limits the input and delays the output you can see that how the the",
    "start": "2231910",
    "end": "2238690"
  },
  {
    "text": "ball is kind of line up here versus the input and which ones got filtered out because they were D bounced distinct",
    "start": "2238690",
    "end": "2247060"
  },
  {
    "text": "until change then our next operation in that search type-ahead search does exactly as you might think it omits",
    "start": "2247060",
    "end": "2254230"
  },
  {
    "text": "values only if they were different from the last value we received the distinct",
    "start": "2254230",
    "end": "2259390"
  },
  {
    "text": "until changed operator forces distinctness only from the most recent value if you want full and uniqueness on",
    "start": "2259390",
    "end": "2266710"
  },
  {
    "text": "your stream you can use the plane distinct operator and then you can also compare those values using a key",
    "start": "2266710",
    "end": "2273609"
  },
  {
    "text": "selector function another thing that you can use operators to avoid is nesting",
    "start": "2273609",
    "end": "2280599"
  },
  {
    "text": "subscriptions nested subscriptions can become quite hard to manage and they're",
    "start": "2280599",
    "end": "2286119"
  },
  {
    "text": "difficult to follow and they take your application straight back to something that looks like callback hell that's not",
    "start": "2286119",
    "end": "2292599"
  },
  {
    "text": "why we're using rxjs is it so in this example that we're showing we've got the",
    "start": "2292599",
    "end": "2297849"
  },
  {
    "text": "ID route parameter observable and when you receive to that when you receive",
    "start": "2297849",
    "end": "2303550"
  },
  {
    "text": "that route parameter you want to go ahead and fetch the data related to that",
    "start": "2303550",
    "end": "2308680"
  },
  {
    "text": "ID from your service and that's a separate dependent observable so don't",
    "start": "2308680",
    "end": "2314830"
  },
  {
    "text": "do this do not Nestor subscriptions Nestea and subscriptions is considered a very bad",
    "start": "2314830",
    "end": "2321070"
  },
  {
    "text": "practice what we want to do here instead is use a higher-order observable",
    "start": "2321070",
    "end": "2327910"
  },
  {
    "text": "operator to flatten or to join to the dependent in our",
    "start": "2327910",
    "end": "2333140"
  },
  {
    "text": "observable stream and then only subscribe once a higher-order observable",
    "start": "2333140",
    "end": "2339500"
  },
  {
    "text": "is an observable that emits other observables that's all it is it sounds fancy but it's an observable of",
    "start": "2339500",
    "end": "2346520"
  },
  {
    "text": "observables difficult to say maybe Arceus provides several operators that flatten these observable of observable",
    "start": "2346520",
    "end": "2353540"
  },
  {
    "text": "streams and turn them into ordinary observables so here we're using switch",
    "start": "2353540",
    "end": "2359300"
  },
  {
    "text": "map on the latest routed ID and then we combine that ID with the service to get",
    "start": "2359300",
    "end": "2365270"
  },
  {
    "text": "that data based on the ID we assign that result to an observable that we then can",
    "start": "2365270",
    "end": "2371750"
  },
  {
    "text": "use in our template maybe with a spacing pipe if you don't know which higher",
    "start": "2371750",
    "end": "2377300"
  },
  {
    "text": "order operator to use when starting out I think switch map can often be a safe",
    "start": "2377300",
    "end": "2382400"
  },
  {
    "text": "bet but we also should examine how it works if you ever see cancelled requests",
    "start": "2382400",
    "end": "2388460"
  },
  {
    "text": "in your network tab sometimes I'm like oh where am I using switch map that I shouldn't be that shouldn't be happening so switching is just one of the ways",
    "start": "2388460",
    "end": "2396500"
  },
  {
    "text": "that we can flatten observable is in rxjs with switch we're subscribed to",
    "start": "2396500",
    "end": "2402890"
  },
  {
    "text": "each inner observable as it arrives output will come then from your first",
    "start": "2402890",
    "end": "2408350"
  },
  {
    "text": "inner observable until we get another one and then the initial observable is",
    "start": "2408350",
    "end": "2413900"
  },
  {
    "text": "unsubscribed - and cancelled so that's where we're gonna see cancel so for",
    "start": "2413900",
    "end": "2420350"
  },
  {
    "text": "flattening operators like switch you've in your in your marble diagram the",
    "start": "2420350",
    "end": "2426140"
  },
  {
    "text": "higher order observable is often represented as the topmost line that",
    "start": "2426140",
    "end": "2431300"
  },
  {
    "text": "emits your inner observables switching is a very specific behavior that when we",
    "start": "2431300",
    "end": "2438860"
  },
  {
    "text": "want to receive values from an inner observable and so we get another observable in which case we cancel the",
    "start": "2438860",
    "end": "2445340"
  },
  {
    "text": "previous one and hand over control to that new inner observable the observable",
    "start": "2445340",
    "end": "2451910"
  },
  {
    "text": "then completes on completion of the last output observable so you might have",
    "start": "2451910",
    "end": "2457850"
  },
  {
    "text": "caught here that d are our fourth value the blue ball is missing from our",
    "start": "2457850",
    "end": "2463220"
  },
  {
    "text": "outputs and the reason that is is because our second inter observable it came along",
    "start": "2463220",
    "end": "2470960"
  },
  {
    "text": "so our higher-order observables subscribe to your second observable canceled the first inter observable and",
    "start": "2470960",
    "end": "2479060"
  },
  {
    "text": "it drops D from the output even though the second observable hadn't yet emitted",
    "start": "2479060",
    "end": "2484310"
  },
  {
    "text": "any values that was the active inner observable at the time so we are missing D can cat is another observable",
    "start": "2484310",
    "end": "2494210"
  },
  {
    "text": "flattening strategy that is also subscribed to only one observable at a time however it waits for each inter",
    "start": "2494210",
    "end": "2501800"
  },
  {
    "text": "observable to complete before subscribing to the next one this process",
    "start": "2501800",
    "end": "2507620"
  },
  {
    "text": "is each of the inner streams fully into the output stream in order of their arrival a third strategy that you're",
    "start": "2507620",
    "end": "2516860"
  },
  {
    "text": "often se is merged very common merge can subscribe to multiple and our",
    "start": "2516860",
    "end": "2522050"
  },
  {
    "text": "observables at the same time and it will emit values from each one as they arrive",
    "start": "2522050",
    "end": "2527230"
  },
  {
    "text": "merging those values into the final output with merge though the order of",
    "start": "2527230",
    "end": "2533300"
  },
  {
    "text": "your output is determined generally by the timing of your input so as you can",
    "start": "2533300",
    "end": "2539210"
  },
  {
    "text": "see if your values arrive non-deterministically in a certain order or not that's how your output is going",
    "start": "2539210",
    "end": "2545930"
  },
  {
    "text": "to look so you can't really depend on a certain ordering with merge that's frequently while people might use can",
    "start": "2545930",
    "end": "2551780"
  },
  {
    "text": "cat to take one in our observable after another",
    "start": "2551780",
    "end": "2556810"
  },
  {
    "text": "emerging come cat operators come in both flavor of observable your pipeable and",
    "start": "2561760",
    "end": "2566930"
  },
  {
    "text": "your creation operators your plane merge is a joint creation operator that",
    "start": "2566930",
    "end": "2573440"
  },
  {
    "text": "subscribes to all input observables and then emits each of their values as they come through right",
    "start": "2573440",
    "end": "2578960"
  },
  {
    "text": "the pipeable merge operators which we're showing here are merge all merge map and",
    "start": "2578960",
    "end": "2585050"
  },
  {
    "text": "merge scan merge map is a combination of map and merge all it allows you to play",
    "start": "2585050",
    "end": "2592790"
  },
  {
    "text": "a projection to those merged values and returns an observable of each value and",
    "start": "2592790",
    "end": "2598100"
  },
  {
    "text": "then flattens it into the stream so what we're doing in each of these examples is",
    "start": "2598100",
    "end": "2603290"
  },
  {
    "text": "the same thing in the first one though we've got that bad inner subscription",
    "start": "2603290",
    "end": "2610100"
  },
  {
    "text": "that we're not keeping track of so we're mapping our observable to an observable",
    "start": "2610100",
    "end": "2615380"
  },
  {
    "text": "of an observable stream and then subscribing to that inner observable to actually get the data we don't want to",
    "start": "2615380",
    "end": "2622250"
  },
  {
    "text": "do that right our second one we've decided oh wait we want to flatten those",
    "start": "2622250",
    "end": "2628990"
  },
  {
    "text": "observable of observables with merge all and then we can subscribe for the result",
    "start": "2628990",
    "end": "2634870"
  },
  {
    "text": "but the quick one to reach for here is the final one merge map that just lets",
    "start": "2634870",
    "end": "2640340"
  },
  {
    "text": "you apply that projection and flattens it into your final stream so to combine",
    "start": "2640340",
    "end": "2646790"
  },
  {
    "text": "streams we're often going to use the join operators they're both join creation",
    "start": "2646790",
    "end": "2652790"
  },
  {
    "text": "operators like can count and merge and then your pipeable join operators I",
    "start": "2652790",
    "end": "2659080"
  },
  {
    "text": "might need a little more water up here before I finish it combined latest and",
    "start": "2659080",
    "end": "2665960"
  },
  {
    "text": "with latest from our some of these joint operators they're pretty similarly names but they have distinctly different",
    "start": "2665960",
    "end": "2673250"
  },
  {
    "text": "behavior when it comes to updates so combine latest is a join creation",
    "start": "2673250",
    "end": "2679100"
  },
  {
    "text": "operator and allows any of the input streams to to update the output stream with latest from then is a is a join",
    "start": "2679100",
    "end": "2687290"
  },
  {
    "text": "creation operator and allows any of the input allows the inputs excuse me",
    "start": "2687290",
    "end": "2694250"
  },
  {
    "text": "it allows so that what the with latest from does is it the only the leading stream puts results into the output",
    "start": "2694250",
    "end": "2701270"
  },
  {
    "text": "we're gonna see a diagram here in a minute that explains this more correctly both of those operators result then in",
    "start": "2701270",
    "end": "2707690"
  },
  {
    "text": "an array in the next notification thank you so much so the values from the input",
    "start": "2707690",
    "end": "2713930"
  },
  {
    "text": "observables are returned and given an order than in that array another thing",
    "start": "2713930",
    "end": "2721340"
  },
  {
    "text": "that both of these operators with latest from and combine latest have in common",
    "start": "2721340",
    "end": "2726910"
  },
  {
    "text": "is that in your combined your combined output stream is not going to emit until",
    "start": "2726910",
    "end": "2733580"
  },
  {
    "text": "all observables have emitted at least one value this has caught me a time or two so the output stream is waiting on",
    "start": "2733580",
    "end": "2741650"
  },
  {
    "text": "all source observables which can be it's kind of a subtle behavior I think until",
    "start": "2741650",
    "end": "2746990"
  },
  {
    "text": "you run up against it and you you want to emit even if only one of those streams has emitted in",
    "start": "2746990",
    "end": "2753290"
  },
  {
    "text": "which case what you might want to do is you can kick off those streams with the starts with operator or possibly you can",
    "start": "2753290",
    "end": "2761060"
  },
  {
    "text": "fall back on emerging strategy or something like that to to get values in the input as soon as you get a sink in",
    "start": "2761060",
    "end": "2766970"
  },
  {
    "text": "the output as soon as you get a single input so as you can see here in these",
    "start": "2766970",
    "end": "2772790"
  },
  {
    "text": "diagrams we're not actually emitting anything until both observables have",
    "start": "2772790",
    "end": "2780020"
  },
  {
    "text": "emitted a value so you'll see that that your ax in your combined latest your",
    "start": "2780020",
    "end": "2786920"
  },
  {
    "text": "result that first ball only comes out after your second stream has emitted values and because with latest from will",
    "start": "2786920",
    "end": "2796550"
  },
  {
    "text": "only emit from your leading stream you don't get a value when you hit a because",
    "start": "2796550",
    "end": "2802910"
  },
  {
    "text": "with latest from blue balls has not emitted anything yet you don't get a",
    "start": "2802910",
    "end": "2809000"
  },
  {
    "text": "value when you hit X because that's not your leading stream so you're finally going to see a value when you hit B and",
    "start": "2809000",
    "end": "2816320"
  },
  {
    "text": "you get then the combination of your leading stream and the the latest value",
    "start": "2816320",
    "end": "2821360"
  },
  {
    "text": "emitted from that second stream so another type of operator take is a",
    "start": "2821360",
    "end": "2830760"
  },
  {
    "text": "filtering operator in rxjs what it does it omits the count of the number of",
    "start": "2830760",
    "end": "2836220"
  },
  {
    "text": "values from the source then it immediately completes as shown here in the diagram we're taking two values from",
    "start": "2836220",
    "end": "2844170"
  },
  {
    "text": "the stream and completing our count is two but would take if the source emits",
    "start": "2844170",
    "end": "2850560"
  },
  {
    "text": "fewer than count values it will just emit all of those source values and then",
    "start": "2850560",
    "end": "2855600"
  },
  {
    "text": "it will complete when the source completes similarly the take until",
    "start": "2855600",
    "end": "2862260"
  },
  {
    "text": "operator is also needed when you need to complete your operations but it's when",
    "start": "2862260",
    "end": "2868320"
  },
  {
    "text": "you send a notification to a stream that it should complete the second observable",
    "start": "2868320",
    "end": "2873960"
  },
  {
    "text": "is the notifier and when that second observable emits of value the first",
    "start": "2873960",
    "end": "2878970"
  },
  {
    "text": "stream will complete however if the second observable never emits any values",
    "start": "2878970",
    "end": "2884100"
  },
  {
    "text": "or it just completes all of your values from your source observable are going to be emitted so here's one way that you",
    "start": "2884100",
    "end": "2892980"
  },
  {
    "text": "might use take until instead of keeping track of all your subscriptions and then",
    "start": "2892980",
    "end": "2898710"
  },
  {
    "text": "having to unsubscribe from each of them you can pipe all of your streams through",
    "start": "2898710",
    "end": "2904650"
  },
  {
    "text": "a take until operation and then you can next into a destroy subject that will",
    "start": "2904650",
    "end": "2912990"
  },
  {
    "text": "emit a value on on destroy of this component and then it will complete all",
    "start": "2912990",
    "end": "2919080"
  },
  {
    "text": "of these subscriptions so here we're not using the async pipe as we normally",
    "start": "2919080",
    "end": "2925560"
  },
  {
    "text": "would in our template just for the sake of example and when the destroy subject",
    "start": "2925560",
    "end": "2930840"
  },
  {
    "text": "receives the next notification you're going to be able to clean up after yourselves and those subscriptions are",
    "start": "2930840",
    "end": "2936000"
  },
  {
    "text": "going to be completed this really saves us a lot of hassle of having to keep track of and unsubscribe from each",
    "start": "2936000",
    "end": "2942030"
  },
  {
    "text": "subscription but again like we've already talked about different strategies that we can use and maybe you",
    "start": "2942030",
    "end": "2948900"
  },
  {
    "text": "don't even want to have this many subscriptions that you're keeping track of and a component so that's kind of why I call this a weird trick but it's it's",
    "start": "2948900",
    "end": "2956730"
  },
  {
    "text": "a good one that people often use as back up just to be sure that they're not having any memory leaks so typically as",
    "start": "2956730",
    "end": "2968090"
  },
  {
    "text": "we learned earlier with your reactive templates we would have used that async pipe and so we wouldn't have to keep",
    "start": "2968090",
    "end": "2975200"
  },
  {
    "text": "track of any of those manual subscriptions but then one thing that I've really run into within my",
    "start": "2975200",
    "end": "2981200"
  },
  {
    "text": "components is like how the heck do I know and debug what that value is on that",
    "start": "2981200",
    "end": "2987080"
  },
  {
    "text": "observable if I can't access any of those values on my stream in my component class like what what is even",
    "start": "2987080",
    "end": "2994640"
  },
  {
    "text": "going on I can't observe my observable",
    "start": "2994640",
    "end": "2999190"
  },
  {
    "text": "so one quick way to peek inside your observable streams and for maybe those",
    "start": "2999790",
    "end": "3006070"
  },
  {
    "text": "logging or debugging reasons perhaps performing this side effect that doesn't affect the observable is by using this",
    "start": "3006070",
    "end": "3014020"
  },
  {
    "text": "tap operator tap can perform your side effects or your output and returns your",
    "start": "3014020",
    "end": "3020410"
  },
  {
    "text": "stream unchanged so it allows you to inspect your observable stream without",
    "start": "3020410",
    "end": "3025870"
  },
  {
    "text": "having to subscribe to it remember that it does have to have a subscription now",
    "start": "3025870",
    "end": "3031780"
  },
  {
    "text": "let me correct that it has to have a subscription in order for it to be active so maybe you subscribed in the",
    "start": "3031780",
    "end": "3037450"
  },
  {
    "text": "async pipe as we said so remember that a stream then can either terminate a by",
    "start": "3037450",
    "end": "3043510"
  },
  {
    "text": "completion or it can error out and once an error occurs the stream won't emit",
    "start": "3043510",
    "end": "3048520"
  },
  {
    "text": "any more values there's not going to be a complete notification and when it's true when it airs out we we can't use it",
    "start": "3048520",
    "end": "3054790"
  },
  {
    "text": "anymore it's done so sometimes handling those errors in your subscription callback and just",
    "start": "3054790",
    "end": "3061210"
  },
  {
    "text": "allowing the stream to complete that's sufficient that's what we want but rxjs also provides a catch error",
    "start": "3061210",
    "end": "3068950"
  },
  {
    "text": "operator in the case that we want to catch errors in the stream and allow the",
    "start": "3068950",
    "end": "3074710"
  },
  {
    "text": "stream to continue instead of letting it terminate by error so catch air is",
    "start": "3074710",
    "end": "3080710"
  },
  {
    "text": "expected to return a new replacement observable that is going to be used",
    "start": "3080710",
    "end": "3086230"
  },
  {
    "text": "instead of the stream that aired out it allows us to go ahead and contain you so when used with the higher-order",
    "start": "3086230",
    "end": "3094020"
  },
  {
    "text": "observable operators catch error prevents the air from bubbling up into",
    "start": "3094020",
    "end": "3099700"
  },
  {
    "text": "the stream and then still allows the inner observables to be subscribed to and process then into your output a",
    "start": "3099700",
    "end": "3107819"
  },
  {
    "text": "common place that you would see catch error that I have used is with an jrx",
    "start": "3107819",
    "end": "3113230"
  },
  {
    "text": "state management applications because you're often dealing with observable of observables and you want those streams",
    "start": "3113230",
    "end": "3119260"
  },
  {
    "text": "to be able to continue maybe you want to deliver an error to your ng rx store",
    "start": "3119260",
    "end": "3124809"
  },
  {
    "text": "instead of the results but you don't want your application to fully break right so we have talked about a lot of",
    "start": "3124809",
    "end": "3133150"
  },
  {
    "text": "the operators and but the thing is Arceus has so many operators I only have",
    "start": "3133150",
    "end": "3138279"
  },
  {
    "text": "so much time today these are a grouping of the few types of operators that we",
    "start": "3138279",
    "end": "3143829"
  },
  {
    "text": "have discussed I think this grouping really helps sort it out and provide me a way to figure",
    "start": "3143829",
    "end": "3150279"
  },
  {
    "text": "out how to to kind of work with my streams and think about what I want to",
    "start": "3150279",
    "end": "3155529"
  },
  {
    "text": "do and to reach for the correct operator so it's clearly it's not going to be",
    "start": "3155529",
    "end": "3161289"
  },
  {
    "text": "helpful for me to just kind of list them and tell you about all your operators what we need are some strategies to",
    "start": "3161289",
    "end": "3167260"
  },
  {
    "text": "connect those dots and create us a mental model of these operators and the",
    "start": "3167260",
    "end": "3172450"
  },
  {
    "text": "various reasons for using each type of operator the creation operators then",
    "start": "3172450",
    "end": "3178990"
  },
  {
    "text": "what they allow us to do is to create an observable from just about anything",
    "start": "3178990",
    "end": "3184289"
  },
  {
    "text": "observables are just declarative abstractions again of how to process things from a stream so the creation",
    "start": "3184289",
    "end": "3191380"
  },
  {
    "text": "operators are there to wrap other processes like events requests timers",
    "start": "3191380",
    "end": "3197680"
  },
  {
    "text": "etc to create those observable sequences out of them",
    "start": "3197680",
    "end": "3203519"
  },
  {
    "text": "so the purpose none of your join creation operators is to be able to process more than one of those streams",
    "start": "3203849",
    "end": "3210910"
  },
  {
    "text": "as a single stream similar to how maybe your higher-order operators flatten the",
    "start": "3210910",
    "end": "3217059"
  },
  {
    "text": "observables of observables but instead of having a stream that's piped of observables piped through them the",
    "start": "3217059",
    "end": "3223990"
  },
  {
    "text": "join creation operators create a new observable stream from a set of separate observables so like playing from cat",
    "start": "3223990",
    "end": "3231100"
  },
  {
    "text": "playing merge those are your join creation operators combine latest is even a join creation operator next we've",
    "start": "3231100",
    "end": "3243130"
  },
  {
    "text": "got our join operators and those are the pipe herbal operators that let us bring other observables into the stream like",
    "start": "3243130",
    "end": "3250750"
  },
  {
    "text": "your with latest from or your merge all that we saw earlier transforming values",
    "start": "3250750",
    "end": "3257680"
  },
  {
    "text": "as they pass through a stream is such a common scenario that they combined joining with transformation for the",
    "start": "3257680",
    "end": "3265119"
  },
  {
    "text": "higher-order operators like merge map and concatenate the multi casting",
    "start": "3265119",
    "end": "3271180"
  },
  {
    "text": "operators as we talked about first like share allow us to use observables as subjects that can be shared by more than",
    "start": "3271180",
    "end": "3278770"
  },
  {
    "text": "one consumer your filtering operators conditionally emit value values into the",
    "start": "3278770",
    "end": "3286810"
  },
  {
    "text": "output based on that input passing a given predicate function the conditional",
    "start": "3286810",
    "end": "3293950"
  },
  {
    "text": "operators also look for a specific condition or predicate function to be met however they will emit only on",
    "start": "3293950",
    "end": "3302770"
  },
  {
    "text": "completion of your stream the error handling operators are there for",
    "start": "3302770",
    "end": "3308410"
  },
  {
    "text": "preventing the stream from airing out when dealing with the inevitable errors that can occur when you're working with",
    "start": "3308410",
    "end": "3314340"
  },
  {
    "text": "non-deterministic and unpredictable outputs and side-effects perhaps like HTTP the aggregate ones operate on an",
    "start": "3314340",
    "end": "3323320"
  },
  {
    "text": "entire sequence at once and like the conditional operators they only emit on",
    "start": "3323320",
    "end": "3328930"
  },
  {
    "text": "completion the utility operators then add to our arcs Jia's toolkit by letting",
    "start": "3328930",
    "end": "3336340"
  },
  {
    "text": "us inspect log or perform side-effects we can repeat delay timeout or convert",
    "start": "3336340",
    "end": "3343780"
  },
  {
    "text": "an observable and to anis or maybe an array another way to find what you're",
    "start": "3343780",
    "end": "3351550"
  },
  {
    "text": "looking for with arkshya's operators is by using the operator decision tree in",
    "start": "3351550",
    "end": "3357010"
  },
  {
    "text": "the ah yes documentation it will ask you a series of questions about what you're trying to do and take you eventually to",
    "start": "3357010",
    "end": "3364849"
  },
  {
    "text": "the correct operator for what you're looking for so I've extracted some of those decisions here for finding the",
    "start": "3364849",
    "end": "3371989"
  },
  {
    "text": "right creation operators the decision tree doesn't I think really cover everything and this is only again one",
    "start": "3371989",
    "end": "3378769"
  },
  {
    "text": "branch of it but hopefully this kind of helps give you an idea of just how many",
    "start": "3378769",
    "end": "3383869"
  },
  {
    "text": "operators they are the vastness of rxjs but all of the different reasons for",
    "start": "3383869",
    "end": "3390019"
  },
  {
    "text": "needing to use each of them and finally I think when troubleshooting your",
    "start": "3390019",
    "end": "3396559"
  },
  {
    "text": "observables which is an often a thing that we run into in order to crack that code",
    "start": "3396559",
    "end": "3401989"
  },
  {
    "text": "it can really help to start off looking for some clues like how has this",
    "start": "3401989",
    "end": "3408410"
  },
  {
    "text": "observable been subscribe to and how many subscriptions does this observable",
    "start": "3408410",
    "end": "3413449"
  },
  {
    "text": "have potentially duplicating any any requests you want to think about when",
    "start": "3413449",
    "end": "3420380"
  },
  {
    "text": "does this observable complete or if it completes and also again do I need to",
    "start": "3420380",
    "end": "3427190"
  },
  {
    "text": "and should I of course you should unsubscribe from your observables so",
    "start": "3427190",
    "end": "3432529"
  },
  {
    "text": "given that I've tipped you off to some of these strategies and tricks and with definitely with practice and some",
    "start": "3432529",
    "end": "3439549"
  },
  {
    "text": "investigative sleuthing on your own I think that you should probably be able to solve any case that you run across",
    "start": "3439549",
    "end": "3446319"
  },
  {
    "text": "and if you really haven't gotten enough and you're hungry for more rxjs content",
    "start": "3446319",
    "end": "3453109"
  },
  {
    "text": "I think that you should consider attending rxjs live in March right here in London just look at all these amazing",
    "start": "3453109",
    "end": "3460579"
  },
  {
    "text": "speakers I I can't believe I'm one of them early bird ticket sales do end for",
    "start": "3460579",
    "end": "3466309"
  },
  {
    "text": "this conference tomorrow so ask your boss get that approval get in on those early birds get in while the",
    "start": "3466309",
    "end": "3473329"
  },
  {
    "text": "gettin's good early birds get the worms so I really want to thank you all for attending my",
    "start": "3473329",
    "end": "3478849"
  },
  {
    "text": "talk today I'd be happy to take any of your questions and your green feedback cards and this is linked to my example",
    "start": "3478849",
    "end": "3488029"
  },
  {
    "text": "code on github which also has a PDF these slides in github and if you want",
    "start": "3488029",
    "end": "3494720"
  },
  {
    "text": "to go ahead and just use SlideShare to click through I have a link to that as well and I'll leave that up for you so",
    "start": "3494720",
    "end": "3499790"
  },
  {
    "text": "you can grab those thanks again [Applause]",
    "start": "3499790",
    "end": "3507289"
  }
]