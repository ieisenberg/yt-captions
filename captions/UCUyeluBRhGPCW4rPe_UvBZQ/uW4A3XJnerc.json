[
  {
    "text": "all right an optimization that is impossible in R so we're going to read",
    "start": "40",
    "end": "5600"
  },
  {
    "text": "this and then we'll go back and we'll read this one because I'm actually curious about that an optimization that's impossible in Rust we don't have",
    "start": "5600",
    "end": "12519"
  },
  {
    "text": "enough string types in Rust okay oh don't we have enough oh gosh",
    "start": "12519",
    "end": "17560"
  },
  {
    "text": "yeah I do have severe dyslexia um hey it's your guys's fault you listen to a",
    "start": "17560",
    "end": "24279"
  },
  {
    "text": "guy who can't read okay that's not my fault last time I checked I looked at my",
    "start": "24279",
    "end": "29679"
  },
  {
    "text": "watch I didn't make this decision you did as I'm studying database systems for my",
    "start": "29679",
    "end": "34680"
  },
  {
    "text": "master degree in geomy this article why German strings are everywhere immediately caught my attention I was",
    "start": "34680",
    "end": "39960"
  },
  {
    "text": "pretty excited to learn it's the string data structure described in a paper Umbra a dis based system with inmemory",
    "start": "39960",
    "end": "47360"
  },
  {
    "text": "performance interesting okay which has been which had been introduced to me through another paper about its storage",
    "start": "47360",
    "end": "54000"
  },
  {
    "text": "engine lean store inmemory data management Beyond main memory I was even more interested to learn that it's been",
    "start": "54000",
    "end": "60000"
  },
  {
    "text": "implemented in many different Data Solutions like Duck DB Apache arrow and polar is that uh is poers the uh Panda's",
    "start": "60000",
    "end": "67200"
  },
  {
    "text": "replacement right Prime getting old no victim blaming much H it's your guys",
    "start": "67200",
    "end": "74960"
  },
  {
    "text": "you're still you're the victims actually I feel like you're actually the",
    "start": "74960",
    "end": "80320"
  },
  {
    "text": "benefactors you know the more I think about this the more I think you're actually the benefactors of my inability",
    "start": "80320",
    "end": "85640"
  },
  {
    "text": "to read than anything else no no polers is the data frame Liv in Rust but poers",
    "start": "85640",
    "end": "91200"
  },
  {
    "text": "is also uh uh pollers is also a python Li Library P po. RS is the rust one he's",
    "start": "91200",
    "end": "101479"
  },
  {
    "text": "on to us one thing that particularly stood out from the article had me puzzled was the",
    "start": "101479",
    "end": "107159"
  },
  {
    "text": "following claim this string implementation allows for a for the very important short string optimization a",
    "start": "107159",
    "end": "113399"
  },
  {
    "text": "short enough string can be stored in place I.E we set a specific bit in the capacity field and the remain let's see",
    "start": "113399",
    "end": "120759"
  },
  {
    "text": "the remainder of the capacity as well as the size and pointer become the string itself this way we save on allocating a",
    "start": "120759",
    "end": "127399"
  },
  {
    "text": "buffer and a pointer D reference each time we access the string an optimization that's impossible in Rust",
    "start": "127399",
    "end": "132840"
  },
  {
    "text": "by the way winky face that's super cool okay so before I look at any of the",
    "start": "132840",
    "end": "137920"
  },
  {
    "text": "details any of that I'm having a hard time thinking about that because the first thing I'm thinking about is that I",
    "start": "137920",
    "end": "144280"
  },
  {
    "text": "thought a string was pointer Len",
    "start": "144280",
    "end": "151200"
  },
  {
    "text": "cap right and so therefore it's a super fat bite right it's a super fat pointer",
    "start": "151200",
    "end": "157360"
  },
  {
    "text": "Triple Fat pointer and so does that mean it stores a bit right here and so what",
    "start": "157360",
    "end": "162720"
  },
  {
    "text": "happens so okay so if I get this correctly the pointer points off to a memory space like that right and so therefore",
    "start": "162720",
    "end": "171400"
  },
  {
    "text": "instead a short string optimization is that this memory space is actually just stored right here that's pretty nifty",
    "start": "171400",
    "end": "178720"
  },
  {
    "text": "okay and okay okay no cap for real on the stack oh God man damn if I correctly interpret the",
    "start": "178720",
    "end": "186440"
  },
  {
    "text": "statement it's objectively wrong because there are already lots of packages in Rust that support this exact feature EG",
    "start": "186440",
    "end": "192200"
  },
  {
    "text": "compact stir smart stir and small stir moreover polers an example from the article is written in Rust and",
    "start": "192200",
    "end": "198599"
  },
  {
    "text": "implements Umbra styled string I got nerd stiped and started implementing German string to show myself it was",
    "start": "198599",
    "end": "204159"
  },
  {
    "text": "possible I can't blame the guy for getting nerd sniped because literally this right here is me getting nerd",
    "start": "204159",
    "end": "211560"
  },
  {
    "text": "sniped so rather than letting the AI fail and requiring the human to always give it feedback until the final result",
    "start": "211560",
    "end": "217760"
  },
  {
    "text": "is correct in some cases you can automate the feedback process and run the AI on a loop so in cases where you",
    "start": "217760",
    "end": "223879"
  },
  {
    "text": "can automatically check for so I built my own I built my own that looks like",
    "start": "223879",
    "end": "230080"
  },
  {
    "text": "this run generated code run test uh or run code gen run test run reasoning and",
    "start": "230080",
    "end": "236879"
  },
  {
    "text": "it just does it in a loop that that literal one line got me to build an entire entire AI thing because I",
    "start": "236879",
    "end": "244680"
  },
  {
    "text": "couldn't I couldn't help it I was just like I got to I got to figure this out okay we're going to prompt we're going to prompt the AI we're going to run the",
    "start": "244680",
    "end": "251560"
  },
  {
    "text": "test and then we're going to get the AI to reason why it's wrong and oh my goodness I get it I totally get getting",
    "start": "251560",
    "end": "258239"
  },
  {
    "text": "nerd sniped it happens it happens to the best of us don't don't feel bad how much better was it it was pretty fun it it",
    "start": "258239",
    "end": "265440"
  },
  {
    "text": "was a fun learning experience I learned a lot more about pring what's a nerd snipe someone said suggest something and",
    "start": "265440",
    "end": "271280"
  },
  {
    "text": "it's impossible to do X or hey this is really really good if you do it this way",
    "start": "271280",
    "end": "276919"
  },
  {
    "text": "and you don't believe them and then you do it and then you end up writing it all it's called getting nerd sniped all of a",
    "start": "276919",
    "end": "282039"
  },
  {
    "text": "sudden you find yourself programming a whole bunch right you just can't help it I just can't help it uh all right let's see there's a certain type of brain that",
    "start": "282039",
    "end": "288639"
  },
  {
    "text": "is easily disabled if you show it in an interesting problem it involuntarily drops everything else to work on it Yep",
    "start": "288639",
    "end": "294639"
  },
  {
    "text": "this is it has led me to invent a new sport nerd sniping see that uh physicist Crossing the road hey uh on this",
    "start": "294639",
    "end": "302440"
  },
  {
    "text": "infinite grid of of Ideal 1 ohm resistors what's the equivalent resistance between the two marked nodes",
    "start": "302440",
    "end": "308880"
  },
  {
    "text": "oh gosh I don't even know what it is H interesting maybe if you start with no wait hm you could vom oh he's dead I'll",
    "start": "308880",
    "end": "316199"
  },
  {
    "text": "have no part in this come on man uh come on make a sign it's fun physicists are two point mathematicians",
    "start": "316199",
    "end": "323759"
  },
  {
    "text": "three oh so he killed the guy oh he killed him in the middle of the road okay I get it nerd sniping it's pretty",
    "start": "323759",
    "end": "329840"
  },
  {
    "text": "funny that's a pretty funny it's a pretty funny one uh in this article I've never I've only heard nerd sniping I didn't realize that it it came from XKCD",
    "start": "329840",
    "end": "337479"
  },
  {
    "text": "right in this article I'll describe how I Implement German string and the challenges and the challenges of doing",
    "start": "337479",
    "end": "343319"
  },
  {
    "text": "so in Russ specifically I'll examine how to enable shared ownership of such data structure providing unique ownership is",
    "start": "343319",
    "end": "349160"
  },
  {
    "text": "relatively trivial and there is already a nicely written tutorial from the rustan con teaching you how to implement",
    "start": "349160",
    "end": "355680"
  },
  {
    "text": "VC which is not much different from a string but first let's talk about the concept of German string okay okay don't",
    "start": "355680",
    "end": "361400"
  },
  {
    "text": "we have enough string types in Rust the term German styled string was coined by Andy pvo Pavo uh in one of his lectures",
    "start": "361400",
    "end": "368160"
  },
  {
    "text": "Advanced database systems German string by the way I got nerd sniped by this one in optimization that's impossible in",
    "start": "368160",
    "end": "373479"
  },
  {
    "text": "Rust this like look at this I I'm reading an article all because of the",
    "start": "373479",
    "end": "378919"
  },
  {
    "text": "title I'm in this photo and I do not like it uh yeah in one of his lectures on Advanced databas database systems",
    "start": "378919",
    "end": "385080"
  },
  {
    "text": "German string uh German styled string and Umbra sty string all refer to the",
    "start": "385080",
    "end": "390599"
  },
  {
    "text": "same concept at a high level strings are conceptually simple just a sequence of characters however there's more going on",
    "start": "390599",
    "end": "397080"
  },
  {
    "text": "with strings than one may realize even the concept of a character is already a complex thing itself depending on the",
    "start": "397080",
    "end": "402199"
  },
  {
    "text": "use case how a string is represented in memory can differ widely just within rust there are several different types",
    "start": "402199",
    "end": "408160"
  },
  {
    "text": "of string each of the following types has its own corresponding borrowed version string utf8 encoded C string and",
    "start": "408160",
    "end": "415639"
  },
  {
    "text": "owned C compatible null terminated string with null bites in the Middle with no null bites in the middle OSS",
    "start": "415639",
    "end": "420840"
  },
  {
    "text": "string an owned mutable platform native string that is uh but is cheaply interconvertible with rust strings a",
    "start": "420840",
    "end": "426479"
  },
  {
    "text": "thin wrapper around OSS string or uh operating system string representing an owned mutable path okay yes and there's",
    "start": "426479",
    "end": "433520"
  },
  {
    "text": "a lot more type of stuff the nice part about Zig there is just uh there's just a an array of u8 well didn't Chris lner",
    "start": "433520",
    "end": "441199"
  },
  {
    "text": "say he was nerd sniped into creating lvm yes yes he did uh rust string string is the most commonly used type in Rust and",
    "start": "441199",
    "end": "447479"
  },
  {
    "text": "thus will be the subject of our discussion internally string is just a VC of u8 I.E a sequence of bytes",
    "start": "447479",
    "end": "453360"
  },
  {
    "text": "additionally that sequence of bytes must be utf8 encoded meaning a character is not always just a bite but ranges",
    "start": "453360",
    "end": "459120"
  },
  {
    "text": "between one and four bytes this the implementation of string is as follows minus some details yeah so that's so",
    "start": "459120",
    "end": "465840"
  },
  {
    "text": "this is assuming string as a the bytes have some sort of of like displaying",
    "start": "465840",
    "end": "471560"
  },
  {
    "text": "information to it whereas Zig or other languages often will treat string as not UTF required right it's just simply it",
    "start": "471560",
    "end": "479680"
  },
  {
    "text": "is just a list of eight eight bits right eight bit chunks and so that's",
    "start": "479680",
    "end": "486120"
  },
  {
    "text": "how you know yeah of encoding yeah there's an assumed encoding to string it's just a v 8 uh ve is just a raw V",
    "start": "486120",
    "end": "493919"
  },
  {
    "text": "length size there we go raw V equals this pointer capacity allocate I'm not sure what this is global allocator I",
    "start": "493919",
    "end": "499960"
  },
  {
    "text": "don't know what's going on here public unique I don't even know what we're looking at I still don't know what Phantom data is I probably need to learn",
    "start": "499960",
    "end": "507039"
  },
  {
    "text": "I quit learning rust when I got to Phantom data honestly I I was just like I'm tired of this uh that looks uh too",
    "start": "507039",
    "end": "513320"
  },
  {
    "text": "complicated but essentially a string consists of three parts on the stack that take up 24 bytes length capacity",
    "start": "513320",
    "end": "518640"
  },
  {
    "text": "pointer yep length capacity pointer okay so pointers at the end not at the beginning okay whoopsy daisies uh",
    "start": "518640",
    "end": "524159"
  },
  {
    "text": "Phantom day is just there to make use of T is is that it but so does non null I don't know uh as a string uh is mutable",
    "start": "524159",
    "end": "532000"
  },
  {
    "text": "and I think it has something else I think there's something else but I can't remember what it is I read John talking about Phantom data and I think I got it",
    "start": "532000",
    "end": "538000"
  },
  {
    "text": "for a little bit but now I can't remember it's been it's been a while anyways a string is mutable and can be appended to",
    "start": "538000",
    "end": "544399"
  },
  {
    "text": "when needed so we need to track the length and the capacity with an invariant that uh that cap is greater",
    "start": "544399",
    "end": "551000"
  },
  {
    "text": "than or equal to length whenever length grows larger than cap a new buffer is created with enough enough capacity to",
    "start": "551000",
    "end": "556880"
  },
  {
    "text": "hold the string with a new length and the old buffer gets deallocated German strings theoretically a string can hold",
    "start": "556880",
    "end": "562560"
  },
  {
    "text": "infinitely many different kinds of text within infinite sizes nonetheless the real world usages of strings especially",
    "start": "562560",
    "end": "569000"
  },
  {
    "text": "in datab bases can be can observe a few common characteristics most strings are short most strings don't change only a",
    "start": "569000",
    "end": "575519"
  },
  {
    "text": "tiny substring is looked at When comparing or ordering strings okay based on those observations German strings was",
    "start": "575519",
    "end": "582040"
  },
  {
    "text": "invented to address these specific use cases aiming to accelerate string processing performance the basic idea",
    "start": "582040",
    "end": "587079"
  },
  {
    "text": "follows what is called short string optimization instead of allocating a buffer on the Heap we can avoid the",
    "start": "587079",
    "end": "592839"
  },
  {
    "text": "expensive allocation and store the bites directly on the stack for short enough strings by repurposing cap and pointer",
    "start": "592839",
    "end": "598920"
  },
  {
    "text": "having no no allocation also means we don't need to follow pointers when access uh accessing short strings this",
    "start": "598920",
    "end": "605680"
  },
  {
    "text": "is actually such a cool optimization this is super cool this is super super cool internally a German string takes",
    "start": "605680",
    "end": "611399"
  },
  {
    "text": "only 16 bytes on the stack uh and has two different representation depending on the string length a German string uh",
    "start": "611399",
    "end": "617800"
  },
  {
    "text": "is also immutable by removing the need to track the buffer and capacity okay so you got four bytes here 12 bytes on this",
    "start": "617800",
    "end": "624200"
  },
  {
    "text": "thing okay cool this is super cool oh is it just like small ve is small ve also",
    "start": "624200",
    "end": "629640"
  },
  {
    "text": "this exact same thing okay awesome uh German string layout for short strings",
    "start": "629640",
    "end": "635000"
  },
  {
    "text": "strings uh at most 12 bytes are inlined and stored directly on the stack out of the 16 bytes four are used to hold the",
    "start": "635000",
    "end": "641000"
  },
  {
    "text": "string length and 12 are used to hold the string content nice uh long strings",
    "start": "641000",
    "end": "647760"
  },
  {
    "text": "okay strings over 12 bytes are Heap allocated like uh like string and have a pointer to the Heap allocated buffer but",
    "start": "647760",
    "end": "654320"
  },
  {
    "text": "there are a few twists only four bytes to hold the string length instead of eight thus limiting the uh string size",
    "start": "654320",
    "end": "659440"
  },
  {
    "text": "to 4 gbes which is completely acceptable this is acceptable because most strings using the real world are short yeah",
    "start": "659440",
    "end": "664519"
  },
  {
    "text": "they're never yeah that it'd be super unusual to see something of that size a 4 byte prefix from the string is inlined",
    "start": "664519",
    "end": "670600"
  },
  {
    "text": "and stored directly on the stack for most string comparison operations this can help avoid expensive pointer D",
    "start": "670600",
    "end": "675800"
  },
  {
    "text": "referencing when the result can be determined just using uh uh using just the prefix oh nice okay oh that's super",
    "start": "675800",
    "end": "683800"
  },
  {
    "text": "clever just the first four bytes oh that's super super clever okay yeah because you're just",
    "start": "683800",
    "end": "689800"
  },
  {
    "text": "doing this initial check and if these if if these two things don't equal then there's no need to actually check the",
    "start": "689800",
    "end": "694959"
  },
  {
    "text": "full length oh that's like super duper clever people be so dang",
    "start": "694959",
    "end": "700399"
  },
  {
    "text": "clever uh four gigabytes is not enough for German words yeah so German of you",
    "start": "700399",
    "end": "705639"
  },
  {
    "text": "uh or German strings or g strings for short damn I don't know how I didn't see",
    "start": "705639",
    "end": "710920"
  },
  {
    "text": "that coming dude I didn't know programers be busted out here it's crazy now that we know the basic shape of",
    "start": "710920",
    "end": "717240"
  },
  {
    "text": "German string and its motivation let's see how we can implement it using rust to start we aimed to implement an owned",
    "start": "717240",
    "end": "723480"
  },
  {
    "text": "immutable string that is utf8 encoded and supports the optimization techniques described earlier moreover the Heap",
    "start": "723480",
    "end": "729639"
  },
  {
    "text": "allocated buffer will have shared ownership using Atomic reference counting allowing us to reuse it across",
    "start": "729639",
    "end": "736760"
  },
  {
    "text": "threads interesting Atomic reference counting on your strings that may not be wanted I mean you may want RC's as well",
    "start": "736760",
    "end": "742680"
  },
  {
    "text": "you know maybe being able to specify I always feel like whenever I use arcs and RC's I kind of feel like I'm I'm kind of",
    "start": "742680",
    "end": "748440"
  },
  {
    "text": "like ruining the use of rust I always feel just bad using them you know",
    "start": "748440",
    "end": "753480"
  },
  {
    "text": "because it's just like now you you're no longer maintaining the lifetime in the ownership and saying hey it's it's it's",
    "start": "753480",
    "end": "759680"
  },
  {
    "text": "this long and that's it it feels dirty but it's fire yeah it is yeah I feel dirty too yeah whenever I use it",
    "start": "759680",
    "end": "765160"
  },
  {
    "text": "something in the back of my head Whispers hey man come on what are you trying to do that what is this you",
    "start": "765160",
    "end": "771440"
  },
  {
    "text": "trying to do Objective C over here it's really it really is okay I know it's okay I know it's okay but I still feel",
    "start": "771440",
    "end": "778880"
  },
  {
    "text": "it I still feel The Objective C calling to me uh struct Umbra string length 32 data",
    "start": "778880",
    "end": "786600"
  },
  {
    "text": "this okay uh Union data I didn't realize they had Union unions oh did I not know that I didn't",
    "start": "786600",
    "end": "793399"
  },
  {
    "text": "know that I didn't realize that I thought they just had enums a buffer of 12 and a pointer manually dropped shared",
    "start": "793399",
    "end": "800279"
  },
  {
    "text": "dine bites okay uh struck shared dine bites prefix of this pointer",
    "start": "800279",
    "end": "806079"
  },
  {
    "text": "nonnull uh isn't okay nonnull shared by B dtes Phantom shared B shared dine",
    "start": "806079",
    "end": "812199"
  },
  {
    "text": "bites inner okay using rust layout rules shared dine bites has a size of 16 bytes and an alignment of eight resulting in",
    "start": "812199",
    "end": "818920"
  },
  {
    "text": "an umra umbra string having a size 24 bytes and an alignment of eight this is different from the layout we want to",
    "start": "818920",
    "end": "824560"
  },
  {
    "text": "make Umbra 16 bytes we can lower shared dine btes alignment to four and make everything correctly sized using the",
    "start": "824560",
    "end": "830519"
  },
  {
    "text": "repper packed four however clippy Russ linter won't be happy with us when we reference the pointer field in shared",
    "start": "830519",
    "end": "836720"
  },
  {
    "text": "dine bites because we might create a reference to an unaligned address which is undefined behavior and rust while we",
    "start": "836720",
    "end": "843680"
  },
  {
    "text": "never need to make such a reference we are prevented from using some apis on pointers which are nice to have length",
    "start": "843680",
    "end": "851360"
  },
  {
    "text": "padding prefix padding pointer okay so that's not umra string layout for long",
    "start": "851360",
    "end": "856519"
  },
  {
    "text": "strings with Fields okay but that's not right that's not look at that that doesn't feel right that's not right oh",
    "start": "856519",
    "end": "862959"
  },
  {
    "text": "move the chat up yeah yeah yeah yeah yeah yeah yeah sorry I have the chat there so it doesn't intersect with uh alerts here let me just grab alerts for",
    "start": "862959",
    "end": "868800"
  },
  {
    "text": "a second and I'll just move alerts over again there you go uh the rust lter is called clippy yes",
    "start": "868800",
    "end": "875880"
  },
  {
    "text": "it is I also refuse to use the rust linter because it has crappy opinions I like",
    "start": "875880",
    "end": "881759"
  },
  {
    "text": "the return keyword suck it rust I don't care uh a more considerable annoyance is that this complicates implementing",
    "start": "881759",
    "end": "887160"
  },
  {
    "text": "string comparison and ordering When comparing or ordering strings we want to deal with prefix before anything else",
    "start": "887160",
    "end": "892800"
  },
  {
    "text": "with this layout we must first check the string length to determine whether data is a buff or a pointer before getting to",
    "start": "892800",
    "end": "898560"
  },
  {
    "text": "the prefix to overcome that we can Mark everything with CER or reer C and rely",
    "start": "898560",
    "end": "903920"
  },
  {
    "text": "on the invariant that prefix is the first field in shared dine bytes as a result we can interpret data as a buff",
    "start": "903920",
    "end": "909800"
  },
  {
    "text": "without checking the length and still be sound if we only access the first four bytes a better approach without relying",
    "start": "909800",
    "end": "916160"
  },
  {
    "text": "on such invariant and freeing us from worrying about field field orders is as",
    "start": "916160",
    "end": "921800"
  },
  {
    "text": "follows okay umber string has now length prefix struct okay Union is going to be",
    "start": "921800",
    "end": "928360"
  },
  {
    "text": "either eight or a manually dropped shared D bites okay okay memory wise there's no difference comp uh compared",
    "start": "928360",
    "end": "933920"
  },
  {
    "text": "to the reer C Pack 4 version instead of having a 12 byte Union our new Union trailing is only eight bytes containing",
    "start": "933920",
    "end": "939880"
  },
  {
    "text": "either the last eight bytes of the string or a pointer to a heap allocated buffer here the prefix is pulled out of",
    "start": "939880",
    "end": "945519"
  },
  {
    "text": "the union for easy access and rust allows layout rules to work its magic without too much inference from us",
    "start": "945519",
    "end": "951759"
  },
  {
    "text": "having the prefix as forbite array also improves performance because comparing fix size arrays performs much better",
    "start": "951759",
    "end": "957839"
  },
  {
    "text": "than comparing slices yeah okay so I never knew that it had Union what",
    "start": "957839",
    "end": "963360"
  },
  {
    "text": "are the I wonder I I've never seen the uh the semantics around using Union can you still just match on a union and just say like if it's buff it does buff if",
    "start": "963360",
    "end": "970319"
  },
  {
    "text": "it's pointer if it's pointer and if you can do that how does it know if it's buff or if it's pointer that's the one thing that I'm a",
    "start": "970319",
    "end": "976759"
  },
  {
    "text": "bit confused on is how how do you know it which is which when it comes to this",
    "start": "976759",
    "end": "982000"
  },
  {
    "text": "because it's not like a tag Union you can't match yeah I figured you could match because it it doesn't have a tag",
    "start": "982000",
    "end": "987639"
  },
  {
    "text": "uh you have you have to check the bit that specifies the short string yes okay so that means there is a bit somewhere",
    "start": "987639",
    "end": "993040"
  },
  {
    "text": "that says the short string okay okay okay so you're doing the manual understanding of the Union okay super",
    "start": "993040",
    "end": "998600"
  },
  {
    "text": "cool I didn't realize you could do that with rust hey today I learned that rust has unions I I always just thought it",
    "start": "998600",
    "end": "1004199"
  },
  {
    "text": "had enums I didn't realize it had unions aren't they both valid simultaneously they are technically both valid",
    "start": "1004199",
    "end": "1009240"
  },
  {
    "text": "simultaneously that is a union uh I just didn't know that you could do that cool Atomic reference counted bites shared Dy",
    "start": "1009240",
    "end": "1015120"
  },
  {
    "text": "bites and atomic reference counted bite slice behaves like an arc this begs the why don't just use AR",
    "start": "1015120",
    "end": "1021120"
  },
  {
    "text": "u8 dynamically sized types most types in Rust have a statically known size and Alignment Dynamic sized types dsts are",
    "start": "1021120",
    "end": "1028480"
  },
  {
    "text": "expected to come from this Rule and rust exposes two major dsts trait objects dine traits and slices because uh dsts",
    "start": "1028480",
    "end": "1036360"
  },
  {
    "text": "don't have a statically known size they can't be on the stack and must be accessed through a pointer consequently",
    "start": "1036360",
    "end": "1041720"
  },
  {
    "text": "every pointer to a DST is a fat pointer consisting of the pointer itself and additional information about the data being pointed to in this case of a slice",
    "start": "1041720",
    "end": "1049160"
  },
  {
    "text": "in which we're interested the extra information is length the results in Arc T having a slice of 16 bytes instead of",
    "start": "1049160",
    "end": "1056280"
  },
  {
    "text": "eight causing umber stream to take 24 bytes instead of 16 okay this makes perfect sense I see why they don't do",
    "start": "1056280",
    "end": "1061559"
  },
  {
    "text": "that okay okay does do people understand this the reason why this makes sense is",
    "start": "1061559",
    "end": "1068960"
  },
  {
    "text": "that when you have a slice you don't get to know how long it is the like at compile time you need to",
    "start": "1068960",
    "end": "1075440"
  },
  {
    "text": "know what you're putting on the stack versus the Heap and so this is",
    "start": "1075440",
    "end": "1082360"
  },
  {
    "text": "unknown so therefore it has to have two that's why it has to have two sets it has to have the pointer and then where",
    "start": "1082360",
    "end": "1088840"
  },
  {
    "text": "the thing the pointer plus the length right it has to it has to be able to understand how to put it onto the",
    "start": "1088840",
    "end": "1094480"
  },
  {
    "text": "stack and so you can't you can't just do something like this where you have either the data itself or a pointer to",
    "start": "1094480",
    "end": "1101159"
  },
  {
    "text": "the data which is then specified by this thing over",
    "start": "1101159",
    "end": "1107320"
  },
  {
    "text": "here uh the reason this is so hard really is because rust doesn't deal with bitfields so in C++ you can make this a",
    "start": "1107520",
    "end": "1113799"
  },
  {
    "text": "lot easier with bitfields yeah yeah yeah it's it's not an unknown unknown yeah exactly are we just are we just edging",
    "start": "1113799",
    "end": "1120760"
  },
  {
    "text": "memory layout we are this is actually super interesting I'm loving this by the way uh umber string layout using Arc u8",
    "start": "1120760",
    "end": "1126880"
  },
  {
    "text": "we know that umber string already keeps track of the length and the extra length Associated uh with the fat pointer can be discarded correct that's why it's",
    "start": "1126880",
    "end": "1133360"
  },
  {
    "text": "just a pointer because you already have a length we need a way to turn a fat pointer into a thin pointer uh and",
    "start": "1133360",
    "end": "1138960"
  },
  {
    "text": "that's not supported by rctt Uh current currently there's no way to construct a DST and we can only create an instance",
    "start": "1138960",
    "end": "1146039"
  },
  {
    "text": "of a custom DST by making a generic and Performing unsized coercion okay I don't",
    "start": "1146039",
    "end": "1151280"
  },
  {
    "text": "understand I i' I've never got this far into rust so I don't understand that having the problem described here are our structs describing a reference",
    "start": "1151280",
    "end": "1157840"
  },
  {
    "text": "counted bytes slightly different from the previous example okay so we repy uh shared dine bites it's a pointer to",
    "start": "1157840",
    "end": "1164440"
  },
  {
    "text": "non-null this I don't get this generic what is this generic doing is this",
    "start": "1164440",
    "end": "1169600"
  },
  {
    "text": "generic saying it it's an array of zero bytes I don't get that and same with",
    "start": "1169600",
    "end": "1175480"
  },
  {
    "text": "that one yep I got too stupid for this one I don't get it shared bite uh shared",
    "start": "1175480",
    "end": "1181280"
  },
  {
    "text": "dine bites inner Atomic uze okay so this is for the atomic reference counting it's a zst a zero sized uh a zero sized",
    "start": "1181280",
    "end": "1189120"
  },
  {
    "text": "yep I'm not sure what they're doing here okay so a lot of people don't understand and then the data t Okay a struct can be",
    "start": "1189120",
    "end": "1195120"
  },
  {
    "text": "made a DST by having its last field be a DST here shared dine bytes inner holds a",
    "start": "1195120",
    "end": "1201240"
  },
  {
    "text": "reference count and a generic value over an unsized type shared dine bytes inner",
    "start": "1201240",
    "end": "1206400"
  },
  {
    "text": "is always allocated on the Heap and the atomic count tracks the number of references currently being given out by",
    "start": "1206400",
    "end": "1212280"
  },
  {
    "text": "allocating both the reference count and data we can avoid one extra allocation and IND Direction while it is generic we",
    "start": "1212280",
    "end": "1219159"
  },
  {
    "text": "are only interested in two specializations of the type that have the exact struct alignment and field",
    "start": "1219159",
    "end": "1224840"
  },
  {
    "text": "okay shared byes D and pointer shared by D pointer these two it has a count of two all right shed by Stein this one has",
    "start": "1224840",
    "end": "1230840"
  },
  {
    "text": "a counter of one okay we get that shed by Stein inner is a dynamically sized",
    "start": "1230840",
    "end": "1236440"
  },
  {
    "text": "and pointers uh to it are fat this one is statically sized and the pointers are thin oh that's why they say that oh oh",
    "start": "1236440",
    "end": "1246679"
  },
  {
    "text": "okay so by by having a by having the sh let me get this straight by having the type be a known size there is no fat",
    "start": "1246679",
    "end": "1254400"
  },
  {
    "text": "pointer is that what is that what I'm saying they it's able to say oh this thing's actually a thin pointer in other",
    "start": "1254400",
    "end": "1259960"
  },
  {
    "text": "words it can drop the length field because the length is already known on it I think is that what I'm is that what I'm seeing that's wild okay you're well",
    "start": "1259960",
    "end": "1267720"
  },
  {
    "text": "past my ability here uh one cool trick that we can do is converting between fat pointer type mute share okay isn't this",
    "start": "1267720",
    "end": "1273840"
  },
  {
    "text": "aren't we already in unsafe territory at this point and a thin pointer of mute shared to dying bites inner this",
    "start": "1273840",
    "end": "1279520"
  },
  {
    "text": "conversion allows us to add and remove information about slices uh slice length from a pointer depending on how we want",
    "start": "1279520",
    "end": "1285039"
  },
  {
    "text": "to use it converting a fat pointer to a thin pointer is easy just a single fast bam okay fat pointer thin",
    "start": "1285039",
    "end": "1295159"
  },
  {
    "text": "pointer okay but there's more dark magic to converting a thin pointer to a fat one instead of a direct cast we must",
    "start": "1295159",
    "end": "1301400"
  },
  {
    "text": "first turn a thin pointer to a pointer to a slice with a specific length which tells Russ to embed information about",
    "start": "1301400",
    "end": "1307480"
  },
  {
    "text": "the length into the pointer only after that can we uh can the sliced pointer be cast into a point uh pointer to our",
    "start": "1307480",
    "end": "1313520"
  },
  {
    "text": "custom DST thin pointer from here fake slice pointer uh standard pointer slic",
    "start": "1313520",
    "end": "1319320"
  },
  {
    "text": "from raw Parts into this one and then we do a fake slice as this one oh okay okay",
    "start": "1319320",
    "end": "1325320"
  },
  {
    "text": "okay there we go allocating now that we can convert between a thin pointer and a fat pointer we can start allocating memory for it unless we can coers a",
    "start": "1325320",
    "end": "1331640"
  },
  {
    "text": "statically sized type into a dynamically sized type we can only create a value of a DST by manually allocating it before",
    "start": "1331640",
    "end": "1337720"
  },
  {
    "text": "doing that we must Define a lay layout and allocate the value we have a new layout which extends this array layout",
    "start": "1337720",
    "end": "1344320"
  },
  {
    "text": "of u8 expect the layout to be this one dot zero must be a tuple of something some sort pad to a line layout boom",
    "start": "1344320",
    "end": "1350760"
  },
  {
    "text": "let's go let's go zero let's go. zero that is still to this day that always kind of",
    "start": "1350760",
    "end": "1357039"
  },
  {
    "text": "weirds me out a little bit isn't a slice from raw uh Parts mute unsafe yeah you",
    "start": "1357039",
    "end": "1362240"
  },
  {
    "text": "can tell it's unsafe because look it's you can tell things are on saafe mode because you're right here there is you don't use pointers in Rust you use",
    "start": "1362240",
    "end": "1369720"
  },
  {
    "text": "references when you're in unsafe rust you'll see things like this you're now in unsafe land unless if I'm completely",
    "start": "1369720",
    "end": "1376279"
  },
  {
    "text": "incorrect uh so 0 Z is the equivalent no it's not the same uh 0 Z means the first",
    "start": "1376279",
    "end": "1381720"
  },
  {
    "text": "item in a tupal so does the install wizard do the dark magic for me uh could the Zero have",
    "start": "1381720",
    "end": "1388320"
  },
  {
    "text": "to do with it being a union o it could be a union uh but not the underlying struct I assume whatever comes back from",
    "start": "1388320",
    "end": "1393840"
  },
  {
    "text": "this thing right here uh this layout is uh I assume this is an",
    "start": "1393840",
    "end": "1399320"
  },
  {
    "text": "option it's it's something that you can call do expect on so it's either an option or a result or whatever it is so",
    "start": "1399320",
    "end": "1406240"
  },
  {
    "text": "you can do that unwrap it with a with an exception with a with a program halt uh",
    "start": "1406240",
    "end": "1411799"
  },
  {
    "text": "panic and then grab the first item out it's a tupal of some sort unsafe curs sh",
    "start": "1411799",
    "end": "1416880"
  },
  {
    "text": "yeah the layout is constructed by first creating a layout for shared d uh dine bites inner where the field data has a",
    "start": "1416880",
    "end": "1422760"
  },
  {
    "text": "zero size types taking no space we then extend that layout with the layout of type bite array resulting in a layout",
    "start": "1422760",
    "end": "1429360"
  },
  {
    "text": "for shared dine bites inner with a slice of u8 with that layout we can allocate just enough space for our Atomic count",
    "start": "1429360",
    "end": "1435559"
  },
  {
    "text": "and bite and a bite array of arbitrary size ah classic classic we just got to do that",
    "start": "1435559",
    "end": "1442600"
  },
  {
    "text": "honestly I yo dog I'm happy for you or I'm",
    "start": "1442600",
    "end": "1450559"
  },
  {
    "text": "sorry uh fat po fat shaming pointers we are this is basically C++ this is",
    "start": "1450559",
    "end": "1456799"
  },
  {
    "text": "actually harder than C++ you've now officially made rust more confusing than C++ congratulations or",
    "start": "1456799",
    "end": "1463080"
  },
  {
    "text": "I'm sorry for you uh looks good to me yeah Ted was right Ted was actually right uh we take a lazy approach to",
    "start": "1463080",
    "end": "1468760"
  },
  {
    "text": "allocation nothing is allocated if the given slice is empty if it's not empty we do the following allocate using the",
    "start": "1468760",
    "end": "1473880"
  },
  {
    "text": "layout we defined cast The Returned pointer to a fat pointer to our DST copy the data from the given slice into the",
    "start": "1473880",
    "end": "1479399"
  },
  {
    "text": "data field cast The Fat pointer back to a thin pointer and store it boom that's what this one is this is the uh fat this",
    "start": "1479399",
    "end": "1485279"
  },
  {
    "text": "is the fat to thin right yep lot of coping copy non overlapping yeah like",
    "start": "1485279",
    "end": "1491120"
  },
  {
    "text": "I'm I'm completely at this point I've lost the game with rust and I'm only vaguely following what's happening now but I want to finish it because it",
    "start": "1491120",
    "end": "1498960"
  },
  {
    "text": "it's very difficult uh unsafe rust sounds like C it's it's it's a lot harder than C because you still have to",
    "start": "1498960",
    "end": "1504000"
  },
  {
    "text": "do all the things let me leode while I see you okay do it baby because our reference counted type doesn't have the",
    "start": "1504000",
    "end": "1510159"
  },
  {
    "text": "information about the length of the array it holds we can't Implement drop for it instead we provided a method for",
    "start": "1510159",
    "end": "1515320"
  },
  {
    "text": "the user to type it to type to manually deallocate it by giving the correct array length deallocate unchecked all",
    "start": "1515320",
    "end": "1522399"
  },
  {
    "text": "right if length is greater than zero uh let inner unsafe pointer",
    "start": "1522399",
    "end": "1528720"
  },
  {
    "text": "okay if it equals one okay so upon drop if the if the so this inner count right here so this would be the amount of",
    "start": "1529000",
    "end": "1534960"
  },
  {
    "text": "atomic references if that equals one then we need to drop it right because that means you're the last one to drop",
    "start": "1534960",
    "end": "1542039"
  },
  {
    "text": "it uh in count load Atomic ordering",
    "start": "1542240",
    "end": "1547520"
  },
  {
    "text": "acquire unsafe deallocate self pointer as cast u8 okay",
    "start": "1547520",
    "end": "1553760"
  },
  {
    "text": "yeah um I haven't done any of these things so now I'm deep unsafe rust is hard because it makes unsafe C safe yeah",
    "start": "1553760",
    "end": "1560799"
  },
  {
    "text": "that's fair that's a fair way to say it you don't do this stuff every day unless if it's specific to a SE Li project yeah",
    "start": "1560799",
    "end": "1566320"
  },
  {
    "text": "you don't do this stuff very often but rust Al I mean this is a great uh this",
    "start": "1566320",
    "end": "1572520"
  },
  {
    "text": "this is a great reminder for when rust is hard it's really really",
    "start": "1572520",
    "end": "1578039"
  },
  {
    "text": "hard uh when called the method first checks uh if the given length is nonzero",
    "start": "1578039",
    "end": "1583799"
  },
  {
    "text": "it if it's zero no memory was allocated and we don't have to do anything when the is allocated we decrease that",
    "start": "1583799",
    "end": "1589640"
  },
  {
    "text": "reference count and see if we're the only owner if we are the only owner we deallocate using the layout from earlier",
    "start": "1589640",
    "end": "1595399"
  },
  {
    "text": "yep cloning similarly we can't Implement clone for our type and rely on the user provided length to know if the memory",
    "start": "1595399",
    "end": "1600760"
  },
  {
    "text": "was allocated cloning involves no coping just incrementing a reference count yep I don't know what a non-al dangling is I",
    "start": "1600760",
    "end": "1607000"
  },
  {
    "text": "don't know I don't know why we're dangling um else we get this thing we add to the atomics and then we do this",
    "start": "1607000",
    "end": "1614279"
  },
  {
    "text": "then we get the pointer let pointer if length equals zero there we go go still",
    "start": "1614279",
    "end": "1619600"
  },
  {
    "text": "the Phantom data slice uh slicing getting a slice to the underlying array also relies on user",
    "start": "1619600",
    "end": "1626640"
  },
  {
    "text": "provided length and it does uh and is done in two steps casting the thin pointer to a fat pointer creating a",
    "start": "1626640",
    "end": "1631880"
  },
  {
    "text": "slice using a pointer to the data field uh and the user provided length there you go there's that uh fat pointer to",
    "start": "1631880",
    "end": "1637960"
  },
  {
    "text": "thin right or is this no that's not a fat pointer to thin that's just a fat pointer and then it's actually getting it and it's returning it from right here",
    "start": "1637960",
    "end": "1644880"
  },
  {
    "text": "or just doing a default length of nothing okay so that's like the zero that's the zero length and then this is",
    "start": "1644880",
    "end": "1650000"
  },
  {
    "text": "the one that we're actually doing the unsafe operation over okay wow when I'm unable to sleep I'll read this article",
    "start": "1650000",
    "end": "1655279"
  },
  {
    "text": "yeah putting things together with all the essential components we can now start implementing a German string while",
    "start": "1655279",
    "end": "1660640"
  },
  {
    "text": "much is needed to provide a usable string we only present some basic functionalities allocating creating a",
    "start": "1660640",
    "end": "1665840"
  },
  {
    "text": "string is straightforward we copy the prefix uh while handling two cases if the string is almost 12 bytes we inline",
    "start": "1665840",
    "end": "1671600"
  },
  {
    "text": "the suffix otherwise we allocate a new shared bytes Dy holding the string content I'm sure anyone could understand",
    "start": "1671600",
    "end": "1677919"
  },
  {
    "text": "this eventually right it just might take a bit of an effort right here so you got the you got the btes you got the length",
    "start": "1677919",
    "end": "1683320"
  },
  {
    "text": "if it's over the largest size it can't do that we get the prefix with the prefix length we get the trailing uh by",
    "start": "1683320",
    "end": "1689080"
  },
  {
    "text": "slicing that stuff out if it's less than inlined length then we don't need to do it then the trailing obviously we must do some sort of writing stuff else we",
    "start": "1689080",
    "end": "1695799"
  },
  {
    "text": "copy the slice from one side to another and create the uh trailing with the manually dropped pointer right here then we return this right here with the",
    "start": "1695799",
    "end": "1701240"
  },
  {
    "text": "length the prefix and the trailing and then allow Kippy cast possible truncation drop deallocation can now be",
    "start": "1701240",
    "end": "1707679"
  },
  {
    "text": "provided by by implementing drop for um uh umber string because it has all the needed information we'll see if there",
    "start": "1707679",
    "end": "1713200"
  },
  {
    "text": "was any data to be deallocated by checking the length if there's data on the Heap we deallocate the deallo",
    "start": "1713200",
    "end": "1718679"
  },
  {
    "text": "unchecked method introduced earlier drop function uh function drop Oh weird I",
    "start": "1718679",
    "end": "1724200"
  },
  {
    "text": "didn't realize wait oh yeah never mind sorry so we're doing the trade implementation for drop the function drop takes a mutable self we get the",
    "start": "1724200",
    "end": "1730480"
  },
  {
    "text": "length if the length is greater than the inline length then we need to do this thing right here right we need to drop",
    "start": "1730480",
    "end": "1735519"
  },
  {
    "text": "it from right here okay clone similarly we can now Implement clone from umber string we",
    "start": "1735519",
    "end": "1741919"
  },
  {
    "text": "copy the bytes to a new instance when the string is inlined otherwise we copy the prefix and delegate the Clone",
    "start": "1741919",
    "end": "1748320"
  },
  {
    "text": "unchecked method to share dine bytes okay and that's where you do that cheap clone you do the uh or I I guess you shouldn't say it's a cheap clone it's an",
    "start": "1748320",
    "end": "1755000"
  },
  {
    "text": "atomic reference clone which may or may not be cheaper or more expensive I have no idea what the uh I don't know what",
    "start": "1755000",
    "end": "1761360"
  },
  {
    "text": "the the cost differences or at what point is an atomic operation less expensive than cloning certain amount of",
    "start": "1761360",
    "end": "1767679"
  },
  {
    "text": "strings right um partial equals comparison is first",
    "start": "1767679",
    "end": "1773679"
  },
  {
    "text": "done with the prefix this check will fail for most strings and the method will return immediately as a result many",
    "start": "1773679",
    "end": "1779320"
  },
  {
    "text": "comparisons don't need to read the rest of the string beyond the prefix by the way I I just I think this is so dang clever this is so dang clever to store",
    "start": "1779320",
    "end": "1787000"
  },
  {
    "text": "the prefix on the stack and so you can just do such fast comparisons it's mindboggling how cool this is uh",
    "start": "1787000",
    "end": "1793559"
  },
  {
    "text": "comparison between fixed uh fix sized arrays are also very fast and well optimized addition Al if both strings",
    "start": "1793559",
    "end": "1798919"
  },
  {
    "text": "are short and inlined we can compare the last eight bites without doing any poin or D referencing poin or D referencing",
    "start": "1798919",
    "end": "1804200"
  },
  {
    "text": "might only happen inside the call to suffix when the strings are not aligned there you go that's super",
    "start": "1804200",
    "end": "1811039"
  },
  {
    "text": "amazing by the way this is just such a super cool optimization right I I just think I I just absolutely",
    "start": "1811039",
    "end": "1819240"
  },
  {
    "text": "blown away by this what's the gain of this it's being able to do German strings showing that there is this optimization that actually is possible",
    "start": "1819240",
    "end": "1825600"
  },
  {
    "text": "in Rust is just an exceptionally difficult possibility right if I jumped into C without a solid C and CPP Foundation I will miss a lot",
    "start": "1825600",
    "end": "1832440"
  },
  {
    "text": "it is it can be difficult I don't have that solid of a CPP Foundation I had an okay foundation with C I'm I'm",
    "start": "1832440",
    "end": "1839080"
  },
  {
    "text": "definitely not the world's best C programmer and I immediately saw what's cool about rust uh it's pretty neat but",
    "start": "1839080",
    "end": "1845600"
  },
  {
    "text": "I I wouldn't say that it's it's easy partial ordering uh ordering also takes similar execution paths to comparison we",
    "start": "1845600",
    "end": "1852240"
  },
  {
    "text": "immediately returned if the order can be determined just from the prefix the string suffixes are only compared with the prefixes are equal pointer de",
    "start": "1852240",
    "end": "1859000"
  },
  {
    "text": "references are also avoided by checking if both strings are inlined there we go so partial compare we can do",
    "start": "1859000",
    "end": "1865039"
  },
  {
    "text": "that uh we can do the left hand side right hand side if the I assume if these uh there we go we can do the they are",
    "start": "1865039",
    "end": "1871960"
  },
  {
    "text": "equal they are inlined or we have to do the suffix comparison ah super cool",
    "start": "1871960",
    "end": "1877799"
  },
  {
    "text": "super super cool I think this stuff is super cool I don't know like you just do a comparison you just do a comparison uh",
    "start": "1877799",
    "end": "1884440"
  },
  {
    "text": "with the prefixes wow I love this optimization I almost made the impossible let's see I made the",
    "start": "1884440",
    "end": "1889760"
  },
  {
    "text": "impossible possible implementing German string in Rust requires knowledge of rust memory model and type layout but is",
    "start": "1889760",
    "end": "1895880"
  },
  {
    "text": "relatively easy so I want to be completely fair to rust right now what rust is really good at or what it's been",
    "start": "1895880",
    "end": "1903720"
  },
  {
    "text": "designed to do is to create a memory safe something that should be or can be as fast as C right that was its kind of",
    "start": "1903720",
    "end": "1910320"
  },
  {
    "text": "goal is it's a system levels system level programming language in which you can determine the",
    "start": "1910320",
    "end": "1916480"
  },
  {
    "text": "layout but that's stuff is is exceptionally difficult to do and so",
    "start": "1916480",
    "end": "1922159"
  },
  {
    "text": "from his vantage point the writer of this uh of this it was very",
    "start": "1922159",
    "end": "1928159"
  },
  {
    "text": "easy because of the already pred you know like the predefined knowledge like understanding what Phantom is how to use",
    "start": "1928159",
    "end": "1933600"
  },
  {
    "text": "Phantom properly understanding this layout and how rust actually does allocations under the hood how it",
    "start": "1933600",
    "end": "1938679"
  },
  {
    "text": "effectively just called Malik right I don't know how to call Malik right I have never done any of this stuff",
    "start": "1938679",
    "end": "1946159"
  },
  {
    "text": "uh and so you can make a safe version of something",
    "start": "1946159",
    "end": "1951399"
  },
  {
    "text": "that is fairly difficult which is very impressive and so that means you can still have all the speed and all the",
    "start": "1951399",
    "end": "1956559"
  },
  {
    "text": "good stuff but for us it looks absolutely Bonkers because we just don't most of us at least in this chat don't",
    "start": "1956559",
    "end": "1963480"
  },
  {
    "text": "have the relative rust expertise to understand this and so I don't want to dunk on Rust because this stuff all",
    "start": "1963480",
    "end": "1969720"
  },
  {
    "text": "looks like you know some of these things just look a bit mindboggling right um",
    "start": "1969720",
    "end": "1975200"
  },
  {
    "text": "putting it all together like this right here just it looks like a lot right and so I don't want to dunk on it",
    "start": "1975200",
    "end": "1982080"
  },
  {
    "text": "because rust is hard in this kind of sense uh because this is a very edge case about rust whereas where I think",
    "start": "1982080",
    "end": "1987760"
  },
  {
    "text": "it's easy to dunk on rust is simple performance optimization right lifetimes",
    "start": "1987760",
    "end": "1994080"
  },
  {
    "text": "yes it is safe but to be able to do lifetimes you end up leaking onto structure like structs and functions",
    "start": "1994080",
    "end": "2000240"
  },
  {
    "text": "become colored and they kind of spread throughout your system once you have one lifetime it just keeps on doing that",
    "start": "2000240",
    "end": "2006760"
  },
  {
    "text": "whole spreading thing I think Ryan Winchester may still have uh the funny meme at the top of his profile if he",
    "start": "2006760",
    "end": "2012440"
  },
  {
    "text": "does I hope he does yeah you could do the exact same thing with the a lifetime which is instead of having Asing",
    "start": "2012440",
    "end": "2018039"
  },
  {
    "text": "function you just have function with a lifetime and then once that happens you know everything has to have",
    "start": "2018039",
    "end": "2024639"
  },
  {
    "text": "this lifetime I I do just for you thank you Ryan I I I literally go to this thing like once a month I go there and",
    "start": "2024639",
    "end": "2030600"
  },
  {
    "text": "show this off you can never change that you may never change that Meme Ryan it's",
    "start": "2030600",
    "end": "2036880"
  },
  {
    "text": "a it's a great meme uh actually you can if you want to I mean that I feel like that's a much more",
    "start": "2036880",
    "end": "2042600"
  },
  {
    "text": "fair thing to critique rust because the reality is you'll probably never you could write rust for the next five years and probably never run into any of these",
    "start": "2042600",
    "end": "2049040"
  },
  {
    "text": "things whereas you will run into this if you write rust for the next year",
    "start": "2049040",
    "end": "2054118"
  },
  {
    "text": "lifetimes need to be a rethought in Rust lifetimes can be exceptionally difficult I think I love the problem with rust is",
    "start": "2054119",
    "end": "2060878"
  },
  {
    "text": "that it's a systems level programming language so it has to be designed this way whereas o camel can get away with a",
    "start": "2060879",
    "end": "2066280"
  },
  {
    "text": "lot of these things because it is garbage collected so you can have lifetimes that are associated with a",
    "start": "2066280",
    "end": "2072599"
  },
  {
    "text": "function as opposed to being associated with a uh data type and I think that",
    "start": "2072599",
    "end": "2077839"
  },
  {
    "text": "that does a really good it just does it it just makes it much more friendly right I don't think they need to be",
    "start": "2077839",
    "end": "2083398"
  },
  {
    "text": "rethought I think if you do that you ruin the language you could potentially ruin the language maybe there's an easier way forward uh you know uh tord",
    "start": "2083399",
    "end": "2090760"
  },
  {
    "text": "maybe there's an easier way forward that you could do lifetimes without all the complications I don't know if that's",
    "start": "2090760",
    "end": "2096679"
  },
  {
    "text": "possible I haven't thought about rust that much to be able to say that's true or false but nonetheless cuz I know",
    "start": "2096679",
    "end": "2102520"
  },
  {
    "text": "there's some Whispering I think from uh Gren the guy that originally invented Russ saying that lifetimes could have been easier so I'm not really",
    "start": "2102520",
    "end": "2108720"
  },
  {
    "text": "sure if it can or can't be uh yeah they're they're they're they're not insane lifetimes aren't crazy they just",
    "start": "2108720",
    "end": "2115920"
  },
  {
    "text": "can become huge pain in the asses right the moment you start trying to go from a",
    "start": "2115920",
    "end": "2121200"
  },
  {
    "text": "clone system to get something out to a lifetime system to make it fast",
    "start": "2121200",
    "end": "2127240"
  },
  {
    "text": "it just requires a lot of effort that's that the n and they do and",
    "start": "2127240",
    "end": "2132400"
  },
  {
    "text": "they still do not prevent memory leaks yes memory leaks are just you can you can memory leak all you want in in Rust",
    "start": "2132400",
    "end": "2138200"
  },
  {
    "text": "that's that's not what rust is saying that you can uh that's not what rust purpose is yeah lifetime as a concept is easy",
    "start": "2138200",
    "end": "2146079"
  },
  {
    "text": "but refactoring is hard agreed refactoring can become very tricky and then it becomes progressively more",
    "start": "2146079",
    "end": "2151160"
  },
  {
    "text": "tricky once you layer on async if that makes sense all right anyways great article though it was very",
    "start": "2151160",
    "end": "2157400"
  },
  {
    "text": "cool to start off with this is an impossible type in Rust and then showing that it actually is possible through the",
    "start": "2157400",
    "end": "2162800"
  },
  {
    "text": "the deep dark magics of unsafe and understanding how layout Works super cool it I will say that's one cool part",
    "start": "2162800",
    "end": "2169760"
  },
  {
    "text": "about rust is that you could spend the next five years understanding it and",
    "start": "2169760",
    "end": "2175280"
  },
  {
    "text": "becoming really like good at the language there is something that's very beautiful about become uh that a",
    "start": "2175280",
    "end": "2182119"
  },
  {
    "text": "language that allows expertise in but it also is a two-edged sword because then you also have to work with people that",
    "start": "2182119",
    "end": "2187599"
  },
  {
    "text": "are an expert in the language and for you to potentially understand some of their code may require years of training right and so",
    "start": "2187599",
    "end": "2196680"
  },
  {
    "text": "it's a two-edged sword but it's super cool right have you ever if you've ever worked with a CPP wizard which I was on a team of like five CPP Wizards",
    "start": "2196680",
    "end": "2204319"
  },
  {
    "text": "it's I'm just saying it can get really wild right it can get really really wild",
    "start": "2204319",
    "end": "2210000"
  },
  {
    "text": "where you're just like dude I don't understand what's happening here that's one thing that's one reason why I really",
    "start": "2210000",
    "end": "2215440"
  },
  {
    "text": "have enjoyed my time with Zig is because is just so straightforward it's it's",
    "start": "2215440",
    "end": "2220599"
  },
  {
    "text": "it's literally just a straight line from what you do in your head to what you do in the computer oh you need to create",
    "start": "2220599",
    "end": "2226280"
  },
  {
    "text": "something on the Heap you must call Malik oh you want it to be stack then you just create it you know like it's",
    "start": "2226280",
    "end": "2232280"
  },
  {
    "text": "just so it it it feels really nice to work with honestly I I genuinely enjoyed",
    "start": "2232280",
    "end": "2237680"
  },
  {
    "text": "my time with Zig because you don't need all of the you don't need all of the advanced Natures of rust and you can",
    "start": "2237680",
    "end": "2243720"
  },
  {
    "text": "create relatively safe programs safer than you wouldn't say c when you need to",
    "start": "2243720",
    "end": "2249079"
  },
  {
    "text": "anyways the name well that I guess that was my name",
    "start": "2249079",
    "end": "2254359"
  },
  {
    "text": "technically that that that's my name you just heard my name it's a very long name it's in fact I would say that that name",
    "start": "2254359",
    "end": "2260599"
  },
  {
    "text": "competes with some German some German words out there yeah so ger",
    "start": "2260599",
    "end": "2266318"
  }
]