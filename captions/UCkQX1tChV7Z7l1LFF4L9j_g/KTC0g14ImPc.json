[
  {
    "start": "0",
    "end": "0"
  },
  {
    "text": "okay uh like they said there's a few beers left over here still if anybody wants to take this opportunity to grab one beer makes my talk sound",
    "start": "24880",
    "end": "32679"
  },
  {
    "text": "better so my name is Bob Lee I'm the CTO of a company called Square uh if you",
    "start": "35480",
    "end": "40840"
  },
  {
    "text": "don't know what square is uh we enable you to take credit card payments on your iPhone or Android phone and uh we're",
    "start": "40840",
    "end": "48239"
  },
  {
    "text": "actually right next door this is our old office as a matter of fact um and we use so far as like technologies that we use",
    "start": "48239",
    "end": "55079"
  },
  {
    "text": "uh we use uh Ruby Objective C and obviously Java both in our Android client and for our backend Services",
    "start": "55079",
    "end": "62160"
  },
  {
    "text": "which is where this comes in I'm going to talk to you about Java references um kind of the Genesis of",
    "start": "62160",
    "end": "68759"
  },
  {
    "text": "this talk uh it came from a couple places um well first there's not a lot of good documentation out there on",
    "start": "68759",
    "end": "74840"
  },
  {
    "text": "references and a lot of the documentation that I found out there when I was first looking into this uh wasn't very good either wasn't accurate",
    "start": "74840",
    "end": "81479"
  },
  {
    "text": "or uh you know just wasn't detailed enough um and for me I had to learn",
    "start": "81479",
    "end": "86680"
  },
  {
    "text": "about references for two reasons one I worked on the guava project used to be called Google Collections how many",
    "start": "86680",
    "end": "92360"
  },
  {
    "text": "people have used that before so there's a guava is kind of like the Google commons libraries and we",
    "start": "92360",
    "end": "98759"
  },
  {
    "text": "have a a bunch of uh classes in there that uh make it easier to use references",
    "start": "98759",
    "end": "103880"
  },
  {
    "text": "uh including mapmaker that's a class that I wrote uh and then on the other end uh I was also the core Library lead",
    "start": "103880",
    "end": "109399"
  },
  {
    "text": "for a project called Android um and that meant I was in charge of like the Java",
    "start": "109399",
    "end": "114640"
  },
  {
    "text": "uh compatibility libraries in Android um and you know and I had to consult on",
    "start": "114640",
    "end": "119680"
  },
  {
    "text": "things things like the implementation of references how the garbage collector actually handled references in the dvic",
    "start": "119680",
    "end": "125280"
  },
  {
    "text": "BM which runs on Android and make sure that you know it was compatible with other Java",
    "start": "125280",
    "end": "130520"
  },
  {
    "text": "platforms so the goals of this talk are one to take the mystery out of garbage collection when I was first starting out",
    "start": "130520",
    "end": "136920"
  },
  {
    "start": "133000",
    "end": "133000"
  },
  {
    "text": "in programming it was something that I ignored for a while and then just kind of finally digging in uh and",
    "start": "136920",
    "end": "142360"
  },
  {
    "text": "understanding how garbage colle collection work really uh helped me write better code uh it's not really",
    "start": "142360",
    "end": "147560"
  },
  {
    "text": "that hard to understand when you just take a peek and look at what actually going on under the covers it's not magic",
    "start": "147560",
    "end": "153160"
  },
  {
    "text": "um two to put an end to finalizers I'm sure we've all heard like that advice that you shouldn't use finalizers but",
    "start": "153160",
    "end": "159000"
  },
  {
    "text": "we're like oh but it's so easy and you know it's like we don't really understand the reasons not to use them",
    "start": "159000",
    "end": "164200"
  },
  {
    "text": "and I'm really going to drill those in and give you a bunch of reasons not to use them um and three to learn how to",
    "start": "164200",
    "end": "169760"
  },
  {
    "text": "since we're not going to use finalizers we need to learn how to do manual cleanup the right way and the right way",
    "start": "169760",
    "end": "174959"
  },
  {
    "text": "uh really depends on the context so first of all um let's talk",
    "start": "174959",
    "end": "180720"
  },
  {
    "start": "178000",
    "end": "178000"
  },
  {
    "text": "about how garbage collection works at a super high level uh basically in Java",
    "start": "180720",
    "end": "185840"
  },
  {
    "text": "you have a heap of objects and so these are all these circles represent objects they're all ref in the arrows ref",
    "start": "185840",
    "end": "191760"
  },
  {
    "text": "represent references uh between the objects um and you have this notion of",
    "start": "191760",
    "end": "196959"
  },
  {
    "text": "uh root objects so and these are the objects that the garbage collector starts from and it can have like",
    "start": "196959",
    "end": "202720"
  },
  {
    "text": "multiple these could be like variables like local variables or static variables or whatever um and basically the way the",
    "start": "202720",
    "end": "209200"
  },
  {
    "text": "garbage collect works is it crawls this graph and uh determines which objects",
    "start": "209200",
    "end": "215360"
  },
  {
    "text": "are reachable from one of these roots uh and basically so uh let me see here if",
    "start": "215360",
    "end": "222720"
  },
  {
    "text": "we took away a reference Bas from uh this root like the reference between D",
    "start": "222720",
    "end": "227920"
  },
  {
    "text": "and the root uh then D is no longer reachable and then by virtue of that e is no",
    "start": "227920",
    "end": "233640"
  },
  {
    "text": "longer reachable either since D was the only object that referenced it so uh those objects are no longer reachable",
    "start": "233640",
    "end": "239439"
  },
  {
    "text": "and garbage colle collector is able to reclaim those uh so what does it mean for",
    "start": "239439",
    "end": "246480"
  },
  {
    "text": "something to be reachable well the jvm defines reachable very abstractly it's basically an object is reachable if any",
    "start": "246480",
    "end": "253519"
  },
  {
    "text": "live thread can access it uh and then the details of that tend to be left up to the implementations and in the Java",
    "start": "253519",
    "end": "259479"
  },
  {
    "text": "world uh just some examples of Heap roots or the places where the garbage collector starts you know I mentioned",
    "start": "259479",
    "end": "264840"
  },
  {
    "text": "the system classes you know and if they'll have static fields that represent other objects and then those objects will represent other objects um",
    "start": "264840",
    "end": "271840"
  },
  {
    "text": "and then thread Stacks so like your local variables all the way up the thread stack um inflight exceptions",
    "start": "271840",
    "end": "277440"
  },
  {
    "text": "that's one people typically don't think of if you throw an exception the garbage collector has to make sure that it doesn't free up that memory uh so long",
    "start": "277440",
    "end": "283280"
  },
  {
    "text": "as that exception is in Flight um uh jni Global references the finalizer cue",
    "start": "283280",
    "end": "289199"
  },
  {
    "text": "that's one people don't typically think about I'll talk more about that in more detail later on in the talk uh the string intern pool so you know it's like",
    "start": "289199",
    "end": "296039"
  },
  {
    "text": "you know Java intern strings that means it kind of like memorizes them or uh",
    "start": "296039",
    "end": "301199"
  },
  {
    "text": "makes sure or like replaces all instances of strings with the equivalent values uh and then other stuff depending",
    "start": "301199",
    "end": "308160"
  },
  {
    "text": "on the VM um so garbage collection isn't a Magic Bullet like you can't just let the",
    "start": "308160",
    "end": "313960"
  },
  {
    "start": "312000",
    "end": "312000"
  },
  {
    "text": "garbage collector uh manage all of your States sometimes you have to clean things up yourself and like examples of",
    "start": "313960",
    "end": "319000"
  },
  {
    "text": "that are listeners if you're doing like UI development um file descriptors are a",
    "start": "319000",
    "end": "324080"
  },
  {
    "text": "common one uh Native memory if you're writing like library that manages native memory you have to manually free that",
    "start": "324080",
    "end": "329319"
  },
  {
    "text": "memory the garbage collector doesn't know about it uh and like external State what I mean by that is like say for example I have a static map from an",
    "start": "329319",
    "end": "336280"
  },
  {
    "text": "object to some value well when that object goes away I want to make sure that that mapping also goes away and the",
    "start": "336280",
    "end": "342960"
  },
  {
    "text": "garbage collector can't necessarily know to do that so we have a few ways to clean up State um first we have the trif",
    "start": "342960",
    "end": "349400"
  },
  {
    "text": "finally block which I'm sure you all uh which you're all aware of we have finalizers and uh which is basically",
    "start": "349400",
    "end": "355759"
  },
  {
    "text": "this finalize method and we have uh the references API which is going to be kind of focus of this talk um first let's",
    "start": "355759",
    "end": "361720"
  },
  {
    "start": "361000",
    "end": "361000"
  },
  {
    "text": "take a look at TR finally uh I have some example code here uh that basically",
    "start": "361720",
    "end": "368080"
  },
  {
    "text": "copies a file into a given output stream and the reason we have to use TR finally",
    "start": "368080",
    "end": "373440"
  },
  {
    "text": "is because as you'll see here um we open the file input stream and then we copy",
    "start": "373440",
    "end": "379639"
  },
  {
    "text": "the data basically we just read from the file and then copy that data directly to the output buffer but we have to make",
    "start": "379639",
    "end": "385080"
  },
  {
    "text": "sure that no matter what happens we remember to close that file uh if we don't do this and for example we",
    "start": "385080",
    "end": "391800"
  },
  {
    "text": "encountered an IO a while reading this file uh then uh we could risk that uh",
    "start": "391800",
    "end": "398080"
  },
  {
    "text": "that file not being closed and then we'd leak a file descriptor and if you don't know uh files file descriptors are a",
    "start": "398080",
    "end": "403639"
  },
  {
    "text": "limited resource and if you leak too many of them your your application's going to crash so to alleviate that we",
    "start": "403639",
    "end": "410280"
  },
  {
    "text": "use this finally block here and this basically ensures that no matter what whether an exception is thrown or this returns gracefully uh we we close that",
    "start": "410280",
    "end": "418160"
  },
  {
    "text": "file so uh kind of the benefit here too uh of of like closing this here as",
    "start": "418160",
    "end": "423479"
  },
  {
    "text": "opposed to like a back uh just letting the garbage collector handle it is you know if we're copying a lot of files we",
    "start": "423479",
    "end": "429639"
  },
  {
    "text": "could uh get in a state where the garbage collector can't keep up and then we end up running out of file descriptors you may have run into a",
    "start": "429639",
    "end": "435960"
  },
  {
    "text": "problem like that before um so like the pros of uh using uh finally to clean up",
    "start": "435960",
    "end": "441919"
  },
  {
    "text": "stuff explicitly is one it's uh more straightforward you don't have to worry about like background threading and and",
    "start": "441919",
    "end": "447440"
  },
  {
    "text": "those types of concerns uh you can handle exeptions in the main thread whereas if you're doing clean up in a background thread and you know it blows",
    "start": "447440",
    "end": "454120"
  },
  {
    "text": "up well then you have to somehow communicate that exception back to the foreground thread uh and it ensures that",
    "start": "454120",
    "end": "459919"
  },
  {
    "text": "the cleanup keeps Pace I kind of mentioned this idea of if we were uh just letting the garbage collector uh",
    "start": "459919",
    "end": "465479"
  },
  {
    "text": "close the files then it might not keep up and we'd run out of file descriptors so the cons of using a finally block are",
    "start": "465479",
    "end": "471720"
  },
  {
    "text": "one it's more work for the programmer they have to explicitly uh write this code to close things uh two it's more",
    "start": "471720",
    "end": "477440"
  },
  {
    "text": "air prone if they forget to close things or even if they forget to close it in a finally block they could leak that",
    "start": "477440",
    "end": "482960"
  },
  {
    "text": "resource uh for example like I said uh if the uh if reading the file throws an",
    "start": "482960",
    "end": "488360"
  },
  {
    "text": "IO a and they didn't close the file in a finally block that file might not get closed uh and a cleanup happens in the",
    "start": "488360",
    "end": "494479"
  },
  {
    "text": "main thread that's also that's a pro in the sense that it's simpler but it's also a con in the sense that that uh the",
    "start": "494479",
    "end": "499759"
  },
  {
    "text": "performance overhead of cleaning up that resource is imposed on the clients of that API so Java 7 introduced a new uh",
    "start": "499759",
    "end": "508919"
  },
  {
    "start": "506000",
    "end": "506000"
  },
  {
    "text": "language feed called try with resources that makes uh the trif finally block a",
    "start": "508919",
    "end": "514320"
  },
  {
    "text": "little easier to deal with so here's the code that we just looked at you can have the TR finally block that closes the uh",
    "start": "514320",
    "end": "520640"
  },
  {
    "text": "file input stream in the finally block while with try with resources this code gets a lot more concise uh basically the",
    "start": "520640",
    "end": "527080"
  },
  {
    "text": "difference is now you can say try and you can uh you you open with a parth parenthese here and now you can open up",
    "start": "527080",
    "end": "535360"
  },
  {
    "text": "the resource and you can open up this resource and you can actually open up multiple resources here but notice we",
    "start": "535360",
    "end": "540560"
  },
  {
    "text": "don't need an explicit finally block anymore um the co the compiler will",
    "start": "540560",
    "end": "545920"
  },
  {
    "text": "close this resource for us and even better it'll do some like really nice exception handling that we uh that",
    "start": "545920",
    "end": "552320"
  },
  {
    "text": "doesn't really make sense to do by handly call close method uh he asked if",
    "start": "552320",
    "end": "557640"
  },
  {
    "text": "it'll explicitly call close method yes so this code on the bottom is semantically equivalent to this code on",
    "start": "557640",
    "end": "564600"
  },
  {
    "text": "top almost this code actually down here is actually a little better because the exception handling that generated by the",
    "start": "564600",
    "end": "570000"
  },
  {
    "text": "compiler is a little better than what's up here up here uh if this throws an",
    "start": "570000",
    "end": "575560"
  },
  {
    "text": "exception we're going to call. close and if close throws an exception that the the exception that was thrown while",
    "start": "575560",
    "end": "581880"
  },
  {
    "text": "reading is going to be just dropped on the floor and this Exception by close is going to be thrown whereas really you",
    "start": "581880",
    "end": "587880"
  },
  {
    "text": "know in my opinion you actually want the original exception not this kind of like ancillary corollary exception that was",
    "start": "587880",
    "end": "593920"
  },
  {
    "text": "thrown by clo uh so whenever you have this expression here uh this is a new thing",
    "start": "593920",
    "end": "601480"
  },
  {
    "text": "you can pass you pass uh this statement uh as part of the try declaration and",
    "start": "601480",
    "end": "607399"
  },
  {
    "text": "anything that's in these parentheses will get Clos what does it mean to get Clos so",
    "start": "607399",
    "end": "614360"
  },
  {
    "text": "this uh declaration here so we say try file input stream and we construct a new file input stream this implements an",
    "start": "614360",
    "end": "621000"
  },
  {
    "text": "interface called closable so and you can have any number of resources yeah you can have any number of resources that",
    "start": "621000",
    "end": "626920"
  },
  {
    "text": "Implement that closable interface and they will get closed automatically ially at the close of this Tri block so we've talked about try finally",
    "start": "626920",
    "end": "634720"
  },
  {
    "text": "and the benefits of that now let's talk about finalizers a little bit um to put it simply a a finalizer is just a",
    "start": "634720",
    "end": "641120"
  },
  {
    "start": "640000",
    "end": "640000"
  },
  {
    "text": "callback method that's invoked uh before garbage collector and this this has been around before garbage collection uh this",
    "start": "641120",
    "end": "647680"
  },
  {
    "text": "has been around since uh Java 1.0 um let me just show you an example of what a finalizer looks like here uh finalize is",
    "start": "647680",
    "end": "654639"
  },
  {
    "text": "actually a method on object uh and all you do is you override it and so here we",
    "start": "654639",
    "end": "659800"
  },
  {
    "text": "have this class Fu that extends bar and it overrides the finalize method now this is something I wanted to point out",
    "start": "659800",
    "end": "665560"
  },
  {
    "text": "here too um whenever you're overriding or and implementing a finalizer you need to take care to also call uh your super",
    "start": "665560",
    "end": "673200"
  },
  {
    "text": "classes finalizer if you extend anything besides object so in in this case we actually use finally again we use",
    "start": "673200",
    "end": "678920"
  },
  {
    "text": "finally with a finalizer in this case so we do whatever it takes to clean up Fu and even if that throws an even if the",
    "start": "678920",
    "end": "684880"
  },
  {
    "text": "clean up for food throws an exception the uh cleanup for bar will still happen so and that's important uh depending on",
    "start": "684880",
    "end": "691079"
  },
  {
    "text": "the context so finalizers are simple it's a simple idea oh hey just when my object",
    "start": "691079",
    "end": "696320"
  },
  {
    "text": "right before my object gets reclaimed as call back gets called but they have a lot of problems and a lot of them like",
    "start": "696320",
    "end": "701839"
  },
  {
    "text": "stem from the fact that well one uh finalizers aren't very well specified and two uh you're calling the cleanup",
    "start": "701839",
    "end": "709560"
  },
  {
    "text": "code is on the object that you're trying to clean up so that me that really opens the door to a lot of nasty surprises so",
    "start": "709560",
    "end": "716480"
  },
  {
    "start": "716000",
    "end": "716000"
  },
  {
    "text": "the first the first uh one of the first ones is the final is not guaranteed to run especially not in a timely manner so",
    "start": "716480",
    "end": "722240"
  },
  {
    "text": "a lot of VMS will just run all finalizers synchronously and if one person's finalizer takes 5 minutes no",
    "start": "722240",
    "end": "728600"
  },
  {
    "text": "one else's finalizers are going to run until that one concludes so and that's actually a common problem we ran into",
    "start": "728600",
    "end": "733839"
  },
  {
    "text": "that on Android uh closing down SSL connections uh took some amount of time because it has to communicate over the",
    "start": "733839",
    "end": "739680"
  },
  {
    "text": "network and that sort of stuff and that prevented other things from getting finalized and ended up like locking up IO for the whole VM it was kind of a",
    "start": "739680",
    "end": "746240"
  },
  {
    "text": "disaster um they have an undefined threading model so that means yeah it could be single threaded like I just",
    "start": "746240",
    "end": "752519"
  },
  {
    "text": "described or it the garbage collector could call finalize on your objects concurrently and if there's any",
    "start": "752519",
    "end": "758320"
  },
  {
    "text": "interdependencies between those objects uh you have to uh make sure that you write thread safe code and anticipate",
    "start": "758320",
    "end": "763880"
  },
  {
    "text": "that uh you must you got to remember to call super. finalize like I showed in the last slide um this is kind of a",
    "start": "763880",
    "end": "769160"
  },
  {
    "text": "funny one exceptions are ignored so if you throw an exception from finalize then the spec specifies that the vm's",
    "start": "769160",
    "end": "775519"
  },
  {
    "text": "just supposed to drop it on the floor and ignore it um this is a big one you can resurrect references in a finalizer",
    "start": "775519",
    "end": "783079"
  },
  {
    "text": "like I said uh you can uh since the finalizer code is on the object that",
    "start": "783079",
    "end": "790040"
  },
  {
    "text": "you're trying to uh clean up your fi what's to stop your finalizer from taking a reference to that object and",
    "start": "790040",
    "end": "796199"
  },
  {
    "text": "storing it in a static field somewhere and bringing it back to life that's called Resurrection uh and that's kind",
    "start": "796199",
    "end": "801440"
  },
  {
    "text": "of a funny situation you have this this kind of like zombie object and from my experience the finalizer won't be called",
    "start": "801440",
    "end": "807199"
  },
  {
    "text": "again so you can still use the object after it was was finalized and it won't be finalized again uh it's not something",
    "start": "807199",
    "end": "813360"
  },
  {
    "text": "you that you want to mess with uh even more worrisome is that um obviously you",
    "start": "813360",
    "end": "820839"
  },
  {
    "text": "probably wouldn't do anything to shoot yourself in the foot but other people could get access to your object this way",
    "start": "820839",
    "end": "826399"
  },
  {
    "text": "and use it to like circumvent your security and do that sort of stuff I'll show you some examples of that here in a minute uh finalizers keep objects alive",
    "start": "826399",
    "end": "833720"
  },
  {
    "text": "longer than necessary so you know we just because we're like waiting we need uh the finalizer is on this object well",
    "start": "833720",
    "end": "840839"
  },
  {
    "text": "this object's queued up and all the state associated with that object can't be reclaimed until that finalizer runs",
    "start": "840839",
    "end": "846880"
  },
  {
    "text": "even if the finalizer doesn't really need all of that state so uh that's you're going to you're going to retain",
    "start": "846880",
    "end": "851920"
  },
  {
    "text": "garbage a lot longer than necessary and possibly even run out of memory um and Josh block did a test for uh Effective",
    "start": "851920",
    "end": "858839"
  },
  {
    "text": "Java some years back and found that uh using a class with a finalizer is 430",
    "start": "858839",
    "end": "865040"
  },
  {
    "text": "times slower to allocate and reclaim than a class without a final ier and why is that well just allocating an object",
    "start": "865040",
    "end": "872360"
  },
  {
    "text": "and letting it get garbage collected is a really cheap operation whereas in queing an object that has a finalizer",
    "start": "872360",
    "end": "877680"
  },
  {
    "text": "and eventually running it later is not very fast uh and so worst of all in my opinion finalizers messed up the",
    "start": "877680",
    "end": "884360"
  },
  {
    "text": "references API because they were there and then the references API came along later it had to kind of accommodate",
    "start": "884360",
    "end": "889880"
  },
  {
    "text": "finalizers and it made the references API more complicated than it needed to be and I'll explain how that is in a",
    "start": "889880",
    "end": "895320"
  },
  {
    "text": "second so let's talk about let's go through an example of a finalizer um",
    "start": "895320",
    "end": "900720"
  },
  {
    "text": "this is very similar to a lot of code that I had to write as a core Library lead for Android and where I had to wrap a lot of native apis and that sort of",
    "start": "900720",
    "end": "907160"
  },
  {
    "text": "thing uh managing native memory is something you have to deal with quite a bit so I just kind of boiled this down",
    "start": "907160",
    "end": "912440"
  },
  {
    "text": "to the simplest possible class that I could come up with the class is called native memory uh and all it does is it",
    "start": "912440",
    "end": "918639"
  },
  {
    "start": "915000",
    "end": "915000"
  },
  {
    "text": "calls a native method that allocates some native memory and it stores away the address for that native memory",
    "start": "918639",
    "end": "923959"
  },
  {
    "text": "that's what's going on right here it just has one simple method uh it enables you it calls through to another native",
    "start": "923959",
    "end": "929519"
  },
  {
    "text": "method to write to that native memory uh we don't really have to worry about the native details all we care about is that we've allocated some native memory and",
    "start": "929519",
    "end": "936600"
  },
  {
    "text": "we have the ability to write to it uh and this is kind of a naive implementation of a finalizer uh",
    "start": "936600",
    "end": "941959"
  },
  {
    "text": "basically when the finalizer gets called uh we we just call into native code to free that native memory so the code",
    "start": "941959",
    "end": "948240"
  },
  {
    "text": "looks simple enough but let's let's take another look um as I mentioned before",
    "start": "948240",
    "end": "953720"
  },
  {
    "text": "someone uh it doesn't necessarily matter uh if your finalizer is safe you also have to anticipate other people's code",
    "start": "953720",
    "end": "959199"
  },
  {
    "text": "who may be referencing your code and they may have finalizers themselves so I called this code sigal Factory because",
    "start": "959199",
    "end": "964920"
  },
  {
    "start": "963000",
    "end": "963000"
  },
  {
    "text": "it generates sigals um and uh so and I titled this I",
    "start": "964920",
    "end": "971399"
  },
  {
    "text": "I call this a slide let's play War because with this class my sigal factory",
    "start": "971399",
    "end": "976519"
  },
  {
    "text": "it will generate uh a Segal 50% of the time just like War you know you're you",
    "start": "976519",
    "end": "981680"
  },
  {
    "text": "have a 50% chance of winning and this case you have a 50% chance of crashing your VM so let's take a look at what",
    "start": "981680",
    "end": "986880"
  },
  {
    "text": "this code is doing uh basically all Segal Factory does is it references a native memory object and it has a",
    "start": "986880",
    "end": "993880"
  },
  {
    "text": "finalizer of its own so and in its finalizer it writes to that native",
    "start": "993880",
    "end": "999720"
  },
  {
    "text": "memory object so what's the problem with this that seems simple enough right you know wouldn't you expect the garbage",
    "start": "999720",
    "end": "1005440"
  },
  {
    "text": "collector to finalize this guy and then finalize the native memory object you get no such guarantee uh I mean like the",
    "start": "1005440",
    "end": "1012079"
  },
  {
    "text": "garbage collector isn't going to like sort your objects topologically based on which objects reference each other uh it's just going to find all the objects",
    "start": "1012079",
    "end": "1018279"
  },
  {
    "text": "that are final at that time and start calling finalizers on them so the odds are uh this finalizer can be called",
    "start": "1018279",
    "end": "1024400"
  },
  {
    "text": "before the native memory one or the native memory finalizer can be called before this one so in this case let's assume that the native memory finalizer",
    "start": "1024400",
    "end": "1030959"
  },
  {
    "text": "is called First and that native memory is freed what's going to happen down here we're this is going to call through to that native code and write to memory",
    "start": "1030959",
    "end": "1038798"
  },
  {
    "text": "that was just freed and probably say your application so how do we fix that um always use protection uh this is this",
    "start": "1038799",
    "end": "1046640"
  },
  {
    "start": "1046000",
    "end": "1046000"
  },
  {
    "text": "is that same native memory class from two slides ago uh the blue code is is kind of our updated code uh in this case",
    "start": "1046640",
    "end": "1053280"
  },
  {
    "text": "we can keep track of whether this object has been finalized or not and we can change our Behavior based on that also",
    "start": "1053280",
    "end": "1060039"
  },
  {
    "text": "we have to take care to uh synchronize the access to this because the finalizer",
    "start": "1060039",
    "end": "1065559"
  },
  {
    "text": "could be run from one thread or you know it's like or from multiple threads and you know it's chances are that this",
    "start": "1065559",
    "end": "1071960"
  },
  {
    "text": "right method could be calling being called from a different method than the finalizer um so we synchronize it we",
    "start": "1071960",
    "end": "1077600"
  },
  {
    "text": "have to synchronize both the right method and the finalizer the finalizer sets finalized to true and the right me",
    "start": "1077600",
    "end": "1083679"
  },
  {
    "text": "method checks finalizer or checks whether it's been finalized or not and this kind of leaves us in this weird situation too you'll notice uh if the",
    "start": "1083679",
    "end": "1090200"
  },
  {
    "text": "object's been finalized and somebody calls right on it like our Sig fault Factory did what do you do um who knows",
    "start": "1090200",
    "end": "1096440"
  },
  {
    "text": "you know it's like maybe you can blow up log a message do nothing uh doing nothing's probably not the best thing to",
    "start": "1096440",
    "end": "1102120"
  },
  {
    "text": "do um and kind of the unfortunate thing here is that before um outside of this",
    "start": "1102120",
    "end": "1107880"
  },
  {
    "text": "there's really no reason for write to be synchronized I mean there's it's perfectly fine for more than one thread",
    "start": "1107880",
    "end": "1113240"
  },
  {
    "text": "to write to this memory presumably um but now we have to add the synchronization on it onto it just for",
    "start": "1113240",
    "end": "1119039"
  },
  {
    "text": "the possibility that uh the finalizer may run and somebody could call it concurrently and that's pretty unfortunate uh so basically what this",
    "start": "1119039",
    "end": "1126000"
  },
  {
    "text": "all boils down to is finalizers are good for one thing in my opinion and that's kind of logging warnings uh if maybe if",
    "start": "1126000",
    "end": "1133120"
  },
  {
    "start": "1128000",
    "end": "1128000"
  },
  {
    "text": "you uh forgot to like manually clean up an object you've probably seen this with database connection pools before if you",
    "start": "1133120",
    "end": "1139120"
  },
  {
    "text": "forget to clean up your connection object um you'll get a warning it'll say hey you didn't explicitly close this",
    "start": "1139120",
    "end": "1144600"
  },
  {
    "text": "connection you should fix your code um but there's also kind of a problem with that because like what happens when you want to disable the warnings well now",
    "start": "1144600",
    "end": "1151400"
  },
  {
    "text": "you have this finalizer that does nothing but you still have to incur all the performance overhead uh that goes with finalizers like I said uh Josh",
    "start": "1151400",
    "end": "1158240"
  },
  {
    "text": "found it to be 430 times slower the alternative what do we do",
    "start": "1158240",
    "end": "1163640"
  },
  {
    "start": "1163000",
    "end": "1163000"
  },
  {
    "text": "instead of finalizers this is where the references API came in and tried to fix these problems uh the references API was",
    "start": "1163640",
    "end": "1169880"
  },
  {
    "text": "introduced in Java 1 2 that a long time ago uh late '90s early 2000s uh late",
    "start": "1169880",
    "end": "1176200"
  },
  {
    "text": "'90s um and it introduced three reference types which I I'll go through the first one is a a soft reference and",
    "start": "1176200",
    "end": "1184280"
  },
  {
    "text": "this we use uh for caching the second one is a weak reference um this is for",
    "start": "1184280",
    "end": "1190240"
  },
  {
    "text": "quick cleanup uh and this third one is a phantom reference and this is for safe",
    "start": "1190240",
    "end": "1195520"
  },
  {
    "text": "cleanup and so that's kind of the key here if we didn't have finalizers we wouldn't need both weak and Phantom",
    "start": "1195520",
    "end": "1202120"
  },
  {
    "text": "references uh and I'll talk a little bit about that um the key difference between weak and Phantom references is that week",
    "start": "1202120",
    "end": "1208520"
  },
  {
    "text": "references run before the finalizer runs so your weak references will be cleared uh before the final before the finalizer",
    "start": "1208520",
    "end": "1215480"
  },
  {
    "text": "runs so your object isn't totally gone people can still get access to it from their own finalizers whereas with Phantom references they aren't cleared",
    "start": "1215480",
    "end": "1222080"
  },
  {
    "text": "until after all the finalizers are run so they kind of have some of the downsides uh of finalizers and that you have to wait uh until your objects",
    "start": "1222080",
    "end": "1229039"
  },
  {
    "text": "totally finalized uh there's also this other Concept in the references API called a reference q and a reference Q",
    "start": "1229039",
    "end": "1235640"
  },
  {
    "text": "is how you get notified about an object uh about a reference being cleaned up so I just this is just kind of the API here",
    "start": "1235640",
    "end": "1242280"
  },
  {
    "text": "it's very simple uh it's in the Java Lang ref package you have a base reference type it's just parameterized",
    "start": "1242280",
    "end": "1247320"
  },
  {
    "start": "1244000",
    "end": "1244000"
  },
  {
    "text": "on type T then you have a soft reference that extends at weak reference and Phantom reference you'll notice that uh",
    "start": "1247320",
    "end": "1254200"
  },
  {
    "text": "uh soft and weak reference you can optionally pass this reference CU object and that's you only pass it in if you",
    "start": "1254200",
    "end": "1259799"
  },
  {
    "text": "actually care about getting notified when that reference gets cleaned up if you just uh don't want to keep a strong",
    "start": "1259799",
    "end": "1264919"
  },
  {
    "text": "reference to it you don't need to pass in a reference que you'll notice that Phantom reference always requires you to",
    "start": "1264919",
    "end": "1270039"
  },
  {
    "text": "pass on the reference CU and this is because uh a phantom reference doesn't let you retrieve the original object",
    "start": "1270039",
    "end": "1276080"
  },
  {
    "text": "once you've created the reference via the reference anyway um so it doesn't make sense to have anything but a que here uh and this is the reference Q is",
    "start": "1276080",
    "end": "1283159"
  },
  {
    "text": "just how you would expect a queue to look uh you can pull it which or remove an element uh the here is just that",
    "start": "1283159",
    "end": "1289440"
  },
  {
    "text": "remove blocks pole doesn't so let's start with soft references soft references are supposed",
    "start": "1289440",
    "end": "1295919"
  },
  {
    "text": "to be cleared when the VM runs low on memory the uh the spec doesn't actually",
    "start": "1295919",
    "end": "1301039"
  },
  {
    "text": "make a lot of guarantees here um but they're hopefully cleared in least recently used or least frequently used",
    "start": "1301039",
    "end": "1306520"
  },
  {
    "text": "fashion there's a lot of you know this is a subject of endless debate like what's the best and it actually really depends on your application and your",
    "start": "1306520",
    "end": "1313120"
  },
  {
    "text": "context um for open jdk or oracles now oracles VM uh the way uh soft references",
    "start": "1313120",
    "end": "1320640"
  },
  {
    "text": "are implemented is they have this VM parameter called Soft ref lure policy Ms",
    "start": "1320640",
    "end": "1326000"
  },
  {
    "text": "per MB um and this is soft references least recently used policy uh milliseconds per",
    "start": "1326000",
    "end": "1334640"
  },
  {
    "text": "megabyte and the idea here is you can set um how many milliseconds to keep a",
    "start": "1334640",
    "end": "1340120"
  },
  {
    "text": "soft reference around relative to the number of megabytes of free memory and",
    "start": "1340120",
    "end": "1345440"
  },
  {
    "text": "it's kind of and the default is 1,000 so it'll keep around a soft reference for 1 second for every free megabyte of heat",
    "start": "1345440",
    "end": "1350880"
  },
  {
    "text": "that you have um so use soft references judiciously frankly you should only use",
    "start": "1350880",
    "end": "1357640"
  },
  {
    "start": "1353000",
    "end": "1353000"
  },
  {
    "text": "them for small things you should probably not use them at all anymore nowadays now that there's better",
    "start": "1357640",
    "end": "1362720"
  },
  {
    "text": "Solutions uh like the caching implementation and guava which I'll talk a little bit about they're good for like maybe quick and dirty caching uh where",
    "start": "1362720",
    "end": "1369840"
  },
  {
    "text": "you don't want to like think about the size of your cash up front or something like that and you just have small pretty cheap objects and you just get a small",
    "start": "1369840",
    "end": "1376240"
  },
  {
    "text": "performance Boost from caching those objects the couple of the problems with soft references is one they have no",
    "start": "1376240",
    "end": "1381679"
  },
  {
    "text": "notion of weight all soft references in your VM are treated the same way um",
    "start": "1381679",
    "end": "1386919"
  },
  {
    "text": "regardless of how long they how much memory they take how long they took to create and you know it's like when you",
    "start": "1386919",
    "end": "1392760"
  },
  {
    "text": "think about like how long something takes to create there's a difference there there's two things you have to consider one is the amount of CPU that",
    "start": "1392760",
    "end": "1398679"
  },
  {
    "text": "went into it did it take uh 100% CPU while it was doing it or did it just take a lot of time and not use any CPU",
    "start": "1398679",
    "end": "1405000"
  },
  {
    "text": "or did it use 100% CPU for a long time those are all very different things uh and you don't want like some lightweight",
    "start": "1405000",
    "end": "1411279"
  },
  {
    "text": "object that took a millisecond to create to be kept while the uh while the VM",
    "start": "1411279",
    "end": "1416679"
  },
  {
    "text": "freeze an object that took like 10 seconds to create right um also the way",
    "start": "1416679",
    "end": "1423880"
  },
  {
    "text": "uh you know you don't have any guarantees for the implementation I know for at least last I checked uh dv's",
    "start": "1423880",
    "end": "1429279"
  },
  {
    "text": "implementation of softare reference clearing wasn't that sophisticated um the open jdks also is really subject to",
    "start": "1429279",
    "end": "1435679"
  },
  {
    "text": "problems and we actually ran into these problems quite a bit at Google um when you'll remember that I that I just",
    "start": "1435679",
    "end": "1441720"
  },
  {
    "text": "described that uh it keep that open jdk keeps soft references around based on",
    "start": "1441720",
    "end": "1447720"
  },
  {
    "text": "how much uh free memory you have left so what's going to happen as you start to",
    "start": "1447720",
    "end": "1452880"
  },
  {
    "text": "converge and like run out of free memory and like the your free space gets lower and lower your VM keeps soft references",
    "start": "1452880",
    "end": "1460080"
  },
  {
    "text": "around for shorter and shorter periods of time until you almost run out of memory and it frees all of your soft",
    "start": "1460080",
    "end": "1465120"
  },
  {
    "text": "references well what happens when you don't have any when all your caches are in and you don't have soft references anymore well if your app continues",
    "start": "1465120",
    "end": "1472240"
  },
  {
    "text": "running it's going to have to recreate all those objects and it's going to take a lot more time and require a lot of memory to recreate those objects and",
    "start": "1472240",
    "end": "1478120"
  },
  {
    "text": "your app just crashes so it's kind of a disaster um there certainly could",
    "start": "1478120",
    "end": "1483600"
  },
  {
    "text": "theoretically be better ways to uh Implement soft references but this is the reality of the situation today so uh",
    "start": "1483600",
    "end": "1490679"
  },
  {
    "text": "probably shouldn't use them um if you're going to use you can use them for like small stuff I just wanted to kind of go",
    "start": "1490679",
    "end": "1496840"
  },
  {
    "text": "through a quick example here of how to use them uh in this example I call it cached file and the idea here is we're",
    "start": "1496840",
    "end": "1504240"
  },
  {
    "start": "1500000",
    "end": "1500000"
  },
  {
    "text": "going to Cache the contents of a file in memory uh and just keep it around it's okay if we go have to go read the file",
    "start": "1504240",
    "end": "1510080"
  },
  {
    "text": "again it's not the end of the world but you know if we read if we read the same file a couple times it's nice to have it",
    "start": "1510080",
    "end": "1515200"
  },
  {
    "text": "um so here you can see we have a soft reference this is a little trick I like to use here uh you'll notice that I",
    "start": "1515200",
    "end": "1521279"
  },
  {
    "text": "initialized the soft reference to uh point to a null value and rather than just making this field null and the",
    "start": "1521279",
    "end": "1528760"
  },
  {
    "text": "reason that I did that is it avoids a null check down here a little bit later on so the we have one method it's called",
    "start": "1528760",
    "end": "1535919"
  },
  {
    "text": "get data and this is going to get the data read the data for that file and copy it all into a bite array so the",
    "start": "1535919",
    "end": "1541120"
  },
  {
    "text": "first thing we do is we call get on the soft reference uh and get the data out um if the softare reference been has",
    "start": "1541120",
    "end": "1547640"
  },
  {
    "text": "been reclaimed or not initialized yet then we're going to get null uh but if it's not null we're going to go ahead",
    "start": "1547640",
    "end": "1552720"
  },
  {
    "text": "and return that data if it was null then we're going to initialize it so we're going to read the data from the file and",
    "start": "1552720",
    "end": "1558480"
  },
  {
    "text": "then we're going to create a soft reference to that data and you notice that I save it away into that into this reference here and we're going to return",
    "start": "1558480",
    "end": "1565159"
  },
  {
    "text": "the data you notice that this is thread safe the way I wrote this code uh and it has I kept a volatile reference to this",
    "start": "1565159",
    "end": "1571640"
  },
  {
    "text": "field which you have to do uh if if this code's going to be thread safe um I didn't synchronize it on it uh and so",
    "start": "1571640",
    "end": "1578760"
  },
  {
    "text": "kind of the interesting thing there is two threads could call get data at the same time and both read the file but that's not the end of the",
    "start": "1578760",
    "end": "1585000"
  },
  {
    "text": "world so there's a reason I picked this particular example it's cuz I see people do this sometimes but you should not do",
    "start": "1585000",
    "end": "1591000"
  },
  {
    "text": "this uh this whole idea of just if you're just uh caching the content of a file in memory it's something that you",
    "start": "1591000",
    "end": "1596480"
  },
  {
    "text": "shouldn't do because the reality is operating systems already do a pretty good job of that for you so if you're also caching the contents of a file in",
    "start": "1596480",
    "end": "1603600"
  },
  {
    "text": "Java memory that means you probably have two copies of that file and memory um and whereas you know reading the same",
    "start": "1603600",
    "end": "1609000"
  },
  {
    "text": "file twice is actually a pretty quick operation assuming you have enough memory it's already",
    "start": "1609000",
    "end": "1614080"
  },
  {
    "text": "cached uh week references so week references are uh a little looser than",
    "start": "1614080",
    "end": "1619960"
  },
  {
    "text": "soft references they're cleared so long uh immediately after no strong or soft references remain so and they're cleared",
    "start": "1619960",
    "end": "1626840"
  },
  {
    "text": "as soon as possible you know a common mistake is that people you try to use weak references for caching uh but you",
    "start": "1626840",
    "end": "1632720"
  },
  {
    "text": "know modern VMS especially will clear these right away so they're really not useful for caching at all uh you should",
    "start": "1632720",
    "end": "1637919"
  },
  {
    "text": "if you want to do lightweight caching you should use soft references uh let's talk about go",
    "start": "1637919",
    "end": "1643000"
  },
  {
    "text": "through a quick example of weak references at the beginning of the talk I mentioned this idea of using listeners if you write U code uh you know how have",
    "start": "1643000",
    "end": "1649840"
  },
  {
    "text": "to do this um so we have a this is a button class this represents kind of like a button in our user interface uh",
    "start": "1649840",
    "end": "1656360"
  },
  {
    "text": "and it has an interface called listener that can get called back whenever uh somebody clicks our button um so you can",
    "start": "1656360",
    "end": "1664760"
  },
  {
    "text": "add a listener as you see here and basically all we do is we add this listener to uh a list but we don't add",
    "start": "1664760",
    "end": "1671399"
  },
  {
    "text": "The Listener directly to the list if we kept a direct reference to The Listener this button would keep that listener",
    "start": "1671399",
    "end": "1677120"
  },
  {
    "text": "from being reclaimed uh and that would mean that you'd have to explicitly remove this listener from the button if you didn't want to have a",
    "start": "1677120",
    "end": "1683279"
  },
  {
    "text": "memory leak whereas now that we're keeping a weak reference to listener once we throw that listener away elsewhere this button will no longer",
    "start": "1683279",
    "end": "1689519"
  },
  {
    "text": "notify it that's kind of a nice feature uh so we keep a list of weak",
    "start": "1689519",
    "end": "1695720"
  },
  {
    "text": "references to the listeners uh whenever somebody clicks this button we iterate through this list",
    "start": "1695720",
    "end": "1703440"
  },
  {
    "text": "and you know I notice I explicitly used an iterator here uh rather than using the for each Loop and that'll become",
    "start": "1703440",
    "end": "1709120"
  },
  {
    "text": "evident and the reason why I'll become evident here in a second but we Loop through the elements and we call uh we",
    "start": "1709120",
    "end": "1715919"
  },
  {
    "text": "get the next week reference and then we call get on that to get the listener out if the listener was null that means our",
    "start": "1715919",
    "end": "1721880"
  },
  {
    "text": "reference was garbage collected and we call remove on the iterator so it gets removed from our list and we won't uh we",
    "start": "1721880",
    "end": "1726960"
  },
  {
    "text": "can just get rid of that week reference now you got to be careful to clean up the week reference otherwise people can keep adding listeners and you know those",
    "start": "1726960",
    "end": "1732760"
  },
  {
    "text": "listeners could be garbage collected but we have to make sure our week reference gets thrown away also so if the listener",
    "start": "1732760",
    "end": "1738559"
  },
  {
    "text": "is not know then we just call on click on it it's as simple as that um finally we have Phantom",
    "start": "1738559",
    "end": "1745960"
  },
  {
    "text": "references and Phantom references are like the most precarious type um they're inced after no other references remain",
    "start": "1745960",
    "end": "1753519"
  },
  {
    "text": "uh and they run as opposed to weak references Phantom references run after the finalizer so when your Phantom",
    "start": "1753519",
    "end": "1759799"
  },
  {
    "text": "reference is in queued and you're notified that that Phantom reference was cleared you know for a fact that nobody",
    "start": "1759799",
    "end": "1764880"
  },
  {
    "text": "else has reference to that object and that's really important from a security stand um so for example you know we were we",
    "start": "1764880",
    "end": "1771559"
  },
  {
    "text": "talked about Native memory um for your code to be secure you have to make sure",
    "start": "1771559",
    "end": "1776840"
  },
  {
    "text": "that people can't access that native memory uh after it's been freed um so",
    "start": "1776840",
    "end": "1782039"
  },
  {
    "text": "like an example of that is a memory mapped file in Java memory mapped files",
    "start": "1782039",
    "end": "1787760"
  },
  {
    "text": "uh use Phantom references under the hood that's why you can't explicitly close them um and that's how they know to like",
    "start": "1787760",
    "end": "1793799"
  },
  {
    "text": "free the native memory if they didn't do that uh and they didn't check they didn't didn't have like the overhead of",
    "start": "1793799",
    "end": "1799200"
  },
  {
    "text": "checks to see whether that uh memory map file was closed or not then um you could access that memory after it was free and",
    "start": "1799200",
    "end": "1805279"
  },
  {
    "text": "potentially even access uh memory that's being used by something else and get sens access to sensitive data that you shouldn't have access",
    "start": "1805279",
    "end": "1811399"
  },
  {
    "text": "to uh so a couple little factoids about Phantom references is they have to be",
    "start": "1811399",
    "end": "1817039"
  },
  {
    "text": "cleared manually and this is really for no good reason that means any objects that those Phantom references uh that",
    "start": "1817039",
    "end": "1823159"
  },
  {
    "text": "that Phantom reference object uh references will be kept around even though can't really get access to them",
    "start": "1823159",
    "end": "1828960"
  },
  {
    "text": "and that has to that's actually due to a patent yay patents",
    "start": "1828960",
    "end": "1834840"
  },
  {
    "text": "um and uh get I mentioned this before will always return null with a phantom",
    "start": "1834840",
    "end": "1840559"
  },
  {
    "text": "reference so if you want to uh it really only makes sense to use a phantom reference with a reference",
    "start": "1840559",
    "end": "1845720"
  },
  {
    "text": "Q so let's revisit that native memory class that we wrote before and look at",
    "start": "1845720",
    "end": "1851600"
  },
  {
    "start": "1848000",
    "end": "1848000"
  },
  {
    "text": "how to do it the right way using a phantom reference like I said we're going to use a phantom reference because we want to make damp sure that nobody",
    "start": "1851600",
    "end": "1858480"
  },
  {
    "text": "has access to our native memory uh after we've freed it so we're going to make a couple changes we're going to add uh",
    "start": "1858480",
    "end": "1864840"
  },
  {
    "text": "whereas before we had a default public Constructor so anybody could construct our native memory directly now we're going to make it private this is package",
    "start": "1864840",
    "end": "1871320"
  },
  {
    "text": "private that's the default in Java if you didn't know that um I'm going to make it package private so we can access it from our Factory class which I'll",
    "start": "1871320",
    "end": "1877240"
  },
  {
    "text": "show in the next slide we're also going to get rid of this crappy finalizer um and we're going to clean up",
    "start": "1877240",
    "end": "1882919"
  },
  {
    "text": "the method we're going to clean up the memory in a different way so the first thing we need is is a",
    "start": "1882919",
    "end": "1888399"
  },
  {
    "text": "phantom reference and the way references work is uh as I said before Phantom",
    "start": "1888399",
    "end": "1894000"
  },
  {
    "text": "reference extends reference and then you can further extend that reference to store any state that you need to clean",
    "start": "1894000",
    "end": "1900480"
  },
  {
    "text": "up that object well what state do we need to clean up this native memory we need the address of the Native memory so that we can free it so here we have our",
    "start": "1900480",
    "end": "1909200"
  },
  {
    "text": "class I call it native memory reference and it's a fan it extends Phantom reference and it just keeps that memory",
    "start": "1909200",
    "end": "1915240"
  },
  {
    "text": "address uh that's basically all we need here the whole Purp this class is just to hold on to that address for us now",
    "start": "1915240",
    "end": "1920760"
  },
  {
    "text": "let's look at how the uh Native memory gets allocated and freed uh and so let's",
    "start": "1920760",
    "end": "1927639"
  },
  {
    "text": "start here um let's start with the allocation so we have this we have this Factory class now uh called native",
    "start": "1927639",
    "end": "1933600"
  },
  {
    "text": "memory manager and this is what we're going to use to create our native memory objects uh we call allocate on this it's",
    "start": "1933600",
    "end": "1940159"
  },
  {
    "text": "just a static Factory method and it returns a native me memory object this class is able to directly",
    "start": "1940159",
    "end": "1947159"
  },
  {
    "text": "construct the native memory object because this is a class that manages it it uses that package private Constructor um this is kind of an",
    "start": "1947159",
    "end": "1953840"
  },
  {
    "text": "interesting thing that a lot of people get tripped up with on references we're going to add uh we're going to construct",
    "start": "1953840",
    "end": "1960039"
  },
  {
    "text": "this native memory reference and we are going to add it to a set so uh this this static set and",
    "start": "1960039",
    "end": "1968240"
  },
  {
    "text": "notice that this set is synchronized so that it's thread safe um why do we have to add this to a set well you have to",
    "start": "1968240",
    "end": "1975440"
  },
  {
    "text": "keep a strong reference to the reference object itself if you don't then the",
    "start": "1975440",
    "end": "1981480"
  },
  {
    "text": "reference object just gets garbage collected and it won't get inced in your reference queue or anything like that and that's actually the way you want it",
    "start": "1981480",
    "end": "1987080"
  },
  {
    "text": "to behave but you do have to remember to keep a reference around to it your own strong reference to it uh then every",
    "start": "1987080",
    "end": "1992799"
  },
  {
    "text": "time somebody allocates memory so we uh create that reference keep track of it and then at that point uh this is a",
    "start": "1992799",
    "end": "1998960"
  },
  {
    "text": "common pattern we clean up we take this opportunity to clean up any uh references that were cleared before this",
    "start": "1998960",
    "end": "2005960"
  },
  {
    "text": "so if we look at our cleanup method what it does is it pulls our reference cue",
    "start": "2005960",
    "end": "2011840"
  },
  {
    "text": "which we specified up here and any uh references that we're in cued uh we'll",
    "start": "2011840",
    "end": "2018120"
  },
  {
    "text": "take those and we'll call free on the address for that reference and then we'll remove that reference from our set",
    "start": "2018120",
    "end": "2025039"
  },
  {
    "text": "does that make sense to everybody what we did here so we allocate the reference we keep track of it uh then we clean up any",
    "start": "2025039",
    "end": "2032159"
  },
  {
    "text": "references that were left and then we just return to that object and basically what's going to happen here is is the uh",
    "start": "2032159",
    "end": "2038919"
  },
  {
    "text": "garbage collector once nobody else ref references this native memory object and all the finalizers have run and all that",
    "start": "2038919",
    "end": "2044919"
  },
  {
    "text": "stuff uh the garbage collector is going to tell our reference queue about it so",
    "start": "2044919",
    "end": "2050000"
  },
  {
    "text": "we have this reference queue here the garbage collector is going to tell this reference queue and we're going to we're going to uh pull that reference off of",
    "start": "2050000",
    "end": "2056760"
  },
  {
    "text": "the queue down here and no to clean it up cool so that's how to do it with the",
    "start": "2056760",
    "end": "2063118"
  },
  {
    "start": "2061000",
    "end": "2061000"
  },
  {
    "text": "traditional like built-in uh platform libraries uh the guava libraries actually have have some helper classes",
    "start": "2063119",
    "end": "2068960"
  },
  {
    "text": "that make this a little easier and a little more efficient um so let's look at what this class looks like with the",
    "start": "2068960",
    "end": "2074960"
  },
  {
    "text": "guava libraries uh instead of having the reference CU now we have a guava specific class called finaliza reference",
    "start": "2074960",
    "end": "2082280"
  },
  {
    "text": "q and the difference here is rather than pulling a que and using that model uh",
    "start": "2082280",
    "end": "2087638"
  },
  {
    "text": "with this we can use a callback method and this will just be called the background thread there's a thread that backs this finaliza reference CU you get",
    "start": "2087639",
    "end": "2094240"
  },
  {
    "text": "one thread per que so you can allocate as many as you want and you're not all on one thread like you would be with",
    "start": "2094240",
    "end": "2100119"
  },
  {
    "text": "finalizers uh so the allocation code changes um we uh store we can just store",
    "start": "2100119",
    "end": "2106280"
  },
  {
    "text": "off the address we don't even need that separate reference class anymore I'm just going to use an anonymous inter class here uh note that I still add the",
    "start": "2106280",
    "end": "2114200"
  },
  {
    "text": "reference to our set we still have to keep a strong reference to it um but now this code got quite a bit simpler I can",
    "start": "2114200",
    "end": "2120240"
  },
  {
    "text": "just put the cleanup code in this callback method here now this looks like a finalizer but why doesn't it have the",
    "start": "2120240",
    "end": "2125960"
  },
  {
    "text": "problems of a finalizer well well it's for a number of reasons one I specified that uh we we we have control of the",
    "start": "2125960",
    "end": "2131880"
  },
  {
    "text": "threading model now like you don't just have one thread for the whole VM anymore um two this call back method here isn't",
    "start": "2131880",
    "end": "2139480"
  },
  {
    "text": "on the object we're trying to clean up uh so it doesn't have a reference to that and there's you don't have that",
    "start": "2139480",
    "end": "2144640"
  },
  {
    "text": "kind of uh uh impurity there like this only has a reference to the address",
    "start": "2144640",
    "end": "2150720"
  },
  {
    "text": "that's all the state that it needs so we know the object is we can uh it's obviously correct we know that the uh",
    "start": "2150720",
    "end": "2157200"
  },
  {
    "text": "that this code doesn't have access to the original object so whenever the Phantom reference",
    "start": "2157200",
    "end": "2163040"
  },
  {
    "text": "gets cleared uh this background thread what's going to happen is it's going to uh pull our that final Phantom reference",
    "start": "2163040",
    "end": "2168800"
  },
  {
    "text": "off the que and invoke this finalized reference method um and here we just free the address and we take care to",
    "start": "2168800",
    "end": "2175040"
  },
  {
    "text": "remove that reference from our set so you can see this is quite a bit shorter uh this includes both the reference",
    "start": "2175040",
    "end": "2181160"
  },
  {
    "text": "class and the factory whereas it's even shorter than just the factory before nice little class uh another",
    "start": "2181160",
    "end": "2187880"
  },
  {
    "text": "thing that this does too that I forgot to mention uh is that it gets the generics correct if you look at this uh",
    "start": "2187880",
    "end": "2194520"
  },
  {
    "text": "uh the original code that uses just the jdk classes we have a cast here and the reason we have this cast here is because",
    "start": "2194520",
    "end": "2200880"
  },
  {
    "text": "when they added generics to the to jvm they didn't uh parameterize reference Q",
    "start": "2200880",
    "end": "2206280"
  },
  {
    "text": "correctly they just made it of type T when you really wanted it of like some class that extends reference of type T",
    "start": "2206280",
    "end": "2211920"
  },
  {
    "text": "so that we get we uh could get our our reference type off there in a type Safe Way",
    "start": "2211920",
    "end": "2218160"
  },
  {
    "start": "2218000",
    "end": "2218000"
  },
  {
    "text": "um here's a little tip too uh like I mentioned um with Phantom references if",
    "start": "2218160",
    "end": "2223760"
  },
  {
    "text": "you call a git method it always returns null you can't get access to the original object uh the original API designer was a little overzealous he's",
    "start": "2223760",
    "end": "2229880"
  },
  {
    "text": "like I can't imagine any reason somebody would want to get access to an object that a phantom reference references uh",
    "start": "2229880",
    "end": "2235319"
  },
  {
    "text": "so I'm just going to totally disallow it altogether but it just so happens I did run into a case where I needed to get a",
    "start": "2235319",
    "end": "2241079"
  },
  {
    "text": "reference to the object that I wanted to use Phantom references it was in a thread local implementation for dvic and",
    "start": "2241079",
    "end": "2246880"
  },
  {
    "text": "basically the situ sitation there was I had uh a hash table you know manually implemented hash table and it contained",
    "start": "2246880",
    "end": "2253240"
  },
  {
    "text": "these reference objects and when I'd rehashed the table when I'd have to grow it I would have to be able to get access to the original objects so I came up",
    "start": "2253240",
    "end": "2260280"
  },
  {
    "text": "with this little p this little trick I call it a weak Phantom reference uh it's very much like a",
    "start": "2260280",
    "end": "2265760"
  },
  {
    "text": "phantom reference except it keeps a weak reference internally so this will keep the object around long enough first to do things like rehash uh hash table and",
    "start": "2265760",
    "end": "2273680"
  },
  {
    "text": "that sort of stuff um but so we can still get access to the orig object so long as it's weekly reachable nice",
    "start": "2273680",
    "end": "2279960"
  },
  {
    "text": "little tip uh don't forget I just wanted to kind of uh drum this in um the garbage",
    "start": "2279960",
    "end": "2286040"
  },
  {
    "start": "2281000",
    "end": "2281000"
  },
  {
    "text": "collector runs concurrently with our code and when I you know I mentioned uh weak references getting cleared uh this",
    "start": "2286040",
    "end": "2292359"
  },
  {
    "text": "is a great example here of what can happen and how fast it happens and I've actually seen this happen so I call this",
    "start": "2292359",
    "end": "2298560"
  },
  {
    "text": "class race The Collector and it has it's just a little stat it's just a little helper method",
    "start": "2298560",
    "end": "2304800"
  },
  {
    "text": "it's called uh let's see here hm I think my battery is dying here uh but it has a",
    "start": "2304800",
    "end": "2310599"
  },
  {
    "text": "dfference method here and you pass it a weak reference and basically what this method is going to do is if uh if the",
    "start": "2310599",
    "end": "2318440"
  },
  {
    "text": "reference is null it's going to throw a null pointer exception uh if it's not it's going to return it uh but the",
    "start": "2318440",
    "end": "2323560"
  },
  {
    "text": "problem with this code here is we called get and we checked if it was null but then we called get again down here the",
    "start": "2323560",
    "end": "2329720"
  },
  {
    "text": "garbage collector could have run concurrently with our code noticed that we don't actually use T anymore after",
    "start": "2329720",
    "end": "2336079"
  },
  {
    "text": "this reference here and garbage collected T somewhere in here the garbage collector could run right here",
    "start": "2336079",
    "end": "2342319"
  },
  {
    "text": "and uh By the time this code runs this reference could have been cleared out and this method will actually return",
    "start": "2342319",
    "end": "2348480"
  },
  {
    "text": "null which you this method is not supposed to do so the fix for this would",
    "start": "2348480",
    "end": "2353520"
  },
  {
    "text": "be to actually return T here make sure you return T here in so instead of calling get on the reference",
    "start": "2353520",
    "end": "2359960"
  },
  {
    "text": "again uh there's some higher level classes in the jdk one of them you might be familiar with is Java util week",
    "start": "2359960",
    "end": "2365880"
  },
  {
    "start": "2360000",
    "end": "2360000"
  },
  {
    "text": "hashmap uh week map keeps uh weak references to the Keys and strong",
    "start": "2365880",
    "end": "2371880"
  },
  {
    "text": "references to the values and this is useful for kind of like emulating adding",
    "start": "2371880",
    "end": "2377200"
  },
  {
    "text": "an additional field to an object so what do I mean by that well you can't extend objects in Java like you can in a",
    "start": "2377200",
    "end": "2383640"
  },
  {
    "text": "language like Ruby but you could have like a static weh map that Maps an",
    "start": "2383640",
    "end": "2389000"
  },
  {
    "text": "object to a value that's associated with that object so say I wanted to add I don't know like some identifier",
    "start": "2389000",
    "end": "2395640"
  },
  {
    "text": "for the object I could map the object to some uh identifier that I use to that",
    "start": "2395640",
    "end": "2400680"
  },
  {
    "text": "object and when that object goes away then uh that it's going to be",
    "start": "2400680",
    "end": "2405720"
  },
  {
    "text": "automatically removed from that weak hash map and the value will be removed too that's kind of the idea of those",
    "start": "2405720",
    "end": "2412400"
  },
  {
    "text": "it's useful in some situations um it's not concurrent so you have to synchronize it uh and um also you know",
    "start": "2412400",
    "end": "2420800"
  },
  {
    "text": "this is kind of like in my original native memory manager class it does the cleanup in line so it only does the",
    "start": "2420800",
    "end": "2426480"
  },
  {
    "text": "cleanup uh it only cleans up these values when you add more when you change that weak cash map that's kind of a",
    "start": "2426480",
    "end": "2433119"
  },
  {
    "text": "downside because it's going to keep around that value until you access the we cach map again when that value should",
    "start": "2433119",
    "end": "2438200"
  },
  {
    "text": "be able to be cleared a little sooner than that uh another downside that I found with weach map and this is a really",
    "start": "2438200",
    "end": "2445040"
  },
  {
    "text": "subtle point is that with the keys it uses it calls equals on the keys when I",
    "start": "2445040",
    "end": "2451000"
  },
  {
    "text": "submit that it should use equals equals because weak references are fundamentally identity based uh when I'm",
    "start": "2451000",
    "end": "2456960"
  },
  {
    "text": "talking about a weak reference I'm talking about that particular instance that that weak reference is pointing to",
    "start": "2456960",
    "end": "2462240"
  },
  {
    "text": "not some other instance that could be equivalent um so it's some some kind of like weird subtle things happen whenever",
    "start": "2462240",
    "end": "2468280"
  },
  {
    "text": "you use a quality with a weak Cash Mount um for example like you might have",
    "start": "2468280",
    "end": "2473560"
  },
  {
    "text": "a reference to a key and expect that to still be in the hashmap but it's not equivalency based so that could be removed and then that uh mapping won't",
    "start": "2473560",
    "end": "2479720"
  },
  {
    "text": "be there anymore the next time you go to it uh so enter guava map maker this is a class I created some time ago um it's a",
    "start": "2479720",
    "end": "2487480"
  },
  {
    "start": "2482000",
    "end": "2482000"
  },
  {
    "text": "drop in replacement for weak hashmap but it's kind of a super set uh it's well one it's concurrent it's very similar to",
    "start": "2487480",
    "end": "2493680"
  },
  {
    "text": "concurrent hashmap under the covers so you have like reads that don't lock and that sort of stuff uh it it's more",
    "start": "2493680",
    "end": "2499599"
  },
  {
    "text": "featureful rather than just supporting weak Keys it supports strong soft or weak keys and or value references and",
    "start": "2499599",
    "end": "2507000"
  },
  {
    "text": "you specify those has uses the Builder pattern it's very easy uh and also as I just talked about it uses uh equals",
    "start": "2507000",
    "end": "2513680"
  },
  {
    "text": "equals uh identity comparisons to compare weak and soft keys",
    "start": "2513680",
    "end": "2519240"
  },
  {
    "text": "um mmaker used to have some additional functionality for like and it actually technically still does but it's kind of",
    "start": "2519440",
    "end": "2525040"
  },
  {
    "text": "going it's going to go away eventually uh some uh some like caching functionality so that you could uh",
    "start": "2525040",
    "end": "2530760"
  },
  {
    "text": "create values on demand but we've replaced that with a new class uh in guava called Cash Builder and this is",
    "start": "2530760",
    "end": "2537000"
  },
  {
    "text": "Cash Builder is kind of a super set of math mapmaker that includes all this caching related functionality and this",
    "start": "2537000",
    "end": "2542880"
  },
  {
    "text": "is probably what you should use from now on instead of uh a soft reference es um",
    "start": "2542880",
    "end": "2549319"
  },
  {
    "text": "so it supports on demand computation of values I'll show you an example here in a second but essentially you give it a",
    "start": "2549319",
    "end": "2554720"
  },
  {
    "text": "function that can take a key and return a value and if you uh if you if you try to get a value out of this map and uh",
    "start": "2554720",
    "end": "2562720"
  },
  {
    "text": "the cash the cache doesn't find a mapping to that key it'll use your function to create that mapping and kind",
    "start": "2562720",
    "end": "2568960"
  },
  {
    "text": "of the cool thing about it too is that it will only ever create one value per key and this is some kind of tricky",
    "start": "2568960",
    "end": "2575160"
  },
  {
    "text": "concurrency code to get right um but basically if you have two threads that come in and try to get the same value",
    "start": "2575160",
    "end": "2580480"
  },
  {
    "text": "for the same key uh the first thread will start the computation and the second thread will wait on that",
    "start": "2580480",
    "end": "2585520"
  },
  {
    "text": "computation to finish so you can you're guaranteed that you're only going to have one mapping per key uh it also has",
    "start": "2585520",
    "end": "2591440"
  },
  {
    "text": "some other cool features like expiration you can specify uh that your values should expire sometime after they were",
    "start": "2591440",
    "end": "2597040"
  },
  {
    "text": "added to the map or sometime after they were last accessed from the map so that's uh really depends on situation",
    "start": "2597040",
    "end": "2603200"
  },
  {
    "text": "you need both and the really cool feature that was added uh I guess probably like six months ago to go to a year maybe a little longer is size",
    "start": "2603200",
    "end": "2610280"
  },
  {
    "text": "limiting and this was really the missing feature that people needed before they could really replace soft references um with cash Builder you can specify the",
    "start": "2610280",
    "end": "2617520"
  },
  {
    "text": "maximum size of your cash and once uh you start to exceed that size it will",
    "start": "2617520",
    "end": "2623839"
  },
  {
    "text": "remove it'll remove those values it's kind of funny I notic vlad's here in the audience he wrote the original expiration code that was in",
    "start": "2623839",
    "end": "2631520"
  },
  {
    "text": "mmaker um so here's an example of cach Builder uh and action uh this this",
    "start": "2632480",
    "end": "2638720"
  },
  {
    "start": "2633000",
    "end": "2633000"
  },
  {
    "text": "example I call I just call this it's like a static utility class I'm going to call it getter methods it has one method",
    "start": "2638720",
    "end": "2645880"
  },
  {
    "text": "um called on and you give it a class and it returns you a list of getter methods in that class so here's the example",
    "start": "2645880",
    "end": "2651960"
  },
  {
    "text": "usage down here uh basically you just call getter methods on food. class and it'll return you a list of the getter",
    "start": "2651960",
    "end": "2658520"
  },
  {
    "text": "methods on food. class and what's a getter method for the purposes of this slide it's just a method that starts with get so when you call whenever you",
    "start": "2658520",
    "end": "2666440"
  },
  {
    "text": "call this on method it's just going to delegate straight to our cach class that we got from the cash Builder let's look",
    "start": "2666440",
    "end": "2672520"
  },
  {
    "text": "how we built that up uh you call Cash builder. new Builder and you can specify",
    "start": "2672520",
    "end": "2677680"
  },
  {
    "text": "uh the keys like the references to the Keys uh we have weak Keys soft values",
    "start": "2677680",
    "end": "2684839"
  },
  {
    "text": "and when we call the build method that's when we specify the function that we use to actually create the list of methods",
    "start": "2684839",
    "end": "2690359"
  },
  {
    "text": "and this is just a function uh from called cach loader from class to the list of methods and all this does is the",
    "start": "2690359",
    "end": "2697720"
  },
  {
    "text": "cache will call this method whenever it needs to create a mapping for a key so",
    "start": "2697720",
    "end": "2702839"
  },
  {
    "text": "it gets the class uh it iterates over the methods in that class and picks any method that has uh G that starts with G",
    "start": "2702839",
    "end": "2710440"
  },
  {
    "text": "and adds it to that list and then returns that list and kind of the cool thing about this is that um well what",
    "start": "2710440",
    "end": "2716599"
  },
  {
    "text": "would we have to do if we didn't use a use a cache here we would have to repeatedly iterate through all the methods in the class and if you have a",
    "start": "2716599",
    "end": "2723319"
  },
  {
    "text": "lot of methods in the class that aren't getter methods you're creating all that garbage and you're doing a lot of work with this we just keep that list of",
    "start": "2723319",
    "end": "2728760"
  },
  {
    "text": "methods and with this little amount of code uh that value gets cached um some",
    "start": "2728760",
    "end": "2734400"
  },
  {
    "text": "interesting things there's a reason I picked this example uh there's some subtleties with classes and references",
    "start": "2734400",
    "end": "2740839"
  },
  {
    "text": "uh I picked weak Keys why did I do that well this is a static field uh we want",
    "start": "2740839",
    "end": "2746119"
  },
  {
    "text": "to keep weak references to the class objects and the reason for that is how many people have like used Dynamic",
    "start": "2746119",
    "end": "2752520"
  },
  {
    "text": "reloading of their web application or that sort of stuff well if we were if this class was",
    "start": "2752520",
    "end": "2759040"
  },
  {
    "text": "loaded by the system class path and we kept a strong reference to a class that",
    "start": "2759040",
    "end": "2764440"
  },
  {
    "text": "was in the web app class loader uh well this class would prevent that class loader from getting reloaded and after",
    "start": "2764440",
    "end": "2771240"
  },
  {
    "text": "you reloaded your web app so many times you would run out of memory keeping a weak reference uh to that class object",
    "start": "2771240",
    "end": "2779200"
  },
  {
    "text": "will enable that web that class loader to be reloaded now here's an even more subtle Point why did I keep a soft",
    "start": "2779200",
    "end": "2785800"
  },
  {
    "text": "reference to the value and not not just a strong reference well in this particular case notice that our value is",
    "start": "2785800",
    "end": "2792599"
  },
  {
    "text": "a list of method objects those method objects are all methods from that",
    "start": "2792599",
    "end": "2798559"
  },
  {
    "text": "class those method objects have a reference to the class that declared them so if we kept a weak even if we",
    "start": "2798559",
    "end": "2805559"
  },
  {
    "text": "kept a weak reference to the class itself if we kept a strong reference to the value we would still prevent that",
    "start": "2805559",
    "end": "2812000"
  },
  {
    "text": "web app class loader from getting reloaded right because you have a strong reference to the value to the list",
    "start": "2812000",
    "end": "2817359"
  },
  {
    "text": "which has a strong reference to a method which has a strong reference to the class which has a strong reference to its class",
    "start": "2817359",
    "end": "2823319"
  },
  {
    "text": "loader well why couldn't I just keep a weak reference to the list of methods",
    "start": "2823319",
    "end": "2828880"
  },
  {
    "text": "well uh if I did that I don't have a reference to this list of methods anywhere else and like I said before you",
    "start": "2828880",
    "end": "2834760"
  },
  {
    "text": "cannot use uh weak references for caching this would be a totally ineffective cach and the list of methods would just be reclaimed immediately",
    "start": "2834760",
    "end": "2841880"
  },
  {
    "text": "whereas if I use a soft reference as I did here then those uh that list methods",
    "start": "2841880",
    "end": "2847319"
  },
  {
    "text": "will stick around it's not the ideal situation you know like maybe I just want uh this maybe I just want to keep",
    "start": "2847319",
    "end": "2853280"
  },
  {
    "text": "this list of methods around uh permanently because you know I'm going to have like a finite number of them but if you want to enable reloading you have",
    "start": "2853280",
    "end": "2859319"
  },
  {
    "text": "to do this sort of thing so does anybody have any questions about that",
    "start": "2859319",
    "end": "2865319"
  },
  {
    "text": "cool all right so this is just a recap the levels of reachability from like strongest to weakest this isn't exactly",
    "start": "2865319",
    "end": "2871680"
  },
  {
    "start": "2867000",
    "end": "2867000"
  },
  {
    "text": "linear but we'll kind of uh I'll be a little hand wavy here strong uh soft for",
    "start": "2871680",
    "end": "2877640"
  },
  {
    "text": "caching um weak which runs before the finalizer fi uh uh finalizer like this",
    "start": "2877640",
    "end": "2883720"
  },
  {
    "text": "is kind of like you can still be referenced by the finalizer even though your object's not referenced other ways and this is when I say that's it's not",
    "start": "2883720",
    "end": "2889359"
  },
  {
    "text": "exactly linear you can go back from finalizer to being strongly referenced uh if you through via like The",
    "start": "2889359",
    "end": "2894400"
  },
  {
    "text": "Reincarnation that I talked about before um Phantom references which runs after the finalizer and then just unreachable",
    "start": "2894400",
    "end": "2900319"
  },
  {
    "text": "and that's one things can be reclaimed so this is a little demo like",
    "start": "2900319",
    "end": "2907000"
  },
  {
    "text": "to do with this talk it's something I came up with to kind of illustrate exactly how a garbage collector Works uh",
    "start": "2907000",
    "end": "2912160"
  },
  {
    "text": "and show you exactly what happens whenever uh whenever we're dealing with these references so here I I I kind of",
    "start": "2912160",
    "end": "2919160"
  },
  {
    "start": "2918000",
    "end": "2918000"
  },
  {
    "text": "just randomly generated a heap of objects and you can see that they reference each other um the different",
    "start": "2919160",
    "end": "2924240"
  },
  {
    "text": "colored ones are references the black ones are uh Heap Roots so the red ones are Phantom",
    "start": "2924240",
    "end": "2931240"
  },
  {
    "text": "references the green ones are soft references and the blue ones are weak references so I'm going to walk you",
    "start": "2931240",
    "end": "2936359"
  },
  {
    "text": "through exactly how a mark and sweep algorithm Works in garbage collection this is a popular garbage collection",
    "start": "2936359",
    "end": "2941680"
  },
  {
    "text": "algorithm pretty much all the garbage collectors in Suns BM uh uses a variation of this how many people have heard of a mark and sweep algorithm",
    "start": "2941680",
    "end": "2948040"
  },
  {
    "text": "before cool it's a very simple algorithm but it's very cool compared to things like reference counting it handles",
    "start": "2948040",
    "end": "2954079"
  },
  {
    "text": "things like circular references really well but the basic idea of a mark and sweep algorithm is that just",
    "start": "2954079",
    "end": "2960040"
  },
  {
    "text": "periodically you have this background thread or you know maybe your app just pauses periodically and does a garbage collection so let's start off off with a",
    "start": "2960040",
    "end": "2967440"
  },
  {
    "text": "mark and sweep algorithm uh you start off with no objects referenced so I just kind of like made them all light colored",
    "start": "2967440",
    "end": "2973240"
  },
  {
    "text": "so we can keep track of which ones are referenced and which ones aren't uh the first thing that the garbage collector does is it starts at a root uh in this",
    "start": "2973240",
    "end": "2979720"
  },
  {
    "start": "2978000",
    "end": "2978000"
  },
  {
    "text": "in this slide we just have one root um and we're going to start Tracing Our Heap from here uh we're going to trace",
    "start": "2979720",
    "end": "2984799"
  },
  {
    "start": "2984000",
    "end": "2984000"
  },
  {
    "text": "and mark the strongly referenced objects so here you can kind of see I'm like tracing the references from objects to",
    "start": "2984799",
    "end": "2990559"
  },
  {
    "text": "objects and marking the objects as I go uh and so kind of interestingly here",
    "start": "2990559",
    "end": "2996720"
  },
  {
    "text": "you can see like the root has a strong reference to this object which has a strong reference to a a reference object",
    "start": "2996720",
    "end": "3001839"
  },
  {
    "text": "as I mentioned before we have to keep strong references to our reference objects or else they won't get inced so we've uh traced and marked all",
    "start": "3001839",
    "end": "3009520"
  },
  {
    "text": "of our strong strongly referenced objects you can see like this object points to that one none of these objects are referenced by uh strong uh by um uh",
    "start": "3009520",
    "end": "3018720"
  },
  {
    "text": "strongly referenced via the root so none of these are marked yet um the next step",
    "start": "3018720",
    "end": "3023799"
  },
  {
    "text": "is that we optionally clear the soft references so in this case you'll see that we have like a softt reference from",
    "start": "3023799",
    "end": "3030160"
  },
  {
    "start": "3027000",
    "end": "3027000"
  },
  {
    "text": "here to this object which isn't otherwise strongly referenced so this soft reference could be cleared or maybe",
    "start": "3030160",
    "end": "3035480"
  },
  {
    "text": "not um in this case we have plenty of room on this slide so I'm going to keep it around uh so we'll we'll uh trace and",
    "start": "3035480",
    "end": "3041720"
  },
  {
    "text": "mark the softly reference objects and as you can see all of these objects come back to life uh via that soft reference",
    "start": "3041720",
    "end": "3047680"
  },
  {
    "start": "3043000",
    "end": "3043000"
  },
  {
    "text": "because we decided to retain it so and that that one right there",
    "start": "3047680",
    "end": "3053640"
  },
  {
    "text": "you'll see that those pointers right there uh those ones point to objects",
    "start": "3053640",
    "end": "3060119"
  },
  {
    "text": "that were strongly referenced so you know basically the garbage collector is going to follow those paths and see that",
    "start": "3060119",
    "end": "3065720"
  },
  {
    "text": "those objects are already marked and stop stop searching the heat uh next we're going to clear the",
    "start": "3065720",
    "end": "3071079"
  },
  {
    "text": "weak references so in this case we have uh we have two weak references the one",
    "start": "3071079",
    "end": "3077319"
  },
  {
    "start": "3073000",
    "end": "3073000"
  },
  {
    "text": "at the bottom here you can see references is an object that's already referenced but this one at the top references an object that's not",
    "start": "3077319",
    "end": "3082359"
  },
  {
    "text": "referenced so that weak reference is going to get cleared the one that I highlighted in red there and those",
    "start": "3082359",
    "end": "3088440"
  },
  {
    "text": "objects aren't going to be reachable via that um finally uh or well not finally",
    "start": "3088440",
    "end": "3094240"
  },
  {
    "text": "actually as you'll see in a moment uh now we get to the to objects with finalizers and this is where finalizers",
    "start": "3094240",
    "end": "3100839"
  },
  {
    "start": "3099000",
    "end": "3099000"
  },
  {
    "text": "really suck you know garbage collection was simple up until this point but now the garbage collector has to go and",
    "start": "3100839",
    "end": "3106920"
  },
  {
    "text": "start with the finalizer que and this is just a queue you know just like a queue in your own application um and the",
    "start": "3106920",
    "end": "3112400"
  },
  {
    "text": "garbage collector has to put any of these unmarked objects that have finalized method on them in the que uh",
    "start": "3112400",
    "end": "3119440"
  },
  {
    "text": "now we have to repeat all those steps that we just went through you know tracing the strongly referenced objects tra handling softly referenced objects",
    "start": "3119440",
    "end": "3125960"
  },
  {
    "text": "handling weakly referenced objects we have to do that all again from the que from the finalizer que and you'll see",
    "start": "3125960",
    "end": "3131640"
  },
  {
    "start": "3129000",
    "end": "3129000"
  },
  {
    "text": "that this finalizer CU brought all these objects back to life so after that uh the last step is",
    "start": "3131640",
    "end": "3139960"
  },
  {
    "text": "we uh inq any Phantom references um in this case we have one Phantom reference",
    "start": "3139960",
    "end": "3145799"
  },
  {
    "start": "3144000",
    "end": "3144000"
  },
  {
    "text": "here which points to an object that's already uh that's already marked and this Phantom references part points to",
    "start": "3145799",
    "end": "3151040"
  },
  {
    "text": "an object that's already marked so life isn't too interesting uh none of them are going to get ined uh all these",
    "start": "3151040",
    "end": "3156839"
  },
  {
    "text": "remaining objects that weren't marked are just dead so garbage collectors can do a couple things in this situation um",
    "start": "3156839",
    "end": "3163000"
  },
  {
    "text": "one it could manually go through and like reclaim all this memory and Mark it as free all the memory associated with these objects or two uh what's common is",
    "start": "3163000",
    "end": "3170680"
  },
  {
    "text": "if you've heard of a copying collector how many people have heard of a copying collector before so a copying collector",
    "start": "3170680",
    "end": "3177400"
  },
  {
    "text": "basically takes all the live objects and copies their memory into a new place in memory and then just frees all the old",
    "start": "3177400",
    "end": "3184040"
  },
  {
    "text": "memory and kind of the cool thing about that it it's a little more overhead and that you got to copy all that memory but you don't have heat fragmentation uh so",
    "start": "3184040",
    "end": "3191760"
  },
  {
    "start": "3190000",
    "end": "3190000"
  },
  {
    "text": "and then all those objects are gone we clear them all out they're gone and we start with our Heap again and we repeat",
    "start": "3191760",
    "end": "3198359"
  },
  {
    "text": "so uh you know like I said you start at the root do the softly referen objects weekly referenced uh handle the",
    "start": "3198359",
    "end": "3204040"
  },
  {
    "text": "finalizer objects and repeat all those steps again uh and then uh you POS handle the Phantom references after the",
    "start": "3204040",
    "end": "3209920"
  },
  {
    "text": "finalizer is run and then the remaining objects are dead and you repeat so this is kind of like a little tidbit um in",
    "start": "3209920",
    "end": "3216160"
  },
  {
    "text": "case you're wondering whether I meticulously uh tweaked all those little",
    "start": "3216160",
    "end": "3222319"
  },
  {
    "text": "object graphs uh by hand the answer is no I actually wrote a Java tool that",
    "start": "3222319",
    "end": "3227559"
  },
  {
    "text": "generated this presentation so I write I write this presentation in Java code this is actually the code for this",
    "start": "3227559",
    "end": "3233000"
  },
  {
    "text": "presentation it's out on Google code it's called crazy Bob's talks and in the case of uh you'll see the",
    "start": "3233000",
    "end": "3238960"
  },
  {
    "text": "code for this heat presentation here I actually just created objects in memory that represented these objects and then",
    "start": "3238960",
    "end": "3245079"
  },
  {
    "text": "wrote American sweep algorithm so it was a lot more fun than like going from through like 30 30 some odd slides and",
    "start": "3245079",
    "end": "3251319"
  },
  {
    "text": "uh uh coming up with all those animations myself um so thank you everyone for",
    "start": "3251319",
    "end": "3258480"
  },
  {
    "text": "coming uh if you enjoyed this talk I'm crazy Bob on Twitter if you want to learn more you know I tweet about like",
    "start": "3258480",
    "end": "3264040"
  },
  {
    "text": "my open source projects and that sort of stuff also I said with with I work at Square we're doing tons of very cool uh",
    "start": "3264040",
    "end": "3271319"
  },
  {
    "text": "Java code and we do lots of cool open source projects so if you're interested in learning more you can email me at",
    "start": "3271319",
    "end": "3277480"
  },
  {
    "text": "Java jobs squareup.com thanks",
    "start": "3277480",
    "end": "3282750"
  },
  {
    "text": "[Applause]",
    "start": "3282750",
    "end": "3288880"
  },
  {
    "text": "[Music]",
    "start": "3288880",
    "end": "3300049"
  }
]