[
  {
    "text": "hi everybody i'm steve i'm here to give you this talk with this terrible or",
    "start": "3929",
    "end": "9660"
  },
  {
    "text": "awesome pun depending on your opinion the talk you've been awaiting for I I",
    "start": "9660",
    "end": "16139"
  },
  {
    "text": "work at CloudFlare and some stuff totally unrelated all these things but uh before that I worked at Mozilla on",
    "start": "16139",
    "end": "21480"
  },
  {
    "text": "the rust programming language and I'm still working on the rust language in a hobby capacity these days so I've been",
    "start": "21480",
    "end": "27809"
  },
  {
    "text": "on the core team since like 2014 and I wrote the book the rust programming language if you're trying to learn rust",
    "start": "27809",
    "end": "33840"
  },
  {
    "text": "and so this is kind of a talk that I've been really super psyched to give for a very long time and it's about how a",
    "start": "33840",
    "end": "40710"
  },
  {
    "text": "single wait works in rust at like a very deep sort of technical level so come on",
    "start": "40710",
    "end": "49649"
  },
  {
    "text": "speak your notes there we go so this is a screenshot from this blog post this actually happened last week",
    "start": "49649",
    "end": "56429"
  },
  {
    "text": "yeah last Thursday we released a async/await and rust and this is a",
    "start": "56429",
    "end": "62069"
  },
  {
    "text": "culmination of like four years of development maybe three or four years in total and it was the work of a lot of",
    "start": "62069",
    "end": "69630"
  },
  {
    "text": "people all of whom were not me so one of the functions I had to play in the rust world is like amateur historian",
    "start": "69630",
    "end": "76350"
  },
  {
    "text": "so I sort of like to collect what we've been doing and then presented to people so and I make it super clear that I didn't do any of the work to design this",
    "start": "76350",
    "end": "82620"
  },
  {
    "text": "feature I'm just here to explain it to you and I have some citations this powe this talk specifically draws on some",
    "start": "82620",
    "end": "89130"
  },
  {
    "text": "really great blog posts written by some of the people who did do all that work and so I have some links at the end and",
    "start": "89130",
    "end": "94740"
  },
  {
    "text": "you can also go read a bunch of that stuff but uh but yeah so the previously",
    "start": "94740",
    "end": "103370"
  },
  {
    "text": "AQ Khan I gave a talk called Russ journey to async/await I should",
    "start": "103370",
    "end": "109320"
  },
  {
    "text": "have posited on my title slide and not like Q Khan New York but whatever it's fine that talk was given like about a year",
    "start": "109320",
    "end": "116640"
  },
  {
    "text": "ago and it was a very high-level overview of like why rust cared about async/await and an overview of different",
    "start": "116640",
    "end": "122610"
  },
  {
    "text": "concurrency methods and so if you want like a high level version of the talk you can like watch that previous one but",
    "start": "122610",
    "end": "128879"
  },
  {
    "text": "I'm really excited for this now that we've actually shipped the feature to talk about the low-level details this talk is sort of like we're going to talk",
    "start": "128879",
    "end": "136379"
  },
  {
    "text": "about how asynchronous function d sugar into more complicated futures and there is like a lot of code in this",
    "start": "136379",
    "end": "142290"
  },
  {
    "text": "in this talk and a lot of type signatures so how many of you have like written rust before or would think that",
    "start": "142290",
    "end": "148500"
  },
  {
    "text": "you're reasonably competent it rests awesome that's very exciting for those",
    "start": "148500",
    "end": "153630"
  },
  {
    "text": "of you who are not hopefully you can follow along I am sorry if it's a little",
    "start": "153630",
    "end": "158670"
  },
  {
    "text": "tough I'm gonna try to take my time and go through things but there's a lot of stuff going on here and I really want to",
    "start": "158670",
    "end": "165480"
  },
  {
    "text": "get like deep into the Nitty Gritty because I think that's really the most interesting part I picked this image because it's like a",
    "start": "165480",
    "end": "171930"
  },
  {
    "text": "meme but also I think it really fits with the theme of this track because rusts implementation of a single weight",
    "start": "171930",
    "end": "178140"
  },
  {
    "text": "is in many ways actually kind of novel it's not novel in the sense that we invented brand new things but it's we",
    "start": "178140",
    "end": "185610"
  },
  {
    "text": "assembled a bunch of existing concepts together in a way that had not really previously been done and that's part of",
    "start": "185610",
    "end": "191790"
  },
  {
    "text": "why it took so while but it took so long but that's also why I think it's really",
    "start": "191790",
    "end": "196800"
  },
  {
    "text": "interesting and exciting and so I think we have the like most performance possible implementation of async/await",
    "start": "196800",
    "end": "203700"
  },
  {
    "text": "that could ever exist we'll see if someone proves me wrong someday but like when you look at",
    "start": "203700",
    "end": "209670"
  },
  {
    "text": "overheads and stuff it's like very very low and so we're gonna get into how all that works it involves a lot of moving",
    "start": "209670",
    "end": "214890"
  },
  {
    "text": "parts so fundamentally we're gonna talk about three things and then depending on",
    "start": "214890",
    "end": "221430"
  },
  {
    "text": "a 5-time will cover one last little bonus round I usually give talks that are not very code heavy and so I know",
    "start": "221430",
    "end": "227640"
  },
  {
    "text": "how long those are but this is a very code heavy talk so I want to put a little bit extra stuff in there so maybe",
    "start": "227640",
    "end": "233550"
  },
  {
    "text": "we'll get to async functions and traits but the three core important things to understand when you want to get into",
    "start": "233550",
    "end": "238860"
  },
  {
    "text": "async await and rust at a low level is first of all the concept of async await and also futures which is the main",
    "start": "238860",
    "end": "245340"
  },
  {
    "text": "feature that's backing it and then secondarily this thing called generators which is the underlying implementation",
    "start": "245340",
    "end": "250530"
  },
  {
    "text": "of async weight and then finally tasks executors and reactors",
    "start": "250530",
    "end": "256109"
  },
  {
    "text": "oh my which is sort of how the futures actually execute and there's some",
    "start": "256109",
    "end": "262740"
  },
  {
    "text": "different parts that are broken up into that so those three things at first are like the most important thing to understand and the last one is an",
    "start": "262740",
    "end": "268800"
  },
  {
    "text": "interesting extension to the language that I I personally find really interesting so it's a little more about the future",
    "start": "268800",
    "end": "275060"
  },
  {
    "text": "so let's get into it first of all we're gonna talk about async Lee and futures",
    "start": "275060",
    "end": "281490"
  },
  {
    "text": "so first of all I while I've mentioned this talk is gonna have a lot of code",
    "start": "281490",
    "end": "287010"
  },
  {
    "text": "and a lot of complicated type signatures I wanted to show you how you as a user would write code with a single weight in",
    "start": "287010",
    "end": "292620"
  },
  {
    "text": "rust so here's an example taken from Tokyo's DOX Tokyo is a package that",
    "start": "292620",
    "end": "297900"
  },
  {
    "text": "implements a bunch of the stuff that we're about to talk about so that you don't have to do it yourself and so this is a very simple program you can see on",
    "start": "297900",
    "end": "305610"
  },
  {
    "text": "Line six we have a TCP listener where we listen to a TCP connection on a given",
    "start": "305610",
    "end": "310650"
  },
  {
    "text": "you know localhost port 8080 and then we loop over accepting connections over",
    "start": "310650",
    "end": "317790"
  },
  {
    "text": "that listener and then finally we like do some processing which I actually sort of eliminated and so you can see that uh",
    "start": "317790",
    "end": "325490"
  },
  {
    "text": "we got an async function main up here and we got a couple lines that are marked dot await the question mark is",
    "start": "325490",
    "end": "332640"
  },
  {
    "text": "for error handling purposes in rust so if you're not familiar with that that basically says like if there's an error then return the error otherwise return",
    "start": "332640",
    "end": "339300"
  },
  {
    "text": "the value so this is kind of the way that it actually feels when you would be writing normal code with with this kind",
    "start": "339300",
    "end": "345930"
  },
  {
    "text": "of stuff you have async functions you call a wait sometimes in the body and just kind of go along with your day",
    "start": "345930",
    "end": "352410"
  },
  {
    "text": "the main reason people really wanted this is because the ergonomic benefits are pretty massive this is much simpler",
    "start": "352410",
    "end": "358590"
  },
  {
    "text": "than what it do sugars to which is what we're about to get into but finally I also wanted to mention that we have this",
    "start": "358590",
    "end": "364440"
  },
  {
    "text": "concept called an async block so you don't actually need to have a full function for a single weight you can",
    "start": "364440",
    "end": "370350"
  },
  {
    "text": "also do async and then a curly brace in this case the move is there for reasons I don't want to get into at the moment",
    "start": "370350",
    "end": "375720"
  },
  {
    "text": "but you can also like take portions of your code and wrap them up in a single weight as well it doesn't actually have",
    "start": "375720",
    "end": "381360"
  },
  {
    "text": "to be at the function boundary and that's useful because in this example there's this API called Tokyo spawn and",
    "start": "381360",
    "end": "387120"
  },
  {
    "text": "that basically spins up a new task we're gonna talk a lot about tasks in the future but sort of the idea is this",
    "start": "387120",
    "end": "393240"
  },
  {
    "text": "spins up a new unit of work and so rather than make you write a brand new function every time passing an async",
    "start": "393240",
    "end": "398850"
  },
  {
    "text": "block to it sort of makes sense so so yeah this is kind of like what writing code would feel like and the way that",
    "start": "398850",
    "end": "404999"
  },
  {
    "text": "people would interact with async/await but if you want to start understanding and at a more surface i don't like a deeper level the very first thing that",
    "start": "404999",
    "end": "411509"
  },
  {
    "text": "you need to understand is that a single wait is simpler syntax for writing this thing called future in rust there's",
    "start": "411509",
    "end": "419699"
  },
  {
    "text": "actually technically an asterisk there it's it's a little more complicated than that but that's like the high level way",
    "start": "419699",
    "end": "425309"
  },
  {
    "text": "to think about it we're gonna get into the asterisk in just a minute but ultimately that's really what the way if",
    "start": "425309",
    "end": "431069"
  },
  {
    "text": "you want to think about it and a future is this concept that represents some",
    "start": "431069",
    "end": "436649"
  },
  {
    "text": "sort of value that will exist sometime in the future this is kind of the core idea of a synchronicity but this reifies",
    "start": "436649",
    "end": "443549"
  },
  {
    "text": "it into an actual like thing and so instead of like needing to have a callback which may be executed at some",
    "start": "443549",
    "end": "449759"
  },
  {
    "text": "time in the future the idea is you have this like object and the rest doesn't really have objects in the oo sense but",
    "start": "449759",
    "end": "455489"
  },
  {
    "text": "like a bit of data that you can basically ask hey does that thing exist yet and it will either tell you like it",
    "start": "455489",
    "end": "461999"
  },
  {
    "text": "doesn't exist yet check back in with me later or it'll say yeah it exists here's the value and that's kind of this poor",
    "start": "461999",
    "end": "467639"
  },
  {
    "text": "idea and so that's the the basic principle and that lets us represent a synchronicity in a way that like works",
    "start": "467639",
    "end": "474389"
  },
  {
    "text": "really well with everything else so the first thing we're gonna do is build a future specifically we have this example",
    "start": "474389",
    "end": "481979"
  },
  {
    "text": "called a timer future so what's gonna happen is this is a future that goes to sleep for a certain amount of time and",
    "start": "481979",
    "end": "487949"
  },
  {
    "text": "then after that I'm out of time happens it will sort of like wake up and say here's this particular value this is",
    "start": "487949",
    "end": "493769"
  },
  {
    "text": "sort of a great hello world example of building a future by hand and while async/await sort of builds futures for",
    "start": "493769",
    "end": "500339"
  },
  {
    "text": "you at the lowest level people who write libraries will implement futures by hand and so I'm going to show you how to do",
    "start": "500339",
    "end": "506249"
  },
  {
    "text": "that so you can kind of see what the guts look like because we're gonna talk a lot more about the guts the implementation strategy we're taking for",
    "start": "506249",
    "end": "512518"
  },
  {
    "text": "this timer future is very simple you could write a much more efficient one than this and that's also true of sort",
    "start": "512519",
    "end": "519268"
  },
  {
    "text": "of all of the code examples that I'm going to show in this talk I'm trying to show examples that are easier to understand not necessarily the most",
    "start": "519269",
    "end": "524819"
  },
  {
    "text": "efficient so the folks who write libraries that do this for production grade things will you know be writing a",
    "start": "524819",
    "end": "531329"
  },
  {
    "text": "significantly more complicated code but it'll have more performance so in this case we're gonna put a mutex around a",
    "start": "531329",
    "end": "536339"
  },
  {
    "text": "boolean and that boolean is going to live between our future and also a new thread",
    "start": "536339",
    "end": "542270"
  },
  {
    "text": "that our future spins up and that thread is then going to sleep for however long we decide we want to wait and then when",
    "start": "542270",
    "end": "548960"
  },
  {
    "text": "that thread wakes back up it will set the boolean to true and tell the future hey we're good to go and calls to the",
    "start": "548960",
    "end": "555410"
  },
  {
    "text": "poll method of future which we're gonna talk about one second we'll check that boolean to see if we've waked up yet or not so this means you have a thread per",
    "start": "555410",
    "end": "562580"
  },
  {
    "text": "timer super inefficient mutex around a boolean also super inefficient probably",
    "start": "562580",
    "end": "567650"
  },
  {
    "text": "we want to use an atomic integer instead yadda yadda I'm trying to keep this like very simple like I said a real",
    "start": "567650",
    "end": "572900"
  },
  {
    "text": "implementation would integrate with your operating system to set up a timer and do all that kind of stuff so I mentioned",
    "start": "572900",
    "end": "579380"
  },
  {
    "text": "a bunch about futures so far a future is a trait in rust so that means that it's an interface that you can you know build",
    "start": "579380",
    "end": "585830"
  },
  {
    "text": "different things the interface sort of looks like this there's two main components first of all is the trait future itself it has an Associated type",
    "start": "585830",
    "end": "593150"
  },
  {
    "text": "called output and that's the value that you will get from the future if it ever exists and then there's this function",
    "start": "593150",
    "end": "598310"
  },
  {
    "text": "called pull it takes two arguments itself in a context we're gonna ignore",
    "start": "598310",
    "end": "603380"
  },
  {
    "text": "those completely for now and it returns this enum called pull with the output type and the pulley num is defined as",
    "start": "603380",
    "end": "610130"
  },
  {
    "text": "either ready or pending so the idea is that we call pull and then we get back either a thing and says yes you're ready",
    "start": "610130",
    "end": "615140"
  },
  {
    "text": "here's the value or you get back a thing that says we're not ready yet you may be wondering about error",
    "start": "615140",
    "end": "620330"
  },
  {
    "text": "handling so previous iterations of this feature had air-handling built in but",
    "start": "620330",
    "end": "626120"
  },
  {
    "text": "it's actually easier to compose this with standard rust and/or air-handling idioms so what happens is if you have a",
    "start": "626120",
    "end": "631580"
  },
  {
    "text": "future that can fail then the output type will be what Russ calls a result which indicates success or failure so",
    "start": "631580",
    "end": "637400"
  },
  {
    "text": "you kind of compose the result type with the futures return type and that makes things like a lot cleaner and",
    "start": "637400",
    "end": "643339"
  },
  {
    "text": "interoperable and doesn't means you don't need to represent different concepts of like fallible versus",
    "start": "643339",
    "end": "648350"
  },
  {
    "text": "infallible futures and like all that stuff we explored with those designs over the last couple years and this is",
    "start": "648350",
    "end": "653480"
  },
  {
    "text": "basically the cleanest and like most orthogonal way to do it so let's actually build a future we're",
    "start": "653480",
    "end": "660560"
  },
  {
    "text": "gonna build this timer future so we create a structure actually represent the data that we need to hold and inside",
    "start": "660560",
    "end": "665660"
  },
  {
    "text": "it we have this thing called shared state which has an atomic reference counted thing wrapped around a mutex",
    "start": "665660",
    "end": "672110"
  },
  {
    "text": "around this thing called shared state and shared state is gonna have two bits of data first of all that boolean that I talked about which is gonna represent",
    "start": "672110",
    "end": "678110"
  },
  {
    "text": "whether or not the we've like finished sleeping and then finally this thing called a Waker we're gonna get more into",
    "start": "678110",
    "end": "684500"
  },
  {
    "text": "wakers in a second but we need to keep track of both of these bits of data and this design and we're gonna wrap them up",
    "start": "684500",
    "end": "691399"
  },
  {
    "text": "in this mark mutex again sort of for simplicity sake this is actually super inefficient then we're actually",
    "start": "691399",
    "end": "699230"
  },
  {
    "text": "implementing a future for this timer future so the output of our timer feature is not actually anything all",
    "start": "699230",
    "end": "705890"
  },
  {
    "text": "we're doing is just waking up and you would usually chain this future with something else so you'd say like okay when this is done and do something else",
    "start": "705890",
    "end": "711560"
  },
  {
    "text": "so we're not really producing a value out of future so they're on line to where it says the type output is the empty tuple we're not actually like",
    "start": "711560",
    "end": "718070"
  },
  {
    "text": "producing anything and so finally like line three is that type signature we just saw with poll and so this is gonna",
    "start": "718070",
    "end": "724579"
  },
  {
    "text": "be implementation like what happens when the runtime calls our timer future and actually want something to execute",
    "start": "724579",
    "end": "731019"
  },
  {
    "text": "fundamentally what happens here is we lock the mutex and it's stored in our",
    "start": "731019",
    "end": "736399"
  },
  {
    "text": "shared state so we can actually look at its contents and then we check to see like if it's completed if that boolean",
    "start": "736399",
    "end": "742940"
  },
  {
    "text": "is set to true then we return that we're ready with that empty tuples and if we're not ready yet what we do is we",
    "start": "742940",
    "end": "749839"
  },
  {
    "text": "stash a copy of the Waker into that shared State this is comes from that",
    "start": "749839",
    "end": "755120"
  },
  {
    "text": "context variable up top so this is specifically like the end of line nine we're like taking a copy of the Waker",
    "start": "755120",
    "end": "761480"
  },
  {
    "text": "and we're storing in our future and we'll get into specifics about that in a second you'll see how that stuff it",
    "start": "761480",
    "end": "767420"
  },
  {
    "text": "interacts and then we return hey we're not actually ready yet and so this is like a very simple mentation like check",
    "start": "767420",
    "end": "773750"
  },
  {
    "text": "the bool you know if it's if it's if it's good then we return if it's not",
    "start": "773750",
    "end": "778940"
  },
  {
    "text": "then we say hold on we need to wait yet and then we actually create our our",
    "start": "778940",
    "end": "786380"
  },
  {
    "text": "thread that we spin up in a new method so we say we want to produce a new timer future so we implement a method on it",
    "start": "786380",
    "end": "792800"
  },
  {
    "text": "with it takes a certain duration so we can parameterize how much time we want to wait and then this is going to end up",
    "start": "792800",
    "end": "798110"
  },
  {
    "text": "so first of all constructing that shared state as you can see on lines like three through six we set our boolean to false",
    "start": "798110",
    "end": "803660"
  },
  {
    "text": "and we put a nun in to where the Waker is because we don't have one yet because the future hasn't started actually",
    "start": "803660",
    "end": "808720"
  },
  {
    "text": "executed and then on line 9 through line",
    "start": "808720",
    "end": "813940"
  },
  {
    "text": "18 is where we're spinning up our thread so we're producing a new thread with thread spawn we passed a closure to it",
    "start": "813940",
    "end": "820420"
  },
  {
    "text": "with what we want to execute in the body of the thread and on line 10 there you can see that the thread sleeps for",
    "start": "820420",
    "end": "826330"
  },
  {
    "text": "however long that duration is that we passed in and then after it's done it will take the mutex out on line 11 and",
    "start": "826330",
    "end": "833200"
  },
  {
    "text": "unlock the mutex set that completed boolean to true and then lines 15 through 17 are the interesting part with",
    "start": "833200",
    "end": "840190"
  },
  {
    "text": "this Waker so we take that Waker that we had stashed in our future and we call",
    "start": "840190",
    "end": "845470"
  },
  {
    "text": "this wake function on it this is a interesting part I have a diagram later for how all these bits sort of interact",
    "start": "845470",
    "end": "851680"
  },
  {
    "text": "but I started to wait until after we talked about the future basically there's this concept called a Waker and",
    "start": "851680",
    "end": "856870"
  },
  {
    "text": "your future before it returns that it's ready it needs to call this wake function to let the executors know that",
    "start": "856870",
    "end": "863140"
  },
  {
    "text": "it's happening we haven't gotten there yet I promise we will for now just like know that futures need to interact with this API and they have to call wake to",
    "start": "863140",
    "end": "869950"
  },
  {
    "text": "like awaken themselves and then finally we return the future that we have and that's it there's a lot of moving parts",
    "start": "869950",
    "end": "877420"
  },
  {
    "text": "going on here but like fundamentally we have our thread we have our structure you know the thread sleeps and that's it",
    "start": "877420",
    "end": "884220"
  },
  {
    "text": "you don't need to write stuff like this in everyday rust because other people have libraries that have done it for you",
    "start": "884220",
    "end": "889810"
  },
  {
    "text": "so this is sort of like an academic exercise but I sort of wanted to show you the bits and pieces of how these sort of move together and we're gonna",
    "start": "889810",
    "end": "896140"
  },
  {
    "text": "build some stuff to actually execute this future and the feet in the in the future later in this talk and so I sort",
    "start": "896140",
    "end": "902800"
  },
  {
    "text": "of wanted to show you like the very basic implementation of this kind of thing so yeah next up briefly I want to",
    "start": "902800",
    "end": "912010"
  },
  {
    "text": "take a small detour and give you sort of like four rules as a user when you're using async/await",
    "start": "912010",
    "end": "917020"
  },
  {
    "text": "to sort of get an intuition for how you would actually use it yourself before we dig into the guts of the next like big",
    "start": "917020",
    "end": "923380"
  },
  {
    "text": "concept here so as I mentioned in that that joke slide earlier with a live",
    "start": "923380",
    "end": "929260"
  },
  {
    "text": "slide if you write an async function foo that say takes a string as an argument and returns a 32-bit integer then that's",
    "start": "929260",
    "end": "936250"
  },
  {
    "text": "sort of syntax sugar and what if sugar four is a regular function that still takes that string as",
    "start": "936250",
    "end": "941890"
  },
  {
    "text": "an argument but returns some implementation of a future that returns that 32-bit value as its output and so",
    "start": "941890",
    "end": "950800"
  },
  {
    "text": "you can kind of think of like async functions sort of return some kind of anonymous future struct why would you",
    "start": "950800",
    "end": "958180"
  },
  {
    "text": "not just write that in future yourself there's a lot of reasons that we're gonna get into in a second but the point",
    "start": "958180",
    "end": "963670"
  },
  {
    "text": "is is that mentally this is like how you think about a single weight as a user as like an async function returns a future but I don't have to worry about that and",
    "start": "963670",
    "end": "970480"
  },
  {
    "text": "what that means is if you have some sort of future that you get from a library or from another async function and you want",
    "start": "970480",
    "end": "975820"
  },
  {
    "text": "to get that value out of it you call a weight on that future and so this can work with any future from any source it",
    "start": "975820",
    "end": "982240"
  },
  {
    "text": "doesn't really matter and sort of that's how you like pull the value out is by calling weight and then finally well not",
    "start": "982240",
    "end": "990040"
  },
  {
    "text": "actually super finally but like you could only call a weight inside of an async function or at async block because",
    "start": "990040",
    "end": "995490"
  },
  {
    "text": "you know it's building up this chain of futures just the next subject we're about to talk about and so you can't",
    "start": "995490",
    "end": "1001830"
  },
  {
    "text": "just a weight on a random value anywhere you have to do it inside one of these function bodies and that's kind of why it's called a single weight is because",
    "start": "1001830",
    "end": "1008340"
  },
  {
    "text": "you can't really use a weight without also using async and the last interesting one before we get into some",
    "start": "1008340",
    "end": "1015570"
  },
  {
    "text": "more of the details about these system works this is the biggest thing that trips people up that are coming from a language like nodejs with their version",
    "start": "1015570",
    "end": "1021960"
  },
  {
    "text": "of promises and async await and that is futures don't execute until you pass it to something that's conveniently called",
    "start": "1021960",
    "end": "1028170"
  },
  {
    "text": "an executor so in in languages like like node there is a runtime and that exists",
    "start": "1028170",
    "end": "1035310"
  },
  {
    "text": "in all programs and there's this thing called the event loop we're going to talk about Amit and it sort of executes",
    "start": "1035310",
    "end": "1040770"
  },
  {
    "text": "whatever promises that you build with a single weight kind of automatically so as soon as you create a promise it'll get put on the micro task queue and then",
    "start": "1040770",
    "end": "1047310"
  },
  {
    "text": "it will end up being implemented rust works a little bit differently in that when you when you call this async",
    "start": "1047310",
    "end": "1054120"
  },
  {
    "text": "function you get a future back futures don't start executing until you explicitly tell them to and this is sort",
    "start": "1054120",
    "end": "1060330"
  },
  {
    "text": "of a slight change in mental model but it leads to some pretty extreme efficiency gains that are not really",
    "start": "1060330",
    "end": "1067320"
  },
  {
    "text": "possible otherwise and we're going to get into what those are but before I do that we said that you",
    "start": "1067320",
    "end": "1074870"
  },
  {
    "text": "can't execute a future unless you pass to an executor but when I showed you the code earlier with Tokyo like there was",
    "start": "1074870",
    "end": "1081080"
  },
  {
    "text": "no executor and passing a future to it so like how does that work well there is this magic little attribute that happens",
    "start": "1081080",
    "end": "1086690"
  },
  {
    "text": "called Tokyo main that lets you write async function main and basically that's a little macro that takes your main",
    "start": "1086690",
    "end": "1092540"
  },
  {
    "text": "function grabs a future out of it and submits it to an executor and then calls wait so this like means you don't",
    "start": "1092540",
    "end": "1097790"
  },
  {
    "text": "actually have to do it yourself and you kind of think of this as more of like a node JSE sort of style of writing things",
    "start": "1097790",
    "end": "1103190"
  },
  {
    "text": "but we built this as convenience functions and libraries because we don't have like a language built in event loop",
    "start": "1103190",
    "end": "1111170"
  },
  {
    "text": "you want to be able to use libraries that have implemented these in different ways because some people are writing web applications and they don't care about",
    "start": "1111170",
    "end": "1117290"
  },
  {
    "text": "dynamically allocating memory that much and they certainly care about network performance other people use async await",
    "start": "1117290",
    "end": "1122810"
  },
  {
    "text": "on embedded devices and they really care about not allocating memory dynamically and doing those kind of things they may",
    "start": "1122810",
    "end": "1130160"
  },
  {
    "text": "not want to be able to have an unbounded queue of possible tasks because that means more dynamic memory allocation and",
    "start": "1130160",
    "end": "1136640"
  },
  {
    "text": "so there's a lot of options in sort of the space that rust is in so we can't build these things in a language and",
    "start": "1136640",
    "end": "1142100"
  },
  {
    "text": "that means you end up using these library features to make it more ergonomic so will actually show us",
    "start": "1142100",
    "end": "1147200"
  },
  {
    "text": "submitting in a future to an executor manually once we actually write an executor in a bit but there's one last",
    "start": "1147200",
    "end": "1154400"
  },
  {
    "text": "part of this implication that trips folks up that are coming from node or just javascript in the browser even and",
    "start": "1154400",
    "end": "1160370"
  },
  {
    "text": "that is this sort of example so here I have this this this is an actual timer",
    "start": "1160370",
    "end": "1166340"
  },
  {
    "text": "function that someone wrote so it's called delay instead of the one that we implemented and I wrote this function",
    "start": "1166340",
    "end": "1172100"
  },
  {
    "text": "called I sleep that basically sleeps for five seconds and so if you write this code where on line six we call I sleep",
    "start": "1172100",
    "end": "1179810"
  },
  {
    "text": "once and then on life seven we call I sleep again we get two variables so we have two futures and we wait on them on",
    "start": "1179810",
    "end": "1186200"
  },
  {
    "text": "lines nine and ten if you're used to coming from JavaScript you might think that this function would take roughly",
    "start": "1186200",
    "end": "1191540"
  },
  {
    "text": "five seconds to execute because as soon as you would call I sleep it would start processing those two futures and go",
    "start": "1191540",
    "end": "1198320"
  },
  {
    "text": "around in the background but because everything doesn't happen until you submit stuff to an executor and a wait",
    "start": "1198320",
    "end": "1204260"
  },
  {
    "text": "actually makes things happen sort of sequentially this will actually wait for the full first future to happen and so that I'll",
    "start": "1204260",
    "end": "1210059"
  },
  {
    "text": "take five seconds and it'll wait for the full second future to happen and that'll take five seconds and so this is a thing",
    "start": "1210059",
    "end": "1216330"
  },
  {
    "text": "that definitely sort of trips people up sometimes and they're getting started if you want to emulate the node behavior there's a function called join that will",
    "start": "1216330",
    "end": "1223769"
  },
  {
    "text": "take two futures and weight them in parallel and so if you want parallelism you need to like expressly put it in in",
    "start": "1223769",
    "end": "1229679"
  },
  {
    "text": "the rust model so that's like probably the biggest shift coming from something",
    "start": "1229679",
    "end": "1235080"
  },
  {
    "text": "like javascript to something like rust is that you know you don't get this automatic execution and it's extra",
    "start": "1235080",
    "end": "1240929"
  },
  {
    "text": "unfortunate because rust has this reputation of if it compiles it works and so a lot of people coming from",
    "start": "1240929",
    "end": "1246090"
  },
  {
    "text": "JavaScript write their first program with futures and it compiles and they run it and it doesn't do anything and",
    "start": "1246090",
    "end": "1251940"
  },
  {
    "text": "they're like I thought if it compiled it actually works and it turns out that if you don't submit the future like rust will be like sure that computation",
    "start": "1251940",
    "end": "1258149"
  },
  {
    "text": "you're describing it is typed perfectly everything is set up you're good to go and then does not actually execute it so",
    "start": "1258149",
    "end": "1263999"
  },
  {
    "text": "cool we just return and don't do anything and that can be a little surprising so those two things in combination are sort of like important",
    "start": "1263999",
    "end": "1270659"
  },
  {
    "text": "to remember but uh but yeah the reason that this happens is what I'm about to",
    "start": "1270659",
    "end": "1276239"
  },
  {
    "text": "get into now which is that because rust is really interested in type type system",
    "start": "1276239",
    "end": "1282149"
  },
  {
    "text": "stuff and efficiency it means that we do a lot of static analysis of how you're",
    "start": "1282149",
    "end": "1287940"
  },
  {
    "text": "using async gonna wait to build up sort of like the maximally efficient thing that you possibly could execute so the",
    "start": "1287940",
    "end": "1293730"
  },
  {
    "text": "issue with the model that JavaScript uses which is great for it as a language is that in order for the future to start",
    "start": "1293730",
    "end": "1298769"
  },
  {
    "text": "executing as soon as you call it we would need to actually like allocate that as a task and then start executing",
    "start": "1298769",
    "end": "1304379"
  },
  {
    "text": "it in the background while we create new values but rust wants to take your entire computation the whole way through",
    "start": "1304379",
    "end": "1309690"
  },
  {
    "text": "everything you've chained together and then compile it down into something super mega ultra efficient and you couldn't do that if your computation",
    "start": "1309690",
    "end": "1316080"
  },
  {
    "text": "started running before you've even like pieced the whole thing together and so we're gonna talk about how that",
    "start": "1316080",
    "end": "1322259"
  },
  {
    "text": "implementation actually works now so part two generators also called stack",
    "start": "1322259",
    "end": "1329460"
  },
  {
    "text": "Lascaux routines there are like a million different names for the features in this area and no one has consistent",
    "start": "1329460",
    "end": "1336240"
  },
  {
    "text": "terminology whatsoever so i sort of apologized names are hard we call",
    "start": "1336240",
    "end": "1341700"
  },
  {
    "text": "them generators other people call them stack gross co-routines some people are like well co-routines don't return a value and generators return of value so",
    "start": "1341700",
    "end": "1348420"
  },
  {
    "text": "a generator is a kind of covert team whatever I don't actually care about our game about names the point is we called",
    "start": "1348420",
    "end": "1353850"
  },
  {
    "text": "our future generators and it's it's fine generators are not a stable feature of",
    "start": "1353850",
    "end": "1359130"
  },
  {
    "text": "the rust language yet they're in nightly and you can try playing around with them and so I'm gonna show you is the nightly",
    "start": "1359130",
    "end": "1364860"
  },
  {
    "text": "only syntax but I'll make it clear that you can't actually implement generators by hand unstable rust yet if you are watching",
    "start": "1364860",
    "end": "1371040"
  },
  {
    "text": "this talk a year from now maybe this all has changed I just want to like flag that as a thing but it's important",
    "start": "1371040",
    "end": "1376350"
  },
  {
    "text": "because generators are how async/await is implemented under the hood so that's why we put them in the language is because the compiler uses this feature",
    "start": "1376350",
    "end": "1382560"
  },
  {
    "text": "to do that efficient computation based stuff I was talking about so in order to truly understand the details you kind of",
    "start": "1382560",
    "end": "1388710"
  },
  {
    "text": "have to know a little bit about this experimental feature and its core generators are sometimes called",
    "start": "1388710",
    "end": "1394290"
  },
  {
    "text": "resumable functions I never really thought that made sense to me if that makes sense to you awesome",
    "start": "1394290",
    "end": "1399840"
  },
  {
    "text": "basically what happens is you in in rusts case we make this generator and it",
    "start": "1399840",
    "end": "1405060"
  },
  {
    "text": "looks like a closure so you have the two pipes this generator takes no arguments and in this case we're taking a vector",
    "start": "1405060",
    "end": "1411750"
  },
  {
    "text": "of numbers 1 2 & 3 and we're summing them up but we're returning the intermediate results each time so you",
    "start": "1411750",
    "end": "1417060"
  },
  {
    "text": "can see there's this for loop where we add the current value on to you know the sum and then we yield some and so what",
    "start": "1417060",
    "end": "1423810"
  },
  {
    "text": "happens is when you when you invoke Jen for the first time it will basically run up to the yield and then return that",
    "start": "1423810",
    "end": "1429690"
  },
  {
    "text": "first value and you get the value back and then you can call you can invoke the generator again and it will continue",
    "start": "1429690",
    "end": "1435960"
  },
  {
    "text": "processing execution and then run through the second iteration and then return the second value and then again",
    "start": "1435960",
    "end": "1441300"
  },
  {
    "text": "and again and again that's why it's called like a generator it's because you're generating these sequences of",
    "start": "1441300",
    "end": "1446480"
  },
  {
    "text": "values and fun domestic Lozier but you put yield in there this is a feature",
    "start": "1446480",
    "end": "1452310"
  },
  {
    "text": "that's in a lot of languages with a lot of names I used rubies so this kind of made intuitive sense to me even though we",
    "start": "1452310",
    "end": "1458130"
  },
  {
    "text": "never called them generators but yeah here's a slightly more complicated",
    "start": "1458130",
    "end": "1463260"
  },
  {
    "text": "generator that basically does the exact same thing we're going to be first adding up all the numbers and then",
    "start": "1463260",
    "end": "1470220"
  },
  {
    "text": "secondly subtracting all the numbers by going back down and the reason that I wanted to use this slightly more interesting generator is I",
    "start": "1470220",
    "end": "1476370"
  },
  {
    "text": "want to show you how rust actually compiles this generator into efficient code behind the scenes and we needed",
    "start": "1476370",
    "end": "1482130"
  },
  {
    "text": "something a little more complicated than just one yield so we kind of have if you would think about how you would try to",
    "start": "1482130",
    "end": "1487560"
  },
  {
    "text": "implement a feature like generators fundamentally you need to save the intermediate state that happens between",
    "start": "1487560",
    "end": "1492690"
  },
  {
    "text": "producing each value so what happens here is on line four we have an iterator",
    "start": "1492690",
    "end": "1498390"
  },
  {
    "text": "iterators have internal state so we mark this with this comment it or zero so we're gonna need to save up to the first",
    "start": "1498390",
    "end": "1504060"
  },
  {
    "text": "yield we're getting to save the value of this particular iterator and then on line six where we yield that sum we also",
    "start": "1504060",
    "end": "1510570"
  },
  {
    "text": "are going to be giving this value back and that's going to be like sort of the starting value for the next iteration of the computation so we're going to need",
    "start": "1510570",
    "end": "1516960"
  },
  {
    "text": "to save both the state of the iterator and the value that we yielded in the sort of first step through the generator",
    "start": "1516960",
    "end": "1522870"
  },
  {
    "text": "and then likewise lines eight and ten when we reverse through the iterator we're gonna need to save that at every",
    "start": "1522870",
    "end": "1529200"
  },
  {
    "text": "single step and we're gonna need to save the sum the second time so we kind of have these like two big sections of",
    "start": "1529200",
    "end": "1534750"
  },
  {
    "text": "yield with two little bits of state in between them and so the way that rust builds this you can actually think about",
    "start": "1534750",
    "end": "1541260"
  },
  {
    "text": "it in rust code so there's sort of these like four stages as we pass through this state first of all there's the like",
    "start": "1541260",
    "end": "1548060"
  },
  {
    "text": "generator that we've never called like - we've never actually asked to execute",
    "start": "1548060",
    "end": "1553170"
  },
  {
    "text": "and that holds this state of a list of 32-bit integers and then after we call",
    "start": "1553170",
    "end": "1558240"
  },
  {
    "text": "it for the first time we move from this unredeemed state into this suspend state and so now we still have our list of",
    "start": "1558240",
    "end": "1564360"
  },
  {
    "text": "vectors our vector of integers but we also have that iterator and we have the intermediate sum and then after we like",
    "start": "1564360",
    "end": "1570330"
  },
  {
    "text": "totally exhaust that we move into the suspend one state and that means we have similarly we need the the list as exists",
    "start": "1570330",
    "end": "1576330"
  },
  {
    "text": "and then innovator that's going backwards now and the current sum state and then finally once this computation is done there's this return state here",
    "start": "1576330",
    "end": "1583170"
  },
  {
    "text": "and so there's this really deep like there could be a totally different talk on this computer science e-track about",
    "start": "1583170",
    "end": "1590370"
  },
  {
    "text": "how like co-routines and generators if you squint ooh this like it looks like a state machine right like we're",
    "start": "1590370",
    "end": "1595950"
  },
  {
    "text": "progressing through these states and there's a really beautiful underlying unified theory of computation that puts all these things together in a wonderful",
    "start": "1595950",
    "end": "1602040"
  },
  {
    "text": "way I don't have time to explain but basically like generators are kind of this a convenient way to write a state",
    "start": "1602040",
    "end": "1607919"
  },
  {
    "text": "machine and this is kind of what the state machine would look like d sugared and what this means is that the",
    "start": "1607919",
    "end": "1613409"
  },
  {
    "text": "generator has sort of like a maximum because there's an enum of likes trucks the generator has sort of a maximum size",
    "start": "1613409",
    "end": "1619080"
  },
  {
    "text": "and memory of the biggest chunk of state that you need to save at any given point of the computation but we can reuse that",
    "start": "1619080",
    "end": "1625139"
  },
  {
    "text": "space for the smaller ones and so you have this really compact nice and tiny",
    "start": "1625139",
    "end": "1630409"
  },
  {
    "text": "representation of the value which is really efficient and that will become important later so anyway that's a quick",
    "start": "1630409",
    "end": "1637409"
  },
  {
    "text": "whirlwind summary of generators and kind of like what the code they generate looks like but the way this interacts",
    "start": "1637409",
    "end": "1644279"
  },
  {
    "text": "with future is in a single weight excuse me futures need to have a pole method",
    "start": "1644279",
    "end": "1651149"
  },
  {
    "text": "that's called over and over again until some sort of value is produced",
    "start": "1651149",
    "end": "1656239"
  },
  {
    "text": "generators let you call like invoke them and then they yield a value over and",
    "start": "1656239",
    "end": "1661919"
  },
  {
    "text": "over to get this sequence of values so there's sort of this interesting symmetry here and that's why a single",
    "start": "1661919",
    "end": "1667739"
  },
  {
    "text": "weight is implemented internally as a generator that implements the future trait so basically a single weight is a",
    "start": "1667739",
    "end": "1674279"
  },
  {
    "text": "simpler syntax for not just futures but more specifically a generator of the implements future and so that's like you",
    "start": "1674279",
    "end": "1680009"
  },
  {
    "text": "can think like these state transitions come from the values that are returned by the calls to pole and everything sort",
    "start": "1680009",
    "end": "1685859"
  },
  {
    "text": "of fits all nice together and that means that we can take your entire chain of async/await computation compile it down",
    "start": "1685859",
    "end": "1691259"
  },
  {
    "text": "into one single state machine represents that whole entire chain of computation put in a very compact representation and",
    "start": "1691259",
    "end": "1697559"
  },
  {
    "text": "know at compile time basically like exactly the size that that computation",
    "start": "1697559",
    "end": "1702599"
  },
  {
    "text": "will take so we call these stack Lascaux routines because they don't allocate their own stack but you can kind of",
    "start": "1702599",
    "end": "1708059"
  },
  {
    "text": "almost think about like stack Lascaux routines is like perfectly sized stack co-routines like we don't need to allocate every",
    "start": "1708059",
    "end": "1714720"
  },
  {
    "text": "single like iteration through like I said what happens in JavaScript we can instead get like the exact size that's",
    "start": "1714720",
    "end": "1720899"
  },
  {
    "text": "needed for the whole computation all at once at compile time and be perfect and this is one of the exhausts",
    "start": "1720899",
    "end": "1726989"
  },
  {
    "text": "implementation is a little novel and also why it's super super highly efficient because like you can't",
    "start": "1726989",
    "end": "1732059"
  },
  {
    "text": "actually hand code it better yourself now there's definitely some optimizations that we're missing when it comes to compacting the generator state",
    "start": "1732059",
    "end": "1738269"
  },
  {
    "text": "and so there still is better work to be done I also want to set some like you know expectations there but like in a",
    "start": "1738269",
    "end": "1743970"
  },
  {
    "text": "theoretical sense we're basically doing as much processing a compile time as you possibly can to make this as zero",
    "start": "1743970",
    "end": "1749340"
  },
  {
    "text": "overhead as possible and that's really cool all right so next up we know how we",
    "start": "1749340",
    "end": "1757200"
  },
  {
    "text": "use futures how we implement futures ourselves and we know how we can use a single wait to work with futures but as",
    "start": "1757200",
    "end": "1763800"
  },
  {
    "text": "I said in order for a future to execute if put it on an executor and so now we're gonna talk about the last sort of",
    "start": "1763800",
    "end": "1769800"
  },
  {
    "text": "remaining part of the system and also another part that's interesting due to some other splits and that's the tasks",
    "start": "1769800",
    "end": "1775980"
  },
  {
    "text": "executors and reactor's chunk of this story so generators and futures and a single wait are all in the rest language",
    "start": "1775980",
    "end": "1782460"
  },
  {
    "text": "but as I mentioned before Russ doesn't have like a built-in executor and that's",
    "start": "1782460",
    "end": "1788280"
  },
  {
    "text": "because rust is used in many different contexts and we need to give people choice and there are some people that don't even need asynchronous computation",
    "start": "1788280",
    "end": "1793920"
  },
  {
    "text": "and we don't have to have them have to pay for this stuff if they don't need it and so the way this kind of works is",
    "start": "1793920",
    "end": "1799920"
  },
  {
    "text": "that the future trait is in the standard library and a single wait and generate it will the future trade and generators",
    "start": "1799920",
    "end": "1806220"
  },
  {
    "text": "are in the standard library a single wait is in the language but all the ways that you actually execute that is left",
    "start": "1806220",
    "end": "1811890"
  },
  {
    "text": "to the library ecosystem so I showed you Tokyo before there's a number of other projects that are providing different",
    "start": "1811890",
    "end": "1818430"
  },
  {
    "text": "kind of executives and reactors that do different things for different areas and some of them are competing to be the",
    "start": "1818430",
    "end": "1824160"
  },
  {
    "text": "best one for web apps and some of them are doing embedded like all these other things so what I'm about to show you in",
    "start": "1824160",
    "end": "1829230"
  },
  {
    "text": "this section is an implementation of a simple executor but again like the folks",
    "start": "1829230",
    "end": "1834330"
  },
  {
    "text": "who are building the real libraries that use in production do a lot of tricks to make this much much faster so I'm trying",
    "start": "1834330",
    "end": "1840420"
  },
  {
    "text": "to emphasize for like learnability not for ultimate speed but that's the nice thing is that you can kind of build one",
    "start": "1840420",
    "end": "1845850"
  },
  {
    "text": "of these things yourself and use it in your toy program and then rip it out and replace it with a production ready one and now all your stuff just goes faster",
    "start": "1845850",
    "end": "1851870"
  },
  {
    "text": "interfaces are awesome so node has this",
    "start": "1851870",
    "end": "1857280"
  },
  {
    "text": "thing called the event loop and I bring up node in this talk a number of times because node was probably the primary inspiration for how we did all this",
    "start": "1857280",
    "end": "1863490"
  },
  {
    "text": "stuff a lot of people in the rest world where JavaScript programmers before a node kind of like made this sort of style of",
    "start": "1863490",
    "end": "1869850"
  },
  {
    "text": "programming kind of like cool even if it didn't like you know pioneer it ultimately and so you know I tend to compare",
    "start": "1869850",
    "end": "1877020"
  },
  {
    "text": "against node because that tends to be what people know in this space but node programmers will talk about the event loop and that's sort of this thing that",
    "start": "1877020",
    "end": "1883290"
  },
  {
    "text": "makes your asynchronous computation happen and you know whether or not you're like just a regular you know",
    "start": "1883290",
    "end": "1889620"
  },
  {
    "text": "person writing node code you don't want to think about how the event loop block works and all you know is like don't",
    "start": "1889620",
    "end": "1894690"
  },
  {
    "text": "block the event loop is like a meme and you try not to do that or if you're someone that's like on the node TSC and you're contributor to libuv",
    "start": "1894690",
    "end": "1901919"
  },
  {
    "text": "and you like know about all the guts like they talk about it in one sort of like unified way well in rusts because",
    "start": "1901919",
    "end": "1909600"
  },
  {
    "text": "we don't have one guaranteed thing that went with the language we actually broke it into sort of three different concepts",
    "start": "1909600",
    "end": "1915270"
  },
  {
    "text": "and we're gonna use a fourth minor one later but when we talk about asynchronous sort of work there's this",
    "start": "1915270",
    "end": "1921510"
  },
  {
    "text": "idea of a task and so in the case of Rustin async await a task specifically",
    "start": "1921510",
    "end": "1926940"
  },
  {
    "text": "represents some sort of chain of futures that you've made a new computation and you're like I want to actually execute",
    "start": "1926940",
    "end": "1932040"
  },
  {
    "text": "this thing now so you hand a task off to an executor to be scheduled and run and",
    "start": "1932040",
    "end": "1937950"
  },
  {
    "text": "so the executor is basically just like a scheduling algorithm and it takes a list",
    "start": "1937950",
    "end": "1943530"
  },
  {
    "text": "of futures that nose needs to run and it figures out how to run them because there's all sorts of different",
    "start": "1943530",
    "end": "1948630"
  },
  {
    "text": "strategies you can use we're gonna use a very simple one that's based on a first in first out queue there are other",
    "start": "1948630",
    "end": "1956070"
  },
  {
    "text": "people that do like multi-threaded work stealing executives and like all these other kind of things so there's a lot of",
    "start": "1956070",
    "end": "1961620"
  },
  {
    "text": "space to explore with how to schedule work that are good for different workloads and then finally there's this",
    "start": "1961620",
    "end": "1967169"
  },
  {
    "text": "concept called the reactor and this would be what like libuv is and node world basically it's the thing that",
    "start": "1967169",
    "end": "1973049"
  },
  {
    "text": "notifies the executor which tasks are actually ready to continue executing and",
    "start": "1973049",
    "end": "1978990"
  },
  {
    "text": "so this often is tied with a specific operating system UI and we sort of split these things apart conceptually even",
    "start": "1978990",
    "end": "1985980"
  },
  {
    "text": "though a lot of projects provide both so for example Tokyo gives you both an executor and a reactor but in theory you",
    "start": "1985980",
    "end": "1991470"
  },
  {
    "text": "could actually like pair Tokyo's reactor with a totally different executor if you didn't like their executive decisions",
    "start": "1991470",
    "end": "1997169"
  },
  {
    "text": "yeah but uh they're they're like separate things whereas all this is kind",
    "start": "1997169",
    "end": "2002240"
  },
  {
    "text": "of bundled up into one thing in many other systems and that gives us flexibility but that also means",
    "start": "2002240",
    "end": "2008059"
  },
  {
    "text": "intense type system stuff so we sort of ignored these call the some of the",
    "start": "2008059",
    "end": "2015349"
  },
  {
    "text": "details about to call a poll earlier but if you read the type signature you can kind of see how this works with the",
    "start": "2015349",
    "end": "2021049"
  },
  {
    "text": "executor and reactor so if we take a future and like tasks implement future which is when you pass a task to an",
    "start": "2021049",
    "end": "2026629"
  },
  {
    "text": "executor the executor job is to do that repeated call of poll so it's going to be calling poll to make sure that your",
    "start": "2026629",
    "end": "2032899"
  },
  {
    "text": "features are doing the work they're supposed to do and it gives this sort of context argument to futures what this",
    "start": "2032899",
    "end": "2040339"
  },
  {
    "text": "context argument actually is was the source of a lot of the situation of",
    "start": "2040339",
    "end": "2045619"
  },
  {
    "text": "developing the future trait but what it currently contains at the moment is basically that interface into the",
    "start": "2045619",
    "end": "2051230"
  },
  {
    "text": "reactor so that Waker concept I referenced preferred before that's like put the executor is like",
    "start": "2051230",
    "end": "2057108"
  },
  {
    "text": "okay you're using this particular reactor I bundle up in this context and I pass it along to the futures and so",
    "start": "2057109",
    "end": "2062750"
  },
  {
    "text": "that's how the future is able to inter interact with the reactors through that Waker interface and that's part of this",
    "start": "2062750",
    "end": "2068179"
  },
  {
    "text": "like context chunk of stuff there's like four levels of indirection here so it",
    "start": "2068179",
    "end": "2073460"
  },
  {
    "text": "takes a little while to get synched into this honestly one of the reasons I wanted to do this talk was to force myself to walk through all these details",
    "start": "2073460",
    "end": "2079128"
  },
  {
    "text": "and make sure that I got it because I knew it at a high level before but I wanted to do a bunch of the research so yeah so like an executor calls poll it",
    "start": "2079129",
    "end": "2085908"
  },
  {
    "text": "gives you a context and a context contains a Waker and that Waker is how the reactor talks to a future so let's",
    "start": "2085909",
    "end": "2095059"
  },
  {
    "text": "actually build an executor together I'm gonna show you a very simple executor again is super inefficient but uh but",
    "start": "2095059",
    "end": "2101660"
  },
  {
    "text": "like actually works before we get into the code though we're gonna do a good old-fashioned flowchart of all these",
    "start": "2101660",
    "end": "2107450"
  },
  {
    "text": "bits and pieces because like I said there's a lot of moving bits around here so if we have an async function foo that",
    "start": "2107450",
    "end": "2114230"
  },
  {
    "text": "we want to turn into a task somehow we are gonna call this interface called spawner and spawn foo if you notice",
    "start": "2114230",
    "end": "2121220"
  },
  {
    "text": "there was that API in Tokyo and the first thing that had Tokyo spawn that lets you like spin up a new task so",
    "start": "2121220",
    "end": "2126470"
  },
  {
    "text": "tasks can also like produce new tasks and sometimes there's a nickname spawners you don't have to make them a",
    "start": "2126470",
    "end": "2131690"
  },
  {
    "text": "whole separate thing but we're about to do that in our particular implementation so we we sort of hand foo off to this",
    "start": "2131690",
    "end": "2137660"
  },
  {
    "text": "interface that says please make a task out of the results of foo and from there that is going to send it",
    "start": "2137660",
    "end": "2144620"
  },
  {
    "text": "to the executor and in our case we're gonna have a queue of tasks so we're gonna put things into this queue the",
    "start": "2144620",
    "end": "2149960"
  },
  {
    "text": "executor is going to go through the queue and execute each task in turn so it's gonna hold on to that state when",
    "start": "2149960",
    "end": "2156230"
  },
  {
    "text": "the executor calls pull on a future that happens to be in its queue that's that's",
    "start": "2156230",
    "end": "2162200"
  },
  {
    "text": "what its gonna do to execute a future call pull and see what happens and that future will return either ready and then",
    "start": "2162200",
    "end": "2168470"
  },
  {
    "text": "it'll be done and the executor will remove it from the queue or it'll say that hey I'm not ready yet and the",
    "start": "2168470",
    "end": "2173750"
  },
  {
    "text": "executor will say ok and it won't keep that in the list of things it needs to pull and it's basically they say I'm not gonna call pull again until I'm told",
    "start": "2173750",
    "end": "2180410"
  },
  {
    "text": "that you're ready to continue executing this is where the Waker bit comes in and so at some point whenever the future is",
    "start": "2180410",
    "end": "2187820"
  },
  {
    "text": "ready it's going to call wake in the background if you think back to our timer future this happened in that",
    "start": "2187820",
    "end": "2193790"
  },
  {
    "text": "background thread so that's why this keeps happening like you may wonder like if the executor never calls pol again how am I supposed to even run the code",
    "start": "2193790",
    "end": "2200450"
  },
  {
    "text": "for the Waker well it depends on what you're doing in our timer example it was that background thread if you were",
    "start": "2200450",
    "end": "2205880"
  },
  {
    "text": "building a full-blown reactor it would maybe be like 'hey pol has you've handed off a call back to e pol that's gonna",
    "start": "2205880",
    "end": "2212840"
  },
  {
    "text": "like invoke the Waker when it happens but in some sort of way the the future",
    "start": "2212840",
    "end": "2218300"
  },
  {
    "text": "is gonna be told hey i'm ready to proceed and it's gonna wake up and that's going to cause the future to be",
    "start": "2218300",
    "end": "2223640"
  },
  {
    "text": "reput on to the ready queue of the executor to be executed again this is kind of the basic control flow of how",
    "start": "2223640",
    "end": "2230000"
  },
  {
    "text": "the system works so let's actually put one of these things together so as I mentioned we",
    "start": "2230000",
    "end": "2237290"
  },
  {
    "text": "have our executor and has a ready queue and this is going to have basically",
    "start": "2237290",
    "end": "2242630"
  },
  {
    "text": "there's going to be a channel that's what the receiver part is is we're gonna be sending things to the executor over",
    "start": "2242630",
    "end": "2249530"
  },
  {
    "text": "this channel and we're gonna treat our channel like a queue because you can do that so what people put stuff on the channel like a channel maintains an",
    "start": "2249530",
    "end": "2255800"
  },
  {
    "text": "internal queue and we pop things off so we're basically just gonna like keep listening to a channel to implement this",
    "start": "2255800",
    "end": "2261170"
  },
  {
    "text": "particular queue and it's going to get a reference counted task a task contains",
    "start": "2261170",
    "end": "2266810"
  },
  {
    "text": "the future and this has a frankly kind of bonkers type signature a mutex option",
    "start": "2266810",
    "end": "2273260"
  },
  {
    "text": "box future of attic and then no output box future is itself a type alias this could actually",
    "start": "2273260",
    "end": "2279300"
  },
  {
    "text": "go two or three more nested types you know types are happen at compile time not run times the more types you put",
    "start": "2279300",
    "end": "2285240"
  },
  {
    "text": "together the more compile time stuff happens and the faster everything is right isn't that totally true but the",
    "start": "2285240",
    "end": "2290340"
  },
  {
    "text": "point is is that we need this to be thread safe and actually we don't even need the mutex here because we're not building a multi-threaded executor but",
    "start": "2290340",
    "end": "2295890"
  },
  {
    "text": "rust sort of forces you to make your code thread safe to begin with if we were making a single threaded executor we could eliminate the mutex with an",
    "start": "2295890",
    "end": "2302070"
  },
  {
    "text": "unsafe code but I'm trying to make this simple not complicated so it's it's some overhead that we wouldn't actually need",
    "start": "2302070",
    "end": "2307290"
  },
  {
    "text": "in production don't worry your futures are not all wrapped in mutexes and as you know boxes and stuff and then",
    "start": "2307290",
    "end": "2313170"
  },
  {
    "text": "finally a task is also going to have the other end of that channel so when a task",
    "start": "2313170",
    "end": "2318360"
  },
  {
    "text": "needs to reschedule itself it's basically gonna like send itself down this channel so it needs a reference to it so it knows where to send it so",
    "start": "2318360",
    "end": "2324420"
  },
  {
    "text": "that's the other component of our tasks and executors then to make it a little",
    "start": "2324420",
    "end": "2330180"
  },
  {
    "text": "easier to spawn tasks on the executor we're gonna split out the spawner type you don't have to do it this way but it",
    "start": "2330180",
    "end": "2335220"
  },
  {
    "text": "can be kind of easier to send the spawner around rather than moving the executor everywhere and it holds the other end of this",
    "start": "2335220",
    "end": "2341940"
  },
  {
    "text": "channel that is in the executor so the sender sends stuff down the channel the executor pull stuff off the channel and",
    "start": "2341940",
    "end": "2347790"
  },
  {
    "text": "then actually runs runs the the futures and we made this little helper function",
    "start": "2347790",
    "end": "2353100"
  },
  {
    "text": "called new executor and spawner that spins up an executor and spawner that know how to talk to each other and",
    "start": "2353100",
    "end": "2358440"
  },
  {
    "text": "in this case because we're using this particular kind of channel we're gonna give it 10,000 tasks maximum because",
    "start": "2358440",
    "end": "2363840"
  },
  {
    "text": "this is a toy again most real ones will give you a cue that is like unbounded if you want that kind of behavior and like",
    "start": "2363840",
    "end": "2369270"
  },
  {
    "text": "all this sort of different stuff so yeah so this is all we'll get our executor and spawner spawner is relatively",
    "start": "2369270",
    "end": "2376950"
  },
  {
    "text": "straightforward what we need to do is we need to take our future which is the task we're gonna create we box it up and",
    "start": "2376950",
    "end": "2382770"
  },
  {
    "text": "then we put it inside that arc and we give it that reference to the particular you know channel that we're sending",
    "start": "2382770",
    "end": "2389190"
  },
  {
    "text": "stuff down and then we basically send it down the channel as like hey this is ready to execute pretty relatively",
    "start": "2389190",
    "end": "2395670"
  },
  {
    "text": "straightforward and then finally we implement this the wake method on our",
    "start": "2395670",
    "end": "2400770"
  },
  {
    "text": "tasks so in this case this would be like where you would put more complicated logic if you were doing something",
    "start": "2400770",
    "end": "2406380"
  },
  {
    "text": "interacted with the operating system but here what happens is whenever we whenever a future calls wake what we're",
    "start": "2406380",
    "end": "2412769"
  },
  {
    "text": "gonna do is send it back down to that channel to be executed immediately so we kind of created a very simple system by which like any time you call wake we're",
    "start": "2412769",
    "end": "2420059"
  },
  {
    "text": "not gonna sleep anymore we're gonna immediately riku you to be executed and",
    "start": "2420059",
    "end": "2426660"
  },
  {
    "text": "then finally here's the guts of the executor itself this is the last big chunk a slide Co big chunk of code slide",
    "start": "2426660",
    "end": "2433700"
  },
  {
    "text": "but an executor fundamentally is a while loop so we have a while loop and we",
    "start": "2433700",
    "end": "2439619"
  },
  {
    "text": "receive stuff off of our queue there on line three and when we get something off of the end of the queue we have that",
    "start": "2439619",
    "end": "2446460"
  },
  {
    "text": "task and then we use the mutex to grab access to it and we take the future out",
    "start": "2446460",
    "end": "2454289"
  },
  {
    "text": "of this particular slot in the task because we want to see like if this feature still needs to be executed or not so when the future is done will no",
    "start": "2454289",
    "end": "2461700"
  },
  {
    "text": "longer have the future anymore so we have to double check if it's finished or not and so that's what line 8 does is",
    "start": "2461700",
    "end": "2467309"
  },
  {
    "text": "like check to make sure hey does the future still exist if it does we want to rip it out of the task lines 10 and 11",
    "start": "2467309",
    "end": "2473759"
  },
  {
    "text": "set up that Waker so we're taking the particular Waker that we implemented and",
    "start": "2473759",
    "end": "2480119"
  },
  {
    "text": "we're turning it into a context because that's what needs to be passed to a particular future and then finally line 13 is where we",
    "start": "2480119",
    "end": "2487200"
  },
  {
    "text": "call poll we pass in that context and we see what happens if it's a pending then",
    "start": "2487200",
    "end": "2492779"
  },
  {
    "text": "we're still processing the future so we need to put that feature back in the task since we ripped it out before so so",
    "start": "2492779",
    "end": "2498720"
  },
  {
    "text": "we re put that back in and we're good to go if the future is done executing we",
    "start": "2498720",
    "end": "2503910"
  },
  {
    "text": "don't need to put anything back in and we're just finished and that's really it like this is just ultimately the guts as",
    "start": "2503910",
    "end": "2509910"
  },
  {
    "text": "I said at the executor you loop over the queue you run the futures you check what they're doing and and that's it so this",
    "start": "2509910",
    "end": "2516569"
  },
  {
    "text": "is like a relatively small number of lines of code but it would let us actually implement our own async/await",
    "start": "2516569",
    "end": "2521849"
  },
  {
    "text": "stuff so here's an example of using this executor we just defined so we call a new executor and spawner to get a new",
    "start": "2521849",
    "end": "2527519"
  },
  {
    "text": "executor and a new spawner we call spawn or spawn and in this case we're gonna use that async block to just print a",
    "start": "2527519",
    "end": "2533249"
  },
  {
    "text": "message sleep for two seconds and then print another message and then finally on line 15 we're going to drop the",
    "start": "2533249",
    "end": "2540450"
  },
  {
    "text": "spawner and the reason why is to tell executor we're done our executor implementation will like wait until the",
    "start": "2540450",
    "end": "2545700"
  },
  {
    "text": "channel closes so it'll always sit there so if we don't actually like tell the spawner we're done spawning tasks it",
    "start": "2545700",
    "end": "2552000"
  },
  {
    "text": "would just sit there waiting for tasks forever and our program would like hang and then finally we call run on the",
    "start": "2552000",
    "end": "2557040"
  },
  {
    "text": "executor and it will take that task that we added and do its magic and run it so",
    "start": "2557040",
    "end": "2562380"
  },
  {
    "text": "this is kind of like the minimal code example of how to put all these bits together and kind of shows you how the",
    "start": "2562380",
    "end": "2567420"
  },
  {
    "text": "control flow works through the system and the way that all these different parts work together okay we didn't talk",
    "start": "2567420",
    "end": "2574260"
  },
  {
    "text": "about pin pin was part of the function signature of of the future if you notice",
    "start": "2574260",
    "end": "2579660"
  },
  {
    "text": "that said pin self and we didn't talk about it pin deserves its own whole talk it's kind of really interesting and",
    "start": "2579660",
    "end": "2584790"
  },
  {
    "text": "complicated but basically the idea is before a future starts exact executive we need to move it around in memory so",
    "start": "2584790",
    "end": "2591930"
  },
  {
    "text": "for example to create a task out of a future we often put it on the heap so we need to move it from the stack to the heap which involves moving it in memory",
    "start": "2591930",
    "end": "2598440"
  },
  {
    "text": "the problem is Rusted the system's language doesn't have a garbage collector so we have pointers so if you move something where there's pointers",
    "start": "2598440",
    "end": "2604320"
  },
  {
    "text": "that exist to the thing you're gonna invalidate those pointers and everything's gonna blow up so that's not great but the problem is once a future",
    "start": "2604320",
    "end": "2610800"
  },
  {
    "text": "starts exactly starts actually executing it can't move in memory for like similar",
    "start": "2610800",
    "end": "2615869"
  },
  {
    "text": "reasons so like before it moves we need to be able to before it executes suis need to move it but after it starts",
    "start": "2615869",
    "end": "2620910"
  },
  {
    "text": "moving it can't move at all because again if it moved it would cause all these references to be invalidated and the rustboro checker really doesn't like",
    "start": "2620910",
    "end": "2627690"
  },
  {
    "text": "like sometimes you can move stuff and sometimes you can't and so somebody had",
    "start": "2627690",
    "end": "2633119"
  },
  {
    "text": "without boats specifically came up with this idea of the pin type and what pin basically says is hey once you construct",
    "start": "2633119",
    "end": "2639720"
  },
  {
    "text": "a pin out of a pointer it will no longer move forever and so this lets us have stuff that's like not pinned at first",
    "start": "2639720",
    "end": "2645869"
  },
  {
    "text": "and then part of the job of the creating a task is to actually like pin that",
    "start": "2645869",
    "end": "2651150"
  },
  {
    "text": "future into memory to say hey this is gonna live here forever so you're free to start executing yourself there's also",
    "start": "2651150",
    "end": "2656970"
  },
  {
    "text": "a type called unpin that basically says like I am NOT a pointer I don't care about being copied around this is very",
    "start": "2656970",
    "end": "2662250"
  },
  {
    "text": "similar to how copy says that they don't care about move semantics and the rest of rust so that's",
    "start": "2662250",
    "end": "2667470"
  },
  {
    "text": "really all I would say about pin today pain is something you'll virtually never use unless you're building a specific low-level future by hand and so it's",
    "start": "2667470",
    "end": "2674339"
  },
  {
    "text": "kind of complicated but you just don't have to think about it basically ever as user but the people who write your",
    "start": "2674339",
    "end": "2679529"
  },
  {
    "text": "libraries do so I don't want to leave that out okay finally we have six minutes let's build a reactor just",
    "start": "2679529",
    "end": "2686910"
  },
  {
    "text": "kidding we're not actually gonna build a reactor just kidding we technically did build a reactor so our reactor was very dumb and",
    "start": "2686910",
    "end": "2694890"
  },
  {
    "text": "all it did was immediately be like yes you're gonna start executing again but this part of implementing the wake trait",
    "start": "2694890",
    "end": "2701160"
  },
  {
    "text": "is where a reactor would fit into this hierarchy of stuff if you didn't want to say sleep you wanted to wait on e-poll",
    "start": "2701160",
    "end": "2707520"
  },
  {
    "text": "or do whatever that's what sort of where this wake machinery comes in and that's the part of building reactors so we did",
    "start": "2707520",
    "end": "2713190"
  },
  {
    "text": "technically write a one line like no op reactor but I'm not gonna be able to get into a complicated one because frankly",
    "start": "2713190",
    "end": "2718859"
  },
  {
    "text": "I've shown you far too much costs giant code blocks in its presentation anyway there's no other really way to do it",
    "start": "2718859",
    "end": "2725250"
  },
  {
    "text": "without getting into details but uh you know this could be its own whole thing right this is basically like how to implement libuv talk or we actually",
    "start": "2725250",
    "end": "2732869"
  },
  {
    "text": "don't use libuv ourselves we use a library called well Tokyo use a library called mio which stands for metal i/o",
    "start": "2732869",
    "end": "2739140"
  },
  {
    "text": "which is kind of like a Liberty competitor bla bla the point is there's a lot of rich interesting problems here",
    "start": "2739140",
    "end": "2744240"
  },
  {
    "text": "and I will never do it justice so we're just gonna leave it at that for this talk I have five more minutes",
    "start": "2744240",
    "end": "2750420"
  },
  {
    "text": "and so I'm gonna go over this the bonus round because I do have time because I think it's really interesting and I talk",
    "start": "2750420",
    "end": "2755880"
  },
  {
    "text": "about some of the future extensions to async/await and how you may hear people talk about type theory questions you may",
    "start": "2755880",
    "end": "2761849"
  },
  {
    "text": "wonder how it's like relevant to you as a programmer and this is the easiest way that I can explain it so async functions",
    "start": "2761849",
    "end": "2768450"
  },
  {
    "text": "and traits right now as of last week you can write async functions in rust but if",
    "start": "2768450",
    "end": "2774930"
  },
  {
    "text": "you want to write a trait with an async function you can't and that feels really weird and awkward at first because",
    "start": "2774930",
    "end": "2780630"
  },
  {
    "text": "you're like what's the big difference between a function and interface as opposed to a function outside of interface well the core of it comes down",
    "start": "2780630",
    "end": "2787740"
  },
  {
    "text": "to a function is just one single function it's not a big deal but a trait is implemented on many types and so ends",
    "start": "2787740",
    "end": "2794430"
  },
  {
    "text": "up being many functions and as we know when you go from one of a thing to as many things as you'd like",
    "start": "2794430",
    "end": "2799890"
  },
  {
    "text": "that's where complexity always creeps in and so this is where the type system complexity ends up being a thing we",
    "start": "2799890",
    "end": "2807000"
  },
  {
    "text": "haven't built the type system machinery to handle this situation yet and you may ask like why",
    "start": "2807000",
    "end": "2812010"
  },
  {
    "text": "does that matter well if we think about what like here's a trait called food that has an async function called foo",
    "start": "2812010",
    "end": "2818010"
  },
  {
    "text": "that returns a 32-bit value if you wanted to think about how this would like D sugar and the same way that we",
    "start": "2818010",
    "end": "2824160"
  },
  {
    "text": "talked about how async functions D sugar and is something that returns an implementation of a future it would look",
    "start": "2824160",
    "end": "2829170"
  },
  {
    "text": "like this so we have an Associated type that would be a future of some kind and you know it",
    "start": "2829170",
    "end": "2835620"
  },
  {
    "text": "would return that associated type so this would kind of be syntax sugar for that this is fine and you can actually do this today but the problem is is that",
    "start": "2835620",
    "end": "2842640"
  },
  {
    "text": "there's only would work for extremely simple things and it gets way more complicated and the reason is lifetimes",
    "start": "2842640",
    "end": "2848280"
  },
  {
    "text": "always in rust lifetimes end up complicating everything which is like why the language exists but also is like",
    "start": "2848280",
    "end": "2854250"
  },
  {
    "text": "lifetimes so if we think about a more interesting trait so say we have a",
    "start": "2854250",
    "end": "2859380"
  },
  {
    "text": "database trait that will fetch users we're building an ORM I want to get a user out you'll notice that we're borrowing self here so that borrow means",
    "start": "2859380",
    "end": "2867840"
  },
  {
    "text": "there's a lifetime and so that means that unlike our very simple example where an async function D sugars into",
    "start": "2867840",
    "end": "2873900"
  },
  {
    "text": "just return imple future we also need to add the lifetime in here so it's actually like an Impala that refers to",
    "start": "2873900",
    "end": "2879750"
  },
  {
    "text": "the lifetime of self that's where the root of all these problems come in because the problem is if you would de",
    "start": "2879750",
    "end": "2885330"
  },
  {
    "text": "sugar that into the general trait like as I talked about before now we have a type that's parameterised by a lifetime",
    "start": "2885330",
    "end": "2891570"
  },
  {
    "text": "that implements a future parameters by a lifetime and there's no way currently to",
    "start": "2891570",
    "end": "2896970"
  },
  {
    "text": "parameterize an associated type and you may have heard people refer to associated type constructors in rust or",
    "start": "2896970",
    "end": "2903240"
  },
  {
    "text": "maybe generic associated types this is basically the thing that you're talking about you can't make line too generic",
    "start": "2903240",
    "end": "2908820"
  },
  {
    "text": "and today's rust but due to lifetimes if you would write any useful trait that would be asynchronous it needs to know",
    "start": "2908820",
    "end": "2914820"
  },
  {
    "text": "what the lifetime is and so it needs that feature so it doesn't exist yet this is the core reason of why async function doesn't work in traits we need",
    "start": "2914820",
    "end": "2921060"
  },
  {
    "text": "more type theory shenanigans and other people are smarter than me are gonna go do all that and I'm just gonna write async function in a trait and be like",
    "start": "2921060",
    "end": "2927360"
  },
  {
    "text": "huh it works because it actually gets even way way more complicated than that but I'm not gonna get into that stuff",
    "start": "2927360",
    "end": "2933360"
  },
  {
    "text": "what I'm gonna tell you is if you want to use async functions and traits today you can use this package called async trait and it implements it for you it",
    "start": "2933360",
    "end": "2941610"
  },
  {
    "text": "implements it for you like how is it not language but a library can implement it basically what happens is you add this",
    "start": "2941610",
    "end": "2947100"
  },
  {
    "text": "async trait thing on to your your on to your trait and instead of D sugaring it into that thing with the associated type",
    "start": "2947100",
    "end": "2953370"
  },
  {
    "text": "it gives you a box so it's gonna box every single invocation so the downside you pay for using this library as your",
    "start": "2953370",
    "end": "2959610"
  },
  {
    "text": "futures are a little less efficient because you're allocating every single future but the advantage is you get to have traits that have asynchronous",
    "start": "2959610",
    "end": "2965970"
  },
  {
    "text": "functions okay I have 30 seconds left thank you so much for missing to e ramble about how all these bits and",
    "start": "2965970",
    "end": "2971940"
  },
  {
    "text": "pieces fit together and how all the types work hopefully you understand a little bit more about how async await is actually generated and how features are",
    "start": "2971940",
    "end": "2978180"
  },
  {
    "text": "executed the slides will be posted up on info queue later but I have these three blog posts that are really good and go",
    "start": "2978180",
    "end": "2984330"
  },
  {
    "text": "into the examples that I showed you in more detail and with written words and I really recommend reading them to sort of",
    "start": "2984330",
    "end": "2990060"
  },
  {
    "text": "get a diction --all additional context and how this stuff works so thank you so much [Applause]",
    "start": "2990060",
    "end": "2998530"
  }
]