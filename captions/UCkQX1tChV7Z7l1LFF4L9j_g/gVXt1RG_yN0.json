[
  {
    "start": "0",
    "end": "273000"
  },
  {
    "text": "coherence what is what is data coherence um well uh this is basically the word",
    "start": "8200",
    "end": "13679"
  },
  {
    "text": "I've been using to describe a concept that's been kind of peeling around the the corners of my brain for a while and",
    "start": "13679",
    "end": "19880"
  },
  {
    "text": "um as with most most things in informal research it probably already exists and it's probably already been described and",
    "start": "19880",
    "end": "25039"
  },
  {
    "text": "it probably has papers that were written about it 25 years ago and so there's probably a term for what I'm describing",
    "start": "25039",
    "end": "30279"
  },
  {
    "text": "here um but as is the case in informal research I haven't been bothered to actually look it up so we're going to call it coherence for now and um go from",
    "start": "30279",
    "end": "37840"
  },
  {
    "text": "there what do I mean by it well basically what I'm referring to is um",
    "start": "37840",
    "end": "43120"
  },
  {
    "text": "the the problems and the design considerations which arise when you have multiple data that you have to work with",
    "start": "43120",
    "end": "50160"
  },
  {
    "text": "together in the same function um which is to say almost every function ever um",
    "start": "50160",
    "end": "55320"
  },
  {
    "text": "so here's an example of this now this is obviously the stupidest possible way I could write this this function but I'm",
    "start": "55320",
    "end": "60920"
  },
  {
    "text": "writing it this way to prove a point um the coherence issue that I see in this function arises from the fact that we",
    "start": "60920",
    "end": "67000"
  },
  {
    "text": "have two input parameters we have two lists of integers that we're trying to put together in this sort of merge",
    "start": "67000",
    "end": "72960"
  },
  {
    "text": "algorithm right and the fact that they're coming in as two separate lists is a problem because it means we have to",
    "start": "72960",
    "end": "79320"
  },
  {
    "text": "make some assumptions there have to be some prerequisites about relations between these lists and relations",
    "start": "79320",
    "end": "85360"
  },
  {
    "text": "between Str these lists structurally in order for us to put them together sanely and in in fact these",
    "start": "85360",
    "end": "91240"
  },
  {
    "text": "assumptions um cause problems in the way I've implemented the function so obviously this predicate right here is a",
    "start": "91240",
    "end": "97520"
  },
  {
    "text": "source of bugs right because I'm only testing the leftand list if the right hand list is too long then we're losing",
    "start": "97520",
    "end": "103920"
  },
  {
    "text": "data if it's too short then we actually explode um so this is this is really really bad um and this is not a a a",
    "start": "103920",
    "end": "111159"
  },
  {
    "text": "particularly good way to write the function um a better way to write the function would be to split out our",
    "start": "111159",
    "end": "118320"
  },
  {
    "text": "prerequisites uh split our preconditions between the lists and have a different way of encoding them so we could have a",
    "start": "118320",
    "end": "124280"
  },
  {
    "text": "function that um instead of actually doing the the the summing right and and the the logic that presumably we're",
    "start": "124280",
    "end": "130679"
  },
  {
    "text": "interested in at the pairwise level we could actually just pair up the lists together and this would probably be implemented as some sort of zip or",
    "start": "130679",
    "end": "136920"
  },
  {
    "text": "something like that but you know this function would encode all of the all of the assumptions that we have about the",
    "start": "136920",
    "end": "143319"
  },
  {
    "text": "two different list and it would have a different way of communicating back to the user that or the user of this API",
    "start": "143319",
    "end": "148959"
  },
  {
    "text": "that something is wrong if these assumptions are violated right it doesn't even necessarily have to return a list of int pairs right it could",
    "start": "148959",
    "end": "155680"
  },
  {
    "text": "return an option of list or a validation of list um and given that we could write this function in a much ster way where",
    "start": "155680",
    "end": "161720"
  },
  {
    "text": "we just take a single input list we only have one datum to deal with um we don't have any assumptions or preconditions",
    "start": "161720",
    "end": "169200"
  },
  {
    "text": "about our different parameters we only have one thing and um therefore we can't have these sort of you know errors where",
    "start": "169200",
    "end": "175720"
  },
  {
    "text": "we line things up um however there's still there's still some coherence issues even in this snippet right um",
    "start": "175720",
    "end": "182599"
  },
  {
    "text": "despite the fact that we only have one input datum um we still have multiple Expressions within our function and",
    "start": "182599",
    "end": "189400"
  },
  {
    "text": "these expressions are slightly incoherent um so we have for example we have a conditional right this",
    "start": "189400",
    "end": "195879"
  },
  {
    "text": "conditional is checking to see whether or not uh the pairs are empty the pairs list are empty and then in the else",
    "start": "195879",
    "end": "203000"
  },
  {
    "text": "Clause we have some Expressions which are actually semantically dependent on the results of that conditional without",
    "start": "203000",
    "end": "208920"
  },
  {
    "text": "being synta ially tied to the conditional itself so we get the head and the tail of the list without",
    "start": "208920",
    "end": "214920"
  },
  {
    "text": "actually being tied to that that conditional and sure right we can make an argument that is in fact correct that",
    "start": "214920",
    "end": "221120"
  },
  {
    "text": "this code can never really fail because you can't get into the else Clause if the list is empty but you know that",
    "start": "221120",
    "end": "227680"
  },
  {
    "text": "that's an argument um that's something that we have to do looking at the code um as humans because Scola doesn't have",
    "start": "227680",
    "end": "234040"
  },
  {
    "text": "strong enough syntactic uh static analysis to answer that question for us and I would argue that writing code that",
    "start": "234040",
    "end": "240439"
  },
  {
    "text": "depends on these sorts of arguments is bad and it it makes it hard to understand and it's another form of",
    "start": "240439",
    "end": "246760"
  },
  {
    "text": "incoherence this time at the code level not at the data level um it's much much",
    "start": "246760",
    "end": "252040"
  },
  {
    "text": "better to write a function in this way where you have the conditional and the",
    "start": "252040",
    "end": "257440"
  },
  {
    "text": "data extraction tied to the same thing in this case with pattern matching so you can't possibly have any incoherence",
    "start": "257440",
    "end": "263040"
  },
  {
    "text": "you're basically taking these two um Expressions the tail and the is empty and merging them together into one thing",
    "start": "263040",
    "end": "270120"
  },
  {
    "text": "so that their coherence is directly expressed so I'm going to talk about three different areas it was going to be",
    "start": "270120",
    "end": "276759"
  },
  {
    "start": "273000",
    "end": "321000"
  },
  {
    "text": "four but I ran out of time um I'm going to talk about expressions and Loosely",
    "start": "276759",
    "end": "282720"
  },
  {
    "text": "Tangled Expressions um which we've already seen some examples of I'm going to talk about sequences because",
    "start": "282720",
    "end": "287759"
  },
  {
    "text": "sequences are really interesting and whenever you have you know a lot of things as opposed to just one thing you",
    "start": "287759",
    "end": "293759"
  },
  {
    "text": "can have that many more bugs um and finally we're going to talk about parametricity because I think",
    "start": "293759",
    "end": "299039"
  },
  {
    "text": "parametricity is really the payoff to thinking about these sorts of problems because it's where you get to get some",
    "start": "299039",
    "end": "304240"
  },
  {
    "text": "validation and some static verification out of being more disciplined in how you write your code so um oh also um despite",
    "start": "304240",
    "end": "313479"
  },
  {
    "text": "the fact that I had to cut entire section um I think we probably have a decent amount of time so if at any point anyone has any questions go right ahead",
    "start": "313479",
    "end": "321360"
  },
  {
    "start": "321000",
    "end": "424000"
  },
  {
    "text": "um Expressions this is another form of the example that we saw earlier this is the uh get or else function from the",
    "start": "321360",
    "end": "327960"
  },
  {
    "text": "option type right um and it's it's kind of implemented in a dumb way where we have this conditional um where we check",
    "start": "327960",
    "end": "334400"
  },
  {
    "text": "to see if the option is empty and if it's empty then we return the default otherwise we return we just do dot get",
    "start": "334400",
    "end": "340000"
  },
  {
    "text": "and we grab the value out of the option because we're absolutely certain that it's there um and the incoherence is of",
    "start": "340000",
    "end": "345280"
  },
  {
    "text": "course here right we have these two expressions that are dependent on each other right the is empty um it's its",
    "start": "345280",
    "end": "352479"
  },
  {
    "text": "dependence on the get is sort of harder harder to see than the dependence of the get on the is empty right because if get",
    "start": "352479",
    "end": "358919"
  },
  {
    "text": "if you call a get without checking that is empty then you don't know whether or not it's going to explode but if you call is empty without calling get or",
    "start": "358919",
    "end": "365720"
  },
  {
    "text": "something else that depends on that then it's sort of a useless Boolean that you just grabbed for no reason other than I don't know to or it with something um so",
    "start": "365720",
    "end": "374319"
  },
  {
    "text": "I think the um so the the the the incoherence of the dot get is really easy to see right um because we have to",
    "start": "374319",
    "end": "380280"
  },
  {
    "text": "make this argument that this is valid um there's another problem here which is that um we're working with a type which",
    "start": "380280",
    "end": "388199"
  },
  {
    "text": "is essentially entirely useless um and that type is Boolean um but it's",
    "start": "388199",
    "end": "393720"
  },
  {
    "text": "difficult to see in this partially because we're using an if else right so through long long ages of tradition up",
    "start": "393720",
    "end": "401520"
  },
  {
    "text": "from Cobalt and Beyond through C and Java and into Scala we've been trained",
    "start": "401520",
    "end": "406919"
  },
  {
    "text": "to look through if El statements we don't even see them anymore we're just like oh okay there's a predicate and",
    "start": "406919",
    "end": "412160"
  },
  {
    "text": "this predicate means oh okay now this is safe we're inside of here blah um we we just we just zip right through it but if",
    "start": "412160",
    "end": "418560"
  },
  {
    "text": "we build our own hierarch key such that this such that we're not actually using IF else I think this problem becomes a little bit more obvious so let's write a",
    "start": "418560",
    "end": "426319"
  },
  {
    "start": "424000",
    "end": "493000"
  },
  {
    "text": "algebra okay bull has two cases true and false very very obvious and it has a fold function on it that um takes a true",
    "start": "426319",
    "end": "433479"
  },
  {
    "text": "case and takes a false case and we'll invoke them depending on which case that we're in very very very straightforward stuff this fold function is literally",
    "start": "433479",
    "end": "440160"
  },
  {
    "text": "what if else does right it has a predicate which is the Boolean on which",
    "start": "440160",
    "end": "445199"
  },
  {
    "text": "we are invoking this function and it has a true and a false Branch um one of which will be invoked depending on where",
    "start": "445199",
    "end": "451520"
  },
  {
    "text": "we are very very very easy and we can rewrite our function we can rewrite our",
    "start": "451520",
    "end": "456560"
  },
  {
    "text": "function is empty to return uh this Boolean and then rewrite our function down here to use this and now I think",
    "start": "456560",
    "end": "461639"
  },
  {
    "text": "it's a little bit more obvious where the problem is right the problem is that we have to go through this whole rigar roll",
    "start": "461639",
    "end": "468479"
  },
  {
    "text": "of Boolean to get at what we actually want which is to say the dogat function",
    "start": "468479",
    "end": "473599"
  },
  {
    "text": "the contents of the option the contents of the option are the point to this whole function um but we had to go",
    "start": "473599",
    "end": "480120"
  },
  {
    "text": "through a completely meaningless type to get there um and I would argue that this is",
    "start": "480120",
    "end": "487479"
  },
  {
    "text": "really a problem um this is a problem that is extremely prolific in most programming because you know why not all",
    "start": "487479",
    "end": "494000"
  },
  {
    "start": "493000",
    "end": "531000"
  },
  {
    "text": "sorts of functions are written with this sort of indirection it's data indirection it's indirection at the data representation level and it's",
    "start": "494000",
    "end": "500879"
  },
  {
    "text": "essentially wasting our cognitive resources to try to understand what's going on in these cases because we we",
    "start": "500879",
    "end": "507599"
  },
  {
    "text": "effectively have uh the we write functions that do this sort of thing where we we're like okay we're going to get this piece of data over here that",
    "start": "507599",
    "end": "514080"
  },
  {
    "text": "we're going to ascribe some meaning to and if this meaning is satisfied okay we're going to jump back over here and do something else like that's I don't",
    "start": "514080",
    "end": "520919"
  },
  {
    "text": "know that's that's that's really absurd and it leads to these situations where we have Expressions that are intrinsically related but not actually",
    "start": "520919",
    "end": "527680"
  },
  {
    "text": "syntactically related in the structure of the code that we wrote um so the doget function is intrinsically related",
    "start": "527680",
    "end": "533839"
  },
  {
    "text": "to the is empty function in that it doesn't make any sense at all in fact will explode if is empty is not",
    "start": "533839",
    "end": "539959"
  },
  {
    "text": "satisfied but it's not syntactically related in how we wrote the code so this shows up in the case of preconditions",
    "start": "539959",
    "end": "546640"
  },
  {
    "text": "right um if your option is not empty get explodes it also shows up in other areas like side effects right side effects are",
    "start": "546640",
    "end": "553320"
  },
  {
    "text": "sort of like the ultimate Uber preconditioned through the external Universe right I'm I I hope that this",
    "start": "553320",
    "end": "560000"
  },
  {
    "text": "file exists because I created it over here and I'm just going to pretend that this rounds after that thing um like",
    "start": "560000",
    "end": "565880"
  },
  {
    "text": "these are these are things that are these are preconditions and these are coherencies between Expressions that um",
    "start": "565880",
    "end": "572880"
  },
  {
    "text": "are not expressed in the way that we traditionally write code or they may not be expressed in the way that we",
    "start": "572880",
    "end": "578360"
  },
  {
    "text": "structure our expressions and that's really bad it leads to reasoning solely by control flow so at the beginning of",
    "start": "578360",
    "end": "585760"
  },
  {
    "text": "this section I had a a flowchart up there which I would venture to uh guess none of us have ever actually written",
    "start": "585760",
    "end": "591079"
  },
  {
    "text": "outside of the classroom um but you know that's that's actually how we have to think about code a lot of the time right",
    "start": "591079",
    "end": "598000"
  },
  {
    "text": "we have to look at a function even a function written in a functional non- imperative style and we have to reason",
    "start": "598000",
    "end": "603920"
  },
  {
    "text": "about okay control flow enters the function here and then we make these checks and okay this guard checks over",
    "start": "603920",
    "end": "609640"
  },
  {
    "text": "here and this Branch goes over here and then we're in this Branch okay well how did we get in this Branch like we have to make those sorts of reasonings that's",
    "start": "609640",
    "end": "616600"
  },
  {
    "text": "dumb that makes code really really hard to talk about it makes bugs really really easy to lose because you have to",
    "start": "616600",
    "end": "623600"
  },
  {
    "text": "kind of reverse this tree of decisions that led you to this particular point in order to understand how you got into to",
    "start": "623600",
    "end": "629360"
  },
  {
    "text": "a buggy case it's much much better if you can reason instead in terms of data",
    "start": "629360",
    "end": "635880"
  },
  {
    "text": "flow right so I have data that goes in and in order to in order to access that data in order to be in this case at all",
    "start": "635880",
    "end": "642000"
  },
  {
    "text": "that data has to be valid right um it's much much better to structure your code in that way so I said side effects right",
    "start": "642000",
    "end": "650440"
  },
  {
    "text": "um what does what does that actually look like um well it's it's kind of like this um so here's a here's an obviously",
    "start": "650440",
    "end": "657000"
  },
  {
    "start": "652000",
    "end": "748000"
  },
  {
    "text": "imperative function right where we write to a file um that may be created I don't know how the right to file function",
    "start": "657000",
    "end": "662839"
  },
  {
    "text": "works we'll just pretend um read that data back out as a string concatenate it and return it very straightforward stuff",
    "start": "662839",
    "end": "669240"
  },
  {
    "text": "um of course the the tangling of concerns here is between the read and write function right we're making this",
    "start": "669240",
    "end": "676440"
  },
  {
    "text": "assumption in the read function in the way that we've invoked it that the right function has in fact been run that this",
    "start": "676440",
    "end": "684240"
  },
  {
    "text": "file exists that was created in some sort of external Universe World thing that we call the file system and it has",
    "start": "684240",
    "end": "691120"
  },
  {
    "text": "some contents that we can sanely decode as a string and return as a result this is a dependency between these two",
    "start": "691120",
    "end": "697800"
  },
  {
    "text": "expressions and it's a dependency that no static Checker in the world is going to be able to help us with at the end of",
    "start": "697800",
    "end": "703079"
  },
  {
    "text": "the day right maybe in this trivial example but I I can make this more and more and more and more and more",
    "start": "703079",
    "end": "708639"
  },
  {
    "text": "complicated until every static analyzer anywhere would just fall in its face um",
    "start": "708639",
    "end": "713880"
  },
  {
    "text": "it's much much better if we can use a tool to combine these expressions",
    "start": "713880",
    "end": "720040"
  },
  {
    "text": "in way that they cannot possi be that they cannot run out of this is Theon comes into place so",
    "start": "720040",
    "end": "729480"
  },
  {
    "text": "most of the time when you're you're looking at the ion ad from the skeptical outside view of imperative programming",
    "start": "729480",
    "end": "736279"
  },
  {
    "text": "um the ionad just seems like something that you slap onto a function that has side effects and it labels it as evil",
    "start": "736279",
    "end": "743519"
  },
  {
    "text": "um that that is sort of true right um and anything anything that returns",
    "start": "743519",
    "end": "750199"
  },
  {
    "start": "748000",
    "end": "872000"
  },
  {
    "text": "inside the iom Ed should be treated with some suspicion um but the real real value of it outside of simple labeling a",
    "start": "750199",
    "end": "757959"
  },
  {
    "text": "simple dogmatic labeling is that we can use it to merge together functions to",
    "start": "757959",
    "end": "763680"
  },
  {
    "text": "merge together expressions and represent their dependencies in terms of the data flow um and it it looks like this right",
    "start": "763680",
    "end": "771959"
  },
  {
    "text": "um of course the for comprehension syntax was chosen specifically to make functions look very imperative so this",
    "start": "771959",
    "end": "778440"
  },
  {
    "text": "is sort of defeating the purpose so rather than rather than looking at this maybe we should desar it um into the actual flat maps and you'll see",
    "start": "778440",
    "end": "785360"
  },
  {
    "text": "structurally here what we've done is we've taken the operations the writing and the reading and we've related them",
    "start": "785360",
    "end": "791720"
  },
  {
    "text": "together in such a way that it is brutally explicitly clear where the dependencies are it is impossible to get",
    "start": "791720",
    "end": "798519"
  },
  {
    "text": "to the read from file expression without having gone through the right to file",
    "start": "798519",
    "end": "804639"
  },
  {
    "text": "expression so we've taken our dependency our side affecting dependency and we've put it together in such a way that it's",
    "start": "804639",
    "end": "811560"
  },
  {
    "text": "represented in the structure of our program this is very powerful this avoids bugs and this is what monads do",
    "start": "811560",
    "end": "819680"
  },
  {
    "text": "so monads in general take um take they they take code flow right they take",
    "start": "819680",
    "end": "825959"
  },
  {
    "text": "control flow and they turn it into data flow where you which is something that you can reason about right data flow is",
    "start": "825959",
    "end": "832759"
  },
  {
    "text": "something that we can reason about because we know that you you can't get this piece of data except from here",
    "start": "832759",
    "end": "839199"
  },
  {
    "text": "right and if you can only get this piece of data from here then just make sure that all of your prerequisite operations are up here and they spit out the data",
    "start": "839199",
    "end": "845800"
  },
  {
    "text": "at the end of the world and they spit out the data and then everything is linked together rather than just having this sort of handwavy assumption that oh",
    "start": "845800",
    "end": "852320"
  },
  {
    "text": "well this happened and then this happened and then this happened because that's hard to reason about and it is hard to type check so we always want to",
    "start": "852320",
    "end": "859720"
  },
  {
    "text": "Reason by structure and within that structure we always want to reason but with data flow because data flow is",
    "start": "859720",
    "end": "866920"
  },
  {
    "text": "typable data flow is something that our type Checkers under scan now I think",
    "start": "866920",
    "end": "872160"
  },
  {
    "text": "that may be something of a historical accident um because I you know I don't really know why data flow is so much",
    "start": "872160",
    "end": "878519"
  },
  {
    "text": "easier to type check than control flow because they really are kind of the same thing right code is data data is code",
    "start": "878519",
    "end": "884360"
  },
  {
    "text": "you can always make this transformation um why is it the type Checkers have such an easier time with one case than",
    "start": "884360",
    "end": "889800"
  },
  {
    "text": "another I don't know but that's just the way it is we're working in Scala we have to work within the bounds of what the",
    "start": "889800",
    "end": "894959"
  },
  {
    "text": "type Checker can give us and if we want to exploit the type Checker we have have to structure things much more in terms",
    "start": "894959",
    "end": "901199"
  },
  {
    "text": "of data than in terms of control um data flow is great because it explodes very",
    "start": "901199",
    "end": "906759"
  },
  {
    "text": "very quickly if you get it wrong now I'm not even talking about just static typing here right um so sure it's great",
    "start": "906759",
    "end": "913639"
  },
  {
    "text": "if your static type Checker can look at your data flow and and make sure that everything is actually lining up",
    "start": "913639",
    "end": "919160"
  },
  {
    "text": "correctly right and most of the time Scola will do that but this holds true even in dynamically typed languages so",
    "start": "919160",
    "end": "924440"
  },
  {
    "text": "if you're working in closure for example and you're composing together some sort of complicated data flow pattern um if",
    "start": "924440",
    "end": "930839"
  },
  {
    "text": "you get it wrong chances are it will simply explode the first time you try to run it it doesn't matter what data",
    "start": "930839",
    "end": "937199"
  },
  {
    "text": "you're feeding through it it doesn't matter what case of the branches you get into if you compose your data structures",
    "start": "937199",
    "end": "943160"
  },
  {
    "text": "incorrectly chances are you're just going to get an exception regardless of what case you land in and that's really",
    "start": "943160",
    "end": "949480"
  },
  {
    "text": "really powerful because if you can't get type errors you may as well just get runtime errors right away in every case",
    "start": "949480",
    "end": "956959"
  },
  {
    "text": "right catch your bugs as early as possible um data flow allows you to do that control flow is much harder because if",
    "start": "956959",
    "end": "962800"
  },
  {
    "text": "you don't happen to hit that magic nested case inside 27 IFL statements well good luck to you because you know",
    "start": "962800",
    "end": "970160"
  },
  {
    "text": "you're not going to realize that bug until it hits production and somebody types in the wrong value um as I said",
    "start": "970160",
    "end": "975880"
  },
  {
    "start": "974000",
    "end": "1022000"
  },
  {
    "text": "code is data you can always always always take your control flow and turn it into data flow um monets are the",
    "start": "975880",
    "end": "982199"
  },
  {
    "text": "easiest and most obvious way to do this most of the time um but there's a lot of other ways too and learning how to do do",
    "start": "982199",
    "end": "989120"
  },
  {
    "text": "this I think is a really really important skill um that all programmers should develop um tie your data to your",
    "start": "989120",
    "end": "996279"
  },
  {
    "text": "branching so this is what I was referencing earlier um and this is kind of a general pattern for one way that",
    "start": "996279",
    "end": "1002399"
  },
  {
    "text": "you can turn things more into data flow is you shouldn't be able to access data",
    "start": "1002399",
    "end": "1008079"
  },
  {
    "text": "unless it is valid to do so and The Duel of that is that if it is valid to access data you should already have it um there",
    "start": "1008079",
    "end": "1015800"
  },
  {
    "text": "should be no distinction between the check for validity and the actual getting of data um and in Scala this",
    "start": "1015800",
    "end": "1023160"
  },
  {
    "start": "1022000",
    "end": "1085000"
  },
  {
    "text": "generally shows up as pattern matching right this is this is really the most natural way to do it oh I just completely bked the recording um if uh",
    "start": "1023160",
    "end": "1031520"
  },
  {
    "text": "you know if you're if you are a certain persuasion of mind let's say I don't",
    "start": "1031520",
    "end": "1036760"
  },
  {
    "text": "judge um you could you maybe would write this as a fold instead but um they're the same thing right um in either case",
    "start": "1036760",
    "end": "1044480"
  },
  {
    "text": "you are performing the test to see which case that you're in which branch that you're in and simultaneously extracting",
    "start": "1044480",
    "end": "1051559"
  },
  {
    "text": "the data that will probably be useful to you precisely because you are in this case right this is why pattern matching",
    "start": "1051559",
    "end": "1058760"
  },
  {
    "text": "you know avoids bugs anecdotally because you land in this case and you can't possibly get it wrong um this is this is",
    "start": "1058760",
    "end": "1066679"
  },
  {
    "text": "very very powerful and um this pattern I think extends Beyond even simple pattern matching and deconstruct decomposing of",
    "start": "1066679",
    "end": "1073240"
  },
  {
    "text": "algebra right you always want to contrive your data structures such that the only possible case you could be in",
    "start": "1073240",
    "end": "1080120"
  },
  {
    "text": "is the correct one and we'll get into how you can do that more in a little bit but first",
    "start": "1080120",
    "end": "1085880"
  },
  {
    "text": "sequences so one very obvious thing that you can do with a sequence one very",
    "start": "1085880",
    "end": "1090960"
  },
  {
    "text": "common thing to do with a sequence is get its length right this is a common property to be common thing to be asking",
    "start": "1090960",
    "end": "1097840"
  },
  {
    "text": "for especially if you're coming from a Java world where you know the standard way of actually getting at a sequence",
    "start": "1097840",
    "end": "1103240"
  },
  {
    "text": "get its length and just sort of walk over it um I am going to make the argument that the length function the",
    "start": "1103240",
    "end": "1108919"
  },
  {
    "text": "value that it gives us is in fact useless there is no point to performing",
    "start": "1108919",
    "end": "1115000"
  },
  {
    "start": "1111000",
    "end": "1352000"
  },
  {
    "text": "this operation absolutely none why well let's think about what length does what",
    "start": "1115000",
    "end": "1121799"
  },
  {
    "text": "does length give us well length gives us an integer what can we do with integers well we can add um I think we can",
    "start": "1121799",
    "end": "1130679"
  },
  {
    "text": "subtract um we can multiply and if we squint we can pretend to divide what",
    "start": "1130679",
    "end": "1136480"
  },
  {
    "text": "does that have to do with a list um answer nothing there there's no reason to be doing this like absolutely",
    "start": "1136480",
    "end": "1143440"
  },
  {
    "text": "no reason whatsoever um the the information about the length of a list",
    "start": "1143440",
    "end": "1148520"
  },
  {
    "text": "is already encoded in its structure right and if we want to do anything useful with the list we have to do",
    "start": "1148520",
    "end": "1153880"
  },
  {
    "text": "something with that structure that presumably respects the length um why do we need to get the length as this",
    "start": "1153880",
    "end": "1159919"
  },
  {
    "text": "separate integer thing that isn't related to anything whatsoever and is sort of hanging out causing bugs uh",
    "start": "1159919",
    "end": "1166360"
  },
  {
    "text": "answer we don't um getting the length is going in the wrong direction right um it",
    "start": "1166360",
    "end": "1172720"
  },
  {
    "text": "is good when we can take two pieces of data and collapse them into one piece of",
    "start": "1172720",
    "end": "1178120"
  },
  {
    "text": "data that we can feed through our code we saw an example of this in the very first slide that was useful right where",
    "start": "1178120",
    "end": "1185919"
  },
  {
    "text": "we had a function that took two lists and there was a bug in that function implementation that stemmed from either",
    "start": "1185919",
    "end": "1192159"
  },
  {
    "text": "my naivity or the fact that we were taking two lists rather than one right um so it's good when we can take two",
    "start": "1192159",
    "end": "1198760"
  },
  {
    "text": "things and collapse them into one early as early as possible representing our assumptions and",
    "start": "1198760",
    "end": "1204280"
  },
  {
    "text": "preconditions therefore it is bad when we go the other way think about length",
    "start": "1204280",
    "end": "1209320"
  },
  {
    "text": "what is it doing it's taking one piece of data a list right and it's exploding it into two pieces of data a list and an",
    "start": "1209320",
    "end": "1217400"
  },
  {
    "text": "integer and now we have both and we have to deal with them to do anything useful it's also focusing on the wrong thing",
    "start": "1217400",
    "end": "1223600"
  },
  {
    "text": "right um who cares how long your list is I don't um what I care about is the",
    "start": "1223600",
    "end": "1229520"
  },
  {
    "text": "contents of the list I care about what's inside that list and that's what I want to perform computations are we do not",
    "start": "1229520",
    "end": "1235960"
  },
  {
    "text": "care about the length unless you have some sort of algorithm uh yes",
    "start": "1235960",
    "end": "1242799"
  },
  {
    "text": "like 10 aha so that was my very next",
    "start": "1242799",
    "end": "1250799"
  },
  {
    "text": "sentence um if you have I I I'll actually get there's a caveat to that as",
    "start": "1251960",
    "end": "1257840"
  },
  {
    "text": "well specifically with merge sword but um if you have an algorithm which is",
    "start": "1257840",
    "end": "1262880"
  },
  {
    "text": "fundamentally algorithmically dependent on the length of your sequence then it is valid to get the length um the number",
    "start": "1262880",
    "end": "1270200"
  },
  {
    "text": "of algorithms which are fundamentally algorithmically dependent on the length of the sequence can practically be enumerated on a Blackboard like at least",
    "start": "1270200",
    "end": "1277400"
  },
  {
    "text": "classic algorithms there really are not that many merge sort is not one of them merge sort does not depend on the length",
    "start": "1277400",
    "end": "1283840"
  },
  {
    "text": "um what you just have to do is be a little bit clever with how you split things up you don't even need the length for quick sort either it's just a little",
    "start": "1283840",
    "end": "1290159"
  },
  {
    "text": "bit faster stochastically if you have it so um like most of the time when people",
    "start": "1290159",
    "end": "1297640"
  },
  {
    "text": "are writing code that depends on length um they're actually writing code that depends on very very different things",
    "start": "1297640",
    "end": "1303120"
  },
  {
    "text": "and they're just using length as a very inconvenient approximation so it's a good point",
    "start": "1303120",
    "end": "1309120"
  },
  {
    "text": "though I think um there's probably a lot of stuff with Matrix manipulation and stuff like that that also is length",
    "start": "1309120",
    "end": "1315600"
  },
  {
    "text": "dependent um legitimately length dependent but um yeah how many of us actually do that on",
    "start": "1315600",
    "end": "1320799"
  },
  {
    "text": "a day-to-day basis yes Eric",
    "start": "1320799",
    "end": "1327919"
  },
  {
    "text": "yes yeah okay so um I don't care about the length Eric does I care about the",
    "start": "1327919",
    "end": "1334720"
  },
  {
    "text": "contents um and we can go from there Eric didn't get a talk yeah Eric Eric",
    "start": "1334720",
    "end": "1340480"
  },
  {
    "text": "didn't get a talk so he has to ruin mine um anyway",
    "start": "1340480",
    "end": "1345519"
  },
  {
    "text": "um so most of the time what people are doing with the length is something like this",
    "start": "1346960",
    "end": "1353760"
  },
  {
    "start": "1352000",
    "end": "1437000"
  },
  {
    "text": "monstrosity um where where you get the length and you sort of iterate over it um this unfortunately is another case of",
    "start": "1353760",
    "end": "1361440"
  },
  {
    "text": "since the early days of what we were doing whenever we were in the early days of programming um we have been trained",
    "start": "1361440",
    "end": "1367520"
  },
  {
    "text": "to look through patterns like this and just sort of X-ray down to oh well we're printing out the contents of the list um",
    "start": "1367520",
    "end": "1374520"
  },
  {
    "text": "it's it's a lot clearer that this is terrible if you desugar it right just like with the if expression um and um",
    "start": "1374520",
    "end": "1382799"
  },
  {
    "text": "you know it's it's really obvious with this this construction why this is absurd right so we get the length of the",
    "start": "1382799",
    "end": "1390440"
  },
  {
    "text": "list and we put it together with another completely arbitrary integer and we construct a",
    "start": "1390440",
    "end": "1396679"
  },
  {
    "text": "range what does a Range has to do with a list well we're working on that um we take the range and we iterate over that",
    "start": "1396679",
    "end": "1403600"
  },
  {
    "text": "range and then we use the elements of the range to get the contents of the list out um this doesn't make any sense",
    "start": "1403600",
    "end": "1409600"
  },
  {
    "text": "at all it's really really really obvious that what we care about are actually the contents of this list not the contents",
    "start": "1409600",
    "end": "1416880"
  },
  {
    "text": "of the range the range is completely incidental complexity um and this is why things like for each directly on the",
    "start": "1416880",
    "end": "1423039"
  },
  {
    "text": "collection tend to make a lot more sense when you're introducing functional Concepts to newcomers is that holy cow",
    "start": "1423039",
    "end": "1429720"
  },
  {
    "text": "we can actually get at the cont we can get at the contents without going through this integer thing that's completely unrelated to anything and um",
    "start": "1429720",
    "end": "1437039"
  },
  {
    "start": "1437000",
    "end": "1560000"
  },
  {
    "text": "yeah yes guess length things with so I think that's an example of where you have domain logic that's predicated on",
    "start": "1437039",
    "end": "1444840"
  },
  {
    "text": "the number of things you have right and they're counting the sequence might actually make some sense um I think",
    "start": "1444840",
    "end": "1451960"
  },
  {
    "text": "another more broaden exam more broaden example of that is when you have some sort of statistical process where you",
    "start": "1451960",
    "end": "1459159"
  },
  {
    "text": "want to determine some sort of summary of your data um Counting the data is really important for determining that",
    "start": "1459159",
    "end": "1465399"
  },
  {
    "text": "summary and usually you do those counts while doing other things but you know counting really really fundamental there but I think that gets",
    "start": "1465399",
    "end": "1472000"
  },
  {
    "text": "into the realm of like business logic and stuff like that that I don't know I don't care about",
    "start": "1472000",
    "end": "1478240"
  },
  {
    "text": "um random element picking a random element there are there are algorithms",
    "start": "1479120",
    "end": "1485600"
  },
  {
    "text": "for so the the correction to that is you do need the length if you want to pick it in constant time yeah yeah there are",
    "start": "1493200",
    "end": "1500000"
  },
  {
    "text": "there are algorithms which don't require what",
    "start": "1500000",
    "end": "1505120"
  },
  {
    "text": "no you're we're using Scala we don't care about constant",
    "start": "1505240",
    "end": "1510279"
  },
  {
    "text": "time um yes so that can sometimes be an optimization if you have so if you",
    "start": "1510760",
    "end": "1517120"
  },
  {
    "text": "happen to have a sequence representation that um uses you arranges itself in",
    "start": "1517120",
    "end": "1523120"
  },
  {
    "text": "memory such that you can get Random Access constant time jumps then right",
    "start": "1523120",
    "end": "1528360"
  },
  {
    "text": "right because then indexing into it is an interesting operation indexing a list is not",
    "start": "1528360",
    "end": "1534279"
  },
  {
    "text": "constant indexing a vector is constant so you better",
    "start": "1534279",
    "end": "1540080"
  },
  {
    "text": "so let's not start that again um indexing an array is constant right all",
    "start": "1540080",
    "end": "1545440"
  },
  {
    "text": "men you all real men use arrays um I don't even remember where we were",
    "start": "1545440",
    "end": "1550720"
  },
  {
    "text": "going representation is my next Point um so thinking about the representation of",
    "start": "1550720",
    "end": "1557559"
  },
  {
    "text": "data is really important um and it's I think when I when I think about a new problem right and I'm trying to write",
    "start": "1557559",
    "end": "1564760"
  },
  {
    "start": "1560000",
    "end": "1646000"
  },
  {
    "text": "some sort of algorithm or system or something um the very first thing that I",
    "start": "1564760",
    "end": "1570080"
  },
  {
    "text": "spend time thinking about and usually the thing that I spend the most time thinking about is how am I going to represent the data structures involved",
    "start": "1570080",
    "end": "1575840"
  },
  {
    "text": "what kind of data what kind of form is this data going to take um because the form that your data takes guides the",
    "start": "1575840",
    "end": "1582480"
  },
  {
    "text": "entire rest of your implementation um so an example of this that I think is really instructive is at",
    "start": "1582480",
    "end": "1588600"
  },
  {
    "text": "sequence representations um so observation sometimes we don't care about the sequence at",
    "start": "1588600",
    "end": "1594919"
  },
  {
    "text": "all like I've already told you that we don't care about the length and then a number of people were contradicting me",
    "start": "1594919",
    "end": "1600039"
  },
  {
    "text": "um sometimes we don't care about the sequence right sometimes we don't actually have to have the sequence at all as a thing sometimes the only thing",
    "start": "1600039",
    "end": "1606640"
  },
  {
    "text": "we care about is iterating over that sequence so it's like if you didn't care that a list was comprised of like some",
    "start": "1606640",
    "end": "1613279"
  },
  {
    "text": "sort of head tail thing that you could deconstruct or you know split into two or whatever if all you care cared about",
    "start": "1613279",
    "end": "1618720"
  },
  {
    "text": "was fold and map right well that's that's kind of cool and you could write a lot of stuff with that and sometimes",
    "start": "1618720",
    "end": "1624039"
  },
  {
    "text": "that is all you care about and sometimes with some data domains it's actually a lot more convenient to think in those",
    "start": "1624039",
    "end": "1629360"
  },
  {
    "text": "terms because it's hard to represent the sequence but it's easy to represent iteration for some domains um so then",
    "start": "1629360",
    "end": "1635679"
  },
  {
    "text": "the question becomes well how do we represent iteration what's the minimal representation for iteration and I think",
    "start": "1635679",
    "end": "1641960"
  },
  {
    "text": "the very first step along this highway is something that looks like this so we",
    "start": "1641960",
    "end": "1647200"
  },
  {
    "start": "1646000",
    "end": "1773000"
  },
  {
    "text": "have an iner trait um that's parameterized in type A and it it just takes a value and returns a new",
    "start": "1647200",
    "end": "1653919"
  },
  {
    "text": "iter right this makes sense um we take each element of a sequence in turn and",
    "start": "1653919",
    "end": "1659679"
  },
  {
    "text": "then we return the you know a new iter that maybe has some new internal State maybe we're summing stuff up or",
    "start": "1659679",
    "end": "1665399"
  },
  {
    "text": "something like that right we just we just build it along and we build this chain of things um and um we could we",
    "start": "1665399",
    "end": "1672000"
  },
  {
    "text": "could use this very easily right we we call our iter with one and then with two",
    "start": "1672000",
    "end": "1677200"
  },
  {
    "text": "and then with three and with four and with five and we start to see a problem because this iter is only useful on",
    "start": "1677200",
    "end": "1682519"
  },
  {
    "text": "infinite sequences um because there's absolutely no way to get anything other than an",
    "start": "1682519",
    "end": "1687799"
  },
  {
    "text": "itter out of our itter so we can keep applying it to stuff and we can keep feeding it more data but that's all we",
    "start": "1687799",
    "end": "1695279"
  },
  {
    "text": "can do so we've sort of accomplished half of our goal here which is to say we've got iteration and you know there's",
    "start": "1695279",
    "end": "1701480"
  },
  {
    "text": "a way of giving it some sort of sequential like thing um but we don't really have a a way of making use of",
    "start": "1701480",
    "end": "1707880"
  },
  {
    "text": "that in some sort of finite process so this is not quite right what we actually have to do is enrich our algebra just a",
    "start": "1707880",
    "end": "1713760"
  },
  {
    "text": "little bit and go beyond that so now we have an it that has two type parameters it has an input and an output because",
    "start": "1713760",
    "end": "1720000"
  },
  {
    "text": "now we can actually get output out the other end and it has two states it has",
    "start": "1720000",
    "end": "1725159"
  },
  {
    "text": "the continue state which is a function that takes an element of our sequence",
    "start": "1725159",
    "end": "1730440"
  },
  {
    "text": "the next element of the sequence and returns us a new iterator right so a new iter that has maybe some new state maybe",
    "start": "1730440",
    "end": "1737159"
  },
  {
    "text": "an increased count to increase Su something like that um and uh we have a",
    "start": "1737159",
    "end": "1742440"
  },
  {
    "text": "second state which is we're done okay and this is just common sense right we",
    "start": "1742440",
    "end": "1747880"
  },
  {
    "text": "have to get a value out of our iter how do we get our value out of our iter we just represent it directly in the iter",
    "start": "1747880",
    "end": "1754360"
  },
  {
    "text": "so our result is of type B we have a little bit of variance annotations just to make things fun um because who",
    "start": "1754360",
    "end": "1760679"
  },
  {
    "text": "doesn't like subtyping um and uh I it wasn't a call for hands",
    "start": "1760679",
    "end": "1770039"
  },
  {
    "text": "um we could use this iteration just like we did before except now we can actually have some bounds to it and this is maybe",
    "start": "1770320",
    "end": "1776559"
  },
  {
    "text": "the ugliest code in history um because in order to actually run this iterator this iter thing um we have to have this",
    "start": "1776559",
    "end": "1784480"
  },
  {
    "text": "weird little dance of like map and get or else and this this weird combinator and this utility function that's sort of",
    "start": "1784480",
    "end": "1790120"
  },
  {
    "text": "hanging out here I don't know this is super ugly but like I said we don't care about it because this is the sequence",
    "start": "1790120",
    "end": "1795559"
  },
  {
    "text": "right if you squint really hard you can see see the sequence inside of this code the sequence is 0 1 2 and that's it then",
    "start": "1795559",
    "end": "1803880"
  },
  {
    "text": "the sequence is done so it's encoded in here somewhere um that's the only thing that matters to us because what we care",
    "start": "1803880",
    "end": "1810039"
  },
  {
    "text": "about is representing the iteration in a reasonable way not the sequence we don't care about the sequence um and so this",
    "start": "1810039",
    "end": "1816320"
  },
  {
    "text": "actually implies something really interesting um sequences are nothing more in this representation sequences",
    "start": "1816320",
    "end": "1823159"
  },
  {
    "text": "are nothing more than functions from iter to iter",
    "start": "1823159",
    "end": "1828279"
  },
  {
    "text": "that's pretty cool and this is in fact forced so if",
    "start": "1828279",
    "end": "1834039"
  },
  {
    "text": "you think about what this function from itter to it would do right what could it possibly do with an it well there's",
    "start": "1834039",
    "end": "1840640"
  },
  {
    "text": "there's two things that you can do with an it right you can depending on which state you're in you can either run the",
    "start": "1840640",
    "end": "1846039"
  },
  {
    "text": "iter one step right um if you're in the continu state or if it's done you can return it um so a function from iter to",
    "start": "1846039",
    "end": "1853480"
  },
  {
    "text": "it could return the iter that it's been given or if if it's done it could return",
    "start": "1853480",
    "end": "1858799"
  },
  {
    "text": "it right away or it could run it maybe one step maybe two steps maybe three",
    "start": "1858799",
    "end": "1864039"
  },
  {
    "text": "steps however many steps it wants to run it but that's all it could possibly do so functions like this very very",
    "start": "1864039",
    "end": "1871799"
  },
  {
    "text": "directly represent sequences they represent nothing but sequences because",
    "start": "1871799",
    "end": "1877080"
  },
  {
    "text": "the sequence we have said in our representation is simply the iteration of our iter running it an additional",
    "start": "1877080",
    "end": "1882960"
  },
  {
    "text": "step so sequences are functions on iter you can't do anything but H you can't do",
    "start": "1882960",
    "end": "1888840"
  },
  {
    "text": "anything but have a sequence um you can't do any I have no idea what I was saying with that you can't you can't do",
    "start": "1888840",
    "end": "1895440"
  },
  {
    "start": "1892000",
    "end": "1967000"
  },
  {
    "text": "anything else with a sequence but iterate it which is kind of cool right the sequence is just sort of this opaque",
    "start": "1895440",
    "end": "1900720"
  },
  {
    "text": "function right and the only way we can interrogate is by feeding an iter in one end and reading the it out the other end that's the only thing we can do what's",
    "start": "1900720",
    "end": "1907639"
  },
  {
    "text": "beautiful about this is not only is that the only thing we can do with sequences it's the only we can do with iters what",
    "start": "1907639",
    "end": "1914240"
  },
  {
    "text": "can you do with an itter other than run it in a sequence answer nothing you can",
    "start": "1914240",
    "end": "1919600"
  },
  {
    "text": "read what state that iter is in but that doesn't really do you much good um so you can read out the function that's in",
    "start": "1919600",
    "end": "1925440"
  },
  {
    "text": "the iter and you can apply it to some element and get the next iter but that's the same as iteration right there's no",
    "start": "1925440",
    "end": "1931200"
  },
  {
    "text": "difference so we have built a representation by starting from these really minimal building blocks where",
    "start": "1931200",
    "end": "1938639"
  },
  {
    "text": "iteration and sequences are both constrained to be exactly and only the",
    "start": "1938639",
    "end": "1945120"
  },
  {
    "text": "use to which we wanted to apply them exactly and only the correct usage and what's beautiful about that is that our",
    "start": "1945120",
    "end": "1951480"
  },
  {
    "text": "type system comes into play right our type system is able to help us and constrain things and give us guarantees",
    "start": "1951480",
    "end": "1958159"
  },
  {
    "text": "about stuff and if you try to do things wrong it simply will not work and I'll explain in the next section about how that is exactly um but first a tiny",
    "start": "1958159",
    "end": "1965440"
  },
  {
    "text": "little bit of historic note just for the record um in our terminology what we've been calling a sequence is",
    "start": "1965440",
    "end": "1971639"
  },
  {
    "start": "1967000",
    "end": "2124000"
  },
  {
    "text": "conventionally called an enumerator what we've been calling an iter is conventionally called an iter a t so if",
    "start": "1971639",
    "end": "1978639"
  },
  {
    "text": "you've ever looked at like schola Ed it implementation or something like that and been really confused well it's it's",
    "start": "1978639",
    "end": "1984760"
  },
  {
    "text": "actually very simple um and it's it's not that difficult to to explain um and",
    "start": "1984760",
    "end": "1990880"
  },
  {
    "text": "uh yeah there are there are other implementations out there as well so anyway um I I think iterates make a",
    "start": "1990880",
    "end": "1997159"
  },
  {
    "text": "really interesting case study in this in this process right because it's basically going back to really really",
    "start": "1997159",
    "end": "2003760"
  },
  {
    "text": "really simple fundamentals of what do we need out of a representation what is the simplest most basic thing that we need",
    "start": "2003760",
    "end": "2010399"
  },
  {
    "text": "out of a representation okay start there work your way up if all data structures",
    "start": "2010399",
    "end": "2016360"
  },
  {
    "text": "in the world were built along this pattern then we would work in a much more bug-free environment because you",
    "start": "2016360",
    "end": "2023039"
  },
  {
    "text": "wouldn't be able to do anything but what the uh what the data was designed to be used as and that's very powerful it's",
    "start": "2023039",
    "end": "2029799"
  },
  {
    "text": "powerful because of something called parametricity so what is parametricity",
    "start": "2029799",
    "end": "2036120"
  },
  {
    "text": "and why do we care about it well let's think about this type okay this type says for all a a function from a to",
    "start": "2036120",
    "end": "2045080"
  },
  {
    "text": "a how many different implementations are there of this type anyone have an",
    "start": "2045080",
    "end": "2051440"
  },
  {
    "text": "idea I were saying one anybody else have any",
    "start": "2051440",
    "end": "2056200"
  },
  {
    "text": "ideas you guys have been reading the the homework um okay so uh I can actually",
    "start": "2056560",
    "end": "2061679"
  },
  {
    "text": "think of four implementations of this function all right we have the obvious one we have the insane one we have the",
    "start": "2061679",
    "end": "2069919"
  },
  {
    "text": "dumb one and we have the landmine um thank you",
    "start": "2069919",
    "end": "2077358"
  },
  {
    "text": "Scola uh for the purposes for the purposes of our own sanity though um we",
    "start": "2077359",
    "end": "2082960"
  },
  {
    "text": "I think we can all agree that the the lower ones are wrong right the lower ones are just bad right so if you have a",
    "start": "2082960",
    "end": "2088440"
  },
  {
    "text": "function that Loops infinitely uh the fact that it claims to give you a certain result is not actually useful um",
    "start": "2088440",
    "end": "2094520"
  },
  {
    "text": "if you have a function that throws an exception that's that's kind of terrify F so um we're just going to pretend that",
    "start": "2094520",
    "end": "2101440"
  },
  {
    "text": "these other three don't exist and we're just going to work within the realm of the one implementation which everybody",
    "start": "2101440",
    "end": "2107920"
  },
  {
    "text": "was basically referencing right away and preempting me to my point um so okay um parametricity why is",
    "start": "2107920",
    "end": "2117359"
  },
  {
    "text": "parametricity useful in the concept in the context of data coherence well it's useful because it allows us to take",
    "start": "2117359",
    "end": "2124160"
  },
  {
    "start": "2124000",
    "end": "2227000"
  },
  {
    "text": "multiple data and put them together safely um so we saw at the beginning where we",
    "start": "2124160",
    "end": "2130200"
  },
  {
    "text": "had two lists and there were some implicit assumptions in our function about how those lists were relative to",
    "start": "2130200",
    "end": "2136400"
  },
  {
    "text": "each other and what we could do with those lists and what structure they had um parametricity allows us to be really",
    "start": "2136400",
    "end": "2143160"
  },
  {
    "text": "really constrained and really really explicit about the sorts of data we accept and what relations between those",
    "start": "2143160",
    "end": "2149880"
  },
  {
    "text": "data we have so you usually set yourself up in a situation where you have two pieces of data one and two and data one",
    "start": "2149880",
    "end": "2157079"
  },
  {
    "text": "can only only be used with data 2 and you cannot do anything else with it it's impossible to do anything else with it",
    "start": "2157079",
    "end": "2163760"
  },
  {
    "text": "but link it to data 2 and data 2 defines how data one can be used that's really",
    "start": "2163760",
    "end": "2168960"
  },
  {
    "text": "really powerful um most of the time you find yourselves making arguments of the sort well where else would you get that",
    "start": "2168960",
    "end": "2174400"
  },
  {
    "text": "sort of value right you could only get it from data one and you can only feed it to data two um this is like the",
    "start": "2174400",
    "end": "2179800"
  },
  {
    "text": "argument that we made with iterates and with enumerators right the only thing you can do within a numerator is iterate",
    "start": "2179800",
    "end": "2185680"
  },
  {
    "text": "over it right um this is is a it's it's a very very common argument to be making in these sorts of really constrained",
    "start": "2185680",
    "end": "2192520"
  },
  {
    "text": "functional designs um and it's it's very very very powerful this is where static",
    "start": "2192520",
    "end": "2198000"
  },
  {
    "text": "typing really starts to shine at least static typing in the language that we're working with which is Scala um if you",
    "start": "2198000",
    "end": "2204960"
  },
  {
    "text": "can say to your type system hey this is what my data looks like it only looks like this this is how my data relates to",
    "start": "2204960",
    "end": "2211880"
  },
  {
    "text": "this other piece of data you're only allowed to put them together in this sort of way then the type system can slap you on the wrist when you do it",
    "start": "2211880",
    "end": "2218200"
  },
  {
    "text": "wrong and it can slap you on theist really really early um very very very",
    "start": "2218200",
    "end": "2223359"
  },
  {
    "text": "powerful concept so here's another really trivial example of this um this function also only has one",
    "start": "2223359",
    "end": "2229359"
  },
  {
    "start": "2227000",
    "end": "2468000"
  },
  {
    "text": "implementation because we're we're saying if you think about this backwards right so we say we have a function that",
    "start": "2229359",
    "end": "2235400"
  },
  {
    "text": "returns a c well where could we possibly get a c the only place we could get it from is function G right but function G",
    "start": "2235400",
    "end": "2241960"
  },
  {
    "text": "needs a b where could we get a B only from function f well function f needs an a we can only only get an A from the",
    "start": "2241960",
    "end": "2248319"
  },
  {
    "text": "first parameter which means that the only possible implementation of this is the following right G composed with f",
    "start": "2248319",
    "end": "2255240"
  },
  {
    "text": "applied to a um less trivial example fold right fold left function on list um",
    "start": "2255240",
    "end": "2262920"
  },
  {
    "text": "this is a function that takes not just one not two but three parameters set that one of them is hidden because we're",
    "start": "2262920",
    "end": "2269400"
  },
  {
    "text": "object oriented um so it takes a list a list of a it takes a b and it takes a",
    "start": "2269400",
    "end": "2275640"
  },
  {
    "text": "function from B and A to be right three parameters um that's more than triple",
    "start": "2275640",
    "end": "2282200"
  },
  {
    "text": "the number of bugs I am going to claim um but because this this function is",
    "start": "2282200",
    "end": "2288400"
  },
  {
    "text": "polymorphic because this function is defined for all a and for all B we can",
    "start": "2288400",
    "end": "2293920"
  },
  {
    "text": "bring arguments with parametricity into play right we can argue that there are only a few number of implementations a",
    "start": "2293920",
    "end": "2301680"
  },
  {
    "text": "few number of ways that we can do this function and all of them end up leading us into a essentially cases that are",
    "start": "2301680",
    "end": "2308560"
  },
  {
    "text": "definitionally correct so the most obvious way that we can implement this function is to just return the value",
    "start": "2308560",
    "end": "2315640"
  },
  {
    "text": "that we're given right so we have to return a b we have to get that B from somewhere we can get that B from two",
    "start": "2315640",
    "end": "2320880"
  },
  {
    "text": "places right we can get it from the value that we're given and we can get it from the return result of the function",
    "start": "2320880",
    "end": "2326160"
  },
  {
    "text": "so we just ignore the function return the value right very very straightforward but um this represents",
    "start": "2326160",
    "end": "2333280"
  },
  {
    "text": "this correctly represents in fact the empty sequence the empty list if you implement all of the functions in list",
    "start": "2333280",
    "end": "2340560"
  },
  {
    "text": "on top of fold left which in fact you can then if your fold left is implemented in this way all of your",
    "start": "2340560",
    "end": "2346920"
  },
  {
    "text": "lists are empty all the time regardless of what data you put into them um that seems useful",
    "start": "2346920",
    "end": "2353520"
  },
  {
    "text": "um so maybe maybe we don't want to have the empty sequence right maybe we want to do something more than that well",
    "start": "2353520",
    "end": "2359040"
  },
  {
    "text": "where else could we get a B from well we could get it from the function right but the function takes a b which in turn we",
    "start": "2359040",
    "end": "2366000"
  },
  {
    "text": "have to get from somewhere um and some other element a which I I mean we have to get that from somewhere too all right",
    "start": "2366000",
    "end": "2373319"
  },
  {
    "text": "so we you know we have to we have to get an A from somewhere and the only way we can get an A is get it out of the",
    "start": "2373319",
    "end": "2381200"
  },
  {
    "text": "list the only place we can get an A is to get it out a list because our list is a list of a and we have no other sources",
    "start": "2381200",
    "end": "2387720"
  },
  {
    "text": "of A's this is the sort of constraining argument that parametricity thrives on right whenever you find yourself in the",
    "start": "2387720",
    "end": "2393200"
  },
  {
    "text": "situation where you're like hey I need a this I can only get it from here parametric is going to be a really powerful tool um so we need to get it",
    "start": "2393200",
    "end": "2400440"
  },
  {
    "text": "out of the list well a list is one of two cases right it's either a conell which has this a in it that we need so",
    "start": "2400440",
    "end": "2406760"
  },
  {
    "text": "much or it's a nil which doesn't have an A in it at all so what could the only possible implementation in the nil case",
    "start": "2406760",
    "end": "2412960"
  },
  {
    "text": "be well return the B that's the only possible thing we could do there um in",
    "start": "2412960",
    "end": "2418640"
  },
  {
    "text": "the notnil case we could you know apply our function and in fact we do here and then just return this represents a",
    "start": "2418640",
    "end": "2424520"
  },
  {
    "text": "sequence of length one so if as soon as you start applying this argument inductively you see how fold left is",
    "start": "2424520",
    "end": "2431440"
  },
  {
    "text": "really really constrained in what it can do right it can basically permute any of the elements that are",
    "start": "2431440",
    "end": "2437839"
  },
  {
    "text": "inside of the list right because that's where it's getting A's from and we don't distinguish between the elements so it can take the first element and repeat it",
    "start": "2437839",
    "end": "2444160"
  },
  {
    "text": "like as many times as it wants or it can Shuffle around the elements like it doesn't have to fold left's type",
    "start": "2444160",
    "end": "2449960"
  },
  {
    "text": "signature says nothing about the order that it does things in but it does say where you can get data which is a heck",
    "start": "2449960",
    "end": "2456520"
  },
  {
    "text": "of a lot more constraining than if we just have some random function hanging out there that claims to give us a value",
    "start": "2456520",
    "end": "2462359"
  },
  {
    "text": "of some type that we don't understand um once you start seeing things in terms",
    "start": "2462359",
    "end": "2468079"
  },
  {
    "text": "of parametricity you start seeing these arguments jumping out pretty much everywhere right look at the map function map takes a list of a and a",
    "start": "2468079",
    "end": "2475000"
  },
  {
    "text": "function from A to B and returns a list of B well how the heck are we going to get a list of B except by applying the",
    "start": "2475000",
    "end": "2481480"
  },
  {
    "text": "function from A to B right what list list. empty yes so you could return nil",
    "start": "2481480",
    "end": "2488440"
  },
  {
    "text": "that's that's a good point I should have used non-empty list because that would have made a more compelling",
    "start": "2488440",
    "end": "2494400"
  },
  {
    "text": "argument um well you have to get your first B somewhere as as it could be twice as long yeah yeah so clearly this",
    "start": "2494400",
    "end": "2500880"
  },
  {
    "text": "type signature parametricity tells us nothing about length tells us nothing about permutation you know it doesn't give us that information um but it does",
    "start": "2500880",
    "end": "2508040"
  },
  {
    "text": "give us some really really strong guarantees about where data can come from if you have data at",
    "start": "2508040",
    "end": "2514040"
  },
  {
    "text": "all um partition is the same way right so now we have a function from a to Boolean o artificial algebra um okay but",
    "start": "2514040",
    "end": "2522240"
  },
  {
    "text": "you know in this case we kind of have an artificial algebra right are we on the left hand side or the right hand side of a um of a pair kind of makes sense um",
    "start": "2522240",
    "end": "2530560"
  },
  {
    "text": "there's very few ways that you can write this because there's only like you can get a from where you can get it from",
    "start": "2530560",
    "end": "2535920"
  },
  {
    "text": "yourself and nowhere else zip is the same way length is not like this length",
    "start": "2535920",
    "end": "2542240"
  },
  {
    "text": "returns an INT how many different inss could it return four and a half some odd billion",
    "start": "2542240",
    "end": "2547680"
  },
  {
    "text": "um that's okay there is nothing that",
    "start": "2547680",
    "end": "2552760"
  },
  {
    "text": "constrains this length function in any way it can return math. random we don't know um so this is this is an example of",
    "start": "2552760",
    "end": "2560559"
  },
  {
    "text": "of kind of the limits of parametricity and why it is that polymorphic functions are so great because not only can you",
    "start": "2560559",
    "end": "2567720"
  },
  {
    "text": "apply them to any data right because it's for all um but they also give you",
    "start": "2567720",
    "end": "2573119"
  },
  {
    "text": "really really strong guarantees so with parametric it's okay to write higher order and",
    "start": "2573119",
    "end": "2579160"
  },
  {
    "text": "higher erity functions right functions that take multiple data because we can",
    "start": "2579160",
    "end": "2585000"
  },
  {
    "text": "constrain how they are related together we can control what the meaning and the relationships between your types are um",
    "start": "2585000",
    "end": "2591720"
  },
  {
    "text": "but you can only do this if your functions are polymorphic length didn't work right we couldn't make these",
    "start": "2591720",
    "end": "2597119"
  },
  {
    "text": "arguments about length um the big concept the the notion that a lot of this is predicated on is that data can",
    "start": "2597119",
    "end": "2603920"
  },
  {
    "text": "really only come from one place if you're saying that this works over for all a then you can't just make up an",
    "start": "2603920",
    "end": "2610040"
  },
  {
    "text": "arbitrary a that came from The Ether over here um with parametricity we",
    "start": "2610040",
    "end": "2616200"
  },
  {
    "text": "basically learn that if you can't constrain your data if you can't confine it to be a certain thing well constrain",
    "start": "2616200",
    "end": "2623720"
  },
  {
    "text": "where it comes from and constrain where it's going right build your constraints and encode them in such a way that the",
    "start": "2623720",
    "end": "2630000"
  },
  {
    "text": "type system can help you and be very very very suspicious of concrete types",
    "start": "2630000",
    "end": "2636319"
  },
  {
    "text": "anything that's an or a string or something like that that's not generic is very very very worrisome and you",
    "start": "2636319",
    "end": "2643680"
  },
  {
    "text": "should suspect bugs whenever you see that so data flow not control flow",
    "start": "2643680",
    "end": "2649599"
  },
  {
    "start": "2648000",
    "end": "2737000"
  },
  {
    "text": "transform your control flow into data flow if you have to using monads or by some other means because it will be much",
    "start": "2649599",
    "end": "2656400"
  },
  {
    "text": "much more helpful don't go through data indirection right don't get the length",
    "start": "2656400",
    "end": "2662680"
  },
  {
    "text": "of a list when really what you want are the contents don't encode things a string and then decode them later",
    "start": "2662680",
    "end": "2668839"
  },
  {
    "text": "because read compos show is is so great um constrain your representations only",
    "start": "2668839",
    "end": "2674760"
  },
  {
    "text": "allow people to do what you want what you specifically want your data to be used as very very very important choose",
    "start": "2674760",
    "end": "2682280"
  },
  {
    "text": "your representations very carefully and you will limit the space in which bugs can occur and",
    "start": "2682280",
    "end": "2689040"
  },
  {
    "text": "finally be as generic as you possibly can specific types are bad specific",
    "start": "2689040",
    "end": "2695559"
  },
  {
    "text": "types cause bugs specific specific types cause people to make assumptions that they shouldn't make don't be specific be",
    "start": "2695559",
    "end": "2700839"
  },
  {
    "text": "generic don't let people know what your types are be very very very generic and it will pay off in the end because you",
    "start": "2700839",
    "end": "2706000"
  },
  {
    "text": "won't have as many bugs um we are essentially out of time um I don't",
    "start": "2706000",
    "end": "2712200"
  },
  {
    "text": "think very quickly what would be the four topic what would be the four I was going to talk about resources and linear",
    "start": "2712200",
    "end": "2719240"
  },
  {
    "text": "typing so that was going to be really fun but it didn't happen all right thank",
    "start": "2719240",
    "end": "2725119"
  },
  {
    "text": "you very much",
    "start": "2725119",
    "end": "2728480"
  }
]