[
  {
    "start": "0",
    "end": "61000"
  },
  {
    "text": "[Music]",
    "start": "530",
    "end": "9120"
  },
  {
    "text": "what's up guys this is Dan from Marana and I'm going to be talking to you today about monads in the schola language now",
    "start": "12080",
    "end": "17680"
  },
  {
    "text": "am monad is H is a concept that's probably going to be relatively unfamiliar to most uh to most folks that",
    "start": "17680",
    "end": "23439"
  },
  {
    "text": "uh that come from a uh procedural or an object oriented programming background um but it shouldn't be too scary area",
    "start": "23439",
    "end": "30240"
  },
  {
    "text": "term uh it's uh it's it's essentially a kind of a design pattern um and design patterns is something that we use all",
    "start": "30240",
    "end": "36640"
  },
  {
    "text": "the time in uh object oriented programming let's say so you know for example your adapter pattern or",
    "start": "36640",
    "end": "42840"
  },
  {
    "text": "composite pattern or or or strategy pattern what have you you can think of what I'm about to introduce here as sort",
    "start": "42840",
    "end": "48760"
  },
  {
    "text": "of the the monad design pattern and uh it's something that ends up being used fairly commonly uh in in functional",
    "start": "48760",
    "end": "55120"
  },
  {
    "text": "programming and and scolar in particular um so we're going to start with an example here the motivation basically is",
    "start": "55120",
    "end": "62320"
  },
  {
    "start": "61000",
    "end": "61000"
  },
  {
    "text": "is to try to declutter this uh this code so what do we got on left hand side we've got uh three classes Fu bar and",
    "start": "62320",
    "end": "69320"
  },
  {
    "text": "baz uh so from from Fu you can get a bar from bar you can get a baz and from baz",
    "start": "69320",
    "end": "75040"
  },
  {
    "text": "you can compute some value we don't really care what what the computation does just the idea is that you want to",
    "start": "75040",
    "end": "81320"
  },
  {
    "text": "be able to given a foo get its bar get the baz from that and then compute um",
    "start": "81320",
    "end": "88479"
  },
  {
    "text": "but the uh the monkey wrench that we're going to throw into the works here is that uh that any of these methods uh get",
    "start": "88479",
    "end": "94960"
  },
  {
    "text": "bar or get B could potentially return null and in fact uh let's say the food that you start with could also be null",
    "start": "94960",
    "end": "101560"
  },
  {
    "text": "so on the right hand side you see sort of the typical uh strategy for for for coping with that the possibility of null",
    "start": "101560",
    "end": "107920"
  },
  {
    "text": "or you know possibility of failed computations or you know failed intermediate computations um is you check for null so",
    "start": "107920",
    "end": "115119"
  },
  {
    "text": "you say if Fu equals null then let's break out early and return null um otherwise we keep going if the bar",
    "start": "115119",
    "end": "122000"
  },
  {
    "text": "that we get from food. get bar is null then again we break out early and so on",
    "start": "122000",
    "end": "127119"
  },
  {
    "text": "uh and at the end of the day we're able to return the the the the value that baz computed um the other thing that you",
    "start": "127119",
    "end": "133360"
  },
  {
    "text": "notice of course is that is that our compute method here returns an a capital I integer uh object rather than a uh an",
    "start": "133360",
    "end": "141120"
  },
  {
    "text": "unboxed int because again we're representing the possibility of a failure in this in this computation so",
    "start": "141120",
    "end": "147760"
  },
  {
    "text": "you know this is fairly cluttered code here um it's a pattern people are familiar with so you sort of come to expect it but uh you know you really",
    "start": "147760",
    "end": "155720"
  },
  {
    "text": "have to have to squint a little bit to to to picture that the intent really is to say f.g bar. get. compute and not not",
    "start": "155720",
    "end": "163599"
  },
  {
    "text": "have to worry so much about all the null checks okay uh so another another",
    "start": "163599",
    "end": "168760"
  },
  {
    "text": "possible style that you might see uh to to try to deal with the possibility of null instead of uh instead of doing the",
    "start": "168760",
    "end": "174760"
  },
  {
    "text": "early returns to break out this is even more verbose uh although a little bit more sort of functional looking um is is",
    "start": "174760",
    "end": "182920"
  },
  {
    "text": "using these nested ifs uh so you know instead of saying if Fu equals null return early let's let's",
    "start": "182920",
    "end": "190159"
  },
  {
    "text": "just say well if f is not equal to null then then we'll proceed into our logic and so the innermost part of our logic",
    "start": "190159",
    "end": "196040"
  },
  {
    "text": "is we're returning returning the value of b. compute but you know then of course we we break out into the series",
    "start": "196040",
    "end": "202120"
  },
  {
    "text": "of El's where we have to return null each time again so it's essentially equivalent code and we really don't like",
    "start": "202120",
    "end": "209000"
  },
  {
    "text": "that all that much either so in Scala using uh you know basically the same",
    "start": "209000",
    "end": "215080"
  },
  {
    "text": "sort of a Java style you can see if I flip back and forth here these look basically",
    "start": "215080",
    "end": "221879"
  },
  {
    "text": "identical and uh really we're just as unhappy with that this is a pure",
    "start": "221879",
    "end": "227000"
  },
  {
    "text": "functional uh technique here there's no there's no immutable uh there's no",
    "start": "227000",
    "end": "232040"
  },
  {
    "text": "mutable State there's no early returns but it's still ugly it's still hard to read so what we're going to do now is is",
    "start": "232040",
    "end": "240200"
  },
  {
    "text": "is try to introduce the concept of a monad to deal with the the the sort of conflated concerns in that code all",
    "start": "240200",
    "end": "245680"
  },
  {
    "start": "243000",
    "end": "243000"
  },
  {
    "text": "right so what's a monad a monad is basically something that has this shape here and notice that uh that there is no",
    "start": "245680",
    "end": "253079"
  },
  {
    "text": "there isn't actually a trait monad uh in the uh in the Scola standard or standard",
    "start": "253079",
    "end": "258120"
  },
  {
    "text": "libraries that you can that you can inherit from it it's just if you want to write something that has this monatic",
    "start": "258120",
    "end": "264400"
  },
  {
    "text": "design pattern it's going to it's going to have this following shape and the idea of a monad b basically is to",
    "start": "264400",
    "end": "270280"
  },
  {
    "text": "provide uh like I say here a standard interface for composing or or sequencing",
    "start": "270280",
    "end": "275680"
  },
  {
    "text": "operations on some value that's contained in the monad so so let's say that this monad contains some some value",
    "start": "275680",
    "end": "282520"
  },
  {
    "text": "a some some value of type A then uh the monad provides a method map and keep in",
    "start": "282520",
    "end": "289479"
  },
  {
    "text": "mind this is functional programming so this is going to be a higher order method here because it's taking a",
    "start": "289479",
    "end": "295400"
  },
  {
    "text": "function as an argument the function is going to be able to like we say map from",
    "start": "295400",
    "end": "300840"
  },
  {
    "text": "some value of type A to a new value of type B what that'll give us is a monad",
    "start": "300840",
    "end": "306479"
  },
  {
    "text": "containing our new value of type B flat map is a little a little bit more oddly named and a little bit later on uh",
    "start": "306479",
    "end": "313000"
  },
  {
    "text": "you'll see why it's called that but essentially it's it's fairly similar we've got our contained value a and",
    "start": "313000",
    "end": "319360"
  },
  {
    "text": "we're going to uh take a function again higher higher order uh method here um",
    "start": "319360",
    "end": "325639"
  },
  {
    "text": "we're going to take a function that translates A's into already wrapped",
    "start": "325639",
    "end": "331080"
  },
  {
    "text": "monads of type B and then return return some monad of type",
    "start": "331080",
    "end": "336919"
  },
  {
    "text": "B um so we're going to call that a monatic function that's that's being passed in the flat map so in particular",
    "start": "336919",
    "end": "344440"
  },
  {
    "text": "to deal with uh to deal with this sort of code bloat that we saw in our our initial example we're going to introduce the option",
    "start": "344440",
    "end": "350680"
  },
  {
    "text": "monad the idea of the option monad is is to is to basically encapsulate the idea",
    "start": "350680",
    "end": "356080"
  },
  {
    "start": "351000",
    "end": "351000"
  },
  {
    "text": "of possible failure in a type rather rather than just saying okay well you know this this thing could be null or",
    "start": "356080",
    "end": "362199"
  },
  {
    "text": "not null so the two possible concrete classes that implement this option trait are called sum and none uh so you can",
    "start": "362199",
    "end": "369800"
  },
  {
    "text": "see sum has some value a and none has nothing special and what we want to try",
    "start": "369800",
    "end": "375599"
  },
  {
    "text": "to do is Define appropriate map and Flat map uh for both of these for both of",
    "start": "375599",
    "end": "381199"
  },
  {
    "text": "these cases so here's how this is going to look option is of the shape that we want",
    "start": "381199",
    "end": "386639"
  },
  {
    "text": "what we had seen before was we were going to have a monac of some type A provide a map and a flat",
    "start": "386639",
    "end": "393039"
  },
  {
    "text": "map Each of which have the shape where map map is taking a regular function flat map is taking a monatic function",
    "start": "393039",
    "end": "398759"
  },
  {
    "text": "and both return a new monad in this case option so we want to actually uh Implement these in our in our two case",
    "start": "398759",
    "end": "405160"
  },
  {
    "text": "classes so sum has the following implementation map",
    "start": "405160",
    "end": "410639"
  },
  {
    "text": "basically takes takes a function f applies it to the value a and then",
    "start": "410639",
    "end": "418120"
  },
  {
    "text": "wraps that up in a new sum and flat map the implementation is even simpler we don't have to wrap anything",
    "start": "418120",
    "end": "424319"
  },
  {
    "text": "up we we've got our value a and the monatic function gives us an option of B so we'll just apply that directly now",
    "start": "424319",
    "end": "432039"
  },
  {
    "text": "for uh for the next case our nun case it's a little bit more it's a little bit",
    "start": "432039",
    "end": "437240"
  },
  {
    "text": "more interesting it's it's very straightforward but it's but it's kind of cute if we have a nonone value in other words value representing",
    "start": "437240",
    "end": "443160"
  },
  {
    "text": "essentially null or a failed computation when we apply some function to that the map what we would expect to",
    "start": "443160",
    "end": "451599"
  },
  {
    "text": "happen is we still have null you know we still have a failed computation we're not going to pull a successful value out",
    "start": "451599",
    "end": "458000"
  },
  {
    "text": "of thin air right um and similarly with flatmap even if the flat map or even if",
    "start": "458000",
    "end": "463840"
  },
  {
    "text": "the function provided is you know again somehow able to pull a successful option",
    "start": "463840",
    "end": "470280"
  },
  {
    "text": "of be's out of thin air still we have no a we we have no value for a so so we're just going to return",
    "start": "470280",
    "end": "476960"
  },
  {
    "text": "none and you'll see in a second how this has some some interesting",
    "start": "476960",
    "end": "482039"
  },
  {
    "text": "consequences one point I wanted to just throw in here is that the standard Scala option class is implemented slightly",
    "start": "482039",
    "end": "488520"
  },
  {
    "text": "differently but at the end of the day uh the way that they work is going to be the same so going back to going back to",
    "start": "488520",
    "end": "495000"
  },
  {
    "text": "our our initial example here we want to compute now instead of an integer you",
    "start": "495000",
    "end": "500639"
  },
  {
    "text": "know capital I integer that could be potentially n let let's let's instead say that we're going to explicitly",
    "start": "500639",
    "end": "506000"
  },
  {
    "text": "represent the possibility of failure with this option let's say wrapper so",
    "start": "506000",
    "end": "511720"
  },
  {
    "text": "the possibility that our fu. bar could return you know could could not have a",
    "start": "511720",
    "end": "517240"
  },
  {
    "text": "bar to return we're going to say okay this is going to return an option of bar which basically says well maybe we'll",
    "start": "517240",
    "end": "522560"
  },
  {
    "text": "get one or maybe not similar with bars baz and then baz its definition of",
    "start": "522560",
    "end": "528200"
  },
  {
    "text": "compute again that's just going to return a straight end the competition let's say will always be successful and what we want to do is Define our our new",
    "start": "528200",
    "end": "536279"
  },
  {
    "text": "compute that's taking maybe a fu or maybe nothing and return maybe an",
    "start": "536279",
    "end": "542600"
  },
  {
    "text": "integer or maybe nothing so let's break this down let's say let's sort of start from the inside out let's say that we've",
    "start": "542600",
    "end": "548920"
  },
  {
    "text": "got a Bas and we want to compute an integer so that one's going to be pretty",
    "start": "548920",
    "end": "554720"
  },
  {
    "text": "straightforward uh this compute bass is going to have type int and it's just going to call b. compute so that's",
    "start": "554720",
    "end": "560600"
  },
  {
    "text": "that's pretty easy now for the next step let's say well let's say we're given a bar and we",
    "start": "560600",
    "end": "566880"
  },
  {
    "text": "want to compute the the uh the result from that and we'll use our our previous",
    "start": "566880",
    "end": "572000"
  },
  {
    "text": "definition here of compute baz well that's going to have type option event because it could fail and",
    "start": "572000",
    "end": "579440"
  },
  {
    "text": "again to Define things in terms of our options map and Flat map what we can what we can see is that bar. baz could",
    "start": "579440",
    "end": "586920"
  },
  {
    "text": "potentially fail and compute baz since since that's a function that goes from",
    "start": "586920",
    "end": "592680"
  },
  {
    "text": "remember we were talking in terms of uh you know mon monads to transform from some type A to Some Type B well here",
    "start": "592680",
    "end": "599000"
  },
  {
    "text": "we're transforming from some type baz to some type int that's that's what that's",
    "start": "599000",
    "end": "604079"
  },
  {
    "text": "the shape of compute B so so we can say bar. b. map compute baz now let's uh",
    "start": "604079",
    "end": "610320"
  },
  {
    "text": "let's try to fill in the next blank we want to do compute Fu and again this is going to probably return an option of in",
    "start": "610320",
    "end": "615560"
  },
  {
    "text": "again it's the possibility of failure and how do we fill this in well the the the tool that we just that we just",
    "start": "615560",
    "end": "621440"
  },
  {
    "text": "developed was a method that takes a bar and an option of in and that's you",
    "start": "621440",
    "end": "627760"
  },
  {
    "text": "recognize that uh from our definition before that's a monatic function it's it's returning not just a straight in",
    "start": "627760",
    "end": "633320"
  },
  {
    "text": "it's returning an option of int so what we'll do here is say food. bar which gives us an option and call flat map on",
    "start": "633320",
    "end": "640079"
  },
  {
    "text": "that with compute bar and then finally we can uh we can Define our compute",
    "start": "640079",
    "end": "645760"
  },
  {
    "text": "overall uh similarly uh saying you know we'll take our maybe Fu and flatmap compute Fu on",
    "start": "645760",
    "end": "652920"
  },
  {
    "text": "that because compute Fu again is a monatic function or monatic method now this is highly verbose here and probably",
    "start": "652920",
    "end": "659320"
  },
  {
    "text": "looks a lot worse than uh than it looked when we were just returning null so let's uh let's collapse this a little",
    "start": "659320",
    "end": "664720"
  },
  {
    "text": "bit and this is starting to look a little bit more interesting it's it's it's definitely much more condensed and",
    "start": "664720",
    "end": "671839"
  },
  {
    "text": "it's also nice in the sense that uh in the sense that we don't have multiple points from which we can return uh from",
    "start": "671839",
    "end": "678200"
  },
  {
    "text": "this method uh you know either return a value or return null but this is fairly hard to read so we're going to uh take a",
    "start": "678200",
    "end": "685680"
  },
  {
    "text": "take a look at a couple more examples and then come back to this one if example two here is let's say instead of",
    "start": "685680",
    "end": "692240"
  },
  {
    "start": "689000",
    "end": "689000"
  },
  {
    "text": "returning null from our get bar and get B let's say if we if we get a value back",
    "start": "692240",
    "end": "698720"
  },
  {
    "text": "out let's say that that value is always real but if for some reason we don't have a bar in Fu or we don't have a baz",
    "start": "698720",
    "end": "705800"
  },
  {
    "text": "in bar let's say that can throw an exception and also uh just to to throw an additional kind of twist into things",
    "start": "705800",
    "end": "712200"
  },
  {
    "text": "let's say the compute can also throw an exception so the easy way to do this uh if we were in Java is to literally say",
    "start": "712200",
    "end": "719000"
  },
  {
    "text": "you know f.g bar. gb.com compute and just accept that that well you know if",
    "start": "719000",
    "end": "724480"
  },
  {
    "text": "any of these throw an exception we're just going to propagate this out and and just declare that our compute method",
    "start": "724480",
    "end": "730760"
  },
  {
    "text": "will throw an exception and that's that's all well and good but it's it's a little bit uh sloppy engineering style",
    "start": "730760",
    "end": "736440"
  },
  {
    "text": "in terms of uh in terms of well you know you probably want to be a bit more informative about what kind of exception",
    "start": "736440",
    "end": "742760"
  },
  {
    "text": "it was and where it came from um what caused it perhaps so let's uh let's",
    "start": "742760",
    "end": "748399"
  },
  {
    "text": "let's expand on this just a little bit to give ourselves a bit more of an engineering challenge and say that uh say that if if Fu get bar throws",
    "start": "748399",
    "end": "757160"
  },
  {
    "text": "something we're going to actually throw something specific a get bar exception and similarly with bar if if get baz",
    "start": "757160",
    "end": "762959"
  },
  {
    "text": "fails we're going to throw a get baz exception and if a compute fails we're going to throw a compute exception so",
    "start": "762959",
    "end": "769360"
  },
  {
    "text": "now things are starting to look a fair amount uglier we've got some uh some TR catches and we could split this up a",
    "start": "769360",
    "end": "775399"
  },
  {
    "text": "bunch of different ways but but here's one possible way we have one Tri block um again of course this could be nested",
    "start": "775399",
    "end": "782279"
  },
  {
    "text": "triy blocks where we try food. get bar and then you know try bar. get baz and so on but the point of course is that as",
    "start": "782279",
    "end": "789680"
  },
  {
    "text": "we try to not lose any information about the failure that happened we have to do some work we have to we have to wrap up",
    "start": "789680",
    "end": "797440"
  },
  {
    "text": "our bar exception in a compute exception wrap up the baz exception in a compute exception and so on and in fact I still",
    "start": "797440",
    "end": "803279"
  },
  {
    "text": "cut some Corners here because I'm still uh not catching the compute exception to",
    "start": "803279",
    "end": "808639"
  },
  {
    "text": "do something with that I'm just letting that flow directly out from uh from compute so this is still fairly sloppy",
    "start": "808639",
    "end": "814800"
  },
  {
    "text": "and even so it's uh it's clumsy so I'm going to introduce a new monad that's uh",
    "start": "814800",
    "end": "820320"
  },
  {
    "text": "that's similar to the option monad uh we're going to call this one validation this is going to be somewhat",
    "start": "820320",
    "end": "825959"
  },
  {
    "start": "825000",
    "end": "825000"
  },
  {
    "text": "drinking from the fire host here so uh so you may want to pause the video at this point and uh and kind of scratch",
    "start": "825959",
    "end": "831440"
  },
  {
    "text": "your head over this just a little bit but uh but I'll walk you through it pretty quick this is going to be very similar to option in the sense that",
    "start": "831440",
    "end": "837880"
  },
  {
    "text": "there is a trait that we Define and there are two cases one case representing success and another case",
    "start": "837880",
    "end": "845120"
  },
  {
    "text": "representing failure in this case we're defining map and Flat map fairly similarly and I'm going to not talk",
    "start": "845120",
    "end": "851600"
  },
  {
    "text": "about lift fail for a second that's a third method I've provided in here uh but I just hold that thought map and",
    "start": "851600",
    "end": "857120"
  },
  {
    "text": "Flat map on the success case actually looks very similar to to what it looked",
    "start": "857120",
    "end": "863920"
  },
  {
    "text": "like in the sum case of the option monad that is when we call and provided a a",
    "start": "863920",
    "end": "870920"
  },
  {
    "text": "normal function from A's to B's we're going to apply that function to the contained value or contained",
    "start": "870920",
    "end": "877759"
  },
  {
    "text": "a and wrap that F of a up in a new success object if we call flat map",
    "start": "877759",
    "end": "884519"
  },
  {
    "text": "that's going to literally just uh just apply f using this this monatic function f to",
    "start": "884519",
    "end": "891120"
  },
  {
    "text": "a and if that succeeds it succeeds if it's if it fails it fails our failure cases is going to be different from none",
    "start": "891120",
    "end": "898519"
  },
  {
    "text": "and the option mon out in the sense that our failure case actually has some information associated with it it has a map method it has a flat map method that",
    "start": "898519",
    "end": "905600"
  },
  {
    "text": "they don't just return none they return a new failure containing some e and I'm",
    "start": "905600",
    "end": "911560"
  },
  {
    "text": "I'm I'm using e to represent exception but this could actually be any type whatsoever uh it doesn't have to be",
    "start": "911560",
    "end": "917240"
  },
  {
    "text": "something that uh that represents a throwable or an exception or what have you now to get back to this lift fail",
    "start": "917240",
    "end": "923720"
  },
  {
    "text": "thing this is uh this is something I I should mention I've I've based this validation monad um implementation here",
    "start": "923720",
    "end": "930440"
  },
  {
    "text": "Loosely on uh the validation uh trait and and case classes from the Scala Zed",
    "start": "930440",
    "end": "936399"
  },
  {
    "text": "Library uh which is very handy I'm not going to talk too much about here but uh really does a good job of of filling in",
    "start": "936399",
    "end": "943480"
  },
  {
    "text": "the blanks in the Scola in the schola standard Library implementation it's it's something that you should definitely consider using or at least",
    "start": "943480",
    "end": "949680"
  },
  {
    "text": "exploring for your for your projects so lift fail is something I've I've borrowed like I say Loosely from from",
    "start": "949680",
    "end": "956040"
  },
  {
    "text": "schola and what it's going to do is say well let's say we have a validation instance of type validation of E and A",
    "start": "956040",
    "end": "964519"
  },
  {
    "text": "so you know with parameterized on some error type and some value type and we",
    "start": "964519",
    "end": "971120"
  },
  {
    "text": "want to be able to use that you know essentially translate that into a validation of the same value type but a",
    "start": "971120",
    "end": "978240"
  },
  {
    "text": "different error type some validation of F and a now just just to point out this",
    "start": "978240",
    "end": "984160"
  },
  {
    "text": "is not something that is part of any sort of standard monata interface but it's something that we're going to need because we're going to need to translate",
    "start": "984160",
    "end": "992160"
  },
  {
    "text": "from our get baz exception and get uh get bar exceptions into compute exception so that we can treat these all",
    "start": "992160",
    "end": "998600"
  },
  {
    "text": "as the same type so under success our implementation of lift fail does nothing",
    "start": "998600",
    "end": "1004000"
  },
  {
    "text": "very interesting because we don't have a failure that we're dealing with but in the failure case where we've where we're",
    "start": "1004000",
    "end": "1009319"
  },
  {
    "text": "not containing a success value we're we're containing some error value then we need to essentially treat that sort",
    "start": "1009319",
    "end": "1015800"
  },
  {
    "text": "of the same thing as map where we create a new failure and apply some some",
    "start": "1015800",
    "end": "1021319"
  },
  {
    "text": "function f that translates from our error Type e to a new error type f to the uh to the contain error value and",
    "start": "1021319",
    "end": "1027959"
  },
  {
    "text": "we'll wrap that up in a new failure object so you'll see how I use this in a second the uh the way that we apply",
    "start": "1027959",
    "end": "1033480"
  },
  {
    "text": "validation Monon ad to uh to our throwing exceptions example is is is",
    "start": "1033480",
    "end": "1039240"
  },
  {
    "text": "like this we uh we do the same the same kind of thing where we say well we're going to flat map on our on our possibility of failure from calling",
    "start": "1039240",
    "end": "1045640"
  },
  {
    "text": "food. bar and we're going to flat map again on our possibility failure from calling bar. baz and incidentally this",
    "start": "1045640",
    "end": "1052919"
  },
  {
    "text": "this is the last thing I was just talking about we're going to make sure that if there are any uh exceptions uh",
    "start": "1052919",
    "end": "1060039"
  },
  {
    "text": "of type bar exception or type as exception or what have you we're going to lift that failure into a new compute",
    "start": "1060039",
    "end": "1066240"
  },
  {
    "text": "exception okay so so cool and this this is definitely more more Compact and more succinct than uh than we had before with",
    "start": "1066240",
    "end": "1072919"
  },
  {
    "text": "our dry catches but it's still pretty hard to read so our final example of the day oh and I I should mention that it's",
    "start": "1072919",
    "end": "1080440"
  },
  {
    "text": "a little bit weird in option we saw basically flat map on the outside flat",
    "start": "1080440",
    "end": "1085720"
  },
  {
    "text": "map in the middle and then map on the inside and here we don't see any map at all we just see two flat Maps so this is",
    "start": "1085720",
    "end": "1092200"
  },
  {
    "text": "a little bit different and it's h it's uh a consequence of my having introduced",
    "start": "1092200",
    "end": "1098400"
  },
  {
    "text": "compute as returning a valid validation of something and int rather than just a",
    "start": "1098400",
    "end": "1103840"
  },
  {
    "text": "straight int so we'll see how how to make this uh consistent with that pattern again in in just a moment all",
    "start": "1103840",
    "end": "1110799"
  },
  {
    "text": "right so our final example of the day we're going to look at it starting in Java first again is this idea of",
    "start": "1110799",
    "end": "1115840"
  },
  {
    "start": "1111000",
    "end": "1111000"
  },
  {
    "text": "non-determinism and this is this is a little bit weird to think about but think about a list as representing not a",
    "start": "1115840",
    "end": "1121720"
  },
  {
    "text": "sequence of values but rather a choice of values so let's say you know if our",
    "start": "1121720",
    "end": "1127400"
  },
  {
    "text": "food. getet bars returns a list of bars that it's actually returning a set of",
    "start": "1127400",
    "end": "1133960"
  },
  {
    "text": "choices of you know bars that we could potentially choose from so it's you know some sort of a Nonet ministic Choice",
    "start": "1133960",
    "end": "1139919"
  },
  {
    "text": "similar with bar. get bazes and b. compute all and the way this ends up looking is going to be something that's",
    "start": "1139919",
    "end": "1146760"
  },
  {
    "text": "again probably very familiar to to a Java developer that's ever written nested Loops is you know you Loop for",
    "start": "1146760",
    "end": "1152840"
  },
  {
    "text": "all the all the foo possibilities out of Foo and then all the bar possibilities out of get bars and so on and and uh the",
    "start": "1152840",
    "end": "1160799"
  },
  {
    "text": "the thing that's a little bit curious here is at the top of the function we've we've instantiated a an empty array list",
    "start": "1160799",
    "end": "1168400"
  },
  {
    "text": "uh to to contain our our result set and as we go through our set of nested Loops",
    "start": "1168400",
    "end": "1173520"
  },
  {
    "text": "what we do is add all of our basda comput alls to that set of aggregated",
    "start": "1173520",
    "end": "1178559"
  },
  {
    "text": "results and then finally return at the end so if you just ignore the fact that we're dealing with a mutable array list",
    "start": "1178559",
    "end": "1183640"
  },
  {
    "text": "here which in functional programming is somewhat Taboo it's it's really not too bad and in Scala it's even somewhat uh",
    "start": "1183640",
    "end": "1192720"
  },
  {
    "text": "somewhat simpler um because that uh that set of nested for Loops turns into one",
    "start": "1192720",
    "end": "1199080"
  },
  {
    "text": "uh for comprehension we call it and so it looks pretty flat here the way that we're seeing we take a foo out of out of",
    "start": "1199080",
    "end": "1204520"
  },
  {
    "text": "our set of foo's we take a bar out of our set of bars and a baz out of our set of bases and our results is is yielded",
    "start": "1204520",
    "end": "1212039"
  },
  {
    "text": "by b. comput all and then what we do is for all of that we just yield our big",
    "start": "1212039",
    "end": "1217440"
  },
  {
    "text": "fat set of results okay so that's kind of cool this is very readable it's even simpler than the Java example which wasn't too bad to begin with so now now",
    "start": "1217440",
    "end": "1224799"
  },
  {
    "text": "the question of course is well what does this have to do with monads we don't see any map or flat map in here and I didn't",
    "start": "1224799",
    "end": "1231120"
  },
  {
    "text": "say okay well you know we're going to solve a problem with the list monad but surprise the for comprehensions are",
    "start": "1231120",
    "end": "1237200"
  },
  {
    "text": "actually a monatic construct so I'm going to show you what that means here and just Define what these four",
    "start": "1237200",
    "end": "1243600"
  },
  {
    "start": "1240000",
    "end": "1240000"
  },
  {
    "text": "comprehensions are somewhat formally so let's say I've got some pattern four and then in Brackets we've got",
    "start": "1243600",
    "end": "1250640"
  },
  {
    "text": "we've got a pattern that's being matched or a variable that's being bound if you want to think about it that way",
    "start": "1250640",
    "end": "1257200"
  },
  {
    "text": "uh coming from some EXP expression some initial expression so you know for bar comes from food. bars for",
    "start": "1257200",
    "end": "1265039"
  },
  {
    "text": "example then we're going to yield e so you know some new expression pertaining probably to uh to the pattern what that",
    "start": "1265039",
    "end": "1272840"
  },
  {
    "text": "actually translates to under the covers this is really just syntactic sugar for our our our call to map so the",
    "start": "1272840",
    "end": "1280640"
  },
  {
    "text": "Assumption here is that this value e0 or you know this expression e0 is of some",
    "start": "1280640",
    "end": "1286360"
  },
  {
    "text": "type that has a method map on it the anonymous function that's passed to",
    "start": "1286360",
    "end": "1292120"
  },
  {
    "text": "it is a function that takes this P this p 0 this variable that's bound and",
    "start": "1292120",
    "end": "1299520"
  },
  {
    "text": "yields our expression e so that's kind of interesting and then similarly if we",
    "start": "1299520",
    "end": "1305120"
  },
  {
    "text": "have a for comprehension that's a that's a whole list of generators pattern zero",
    "start": "1305120",
    "end": "1311240"
  },
  {
    "text": "coming from expression zero pattern one coming from expression one and so on the way that we translate that is well let's",
    "start": "1311240",
    "end": "1318320"
  },
  {
    "text": "let's just break this down into expression 0. flatmap pass that a closure or an anous",
    "start": "1318320",
    "end": "1325400"
  },
  {
    "text": "anonymous function taking our p 0 and then Define the rest recursively in",
    "start": "1325400",
    "end": "1330600"
  },
  {
    "text": "terms of a a new for comprehension on the rest of what was there so you can see that uh that pattern one yielding E1",
    "start": "1330600",
    "end": "1338480"
  },
  {
    "text": "and so on and and the only thing that we've broken out from that is expression zero and pattern zero okay so for",
    "start": "1338480",
    "end": "1345080"
  },
  {
    "text": "comprehensions the way that we've defined monads uh based entirely on flat map and",
    "start": "1345080",
    "end": "1351000"
  },
  {
    "text": "map we can see the four comprehensions operate on any kind of monad so let's get back to this last example that we",
    "start": "1351000",
    "end": "1357159"
  },
  {
    "start": "1355000",
    "end": "1355000"
  },
  {
    "text": "were looking at where we did a for comprehension over uh over a bunch of lists let's now start thinking about",
    "start": "1357159",
    "end": "1363600"
  },
  {
    "text": "this as oh it's the list monad so let's let's uh let's go through our translation process based on our",
    "start": "1363600",
    "end": "1369559"
  },
  {
    "text": "formalization before let's say for Fu comes from Foos well what does that turn into well there's a bunch of generators",
    "start": "1369559",
    "end": "1375159"
  },
  {
    "text": "here so this is going to turn into a flat map so the Foos that we given as as the",
    "start": "1375159",
    "end": "1381440"
  },
  {
    "text": "function argument here we're going to call flat map on that and pass that a closure uh that that takes some Fu and",
    "start": "1381440",
    "end": "1389360"
  },
  {
    "text": "gives us another another nested for comprehension here the way that we're going to translate that is well you know",
    "start": "1389360",
    "end": "1396559"
  },
  {
    "text": "we're going to pick the bar coming from food. bars off and we're going to turn that into another flat map then we look",
    "start": "1396559",
    "end": "1403640"
  },
  {
    "text": "at baz coming from bar. bazes that's going to be another flat map and then finally we've got a for comprehension on",
    "start": "1403640",
    "end": "1410799"
  },
  {
    "text": "the very uh the very inside that has only one generator so that's going to turn into a",
    "start": "1410799",
    "end": "1416799"
  },
  {
    "text": "map so that's kind of cool and we can actually simplify this a little bit because this innermost map is actually",
    "start": "1416799",
    "end": "1422279"
  },
  {
    "text": "just mapping on the identity function so we can just toss that out entirely so",
    "start": "1422279",
    "end": "1427600"
  },
  {
    "text": "that's kind of interesting we've we've we've seen patterns like this now we've seen these series of nested flat maps",
    "start": "1427600",
    "end": "1433120"
  },
  {
    "text": "and Maps so what if we were to take what we've seen here and sort of go in the opposite direction",
    "start": "1433120",
    "end": "1439080"
  },
  {
    "text": "taking our first two examples that had these nested constructs and turning them into for comprehensions all right so our",
    "start": "1439080",
    "end": "1445320"
  },
  {
    "start": "1445000",
    "end": "1445000"
  },
  {
    "text": "first example based on the option monad we had a maybe Fu and we flat mapped on",
    "start": "1445320",
    "end": "1450919"
  },
  {
    "text": "that we got maybe a bar flat mapped on that and uh and then finally we flat",
    "start": "1450919",
    "end": "1456000"
  },
  {
    "text": "mapped on the baz got b. compute so let's let's sort of fold this back up into a for comprehension so starting",
    "start": "1456000",
    "end": "1462039"
  },
  {
    "text": "from the inside out let's say map all right so we know that's going to be some for comprehension with one generator",
    "start": "1462039",
    "end": "1468159"
  },
  {
    "text": "this flat map is going to now be a for comprehension with two",
    "start": "1468159",
    "end": "1474640"
  },
  {
    "text": "generators and the outermost flat map is going to be another for",
    "start": "1475159",
    "end": "1480559"
  },
  {
    "text": "comprehension with three generators so that was pretty cool we'll",
    "start": "1480559",
    "end": "1487760"
  },
  {
    "start": "1485000",
    "end": "1485000"
  },
  {
    "text": "uh we'll we'll see that again in just a second so we went from we went from this case where we've got this whole nested",
    "start": "1487760",
    "end": "1493880"
  },
  {
    "text": "series of of if uh if El's returning null at each step which really conflates",
    "start": "1493880",
    "end": "1499720"
  },
  {
    "text": "the concerns of doing your actual computation food I get bar I get be. compute with the fact that we have to",
    "start": "1499720",
    "end": "1506919"
  },
  {
    "text": "deal with this possibility of failure and we've really slimmed it down into this this very uh this very uh fairly",
    "start": "1506919",
    "end": "1514120"
  },
  {
    "text": "fairly slick little little bit of code where we say well let's get a foo let's get a bar let's get a baz and compute",
    "start": "1514120",
    "end": "1520640"
  },
  {
    "text": "that and the fact that we're coping with this you know the fact that these are",
    "start": "1520640",
    "end": "1526240"
  },
  {
    "text": "optional that we could you know return none instead of some",
    "start": "1526240",
    "end": "1532080"
  },
  {
    "text": "in is is really doing a good good job at separating concerns the option moment out is en encapsulating that uh that",
    "start": "1532080",
    "end": "1538919"
  },
  {
    "text": "coping mechanism uh we can do the same thing where with our our validation one out",
    "start": "1538919",
    "end": "1545399"
  },
  {
    "start": "1542000",
    "end": "1542000"
  },
  {
    "text": "example uh we can take these uh these flat maps and uh I I also promised that",
    "start": "1545399",
    "end": "1552039"
  },
  {
    "text": "we were going to make this more consistent with uh with the option example that we had seen previously",
    "start": "1552039",
    "end": "1557960"
  },
  {
    "text": "remember how I mentioned just a minute ago that if we're mapping the identity function we don't have to include that",
    "start": "1557960",
    "end": "1564880"
  },
  {
    "text": "in a map well let's just for the sake of it throw it back in So now this looks like the pattern",
    "start": "1564880",
    "end": "1572000"
  },
  {
    "text": "that we're used to we can say okay well this this map is a for comprehension with one generator and and so on until",
    "start": "1572000",
    "end": "1578840"
  },
  {
    "text": "we get this series of generators all in one for comprehension and the fact that uh that",
    "start": "1578840",
    "end": "1584880"
  },
  {
    "text": "food. bar and food. baz are giving us different error cases they're giving us a uh get bar exception and a get baz",
    "start": "1584880",
    "end": "1592080"
  },
  {
    "text": "exception the fact that we have to convert those into compute exceptions it doesn't take a whole lot of typing here",
    "start": "1592080",
    "end": "1598080"
  },
  {
    "text": "we just say well you know we're going to lift that into the particular monad type that we care about here which is a",
    "start": "1598080",
    "end": "1603679"
  },
  {
    "text": "validation of compute exception and int and so you can see this this looks very similar to what we saw",
    "start": "1603679",
    "end": "1610679"
  },
  {
    "text": "before so I'm going to close out here with a bit of a Roundup and summarize by saying",
    "start": "1610679",
    "end": "1616840"
  },
  {
    "start": "1614000",
    "end": "1614000"
  },
  {
    "text": "basically that am monad is a a pattern that that captures policies for function application and composition meaning the",
    "start": "1616840",
    "end": "1623760"
  },
  {
    "text": "policy in the case of option was to propagate failure the policy in in the case of the list monad was to basically",
    "start": "1623760",
    "end": "1631520"
  },
  {
    "text": "do the equivalent of nested for Loops do the the cartisian product of all of the lists combined so that's the policy and",
    "start": "1631520",
    "end": "1638399"
  },
  {
    "text": "we and we basically hide that or wrap that up in inside our our map and Flat map and then as sort of syntactic sugar",
    "start": "1638399",
    "end": "1645600"
  },
  {
    "text": "that helps us make this make this look really pretty comprehensions provide this sequential looking syntax and it's",
    "start": "1645600",
    "end": "1652520"
  },
  {
    "text": "all done on top of map and Flat map so we're going to we're going to see this this pattern fairly frequently some",
    "start": "1652520",
    "end": "1659279"
  },
  {
    "text": "monad making something explicit in the type system while hiding something else so in in the option case we're making",
    "start": "1659279",
    "end": "1666360"
  },
  {
    "text": "the possibility of failure or the possibility of missing data explicit by saying oh we have an option of int while",
    "start": "1666360",
    "end": "1673919"
  },
  {
    "text": "hiding all of the boilerplate if non null logic that's very convenient simp ilarly with validation from from Scala",
    "start": "1673919",
    "end": "1680279"
  },
  {
    "text": "Ed we make the possibility of Errors explicit and the errors of course have some type and some value but we hide the",
    "start": "1680279",
    "end": "1686919"
  },
  {
    "text": "boiler play TR catch logic we also saw the listm ad which makes this possibility of non-determinism or the",
    "start": "1686919",
    "end": "1693159"
  },
  {
    "text": "possibility of having to deal with a bunch of different combinations explicit in the type system and we hide all this",
    "start": "1693159",
    "end": "1699640"
  },
  {
    "text": "boilerplate of nested for Loops but there's other monads that we haven't gotten a chance to look at here and I'd",
    "start": "1699640",
    "end": "1705679"
  },
  {
    "text": "encourage everybody to play around with these uh sort of an exercise for the reader there's some really great kind of",
    "start": "1705679",
    "end": "1711039"
  },
  {
    "text": "wacky monads out there that end up helping helping encapsulate other concerns so the state monad and uh and",
    "start": "1711039",
    "end": "1718200"
  },
  {
    "text": "sort of an extension a logical extension on that the undo monad make the presence of mutable state in an algorithm the",
    "start": "1718200",
    "end": "1724519"
  },
  {
    "text": "idea that for for each sequential function call you might actually get a different result given the same arguments just because there's some",
    "start": "1724519",
    "end": "1731120"
  },
  {
    "text": "there's some State that's being modified in the background it's making that possibility explicit in the type system",
    "start": "1731120",
    "end": "1736240"
  },
  {
    "text": "Again by saying oh we've got a state of of something or an undo of something while hiding the fact that we",
    "start": "1736240",
    "end": "1743399"
  },
  {
    "text": "have to propagate those State changes through our algorithm recursively or whatever there's another monad called",
    "start": "1743399",
    "end": "1749360"
  },
  {
    "text": "Promise which is really cool it's uh it's similar in a sense to the option monad and even simpler in in in a sense",
    "start": "1749360",
    "end": "1756919"
  },
  {
    "text": "because um well I'll just say what it is here it's it's similar similar to the idea of promises from um Java Ule",
    "start": "1756919",
    "end": "1764240"
  },
  {
    "text": "concurrent or what have you the idea that we're doing some asynchronous comp a and we get a promise of some future",
    "start": "1764240",
    "end": "1771240"
  },
  {
    "text": "result we don't know when when we're going to get it but let's you know assuming that we do get it at some point we're going to sequence those",
    "start": "1771240",
    "end": "1777440"
  },
  {
    "text": "computations let you know let's say we have a bunch of these monatic asynchronous",
    "start": "1777440",
    "end": "1784000"
  },
  {
    "text": "computations and we want to make that possibility or make make the fact that they are asynchronous explicit in the",
    "start": "1784000",
    "end": "1789480"
  },
  {
    "text": "type system but not have to worry about all of the threading logic all of the joining on a thread to wait for it to",
    "start": "1789480",
    "end": "1795399"
  },
  {
    "text": "wait for its completion and so on the transaction monad is another interesting one um there's a number of different",
    "start": "1795399",
    "end": "1801600"
  },
  {
    "text": "implementations of it that uh you can find across the web it makes the notion that a computation could possibly be",
    "start": "1801600",
    "end": "1808399"
  },
  {
    "text": "rolled back after uh after being being completed so some some state that was",
    "start": "1808399",
    "end": "1813559"
  },
  {
    "text": "mutated could be undone uh in a transaction it makes That explicit in the type system again while hiding the",
    "start": "1813559",
    "end": "1821279"
  },
  {
    "text": "fact that we actually do have to do these roll backs at some point or another and the list the list just goes on from there so hopefully you've seen",
    "start": "1821279",
    "end": "1828679"
  },
  {
    "text": "that that uh using monads uh at least in our simple examples here are a really nice way to clean up your code to to to",
    "start": "1828679",
    "end": "1835399"
  },
  {
    "text": "hide the fact that you have to do some some repetitive logic that doesn't have all that much to do with the actual uh",
    "start": "1835399",
    "end": "1842600"
  },
  {
    "text": "computation you're trying to you're trying to affect you really want to kind of want to sweep that under the rug in some sense make it explicit just in one",
    "start": "1842600",
    "end": "1849960"
  },
  {
    "text": "place without having to repeat yourself and that one place of course is in the type signature uh so the option of int",
    "start": "1849960",
    "end": "1856440"
  },
  {
    "text": "for example and leave all the rest out and uh you know like I say here I I want to encourage everybody to use mon ads",
    "start": "1856440",
    "end": "1862919"
  },
  {
    "text": "wherever you can to uh to to try to keep those concerns separate to to try to avoid that conflation of concerns and",
    "start": "1862919",
    "end": "1869080"
  },
  {
    "text": "keep your code clean so thanks again for listening and I hope you enjoy your classes from Marana",
    "start": "1869080",
    "end": "1875720"
  },
  {
    "text": "[Music]",
    "start": "1876080",
    "end": "1882018"
  }
]