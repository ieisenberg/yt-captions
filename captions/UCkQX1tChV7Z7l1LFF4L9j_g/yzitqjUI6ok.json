[
  {
    "start": "0",
    "end": "144000"
  },
  {
    "text": "I'm lb Brian and currently at Etsy I'm going to talk a bit about approximate",
    "start": "12179",
    "end": "18130"
  },
  {
    "text": "collections so so approximate collections why would we ever want an",
    "start": "18130",
    "end": "23680"
  },
  {
    "text": "approximate collection and what do I mean by that so there are times when you",
    "start": "23680",
    "end": "28809"
  },
  {
    "text": "have a collection sort of conceptually of an unbounded number of items are a very very large number of items right",
    "start": "28809",
    "end": "35469"
  },
  {
    "text": "millions of items billions of items but you've only got a bounded amount of memory and so you want to get some of",
    "start": "35469",
    "end": "42879"
  },
  {
    "text": "the advantages some of the summaries or aggregates or properties of a collection",
    "start": "42879",
    "end": "48100"
  },
  {
    "text": "like a set but you want to do it without actually storing all of the items and so",
    "start": "48100",
    "end": "54640"
  },
  {
    "text": "necessarily what you're going to have is an approximation so almost everybody I'm assuming in this talk that everybody in",
    "start": "54640",
    "end": "61120"
  },
  {
    "text": "this talk knows bloom filters which are probably the like best known sort of",
    "start": "61120",
    "end": "66189"
  },
  {
    "text": "approximate set the context of this talk is is the algebra library which which",
    "start": "66189",
    "end": "74079"
  },
  {
    "text": "came out of Twitter and if you were in Oscars talk earlier you might have seen a bit about it it it's a it's an",
    "start": "74079",
    "end": "82450"
  },
  {
    "text": "abstract algebra framework but but specifically focused on data structures that you might use in streaming or in",
    "start": "82450",
    "end": "90190"
  },
  {
    "text": "distributed computation like Hadoop for aggregation so in practice a lot of those end up being approximate",
    "start": "90190",
    "end": "96850"
  },
  {
    "text": "collections this came out of the scalding project which I started a Twitter and Oscar extracted a bunch of",
    "start": "96850",
    "end": "103930"
  },
  {
    "text": "stuff from it that that he wrote and and added and a bunch of us have contributed",
    "start": "103930",
    "end": "109299"
  },
  {
    "text": "to it but most of the credit for a lot of code you see in this talk should go to Oscar there's no contents may sell",
    "start": "109299",
    "end": "116259"
  },
  {
    "text": "during shipping what I'm showing you appropriately is sort of approximate code a bunch of it is real code from",
    "start": "116259",
    "end": "121630"
  },
  {
    "text": "algebra some of it is sort of api's that we're thinking about but haven't completely implemented yet or it's only",
    "start": "121630",
    "end": "128078"
  },
  {
    "text": "sort of Spada ly implemented some of it is sort of a little bit you know alighted just for ease of presentation",
    "start": "128079",
    "end": "134349"
  },
  {
    "text": "so the concepts are all their most of the implementation is there but some of this is kind of up in the air and part",
    "start": "134349",
    "end": "140349"
  },
  {
    "text": "of the point of this talk is maybe it have some discussion about what it should look like so if you",
    "start": "140349",
    "end": "145420"
  },
  {
    "start": "144000",
    "end": "355000"
  },
  {
    "text": "we're going to implement a bloom filter kind of them the kind of simplest most naive API that it might look like is",
    "start": "145420",
    "end": "151630"
  },
  {
    "text": "this so you know you you need to be able to update it with a new item and then",
    "start": "151630",
    "end": "158140"
  },
  {
    "text": "you need to be able to query as to whether or not the bloom filter contains that item and in the bloom filter you",
    "start": "158140",
    "end": "165400"
  },
  {
    "text": "know most of you probably know this that if the item is not there if the item has never been added to the bloom filter it",
    "start": "165400",
    "end": "171250"
  },
  {
    "text": "will it will answer false excuse me if it answers false that means that the",
    "start": "171250",
    "end": "177880"
  },
  {
    "text": "item definitely was never added if it answers true it might mean the item was added it might be a false positive right",
    "start": "177880",
    "end": "185459"
  },
  {
    "text": "and so you know that's that's maybe how you might think of this how you might implement it in Java or something in",
    "start": "185459",
    "end": "192940"
  },
  {
    "text": "Scala we want to make this nicer probably in a couple of ways one is we probably want this to be immutable and",
    "start": "192940",
    "end": "200580"
  },
  {
    "text": "the other is that we can make this sort of start to look like a set because that's conceptually what this is so we",
    "start": "200580",
    "end": "206380"
  },
  {
    "text": "might have the plus for the element and have that routine return a new instance of the bloom filter and we might have",
    "start": "206380",
    "end": "212980"
  },
  {
    "text": "some way to union two of these things right we might have plus plus for that so you notice thinked and contains right",
    "start": "212980",
    "end": "218890"
  },
  {
    "text": "which is also part of the set API in Scala so this thing starts to look a little bit like a set and it's worth",
    "start": "218890",
    "end": "225400"
  },
  {
    "text": "asking once this starts to look a little bit like I set what else from set might we want to add here so you know all of",
    "start": "225400",
    "end": "231970"
  },
  {
    "text": "the stuff that makes set iterable is just totally out right because the nature of a bloom filters that you do",
    "start": "231970",
    "end": "237910"
  },
  {
    "text": "not have these elements and so you cannot iterate through these elements so we can't do you know for each map Latin",
    "start": "237910",
    "end": "244090"
  },
  {
    "text": "have any of that stuff right can we do sighs right because size is another thing that sets tend to have and it",
    "start": "244090",
    "end": "251769"
  },
  {
    "text": "turns out that in a bloom filter you can do sighs there's a paper that describes",
    "start": "251769",
    "end": "256959"
  },
  {
    "text": "how you can estimate the number of items that have been added to a bloom filter basically just looking at how many bits",
    "start": "256959",
    "end": "263410"
  },
  {
    "text": "have been set in the bloom filter right and as long as it hasn't gotten too filled up right once it gets filled up a",
    "start": "263410",
    "end": "268630"
  },
  {
    "text": "certain point your estimates going to be really bad but in general you can actually get a pretty decent estimate",
    "start": "268630",
    "end": "273960"
  },
  {
    "text": "and so you know when you say things like pretty decent estimate you know is natural to ask like how good",
    "start": "273960",
    "end": "279910"
  },
  {
    "text": "is the estimate and in fact the paper gives bounds right and the bounds tend",
    "start": "279910",
    "end": "284950"
  },
  {
    "text": "to be of this form right if I tell you the estimate that I have of the size i",
    "start": "284950",
    "end": "290140"
  },
  {
    "text": "can give you a sort of minimum and a maximum right of what i think the the",
    "start": "290140",
    "end": "295360"
  },
  {
    "text": "range is that the size is in fact going to be and i can also give you a probability that the true size is within",
    "start": "295360",
    "end": "302230"
  },
  {
    "text": "these bounds right and that's sort of like you know if you see stats reported as like you know plus or minus five",
    "start": "302230",
    "end": "307780"
  },
  {
    "text": "percent 19 times out of 20 right it's the same pattern right I've got I've got a bound I've got a confidence bound and",
    "start": "307780",
    "end": "313630"
  },
  {
    "text": "then I've got a probability that the true value is in fact within that confidence bound and so you can end up",
    "start": "313630",
    "end": "318700"
  },
  {
    "text": "with an API that looks kind of like this right and it turns out also that if you",
    "start": "318700",
    "end": "324610"
  },
  {
    "text": "have an estimate of the size of a bloom filter one of the other things that you can do is you can estimate the false",
    "start": "324610",
    "end": "331090"
  },
  {
    "text": "prophet or give a probability for the false positive rate right and so that's useful because when you ask and you get",
    "start": "331090",
    "end": "338140"
  },
  {
    "text": "back a true you may want to know like how much can I rely on this true so this",
    "start": "338140",
    "end": "343750"
  },
  {
    "text": "API starting to get a little bit clunky I think you know with all of these",
    "start": "343750",
    "end": "349270"
  },
  {
    "text": "different things asking different probabilities asking different sizes min sighs max sighs so so it would be nice",
    "start": "349270",
    "end": "355330"
  },
  {
    "start": "355000",
    "end": "647000"
  },
  {
    "text": "to clean that up a little bit and one way that we can clean that up is by introducing some new types so rather than returning a boolean and having the",
    "start": "355330",
    "end": "361990"
  },
  {
    "text": "separate method for the probability that that bullying is wrong we can return an approximate boolean and similarly rather",
    "start": "361990",
    "end": "368050"
  },
  {
    "text": "than returning a size and then having all of these separate methods giving us some bounds on this we can return say an",
    "start": "368050",
    "end": "373960"
  },
  {
    "text": "approximate long so and these types exist within algebra so what does this",
    "start": "373960",
    "end": "379570"
  },
  {
    "text": "look like well an approximate boolean a you know basically is just a boolean value and a probability right so you",
    "start": "379570",
    "end": "388270"
  },
  {
    "text": "know actually in the case of a bloom filter if it returns false that probability is going to get set to one right so it's going to give you back an",
    "start": "388270",
    "end": "394750"
  },
  {
    "text": "approximate boolean that is in fact an exact boolean but if it returns true it's going to give you you know some",
    "start": "394750",
    "end": "401470"
  },
  {
    "text": "probability which is the same as that like probability of false positives that we saw another you had these types it's",
    "start": "401470",
    "end": "407260"
  },
  {
    "text": "interesting to think about like what operations can we do on these types right so in the case of approximate boolean we can for example negated and",
    "start": "407260",
    "end": "415479"
  },
  {
    "text": "the first time that I saw this coded actually threw me for a second because I kind of expected to invert the",
    "start": "415479",
    "end": "420669"
  },
  {
    "text": "probability somehow in my head I was like oh that should be 1 minus profit that's not right if we know with some",
    "start": "420669",
    "end": "426279"
  },
  {
    "text": "probability P that we have true then it's that same probability P that the",
    "start": "426279",
    "end": "431559"
  },
  {
    "text": "negation of that is false right and so that's all this is doing right is giving you a new approximate boolean that flips",
    "start": "431559",
    "end": "438550"
  },
  {
    "text": "the bit and gives you keeps the probability the same right things like and are also possible it gets a little",
    "start": "438550",
    "end": "445240"
  },
  {
    "text": "bit more involved but if you sort of read through this code what's going on is that if we're anding true with true",
    "start": "445240",
    "end": "453999"
  },
  {
    "text": "right the approximate true we get back has the same probability as multiplying",
    "start": "453999",
    "end": "459159"
  },
  {
    "text": "those two probabilities right so it's true with the probability of you know their their combined their joint",
    "start": "459159",
    "end": "464800"
  },
  {
    "text": "probability right otherwise it's false with the max of their two probabilities",
    "start": "464800",
    "end": "472029"
  },
  {
    "text": "right so you know if I tell you that this one is like very probably false and",
    "start": "472029",
    "end": "479139"
  },
  {
    "text": "then I and that with something that's that that is approximately true then it doesn't matter how approximate that true",
    "start": "479139",
    "end": "485769"
  },
  {
    "text": "value is because I know the false is really really good right and and so that",
    "start": "485769",
    "end": "491050"
  },
  {
    "text": "excuse me it's it's the it's the maximum of the false probabilities right the",
    "start": "491050",
    "end": "496930"
  },
  {
    "text": "true probability is don't matter so you know or you can implement us very",
    "start": "496930",
    "end": "501939"
  },
  {
    "text": "similar it's just everything's kind of inverted right okay now we also have this approximate long what does that",
    "start": "501939",
    "end": "508029"
  },
  {
    "text": "look like well again we're just kind of encapsulating in this type the same methods that we had before right so we've got a min we've got an estimate",
    "start": "508029",
    "end": "514328"
  },
  {
    "text": "we've got a max and then we've got a probability that the true value is within that range and there's no reason",
    "start": "514329",
    "end": "520659"
  },
  {
    "text": "we have to do this specifically for long we can do this for any numeric right so we might as well use the numeric type",
    "start": "520659",
    "end": "526660"
  },
  {
    "text": "class and do that and so what can we do with with an approximate numeric well",
    "start": "526660",
    "end": "533380"
  },
  {
    "text": "probably the most important thing we want to do apart from just directly reading the estimate in the range is",
    "start": "533380",
    "end": "538920"
  },
  {
    "text": "asking whether or not a certain value that we're interested in is within these bounds right and kind of nicely",
    "start": "538920",
    "end": "545710"
  },
  {
    "text": "what that returns is an approximate boolean you know what else might want to do you know we can add approximate",
    "start": "545710",
    "end": "553210"
  },
  {
    "text": "numbers we can we can subtract approximate numbers I'm not showing the implementations because that's not",
    "start": "553210",
    "end": "558490"
  },
  {
    "text": "really the point you can go look at the source code you can kind of imagine what the what the manipulations on the",
    "start": "558490",
    "end": "563590"
  },
  {
    "text": "probability would be so okay you know can we generalize this right so bloom",
    "start": "563590",
    "end": "569620"
  },
  {
    "text": "filters do this but but do we can we just think of a general approximate set",
    "start": "569620",
    "end": "575770"
  },
  {
    "text": "interface of which bloom filter is simply one implementation right and and",
    "start": "575770",
    "end": "581290"
  },
  {
    "text": "what would the other implementations be so another one that we use a lot in algebra does hyper log-log so hyper log",
    "start": "581290",
    "end": "589210"
  },
  {
    "text": "log is this fancy distinct value estimation algorithm right Sol Sol bloom filter was really designed for the",
    "start": "589210",
    "end": "596140"
  },
  {
    "text": "contains operation right bloom filters optimized have good bounds on contains",
    "start": "596140",
    "end": "601210"
  },
  {
    "text": "hyper log log was optimized have good bounds on the size method right it can",
    "start": "601210",
    "end": "607810"
  },
  {
    "text": "do contains it does contains kind of janky which is that if you have a hyper",
    "start": "607810",
    "end": "613210"
  },
  {
    "text": "log log and you want to know whether it contains something you just add something to it and see whether the size changed right which is not you know",
    "start": "613210",
    "end": "620290"
  },
  {
    "text": "going to give you the best bounce right but on the other hand it has really good bounds on size so I think Oscar",
    "start": "620290",
    "end": "626920"
  },
  {
    "text": "mentioned in his talk that if you're willing to give it you know like 15k or so then you get under one percent error",
    "start": "626920",
    "end": "632470"
  },
  {
    "text": "which is pretty good and I think you give it 1 K you still get within like two percent error so how does it work",
    "start": "632470",
    "end": "637780"
  },
  {
    "text": "I'm not going to explain this talk how hyper log log works but I'm going to explain how one of the earlier in the",
    "start": "637780",
    "end": "643270"
  },
  {
    "text": "family of this algorithms that that came from the same people works so if you",
    "start": "643270",
    "end": "648730"
  },
  {
    "text": "have n values in this set and you see them in a stream or whatever you know",
    "start": "648730",
    "end": "654060"
  },
  {
    "text": "however your computing this every every value that you see you hash using a you",
    "start": "654060",
    "end": "660430"
  },
  {
    "text": "know good uniform hash function the let's say for the sake of argument hashes them to between 0 and 1 and I've",
    "start": "660430",
    "end": "666850"
  },
  {
    "text": "got little marks on the number line they're supposed to represent like where those hash values fall right so this is",
    "start": "666850",
    "end": "672010"
  },
  {
    "text": "sort of supposed to represent like a set of I don't even know what that is 10 items or something right",
    "start": "672010",
    "end": "677680"
  },
  {
    "text": "and it's more or less uniformly and you know this is it's not perfect but it's uniformly distributed from zero to one",
    "start": "677680",
    "end": "683710"
  },
  {
    "text": "right so okay that's fine now let's think about the distance between any two",
    "start": "683710",
    "end": "690190"
  },
  {
    "text": "of these adjacent hash values right so let's call that W so what do we expect w",
    "start": "690190",
    "end": "696430"
  },
  {
    "text": "to be well if we have the distance between 0 to 1 and were uniformly distributing these things across it we",
    "start": "696430",
    "end": "703060"
  },
  {
    "text": "expect that to be 1 over N where n is the number of items in the set right i",
    "start": "703060",
    "end": "708279"
  },
  {
    "text": "think that's that's fairly straightforward and that's true you know wherever we're looking at two adjacent ones or if we're looking at the distance",
    "start": "708279",
    "end": "715240"
  },
  {
    "text": "between 0 and the first one the minimum one right that's that's always going to be true so okay that's cool because that",
    "start": "715240",
    "end": "723040"
  },
  {
    "text": "means that if all that we do instead of remembering all of these is just as we're screaming through this we just",
    "start": "723040",
    "end": "729010"
  },
  {
    "text": "keep the minimum one we've seen right now we have an estimator of the total",
    "start": "729010",
    "end": "734140"
  },
  {
    "text": "number of items right so we just look at W we do one over w and that's our n and",
    "start": "734140",
    "end": "741310"
  },
  {
    "text": "that's going to be actually a pretty bad estimator right it's going to be very high variance and so a better thing to",
    "start": "741310",
    "end": "746589"
  },
  {
    "text": "do is to keep the K minimum that we see right the K lowest ashes that we see and now we've got KW and k / end is is going",
    "start": "746589",
    "end": "754959"
  },
  {
    "text": "to you know expected of you KW and so we can again estimate n and and now it's just a trade-off of space versus",
    "start": "754959",
    "end": "760600"
  },
  {
    "text": "accuracy right so the more k you know the larger you know an approximate set",
    "start": "760600",
    "end": "766870"
  },
  {
    "text": "we're deciding to keep the better error is going to be so that's cool and in",
    "start": "766870",
    "end": "774279"
  },
  {
    "text": "very useful the hyper log log is basically this but like better optimized so there's another one that we use in",
    "start": "774279",
    "end": "782500"
  },
  {
    "text": "algebra which is which is min hash and in min hash is optimized for a different",
    "start": "782500",
    "end": "790510"
  },
  {
    "text": "purpose again which is set similarity so the assumption is you have a couple of",
    "start": "790510",
    "end": "795910"
  },
  {
    "text": "these approximate sets and you want to see how similar they are to each other so how does that work well it actually",
    "start": "795910",
    "end": "802360"
  },
  {
    "text": "starts out very similarly which is to say that you have some hash function and",
    "start": "802360",
    "end": "808000"
  },
  {
    "text": "every item in the set you run through this hash function and you keep the lowest one right so so far",
    "start": "808000",
    "end": "814810"
  },
  {
    "text": "this looks almost exactly the same but but you do something different with it",
    "start": "814810",
    "end": "820900"
  },
  {
    "text": "and if you have two sets and they have",
    "start": "820900",
    "end": "826630"
  },
  {
    "text": "the same hash function and you kept the lowest one of each the question you ask",
    "start": "826630",
    "end": "832900"
  },
  {
    "text": "is what's the probability that the two sets are going to have the same lowest",
    "start": "832900",
    "end": "839080"
  },
  {
    "text": "hash value and it turns out and I don't think I want to walk through a proof of",
    "start": "839080",
    "end": "845080"
  },
  {
    "text": "this but hopefully people can kind of intuitively see this that the probability that these two sets are",
    "start": "845080",
    "end": "851200"
  },
  {
    "text": "going to have the same lowest value is the same as the size of their",
    "start": "851200",
    "end": "856810"
  },
  {
    "text": "intersection / the size of their union right so if you sort of you know hand",
    "start": "856810",
    "end": "862420"
  },
  {
    "text": "wavy proof right is that if you sort of think of like combining these and and",
    "start": "862420",
    "end": "867670"
  },
  {
    "text": "that's going to be you know have as many elements as the size of the Union and then ask like what's the chance that",
    "start": "867670",
    "end": "873670"
  },
  {
    "text": "that's going to change the lowest one that's sort of the probability of you",
    "start": "873670",
    "end": "878770"
  },
  {
    "text": "know how many of them intersect / how many of them Union right so anyway that",
    "start": "878770",
    "end": "884230"
  },
  {
    "text": "that quantity the size of the intersection divided by the size of the union is actually a common similarity",
    "start": "884230",
    "end": "890020"
  },
  {
    "text": "metric which is Jaccard similarity or 1 minus that is is the Jaccard distance which is the actual metric right so",
    "start": "890020",
    "end": "898090"
  },
  {
    "text": "that's cool but you know you're just going to get a binary 1 or 0 out of this",
    "start": "898090",
    "end": "903340"
  },
  {
    "text": "right so knowing that like you know these sets are yes they're similar with this probability or no they're not",
    "start": "903340",
    "end": "909550"
  },
  {
    "text": "similar with this probability is not actually that helpful what you want is to know how similar they are and so what",
    "start": "909550",
    "end": "916540"
  },
  {
    "text": "you do is you do this K times with K different hash functions right so",
    "start": "916540",
    "end": "921940"
  },
  {
    "text": "instead of just keeping so the difference between this and the last one I was describing right is that the last one I was describing you have one hash",
    "start": "921940",
    "end": "928000"
  },
  {
    "text": "function and you keep the K lowest values here you have K hash functions and you keep the one lowest value for",
    "start": "928000",
    "end": "934030"
  },
  {
    "text": "each of them right and then you can do this pair wise comparison where you look ok for this hash function does the",
    "start": "934030",
    "end": "940450"
  },
  {
    "text": "lowest value that I've kept match for this has functioned the lowest value that I've kept match for this hash function and you do that k",
    "start": "940450",
    "end": "946190"
  },
  {
    "text": "times and you see how many matches you get and so the number of matches divided",
    "start": "946190",
    "end": "951980"
  },
  {
    "text": "by K is your estimate of that probability which is equal to the",
    "start": "951980",
    "end": "957170"
  },
  {
    "text": "Jaccard similarity right and so from that you can get similarity and so okay this sort of requires new extensions to",
    "start": "957170",
    "end": "965630"
  },
  {
    "text": "our to our approximate set API right which is we want Jaccard similarity as",
    "start": "965630",
    "end": "973280"
  },
  {
    "start": "967000",
    "end": "1077000"
  },
  {
    "text": "an approximate double and then actually if you have their similarity if you have their Jaccard similarity and you have",
    "start": "973280",
    "end": "979280"
  },
  {
    "text": "their size you can compute the size of their intersection and and I should have",
    "start": "979280",
    "end": "985250"
  },
  {
    "text": "put the math up here right but if you think about it if you take their if you take them you have a union operation",
    "start": "985250",
    "end": "991010"
  },
  {
    "text": "here so you can get the size of their union you have the Jaccard similarity which is the size of the intersection",
    "start": "991010",
    "end": "997430"
  },
  {
    "text": "over the size of the union so you multiply those two things and you end up with the size of the intersection right",
    "start": "997430",
    "end": "1002520"
  },
  {
    "text": "so this is this weird kind of asymmetry between unions and intersections that that you tend to see in these structures",
    "start": "1002520",
    "end": "1009490"
  },
  {
    "text": "which is that unions are sort of free in the sense that they're lossless right you don't increase the error by and",
    "start": "1009490",
    "end": "1015820"
  },
  {
    "text": "large by Union and two sets and so you can kind of Union all day long and take the size right but intersection is kind",
    "start": "1015820",
    "end": "1022720"
  },
  {
    "text": "of you get one shot at it basically right because your air is just going to keep going up and so usually you you",
    "start": "1022720",
    "end": "1028990"
  },
  {
    "text": "have an actual Union operation right you have a size operation and then you have this intersection size operation and",
    "start": "1028990",
    "end": "1035530"
  },
  {
    "text": "sometimes and put code up here for it but sometimes you can do like an N way intersection and that's a little bit",
    "start": "1035530",
    "end": "1041410"
  },
  {
    "text": "better and a little bit more useful but in general this is this is kind of what you get so this part of the API am not",
    "start": "1041410",
    "end": "1049150"
  },
  {
    "text": "like super happy about in that it would be so for example similarity and",
    "start": "1049150",
    "end": "1054310"
  },
  {
    "text": "intersection size are related quantities but some of these approximate sets are",
    "start": "1054310",
    "end": "1060340"
  },
  {
    "text": "better at estimating one and some of these approximate sets are better estimating the other and so you don't",
    "start": "1060340",
    "end": "1065410"
  },
  {
    "text": "really want to get the user to just use one and do the multiplication themselves",
    "start": "1065410",
    "end": "1070960"
  },
  {
    "text": "because then you might end up with two high bounds so so there's that",
    "start": "1070960",
    "end": "1076320"
  },
  {
    "text": "so that's approximate set stuff and and",
    "start": "1076320",
    "end": "1081419"
  },
  {
    "start": "1077000",
    "end": "1247000"
  },
  {
    "text": "it would be nice also if there were a proximate Mac approximate list kind of",
    "start": "1081419",
    "end": "1087509"
  },
  {
    "text": "doesn't make sense because really lists what you want to do is iterate over them and again you can't iterate over them but approximate map might make sense we",
    "start": "1087509",
    "end": "1093840"
  },
  {
    "text": "don't have yet anything that totally feels like an approximate mat but one thing that we do have is what you might",
    "start": "1093840",
    "end": "1100200"
  },
  {
    "text": "call and this name isn't in the code but I just made it up for the talk an approximate frequency set so what I mean",
    "start": "1100200",
    "end": "1107850"
  },
  {
    "text": "by this is it's basically an approximate set you're still adding elements to it right but not only can you ask does this",
    "start": "1107850",
    "end": "1114299"
  },
  {
    "text": "set contain this element you can say how many times did I add this element to this set and that can be really valuable",
    "start": "1114299",
    "end": "1119820"
  },
  {
    "text": "right so you have an operation that's not quite yet but it's like get frequency or get count and again that's",
    "start": "1119820",
    "end": "1127019"
  },
  {
    "text": "going to return an approximate number and we only have one instance of this implemented it certainly there are other",
    "start": "1127019",
    "end": "1132690"
  },
  {
    "text": "structures that would implement something like that but that's the countenance catch and so I'll briefly",
    "start": "1132690",
    "end": "1139440"
  },
  {
    "text": "describe how accountant in sketch works so you imagine having just a just a",
    "start": "1139440",
    "end": "1146730"
  },
  {
    "text": "bunch of buckets right a fixed size number of buckets each of which is a",
    "start": "1146730",
    "end": "1151830"
  },
  {
    "text": "counter and each time an element comes in you have a hash function that's going",
    "start": "1151830",
    "end": "1157440"
  },
  {
    "text": "to choose a bucket for that element and you're going to increment the counter in that bucket right and and so whatever i",
    "start": "1157440",
    "end": "1165480"
  },
  {
    "text": "have k k hashes to that bucket i'm going to increment you know from for there was before 25 and now i want to know later",
    "start": "1165480",
    "end": "1173460"
  },
  {
    "text": "on how many times have I seen k well I use the same hash function i get to the",
    "start": "1173460",
    "end": "1178919"
  },
  {
    "text": "same bucket I look it up now is that the number of times I've seen k I mean no",
    "start": "1178919",
    "end": "1184200"
  },
  {
    "text": "probably not it is an upper bound on the number of times I've seen K right",
    "start": "1184200",
    "end": "1189509"
  },
  {
    "text": "because I have incremented that bucket at least as many times as I've seen K",
    "start": "1189509",
    "end": "1195240"
  },
  {
    "text": "but it's probably quite an over estimate because i have also no doubt seeing",
    "start": "1195240",
    "end": "1201480"
  },
  {
    "text": "other things unless my number of buckets here is like on the same order as my number of items in which case this is kind of pointless i have no doubt also",
    "start": "1201480",
    "end": "1208889"
  },
  {
    "text": "seen other things that hash that same bucket and so that number is going to be too high and so",
    "start": "1208889",
    "end": "1213929"
  },
  {
    "text": "how do I solve this so there's a common pattern here which is sort of how do I solve this is basically we do this K",
    "start": "1213929",
    "end": "1219510"
  },
  {
    "text": "times right so again we do this K times we have K different sets of buckets with",
    "start": "1219510",
    "end": "1224549"
  },
  {
    "text": "K different hash functions right and every time the element comes through we",
    "start": "1224549",
    "end": "1229620"
  },
  {
    "text": "get the K different buckets and increment each of them and then when we want to do the query we look at the K",
    "start": "1229620",
    "end": "1236909"
  },
  {
    "text": "different buckets that are hashes too and we take the minimum one right because all of these are upper bounds so",
    "start": "1236909",
    "end": "1243390"
  },
  {
    "text": "now we have K different upper bounds and so if we take the lowest of the K different upper bounds then we get still",
    "start": "1243390",
    "end": "1249750"
  },
  {
    "text": "an upper bound but we get the best upper bound right and so we've managed to reduce our error by having more of these",
    "start": "1249750",
    "end": "1256559"
  },
  {
    "text": "and and so that's actually all the stuff that I've prepared and I went through",
    "start": "1256559",
    "end": "1261929"
  },
  {
    "text": "that a little quickly i'm i'm from etsy my team is is a distributed team",
    "start": "1261929",
    "end": "1270179"
  },
  {
    "text": "entirely distributed team we don't commute to the office so this group doesn't commute but if there are any",
    "start": "1270179",
    "end": "1278809"
  },
  {
    "text": "questions I'd like to take them yeah so the question was can I talk about some",
    "start": "1278809",
    "end": "1284490"
  },
  {
    "start": "1282000",
    "end": "1577000"
  },
  {
    "text": "of the use cases for these various operators right so a you know a bloom",
    "start": "1284490",
    "end": "1290490"
  },
  {
    "text": "filter so I'm going to be coming at this very much from the context of kind of",
    "start": "1290490",
    "end": "1296130"
  },
  {
    "text": "Hadoop distributed computation right hey bloom filter is is used all over the",
    "start": "1296130",
    "end": "1304140"
  },
  {
    "text": "place right often when you want to know so you have a bunch of machines you have",
    "start": "1304140",
    "end": "1311220"
  },
  {
    "text": "data distributed over a bunch of them you want to look up some value in each",
    "start": "1311220",
    "end": "1317460"
  },
  {
    "text": "of them and you have a bloom filter that cash is in memory sort of what values",
    "start": "1317460",
    "end": "1323370"
  },
  {
    "text": "are on disk and so you can quickly check in the bloom filter to see whether or not it's worth looking and disk for this value or if you're doing join especially",
    "start": "1323370",
    "end": "1334620"
  },
  {
    "text": "like a join of a very large table to a very small table one thing that you",
    "start": "1334620",
    "end": "1341850"
  },
  {
    "text": "might do is produce a bloom filter of all of the",
    "start": "1341850",
    "end": "1348540"
  },
  {
    "text": "keys in the small table right and and ship that over to all of the various",
    "start": "1348540",
    "end": "1354030"
  },
  {
    "text": "partitioning zuv the large table that you've got like spread over your distributed file system and then you can use that to filter the large table down",
    "start": "1354030",
    "end": "1360720"
  },
  {
    "text": "considerably and then you have fewer keys that actually need to go into your shuffle or whatever it is a hyper log",
    "start": "1360720",
    "end": "1367800"
  },
  {
    "text": "log you know any time you I mean unique visitors is the like classic use case for this right so you know you want to",
    "start": "1367800",
    "end": "1374940"
  },
  {
    "text": "know over this very large stream of events how many unique visitors you have that day or that month of that year and",
    "start": "1374940",
    "end": "1382020"
  },
  {
    "text": "the fact that you can Union them is really nice so you know as a trivial example right if you store the hyper log",
    "start": "1382020",
    "end": "1388800"
  },
  {
    "text": "log for each day of the month and then you want to know the unique visitors like across the whole month you can just Union those up which is quite an",
    "start": "1388800",
    "end": "1395520"
  },
  {
    "text": "efficient operation and then get that right you can also imagine sort of more complicated analytic stuff where you",
    "start": "1395520",
    "end": "1401790"
  },
  {
    "text": "have a whole bunch of like segmentations like you know segmented by that segmentation by time but you might also",
    "start": "1401790",
    "end": "1408780"
  },
  {
    "text": "second by geo or whatever and so you want to Union up a bunch of these little sort of shards and see how many people",
    "start": "1408780",
    "end": "1414630"
  },
  {
    "text": "are in them and then like see how much intersection there is with something else min hash which is about set",
    "start": "1414630",
    "end": "1420150"
  },
  {
    "text": "similarity is very often used for like personalization algorithms or",
    "start": "1420150",
    "end": "1425820"
  },
  {
    "text": "recommendation algorithms so you know Google News uses this where there's one",
    "start": "1425820",
    "end": "1432930"
  },
  {
    "text": "set which is like the number of articles that I have liked and or read and there's another set which is the number",
    "start": "1432930",
    "end": "1438030"
  },
  {
    "text": "of articles that you have read and they want to see how similar we are to each other because if we're similar enough then maybe if you read an article they",
    "start": "1438030",
    "end": "1444900"
  },
  {
    "text": "want to recommend it to me right or you know other similar similar similarity",
    "start": "1444900",
    "end": "1450510"
  },
  {
    "text": "stuff right count min sketch one of the main applications of countenance",
    "start": "1450510",
    "end": "1455550"
  },
  {
    "text": "sketches like a heavy hitters so streaming heavy hitters so what that means is that if you so the count min",
    "start": "1455550",
    "end": "1461910"
  },
  {
    "text": "sketch bound is basically the the percentage of the stream has a",
    "start": "1461910",
    "end": "1469290"
  },
  {
    "text": "percentage error right so i can say with certain error bounds that",
    "start": "1469290",
    "end": "1474480"
  },
  {
    "text": "this item is you know makes up six percent of the items I've seen over the",
    "start": "1474480",
    "end": "1479640"
  },
  {
    "text": "stream or whatever and so what you might do is say I want to record any time an",
    "start": "1479640",
    "end": "1485490"
  },
  {
    "text": "item is is estimated to be greater than like one percent of my stream or two",
    "start": "1485490",
    "end": "1490890"
  },
  {
    "text": "percent on my stream or something like that I want to keep track of it and so along with my count man sketch I'll keep",
    "start": "1490890",
    "end": "1496320"
  },
  {
    "text": "a list of sort of all of the items that have been estimated to be above that count min sketch is also very useful",
    "start": "1496320",
    "end": "1503179"
  },
  {
    "text": "back to to joins in a distributed context because estimating the frequency",
    "start": "1503179",
    "end": "1511230"
  },
  {
    "text": "of various keys tells you a lot about what kind of joint algorithm you might want to use and you know how skewed it",
    "start": "1511230",
    "end": "1518280"
  },
  {
    "text": "is and so one of the things that that count men sketch gives you a very good estimate of is what sometimes people",
    "start": "1518280",
    "end": "1525720"
  },
  {
    "text": "call the f2 or the second frequency moment which is like the anyway it's the dot product of the frequencies but",
    "start": "1525720",
    "end": "1531660"
  },
  {
    "text": "basically it's a measure of skew and so counting in sketch is very good for that count min sketches also this gets really",
    "start": "1531660",
    "end": "1538679"
  },
  {
    "text": "involved but if you build up a tree of them it's a way that you can estimate percentiles so you can end up getting",
    "start": "1538679",
    "end": "1544980"
  },
  {
    "text": "both range queries and you can get like mediums or nine gifts percentiles or whatever which tends to be a really hard",
    "start": "1544980",
    "end": "1550260"
  },
  {
    "text": "thing to get a good estimate of in a distributed context or in a streaming context but if you use like you know",
    "start": "1550260",
    "end": "1557880"
  },
  {
    "text": "enough basically you use sort of log and countenance catches it given that you",
    "start": "1557880",
    "end": "1564750"
  },
  {
    "text": "have n distinct values then you can get really good estimates on on percentile stuff so you know those are the things",
    "start": "1564750",
    "end": "1572940"
  },
  {
    "text": "that that I've looked into using these for I mean I'm sure there's a bunch of other things that other people use them",
    "start": "1572940",
    "end": "1578220"
  },
  {
    "start": "1577000",
    "end": "1861000"
  },
  {
    "text": "for so a cache is another kind of approximate set yep with the other",
    "start": "1578220",
    "end": "1583919"
  },
  {
    "text": "inverted right what is this API biased to the bloom filter style of sets what a",
    "start": "1583919",
    "end": "1589770"
  },
  {
    "text": "cache mix-up it's not know right so so an expiring cash right if it tells you",
    "start": "1589770",
    "end": "1597210"
  },
  {
    "text": "that the thing is there it's definitely there if you tells you that the thing is not there it it might have just fallen",
    "start": "1597210",
    "end": "1603929"
  },
  {
    "text": "out of cash and and you would just use approximate boolean but your truths would have the",
    "start": "1603929",
    "end": "1609429"
  },
  {
    "text": "probability set to one and your falses would have the probability set to something right which is the inverse of",
    "start": "1609429",
    "end": "1615190"
  },
  {
    "text": "what a bloom filter does but but the API would actually be exactly the same yeah so there is a lack of intersection",
    "start": "1615190",
    "end": "1620979"
  },
  {
    "text": "between the intersection and union as far as I can think that's completely orthogonal to the what we're talking",
    "start": "1620979",
    "end": "1626769"
  },
  {
    "text": "about that the contains you know whether whether it's I don't know the technical terms for this right but but whether",
    "start": "1626769",
    "end": "1633549"
  },
  {
    "text": "it's biased towards false positives or false negatives right yeah in the few algorithms where you need to use K",
    "start": "1633549",
    "end": "1641080"
  },
  {
    "text": "different hash functions can you talk about what if any constraints are on the different hash functions and what ash",
    "start": "1641080",
    "end": "1646809"
  },
  {
    "text": "functions you would tend to use or how you do that yeah so what we use is murmur hash three and murmur hash three",
    "start": "1646809",
    "end": "1653229"
  },
  {
    "text": "takes a seed and so the the approach that we've been using anyway is use a",
    "start": "1653229",
    "end": "1661719"
  },
  {
    "text": "fixed seed to initialize a random number generator use that random number generator to generate k different seeds",
    "start": "1661719",
    "end": "1668859"
  },
  {
    "text": "use those k different seeds for K different murmur hash variants I have",
    "start": "1668859",
    "end": "1676089"
  },
  {
    "text": "like no formal you no justification for that it seems empirically to work fine",
    "start": "1676089",
    "end": "1682559"
  },
  {
    "text": "so kirshen mitcham it Kirsh and Mick mitcham occur did a formal study where",
    "start": "1682559",
    "end": "1689559"
  },
  {
    "text": "they showed that you can use to hash functions as long as they're linearly separable and you can use linear combinations of those two get n hash",
    "start": "1689559",
    "end": "1696519"
  },
  {
    "text": "functions with a decay of about one or two percent worth of overall efficiency in the algorithm so if you're looking",
    "start": "1696519",
    "end": "1702009"
  },
  {
    "text": "for a way to cut your hashing cost that may save you a lot of work yeah thank you why does approximate boolean have a",
    "start": "1702009",
    "end": "1709389"
  },
  {
    "text": "boolean value it's just a probability",
    "start": "1709389",
    "end": "1714330"
  },
  {
    "text": "that's a good question i'm still thinking about it Oscar is going to",
    "start": "1717330",
    "end": "1724650"
  },
  {
    "text": "answer that one the real answer is that you want to push all kinds of proofs through about like not or and or or and",
    "start": "1724650",
    "end": "1732000"
  },
  {
    "text": "if you know something about the the space that you're working in you can actually do that if you give me like an",
    "start": "1732000",
    "end": "1738060"
  },
  {
    "text": "approximate a like it's it's it's probability it's at least with probability half a and then I want to",
    "start": "1738060",
    "end": "1744000"
  },
  {
    "text": "combine it with some function like from A to B to C that that's also like you're going to give me an approximate be then",
    "start": "1744000",
    "end": "1750990"
  },
  {
    "text": "I have to resort to relatively loose bounds about like the probability that i got see correct you have to only go with",
    "start": "1750990",
    "end": "1756990"
  },
  {
    "text": "that and correctness and that falls off exponentially but the wind that obvi showed where you can we you have certain",
    "start": "1756990",
    "end": "1764730"
  },
  {
    "text": "facts about the way bullion's combine that if you see an or if either one of them are true then you can strengthen",
    "start": "1764730",
    "end": "1771600"
  },
  {
    "text": "the balance and they don't necessarily fall off exponentially fast that was the only reason for it the question is how",
    "start": "1771600",
    "end": "1778290"
  },
  {
    "text": "we persist these yeah so that's a that's a great question right now the answer is badly which is to say that we use the",
    "start": "1778290",
    "end": "1786210"
  },
  {
    "text": "cryo library for for serialization that's great for temporary storage when",
    "start": "1786210",
    "end": "1793590"
  },
  {
    "text": "it's like just going from the map nodes to the reduced nodes across a new cluster and often that's all that we",
    "start": "1793590",
    "end": "1800460"
  },
  {
    "text": "need right often you're sort of going to pull a final answer out of it and that's what you actually need to persist in the",
    "start": "1800460",
    "end": "1805830"
  },
  {
    "text": "long term but you know serializing with that particular framework on disk does",
    "start": "1805830",
    "end": "1812280"
  },
  {
    "text": "not seem like a robust long-term solution so one of the things that we are adding to algebra is more stable",
    "start": "1812280",
    "end": "1819660"
  },
  {
    "text": "long-term bye Jek shins to and from byte arrays but couldn't resist but but yeah",
    "start": "1819660",
    "end": "1833640"
  },
  {
    "text": "so so that's that's that's a big to-do item actually for the framework right now most of these effectively get",
    "start": "1833640",
    "end": "1839880"
  },
  {
    "text": "represented as bit fields right so it's not like serializing them is hard but",
    "start": "1839880",
    "end": "1845820"
  },
  {
    "text": "but there does need to be better code in there than there is right now thank",
    "start": "1845820",
    "end": "1852320"
  }
]