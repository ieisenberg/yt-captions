[
  {
    "text": "I'll I'll need you in a second to switch to my to my reppel right uh sorry about the delay can everyone hear me is",
    "start": "160",
    "end": "6759"
  },
  {
    "text": "everyone all excited to hear about demystifying type inference good good uh so good good to",
    "start": "6759",
    "end": "13639"
  },
  {
    "text": "see so many of you here uh especially War welcome to Paul is Paul here yeah oh",
    "start": "13639",
    "end": "18920"
  },
  {
    "text": "you you've come to the front Okay Paul Paul came all the way from Paul Paul came all the way from",
    "start": "18920",
    "end": "26000"
  },
  {
    "text": "Oregon just to Heckle my talk so thank you thank you for coming I I hope you",
    "start": "26000",
    "end": "31800"
  },
  {
    "text": "hope you feel welcome so I've I've chosen this image of a uh like like a",
    "start": "31800",
    "end": "36879"
  },
  {
    "text": "human brain um to sort of be my metaphor for type inference because it's it's very much a black box nobody really",
    "start": "36879",
    "end": "43120"
  },
  {
    "text": "suddenly I don't know how it works but I'm I'm going to try and explain a bit about it uh today um give or take some",
    "start": "43120",
    "end": "50039"
  },
  {
    "text": "corrections probably I I'm sure there's a lot of people in here who will spot issues with what I'm saying and please shout out some people I don't need to",
    "start": "50039",
    "end": "57440"
  },
  {
    "text": "tell so let's let's get started with a few",
    "start": "57440",
    "end": "63680"
  },
  {
    "text": "examples this this is this is really basic stuff if we write Val value equals",
    "start": "63680",
    "end": "69200"
  },
  {
    "text": "hello the type inference will automatically put in effectively a colon string there it knows that that's a",
    "start": "69200",
    "end": "75520"
  },
  {
    "text": "string that's that's kind of what we want if we were to write write this list",
    "start": "75520",
    "end": "81000"
  },
  {
    "text": "now there's there's a gap there let's see we've got got a gap here which is which is",
    "start": "81000",
    "end": "86520"
  },
  {
    "text": "going to be where where something goes which I'll reveal in a second the type inference is able to work out that this",
    "start": "86520",
    "end": "92159"
  },
  {
    "text": "is actually an either even though we don't anywhere mention either in in in",
    "start": "92159",
    "end": "97200"
  },
  {
    "text": "the values we apply to that that list Factory so that's that's again what we",
    "start": "97200",
    "end": "103920"
  },
  {
    "text": "want um if we were to if you were to write this the compiler is able to work out",
    "start": "103920",
    "end": "109640"
  },
  {
    "text": "that this is an exception even though once again we've not mentioned exception we've mentioned a subclass of it and um",
    "start": "109640",
    "end": "116399"
  },
  {
    "text": "it's infering this from from the return type that we specified here so this is all good so I've managed to find",
    "start": "116399",
    "end": "122680"
  },
  {
    "text": "three good things now this this doesn't work this is still connected to my old laptop",
    "start": "122680",
    "end": "129798"
  },
  {
    "text": "right uh so typ is not working so well okay can anyone tell me what type is",
    "start": "129800",
    "end": "135879"
  },
  {
    "text": "inferred in the Gap there anyal did you get it wrong get",
    "start": "135879",
    "end": "143840"
  },
  {
    "text": "out put them in lists what put them in lists oh okay gu",
    "start": "144160",
    "end": "150720"
  },
  {
    "text": "like like that is that is that good enough",
    "start": "150720",
    "end": "156319"
  },
  {
    "text": "any so this is actually FL flowed onto two lines and there's a massive Gap here",
    "start": "156319",
    "end": "161640"
  },
  {
    "text": "now this is actually the same one I showed you last time except the type last time was a lie what it's actually inferring is this product with",
    "start": "161640",
    "end": "167599"
  },
  {
    "text": "serializable with either of int and string this is correct this is this is I",
    "start": "167599",
    "end": "174080"
  },
  {
    "text": "mean there are very good reasons as to why this comes out as the inferred type but we would actually probably",
    "start": "174080",
    "end": "180440"
  },
  {
    "text": "prefer that to be either of int and string I think most of the",
    "start": "180440",
    "end": "185480"
  },
  {
    "text": "time another pretty simple example if if we've got a VAR uh which we assign sum 42 to given",
    "start": "185480",
    "end": "194440"
  },
  {
    "text": "that we've assigned it sum of something rather than just 42 we probably may want to have the option later on to assign",
    "start": "194440",
    "end": "200640"
  },
  {
    "text": "none to it but we don't get that because it's it ascribes automatically the type some of it so none is not a possible",
    "start": "200640",
    "end": "206920"
  },
  {
    "text": "value for that um again there are good reasons for it or the reasons for it at least and uh",
    "start": "206920",
    "end": "213879"
  },
  {
    "text": "we have to live with that okay any guesses as to what this one is now that the the Gap is",
    "start": "213879",
    "end": "220239"
  },
  {
    "text": "misleadingly small here in fact the Gap is a question mark for now that's like",
    "start": "220239",
    "end": "225360"
  },
  {
    "text": "two P ah right okay so if I if I can bring",
    "start": "225360",
    "end": "231319"
  },
  {
    "text": "up so what what was it it was uh list of vector and range",
    "start": "231319",
    "end": "239280"
  },
  {
    "text": "yeah a list of vector and range so",
    "start": "241680",
    "end": "247760"
  },
  {
    "text": "something like this here we go yeah now",
    "start": "247760",
    "end": "253879"
  },
  {
    "text": "now but the thing is this this isn't this isn't even the whole story this is actually an infinitely recursive",
    "start": "253879",
    "end": "259639"
  },
  {
    "text": "structural type uh when I when I say infinite it doesn't look infinite it does seem to terminate that's because",
    "start": "259639",
    "end": "266000"
  },
  {
    "text": "the compiler has a little hook which says if this looks like it's infinitely recursive actually just just fall back to any or",
    "start": "266000",
    "end": "272440"
  },
  {
    "text": "something now some somewhere in here there is probably an any that is um the the the compiler getting out of jail um",
    "start": "272440",
    "end": "281000"
  },
  {
    "text": "so so that's that is probably not what we want I mean it might it might do something useful but",
    "start": "281000",
    "end": "288520"
  },
  {
    "text": "nevertheless uh last one this this is a a list of the vector companion class uh",
    "start": "288520",
    "end": "295120"
  },
  {
    "text": "companion object and the list companion object any guesses as to what this what type inferred here it's another question",
    "start": "295120",
    "end": "301160"
  },
  {
    "text": "mark I think it is a compile error yeah so the type that is",
    "start": "301160",
    "end": "307400"
  },
  {
    "text": "inferred is not actually a super type of the the the the two values it uses to",
    "start": "307400",
    "end": "313720"
  },
  {
    "text": "work out what the super type is so what do we have",
    "start": "313720",
    "end": "318680"
  },
  {
    "text": "list yeah so so we get uh we get in fact two compile errors one one for each of",
    "start": "320960",
    "end": "327120"
  },
  {
    "text": "the values uh neither of which is the type",
    "start": "327120",
    "end": "332840"
  },
  {
    "text": "that it should obviously be I mean list of any would be a better better type to",
    "start": "332840",
    "end": "338479"
  },
  {
    "text": "infer than than than whatever this is so there we are uh it doesn't always work",
    "start": "338479",
    "end": "344240"
  },
  {
    "text": "as we would like it to so what are the things that that may",
    "start": "344240",
    "end": "349479"
  },
  {
    "text": "influence um type inference I mean the compiler is doing it all the time whenever it evaluates an expression a",
    "start": "349479",
    "end": "354600"
  },
  {
    "text": "polymorphic expression there is there's a a type there that the compiler has to work out in order to know what to do",
    "start": "354600",
    "end": "360240"
  },
  {
    "text": "with that expression so if you apply a parameter to uh to something then that",
    "start": "360240",
    "end": "365680"
  },
  {
    "text": "that will influence maybe the uh the the type that's in that expression if",
    "start": "365680",
    "end": "370919"
  },
  {
    "text": "there's an expected return type so if if you are use if you're putting an expression in a parameter position where",
    "start": "370919",
    "end": "376360"
  },
  {
    "text": "the the the type of that parameter is known that that becomes the expected return type and that can influence how",
    "start": "376360",
    "end": "381960"
  },
  {
    "text": "the expression is evaluated if it takes an implicit and if",
    "start": "381960",
    "end": "387560"
  },
  {
    "text": "there exists a a single unique implicit if there's no implicit it doesn't work if there are if there's more than one it",
    "start": "387560",
    "end": "393319"
  },
  {
    "text": "won't help but if there's a unique one that can force it down a certain route uh with with with type inference and it",
    "start": "393319",
    "end": "399080"
  },
  {
    "text": "can infer a type based on that and of course if you just write the typ in in square brackets in in the",
    "start": "399080",
    "end": "406400"
  },
  {
    "text": "expression then that will that will maybe obviously uh very strongly",
    "start": "406400",
    "end": "412599"
  },
  {
    "text": "influence what the type is maybe maybe it will it will it will infer it into a type",
    "start": "412599",
    "end": "418039"
  },
  {
    "text": "error okay type this is just a reminder you can sing this if you like uh I'm not going to so",
    "start": "418039",
    "end": "424639"
  },
  {
    "text": "the nothing types A subtype of the null pointer exception type the null pointer exception types to subtype of etc etc",
    "start": "424639",
    "end": "430319"
  },
  {
    "text": "etc um all the way down to any I'm going to use these as examples um I've",
    "start": "430319",
    "end": "436639"
  },
  {
    "text": "colorcoded them to make it easier I hope maybe not easier to read nothing is that",
    "start": "436639",
    "end": "442280"
  },
  {
    "text": "that does say nothing at the top there um in in in bright bright hot yellow",
    "start": "442280",
    "end": "447680"
  },
  {
    "text": "down to cold red with uh with the any type at the bottom um but I'll mainly be using as an example of of a type",
    "start": "447680",
    "end": "455319"
  },
  {
    "text": "hierarchy that's quite simple and that we're hopefully all very familiar with runtime exception is a subtype of",
    "start": "455319",
    "end": "460840"
  },
  {
    "text": "exception which is a subtype of throwable so I'll I'll use these in a few places so this is just a just a",
    "start": "460840",
    "end": "466520"
  },
  {
    "text": "quick reminder uh right um so parameters if we",
    "start": "466520",
    "end": "475400"
  },
  {
    "text": "if we have a method called Fu which takes a single parameter t we can infer the type of T from the",
    "start": "475400",
    "end": "483400"
  },
  {
    "text": "value we we we choose to apply to that that method so Fu of new exception will",
    "start": "483400",
    "end": "488599"
  },
  {
    "text": "give us uh the type inferred as exception nothing nothing clever at all there",
    "start": "488599",
    "end": "494159"
  },
  {
    "text": "really if we have two parameters but what the compiler does is",
    "start": "494159",
    "end": "499680"
  },
  {
    "text": "it needs to find a suitable T that works for both parameters so say we had exception and",
    "start": "499680",
    "end": "506199"
  },
  {
    "text": "error well neither the type exception nor the type error would be appropriate there because it would it would break",
    "start": "506199",
    "end": "512279"
  },
  {
    "text": "either one of those parameters so it it falls back to throw ball now this this shouldn't be too alien to to most people",
    "start": "512279",
    "end": "519839"
  },
  {
    "text": "here and what the compiler does it just finds the best type that fits uh fits all the",
    "start": "519839",
    "end": "525399"
  },
  {
    "text": "parameters now this is a u a least upper bound or a l uh who's familiar with",
    "start": "525399",
    "end": "532040"
  },
  {
    "text": "ls good good so the uh in our in our type",
    "start": "532040",
    "end": "538760"
  },
  {
    "text": "hierarchy at the top of the hierarchy we always have any any is the uh any is the",
    "start": "538760",
    "end": "544279"
  },
  {
    "text": "top type nothing is the bottom type and everything else fits between these",
    "start": "544279",
    "end": "549920"
  },
  {
    "text": "two as I've said there and there is a diagram that is missing unfortunately but well it's not that unfortunate",
    "start": "549920",
    "end": "555399"
  },
  {
    "text": "because it was a really terrible diagram it was it was a little bit larger than the the missing image I there and it it",
    "start": "555399",
    "end": "561920"
  },
  {
    "text": "came from I think I think it's originally from the uh the scolar language spec great source of uh no no",
    "start": "561920",
    "end": "567959"
  },
  {
    "text": "it's it just came from the language spec um great source of something uh inspiration possibly um which",
    "start": "567959",
    "end": "575880"
  },
  {
    "text": "yeah I I can't I can't believe I'm trying to explain a diagram that's missing it's it's not very exciting anyway so imagine a diagram an an",
    "start": "575880",
    "end": "584120"
  },
  {
    "text": "abstract diagram with any of the top and and nothing at the bottom that that's what would be",
    "start": "584120",
    "end": "590360"
  },
  {
    "text": "there so uh say we are the compiler we're trying to work out a a least upper",
    "start": "591120",
    "end": "597240"
  },
  {
    "text": "Bound for uh for our expression so the first thing we want to",
    "start": "597240",
    "end": "602640"
  },
  {
    "text": "do is find the intersection of all the super types of the the types that are",
    "start": "602640",
    "end": "608160"
  },
  {
    "text": "involved in that by the way I'll show you an example in a second grab the intersection of all the super types of",
    "start": "608160",
    "end": "615040"
  },
  {
    "text": "the types that are that are applied as parameters in in this expression uh and we're going to ignore",
    "start": "615040",
    "end": "621680"
  },
  {
    "text": "type parameters because that complicates things at least for the moment now if if there are uh super",
    "start": "621680",
    "end": "628839"
  },
  {
    "text": "types that are that are implied Anyway by by the presence of uh of the types in our intersection then",
    "start": "628839",
    "end": "636560"
  },
  {
    "text": "we can remove them because they're sort of implied anyway and the answer the the the L is going to be the intersection of",
    "start": "636560",
    "end": "643600"
  },
  {
    "text": "all these types now this probably doesn't make a lot of sense until I show you an example um so let's let's take for",
    "start": "643600",
    "end": "651800"
  },
  {
    "text": "example we've got a list uh of right of zero and left of two so they're both",
    "start": "651800",
    "end": "657440"
  },
  {
    "text": "they're both um ISS of integers or either of integer",
    "start": "657440",
    "end": "664639"
  },
  {
    "text": "comma integer but we we're ignoring the typ parameters for now so we can just write that the the right value the first",
    "start": "664639",
    "end": "670800"
  },
  {
    "text": "parameter has these super types right either product serializable any ref and",
    "start": "670800",
    "end": "677240"
  },
  {
    "text": "any and the left second parameter has pretty much the same except instead of",
    "start": "677240",
    "end": "682519"
  },
  {
    "text": "right it has left so as I said we find the intersection between these two",
    "start": "682519",
    "end": "687560"
  },
  {
    "text": "lists so we lose the right the left and then I said we remove the Redundant",
    "start": "687560",
    "end": "692880"
  },
  {
    "text": "super type so of these which ones can we get rid of any",
    "start": "692880",
    "end": "698360"
  },
  {
    "text": "suggestions nuf and any okay so we're left with either product and",
    "start": "698360",
    "end": "704839"
  },
  {
    "text": "serializable and we find the intersection type of these which leaves us with either with product with",
    "start": "704839",
    "end": "711560"
  },
  {
    "text": "serializable which is why we got that result before even though we we thought",
    "start": "711560",
    "end": "716800"
  },
  {
    "text": "actually maybe it wasn't uh wasn't what we we wanted",
    "start": "716800",
    "end": "723160"
  },
  {
    "text": "okay so you know Scara can do multiple parameter blocks unlike Java and we can",
    "start": "723160",
    "end": "729760"
  },
  {
    "text": "have a we can have a a type parameter should I use this or should I use the uh the the othered benefit of",
    "start": "729760",
    "end": "736440"
  },
  {
    "text": "the laser PO is you can see how how shaky I am I hoped I'd be really cold and then",
    "start": "736440",
    "end": "742519"
  },
  {
    "text": "then my Shivers would be sort of an antiphase with my nerves but uh so we we've got uh fn1 this this is the same",
    "start": "742519",
    "end": "751440"
  },
  {
    "text": "as we saw before with with with creating a list for example fn2 takes two",
    "start": "751440",
    "end": "757320"
  },
  {
    "text": "separate parameter blocks and the way the compiler works is it will work out the it will work out",
    "start": "757320",
    "end": "766320"
  },
  {
    "text": "t for the first block without looking at the second one it won't use any information from the",
    "start": "766320",
    "end": "772920"
  },
  {
    "text": "the value you've got in the second Block in order to work out T and once T is established that's it it's not going to",
    "start": "772920",
    "end": "778600"
  },
  {
    "text": "change now if we were to write this function two the inferred type from this it'll be",
    "start": "778600",
    "end": "786399"
  },
  {
    "text": "a bit like that sum type I showed you at the beginning sum of 42 it will infer",
    "start": "786399",
    "end": "791720"
  },
  {
    "text": "right not either which means that when we apply the second parameter second",
    "start": "791720",
    "end": "798040"
  },
  {
    "text": "parameter block we get a compile error because left is not a subtype of right so that's no",
    "start": "798040",
    "end": "804519"
  },
  {
    "text": "good we can get around it by artificially adding this this type of description here but it's it's not what",
    "start": "804519",
    "end": "810600"
  },
  {
    "text": "we want it's not we want to have to do um so in this particular case if if",
    "start": "810600",
    "end": "816279"
  },
  {
    "text": "if this is the kind of code you want to write don't use two parameter blocks use",
    "start": "816279",
    "end": "821880"
  },
  {
    "text": "one we can also have something like this which takes a more complicated argument involving t as the second parameter now",
    "start": "822120",
    "end": "828800"
  },
  {
    "text": "this this can actually be useful we we we're we're taking advantage of the fact that the first parameter block is done",
    "start": "828800",
    "end": "834199"
  },
  {
    "text": "separately from the the second because we can we can safely",
    "start": "834199",
    "end": "840480"
  },
  {
    "text": "put a value in here we put the string 42 don't know why but string of 42 there",
    "start": "840480",
    "end": "848279"
  },
  {
    "text": "and this this function here we're able to just say underscore plus one so it's a it's a Lambda now nowhere have I have",
    "start": "848279",
    "end": "856160"
  },
  {
    "text": "I suggested that that this is a a Lambda from a string to a to a",
    "start": "856160",
    "end": "862639"
  },
  {
    "text": "string except this parameter here so as soon as we we apply the 42 here as a",
    "start": "862639",
    "end": "868399"
  },
  {
    "text": "string T is known to be a string and we use",
    "start": "868399",
    "end": "873440"
  },
  {
    "text": "that in determining what this what this parameter here is what what uh H how to",
    "start": "873440",
    "end": "879440"
  },
  {
    "text": "understand what this plus actually represents this is a string concatenation plus it's not an in or or",
    "start": "879440",
    "end": "884959"
  },
  {
    "text": "long addition Plus or any other kind of",
    "start": "884959",
    "end": "890399"
  },
  {
    "text": "plus so what's generally happening here and this this was something I I didn't",
    "start": "890399",
    "end": "895639"
  },
  {
    "text": "really I I never really thought of until I spoke to Adrian mod was um when I as",
    "start": "895639",
    "end": "901000"
  },
  {
    "text": "part of my research for this talk I I went out to see him in in Switzerland and asked him loads of questions about",
    "start": "901000",
    "end": "907160"
  },
  {
    "text": "the type system and he said think of it as a constraint system and there are various constraints",
    "start": "907160",
    "end": "913480"
  },
  {
    "text": "that are um sort of provided to the to the the solver the type system the type",
    "start": "913480",
    "end": "921440"
  },
  {
    "text": "inferencing come from different things like the the expected return type the the uh the results of implicit search",
    "start": "921440",
    "end": "927399"
  },
  {
    "text": "and so on and all it does is solves an expression for a given set of constraints now",
    "start": "927399",
    "end": "933480"
  },
  {
    "text": "that's not a simple thing to do but but that is that is one way of looking at it and we get problems if the system's",
    "start": "933480",
    "end": "940680"
  },
  {
    "text": "over constrained if it's over constrained then there is no possible type that will that will satisfy all of",
    "start": "940680",
    "end": "945959"
  },
  {
    "text": "the constraints we've we've suggested and you get a compile error or if it's under constrained in which case the",
    "start": "945959",
    "end": "951839"
  },
  {
    "text": "compiler will probably tell you you need to specify a type somewhere you need to add or or or prer nothing or or any or",
    "start": "951839",
    "end": "961079"
  },
  {
    "text": "any value yeah whatever you like pick",
    "start": "961079",
    "end": "969319"
  },
  {
    "text": "something okay little diversion here I I I tweeted recently about uh how you can",
    "start": "969560",
    "end": "975920"
  },
  {
    "text": "how you can provide a default for a type parameter now often you'll write some code that that that takes a you'll write",
    "start": "975920",
    "end": "981880"
  },
  {
    "text": "a method that takes a type parameter and you will want that method to do something useful if you don't",
    "start": "981880",
    "end": "987440"
  },
  {
    "text": "specify the type parameter but you'll want it to do exactly what you say if you do specify the type",
    "start": "987440",
    "end": "992920"
  },
  {
    "text": "parameter now the way to do this uh I'm not going to give you the code because it's it's not long but it'll take",
    "start": "992920",
    "end": "999319"
  },
  {
    "text": "probably a long time to talk through and uh if you if you want to find out how to do it uh follow me on Twitter and check",
    "start": "999319",
    "end": "1005759"
  },
  {
    "text": "my tweets for the last couple of days um the the the way the way it's",
    "start": "1005759",
    "end": "1012600"
  },
  {
    "text": "basically done is using implicit search and and prioritization of implicits and it it it does some some people said it",
    "start": "1012600",
    "end": "1018240"
  },
  {
    "text": "was a hack I don't think it's any more of a hack than many other things that that",
    "start": "1018240",
    "end": "1023800"
  },
  {
    "text": "certainly I do but",
    "start": "1023800",
    "end": "1027959"
  },
  {
    "text": "uh um yeah",
    "start": "1029199",
    "end": "1034558"
  },
  {
    "text": "maybe so so okay here here's here's a here's a here's the the simplest method I could come up with that uh that uses a",
    "start": "1036640",
    "end": "1043360"
  },
  {
    "text": "default and we want we want a default for T all we do is we add an implicit parameter which uh uses this infix type",
    "start": "1043360",
    "end": "1050480"
  },
  {
    "text": "defaults to so I'm going to say that t our T type defaults to string okay and that means that we can",
    "start": "1050480",
    "end": "1057520"
  },
  {
    "text": "say for of apple and this remember we're actually inferring the return type it's",
    "start": "1057520",
    "end": "1062559"
  },
  {
    "text": "always null but uh we successfully get the the Apple we wanted by specifying it there but if we don't specify it we get",
    "start": "1062559",
    "end": "1069480"
  },
  {
    "text": "string which is which came from this default here so if you've ever wanted a",
    "start": "1069480",
    "end": "1074600"
  },
  {
    "text": "uh a default type parameter um it's about three lines of code they're a bit hacky uh but they",
    "start": "1074600",
    "end": "1082000"
  },
  {
    "text": "they do work in at least some simple examples such as the the very useful ones I've shown you",
    "start": "1082000",
    "end": "1089320"
  },
  {
    "text": "here another thing we might want to do sometimes you have a method",
    "start": "1089320",
    "end": "1094840"
  },
  {
    "text": "that takes two type parameters it needs to take two two type parameters because fundamentally it uses like a a",
    "start": "1094840",
    "end": "1102919"
  },
  {
    "text": "type T and A type S but one of them you want to be specified by the user because the user",
    "start": "1102919",
    "end": "1109440"
  },
  {
    "text": "is sort of controlling what the method does by virtue of specifying the type but the other one is is something that",
    "start": "1109440",
    "end": "1115159"
  },
  {
    "text": "that exists just because it the the method is is polymorphic and needs to be",
    "start": "1115159",
    "end": "1120559"
  },
  {
    "text": "there so you don't want don't really want the user to have to specify it so it's a bit like this we've got",
    "start": "1120559",
    "end": "1126280"
  },
  {
    "text": "this this action method which takes a parameter T and we we would normally",
    "start": "1126280",
    "end": "1132159"
  },
  {
    "text": "specify s manually in order to determine which type class gets pulled in through",
    "start": "1132159",
    "end": "1137400"
  },
  {
    "text": "the implicit does this look Vaguely Familiar to anyone yeah I've got a few nods that's good so you can rewrite that",
    "start": "1137400",
    "end": "1144640"
  },
  {
    "text": "as this first define a class um which takes an apply method or",
    "start": "1144640",
    "end": "1149679"
  },
  {
    "text": "which has an apply method which deals with the uh well",
    "start": "1149679",
    "end": "1156840"
  },
  {
    "text": "let's do it backwards we deal with the the specified type first def action S one type",
    "start": "1156840",
    "end": "1163760"
  },
  {
    "text": "parameter and that will create our new unapplied class",
    "start": "1163760",
    "end": "1168880"
  },
  {
    "text": "and then this will automatically uh as soon as you apply as",
    "start": "1168880",
    "end": "1174440"
  },
  {
    "text": "as soon as you provide the T parameter can you will see the cursor there it's it's not not brilliantly clear but um as",
    "start": "1174440",
    "end": "1182159"
  },
  {
    "text": "soon as you apply the T this method here will be invoked and the T will be inferred so you can I hope I've got an",
    "start": "1182159",
    "end": "1188360"
  },
  {
    "text": "example we can say action string and the that the T type which is",
    "start": "1188360",
    "end": "1193760"
  },
  {
    "text": "int will be automatically inferred so that's that's one thing you",
    "start": "1193760",
    "end": "1199360"
  },
  {
    "text": "can do to make make your apis a little bit nicer how am I doing for time 29 minutes oh to go or oh excellent",
    "start": "1199360",
    "end": "1208760"
  },
  {
    "text": "okay and I'm yeah about a third of the way through good so in in Scara uh subtyping is",
    "start": "1208760",
    "end": "1217840"
  },
  {
    "text": "nominal now what I mean by that is that it's determined by the names of of the types the names of the classes you",
    "start": "1217840",
    "end": "1223559"
  },
  {
    "text": "define and the traits and so on if you say something is a subtype of something else then is now it must be",
    "start": "1223559",
    "end": "1231080"
  },
  {
    "text": "structurally sound as well you can't you can't have a uh have a type which has",
    "start": "1231080",
    "end": "1236720"
  },
  {
    "text": "methods which just don't make sense just because you say they just because you say one is a subtype of the",
    "start": "1236720",
    "end": "1242480"
  },
  {
    "text": "other so given given a couple of types b and a we can say B is a subtype of a if",
    "start": "1242480",
    "end": "1248039"
  },
  {
    "text": "vaguely it has the same capabilities as a what does that mean well if B can be a",
    "start": "1248039",
    "end": "1254440"
  },
  {
    "text": "subtype of a if all the methods of B have the same capabilities as as as A's",
    "start": "1254440",
    "end": "1259679"
  },
  {
    "text": "equivalent methods methods with the same name so if all methods take and return",
    "start": "1259679",
    "end": "1266640"
  },
  {
    "text": "compatible types and B's methods must must accept every argument that the equivalent method in a",
    "start": "1266640",
    "end": "1273880"
  },
  {
    "text": "will accept now subtly differently B's method must return some value not every value",
    "start": "1273880",
    "end": "1281480"
  },
  {
    "text": "some value that A's method could return now this is the subtle difference between co-variance and contravariance",
    "start": "1281480",
    "end": "1289200"
  },
  {
    "text": "return types of methods are covariant they vary with the type",
    "start": "1289200",
    "end": "1294600"
  },
  {
    "text": "whereas parameter types are contravariant they they vary in sort of the the opposite direction",
    "start": "1294600",
    "end": "1301720"
  },
  {
    "text": "I'll hopefully show you some examples of this who is very comfortable with",
    "start": "1301720",
    "end": "1308279"
  },
  {
    "text": "covariance and contravariance and invariance there's Dean who was here in the first time I gave this talk is still",
    "start": "1308279",
    "end": "1314480"
  },
  {
    "text": "comfortable with it so so at the very least by giving the talk to Dean before didn't I didn't make him worse at uh at",
    "start": "1314480",
    "end": "1322000"
  },
  {
    "text": "variants which was a risk let's have a look is there some",
    "start": "1322000",
    "end": "1327840"
  },
  {
    "text": "water down here so I'm using color coding again uh covariant stuff will be",
    "start": "1327840",
    "end": "1336399"
  },
  {
    "text": "purple and contravariant stuff will be Canan is everyone okay with that",
    "start": "1338240",
    "end": "1346890"
  },
  {
    "text": "[Laughter] it's too late",
    "start": "1346890",
    "end": "1352200"
  },
  {
    "text": "now so I I will I will also uh I'll also hopefully make it very obvious that that",
    "start": "1352720",
    "end": "1357760"
  },
  {
    "text": "super is a super type sub is a subtype of of super this is the little symbol we use for is a uh is a super type",
    "start": "1357760",
    "end": "1366120"
  },
  {
    "text": "of so covariant things vary with their",
    "start": "1366120",
    "end": "1371919"
  },
  {
    "text": "types So Co a covariant type like list for example will vary in the same way",
    "start": "1371919",
    "end": "1377240"
  },
  {
    "text": "that uh that that the the type of the list or the type of the covariant thing varies",
    "start": "1377240",
    "end": "1384360"
  },
  {
    "text": "so because super is a super type of sub we can therefore infer that Co of super",
    "start": "1384360",
    "end": "1391520"
  },
  {
    "text": "is a super type of Co of",
    "start": "1391520",
    "end": "1395600"
  },
  {
    "text": "sub now if we change that to Contra this Arrow verses reverses uh",
    "start": "1397520",
    "end": "1404320"
  },
  {
    "text": "super contra of super is now a subtype",
    "start": "1404320",
    "end": "1409799"
  },
  {
    "text": "of Contra of sub now the reason is in order to make those methods work in in the types in",
    "start": "1409799",
    "end": "1416159"
  },
  {
    "text": "order for the in order for the methods to accept suitable parameters which may be dependent on the parameter type the",
    "start": "1416159",
    "end": "1424279"
  },
  {
    "text": "the parameter type there the generic type parameter we must we must have those",
    "start": "1424279",
    "end": "1430440"
  },
  {
    "text": "method parameters varying in a contravariant way otherwise we we we leave open the",
    "start": "1430440",
    "end": "1437679"
  },
  {
    "text": "possibility that you could call a call a method on a typee that just can't deal with that particular",
    "start": "1437679",
    "end": "1443919"
  },
  {
    "text": "value for now we can just think of Contra is working in",
    "start": "1443919",
    "end": "1449480"
  },
  {
    "text": "Reverse we can we can Nest these further So Co of Co of super is a super type of Co of Co of sub and Contra of",
    "start": "1449520",
    "end": "1458200"
  },
  {
    "text": "Contra now this these two effectively cancel each other out so you reverse it then you reverse",
    "start": "1458200",
    "end": "1464000"
  },
  {
    "text": "it again you get back to covariance so Contra of Contra of something is a",
    "start": "1464000",
    "end": "1469919"
  },
  {
    "text": "covariant type so uh you're all following",
    "start": "1469919",
    "end": "1476440"
  },
  {
    "text": "this we can mix them up Contra of Co of super is a subtype now because there's",
    "start": "1476440",
    "end": "1481720"
  },
  {
    "text": "one Contra in there and uh same thing if we have Co of Contra of super is a",
    "start": "1481720",
    "end": "1488080"
  },
  {
    "text": "subtype of Co of Contra of sub okay that's it it takes a while to",
    "start": "1488080",
    "end": "1496799"
  },
  {
    "text": "get around this so the easiest thing to do is just think whether the the types are covariant represented by a plus in",
    "start": "1496799",
    "end": "1502399"
  },
  {
    "text": "the in the definition or contravariant represented by a minus sign and you multiply the minus",
    "start": "1502399",
    "end": "1508399"
  },
  {
    "text": "signs we we can say that in this this example",
    "start": "1508399",
    "end": "1513960"
  },
  {
    "text": "here this or let's take this example here actually Contra of Contra of super",
    "start": "1513960",
    "end": "1519159"
  },
  {
    "text": "contra of super is covariant sorry is is",
    "start": "1519159",
    "end": "1524919"
  },
  {
    "text": "contravariant in that particular position super is covariant in that",
    "start": "1525159",
    "end": "1532880"
  },
  {
    "text": "position silence have you had enough of Co cence and contance",
    "start": "1532880",
    "end": "1540039"
  },
  {
    "text": "yet uh if if if you haven't got it now then um there there are uh there's a",
    "start": "1540039",
    "end": "1546399"
  },
  {
    "text": "whole lifetime ahead of you to to practice it we also have invariants just to make",
    "start": "1546399",
    "end": "1552520"
  },
  {
    "text": "things a little bit more confusing I'm only going to briefly mention in invariance that's when something's neither covariant or contant it doesn't",
    "start": "1552520",
    "end": "1559720"
  },
  {
    "text": "vary so if it doesn't doesn't have a plus or a minus in the in the definition",
    "start": "1559720",
    "end": "1565039"
  },
  {
    "text": "so one example of a of an invariant trait in I can't if it's a trait or a class but a type in Scala is",
    "start": "1565039",
    "end": "1571880"
  },
  {
    "text": "ordering you can you can compare two things using an ordering provided they",
    "start": "1571880",
    "end": "1577399"
  },
  {
    "text": "are the same type um we we could argue that it's not mean it's not really meaningful to to",
    "start": "1577399",
    "end": "1584320"
  },
  {
    "text": "compare the the The Ordering of something and a subtype of that thing",
    "start": "1584320",
    "end": "1589480"
  },
  {
    "text": "I mean there might be a there might be a total ordering somehow but um it's it's not something you would normally want to",
    "start": "1589480",
    "end": "1596640"
  },
  {
    "text": "do so if uh if sub is a subtype of super so same relationship as before there is",
    "start": "1596960",
    "end": "1603120"
  },
  {
    "text": "no subtyping relationship between ordering of sub and ordering of super it might be that you can cast them",
    "start": "1603120",
    "end": "1609520"
  },
  {
    "text": "and it might be that in the case of ordering this will actually work but in the general",
    "start": "1609520",
    "end": "1614760"
  },
  {
    "text": "case there is no there's no relationship between ordering of sub and ordering of",
    "start": "1614760",
    "end": "1619840"
  },
  {
    "text": "super no no no uh no subtyping relationship is is uh is implied just",
    "start": "1619840",
    "end": "1625720"
  },
  {
    "text": "because the parameters happen to be uh a subtype of or one is a sub type of the",
    "start": "1625720",
    "end": "1631720"
  },
  {
    "text": "other is that okay or at least sort of vaguely",
    "start": "1631720",
    "end": "1638600"
  },
  {
    "text": "acceptable so uh G given given ordering of exception and ordering of throw throwable these two types are in many",
    "start": "1638720",
    "end": "1645279"
  },
  {
    "text": "ways as different as int and string they they are they are I mean they're both orderings but",
    "start": "1645279",
    "end": "1650520"
  },
  {
    "text": "they're that they're not relate they don't have a subtyping relationship but be careful because if",
    "start": "1650520",
    "end": "1657240"
  },
  {
    "text": "we have a fo of te and a bar of T and there's a relationship between the the",
    "start": "1657240",
    "end": "1663640"
  },
  {
    "text": "the the N generic part of the type then we still have the relationship",
    "start": "1663640",
    "end": "1669320"
  },
  {
    "text": "there between those two provided they have the same the same type so that's that's maybe a possible",
    "start": "1669320",
    "end": "1677440"
  },
  {
    "text": "trap you could follow into into thinking that there is always no relationship between them we can still have",
    "start": "1677440",
    "end": "1684919"
  },
  {
    "text": "that right I waffled a bit before about uh how to calculate the least upper",
    "start": "1684919",
    "end": "1690559"
  },
  {
    "text": "bound uh this is this is basically what I said before and I said we ignore the type",
    "start": "1690559",
    "end": "1697399"
  },
  {
    "text": "parameters because this is this is a little bit more complicated so with type",
    "start": "1697399",
    "end": "1702760"
  },
  {
    "text": "parameters we follow the procedure as we did before we find the lab of the of the main type",
    "start": "1702760",
    "end": "1708880"
  },
  {
    "text": "and then we look at the type parameters and we trace the type parameters through the through the the",
    "start": "1708880",
    "end": "1715519"
  },
  {
    "text": "the supertypes so um generally if you have a type like",
    "start": "1715519",
    "end": "1721279"
  },
  {
    "text": "write of int that that int can be traced back to the uh the second parameter of the",
    "start": "1721279",
    "end": "1729159"
  },
  {
    "text": "either type that is its super TR that's what I mean by tracing it through to the",
    "start": "1729159",
    "end": "1734440"
  },
  {
    "text": "uh to to its parent type and we then have to do two different",
    "start": "1734440",
    "end": "1741200"
  },
  {
    "text": "things depending on whether that type parameter in in the definition so in the definition of either whether that type",
    "start": "1741200",
    "end": "1746640"
  },
  {
    "text": "is covariant or contravariant if it's covariant we do",
    "start": "1746640",
    "end": "1752080"
  },
  {
    "text": "the same thing with the type parameters we we find the lab as we did previously if it's",
    "start": "1752080",
    "end": "1758440"
  },
  {
    "text": "contravariant instead of the lab we found we find the Glo the greatest lower",
    "start": "1758440",
    "end": "1764440"
  },
  {
    "text": "bound uh now this is this is uh I think actually easier than finding the love",
    "start": "1764440",
    "end": "1769640"
  },
  {
    "text": "you just find the intersection type so um it's a with B with C you just you",
    "start": "1769640",
    "end": "1775000"
  },
  {
    "text": "just with them together and that will give you the Glo of the uh of the types",
    "start": "1775000",
    "end": "1781000"
  },
  {
    "text": "for a contravariant parameter and you recurse on any nested parameters so so if it's a complicated",
    "start": "1781000",
    "end": "1787840"
  },
  {
    "text": "expression with with deeply deeply nested types you use the same algorithm over and over again uh it's a bit it's a",
    "start": "1787840",
    "end": "1795600"
  },
  {
    "text": "bit generous to call this an algorithm it it really is a sort of this is vaguely what happens there are details",
    "start": "1795600",
    "end": "1802399"
  },
  {
    "text": "which I haven't mentioned so one other possible thing that can uh can influence the the type",
    "start": "1802399",
    "end": "1810679"
  },
  {
    "text": "of an expression when you're when you're evaluating it is the return type the return type",
    "start": "1810679",
    "end": "1819039"
  },
  {
    "text": "that's expected for the position that that uh that expression is in in the",
    "start": "1819039",
    "end": "1824720"
  },
  {
    "text": "code here are two methods which look very similar they have different names and",
    "start": "1824720",
    "end": "1832200"
  },
  {
    "text": "they have different return types one returns an ordering one returns a list I haven't shown you the implementations",
    "start": "1832200",
    "end": "1838120"
  },
  {
    "text": "because they're boring I also don't know what they they do",
    "start": "1838120",
    "end": "1843440"
  },
  {
    "text": "really and and I've also I've also made these uh any to to kind of indicate that",
    "start": "1843720",
    "end": "1849760"
  },
  {
    "text": "that that type is not an interesting type pretend it's not",
    "start": "1849760",
    "end": "1855200"
  },
  {
    "text": "there so we can call these these two things here X these these should look very similar except this is using an",
    "start": "1855200",
    "end": "1861240"
  },
  {
    "text": "ordering this one's using a list and we call the different methods here what happens do both of them work",
    "start": "1861240",
    "end": "1869440"
  },
  {
    "text": "do neither of them work does one of them work one of them Works which",
    "start": "1869440",
    "end": "1874600"
  },
  {
    "text": "one the one which isn't the one which isn't covariant correct um so it would actually",
    "start": "1874600",
    "end": "1882440"
  },
  {
    "text": "yeah uh first thing to note is that Scala can't infer the type of something",
    "start": "1882440",
    "end": "1887600"
  },
  {
    "text": "just Lambda I I kind of touched on this before where um where I had a had a",
    "start": "1887600",
    "end": "1893519"
  },
  {
    "text": "Lambda which wasn't where the parameter to the Lambda was not explicitly ascribed to type scolar just doesn't",
    "start": "1893519",
    "end": "1900480"
  },
  {
    "text": "know how to do that there there are generally speaking too many possible things or too many possible um things",
    "start": "1900480",
    "end": "1908320"
  },
  {
    "text": "that could influence what that type is sculla could do more more more Global analysis of of",
    "start": "1908320",
    "end": "1915840"
  },
  {
    "text": "the code that exists inside that lambra and make a guess as to what the uh what the what the type is meant to be but it",
    "start": "1915840",
    "end": "1923799"
  },
  {
    "text": "then becomes a a horrendously complicated system as opposed to a a mildly no it's not it is horrendously",
    "start": "1923799",
    "end": "1930760"
  },
  {
    "text": "complicated either way but it it's it's it's it is yet further away from simple so it just doesn't try and try",
    "start": "1930760",
    "end": "1938240"
  },
  {
    "text": "and infer the type of Lambda unless it's got some more information now with",
    "start": "1938240",
    "end": "1944039"
  },
  {
    "text": "ordering the these are the two definitions from The Scholar standard Library source code on ordering and list",
    "start": "1944039",
    "end": "1950960"
  },
  {
    "text": "uh they differ and that's a trait that's a sealed abstract class but that's not the relevant bit it's this plus here",
    "start": "1950960",
    "end": "1957159"
  },
  {
    "text": "that is the thing that makes list different from ordering and which means that list does not",
    "start": "1957159",
    "end": "1962960"
  },
  {
    "text": "work so if our return type is ordering then we can say that the return",
    "start": "1962960",
    "end": "1968360"
  },
  {
    "text": "values type is anything that's a sub type of ordering of",
    "start": "1968360",
    "end": "1975360"
  },
  {
    "text": "T now ordering is invariant so we can say that the T must be exactly",
    "start": "1975360",
    "end": "1981559"
  },
  {
    "text": "T the T does not vary it is invariant so we therefore know what T is",
    "start": "1981559",
    "end": "1987039"
  },
  {
    "text": "for the for the function parameter value so although although invariance",
    "start": "1987039",
    "end": "1994399"
  },
  {
    "text": "may seem like you haven't put the effort in to add all those uh add all those pluses and minuses throughout your",
    "start": "1994399",
    "end": "1999880"
  },
  {
    "text": "massive hierarchy of types it actually gives us gives us an easy answer here",
    "start": "1999880",
    "end": "2006720"
  },
  {
    "text": "but in the case of list list is covariant in its in its parameter",
    "start": "2006720",
    "end": "2012840"
  },
  {
    "text": "T so I'm I'm going to I'm going to read this out we only know that the actual t for the expression is a super type of",
    "start": "2012840",
    "end": "2019480"
  },
  {
    "text": "something which is a subtype of the expected return type what is that saying it's saying",
    "start": "2019480",
    "end": "2026120"
  },
  {
    "text": "very little about t we don't know anything from that it's something which is a super type and something which is a",
    "start": "2026120",
    "end": "2031200"
  },
  {
    "text": "subtype it could be anything we know nothing about it therefore our system is under constrained and there is no useful",
    "start": "2031200",
    "end": "2037919"
  },
  {
    "text": "information to come from uh from from the expected return type to infer that",
    "start": "2037919",
    "end": "2045880"
  },
  {
    "text": "uh that that that type T when used in the Lambda is that okay does that make",
    "start": "2045880",
    "end": "2054158"
  },
  {
    "text": "sense is that correct I had to think about that quite long and hard to to come up with a",
    "start": "2054159",
    "end": "2060839"
  },
  {
    "text": "wording that that made some sense I I hope it's at least close right so uh constraint from Return",
    "start": "2060839",
    "end": "2068200"
  },
  {
    "text": "types are only useful in inferring types which are in positions where where the",
    "start": "2068200",
    "end": "2073760"
  },
  {
    "text": "the the variance matches so we have to have to work a",
    "start": "2073760",
    "end": "2079358"
  },
  {
    "text": "little bit to to check that the the variance does actually match Contra so this is this is this is",
    "start": "2079359",
    "end": "2086440"
  },
  {
    "text": "a return type so return types are covariant contra so T is in a",
    "start": "2086440",
    "end": "2092720"
  },
  {
    "text": "contravariant position there because it's co of Contra whereas the T here well a a",
    "start": "2092720",
    "end": "2100880"
  },
  {
    "text": "parameter is contravariant but the parameter type",
    "start": "2100880",
    "end": "2106040"
  },
  {
    "text": "here is a function and the parameter type of a function the first type",
    "start": "2106040",
    "end": "2112720"
  },
  {
    "text": "parameter is itself contravariant so it's contravariant of a contravariant",
    "start": "2112720",
    "end": "2117920"
  },
  {
    "text": "thing and it's covariant of that so T is Contra Contra Co multiply the the pluses",
    "start": "2117920",
    "end": "2124760"
  },
  {
    "text": "and minuses we get that that is covariant or",
    "start": "2124760",
    "end": "2131000"
  },
  {
    "text": "contravariant did I mess up here I CH I I I changed this several",
    "start": "2131000",
    "end": "2136760"
  },
  {
    "text": "time I don't [Laughter] know try it if it works it's right if it",
    "start": "2136760",
    "end": "2143400"
  },
  {
    "text": "doesn't work change change that to Contra and the other thing to",
    "start": "2143400",
    "end": "2148720"
  },
  {
    "text": "co this is how hard it is um so we can we can write this inferred without",
    "start": "2148720",
    "end": "2155200"
  },
  {
    "text": "specifying the parameter here just by virtue of knowing the result type likewise if we reverse the Contra",
    "start": "2155200",
    "end": "2161119"
  },
  {
    "text": "and Co here we can say this this will be inferred this this type here but if they",
    "start": "2161119",
    "end": "2169400"
  },
  {
    "text": "match we have a problem we have to actually say this is this is explicitly type coent in order for it to work it",
    "start": "2169400",
    "end": "2178520"
  },
  {
    "text": "out I'm not going to ask if that's okay because it's probably not triy",
    "start": "2178520",
    "end": "2183560"
  },
  {
    "text": "out so back to our list of things which which influence type inference uh the first I'm I'm",
    "start": "2183560",
    "end": "2192160"
  },
  {
    "text": "going to order them this time so the number one thing which will definitely influence it is the is explicitly",
    "start": "2192160",
    "end": "2197680"
  },
  {
    "text": "specifying the type that will guarantee that that that it is uh that type or at",
    "start": "2197680",
    "end": "2203040"
  },
  {
    "text": "least compile error if if it's not been specified explicitly then the compiler will look",
    "start": "2203040",
    "end": "2208520"
  },
  {
    "text": "at the parameters the parameters or the the types of the values you apply to the the the method",
    "start": "2208520",
    "end": "2214359"
  },
  {
    "text": "call the types of them will will influence potentially the uh the types",
    "start": "2214359",
    "end": "2219760"
  },
  {
    "text": "in the expression if there is a unique implicit uh that that can also uh",
    "start": "2219760",
    "end": "2227040"
  },
  {
    "text": "influence the type and finally so it's it's notable that this is the this is",
    "start": "2227040",
    "end": "2232800"
  },
  {
    "text": "the last thing on the list the expected return type that is the last thing the compiler",
    "start": "2232800",
    "end": "2238520"
  },
  {
    "text": "checks or the type inference checks to see whether it can gain anything from um uh from from from from uh from from",
    "start": "2238520",
    "end": "2247200"
  },
  {
    "text": "from the well it's the last thing that that is checked in order to influence the uh the",
    "start": "2247200",
    "end": "2252880"
  },
  {
    "text": "type so what can we do to take advantage of of knowing this order of things well",
    "start": "2252880",
    "end": "2258119"
  },
  {
    "text": "if we're going to use the expected return type we have to make sure there's nothing else that beats it nothing else which influences it so no uh no",
    "start": "2258119",
    "end": "2265880"
  },
  {
    "text": "implicits that're unique no parameters in in in the",
    "start": "2265880",
    "end": "2272000"
  },
  {
    "text": "type if you uh if you're not going to use the the expected return type",
    "start": "2272520",
    "end": "2278119"
  },
  {
    "text": "and you want to use use implicits make sure they're unique or at least the most that the highest priority implicit in",
    "start": "2278119",
    "end": "2283480"
  },
  {
    "text": "scope is uh is unique and be aware that you can't infer",
    "start": "2283480",
    "end": "2291359"
  },
  {
    "text": "a type in a covariant position from a covariant return type or likewise a contravariant position from a",
    "start": "2291359",
    "end": "2296599"
  },
  {
    "text": "contravariant return type",
    "start": "2296599",
    "end": "2301920"
  },
  {
    "text": "now all the examples I've given so far have had uh pretty much a single single",
    "start": "2301920",
    "end": "2307040"
  },
  {
    "text": "type being inferred at any one time now you can have types that take several generic",
    "start": "2307040",
    "end": "2312119"
  },
  {
    "text": "parameters and these are independently excuse me independently determined so",
    "start": "2312119",
    "end": "2318680"
  },
  {
    "text": "the the the types of uh I'll I'll show you oh yeah can build from who is a fan",
    "start": "2318680",
    "end": "2324760"
  },
  {
    "text": "of can build [Music] from Full",
    "start": "2324760",
    "end": "2332250"
  },
  {
    "text": "[Laughter]",
    "start": "2332250",
    "end": "2336470"
  },
  {
    "text": "so sky has this thing called can build from which takes three parameters and the the two parameter which is uh",
    "start": "2338359",
    "end": "2345760"
  },
  {
    "text": "covariant uh this uh this this it is",
    "start": "2345760",
    "end": "2351280"
  },
  {
    "text": "dealt with independently of of the others and uh what you can do yeah we've got a whole slide on can build",
    "start": "2351280",
    "end": "2358079"
  },
  {
    "text": "from uh this is yeah we have a from type and element type and two type we can happily deal with the two",
    "start": "2358079",
    "end": "2366680"
  },
  {
    "text": "type independent ly of anything that affects the LM type or the from type uh what this does it gives you a",
    "start": "2366680",
    "end": "2373400"
  },
  {
    "text": "means of creating a new uh a new container collection from an existing",
    "start": "2373400",
    "end": "2381440"
  },
  {
    "text": "one uh and this is used extensively in the uh the wonderful collections library",
    "start": "2381440",
    "end": "2387000"
  },
  {
    "text": "in Scala with methods like map and Flat map and anything that creates uh a new",
    "start": "2387000",
    "end": "2392079"
  },
  {
    "text": "instance of a of a collection type and if you chain several of these together",
    "start": "2392079",
    "end": "2397760"
  },
  {
    "text": "you can get a type to flow all the way from the expected return type back to the uh back back back to",
    "start": "2397760",
    "end": "2405480"
  },
  {
    "text": "the uh the earliest implicits in the so the the earliest calls in in in a long",
    "start": "2405480",
    "end": "2411400"
  },
  {
    "text": "expression or a for comprehension so it sort of flows backwards and I probably don't have I've got nine",
    "start": "2411400",
    "end": "2418319"
  },
  {
    "text": "minutes no I don't have time to uh to to to spend much longer on can build from but there is an excellent answer on",
    "start": "2418319",
    "end": "2424119"
  },
  {
    "text": "stack Overflow by Danielle saal about uh about how can build from Works in",
    "start": "2424119",
    "end": "2434960"
  },
  {
    "text": "particular breakout who understands who who knows what I'm talking about",
    "start": "2435240",
    "end": "2442160"
  },
  {
    "text": "here both references one of them is pink right no",
    "start": "2442160",
    "end": "2450319"
  },
  {
    "text": "keep going ref yeah uh does anyone know us song called",
    "start": "2450319",
    "end": "2459680"
  },
  {
    "text": "breakout I I'm impressed I'm disappointed in Paul but I'm I'm dep I'm I'm I'm impressed by everyone that",
    "start": "2459680",
    "end": "2466000"
  },
  {
    "text": "breakout let the party start is uh is is is uh from from a song by Miley",
    "start": "2466000",
    "end": "2472160"
  },
  {
    "text": "Cyrus which which comes up whenever I search for",
    "start": "2472160",
    "end": "2477119"
  },
  {
    "text": "breakout yeah that's the only reason I know obviously um so I I'm I'm very satisfied",
    "start": "2477240",
    "end": "2484319"
  },
  {
    "text": "that actually there is nobody in the world who understands maybe maybe other than",
    "start": "2484319",
    "end": "2489800"
  },
  {
    "text": "me uh that understands I would like to meet that",
    "start": "2489800",
    "end": "2495839"
  },
  {
    "text": "person if they existed so I've um I i' I've glossed",
    "start": "2495839",
    "end": "2502359"
  },
  {
    "text": "over quite a few things uh that are related to type inference that um I I I",
    "start": "2502359",
    "end": "2508119"
  },
  {
    "text": "just didn't have time for it says eight minutes there but I'll answer some questions which I probably won't know the answer to but um overloading",
    "start": "2508119",
    "end": "2514400"
  },
  {
    "text": "overloading can uh can can really limits the capabilities of type inference uh it",
    "start": "2514400",
    "end": "2520800"
  },
  {
    "text": "makes things more complicated for the the typer weak conformance this is kind of a a a nice",
    "start": "2520800",
    "end": "2528640"
  },
  {
    "text": "little hack that the compiler does to to work out that um for example a float is a bit like a double it's not a subtype",
    "start": "2528640",
    "end": "2535440"
  },
  {
    "text": "but it's a bit like it and uh this this is used um to make a few quite simple",
    "start": "2535440",
    "end": "2544280"
  },
  {
    "text": "Expressions work as you might expect them but doesn't really scale to larger",
    "start": "2544280",
    "end": "2549760"
  },
  {
    "text": "larger things um it it really does just confuse things",
    "start": "2549760",
    "end": "2555400"
  },
  {
    "text": "a bit uh path dependent types I haven't talked about at all they are",
    "start": "2555400",
    "end": "2560880"
  },
  {
    "text": "um they're probably one area that that you may be find that as soon as you start using them stuff doesn't work or doesn't get",
    "start": "2560880",
    "end": "2568359"
  },
  {
    "text": "inferred as as you would as you would expect it to there are reasons for that um I I had to cut a load of material on",
    "start": "2568359",
    "end": "2575599"
  },
  {
    "text": "uh on on why that is unfortunately either that or I just didn't write it uh",
    "start": "2575599",
    "end": "2581160"
  },
  {
    "text": "F band of polymorphism who's familiar with that few people um you you've maybe",
    "start": "2581160",
    "end": "2586520"
  },
  {
    "text": "seen it in other people's Code E FB of polymorphis polymorphism is is a way of",
    "start": "2586520",
    "end": "2591839"
  },
  {
    "text": "I I guess oh oh okay so there there is",
    "start": "2591839",
    "end": "2597880"
  },
  {
    "text": "there's a talk coming up there is a talk coming up on F so all I will say is that",
    "start": "2597880",
    "end": "2602920"
  },
  {
    "text": "f f band of polymorph is is a way of having like",
    "start": "2602920",
    "end": "2607960"
  },
  {
    "text": "a type that is sort of both contravariant and covariant in in a class and it's kind of a if if you if",
    "start": "2607960",
    "end": "2613760"
  },
  {
    "text": "you have that it's kind of a it's a get out of jail free card and a well get out",
    "start": "2613760",
    "end": "2619119"
  },
  {
    "text": "of jail and walk straight into pergatory card",
    "start": "2619119",
    "end": "2624559"
  },
  {
    "text": "the um and of course scar has both type parameters and type members which",
    "start": "2624559",
    "end": "2629960"
  },
  {
    "text": "probably seem very similar most of the time until you until you sort of expect",
    "start": "2629960",
    "end": "2635839"
  },
  {
    "text": "your type members to be inferred in the same way that your type parameters are or your or being able to refer to type",
    "start": "2635839",
    "end": "2643640"
  },
  {
    "text": "parameters by name as you can with with type members they each have their pros and",
    "start": "2643640",
    "end": "2649119"
  },
  {
    "text": "cons and and and they're basically implemented in the same way but one is one is heavily biased towards specifying",
    "start": "2649119",
    "end": "2657240"
  },
  {
    "text": "it all the time type parameters you're kind of forced by the compiler to always specify them in in in any place you",
    "start": "2657240",
    "end": "2664440"
  },
  {
    "text": "specify the type of something whereas a type parameter your the the the syntax",
    "start": "2664440",
    "end": "2670160"
  },
  {
    "text": "is biased to not bothering to mention them and that is kind of the reason why you end up with them appearing to be",
    "start": "2670160",
    "end": "2677280"
  },
  {
    "text": "two different things that don't don't work quite as well as each other that's uh that's all I've got I've",
    "start": "2677280",
    "end": "2683599"
  },
  {
    "text": "I've got five minutes for questions uh like I said I won't I probably won't know the answer this is about the limit of my understanding or",
    "start": "2683599",
    "end": "2690680"
  },
  {
    "text": "Beyond it uh I I can't is that no yeah okay Paul what is it well I just wanted",
    "start": "2690680",
    "end": "2696520"
  },
  {
    "text": "to help you out non oh oh yeah yeah yeah go on go on you might",
    "start": "2696520",
    "end": "2704800"
  },
  {
    "text": "also sing finality did you say yeah you didn't mention single types The Finity",
    "start": "2709400",
    "end": "2715839"
  },
  {
    "text": "of influences it will a Conant single actually ah so I I'll tell you a story",
    "start": "2715839",
    "end": "2723680"
  },
  {
    "text": "about this actually I I I gave this talk in London in December and um the the the",
    "start": "2723680",
    "end": "2729720"
  },
  {
    "text": "night before I had I have dinner with Mar urki and uh I asked him does does",
    "start": "2729720",
    "end": "2735680"
  },
  {
    "text": "the finality of a of a class have any influence on on type inference he said I don't think so class oh of a class class",
    "start": "2735680",
    "end": "2743720"
  },
  {
    "text": "okay so he he's he's cor there MERS yeah anyway over over dinner it was um myself",
    "start": "2743720",
    "end": "2750960"
  },
  {
    "text": "Martin and Bill was there you you around bill yeah so so Bill can verify the story as true I I I I I I I said to",
    "start": "2750960",
    "end": "2758480"
  },
  {
    "text": "Martin I went uh so so Martin why why is it that when when you type whatever it",
    "start": "2758480",
    "end": "2764640"
  },
  {
    "text": "was list of I think I said list of vector [Music]",
    "start": "2764640",
    "end": "2770760"
  },
  {
    "text": "and uh I think maybe maybe I said this so what why why does list of vector and",
    "start": "2770760",
    "end": "2778160"
  },
  {
    "text": "and list of uh sorry list list of vector of int and list of int give you this",
    "start": "2778160",
    "end": "2784480"
  },
  {
    "text": "horrendous type and I oh that's were whoa whoa I didn't think it was that bad okay this this this this",
    "start": "2784480",
    "end": "2791400"
  },
  {
    "text": "changes between different minor versions of Scala all the time yeah I I I I I",
    "start": "2791400",
    "end": "2796880"
  },
  {
    "text": "said to Martin what I I got my laptop out and said why why does it do this and and and i i s a hit return and this",
    "start": "2796880",
    "end": "2802880"
  },
  {
    "text": "really nice concise little type came up I was like oh well that's",
    "start": "2802880",
    "end": "2808400"
  },
  {
    "text": "that's that's taking the wind out of my uh my sales so um but then then Martin said oh hold on you can and he he sort",
    "start": "2808400",
    "end": "2815440"
  },
  {
    "text": "of hacked around for about 5 minutes and said oh I've got another example which is the example using vector and range so",
    "start": "2815440",
    "end": "2821280"
  },
  {
    "text": "he was very satisfied that he found a way of inferring this horrendous type yeah yeah greatness of this type is not",
    "start": "2821280",
    "end": "2828200"
  },
  {
    "text": "appreciated until you know that abstract seek is a private type which you can't reference so if you try to write this",
    "start": "2828200",
    "end": "2833680"
  },
  {
    "text": "type you can't because it says well there's no such type as that man you don't have access it infers types that",
    "start": "2833680",
    "end": "2839200"
  },
  {
    "text": "you have no access [Laughter] to that's good",
    "start": "2839200",
    "end": "2845080"
  },
  {
    "text": "[Laughter] I think I think you probably shouldn't",
    "start": "2845080",
    "end": "2851359"
  },
  {
    "text": "have access to it should you I mean it's it's probably for the best you don't have access I'm not sure",
    "start": "2851359",
    "end": "2858200"
  },
  {
    "text": "it's for the best that you um any other questions for me or",
    "start": "2858200",
    "end": "2863480"
  },
  {
    "text": "Paul uh yeah got the front yeah so so you remember the example you gave with",
    "start": "2863480",
    "end": "2868640"
  },
  {
    "text": "with either um yeah does that imply that either should be extending product oh",
    "start": "2868640",
    "end": "2876640"
  },
  {
    "text": "right um no because they come from case classes so because right and left are",
    "start": "2876640",
    "end": "2883240"
  },
  {
    "text": "case classes and case classes can't inherit from one another so either can't be a case class it doesn't therefore",
    "start": "2883240",
    "end": "2890000"
  },
  {
    "text": "extend from serializable and",
    "start": "2890000",
    "end": "2893319"
  },
  {
    "text": "product can you do that I tried to that and it didn't work you can show me",
    "start": "2898800",
    "end": "2904040"
  },
  {
    "text": "later okay andless we're talking about something",
    "start": "2905280",
    "end": "2912480"
  },
  {
    "text": "different oh oh right yeah yeah but I can't modify either that's the yeah yeah",
    "start": "2920000",
    "end": "2925119"
  },
  {
    "text": "I yeah so where I where I to Fork the compiler then maybe I",
    "start": "2925119",
    "end": "2933640"
  },
  {
    "text": "could uh uh guy in purple yeah",
    "start": "2933640",
    "end": "2939799"
  },
  {
    "text": "you it's out of",
    "start": "2945400",
    "end": "2948880"
  },
  {
    "text": "scope sorry carry on I don't know the answer but",
    "start": "2950839",
    "end": "2956240"
  },
  {
    "text": "it's way way out of scope um there are probably people here who can answer that um but I've got 20",
    "start": "2968720",
    "end": "2976720"
  },
  {
    "text": "seconds left I will probably round up there so thanks for coming everyone",
    "start": "2976720",
    "end": "2983078"
  }
]