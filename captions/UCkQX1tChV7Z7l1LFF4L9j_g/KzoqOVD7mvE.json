[
  {
    "start": "0",
    "end": "91000"
  },
  {
    "text": "[Music]",
    "start": "1430",
    "end": "12320"
  },
  {
    "text": "so hello my name is Lars and I'm going to talk about um Scala at 7 and new and",
    "start": "12320",
    "end": "17840"
  },
  {
    "text": "Polished features in that version and the title of the talk is seven at one blow that's actually um a proverb from a",
    "start": "17840",
    "end": "23920"
  },
  {
    "text": "German fairy tale it's called the little Taylor and I have no clue what that got to do with the topic but um it has a",
    "start": "23920",
    "end": "30240"
  },
  {
    "text": "seven in it so yeah okay um so some people might",
    "start": "30240",
    "end": "35320"
  },
  {
    "text": "already know me um so my name is Lars and um I'm studying computer science and",
    "start": "35320",
    "end": "41320"
  },
  {
    "text": "um my first contribution to scalar set was in December 2011 and I've been committer became",
    "start": "41320",
    "end": "47920"
  },
  {
    "text": "committer shortly afterwards and in October I picked up like Co maintenance",
    "start": "47920",
    "end": "53199"
  },
  {
    "text": "or maintenance of um this stuff and just a side note so I did not actually invent",
    "start": "53199",
    "end": "58879"
  },
  {
    "text": "any of this stuff I'm going to present today so most of it was already there and some of it is coming from miles and",
    "start": "58879",
    "end": "65680"
  },
  {
    "text": "some other from Jason and Paul and yeah so I did not invent any of this so",
    "start": "65680",
    "end": "70759"
  },
  {
    "text": "please don't uh credit my myself for that um okay so um who of you uh uses Scala",
    "start": "70759",
    "end": "79119"
  },
  {
    "text": "set in production or for hobby projects so okay who uses specs 2 for testing so",
    "start": "79119",
    "end": "86799"
  },
  {
    "text": "you also actually use scalar set because specs 2 depends on scal SC set um so Scala set is a Scala library for",
    "start": "86799",
    "end": "93320"
  },
  {
    "start": "91000",
    "end": "91000"
  },
  {
    "text": "functional programming and it contains um purely functional data",
    "start": "93320",
    "end": "98720"
  },
  {
    "text": "structures and also it mirrors the type classes which uh from which came from",
    "start": "98720",
    "end": "104560"
  },
  {
    "text": "has originally so like fun and monoids and monets and all that stuff and the",
    "start": "104560",
    "end": "110280"
  },
  {
    "text": "current stable version is um 604 and yeah the successor has been",
    "start": "110280",
    "end": "116640"
  },
  {
    "text": "under development for over a year now so um it's compatible with Scala 29 and 2",
    "start": "116640",
    "end": "122880"
  },
  {
    "text": "so if you're still stuck with 28 or even 27s you're out of luck you have to use something older um but if you're",
    "start": "122880",
    "end": "129319"
  },
  {
    "text": "starting a project now I'm going to argue that you should be using Scala set 7even and um it should should work out",
    "start": "129319",
    "end": "137840"
  },
  {
    "text": "all pretty well so here's my agenda for today um I'm probably not going to cover",
    "start": "137840",
    "end": "144000"
  },
  {
    "text": "everything in 30 minutes so let's just see how everything works out",
    "start": "144000",
    "end": "150280"
  },
  {
    "text": "um first of all alak card implicits so um if you're used to Scala set six um",
    "start": "150280",
    "end": "157360"
  },
  {
    "text": "you know that if you want to use any of the functionality you had this um so-called all you can eat object and um",
    "start": "157360",
    "end": "164800"
  },
  {
    "text": "you import it from that object so you make an a wild card import and you got all the features you got most of the",
    "start": "164800",
    "end": "170319"
  },
  {
    "text": "implicits and stuff like that so here's an example so first you import the name",
    "start": "170319",
    "end": "177000"
  },
  {
    "text": "space then you import this all you can eat object and then you can obtain all instances so",
    "start": "177000",
    "end": "183200"
  },
  {
    "text": "mon it for option and you also get this applicative Builder syntax and yeah",
    "start": "183200",
    "end": "188640"
  },
  {
    "text": "everything's just there at your fingertips now in Scala set 7 there's um",
    "start": "188640",
    "end": "196720"
  },
  {
    "text": "it's it's a bit more complicated um we distinguish between different kinds of",
    "start": "196720",
    "end": "202040"
  },
  {
    "text": "implicits um first of all we have type class instances like this thing here",
    "start": "202040",
    "end": "208920"
  },
  {
    "text": "this a type class in instance and there's also another separation so we distinguish between Type class instance",
    "start": "208920",
    "end": "215000"
  },
  {
    "text": "of our own data types and of instances of standard Library",
    "start": "215000",
    "end": "220159"
  },
  {
    "text": "types and the second part is um infix operators that's what we call syntax now so this is all this fancy stuff here",
    "start": "220159",
    "end": "226720"
  },
  {
    "text": "that's syntax that's syntax because that's not usually there and this fancy",
    "start": "226720",
    "end": "231840"
  },
  {
    "text": "monoid addition operator yeah and there's also uh there are infix operators for type class",
    "start": "231840",
    "end": "238799"
  },
  {
    "text": "instances and also additional Syntax for standard Library types like you have",
    "start": "238799",
    "end": "244079"
  },
  {
    "text": "seen here for uh integer we provide some separate syntax and also the Third Kind it's not",
    "start": "244079",
    "end": "251400"
  },
  {
    "start": "247000",
    "end": "247000"
  },
  {
    "text": "really um implicit like the functions on our data Tye sets are just bare functions to construct um our own data",
    "start": "251400",
    "end": "258959"
  },
  {
    "text": "types and um yeah this is also a third category so what do you have to do now",
    "start": "258959",
    "end": "266560"
  },
  {
    "text": "in order to import that stuff so first of all you you use the U namespace as",
    "start": "266560",
    "end": "272560"
  },
  {
    "text": "you did previously and then you can say Okay I want the instances for option so",
    "start": "272560",
    "end": "279720"
  },
  {
    "text": "we have the sub package called STD and in this subpackage there's an object called option and in this object all the",
    "start": "279720",
    "end": "287199"
  },
  {
    "text": "implicits reside so if you import this you get the Monet instance for option",
    "start": "287199",
    "end": "292680"
  },
  {
    "text": "and as you might have noticed um you don't have to write implicitly here so all our type classes now have companion",
    "start": "292680",
    "end": "298680"
  },
  {
    "text": "objects within the apply method and so uh you you don't have to actually write this",
    "start": "298680",
    "end": "303960"
  },
  {
    "text": "implicitly and um you just call the apply method and get your",
    "start": "303960",
    "end": "309440"
  },
  {
    "text": "instance okay now to the second example and uh now we need a bit more Imports",
    "start": "309520",
    "end": "314639"
  },
  {
    "text": "and that's actually a quite nice example because now we can actually see um that this line of code contains so much of",
    "start": "314639",
    "end": "322280"
  },
  {
    "text": "stuff from Scala set um so let's break it down the first thing to notice is um",
    "start": "322280",
    "end": "328160"
  },
  {
    "text": "let's start with the syntax okay we have this applicative Builder syntax here so we have this fancy operator and it's",
    "start": "328160",
    "end": "334120"
  },
  {
    "text": "defined not an applicative but an apply but that's just a technical distinction so you have to import the Syntax for",
    "start": "334120",
    "end": "339560"
  },
  {
    "text": "this type class then you use this addition operator so you have to import",
    "start": "339560",
    "end": "344639"
  },
  {
    "text": "the syntax. semigroup also you use this um syntax on",
    "start": "344639",
    "end": "351000"
  },
  {
    "text": "standard Library data types and you have to import that to it lives under syntax. sd. option so this is the syntax to",
    "start": "351000",
    "end": "358759"
  },
  {
    "text": "create op options so that's the first step now you",
    "start": "358759",
    "end": "363880"
  },
  {
    "text": "have all the necessary syntax and now the syntax has to know that it's actually that all the type class",
    "start": "363880",
    "end": "369240"
  },
  {
    "text": "instances are there so now you have to import the type class instances you do that uh with importing stuff from option",
    "start": "369240",
    "end": "376120"
  },
  {
    "text": "and stuff from anual because here you need the applicative instance for option and here you need the monoid um instance",
    "start": "376120",
    "end": "382360"
  },
  {
    "text": "for integer and those live in annual okay you now you might argue that",
    "start": "382360",
    "end": "389120"
  },
  {
    "text": "these are a lot of imports and that's not really nice so um we also provided",
    "start": "389120",
    "end": "395199"
  },
  {
    "text": "some um common Imports which provide you with all the syntax and all our U",
    "start": "395199",
    "end": "402400"
  },
  {
    "text": "library enrichments uh so this makes it a bit shorter okay why is this better um let's",
    "start": "402400",
    "end": "410800"
  },
  {
    "start": "409000",
    "end": "409000"
  },
  {
    "text": "start with the disadvantages so um obviously you need more import",
    "start": "410800",
    "end": "416039"
  },
  {
    "text": "statements um yeah that's true and also it makes compile time debugging",
    "start": "416039",
    "end": "421919"
  },
  {
    "text": "harder why because if you are referring to a syntax so if you write like X and",
    "start": "421919",
    "end": "428000"
  },
  {
    "text": "then this operator and then Y and the compiler complains that um it couldn't find any implicit instance so now you",
    "start": "428000",
    "end": "435599"
  },
  {
    "text": "have to think did I actually import everything which is needed or is the instance just not there or what happened",
    "start": "435599",
    "end": "442080"
  },
  {
    "text": "here so it takes you a bit of time to debug this kind of stuff so but there are also advantages",
    "start": "442080",
    "end": "449680"
  },
  {
    "text": "so you can use the syntax but you don't have to so if you decide to just use the type class instances and write",
    "start": "449680",
    "end": "456039"
  },
  {
    "text": "everything with type class dot um append or ADD and then two parameters and if",
    "start": "456039",
    "end": "462400"
  },
  {
    "text": "you choose to not use the syntax that's fine you can just import the type class instances and everything works well and",
    "start": "462400",
    "end": "469280"
  },
  {
    "text": "also it improves reability of the code so if you have your source file and in",
    "start": "469280",
    "end": "475080"
  },
  {
    "text": "the header you list all the Imports um and someone reads your code here or could simply look did this person import",
    "start": "475080",
    "end": "482280"
  },
  {
    "text": "Scala set syntax if yes I have to watch out there might be operators around here",
    "start": "482280",
    "end": "487360"
  },
  {
    "text": "which I have to look up and if you don't import syntax you immediately know okay everything's from the standard Library",
    "start": "487360",
    "end": "494000"
  },
  {
    "text": "here also it makes compile di debugging easier so this is with tongue and cheek",
    "start": "494000",
    "end": "500039"
  },
  {
    "text": "um because your implicit scope is much smaller you don't have all those hundreds of thousands of implicits in",
    "start": "500039",
    "end": "506560"
  },
  {
    "text": "your scope so if you get in Divergent implicit or stuff like that you can just remove State import statements one by",
    "start": "506560",
    "end": "512919"
  },
  {
    "text": "one and see which one was the offender so you couldn't do that with this all you can eat object you just had to um",
    "start": "512919",
    "end": "518880"
  },
  {
    "text": "import it and if something didn't work yeah well you were out of luck also it increases compilation speed",
    "start": "518880",
    "end": "525320"
  },
  {
    "text": "um I don't have any hard numbers on that but the thing is the implicit scope is smaller so the implicit search will be",
    "start": "525320",
    "end": "534000"
  },
  {
    "text": "faster Okay so the second thing which improves",
    "start": "535560",
    "end": "541160"
  },
  {
    "text": "the usability of Scala set by far is so-called unapply so um who of you have has have",
    "start": "541160",
    "end": "549880"
  },
  {
    "text": "heard of that so I'm not talking about the case class underplay but about type level underly so just for me how many",
    "start": "549880",
    "end": "555560"
  },
  {
    "text": "people do know this concept okay so this concept was originally invented by Miles and then",
    "start": "555560",
    "end": "562360"
  },
  {
    "text": "refined by Jason so what's the problem just take a second to have a look at that code",
    "start": "562360",
    "end": "568200"
  },
  {
    "text": "snippet we Define a function with two type parameters where the first type parameter is actually a type",
    "start": "568200",
    "end": "574720"
  },
  {
    "start": "569000",
    "end": "569000"
  },
  {
    "text": "Constructor and then we want to take a value X which is of type type",
    "start": "574720",
    "end": "581480"
  },
  {
    "text": "Constructor applied to a and we just for the sake of example we just return X itself so what we require is that if we",
    "start": "581480",
    "end": "588839"
  },
  {
    "text": "want to call F we need to know that it has a type such that can be destructured",
    "start": "588839",
    "end": "594480"
  },
  {
    "text": "into this type Constructor and an element applied to it yeah like list of int or",
    "start": "594480",
    "end": "599880"
  },
  {
    "text": "Vector of string or something like that so what happens if you call it like that anybody know what happens does it",
    "start": "599880",
    "end": "607519"
  },
  {
    "text": "compile does it not compile oh this actually prints a type error because we put in a function from",
    "start": "607519",
    "end": "616800"
  },
  {
    "text": "int to INT in here but we required this type Constructor thingy and the compiler",
    "start": "616800",
    "end": "622839"
  },
  {
    "text": "is not able to figure this out so um now you could say okay well",
    "start": "622839",
    "end": "629360"
  },
  {
    "text": "well why doesn't the compiler figure this out isn't it smart enough the reason is uh it's very hard to do so and",
    "start": "629360",
    "end": "635880"
  },
  {
    "text": "why is that because now assume you were the compiler and I'd ask you to do this kind of inference which one of these",
    "start": "635880",
    "end": "643720"
  },
  {
    "text": "those candidates would you choose well the type Constructor could be could be fixed on the input it could also be",
    "start": "643720",
    "end": "650959"
  },
  {
    "text": "fixed on the result uh it couldn't be fixed at all or it could be fixed on",
    "start": "650959",
    "end": "656320"
  },
  {
    "text": "both of them so you don't actually know which destructuring you should choose because it's",
    "start": "656320",
    "end": "661519"
  },
  {
    "text": "ambiguous and this is a non limitation this is also filed as a bug and um this",
    "start": "661519",
    "end": "666560"
  },
  {
    "text": "is a bug number less than 3,000 so it's a feature request and I'm not sure if this is ever going to happen um",
    "start": "666560",
    "end": "675639"
  },
  {
    "text": "so let's go to the so in the last year I would have probably said let's go to the fundament of the problem but then",
    "start": "675639",
    "end": "681399"
  },
  {
    "start": "678000",
    "end": "678000"
  },
  {
    "text": "someone said to me that fundament doesn't mean what I think it means so let's go to the foundation of the problem and we use math for that um this",
    "start": "681399",
    "end": "689680"
  },
  {
    "text": "problem is known as higher order unification so if someone of you have already used um prologue or data log",
    "start": "689680",
    "end": "697760"
  },
  {
    "text": "prologue uh does unification so it takes two terms and tries to find a mapping between them such that they look the",
    "start": "697760",
    "end": "703480"
  },
  {
    "text": "same thing so that's what we do here so we try to find a mapping from this thing",
    "start": "703480",
    "end": "708800"
  },
  {
    "text": "to this thing so that these constraints are satisfied that's basically unification and now Scala add subtyping",
    "start": "708800",
    "end": "717600"
  },
  {
    "text": "so why is this bad because everything single subtype of any any is always treated as well kinded and that's",
    "start": "717600",
    "end": "724320"
  },
  {
    "text": "instantly ambiguous so uh no matter how hard you try any is always a candidate",
    "start": "724320",
    "end": "730120"
  },
  {
    "text": "so you get um ambiguities all the way down and even without subtyping higher",
    "start": "730120",
    "end": "736800"
  },
  {
    "text": "order unification is undecidable even second order unification is undecidable so yeah that's pretty sad",
    "start": "736800",
    "end": "744600"
  },
  {
    "text": "um yeah so in fact Scala C is not stupid or the implement mentation the people",
    "start": "744600",
    "end": "750600"
  },
  {
    "text": "who implemented it were not lazy it's just impossible to do in the general",
    "start": "750600",
    "end": "755839"
  },
  {
    "text": "case so as good programmers what do we do we approximate so that's what we do",
    "start": "755839",
    "end": "761240"
  },
  {
    "start": "759000",
    "end": "759000"
  },
  {
    "text": "all day so we have some hard problems and we can't solve it directly so we have to use some kind of approximation",
    "start": "761240",
    "end": "767320"
  },
  {
    "text": "uh to get rid of those limitations and like find a solution which just works",
    "start": "767320",
    "end": "772639"
  },
  {
    "text": "and is close enough so first thing to notice um this is the same code example and we know",
    "start": "772639",
    "end": "779320"
  },
  {
    "text": "that this type Constructor here is is rarely use it's not actually useful so you cannot actually do something with",
    "start": "779320",
    "end": "784639"
  },
  {
    "text": "the structure you require that this type here is structured in a certain way but",
    "start": "784639",
    "end": "791680"
  },
  {
    "text": "you cannot actually do anything with it you cannot transform it in some way so",
    "start": "791680",
    "end": "796720"
  },
  {
    "text": "the important thing to note is if you have a type constructure you usually have also a type class so you want this",
    "start": "796720",
    "end": "804279"
  },
  {
    "text": "to be a functor or a Monet or something like that so this is a more real realistic example you have a function",
    "start": "804279",
    "end": "812600"
  },
  {
    "text": "again with this type Constructor and you say Okay I want my type Constructor to be a Monet and then I can do some",
    "start": "812600",
    "end": "818720"
  },
  {
    "text": "operations I can map the type or whatever I want and now we have more information",
    "start": "818720",
    "end": "825800"
  },
  {
    "text": "and this piece of information can guide type inference",
    "start": "825800",
    "end": "832839"
  },
  {
    "start": "832000",
    "end": "832000"
  },
  {
    "text": "how yeah we can use dependent types for that what we do is we Define a proof object which contains the type",
    "start": "832839",
    "end": "839959"
  },
  {
    "text": "Constructor the inot type and the type class instance and now we have to create that",
    "start": "839959",
    "end": "846600"
  },
  {
    "text": "uh kind of proof object somehow and we do that with implicits and lots of implicits and now we have to resolve",
    "start": "846600",
    "end": "854279"
  },
  {
    "text": "those those ambiguities and we do that by the usual usual mechanism of prioritization so you know if you have a",
    "start": "854279",
    "end": "861839"
  },
  {
    "text": "hierarchy of classes or traits or whatever and you define implicits in all those traits and now you",
    "start": "861839",
    "end": "869639"
  },
  {
    "text": "ask for an implicit value and multiple of those implicits would qualify then the compiler always chooses the one",
    "start": "869639",
    "end": "876279"
  },
  {
    "text": "which is um at the bottom of this uh hery so that's one mechanism so we",
    "start": "876279",
    "end": "882240"
  },
  {
    "text": "simply say if there are two possibilities just choose the one we deem more",
    "start": "882240",
    "end": "888040"
  },
  {
    "text": "likely and also availability of type class instances so if you have um two",
    "start": "888040",
    "end": "893079"
  },
  {
    "text": "possibilities and you say well um you could destructure it in two ways but in only one way I have this Mona instance",
    "start": "893079",
    "end": "899199"
  },
  {
    "text": "available then I'll choose just that one which has the Monet instance available because the other destructuring wouldn't make any sense at",
    "start": "899199",
    "end": "906240"
  },
  {
    "text": "all okay here's a short",
    "start": "906240",
    "end": "911120"
  },
  {
    "text": "demo oops so okay",
    "start": "917759",
    "end": "926360"
  },
  {
    "text": "so let's have a first have a look at how it's implemented so this is quite a lot of",
    "start": "931199",
    "end": "937199"
  },
  {
    "text": "boiler plate so you don't have to actually understand that um these are like 500 lines of boiler plate which",
    "start": "937199",
    "end": "944000"
  },
  {
    "text": "Comm which cover some type shapes so um",
    "start": "944000",
    "end": "949160"
  },
  {
    "text": "the most important thing is the definition of this proof object which is",
    "start": "949160",
    "end": "954319"
  },
  {
    "text": "here so here's the straight unapply and you see here you have all those different memb",
    "start": "954319",
    "end": "959480"
  },
  {
    "text": "like the type Constructor and the type A and the type class instance and we can",
    "start": "959480",
    "end": "964720"
  },
  {
    "text": "use that we can just ask for this proof object and the implicit search will give it to us and this looks like the",
    "start": "964720",
    "end": "972360"
  },
  {
    "text": "following assume we have this file and",
    "start": "972360",
    "end": "977519"
  },
  {
    "text": "now we want to have this class which does something on something else and we want to create such um such a such an",
    "start": "977519",
    "end": "984920"
  },
  {
    "text": "instance we simply say okay just give me anything I don't care what type that is",
    "start": "984920",
    "end": "990920"
  },
  {
    "text": "just something and then I require such a proof object and say okay this T can be",
    "start": "990920",
    "end": "997440"
  },
  {
    "text": "destructured in a way that we have a type Constructor and this type constructure is classified by a functor",
    "start": "997440",
    "end": "1003639"
  },
  {
    "text": "so we need a functor for that type class and then here here where where the dependent types come into play we can",
    "start": "1003639",
    "end": "1010079"
  },
  {
    "text": "say okay we instantiate our fornicate class with this unapply m unapply a so",
    "start": "1010079",
    "end": "1016880"
  },
  {
    "text": "these are the type parameters and then then just some um technical details we",
    "start": "1016880",
    "end": "1022160"
  },
  {
    "text": "have to convert a bit and then here we get the type class instance okay and that works pretty",
    "start": "1022160",
    "end": "1030640"
  },
  {
    "text": "well so if you have this code you can actually um call that and it will",
    "start": "1031240",
    "end": "1039558"
  },
  {
    "text": "compile without a problem so now that invokes Scala Z so",
    "start": "1039559",
    "end": "1047199"
  },
  {
    "text": "let's hope this won't take too",
    "start": "1047199",
    "end": "1050840"
  },
  {
    "text": "long yeah so it compiles this other problem it was able to uh infer that the",
    "start": "1053960",
    "end": "1060720"
  },
  {
    "text": "shape of the type Constructor um despite the fact that we passed in a function",
    "start": "1060720",
    "end": "1065760"
  },
  {
    "text": "which is like function one and has two parameters and it was able to underplay in such a way that everything works out",
    "start": "1065760",
    "end": "1072520"
  },
  {
    "text": "beautifully",
    "start": "1072520",
    "end": "1075520"
  },
  {
    "text": "so does it work well yes in scalar set six we had we used to have conversions",
    "start": "1083520",
    "end": "1089360"
  },
  {
    "start": "1086000",
    "end": "1086000"
  },
  {
    "text": "for each concrete type so we had conversions for isor for Function One function two and all that stuff and um",
    "start": "1089360",
    "end": "1096200"
  },
  {
    "text": "now we have a general mechanism for common shapes so we say okay we have a",
    "start": "1096200",
    "end": "1101240"
  },
  {
    "text": "conversion for type Constructors which take two parameters and then we have uh type conversions for type Constructor",
    "start": "1101240",
    "end": "1107799"
  },
  {
    "text": "which take three parameters and stuff like that so um in many cases type parameters can be omitted and",
    "start": "1107799",
    "end": "1115880"
  },
  {
    "text": "here's the thing so if you want to Traverse a list State F so I don't know who of you uses uh the state thingy from",
    "start": "1115880",
    "end": "1122520"
  },
  {
    "text": "Scala set um previously in scalar set six you had to use a very hideous type",
    "start": "1122520",
    "end": "1128799"
  },
  {
    "text": "Lambda here to actually tell the compiler uh how this should work out and",
    "start": "1128799",
    "end": "1133880"
  },
  {
    "text": "now we have this Traverse U method U stands for unapply and uh um the",
    "start": "1133880",
    "end": "1139280"
  },
  {
    "text": "compiler will figure it out and we also have the old Traverse method still lying around because in",
    "start": "1139280",
    "end": "1146919"
  },
  {
    "text": "some cases unapply won't work so um you can uh still specify it like you used to",
    "start": "1146919",
    "end": "1152880"
  },
  {
    "text": "do it so um but it's not soap bright because we have those uh amount of",
    "start": "1152880",
    "end": "1160480"
  },
  {
    "text": "boiler plate and we need one implicit per type shape but there are infinitely many type shapes so we are doomed anyway",
    "start": "1160480",
    "end": "1167400"
  },
  {
    "text": "um but I don't know if anyone of you uses um type Constructors with 20",
    "start": "1167400",
    "end": "1172919"
  },
  {
    "text": "parameters so um if you do you might be doing something wrong um there's I I'd say there is only a finite number of",
    "start": "1172919",
    "end": "1178919"
  },
  {
    "text": "interesting type Constructors so um yeah we are not doomed at all um also the",
    "start": "1178919",
    "end": "1184159"
  },
  {
    "text": "compile errors can get a little funky and um yeah it needs dependent types so",
    "start": "1184159",
    "end": "1189360"
  },
  {
    "text": "with Scala 29 you have to specify a command line switch minus y um dependent",
    "start": "1189360",
    "end": "1194720"
  },
  {
    "text": "method types or something like that um but this is enabled by default in 210 so you can enable it anyway you won't get",
    "start": "1194720",
    "end": "1202000"
  },
  {
    "text": "any compatibility problems at all it's enabled with 210 and yeah you should be",
    "start": "1202000",
    "end": "1207760"
  },
  {
    "text": "safe to use",
    "start": "1207760",
    "end": "1210480"
  },
  {
    "text": "that okay so um let's get to the third",
    "start": "1213159",
    "end": "1218799"
  },
  {
    "text": "Point law um in Scala set six we had all",
    "start": "1218799",
    "end": "1223919"
  },
  {
    "text": "those type classes and instances and the problem was that you could implement your own instances and nobody actually",
    "start": "1223919",
    "end": "1231360"
  },
  {
    "text": "ever checked whether your instances are lawful so you could just Define a functor and nobody ever checked if this",
    "start": "1231360",
    "end": "1238600"
  },
  {
    "text": "was a wet functor we did change that so first bit of motivation so we",
    "start": "1238600",
    "end": "1247159"
  },
  {
    "start": "1246000",
    "end": "1246000"
  },
  {
    "text": "are programmers so we usually don't program against classes we program against interfaces and uh in Java land",
    "start": "1247159",
    "end": "1254720"
  },
  {
    "text": "we used to specify um a contract in the Java do comment so this is object.",
    "start": "1254720",
    "end": "1260440"
  },
  {
    "text": "equals I am sure everyone of you loves that method um and we have this kind of",
    "start": "1260440",
    "end": "1267000"
  },
  {
    "text": "uh contract here and it says well um the equals method and bl and it should be",
    "start": "1267000",
    "end": "1272039"
  },
  {
    "text": "reflexive so X should always be equal to X and if x is equal to Y then y should be equal to X and yeah we we do we do",
    "start": "1272039",
    "end": "1280360"
  },
  {
    "text": "rely on that on a daily basis so if you implement some sort of sets or stuff like that we do want these um we do want",
    "start": "1280360",
    "end": "1289120"
  },
  {
    "text": "sub classes of object to satisfy that contract and I assume everybody of you",
    "start": "1289120",
    "end": "1294760"
  },
  {
    "text": "is uh completely convinced that every subass of object uh aderes to this",
    "start": "1294760",
    "end": "1301760"
  },
  {
    "start": "1300000",
    "end": "1300000"
  },
  {
    "text": "contract so we have the same problem um with type classes so type classes abstract over types and they offer",
    "start": "1301760",
    "end": "1308600"
  },
  {
    "text": "common functionality and users of those type classes expect similar behavior and once",
    "start": "1308600",
    "end": "1314559"
  },
  {
    "text": "again we do not program against the list functor we program against the functor and we have have a method and we do not",
    "start": "1314559",
    "end": "1320760"
  },
  {
    "text": "know which um we do not know which kind of functor the user puts into it so we need to have some hard and fast rules",
    "start": "1320760",
    "end": "1328159"
  },
  {
    "text": "for that and those rules need to be formalized so yeah I'm an academic I want to formalize everything um why",
    "start": "1328159",
    "end": "1335360"
  },
  {
    "text": "because if you put it just in your comments nobody can check it and everybody will ignore it and also",
    "start": "1335360",
    "end": "1340960"
  },
  {
    "text": "comments will rot so you have like your implementation and then like two years",
    "start": "1340960",
    "end": "1346640"
  },
  {
    "text": "ago somebody wrote a comment and implementation doesn't even know about the old comment anymore so yeah we need",
    "start": "1346640",
    "end": "1354120"
  },
  {
    "text": "to do something about that and um this is a quote from Tony",
    "start": "1354120",
    "end": "1359200"
  },
  {
    "start": "1355000",
    "end": "1355000"
  },
  {
    "text": "Morris in the Scala set IRC Channel um I think this was from a trt project and he was wondering whether this is actually a",
    "start": "1359200",
    "end": "1365600"
  },
  {
    "text": "lawful Mones or whether it um satisfies some laws and we don't not do not want to run",
    "start": "1365600",
    "end": "1372200"
  },
  {
    "text": "into some legal problems okay so how do we do it in scolar set um we have um this type class",
    "start": "1372200",
    "end": "1381480"
  },
  {
    "start": "1376000",
    "end": "1376000"
  },
  {
    "text": "hierarchy and in this type classes we embed laws so for example the class",
    "start": "1381480",
    "end": "1386679"
  },
  {
    "text": "Monet contains a trait called Monet law and this trait Monet law extends fun law",
    "start": "1386679",
    "end": "1392480"
  },
  {
    "text": "and fun law itself is defined in functor y nothing too specific and then we have",
    "start": "1392480",
    "end": "1398240"
  },
  {
    "text": "one method per law and we call those methods with scalar check so um is",
    "start": "1398240",
    "end": "1404200"
  },
  {
    "text": "everybody of you familiar with scalar check so this is just a tool which",
    "start": "1404200",
    "end": "1409320"
  },
  {
    "text": "produces random input but here's the thing it's not a theorum improver so in an Ideal World we would just Define our",
    "start": "1409320",
    "end": "1416240"
  },
  {
    "text": "instances in theum improver and then click on a button export to Scala and then we have trust full code um we do",
    "start": "1416240",
    "end": "1423600"
  },
  {
    "text": "not usually do that so um if the if scalar check says okay it's not a",
    "start": "1423600",
    "end": "1429200"
  },
  {
    "text": "guarantee but it's better than the usual unit test because in usual unit test you just um test some cases which you",
    "start": "1429200",
    "end": "1436880"
  },
  {
    "text": "thought would be common or whatever and um Scala check is good at creating",
    "start": "1436880",
    "end": "1443120"
  },
  {
    "text": "Corner cases and usually the corner cases are more interesting and our",
    "start": "1443120",
    "end": "1448279"
  },
  {
    "text": "bindings to Scala check can be used by other projects so if you are defining instances of fun or stuff like that you",
    "start": "1448279",
    "end": "1454480"
  },
  {
    "text": "can just add another dependency it's called scalar set Scala check binding and then you can um simply call all",
    "start": "1454480",
    "end": "1461039"
  },
  {
    "text": "those functions and um we call this check all so if you if you call check all with an",
    "start": "1461039",
    "end": "1467399"
  },
  {
    "text": "instance it will automatically get check everything and in our own code base we have 332 occurrences so we take this",
    "start": "1467399",
    "end": "1474960"
  },
  {
    "text": "pretty seriously and yeah the test speed of Scala set 7 is much better than of Scala",
    "start": "1474960",
    "end": "1480919"
  },
  {
    "text": "set 6 so we didn't you we didn't do that checking previously but now we do and now we are pretty confident that",
    "start": "1480919",
    "end": "1486679"
  },
  {
    "text": "everything is in order okay I have another demo",
    "start": "1486679",
    "end": "1495000"
  },
  {
    "text": "so let me just show you how that looks",
    "start": "1498440",
    "end": "1502559"
  },
  {
    "text": "like for example for our anual instances we just say check all the laws",
    "start": "1505960",
    "end": "1513399"
  },
  {
    "text": "for the unit instance and check all the laws for the Boolean and character and stuff like that here's also the",
    "start": "1513399",
    "end": "1519240"
  },
  {
    "text": "benchmarking stuff but that's not important and this file just contains all those check all",
    "start": "1519240",
    "end": "1525080"
  },
  {
    "text": "calls and if you were about to execute that",
    "start": "1525080",
    "end": "1530320"
  },
  {
    "text": "so this called spt I hope it doesn't recompile everything",
    "start": "1530919",
    "end": "1536440"
  },
  {
    "text": "um so yeah that worked out well uh internally it uses specs two and it",
    "start": "1548760",
    "end": "1554039"
  },
  {
    "text": "generates specs two um fragments from those uh scalar check properties and now",
    "start": "1554039",
    "end": "1560279"
  },
  {
    "text": "you can see um if you want to check this short instance you see all those laws",
    "start": "1560279",
    "end": "1565880"
  },
  {
    "text": "which it checked for that so that's pretty awesome you you just have to call check all and everything will be done",
    "start": "1565880",
    "end": "1572520"
  },
  {
    "text": "for you okay so if you want if you want to know more about LW um you can watch a",
    "start": "1572520",
    "end": "1578399"
  },
  {
    "text": "talk by Nick Partridge he gave it in the past week at the Brisbane FP group and",
    "start": "1578399",
    "end": "1584159"
  },
  {
    "text": "there are also slides available okay uh since I think I'm running out of time so",
    "start": "1584159",
    "end": "1589279"
  },
  {
    "text": "I'm just going to skip type level programming and um if you want to know more about type level programming ask miles and I'm going to skip to um the",
    "start": "1589279",
    "end": "1598559"
  },
  {
    "text": "last point when I want to point something out about our community um so what actually happened in the past year",
    "start": "1598559",
    "end": "1605520"
  },
  {
    "text": "um I've told you that Scala said 7 has been under development for quite some time and Wiki says it should be released",
    "start": "1605520",
    "end": "1612279"
  },
  {
    "text": "expect and release in April 2012 um well we are well overdue and um",
    "start": "1612279",
    "end": "1618600"
  },
  {
    "text": "but we got tons of contributions so about 200 issues opened and um pull",
    "start": "1618600",
    "end": "1624279"
  },
  {
    "start": "1620000",
    "end": "1620000"
  },
  {
    "text": "requests we got quite a number of of awesome contribution um for example um",
    "start": "1624279",
    "end": "1631600"
  },
  {
    "text": "we got um new data types and some classes which do not have any laws",
    "start": "1631600",
    "end": "1637440"
  },
  {
    "text": "Associated removed and I'm still on the quest to remove more of Lawless classes",
    "start": "1637440",
    "end": "1642640"
  },
  {
    "text": "and um lenses which have been some new Concepts which have been ported for from",
    "start": "1642640",
    "end": "1648279"
  },
  {
    "text": "the h lens library and stuff like that um that's pretty cool and um I'm going to plug sh give a",
    "start": "1648279",
    "end": "1657279"
  },
  {
    "start": "1653000",
    "end": "1653000"
  },
  {
    "text": "Shameless plug here this is something I've been doing so some people say validation is the Gateway truck to Scala",
    "start": "1657279",
    "end": "1663880"
  },
  {
    "text": "set and I said I thought to myself so if it's a gateway drug let's make it even cheaper and um the problem with using",
    "start": "1663880",
    "end": "1670799"
  },
  {
    "text": "validation is that sometimes in in code you have all those fancy operators and nobody knows how to call them or",
    "start": "1670799",
    "end": "1676200"
  },
  {
    "text": "whatever like spaceship operators or stuff like that and",
    "start": "1676200",
    "end": "1681480"
  },
  {
    "text": "um yeah so what I did is create such a DSL such you can say okay I create such",
    "start": "1681480",
    "end": "1687799"
  },
  {
    "text": "checking object and I put some value in it and then I can say Okay verify all those properties and there's a library",
    "start": "1687799",
    "end": "1694399"
  },
  {
    "text": "which with some of those properties readily available and it will track all failures and give you a list of all the",
    "start": "1694399",
    "end": "1701080"
  },
  {
    "text": "failures combined and then you can also convert that stuff and um at the end you",
    "start": "1701080",
    "end": "1706919"
  },
  {
    "text": "can get a full-fledged Scala set validation out of it and if you would run that you would see okay this thing",
    "start": "1706919",
    "end": "1712679"
  },
  {
    "text": "has actually only 15 characters so you get wrong length and it's also doesn't satisfy this check sum function so you",
    "start": "1712679",
    "end": "1720200"
  },
  {
    "text": "also get this arrow and yeah I hope that's useful and this is not actually in Scala set in the",
    "start": "1720200",
    "end": "1727320"
  },
  {
    "text": "Scala set codebase it's in a separate project so this um is uh this enables us to move forward",
    "start": "1727320",
    "end": "1734840"
  },
  {
    "start": "1734000",
    "end": "1734000"
  },
  {
    "text": "quickly so what can you do if you're using Scala set 6 please migrate to the",
    "start": "1734840",
    "end": "1740840"
  },
  {
    "text": "latest Milestone which is 7 M7 and please tell us about it so there are",
    "start": "1740840",
    "end": "1747039"
  },
  {
    "text": "some things which you have to um adapt for Scala set 7 so um there will be a",
    "start": "1747039",
    "end": "1753399"
  },
  {
    "text": "bit of pain but please tell us about your pain so we can ease it for the next people to do that transition um if",
    "start": "1753399",
    "end": "1760039"
  },
  {
    "text": "you're not using scalar Set 7even uh or Scala set six at all please try to adopt",
    "start": "1760039",
    "end": "1765679"
  },
  {
    "text": "it in your project so if you're starting a new project just put it in your build SBT and see what happens and um also",
    "start": "1765679",
    "end": "1773320"
  },
  {
    "text": "please don't be afraid of asking questions I know that the scalet community um is kind of Infamous for",
    "start": "1773320",
    "end": "1779799"
  },
  {
    "text": "like yeah some people and um please ask questions on the mailing list and um",
    "start": "1779799",
    "end": "1787240"
  },
  {
    "text": "yeah I'm sure somebody will give you a helpful answer so what are we going to do um we",
    "start": "1787240",
    "end": "1793640"
  },
  {
    "start": "1793000",
    "end": "1793000"
  },
  {
    "text": "will release the final version soon probably this still this year and and we also promise to not break too much until",
    "start": "1793640",
    "end": "1800480"
  },
  {
    "text": "then and um also on the point on my agenda is to rewind the website so we",
    "start": "1800480",
    "end": "1807519"
  },
  {
    "text": "have still this Google code Wiki and stuff like that and I I hope to replace that by something more",
    "start": "1807519",
    "end": "1814440"
  },
  {
    "text": "beautiful okay that's it for me [Applause]",
    "start": "1814440",
    "end": "1822970"
  },
  {
    "text": "[Music]",
    "start": "1823170",
    "end": "1826299"
  }
]