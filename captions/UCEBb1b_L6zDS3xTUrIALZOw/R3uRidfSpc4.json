[
  {
    "start": "0",
    "end": "37000"
  },
  {
    "start": "0",
    "end": "18910"
  },
  {
    "text": "PROFESSOR: All right, well,\nwe've seen how the query language works. Now, let's talk about how\nit's implemented.",
    "start": "18910",
    "end": "26280"
  },
  {
    "text": "You already pretty much can\nguess what's going on there. At the bottom of it, there's\na pattern matcher.",
    "start": "26280",
    "end": "32809"
  },
  {
    "text": "And we looked at a pattern\nmatcher when we did the rule-based control language.",
    "start": "32810",
    "end": "38110"
  },
  {
    "start": "37000",
    "end": "274000"
  },
  {
    "text": "Just to remind you, here are\nsome sample patterns. This is a pattern that will\nmatch any list of three things",
    "start": "38110",
    "end": "45010"
  },
  {
    "text": "of which the first is a and the\nsecond is c and the middle one can be anything.",
    "start": "45010",
    "end": "50650"
  },
  {
    "text": "So in this little\npattern-matching syntax, there's only one distinction\nyou make. There's either literal things\nor variables, and variables",
    "start": "50650",
    "end": "57829"
  },
  {
    "text": "begin with question mark.  So this matches any list of\nthree things of which the",
    "start": "57830",
    "end": "64900"
  },
  {
    "text": "first is a and the\nsecond is c. This one matches any list of\nthree things of which the",
    "start": "64900",
    "end": "71010"
  },
  {
    "text": "first is the symbol job. The second can be anything. And the third is a list of two\nthings of which the first is",
    "start": "71010",
    "end": "76750"
  },
  {
    "text": "the symbol computer and the\nsecond can be anything. And this one, this next one\nmatches any list of three",
    "start": "76750",
    "end": "85100"
  },
  {
    "text": "things, and the only difference\nis, here, the third list, the first is the symbol\ncomputer, and then there's",
    "start": "85100",
    "end": "92280"
  },
  {
    "text": "some rest of the list. So this\nmeans two elements and this means arbitrary number.",
    "start": "92280",
    "end": "97860"
  },
  {
    "text": "And our language implementation\nisn't even going to have to worry about\nimplementing this dot because that's automatically done\nby Lisp's reader.",
    "start": "97860",
    "end": "104049"
  },
  {
    "text": " Remember matchers also have\nsome consistency in them.",
    "start": "104050",
    "end": "110310"
  },
  {
    "text": "This match is a list of\nthree things of which the first is a. And the second and third can be\nanything, but they have to",
    "start": "110310",
    "end": "116280"
  },
  {
    "text": "be the same thing. They're both called x. And this matches a list of four\nthings of which the first",
    "start": "116280",
    "end": "122729"
  },
  {
    "text": "is the fourth and the second\nis the same as the third. And this last one matches any\nlist that begins with a.",
    "start": "122730",
    "end": "129685"
  },
  {
    "text": "The first thing is a, and the\nrest can be anything. So that's just a review of\npattern matcher syntax that",
    "start": "129685",
    "end": "136750"
  },
  {
    "text": "you've already seen. And remember, that's implemented\nby some procedure called match.",
    "start": "136750",
    "end": "142740"
  },
  {
    "text": " And match takes a pattern and\nsome data and a dictionary.",
    "start": "142740",
    "end": "155694"
  },
  {
    "start": "155695",
    "end": "163200"
  },
  {
    "text": "And match asks the question is\nthere any way to match this",
    "start": "163200",
    "end": "170470"
  },
  {
    "text": "pattern against this data object\nsubject to the bindings that are already in\nthis dictionary?",
    "start": "170470",
    "end": "178160"
  },
  {
    "text": "So, for instance, if we're going\nto match the pattern x,",
    "start": "178160",
    "end": "183200"
  },
  {
    "text": "y, y, x against the data a, b,\nb, a subject to a dictionary,",
    "start": "183200",
    "end": "198080"
  },
  {
    "text": "that says x equals a. Then the matcher would say,\nyes, that's consistent.",
    "start": "198080",
    "end": "205260"
  },
  {
    "text": "These match, and it's consistent\nwith what's in the dictionary to say\nthat x equals a.",
    "start": "205260",
    "end": "210320"
  },
  {
    "text": "And the result of the match is\nthe extended dictionary that says x equals a and\ny equals b.",
    "start": "210320",
    "end": "219489"
  },
  {
    "text": "So a matcher takes in pattern\ndata dictionary, puts out an extended dictionary if it\nmatches, or if it doesn't",
    "start": "219490",
    "end": "225590"
  },
  {
    "text": "match, says that it fails. So, for example, if I use the\nsame pattern here, if I say",
    "start": "225590",
    "end": "231620"
  },
  {
    "text": "this x, y, y, x match a, b, b, a\nwith the dictionary y equals",
    "start": "231620",
    "end": "242450"
  },
  {
    "text": "a, then the matcher would\nput out fail. ",
    "start": "242450",
    "end": "252150"
  },
  {
    "text": "Well, you've already seen the\ncode for a pattern matcher so I'm not going to go over it, but\nit's the same thing we've",
    "start": "252150",
    "end": "259040"
  },
  {
    "text": "been doing before. You saw that in the system\non rule-based control. It's essentially the\nsame matcher.",
    "start": "259040",
    "end": "264950"
  },
  {
    "text": "In fact, I think the syntax is\na little bit simpler because we're not worrying about\narbitrary constants and",
    "start": "264950",
    "end": "270490"
  },
  {
    "text": "expressions and things. There's just variables\nand constants. ",
    "start": "270490",
    "end": "275790"
  },
  {
    "start": "274000",
    "end": "592000"
  },
  {
    "text": "OK, well, given that, what's\na primitive query? ",
    "start": "275790",
    "end": "282969"
  },
  {
    "text": "Primitive query is going to be\na rather complicated thing. It's going to be--",
    "start": "282970",
    "end": "288100"
  },
  {
    "text": "let's think about the query\njob of x is d dot y.",
    "start": "288100",
    "end": "303490"
  },
  {
    "text": " That's a query we\nmight type in.",
    "start": "303490",
    "end": "309400"
  },
  {
    "text": "That's going to be implemented\nin the system.  We'll think of it as\nthis little box.",
    "start": "309400",
    "end": "315699"
  },
  {
    "text": "Here's the primitive query. What this little box is going\nto do is take in two streams",
    "start": "315700",
    "end": "332070"
  },
  {
    "text": "and put out a stream. So the shape of a primitive\nquery is that it's a thing",
    "start": "332070",
    "end": "337310"
  },
  {
    "text": "where two streams come in\nand one stream goes out. What these streams are\ngoing to be is",
    "start": "337310",
    "end": "343240"
  },
  {
    "text": "down here is the database. ",
    "start": "343240",
    "end": "351599"
  },
  {
    "text": "So we imagine all the things\nin the database sort of sitting there in a stream and\nthis thing sucks on them.",
    "start": "351600",
    "end": "360330"
  },
  {
    "text": "So what are some things that\nmight be in the database? Oh, job of Alyssa is\nsomething and some",
    "start": "360330",
    "end": "382440"
  },
  {
    "text": "other job is something. So imagine all of the facts in\nthe database sitting there in",
    "start": "382440",
    "end": "389800"
  },
  {
    "text": "the stream. That's what comes in here. What comes in here is a stream\nof dictionaries.",
    "start": "389800",
    "end": "398509"
  },
  {
    "text": "So one particular dictionary\nmight say y equals programmer.",
    "start": "398510",
    "end": "408855"
  },
  {
    "start": "408855",
    "end": "415470"
  },
  {
    "text": "Now, what the query does when\nit gets in a dictionary from this stream, it finds all\npossible ways of matching the",
    "start": "415470",
    "end": "426090"
  },
  {
    "text": "query against whatever is coming\nin from the database.",
    "start": "426090",
    "end": "431389"
  },
  {
    "text": "It looks at the query as a\npattern, matches it against any fact from the database or\nall possible ways of finding",
    "start": "431390",
    "end": "440870"
  },
  {
    "text": "and matching the database with\nrespect to this dictionary that's coming in.",
    "start": "440870",
    "end": "447550"
  },
  {
    "text": "So for each fact in the\ndatabase, it calls the matcher using the pattern, fact,\nand dictionary.",
    "start": "447550",
    "end": "455110"
  },
  {
    "text": "And every time it gets a good\nmatch, it puts out the extended dictionary.",
    "start": "455110",
    "end": "460420"
  },
  {
    "text": "So, for example, if this one\ncomes in and it finds a match, out will come a dictionary that\nin this case will have y",
    "start": "460420",
    "end": "468710"
  },
  {
    "text": "equals programmer and\nx equals something. ",
    "start": "468710",
    "end": "476740"
  },
  {
    "text": "y is programmer, x is\nsomething, and d is whatever it found. And that's all.",
    "start": "476740",
    "end": "483520"
  },
  {
    "text": "And, of course, it's going to\ntry this for every fact in the dictionary. So it might find lots of them.",
    "start": "483520",
    "end": "489250"
  },
  {
    "text": "It might find another one that\nsays y equals programmer and x equals, and d equals.",
    "start": "489250",
    "end": "496354"
  },
  {
    "text": " So for one frame coming\nin, it might put out--",
    "start": "496355",
    "end": "502750"
  },
  {
    "text": "for one dictionary coming in,\nit might put out a lot of dictionaries, or it might\nput out none.",
    "start": "502750",
    "end": "510470"
  },
  {
    "text": "It might have something\nthat wouldn't match like x equals FOO.",
    "start": "510470",
    "end": "519320"
  },
  {
    "text": "This one might not match\nanything in which case nothing will go into this stream\ncorresponding to this frame.",
    "start": "519320",
    "end": "527510"
  },
  {
    "text": "Or what you might do is put in\nan empty frame, and an empty",
    "start": "527510",
    "end": "533560"
  },
  {
    "text": "frame says try matching\nall ways-- ",
    "start": "533560",
    "end": "539930"
  },
  {
    "text": "find all possible ways of\nmatching the query against something in the database\nsubject to no previous",
    "start": "539930",
    "end": "545470"
  },
  {
    "text": "restrictions. And if you think about what that\nmeans, that's just the",
    "start": "545470",
    "end": "550620"
  },
  {
    "text": "computation that's done when you\ntype in a query right off. It tries to find all matches.",
    "start": "550620",
    "end": "556649"
  },
  {
    "text": "So a primitive query sets\nup this mechanism. And what the language does, when\nyou type in the query at",
    "start": "556650",
    "end": "563920"
  },
  {
    "text": "the top level, it takes this\nmechanism, feeds in one single empty dictionary, and then for\neach thing that comes out",
    "start": "563920",
    "end": "573130"
  },
  {
    "text": "takes the original query and\ninstantiates the result with",
    "start": "573130",
    "end": "579330"
  },
  {
    "text": "all the different dictionaries,\nproducing a new stream of instantiated\npatterns here.",
    "start": "579330",
    "end": "584990"
  },
  {
    "text": "And that's what gets printed\non the terminal. That's the basic mechanism\ngoing on there.",
    "start": "584990",
    "end": "593510"
  },
  {
    "start": "592000",
    "end": "1048000"
  },
  {
    "text": "Well, why is that\nso complicated? You probably can think of a lot\nsimpler ways to arrange",
    "start": "593510",
    "end": "600310"
  },
  {
    "text": "this match for a primitive query\nrather than having all of these streams floating\naround. And the answer is--",
    "start": "600310",
    "end": "607290"
  },
  {
    "text": "you probably guess already. The answer is this thing extends\nelegantly to implement",
    "start": "607290",
    "end": "615660"
  },
  {
    "text": "the means of combination. So, for instance, suppose I\ndon't only want to do this.",
    "start": "615660",
    "end": "622470"
  },
  {
    "text": "I don't want to say who to be\neverybody's job description. Suppose I want to say AND the\njob of x is d dot y and the",
    "start": "622470",
    "end": "639139"
  },
  {
    "text": "supervisor of x is z.",
    "start": "639140",
    "end": "648800"
  },
  {
    "text": "Now, supervisor of x is z is\ngoing to be another primitive query that has the same shape\nto take in a stream of data",
    "start": "648800",
    "end": "657830"
  },
  {
    "text": "objects, a stream of initial\ndictionaries, which are the restrictions to try and use when\nyou match, and it's going",
    "start": "657830",
    "end": "665930"
  },
  {
    "text": "to put out a stream\nof dictionaries. So that's what this primitive\nquery looks like.",
    "start": "665930",
    "end": "671680"
  },
  {
    "text": "And how do I implement\nthe AND? Well, it's simple. I just hook them together. I take the output of this one,\nand I put that to the",
    "start": "671680",
    "end": "677790"
  },
  {
    "text": "input of that one. And I take the dictionary\nhere and I fan it out. ",
    "start": "677790",
    "end": "686570"
  },
  {
    "text": "And then you see how that's\ngoing to work, because what's going to happen is a frame will\nnow come in here, which",
    "start": "686570",
    "end": "692820"
  },
  {
    "text": "has a binding for x, y, and d.",
    "start": "692820",
    "end": "697920"
  },
  {
    "text": "And then when this one gets\nit, it'll say, oh, gee, subject to these restrictions,\nwhich now already have values",
    "start": "697920",
    "end": "705530"
  },
  {
    "text": "in the dictionary for y and\nx and d, it looks in the",
    "start": "705530",
    "end": "712340"
  },
  {
    "text": "database and says, gee, can I\nfind any supervisor facts? And if it finds any, out will\ncome dictionaries which have",
    "start": "712340",
    "end": "720120"
  },
  {
    "text": "bindings for y and x\nand d and z now.",
    "start": "720120",
    "end": "729339"
  },
  {
    "text": " And then notice that because the\nframes coming in here have",
    "start": "729340",
    "end": "736430"
  },
  {
    "text": "these restrictions, that's the\nthing that assures that when you do the AND, this x will mean\nthe same thing as that x.",
    "start": "736430",
    "end": "746470"
  },
  {
    "text": "Because by the time something\ncomes floating in here, x has a value that you have to match\nagainst consistently.",
    "start": "746470",
    "end": "754460"
  },
  {
    "text": "And then you remember from the\ncode from the matcher, there was something in the way the\nmatcher did dictionaries that arrange consistent matches.",
    "start": "754460",
    "end": "760710"
  },
  {
    "text": "So there's AND. The important point to notice\nis the general shape.",
    "start": "760710",
    "end": "768570"
  },
  {
    "text": "Look at what happened: the AND\nof two queries, say, P and Q. Here's P and Q. The AND\nof two queries, well,",
    "start": "768570",
    "end": "780464"
  },
  {
    "text": "it looks like this. Each query takes in a stream\nfrom the database, a stream of inputs, and puts out a\nstream of outputs.",
    "start": "780465",
    "end": "790230"
  },
  {
    "text": "And the important point to\nnotice is that if I draw a box around this thing and say this\nis AND of P and Q, then that",
    "start": "790230",
    "end": "806500"
  },
  {
    "text": "box has exactly the same\noverall shape.",
    "start": "806500",
    "end": "812360"
  },
  {
    "text": "It's something that takes in\na stream from the database. Here it's going to get fanned\nout inside, but from the outside you don't see that.",
    "start": "812360",
    "end": "818160"
  },
  {
    "text": "It takes an input stream and\nputs out an output stream. So this is AND.",
    "start": "818160",
    "end": "823570"
  },
  {
    "text": "And then similarly, OR\nwould look like this. OR would-- although I didn't show\nyou examples of OR.",
    "start": "823570",
    "end": "829840"
  },
  {
    "text": "OR would say can I find all ways\nof matching P or Q. So I",
    "start": "829840",
    "end": "835970"
  },
  {
    "text": "have P and Q. Each will\nhave their shape. ",
    "start": "835970",
    "end": "844460"
  },
  {
    "text": "And the way OR is implemented\nis I'll take my database stream.",
    "start": "844460",
    "end": "852500"
  },
  {
    "text": "I'll fan it out. I'll put one into P and one into\nQ. I'll take my initial",
    "start": "852500",
    "end": "859870"
  },
  {
    "text": "query stream coming\nin and fan it out. ",
    "start": "859870",
    "end": "866750"
  },
  {
    "text": "So I'll look at all the answers\nI might get from P and all the answers I might get\nfrom Q, and I'll put them",
    "start": "866750",
    "end": "872950"
  },
  {
    "text": "through some sort of thing that\nappends them or merges the result into one stream, and\nthat's what will come out.",
    "start": "872950",
    "end": "881080"
  },
  {
    "text": "And this whole thing from\nthe outside is OR.",
    "start": "881080",
    "end": "888240"
  },
  {
    "text": " And again, you see it has the\nsame overall shape when looked",
    "start": "888240",
    "end": "895540"
  },
  {
    "text": "at from the outside. ",
    "start": "895540",
    "end": "901000"
  },
  {
    "text": "What's NOT? NOT works kind of\nthe same way. If I have some query P, I take\nthe primitive query for P.",
    "start": "901000",
    "end": "914690"
  },
  {
    "text": "Here, I'm going to implement NOT\nP. And NOT's just going to act as a filter.",
    "start": "914690",
    "end": "920720"
  },
  {
    "text": "I'll take in the database and\nmy original stream of",
    "start": "920720",
    "end": "927050"
  },
  {
    "text": "dictionaries coming in, and what\nNOT P will do is it will",
    "start": "927050",
    "end": "932209"
  },
  {
    "text": "filter these guys.",
    "start": "932210",
    "end": "939020"
  },
  {
    "text": "And the way it will filter it,\nit will say when I get in a dictionary here, I'll find all\nthe matches, and if I find",
    "start": "939020",
    "end": "945540"
  },
  {
    "text": "any, I'll throw it away. And if I don't find any matches\nto something coming in here, I'll just pass\nthat through, so",
    "start": "945540",
    "end": "952500"
  },
  {
    "text": "NOT is a pure filter. So AND is-- think of these sort\nof electoral",
    "start": "952500",
    "end": "959090"
  },
  {
    "text": "resistors or something. AND is series combination and\nOR is parallel combination.",
    "start": "959090",
    "end": "964959"
  },
  {
    "text": "And then NOT is not going\nto extend any dictionaries at all. It's just going to filter it. It's going to throw away\nthe ones for which it",
    "start": "964960",
    "end": "970220"
  },
  {
    "text": "finds a way to match. And list value is sort\nof the same way. The filter's a little\nmore complicated.",
    "start": "970220",
    "end": "976600"
  },
  {
    "text": "It applies to predicate. The major point to notice here,\nand it's a major point",
    "start": "976600",
    "end": "982610"
  },
  {
    "text": "we've looked at before, is\nthis idea of closure. ",
    "start": "982610",
    "end": "988490"
  },
  {
    "text": "The things that we build as a\nmeans of combination have the same overall structure\nas the primitive",
    "start": "988490",
    "end": "996470"
  },
  {
    "text": "things that we're combining. So the AND of two things when\nlooked at from the outside has",
    "start": "996470",
    "end": "1002950"
  },
  {
    "text": "the same shape. And what that means is that this\nbox here could be an AND",
    "start": "1002950",
    "end": "1008790"
  },
  {
    "text": "or an OR or a NOT or something\nbecause it has the same shape to interface to the\nlarger things.",
    "start": "1008790",
    "end": "1014950"
  },
  {
    "text": "It's the same thing that allowed\nus to get complexity in the Escher picture language\nor allows you to immediately",
    "start": "1014950",
    "end": "1020980"
  },
  {
    "text": "build up these complicated\nstructures just out of pairs. It's closure.",
    "start": "1020980",
    "end": "1026280"
  },
  {
    "text": "And that's the thing that\nallowed me to do what by now you took for granted when I\nsaid, gee, there's a query",
    "start": "1026280",
    "end": "1032829"
  },
  {
    "text": "which is AND of job and salary,\nand I said, oh, there's another one,\nwhich is AND of job, a NOT of something.",
    "start": "1032829",
    "end": "1039259"
  },
  {
    "text": "The fact that I can do that is\na direct consequence of this closure principle.",
    "start": "1039260",
    "end": "1045230"
  },
  {
    "text": "OK, let's break and\nthen we'll go on. AUDIENCE: Where does the\ndictionary come from?",
    "start": "1045230",
    "end": "1050710"
  },
  {
    "start": "1048000",
    "end": "1189000"
  },
  {
    "text": "PROFESSOR: The dictionary\ncomes initially from what you type in.",
    "start": "1050710",
    "end": "1056030"
  },
  {
    "text": "So when you start this up, the\nfirst thing it does is set up this whole structure.",
    "start": "1056030",
    "end": "1061090"
  },
  {
    "text": "It puts in one empty\ndictionary. And if all you have is one\nprimitive query, then what",
    "start": "1061090",
    "end": "1068560"
  },
  {
    "text": "will come out is a bunch\nof dictionaries with things filled in. The general situation that I\nhave here is when this is in",
    "start": "1068560",
    "end": "1075330"
  },
  {
    "text": "the middle of some nest\nof combined things. ",
    "start": "1075330",
    "end": "1082380"
  },
  {
    "text": "Let's look at the picture\nover here. This supervisor query gets\nin some dictionary. Where did this one come from?",
    "start": "1082380",
    "end": "1088730"
  },
  {
    "text": "This dictionary came from the\nfact that I'm looking at the output of this primitive\nquery.",
    "start": "1088730",
    "end": "1096260"
  },
  {
    "text": "So maybe to be very specific,\nif I literally typed in just this query at the top level,\nthis AND, what would actually",
    "start": "1096260",
    "end": "1103820"
  },
  {
    "text": "happen is it would build this\nstructure and start up this whole thing with one\nempty dictionary.",
    "start": "1103820",
    "end": "1111770"
  },
  {
    "text": "And now this one would process,\nand a whole bunch of dictionaries would come out with\nx, y's and d's in them.",
    "start": "1111770",
    "end": "1118640"
  },
  {
    "text": "Run it through this one. So now that's the input\nto this one. This one would now put\nout some other stuff.",
    "start": "1118640",
    "end": "1125040"
  },
  {
    "text": "And if this itself were buried\nin some larger thing, like an",
    "start": "1125040",
    "end": "1130110"
  },
  {
    "text": "OR of something, then\nthat would go feed into the next one.",
    "start": "1130110",
    "end": "1136110"
  },
  {
    "text": " So you initially get only one\nempty dictionary when you start it, but as you're in the\nmiddle of processing these",
    "start": "1136110",
    "end": "1143380"
  },
  {
    "text": "compounds things, that's where\nthese cascades of dictionaries start getting generated. AUDIENCE: Dictionaries only\ncome about as a result of",
    "start": "1143380",
    "end": "1151030"
  },
  {
    "text": "using the queries?  Or do they become--",
    "start": "1151030",
    "end": "1158280"
  },
  {
    "text": "do they stay someplace in space\nlike the database does? Are these temporary items?",
    "start": "1158280",
    "end": "1164980"
  },
  {
    "text": "PROFESSOR: They're created\ntemporarily in the matcher. Really, they're someplace\nin storage. Initially, someone creates\na thing called the empty",
    "start": "1164980",
    "end": "1172430"
  },
  {
    "text": "dictionary that gets initially\nfed to this match procedure, and then the match procedure\nbuilds some dictionaries, and",
    "start": "1172430",
    "end": "1179150"
  },
  {
    "text": "they get passed on and on. AUDIENCE: OK, so they'll\ngo way after the match? PROFESSOR: They'll go\naway when no one",
    "start": "1179150",
    "end": "1184680"
  },
  {
    "text": "needs them again, yeah. ",
    "start": "1184680",
    "end": "1191900"
  },
  {
    "text": "AUDIENCE: It appears that the\nAND performs some redundant searches of the database. If the first clause matched,\nlet's say, the third element",
    "start": "1191900",
    "end": "1198660"
  },
  {
    "text": "and not on the first two\nelements, the second clause is going to look at those first two\nelements again, discarding",
    "start": "1198660",
    "end": "1204889"
  },
  {
    "text": "them because they don't match. The match is already\nin the dictionary.",
    "start": "1204890",
    "end": "1210000"
  },
  {
    "text": "Would it makes sense to carry\nthe data element from the database along with\nthe dictionary? ",
    "start": "1210000",
    "end": "1217120"
  },
  {
    "text": "PROFESSOR: Well, in general,\nthere are other ways to arrange this search, and\nthere's some analysis that you can do. I think there's a problem in the\nbook, which talks about a",
    "start": "1217120",
    "end": "1224600"
  },
  {
    "text": "different way that you can\ncascade AND to eliminate various kinds of redundancies.",
    "start": "1224600",
    "end": "1229850"
  },
  {
    "text": "This one is meant to be-- was mainly meant to be very\nsimple so you can see how they fit together. But you're quite right.",
    "start": "1229850",
    "end": "1235380"
  },
  {
    "text": "There are redundancies here\nthat you can get rid of. That's another reason why this\nlanguage is somewhat slow.",
    "start": "1235380",
    "end": "1241190"
  },
  {
    "text": "There are a lot smarter\nthings you can do. We're just trying to show you\na very simple, in principle, implementation.",
    "start": "1241190",
    "end": "1246840"
  },
  {
    "text": " AUDIENCE: Did you model this\nlanguage on Prolog, or did it",
    "start": "1246840",
    "end": "1253716"
  },
  {
    "start": "1249000",
    "end": "1414000"
  },
  {
    "text": "just come out looking\nlike Prolog? ",
    "start": "1253716",
    "end": "1264960"
  },
  {
    "text": "PROFESSOR: Well, Jerry insulted\na whole bunch of people yesterday, so I might\nas well say that the MIT attitude towards Prolog is\nsomething that people did in",
    "start": "1264960",
    "end": "1271460"
  },
  {
    "text": "about 1971 and decided that it\nwasn't really the right thing and stopped. So we modeled this on the sort\nof natural way that this thing",
    "start": "1271460",
    "end": "1282640"
  },
  {
    "text": "was done in about 1971, except\nat that point, we didn't do it with streams. After we were\nusing it for about six months,",
    "start": "1282640",
    "end": "1293020"
  },
  {
    "text": "we discovered that it had all\nthese problems, some of which I'll talk about later. And we said, gee, Prolog must\nhave fixed those, and then we",
    "start": "1293020",
    "end": "1300309"
  },
  {
    "text": "found out that it didn't. So this does about the\nsame thing as Prolog. AUDIENCE: Does Prolog\nuse streams? PROFESSOR: No.",
    "start": "1300310",
    "end": "1306200"
  },
  {
    "text": " In how it behaves, it behaves\na lot like Prolog. Prolog uses a backtracking\nstrategy.",
    "start": "1306200",
    "end": "1313800"
  },
  {
    "text": "But the other thing that's\nreally good about Prolog that makes it a usable thing is that\nthere's a really very,",
    "start": "1313800",
    "end": "1319950"
  },
  {
    "text": "very well-engineered compiler\ntechnology that makes it run fast. So although you saw the\nmerge spitting out these",
    "start": "1319950",
    "end": "1329260"
  },
  {
    "text": "answers very, very slowly, a\nreal Prolog will run very, very fast. Because even though\nit's sort of doing this, the",
    "start": "1329260",
    "end": "1336799"
  },
  {
    "text": "real work that went into\nProlog is a very, very excellent compiler effort. ",
    "start": "1336800",
    "end": "1344460"
  },
  {
    "text": "Let's take a break. ",
    "start": "1344460",
    "end": "1396649"
  },
  {
    "text": "We've looked at the primitive\nqueries and the ways that streams are used to implement\nthe means of combination: AND",
    "start": "1396650",
    "end": "1404300"
  },
  {
    "text": "and OR and NOT. Now, let go on to the means\nof abstraction.",
    "start": "1404300",
    "end": "1409580"
  },
  {
    "text": "Remember, the means of\nabstraction in this language are rules. ",
    "start": "1409580",
    "end": "1415149"
  },
  {
    "text": "So z is a boss in division d\nif there's some x who has a",
    "start": "1415150",
    "end": "1422580"
  },
  {
    "text": "job in division d and z is\nthe supervisor of x.",
    "start": "1422580",
    "end": "1428899"
  },
  {
    "text": "That's what it means for\nsomeone to be a boss. And in effect, if you think\nabout what we're doing with",
    "start": "1428900",
    "end": "1434780"
  },
  {
    "text": "relation to this, there's the\nquery we wrote-- the job of x is in d and the supervisor\nof x is z--",
    "start": "1434780",
    "end": "1442150"
  },
  {
    "text": "what we in effect want to do\nis take this whole mess and draw a box around it and say\nthis whole thing inside the",
    "start": "1442150",
    "end": "1464070"
  },
  {
    "text": "box is boss of z\nin division d.",
    "start": "1464070",
    "end": "1473899"
  },
  {
    "text": "That's in effect what\nwe want to do.  So, for instance, if we've\ndone that, and we want to",
    "start": "1473900",
    "end": "1485690"
  },
  {
    "text": "check whether or not it's true\nthat Ben Bitdiddle is a boss in the computer division, so if\nI want to say boss of Ben",
    "start": "1485690",
    "end": "1500730"
  },
  {
    "text": "Bitdiddle in the computer\ndivision, imagine typing that",
    "start": "1500730",
    "end": "1505850"
  },
  {
    "text": "in as query to the system, in\neffect what we want to do is",
    "start": "1505850",
    "end": "1510860"
  },
  {
    "text": "set up a dictionary here, which\nhas z to Ben Bitdiddle",
    "start": "1510860",
    "end": "1528920"
  },
  {
    "text": "and d to computer. ",
    "start": "1528920",
    "end": "1537340"
  },
  {
    "text": "Where did that dictionary\ncome from? Let's look at the slide\nfor one second. That dictionary came from\nmatching the query that said",
    "start": "1537340",
    "end": "1544750"
  },
  {
    "text": "boss of Ben Bitdiddle and\ncomputer onto the conclusion of the rule: boss of z and d.",
    "start": "1544750",
    "end": "1551650"
  },
  {
    "text": "So we match the query to the\nconclusion of the rule. That gives us a dictionary, and\nthat's the thing that we",
    "start": "1551650",
    "end": "1560330"
  },
  {
    "text": "would now like to put into\nthis whole big thing and process and see if anything\ncomes out the other side.",
    "start": "1560330",
    "end": "1566670"
  },
  {
    "text": "If anything comes out,\nit'll be true. That's the basic idea.",
    "start": "1566670",
    "end": "1572370"
  },
  {
    "text": "So in general, the way we\nimplement a rule is we match the conclusion of the rule\nagainst something we might",
    "start": "1572370",
    "end": "1581860"
  },
  {
    "text": "want to check it's true. That match gives us a\ndictionary, and with respect to that dictionary, we process\nthe body of the rule.",
    "start": "1581860",
    "end": "1596470"
  },
  {
    "text": "Well, that's really all\nthere is, except for two technical points.",
    "start": "1596470",
    "end": "1603070"
  },
  {
    "text": "The first technical point is\nthat I might have said something else. I might have said who's the boss\nin the computer division?",
    "start": "1603070",
    "end": "1612490"
  },
  {
    "text": "So I might say boss of who\nin computer division. ",
    "start": "1612490",
    "end": "1620329"
  },
  {
    "text": "And if I did that, what I would\nreally like to do in effect is start up this\ndictionary with a match that",
    "start": "1620329",
    "end": "1629280"
  },
  {
    "text": "sort of says, well, d\nis computer and z is",
    "start": "1629280",
    "end": "1637370"
  },
  {
    "text": "whatever who is.  And our matcher won't\nquite do that.",
    "start": "1637370",
    "end": "1643220"
  },
  {
    "text": "That's not quite matching\na pattern against data.",
    "start": "1643220",
    "end": "1648580"
  },
  {
    "text": "It's matching two patterns and\nsaying are they consistent or not or what ways make\nthem consistent. In other words, what we need\nis not quite a pattern",
    "start": "1648580",
    "end": "1655940"
  },
  {
    "text": "matcher, but something\na little bit more general called a unifier. ",
    "start": "1655940",
    "end": "1664420"
  },
  {
    "text": "And a unifier is a slight\ngeneralization of a pattern matcher.",
    "start": "1664420",
    "end": "1669529"
  },
  {
    "text": "What a unifier does is take two\npatterns and say what's",
    "start": "1669530",
    "end": "1675390"
  },
  {
    "text": "the most general thing you can\nsubstitute for the variables in those two patterns to make\nthem satisfy the pattern",
    "start": "1675390",
    "end": "1684060"
  },
  {
    "text": "simultaneously? Let me give you an example. If I have the pattern\ntwo-element list, which is x",
    "start": "1684060",
    "end": "1693940"
  },
  {
    "start": "1688000",
    "end": "1991000"
  },
  {
    "text": "and x, so I have a two-element\nlist where both elements are the same and otherwise I don't\ncare what they are, and I",
    "start": "1693940",
    "end": "1700669"
  },
  {
    "text": "unify that against the pattern\nthat says there's a two-element list, and the first\none is a and something",
    "start": "1700670",
    "end": "1707010"
  },
  {
    "text": "in c and the second one is a\nand b and z, then what the",
    "start": "1707010",
    "end": "1713830"
  },
  {
    "text": "unifier should tell me is, oh\nyeah, in that dictionary, x has to be a, b, c, and y has\nto be d and z has to be c.",
    "start": "1713830",
    "end": "1723440"
  },
  {
    "text": "Those are the restrictions I'd\nhave to put on the values of x, y, and z to make these two\nunify, or in other words, to",
    "start": "1723440",
    "end": "1728880"
  },
  {
    "text": "make this match x and\nmake this match x.",
    "start": "1728880",
    "end": "1735420"
  },
  {
    "text": "The unifier should be\nable to deduce that. But the unifier may-- there are more complicated\nthings.",
    "start": "1735420",
    "end": "1741080"
  },
  {
    "text": "I might have said something a\nlittle bit more complicated. I might have said there's a list\nwith two elements, and",
    "start": "1741080",
    "end": "1747170"
  },
  {
    "text": "they're both the same, and\nthey should unify against something of this form.",
    "start": "1747170",
    "end": "1752649"
  },
  {
    "text": "And the unifier should be able\nto deduce from that. Like that y would have to be\nb. y would have to be b.",
    "start": "1752650",
    "end": "1759570"
  },
  {
    "text": "Because these two are the same,\nso y's got to be b. And v here would have to be a.",
    "start": "1759570",
    "end": "1768940"
  },
  {
    "text": "And z and w can be anything,\nbut they have to be the same thing. ",
    "start": "1768940",
    "end": "1775710"
  },
  {
    "text": "And x would have to be b,\nfollowed by a, followed by whatever w is or whatever\nz is, which is the same.",
    "start": "1775710",
    "end": "1784680"
  },
  {
    "text": "So you see, the unifier somehow\nhas to deduce things to unify these patterns.",
    "start": "1784680",
    "end": "1790880"
  },
  {
    "text": "So you might think there's some\nkind of magic deduction going on, but there's not. A unifier is basically a very\nsimple modification of a",
    "start": "1790880",
    "end": "1799100"
  },
  {
    "text": "pattern matcher. And if you look in the book,\nyou'll see something like three or four lines of code\nadded to the pattern matcher",
    "start": "1799100",
    "end": "1805350"
  },
  {
    "text": "you just saw to handle\nthe symmetric case. Remember, the pattern matcher\nhas a place where it says is",
    "start": "1805350",
    "end": "1811920"
  },
  {
    "text": "this variable matching\na constant. And if so, it checks\nin the dictionary. There's only one other clause in\nthe unifier, which says is",
    "start": "1811920",
    "end": "1818970"
  },
  {
    "text": "this variable matching a\nvariable, in which case you go look in the dictionary and see\nif that's consistent with",
    "start": "1818970",
    "end": "1824740"
  },
  {
    "text": "what's in the dictionary. So all the, quote, deduction\nthat's in this language, if",
    "start": "1824740",
    "end": "1831450"
  },
  {
    "text": "you sort of look at it, sort\nof sits in the rule applications, which, if you\nlook at that, sits in the",
    "start": "1831450",
    "end": "1837220"
  },
  {
    "text": "unifier, which, if you look at\nthat under a microscope, sits",
    "start": "1837220",
    "end": "1842500"
  },
  {
    "text": "essentially in the\npattern matcher. There's no magic at all\ngoing on in there. And the, quote, deduction that\nyou see is just the fact that",
    "start": "1842500",
    "end": "1851930"
  },
  {
    "text": "there's this recursion,\nwhich is unwinding the matches bit by bit. So it looks like this thing is\nbeing very clever, but in",
    "start": "1851930",
    "end": "1858670"
  },
  {
    "text": "fact, it's not being\nvery clever at all. There are cases where a unifier might have to be clever.",
    "start": "1858670",
    "end": "1864880"
  },
  {
    "text": "Let me show you one more. ",
    "start": "1864880",
    "end": "1871070"
  },
  {
    "text": "Suppose I want to unify a list\nof two elements, x and x, with",
    "start": "1871070",
    "end": "1877529"
  },
  {
    "text": "a thing that says it's y\nfollowed by a dot y.",
    "start": "1877530",
    "end": "1884370"
  },
  {
    "text": "Now, if you think of what that\nwould have to mean, it would have to mean that x had better\nbe the same as y, but also x",
    "start": "1884370",
    "end": "1892230"
  },
  {
    "text": "had better be the same as a list\nwhose first element is a and whose rest is y.",
    "start": "1892230",
    "end": "1897330"
  },
  {
    "text": "And if you think about what that\nwould have to mean, it",
    "start": "1897330",
    "end": "1902460"
  },
  {
    "text": "would have to mean that y is\nthe infinite list of a's. ",
    "start": "1902460",
    "end": "1907500"
  },
  {
    "text": "In some sense, in order to do\nthat unification, I have to",
    "start": "1907500",
    "end": "1913100"
  },
  {
    "text": "solve the fixed-point equation\ncons of a to y is equal to y.",
    "start": "1913100",
    "end": "1921840"
  },
  {
    "text": " And in general, I wrote\na very simple one.",
    "start": "1921840",
    "end": "1927289"
  },
  {
    "text": "Really doing unification might\nhave to solve an arbitrary fixed-point equation:\nf of y equals y.",
    "start": "1927290",
    "end": "1935530"
  },
  {
    "text": "And basically, you can't do that\nand make the thing finite all the time.",
    "start": "1935530",
    "end": "1940570"
  },
  {
    "text": "So how does the logic language\nhandle that? The answer is it doesn't.",
    "start": "1940570",
    "end": "1946850"
  },
  {
    "text": "It just punts. And there's a little check in\nthe unifier, which says, oh,",
    "start": "1946850",
    "end": "1952280"
  },
  {
    "text": "is this one of the hard cases\nwhich when I go to match things would involve solving\na fixed-point equation?",
    "start": "1952280",
    "end": "1958650"
  },
  {
    "text": "And in this case, I will\nthrow up my hands. And if that check were not in\nthere, what would happen?",
    "start": "1958650",
    "end": "1967990"
  },
  {
    "text": "In most cases is that the\nunifier would just go into an infinite loop.",
    "start": "1967990",
    "end": "1973740"
  },
  {
    "text": "And other logic programming\nlanguages work like that. So there's really no magic. The easy case is done\nin a matcher.",
    "start": "1973740",
    "end": "1980100"
  },
  {
    "text": "The hard case is not\ndone at all. And that's about the state\nof this technology.",
    "start": "1980100",
    "end": "1985115"
  },
  {
    "start": "1985115",
    "end": "1992840"
  },
  {
    "start": "1991000",
    "end": "2179000"
  },
  {
    "text": "Let me just say again formally\nhow rules work now that I talked about unifiers. So the official definition is\nthat to apply a rule, we--",
    "start": "1992840",
    "end": "2005260"
  },
  {
    "text": "well, let's start using some\nwords we've used before. Let's talk about sticking\ndictionaries into these big",
    "start": "2005260",
    "end": "2013280"
  },
  {
    "text": "boxes of query things as\nevaluating these large queries",
    "start": "2013280",
    "end": "2020090"
  },
  {
    "text": "relative to an environment\nor a frame. So when you think of that\ndictionary, what's the",
    "start": "2020090",
    "end": "2025350"
  },
  {
    "text": "dictionary after all? It's a bunch of meanings\nfor symbols. That's what we've been calling\nframes or environments.",
    "start": "2025350",
    "end": "2031800"
  },
  {
    "text": "What does it mean to do some\nprocessing relevant to an environment? That's what we've been\ncalling evaluation.",
    "start": "2031800",
    "end": "2038309"
  },
  {
    "text": "So we can say the way that you\napply a rule is to evaluate the rule body relative to an\nenvironment that's formed by",
    "start": "2038310",
    "end": "2047730"
  },
  {
    "text": "unifying the rule conclusion\nwith the given query.",
    "start": "2047730",
    "end": "2053230"
  },
  {
    "text": "And the thing I want you to\nnotice is the complete formal similarity to the net of\ncircular evaluator or the",
    "start": "2053230",
    "end": "2060760"
  },
  {
    "text": "substitution model. To apply a procedure, we\nevaluate the procedure body",
    "start": "2060760",
    "end": "2067099"
  },
  {
    "text": "relative to an environment\nthat's formed by blinding the procedure parameters\nto the arguments.",
    "start": "2067100",
    "end": "2074560"
  },
  {
    "text": "There's a complete formal\nsimilarity here between the rules, rule application, and\nprocedure application even",
    "start": "2074560",
    "end": "2080870"
  },
  {
    "text": "though these things are\nvery, very different. And again, you have the\nEVAL APPLY loop.",
    "start": "2080870",
    "end": "2087289"
  },
  {
    "text": "EVAL and APPLY. ",
    "start": "2087290",
    "end": "2093360"
  },
  {
    "text": "So in general, I might be\nprocessing some combined expression that will turn into a\nrule application, which will",
    "start": "2093360",
    "end": "2101050"
  },
  {
    "text": "generate some dictionaries or\nframes or environments-- whatever you want to call them--\nfrom match, which will then be the input to some big\ncompound thing like this.",
    "start": "2101050",
    "end": "2108660"
  },
  {
    "text": "This has pieces of it and may\nhave other rule applications. And you have essentially the\nsame cycle even though there's",
    "start": "2108660",
    "end": "2116220"
  },
  {
    "text": "nothing here at all that\nlooks like procedures. It really has to do with the\nfact you've built a language",
    "start": "2116220",
    "end": "2122119"
  },
  {
    "text": "whose means of combination\nand abstraction unwind in certain ways. ",
    "start": "2122120",
    "end": "2128770"
  },
  {
    "text": "And then in general, what\nhappens at the very top level,",
    "start": "2128770",
    "end": "2133840"
  },
  {
    "text": "you might have rules in your\ndatabase also, so things in this database might be rules.",
    "start": "2133840",
    "end": "2140460"
  },
  {
    "text": "There are ways to check\nthat things are true. So it might come in here and\nhave to do a rule check.",
    "start": "2140460",
    "end": "2146750"
  },
  {
    "text": "And then there's some control\nstructure which says, well, you look at some rules, and\nyou look at some data elements, and you look at some\nrules and data elements, and",
    "start": "2146750",
    "end": "2151964"
  },
  {
    "text": "these fan out and out and out. So it becomes essentially\nimpossible to say what order it's looking at these things in,\nwhether it's breadth first",
    "start": "2151965",
    "end": "2159300"
  },
  {
    "text": "or depth first or anything. And it's even more impossible\nbecause the actual order is somehow buried in the delays of\nthe streams. So what's very",
    "start": "2159300",
    "end": "2168900"
  },
  {
    "text": "hard to tell from this is the\norder in which it's scanned. But what's true, because you're\nlooking at the stream view, is that all of them\neventually get looked at.",
    "start": "2168900",
    "end": "2175820"
  },
  {
    "start": "2175820",
    "end": "2184980"
  },
  {
    "start": "2179000",
    "end": "2309000"
  },
  {
    "text": "Let me just mention one tiny\ntechnical problem. ",
    "start": "2184980",
    "end": "2197529"
  },
  {
    "text": "Suppose I tried saying boss of\ny is computer, then a funny",
    "start": "2197530",
    "end": "2204960"
  },
  {
    "text": "thing would happen. As I stuck a dictionary with\ny in here, I might get--",
    "start": "2204960",
    "end": "2213680"
  },
  {
    "text": "this y is not the same as that\ny, which was the other piece",
    "start": "2213680",
    "end": "2219349"
  },
  {
    "text": "of somebody's job description. So if I really only did\nliterally what I said, we'd",
    "start": "2219350",
    "end": "2224380"
  },
  {
    "text": "get some variable conflict\nproblems. So I lied to you a",
    "start": "2224380",
    "end": "2229990"
  },
  {
    "text": "little bit. Notice that problem is\nexactly a problem we've run into before. It is precisely the need for\nlocal variables in a language.",
    "start": "2229990",
    "end": "2240505"
  },
  {
    "text": "When I have the sum of\nsquares, that x had better not be that x. That's exactly the same\nas this y had",
    "start": "2240505",
    "end": "2248619"
  },
  {
    "text": "better not be that y. And we know how to solve that. That was this whole environment\nmodel, and we",
    "start": "2248620",
    "end": "2254730"
  },
  {
    "text": "built chains of frames and all\nsorts of things like that. There's a much more brutal\nway to solve it. In the query language, we\ndidn't even do that.",
    "start": "2254730",
    "end": "2261730"
  },
  {
    "text": "We did something completely\nbrutal. We said every time you apply a\nrule, rename consistently all",
    "start": "2261730",
    "end": "2268520"
  },
  {
    "text": "the variables in the rule to\nsome new unique names that won't conflict with anything.",
    "start": "2268520",
    "end": "2275720"
  },
  {
    "text": "That's conceptually simpler,\nbut really brutal and not particularly efficient. But notice, we could have\ngotten rid of all of our",
    "start": "2275720",
    "end": "2283700"
  },
  {
    "text": "environment structures if we\ndefined for procedures in Lisp the same thing.",
    "start": "2283700",
    "end": "2289180"
  },
  {
    "text": "If every time we applied\na procedure and did the substitution model we renamed\nall the variables in the procedure, then we never would\nhave had to worry about local",
    "start": "2289180",
    "end": "2295829"
  },
  {
    "text": "variables because they\nwould never arise. OK, well, that would be\ninefficient, and it's",
    "start": "2295830",
    "end": "2301240"
  },
  {
    "text": "inefficient here in the query\nlanguage, too, but we did it to keep it simple. Let's break for questions.",
    "start": "2301240",
    "end": "2306860"
  },
  {
    "text": " AUDIENCE: When you started this\nsection, you emphasized",
    "start": "2306860",
    "end": "2314869"
  },
  {
    "start": "2309000",
    "end": "2515000"
  },
  {
    "text": "how powerful our APPLY EVAL\nmodel was that we could use it",
    "start": "2314870",
    "end": "2320390"
  },
  {
    "text": "for any language. And then you say we're going to\nhave this language which is so different. It turns out that this language,\nas you just pointed",
    "start": "2320390",
    "end": "2326440"
  },
  {
    "text": "out, is very much the same. I'm wondering if you're arguing\nthat all languages end up coming down to this you can\napply a rule or apply a",
    "start": "2326440",
    "end": "2333810"
  },
  {
    "text": "procedure or some\nkind of apply? PROFESSOR: I would say that\npretty much any language where",
    "start": "2333810",
    "end": "2339150"
  },
  {
    "text": "you really are building up these\nmeans of combination and giving them simpler names and\nyou're saying anything of the",
    "start": "2339150",
    "end": "2346119"
  },
  {
    "text": "sort, like here's a general kind\nof expression, like how to square something, almost\nanything that you",
    "start": "2346120",
    "end": "2353180"
  },
  {
    "text": "would call a procedure. If that's got to have\nparts, you have to unwind those parts. You have to have some kind of\norganization which says when I",
    "start": "2353180",
    "end": "2360830"
  },
  {
    "text": "look at the abstract variables\nor tags or whatever you want to call them that might stand\nfor particular things, you",
    "start": "2360830",
    "end": "2368490"
  },
  {
    "text": "have to keep track of that,\nand that's going to be something like an environment. And then if you say this part\ncan have parts which I have to",
    "start": "2368490",
    "end": "2374670"
  },
  {
    "text": "unwind, you've got to have\nsomething like this cycle. ",
    "start": "2374670",
    "end": "2379970"
  },
  {
    "text": "And lots and lots of languages\nhave that character when they sort of get put together\nin this way.",
    "start": "2379970",
    "end": "2385590"
  },
  {
    "text": "This language again really is\ndifferent because there's nothing like procedures\non the outside.",
    "start": "2385590",
    "end": "2390690"
  },
  {
    "text": "When you go below the surface\nand you see the implementation, of course, it\nstarts looking the same. But from the outside, it's a\nvery different world view.",
    "start": "2390690",
    "end": "2396950"
  },
  {
    "text": "You're not computing functions\nof inputs. ",
    "start": "2396950",
    "end": "2403970"
  },
  {
    "text": "AUDIENCE: You mentioned earlier\nthat when you build all of these rules in pattern\nmatcher and with the delayed",
    "start": "2403970",
    "end": "2410660"
  },
  {
    "text": "action of streams, you really\nhave no way to know in what order things are evaluated. PROFESSOR: Right.",
    "start": "2410660",
    "end": "2415940"
  },
  {
    "text": "AUDIENCE: And that would\nindicate then that you should only express declarative\nknowledge that's true for",
    "start": "2415940",
    "end": "2421849"
  },
  {
    "text": "all-time, no-time sequence\nbuilt into it. Otherwise, these things\nget all--",
    "start": "2421850",
    "end": "2427440"
  },
  {
    "text": "PROFESSOR: Yes. Yes. The question is this really is\nset up for doing declarative knowledge, and as I presented\nit-- and I'll show you some of",
    "start": "2427440",
    "end": "2437190"
  },
  {
    "text": "the ugly warts under this\nafter the break. As I presented it, it's\njust doing logic.",
    "start": "2437190",
    "end": "2443070"
  },
  {
    "text": "And in principle, if it were\nlogic, it wouldn't matter what order it's getting done.",
    "start": "2443070",
    "end": "2448840"
  },
  {
    "text": "And it's quite true when you\nstart doing things where you have side effects like adding\nthings to the database and",
    "start": "2448840",
    "end": "2455380"
  },
  {
    "text": "taking things out, and we'll see\nsome others, you use that kind of control.",
    "start": "2455380",
    "end": "2461290"
  },
  {
    "text": "So, for example, contrasting\nwith Prolog. Say Prolog has various features\nwhere you really exploit the order\nof evaluation.",
    "start": "2461290",
    "end": "2469640"
  },
  {
    "text": "And people write Prolog\nprograms that way. That turns out to be very\ncomplicated in Prolog, although if you're\nan expert Prolog",
    "start": "2469640",
    "end": "2475940"
  },
  {
    "text": "programmer, you can do it. However, here I don't think\nyou can do it at all. It's very complicated because\nyou really are giving up",
    "start": "2475940",
    "end": "2482890"
  },
  {
    "text": "control over any prearranged\norder of trying things. AUDIENCE: Now, that would\nindicate then that you have a",
    "start": "2482890",
    "end": "2489210"
  },
  {
    "text": "functional mapping. And when you started out this\nlecture, you said that we",
    "start": "2489210",
    "end": "2494869"
  },
  {
    "text": "express the declarative\nknowledge which is a relation, and we don't talk about the\ninputs and the outputs. ",
    "start": "2494870",
    "end": "2501390"
  },
  {
    "text": "PROFESSOR: Well, there's a\npun on functional, right? There's function in the sense\nof no side effects and not",
    "start": "2501390",
    "end": "2506560"
  },
  {
    "text": "depending on what order\nis going on. And then there's functional in\nthe sense of mathematical function, which means\ninput and output.",
    "start": "2506560",
    "end": "2512220"
  },
  {
    "text": "And it's just that pun that\nyou're making, I think. AUDIENCE: I'm a little unclear\non what you're doing with",
    "start": "2512220",
    "end": "2518520"
  },
  {
    "start": "2515000",
    "end": "2605000"
  },
  {
    "text": "these two statements, the\ntwo boss statements. Is the first one building up\nthe database and the second",
    "start": "2518520",
    "end": "2526416"
  },
  {
    "text": "one a query or-- PROFESSOR: OK, I'm sorry.",
    "start": "2526416",
    "end": "2532440"
  },
  {
    "text": "What I meant here, if I\ntype something like this in as a query-- I should have given an example\nway at the very beginning.",
    "start": "2532440",
    "end": "2539470"
  },
  {
    "text": "If I type in job, Ben Bitdiddle,\ncomputer wizard,",
    "start": "2539470",
    "end": "2545099"
  },
  {
    "text": "what the processing will do is\nif it finds a match, it'll find a match to that exact\nthing, and it'll type out a",
    "start": "2545100",
    "end": "2551600"
  },
  {
    "text": "job, Ben Bitdiddle,\ncomputer wizard. If it doesn't find a match,\nit won't find anything.",
    "start": "2551600",
    "end": "2557400"
  },
  {
    "text": "So what I should have said is\nthe way you use the query language to check whether\nsomething is true, remember,",
    "start": "2557400",
    "end": "2563610"
  },
  {
    "text": "that's one of the things\nyou want to do in logic programming, is you type in\nyour query and either that comes out or it doesn't.",
    "start": "2563610",
    "end": "2570680"
  },
  {
    "text": "So what I was trying to\nillustrate here, I wanted to start with a very simple\nexample before talking about unifiers.",
    "start": "2570680",
    "end": "2577480"
  },
  {
    "text": "So what I should have said, if I\njust wanted to check whether this is true, I could type that\nin and see if anything",
    "start": "2577480",
    "end": "2582820"
  },
  {
    "text": "came out AUDIENCE: And then\nthe second one-- PROFESSOR: The second one\nwould be a real query.",
    "start": "2582820",
    "end": "2587830"
  },
  {
    "text": "AUDIENCE: A real query, yeah. PROFESSOR: What would come out,\nsee, it would go in here say with FOO, and in would go\nframe that says z is bound to",
    "start": "2587830",
    "end": "2597480"
  },
  {
    "text": "who and d is bound\nto computer. And this will pass through, and\nthen by the time it got out of here, who would\npick up a binding.",
    "start": "2597480",
    "end": "2603250"
  },
  {
    "text": " AUDIENCE: On the unifying thing\nthere, I still am not",
    "start": "2603250",
    "end": "2611950"
  },
  {
    "start": "2605000",
    "end": "3178000"
  },
  {
    "text": "sure what happens\nwith who and z. If the unifying--",
    "start": "2611950",
    "end": "2617849"
  },
  {
    "text": "the rule here says--  OK, so you say that you can't\nmake question mark equal to",
    "start": "2617850",
    "end": "2624920"
  },
  {
    "text": "question mark who. PROFESSOR: Right. That's what the matcher\ncan't do. But what this will mean to a\nunifier is that there's an",
    "start": "2624920",
    "end": "2632550"
  },
  {
    "text": "environment with three\nvariables.  d here is computer.",
    "start": "2632550",
    "end": "2638520"
  },
  {
    "text": "z is whatever who is. So if later on in the matcher\nroutine it said, for example,",
    "start": "2638520",
    "end": "2649180"
  },
  {
    "text": "who has to be 3, then when I\nlooked up in the dictionary, it will say, oh, z is 3 because\nit's the same as who.",
    "start": "2649180",
    "end": "2658360"
  },
  {
    "text": "And that's in some sense the\nonly thing you need to do to extend the unifier\nto a matcher. AUDIENCE: OK, because it looked\nlike when you were",
    "start": "2658360",
    "end": "2663829"
  },
  {
    "text": "telling how to unify it, it\nlooked like you would put the things together in such a way\nthat you'd actually solve and have a value for both of them.",
    "start": "2663830",
    "end": "2669770"
  },
  {
    "text": "And what it looks like now is\nthat you're actually pass a dictionary with two variables\nand the variables are linked.",
    "start": "2669770",
    "end": "2674859"
  },
  {
    "text": "PROFESSOR: Right. It only looks like you're\nsolving for both of them because you're sort of looking\nat the whole solution at once.",
    "start": "2674860",
    "end": "2680540"
  },
  {
    "text": "If you sort of watch the thing\ngetting built up recursively, it's merely this. AUDIENCE: OK, so you\ndo pass off that",
    "start": "2680540",
    "end": "2686619"
  },
  {
    "text": "dictionary with two variables? PROFESSOR: That's right. AUDIENCE: And link? PROFESSOR: Right. It just looks like an\nordinary dictionary.",
    "start": "2686620",
    "end": "2694055"
  },
  {
    "text": "AUDIENCE: When you're talking\nabout the unifier, is it that there are some cases or some\npoints that you are not able",
    "start": "2694055",
    "end": "2702785"
  },
  {
    "text": "to use by them? PROFESSOR: Right. AUDIENCE: Can you just by\nbuilding the rules or writing",
    "start": "2702785",
    "end": "2710099"
  },
  {
    "text": "the forms know in advance if\nyou are going to be able to",
    "start": "2710100",
    "end": "2715582"
  },
  {
    "text": "solve to get the unification\nor not? Can you add some properties\neither to the rules itself or",
    "start": "2715582",
    "end": "2723560"
  },
  {
    "text": "to the formula that you're\nwriting so that you avoid the problem of not finding\nunification?",
    "start": "2723560",
    "end": "2730090"
  },
  {
    "text": "PROFESSOR: I mean, you can\nagree, I think, to write in a fairly restricted way where\nyou won't run into it.",
    "start": "2730090",
    "end": "2735390"
  },
  {
    "text": "See, because what\nyou're getting-- see, the place where you get\ninto problems is when you-- well, again, you're trying to\nmatch things like that against",
    "start": "2735390",
    "end": "2745020"
  },
  {
    "text": "things where these\nhave structure, where a, y, b, y something.",
    "start": "2745020",
    "end": "2755300"
  },
  {
    "text": " So this is the kind of\nplace where you're",
    "start": "2755300",
    "end": "2760570"
  },
  {
    "text": "going to get into trouble. AUDIENCE: So you can do\nthat syntactically?",
    "start": "2760570",
    "end": "2766370"
  },
  {
    "text": "PROFESSOR: So you can kind of\nwatch your rules in the kinds of things that your writing.",
    "start": "2766370",
    "end": "2771561"
  },
  {
    "text": "AUDIENCE: So that's the problem\nthat the builder of the database has to\nbe concerned? PROFESSOR: That's a problem.",
    "start": "2771561",
    "end": "2777560"
  },
  {
    "text": " It's a problem either-- not\nquite the builder of the database, the person who is\nexpressing the rules, or the",
    "start": "2777560",
    "end": "2784270"
  },
  {
    "text": "builder of the database. What the unifier actually does\nis you can check at the next level down when you actually get\nto the unifier and you'll",
    "start": "2784270",
    "end": "2792710"
  },
  {
    "text": "see in the code where it looks\nup in the dictionary. If it sort of says what\ndoes y have to be? Oh, does y have to be something\nthat contains a y as",
    "start": "2792710",
    "end": "2800690"
  },
  {
    "text": "its expression? At that point, the unifier and\nsay, oh my God, I'm trying to solve a fixed-point equation.",
    "start": "2800690",
    "end": "2806240"
  },
  {
    "text": "I'll give it up here. AUDIENCE: You make the\ndistinction between the rules in the database.",
    "start": "2806240",
    "end": "2811910"
  },
  {
    "text": "Are the rules added\nto the database?",
    "start": "2811910",
    "end": "2816950"
  },
  {
    "text": "PROFESSOR: Yes. Yes, I should have said that. One way to think about rules\nis that they're just other things in the database.",
    "start": "2816950",
    "end": "2823890"
  },
  {
    "text": "So if you want to check the\nthings that have to be checked in the database, they're kind\nof virtual facts that are in",
    "start": "2823890",
    "end": "2828935"
  },
  {
    "text": "the database. AUDIENCE: But in that\nexplanation, you made the differentiation between database\nand the rules itself.",
    "start": "2828935",
    "end": "2838230"
  },
  {
    "text": "PROFESSOR: Yeah, I probably\nshould not have done that. The only reason to do that\nis in terms of the implementation.",
    "start": "2838230",
    "end": "2843540"
  },
  {
    "text": "When you look at the\nimplementation, there's a part which says check either\nprimitive assertions in the database or check rules.",
    "start": "2843540",
    "end": "2850470"
  },
  {
    "text": "And then the real reason why\nyou can't tell what order things are going to come out\nin and is that the rules",
    "start": "2850470",
    "end": "2858010"
  },
  {
    "text": "database and the data database\nsort of get merged in a kind of delayed evaluation way.",
    "start": "2858010",
    "end": "2864600"
  },
  {
    "text": "And so that's what makes the\norder very complicated. ",
    "start": "2864600",
    "end": "2875440"
  },
  {
    "text": "OK, let's break. ",
    "start": "2875440",
    "end": "2913160"
  },
  {
    "text": "We've just seen how the\nlogic language works and how rules work. Now, let's turn to a more\nprofound question.",
    "start": "2913160",
    "end": "2920119"
  },
  {
    "text": "What do these things mean? That brings us to the subtlest,\nmost devious part of",
    "start": "2920120",
    "end": "2927240"
  },
  {
    "text": "this whole query language\nbusiness, and that is that it's not quite what\nit seems to be.",
    "start": "2927240",
    "end": "2933569"
  },
  {
    "text": "AND and OR and NOT and the\nlogical implication of rules",
    "start": "2933570",
    "end": "2939750"
  },
  {
    "text": "are not really the AND and\nOR and NOT and logical",
    "start": "2939750",
    "end": "2945400"
  },
  {
    "text": "implication of logic. Let me give you an\nexample of that. Certainly, if we have two things\nin logic, it ought to",
    "start": "2945400",
    "end": "2952960"
  },
  {
    "text": "be the case that AND of P and Q\nis the same as AND of Q and",
    "start": "2952960",
    "end": "2962224"
  },
  {
    "text": "P and that OR of P and Q is the\nsame as OR of Q and P. But",
    "start": "2962225",
    "end": "2968920"
  },
  {
    "text": "let's look here. Here's an example. Let's talk about somebody\noutranking somebody else in",
    "start": "2968920",
    "end": "2978200"
  },
  {
    "text": "our little database\norganization. We'll say s is outranked by b or\nif either the supervisor of",
    "start": "2978200",
    "end": "2987890"
  },
  {
    "text": "this is b or there's some middle\nmanager here, that supervisor of s is m, and\nm is outranked by b.",
    "start": "2987890",
    "end": "2995640"
  },
  {
    "text": " So there's one way to define\nrule outranked by.",
    "start": "2995640",
    "end": "3002310"
  },
  {
    "text": "Or we can write exactly the\nsame thing, except at the bottom here, we reversed the\norder of these two clauses.",
    "start": "3002310",
    "end": "3011630"
  },
  {
    "text": "And certainly if this were\nlogic, those ought to mean the same thing.",
    "start": "3011630",
    "end": "3016690"
  },
  {
    "text": "However, in our particular\nimplementation, if you say something like who's outranked\nby Ben Bitdiddle, what you'll",
    "start": "3016690",
    "end": "3023800"
  },
  {
    "text": "find is that this rule will\nwork perfectly well and generate answers, whereas\nthis rule will go",
    "start": "3023800",
    "end": "3031030"
  },
  {
    "text": "into an infinite loop. And the reason for that is that\nthis will come in and",
    "start": "3031030",
    "end": "3037230"
  },
  {
    "text": "say, oh, who's outranked\nby Ben Bitdiddle?  Find an s which is outranked\nby b, where b is Ben",
    "start": "3037230",
    "end": "3045790"
  },
  {
    "text": "Bitdiddle, which is going to\nhappen in it a subproblem. Oh gee, find an m such as m is\noutranked by Ben Bitdiddle",
    "start": "3045790",
    "end": "3055710"
  },
  {
    "text": "with no restrictions on m. So this will say in order to\nsolve this problem, I solve",
    "start": "3055710",
    "end": "3061910"
  },
  {
    "text": "exactly the same problem. And then after I've solved\nthat, I'll check for a supervisory relationship.",
    "start": "3061910",
    "end": "3068000"
  },
  {
    "text": "Whereas this one won't get into\nthat, because before it tries to find this outranked by,\nit'll already have had a",
    "start": "3068000",
    "end": "3074010"
  },
  {
    "text": "restriction on m here.  So these two things which ought\nto mean the same, in",
    "start": "3074010",
    "end": "3081190"
  },
  {
    "text": "fact, one goes into\nan infinite loop. One does not.",
    "start": "3081190",
    "end": "3086720"
  },
  {
    "text": "That's a very extreme case of\na general thing that you'll find in logic programming that\nif you start changing the",
    "start": "3086720",
    "end": "3095970"
  },
  {
    "text": "order of the things in the\nANDs or ORs, you'll find tremendous differences\nin efficiency.",
    "start": "3095970",
    "end": "3102240"
  },
  {
    "text": "And we just saw an infinitely\nbig difference in efficiency and an infinite loop. ",
    "start": "3102240",
    "end": "3109190"
  },
  {
    "text": "And there are similar things\nhaving to do with the order in which you enter rules. The order in which it happens\nto look at rules in the",
    "start": "3109190",
    "end": "3115980"
  },
  {
    "text": "database may vastly change the\nefficiency with which it gets out answers or, in fact, send\nit into an infinite loop for",
    "start": "3115980",
    "end": "3121859"
  },
  {
    "text": "some orderings. And this whole thing has to do\nwith the fact that you're",
    "start": "3121860",
    "end": "3128370"
  },
  {
    "text": "checking these rules\nin some order. And some rules may lead to\nreally long paths of",
    "start": "3128370",
    "end": "3133690"
  },
  {
    "text": "implication. Others might not. And you don't know a priori\nwhich ones are good and which ones are bad.",
    "start": "3133690",
    "end": "3139300"
  },
  {
    "text": "And there's a whole bunch of\nresearch having to do with that, mostly having to do with\nthinking about making parallel",
    "start": "3139300",
    "end": "3144840"
  },
  {
    "text": "implementations of logic\nprogramming languages. And in some sense, what you'd\nlike to do is check all rules in parallel and whichever\nones get answers,",
    "start": "3144840",
    "end": "3151870"
  },
  {
    "text": "you bubble them up. And if some go down\ninfinite deductive changed, well, you just-- you know, memory is cheap and\nprocessors are cheap, and you",
    "start": "3151870",
    "end": "3158440"
  },
  {
    "text": "just let them buzz for as\nfor as long as you want. ",
    "start": "3158440",
    "end": "3163510"
  },
  {
    "text": "There's a deeper problem,\nthough, in comparing this logic language to real logic.",
    "start": "3163510",
    "end": "3170869"
  },
  {
    "text": "The example I just showed you,\nit went into an infinite loop maybe, but at least it didn't\ngive the wrong answer.",
    "start": "3170870",
    "end": "3178370"
  },
  {
    "start": "3178000",
    "end": "3314000"
  },
  {
    "text": "There's an actual deeper\nproblem when we start comparing, seriously comparing\nthis logic language with real",
    "start": "3178370",
    "end": "3187460"
  },
  {
    "text": "classical logic. So let's sort of review\nreal classical logic.",
    "start": "3187460",
    "end": "3194030"
  },
  {
    "text": "All humans are mortal.",
    "start": "3194030",
    "end": "3202140"
  },
  {
    "text": "That's pretty classical logic. Then maybe we'll continue\nin the very best classical tradition.",
    "start": "3202140",
    "end": "3209119"
  },
  {
    "text": "We'll say all-- let's make it really\nclassical. All Greeks are human, which\nhas the syllogism that",
    "start": "3209120",
    "end": "3221690"
  },
  {
    "text": "Socrates is a Greek.",
    "start": "3221690",
    "end": "3228060"
  },
  {
    "text": "And then what do\nyou write here? I think three dots,\nclassical logic. Therefore, then the syllogism,\nSocrates is mortal.",
    "start": "3228060",
    "end": "3241359"
  },
  {
    "text": "So there's some real honest\nclassical logic. Let's compare that with our\nclassical logic database.",
    "start": "3241360",
    "end": "3252569"
  },
  {
    "text": "So here's a classical\nlogic database. Socrates is a Greek.",
    "start": "3252570",
    "end": "3258030"
  },
  {
    "text": "Plato is a Greek. Zeus is a Greek, and\nZeus is a god.",
    "start": "3258030",
    "end": "3264120"
  },
  {
    "text": "And all humans are mortal.",
    "start": "3264120",
    "end": "3270780"
  },
  {
    "text": "To show that something is\nmortal, it's enough to show that it's human. All humans are fallible.",
    "start": "3270780",
    "end": "3275900"
  },
  {
    "text": " And all Greeks are humans\nis not quite right.",
    "start": "3275900",
    "end": "3280980"
  },
  {
    "text": "This says that all Greeks who\nare not gods are human. So to show something's human,\nit's enough to show it's a",
    "start": "3280980",
    "end": "3287819"
  },
  {
    "text": "Greek and not a god. And the address of any Greek\ngod is Mount Olympus.",
    "start": "3287820",
    "end": "3294470"
  },
  {
    "text": "So there's a little classical\nlogic database. And indeed, that would\nwork fairly well.",
    "start": "3294470",
    "end": "3299490"
  },
  {
    "text": "If we type that in and say is\nSocrates mortal or Socrates",
    "start": "3299490",
    "end": "3305420"
  },
  {
    "text": "fallible or mortal? It'll say yes. Is Plato mortal and fallible. It'll say yes.",
    "start": "3305420",
    "end": "3310680"
  },
  {
    "text": "If we say is Zeus mortal? It won't find anything. And it'll work perfectly well.",
    "start": "3310680",
    "end": "3316640"
  },
  {
    "start": "3314000",
    "end": "3599000"
  },
  {
    "text": "However, suppose we want\nto extend this. Let's define what it means for\nsomeone to be a perfect being.",
    "start": "3316640",
    "end": "3325070"
  },
  {
    "text": "Let's say rule: a\nperfect being. ",
    "start": "3325070",
    "end": "3334050"
  },
  {
    "text": "And I think this is right. If you're up on your medieval\nscholastic philosophy, I believe that perfect beings\nare ones who were neither",
    "start": "3334050",
    "end": "3341350"
  },
  {
    "text": "mortal nor fallible. AND NOT mortal x,\nNOT fallible x.",
    "start": "3341350",
    "end": "3359300"
  },
  {
    "text": "So we'll define this system\nto teach it what a perfect being is.",
    "start": "3359300",
    "end": "3365790"
  },
  {
    "text": "And now what we're going to do\nis he ask for the address of all the perfect beings.",
    "start": "3365790",
    "end": "3371750"
  },
  {
    "text": "AND the address of x is\ny and x is perfect.",
    "start": "3371750",
    "end": "3383680"
  },
  {
    "text": "And so what we're generating\nhere is the world's most exclusive mailing list. For the\naddress of all the perfect",
    "start": "3383680",
    "end": "3392050"
  },
  {
    "text": "things, we might have\ntyped this in. Or we might type in this. We'll say AND perfect of x and\nthe address of x is y.",
    "start": "3392050",
    "end": "3412140"
  },
  {
    "text": "Well, suppose we type all that\nin and we try this query. This query is going to\ngive us an answer.",
    "start": "3412140",
    "end": "3417650"
  },
  {
    "text": "This query will say, yeah,\nMount Olympus. ",
    "start": "3417650",
    "end": "3424230"
  },
  {
    "text": "This query, in fact, is going\nto give us nothing. It will say no addresses\nof perfect beings.",
    "start": "3424230",
    "end": "3431640"
  },
  {
    "text": "Now, why is that? Why is there a difference? This is not an infinite\nloop question. This is a different\nanswer question.",
    "start": "3431640",
    "end": "3439145"
  },
  {
    "text": "The reason is that if you\nremember the implementation of NOT, NOT acted as a filter.",
    "start": "3439145",
    "end": "3445880"
  },
  {
    "text": "NOT said I'm going to take some\npossible dictionaries, some possible frames, some\npossible answers, and filter",
    "start": "3445880",
    "end": "3452480"
  },
  {
    "text": "out the ones that happened to\nsatisfy some condition, and that's how I implement NOT. If you think about what's going\non here, I'll build this",
    "start": "3452480",
    "end": "3460730"
  },
  {
    "text": "query box where the output of an\naddress piece gets fed into",
    "start": "3460730",
    "end": "3466470"
  },
  {
    "text": "a perfect piece.  What will happen is the address\npiece will set up some",
    "start": "3466470",
    "end": "3472880"
  },
  {
    "text": "things of everyone whose\naddress I know. Those will get filtered by the\nNOTs inside perfect here.",
    "start": "3472880",
    "end": "3479880"
  },
  {
    "text": "So it will throw out the ones\nwhich happened to be either mortal or fallible.",
    "start": "3479880",
    "end": "3484910"
  },
  {
    "text": "In the other order what happens\nis I set this up, started up with an\nempty frame. The perfect in here doesn't find\nanything for the NOTs to",
    "start": "3484910",
    "end": "3492000"
  },
  {
    "text": "filter, so nothing comes\nout here at all. ",
    "start": "3492000",
    "end": "3498829"
  },
  {
    "text": "And there's sort of nothing\nthere that gets fed into the address thing. So here, I don't\nget an answer.",
    "start": "3498830",
    "end": "3504260"
  },
  {
    "text": "And again, the reason\nfor that is NOT isn't generating anything. NOT's only throwing\nout things. And if I never started up with\nanything, there's nothing for",
    "start": "3504260",
    "end": "3511160"
  },
  {
    "text": "it to throw out. So out of this thing, I\nget the wrong answer. ",
    "start": "3511160",
    "end": "3517200"
  },
  {
    "text": "How can you fix that? Well, there are ways\nto fix that. So you might say, well,\nthat's sort of stupid. Why are you just doing\nall your NOT",
    "start": "3517200",
    "end": "3523700"
  },
  {
    "text": "stuff at the beginning? The right way to implement NOT\nis to realize that when you have conditions like NOT, you\nshould generate all your",
    "start": "3523700",
    "end": "3531359"
  },
  {
    "text": "answers first, and then with\neach of these dictionaries pass along until at the very\nend I'll do filtering.",
    "start": "3531360",
    "end": "3538559"
  },
  {
    "text": "And there are implementations\nof logic languages that work like that that solve this\nparticular problem.",
    "start": "3538560",
    "end": "3544050"
  },
  {
    "text": " However, there's a more profound\nproblem, which is",
    "start": "3544050",
    "end": "3550030"
  },
  {
    "text": "which one of these is\nthe right answer? Is it Mount Olympus\nor is it nothing?",
    "start": "3550030",
    "end": "3555320"
  },
  {
    "text": "So you might say it's Mount\nOlympus, because after all, Zeus is in that database,\nand Zeus was",
    "start": "3555320",
    "end": "3563220"
  },
  {
    "text": "neither mortal nor fallible. ",
    "start": "3563220",
    "end": "3569550"
  },
  {
    "text": "So you might say Zeus wants to\nsatisfy NOT mortal Zeus or NOT",
    "start": "3569550",
    "end": "3583310"
  },
  {
    "text": "fallible Zeus. But let's actually look\nat that database. Let's look at it.",
    "start": "3583310",
    "end": "3589319"
  },
  {
    "text": "There's no way-- how does it know that Zeus\nis not fallible?",
    "start": "3589320",
    "end": "3594809"
  },
  {
    "text": "There's nothing in\nthere about that. What's in there is that\nhumans are fallible. ",
    "start": "3594810",
    "end": "3602390"
  },
  {
    "text": "How does it know that\nZeus is not mortal? There's nothing in\nthere about that.",
    "start": "3602390",
    "end": "3607980"
  },
  {
    "text": "It just said I don't have\nany rule, which-- the only way I can deduce\nsomething's mortal is if it's",
    "start": "3607980",
    "end": "3613820"
  },
  {
    "text": "human, and that's all it really\nknows about mortal. And in fact, if you remember\nyour classical mythology, you",
    "start": "3613820",
    "end": "3620060"
  },
  {
    "text": "know that the Greek gods were\nnot mortal but fallible.",
    "start": "3620060",
    "end": "3625300"
  },
  {
    "text": "So the answer is not\nin the rules there.",
    "start": "3625300",
    "end": "3630850"
  },
  {
    "text": "See, why does it deduce that?  See, Socrates would certainly\nnot have made",
    "start": "3630850",
    "end": "3637330"
  },
  {
    "text": "this error of logic. What NOT needs in this\nlanguage is not NOT.",
    "start": "3637330",
    "end": "3643370"
  },
  {
    "text": "It's not the NOT of logic. What NOT needs in this language\nis not deducible from",
    "start": "3643370",
    "end": "3648950"
  },
  {
    "text": "things in the database as\nopposed to not true.",
    "start": "3648950",
    "end": "3655140"
  },
  {
    "text": "That's a very big difference. Subtle, but big. So, in fact, this is perfectly\nhappy to say not anything that",
    "start": "3655140",
    "end": "3663080"
  },
  {
    "text": "it doesn't know about. So if you ask it is it not\ntrue that Zeus likes chocolate ice cream? It will say sure,\nit's not true.",
    "start": "3663080",
    "end": "3670251"
  },
  {
    "text": "Or anything else or anything\nit doesn't know about. NOT means not deducible from\nthe things you've told me.",
    "start": "3670251",
    "end": "3678280"
  },
  {
    "text": "In a world where you're\nidentifying not deducible with, in fact, not true, this\nis called the closed world",
    "start": "3678280",
    "end": "3685800"
  },
  {
    "text": "assumption. ",
    "start": "3685800",
    "end": "3696870"
  },
  {
    "text": "The closed world assumption. Anything that I cannot deduce\nfrom what I know",
    "start": "3696870",
    "end": "3703550"
  },
  {
    "text": "is not true, right? If I don't know anything about\nx, the x isn't true.",
    "start": "3703550",
    "end": "3709290"
  },
  {
    "text": "That's very dangerous. From a logical point of view,\nfirst of all, it doesn't really makes sense.",
    "start": "3709290",
    "end": "3714480"
  },
  {
    "text": "Because if I don't know anything\nabout x, I'm willing to say not x.",
    "start": "3714480",
    "end": "3720240"
  },
  {
    "text": "But am I willing to\nsay not not x? Well, sure, I don't\nknow anything about that either maybe.",
    "start": "3720240",
    "end": "3726470"
  },
  {
    "text": "So not not x is not necessarily\nthe same as x and so on and so on and so on, so\nthere's some sort of funny",
    "start": "3726470",
    "end": "3733119"
  },
  {
    "text": "bias in there. So that's sort of funny. The second thing, if you start\nbuilding up real reasoning",
    "start": "3733120",
    "end": "3742840"
  },
  {
    "text": "programs based on this, think\nhow dangerous that is. You're saying I know I'm in a\nposition to deduce everything",
    "start": "3742840",
    "end": "3753420"
  },
  {
    "text": "true that's relevant\nto this problem. I'm reasoning, and built into my\nreasoning mechanism is the",
    "start": "3753420",
    "end": "3761590"
  },
  {
    "text": "assumption that anything that I\ndon't know can't possibly be relevant to this\nproblem, right?",
    "start": "3761590",
    "end": "3768859"
  },
  {
    "text": "There are a lot of big\norganizations that work like that, right?",
    "start": "3768860",
    "end": "3774720"
  },
  {
    "text": "Most corporate marketing\ndivisions work like that. You know the consequences\nto that.",
    "start": "3774720",
    "end": "3780560"
  },
  {
    "text": "So it's very dangerous to start\nreally typing in these big logical implication systems\nand going on what they",
    "start": "3780560",
    "end": "3788750"
  },
  {
    "text": "say, because they have\nthis really limiting assumption built in. So you have to be very, very\ncareful about that.",
    "start": "3788750",
    "end": "3794905"
  },
  {
    "text": "And that's a deep problem. That's not a problem about we\ncan make a little bit cleverer implementation and do the\nfilters and organize the",
    "start": "3794905",
    "end": "3802360"
  },
  {
    "text": "infinite loops to make\nthem go away. It's a different kind\nof problem. It's a different semantics. So I think to wrap this up, it's\nfair to say that logic",
    "start": "3802360",
    "end": "3811910"
  },
  {
    "text": "programming I think is a\nterrifically exciting idea, the idea that you can bridge\nthis gap from the imperative",
    "start": "3811910",
    "end": "3818010"
  },
  {
    "text": "to the declarative, that you\ncan start talking about relations and really get\ntremendous power by going",
    "start": "3818010",
    "end": "3826900"
  },
  {
    "text": "above the abstraction\nof what's my input and what's my output. And linked to logic, the problem\nis it's a goal that I",
    "start": "3826900",
    "end": "3835160"
  },
  {
    "text": "think has yet to be realized. And probably one of the very\nmost interesting research",
    "start": "3835160",
    "end": "3842740"
  },
  {
    "text": "questions going on now in\nlanguages is how do you somehow make a real\nlogic language?",
    "start": "3842740",
    "end": "3849460"
  },
  {
    "text": "And secondly, how do you bridge\nthe gap from this world of logic and relations to the\nworlds of more traditional",
    "start": "3849460",
    "end": "3856020"
  },
  {
    "text": "languages and somehow combine\nthe power of both. OK, let's break. ",
    "start": "3856020",
    "end": "3863750"
  },
  {
    "text": "AUDIENCE: Couldn't you solve\nthat last problem by having the extra rules that imply it? The problem here is you have the\ndefinition of something,",
    "start": "3863750",
    "end": "3870059"
  },
  {
    "text": "but you don't have the\ndefinition of its opposite. If you include in the database\nsomething that says something",
    "start": "3870060",
    "end": "3875890"
  },
  {
    "text": "implies mortal x, something\nelse implies not mortal x, haven't you basically\nsolved the problem? ",
    "start": "3875890",
    "end": "3883370"
  },
  {
    "text": "PROFESSOR: But the issue\nis do you put a finite number of those in? ",
    "start": "3883370",
    "end": "3890740"
  },
  {
    "text": "AUDIENCE: If things are\nspecified always in pairs-- PROFESSOR: But the impression\nis then what do",
    "start": "3890740",
    "end": "3895970"
  },
  {
    "text": "you do about deduction?  You can't specify NOTs.",
    "start": "3895970",
    "end": "3903400"
  },
  {
    "text": "But the problem is, in a big\nsystem, it turns out that might not be a finite\nnumber of things. ",
    "start": "3903400",
    "end": "3912820"
  },
  {
    "text": "There are also sort\nof two issues. Partly it might not be finite. Partly it might be that's\nnot what you want.",
    "start": "3912820",
    "end": "3921510"
  },
  {
    "text": "So a good example would be\nsuppose I want to do connectivity. I want a reason about\nconnectivity.",
    "start": "3921510",
    "end": "3928050"
  },
  {
    "text": "And I'm going to tell you\nthere's four things: a and b and c and d.",
    "start": "3928050",
    "end": "3935480"
  },
  {
    "text": "And I'll tell you a is connected\nto b and c's connected to d.",
    "start": "3935480",
    "end": "3943200"
  },
  {
    "text": "And now I'll tell you\nis a connected to d? That's the question. There's an example where I would\nlike something like the",
    "start": "3943200",
    "end": "3949360"
  },
  {
    "text": "closed world assumption.  That's a tiny toy, but a lot of\ntimes, I want to be able to",
    "start": "3949360",
    "end": "3957630"
  },
  {
    "text": "say something like anything\nthat I haven't told you, assume is not true. ",
    "start": "3957630",
    "end": "3964260"
  },
  {
    "text": "So it's not as simple as you\nonly want to put in explicit NOTs all over the place.",
    "start": "3964260",
    "end": "3969470"
  },
  {
    "text": "It's that sometimes it\nreally isn't clear what you even want. That having to specify both\neverything and not everything",
    "start": "3969470",
    "end": "3977160"
  },
  {
    "text": "is too precise, and then you get\ndown into problems there. But there are a lot of\napproaches that explicitly put",
    "start": "3977160",
    "end": "3984420"
  },
  {
    "text": "in NOTs and reason\nbased on that. So it's a very good idea. It's just that then it starts\nbecoming a little cumbersome",
    "start": "3984420",
    "end": "3991620"
  },
  {
    "text": "in the very large problems\nyou'd like to use. ",
    "start": "3991620",
    "end": "4003460"
  },
  {
    "text": "AUDIENCE: I'm not sure how\ndirectly related to the argument this is, but one of\nyour points was that one of",
    "start": "4003460",
    "end": "4008839"
  },
  {
    "text": "the dangers of the closed rule\nis you never really know all the things that are there. You never really know\nall the parts to it.",
    "start": "4008840",
    "end": "4015930"
  },
  {
    "text": "Isn't that a major problem\nwith any programming? I always write programs where I\nassume that I've got all the",
    "start": "4015930",
    "end": "4021109"
  },
  {
    "text": "cases, and so I check for them\nall or whatever, and somewhere down the road, I find\nout that I didn't check for one of them.",
    "start": "4021110",
    "end": "4027390"
  },
  {
    "text": "PROFESSOR: Well, sure,\nit's true. But the problem here is it's\nthat assumption which is the",
    "start": "4027390",
    "end": "4034630"
  },
  {
    "text": "thing that you're making if you\nbelieve you're identifying this with logic. So you're quite right.",
    "start": "4034630",
    "end": "4040510"
  },
  {
    "text": "It's a situation you're\nnever in. The problem is if you're\nstarting to believe that what this is doing is logic and you\nlook at the rules you write",
    "start": "4040510",
    "end": "4047305"
  },
  {
    "text": "down and say what can I deduce\nfrom them, you have to be very careful to remember that NOT\nmeans something else.",
    "start": "4047305",
    "end": "4053470"
  },
  {
    "text": "And it means something else\nbased on an assumption which is probably not true.",
    "start": "4053470",
    "end": "4059030"
  },
  {
    "text": "AUDIENCE: Do I understand you\ncorrectly that you cannot fix this problem without killing\noff all possibilities of",
    "start": "4059030",
    "end": "4064510"
  },
  {
    "text": "inference through\naltering NOT? PROFESSOR: No, that's\nnot quite right. There are other--",
    "start": "4064510",
    "end": "4070620"
  },
  {
    "text": " there are ways to do logic\nwith real NOTs.",
    "start": "4070620",
    "end": "4076339"
  },
  {
    "text": "There are actually\nways to do that. But they're very inefficient\nas far as anybody knows.",
    "start": "4076340",
    "end": "4081610"
  },
  {
    "text": "And they're much more--  the, quote, inference in here is\nbuilt into this unifier and",
    "start": "4081610",
    "end": "4089240"
  },
  {
    "text": "this pattern matching\nunification algorithm. There are ways to automate\nreal logical reasoning.",
    "start": "4089240",
    "end": "4096589"
  },
  {
    "text": "But it's not based on that,\nand logic programming languages don't tend to do\nthat because it's very inefficient as far\nas anybody knows.",
    "start": "4096590",
    "end": "4103850"
  },
  {
    "start": "4103850",
    "end": "4109390"
  },
  {
    "text": "All right, thank you. ",
    "start": "4109390",
    "end": "4123903"
  }
]