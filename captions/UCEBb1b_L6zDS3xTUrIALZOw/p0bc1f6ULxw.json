[
  {
    "start": "0",
    "end": "174000"
  },
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help MIT\nOpenCourseWare continue to",
    "start": "0",
    "end": "6950"
  },
  {
    "text": "offer high-quality educational\nresources for free. To make a donation or view\nadditional materials from",
    "start": "6950",
    "end": "13500"
  },
  {
    "text": "hundreds of MIT courses, visit\nMIT OpenCourseWare at ocw.mit.edu.",
    "start": "13500",
    "end": "18680"
  },
  {
    "start": "18680",
    "end": "23960"
  },
  {
    "text": "CHARLES LEISERSON: Today we're\ngoing to talk about dynamic storage allocation, which is a\nhugely rich and interesting",
    "start": "23960",
    "end": "31070"
  },
  {
    "text": "topic, and hopefully cover some\nof the basics of dynamic",
    "start": "31070",
    "end": "36110"
  },
  {
    "text": "storage allocation today. I want to start out with perhaps\nthe simplest storage",
    "start": "36110",
    "end": "41150"
  },
  {
    "text": "allocation scheme, and that's\nstack allocation, which I think you're probably fairly\nfamiliar with.",
    "start": "41150",
    "end": "47890"
  },
  {
    "text": "So stack allocation is just an\narray and a pointer into the array, an index or a pointer\ninto the array.",
    "start": "47890",
    "end": "56379"
  },
  {
    "text": "And when you have a stack in\na computer memory, you're talking about the array of all\nmemory, and the stack pointer",
    "start": "56380",
    "end": "62899"
  },
  {
    "text": "pointing that's used, for\nexample, for calls. The reason stack allocation\nis neat is",
    "start": "62900",
    "end": "70170"
  },
  {
    "text": "because it's so simple. If I want to allocate x bytes,\nthen what I do, is I just",
    "start": "70170",
    "end": "76130"
  },
  {
    "text": "simply increment my stack\npointer by x bytes, and then I",
    "start": "76130",
    "end": "84030"
  },
  {
    "text": "return the original position of\nthe stack pointer as being the location of the storage\nthat's just been allocated.",
    "start": "84030",
    "end": "90705"
  },
  {
    "text": " So pretty simple.",
    "start": "90705",
    "end": "97320"
  },
  {
    "text": "Typically if you write a stack\nallocator, the routines are so simple they get inlined,\nalthough it's of course",
    "start": "97320",
    "end": "104500"
  },
  {
    "text": "advantageous to say that things\nare inlined, but most compilers these days\nwill inline.",
    "start": "104500",
    "end": "110460"
  },
  {
    "text": "And as you can see, it's just a\ncouple of operations here to perform this calculation.",
    "start": "110460",
    "end": "115934"
  },
  {
    "text": "To deallocate the bytes,\nwe basically-- oh, yeah, I should mention,\nthis isn't",
    "start": "115934",
    "end": "121430"
  },
  {
    "text": "checking for overflow. So technically, one should\ncheck for overflow. ",
    "start": "121430",
    "end": "130020"
  },
  {
    "text": "One way to do that is for the\nassert package, and that way, at run time, you don't\nhave to pay the",
    "start": "130020",
    "end": "136750"
  },
  {
    "text": "extra overhead of checking. And see, these operations are\nso cheap that actually checking for overflow is perhaps\nas expensive as doing",
    "start": "136750",
    "end": "146420"
  },
  {
    "text": "the rest of the operations\nthemselves. Checking to see whether you went\nover the right end of the",
    "start": "146420",
    "end": "151740"
  },
  {
    "text": "array here. So to free x bytes, you\nbasically just simply",
    "start": "151740",
    "end": "158819"
  },
  {
    "text": "decrement the stack pointer. And of course, technically,\nyou should also check for",
    "start": "158820",
    "end": "163900"
  },
  {
    "text": "underflow, make sure somebody\ndidn't say to deallocate more",
    "start": "163900",
    "end": "169120"
  },
  {
    "text": "bytes than were actually\nalready allocated on the stack. ",
    "start": "169120",
    "end": "175030"
  },
  {
    "start": "174000",
    "end": "271000"
  },
  {
    "text": "And so course, check for\nstack underflow. So this is pretty good, because\nallocating and freeing",
    "start": "175030",
    "end": "181790"
  },
  {
    "text": "take just constant time. Very quick. But you're required to free\nmemory consistent with the",
    "start": "181790",
    "end": "190989"
  },
  {
    "text": "stack discipline, which is the\nlast in, first out discipline.",
    "start": "190990",
    "end": "197110"
  },
  {
    "text": "So you don't get to free\nsomething that you allocated long ago until you've freed\neverything else that's been",
    "start": "197110",
    "end": "205459"
  },
  {
    "text": "allocated since. So therefore, it has limited\napplicability, but it's great",
    "start": "205460",
    "end": "211520"
  },
  {
    "text": "when it works. Now it turns out, sometimes you\ncan actually use the call",
    "start": "211520",
    "end": "218010"
  },
  {
    "text": "stack yourself to store stack\nvalues, using a function",
    "start": "218010",
    "end": "226069"
  },
  {
    "text": "called alloca. But this function is now\ndeprecated, meaning that people advise you not to use it\nin any modern programming.",
    "start": "226070",
    "end": "234520"
  },
  {
    "text": "And part of the reason is that\nthe compiler is more efficient with fixed size stack frames.",
    "start": "234520",
    "end": "240330"
  },
  {
    "text": "You remember when we went\nthrough how the compiler actually lays out memory and\ndoes the calling convention?",
    "start": "240330",
    "end": "248659"
  },
  {
    "text": "If you have a fixed size stack\nframe, then the frame pointer and the stack pointer are\nredundant, and so you can",
    "start": "248660",
    "end": "254879"
  },
  {
    "text": "reclaim a register, namely, the\nframe pointer register, and do everything off\nthe stack pointer.",
    "start": "254880",
    "end": "260768"
  },
  {
    "text": "But if you use things like\nalloca, which are pushing the sides of the stack frame, then\nyou actually have to keep both",
    "start": "260769",
    "end": "266669"
  },
  {
    "text": "pointers there, and that's a\nlittle bit less efficient in terms of the register usage. OK?",
    "start": "266670",
    "end": "271740"
  },
  {
    "text": "So that's pretty much\nstack storage. Any questions about stacks? Yeah?",
    "start": "271740",
    "end": "277210"
  },
  {
    "text": "AUDIENCE: Is there anything\nthat detects overflow or underflow without\nusing inserts? Like, if you wanted to check-- CHARLES LEISERSON: Yeah, you\ncouldn't check explicitly.",
    "start": "277210",
    "end": "283384"
  },
  {
    "text": "Just say, you know, for this, is\nbefore you check that, make sure that SP plus x, is it\nbigger than the right end?",
    "start": "283385",
    "end": "291451"
  },
  {
    "text": "AUDIENCE: But how do you know\nwhere the right end is? CHARLES LEISERSON: Well, because\nI'm assuming here that in this case, you are\nallocating it.",
    "start": "291451",
    "end": "297920"
  },
  {
    "text": "Now, if you're talking\nabout using the call stack, you mean? You'll never run out. We'll do that analysis\nin a little bit.",
    "start": "297920",
    "end": "304620"
  },
  {
    "text": "But you'll never run\nout of stack space. Although as a practical matter,\nmost compilers assume",
    "start": "304620",
    "end": "312670"
  },
  {
    "text": "a stack of a megabyte, and so\nif you overflow that, your",
    "start": "312670",
    "end": "321420"
  },
  {
    "text": "program will fail in any\nof a variety of ways. AUDIENCE: You can\ndo guard pages. CHARLES LEISERSON: You can do\nguard pages, which don't",
    "start": "321420",
    "end": "327460"
  },
  {
    "start": "324000",
    "end": "426000"
  },
  {
    "text": "always work. But let me explain\nguard pages, OK? So what's sometimes done is,\nif I have my stack growing",
    "start": "327460",
    "end": "339789"
  },
  {
    "text": "down in memory-- OK, so here's my stack, and\nit's growing this way--",
    "start": "339790",
    "end": "345720"
  },
  {
    "text": "and I want to make sure, for\nexample, the thing that's typically growing up this way\nis heat, and I want to make",
    "start": "345720",
    "end": "351200"
  },
  {
    "text": "sure that they don't collide\nsomewhere in here. So one thing I can do\nis put some pages in",
    "start": "351200",
    "end": "357000"
  },
  {
    "text": "here that are protected. These are read-only pages.",
    "start": "357000",
    "end": "363430"
  },
  {
    "text": "Or actually even better\nis no permissions. ",
    "start": "363430",
    "end": "369449"
  },
  {
    "text": "So I can put no permissions so\nthat if you ever try to read or write that page, it automatically generates a fault.",
    "start": "369450",
    "end": "377600"
  },
  {
    "text": "And so the runtime will\nsometimes do that. The difficulty is, what happens\nif you increased your stack so much that you went\nbeyond your guard pages?",
    "start": "377600",
    "end": "385590"
  },
  {
    "text": "But as a practical matter most\nof the times that people exceed the guard pages is\nonly by small amount.",
    "start": "385590",
    "end": "394919"
  },
  {
    "text": "And so just putting a few guard\npages in there will make sure that you can use the memory\nmanagement hardware,",
    "start": "394920",
    "end": "403870"
  },
  {
    "text": "which basically ends up being\nfree from your point of view as a programmer, in\norder to catch a",
    "start": "403870",
    "end": "410180"
  },
  {
    "text": "stack overflow problem. And you can do that yourself. You can use the call mmap, which\nwe haven't talked about,",
    "start": "410180",
    "end": "421919"
  },
  {
    "text": "to set permissions on\npages at user level.",
    "start": "421920",
    "end": "427860"
  },
  {
    "start": "426000",
    "end": "481000"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] CHARLES LEISERSON: No. You can actually handle the\nerror however you want.",
    "start": "427860",
    "end": "435090"
  },
  {
    "text": "You can vector into a user\nto find routine. Now, what are you going to do,\nI don't know, but you can",
    "start": "435090",
    "end": "441780"
  },
  {
    "text": "indeed catch the error yourself\nand decide that",
    "start": "441780",
    "end": "448480"
  },
  {
    "text": "there's some way of recovering,\nas opposed to crashing and burning.",
    "start": "448480",
    "end": "453540"
  },
  {
    "text": "So generally, it's considered\npoor form for your software to fail, other than in\na controlled way.",
    "start": "453540",
    "end": "462130"
  },
  {
    "text": "So you should always have your\nsoftware exiting or calling error, and it should never\nsegment fault.",
    "start": "462130",
    "end": "470310"
  },
  {
    "text": "Most people consider any program\nthat segfaults to be poorly engineered.",
    "start": "470310",
    "end": "477420"
  },
  {
    "text": "Is there any case where there's\na segfaulting program that is not poorly engineered?",
    "start": "477420",
    "end": "482699"
  },
  {
    "start": "481000",
    "end": "682000"
  },
  {
    "text": "I don't know. I think most people, it's\nprobably an understatement.",
    "start": "482700",
    "end": "488449"
  },
  {
    "text": "OK?  So this is stack memory. You can build it yourself out of\nan array and a pointer, or",
    "start": "488450",
    "end": "498150"
  },
  {
    "text": "you can I use this\nthe call stack. And when you have something\nthat's using that kind of",
    "start": "498150",
    "end": "505920"
  },
  {
    "text": "discipline, it's great, because\nit's really cheap. ",
    "start": "505920",
    "end": "511039"
  },
  {
    "text": "Now in C and C++, and we're\ngoing to start moving and",
    "start": "511040",
    "end": "516200"
  },
  {
    "text": "talking more about things like\nC++, we have what's called heap allocation.",
    "start": "516200",
    "end": "522969"
  },
  {
    "text": "And in C, the routines are\ncalled malloc and free, and C++ provides a new directive\nand delete.",
    "start": "522970",
    "end": "532750"
  },
  {
    "text": "So unlike Java and\nPython, C and C++ provide no garbage collector.",
    "start": "532750",
    "end": "541050"
  },
  {
    "text": "So in other words, you're\nresponsible as a programmer for freeing allocated\nstorage yourself.",
    "start": "541050",
    "end": "548490"
  },
  {
    "text": "If you fail to do so, you\ncreate a memory leak. So a memory leak means I\nallocated something, I no",
    "start": "548490",
    "end": "556130"
  },
  {
    "text": "longer am in a position to use\nit, but I failed to free it, so it can't be reused.",
    "start": "556130",
    "end": "562530"
  },
  {
    "text": "And if you keep doing that,\nespecially if you're in a loop, then you have\na memory leak. Where if you look at a program\nwith a memory leak, and you",
    "start": "562530",
    "end": "570120"
  },
  {
    "text": "look using [? Top ?] or\nwhatever, how big is my program, you watch as it goes\nand computes and computes, and",
    "start": "570120",
    "end": "576600"
  },
  {
    "text": "it keeps getting bigger and\nbigger and bigger and bigger as it's running, and it just\nruns away, getting more and",
    "start": "576600",
    "end": "581700"
  },
  {
    "text": "more storage. Also you have to watch out for\nthings like dangling pointers.",
    "start": "581700",
    "end": "588590"
  },
  {
    "text": "That is, you deallocated\nsomething, but somebody still wanted to use it.",
    "start": "588590",
    "end": "594589"
  },
  {
    "text": "Or double-freeing. You have two places in\nthe code where you free the same storage.",
    "start": "594590",
    "end": "602720"
  },
  {
    "text": "Very bad to try to free\nthe same storage. Yeah?",
    "start": "602720",
    "end": "608826"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]  CHARLES LEISERSON: It's\nbasically going to be sitting",
    "start": "608826",
    "end": "614860"
  },
  {
    "text": "in the storage structure, which\nwe'll talk about how those are organized\nin a few minutes--",
    "start": "614860",
    "end": "620515"
  },
  {
    "text": "going to be sitting in the\nstorage structure, but the program that is going to look at\nthat and not recognize that",
    "start": "620515",
    "end": "626569"
  },
  {
    "text": "it's in the storage structure,\nand think that it's something that now all its pointers\ncan be reset. And so you basically clobber\nall the invariants of the",
    "start": "626570",
    "end": "633950"
  },
  {
    "text": "storage structure, and somewhere\ndown the road, you get a segment fault\nor something. OK?",
    "start": "633950",
    "end": "639720"
  },
  {
    "text": "Yeah, John? AUDIENCE: [UNINTELLIGIBLE] that comes out of that is-- CHARLES LEISERSON:\nJust a second. Why don't you take this?",
    "start": "639720",
    "end": "645456"
  },
  {
    "text": " AUDIENCE: [INAUDIBLE] ",
    "start": "645456",
    "end": "657500"
  },
  {
    "text": "One thing that often happens in\nthe real world is when you free something, it adds it to\na free, list and if you free",
    "start": "657500",
    "end": "664800"
  },
  {
    "text": "something twice, it will add two\ncopies of that pointer to the free list. So later on, when you malloc,\nmalloc might return the same",
    "start": "664800",
    "end": "670970"
  },
  {
    "text": "pointer to you twice. So the same memory block might\nbe allocated for two",
    "start": "670970",
    "end": "675990"
  },
  {
    "text": "completely different\nfunctionalities, and attackers use that to do all sorts\nof interesting",
    "start": "675990",
    "end": "681890"
  },
  {
    "text": "things to your program. CHARLES LEISERSON: Yeah. OK? So fortunately, there are some\nreally good-- why don't you",
    "start": "681890",
    "end": "689930"
  },
  {
    "start": "682000",
    "end": "774000"
  },
  {
    "text": "keep that down there, and then\nif you guys want to chime in, you'll have some\npower to do so.",
    "start": "689930",
    "end": "699660"
  },
  {
    "text": "So fortunately, there are now\nsome tools to make that easier",
    "start": "699660",
    "end": "704720"
  },
  {
    "text": "to debug these kinds of\nreally nasty bugs. The one we'll be using is\nValgrind, and what you do is",
    "start": "704720",
    "end": "712080"
  },
  {
    "text": "you just say, Valgrind minus\nminus leak check equals yes, and then run your program the\nway you would normally run it.",
    "start": "712080",
    "end": "718950"
  },
  {
    "text": "And what it will do is, it will\nmonitor the way that the program is doing allocations\nand frees, and give you a",
    "start": "718950",
    "end": "729850"
  },
  {
    "text": "report as to whether everything\nthat was allocated was free, and whether you tried\nto free something twice,",
    "start": "729850",
    "end": "736029"
  },
  {
    "text": "and so forth. Now, this works with the\nexisting allocators.",
    "start": "736030",
    "end": "741830"
  },
  {
    "text": "If you have your own allocator\nthat you decide you're going to write for a little piece of\nyour code, you say, gee, I'm",
    "start": "741830",
    "end": "747399"
  },
  {
    "text": "going to do my own little\nallocation here, you can actually communicate to Valgrind\nwhat that allocator",
    "start": "747400",
    "end": "754280"
  },
  {
    "text": "is, and it can check for\nproper use of that structure as well. So you can see valgrind.org\nfor details.",
    "start": "754280",
    "end": "761970"
  },
  {
    "text": "And are a lot of other programs\non the market, and",
    "start": "761970",
    "end": "767360"
  },
  {
    "text": "out there as open software,\nsuch as purify and a variety of others.",
    "start": "767360",
    "end": "772700"
  },
  {
    "text": " So let's talk about\nheap allocation.",
    "start": "772700",
    "end": "779100"
  },
  {
    "start": "774000",
    "end": "919000"
  },
  {
    "text": "I want to start by talking about\nfixed size allocation. So suppose the world has only\none size of objects that you",
    "start": "779100",
    "end": "785400"
  },
  {
    "text": "care about. Then it turns out that doing an\nallocator is really simple,",
    "start": "785400",
    "end": "792710"
  },
  {
    "text": "and you could program\none yourself. So here's basically\nhow it works. It's called using a free list.",
    "start": "792710",
    "end": "799275"
  },
  {
    "text": "And what you have is, in your\narray, say, that you're using",
    "start": "799275",
    "end": "805830"
  },
  {
    "text": "for storing all of your values,\nand here they're",
    "start": "805830",
    "end": "811500"
  },
  {
    "text": "basically this size, what you\ndo is you have a certain number that are used. That means that the program\nis using them,",
    "start": "811500",
    "end": "819560"
  },
  {
    "text": "not the storage allocator. And what you do is you take\nadvantage of the fact that if it's an unused block of storage,\nthen you can put a",
    "start": "819560",
    "end": "828440"
  },
  {
    "text": "pointer in there. And so what you do, is you\nstring all these unblocked",
    "start": "828440",
    "end": "834290"
  },
  {
    "text": "pieces of storage together\ninto a free list. So we point to there, which\npoints to there, which points",
    "start": "834290",
    "end": "839960"
  },
  {
    "text": "to there, which points to there,\nwhich points nowhere. So you just simply linked\ntogether all of the things",
    "start": "839960",
    "end": "846529"
  },
  {
    "text": "that are free in that list. And then whenever you need one\nto allocate an object, what",
    "start": "846530",
    "end": "853350"
  },
  {
    "text": "you do is, you grab one\noff the free list. So you set the value that you're\ngoing to want to take",
    "start": "853350",
    "end": "863290"
  },
  {
    "text": "off free list to free-- so here x gets a pointer to this\nobject, the one that's at",
    "start": "863290",
    "end": "868540"
  },
  {
    "text": "the start of the list. Then you update free with\nfree arrow next, which",
    "start": "868540",
    "end": "877690"
  },
  {
    "text": "gives you this guy.  So that's the next\nguy in line.",
    "start": "877690",
    "end": "883180"
  },
  {
    "text": "And then you basically\nreturn x. And that's all there is to it.",
    "start": "883180",
    "end": "888920"
  },
  {
    "text": "You just grab the first element\noff the free list. Now, there's a little bit of\nsubtlety in that the thing",
    "start": "888920",
    "end": "896070"
  },
  {
    "text": "that you're grabbing off has a\ngarbage pointer in it, because we're not initializing\nstorage.",
    "start": "896070",
    "end": "901730"
  },
  {
    "text": "There are some storage\nallocators that will always set the value that's returned\nto the user to all zeros, for example.",
    "start": "901730",
    "end": "908209"
  },
  {
    "text": "But typically malloc\ndoesn't do that. It basically leaves that as\nuninitialized storage.",
    "start": "908210",
    "end": "915590"
  },
  {
    "text": "And so you can actually go and\nsee, what were the values that used to be stored in there?",
    "start": "915590",
    "end": "921029"
  },
  {
    "text": "And so basically, you can end\nup with a garbage pointer there, but you really don't care\nabout that, because it's",
    "start": "921030",
    "end": "928170"
  },
  {
    "text": "no longer on the list. So you can see, for example,\nif I then went and I-- ",
    "start": "928170",
    "end": "936060"
  },
  {
    "text": "well, let's do this, to take a\nlook at what happens when a free an item.",
    "start": "936060",
    "end": "941490"
  },
  {
    "text": "So if I want to free an object\nx, I take some object x here.",
    "start": "941490",
    "end": "946790"
  },
  {
    "text": "Let's say it's this guy\nthat's being freed. What I do is, I make it\npoint to the first",
    "start": "946790",
    "end": "957620"
  },
  {
    "text": "element of the list. So basically, next equals\nfree, So he",
    "start": "957620",
    "end": "964050"
  },
  {
    "text": "basically points there. And then I say free equals x,\nmeaning move the free pointer",
    "start": "964050",
    "end": "969560"
  },
  {
    "text": "up to now point to the new\nbeginning of the list. So we're basically pushing and\npopping things off the front",
    "start": "969560",
    "end": "975830"
  },
  {
    "text": "of the list. It's just the stack discipline,\nexcept we're using a linked list, rather\nthan using an array.",
    "start": "975830",
    "end": "983060"
  },
  {
    "text": "So we push to free, and\nwe pop to allocate.",
    "start": "983060",
    "end": "993880"
  },
  {
    "text": "Now the tricky thing here-- you can sort of see what might\ngo wrong if I then said, oh, let me free this thing again.",
    "start": "993880",
    "end": "1001910"
  },
  {
    "text": "Suppose you said, now that this\nis free, suppose you came in and say, oh, I'll free\nthat thing again.",
    "start": "1001910",
    "end": "1007540"
  },
  {
    "text": "Well, now you're going to go\nthrough the same code here, and you're going to see, you're\ngoing to completely",
    "start": "1007540",
    "end": "1013100"
  },
  {
    "text": "screw up the free list. So that's why you don't want\nto do a double free.",
    "start": "1013100",
    "end": "1019000"
  },
  {
    "text": "So you can see exactly what's\ngoing to go on in the free list implementation. So this is pretty good\nand pretty cheap.",
    "start": "1019000",
    "end": "1024780"
  },
  {
    "text": " Allocating and freeing\ntake constant time.",
    "start": "1024780",
    "end": "1030069"
  },
  {
    "text": "That's great, just as\nwith stack pointer. It's got good temporal locality,\nand the reason is",
    "start": "1030069",
    "end": "1035240"
  },
  {
    "text": "because you're tending to\nallocate the thing that you freed most recently.",
    "start": "1035240",
    "end": "1040319"
  },
  {
    "text": "The free list operates\nas a last in, first out data structure. So from a temporal locality\npoint of view,",
    "start": "1040319",
    "end": "1046829"
  },
  {
    "text": "it's really very good. You're always using the most\nrecently freed stuff whenever",
    "start": "1046829",
    "end": "1052550"
  },
  {
    "text": "you allocate, and that means\nyou have very good caching behavior from a temporal\nlocality point of view.",
    "start": "1052550",
    "end": "1059450"
  },
  {
    "text": "However, it has poor spatial\nlocality, and the reason is due to what's called external\nfragmentation, where you get",
    "start": "1059450",
    "end": "1069760"
  },
  {
    "text": "your storage distributed\nacross virtual memory. So if you think about this, as\nyou start allocating and",
    "start": "1069760",
    "end": "1076750"
  },
  {
    "text": "freeing in different orders,\nthe order of that free list gets very jumbled up.",
    "start": "1076750",
    "end": "1082450"
  },
  {
    "text": "And as it increases, and you end\nup with jumping from one",
    "start": "1082450",
    "end": "1089720"
  },
  {
    "text": "thing to another, you basically\ncan end up causing",
    "start": "1089720",
    "end": "1097750"
  },
  {
    "text": "you to use a lot of the page\ntable, because you're basically using a huge piece\nof it, rather than-- and in",
    "start": "1097750",
    "end": "1105090"
  },
  {
    "text": "particular, the translation\nlook aside buffer can also be a problem.",
    "start": "1105090",
    "end": "1110430"
  },
  {
    "text": "So the translation look aside\nbuffer typically works on a page basis.",
    "start": "1110430",
    "end": "1116140"
  },
  {
    "text": "And if you recently referenced\nthings on a given page, that's very good for the TLB, because\nit's already got the",
    "start": "1116140",
    "end": "1122340"
  },
  {
    "text": "translation, the virtual address\nmapping of that page dealt with.",
    "start": "1122340",
    "end": "1128120"
  },
  {
    "text": "So it basically has poor spatial\nlocality, because it's getting all jumbled up. Compared to stack allocation,\nwhich is always very nice in",
    "start": "1128120",
    "end": "1135920"
  },
  {
    "text": "terms of its behavior, because\nyou're going across consecutive locations in memory,\nwhich means you're",
    "start": "1135920",
    "end": "1141980"
  },
  {
    "text": "always allocating and freeing\nfrom the same page, unless you trip over a page boundary.",
    "start": "1141980",
    "end": "1149169"
  },
  {
    "text": "So here's some ways of\nmitigating external fragmentation. Of course, this makes the\ncode for free list more",
    "start": "1149170",
    "end": "1157940"
  },
  {
    "text": "complicated. And then you have to weigh, how\nmuch am I losing in having",
    "start": "1157940",
    "end": "1163500"
  },
  {
    "text": "a more complicated allocator\nversus suffering the fragmentation may occur?",
    "start": "1163500",
    "end": "1168840"
  },
  {
    "text": "Yes, question? AUDIENCE: You specificed before\nthat it was fixed size. Is that why we don't specify\nanything about the size?",
    "start": "1168840",
    "end": "1175260"
  },
  {
    "text": "CHARLES LEISERSON:\nThat's right. We're just assuming that it's\nall whatever the unit size is. So this is really good when\nyou've created your own data",
    "start": "1175260",
    "end": "1182450"
  },
  {
    "text": "structure, and let's say you're\ndoing nodes in a graph. You know exactly what elements\nyou want in the graph, for",
    "start": "1182450",
    "end": "1190490"
  },
  {
    "text": "each vertex. And now what you want to do is\nbasically be able to give",
    "start": "1190490",
    "end": "1196240"
  },
  {
    "text": "yourself a note of a graph, free\na note of a graph, and manage that storage yourself. ",
    "start": "1196240",
    "end": "1202970"
  },
  {
    "text": "Yes, question? AUDIENCE: [INAUDIBLE] allocated across virtual\nmemory [INAUDIBLE] one",
    "start": "1202970",
    "end": "1208043"
  },
  {
    "text": "application? CHARLES LEISERSON: Why is it\nallocated across virtual memory if it's all\none application?",
    "start": "1208043",
    "end": "1215060"
  },
  {
    "text": "Well, because the size that you\nmay end up needing can end up being large. And I'll show you in just a\nminute how that happens.",
    "start": "1215060",
    "end": "1222010"
  },
  {
    "text": " So here's the idea.",
    "start": "1222010",
    "end": "1227920"
  },
  {
    "text": "What you can do is keep a\nfree list per disk page. So disk page, a traditional\npage is 4,000 bytes.",
    "start": "1227920",
    "end": "1237030"
  },
  {
    "text": "These days they talk about\nsuper pages that are megabytes, and who knows what\nsize pages various operating",
    "start": "1237030",
    "end": "1245120"
  },
  {
    "text": "systems will support. I believe the clouds use 4k,\nas configured right now are",
    "start": "1245120",
    "end": "1250450"
  },
  {
    "text": "using 4k, which leads to some\nstrange anomalies where the TLB can address less stuff\nthan the L3 cache.",
    "start": "1250450",
    "end": "1260704"
  },
  {
    "text": "But so be it. So basically, they just keep a\nfree list per disk page, and basically always allocate from\nthe free list for the page",
    "start": "1260704",
    "end": "1269320"
  },
  {
    "text": "that's fullest, the page that\nyou've allocated the most of the stuff off of. Rather than for a page\nthat's less empty.",
    "start": "1269320",
    "end": "1277390"
  },
  {
    "text": "So what this means is that when\nyou come to allocate, you have to figure out, which\npage should I do the allocation off of?",
    "start": "1277390",
    "end": "1283670"
  },
  {
    "text": "But we'll have a free\nlist on each page. Whenever you free of a block of\nstorage, you have to free it to the page on which\nthe block resides.",
    "start": "1283670",
    "end": "1290460"
  },
  {
    "text": "Don't put into a free list\nof a different page. You put it into a free list all\nof that particular page.",
    "start": "1290460",
    "end": "1296430"
  },
  {
    "text": "Now if a page becomes empty, in\nother words, there's only the free list on it, there's no\nactually used elements by",
    "start": "1296430",
    "end": "1303180"
  },
  {
    "text": "the programmer, the virtual\nmemory system will page it out. And since the programmer's never\nreferencing things on",
    "start": "1303180",
    "end": "1310220"
  },
  {
    "text": "that page, it basically\ncosts you nothing. You end up not having to have\nan entry in the TLB, and you",
    "start": "1310220",
    "end": "1319570"
  },
  {
    "text": "may have written to it, but\nyou will end up allocating things preferentially to\nthe more full pages.",
    "start": "1319570",
    "end": "1327770"
  },
  {
    "text": "And the basic idea is, it's\nbetter to have the use of your pages balance 90/10\nthan 50/50.",
    "start": "1327770",
    "end": "1335720"
  },
  {
    "text": "So this kind [? of fig ?]\nconfiguration is better than that. So why is that?",
    "start": "1335720",
    "end": "1342590"
  },
  {
    "text": "If you have 90% of your storage\non one page and only 10% on another--",
    "start": "1342590",
    "end": "1350940"
  },
  {
    "text": "yeah, let's say we only of two\npages in our system, and 90% of the objects are on one page,\nand 10% of the objects",
    "start": "1350940",
    "end": "1359210"
  },
  {
    "text": "are on the other page, versus\nif they're 50-50. Then what you can do is look\nat the probability that two",
    "start": "1359210",
    "end": "1366860"
  },
  {
    "text": "accesses are going to\ngo to the same page. Because if you're going to the\nsame page, then your paging",
    "start": "1366860",
    "end": "1374870"
  },
  {
    "text": "hardware, which is very much\nlike the cache, your TLB, which is very much\nlike a cache--",
    "start": "1374870",
    "end": "1380330"
  },
  {
    "text": "whenever you get a hit on the\nsame page, that's good, it costs you nothing. If you hit on a different\npage, that's bad.",
    "start": "1380330",
    "end": "1386759"
  },
  {
    "text": "So what happens is, the\nprobability that two hit the same page is, well, for the\nfirst one, it's, what's the",
    "start": "1386760",
    "end": "1391830"
  },
  {
    "text": "probability that the first\none was on this page, versus on the other?",
    "start": "1391830",
    "end": "1396900"
  },
  {
    "text": "So it's going to be on the same\npage if they're both on this page or they're\nboth on this page.",
    "start": "1396900",
    "end": "1402230"
  },
  {
    "text": "And so that's going to be 0.9\ntimes 0.9 plus 0.1 times 0.1.",
    "start": "1402230",
    "end": "1407330"
  },
  {
    "text": "Whereas if it's 50/50, then the\nprobability that you get hit on the same page is now this\n0.5 times 0.5 plus 0.5",
    "start": "1407330",
    "end": "1416820"
  },
  {
    "text": "times 0.5, which is only 50%. So we get 82% hit rate versus\nthe 50% hit rate.",
    "start": "1416820",
    "end": "1425520"
  },
  {
    "text": "So it's much more likely, if I'm\nstacking everything out in the extreme, it's better to have\neverything on one page",
    "start": "1425520",
    "end": "1431139"
  },
  {
    "text": "and nothing on the other. Then I get 100% hit rate,\nbecause whenever I'm accessing something, I always am hitting\non the page I had before.",
    "start": "1431140",
    "end": "1440750"
  },
  {
    "text": "So this kind of heuristic\nhelps it so that you're swinging your accesses to using\nfewer pages, and the",
    "start": "1440750",
    "end": "1449940"
  },
  {
    "text": "fewer pages, the less likely\nit is that you're going to stress your virtual memory\npaging, disk swapping, you're",
    "start": "1449940",
    "end": "1456860"
  },
  {
    "text": "going to stress your TLB\nand what have you.  Good for that?",
    "start": "1456860",
    "end": "1463660"
  },
  {
    "text": "We're going to get deeper\ninto this, so. ",
    "start": "1463660",
    "end": "1470130"
  },
  {
    "text": "So that's basically fixed\nsize allocation. It's really nice, because you\ncan basically use a very",
    "start": "1470130",
    "end": "1475230"
  },
  {
    "text": "simple free list. But of course what most people\nneed and want is variable",
    "start": "1475230",
    "end": "1480350"
  },
  {
    "text": "sized allocation. The most popular way of doing\nvariable sized allocation is a",
    "start": "1480350",
    "end": "1486830"
  },
  {
    "text": "scheme called binned free lists,\nand of that, then there are a zillion variations\non it. But mostly, people use\nbinned free lists.",
    "start": "1486830",
    "end": "1495180"
  },
  {
    "text": "The idea is, we're going to\nleverage the efficiency of normal free lists. Normal free lists I can allocate\nand free in just one",
    "start": "1495180",
    "end": "1502800"
  },
  {
    "text": "operation, in just a constant\namount of time I make. And what we're going to do\nis accept some internal",
    "start": "1502800",
    "end": "1509700"
  },
  {
    "text": "fragmentation. So by internal fragmentation\nI mean the following. When somebody asks for something\nof a given size,",
    "start": "1509700",
    "end": "1519130"
  },
  {
    "text": "what we're going to do is\nactually give them something which is a little bit\nbigger, maybe.",
    "start": "1519130",
    "end": "1527350"
  },
  {
    "start": "1526000",
    "end": "1578000"
  },
  {
    "text": "And so we'll waste some. And in particular, what we'll\ndo is, we'll organize our",
    "start": "1527350",
    "end": "1532460"
  },
  {
    "text": "system so that all the blocks\nthat we ever give out are always a size the\npower of two.",
    "start": "1532460",
    "end": "1539250"
  },
  {
    "text": "In practice, you don't always\ngive out exactly a power of two, because then you get cache\nalignment problems.",
    "start": "1539250",
    "end": "1544260"
  },
  {
    "text": "But this is the basic scheme,\nis to give out things are powers of two.",
    "start": "1544260",
    "end": "1550880"
  },
  {
    "text": "And that way, if somebody asks\nfor something that has 13 bytes, you give them 16 bytes.",
    "start": "1550880",
    "end": "1557270"
  },
  {
    "text": "For somebody who asked\nfor 65 bytes, have to give them 128 bytes.",
    "start": "1557270",
    "end": "1563570"
  },
  {
    "text": "So you might waste up to as\nmuch as a factor of two. But now, for a given that range\nof values, there's only",
    "start": "1563570",
    "end": "1571590"
  },
  {
    "text": "a logarithmic number of\ndifferent sizes that we have to give out, because we're\nonly giving them out",
    "start": "1571590",
    "end": "1576770"
  },
  {
    "text": "in powers of two. So here's the basic allocation\nscheme to allocate x bytes.",
    "start": "1576770",
    "end": "1587430"
  },
  {
    "start": "1578000",
    "end": "1763000"
  },
  {
    "text": "So what I do is, if I'm\nallocating x bytes, what I do",
    "start": "1587430",
    "end": "1592660"
  },
  {
    "text": "is, I look in the bin ceiling of\nlog x, because that's where",
    "start": "1592660",
    "end": "1598870"
  },
  {
    "text": "everything of size two to the\nceiling of log x is, which is basically rounding x up to\nthe next power of two.",
    "start": "1598870",
    "end": "1606890"
  },
  {
    "text": "If it's non-empty, I just return\na block as if it were an ordinary free list.",
    "start": "1606890",
    "end": "1614030"
  },
  {
    "text": "And what I'll be doing is\nreturning a block which is at most twice the size of\nthe requested block.",
    "start": "1614030",
    "end": "1619380"
  },
  {
    "text": "But that's generally OK. Somebody wants at least\nthat many bytes. The fact that it's a few more\nbytes won't matter to them.",
    "start": "1619380",
    "end": "1626240"
  },
  {
    "text": "They don't know that there's\nmore bytes hidden there. They only take advantage of the\nfact that there are many",
    "start": "1626240",
    "end": "1631720"
  },
  {
    "text": "bytes as I've asked for. Otherwise, suppose that\nthat bin is empty.",
    "start": "1631720",
    "end": "1640190"
  },
  {
    "text": "There's nothing in that\nbin at this time. Well, then what you do is you\nstart looking to find a block",
    "start": "1640190",
    "end": "1648250"
  },
  {
    "text": "in the next larger non-empty\nbin, and you split it up. So for example here,\nsuppose that the",
    "start": "1648250",
    "end": "1654180"
  },
  {
    "text": "request is x equals 3. I have to look in bin 2, which\nis blocks of size 4.",
    "start": "1654180",
    "end": "1660705"
  },
  {
    "text": "Uh oh, bin 2 is empty. So what I do is, I start going\ndown, looking in the next bin.",
    "start": "1660705",
    "end": "1666001"
  },
  {
    "text": "Oops, that's empty too,\nthat's empty-- and then finally, I get to one\nwhere there is a block in it.",
    "start": "1666001",
    "end": "1671960"
  },
  {
    "text": "So what I do then is\nI dice this up. I cut it in half, and then cut\nthat one in half, until I get",
    "start": "1671960",
    "end": "1679090"
  },
  {
    "text": "a piece that's exactly the\nsize I want to return. OK? And then I distribute all of\nthese guys up to the other",
    "start": "1679090",
    "end": "1685960"
  },
  {
    "text": "bins, like this. ",
    "start": "1685960",
    "end": "1692230"
  },
  {
    "text": "So I return one of this size,\nand I populate these other guys with one block each of\nthe appropriate size.",
    "start": "1692230",
    "end": "1702490"
  },
  {
    "text": "And as you can see, they're\nbasically growing in a geometric fashion.",
    "start": "1702490",
    "end": "1707630"
  },
  {
    "text": "And then I distribute\nthat bin. Now there's a caveat here.",
    "start": "1707630",
    "end": "1713759"
  },
  {
    "text": "Suppose that no larger blocks\nexist in my storage structure.",
    "start": "1713760",
    "end": "1719230"
  },
  {
    "text": "Well, then I have to ask the\noperating system for more bytes, to allocate x more\nbytes of virtual memory.",
    "start": "1719230",
    "end": "1730860"
  },
  {
    "text": "Now in practice what you do is\nyou don't actually ask for x, since you never ask\nthe operating system for small values.",
    "start": "1730860",
    "end": "1736590"
  },
  {
    "text": "You always ask the operating\nsystem for big values. Give me another page worth,\nor give me another five pages, or something.",
    "start": "1736590",
    "end": "1743110"
  },
  {
    "text": "Because that's an expensive call\nto the operating system, to ask it to allocate\nmore storage.",
    "start": "1743110",
    "end": "1749130"
  },
  {
    "text": "Let me explain how that works. And this gets back to the\nquestion you had before, which is, where's the stuff\ncoming from anyway?",
    "start": "1749130",
    "end": "1756460"
  },
  {
    "text": "What the operating system is\nallocating is actually not physical pages, but rather\nparts of virtual memory.",
    "start": "1756460",
    "end": "1764620"
  },
  {
    "start": "1763000",
    "end": "1855000"
  },
  {
    "text": "So we looked at this before,\nabout how virtual memory is",
    "start": "1764620",
    "end": "1769830"
  },
  {
    "text": "laid out for a typical\nprogram. So what we do is, on the very\nhigh addresses, we have the",
    "start": "1769830",
    "end": "1775790"
  },
  {
    "text": "stack, and the stack\ngrows downwards. This is the call stack. At the low address, we typically\nstart out with",
    "start": "1775790",
    "end": "1781750"
  },
  {
    "text": "what's called the text segment, which holds your code.  Then there's a region called\nthe data segment, and this",
    "start": "1781750",
    "end": "1789860"
  },
  {
    "text": "consists of data that needs\nto be initialized. So the compiler typically\ndistinguishes between data",
    "start": "1789860",
    "end": "1798320"
  },
  {
    "text": "that needs initialization and\ndata which is going to be zero, because data that needs\ninitialization, it writes into",
    "start": "1798320",
    "end": "1805150"
  },
  {
    "text": "the binary executable file\nand stores that on disk. So when you load in your\nprogram, it just loads as part",
    "start": "1805150",
    "end": "1811580"
  },
  {
    "text": "of the text here, it loads that\ndata segment, saying what all of the storage is. The next segment is, for\nhistorical reasons, called the",
    "start": "1811580",
    "end": "1819390"
  },
  {
    "text": "BSS segment. And what BSS consists of is all\nthe variables that at the",
    "start": "1819390",
    "end": "1826780"
  },
  {
    "text": "start of the program should\nbe initialized to 0. It doesn't bother storing\nthese in the file.",
    "start": "1826780",
    "end": "1834700"
  },
  {
    "text": "Why not? Because it's easy enough to just\nbring it in, understand what that distance there is, and\nthen do a memset of this",
    "start": "1834700",
    "end": "1843980"
  },
  {
    "text": "whole region with zero, to\nzero it out, rather than trying to read in a whole\nbunch of zeroes.",
    "start": "1843980",
    "end": "1850185"
  },
  {
    "text": " An obvious kind of\ndata compression.",
    "start": "1850185",
    "end": "1855790"
  },
  {
    "start": "1855000",
    "end": "1889000"
  },
  {
    "text": "Then heap storage is allocated\nin the space above the BSS segment.",
    "start": "1855790",
    "end": "1862920"
  },
  {
    "text": "So the idea is, there's a part\nof heap which has already been allocated stuff. And whenever you need more\nheap storage, you ask the",
    "start": "1862920",
    "end": "1870280"
  },
  {
    "text": "operating system-- the operating\nsystem moves just as if it were a stack, moves the\nline for where heap is to",
    "start": "1870280",
    "end": "1878850"
  },
  {
    "text": "allocate, to give you more pages\nof heap storage that you can now allocate out of.",
    "start": "1878850",
    "end": "1885660"
  },
  {
    "text": "And what it's doing\nis allocating pieces of virtual memory. ",
    "start": "1885660",
    "end": "1891380"
  },
  {
    "start": "1889000",
    "end": "2459000"
  },
  {
    "text": "Now, here's a good mind\nquestion, which I think gets",
    "start": "1891380",
    "end": "1897630"
  },
  {
    "text": "directly to your point. So think about this. We have a 64-bit\naddress space.",
    "start": "1897630",
    "end": "1905370"
  },
  {
    "text": "If I try to write at the rate of\n4 billion bytes per second, that's pretty fast, because\nthat's the speed at which the",
    "start": "1905370",
    "end": "1911640"
  },
  {
    "text": "registers get written. Not the speed that memory\ngets written. So really, it's something like\n4 billion bytes per second.",
    "start": "1911640",
    "end": "1920059"
  },
  {
    "text": "It takes over a century to write\nall of virtual memory.",
    "start": "1920060",
    "end": "1927330"
  },
  {
    "text": "So as a practical matter,\nthat means I never run out of stack space.",
    "start": "1927330",
    "end": "1932600"
  },
  {
    "text": "I never run out of heap space. They're never going to cross,\nno matter how much I'm",
    "start": "1932600",
    "end": "1938910"
  },
  {
    "text": "allocating. Even if I allocate on every\ncycle, there's not going to be a program-- unless you're going\nto set a program running",
    "start": "1938910",
    "end": "1944780"
  },
  {
    "text": "for a millennium sort\nof thing, you're not going to see that. Most programs run for\na few minutes.",
    "start": "1944780",
    "end": "1953190"
  },
  {
    "text": "Some may run for days. Some may run for years. Very few do people write\nto run for a century.",
    "start": "1953190",
    "end": "1958220"
  },
  {
    "text": " So why not just allocate out\nof free virtual memory and",
    "start": "1958220",
    "end": "1964920"
  },
  {
    "text": "never bother freeing? Why am I worried about freeing\nstuff all the time? Why not just allocate it?",
    "start": "1964920",
    "end": "1970080"
  },
  {
    "text": "It's virtual memory. It's virtual. I just allocate more storage\nas I need it.",
    "start": "1970080",
    "end": "1975290"
  },
  {
    "text": "Yeah? AUDIENCE: [INAUDIBLE] memory? CHARLES LEISERSON: So it is\ntied to real memory, and that's part of the answer.",
    "start": "1975290",
    "end": "1981070"
  },
  {
    "text": "It is tied to real memory,\nbecause anything that you write must find itself\na place on disk.",
    "start": "1981070",
    "end": "1989030"
  },
  {
    "text": "Because it's going to be written\nto pages, and those pages are going to be paged\nand then written to what's",
    "start": "1989030",
    "end": "1994220"
  },
  {
    "text": "called the swap space on\ndisk, which allows you to put things there. Even so, though, writing\nto disk--",
    "start": "1994220",
    "end": "2003320"
  },
  {
    "text": "it's still not going\nto take very long. I mean, you're never going to\nbe able to use up disk,",
    "start": "2003320",
    "end": "2009000"
  },
  {
    "text": "because disk takes so\nlong to write for. But that is part\nof the answer. AUDIENCE: So you need to\nbasically use [INAUDIBLE]",
    "start": "2009000",
    "end": "2018268"
  },
  {
    "text": "software? And so-- CHARLES LEISERSON: And\nthe page table. AUDIENCE: [UNINTELLIGIBLE]",
    "start": "2018268",
    "end": "2024560"
  },
  {
    "text": "on the disk. CHARLES LEISERSON: So the issue\nis, this is where the external fragmentation\nwould be horrendous.",
    "start": "2024560",
    "end": "2030950"
  },
  {
    "text": "If you just kept writing across\nmemory, and you only had a couple of words written\non every page that were",
    "start": "2030950",
    "end": "2036450"
  },
  {
    "text": "actually used, the rest is just\ngarbage, then what you're",
    "start": "2036450",
    "end": "2041950"
  },
  {
    "text": "saying is that in order to\naccess a given datum, I'm not going to have it in memory with\nit a lot of other stuff.",
    "start": "2041950",
    "end": "2049658"
  },
  {
    "text": "What I'm going to have in memory\nwith it is going to be all garbage, this stuff that\nI would have freed.",
    "start": "2049659",
    "end": "2055500"
  },
  {
    "text": "And so therefore, you end\nup having your program distributed across a large\nregion of virtual memory, and",
    "start": "2055500",
    "end": "2062870"
  },
  {
    "text": "that means as we're doing the\npaging, et cetera, we're getting very poor\npage locality as",
    "start": "2062870",
    "end": "2070330"
  },
  {
    "text": "I'm accessing things. And so I have a finite number of\npages that I fit in memory,",
    "start": "2070330",
    "end": "2075408"
  },
  {
    "text": "and now I may be blowing that\nout, and every access, rather than going to something\nnearby, is",
    "start": "2075409",
    "end": "2080520"
  },
  {
    "text": "instead going to disk. And so that can cause disk\nthrashing, where every access",
    "start": "2080520",
    "end": "2086770"
  },
  {
    "text": "causes a disk access. So how fast are disk accesses?",
    "start": "2086770",
    "end": "2091830"
  },
  {
    "text": "Order of magnitude? ",
    "start": "2091830",
    "end": "2096896"
  },
  {
    "text": "How fast are disk accesses? What's a disk access cost? Fast disk?",
    "start": "2096896",
    "end": "2101930"
  },
  {
    "text": " AUDIENCE: [INAUDIBLE] ",
    "start": "2101930",
    "end": "2110057"
  },
  {
    "text": "CHARLES LEISERSON: No, it's\nslower than that. Disk access.",
    "start": "2110057",
    "end": "2115497"
  },
  {
    "text": "So good memory access, DRAM\nmemory is, like, 60 nanoseconds for DRAM access.",
    "start": "2115497",
    "end": "2122070"
  },
  {
    "text": "It's like 60 nanoseconds. So the processor is going\nsomewhere around, these days,",
    "start": "2122070",
    "end": "2128460"
  },
  {
    "text": "between 3 and 4 gigahertz. So memory is like 200 processor\ncycles away.",
    "start": "2128460",
    "end": "2139210"
  },
  {
    "text": "How fast is disk? An ordinary disk, not a\nsolid state device.",
    "start": "2139210",
    "end": "2145050"
  },
  {
    "text": "Ordinary disk.  10 milliseconds is a good\nballpark to give.",
    "start": "2145050",
    "end": "2151840"
  },
  {
    "text": "That's a good number to know. 10 milliseconds, not 10\nmicroseconds, not 10",
    "start": "2151840",
    "end": "2157590"
  },
  {
    "text": "nanoseconds. 10 milliseconds. So you are, what?",
    "start": "2157590",
    "end": "2165510"
  },
  {
    "text": "6 to 7 orders of magnitude\nslower if you go to disk. ",
    "start": "2165510",
    "end": "2171930"
  },
  {
    "text": "Really slow. So one of the things in\nperformance optimization-- we're focusing a lot\non the CPU--",
    "start": "2171930",
    "end": "2178630"
  },
  {
    "text": "is often the case for\ndatabase things. How do you minimize those\ndisk accesses? And all the things that we're\nlearning about, performance",
    "start": "2178630",
    "end": "2186640"
  },
  {
    "text": "for CPUs, can be applied to\ndisk accesses, as well.",
    "start": "2186640",
    "end": "2194039"
  },
  {
    "text": "So the idea here is\nwe want to avoid-- that's why we don't want to have\nour stuff strewn across a",
    "start": "2194040",
    "end": "2200280"
  },
  {
    "text": "whole bunch of pages where we\nonly have a fixed amount of internal memory, because\nthen we'll end up paging all the time.",
    "start": "2200280",
    "end": "2206640"
  },
  {
    "text": "Every access will cause us to\ndo a disk access, because it won't be very likely\nthat we're getting",
    "start": "2206640",
    "end": "2211820"
  },
  {
    "text": "stuff on the same page. So getting back, for example,\nto the fixed allocation, that's why it's a good idea to\ntry to keep those pages full,",
    "start": "2211820",
    "end": "2220039"
  },
  {
    "text": "so that we have a small thing. So the goal of most storage\nallocators is therefore to use",
    "start": "2220040",
    "end": "2226480"
  },
  {
    "text": "as little virtual memory as\npossible, and try to keep the",
    "start": "2226480",
    "end": "2231710"
  },
  {
    "text": "used portions very compact. Because the more compact it is,\nthe more likely it is that",
    "start": "2231710",
    "end": "2238029"
  },
  {
    "text": "when you access one, you'll be\nable to access something nearby without causing\na page fault.",
    "start": "2238030",
    "end": "2245359"
  },
  {
    "text": "So that's the goal of almost\nall storage allocators. Try to keep things compact, try\nto keep things tight and",
    "start": "2245360",
    "end": "2251579"
  },
  {
    "text": "in very little virtual memory\nspace, even though virtual memory is huge.",
    "start": "2251580",
    "end": "2256640"
  },
  {
    "text": "Now, that doesn't mean that\neverything has to be contiguous. For example, in this\norganization as I showed",
    "start": "2256640",
    "end": "2262650"
  },
  {
    "text": "before, actually, I have it just\non the previous slide, so why don't I go back there-- these are very far away in\nmemory, but there's only a",
    "start": "2262650",
    "end": "2270660"
  },
  {
    "text": "couple of them, and they're\ntight and local in the regions",
    "start": "2270660",
    "end": "2275970"
  },
  {
    "text": "that they're operating in. What I don't want to do is\nhave it where I have just little stuff.",
    "start": "2275970",
    "end": "2281559"
  },
  {
    "text": "It's OK to go into the middle\nof virtual memory and have a whole bunch of consecutive\npages full of data.",
    "start": "2281560",
    "end": "2287760"
  },
  {
    "text": "That's fine. What's bad is having just a\nlittle bit of data, a little bit of data, and a little\nbit of data sort of",
    "start": "2287760",
    "end": "2294120"
  },
  {
    "text": "sprinkled all over. That's bad. But as long as I can put a whole\nbunch of data nearby, it",
    "start": "2294120",
    "end": "2299930"
  },
  {
    "text": "doesn't matter where in virtual\nmemory I put it, particularly. ",
    "start": "2299930",
    "end": "2306099"
  },
  {
    "text": "So the idea is, let's try to use\nas little virtual memory as possible. Any questions about that?",
    "start": "2306100",
    "end": "2311230"
  },
  {
    "text": " OK.",
    "start": "2311230",
    "end": "2317227"
  },
  {
    "text": "So how do we do that? So the first thing is, binned\nfree list turns out to do a",
    "start": "2317227",
    "end": "2323270"
  },
  {
    "text": "really good job of using\nrelatively little memory.",
    "start": "2323270",
    "end": "2329170"
  },
  {
    "text": "So suppose that the user program\nis using, at most, m",
    "start": "2329170",
    "end": "2335930"
  },
  {
    "text": "memory at any point during\nthe execution. Maybe allocating,\nmaybe freeing. But if I took the high watermark\nof everything he",
    "start": "2335930",
    "end": "2342330"
  },
  {
    "text": "says that he needs,\nwe call that m. Then it turns out that if you\nuse a bin free list allocator,",
    "start": "2342330",
    "end": "2351440"
  },
  {
    "text": "the amount of virtual memory\nconsumed is at most m times log n.",
    "start": "2351440",
    "end": "2357480"
  },
  {
    "text": "Order m times log n. And why is that? Here's kind of a hand-wavy\nproof sketch.",
    "start": "2357480",
    "end": "2364000"
  },
  {
    "text": "So whenever I make a request for\na block of size x, it may consume at most twice x storage",
    "start": "2364000",
    "end": "2372970"
  },
  {
    "text": "that's actually in use. And so it turns out that the\ntotal amount of memory devoted",
    "start": "2372970",
    "end": "2378839"
  },
  {
    "text": "to blocks of size 2 to the k\nis therefore at most 2m. So for any given size, I might,\nat any given point in",
    "start": "2378840",
    "end": "2388430"
  },
  {
    "text": "time, have the program using all\nblocks of that given size. Let's say size 2 to the k.",
    "start": "2388430",
    "end": "2397200"
  },
  {
    "text": "And since there are a\nlogarithmic number of those bins, each bin of which could\nhave a size at most m, the",
    "start": "2397200",
    "end": "2409690"
  },
  {
    "text": "total is order m log m.  Now it turns out that there's\nactually a stronger property.",
    "start": "2409690",
    "end": "2416990"
  },
  {
    "text": "In fact, you can show that\nbinned free list is order one competitive.",
    "start": "2416990",
    "end": "2422230"
  },
  {
    "text": "Who knows the term \"competitive\"\nin this sense? The algorithmic meaning\nof \"competitive\"?",
    "start": "2422230",
    "end": "2427530"
  },
  {
    "text": "So what it means is, it's at\nmost a constant factor slower than the optimal omniscient\nalgorithm that could figure",
    "start": "2427530",
    "end": "2435849"
  },
  {
    "text": "out exactly what's going\non in every step. So you're within a constant\nfactor competitive with the",
    "start": "2435850",
    "end": "2442280"
  },
  {
    "text": "optimal allocator, assuming\nthat the optimal allocator does not do what's called\ncoalescing.",
    "start": "2442280",
    "end": "2449470"
  },
  {
    "text": "If it simply is dividing up\nthings, then it can subdivide, but it can never glue things\nback together again.",
    "start": "2449470",
    "end": "2455390"
  },
  {
    "text": "It turns out that in fact,\nbinned free list is really much better than that.",
    "start": "2455390",
    "end": "2461430"
  },
  {
    "start": "2459000",
    "end": "2667000"
  },
  {
    "text": "So let's talk a bit about\ncoalescing, because many, many memory allocators\nuse coalescing. ",
    "start": "2461430",
    "end": "2469220"
  },
  {
    "text": "So the idea is, I'm concerned\nabout the case where I end up",
    "start": "2469220",
    "end": "2474250"
  },
  {
    "text": "with a whole bunch of little\nsmall objects, and yet the allocations now come\nfrom big chunks.",
    "start": "2474250",
    "end": "2481109"
  },
  {
    "text": "And so I have to go and use more\nof my virtual memory, or maybe I can glue together those\nlittle pieces into a big",
    "start": "2481110",
    "end": "2487970"
  },
  {
    "text": "chunk, and not have to\ngo off to memory. So that's what coalescing\nis all about. So the idea is, if two things\nare adjacent, let",
    "start": "2487970",
    "end": "2495609"
  },
  {
    "text": "me glue them together. And there are really clever\nsystems for doing that, including a very famous one\ncalled the buddy system.",
    "start": "2495610",
    "end": "2504450"
  },
  {
    "text": "But using any of these\nmechanisms for coalescing, you always have to trade off between\nthe simplicity of not",
    "start": "2504450",
    "end": "2510730"
  },
  {
    "text": "coalescing. Not coalescing so stick it in\nthe free list, I'm done. Coalescing is, stick it in the\nfree list, oh, am I next to",
    "start": "2510730",
    "end": "2517950"
  },
  {
    "text": "somebody I can merge with? Now let me merge. So you always have to weigh, is\nthat really going to be an",
    "start": "2517950",
    "end": "2525460"
  },
  {
    "text": "advantageous thing? It turns out there are no good\ntheoretical bounds that I'm",
    "start": "2525460",
    "end": "2530730"
  },
  {
    "text": "aware that prove the\neffectiveness of coalescing. People have not figured out how\nto analyze this, or what",
    "start": "2530730",
    "end": "2537740"
  },
  {
    "text": "an appropriate model is for\nunderstanding whether coalescing is a good idea.",
    "start": "2537740",
    "end": "2542940"
  },
  {
    "text": "However, it does seem to work\nin practice for some things, and I think the reason for\nthat-- and this is just my own",
    "start": "2542940",
    "end": "2549510"
  },
  {
    "text": "take on it-- is that storage tends to be\ndeallocated as a stack. So you tend to go into a region\nof a program where you",
    "start": "2549510",
    "end": "2557370"
  },
  {
    "text": "do a lot of heap allocation-- let's say I'm building up a\ngraph, and I keep doing a whole bunch of mallocs.",
    "start": "2557370",
    "end": "2562569"
  },
  {
    "text": "And when I'm done with the\ngraph, what do I do? I free it all. So I tend to have these batch\nallocations and then",
    "start": "2562570",
    "end": "2572250"
  },
  {
    "text": "deallocations, and they tend\nto work often as a stack,",
    "start": "2572250",
    "end": "2578130"
  },
  {
    "text": "often in a batch. And that means that when I do\nthat freeing, I can sometimes take advantage of that\nand do coalescing.",
    "start": "2578130",
    "end": "2585550"
  },
  {
    "text": "In some systems, people have\nwhat are called memory pools,",
    "start": "2585550",
    "end": "2594130"
  },
  {
    "text": "where you have a region where\nwhen you allocate out of it, you know you're allocating out\nof your own particular region",
    "start": "2594130",
    "end": "2600640"
  },
  {
    "text": "specifically so that you can\ndo coalescing of things in that region.",
    "start": "2600640",
    "end": "2606099"
  },
  {
    "text": "And so you may have multiple\nallocators, and you'll call the allocator on the region,\nsay, for a graph, because",
    "start": "2606100",
    "end": "2611930"
  },
  {
    "text": "let's imagine you're creating\ntwo graphs, and one of them you're going to keep around,\nand the other you're going to dump.",
    "start": "2611930",
    "end": "2617059"
  },
  {
    "text": "Well, if I create them at the\nsame time, the storage gets all intermixed, I'll deallocate\none graph.",
    "start": "2617060",
    "end": "2623120"
  },
  {
    "text": "The other one will be, I'll have\nfragmentation all over. These little spots appeared\nwhere the other graph used to be--",
    "start": "2623120",
    "end": "2629380"
  },
  {
    "text": "not so good. But if I say, use this allocator\nfor this graph, use that allocator for that graph,\nthen when I'm done and I'm",
    "start": "2629380",
    "end": "2639310"
  },
  {
    "text": "allocating those out of two\ndifferent regions of memory, that when I'm done with the\nfirst graph and deallocate",
    "start": "2639310",
    "end": "2646000"
  },
  {
    "text": "everything, now I've created\na nice big piece of contiguous storage. So people will sometimes play\nwith different memory pools",
    "start": "2646000",
    "end": "2656609"
  },
  {
    "text": "for allocators, and C++ has a\nfairly rich set of libraries",
    "start": "2656610",
    "end": "2663550"
  },
  {
    "text": "and so forth for that,\nto allow you to do that kind of thing. ",
    "start": "2663550",
    "end": "2670170"
  },
  {
    "start": "2667000",
    "end": "2846000"
  },
  {
    "text": "So let's go on and talk about\ngarbage collection, because",
    "start": "2670170",
    "end": "2675799"
  },
  {
    "text": "that's something you've probably\nseen in Java and Python, and what's going on\nunder the covers there.",
    "start": "2675800",
    "end": "2680940"
  },
  {
    "text": "Because even though C and\nC++ do not have garbage collection, you can\nactually implement",
    "start": "2680940",
    "end": "2686730"
  },
  {
    "text": "your own garbage collector. It's not that hard, except\nfor some details.",
    "start": "2686730",
    "end": "2692620"
  },
  {
    "text": " It's only hard when you want\nit to perform well.",
    "start": "2692620",
    "end": "2699840"
  },
  {
    "text": "So the idea is to free\nthe programmer from freeing objects. The downside, by the way, is\nwhen you free the programmer",
    "start": "2699840",
    "end": "2706490"
  },
  {
    "text": "from freeing objects,\nthey tend to create lots of garbage. And so what happens in Java\nprograms, for example, is",
    "start": "2706490",
    "end": "2713460"
  },
  {
    "text": "you'll have these-- I remember once having a Java\nprogram where, when it was",
    "start": "2713460",
    "end": "2719460"
  },
  {
    "text": "sitting, waiting for user input,\nit would periodically go, garbage collect.",
    "start": "2719460",
    "end": "2725750"
  },
  {
    "text": "It was just sitting\nthere, and then it would go, garbage collect. We weren't doing anything. It was just periodically, the\nway they had written the code,",
    "start": "2725750",
    "end": "2733460"
  },
  {
    "text": "they were somehow generating\ngarbage, doing allocations and frees, when you were sitting\naround doing nothing.",
    "start": "2733460",
    "end": "2740540"
  },
  {
    "text": "And so it would basically use\nup all of the space and then do a garbage collection, use\nup all the space and do a garbage collection.",
    "start": "2740540",
    "end": "2746260"
  },
  {
    "text": "Naturally that's kind\nof a slow system. And so even in something like\nJava, where you have a garbage",
    "start": "2746260",
    "end": "2751520"
  },
  {
    "text": "collector, you do have to worry\nabout whether you're creating garbage or not, and you\ncan generate faster code",
    "start": "2751520",
    "end": "2757200"
  },
  {
    "text": "by not creating as much garbage,\nor by finding ways of recycling the garbage\nyourself.",
    "start": "2757200",
    "end": "2763120"
  },
  {
    "text": "So even in Java, it's worthwhile\nsaying, give me a big chunk of memory, let\nme manage it myself,",
    "start": "2763120",
    "end": "2768890"
  },
  {
    "text": "now let me free it. I don't have to free it, but\nwhen I'm done with it, I'll be done with it. But in the meantime, let me\nmanage it myself so that I",
    "start": "2768890",
    "end": "2775170"
  },
  {
    "text": "don't have it continually\ngenerating more garbage.",
    "start": "2775170",
    "end": "2780790"
  },
  {
    "text": "So the garbage collector\ncan be built in, or you can do it yourself. And mostly in this class, we do\nstuff ourselves, so we know",
    "start": "2780790",
    "end": "2789020"
  },
  {
    "text": "how they work. So that even when you're doing\nit with built in, you know what's going on under\nthe covers.",
    "start": "2789020",
    "end": "2796470"
  },
  {
    "text": "So here's some terminology. The roots in garbage collection\nare the objects",
    "start": "2796470",
    "end": "2801660"
  },
  {
    "text": "that are directly accessible\nby the program. And those typically are things\nlike globals, stacked",
    "start": "2801660",
    "end": "2806770"
  },
  {
    "text": "variables, and so forth. Things that the program can\ndirectly address by name.",
    "start": "2806770",
    "end": "2813830"
  },
  {
    "text": "The live objects are reachable\nfrom the roots by following pointers, and the debt objects\nare the ones that the",
    "start": "2813830",
    "end": "2820890"
  },
  {
    "text": "programmer can never\nget to again. And so what we're interested in\ndoing in garbage collection",
    "start": "2820890",
    "end": "2828180"
  },
  {
    "text": "is finding all the dead objects\nand recycling them so we can use them again, so that\nthey don't end up taking up",
    "start": "2828180",
    "end": "2835060"
  },
  {
    "text": "space in our virtual memory and\nslowing us down by making our virtual memory space\ncontinue to grow and grow and",
    "start": "2835060",
    "end": "2842140"
  },
  {
    "text": "grow across many disk pages. So one of the questions, in\norder for one to be able to do",
    "start": "2842140",
    "end": "2853220"
  },
  {
    "start": "2846000",
    "end": "2941000"
  },
  {
    "text": "garbage collection, is\nhow do I know where pointers are in objects?",
    "start": "2853220",
    "end": "2859080"
  },
  {
    "text": "How do I know what's\naccessible? And so typically, in order to\ndo that, you have to have a",
    "start": "2859080",
    "end": "2864589"
  },
  {
    "text": "very strong idea of where is a\npointer and where is data? Because you don't want to\nfollow data as if it's a",
    "start": "2864590",
    "end": "2870630"
  },
  {
    "text": "pointer, you want to know which\nregions of a given block of memory are pointers.",
    "start": "2870630",
    "end": "2876090"
  },
  {
    "text": "And so strong typing helps a\nlot with that, which is why mostly people do garbage\ncollection in strongly typed",
    "start": "2876090",
    "end": "2882540"
  },
  {
    "text": "languages, because then you\ncan actually identify it. It also requires you to prohibit\npointer arithmetic.",
    "start": "2882540",
    "end": "2890040"
  },
  {
    "text": "So the ability to take a pointer\nand then index off that pointer means I can get to\nsome piece of storage that",
    "start": "2890040",
    "end": "2896000"
  },
  {
    "text": "I can't access directly. And so typically in these kinds\nof systems, pointer arithmetic is illegal.",
    "start": "2896000",
    "end": "2903940"
  },
  {
    "text": "So you can do array indexing, as\nlong as you treat the array as a single object.",
    "start": "2903940",
    "end": "2909310"
  },
  {
    "text": "You can't treat an array as\nthe component pieces. You have to treat it\nas a single object.",
    "start": "2909310",
    "end": "2916070"
  },
  {
    "text": "So pointer arithmetic. Well, you folks, who's\nfamiliar with pointer arithmetic?",
    "start": "2916070",
    "end": "2921420"
  },
  {
    "text": "At this point, almost all of\nyou have done stuff with pointer arithmetic, if your\ncode is any good.",
    "start": "2921420",
    "end": "2927770"
  },
  {
    "text": "Almost all of you have done\nadding to pointers in order to move through an array or what\nhave you as being somewhat",
    "start": "2927770",
    "end": "2934020"
  },
  {
    "text": "cheaper than doing an array\nindex every time. It saves you an extra memory\nreference, typically.",
    "start": "2934020",
    "end": "2942460"
  },
  {
    "start": "2941000",
    "end": "3225000"
  },
  {
    "text": "So that's one of their\nrestrictions when you want to do garbage collection in\na general setting.",
    "start": "2942460",
    "end": "2948530"
  },
  {
    "text": "Now probably the simplest\nand most useful one as a programmer to use for garbage\ncollection is what's called",
    "start": "2948530",
    "end": "2955150"
  },
  {
    "text": "reference counting. I know many, many programs where\nwhat you do is you do reference counting\nbecause you can.",
    "start": "2955150",
    "end": "2963130"
  },
  {
    "text": "But as you'll see, it\nhas a limitation. So the idea in reference\ncounting is to keep a count of",
    "start": "2963130",
    "end": "2968950"
  },
  {
    "text": "the number of pointers\nreferencing each object. So here we have a whole bunch\nof different objects of different sizes, and whenever\nthere's a pointer going to the",
    "start": "2968950",
    "end": "2976630"
  },
  {
    "text": "object, I add one to the\nreference count shown in green at the top here. I hope I got the count right.",
    "start": "2976630",
    "end": "2984760"
  },
  {
    "text": "Whenever the count drops to\nzero, you free the object.",
    "start": "2984760",
    "end": "2990820"
  },
  {
    "text": "That means nobody's pointing\nto this object [UNINTELLIGIBLE]. Let's free it. So let's see how that goes.",
    "start": "2990820",
    "end": "2996470"
  },
  {
    "text": "So suppose that, for example,\nthat pointer got moved to over here. Went away from there,\ngot moved to there.",
    "start": "2996470",
    "end": "3002750"
  },
  {
    "text": "Well, now there are two fields\nthat have to be updated. The one that we took the pointer\naway from and the one",
    "start": "3002750",
    "end": "3008140"
  },
  {
    "text": "that we put it to. So we update those. Oops, that guy went to zero.",
    "start": "3008140",
    "end": "3013410"
  },
  {
    "text": "That means this stuff\nis garbage. But I can't just immediately\ngo and collect",
    "start": "3013410",
    "end": "3018470"
  },
  {
    "text": "that piece of storage. Why not?  AUDIENCE: To save the value of\nthe pointer, and [INAUDIBLE]",
    "start": "3018470",
    "end": "3025932"
  },
  {
    "text": "pointer later? CHARLES LEISERSON:\nYeah, to save the value of the pointer-- AUDIENCE: To save the value of\nthe pointer and then use it",
    "start": "3025932",
    "end": "3031015"
  },
  {
    "text": "again later. The pointer isn't there,\nbut you know where-- CHARLES LEISERSON: Not\nquite, not quite.",
    "start": "3031015",
    "end": "3037022"
  },
  {
    "text": "Yes? AUDIENCE: [INAUDIBLE] the reference counts for\n[INAUDIBLE], and also-- CHARLES LEISERSON: Yeah. If you're going to deallocate\nthis guy, he's got pointers.",
    "start": "3037022",
    "end": "3045490"
  },
  {
    "text": "They have to follow his pointers\nand see which ones need to be deallocated.",
    "start": "3045490",
    "end": "3050690"
  },
  {
    "text": "Good. So this guy now, we realize,\nis garbage. But before we can just free him,\nI've got to deallocate",
    "start": "3050690",
    "end": "3059000"
  },
  {
    "text": "these pointers. So this guy also got\ndecremented, but he didn't. So this guy, we have to\ndecrement these two fields,",
    "start": "3059000",
    "end": "3068150"
  },
  {
    "text": "because we took away those\npointers because we're going to garbage collect that. And when we do that, it turns\nout this thing turns to",
    "start": "3068150",
    "end": "3074380"
  },
  {
    "text": "garbage, as well. So when you do reference\ncounting, you have to make",
    "start": "3074380",
    "end": "3079960"
  },
  {
    "text": "sure that when you decrement\nthings and decide you're going to free something, you also then\ngo through and free the",
    "start": "3079960",
    "end": "3086740"
  },
  {
    "text": "things, and you continue that\nprocess until everything that has been deallocated\ncan be deallocated.",
    "start": "3086740",
    "end": "3095880"
  },
  {
    "text": "And then this becomes\nrecyclable, put back into the storage, into your free list or\nwhatever scheme you have.",
    "start": "3095880",
    "end": "3103310"
  },
  {
    "text": "So this is a very simple way,\nwhen you're implementing data structures, of building your\nown dynamic storage.",
    "start": "3103310",
    "end": "3110069"
  },
  {
    "text": "Because you basically can\nallocate stuff, you can free it, and whenever the reference\ncount goes to 0, boom.",
    "start": "3110070",
    "end": "3118230"
  },
  {
    "text": "You just have it deallocated. OK? But you can program that\nyourself [INAUDIBLE].",
    "start": "3118230",
    "end": "3125590"
  },
  {
    "text": "Now there's a problem with\nthe scheme, though. What's the problem? Cycles.",
    "start": "3125590",
    "end": "3131170"
  },
  {
    "text": "Yeah, cycles are the problem\nfor reference counting. So here's an example. The problem is that a cycle is\nnever garbage collected.",
    "start": "3131170",
    "end": "3138890"
  },
  {
    "text": "Let's take a look at this\nstructure here. So everybody's got a pointer\nfrom somewhere, but it turns",
    "start": "3138890",
    "end": "3145640"
  },
  {
    "text": "out that there's a cycle here\nwhere, notice that they are",
    "start": "3145640",
    "end": "3153950"
  },
  {
    "text": "pointing to each other, we even\nhave a guy coming off here, but nothing points\ninto the cycle.",
    "start": "3153950",
    "end": "3159870"
  },
  {
    "text": "So there's no way that, from the\nroots, I can ever access these four guys.",
    "start": "3159870",
    "end": "3164980"
  },
  {
    "text": "They're garbage, but my\nreference counting scheme will never find it, because no one's\never going to decrement",
    "start": "3164980",
    "end": "3175220"
  },
  {
    "text": "one of those counters here. So those are all garbage,\nbut how would I know?",
    "start": "3175220",
    "end": "3181060"
  },
  {
    "text": "And that's basically\nthe disadvantage of reference counting.",
    "start": "3181060",
    "end": "3188420"
  },
  {
    "text": "And uncollected garbage,\nas we all know, stinks.",
    "start": "3188420",
    "end": "3193859"
  },
  {
    "text": "So we don't want that\nsituation to occur. So nevertheless, reference\ncounting is great if you've",
    "start": "3193860",
    "end": "3201859"
  },
  {
    "text": "got an acyclic structure. And the number of times acyclic\nstructures come up",
    "start": "3201860",
    "end": "3208069"
  },
  {
    "text": "where reference counting is the\nsimple and easy way to do the storage management is huge\nwhen you get into doing any",
    "start": "3208070",
    "end": "3215540"
  },
  {
    "text": "kind of interesting\nprogramming. Lots and lots of opportunity\nto use reference counting approach.",
    "start": "3215540",
    "end": "3221840"
  },
  {
    "text": "So questions about reference\ncounting? ",
    "start": "3221840",
    "end": "3227230"
  },
  {
    "start": "3225000",
    "end": "3384000"
  },
  {
    "text": "You have a question? Yeah? AUDIENCE: So this means you\nactually have to do this [UNINTELLIGIBLE] ever do a [INAUDIBLE]?",
    "start": "3227230",
    "end": "3233120"
  },
  {
    "text": "You can, like, save the work-- CHARLES LEISERSON:\nThat's right. Whenever you move a pointer,\nif you're going to move a",
    "start": "3233120",
    "end": "3238380"
  },
  {
    "text": "pointer, you first decrement\nthe counter on the place you're moving it from, and then\ngarbage collect if need",
    "start": "3238380",
    "end": "3244819"
  },
  {
    "text": "be, and then you move\nthe pointer-- that's typically what you do--\nyou move the pointer and",
    "start": "3244820",
    "end": "3249930"
  },
  {
    "text": "increment the count at that\nlocation, which typically",
    "start": "3249930",
    "end": "3256390"
  },
  {
    "text": "doesn't require any extra work\nto decrement, which is the trick thing. Sorry? AUDIENCE: There's no good way\nto do this in idle time.",
    "start": "3256390",
    "end": "3262722"
  },
  {
    "text": "Like I'll have some idle time\nlater, let me do it-- CHARLES LEISERSON: So that's\nwhat you use true garbage",
    "start": "3262722",
    "end": "3268520"
  },
  {
    "text": "collection for Yeah? ",
    "start": "3268520",
    "end": "3273790"
  },
  {
    "text": "AUDIENCE: You could actually,\nthere's techniques where you can defer the work of\nincrementing it. Like you basically put the\nincrement and decrement",
    "start": "3273790",
    "end": "3280390"
  },
  {
    "text": "operations that you'd like to do\ninto a buffer, and then you can do them later. But it's sort of the same.",
    "start": "3280390",
    "end": "3286230"
  },
  {
    "text": "CHARLES LEISERSON: Yeah,\nyou could log. So there are schemes where you\nlog that, oh, I decremented this, better check it\nlater, type thing.",
    "start": "3286230",
    "end": "3292590"
  },
  {
    "text": "Or I decrement it to 0. Let me just put it in there,\nand I'll go actually do the stuff in batch mode at\nsome later time.",
    "start": "3292590",
    "end": "3300460"
  },
  {
    "text": "Yep. So programming is fun, because\nyou can be clever with schemes like that.",
    "start": "3300460",
    "end": "3307020"
  },
  {
    "text": "And that could be quite a\nreasonable thing to do, which is wait until you're waiting on\nthe user for input, and at",
    "start": "3307020",
    "end": "3313369"
  },
  {
    "text": "that point, collect\nyour garbage. Now, the thing you have to risk\nis, what happens if that takes a long time\nto get there?",
    "start": "3313370",
    "end": "3320690"
  },
  {
    "text": "And then there's the complexity\nof your algorithms",
    "start": "3320690",
    "end": "3327349"
  },
  {
    "text": "and so forth. So you get into a lot of issues\nof software maintenance and so forth.",
    "start": "3327350",
    "end": "3332460"
  },
  {
    "text": "But that can be a very effective\nthing, is take it out of the critical path of the\nactual complication you're doing, if that's mission\ncritical, and put it in some",
    "start": "3332460",
    "end": "3340390"
  },
  {
    "text": "part of the computation where\nit isn't mission critical. Very good idea. ",
    "start": "3340390",
    "end": "3346875"
  },
  {
    "text": "I'm sorry? AUDIENCE: For thread safety. ",
    "start": "3346875",
    "end": "3351890"
  },
  {
    "text": "Like if you have shared\nreference accounts, like multiple threads updating the\ncounts, you don't want to have",
    "start": "3351890",
    "end": "3358600"
  },
  {
    "text": "them all in the same count\nat the same time. So they fill it like a thread\nlocal buffer, and--",
    "start": "3358600",
    "end": "3364160"
  },
  {
    "text": "CHARLES LEISERSON: I see\nwhat you're saying. Yes. So we're going to get into\nthat as we deal with multi-threading and so forth,\nthat if you've got two guys",
    "start": "3364160",
    "end": "3370780"
  },
  {
    "text": "that are operating on the same\ndata structure, you have to be very careful about the\nconsistency, and that one doesn't do something while the\nother is doing something else,",
    "start": "3370780",
    "end": "3377500"
  },
  {
    "text": "and so forth. So for that reason,\nit can be a good idea to postpone operation. ",
    "start": "3377500",
    "end": "3385089"
  },
  {
    "start": "3384000",
    "end": "3599000"
  },
  {
    "text": "So general garbage collection\nis based on a graph abstraction. So let's move into\nthe graph world.",
    "start": "3385090",
    "end": "3393080"
  },
  {
    "text": "So I can view objects and\npointers as forming a directed graph G equals VE, where V are\nthe objects and E are the",
    "start": "3393080",
    "end": "3400480"
  },
  {
    "text": "pointers from one object\nto another.  The live objects are reachable\nfrom the roots.",
    "start": "3400480",
    "end": "3408560"
  },
  {
    "text": "And now the thing is that\nfinding all of the live objects is then like doing\na graph search.",
    "start": "3408560",
    "end": "3417270"
  },
  {
    "text": "The common ways of doing a graph\nsearch are depth for search and breadth-first\nsearch.",
    "start": "3417270",
    "end": "3423080"
  },
  {
    "text": "It turns out we're going to use\nbreadth-first search for reasons that I'll show you.",
    "start": "3423080",
    "end": "3428660"
  },
  {
    "text": "So the idea in breadth-first\nsearch, to find all the objects. So the idea is, what we're going\nto do is go through and",
    "start": "3428660",
    "end": "3434740"
  },
  {
    "text": "find, where are all the objects\nin my system that are reachable from the root?",
    "start": "3434740",
    "end": "3439760"
  },
  {
    "text": "And then anything that\nI didn't find, ah. That must be garbage.",
    "start": "3439760",
    "end": "3447540"
  },
  {
    "text": "So here's the idea. What we're going to use is FIFO\nqueue called Q. So that's",
    "start": "3447540",
    "end": "3454600"
  },
  {
    "text": "a first in, first out. It has a head and a tail. And the mechanism is very\nmuch like a stack.",
    "start": "3454600",
    "end": "3461840"
  },
  {
    "text": "Whenever I need to enqueue\nsomething, I put it on the tail end and increment\nthe tail pointer.",
    "start": "3461840",
    "end": "3468000"
  },
  {
    "text": "Whenever I need to take\nsomething off the queue, I increment the head pointer. ",
    "start": "3468000",
    "end": "3474290"
  },
  {
    "text": "So I'm always doing head and\ntail, pushing on the tail and",
    "start": "3474290",
    "end": "3479800"
  },
  {
    "text": "pulling off the head. Enqueue and dequeue. So the way that this works is,\nI basically go through all my",
    "start": "3479800",
    "end": "3487340"
  },
  {
    "text": "objects, and if they're a route,\nI put a mark on it.",
    "start": "3487340",
    "end": "3493000"
  },
  {
    "text": "And I enqueue-- this is pseudocode, by the way,\nso don't hold me to my C",
    "start": "3493000",
    "end": "3498320"
  },
  {
    "text": "programming standard here. And I market, and then I enqueue\nit on the queue Q. And",
    "start": "3498320",
    "end": "3506600"
  },
  {
    "text": "otherwise, I just simply\nmark it as zero. So being marked means whether\nwe've discovered it's",
    "start": "3506600",
    "end": "3513030"
  },
  {
    "text": "reachable from a route. So to begin with, what we're\ngoing to do is mark everything that's reachable from the\nroutes, and we're going to",
    "start": "3513030",
    "end": "3522000"
  },
  {
    "text": "enqueue them on the FIFO. And everything else, we're\ngoing to mark as unreachable, for now.",
    "start": "3522000",
    "end": "3528550"
  },
  {
    "text": "And now what we're going to do\nis see which ones we discover. So what we do is, while the\nqueue is non-empty, we're",
    "start": "3528550",
    "end": "3536930"
  },
  {
    "text": "going to take something off of\nthe queue and then look at all of its neighbors.",
    "start": "3536930",
    "end": "3542520"
  },
  {
    "text": "So all the edges UV, look at all\nthe things that go from U to V And if it's not marked,\nthen we're going to mark it",
    "start": "3542520",
    "end": "3551440"
  },
  {
    "text": "and put it on the queue. That's it. If it's already marked, we don't\nhave to do anything with",
    "start": "3551440",
    "end": "3557530"
  },
  {
    "text": "it, but if it's unmarked,\nwe'll mark it and do it. And then in the end, everything\nthat's marked is",
    "start": "3557530",
    "end": "3563910"
  },
  {
    "text": "going to be something that is\nlive, and everything that is",
    "start": "3563910",
    "end": "3569039"
  },
  {
    "text": "unmarked is going to be\nthings that are dead. But it's going to be actually\neven sexier and more clever",
    "start": "3569040",
    "end": "3575480"
  },
  {
    "text": "than that, as you'll see. So here's an example.",
    "start": "3575480",
    "end": "3580520"
  },
  {
    "text": "We start out with my queue being\nempty, with head and tail pointing to\nthe same place. And what we do, is we go through\nand we first-- in this",
    "start": "3580520",
    "end": "3587000"
  },
  {
    "text": "case, I have just one\nroute R, right here. So we basically mark R\nand put it on, and",
    "start": "3587000",
    "end": "3593780"
  },
  {
    "text": "that's how we get started. And everything else is\nunmarked up here. So I'm going to mark with green\nup here, and I'm going",
    "start": "3593780",
    "end": "3599720"
  },
  {
    "text": "to show what's on the queue with\nthe green down here, and dark green when I pop\nsomething off.",
    "start": "3599720",
    "end": "3606509"
  },
  {
    "text": "So the first thing I\ndo is I say, OK. Let me dequeue something. And in this case, I'm dequeueing\nR, because it's the",
    "start": "3606510",
    "end": "3613900"
  },
  {
    "text": "only thing on there. And what I do now is I visit\nall the neighbors. So I visit b, so I put that on,\nmark it and put that on,",
    "start": "3613900",
    "end": "3622340"
  },
  {
    "text": "and then I visit c, so I\nvisit and put that on. ",
    "start": "3622340",
    "end": "3628329"
  },
  {
    "text": "Then I'm done with R. I visited\nall its neighbors. So then I go and I dequeue\nB, and now",
    "start": "3628330",
    "end": "3637390"
  },
  {
    "text": "visit all its neighbors. Well, in [? visit ?] c, there's\nnothing to be done there, because c is\nalready marked.",
    "start": "3637390",
    "end": "3643230"
  },
  {
    "text": "So I don't enqueue it again. I already have observed that. And there's nothing else\nadjacent to b, so basically, I",
    "start": "3643230",
    "end": "3655500"
  },
  {
    "text": "then go on and dequeue c. So I have c here, and now we go\nvisit its neighbours, and",
    "start": "3655500",
    "end": "3662380"
  },
  {
    "text": "the neighbors are d and e. So we enqueue d, enqueue e, and\nnow we are done dequeuing",
    "start": "3662380",
    "end": "3671980"
  },
  {
    "text": "all his neighbors and marking\nthem, so now we pop off d. And now d has no neighbors, so\nthere's nothing to be done.",
    "start": "3671980",
    "end": "3679510"
  },
  {
    "text": "And now I dequeue e, and\nbasically, e has one neighbor f, so we mark f.",
    "start": "3679510",
    "end": "3687640"
  },
  {
    "text": "Then we dequeue f, we mark g,\nthen we dequeue g, and g has--",
    "start": "3687640",
    "end": "3694539"
  },
  {
    "text": "the only neighbor is e. And now my queue is empty,\nand so I'm done.",
    "start": "3694540",
    "end": "3703329"
  },
  {
    "text": "And now you'll see,\nwhat did I do? I marked all the things that\nwere reachable from r, and everything else is garbage.",
    "start": "3703330",
    "end": "3711470"
  },
  {
    "text": "Now, that's only\nhalf the story. So I've marked them, but more\nrelevantly, it turns out for",
    "start": "3711470",
    "end": "3717720"
  },
  {
    "text": "garbage collection, is look at\nwhat I've got in my queue. What do I have in my queue?",
    "start": "3717720",
    "end": "3724319"
  },
  {
    "text": "I've got all the live objects,\ngot put in the queue as we",
    "start": "3724320",
    "end": "3731100"
  },
  {
    "text": "were going along. All the live objects are\nput in the queue. And not only that, but notice\nthey're all adjacent to each",
    "start": "3731100",
    "end": "3738040"
  },
  {
    "text": "other in the queue. They're compact in the queue. ",
    "start": "3738040",
    "end": "3745069"
  },
  {
    "text": "And so the idea is, we're going\nto take advantage of that property. That when I do breadth-first\nsearch, that the queue, when",
    "start": "3745070",
    "end": "3750440"
  },
  {
    "text": "I'm done, I put every\nobject in there. So all the live vertices\nare placed in",
    "start": "3750440",
    "end": "3756430"
  },
  {
    "text": "contiguous storage in queue.  So this is the principle behind\nthe copying garbage",
    "start": "3756430",
    "end": "3763680"
  },
  {
    "text": "collector, which is one of\nthe more popular garbage collectors that's used.",
    "start": "3763680",
    "end": "3769540"
  },
  {
    "text": "The idea is that as I'm\nexecuting, I'm going to have some live objects and some dead\nobjects, and I'm going to",
    "start": "3769540",
    "end": "3781630"
  },
  {
    "text": "have some place that I'm doing\nmy next allocation at. And as I go through, I allocate\nmore things in what's",
    "start": "3781630",
    "end": "3791410"
  },
  {
    "text": "called the from space, and I\nkeep allocating, and I may do a deallocation, and maybe some\nmore allocation, and maybe",
    "start": "3791410",
    "end": "3799590"
  },
  {
    "text": "another deallocation, and some\nmore allocation, and eventually I run out of my\nmemory that I've assigned for",
    "start": "3799590",
    "end": "3812140"
  },
  {
    "text": "my heap storage. So when I get to this point, now\nwhat I do is I'm going to",
    "start": "3812140",
    "end": "3817440"
  },
  {
    "text": "do breadth-first search\non the from space.",
    "start": "3817440",
    "end": "3823119"
  },
  {
    "text": "And what I'm going to do is I'm\ngoing to copy using the live storage here, using\n[UNINTELLIGIBLE] to a TO",
    "start": "3823120",
    "end": "3829670"
  },
  {
    "text": "space, where the TO space\nimplements the FIFO queue.",
    "start": "3829670",
    "end": "3836599"
  },
  {
    "text": "So here's the TO space, and when\nI go through and I walk all that, I've now copied all\nof the values, all of the",
    "start": "3836600",
    "end": "3843250"
  },
  {
    "text": "objects down to this\nspace over here. And now I have this amount\nof storage left.",
    "start": "3843250",
    "end": "3848390"
  },
  {
    "text": "I make the two space\nexactly the same size as the from space. I have to make it at least that\nbig, because I know that",
    "start": "3848390",
    "end": "3856000"
  },
  {
    "text": "it may be that everything\nhere is alive. Maybe nothing got deallocated. So I have to make sure that the\nTO space is large enough",
    "start": "3856000",
    "end": "3863490"
  },
  {
    "text": "to handle everything that might\nbe alive there, and it may be everything. So the TO space is generally\nallocated to be exactly the",
    "start": "3863490",
    "end": "3870700"
  },
  {
    "text": "same size as the FROM space.  So basically, the way I\ncompacted is I copied things",
    "start": "3870700",
    "end": "3878140"
  },
  {
    "text": "down using the breadth-first\nsearch algorithm.  Now there's one problem with\nthis, and that is that we have",
    "start": "3878140",
    "end": "3886650"
  },
  {
    "text": "pointers in these objects. And when I copy it down here,\nhow did I make sure that all",
    "start": "3886650",
    "end": "3894119"
  },
  {
    "text": "the pointers now point\nto the new locations? So here's how you do that.",
    "start": "3894120",
    "end": "3900010"
  },
  {
    "text": "So since the FROM address of\nthe object is not generally equal to the TO address,\npointers must be updated.",
    "start": "3900010",
    "end": "3906980"
  },
  {
    "text": "So I have to know, of course,\nwhere the pointers are. So the idea is that when an\nobject is copied to the TO",
    "start": "3906980",
    "end": "3912100"
  },
  {
    "text": "space, what we're going to do\nin FROM space is store a forwarding pointer in\nFROM space saying,",
    "start": "3912100",
    "end": "3919010"
  },
  {
    "text": "I copy you to here.  So that whenever I look at\nsomething in the FROM space",
    "start": "3919010",
    "end": "3925540"
  },
  {
    "text": "that's already been copied, I\ncan say, oh, here's where it's been copied to.",
    "start": "3925540",
    "end": "3930805"
  },
  {
    "text": "It's been copied to this\nregion in the TO space. When an object is removed from\nthe FIFO queue in the TO",
    "start": "3930805",
    "end": "3938890"
  },
  {
    "text": "space, we're going to update\nall its pointers. I'm going to give you\nan example of this. ",
    "start": "3938890",
    "end": "3947580"
  },
  {
    "text": "So if you think about it, when\nI remove something from the FIFO queue, at that point, I\nknow all of its adjacent",
    "start": "3947580",
    "end": "3956119"
  },
  {
    "text": "vertices have been placed into\nthe queue, into the TO space.",
    "start": "3956120",
    "end": "3963790"
  },
  {
    "text": "And so at that point, I know\nwhere all the final destinations of pointers are.",
    "start": "3963790",
    "end": "3969000"
  },
  {
    "text": "So here's an example. So suppose that I'm doing the\ncopy of these guys, and I've",
    "start": "3969000",
    "end": "3976930"
  },
  {
    "text": "got all the pointers around\nhere, and now some of these guys have already made it\ninto the FIFO queue.",
    "start": "3976930",
    "end": "3983420"
  },
  {
    "text": "Let's say this guy has made\nit in, because I've got forwarding pointer to there, and\nthis guy has made it in, so I've got forwarding\npointer to there.",
    "start": "3983420",
    "end": "3990080"
  },
  {
    "text": "And this is what my queue\ncurrently holds. So when I remove an item from\nthe queue, I then look at this",
    "start": "3990080",
    "end": "3997490"
  },
  {
    "text": "guy, and what I do is first\nof all, I visit all of the adjacent neighbors. So I visit this guy and I say,\noh, he's already been copied,",
    "start": "3997490",
    "end": "4005339"
  },
  {
    "text": "because I have a forwarding\npointer. So nothing to be done there. But this guy, he hasn't\nbeen copied yet.",
    "start": "4005340",
    "end": "4011640"
  },
  {
    "text": "So I have to make sure that\nthat guy is copied by enqueuing the adjacent\nvertices. So I copy my neighbor\nto there.",
    "start": "4011640",
    "end": "4022220"
  },
  {
    "text": "And part of copying is, if I'm\nactually making a copy, I'm going to have a pointer\nfrom here.",
    "start": "4022220",
    "end": "4028630"
  },
  {
    "text": "The pointer now has to point to\nthis guy over here, because that's how I'm copying.",
    "start": "4028630",
    "end": "4035140"
  },
  {
    "text": "Otherwise it isn't a copy. So in the copy, this pointer\nis the same as that one, is",
    "start": "4035140",
    "end": "4040780"
  },
  {
    "text": "pointing to the same storage\nlocation, namely this place over here. So I do that for all my\nadjacent vertices.",
    "start": "4040780",
    "end": "4049170"
  },
  {
    "text": "People follow so far? Now I've copied all of the\nneighbors for this guy.",
    "start": "4049170",
    "end": "4055760"
  },
  {
    "text": "Now this guy, all of his\nneighbors are in their final destinations in the TO space.",
    "start": "4055760",
    "end": "4063070"
  },
  {
    "text": "So that means I can now update\nthese pointers to be the pointers in the TO space.",
    "start": "4063070",
    "end": "4068310"
  },
  {
    "text": "So I do that as follows. Oh, first of all, I forgot to\nplace the forwarding pointer",
    "start": "4068310",
    "end": "4074310"
  },
  {
    "text": "here to indicate that\nhe's been copied. That's how I'm doing\nthe marks. Sorry about that.",
    "start": "4074310",
    "end": "4080540"
  },
  {
    "text": "So I copied the values, and\nthat's just a straight copy, because all the pointer\nvalues are now pointing into this space.",
    "start": "4080540",
    "end": "4088130"
  },
  {
    "text": "Then I put a forwarding\npointer in. Now I'm ready to do the update\nof the pointers here.",
    "start": "4088130",
    "end": "4095040"
  },
  {
    "text": "So I update the pointers\nto the removed item. So here's one pointer. I get rid of him there and\nI make him point to the",
    "start": "4095040",
    "end": "4101140"
  },
  {
    "text": "forwarding thing. He used to point to here, now\nhe's pointing to here. This one used to point to\nhere, I want to make",
    "start": "4101140",
    "end": "4107568"
  },
  {
    "text": "him point to there. ",
    "start": "4107569",
    "end": "4113399"
  },
  {
    "text": "There we go. So now he's pointing here. And now this guy here now has\nhis pointers to his final",
    "start": "4113399",
    "end": "4120979"
  },
  {
    "text": "destinations. And so the invariance that I'm\nmaintaining is that everything before the head of the queue all\nhave their final pointers",
    "start": "4120979",
    "end": "4132630"
  },
  {
    "text": "in place in the TO space. Question? AUDIENCE: So do you know where\nto put the pointers--",
    "start": "4132630",
    "end": "4139118"
  },
  {
    "text": "how do [UNINTELLIGIBLE] pointers\ngo from the TO space to the TO space so that they're\nactually getting to",
    "start": "4139119",
    "end": "4144882"
  },
  {
    "text": "their final destination? So my question is,\n[UNINTELLIGIBLE] by following [UNINTELLIGIBLE]. ",
    "start": "4144883",
    "end": "4153000"
  },
  {
    "text": "But how do you know what\npointer to follow? How do you know that\n[INAUDIBLE]? CHARLES LEISERSON: If I have a\npointer to something in the",
    "start": "4153000",
    "end": "4159380"
  },
  {
    "text": "FROM space, then I update it to\nbe the forwarding pointer in the TO space.",
    "start": "4159380",
    "end": "4165195"
  },
  {
    "text": "AUDIENCE: Yeah, the question\nis, how do you know that [INAUDIBLE] it's being pointed\nto [? the ?] actually in the TO space?",
    "start": "4165196",
    "end": "4171607"
  },
  {
    "text": "Can you check, is this\nin the TO space? CHARLES LEISERSON: Well, yeah. I mean, you know what the range\nof the two spaces is, so you could check that.",
    "start": "4171607",
    "end": "4177240"
  },
  {
    "text": " OK. Question? AUDIENCE: So the reason you\nwould be using [? BFS ?]",
    "start": "4177240",
    "end": "4182321"
  },
  {
    "text": "instead of [? DFS ?] is\nbecause [INAUDIBLE]. ",
    "start": "4182322",
    "end": "4187409"
  },
  {
    "text": "CHARLES LEISERSON: The reason\nyou're using BFS is because it has this nice property that\nthe queue represents the copying of all the values.",
    "start": "4187410",
    "end": "4193390"
  },
  {
    "text": "If I use DFS, I need a stack\nto do it, and then I'm overwriting the locations where\nthe vertices would be",
    "start": "4193390",
    "end": "4201710"
  },
  {
    "text": "stored in the data structure. By using DFS, there's this just\nclever thing that the",
    "start": "4201710",
    "end": "4208239"
  },
  {
    "text": "queue, when I'm done with\nDFS, represents all of the visited vertices.",
    "start": "4208240",
    "end": "4213550"
  },
  {
    "text": "It's very clever. Wish I'd thought of that. But I was, I think, only 10\nyears old or something when",
    "start": "4213550",
    "end": "4219520"
  },
  {
    "text": "they invented this, and I\nwasn't that precocious. ",
    "start": "4219520",
    "end": "4226390"
  },
  {
    "text": "OK? So very, very clever. So this is the scheme behind\nthe Minsky, Fenichel,",
    "start": "4226390",
    "end": "4235340"
  },
  {
    "text": "Yochelson garbage collector. So Marvin Minsky, you may have\nheard of, was one of the inventors of a scheme\nlike this.",
    "start": "4235340",
    "end": "4244020"
  },
  {
    "text": "One reason he's so famous.  Good. So this is really nice, because\nit takes me linear",
    "start": "4244020",
    "end": "4251670"
  },
  {
    "text": "time to copy and update\nall of the vertices. It's just one pass of\nbreadth-first search.",
    "start": "4251670",
    "end": "4257800"
  },
  {
    "text": "Very fast to copy and update\nall the vertices. Sometimes, by the way, people\ncall these forwarding",
    "start": "4257800",
    "end": "4262840"
  },
  {
    "text": "pointers, they call them\nbroken hearts. You'll see that in\nthe literature. They call them a broken\nheart if it's--",
    "start": "4262840",
    "end": "4269400"
  },
  {
    "text": "I don't quite remember\nwhy that's the-- it's like, I went there,\noh, you're not",
    "start": "4269400",
    "end": "4275580"
  },
  {
    "text": "there, it's over there-- it's like, I don't know.  Now, the last thing you have to\ndo-- and this is something",
    "start": "4275580",
    "end": "4283980"
  },
  {
    "text": "that's not talked about a\nlot in the literature-- is how do you manage\nthese from and to",
    "start": "4283980",
    "end": "4289460"
  },
  {
    "text": "spaces in virtual memory? So here's the strategy\nthat works well.",
    "start": "4289460",
    "end": "4297440"
  },
  {
    "text": "So basically, typically what I'm\ndoing is after I've done a copy, I've emptied everything\nout of the FROM space, and",
    "start": "4297440",
    "end": "4305130"
  },
  {
    "text": "I've got a portion that's used\nin the TO space, and then an unused portion that I'm going\nto be able to do allocations",
    "start": "4305130",
    "end": "4312500"
  },
  {
    "text": "out of for the next\npass around. So what I do at that point\nis I make the old TO",
    "start": "4312500",
    "end": "4319580"
  },
  {
    "text": "become the new FROM. So here's the new FROM. This is available space.",
    "start": "4319580",
    "end": "4324739"
  },
  {
    "text": "And now what I do is I extend\nthis space, if necessary, to make the new heap space that I'm\ngoing to allocate out of",
    "start": "4324740",
    "end": "4332230"
  },
  {
    "text": "equal in size to\nthe used space. And the reason for doing this\nis to amortize the cost of",
    "start": "4332230",
    "end": "4338980"
  },
  {
    "text": "going through all of the\nstorage, so that the cost of going the garbage question\ncan be amortized",
    "start": "4338980",
    "end": "4345660"
  },
  {
    "text": "against what's used. If I didn't extend this, I might\nhave only freed up a tiny little bit of space, and\nnow when I run out of that",
    "start": "4345660",
    "end": "4353170"
  },
  {
    "text": "space, I'll run the garbage\ncollector going over all the elements, but I'll only have\ngotten a few elements",
    "start": "4353170",
    "end": "4359630"
  },
  {
    "text": "[INAUDIBLE]. So what I want to do is make\nsure that I've done at least a certain number of allocations\nproportional to the number",
    "start": "4359630",
    "end": "4365300"
  },
  {
    "text": "that I'm going to have to walk\nover in order to finish it. So that's why you make this\nbe the same size.",
    "start": "4365300",
    "end": "4370630"
  },
  {
    "text": "Now when the space runs out, the\nnew TO is allocated with the same size as FROM.",
    "start": "4370630",
    "end": "4377580"
  },
  {
    "text": "So if you can allocate it back\nin the old FROM space here,",
    "start": "4377580",
    "end": "4383360"
  },
  {
    "text": "that's great. If there's room here\nto allocate it at the front, super. That's where you allocate it.",
    "start": "4383360",
    "end": "4388599"
  },
  {
    "text": "But as in this example, the FROM\nspace here is bigger than the space that goes\nup to here.",
    "start": "4388600",
    "end": "4394770"
  },
  {
    "text": "So therefore what I do is I\nallocate it at the end, and then I go through and\ncopy to here.",
    "start": "4394770",
    "end": "4402600"
  },
  {
    "text": "Now if this ended up being\nused, then the next time around, I would be able to reuse\nthis space at the front",
    "start": "4402600",
    "end": "4410400"
  },
  {
    "text": "for the next time that I flip\nthe garbage collection. The idea is, if things will\nfit as early in memory as",
    "start": "4410400",
    "end": "4418219"
  },
  {
    "text": "possible, that's where\nI put them. But if they don't fit,\nI put them later. And you can prove, if you do\nthis, that the virtual memory",
    "start": "4418220",
    "end": "4424420"
  },
  {
    "text": "space used is order 1 times\nthe optimal, where you're getting nearly the best virtual\nmemory space used",
    "start": "4424420",
    "end": "4431330"
  },
  {
    "text": "compared to the amount of items\nthat are in use by the user at any time.",
    "start": "4431330",
    "end": "4438460"
  },
  {
    "text": "So it keeps everything sort\nof compact towards the front end here. So in this case, I had\nto allocate to here.",
    "start": "4438460",
    "end": "4444360"
  },
  {
    "text": "If the use had been very small,\nI could have allocated just a very small amount\nfor the heap.",
    "start": "4444360",
    "end": "4449630"
  },
  {
    "text": "When I was done, the\nnew TO space would have fit at the beginning. I would have allocated\nit at the beginning.",
    "start": "4449630",
    "end": "4456380"
  },
  {
    "text": "And it's a nice little exercise,\nfor those of you who are analytically inclined, to\nfigure out what the constant",
    "start": "4456380",
    "end": "4463050"
  },
  {
    "text": "is here, because it's a little\nbit of a game to figure out what the amortized constant,\nfor those who have some",
    "start": "4463050",
    "end": "4470730"
  },
  {
    "text": "algorithmic energy and our\nconfident about working in",
    "start": "4470730",
    "end": "4477700"
  },
  {
    "text": "this kind of thing instead\nof studying for the quiz. ",
    "start": "4477700",
    "end": "4483460"
  },
  {
    "text": "So dynamic storage allocation. Hugely interesting area.",
    "start": "4483460",
    "end": "4488960"
  },
  {
    "text": "Lots is known and\nlots is unknown. For example, I mentioned\ncoalescing. We really don't understand\ncoalescing.",
    "start": "4488960",
    "end": "4494460"
  },
  {
    "text": "Disaster people have been doing\nit for 50 years or more. We do not understand\ncoalescing.",
    "start": "4494460",
    "end": "4501490"
  },
  {
    "text": "There are a lot of strategies\nthat people have studied, things like the buddy\nsystem, I mentioned. There are other types of garbage\ncollectors called mark",
    "start": "4501490",
    "end": "4509050"
  },
  {
    "text": "and sweep garbage collection. Those are typically inferior\nto the copying garbage collection, because they\nleave you with a",
    "start": "4509050",
    "end": "4519070"
  },
  {
    "text": "memory that isn't compact. And so you end up using more\nand more of your virtual",
    "start": "4519070",
    "end": "4524390"
  },
  {
    "text": "memory, because you're leaving\nthings in place. On the other hand, you leave\nthings in place so there's no",
    "start": "4524390",
    "end": "4529840"
  },
  {
    "text": "need to move pointers. So that can be a\nvaluable thing. There's things called\ngenerational garbage",
    "start": "4529840",
    "end": "4535620"
  },
  {
    "text": "collection. Generational garbage collectors\nrealize that things that are allocated typically\nare freed very soon",
    "start": "4535620",
    "end": "4543930"
  },
  {
    "text": "thereafter, and so therefore, if\nyou especially take care of the things that are allocated\nand guess that they're going",
    "start": "4543930",
    "end": "4551080"
  },
  {
    "text": "to be used again, and that\nthings that haven't been deallocated for a long time\nare very unlikely to be",
    "start": "4551080",
    "end": "4558980"
  },
  {
    "text": "allocated, you can get better\nperformance out of a garbage collector.",
    "start": "4558980",
    "end": "4564580"
  },
  {
    "text": "There's real time garbage\ncollection. So this is what I've explained,\nis what's called a stop and copy garbage\ncollector.",
    "start": "4564580",
    "end": "4571500"
  },
  {
    "text": "Meaning that when you run\nout of storage, oops! Stop the world, run the\ngarbage collector. There are real time garbage\ncollectors which, whenever you",
    "start": "4571500",
    "end": "4577880"
  },
  {
    "text": "do an allocation, it goes and\nit does a few cycles of garbage collection, and is such\nthat you can always keep",
    "start": "4577880",
    "end": "4586680"
  },
  {
    "text": "up with the allocations and\ndeallocations going on. By doing a few cycles, you\neventually get to garbage",
    "start": "4586680",
    "end": "4594070"
  },
  {
    "text": "collect everything, but you do\nit intermixed, so that you're slowing everything down by a\nconstant amount, rather than",
    "start": "4594070",
    "end": "4600140"
  },
  {
    "text": "running and suddenly, OK, your\nrobot arm is going like this, oops, garbage collect, garbage\ncollect, garbage collect,",
    "start": "4600140",
    "end": "4605276"
  },
  {
    "text": "[CREAKING SOUND]. So you can have your robot arm\nmove smoothly, because it's paying the price all the way.",
    "start": "4605276",
    "end": "4612080"
  },
  {
    "text": "It's not stopping and going. There is multi-threaded\nstorage allocation.",
    "start": "4612080",
    "end": "4617570"
  },
  {
    "text": "What happens when you have a\nmulti-threaded environment",
    "start": "4617570",
    "end": "4624389"
  },
  {
    "text": "where you have many processors\nthat are all allocating out of the same pool? How do they organize it?",
    "start": "4624390",
    "end": "4629790"
  },
  {
    "text": "You can have the interesting\nthings going there where things are allocated on one\nprocessor, and then get",
    "start": "4629790",
    "end": "4635989"
  },
  {
    "text": "deallocated on another. And if you're not careful, you\nhave something like a memory leak going on, which is called\nmemory drift, where the memory",
    "start": "4635990",
    "end": "4644420"
  },
  {
    "text": "gets allocated on one, and one\nguy's busy creating it, and it keeps getting deallocated on\nthe other, but never gets",
    "start": "4644420",
    "end": "4650360"
  },
  {
    "text": "recycled back to the\nguy who needs it. And so how is it that you figure\nout to make sure that",
    "start": "4650360",
    "end": "4656280"
  },
  {
    "text": "memory drift doesn't end up\nhaving you grow your memory? In fact, many, many garbage\ncollectors that are out there",
    "start": "4656280",
    "end": "4662580"
  },
  {
    "text": "have this memory drift problem\nfor multi-threaded storage allocation. There's also parallel\ngarbage collection.",
    "start": "4662580",
    "end": "4668739"
  },
  {
    "text": "How do you, in a parallel\nenvironment, have the garbage collector going on as a separate\nprocess while you",
    "start": "4668740",
    "end": "4674470"
  },
  {
    "text": "have other things going\non at the same time? So a huge, huge, huge\narea of storage.",
    "start": "4674470",
    "end": "4679960"
  },
  {
    "text": "And for our next lab, lab 3,\nyou'll be building your own",
    "start": "4679960",
    "end": "4685239"
  },
  {
    "text": "storage allocator. So you have a lot of\nfun with this. [? Reid ?] says this is\nhis favorite lab.",
    "start": "4685240",
    "end": "4690580"
  },
  {
    "text": " Great. Any questions? ",
    "start": "4690580",
    "end": "4697560"
  },
  {
    "text": "OK. Good luck on the\nquiz next time. ",
    "start": "4697560",
    "end": "4700885"
  }
]