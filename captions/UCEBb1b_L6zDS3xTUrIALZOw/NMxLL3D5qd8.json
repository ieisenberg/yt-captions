[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: All right,\nlet's get started.",
    "start": "18450",
    "end": "23500"
  },
  {
    "text": "So today, we start out geometry,\ngeometric data structures. There are two lectures on this.",
    "start": "23500",
    "end": "29679"
  },
  {
    "text": "This is lecture one. And we're going to solve\ntwo main problems today. One is point location, which\nis finding yourself on a map.",
    "start": "29680",
    "end": "36900"
  },
  {
    "text": "And the other is\northogonal range searching, which is catching a bunch of\ndots with a rectangular net.",
    "start": "36900",
    "end": "43280"
  },
  {
    "text": "And they're fun problems. And they're good illustrations\nof a couple of techniques.",
    "start": "43280",
    "end": "48420"
  },
  {
    "text": "We're going to cover two general\ntechniques for data structure building. One is dynamizing\nstatic data structures,",
    "start": "48420",
    "end": "54120"
  },
  {
    "text": "turning static into dynamic\nusing a technique called weight balance, which is really cool. And another one is called\nfractional cascading,",
    "start": "54120",
    "end": "60540"
  },
  {
    "text": "which has probably one\nof the coolest names of any algorithmic or\ndata structures technique. It's actually a very simple\nidea, but sounds very scary.",
    "start": "60540",
    "end": "67320"
  },
  {
    "text": " And with point\nlocation, we're going",
    "start": "67320",
    "end": "72470"
  },
  {
    "text": "to see some fun connections to\npersistence and retroactivity, which was the topic of the last\ntwo lectures, you may recall.",
    "start": "72470",
    "end": "78635"
  },
  {
    "text": "And so we'll start\nout with that.  Planar point location, you\ncan do it in higher dimensions",
    "start": "78635",
    "end": "87600"
  },
  {
    "text": "as well. In general, geometric\ndata structures are about going to more\nthan one dimension.",
    "start": "87600",
    "end": "92680"
  },
  {
    "text": "Most data structures are about\none dimensional ordered data. Now, we have points\nin the plane.",
    "start": "92680",
    "end": "99430"
  },
  {
    "text": "We might have\npolygons in the plane. So this is what we\ncall a planar map,",
    "start": "99430",
    "end": "108810"
  },
  {
    "text": "got a bunch of line\nsegments and points forming a graph structure. So think of it as a\nplanar graph drawn in the plane where every edge\nis a straight line segment.",
    "start": "108810",
    "end": "117060"
  },
  {
    "text": "And none of the edges\ncross, let's say. So this is a planar map.",
    "start": "117060",
    "end": "124335"
  },
  {
    "text": "It's also called a planar\nstraight line graph. And the static version\nof this problem--",
    "start": "124335",
    "end": "132010"
  },
  {
    "text": "so there's two versions,\none is static-- you want to preprocess the map.",
    "start": "132010",
    "end": "138490"
  },
  {
    "text": "So I give you a\nsingle map up front. And then I want to support\ndynamic queries, which are",
    "start": "138490",
    "end": "147120"
  },
  {
    "text": "which face contains a point p.",
    "start": "147120",
    "end": "153799"
  },
  {
    "text": " So that point is\ngoing to be given",
    "start": "153800",
    "end": "159569"
  },
  {
    "text": "to you as coordinates x and y. So maybe I mark a\npoint like this one.",
    "start": "159570",
    "end": "167430"
  },
  {
    "text": "I give you those x\nand y coordinates. I want to quickly\ndetermine that this face is the one that contains it.",
    "start": "167430",
    "end": "173355"
  },
  {
    "text": "I give you another\npoint over here. It quickly determines this face. This has a lot of applications.",
    "start": "173355",
    "end": "178590"
  },
  {
    "text": "If you're writing a GUI and\nsomeone clicks on the screen, you need to map the coordinates\nthat the mouse gives you",
    "start": "178590",
    "end": "184469"
  },
  {
    "text": "to which GUI element\nyou're clicking on. If you have a GPS\ndevice and it has a map,",
    "start": "184470",
    "end": "192069"
  },
  {
    "text": "so it's preprocessed\nthe map all at once. And now, given two GPS\ncoordinates, latitude, longitude, it needs to\nknow which city you're in,",
    "start": "192070",
    "end": "199021"
  },
  {
    "text": "which part of the map you're\nin, so that it knows what to display, that sort of thing.",
    "start": "199021",
    "end": "204250"
  },
  {
    "text": "These are all planar\npoint location problems. It comes up in simulation,\nlots of things. It's actually one of\nthe first problems",
    "start": "204250",
    "end": "209773"
  },
  {
    "text": "I got interested in\nalgorithms way back in my oceanography days.",
    "start": "209774",
    "end": "216599"
  },
  {
    "text": "So that's planar point location. That's the static version. The dynamic version--\nmake things harder--",
    "start": "216600",
    "end": "224010"
  },
  {
    "text": "is the map is dynamic. So here, the map is static. The queries are\nstill coming online.",
    "start": "224010",
    "end": "229110"
  },
  {
    "text": "Dynamic version, you can insert\nand delete edges in your map. ",
    "start": "229110",
    "end": "237390"
  },
  {
    "text": "And let's say if you get\na vertex down to degree 0, you can delete the vertex\nas well, add new degrees 0 vertices.",
    "start": "237390",
    "end": "243390"
  },
  {
    "text": "As long as you\ndon't have crossings introduced by inserting\nedges, you can change things. So that's obviously harder.",
    "start": "243390",
    "end": "251040"
  },
  {
    "text": "And we can solve this problem\nusing persistence and using retroactivity in a pretty simple\nway using a technique which you",
    "start": "251040",
    "end": "259078"
  },
  {
    "text": "may have seen before,\npretty classic technique in computational geometry.",
    "start": "259079",
    "end": "264186"
  },
  {
    "text": "So this is a\ntechnique that comes from the algorithms world. And we're going to apply it\nto the data structures world.",
    "start": "264186",
    "end": "271860"
  },
  {
    "text": "So, sweep line technique,\nit's a very simple idea.",
    "start": "271860",
    "end": "277360"
  },
  {
    "text": "So you have some line\nsegments in the plane,",
    "start": "277360",
    "end": "282900"
  },
  {
    "text": "something like this. And I'm going to\ntake a vertical line.",
    "start": "282900",
    "end": "288750"
  },
  {
    "text": "So the algorithmic\nproblem is I want to know are there any crossings.",
    "start": "288750",
    "end": "293910"
  },
  {
    "text": "Do any of these segments cross? This is where sweep line\ntechnique comes from, I believe. So the idea is we want to\nlinearize or one-dimensionalify",
    "start": "293910",
    "end": "302650"
  },
  {
    "text": "the problem. So just take a slice of the\nproblem with a vertical line. And imagine sweeping that\nline from left to right.",
    "start": "302650",
    "end": "309370"
  },
  {
    "text": "So you imagine it\nmoving continuously. Of course, in reality,\nit moves discretely.",
    "start": "309370",
    "end": "314729"
  },
  {
    "start": "314730",
    "end": "320390"
  },
  {
    "text": "Let me unambiguate\nthis a little bit. ",
    "start": "320390",
    "end": "333291"
  },
  {
    "text": "OK. There are discrete\nmoments in time when what is hit by\nthe sweep line changes.",
    "start": "333291",
    "end": "338425"
  },
  {
    "text": " Let me maybe label\nthese segments. We've got a, b, c, and d.",
    "start": "338425",
    "end": "348789"
  },
  {
    "text": "So initially, we hit nothing. Then we hit a, then we hit b.",
    "start": "348790",
    "end": "354064"
  },
  {
    "text": "Why do we hit b? Because we saw the\nleft end point of b. Then we see the right endpoint\nof a which means we no longer--",
    "start": "354064",
    "end": "359560"
  },
  {
    "text": "sorry, at this point, we see\nboth a and b in that order.",
    "start": "359560",
    "end": "364610"
  },
  {
    "text": "Then we lose a, so\nwe're down to b. Then we see c. c is above b.",
    "start": "364610",
    "end": "371050"
  },
  {
    "text": "Then we see d. d\nis above c and b. Then c and d cross.",
    "start": "371050",
    "end": "378180"
  },
  {
    "text": "So c and d change positions. And then we have b. Then we lose b, then we lose c.",
    "start": "378180",
    "end": "388630"
  },
  {
    "text": "Then we lose d. This is a classic algorithm for\ndetecting these intersections.",
    "start": "388630",
    "end": "394930"
  },
  {
    "text": "I don't want to get into\ndetails how you do this. But you're trying to look for\nwhen things change in order",
    "start": "394930",
    "end": "401110"
  },
  {
    "text": "in these cross-sections. The way you do that\nis you maintain the cross-section in\na binary search tree,",
    "start": "401110",
    "end": "406670"
  },
  {
    "text": "so you maintain the order. If you hit a left endpoint, you\ninsert into the binary search tree. If you see a right endpoint, you\ndelete from the binary search",
    "start": "406670",
    "end": "412300"
  },
  {
    "text": "tree. And you do some stuff\nto check for crossings. In this problem, there\nare no crossings. So we don't need to\nworry about that.",
    "start": "412300",
    "end": "419290"
  },
  {
    "text": "But we're taking this technique. Say, OK, there's a\ndata structure here, which is the binary search tree\nmaintaining the cross-section.",
    "start": "419290",
    "end": "428800"
  },
  {
    "text": "OK. So, typically, the\ncross-section data structure",
    "start": "428800",
    "end": "446120"
  },
  {
    "text": "is regular balanced\nbinary search tree. ",
    "start": "446120",
    "end": "454150"
  },
  {
    "text": "Our idea is what if\nwe add persistence",
    "start": "454150",
    "end": "459259"
  },
  {
    "text": "to that binary search tree? So instead of using a\nregular binary search tree, we use a partially persistent\nbalanced binary search",
    "start": "459260",
    "end": "465440"
  },
  {
    "text": "tree, which we know how to do. This is a bounded\nn degree structure. We can make it partially\npersistent, constant overhead.",
    "start": "465440",
    "end": "473070"
  },
  {
    "text": "So if we add\npartial persistence,",
    "start": "473070",
    "end": "487430"
  },
  {
    "text": "what does that let us do? Well, let's just\nlook at a moment in the past, partial persistence\nabout querying the past.",
    "start": "487430",
    "end": "494340"
  },
  {
    "text": "So there's a sequence of\ninsertions and deletions that occur from the sweep line. But now, if we can query\nin the past, that's",
    "start": "494340",
    "end": "501050"
  },
  {
    "text": "like going to a desired\nx-coordinate and saying, what does my data structure\nlook like at this moment?",
    "start": "501050",
    "end": "508620"
  },
  {
    "text": "OK. Now, the data structure,\nlet's maybe look at this one, because it's got three\nelements, very exciting.",
    "start": "508620",
    "end": "515870"
  },
  {
    "text": "So you've got d, then c, then b. So you've got a\nlittle data structure",
    "start": "515870",
    "end": "521529"
  },
  {
    "text": "that looks something like this. It understands the order\nof the cross-section",
    "start": "521530",
    "end": "526779"
  },
  {
    "text": "of those segments. And so, for example, if\nI was given a query point",
    "start": "526780",
    "end": "532690"
  },
  {
    "text": "like this one, I\ncould figure out what is the segment above me,\nwhat is the segment below me.",
    "start": "532690",
    "end": "540010"
  },
  {
    "text": "That is a successor query\nand a predecessor query in that binary search tree. ",
    "start": "540010",
    "end": "551500"
  },
  {
    "text": "This notation maybe-- a query\nat time t of, let's say,",
    "start": "551500",
    "end": "556750"
  },
  {
    "text": "successor of y is what we call\nan upward ray shooting query",
    "start": "556750",
    "end": "575370"
  },
  {
    "text": "from coordinates t,y. So t, the time, is\nacting as x-coordinate.",
    "start": "575370",
    "end": "582330"
  },
  {
    "text": "Time is left to right here. And so what's happening is we're\nimagining, from this point,",
    "start": "582330",
    "end": "589080"
  },
  {
    "text": "shooting a ray upward\nand asking what is the segment that I hit first. That's an upward\nray shooting query.",
    "start": "589080",
    "end": "596130"
  },
  {
    "text": "And this is from a problem\ncalled vertical ray shooting,",
    "start": "596130",
    "end": "601710"
  },
  {
    "text": "which is more or less equivalent\nto planar point location. ",
    "start": "601710",
    "end": "610710"
  },
  {
    "text": "So vertical ray shooting, again,\nyou're given a map, planar map.",
    "start": "610710",
    "end": "616560"
  },
  {
    "text": "And the queries are like this. What is the first segment that\nyou hit with an upward ray?",
    "start": "616560",
    "end": "623430"
  },
  {
    "start": "623430",
    "end": "635750"
  },
  {
    "text": "So I give you a point, x,y. And I ask, if I\ngo up from there,",
    "start": "635750",
    "end": "641060"
  },
  {
    "text": "what's the next edge that I get? That's the vertical\nray shooting problem. And we just solved\nthe vertical ray",
    "start": "641060",
    "end": "647255"
  },
  {
    "text": "shooting problem for static. If you're given a static map,\nyou run this algorithm once,",
    "start": "647255",
    "end": "652430"
  },
  {
    "text": "assume there are no crossings. Then to answer vertical\nray shooting query, we just go back\nin time to time t,",
    "start": "652430",
    "end": "659390"
  },
  {
    "text": "do the successor query,\nwhich takes log n time, and then we get\nthe answer to this.",
    "start": "659390",
    "end": "664680"
  },
  {
    "text": "So we can do this in\nlog n per query static.",
    "start": "664680",
    "end": "673220"
  },
  {
    "text": "This is all two dimensional. I should probably say that. You can generalize.",
    "start": "673220",
    "end": "679040"
  },
  {
    "text": " Questions? This is actually really easy.",
    "start": "679040",
    "end": "684360"
  },
  {
    "text": "This is the stuff we get\nfor free out of persistence and, at the moment,\nretroactivity. I believe this is one of\nthe reasons persistence",
    "start": "684360",
    "end": "691230"
  },
  {
    "text": "was invented in the first place. There were a bunch of early\npersistent data structures. Then there was a\ngeneral Driscoll paper,",
    "start": "691230",
    "end": "696686"
  },
  {
    "text": "which I talked about. But I think geometry was\none of the main motivations.",
    "start": "696686",
    "end": "702300"
  },
  {
    "text": "Because it lets you\nadd a dimension.  As long as that dimension\nis time-like, then",
    "start": "702300",
    "end": "710800"
  },
  {
    "text": "you get the dimension\nsort of for free. So that's nice. OK. What about retroactivity?",
    "start": "710800",
    "end": "716540"
  },
  {
    "text": " Again, we're going to use\npartial retroactivity.",
    "start": "716540",
    "end": "722790"
  },
  {
    "text": "And I can tell you for\ncertainty, because I was there, this is why retroactivity\nwas invented. ",
    "start": "722790",
    "end": "729930"
  },
  {
    "text": "So retroactivity,\nso that would mean that we get to\ndynamically add and delete",
    "start": "729930",
    "end": "737250"
  },
  {
    "text": "insertions and deletions. So that's like adding\nand deleting segments",
    "start": "737250",
    "end": "742350"
  },
  {
    "text": "from the structure. Again, we have a\nlinear timeline. We always want to maintain\na linear timeline, because that is reality.",
    "start": "742350",
    "end": "748260"
  },
  {
    "text": "That corresponds to\nthe x-coordinate. And now I want to be able to\nadd a segment like this, which",
    "start": "748260",
    "end": "753270"
  },
  {
    "text": "means there was an insertion\nat this time, a deletion at this time. Now, this doesn't quite work.",
    "start": "753270",
    "end": "758680"
  },
  {
    "text": "Because this point\nin cross-section, it's actually moving over time. Binary search trees, that's\nOK, because things are simple.",
    "start": "758680",
    "end": "767459"
  },
  {
    "text": "But at the moment,\nall we know how to do is actually horizontal segments,\nwhich are inserted and deleted",
    "start": "767460",
    "end": "774960"
  },
  {
    "text": "at the same y-coordinate. So then we can do\ninsert at time t1,",
    "start": "774960",
    "end": "785316"
  },
  {
    "text": "an insertion of\nsome y-coordinate,",
    "start": "785316",
    "end": "790649"
  },
  {
    "text": "and then an insert\nat some later time, the deletion of\nthat y-coordinate.",
    "start": "790650",
    "end": "797374"
  },
  {
    "text": " So this is a partially\nretroactive successor problem.",
    "start": "797374",
    "end": "805320"
  },
  {
    "text": "This is equal to dynamic\nvertical ray shooting.",
    "start": "805320",
    "end": "812502"
  },
  {
    "text": " I guess this\ninsertion corresponds",
    "start": "812502",
    "end": "819760"
  },
  {
    "text": "to the insertion of a thing. If you instead do\ndelete here, then you're deleting one of the segments.",
    "start": "819760",
    "end": "827040"
  },
  {
    "text": "This is among\nhorizontal segments. ",
    "start": "827040",
    "end": "835720"
  },
  {
    "text": "So if your map is made of\nhorizontal and vertical segments-- so it's an orthogonal map--",
    "start": "835720",
    "end": "841590"
  },
  {
    "text": "then you can solve the dynamic\nproblem using a partially retroactive successor. Again, we want to do\nsuccessor just like before,",
    "start": "841590",
    "end": "849260"
  },
  {
    "text": "querying the past. But now, our updates\nare different. Now, we have\nretroactive updates.",
    "start": "849260",
    "end": "854310"
  },
  {
    "text": "That lets us dynamically\nchange the past, which is like inserting\nand deleting edges",
    "start": "854310",
    "end": "859920"
  },
  {
    "text": "through that algorithm. But at the moment,\nwe only know how to do this for\nhorizontal segments. So this gives us,\nif you remember,",
    "start": "859920",
    "end": "866550"
  },
  {
    "text": "the retroactive\nsuccessor result. We haven't seen\nthat, how it works.",
    "start": "866550",
    "end": "872380"
  },
  {
    "text": "It's complicated. But it achieves log n insert,\ndelete successor retroactively.",
    "start": "872380",
    "end": "878970"
  },
  {
    "text": "And so we get a log n,\nwhich is an optimal solution for dynamic vertical\nray shooting among horizontal segments.",
    "start": "878970",
    "end": "887010"
  },
  {
    "text": "There are a bunch\nof open problems. What about general maps? ",
    "start": "887010",
    "end": "896220"
  },
  {
    "text": "So for a dynamic vertical\nray shooting in general maps,",
    "start": "896220",
    "end": "910209"
  },
  {
    "text": "if you want log n\nquery, the best results are log to the 1 plus\nepsilon insert log",
    "start": "910210",
    "end": "915959"
  },
  {
    "text": "to the 2 plus epsilon delete. There's some other trade-offs. You can get log times log\nlog n query and reduce.",
    "start": "915960",
    "end": "922000"
  },
  {
    "text": "Still, we don't know\nhow to delete faster than log squared in any\nof the general solutions.",
    "start": "922000",
    "end": "928260"
  },
  {
    "text": "So you can do log\nsquare for everything. But the hope would be you could\ndo log for everything even when",
    "start": "928260",
    "end": "934187"
  },
  {
    "text": "the segments are not horizontal. But here, retroactivity\ndoesn't seem to buy you things.",
    "start": "934187",
    "end": "941980"
  },
  {
    "text": "It'd be nice if you could. Another fun open\nproblem is, what",
    "start": "941980",
    "end": "947170"
  },
  {
    "text": "about non-vertical rays,\ngeneral rays, non-vertical rays?",
    "start": "947170",
    "end": "958010"
  },
  {
    "text": " So I give you a point\nand I give you a vector,",
    "start": "958010",
    "end": "965149"
  },
  {
    "text": "I want to know what do\nI hit in that direction. This is a lot harder. You can't use any\nof these tricks. And in fact, it's believed you\ncannot get polylog performance",
    "start": "965150",
    "end": "973120"
  },
  {
    "text": "unless you have a ton of space. So the best known result is--",
    "start": "973120",
    "end": "978482"
  },
  {
    "text": "I'll just throw this up here. You can get n over square\nroot s polylog and query.",
    "start": "978482",
    "end": "987730"
  },
  {
    "text": "If you use, basically, s space. ",
    "start": "987730",
    "end": "996320"
  },
  {
    "text": "So you need quite\na bit of space. Because if you use n to\nthe 1 plus epsilon space,",
    "start": "996320",
    "end": "1002260"
  },
  {
    "text": "you can get roughly\nroot n query time. If you use n to\n5 space, then you",
    "start": "1002260",
    "end": "1010200"
  },
  {
    "text": "get somewhat better query\ntime, but still not great. You can maybe get down\nto n to the epsilon",
    "start": "1010200",
    "end": "1015960"
  },
  {
    "text": "if you have very large\npolynomial space. But this is conjectured\nto be roughly optimal,",
    "start": "1015960",
    "end": "1022890"
  },
  {
    "text": "I assume, other than\nthe polylog factors. The belief is you cannot\nbeat this for general ray. This is kind of\nannoying, because this",
    "start": "1022890",
    "end": "1028470"
  },
  {
    "text": "is a problem we care about. Especially in 3D,\nthis is ray tracing. You shoot a ray,\nwhat does it hit?",
    "start": "1028470",
    "end": "1033991"
  },
  {
    "text": "You bounce it. You shoot another ray. I always want to know\nwhat objects am I hitting. And for special cases,\nyou can do better.",
    "start": "1033992",
    "end": "1041041"
  },
  {
    "text": "But in general, it\nseems quite hard. This is even in two dimensions. But there are a bunch of\npapers on 3D and so on.",
    "start": "1041041",
    "end": "1050500"
  },
  {
    "text": "I just wanted to give you those\nconnections to persistence and retroactivity. And that's point location.",
    "start": "1050500",
    "end": "1057070"
  },
  {
    "text": "And now, I want to go on two\northogonal range searching.",
    "start": "1057070",
    "end": "1062740"
  },
  {
    "text": "We can do some new data\nstructures, new to us. ",
    "start": "1062740",
    "end": "1071480"
  },
  {
    "text": "So first, what is the problem? ",
    "start": "1071480",
    "end": "1090929"
  },
  {
    "text": "So it's sort of the reverse\nkind of problem here. You're given a bunch of points\nbefore the query was a point.",
    "start": "1090930",
    "end": "1101710"
  },
  {
    "text": "And the query, in\nthis case, is going to be, in two dimensions,\na rectangle, a window",
    "start": "1101710",
    "end": "1109560"
  },
  {
    "text": "if you will. And you want to know what\npoints are in the rectangle.",
    "start": "1109560",
    "end": "1115320"
  },
  {
    "text": "So given n points and d\ndimensions, query in general",
    "start": "1115320",
    "end": "1129950"
  },
  {
    "text": "is going to be a box. So in 2D, it's an interval\ncrossing interval.",
    "start": "1129950",
    "end": "1135830"
  },
  {
    "text": "In 3D, it's three intervals\ncross-product together. ",
    "start": "1135830",
    "end": "1141801"
  },
  {
    "text": "OK. So in the static version, you\nget to preprocess the points. In the dynamic\nversion, the points",
    "start": "1141801",
    "end": "1147130"
  },
  {
    "text": "are being added and deleted. And in all cases, we\nhave dynamic queries, which are what are\nthe points in the box.",
    "start": "1147130",
    "end": "1153500"
  },
  {
    "text": "Now, there are different\nversions of this query. There is an existence\nquery, which is are there any points in the box?",
    "start": "1153500",
    "end": "1158600"
  },
  {
    "text": "That's sort of the easiest. Next level up is, how many\npoints are in the box? Which you can use\nto solve existence.",
    "start": "1158600",
    "end": "1164770"
  },
  {
    "text": "Next level up is give me\nall the points in the box, or give me 10 points in the\nbox, give me a point in the box.",
    "start": "1164770",
    "end": "1172100"
  },
  {
    "text": "All of these problems are\nmore or less the same. They do differ in some cases. But the things\nwe'll see today, you can solve them all\nabout as efficiently.",
    "start": "1172100",
    "end": "1178850"
  },
  {
    "text": "But, of course, if you want to\nlist all the points in the box, it could be everything. And so that could\ntake linear time.",
    "start": "1178850",
    "end": "1184190"
  },
  {
    "text": "So in general, our goal is to\nget a running time something like log n plus k, where k\nis the size of the output.",
    "start": "1184190",
    "end": "1191740"
  },
  {
    "text": " So if you're asking how\nmany points are in there,",
    "start": "1191740",
    "end": "1196835"
  },
  {
    "text": "the size the output\nis a single number. So k is 1, you should\nget log n time. If you want to list 100\npoints in there, k is 100.",
    "start": "1196835",
    "end": "1204520"
  },
  {
    "text": "And so you have to\npay that to list them. If you want to know all\nof them, well, then k is the number of points\nthat are in there.",
    "start": "1204520",
    "end": "1211270"
  },
  {
    "text": "And we'll be able to achieve\nthese kinds of bounds",
    "start": "1211270",
    "end": "1217990"
  },
  {
    "text": "pretty much all the time,\ndefinitely in two dimensions. In D dimensions, it's\ngoing to get harder.",
    "start": "1217990",
    "end": "1225246"
  },
  {
    "text": "OK.  So I want to start out\nwith one dimension just",
    "start": "1225246",
    "end": "1231670"
  },
  {
    "text": "to make sure we're\non the same page. And in general, we're going to\nstart with a solution called",
    "start": "1231670",
    "end": "1237279"
  },
  {
    "text": "range trees, which were\nsimultaneously invented by a lot of people in the\nlate '70s, Bentley, one",
    "start": "1237280",
    "end": "1245799"
  },
  {
    "text": "of the main guys. And in general, we're going to\naim here for a log to the d n",
    "start": "1245800",
    "end": "1252220"
  },
  {
    "text": "plus k query time. ",
    "start": "1252220",
    "end": "1257370"
  },
  {
    "text": "So I like this, but now we\nhave a dependence on dimension. And for 2D, this is not great. It's log squared.",
    "start": "1257370",
    "end": "1263340"
  },
  {
    "text": "And we're going to do better. OK. But let's start with d equals 1. How do you do this?",
    "start": "1263340",
    "end": "1270260"
  },
  {
    "text": "How do I achieve\nlog n plus k query? ",
    "start": "1270260",
    "end": "1277360"
  },
  {
    "text": "Sort the points. Yeah. I could sort the points,\nthen do binary search. So the query now is\njust an interval.",
    "start": "1277360",
    "end": "1286270"
  },
  {
    "text": "That's the one dimensional\nversion of a box. So if I search for a, search\nfor b in a sorted list,",
    "start": "1286270",
    "end": "1292300"
  },
  {
    "text": "then all the points\nin between I can count the different indices-- or subtract the two\nindices into the array.",
    "start": "1292300",
    "end": "1297520"
  },
  {
    "text": "That will give me how\nmany points there are in the box, all these things.",
    "start": "1297520",
    "end": "1302919"
  },
  {
    "text": "Arrays aren't going to\ngeneralize super nicely. Although, we'll come\nback to arrays later.",
    "start": "1302920",
    "end": "1308660"
  },
  {
    "text": "For now, I'd like to think\nof a binary search tree, balanced binary search tree.",
    "start": "1308660",
    "end": "1314359"
  },
  {
    "text": "And I'm going to make\nit a little different from the usual kind\nof binary search tree. I want the data to\nbe in the leaves.",
    "start": "1314359",
    "end": "1320875"
  },
  {
    "text": " So I want the leaves\nto be my points.",
    "start": "1320875",
    "end": "1327429"
  },
  {
    "text": "And this will be convenient\nfor higher dimensions. It doesn't really matter\nfor one dimension,",
    "start": "1327430",
    "end": "1332950"
  },
  {
    "text": "but it's kind of\nnice to think about. So you've got a\nbinary search tree. And then here is the data sorted\nby the only coordinate that",
    "start": "1332950",
    "end": "1341320"
  },
  {
    "text": "exists, the x-coordinate. And so, of course,\nI can search for a, here's a maybe, search for b.",
    "start": "1341320",
    "end": "1349870"
  },
  {
    "text": "And the stuff in between\nhere, that is my result.",
    "start": "1349870",
    "end": "1355446"
  },
  {
    "text": "And in a little more detail,\nas you search for a and b,",
    "start": "1355446",
    "end": "1360540"
  },
  {
    "text": "at some point,\nthey will diverge. One will go left,\none will go right. ",
    "start": "1360540",
    "end": "1370730"
  },
  {
    "text": "At some point, you reach a. Maybe a isn't actually\nin the structure. You're searching for everything\nbetween a and b inclusive,",
    "start": "1370730",
    "end": "1377120"
  },
  {
    "text": "but a may not be there. So in general, we're going\nto find the predecessor and successor of a.",
    "start": "1377120",
    "end": "1382325"
  },
  {
    "text": "In this case, I'm interested\nin the predecessor. And similarly over\nhere, eventually--",
    "start": "1382325",
    "end": "1391010"
  },
  {
    "text": "this is all, of course,\nlogarithmic time-- I find the successor of b.",
    "start": "1391010",
    "end": "1396719"
  },
  {
    "text": "Those are the two things\nI'm interested in. And now, all the\nleaves in between here, that's the result. Question?",
    "start": "1396719",
    "end": "1402007"
  },
  {
    "text": "AUDIENCE: So if you have\nthe data just on the leaves, what do you have\nintermediate node? ERIK DEMAINE: Ah, right.",
    "start": "1402007",
    "end": "1407270"
  },
  {
    "text": "So in the intermediate\nnodes, I need to know, let's say, if every subtree\nknows the min and max, then",
    "start": "1407270",
    "end": "1412520"
  },
  {
    "text": "at a node, I can decide should\nI go left, should I go right? I think every node can store\nthe max of the left subtree",
    "start": "1412520",
    "end": "1418880"
  },
  {
    "text": "if you just want\none key per node. But, yeah, good question. Sorry, I forgot to mention that. You store a representative\nsort of in the middle",
    "start": "1418880",
    "end": "1427269"
  },
  {
    "text": "that lets you decide\nwhether to go left or right. So you can still do searches. We can find these two nodes.",
    "start": "1427270",
    "end": "1433070"
  },
  {
    "text": "And now, the answer is\nbasically all of this stuff. ",
    "start": "1433070",
    "end": "1441660"
  },
  {
    "text": "I did not leave\nmyself enough space. That's the left child.",
    "start": "1441660",
    "end": "1447210"
  },
  {
    "start": "1447210",
    "end": "1452840"
  },
  {
    "text": "OK. So wherever this\nleft branch went left, the right\nbranches in the answer.",
    "start": "1452840",
    "end": "1459970"
  },
  {
    "text": "Whenever this right\nbranch went right, the left branch is the answer. But from here, there's no\nsubtree that we care about.",
    "start": "1459970",
    "end": "1466290"
  },
  {
    "text": "Because this is all greater\nthan what we care about. OK. But the good news\nis there's only log n of these subtrees,\nmaybe two log n.",
    "start": "1466290",
    "end": "1473100"
  },
  {
    "text": "Because there's the left\nside, the right side. OK. So the answer is\nimplicitly represented.",
    "start": "1473100",
    "end": "1479789"
  },
  {
    "text": "We don't have to explicitly\ntouch all these items. We just know that they\nlive in the subtrees, in those order log n subtrees.",
    "start": "1479790",
    "end": "1489370"
  },
  {
    "text": "So in particular, if every node\nstores the size of its subtree, then we can add up\nthese log n numbers.",
    "start": "1489370",
    "end": "1494430"
  },
  {
    "text": "And we get the\nsize of the answer. If we want the first k items,\nwe can visit the first k items here in order k time.",
    "start": "1494430",
    "end": "1503490"
  },
  {
    "text": "So in log n time, we get a nice\nrepresentation of the answers, log n subtrees.",
    "start": "1503490",
    "end": "1508650"
  },
  {
    "text": "Of course, we also had a nice\nanswer when we had an array. But this one will be\neasier to generalize.",
    "start": "1508650",
    "end": "1514929"
  },
  {
    "text": "And that's range trees. ",
    "start": "1514930",
    "end": "1521539"
  },
  {
    "text": "So that was a 1D range tree. The only difference is we\nput data at the leaves. ",
    "start": "1521540",
    "end": "1528796"
  },
  {
    "text": "2D range tree has a simple idea.",
    "start": "1528796",
    "end": "1534980"
  },
  {
    "text": "We have the data\nin these subtrees. These are the matches. Let's think we have\nan x-coordinate",
    "start": "1534980",
    "end": "1540630"
  },
  {
    "text": "and a y-coordinate. We have an x range\nand a y range. Let's do this for x. Now, we have a representation\nof all the matches in x.",
    "start": "1540630",
    "end": "1548340"
  },
  {
    "text": "So we want this rectangle. But we can get this\nentire slab in log n time,",
    "start": "1548340",
    "end": "1554360"
  },
  {
    "text": "and we have log n\nsubtrees that we now have to filter in terms of y. There's all these points out\nhere that we don't care about.",
    "start": "1554360",
    "end": "1560610"
  },
  {
    "text": "We want to get rid of those and\njust focus in on these points.",
    "start": "1560610",
    "end": "1565920"
  },
  {
    "text": "So we're going to do\nthe same thing on y, but we want to do\nthat for this subtree. And we want to do\nit for this subtree,",
    "start": "1565920",
    "end": "1572270"
  },
  {
    "text": "and for this subtree,\nso simple idea. For each subtree, let's\ncall it an x subtree.",
    "start": "1572270",
    "end": "1580470"
  },
  {
    "text": "So we have one tree which\nrepresents all the x data. It looks just like this. And then for each\nsubtree of that x tree,",
    "start": "1580470",
    "end": "1587929"
  },
  {
    "text": "we store, let's say,\na pointer to a y tree,",
    "start": "1587930",
    "end": "1599750"
  },
  {
    "text": "which is also a 1D range tree. So this guy has a pointer to\na similarly sized triangle.",
    "start": "1599750",
    "end": "1612720"
  },
  {
    "text": "Except, this one is on y. This one's sorted by x. This one's sorted\nby y, same points.",
    "start": "1612720",
    "end": "1618620"
  },
  {
    "text": "This subtree also has one,\nsame data as over here,",
    "start": "1618620",
    "end": "1624210"
  },
  {
    "text": "but now sorted an\ny instead of x. For example, there is a\nsmaller tree inside this one.",
    "start": "1624210",
    "end": "1632220"
  },
  {
    "text": "That one also has a pointer\nto a smaller y tree. Except, now, these\nare disjoined,",
    "start": "1632220",
    "end": "1637260"
  },
  {
    "text": "because these are completely-- yeah. This is a subset of that one. But we're going to store a y\ntree for this one and a y tree",
    "start": "1637260",
    "end": "1644400"
  },
  {
    "text": "for this one. So we're blowing up space.  Every element, every point\nlives in log n y trees.",
    "start": "1644400",
    "end": "1660690"
  },
  {
    "text": " Because if you look\nat a point, there's the tiny y tree that contains\nit bigger, bigger, bigger,",
    "start": "1660690",
    "end": "1667090"
  },
  {
    "text": "bigger until the entire\ntree also contains it. Each of those has a\ncorresponding y tree. So the overall space\nwill be n log n.",
    "start": "1667090",
    "end": "1675360"
  },
  {
    "text": " We're repeating points here.",
    "start": "1675360",
    "end": "1680810"
  },
  {
    "text": "But the good news is now I can\ndo search really efficiently, well, log squared efficiently. I spend log time to find\nthese x trees that represent",
    "start": "1680810",
    "end": "1688360"
  },
  {
    "text": "the slabs that I care about. So it's more like this picture.",
    "start": "1688360",
    "end": "1693970"
  },
  {
    "text": "So there's a bunch of\ndisjoint slabs, which together contain my points in x.",
    "start": "1693970",
    "end": "1699039"
  },
  {
    "text": "And now I want to filter\neach of them by y. So for each of them, I\njump over to y space and do a range query in y space just\nlike what we were doing here.",
    "start": "1699040",
    "end": "1709490"
  },
  {
    "text": "So search for a, search\nfor b, but in y-coordinate. And then I get log n subtrees\nin here, log n subtrees in here,",
    "start": "1709490",
    "end": "1716860"
  },
  {
    "text": "log n subtrees in here. So the query gives me\nlog squared y subtrees.",
    "start": "1716860",
    "end": "1729066"
  },
  {
    "text": "It takes me log squared\nn time to find them. If I have subtree sizes, I\ncompute the number of matches in log squared n time.",
    "start": "1729066",
    "end": "1735740"
  },
  {
    "text": "If I want k items, I\ncan grab k items out of them in order k time. OK.",
    "start": "1735740",
    "end": "1741980"
  },
  {
    "text": "Pretty easy. Of course, D dimensions\nis just the same trick. You have x tree.",
    "start": "1741980",
    "end": "1747770"
  },
  {
    "text": "Every subtree links to a y tree. Every y subtree\nlinks to a z tree. Every z subtree links\nto a w tree, and so on.",
    "start": "1747770",
    "end": "1755029"
  },
  {
    "text": "For D dimensions, you're going\nto get log to the D query",
    "start": "1755030",
    "end": "1761360"
  },
  {
    "text": "as I claimed before. How much space? Well, every dimension you\nadd adds another log factor",
    "start": "1761360",
    "end": "1768050"
  },
  {
    "text": "of space. So it's going to be n log\nto the d minus 1 space.",
    "start": "1768050",
    "end": "1775520"
  },
  {
    "text": "And if you want to\ndo this statically, you can also build the\ndata structure in n log",
    "start": "1775520",
    "end": "1785539"
  },
  {
    "text": "to the d minus 1 n time,\nexcept for d equals 1 where you need n log n time to sort.",
    "start": "1785540",
    "end": "1792020"
  },
  {
    "text": "But as long as d\nis bigger than 1, this is the right bound\nfor higher dimensions. It takes a little bit of\neffort to actually build",
    "start": "1792020",
    "end": "1799970"
  },
  {
    "text": "the structure in that much\ntime, but it can be done. ",
    "start": "1799970",
    "end": "1806010"
  },
  {
    "text": "OK. That's the very\nsimple data structure. Any questions about that\nbefore we make it cooler?",
    "start": "1806010",
    "end": "1811325"
  },
  {
    "text": "You may have seen this\ndata structure before. It's kind of classic. But you can do\nmuch better, well,",
    "start": "1811325",
    "end": "1816889"
  },
  {
    "text": "at least a log factor better. AUDIENCE: Question. ERIK DEMAINE: Yeah. AUDIENCE: So when your storing\none pointer for each subtree,",
    "start": "1816890",
    "end": "1823586"
  },
  {
    "text": "you essentially have a\npointer for each root, like for each node? ERIK DEMAINE: Yeah. Right.",
    "start": "1823586",
    "end": "1828789"
  },
  {
    "text": "Every node. So I know these are the nodes\nthat the stuff below them represents my answer in x.",
    "start": "1828789",
    "end": "1834410"
  },
  {
    "text": "And so I teleport over to the\ny universe from the x universe. AUDIENCE: So, basically,\nit has all the same nodes",
    "start": "1834410",
    "end": "1840364"
  },
  {
    "text": "of that subtree, but [INAUDIBLE] ERIK DEMAINE: Yeah. All the points that\nare in here also live in here, except these\nones are sorted by x.",
    "start": "1840364",
    "end": "1846460"
  },
  {
    "text": "These ones are sorted by y. If I kept following pointers,\nI get to z and w and so on.",
    "start": "1846460",
    "end": "1853210"
  },
  {
    "text": "Other questions? Yeah. AUDIENCE: So if we were\ndoing the dynamic case, how would we implement\nrotations in the [INAUDIBLE]?",
    "start": "1853210",
    "end": "1859020"
  },
  {
    "text": "ERIK DEMAINE: OK.  Dynamic is annoying.",
    "start": "1859020",
    "end": "1865171"
  },
  {
    "text": "Yeah. Rotations are annoying. I think we'll come back to that.",
    "start": "1865171",
    "end": "1870710"
  },
  {
    "text": "We can solve that. I thought it was easy,\nbut you're right. Rotations are kind of annoying. And we can solve that using\nthis dynamization trick.",
    "start": "1870710",
    "end": "1878840"
  },
  {
    "text": "So we don't have to worry\nabout it till we get there. It's going to get even harder\nto make things dynamic.",
    "start": "1878840",
    "end": "1886010"
  },
  {
    "text": "And so then we really need\nto pull out the black box. Well, it's not a black box.",
    "start": "1886010",
    "end": "1892120"
  },
  {
    "text": "We're going to see how it works. But it's a general\ntransformation that makes things dynamic. ",
    "start": "1892120",
    "end": "1900465"
  },
  {
    "text": "OK.  Before we get a dynamic,\nstick with static.",
    "start": "1900465",
    "end": "1906980"
  },
  {
    "text": "And let's improve\nthings by a log factor. ",
    "start": "1906980",
    "end": "1914530"
  },
  {
    "text": "This is an idea called\nlayered range trees. ",
    "start": "1914530",
    "end": "1922240"
  },
  {
    "text": "It's also sometimes called\nfractional cascading,",
    "start": "1922240",
    "end": "1927520"
  },
  {
    "text": "which is the technique\nwe're going to get to later. I would say it involves one\nhalf of fractional cascading.",
    "start": "1927520",
    "end": "1932740"
  },
  {
    "text": "Fractional cascading\nhas two ideas. And the one that it's named\nafter is not this idea.",
    "start": "1932740",
    "end": "1937799"
  },
  {
    "text": "So idea one is basically\nto reuse searches.",
    "start": "1937800",
    "end": "1943420"
  },
  {
    "text": "The idea is we're\nsearching in this subtree or, I guess, this subtree\nwith respect to y. We're also searching for\nthe same interval of y",
    "start": "1943420",
    "end": "1951430"
  },
  {
    "text": "in this subtree. Completely different\nelements, but if there was some way we\ncould reuse the searches for y",
    "start": "1951430",
    "end": "1956659"
  },
  {
    "text": "in all of these log n subtrees,\nwe could save a log factor. And it turns out we can. And this is one idea in\nfractional cascading,",
    "start": "1956660",
    "end": "1963520"
  },
  {
    "text": "but there will be\nanother one later.  OK.",
    "start": "1963520",
    "end": "1970470"
  },
  {
    "text": "So, fun stuff. This is where I want\nto change my notes.",
    "start": "1970470",
    "end": "1976169"
  },
  {
    "text": "So we're searching in x with\na regular 1D range tree.",
    "start": "1976170",
    "end": "1983190"
  },
  {
    "text": "I also want to have a\nregular 1D range tree-- range tree?",
    "start": "1983190",
    "end": "1988650"
  },
  {
    "text": "Sure. Actually, it doesn't\nmatter too much. I want to have an array\nof all the items sorted by y-coordinate.",
    "start": "1988650",
    "end": "1996610"
  },
  {
    "text": "And we're going to\nsimplify things here. Instead of pointing\nto a tree, I'm going to point to an\narray sorted by y.",
    "start": "1996610",
    "end": "2002700"
  },
  {
    "text": "This is totally static. And this is where\ndynamic gets harder,",
    "start": "2002700",
    "end": "2008639"
  },
  {
    "text": "not that know how to\ndo it over there yet. So for each x\nsubtree, we're going",
    "start": "2008640",
    "end": "2016500"
  },
  {
    "text": "to have a pointer to the\nsame elements sorted by y. ",
    "start": "2016500",
    "end": "2025360"
  },
  {
    "text": "So all the leaves\nthat are down here are, basically, also there, but\nby y coordinate instead of x.",
    "start": "2025360",
    "end": "2033352"
  },
  {
    "text": "Obviously, we can\nstill do the same thing we could do before, spend\nlog n time to search in each of these log n arrays\ncorresponding to these log n",
    "start": "2033352",
    "end": "2041710"
  },
  {
    "text": "subtrees. And in log squared n,\nwe'll have our answers. But we can do better now.",
    "start": "2041710",
    "end": "2047950"
  },
  {
    "text": "I only want to do one\nbinary search in y. And that will be at the root.",
    "start": "2047950",
    "end": "2053460"
  },
  {
    "text": "So the root, there's\nan array representing everything sorted by y. I search for the\nlower y-coordinate.",
    "start": "2053460",
    "end": "2059723"
  },
  {
    "text": "I search for the upper\ny-coordinate, some things. It's hard to draw\nthis, because it's",
    "start": "2059724",
    "end": "2065169"
  },
  {
    "text": "in the dimensional\northogonal to this one. I guess I should really\ndraw the arrays like this.",
    "start": "2065170",
    "end": "2071239"
  },
  {
    "text": "So this guy has an array. We find the upper\nand lower bounds for the y-coordinate\nin the global space.",
    "start": "2071239",
    "end": "2077500"
  },
  {
    "text": "This takes log n time\nto do two searches. Question. AUDIENCE: Those are the\nupper and lower bounds from the predecessor [INAUDIBLE]\nsuccessor [INAUDIBLE]?",
    "start": "2077500",
    "end": "2084049"
  },
  {
    "text": "ERIK DEMAINE: Yeah, right. So we're doing a predecessor\nand successor search, let's say, in this array. Binary search we find--",
    "start": "2084049",
    "end": "2092169"
  },
  {
    "text": "I didn't give them\nnames, but in the notes they're a1 through b1 and x.",
    "start": "2092170",
    "end": "2100540"
  },
  {
    "text": "And they're a2 through b2 and y. So that's my query,\nthis rectangle.",
    "start": "2100540",
    "end": "2106740"
  },
  {
    "text": "I'm doing the search for a2\nand for b2 in the top array. Now, what I'd like to do\nis keep that information",
    "start": "2106740",
    "end": "2114460"
  },
  {
    "text": "as I walk down the tree.  So that in the end, when\nI get to these nodes,",
    "start": "2114460",
    "end": "2121390"
  },
  {
    "text": "I know where I am in\nthose arrays in y.",
    "start": "2121390",
    "end": "2126519"
  },
  {
    "text": "So let's think of that\njust step by step. ",
    "start": "2126520",
    "end": "2147460"
  },
  {
    "text": "So imagine in the x\ntree, I'm at some node.",
    "start": "2147460",
    "end": "2153900"
  },
  {
    "text": "And then I follow, let's\nsay, a right pointer to the right child.",
    "start": "2153900",
    "end": "2159580"
  },
  {
    "text": "OK. Now, in y space-- maybe I should switch\nto red for y space.",
    "start": "2159580",
    "end": "2166500"
  },
  {
    "text": "This guy has a really big array\nrepresenting all of the nodes",
    "start": "2166500",
    "end": "2173010"
  },
  {
    "text": "down here, but sorted\nby y-coordinate. This guy has a\ncorresponding array",
    "start": "2173010",
    "end": "2178410"
  },
  {
    "text": "with some subset of the nodes. Which subset? The ones that are to the\nright of this x-coordinate.",
    "start": "2178410",
    "end": "2184660"
  },
  {
    "text": "So there's no relation. I mean, some of the\nguys that are here-- let me circle them-- ",
    "start": "2184660",
    "end": "2192180"
  },
  {
    "text": "some of these guys\nexist over here. They'll be in the\nsame relative order.",
    "start": "2192180",
    "end": "2197740"
  },
  {
    "text": "So here's those four\nguys, then one, and two. So some of these guys will\nbe preserved over here.",
    "start": "2197740",
    "end": "2203899"
  },
  {
    "text": "Some of them won't, because\ntheir x-coordinate smaller. It's an arbitrary subset. These guys will also live here.",
    "start": "2203899",
    "end": "2210660"
  },
  {
    "text": "OK. The idea is store pointers from\nevery element over here to,",
    "start": "2210660",
    "end": "2216180"
  },
  {
    "text": "let's say, the\nsuccessor over here. So store these red arrows.",
    "start": "2216180",
    "end": "2222680"
  },
  {
    "text": "let's say, these guys\nall point to this node. These guys point to that node.",
    "start": "2222680",
    "end": "2229260"
  },
  {
    "text": "I guess these guys just\npoint to some adjacent node, either the predecessor\nor the successor.",
    "start": "2229260",
    "end": "2235550"
  },
  {
    "text": "So the result is if I know where\na2 and b2 live in this array, I can figure out where\nthey live in this array.",
    "start": "2235550",
    "end": "2242250"
  },
  {
    "text": "I just follow the pointer. Easy. Done.",
    "start": "2242250",
    "end": "2248240"
  },
  {
    "text": "OK. Let's think about\nwhat this means. So I'm going to store\npointers from the y",
    "start": "2248240",
    "end": "2259580"
  },
  {
    "text": "array of some x node.",
    "start": "2259580",
    "end": "2265110"
  },
  {
    "text": " Let's call that\nnode v in the x tree",
    "start": "2265110",
    "end": "2276340"
  },
  {
    "text": "to the corresponding places,\ncorresponding points,",
    "start": "2276340",
    "end": "2284940"
  },
  {
    "text": "let's say, in the y\narrays of left child of v",
    "start": "2284940",
    "end": "2295410"
  },
  {
    "text": "and the right child of v. So, actually,\nevery array item is going to have two\npointers, one if you're",
    "start": "2295410",
    "end": "2301530"
  },
  {
    "text": "going right in the x\ntree, one if you're going the left in the x tree. But we can afford a constant\nnumber of pointers per node.",
    "start": "2301530",
    "end": "2308700"
  },
  {
    "text": "This only increases space\nby a constant factor. And now, it tells me\nexactly what I need to know.",
    "start": "2308700",
    "end": "2314100"
  },
  {
    "text": "I start at the root. I do a binary search. That's the slow part. I spend log n time,\nfind those two slots.",
    "start": "2314100",
    "end": "2319740"
  },
  {
    "text": "Every time I go down,\nI follow the pointer. I know exactly where a2 and\nb2 live in the next array.",
    "start": "2319740",
    "end": "2327120"
  },
  {
    "text": "In constant time, as I walk\ndown, I can figure this out. I can remember the information\non both sides here.",
    "start": "2327120",
    "end": "2332430"
  },
  {
    "text": "And every time I go to\none of these subtrees, I know exactly where I live--",
    "start": "2332430",
    "end": "2338970"
  },
  {
    "text": "it's no longer a tree--\nnow, in that array. So I can identify the\nregions in these arrays.",
    "start": "2338970",
    "end": "2346710"
  },
  {
    "text": "that correspond to these\nmatching subrectangles with no extra time.",
    "start": "2346710",
    "end": "2352560"
  },
  {
    "text": "So I save that last log factor. If you generalize\nthis to D dimensions, it only works in\nthe last dimension.",
    "start": "2352560",
    "end": "2357730"
  },
  {
    "text": "You can use this trick\nin the last dimension and improve from log to the d\nquery to log to the d minus 1.",
    "start": "2357730",
    "end": "2365880"
  },
  {
    "text": "In the higher dimensions, we\njust use regular range trees. And when we get down to\nthe two dimensional case, it's a recursion.",
    "start": "2365880",
    "end": "2371754"
  },
  {
    "text": "Before we were stopping at\nthe one dimensional case. We use a regular\nbinary search tree. Now, we stop at the\ntwo dimensional case,",
    "start": "2371754",
    "end": "2378390"
  },
  {
    "text": "and we use this fancy thing.  I call this cross-linking.",
    "start": "2378390",
    "end": "2384780"
  },
  {
    "text": "A lot of people call it\nfractional cascading. Both are valid names. It's a cool idea,\nbut simple once you",
    "start": "2384780",
    "end": "2392100"
  },
  {
    "text": "can see both dimensions\nat once, which I know it's hard to see in two dimensions. But it can be done.",
    "start": "2392100",
    "end": "2399060"
  },
  {
    "text": "All right. Questions? ",
    "start": "2399060",
    "end": "2404270"
  },
  {
    "text": "I guess the obvious\nquestion is dynamic. Now, we're going\nto go to dynamic.",
    "start": "2404270",
    "end": "2410040"
  },
  {
    "text": "This is a very static\nthing to be doing. How in the world\nwould we maintain this if the point set is changing?",
    "start": "2410040",
    "end": "2415340"
  },
  {
    "text": "All these pointers are\ngoing to move around. Life seems so hard.",
    "start": "2415340",
    "end": "2420350"
  },
  {
    "text": "But it's not. In fact, updates are a lot\neasier than you might think. ",
    "start": "2420350",
    "end": "2445850"
  },
  {
    "text": "Some of you may believe\nthis in your heart. Some of you may not.",
    "start": "2445850",
    "end": "2451190"
  },
  {
    "text": "But if you've ever seen an\namortization argument that says, basically, when\nyou modify a tree,",
    "start": "2451190",
    "end": "2457684"
  },
  {
    "text": "only a constant number\nof things happen. And they usually\nhappen near the leaves. I'm thinking of a\nbinary search tree.",
    "start": "2457684",
    "end": "2463900"
  },
  {
    "text": "The easiest way to see\nthis is in a B-tree if you know B-trees. Usually, if you do\ninsertion, you're",
    "start": "2463900",
    "end": "2469567"
  },
  {
    "text": "going to do maybe one or\ntwo splits at the bottom, and that's it. Constant fraction at a\ntime, that's all there is.",
    "start": "2469567",
    "end": "2474620"
  },
  {
    "text": "So it should only take\nconstant time to do an update. This structure is easy\nto update at the leaves.",
    "start": "2474620",
    "end": "2481934"
  },
  {
    "text": "If you look at one of these\nstructures, a constant number of items, there's a\nconstant size array. You could update everything\nin constant time.",
    "start": "2481935",
    "end": "2489840"
  },
  {
    "text": "If we're only up to hitting near\nthe leaves, then life is good. Occasionally,\nthough, we're going to have to update\nthese giant structures.",
    "start": "2489840",
    "end": "2496609"
  },
  {
    "text": "And then we're going to\nhave to spend giant time. That's OK. The only thing we need\nout of this data structure",
    "start": "2496609",
    "end": "2503720"
  },
  {
    "text": "is that it takes the same amount\nof space and pre-processing time, n log to d minus 1\nspace, and time to build",
    "start": "2503720",
    "end": "2512950"
  },
  {
    "text": "the static data structure. If we have this, it turns out\nwe can make it dynamic for free.",
    "start": "2512950",
    "end": "2521540"
  },
  {
    "text": "This is the magic of\nweight balance trees. ",
    "start": "2521540",
    "end": "2535609"
  },
  {
    "text": "In general, there are many\nkinds of weight balance trees. We're going to look\nat one called BB alpha",
    "start": "2535610",
    "end": "2542569"
  },
  {
    "text": "trees, which are the oldest\nand sort of the simplest.",
    "start": "2542570",
    "end": "2548450"
  },
  {
    "text": "Well, you'll see. It's pretty easy to do. You've already seen\nheight balance trees. AVL trees, for example, you keep\nthe left and the right subtree.",
    "start": "2548450",
    "end": "2556190"
  },
  {
    "text": "You want their height to be\nwithin an additive constant of each other, 1. Red black trees are\nmultiplicative factor 2.",
    "start": "2556190",
    "end": "2563779"
  },
  {
    "text": "Left and right\nsubtree, the heights will be roughly the same. Weight balance trees,\nweight is the number",
    "start": "2563780",
    "end": "2569450"
  },
  {
    "text": "of nodes in a subtree. Weight balance trees,\nthey want to keep the size of the left subtree and\nthe size of the right subtree",
    "start": "2569450",
    "end": "2575329"
  },
  {
    "text": "to be roughly the same. So here's the definition\nof BB alpha trees.",
    "start": "2575330",
    "end": "2582710"
  },
  {
    "text": "For each node v, size\nof the left subtree of v",
    "start": "2582710",
    "end": "2591900"
  },
  {
    "text": "is at least alpha\ntimes the size of v. And size of the\nright subtree of v",
    "start": "2591900",
    "end": "2601540"
  },
  {
    "text": "is at least alpha times\nthe size of v. Now, size,",
    "start": "2601540",
    "end": "2607860"
  },
  {
    "text": "I didn't define size. It could be the total number\nof nodes in the subtree. It could be the number\nof leaves in the subtree. Doesn't really matter.",
    "start": "2607860",
    "end": "2613580"
  },
  {
    "text": " What else? What's alpha?",
    "start": "2613580",
    "end": "2619079"
  },
  {
    "text": "Alpha is a half,\nyou're in trouble. Because then it has to\nbe perfectly balanced. But just make alpha small,\nlike 1/10 or something.",
    "start": "2619080",
    "end": "2626569"
  },
  {
    "text": "Any constant less\nthan a half will do. ",
    "start": "2626570",
    "end": "2632500"
  },
  {
    "text": "Right. The nice thing\nabout weight balance is they imply height balance. If you have this property\nthat neither your left",
    "start": "2632500",
    "end": "2639290"
  },
  {
    "text": "nor your right subtree are too\nsmall, then as you go down,",
    "start": "2639290",
    "end": "2644300"
  },
  {
    "text": "every time you take a\nleft or a right child, you throw away an alpha\nfraction of your nodes.",
    "start": "2644300",
    "end": "2650839"
  },
  {
    "text": "So initially, you\nhave all the nodes. Every time you go down,\nyou lose an alpha fraction. How many times can that happen?",
    "start": "2650840",
    "end": "2656240"
  },
  {
    "text": "Log base alpha, basically,\nso log base 1 over alpha.",
    "start": "2656240",
    "end": "2661280"
  },
  {
    "text": "The height is log base\n1 over alpha of n.",
    "start": "2661280",
    "end": "2669350"
  },
  {
    "text": "So this is really a stronger\nproperty than height balance. It implies that your\nheights are good.",
    "start": "2669350",
    "end": "2674871"
  },
  {
    "text": "So it implies the height of\nthe left and right subtree are not too far from each other. But it's a lot stronger.",
    "start": "2674871",
    "end": "2681290"
  },
  {
    "text": "It lets you do updates\nlickety fast, basically.",
    "start": "2681290",
    "end": "2686960"
  },
  {
    "text": "So how do we do an update? ",
    "start": "2686960",
    "end": "2697710"
  },
  {
    "text": "The idea is, normally,\nyou insert a leaf, do a regular BST,\ninsert a delete.",
    "start": "2697710",
    "end": "2703520"
  },
  {
    "text": "You add a leaf at the\nbottom or delete a leaf. And so you have to update like\nthat node and maybe its parent.",
    "start": "2703520",
    "end": "2711240"
  },
  {
    "text": "As long as you have\nweight balance, you're just making little\nconstant sized changes at the bottom.",
    "start": "2711240",
    "end": "2716430"
  },
  {
    "text": "Everything's good. OK. The trouble is when one of these\nconstraints becomes violated. Then you want to do a\nrotation or something.",
    "start": "2716430",
    "end": "2723880"
  },
  {
    "text": "OK. So when a node is\nnot weight balanced,",
    "start": "2723880",
    "end": "2734650"
  },
  {
    "text": "it's a pretty loose algorithm. But it's easy to find nodes. You just store all the\nweights, all the subtree sizes,",
    "start": "2734650",
    "end": "2741630"
  },
  {
    "text": "which we were doing already. You can detect when nodes are\nno longer weight balanced.",
    "start": "2741630",
    "end": "2747150"
  },
  {
    "text": "And then we just want\nto weight balance it. How do we weight balance it? We rebuild the entire\nsubtree from scratch.",
    "start": "2747150",
    "end": "2754089"
  },
  {
    "text": "This is sort of the only\nthing we know how to do. We have a static data structure. This is a general\ntransformation, dynamization",
    "start": "2754090",
    "end": "2760230"
  },
  {
    "text": "when you have augmentation. We have this data structure. It's got all these\naugmented things.",
    "start": "2760230",
    "end": "2766560"
  },
  {
    "text": "It's complicated. But at least it's sort\nof downward looking. I mean, you only need to\nstore pointers from here down,",
    "start": "2766560",
    "end": "2772660"
  },
  {
    "text": "not up. I mean, your parent\npoints into you. But you have a nice local thing. So if this guy's\nnot weight balanced,",
    "start": "2772660",
    "end": "2779040"
  },
  {
    "text": "if this left subtree is way\nheavier than the right subtree by this alpha factor,\none over alpha factor,",
    "start": "2779040",
    "end": "2786950"
  },
  {
    "text": "then just redo\neverything in here. Find the median. Make a perfect\nbinary search tree.",
    "start": "2786950",
    "end": "2793522"
  },
  {
    "text": "Then the weights between\nthe left and the right will be perfectly balanced. We'll have achieved the one\nhalf, one half split of weight.",
    "start": "2793522",
    "end": "2800880"
  },
  {
    "text": "How long before it\ngets unbalanced again? A long time. If I start with a one half,\none half split, and then",
    "start": "2800880",
    "end": "2807870"
  },
  {
    "text": "I have to get to an alpha\n1 minus alpha split, a lot of nodes had to move\nfrom one side to the other.",
    "start": "2807870",
    "end": "2816365"
  },
  {
    "text": "The alpha gets messy. So let me just say\nwhen this happens,",
    "start": "2816365",
    "end": "2821760"
  },
  {
    "text": "rebuild entire subtree. ",
    "start": "2821760",
    "end": "2828940"
  },
  {
    "text": "I guess it's like a 1/2\nminus alpha had to move. 1/2 minus alpha times\nthe size of the subtree",
    "start": "2828940",
    "end": "2834550"
  },
  {
    "text": "had to be inserted or deleted,\nhad to happen, or maybe half of that, some constant fraction.",
    "start": "2834550",
    "end": "2839877"
  },
  {
    "text": "I don't really care. Alpha's a constant. I'm going to charge\nto the theta k",
    "start": "2839877",
    "end": "2848789"
  },
  {
    "text": "updates that unbalance things.",
    "start": "2848790",
    "end": "2858560"
  },
  {
    "start": "2858560",
    "end": "2867150"
  },
  {
    "text": "k here is the size\nof the subtree. ",
    "start": "2867150",
    "end": "2874260"
  },
  {
    "text": "k So when I see a node is\non balance, just fix it. Make it perfect.",
    "start": "2874260",
    "end": "2879270"
  },
  {
    "text": "And if I started out perfect,\nthe subtree started out perfect, I know there were theta\nk updates that I can charge to.",
    "start": "2879270",
    "end": "2884780"
  },
  {
    "text": "The only catch is I'm actually\ndouble charging quite a bit, actually. If you look at a tree,\nif I do an insert here,",
    "start": "2884780",
    "end": "2894859"
  },
  {
    "text": "it makes this subtree\npotentially slightly unbalanced. It makes this subtrees\nslightly unbalanced. It makes this subtree\nslightly unbalanced.",
    "start": "2894860",
    "end": "2901180"
  },
  {
    "text": "There are log n subtrees\nthat contain that item. Each of them may\nbe getting worse.",
    "start": "2901180",
    "end": "2907095"
  },
  {
    "text": "So if I say, well, yeah, there\nare these theta k updates, but actually there are log\nn different subtrees that will charge to the same update.",
    "start": "2907095",
    "end": "2913590"
  },
  {
    "text": "So I lose a log n factor\nin this amortization. But it's not so bad. I get log n amortized update.",
    "start": "2913590",
    "end": "2920420"
  },
  {
    "start": "2920420",
    "end": "2926680"
  },
  {
    "text": "This is if a rebuild\ncosts linear time. ",
    "start": "2926680",
    "end": "2937616"
  },
  {
    "text": "This is pretty nifty. I don't have to do\nrotations per se. I just take all the notes in\nthe subtree, write them down.",
    "start": "2937616",
    "end": "2943980"
  },
  {
    "text": "I do an in order traverse. I have them sorted,\ntake the median, build a nice perfect binary\nsearch tree on those items.",
    "start": "2943980",
    "end": "2949740"
  },
  {
    "text": "I can easily do\nthat in linear time. And so this is like\nthe brain dead way",
    "start": "2949740",
    "end": "2954930"
  },
  {
    "text": "to make this weight\nbalanced tree dynamic. The original BB alpha\ntrees use rotations.",
    "start": "2954930",
    "end": "2961680"
  },
  {
    "text": "But you don't have to. You can do this very simple\nthing and still get a log n amortized update.",
    "start": "2961680",
    "end": "2967650"
  },
  {
    "text": "And the good news is, if you\nhave augmentation as well-- because with this\nsubtree, there's tons of extra stuff, all these\narrays and pointers and stuff,",
    "start": "2967650",
    "end": "2975990"
  },
  {
    "text": "it's easy to build from scratch. But it's hard to\nmaintain dynamically. The point is, now,\nwe don't have to.",
    "start": "2975990",
    "end": "2981599"
  },
  {
    "text": "If ever we need\nto change a node, we just rebuild\nthe entire subtree. And we can afford it at the\nloss of a logarithmic overhead.",
    "start": "2981600",
    "end": "2989620"
  },
  {
    "text": "So we had n log to the d minus\n1 n time to build the structure. So for a structure\nof size k, it's",
    "start": "2989620",
    "end": "2995010"
  },
  {
    "text": "going to be k times log\nto the d minus 1 of k.",
    "start": "2995010",
    "end": "3000154"
  },
  {
    "text": "We're going to lose\nan extra log factor. So this d minus 1 is going\nto turn into a d minus 2 for updates. ",
    "start": "3000154",
    "end": "3024589"
  },
  {
    "text": "So that was the\ngeneric structure.",
    "start": "3024590",
    "end": "3031010"
  },
  {
    "text": "And now, if we apply this\nto layered range trees,",
    "start": "3031010",
    "end": "3038720"
  },
  {
    "text": "we get log to the d\nn amortized update.",
    "start": "3038720",
    "end": "3046250"
  },
  {
    "start": "3046250",
    "end": "3052160"
  },
  {
    "text": "Because we had k\ntimes log to the d minus 1 of k pre-processing\nto rebuild node.",
    "start": "3052160",
    "end": "3061220"
  },
  {
    "text": " And just to recall,\nwe still have log",
    "start": "3061220",
    "end": "3067380"
  },
  {
    "text": "to the d minus 1 of n query. So this was regular range trees.",
    "start": "3067380",
    "end": "3074779"
  },
  {
    "text": "And we've made them dynamic,\nthe same time as range trees. And still, the query\nis a log factor faster.",
    "start": "3074780",
    "end": "3082250"
  },
  {
    "text": "So for 2D, we get log n query\nlog squired n update insertion and deletion of points.",
    "start": "3082250",
    "end": "3088700"
  },
  {
    "text": "Questions about that?  Cool.",
    "start": "3088700",
    "end": "3094650"
  },
  {
    "text": "Well, that is range searching,\northogonal range searching. ",
    "start": "3094650",
    "end": "3102750"
  },
  {
    "text": "Let's see. There are more\nresults, which I don't",
    "start": "3102750",
    "end": "3107859"
  },
  {
    "text": "want to cover in detail here. But you should at\nleast know about them.",
    "start": "3107860",
    "end": "3113164"
  },
  {
    "text": "And then we're going to\nturn to fractional cascading a little more generally. ",
    "start": "3113164",
    "end": "3125109"
  },
  {
    "text": "So where is this result?",
    "start": "3125110",
    "end": "3130855"
  },
  {
    "text": "Somewhere here. ",
    "start": "3130855",
    "end": "3141160"
  },
  {
    "text": "So for static orthogonal\nrange searching,",
    "start": "3141160",
    "end": "3148109"
  },
  {
    "text": "range searching is a big area. We're looking at\nthe orthogonal case. There's other versions\nwhere you're querying",
    "start": "3148110",
    "end": "3153630"
  },
  {
    "text": "with a triangle or a simplex. You can query with\ntwo-sided box, which",
    "start": "3153630",
    "end": "3160019"
  },
  {
    "text": "goes out to infinity here. All sorts of things\nare out there. But let me stick to rectangles.",
    "start": "3160020",
    "end": "3166312"
  },
  {
    "text": "Because that's what we've\nseen and we can relate to. You can achieve\nthese same bounds--",
    "start": "3166312",
    "end": "3174400"
  },
  {
    "text": "sorry, no update. You can achieve the\nlog to the d minus 1 n query using less space.",
    "start": "3174400",
    "end": "3181690"
  },
  {
    "text": "So I can get log\nto the d minus 1 n query and n log to the\nd minus 1 n space--",
    "start": "3181690",
    "end": "3196170"
  },
  {
    "text": "that's what we were\ngetting before-- divided by log log n.",
    "start": "3196170",
    "end": "3201240"
  },
  {
    "text": "Slight improvement. And in a certain model,\nthis is basically optimal,",
    "start": "3201240",
    "end": "3206370"
  },
  {
    "text": "which is kind of even crazier. This is an old\nresult by Chazelle.",
    "start": "3206370",
    "end": "3211970"
  },
  {
    "text": "That's in '86. OK. This is 2D-- sorry, not\n2D, just in general.",
    "start": "3211970",
    "end": "3221325"
  },
  {
    "text": " Turns out this query\ntime is not optimal.",
    "start": "3221325",
    "end": "3228840"
  },
  {
    "text": "If you allow the space\nto go up a little bit, you can get another\nlog improvement.",
    "start": "3228840",
    "end": "3235188"
  },
  {
    "text": "So I can get log\nto the d minus 2 and query if I'm\nwilling to pay--",
    "start": "3235188",
    "end": "3244674"
  },
  {
    "text": "I didn't this is space--  n log to the d n space.",
    "start": "3244675",
    "end": "3255510"
  },
  {
    "text": "So if I give up another\nlog factor in space, I can get another\nlog factor in query.",
    "start": "3255510",
    "end": "3261060"
  },
  {
    "text": "I don't think you\ncan keep doing that. But for one more step, you can. I believe this is conjectured\noptimal for query.",
    "start": "3261060",
    "end": "3268770"
  },
  {
    "text": "I don't know if it's proved. And this was originally\ndone by Chazelle and Guibas",
    "start": "3268770",
    "end": "3275190"
  },
  {
    "text": "using fractional cascading. And we'll see. If there's time next class,\nI'll show you how this works.",
    "start": "3275190",
    "end": "3283430"
  },
  {
    "text": "But for now, I want\nto tell you in general how fractional cascading\nworks in generality.",
    "start": "3283430",
    "end": "3288540"
  },
  {
    "text": "This is part of\nfractional cascading, this idea of cross-linking from\na bigger structure to a smaller",
    "start": "3288540",
    "end": "3293970"
  },
  {
    "text": "one, so that you don't\nhave to keep researching. You just reuse where you were.",
    "start": "3293970",
    "end": "3299339"
  },
  {
    "text": "But there's another idea. I want to show you that idea.  So, fractional cascading.",
    "start": "3299340",
    "end": "3306180"
  },
  {
    "start": "3306180",
    "end": "3322052"
  },
  {
    "text": "AUDIENCE: Would that\nwork for d equals 2? ERIK DEMAINE: For d equals\n2, no it does not work.",
    "start": "3322052",
    "end": "3327840"
  },
  {
    "text": "So I should say this\nis for 2D and higher. D has to be bigger than 1.",
    "start": "3327840",
    "end": "3333620"
  },
  {
    "text": "Because you can never be log n. So for 2D and higher, we could\nuse the trick that we just did.",
    "start": "3333620",
    "end": "3339470"
  },
  {
    "text": "For 3D and higher, you can\nimprove by another long, thanks.",
    "start": "3339470",
    "end": "3344984"
  },
  {
    "text": "Other questions? AUDIENCE: But you said\nyou can never beat log n. ERIK DEMAINE: We can\nnever beat log n. In this model, which is\nbasically comparison model,",
    "start": "3344984",
    "end": "3352880"
  },
  {
    "text": "we're comparing coordinates. In that model and\nmany other models, you can't beat log n query.",
    "start": "3352880",
    "end": "3358762"
  },
  {
    "text": "Because in particular, you have\nto solve the search problem in 1D. So we're always\nhampered by that.",
    "start": "3358762",
    "end": "3364310"
  },
  {
    "text": "But the question is,\nhow does it grow with d? And the claim is we can get\nlog n all the way up to three",
    "start": "3364310",
    "end": "3370599"
  },
  {
    "text": "dimensions. Only at four dimensions do\nwe have to pay log squared. It's pretty amazing I think.",
    "start": "3370600",
    "end": "3377869"
  },
  {
    "text": "OK. Fractional cascading-- super\ncool name, kind of scary name.",
    "start": "3377870",
    "end": "3392191"
  },
  {
    "text": "I was always scared when I heard\nabout fractional cascading. But it turns out,\nit's very simple. Goal today is to not be scared.",
    "start": "3392191",
    "end": "3397329"
  },
  {
    "text": " Let's start with\na warm up problem.",
    "start": "3397330",
    "end": "3403560"
  },
  {
    "text": "And then I'll tell you\nits full generality. But simple version\nof the problem is not geometry, per se.",
    "start": "3403560",
    "end": "3410290"
  },
  {
    "text": "It's kind of 1 and 1/2\ndimensions, if you will. Suppose I have k lists\nand each has size n.",
    "start": "3410290",
    "end": "3422619"
  },
  {
    "text": "They're sorted\nlists, think of them. So we have n items come\nfrom an ordered universe.",
    "start": "3422620",
    "end": "3429460"
  },
  {
    "text": "Here's list one. Here's list two. Here's a list three. There's k of them.",
    "start": "3429460",
    "end": "3436330"
  },
  {
    "text": "Each of them has n items. I would like to\nsearch the query.",
    "start": "3436330",
    "end": "3441805"
  },
  {
    "text": " We'll just do static here.",
    "start": "3441805",
    "end": "3446920"
  },
  {
    "text": "Original fractional\ncascading was just static. And these results\nare just static.",
    "start": "3446920",
    "end": "3452153"
  },
  {
    "text": "You can make it dynamic,\nbut there is some overhead. And I don't want\nto get into that. It's even messier,\nor it is messy.",
    "start": "3452154",
    "end": "3460450"
  },
  {
    "text": "Fractional cascading by\nitself is a very simple idea. Query is search\nfor x in all lists.",
    "start": "3460450",
    "end": "3470720"
  },
  {
    "text": " OK. So I want to know what is the\npredecessor and successor of x",
    "start": "3470720",
    "end": "3477639"
  },
  {
    "text": "in this list. I want to know what\nis the predecessor and successor in this list. I want to know what's the\npredecessor and successor",
    "start": "3477639",
    "end": "3483010"
  },
  {
    "text": "in this list, all of them. It's more information. If I just merged the\nlists and searched for x,",
    "start": "3483010",
    "end": "3488470"
  },
  {
    "text": "I would find where\nx fits globally. But I want to know how it\nfits relative to this list and relative to this list\nand relative to this list.",
    "start": "3488470",
    "end": "3496480"
  },
  {
    "text": "How do I do it? I could just do k\nbinary searches. So this is an easy\nproblem to solve.",
    "start": "3496480",
    "end": "3505270"
  },
  {
    "text": "You get k times log n. But, now, fractional\ncascading comes in.",
    "start": "3505270",
    "end": "3512050"
  },
  {
    "text": "And we can get the optimal\nbound, which is k plus log n.",
    "start": "3512050",
    "end": "3520760"
  },
  {
    "text": "I need k to write\ndown the answers. I need log n to do the\nsearch in one list. It turns out I can\nsearch on all k lists,",
    "start": "3520760",
    "end": "3527500"
  },
  {
    "text": "simultaneously get all k\nanswers in k plus log n time.",
    "start": "3527500",
    "end": "3532570"
  },
  {
    "text": "It's kind of cool and,\nactually, quite easy to do. We want to use this concept.",
    "start": "3532570",
    "end": "3538645"
  },
  {
    "text": " If I could search for\nmy item, for x, in here,",
    "start": "3538645",
    "end": "3544869"
  },
  {
    "text": "and then basically follow\na pointer to where I want to go in here, I'd be done.",
    "start": "3544870",
    "end": "3549910"
  },
  {
    "text": "Sadly, that can't be done. Why? Because who knows what\nelements are in here?",
    "start": "3549910",
    "end": "3556810"
  },
  {
    "text": "All of these elements could\nfit right in this slot. And so how do I know where\nto go in this giant list?",
    "start": "3556810",
    "end": "3564400"
  },
  {
    "text": "If these all fit in\nhere and, recursively, these all fit in here,\nthen by searching up here,",
    "start": "3564400",
    "end": "3570280"
  },
  {
    "text": "I learn nothing about\nwhere x fits in here. I have to do another search. And then I learn nothing\nabout where x fits in here.",
    "start": "3570280",
    "end": "3575986"
  },
  {
    "text": "So it doesn't work straight up. But if we combine this idea\nwith fractional cascading,",
    "start": "3575986",
    "end": "3581830"
  },
  {
    "text": "then we can do it. So I can erase this now. ",
    "start": "3581830",
    "end": "3598040"
  },
  {
    "text": "So what do we do?  Idea is very simple.",
    "start": "3598040",
    "end": "3604430"
  },
  {
    "text": "So I'm going to call these\nlists L1, L2, L3 up to Lk.",
    "start": "3604430",
    "end": "3610410"
  },
  {
    "text": " I want to add every other\nitem in Lk to Lk minus 1",
    "start": "3610410",
    "end": "3635300"
  },
  {
    "text": "and produce a new\nlist Lk minus 1 prime.  So I take every\nsecond item here,",
    "start": "3635300",
    "end": "3645150"
  },
  {
    "text": "just insert them into this list.  [INAUDIBLE] it's a\nconstant fraction bigger.",
    "start": "3645150",
    "end": "3652460"
  },
  {
    "text": "And then repeat. This is the fractional part. Here, a fraction is one half.",
    "start": "3652460",
    "end": "3657849"
  },
  {
    "text": "You can make it\nwhatever fraction you like less than one. In general, I'm going to\nadd every other item--",
    "start": "3657849",
    "end": "3666560"
  },
  {
    "text": " this is in sorted order\nin Lk, of course--",
    "start": "3666560",
    "end": "3673359"
  },
  {
    "text": "that's in Li prime-- the prime is the\nimportant part here--",
    "start": "3673360",
    "end": "3678410"
  },
  {
    "text": "to Li minus 1 to\nform Li minus prime.",
    "start": "3678410",
    "end": "3684780"
  },
  {
    "text": "So I've got this new\nlarger version of L2. I take half the items from here. Some of them may be\nitems that were in L3.",
    "start": "3684780",
    "end": "3691850"
  },
  {
    "text": "Some of them are items\nthat were originally in L2. But all of them get promoted. Or half of them\nget promoted to L1.",
    "start": "3691850",
    "end": "3700550"
  },
  {
    "text": "So I keep promoting\nfrom the bottom up. How big do my lists get?",
    "start": "3700550",
    "end": "3706339"
  },
  {
    "text": "What is the size of Li prime? Well, it started with Li.",
    "start": "3706340",
    "end": "3714290"
  },
  {
    "text": "And then I added\nhalf of the items that were in the next\nlevel down, Li plus 1.",
    "start": "3714290",
    "end": "3722200"
  },
  {
    "text": "OK. So this is n. And so this is going\nto be half of n",
    "start": "3722200",
    "end": "3727970"
  },
  {
    "text": "plus half of another\nn plus half of-- I mean, it's going to be n\nplus a half n plus a quarter n plus an eighth n.",
    "start": "3727970",
    "end": "3734010"
  },
  {
    "text": "It's a geometric series. This is just a\nconstant factor growth. I'm assuming all the lists\nhave the same size here",
    "start": "3734010",
    "end": "3740510"
  },
  {
    "text": "for simplicity. You can generalize. So I didn't really make the\nlists any bigger, per se.",
    "start": "3740510",
    "end": "3747920"
  },
  {
    "text": "But I fixed this problem. If all of the elements in\nL2 fit right here in L1,",
    "start": "3747920",
    "end": "3756330"
  },
  {
    "text": "it's no longer a problem. Because, now, half of the\nitems from L2 now live in L1. So when I search among\nL1, I'm not quite",
    "start": "3756330",
    "end": "3763880"
  },
  {
    "text": "doing a global search. But I'm finding\nwhere I fit in L1. I didn't contaminate\nit too much from L2.",
    "start": "3763880",
    "end": "3770990"
  },
  {
    "text": "And then now, it's useful to\nhave pointers from L1 to L2.",
    "start": "3770990",
    "end": "3776390"
  },
  {
    "text": "Let me draw a picture maybe. ",
    "start": "3776390",
    "end": "3792130"
  },
  {
    "text": "So here's L1, L2, L3.",
    "start": "3792130",
    "end": "3801700"
  },
  {
    "text": "So half of the items here\nhave been inserted into here.",
    "start": "3801700",
    "end": "3809380"
  },
  {
    "text": "Now, we don't really know-- maybe many of them went\nnear the same location.",
    "start": "3809380",
    "end": "3816480"
  },
  {
    "text": "But they went there. And I'm going to have\npointers in both directions. Let's say I need them down.",
    "start": "3816480",
    "end": "3822776"
  },
  {
    "text": "So that if I search in\nhere, I can figure out where I am down here. ",
    "start": "3822776",
    "end": "3829020"
  },
  {
    "text": "Then half of these guys-- maybe I'll use another color--",
    "start": "3829020",
    "end": "3835119"
  },
  {
    "text": "get promoted to\nthe next level up. So maybe this one gets promoted. Maybe this one gets promoted.",
    "start": "3835120",
    "end": "3842670"
  },
  {
    "text": "I guess half would be that one,\nthat one, that one, that one,",
    "start": "3842670",
    "end": "3847740"
  },
  {
    "text": "that one. These guys get promoted\nto the next level. ",
    "start": "3847740",
    "end": "3866450"
  },
  {
    "text": "OK. I claim this is\nenough information. This is fractional cascading\nin its full generality.",
    "start": "3866450",
    "end": "3872020"
  },
  {
    "text": "We have the\ncross-linking that we had in the layered range trees. But, now, we also have the\nfractional cascading part,",
    "start": "3872020",
    "end": "3878986"
  },
  {
    "text": "which is you take a\nfraction, you cascade it into the next layer. The cascading refers to those\nguys continue to get promoted.",
    "start": "3878987",
    "end": "3885330"
  },
  {
    "text": "Half of them get\npromoted up recursively. That's where the\nname comes from.",
    "start": "3885330",
    "end": "3891950"
  },
  {
    "text": "So now, how do we do a search? We're going to start at the top. And we're going to do a regular\nbinary search at the top.",
    "start": "3891950",
    "end": "3897490"
  },
  {
    "text": "Because we can\nafford log n once. So we do the binary\nsearch at the top. So maybe we find that our\nitem fits here in this search.",
    "start": "3897490",
    "end": "3907600"
  },
  {
    "text": "So that tells us,\noh, well, this is where item x fits in this list.",
    "start": "3907600",
    "end": "3913960"
  },
  {
    "text": "Great. Now, I need to\nknow where it fits in the next list\nin constant time.",
    "start": "3913960",
    "end": "3918970"
  },
  {
    "text": "Well, I need some more\npointers for this. So for each item\nin here, I'm going to store a pointer to the\nprevious and next, let's say,",
    "start": "3918970",
    "end": "3925880"
  },
  {
    "text": "red node, the\nprevious and next node that was promoted\nfrom the list below.",
    "start": "3925880",
    "end": "3931490"
  },
  {
    "text": "OK. So, now, I basically\nknow where it fits here. Not quite, because this\nis only half the items.",
    "start": "3931490",
    "end": "3938350"
  },
  {
    "text": "So I know that it fits\nbetween this guy and this guy in list 2 prime, technically.",
    "start": "3938350",
    "end": "3947260"
  },
  {
    "text": "So the only thing I don't\nknow is, is it here or here? So I compare with this one item.",
    "start": "3947260",
    "end": "3953590"
  },
  {
    "text": "And in general, if\nit's not a half, if the fraction is\nsome other constant, I spend constant time to look\nat a constant number of items,",
    "start": "3953590",
    "end": "3961119"
  },
  {
    "text": "figure out where it\nfits among those items. Now, I know where\nit fits in L2 prime. Then I, again, follow\npointers to the next items.",
    "start": "3961120",
    "end": "3969490"
  },
  {
    "text": "In this case, they're\nthe white items. So let's say it fits\nhere, basically.",
    "start": "3969490",
    "end": "3975150"
  },
  {
    "text": "I have a pointer to the\nprevious and next white item from that item. Follow those pointers down.",
    "start": "3975150",
    "end": "3981069"
  },
  {
    "text": "And now, I know it's either,\nbasically, here, here, here. It's somewhere in that little\nrange of either equaling this",
    "start": "3981070",
    "end": "3988299"
  },
  {
    "text": "or being between these\ntwo items or on this item or between those two\nitems or on this item. And, again, constant number\nof things to look at.",
    "start": "3988300",
    "end": "3995410"
  },
  {
    "text": "I figure out where I belong. In the primed list, which is\nnot quite the original list,",
    "start": "3995410",
    "end": "4003450"
  },
  {
    "text": "maybe I determine\nthat x falls here. And what I really\nwant to know is it's between this item and\nthat item of the original list.",
    "start": "4003450",
    "end": "4011170"
  },
  {
    "text": "I don't care so much\nabout the promoted lists. So I need more\npointers, which tell me",
    "start": "4011170",
    "end": "4016670"
  },
  {
    "text": "if it happens that I fall here,\nbasically, every promoted item",
    "start": "4016670",
    "end": "4023369"
  },
  {
    "text": "has a pointer to the\nprevious and next unpromoted item from the original list. This is static.",
    "start": "4023370",
    "end": "4029040"
  },
  {
    "text": "I can have all these pointers. Let's write them down. So every promoted\nitem in Li prime--",
    "start": "4029040",
    "end": "4043619"
  },
  {
    "text": "that means it came from\na promotion from below-- has a pointer to the previous\nand next non-promoted item.",
    "start": "4043620",
    "end": "4062290"
  },
  {
    "text": "So that's an item in Li. OK. That's two pointers.",
    "start": "4062290",
    "end": "4067560"
  },
  {
    "text": "And that's what we just use. So I found where I was\namong the entire L1",
    "start": "4067560",
    "end": "4072960"
  },
  {
    "text": "prime, which was almost like\na global search, not quite. And then I follow these\npoints to figure out where",
    "start": "4072960",
    "end": "4079500"
  },
  {
    "text": "it was in the original L1. ",
    "start": "4079500",
    "end": "4085137"
  },
  {
    "text": "Well, so if I found\nthat I was in the middle of this big white region, I need\nto find the next red region.",
    "start": "4085137",
    "end": "4090180"
  },
  {
    "text": "So it's basically the reverse. Every non-promoted item, every\nitem in Li, has a pointer.",
    "start": "4090180",
    "end": "4099354"
  },
  {
    "text": " So this is basically Li\nprime minus Li, if you will.",
    "start": "4099354",
    "end": "4107344"
  },
  {
    "text": "And then these\nguys need a pointer to the next and previous\nin that, so previous",
    "start": "4107344",
    "end": "4115539"
  },
  {
    "text": "and the next item in\nLi prime minus Li.",
    "start": "4115540",
    "end": "4125720"
  },
  {
    "text": "So these are the promoted items. These are the unpromoted items. So it's actually just\ntwo pointers per item.",
    "start": "4125720",
    "end": "4132020"
  },
  {
    "text": "If you're promoted, you\nstore the previous and next. Unpromoted, if\nyou're unpromoted, you store the previous\nand next promoted.",
    "start": "4132020",
    "end": "4137738"
  },
  {
    "text": "It's nice and symmetric. It's pretty clean,\na lot of pointers, hard to draw, but quite\nsimple in the end.",
    "start": "4137739",
    "end": "4144359"
  },
  {
    "text": "There's two main ideas. One is to promote\nrecursively up, just a constant fraction, so\nthe lists don't get much bigger.",
    "start": "4144359",
    "end": "4151705"
  },
  {
    "text": "Because it's a\nconstant fraction, the gaps when you walk\ndown are constant size. And so you basically\nget free relocalization",
    "start": "4151705",
    "end": "4157818"
  },
  {
    "text": "within each list with\nthe help of some pointers to walk down and jump left and\nright between the two colors.",
    "start": "4157819",
    "end": "4166220"
  },
  {
    "text": "OK. That's basic\nfractional cascading in that we solved this problem,\nsearched within k lists",
    "start": "4166220",
    "end": "4174460"
  },
  {
    "text": "each of size n and k plus log n\ntime, which is kind of amazing I think, pretty cool.",
    "start": "4174460",
    "end": "4180700"
  },
  {
    "text": " But there's a more\ngeneral form of this,",
    "start": "4180700",
    "end": "4187589"
  },
  {
    "text": "uses the exact same ideas. But I just want to tell you\nhow they generalized it.",
    "start": "4187590",
    "end": "4194149"
  },
  {
    "text": " This is Chazelle and Guibas.",
    "start": "4194149",
    "end": "4199250"
  },
  {
    "start": "4199250",
    "end": "4207958"
  },
  {
    "text": "So in general,\nfractional cascading,",
    "start": "4207958",
    "end": "4222920"
  },
  {
    "text": "if you look at what\ncascading is happening here--  here being here-- we essentially\nhave a path of cascades.",
    "start": "4222920",
    "end": "4231800"
  },
  {
    "text": "We start at the bottom and\npush into the predecessor in the path. We push into the\npredecessor in the path.",
    "start": "4231800",
    "end": "4237530"
  },
  {
    "text": "In the general case, we\ndo it on a graph instead of a path, arbitrary graph.",
    "start": "4237530",
    "end": "4242580"
  },
  {
    "text": "So we have a graph. The input, in some\nsense, you can think",
    "start": "4242580",
    "end": "4248869"
  },
  {
    "text": "of this as a transformation. But it's for a specific\nkind of data structure.",
    "start": "4248870",
    "end": "4254510"
  },
  {
    "text": "The data structure is\nrepresented by a graph.",
    "start": "4254510",
    "end": "4259639"
  },
  {
    "text": "And each vertex of the\ngraph has a set of elements",
    "start": "4259640",
    "end": "4271370"
  },
  {
    "text": "or a list of elements. That's what we had here. We had a path here.",
    "start": "4271370",
    "end": "4277415"
  },
  {
    "text": "And each node in the path had a\ncorresponding list of elements. And we wanted to search\namong those lists.",
    "start": "4277415",
    "end": "4282982"
  },
  {
    "text": "Before I tell you\nexactly what search is, let me tell you about\nthe rest of the graph. ",
    "start": "4282982",
    "end": "4294500"
  },
  {
    "text": "And this is, sorry, in\nan ordered universe. So it's one dimensional.",
    "start": "4294500",
    "end": "4300167"
  },
  {
    "text": " Edge is labeled with a range\nfrom that ordered universe a,",
    "start": "4300167",
    "end": "4310245"
  },
  {
    "text": "b. Every edge has some range. ",
    "start": "4310245",
    "end": "4315454"
  },
  {
    "text": "You can think of it\nas a directed graph. It's probably cleaner. So when I follow this\nedge, there's a range here.",
    "start": "4315454",
    "end": "4322580"
  },
  {
    "text": "And, basically, I'm only\nallowed to follow that edge if the range contains the\nthing I'm searching for.",
    "start": "4322580",
    "end": "4328730"
  },
  {
    "text": "So here, I was searching for\nsome item x in all the lists. There's no ranges here.",
    "start": "4328730",
    "end": "4334160"
  },
  {
    "text": "But in general, you\nget to specify a range. Why do we want to\nspecify a range? We need a sort of bounded\ndegree constraint.",
    "start": "4334160",
    "end": "4341633"
  },
  {
    "start": "4341633",
    "end": "4348889"
  },
  {
    "text": "We want to have\nbounded n degree. So here we had n degree\n1 for every node.",
    "start": "4348890",
    "end": "4357116"
  },
  {
    "text": "In general, we\ndon't want to have too many nodes pointing in. Because we want to take\nhalf the nodes in here,",
    "start": "4357116",
    "end": "4362491"
  },
  {
    "text": "or a constant\nfraction of the items here, and promote them into\nall the nodes that point to it, so that when we\nfollow the pointer,",
    "start": "4362492",
    "end": "4368330"
  },
  {
    "text": "we get to know where\nwe belong here. That's the general concept. So, ideally, we have\nbounded n degree.",
    "start": "4368330",
    "end": "4374570"
  },
  {
    "text": "If we do, we're done. We can have a slightly\nweaker condition, which is called\nlocally-bounded n degree where",
    "start": "4374570",
    "end": "4382010"
  },
  {
    "text": "the number of incoming edges for\na node whose labels are ranges",
    "start": "4382010",
    "end": "4392750"
  },
  {
    "text": "The labels have to have\na common intersection, x. So we're searching\nfor some item x.",
    "start": "4392750",
    "end": "4399260"
  },
  {
    "text": "And if all the possible ways we\ncan enter this node given item x-- so this x has to fall\nin all those ranges--",
    "start": "4399260",
    "end": "4405980"
  },
  {
    "text": "that should be bounded, so,\nat most, some constant c.",
    "start": "4405980",
    "end": "4412700"
  },
  {
    "text": "If it's always at\nmost c for all nodes and for all x's, then this\nis locally-bounded degree.",
    "start": "4412700",
    "end": "4418040"
  },
  {
    "text": "And these range labels help\nyou achieve this property. If you can constrain\nthat you're only",
    "start": "4418040",
    "end": "4424332"
  },
  {
    "text": "going to follow this edge\nin certain situations and there aren't\ntoo many ways you could have gotten to a node,\nthen you have this property.",
    "start": "4424332",
    "end": "4430340"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]\nbound to x?",
    "start": "4430340",
    "end": "4437210"
  },
  {
    "text": "ERIK DEMAINE: Contain x is\na backwards containment. Let me put it this way.",
    "start": "4437210",
    "end": "4443340"
  },
  {
    "text": "You have a node. You have all these\nedges coming into it. I want x to be a valid choice\nfor each of these edges.",
    "start": "4443340",
    "end": "4451190"
  },
  {
    "text": "Meaning, the range, each of them\nis some interval on the line.",
    "start": "4451190",
    "end": "4456980"
  },
  {
    "text": "All those intervals\nshould contain x. ",
    "start": "4456980",
    "end": "4462739"
  },
  {
    "text": "It's basically, if you laid\nout all the intervals incoming into this node, what\nis the maximum depth",
    "start": "4462740",
    "end": "4468290"
  },
  {
    "text": "of those intervals? What's the maximum intersection\nbetween all those intervals? That is your local degree.",
    "start": "4468290",
    "end": "4474200"
  },
  {
    "text": "And as long as that's the\nconstant, we're happy. ",
    "start": "4474200",
    "end": "4479516"
  },
  {
    "text": "All right. So now, let me specify\nwhat a search means.",
    "start": "4479516",
    "end": "4484590"
  },
  {
    "text": " This is the problem that\nfractional cascading can solve. ",
    "start": "4484590",
    "end": "4492150"
  },
  {
    "text": "Goal is to find x in\nsome k vertex sets.",
    "start": "4492150",
    "end": "4505310"
  },
  {
    "text": "So k vertices, each\nof them has a set. I want to find x in k of them.",
    "start": "4505310",
    "end": "4510860"
  },
  {
    "text": "Not all of them, k of them. That's the general problem. I have a constraint on\nhow those sets are found.",
    "start": "4510860",
    "end": "4516945"
  },
  {
    "start": "4516945",
    "end": "4523170"
  },
  {
    "text": "They're found by navigating this\ngraph starting from any vertex.",
    "start": "4523170",
    "end": "4528775"
  },
  {
    "start": "4528775",
    "end": "4535010"
  },
  {
    "text": "And we navigate by following\nedges whose labels contain x.",
    "start": "4535010",
    "end": "4542000"
  },
  {
    "start": "4542000",
    "end": "4550520"
  },
  {
    "text": "So we started some\nvertex in the graph. We can follow some\nedges that contain",
    "start": "4550520",
    "end": "4556159"
  },
  {
    "text": "x. x is a valid choice here\nthat's inside the interval. Then from here, maybe we\nfollow some more where",
    "start": "4556160",
    "end": "4562730"
  },
  {
    "text": "x is a valid choice, and so on. It could look like anything.",
    "start": "4562730",
    "end": "4569485"
  },
  {
    "text": "It doesn't have to be depth\nfirst or breadth first. It's just you follow\nsome tree from some node",
    "start": "4569485",
    "end": "4575030"
  },
  {
    "text": "where all of the\nedges are valid for x. At some point, you decide\nthat I've seen enough.",
    "start": "4575030",
    "end": "4582139"
  },
  {
    "text": "And now, the goal is to find\nin this set, where is x?",
    "start": "4582140",
    "end": "4587750"
  },
  {
    "text": "In this set, where is x? In this set, where is x? In each of these lists, what\nis a predecessor and successor",
    "start": "4587750",
    "end": "4594090"
  },
  {
    "text": "of x? Question. AUDIENCE: So there's\ngenerally some root node from which all queries start? ERIK DEMAINE: I believe you do\nnot need a single root node.",
    "start": "4594090",
    "end": "4602420"
  },
  {
    "text": "Each search could start\nfrom a different point. AUDIENCE: OK. So it's [INAUDIBLE]. ERIK DEMAINE: But\nyou're told where.",
    "start": "4602420",
    "end": "4608090"
  },
  {
    "text": "So imagine this is like\nan interaction between two parties. So the input basically says,\nlook, I'm searching for x.",
    "start": "4608090",
    "end": "4615350"
  },
  {
    "text": "And I'm going to\nstart at this node. And then the fractional\ncascading data structure says, OK, here's where\nx is in that node.",
    "start": "4615350",
    "end": "4621559"
  },
  {
    "text": "It tells you immediately. Why not? Then it says, OK, I'd\nlike to follow this edge",
    "start": "4621560",
    "end": "4627050"
  },
  {
    "text": "and go to this node. And fractional\ncascading says, OK, here's where x is in this\nnode in constant time.",
    "start": "4627050",
    "end": "4632670"
  },
  {
    "text": "OK. Then now these two\nguys are active. And now, the adversary, the\ninput, whatever, can decide,",
    "start": "4632670",
    "end": "4639030"
  },
  {
    "text": "OK, I'm going to follow this\nedge, or this edge, any order. It can build this\ntree in any order.",
    "start": "4639030",
    "end": "4644120"
  },
  {
    "text": "And every time it says here's\nthe edge I want to follow, the fractional cascading data\nstructure in constant time",
    "start": "4644120",
    "end": "4650239"
  },
  {
    "text": "tells you here's\nwhere x is among all the items in that node. How does it do that?",
    "start": "4650240",
    "end": "4655730"
  },
  {
    "text": "With fractional cascading. You just take half the items. Half doesn't work anymore.",
    "start": "4655730",
    "end": "4661040"
  },
  {
    "text": "Now, it depends on\nthat bounded n degree. But you take some\nfunction of that degree",
    "start": "4661040",
    "end": "4666530"
  },
  {
    "text": "c, take some constant\nfraction of the items, promote them to all\nthe things, keep going.",
    "start": "4666530",
    "end": "4674030"
  },
  {
    "text": "It's a little trickier,\nbecause now you have cycles. So you could actually\npromote back into yourself,",
    "start": "4674030",
    "end": "4679310"
  },
  {
    "text": "eventually, by chain reactions. But if you set the\nconstant low enough, it's like radioactive decay.",
    "start": "4679310",
    "end": "4685700"
  },
  {
    "text": "Eventually, it all\ngoes away, right? I wish. ",
    "start": "4685700",
    "end": "4692389"
  },
  {
    "text": "So it's much better\nthan radioactive decay. Radioactive is logarithmic. This is exponential. So it's decreasing very quickly.",
    "start": "4692390",
    "end": "4698510"
  },
  {
    "text": "After log n steps, all\nyour items are gone. So, yeah, maybe you go in\na short loop for a while.",
    "start": "4698510",
    "end": "4703619"
  },
  {
    "text": "But after log n\nsteps, it's all gone. So you're, at most,\nincreasing by a log factor.",
    "start": "4703620",
    "end": "4708690"
  },
  {
    "text": "In fact, you just increase\nby a constant factor, because the number\nof items that remain gets so tiny very quickly.",
    "start": "4708690",
    "end": "4715144"
  },
  {
    "text": "So I'm not going to\ngo into the details, but you just take this list\nidea, apply it to your graph.",
    "start": "4715144",
    "end": "4720320"
  },
  {
    "text": "It works. It gets messier. But in this very\ngeneral scenario, you can support\nthese searches in k",
    "start": "4720320",
    "end": "4728870"
  },
  {
    "text": "plus log n where n, let's\nsay, is the maximum size of any vertex set.",
    "start": "4728870",
    "end": "4735650"
  },
  {
    "start": "4735650",
    "end": "4741199"
  },
  {
    "text": "So just it directly generalizes. And this is the\nthing that you can",
    "start": "4741200",
    "end": "4746420"
  },
  {
    "text": "use to get this log\nfactor improvement",
    "start": "4746420",
    "end": "4751520"
  },
  {
    "text": "and many other things. Actually, this was such\na big thing at the time. There were two papers on\nfractional cascading, part 1",
    "start": "4751520",
    "end": "4757850"
  },
  {
    "text": "and part 2. Part 1 is what is solving this. And part 2 is applications.",
    "start": "4757850",
    "end": "4763312"
  },
  {
    "text": "They solved a ton of\nproblems that no one knew how to solve using this\ngeneral fractional cascading",
    "start": "4763312",
    "end": "4768380"
  },
  {
    "text": "technique. That's it for today.",
    "start": "4768380",
    "end": "4771429"
  }
]