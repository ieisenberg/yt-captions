[
  {
    "start": "0",
    "end": "40000"
  },
  {
    "text": " The following content is\nprovided under a Creative Commons license.",
    "start": "0",
    "end": "5310"
  },
  {
    "text": "Your support will help\nMIT OpenCourseWare continue to offer high-quality\neducational resources for free.",
    "start": "5310",
    "end": "11610"
  },
  {
    "text": "To make a donation or to\nview additional materials from hundreds of MIT courses,\nvisit MIT OpenCourseWare",
    "start": "11610",
    "end": "18140"
  },
  {
    "text": "at ocw.mit.edu.  JULIAN SHUN: Good\nafternoon, everybody.",
    "start": "18140",
    "end": "24020"
  },
  {
    "text": "So welcome to the\nthird lecture of 6.172.",
    "start": "24020",
    "end": "29590"
  },
  {
    "text": "Today we're going to\ntalk about bit hacks, and today's going to be\na really fun lecture. ",
    "start": "29590",
    "end": "36510"
  },
  {
    "text": "So, first of all, let's recall\nthe binary representation of a word. So a w-bit word is\nrepresented as follows.",
    "start": "36510",
    "end": "45390"
  },
  {
    "start": "40000",
    "end": "40000"
  },
  {
    "text": "So we're going to number the\nbits from x0 to xw minus 1 starting from the\nrightmost side.",
    "start": "45390",
    "end": "53370"
  },
  {
    "text": "And the unsigned\ninteger value stored in x with this\nbinary representation can be computed as follows.",
    "start": "53370",
    "end": "59820"
  },
  {
    "text": "So it's essentially the sum of\na whole bunch of powers of 2. And you sum the product of the\nbit with the appropriate power",
    "start": "59820",
    "end": "68320"
  },
  {
    "text": "of 2. So if the bit is\n1 in position k, then you multiply by 2 to the k. And if it's 0, then\nyou just add 0.",
    "start": "68320",
    "end": "75350"
  },
  {
    "text": "So, for example, let's say\nwe have this 8-bit word here. And if we apply this\nequation, we get--",
    "start": "75350",
    "end": "83840"
  },
  {
    "text": "first we get 2 because there is\none bit in the first position. So we multiply 1 by\n2 to 1, which is 2.",
    "start": "83840",
    "end": "92090"
  },
  {
    "text": "Then in the second\nposition, we also have a 1. So we multiply 1 by 2\nto the 2, which is 4.",
    "start": "92090",
    "end": "99330"
  },
  {
    "text": "And then we have 16 and 128. So we just sum up all\nof these powers of 2",
    "start": "99330",
    "end": "104840"
  },
  {
    "text": "and that gives us the\nunsigned integer value. And that 0b prefix here\nrepresents a Boolean constant.",
    "start": "104840",
    "end": "114479"
  },
  {
    "text": "So that means we're going\nto interpret this constant as a Boolean value. ",
    "start": "114480",
    "end": "121580"
  },
  {
    "text": "There's also signed integers. So you can also represent\nnegative numbers, which is useful, and this\nis called the two's",
    "start": "121580",
    "end": "127780"
  },
  {
    "text": "complement representation. And here's the\nformula for computing the two's complement\nrepresentation of a word.",
    "start": "127780",
    "end": "134290"
  },
  {
    "text": "So for bit 0 all the\nway up to bit w minus 2, you do the same thing as above.",
    "start": "134290",
    "end": "141459"
  },
  {
    "text": "But for the leftmost\nbit or bit w minus 1,",
    "start": "141460",
    "end": "146530"
  },
  {
    "text": "you subtract that bit multiplied\nby 2 to the w minus 1.",
    "start": "146530",
    "end": "151984"
  },
  {
    "text": "So for this example here,\nwe saw 2 plus 4 plus 16.",
    "start": "151984",
    "end": "158680"
  },
  {
    "text": "That's the same as above. But for the leftmost bit,\nsince we have a 1 here, we're going to subtract\n2 the 7, which is 128.",
    "start": "158680",
    "end": "167170"
  },
  {
    "text": "And this gives us\nthe signed value for the integer,\nwhich is negative 106.",
    "start": "167170",
    "end": "174099"
  },
  {
    "text": "Does that make sense? Any questions about\nthis representation? ",
    "start": "174100",
    "end": "182140"
  },
  {
    "text": "So the leftmost bit\nis known as a sign bit because it tells you\nwhether you need to subtract",
    "start": "182140",
    "end": "189730"
  },
  {
    "text": "by this negative value or not. So if it's 0, then you don't\nhave to subtract anything. If it's 1, then you subtract\nby a large integer value.",
    "start": "189730",
    "end": "200500"
  },
  {
    "start": "198000",
    "end": "198000"
  },
  {
    "text": "So in two's complement,\nthe all 0's word is just 0. So you just apply the above\nformula and everything is 0.",
    "start": "200500",
    "end": "208150"
  },
  {
    "text": "So you just get 0. What's the value of\nthe all 1's word?",
    "start": "208150",
    "end": "213360"
  },
  {
    "text": " Yes. AUDIENCE: 1.",
    "start": "213360",
    "end": "218580"
  },
  {
    "text": "JULIAN SHUN: Negative 1, right? So the reason why it's\nnegative 1, so you can just",
    "start": "218580",
    "end": "225060"
  },
  {
    "text": "use the formula. And we're going to sum up\na bunch of powers of 2.",
    "start": "225060",
    "end": "230340"
  },
  {
    "text": "All of the x sub k's\nare going to be 1. So we're summing up 2 to the k\nfrom k equals 0 to w minus 2,",
    "start": "230340",
    "end": "238170"
  },
  {
    "text": "and that's a geometric series\nwhich sums to 2 to the w minus 1 minus 1.",
    "start": "238170",
    "end": "243700"
  },
  {
    "text": "And then for the\nsign bit, we're going to subtract 2 to the w minus 1. So now the 2 to the w\nminus 1's cancel out",
    "start": "243700",
    "end": "250800"
  },
  {
    "text": "and we're just left\nwith negative 1. So this is an important\nproperty to know about two's",
    "start": "250800",
    "end": "257160"
  },
  {
    "text": "complement representation. The all 1's word\nis just negative 1.",
    "start": "257160",
    "end": "264341"
  },
  {
    "start": "264000",
    "end": "264000"
  },
  {
    "text": "And this leads to important\nidentity which says that x plus the one's complement of x-- the\none's complement is just all",
    "start": "264342",
    "end": "271990"
  },
  {
    "text": "the bits of x flipped-- is equal to negative 1. This is because if you add x\nwith all of it bits flipped,",
    "start": "271990",
    "end": "280860"
  },
  {
    "text": "then you're just going to\nend up with the all 1's word. And we saw on the\nprevious slide that that's equal to negative 1.",
    "start": "280860",
    "end": "286979"
  },
  {
    "text": "And from this identity,\nwe have that negative x is equal to the one's\ncomplement of x plus 1.",
    "start": "286980",
    "end": "292990"
  },
  {
    "text": "So this relates the\ntwo's complement to the one's complement\nrepresentation.",
    "start": "292990",
    "end": "298360"
  },
  {
    "text": "Let's look at an example. So let's look at-- let's say x is equal\nto this constant here.",
    "start": "298360",
    "end": "305789"
  },
  {
    "text": "The one's complement\nof x or tilde of x is just all of the\nbits of x flipped.",
    "start": "305790",
    "end": "312389"
  },
  {
    "text": "And then to get\nnegative x, we add 1 to the one's complement of x.",
    "start": "312390",
    "end": "317940"
  },
  {
    "text": "And the fact of\nadding 1 here is we're going to take the rightmost 0\nbit in the one's complement,",
    "start": "317940",
    "end": "325289"
  },
  {
    "text": "flip that to a 1. And then for all of the\nbits to the right of that, we flip them to 0's.",
    "start": "325290",
    "end": "330750"
  },
  {
    "text": " So another way to\nsee this is you",
    "start": "330750",
    "end": "337330"
  },
  {
    "text": "look at the representation of\nx and you flip all of the bits up to the rightmost 1 but not\nincluding that rightmost 1 bit,",
    "start": "337330",
    "end": "345185"
  },
  {
    "text": "and then you just\ncopy everything over.  So any questions about this?",
    "start": "345185",
    "end": "351289"
  },
  {
    "text": " OK. ",
    "start": "351290",
    "end": "357759"
  },
  {
    "text": "So this is a table showing\nthe relationship between hex",
    "start": "357760",
    "end": "363370"
  },
  {
    "start": "358000",
    "end": "358000"
  },
  {
    "text": "and binary representation. So hex representation\nis base 16. And the reason why we use\nhex is because sometimes we",
    "start": "363370",
    "end": "371740"
  },
  {
    "text": "have these big binary constants\nand we don't want to write-- have to type all of these\nsymbols into our code.",
    "start": "371740",
    "end": "378100"
  },
  {
    "text": "And hex gives us a\nmore compact format to write these constants.",
    "start": "378100",
    "end": "383349"
  },
  {
    "text": "And this table, you\ncan basically just look up, for each\npossible hex value, what",
    "start": "383350",
    "end": "389680"
  },
  {
    "text": "its binary representation is. And for the values\nfrom 0 to 9, we're",
    "start": "389680",
    "end": "396189"
  },
  {
    "text": "just going to use the same as\ndecimal representation for hex. And then for values\n10 to 15, we're going to use the\ncharacters from A to F.",
    "start": "396190",
    "end": "407460"
  },
  {
    "text": "To translate from hex to binary,\nyou just take each hex digit, look it up in this table, write\nout the binary equivalent,",
    "start": "407460",
    "end": "415620"
  },
  {
    "text": "and then you\nconcatenate together all of the binary\nvalues you've got. So in this example I\nhave this hex constant",
    "start": "415620",
    "end": "423960"
  },
  {
    "text": "which says DEC1DE2C0DE4F00D. So now I just look up each of\nthese hex values in this table.",
    "start": "423960",
    "end": "431970"
  },
  {
    "text": "So D is 1101, E is 1110,\nC is 1100, and so on.",
    "start": "431970",
    "end": "438940"
  },
  {
    "text": "And I just concatenate all\nof these values together and that gives me my\nbinary representation.",
    "start": "438940",
    "end": "446192"
  },
  {
    "text": "And you can also go\nthe other way around, converting binary to hex. And you do the same thing,\njust look it up in this table.",
    "start": "446192",
    "end": "453120"
  },
  {
    "text": " And the prefix 0x here\ndesignates a hex constant,",
    "start": "453120",
    "end": "459889"
  },
  {
    "text": "just like 0b designates\nthe Boolean constant. So if you're using these\nconstants in your code",
    "start": "459890",
    "end": "465867"
  },
  {
    "text": "and you're writing\nit in hex, then you should use the 0x prefix. ",
    "start": "465867",
    "end": "475400"
  },
  {
    "start": "473000",
    "end": "473000"
  },
  {
    "text": "So C has a bunch of\nbitwise operators. And here's a table\ndescribing what",
    "start": "475400",
    "end": "480950"
  },
  {
    "text": "these bitwise operators do. So the ampersand is\njust logical AND. The vertical bar is logical OR.",
    "start": "480950",
    "end": "489590"
  },
  {
    "text": "This caret sign is the\nXOR or exclusive OR. And XOR just says that if\neither of the two bits is 1,",
    "start": "489590",
    "end": "497660"
  },
  {
    "text": "then we return 1. And if both of the bits are\n0 or both of them are 1, then we return 0.",
    "start": "497660",
    "end": "504759"
  },
  {
    "text": "The tilde sign is the one's\ncomplement or the not.",
    "start": "504760",
    "end": "510800"
  },
  {
    "text": "And then we have left shift\nand right shift operators. So let's look at how these\noperatives work on this example",
    "start": "510800",
    "end": "519029"
  },
  {
    "text": "here. So we have these\ntwo 8-bit words, A and B. To compute A AND B,\nwe just look at every two bits",
    "start": "519030",
    "end": "527750"
  },
  {
    "text": "in the same position\nin A and B and compute the AND of those two bits. So 1 ANDed with 0 is\n0, so we get 0 here.",
    "start": "527750",
    "end": "537130"
  },
  {
    "text": "0 ANDed with 1 is 0. 1 ended with 1 is 1, and so on.",
    "start": "537130",
    "end": "543512"
  },
  {
    "text": "A OR B is similar but now\nyou apply the OR operator instead of the AND operator.",
    "start": "543512",
    "end": "549290"
  },
  {
    "text": "So if either one of\nthe two positions is 1, then you return 1. And if both are 0,\nthen you return 0.",
    "start": "549290",
    "end": "554899"
  },
  {
    "text": "So an A OR B, all of the\nbits except for this bit here is 0 because in the\noriginal two words",
    "start": "554900",
    "end": "563340"
  },
  {
    "text": "both of the corresponding\nbits were 0. For A XOR B, we check if exactly\none of the two bits is 1.",
    "start": "563340",
    "end": "572569"
  },
  {
    "text": "So for the leftmost\nbit, we have 1 and 0,",
    "start": "572570",
    "end": "577790"
  },
  {
    "text": "so we have exactly one bit\nset to 1 and we get a 1 here. The second bit is 0\nand 1, so that's 1.",
    "start": "577790",
    "end": "584910"
  },
  {
    "text": "The third bit is 1, 1,\nso that's 0, and so on. Tilde of A is just the one's\ncomplement of A. We saw",
    "start": "584910",
    "end": "591330"
  },
  {
    "text": "that before. We just flip all the bits. A right shifted by 3, we\njust shift the bit string",
    "start": "591330",
    "end": "598100"
  },
  {
    "text": "to the right by 3, and then we\nfill in the digits or the bits",
    "start": "598100",
    "end": "603800"
  },
  {
    "text": "on the left with 0's. And then A left shifted\nwith 2, we do the same thing",
    "start": "603800",
    "end": "609140"
  },
  {
    "text": "but to the left. And then we fill in these\nempty bits with 0's. ",
    "start": "609140",
    "end": "615440"
  },
  {
    "text": "So these are the bitwise\noperators in C. Any questions? ",
    "start": "615440",
    "end": "628160"
  },
  {
    "text": "AUDIENCE: They're\nnot [INAUDIBLE]?? ",
    "start": "628160",
    "end": "634470"
  },
  {
    "text": "JULIAN SHUN: For a right\nshift, there is a-- there is a shift that will\nfill in the upper digits",
    "start": "634470",
    "end": "642190"
  },
  {
    "text": "with whatever the\nleftmost digit was. But if you're working\nwith unsigned integers,",
    "start": "642190",
    "end": "647980"
  },
  {
    "text": "then it's not going to do that. For signed integers it will. And when we're doing\nbit manipulations,",
    "start": "647980",
    "end": "653980"
  },
  {
    "text": "we're usually going to\nstick to unsigned integers, so we don't have to\nworry about that. ",
    "start": "653980",
    "end": "664430"
  },
  {
    "start": "662000",
    "end": "662000"
  },
  {
    "text": "So now let's look at\nsome common idioms that you can do using\nthese bitwise operators. So the first one we'll\nlook at is setting",
    "start": "664430",
    "end": "671720"
  },
  {
    "text": "the kth bit in a word x to 1. So the idea here is to use\na shift followed by an OR.",
    "start": "671720",
    "end": "680210"
  },
  {
    "text": "So we're going to compute\n1 left-shift it by k if we want to set the kth bit to a 1.",
    "start": "680210",
    "end": "687410"
  },
  {
    "text": "And this gives us a mask with a\n1 in exactly the kth position, and 0's everywhere else.",
    "start": "687410",
    "end": "694050"
  },
  {
    "text": "And then now when\nwe OR that in to x, that's going to change the bit\nfrom a 0 to a 1 if it was a 0.",
    "start": "694050",
    "end": "700070"
  },
  {
    "text": "And if that bit was\nalready set to 1, then this doesn't do anything. And then for all of\nthe other positions, since we're doing\nan OR with 0, we're",
    "start": "700070",
    "end": "706520"
  },
  {
    "text": "just copying over\nthe bits from x. So that's setting the kth bit.",
    "start": "706520",
    "end": "714209"
  },
  {
    "start": "714000",
    "end": "714000"
  },
  {
    "text": "We can also clear the kth bit. And the idea here is to use a\nshift, a complement, and then an AND.",
    "start": "714210",
    "end": "720440"
  },
  {
    "text": "So again we're going to generate\nthis mask, 1 left-shifted by k. But now we're going to take\nthe complement of this.",
    "start": "720440",
    "end": "727300"
  },
  {
    "text": "So now we have a 0 in exactly\nthe kth position and 1's everywhere else.",
    "start": "727300",
    "end": "734300"
  },
  {
    "text": "And now when we AND this mask\nwith x, in the kth position it's going to clear\nthat bit because we're",
    "start": "734300",
    "end": "740420"
  },
  {
    "text": "ANDing it with a 0. So the result is going\nto be 0 no matter what was there before. And then for all\nthe remaining bits,",
    "start": "740420",
    "end": "747440"
  },
  {
    "text": "since we're ANDing with 1,\nwe're just copying it over from the original word. ",
    "start": "747440",
    "end": "756889"
  },
  {
    "text": "You can toggle the kth\nbit or flip the kth bit using a shift and then an XOR.",
    "start": "756890",
    "end": "762920"
  },
  {
    "start": "759000",
    "end": "759000"
  },
  {
    "text": "So, again, we're going\nto generate this mask. And then now, when we do\nan XOR with this mask,",
    "start": "762920",
    "end": "768920"
  },
  {
    "text": "it's going to change a bit from\na 0 to 1, or from a 1 to a 0, because that's what XOR does.",
    "start": "768920",
    "end": "776330"
  },
  {
    "text": "So in this example, it's\nchanging from a 0 to 1. But if it was already\na 1, then it's going to toggle it back to 0.",
    "start": "776330",
    "end": "782180"
  },
  {
    "text": " Any questions? ",
    "start": "782180",
    "end": "792290"
  },
  {
    "text": "So let's look at\nanother bit trick. So here we're trying to extract\na bit field from a word x.",
    "start": "792290",
    "end": "801500"
  },
  {
    "start": "793000",
    "end": "793000"
  },
  {
    "text": "And this is important if you're\nworking with encoded data. And the idea here is to\ndo a mask and a shift.",
    "start": "801500",
    "end": "809720"
  },
  {
    "text": "So we're going to generate\na mask with 1's in exactly",
    "start": "809720",
    "end": "814819"
  },
  {
    "text": "the positions that we want\nto extract out of this word, and then 0's everywhere else.",
    "start": "814820",
    "end": "821329"
  },
  {
    "text": "And then we're going to\nAND the x with the mask, and that's going to give us\nthe bits in the four positions",
    "start": "821330",
    "end": "827480"
  },
  {
    "text": "that we wanted to\nextract in this example, and then we have\n0's everywhere else. ",
    "start": "827480",
    "end": "833950"
  },
  {
    "text": "And then now we're going\nto right-shift this value that we extracted so that\nit appears in the least",
    "start": "833950",
    "end": "840790"
  },
  {
    "text": "significant digits so that we\ncan use it in our computation.",
    "start": "840790",
    "end": "846730"
  },
  {
    "text": "So this is a very\nuseful bit trick to know if you're working with\ncompressed or encoded data.",
    "start": "846730",
    "end": "853389"
  },
  {
    "text": "And if you use the bit\nfield facilities in C, it's actually going to generate\nassembly code that will do",
    "start": "853390",
    "end": "861279"
  },
  {
    "text": "masking and shifting for you. ",
    "start": "861280",
    "end": "867880"
  },
  {
    "start": "866000",
    "end": "866000"
  },
  {
    "text": "You can also set a\nbit field in a word. So let's say we want to set a\nbit field in x to some value y.",
    "start": "867880",
    "end": "876300"
  },
  {
    "text": "The idea is to first invert\nthis mask to clear those bits we want to set in x.",
    "start": "876300",
    "end": "881820"
  },
  {
    "text": "And then we OR in the\nshifted value of y. So let's say we have these\ntwo words, x and y here.",
    "start": "881820",
    "end": "890180"
  },
  {
    "text": "We're going to generate\nthe mask as we did before, but now we're going to flip\nall the bits in the mask by taking the one's complement.",
    "start": "890180",
    "end": "897440"
  },
  {
    "text": "And then we AND the-- we AND the one's\ncomplement of the mask",
    "start": "897440",
    "end": "903260"
  },
  {
    "text": "with x, and that's going to\nclear the bits in x because we",
    "start": "903260",
    "end": "909230"
  },
  {
    "text": "have 0's in exactly those\npositions in that mask, and when you AND that into\nx it will return to 0.",
    "start": "909230",
    "end": "914840"
  },
  {
    "text": "And then for all\nthe other positions, we're just copying\nin the bits of x. ",
    "start": "914840",
    "end": "921500"
  },
  {
    "text": "And then, finally, we're\ngoing to left-shift y by an appropriate\namount so that we",
    "start": "921500",
    "end": "926660"
  },
  {
    "text": "can line up the value with\nthese four bit positions here. And then we can now\njust OR those values in.",
    "start": "926660",
    "end": "933260"
  },
  {
    "text": "And this will set the\npositions in x to the value y. ",
    "start": "933260",
    "end": "944790"
  },
  {
    "text": "In order to be safe,\nyou should actually do a mask on the shifted y\nvalue before you OR it in,",
    "start": "944790",
    "end": "949800"
  },
  {
    "text": "because you don't know\nthat the value of y is within the range of the mask. So if y has some garbage\nvalues in the higher bits,",
    "start": "949800",
    "end": "958680"
  },
  {
    "text": "when you OR this\nin it might pollute the original value of x. So, for safety,\nyou should actually",
    "start": "958680",
    "end": "963750"
  },
  {
    "text": "do a mask before you OR the\nvalue, the shifted value of y in. ",
    "start": "963750",
    "end": "975330"
  },
  {
    "text": "So any questions on this? ",
    "start": "975330",
    "end": "981990"
  },
  {
    "start": "980000",
    "end": "980000"
  },
  {
    "text": "So now let's look at how\nwe can swap two integers. So we want to swap\nthe values of x and y.",
    "start": "981990",
    "end": "989480"
  },
  {
    "text": "The standard way to do this is\nto use a temporary variable t. So we set t equal to x, x equal\nto y, and then y equal to t.",
    "start": "989480",
    "end": "997490"
  },
  {
    "text": " This does involve a\ntemporary variable, however.",
    "start": "997490",
    "end": "1003570"
  },
  {
    "text": "So now the question\nis whether we can do a swap without\nusing a temporary variable. It turns out that you\ncan using bit tricks.",
    "start": "1003570",
    "end": "1011940"
  },
  {
    "text": "So here's the code for\ndoing a no-temp swap. So you first set\nx equal to x XOR",
    "start": "1011940",
    "end": "1018210"
  },
  {
    "text": "y, then y equal to x XOR y,\nand then x equal to x XOR y.",
    "start": "1018210",
    "end": "1024780"
  },
  {
    "text": "So has anyone seen this before? OK, good. So some of you have\nseen this before.",
    "start": "1024780",
    "end": "1031180"
  },
  {
    "text": "And for the rest\nof you all, I'll tell you how it works in\nthe next couple slides. So let's first\nlook at an example",
    "start": "1031180",
    "end": "1038160"
  },
  {
    "text": "of how to run this\ncode before we go into why it actually works. So we're going to start with\nthese two words in x and y.",
    "start": "1038160",
    "end": "1047069"
  },
  {
    "text": "We're first going to\ndo x equal x XOR y. And now we store\nthe result in x.",
    "start": "1047069",
    "end": "1053520"
  },
  {
    "text": "And this is the result when you\ndo the XOR of these two words. And then now we do\ny equal to x XOR y.",
    "start": "1053520",
    "end": "1061120"
  },
  {
    "text": "And notice how the value of\nx here has already changed. So we're doing the\nXOR of these two words",
    "start": "1061120",
    "end": "1067650"
  },
  {
    "text": "and setting that to y. And here this value is\nactually the same as x.",
    "start": "1067650",
    "end": "1073200"
  },
  {
    "text": "So we've already placed x in y. And, finally, we do another XOR.",
    "start": "1073200",
    "end": "1079170"
  },
  {
    "text": "We set x equal to x XOR y. And then this gives us\nthis value, which is y.",
    "start": "1079170",
    "end": "1086429"
  },
  {
    "text": "So at the end,\nwe've just swapped x and y without using\nany temporary variable. ",
    "start": "1086430",
    "end": "1094150"
  },
  {
    "text": "So the reason why this works is\nbecause XOR is its own inverse. So if you do x XOR y, and then\nXOR the result of that with y,",
    "start": "1094150",
    "end": "1103259"
  },
  {
    "text": "you just get back x itself. So let's look at the truth\ntable to see why this is true. So in the x and y columns, I've\nshown all the possibilities.",
    "start": "1103260",
    "end": "1113770"
  },
  {
    "text": "So there are four different\npossibilities of x and y. And then I also have\nthe values of x XOR y.",
    "start": "1113770",
    "end": "1120159"
  },
  {
    "text": "So it's 1 in the rows\nwhere I have exactly one 1,",
    "start": "1120160",
    "end": "1125670"
  },
  {
    "text": "and then 0 in the\nremaining rows. And then now if I do\nx XOR y XORed with y,",
    "start": "1125670",
    "end": "1133169"
  },
  {
    "text": "I'm going to XOR\nthese values with y. 0 XOR 0 is 0. 1 XOR 1 is 0.",
    "start": "1133170",
    "end": "1140250"
  },
  {
    "text": "1 XOR 0 is 1. And 0 XOR 1 is 1. And notice that these values\nare the same as the values of x.",
    "start": "1140250",
    "end": "1149310"
  },
  {
    "text": "So when I XOR something in\ntwice, it just cancels out",
    "start": "1149310",
    "end": "1154950"
  },
  {
    "text": "and I get back the\noriginal thing. ",
    "start": "1154950",
    "end": "1160720"
  },
  {
    "start": "1160000",
    "end": "1160000"
  },
  {
    "text": "So now let's go into why this\nbit trick actually does a swap.",
    "start": "1160720",
    "end": "1166780"
  },
  {
    "text": "So in the first line,\nwhat we're doing is we're generating a mask with\n1's where the bits in x and y",
    "start": "1166780",
    "end": "1174730"
  },
  {
    "text": "differ. Because that's what XOR\nis going to give you. It's going to return a 1\nif the bits are different, and 0 otherwise.",
    "start": "1174730",
    "end": "1180670"
  },
  {
    "text": "So this is a mask that\ntells us in which positions the bits in x and y differ.",
    "start": "1180670",
    "end": "1188340"
  },
  {
    "text": "And I'm going to\nstore that into x. And then in the second\nline, when I do x XOR y,",
    "start": "1188340",
    "end": "1194830"
  },
  {
    "text": "this is going to\nflip the bits in y that are different\nfrom x, because I'm XORing with this mask, which\ntells me which of the bits",
    "start": "1194830",
    "end": "1202150"
  },
  {
    "text": "differ from x. And then if I XOR\nwith that mask, I'm flipping the bits\nin y that differ from x,",
    "start": "1202150",
    "end": "1210580"
  },
  {
    "text": "and this will just\ngive me back x. And I store that in y. So we see that the original\nvalue of x is in y now.",
    "start": "1210580",
    "end": "1220270"
  },
  {
    "text": "And then in the last line,\nI do the same thing but now I'm flipping the bits in x\nthat are different from y. So I still have the\nmask that's stored in x.",
    "start": "1220270",
    "end": "1228250"
  },
  {
    "text": "And then I can XOR\nthat mask with y, and y has the\noriginal value of x.",
    "start": "1228250",
    "end": "1233380"
  },
  {
    "text": "So this is flipping the bits\nin x that differ from y, and now I have the original\nvalue of y stored in x.",
    "start": "1233380",
    "end": "1240760"
  },
  {
    "text": " So this is a pretty\ncool trick, right?",
    "start": "1240760",
    "end": "1247480"
  },
  {
    "text": "Any questions on why this works? ",
    "start": "1247480",
    "end": "1258050"
  },
  {
    "text": "So one thing about\nthis bit trick here is that it's actually\npoor at exploiting",
    "start": "1258050",
    "end": "1263080"
  },
  {
    "text": "instruction-level\nparallelism, so it's actually going to be slower than\nthe naive code that",
    "start": "1263080",
    "end": "1268750"
  },
  {
    "text": "uses a temporary variable. Because in the\noriginal code I had,",
    "start": "1268750",
    "end": "1274240"
  },
  {
    "text": "I could actually execute\ntwo lines in parallel. I can store value\ninto the temporary and then also change\none of the values",
    "start": "1274240",
    "end": "1281110"
  },
  {
    "text": "of x and y at the same time. Whereas in this\ncode here, there's a sequential dependence\namong these three lines.",
    "start": "1281110",
    "end": "1287830"
  },
  {
    "text": "I can't execute any of\nthe lines in parallel. We'll learn more about\ninstruction-level parallelism",
    "start": "1287830",
    "end": "1294580"
  },
  {
    "text": "in next week's\nlectures, but I just wanted to point out that\nthe performance of this",
    "start": "1294580",
    "end": "1300787"
  },
  {
    "text": "isn't actually that great. But this is actually a\npretty cool trick to know. Sometimes it shows\nup in job interviews.",
    "start": "1300787",
    "end": "1307642"
  },
  {
    "text": " So the next thing\nwe're going to look at",
    "start": "1307642",
    "end": "1315890"
  },
  {
    "start": "1314000",
    "end": "1314000"
  },
  {
    "text": "is finding the minimum\nof two integers, x and y.",
    "start": "1315890",
    "end": "1321830"
  },
  {
    "text": "So let's say we want\nto store the result of the minimum in a variable r. Here's the standard\nway to do this.",
    "start": "1321830",
    "end": "1329540"
  },
  {
    "text": "We just use an\nif-else statement. So if x is less\nthan y, than r is x. And, otherwise, r is set to y.",
    "start": "1329540",
    "end": "1337610"
  },
  {
    "text": "Here's an equivalent expression. It just uses the\nternary operator in C. It does exactly the same\nthing as the if-else statement",
    "start": "1337610",
    "end": "1344750"
  },
  {
    "text": "on the left. ",
    "start": "1344750",
    "end": "1351710"
  },
  {
    "text": "One performance\nproblem with this code is that there is a\nbranch in the code. So we have this\nif statement that",
    "start": "1351710",
    "end": "1357390"
  },
  {
    "text": "checks if x is less than y. And modern machines will\ndo branch prediction.",
    "start": "1357390",
    "end": "1363600"
  },
  {
    "text": "And for whatever branch it\npredicts the code to take, it's going to do\nprefetching and execute some of the instructions in advance.",
    "start": "1363600",
    "end": "1370870"
  },
  {
    "text": "But the problem is if it\nmispredicts the branch, it does a lot of wasted\nwork, and the processor",
    "start": "1370870",
    "end": "1377970"
  },
  {
    "text": "has to empty the pipeline\nand undo all of the work that it did. So this is a performance issue\ndue to branch misprediction.",
    "start": "1377970",
    "end": "1388170"
  },
  {
    "text": "Modern compilers are\nusually good enough to optimize this branch away,\nbut sometimes the compiler isn't good enough to\noptimize the branch away.",
    "start": "1388170",
    "end": "1395820"
  },
  {
    "text": "So is there a way to do a\nminimum without using a branch? ",
    "start": "1395820",
    "end": "1403240"
  },
  {
    "start": "1403000",
    "end": "1403000"
  },
  {
    "text": "All right. So here's how you do it. So we set r equal to y XOR\nx or y ANDed with negative x",
    "start": "1403240",
    "end": "1412000"
  },
  {
    "text": "less than y. So it's pretty obvious, right? ",
    "start": "1412000",
    "end": "1419710"
  },
  {
    "text": "So why does this work? So first we need to know that\nthe C language represents",
    "start": "1419710",
    "end": "1426120"
  },
  {
    "text": "the Boolean values\ntrue and false with the integers 1\nand 0, respectively.",
    "start": "1426120",
    "end": "1432250"
  },
  {
    "text": "So now let's look at\nthe two possible cases. First, let's look at a case\nwhere x is less than y,",
    "start": "1432250",
    "end": "1437370"
  },
  {
    "text": "and then we'll look\nat the case where x is greater than or equal to y. So in the first case,\nwhen x is less than y,",
    "start": "1437370",
    "end": "1445800"
  },
  {
    "text": "the comparison here x less\nthan y is going to return 1. And then we're going\nto negate that, which gives us negative 1.",
    "start": "1445800",
    "end": "1451860"
  },
  {
    "text": "And recall from\nearlier, negative 1 is the all 1's word in two's\ncomplement representation.",
    "start": "1451860",
    "end": "1459480"
  },
  {
    "text": "So when we AND x XOR\ny with all 1's word,",
    "start": "1459480",
    "end": "1464610"
  },
  {
    "text": "that just gives us x XOR y. And now we're left\nwith y XOR x XOR y.",
    "start": "1464610",
    "end": "1471110"
  },
  {
    "text": "And we know that the-- we know that the inverse\nof XOR is itself.",
    "start": "1471110",
    "end": "1477990"
  },
  {
    "text": "And therefore the two\ny's cancel out here and we're just left with x. And in this case x is\nindeed the minimum.",
    "start": "1477990",
    "end": "1484620"
  },
  {
    "text": " In the other case, we have x\ngreater than or equal to y.",
    "start": "1484620",
    "end": "1492490"
  },
  {
    "text": "Then the expression x less\nthan y is going to return 0. Negative of 0 is still 0.",
    "start": "1492490",
    "end": "1497710"
  },
  {
    "text": "And then when we AND x XOR\ny with 0, we're left with 0. And this just gives us\ny XOR 0, which is y.",
    "start": "1497710",
    "end": "1505360"
  },
  {
    "text": "And in this case y is the\nminimum of the two integers. ",
    "start": "1505360",
    "end": "1511140"
  },
  {
    "text": "So any questions? ",
    "start": "1511140",
    "end": "1520710"
  },
  {
    "text": "So how many of you-- how many of you\nknew this already? ",
    "start": "1520710",
    "end": "1526230"
  },
  {
    "text": "Good. So we learned\nsomething new today. So let's see how branches\nwork in a real function.",
    "start": "1526230",
    "end": "1536639"
  },
  {
    "start": "1536000",
    "end": "1536000"
  },
  {
    "text": "So here we're trying to merge\ntogether two sorted arrays, and this is a subroutine\nthat's used in merge sort if you've seen it before.",
    "start": "1536640",
    "end": "1544370"
  },
  {
    "text": "So the inputs to this\nfunction are three arrays. So we want to merge\ntogether arrays A and B",
    "start": "1544370",
    "end": "1550220"
  },
  {
    "text": "and store the result\nin C. And then we also pass the function the\nsizes of A and B in na and nb.",
    "start": "1550220",
    "end": "1557060"
  },
  {
    "text": " So what does the\nrestrict keyword do here? Does anyone know?",
    "start": "1557060",
    "end": "1562470"
  },
  {
    "start": "1562470",
    "end": "1567980"
  },
  {
    "text": "So the restrict keyword\ntells the compiler that this is going to be\nthe only pointer that can",
    "start": "1567980",
    "end": "1573570"
  },
  {
    "text": "point to that particular data. And this enables the compiler\nto do more optimizations.",
    "start": "1573570",
    "end": "1580135"
  },
  {
    "text": "So when you're writing\nprograms and you know that there can only\nbe one pointer pointing to specific pieces\nof data, then you",
    "start": "1580135",
    "end": "1586620"
  },
  {
    "text": "can declare that\nrestrict keyword, and this gives the compiler more\nfreedom to do optimizations.",
    "start": "1586620",
    "end": "1592230"
  },
  {
    "text": " So now let's look at\nthis procedure here.",
    "start": "1592230",
    "end": "1599590"
  },
  {
    "text": "So while the sizes of\nA and B are nonzero, we're going to go into\nthis if-else clause",
    "start": "1599590",
    "end": "1605860"
  },
  {
    "text": "and we're going to check if\nthe element pointed to by A is",
    "start": "1605860",
    "end": "1611170"
  },
  {
    "text": "less than or equal to the\nelement pointed to by B. And if so, we're going to\nstore that element pointed to by A into C. And then\nwe're going to increment",
    "start": "1611170",
    "end": "1618880"
  },
  {
    "text": "both the C and A pointers. And then we're going\nto decrement na.",
    "start": "1618880",
    "end": "1624100"
  },
  {
    "text": "This tells us that there's\none less element in A that we need to merge in now.",
    "start": "1624100",
    "end": "1629460"
  },
  {
    "text": "And, otherwise, we do the same\nthing but with array B and nb.",
    "start": "1629460",
    "end": "1634799"
  },
  {
    "text": "And if one of the two\narrays becomes empty, then we go to one of these\ntwo while loops at the bottom",
    "start": "1634800",
    "end": "1642350"
  },
  {
    "text": "and we just copy all\nthe remaining elements in the non-empty\narray into C. So here,",
    "start": "1642350",
    "end": "1649010"
  },
  {
    "text": "if na is greater than 0,\nthen A is a non-empty array, and then we just copy the\nremaining elements of A into C.",
    "start": "1649010",
    "end": "1654590"
  },
  {
    "text": "And, otherwise, we copy the\nremaining elements of B into C. So let's do a simple example.",
    "start": "1654590",
    "end": "1660809"
  },
  {
    "text": "Let's say we want to merge\nthese two arrays in green into the blue array here. So let's say the top array is\nA, and the bottom array is B,",
    "start": "1660810",
    "end": "1669590"
  },
  {
    "text": "and the blue array is C.\nSo, initially, A and B are pointing to the beginning\nof these two green arrays.",
    "start": "1669590",
    "end": "1677420"
  },
  {
    "text": "And since both\narrays are non-empty, we're going to compare the\nfirst two elements here.",
    "start": "1677420",
    "end": "1684020"
  },
  {
    "text": "And we see that\n3 is less than 4, so we're going to place\n3 into the array C. And then we're going to\nincrement the pointer in A",
    "start": "1684020",
    "end": "1691309"
  },
  {
    "text": "to point to the next element. And we're also going to\nincrement the pointer C to point to the next slot.",
    "start": "1691310",
    "end": "1698540"
  },
  {
    "text": "Now we're going to\ncompare 4 and 12. 4 is less than 12, so we\nplace 4 into the array C,",
    "start": "1698540",
    "end": "1704030"
  },
  {
    "text": "and we increment array B. And\nthen we just keep doing this. So 12 is less than 14.",
    "start": "1704030",
    "end": "1709789"
  },
  {
    "text": "14 is less than 19. 19 Is less than 21. 21 is less than 46.",
    "start": "1709790",
    "end": "1716380"
  },
  {
    "text": "And here 23 is less than 46. And at this point, one of\nthe arrays becomes empty. So B is empty now.",
    "start": "1716380",
    "end": "1722780"
  },
  {
    "text": "So now we get to the\nsecond while loop. And we see that A still\nhas elements in it, and we just copy the remaining\nelements in A into C.",
    "start": "1722780",
    "end": "1730257"
  },
  {
    "text": "And then we're done. ",
    "start": "1730257",
    "end": "1735260"
  },
  {
    "text": "So that's how the standard code\nfor merging two sorted arrays works. ",
    "start": "1735260",
    "end": "1742710"
  },
  {
    "start": "1742000",
    "end": "1742000"
  },
  {
    "text": "So let's look at each\nof these branches to see if it's predictable. So a predictable\nbranch is a branch",
    "start": "1742710",
    "end": "1750790"
  },
  {
    "text": "that most of the time it\nreturns the same answer, and only rarely does it\nreturn a different answer.",
    "start": "1750790",
    "end": "1756519"
  },
  {
    "text": "And an unpredictable branch is\none where it sometimes returns one value and sometimes\nreturns another value",
    "start": "1756520",
    "end": "1762049"
  },
  {
    "text": "and you can't really predict it. So let's look at\nthe first branch.",
    "start": "1762050",
    "end": "1767440"
  },
  {
    "text": "Does anyone know if this\nbranch is predictable? ",
    "start": "1767440",
    "end": "1776700"
  },
  {
    "text": "Yes. AUDIENCE: That would\nbe unpredictable because it depends on\nwhat input you're given.",
    "start": "1776700",
    "end": "1783562"
  },
  {
    "text": "JULIAN SHUN: So it turns out\nthat this branch is actually predictable because it's going\nto return true most of the time",
    "start": "1783562",
    "end": "1789300"
  },
  {
    "text": "except for the last time. So it's only going to return\nfalse when nb is equal to 0.",
    "start": "1789300",
    "end": "1794750"
  },
  {
    "text": "And at that point you're just\ngoing to execute this once and then you're done. But most of the time nb\nis going to be greater",
    "start": "1794750",
    "end": "1801800"
  },
  {
    "text": "than 0 when you\nexecute this, and we call this a predictable branch. ",
    "start": "1801800",
    "end": "1809779"
  },
  {
    "text": "What about the second one? ",
    "start": "1809780",
    "end": "1814802"
  },
  {
    "text": "So-- AUDIENCE: Also predictable? JULIAN SHUN: Yes. So it's also predictable\nfor the same reason.",
    "start": "1814802",
    "end": "1821190"
  },
  {
    "text": " What about the third one? ",
    "start": "1821190",
    "end": "1829950"
  },
  {
    "text": "Yes. AUDIENCE: No. Because we really-- if we\nalready knew which was bigger, then we already have\nthe sorted array then.",
    "start": "1829950",
    "end": "1837412"
  },
  {
    "text": "JULIAN SHUN: Yes. So this turns out\nto be unpredictable because we don't know the\nvalues in A and B a priori.",
    "start": "1837412",
    "end": "1844180"
  },
  {
    "text": "So this condition\ninside the if statement",
    "start": "1844180",
    "end": "1849220"
  },
  {
    "text": "is going to return true\nabout half of the time because we don't know what\nvalues are in A and B.",
    "start": "1849220",
    "end": "1855253"
  },
  {
    "text": "And that's going to be\nan unpredictable branch because it's going to return\ntrue or false about 50/50.",
    "start": "1855253",
    "end": "1863520"
  },
  {
    "text": "What about the last one? Yes. Why? AUDIENCE: Yes, because for\nsimilar reasons of 1 and 2.",
    "start": "1863520",
    "end": "1872612"
  },
  {
    "text": "It's probably [INAUDIBLE]. JULIAN SHUN: Yes. So it is predictable.",
    "start": "1872612",
    "end": "1877760"
  },
  {
    "text": "The reason why it's\npredictable is that most the time it's going\nto return true. And that once it\nreturns false you're",
    "start": "1877760",
    "end": "1883340"
  },
  {
    "text": "never going to look at that\nagain inside this function call. So it returns true\nmost of the time,",
    "start": "1883340",
    "end": "1889640"
  },
  {
    "text": "and we call that a\npredictable branch. So branches 1, 2, and 4\nare OK because they're",
    "start": "1889640",
    "end": "1897420"
  },
  {
    "text": "predictable branches, but branch\n3 is going to cause a problem. It's an unpredictable branch,\nand the hardware doesn't really",
    "start": "1897420",
    "end": "1905970"
  },
  {
    "text": "like this because it can't\ndo prefetching efficiently.",
    "start": "1905970",
    "end": "1911429"
  },
  {
    "start": "1911000",
    "end": "1911000"
  },
  {
    "text": "So to fix this, we can use our\nno-branch minimum bit trick that we learned a\ncouple slides ago.",
    "start": "1911430",
    "end": "1918660"
  },
  {
    "text": "So now what we're doing is we're\ngoing to have a variable called cmp which stores the\nresult of the comparison",
    "start": "1918660",
    "end": "1925200"
  },
  {
    "text": "between the first element of\nA and the first element of B.",
    "start": "1925200",
    "end": "1930539"
  },
  {
    "text": "And then now we're going to\nget the minimum of A and B as follows. It's the same bit trick\nthat we saw before.",
    "start": "1930540",
    "end": "1937035"
  },
  {
    "text": " So now the variable\nmin is going to store",
    "start": "1937035",
    "end": "1942420"
  },
  {
    "text": "the smaller of the\nfirst element of A and the first element\nof B. And we also",
    "start": "1942420",
    "end": "1947549"
  },
  {
    "text": "have the result of\nthis comparison here. So that's stored in cmp.",
    "start": "1947550",
    "end": "1953309"
  },
  {
    "text": "So first we're going to\nplace the minimum value in C. And then, based on\nthe result of cmp,",
    "start": "1953310",
    "end": "1958710"
  },
  {
    "text": "we're going to increment one of\nA or B. So if A was less than or equal to B, then\ncmp is going to be 1.",
    "start": "1958710",
    "end": "1965670"
  },
  {
    "text": "And A plus equal cmp is\ngoing to increment A by 1.",
    "start": "1965670",
    "end": "1972360"
  },
  {
    "text": "And then B plus equal to not\ncmp is going to not do anything, because not cmp is 0.",
    "start": "1972360",
    "end": "1977880"
  },
  {
    "text": "And then for na, we're\ngoing to decrement by cmp. So it's going to be 1 if A\nis less than or equal to B,",
    "start": "1977880",
    "end": "1984390"
  },
  {
    "text": "and 0 otherwise. And then for nb, we're\ngoing to decrement by the not of the cmp.",
    "start": "1984390",
    "end": "1989820"
  },
  {
    "text": "So only one of these\ntwo lines is actually going to do something based on\nthe result of the comparison.",
    "start": "1989820",
    "end": "1998348"
  },
  {
    "text": "And then the rest of the\ncode is the same as before.  Any questions?",
    "start": "1998348",
    "end": "2005770"
  },
  {
    "text": "So now we've gotten rid of\nthis unpredictable branch that we had before. ",
    "start": "2005770",
    "end": "2013690"
  },
  {
    "text": "So one thing about\nthis optimization is that it works well\non certain machines. However, on modern machines,\nusing a good compiler",
    "start": "2013690",
    "end": "2021120"
  },
  {
    "text": "like Clang with\nthe minus O3 flag, the branchless\nversion is usually",
    "start": "2021120",
    "end": "2026639"
  },
  {
    "text": "going to be slower than\nthe branching version because the compiler is\nactually smart enough to get rid of the branch\ninside the original version",
    "start": "2026640",
    "end": "2035309"
  },
  {
    "text": "of minimum. There's this instruction called\ncmov or a conditional move.",
    "start": "2035310",
    "end": "2040980"
  },
  {
    "text": "It's basically a\nbranchless instruction for doing a comparison. We'll learn more\nabout that next week.",
    "start": "2040980",
    "end": "2048429"
  },
  {
    "text": "So this trick actually\nusually doesn't really work. There might be some machines\nand some compilers that works,",
    "start": "2048429",
    "end": "2054000"
  },
  {
    "text": "but most of the\ntime, the compiler is better at optimizing\nthis code than you are.",
    "start": "2054000",
    "end": "2059860"
  },
  {
    "text": "So one of the\ncommon themes so far is that I've told you about\na really cool bit trick",
    "start": "2059860",
    "end": "2065190"
  },
  {
    "text": "and then I told you that\nit doesn't really work. So why are we even learning\nabout these bit tricks",
    "start": "2065190",
    "end": "2070940"
  },
  {
    "text": "then if they don't even work? So first is because the compiler\ndoes some of these bit tricks,",
    "start": "2070940",
    "end": "2077310"
  },
  {
    "start": "2071000",
    "end": "2071000"
  },
  {
    "text": "and it's helpful to understand\nwhat these bit tricks are so you can figure out what\nthe compiler is doing when",
    "start": "2077310",
    "end": "2082408"
  },
  {
    "text": "you look at the assembly code. Secondly, sometimes the compiler\ndoesn't do these optimizations",
    "start": "2082409",
    "end": "2088530"
  },
  {
    "text": "for you and you have\nto do it yourself. Thirdly, many bit\nhacks for words",
    "start": "2088530",
    "end": "2093540"
  },
  {
    "text": "extend naturally to\nbit and word hacks for vectors, which are widely\nused in high-performance code.",
    "start": "2093540",
    "end": "2099530"
  },
  {
    "text": "So it's good to know\nabout these tricks. These bit tricks also\narise in other domains.",
    "start": "2099530",
    "end": "2105670"
  },
  {
    "text": "And, finally, because they're\njust fun to learn about. And for project 1,\nyou'll be playing around",
    "start": "2105670",
    "end": "2112150"
  },
  {
    "text": "with some of these\nbit tricks, so it's good to know about these things\nthat I've talked about already.",
    "start": "2112150",
    "end": "2119470"
  },
  {
    "start": "2119000",
    "end": "2119000"
  },
  {
    "text": "Here I'll talk about a bit\ntrick that actually does work. So here we're trying\nto do modular addition.",
    "start": "2119470",
    "end": "2126970"
  },
  {
    "text": "So we want to do x plus y mod n. And here let's assume that x\nis between 0 and n minus 1,",
    "start": "2126970",
    "end": "2135099"
  },
  {
    "text": "and y is also between\n0 and n minus 1. So the standard way\nto do this is just",
    "start": "2135100",
    "end": "2141190"
  },
  {
    "text": "to use the mod operator,\nx plus y mod n. However, this does\na division, which",
    "start": "2141190",
    "end": "2147640"
  },
  {
    "text": "is relatively expensive\ncompared to other operations unless n is a power of 2.",
    "start": "2147640",
    "end": "2152830"
  },
  {
    "text": "But most of the\ntime, you don't know if n is a power of\n2 at compile time, so the compiler can't\nactually translate this",
    "start": "2152830",
    "end": "2159400"
  },
  {
    "text": "to a right shift operation, and\nthen it has to do a division.",
    "start": "2159400",
    "end": "2165549"
  },
  {
    "text": "So here's another way to do\nit without using division.",
    "start": "2165550",
    "end": "2171020"
  },
  {
    "text": "So we're first going to set z\nequal to the sum of x and y. And then if z is\nless than n, then",
    "start": "2171020",
    "end": "2178060"
  },
  {
    "text": "it's already within the range\nand we can just return z. If z is greater\nthan or equal to n,",
    "start": "2178060",
    "end": "2183790"
  },
  {
    "text": "well we know we can\nbe at most 2n minus 2 because x and y were\nboth at most n minus 1.",
    "start": "2183790",
    "end": "2189220"
  },
  {
    "text": "So all we have to do is to\nsubtract n and bring it back into range.",
    "start": "2189220",
    "end": "2195140"
  },
  {
    "text": "However, this code has an\nunpredictable branch here because we don't know whether\nz is less than n or not.",
    "start": "2195140",
    "end": "2201910"
  },
  {
    "text": "So now we can use the\nsame trick as minimum. So now we're going to\nset r equal to z minus n",
    "start": "2201910",
    "end": "2209180"
  },
  {
    "text": "ANDed with the negative of z\ngreater than or equal to n.",
    "start": "2209180",
    "end": "2215380"
  },
  {
    "text": "So if z is less\nthan n, then this is going to return 0 in here.",
    "start": "2215380",
    "end": "2220770"
  },
  {
    "text": "And n ANDed with 0 is 0,\nso we're just left with z. And if z is greater\nthan or equal to n,",
    "start": "2220770",
    "end": "2227380"
  },
  {
    "text": "then this is going to be 1. We negate that, we get negative\n1, which is the all 1's word.",
    "start": "2227380",
    "end": "2233200"
  },
  {
    "text": "n ANDed with all 1's is just n. So that is z minus n, which\nwill bring the result back",
    "start": "2233200",
    "end": "2239320"
  },
  {
    "text": "into range. ",
    "start": "2239320",
    "end": "2244830"
  },
  {
    "text": "So any questions? Yes. AUDIENCE: It seems\nlike there essentially",
    "start": "2244830",
    "end": "2251278"
  },
  {
    "text": "is still a branch based\non the value of z. So why would that be faster?",
    "start": "2251278",
    "end": "2257760"
  },
  {
    "text": "JULIAN SHUN: So this branch\nhere is just generating either a Boolean value 1 or 0. There's actually-- like the\ncode that you execute after it,",
    "start": "2257760",
    "end": "2264900"
  },
  {
    "text": "it's still the same\nin either case. So the branch misprediction\nonly hurts you if there are two\ndifferent code paths.",
    "start": "2264900",
    "end": "2271570"
  },
  {
    "text": "In this version, there are\ntwo different code paths, because one is doing z and\none is doing z minus n.",
    "start": "2271570",
    "end": "2278130"
  },
  {
    "text": " So the next problem\nwe will look at",
    "start": "2278130",
    "end": "2284810"
  },
  {
    "text": "is computing or rounding a value\nup to the nearest power of 2. And this is just 2 to the\nceiling of log base 2 of n.",
    "start": "2284810",
    "end": "2295160"
  },
  {
    "start": "2285000",
    "end": "2285000"
  },
  {
    "text": "And recall that lg of n\nis the log base 2 of n. That's the notation we'll\nbe using in this class.",
    "start": "2295160",
    "end": "2303140"
  },
  {
    "text": "Here's some code to do this. So we have our value of n here. First, we're going\nto decrement n.",
    "start": "2303140",
    "end": "2310640"
  },
  {
    "text": "And then we're going to do an OR\nof n with n right-shifted by 1. Then an OR with n and n\nright-shifted by 2, and so on,",
    "start": "2310640",
    "end": "2318920"
  },
  {
    "text": "all the way up to 32. So we do this for all\npowers of 2 up to 32.",
    "start": "2318920",
    "end": "2324500"
  },
  {
    "text": "And then, finally, we\nincrement n at the end. So let's look at an example\nto see why this works.",
    "start": "2324500",
    "end": "2331140"
  },
  {
    "text": "So we're starting with\nthis value of n here. ",
    "start": "2331140",
    "end": "2336710"
  },
  {
    "text": "First we're going\nto decrement it. And what that does is it flips\nthe rightmost 1 bit to 0,",
    "start": "2336710",
    "end": "2343010"
  },
  {
    "text": "and then it fills in all the\n0's right of that with 1's. ",
    "start": "2343010",
    "end": "2349490"
  },
  {
    "text": "And then when we\ndo this line, which says n is equal to n ORed\nwith n right-shifted by 1,",
    "start": "2349490",
    "end": "2356630"
  },
  {
    "text": "that's essentially propagating\nall of the 1 bits one position to the right and\nthen ORing those in.",
    "start": "2356630",
    "end": "2362270"
  },
  {
    "text": "So we can see that\nthis 1 bit got copied one position to the right. This 1 bit got copied to\none position to the right.",
    "start": "2362270",
    "end": "2369380"
  },
  {
    "text": "These 1's also propagate, but\nsince they were already 1's it doesn't do anything.",
    "start": "2369380",
    "end": "2375290"
  },
  {
    "text": "For the next line, we're\npropagating the 1 bits two positions to the right. So this 1 bit here\ngets copied here.",
    "start": "2375290",
    "end": "2383750"
  },
  {
    "text": "This 1 gets copied\nhere, and so on. And then the next line is\ngoing to propagate bits",
    "start": "2383750",
    "end": "2389600"
  },
  {
    "text": "four positions the right. Then 8, 16, and 32. For this example here,\nwhen I get to this line",
    "start": "2389600",
    "end": "2396650"
  },
  {
    "text": "I'm already done. But, in general,\nyou have more bits in a word, which I\ncan't fit on this slide.",
    "start": "2396650",
    "end": "2404510"
  },
  {
    "text": "And now we have\nsomething that's exactly one less than a power of 2.",
    "start": "2404510",
    "end": "2409670"
  },
  {
    "text": "And when we add 1 to that,\nwe just get a power of 2. So we're going to zero\nout all of these 1 bits",
    "start": "2409670",
    "end": "2414890"
  },
  {
    "text": "and then place a 1 here. And this is exactly\nthe power of 2 that's greater than the value n.",
    "start": "2414890",
    "end": "2421360"
  },
  {
    "start": "2421360",
    "end": "2428890"
  },
  {
    "text": "So the first line\nhere is essentially guaranteeing us that the\nlog nth minus 1 bit is set.",
    "start": "2428890",
    "end": "2435670"
  },
  {
    "text": "And we need that bit\nto be set because we want to propagate that\nbit to all the positions",
    "start": "2435670",
    "end": "2440890"
  },
  {
    "text": "to the right of it. And then these six lines here\nare populating all the bits",
    "start": "2440890",
    "end": "2447369"
  },
  {
    "text": "to the right with 1's. And then the last bit is\nsetting the log nth bit to 1",
    "start": "2447370",
    "end": "2453580"
  },
  {
    "text": "and then clearing all\nof the other bits.  So one question is why\ndid we have to decrement n",
    "start": "2453580",
    "end": "2461329"
  },
  {
    "text": "at the beginning?  Yes.",
    "start": "2461330",
    "end": "2466425"
  },
  {
    "text": "AUDIENCE: In case n is\nalready [INAUDIBLE].. JULIAN SHUN: Yes. So if n is already a power of\n2 and if we don't decrement n,",
    "start": "2466425",
    "end": "2473130"
  },
  {
    "text": "this is isn't going to work\nbecause the log nth minus 1 bit isn't set. But if we decrement\nn, then it's going",
    "start": "2473130",
    "end": "2479660"
  },
  {
    "text": "to guarantee us that\nthe log nth minus 1 bit is set so that we can\npropagate that to the right. ",
    "start": "2479660",
    "end": "2488589"
  },
  {
    "text": "Any questions? Yes. AUDIENCE: [INAUDIBLE]?",
    "start": "2488590",
    "end": "2494480"
  },
  {
    "text": "JULIAN SHUN: Because,\nin general, you're using 64-bit words.",
    "start": "2494480",
    "end": "2499720"
  },
  {
    "text": "Here I don't have\nthat many bits here because I can't fit\nin on the slide, but in general you\nhave more bits. ",
    "start": "2499720",
    "end": "2511810"
  },
  {
    "start": "2511000",
    "end": "2511000"
  },
  {
    "text": "Let's look at another problem. Here we want to compute the\nmask of the least significant 1",
    "start": "2511810",
    "end": "2517060"
  },
  {
    "text": "in a word x. So we want a mask\nthat has a 1 in only the position of the least\nsignificant 1 in x, and 0's",
    "start": "2517060",
    "end": "2524200"
  },
  {
    "text": "everywhere else. So how can we do this? So we can set r, the\nresult, equal to x",
    "start": "2524200",
    "end": "2531210"
  },
  {
    "text": "ANDed with negative x.  So let's look at why this works.",
    "start": "2531210",
    "end": "2538550"
  },
  {
    "text": "So here is x. And recall negative x is the\ntwo's complement of x plus 1.",
    "start": "2538550",
    "end": "2547200"
  },
  {
    "text": "So what we do is we flip all of\nthe bits up to the rightmost 1",
    "start": "2547200",
    "end": "2553670"
  },
  {
    "text": "but not including it, and then\nwe just copy all of the bits over. That's how we get\nnegative x from x.",
    "start": "2553670",
    "end": "2560770"
  },
  {
    "text": "And then now when we\ncompare x and negative x, we see that all of the bits\nwhen we AND them together",
    "start": "2560770",
    "end": "2567320"
  },
  {
    "text": "are going to be 0 except\nfor the bit at the position",
    "start": "2567320",
    "end": "2572420"
  },
  {
    "text": "corresponding to the least\nsignificant 1 bit in x. And that's going to be 1\nsince we're ANDing 1 and 1,",
    "start": "2572420",
    "end": "2578540"
  },
  {
    "text": "and everything else\nis going to be 0. And this will give us\nthe mask that we want. ",
    "start": "2578540",
    "end": "2586860"
  },
  {
    "text": "So this works because the\nbinary representation of minus x is just the one's\ncomplement of x plus 1.",
    "start": "2586860",
    "end": "2593450"
  },
  {
    "start": "2593450",
    "end": "2598916"
  },
  {
    "text": "So now, a question is how can\nwe find the index of this bit? So here I'm just generating\na mask that has a 1",
    "start": "2598916",
    "end": "2606150"
  },
  {
    "text": "in the least significant 1\nin x, but it doesn't actually",
    "start": "2606150",
    "end": "2611309"
  },
  {
    "text": "tell me the index of this bit. In other words, I want to find\nthe log base 2 of a power of 2.",
    "start": "2611310",
    "end": "2616950"
  },
  {
    "text": " So that's the problem\nwe want to solve,",
    "start": "2616950",
    "end": "2622090"
  },
  {
    "start": "2619000",
    "end": "2619000"
  },
  {
    "text": "and here's some code\nthat lets us do this. So we have this constant\ncalled the de Bruijn.",
    "start": "2622090",
    "end": "2629260"
  },
  {
    "text": "It's written in hex here. And then we have this table\nof size 64 called convert.",
    "start": "2629260",
    "end": "2636850"
  },
  {
    "text": "And now all we have to do is\nmultiply x by this de Bruijn constant, right shift\nit by 58 positions,",
    "start": "2636850",
    "end": "2644140"
  },
  {
    "text": "and then look up the result\nin the convert table. And that's going to give us the\nlog base 2 of the power of 2.",
    "start": "2644140",
    "end": "2650850"
  },
  {
    "text": "Any questions? [STUDENTS LAUGH]",
    "start": "2650850",
    "end": "2656380"
  },
  {
    "text": " So this looks like magic to us.",
    "start": "2656380",
    "end": "2661810"
  },
  {
    "text": "So in the spirit of magic, we're\ngoing to do a mathemagic trick. And to do this trick, I'm\ngoing to need five volunteers,",
    "start": "2661810",
    "end": "2669240"
  },
  {
    "start": "2663000",
    "end": "2663000"
  },
  {
    "text": "and the only\nrequirement is that you need to be able to\nfollow directions. So who wants to volunteer\nfor this magic trick?",
    "start": "2669240",
    "end": "2675900"
  },
  {
    "text": "Yes, 1, 2, 3, 4--",
    "start": "2675900",
    "end": "2682650"
  },
  {
    "text": "one more-- 5. All right, come on up.",
    "start": "2682650",
    "end": "2687770"
  },
  {
    "text": "So line up here. [STUDENTS APPLAUD] Yes, just line up right here.",
    "start": "2687770",
    "end": "2694430"
  },
  {
    "start": "2694430",
    "end": "2703843"
  },
  {
    "text": "Can you move a little\nbit over to the left?  OK, cool. So today I have the pleasure of\nwelcoming Jess Ray, also known",
    "start": "2703843",
    "end": "2713790"
  },
  {
    "text": "as The Golden Raytio,\nto join us for a lecture and help us perform\nthis cool magic trick.",
    "start": "2713790",
    "end": "2719650"
  },
  {
    "text": "So let's give her a\nround of applause. [STUDENTS APPLAUD]",
    "start": "2719650",
    "end": "2724952"
  },
  {
    "text": "JESS RAY: I'm going to be doing\na little bit of magic trick for you all today. I'm going to be reading\nyour guys' minds.",
    "start": "2724952",
    "end": "2731579"
  },
  {
    "text": "And I know you're\nlooking skeptical, but I'm hoping I can\nconvince you here. So we'll get to that\npart in a second.",
    "start": "2731580",
    "end": "2737980"
  },
  {
    "text": "But, first, the first\nbig step in reading minds is you got to clear\nthe air, like get",
    "start": "2737980",
    "end": "2743100"
  },
  {
    "text": "rid of all the negative\nvibes, all the bad energy. Throw that out. So I'm going to need a\nlittle help from you guys",
    "start": "2743100",
    "end": "2748690"
  },
  {
    "text": "in doing this. So, first, we have this\nsweet little bell here. Let's see. Who wants the bell?",
    "start": "2748690",
    "end": "2754097"
  },
  {
    "text": "AUDIENCE: I'll take it, I guess. JESS RAY: All right. Can you hold that for a second? So what this bell\nis going to do is help us get rid of some\nof those negative ideas.",
    "start": "2754097",
    "end": "2760500"
  },
  {
    "text": "Can you give it a ring? Oh yes. So that painful ringing you're\nhearing in your ears right now",
    "start": "2760500",
    "end": "2766080"
  },
  {
    "text": "is actually just clearing\nup the air for us, making it so I can\nread your minds. Thank you. Stop that.",
    "start": "2766080",
    "end": "2771430"
  },
  {
    "text": " All right. Next we have this\nmagic tone here.",
    "start": "2771430",
    "end": "2779480"
  },
  {
    "text": "Who would like to\ngive this a spin? Can you shake that\naround a couple of times? Spin it. Spin it with your wrist there,\nlike-- you can go like this.",
    "start": "2779480",
    "end": "2786560"
  },
  {
    "text": "There we go. All right. Perfect. All right. It's feeling a\nlittle clearer here.",
    "start": "2786560",
    "end": "2792770"
  },
  {
    "text": "I can start-- you can start\ngetting things off your mind. Don't worry, I won't tell\nanybody what you're thinking.",
    "start": "2792770",
    "end": "2798920"
  },
  {
    "text": "Oh, let's see what else. Let me channel the spirits. Help me out here.",
    "start": "2798920",
    "end": "2805310"
  },
  {
    "text": "All right, I'm feeling good. All right. So what we're going to\nbe doing is, as I said,",
    "start": "2805310",
    "end": "2811599"
  },
  {
    "text": "reading your mind. I'm going to be doing\nthis by giving you cards, and I'm going to tell\nyou what each of you are holding for the card.",
    "start": "2811600",
    "end": "2817520"
  },
  {
    "text": "So I have some cards here. Well, I guess these\nare a little small. Let's see.",
    "start": "2817520",
    "end": "2823450"
  },
  {
    "text": "Go a little bigger. Meh. Here we go. Let's-- this looks better.",
    "start": "2823450",
    "end": "2832430"
  },
  {
    "text": "All right. These are kind of heavy. Get rid of these junk ones\nup here, all the junk.",
    "start": "2832430",
    "end": "2842269"
  },
  {
    "text": "All right. So I need your help for this. So what I want you to\ndo is take the cards",
    "start": "2842270",
    "end": "2847898"
  },
  {
    "text": "and cut the deck as\nmany times as you want. So, basically, just going\nlike that however much. Just don't actually\nshuffle them randomly.",
    "start": "2847898",
    "end": "2854810"
  },
  {
    "text": " AUDIENCE: All right. Here you go. JESS RAY: All right, cool.",
    "start": "2854810",
    "end": "2860237"
  },
  {
    "text": "So now I'm going to\nhand each of you a card. Don't let me see it. Feel free to look at it. ",
    "start": "2860237",
    "end": "2870176"
  },
  {
    "text": "There you go. All right. So the reason I'm wearing\nthis awesome onesie",
    "start": "2870176",
    "end": "2875900"
  },
  {
    "text": "is this helps me sweat\nout the bad energy. I'm literally\nsweating right now.",
    "start": "2875900",
    "end": "2881000"
  },
  {
    "text": "But there's one more piece that\nwe need for this mind reading trick. ",
    "start": "2881000",
    "end": "2887590"
  },
  {
    "text": "The magic hat. All right. See if this fits on my head. There we go.",
    "start": "2887590",
    "end": "2892948"
  },
  {
    "text": "Where's the switch? All right. Turn it on. All right, I'm\nfeeling good here. All right, you guys ready?",
    "start": "2892948",
    "end": "2899960"
  },
  {
    "text": "All right. So I do need a little help\ngetting this trick started. So if you are\nholding a red card,",
    "start": "2899960",
    "end": "2905582"
  },
  {
    "text": "can you just raise your hand?  So no?",
    "start": "2905582",
    "end": "2911202"
  },
  {
    "text": "Who's got the red card? Red, red. You don't have red? OK. All right.",
    "start": "2911202",
    "end": "2916570"
  },
  {
    "text": "So the first one\nand the third one. All right. So let me handle the mind\nreading abilities here.",
    "start": "2916570",
    "end": "2922630"
  },
  {
    "text": "Now what I'm going to do is\nI'm going to go left to right and tell you what\nyou're holding. Obviously, I know the color, but\nI'll tell you what suit it is,",
    "start": "2922630",
    "end": "2928210"
  },
  {
    "text": "and also I will tell\nyou what the number is. So first card, obviously\nI know you have a red.",
    "start": "2928210",
    "end": "2935115"
  },
  {
    "text": "Hmm. I'm feeling a diamond\nand also a four?",
    "start": "2935115",
    "end": "2940402"
  },
  {
    "text": "AUDIENCE: That was it. JESS RAY: Yes. All right. All right.",
    "start": "2940403",
    "end": "2945670"
  },
  {
    "text": "Good start, good start.  All right. Got to-- got to think about\nwhat the next one is here.",
    "start": "2945670",
    "end": "2953395"
  },
  {
    "text": " All right. So I know you had a black card.",
    "start": "2953395",
    "end": "2959800"
  },
  {
    "text": "Let's see. Black of spades.",
    "start": "2959800",
    "end": "2964840"
  },
  {
    "text": "Is it the ace of spades? Oh yes. There we go. ",
    "start": "2964840",
    "end": "2973839"
  },
  {
    "text": "All right. So back to red.",
    "start": "2973840",
    "end": "2979060"
  },
  {
    "text": "All right. This one, let's see. Red, diamond, two.",
    "start": "2979060",
    "end": "2985710"
  },
  {
    "text": "All right, all right. We're doing good so far. Can I get the last two? ",
    "start": "2985710",
    "end": "2991651"
  },
  {
    "text": "All right, let's see\nwhat we can do here. All right, black, club, four.",
    "start": "2991652",
    "end": "2999750"
  },
  {
    "text": "All right. Last one, last one. All right.",
    "start": "2999750",
    "end": "3006160"
  },
  {
    "text": "Oh, it's going to\nbe a tough one.  Black, spade, eight.",
    "start": "3006160",
    "end": "3016167"
  },
  {
    "text": "[STUDENTS APPLAUD] ",
    "start": "3016167",
    "end": "3021440"
  },
  {
    "text": "And if we had time, I\ncould you mystify you and go through the rest of the\ndeck, but we won't do that.",
    "start": "3021440",
    "end": "3027650"
  },
  {
    "text": "So thank you guys very much. I hope your minds were blown. Yes.",
    "start": "3027650",
    "end": "3032890"
  },
  {
    "text": "So me collect the\ncards back from you. ",
    "start": "3032890",
    "end": "3039747"
  },
  {
    "text": "Thank you. All right. Thank you. Now I can get out of\nthis and stop sweating.",
    "start": "3039747",
    "end": "3045022"
  },
  {
    "text": "[STUDENTS APPLAUD]",
    "start": "3045022",
    "end": "3051688"
  },
  {
    "text": "JULIAN SHUN: It's\npretty cool, right?  So why does this actually work?",
    "start": "3051688",
    "end": "3058140"
  },
  {
    "text": " To know why this\ntrick actually works, we need to first study what\na de Bruijn sequence is.",
    "start": "3058140",
    "end": "3067830"
  },
  {
    "text": "So a de Bruijn\nsequence s of length 2 to the k is a cyclic bit\nsequence such that each",
    "start": "3067830",
    "end": "3075270"
  },
  {
    "text": "of the 2 to the k possible\nbit strings of length k",
    "start": "3075270",
    "end": "3080730"
  },
  {
    "text": "occurs exactly once\nas a substring in s. So this a pretty long\ndefinition, so let's",
    "start": "3080730",
    "end": "3087330"
  },
  {
    "text": "look at an example. So here is a de Bruijn\nsequence for k equals 3.",
    "start": "3087330",
    "end": "3092950"
  },
  {
    "text": "So the length of this sequence\nis 8 because 2 to the 3 is 8.",
    "start": "3092950",
    "end": "3098829"
  },
  {
    "text": "And you can see that each of the\npossible three-bit substrings",
    "start": "3098830",
    "end": "3104740"
  },
  {
    "text": "occurs exactly once in this\ncyclic bit string of length 8.",
    "start": "3104740",
    "end": "3110350"
  },
  {
    "text": "So it wraps around\nand you can consider this as a cyclic string.",
    "start": "3110350",
    "end": "3115810"
  },
  {
    "text": "So we see that 000\nappears at position 0. 001 is at position 1.",
    "start": "3115810",
    "end": "3123055"
  },
  {
    "text": "Then 010 is at position 6. 011 is at position 2.",
    "start": "3123055",
    "end": "3130660"
  },
  {
    "text": "100 is at position 7. 101 is at 5. 110 is at 4.",
    "start": "3130660",
    "end": "3137180"
  },
  {
    "text": "And then 111 is at 3. So all of the 8 possible\nsubstrings of length 3",
    "start": "3137180",
    "end": "3143950"
  },
  {
    "text": "occur exactly once in\nthis de Bruijn sequence. ",
    "start": "3143950",
    "end": "3149920"
  },
  {
    "text": "So now we're going to create\nthis convert table of length 8.",
    "start": "3149920",
    "end": "3156520"
  },
  {
    "text": "In general, this\nwill be 2 to the k. And here, k is 3. And in this convert table, what\nwe're storing in each position",
    "start": "3156520",
    "end": "3165310"
  },
  {
    "text": "is the index in the\nde Bruijn sequence where the bit string\ncorresponding to that position",
    "start": "3165310",
    "end": "3171730"
  },
  {
    "text": "starts in the de\nBruijn sequence. So here we see that convert of\n2 is 6 because the bit string",
    "start": "3171730",
    "end": "3180220"
  },
  {
    "text": "corresponding to 2 is 010,\nand that begins at position 6 in the de Bruijn sequence.",
    "start": "3180220",
    "end": "3186369"
  },
  {
    "text": "We also see that convert\nof 4 is 7 because 4 is 100,",
    "start": "3186370",
    "end": "3191770"
  },
  {
    "text": "and that begins at position\n7 in the de Bruijn sequence. ",
    "start": "3191770",
    "end": "3197590"
  },
  {
    "text": "Now we have this convert table. And recall that we're\ntrying to compute",
    "start": "3197590",
    "end": "3203230"
  },
  {
    "text": "the log base 2 of a power of 2. So hopefully you\nguys remember that. ",
    "start": "3203230",
    "end": "3211250"
  },
  {
    "text": "So the way to do\nthis is we're going to multiply the\nde Bruijn sequence",
    "start": "3211250",
    "end": "3216880"
  },
  {
    "text": "constant by this power of 2. So let's say we're\nworking with the integer 16, which is 2 to the 4.",
    "start": "3216880",
    "end": "3223480"
  },
  {
    "text": "So we're going to multiply\nthis de Bruijn sequence by 2 to the 4. And when we multiply\nby a power of 2,",
    "start": "3223480",
    "end": "3229480"
  },
  {
    "text": "that's the same\nas left shifting. So that's going to left shift\nthe de Bruijn sequence four",
    "start": "3229480",
    "end": "3235300"
  },
  {
    "text": "positions to the left. And then now we want to\nsee which of the eight",
    "start": "3235300",
    "end": "3241809"
  },
  {
    "text": "possible substrings appears at\nthe beginning of this sequence. And after we do\nthe left shift, 110",
    "start": "3241810",
    "end": "3248320"
  },
  {
    "text": "appears at the beginning\nof the sequence. And we want to extract\nthis out, and we",
    "start": "3248320",
    "end": "3253570"
  },
  {
    "text": "can do that by right\nshifting five positions. And 110 is just 6.",
    "start": "3253570",
    "end": "3261670"
  },
  {
    "text": "And we can figure out where\n5 starts in this de Bruijn sequence by looking it\nup in the convert table.",
    "start": "3261670",
    "end": "3267820"
  },
  {
    "text": "We see that convert of 6 is 4. So the string 110\nappears starting",
    "start": "3267820",
    "end": "3276039"
  },
  {
    "text": "at position 4 in the\nde Bruijn sequence, and that means that we\ndid a left shift by 4",
    "start": "3276040",
    "end": "3281590"
  },
  {
    "text": "in the first step, and\nthat gives us the log base 2 of the power of 2,\nbecause the only reason why",
    "start": "3281590",
    "end": "3287680"
  },
  {
    "text": "we did a left shift by 4\nis because the power of 2 was 2 to the 4.",
    "start": "3287680",
    "end": "3294819"
  },
  {
    "text": "So this returns us the\nlog base 2 of the integer that we started with. ",
    "start": "3294820",
    "end": "3302660"
  },
  {
    "text": "And one thing to\nnote is that it's important to start with all\n0's in this sequence here,",
    "start": "3302660",
    "end": "3308890"
  },
  {
    "text": "because we're representing\nthis as a cyclic bit sequence.",
    "start": "3308890",
    "end": "3314260"
  },
  {
    "text": "So when we do a\nleft shift, we need to make sure that the values\nthat fill in on the right side",
    "start": "3314260",
    "end": "3320349"
  },
  {
    "text": "are correct. So notice that in the sixth\nand seventh positions,",
    "start": "3320350",
    "end": "3325750"
  },
  {
    "text": "we need 0's at the\nend when we overflow. So because the de\nBruijn sequence",
    "start": "3325750",
    "end": "3332020"
  },
  {
    "text": "starts with all 0's, when\nwe do the left shift, it's automatically filling\nwith 0's, giving us the correct substring.",
    "start": "3332020",
    "end": "3339190"
  },
  {
    "text": "So the magic trick that Jess\ndid had 32 cards, and in that case k was equal to 5.",
    "start": "3339190",
    "end": "3346750"
  },
  {
    "text": "And the cards were arranged\naccording to a de Bruijn sequence of length 32.",
    "start": "3346750",
    "end": "3353500"
  },
  {
    "text": "And each of the\ncards corresponded to one particular bit\nstring of length 5.",
    "start": "3353500",
    "end": "3360700"
  },
  {
    "text": "And the color of the card\ncorresponded to the bit. So when she asked you what\nthe color of your card was,",
    "start": "3360700",
    "end": "3368950"
  },
  {
    "text": "she could determine\nthe bits corresponding to the first card\nin the sequence",
    "start": "3368950",
    "end": "3375040"
  },
  {
    "text": "because she has the 5 bits\ncorresponding to that card. And then with that she\nhas some clever way",
    "start": "3375040",
    "end": "3381430"
  },
  {
    "text": "to determine the\nrest of the cards. So that's how the\nde Bruijn sequence",
    "start": "3381430",
    "end": "3386650"
  },
  {
    "text": "is related to the magic\ntrick that you just saw. ",
    "start": "3386650",
    "end": "3393940"
  },
  {
    "text": "Any questions? Yes. AUDIENCE: The de\nBruijn sequence, do you need to do\ncyclic translation?",
    "start": "3393940",
    "end": "3400610"
  },
  {
    "text": "JULIAN SHUN: So there could be\nmultiple de Bruijn sequences. We just need one particular\nde Bruijn sequence",
    "start": "3400610",
    "end": "3405660"
  },
  {
    "text": "to make this bit trick work. Yes. ",
    "start": "3405660",
    "end": "3412210"
  },
  {
    "text": "So this example is\njust for k equals 3. And the code I showed you\nbefore, that was for k",
    "start": "3412210",
    "end": "3419890"
  },
  {
    "text": "equals 8, so you can\ndo up to 64-bit words. Yes. AUDIENCE: How do we know\nthat the sequence exists?",
    "start": "3419890",
    "end": "3427525"
  },
  {
    "text": "JULIAN SHUN: So there\nis a mathematical proof that says that. I can give you some\npointers so that you",
    "start": "3427525",
    "end": "3433300"
  },
  {
    "text": "can look at it after class. But there's a proof that\nsays that for any length there is a de Bruijn sequence.",
    "start": "3433300",
    "end": "3439536"
  },
  {
    "text": " Yes. AUDIENCE: Sorry, I\nmissed the procedure.",
    "start": "3439536",
    "end": "3444900"
  },
  {
    "text": "So how exactly do you\ndetermine the log base 2? ",
    "start": "3444900",
    "end": "3451650"
  },
  {
    "text": "JULIAN SHUN: So we have-- we're starting with some\ninteger that is a power of 2.",
    "start": "3451650",
    "end": "3457230"
  },
  {
    "text": "So when we multiply\nby that power of 2, it's left-shifting by\nthe log base 2 of that.",
    "start": "3457230",
    "end": "3464460"
  },
  {
    "text": "And then we can determine how\nmuch we left-shifted because we know--",
    "start": "3464460",
    "end": "3470760"
  },
  {
    "text": "we can just look at the first\nthree bits of this sequence after we did the\nleft shift, and then",
    "start": "3470760",
    "end": "3475980"
  },
  {
    "text": "look at where that\nthree-bit sequence appears in the original de Bruijn\nsequence before we shifted it.",
    "start": "3475980",
    "end": "3484570"
  },
  {
    "text": "And to do that, you can look\nit up in the convert table. This is what we did when we\nlooked up the bit string 110",
    "start": "3484570",
    "end": "3491455"
  },
  {
    "text": "in the convert table. And that tells us that it\nstarts in the fourth position. That means that we\nleft-shifted by 4,",
    "start": "3491455",
    "end": "3498240"
  },
  {
    "text": "and that means that the\nvalue of n was 2 to the 4.",
    "start": "3498240",
    "end": "3503610"
  },
  {
    "text": "Does that make sense? Yes. AUDIENCE: So just to\nclarify this only works if you multiply the\nsequence by a power of 2,",
    "start": "3503610",
    "end": "3510290"
  },
  {
    "text": "then it gives you back\nwhich power of 2 it was? JULIAN SHUN: Yes. So this only works if you're\nstarting with a power of 2.",
    "start": "3510290",
    "end": "3516130"
  },
  {
    "text": "So if it's not a power\nof 2, this doesn't work. ",
    "start": "3516130",
    "end": "3526125"
  },
  {
    "text": "Any other questions? ",
    "start": "3526125",
    "end": "3531526"
  },
  {
    "text": "Yes. So if it's not a power\nof 2, you can round it up to the nearest power\nof 2 using another bit trick that we saw earlier.",
    "start": "3531526",
    "end": "3537619"
  },
  {
    "text": "And then you can use\nthis bit trick here.  The performance\nof this bit trick",
    "start": "3537620",
    "end": "3545250"
  },
  {
    "text": "is limited by the performance\nof multiplication and table lookup. So you have to do\na multiplication",
    "start": "3545250",
    "end": "3551849"
  },
  {
    "text": "by some constant,\nand then you have to do table lookup in\nthis convert table.",
    "start": "3551850",
    "end": "3557460"
  },
  {
    "text": "So a table lookup does\na memory reference, which could be expensive. And nowadays there's actually\na hardware instruction",
    "start": "3557460",
    "end": "3564900"
  },
  {
    "text": "to compute this, so\nyou don't actually have to implement this trick. But this trick is\nstill pretty cool.",
    "start": "3564900",
    "end": "3570450"
  },
  {
    "text": "And in the past this\nis how you would do it before there was a hardware\ninstruction that came out.",
    "start": "3570450",
    "end": "3575940"
  },
  {
    "start": "3575940",
    "end": "3581119"
  },
  {
    "start": "3580000",
    "end": "3580000"
  },
  {
    "text": "So let's look at\nanother problem. So this is the n queens problem. How many of you have\nseen this before?",
    "start": "3581120",
    "end": "3586780"
  },
  {
    "text": "Yes. So many of you have\nseen this before. As a reminder, we're\ntrying to place n queens",
    "start": "3586780",
    "end": "3592250"
  },
  {
    "text": "on an n by n chessboard so that\nno queen attacks another queen.",
    "start": "3592250",
    "end": "3597350"
  },
  {
    "text": "In other words, there\nare no two queens in any row, any column,\nor any diagonal.",
    "start": "3597350",
    "end": "3603110"
  },
  {
    "text": "And, commonly, we want\nto count the number of possible solutions\nto the n queens problem",
    "start": "3603110",
    "end": "3608210"
  },
  {
    "text": "for a particular value of n. And in this example here,\nthis is a valid configuration.",
    "start": "3608210",
    "end": "3614930"
  },
  {
    "text": "You can check, for\neach of the queens, they can't attack any\nother queen on the board. ",
    "start": "3614930",
    "end": "3623450"
  },
  {
    "text": "So one common strategy for\nimplementing the n queens algorithm is to\nuse backtracking.",
    "start": "3623450",
    "end": "3629089"
  },
  {
    "text": "We're going to try\nplacing queens row by row. We know that there can\nonly be one queen per row, so we just need to determine\nwhich position in that row",
    "start": "3629090",
    "end": "3636680"
  },
  {
    "text": "the queen will appear in. And then if we can't\nplace a queen in any row, then we backtrack.",
    "start": "3636680",
    "end": "3643820"
  },
  {
    "text": "So, for example,\nin the first row, we'll just place the queen\nin the first position, because there's no\nqueens on the board",
    "start": "3643820",
    "end": "3650480"
  },
  {
    "text": "yet, so the first\nposition is valid. For the second row,\nwe're going to try",
    "start": "3650480",
    "end": "3655789"
  },
  {
    "text": "to place in the first position,\nbut we can't place it there because then it will\nattack the first queen.",
    "start": "3655790",
    "end": "3663410"
  },
  {
    "text": "And then the second\nposition is also invalid, so the third position is where\nwe place the second queen.",
    "start": "3663410",
    "end": "3670970"
  },
  {
    "text": "Now, for the third\nrow we're going to check the positions until\nwe get to one that's valid, and this is going to\nbe the fifth position.",
    "start": "3670970",
    "end": "3678170"
  },
  {
    "text": " Do this again. Here we can do it in\nthe second position.",
    "start": "3678170",
    "end": "3685779"
  },
  {
    "text": "For the fifth row, let's see\nwhere this is going to end up. OK. So it goes in the\nfourth position.",
    "start": "3685780",
    "end": "3693130"
  },
  {
    "text": "What about the sixth row? ",
    "start": "3693130",
    "end": "3704290"
  },
  {
    "text": "Whoops. So all of the eight\npositions are invalid, because if we place the queen\nin any of those positions,",
    "start": "3704290",
    "end": "3711010"
  },
  {
    "text": "it's going to attack one of the\nqueens that we already placed. So now we're going to backtrack. We're going to find another\nposition for the fifth queen.",
    "start": "3711010",
    "end": "3719039"
  },
  {
    "text": "So let's try some\nmore positions. ",
    "start": "3719040",
    "end": "3724630"
  },
  {
    "text": "So we can place it at the end. Now we try again. ",
    "start": "3724630",
    "end": "3736819"
  },
  {
    "text": "All right. So, unfortunately, we\ncouldn't find a position for the sixth row again. We have to backtrack.",
    "start": "3736820",
    "end": "3742510"
  },
  {
    "text": "But we already tried all the\npositions in the fifth row, so we backtrack\nto the fourth row. And you get the idea.",
    "start": "3742510",
    "end": "3749349"
  },
  {
    "text": "And then whenever we find\na configuration where all eight queens are valid, then\nwe increment some counter by 1.",
    "start": "3749350",
    "end": "3755430"
  },
  {
    "text": "And at the end we just\nreturn this counter, which tells us the number\nof solutions to the n queens puzzle.",
    "start": "3755430",
    "end": "3760720"
  },
  {
    "start": "3760720",
    "end": "3768820"
  },
  {
    "text": "So you can implement\nthis quite easily using a recursive procedure. You can implement this\nbacktracking search.",
    "start": "3768820",
    "end": "3776500"
  },
  {
    "text": "But one question\nis how should we represent the board to\nfacilitate efficient queen placement?",
    "start": "3776500",
    "end": "3783579"
  },
  {
    "text": "So one way to\nrepresent the board is to use an array\nof n squared bytes.",
    "start": "3783580",
    "end": "3789130"
  },
  {
    "text": "And for each byte,\nwe just have a 1 if there is a queen in that\nposition, and 0 otherwise.",
    "start": "3789130",
    "end": "3797365"
  },
  {
    "text": "Is there a better way\nto represent the board? ",
    "start": "3797365",
    "end": "3807032"
  },
  {
    "text": "AUDIENCE: You can\ntrack all of the bits such that a 1 bit\nrepresents a queen at some place on the board?",
    "start": "3807032",
    "end": "3814350"
  },
  {
    "text": "JULIAN SHUN: Yes. So that's a good answer. So instead of using\nbytes, we can use bits,",
    "start": "3814350",
    "end": "3819400"
  },
  {
    "text": "because the value\ncan only be 0 or 1. We only need one bit\nto represent that. So we can just have an\narray of n squared bits.",
    "start": "3819400",
    "end": "3828082"
  },
  {
    "text": "Is there a better\nway to do this? ",
    "start": "3828082",
    "end": "3836550"
  },
  {
    "text": "Yes. AUDIENCE: You could\njust say in each row where a queen is with a byte?",
    "start": "3836550",
    "end": "3842192"
  },
  {
    "text": "JULIAN SHUN: Yes. So good answer. So a better way to do this is\nto just use an array of n bytes.",
    "start": "3842192",
    "end": "3847380"
  },
  {
    "text": "Because we know that on each\nrow there can only be one queen, so we just need to store\nthe position of that queen.",
    "start": "3847380",
    "end": "3854819"
  },
  {
    "text": "So we have an array of n\nbytes, one byte for each row, and then you just used the\nbyte to store the position of the queen in that row.",
    "start": "3854820",
    "end": "3860630"
  },
  {
    "text": " It turns out, to\nimplement this algorithm, there's a even more\ncompact representation,",
    "start": "3860630",
    "end": "3867740"
  },
  {
    "text": "which is to use three-bit\nvectors of size n, 2n minus 1, and 2n minus 1.",
    "start": "3867740",
    "end": "3875380"
  },
  {
    "text": "So let's see how this works. So the first bit vector we're\ngoing to use is of length n.",
    "start": "3875380",
    "end": "3880520"
  },
  {
    "text": "We're going to call\nthis the down vector. And the down vector\njust stores a 1",
    "start": "3880520",
    "end": "3885619"
  },
  {
    "text": "in the columns that have a\nqueen in it and 0 in the columns that are empty. ",
    "start": "3885620",
    "end": "3893300"
  },
  {
    "text": "And then when we want to\ncheck whether placing a queen is safe in any\nposition, we first",
    "start": "3893300",
    "end": "3900079"
  },
  {
    "text": "have to check whether\nthat column is empty. And you can do this\nby ANDing the down bit",
    "start": "3900080",
    "end": "3905900"
  },
  {
    "text": "vector with 1 left-shifted by\nc, where c is a column where you want to place the queen.",
    "start": "3905900",
    "end": "3911300"
  },
  {
    "text": "And if that's\nnonzero, that means there's already a queen in that\ncolumn and you can't place it.",
    "start": "3911300",
    "end": "3917030"
  },
  {
    "text": "Otherwise, we're going to\nhave to do another check, and we're going to create this\nother bit vector called left.",
    "start": "3917030",
    "end": "3923869"
  },
  {
    "text": "The length of this bit\nvector is 2n minus 1. And it stores a 1\nin the diagonal that",
    "start": "3923870",
    "end": "3931250"
  },
  {
    "text": "has a queen in it,\nand 0's otherwise. And there are 2n minus\n2 possible diagonals.",
    "start": "3931250",
    "end": "3937210"
  },
  {
    "text": "And then now, when\nwe want to place a queen in row r\nand column c, we can check whether it's safe\nby doing left ANDed with 1",
    "start": "3937210",
    "end": "3947090"
  },
  {
    "text": "left-shifted by r plus c. And this is going to be\nnonzero if there is already a queen in that\nparticular diagonal.",
    "start": "3947090",
    "end": "3954950"
  },
  {
    "text": "So in that case, we can't\nplace a queen there. And, otherwise, we're going\nto do a final check using",
    "start": "3954950",
    "end": "3961220"
  },
  {
    "text": "this right bit vector, which\nis essentially the same but we're looking\nat the diagonals going down to the right.",
    "start": "3961220",
    "end": "3968960"
  },
  {
    "text": "So, again, we have a 1 in the\ndiagonals that have a queen and 0's otherwise.",
    "start": "3968960",
    "end": "3974700"
  },
  {
    "text": "And then now the check is\ngoing to be right ANDed with 1 left-shifted by n\nminus 1 minus r plus c.",
    "start": "3974700",
    "end": "3983119"
  },
  {
    "text": "And if a particular\ncandidate passes all three of these checks, then\nwe know that there's not",
    "start": "3983120",
    "end": "3988310"
  },
  {
    "text": "going to be a conflict\nand we can place the queen in that particular position.",
    "start": "3988310",
    "end": "3994020"
  },
  {
    "text": "So this is a bit\nvector representation. You actually still\nhave to write the code to count the number of\nqueens using this bit vector",
    "start": "3994020",
    "end": "4000850"
  },
  {
    "text": "representation,\nand it's actually an interesting exercise. So I encourage you to\ntry to do this at home.",
    "start": "4000850",
    "end": "4008440"
  },
  {
    "text": "But I just told you about the\nbit vector representation. So any questions? ",
    "start": "4008440",
    "end": "4015510"
  },
  {
    "text": "Yes. AUDIENCE: Could you just\nrepeat what the down vector bit hack was for figuring\nout [INAUDIBLE]??",
    "start": "4015510",
    "end": "4022319"
  },
  {
    "text": "JULIAN SHUN: Yes. So the down vector,\nit stores a 1 in the columns that have a\nqueen in it and 0's otherwise.",
    "start": "4022320",
    "end": "4028790"
  },
  {
    "text": "And what you do is, if you want\nto place a queen in column c, you first create the\nmask 1 left-shifted by c.",
    "start": "4028790",
    "end": "4035840"
  },
  {
    "text": "And then you AND it\nwith a down vector. And that's going to\nbe nonzero if there's a queen in that column. ",
    "start": "4035840",
    "end": "4047030"
  },
  {
    "text": "Any other questions? Yes. AUDIENCE: Why isn't\nthere a horizontal one? JULIAN SHUN: So it turns\nout that you don't need.",
    "start": "4047030",
    "end": "4054050"
  },
  {
    "text": "Just these three checks\nis enough to guarantee-- guarantee that you can\nplace a queen in a position",
    "start": "4054050",
    "end": "4061079"
  },
  {
    "text": "if it passes all\nthree of the checks. Yes. So a fourth check would\njust be redundant.",
    "start": "4061080",
    "end": "4066635"
  },
  {
    "text": "AUDIENCE: So we don't\nneed a horizontal one because we're not placing\ntwo queens in the same row. JULIAN SHUN: Yes. That's true. Good point.",
    "start": "4066635",
    "end": "4071910"
  },
  {
    "text": "Yes. So we're only placing one\nqueen in each particular row. ",
    "start": "4071910",
    "end": "4081109"
  },
  {
    "text": "So let's look at\nanother problem. This is called population\ncount, or pop count for short.",
    "start": "4081110",
    "end": "4088619"
  },
  {
    "text": "And the problem here is we\nwant to count the number of 1 bits in some word x.",
    "start": "4088620",
    "end": "4094880"
  },
  {
    "text": "Here's a way to do this that\nrepeatedly eliminates the least significant 1 bit in a word.",
    "start": "4094880",
    "end": "4100609"
  },
  {
    "text": "So we have this for loop\nwhere r is initialized to 0. And we're going to repeat\nthis loop until x becomes 0.",
    "start": "4100609",
    "end": "4108560"
  },
  {
    "text": "And then each time we go through\nthis loop, we increment r. And inside the loop\nwe're going to set x equal to x ANDed\nwith x minus 1.",
    "start": "4108560",
    "end": "4117410"
  },
  {
    "text": "And this is going to clear the\nleast significant 1 bit in x. So let's look at an example.",
    "start": "4117410",
    "end": "4124830"
  },
  {
    "text": "So let's say we have\nthis value here for x. Well, to get x minus 1, we\nflip the rightmost 1 bit",
    "start": "4124830",
    "end": "4131729"
  },
  {
    "text": "in x from a 1 to 0. And then we fill in all of the\nbits to the right of that with 1's.",
    "start": "4131729",
    "end": "4137222"
  },
  {
    "text": "And then now when we AND\nthose two things together, we're going to copy all of the\nbits up to the rightmost 1.",
    "start": "4137222",
    "end": "4146659"
  },
  {
    "text": "And then for the rightmost\n1, we're going to zero it out because we're ending with a 0. And then all of the bits\nto the right of that",
    "start": "4146660",
    "end": "4152134"
  },
  {
    "text": "are still going to be 0. So x ANDed with\nx minus 1 is just going to get rid of the\nleast significant 1 bit.",
    "start": "4152135",
    "end": "4161750"
  },
  {
    "text": "And then we repeat this\nprocess until x becomes 0. In that case we've already\neliminated all the 1's and we",
    "start": "4161750",
    "end": "4168109"
  },
  {
    "text": "know the answer,\nwhich is stored in r. ",
    "start": "4168109",
    "end": "4174989"
  },
  {
    "text": "Questions? ",
    "start": "4174990",
    "end": "4181580"
  },
  {
    "text": "So this code will be pretty\nfast if the number of 1 bits is small, but the\nrunning time is",
    "start": "4181580",
    "end": "4187589"
  },
  {
    "text": "proportional to the number\nof 1 bits in a word. So in the worst case, if most\nof the bits are set to 1,",
    "start": "4187590",
    "end": "4193600"
  },
  {
    "text": "then you're going to need a lot\nof iterations to run this code.",
    "start": "4193600",
    "end": "4200320"
  },
  {
    "text": "So let's look at a more\nefficient way to do this. This is to use table lookup.",
    "start": "4200320",
    "end": "4207929"
  },
  {
    "text": "So we're going to create\na table of size 256, which",
    "start": "4207930",
    "end": "4212970"
  },
  {
    "text": "stores for each 8-bit\nword the number of 1's in that 8-bit word. So we have all possible 8-bit\nwords stored in this table.",
    "start": "4212970",
    "end": "4223260"
  },
  {
    "text": "And then now, to get the\nnumber of 1 bits in x, for every 8-bit\nsubstring in x, we're",
    "start": "4223260",
    "end": "4230760"
  },
  {
    "text": "going to look it up in this\ncount table and add it to r.",
    "start": "4230760",
    "end": "4236039"
  },
  {
    "text": "And then we're going\nto right-shift x by 8 so that we can\nget the next word. And then when x becomes\n0, we know we're done.",
    "start": "4236040",
    "end": "4243869"
  },
  {
    "text": "So that's table lookup. And the performance here\ndepends on the size of x.",
    "start": "4243870",
    "end": "4251060"
  },
  {
    "text": "If we have a 64-bit\nword, we need to do this at most eight times,\nwhereas in the initial code",
    "start": "4251060",
    "end": "4257400"
  },
  {
    "text": "we might have to do it 64\ntimes if we had 64 1 bits.",
    "start": "4257400",
    "end": "4263179"
  },
  {
    "text": "The cost of this code is\nbottlenecked by the memory operations, because this table\nhere is stored in memory.",
    "start": "4263180",
    "end": "4270540"
  },
  {
    "text": "So every time you access\nit you have to go to memory to fetch the value there.",
    "start": "4270540",
    "end": "4275910"
  },
  {
    "text": "And here are some\napproximate costs for accessing memory in various\nlevels of the hierarchy.",
    "start": "4275910",
    "end": "4282600"
  },
  {
    "text": "If something's stored in\nregister, it's very fast. It only takes you 1 cycle. If it's stored in L1\ncache, it's about 4 cycles,",
    "start": "4282600",
    "end": "4289910"
  },
  {
    "text": "L2 cache about 10 cycles,\nL3 cache about 50 cycles. And then, finally, if you have\nto go to DRAM because it's not",
    "start": "4289910",
    "end": "4297260"
  },
  {
    "text": "in cache, it's much more\nexpensive, 150 cycles. It's an order of\nmagnitude slower",
    "start": "4297260",
    "end": "4303650"
  },
  {
    "text": "than doing something--\nfetching something that's already stored in a register. ",
    "start": "4303650",
    "end": "4309619"
  },
  {
    "text": "So let's now look at a third\nway to do population count where we don't actually have\nto go to cache or DRAM.",
    "start": "4309620",
    "end": "4317660"
  },
  {
    "text": "Essentially, we can do\neverything in registers. So here's how you do it.",
    "start": "4317660",
    "end": "4323640"
  },
  {
    "text": "So we're going to create\nthese five masks-- or six masks, from M0 up to M5.",
    "start": "4323640",
    "end": "4330860"
  },
  {
    "text": "And these masks-- the\nvalues of these masks are shown in the comments here. In this notation\nhere, x to the k",
    "start": "4330860",
    "end": "4338360"
  },
  {
    "text": "just means x repeated k times. So the mask M5 has 32\n0's, followed by 32 1's.",
    "start": "4338360",
    "end": "4346430"
  },
  {
    "text": "The mask M0 has the bit\nstring 01 repeated 32 times,",
    "start": "4346430",
    "end": "4351440"
  },
  {
    "text": "and so on.  After we create\nthese masks, we're going to execute these six\ninstructions at the bottom,",
    "start": "4351440",
    "end": "4360030"
  },
  {
    "text": "and this is going to give us\nthe number of 1's in the word. So let's do an example\nto see how this works.",
    "start": "4360030",
    "end": "4369150"
  },
  {
    "text": "So let's say we start\nwith this bit string here. ",
    "start": "4369150",
    "end": "4374750"
  },
  {
    "text": "In the first step,\nwhat we're going to do is we're going to AND\nx with the mask M0.",
    "start": "4374750",
    "end": "4379820"
  },
  {
    "text": "And then we're also going\nto AND x right-shifted by 1 with the mask M0. and recall that the mask M0\nis just 01 repeated 32 times,",
    "start": "4379820",
    "end": "4392390"
  },
  {
    "text": "and therefore the mask is\nessentially extracting all of the even bits. So x ANDed with M0 gives\nus all of the even bits.",
    "start": "4392390",
    "end": "4401180"
  },
  {
    "text": "And then when we right-shift\nx by 1 and AND it with M0, that's going to give\nus all the odd bits.",
    "start": "4401180",
    "end": "4406489"
  },
  {
    "text": "And then we're going to\nline those two things up and add them together. And the result of\ndoing this is it's",
    "start": "4406490",
    "end": "4413090"
  },
  {
    "text": "going to tell us for every\ngroup of two bits the number of 1 bits in that group.",
    "start": "4413090",
    "end": "4419870"
  },
  {
    "text": "So now for each of\nthese pairs of bits, it's telling us how\nmany of them are 1.",
    "start": "4419870",
    "end": "4424920"
  },
  {
    "text": "So in the leftmost group\nhere, we add two 1's. So the result of adding 1\nand 1 is 1 0, which is 2.",
    "start": "4424920",
    "end": "4432440"
  },
  {
    "text": "For the rightmost group, we have\ntwo 0's, and the count there is 00.",
    "start": "4432440",
    "end": "4437810"
  },
  {
    "text": "And this is the same for\nall of the other groups. So this gives us the number of\n1's in every pair of positions.",
    "start": "4437810",
    "end": "4449900"
  },
  {
    "text": "Now we're going to AND\nthe result with M1.",
    "start": "4449900",
    "end": "4455090"
  },
  {
    "text": "And we're going to right-shift\nit by 2 and also AND it with M1 and add those two\nthings together.",
    "start": "4455090",
    "end": "4460474"
  },
  {
    "text": " And M1 is a mask that will\ngive us the bottom two bits",
    "start": "4460475",
    "end": "4467120"
  },
  {
    "text": "in every group of four bits. So when we right-shift\nx by 2, that's giving us the top two bits.",
    "start": "4467120",
    "end": "4473119"
  },
  {
    "text": "And then now we\nadd those together, and it will give us the\ncount of the number of 1",
    "start": "4473120",
    "end": "4478520"
  },
  {
    "text": "bits in every group of size 4. And these counts are stored\nin the result here now.",
    "start": "4478520",
    "end": "4485800"
  },
  {
    "text": "So you can verify that\neach of these groups has the count of the\nnumber of 1 bits. So, for example,\nwe have 100 here.",
    "start": "4485800",
    "end": "4494540"
  },
  {
    "text": "And this is correct since\nthere are four 1 bits. ",
    "start": "4494540",
    "end": "4499920"
  },
  {
    "text": "Now we do this again\nwith the mask M2. That's going to\ngive us the counts",
    "start": "4499920",
    "end": "4505530"
  },
  {
    "text": "for all groups of size 8. Then we go to groups of size 16.",
    "start": "4505530",
    "end": "4512490"
  },
  {
    "text": "And then, finally, we\nadd these two together, giving us the number of bits\nin this group of size 32.",
    "start": "4512490",
    "end": "4521350"
  },
  {
    "text": "And this is actually\nthe pop count. So the value here is 17. And you can verify that\nthere are indeed 17 1's",
    "start": "4521350",
    "end": "4529030"
  },
  {
    "text": "in the input word x. ",
    "start": "4529030",
    "end": "4534219"
  },
  {
    "text": "Any questions? ",
    "start": "4534220",
    "end": "4541430"
  },
  {
    "text": "So the performance\nof this code, which is based on parallel\ndivide and conquer, is going to be proportional\nto log base 2 of w,",
    "start": "4541430",
    "end": "4549739"
  },
  {
    "text": "where w is the word length. Because on every step I'm\ndoubling the size of my groups.",
    "start": "4549740",
    "end": "4556670"
  },
  {
    "text": "And after I do this log base 2\nw times, I have the whole group. ",
    "start": "4556670",
    "end": "4564680"
  },
  {
    "text": "In the first two instructions\nthat I executed here,",
    "start": "4564680",
    "end": "4569730"
  },
  {
    "text": "I have to actually\ndo the AND separately for x right-shifted by 1 and x,\nand also x right-shifted by 2",
    "start": "4569730",
    "end": "4577890"
  },
  {
    "text": "and x, and then\nadd them together, because there is\nan overflow issue.",
    "start": "4577890",
    "end": "4583750"
  },
  {
    "text": "The overflow issue is that\nthe size of the groups here might not be large\nenough to actually store",
    "start": "4583750",
    "end": "4590700"
  },
  {
    "text": "the count of the number\nof 1 bits in that group. But once I get to\nthe larger groups, the count can always be\nstored in a group of that size",
    "start": "4590700",
    "end": "4598530"
  },
  {
    "text": "and I don't need to\nworry about overflow. So for the last four\nlines, I can actually",
    "start": "4598530",
    "end": "4604139"
  },
  {
    "text": "save one instruction. I don't need to\ndo the AND twice. ",
    "start": "4604140",
    "end": "4615920"
  },
  {
    "text": "So it turns out that most\nmodern machines nowadays have an intrinsic pop count\ninstruction implemented",
    "start": "4615920",
    "end": "4621489"
  },
  {
    "text": "in hardware, which is\nfaster than anything you can code yourself. And you can access this\npop count instruction",
    "start": "4621490",
    "end": "4628699"
  },
  {
    "text": "via compiler intrinsics,\nfor example in GCC or Clang. And in GCC, it's\n__builtin_popcount.",
    "start": "4628700",
    "end": "4637239"
  },
  {
    "text": " One warning though is that\nif you write this code using",
    "start": "4637240",
    "end": "4644739"
  },
  {
    "text": "these intrinsics, if\nyou try to compile the code on a machine\nthat doesn't support it, your code isn't\ngoing to compile.",
    "start": "4644740",
    "end": "4651190"
  },
  {
    "text": "So it makes your\ncode less portable. But this intrinsic is faster\nthan the parallel divide",
    "start": "4651190",
    "end": "4657250"
  },
  {
    "text": "and conquer version.  So one question is, how\ncan you get the log base",
    "start": "4657250",
    "end": "4663010"
  },
  {
    "text": "2 of a power of 2 quickly\nusing a pop count instruction? So instead of using the\nde Bruijn sequence trick.",
    "start": "4663010",
    "end": "4668796"
  },
  {
    "text": " Yes. AUDIENCE: You decrement\nthen you pop count.",
    "start": "4668796",
    "end": "4674772"
  },
  {
    "text": "JULIAN SHUN: Yes. So what you do is you subtract\n1 from the power of 2,",
    "start": "4674772",
    "end": "4679800"
  },
  {
    "text": "and that's going to flood all\nof the lower bits with 1's. And then now when you\nexecute pop count,",
    "start": "4679800",
    "end": "4684809"
  },
  {
    "text": "it's going to count the number\nof 1's, and that gives us the log base 2 of\nthe power of 2. So good answer.",
    "start": "4684810",
    "end": "4690450"
  },
  {
    "text": " So those all the\nbit tricks I'm going to be talking about today.",
    "start": "4690450",
    "end": "4697130"
  },
  {
    "text": "There's a lot of\nresources online if you're interested in learning more. There's this really\ngood website maintained",
    "start": "4697130",
    "end": "4703670"
  },
  {
    "text": "by Sean Eron Anderson. There's also the\nKnuth's textbook, which",
    "start": "4703670",
    "end": "4708800"
  },
  {
    "text": "has some bit tricks in there. There's a chess\nprogramming website which has a lot of cool bit tricks.",
    "start": "4708800",
    "end": "4714650"
  },
  {
    "text": "Some of those are used in\nimplementing chess programs. And then, finally, this book\ncalled Hacker's Delight. So we'll be playing around\nwith many of these bit",
    "start": "4714650",
    "end": "4721610"
  },
  {
    "text": "tricks in project 1,\nso happy bit hacking. ",
    "start": "4721610",
    "end": "4734246"
  }
]