[
  {
    "start": "0",
    "end": "60000"
  },
  {
    "text": "[SQUEAKING]\n[RUSTLING] [CLICKING] ",
    "start": "0",
    "end": "12740"
  },
  {
    "text": "ERIK DEMAINE: All right, welcome\nback to data structures land. Today we continue and complete\nour segment on binary trees.",
    "start": "12740",
    "end": "21140"
  },
  {
    "text": "So this is part two. If you missed part one, go\nback and watch part one.",
    "start": "21140",
    "end": "26180"
  },
  {
    "text": "Last time, we talked about\nbinary trees in general. We had each node stored an\nitem, and also a left pointer",
    "start": "26180",
    "end": "36980"
  },
  {
    "text": "and a right pointer\nto other nodes, and a parent pointer\nto another node. This was an example of a tree.",
    "start": "36980",
    "end": "43910"
  },
  {
    "text": "B, and C are A's children. A is the parent of B\nand C, and also the root",
    "start": "43910",
    "end": "49010"
  },
  {
    "text": "of the entire tree. We defined the height of a node. We didn't use this too much yet. But we're going to\nuse it a lot today.",
    "start": "49010",
    "end": "54763"
  },
  {
    "text": "So remember, the height\nis as drawn in red here. Height of the node is the length\nof the longest downward path",
    "start": "54763",
    "end": "62390"
  },
  {
    "text": "counting edges. So B, for example,\nhas a length 2 paths. So we write a 2 here. You can also think\nof it as if you just",
    "start": "62390",
    "end": "69560"
  },
  {
    "text": "live within the subtree\nrooted at B, B subtree,",
    "start": "69560",
    "end": "74600"
  },
  {
    "text": "then what is the maximum\ndepth of those nodes, if you prefer to think\nabout it that way. Either way is fine.",
    "start": "74600",
    "end": "80750"
  },
  {
    "text": "And in particular,\nwe distinguished h, the height of the\nroot node, as the height of the entire tree.",
    "start": "80750",
    "end": "87360"
  },
  {
    "text": "And what we achieved\nlast time was basically all of our operations\nran in order h time.",
    "start": "87360",
    "end": "92850"
  },
  {
    "text": "So we had subtree insert,\nsubtree delete, subtree first and last.",
    "start": "92850",
    "end": "98270"
  },
  {
    "text": "We could compute the\npredecessor and successor of a node, all in order h time. So as long as h was\nsmall, we were happy.",
    "start": "98270",
    "end": "108170"
  },
  {
    "text": "And remember, what does\npredecessor and successor mean? It's talking about an implicit\norder in the tree, which",
    "start": "108170",
    "end": "114320"
  },
  {
    "text": "is what we call traversal order,\nwhich is defined recursively as recursively traverse the left\nsubtree, then output the root,",
    "start": "114320",
    "end": "122329"
  },
  {
    "text": "then recursively traverse\nthe right subtree. So in this example, the\ntraversal order is F is the--",
    "start": "122330",
    "end": "130520"
  },
  {
    "text": "if you go all the way\nleft, that was the first in the traversal order. Then we have-- right, I'll\nmake me some space here.",
    "start": "130520",
    "end": "139430"
  },
  {
    "text": "Then we have D,\nthen we have B. Then we do the right\nsubtree of B, which",
    "start": "139430",
    "end": "146000"
  },
  {
    "text": "is E. Then we have the\nroot, because we finished the left subtree of the root.",
    "start": "146000",
    "end": "152310"
  },
  {
    "text": "So that's A. And then we have C. So there's an implicit linear\norder encoded by this tree.",
    "start": "152310",
    "end": "160910"
  },
  {
    "text": "And the whole point\nof binary trees is that we can efficiently\nupdate the tree much faster",
    "start": "160910",
    "end": "166220"
  },
  {
    "text": "than we could explicitly write\ndown an order in an array or something like that. So binary trees let us quickly--",
    "start": "166220",
    "end": "173480"
  },
  {
    "start": "173000",
    "end": "205000"
  },
  {
    "text": "now, quickly is not\nso quick right now. Because everything is order h. And in the worst\ncase, h is linear.",
    "start": "173480",
    "end": "178790"
  },
  {
    "text": "Because we can have\na tree like this.  But today, we're going\nto make-- we're going",
    "start": "178790",
    "end": "185120"
  },
  {
    "text": "to guarantee that h is log n. And so the goal of\ntoday is to take all of these operations\nthat run in order h time",
    "start": "185120",
    "end": "192080"
  },
  {
    "text": "and get them to run an\norder log n time, just by modifying the data\nstructure we've already seen. So we've done a lot of the\nhard work, just a little bit",
    "start": "192080",
    "end": "198822"
  },
  {
    "text": "more work we need to do\ntoday on something called AVL trees or height balance.",
    "start": "198822",
    "end": "205370"
  },
  {
    "start": "205000",
    "end": "338000"
  },
  {
    "text": "But before we get there, I want\nto talk a little bit more-- at the very end of\nthe last lecture, we talked about once you have\nthese subtree operations--",
    "start": "205370",
    "end": "212970"
  },
  {
    "text": "so I can insert and\ndelete in the subtree-- how do I actually use that to\nsolve the problems that we care",
    "start": "212970",
    "end": "218780"
  },
  {
    "text": "about in this class, which are\nsequence data structure and set data structure? So we talked mostly about the\nset data structure last time.",
    "start": "218780",
    "end": "227909"
  },
  {
    "text": "So in general, we're going to\ndefine what traversal order we maintain by a binary tree.",
    "start": "227910",
    "end": "233780"
  },
  {
    "text": "And so for a set, because\nfor the set interface, we're interested in doing\nqueries like find_next",
    "start": "233780",
    "end": "241700"
  },
  {
    "text": "and find_previous, given\na key, if it's not there, tell me the previous\none or the next one, this is something we could\ndo with binary search.",
    "start": "241700",
    "end": "248720"
  },
  {
    "text": "And so the big, cool thing\nthat binary trees let us do, if we let the traversal order\nalways be all of the items",
    "start": "248720",
    "end": "256278"
  },
  {
    "text": "stored in increasing\nkey order, then we are effectively maintaining\nthe items in order--",
    "start": "256279",
    "end": "263449"
  },
  {
    "text": "in the traversal order sense. Again, we're not explicitly\nmaintaining them in order. But up here, we're\nmaintaining a tree that",
    "start": "263450",
    "end": "269840"
  },
  {
    "text": "represents items in key order. And so this lets us do a\nsubtree_find operation--",
    "start": "269840",
    "end": "277639"
  },
  {
    "text": "which you could easily\nuse to implement find, and find_previous, and so on-- as follows.",
    "start": "277640",
    "end": "283800"
  },
  {
    "text": "We start at the\nroot of the tree. So we can say, node\nequals root initially. And then we can recursively\nsearch for a key k as follows.",
    "start": "283800",
    "end": "292770"
  },
  {
    "text": "We check, well, if\nthe item at the root has a key that's bigger than k--",
    "start": "292770",
    "end": "299490"
  },
  {
    "text": "let me draw a little picture.  So we're at some node here.",
    "start": "299490",
    "end": "308348"
  },
  {
    "text": "This is a node. And it has left subtree\nand a right subtree.",
    "start": "308348",
    "end": "313550"
  },
  {
    "text": "And there's some\nitem with some key. So if the key we're looking for\nis less than the node's item,",
    "start": "313550",
    "end": "320260"
  },
  {
    "text": "that means it's down\nhere in the left subtree. And so we recurse on node.left.",
    "start": "320260",
    "end": "325509"
  },
  {
    "text": "If they're equal, that\nmeans that this item is the item we're looking for. So we can just return\nit or the node,",
    "start": "325510",
    "end": "330848"
  },
  {
    "text": "depending on what\nyou're looking for. And if the key in here\nis greater than the key we're looking for, then\nwe'll recurse to the right.",
    "start": "330848",
    "end": "338650"
  },
  {
    "start": "338000",
    "end": "443000"
  },
  {
    "text": "If you think about\nit a little bit, this is exactly binary\nsearch on an array. It just happens to\nbe on a tree instead.",
    "start": "338650",
    "end": "346120"
  },
  {
    "text": "If you think of an\narray like this,",
    "start": "346120",
    "end": "355330"
  },
  {
    "text": "what does binary search do? It first looks at the\nkey in the middle. I'm going to draw\nthat as the root. And then, it recurses\neither on the left chunk,",
    "start": "355330",
    "end": "364060"
  },
  {
    "text": "which I will draw recursively,\nor on the right chunk. And so if you happen to\nhave a perfect binary",
    "start": "364060",
    "end": "370240"
  },
  {
    "text": "tree like this one, it\nis simulating exactly binary search in this array. But this we're going to be able\nto maintain dynamically-- not",
    "start": "370240",
    "end": "377590"
  },
  {
    "text": "perfect any more, but close. Whereas this we could not\nmaintain in sorted order.",
    "start": "377590",
    "end": "383180"
  },
  {
    "text": "So this is like a\ngeneralization of binary search to work on trees\ninstead of on arrays.",
    "start": "383180",
    "end": "390670"
  },
  {
    "text": "And for this reason, set binary\ntrees are called binary search trees, because they're the\ntree version of binary search.",
    "start": "390670",
    "end": "396820"
  },
  {
    "text": "So there's many\nequivalent names. So binary search tree is another\nname for set binary tree. And the key thing that\nmakes this algorithm work is",
    "start": "396820",
    "end": "403720"
  },
  {
    "text": "the so-called binary\nsearch tree property, which is all the keys in the\nleft subtree of a node",
    "start": "403720",
    "end": "410050"
  },
  {
    "text": "are less than the\nroot, or of that node, and that key is less than all\nthe keys in the right subtree.",
    "start": "410050",
    "end": "417880"
  },
  {
    "text": "And this is true recursively\nall the way down. And so that's how you prove\nthat this algorithm is",
    "start": "417880",
    "end": "422950"
  },
  {
    "text": "correct by this property. Why is this true? Because if we can\nmaintain traversal order",
    "start": "422950",
    "end": "429160"
  },
  {
    "text": "to be increasing\nkey, then that's exactly what\ntraversal order means. It tells you all the things\nin the left subtree come",
    "start": "429160",
    "end": "436150"
  },
  {
    "text": "before the root, which\ncome before all the things in the right subtree. So this property\nimplies this one.",
    "start": "436150",
    "end": "443680"
  },
  {
    "start": "443000",
    "end": "566000"
  },
  {
    "text": "And how do you maintain things\nin increasing key order? It's pretty easy. If you want to insert an\nitem, where does it belong?",
    "start": "443680",
    "end": "451240"
  },
  {
    "text": "Well, you do this\nsearch to find where it would belong if it was there. If it's there, you can overwrite\nthe value stored with that key.",
    "start": "451240",
    "end": "458260"
  },
  {
    "text": "If it's not, this\nsearch will fall off the tree at some\npoint, and that's",
    "start": "458260",
    "end": "463810"
  },
  {
    "text": "where you insert a\nnew node in your tree.",
    "start": "463810",
    "end": "468850"
  },
  {
    "text": "That was covered in recitation,\nso I don't want to dwell on it. What I want to focus on today\nis the other application.",
    "start": "468850",
    "end": "474919"
  },
  {
    "text": "How do we-- this is for\nrepresenting a set, which is relatively easy. A challenge to sort of\nset ourselves up for,",
    "start": "474920",
    "end": "481960"
  },
  {
    "text": "but we need a\nlittle more work, is to make sequence binary trees.",
    "start": "481960",
    "end": "487540"
  },
  {
    "text": "So suppose I have a binary\ntree, and what I would like-- we mentioned at the\nend of last time-- is that I want the\ntraversal order of my tree",
    "start": "487540",
    "end": "495639"
  },
  {
    "text": "to be the sequence\norder, the order that I'm trying to represent that's\nchanged by operations",
    "start": "495640",
    "end": "502960"
  },
  {
    "text": "like insert_at. So I'd just like to\ndo the same thing.",
    "start": "502960",
    "end": "508473"
  },
  {
    "text": "But now, I have to think\nabout how do I do a search, how do I do a insert_at,\nthat sort of thing. And here is an algorithm for\nwhat I would like to work.",
    "start": "508473",
    "end": "516789"
  },
  {
    "text": "But it's not going\nto quite work yet. So suppose I give you a\nsubtree, so specified by a node.",
    "start": "516789",
    "end": "525700"
  },
  {
    "text": "So there's all the\ndescendants of that node. And I'd like to know what\nis in the traversal order",
    "start": "525700",
    "end": "532360"
  },
  {
    "text": "of that subtree, which\nstarts here, and ends here, and the root will be\nsomewhere in the middle.",
    "start": "532360",
    "end": "538250"
  },
  {
    "text": "Give me the ith node. So if I ask i equals\n0, I want to get",
    "start": "538250",
    "end": "543430"
  },
  {
    "text": "this leftmost descendant. If I ask for i equals the\nsize of the tree minus 1,",
    "start": "543430",
    "end": "548800"
  },
  {
    "text": "I want to get the\nrightmost descendant. That was the first and\nlast in the subtree",
    "start": "548800",
    "end": "553835"
  },
  {
    "text": "that we talked about. But we know how to find\nthe first and last. Just walk left or walk right. But we don't know how\nto find the ith node--",
    "start": "553835",
    "end": "562180"
  },
  {
    "text": "in order h time is the\ngoal right now, not log n. And the idea is, well, it\nseems like size matters.",
    "start": "562180",
    "end": "570399"
  },
  {
    "start": "566000",
    "end": "643000"
  },
  {
    "text": "[CHUCKLES] Sorry if\nyou heard otherwise. So in particular,\nI mentioned size",
    "start": "570400",
    "end": "576940"
  },
  {
    "text": "when I was talking about the\nlast node in the sequence. The index of that node is\nsize of the subtree minus 1.",
    "start": "576940",
    "end": "584860"
  },
  {
    "text": "So let's define\nthe size of a node",
    "start": "584860",
    "end": "591250"
  },
  {
    "text": "to be the number of\nnodes in its subtree--",
    "start": "591250",
    "end": "597310"
  },
  {
    "text": "we were calling\nthat subtree(node)-- ",
    "start": "597310",
    "end": "606510"
  },
  {
    "text": "including the node itself. So if I somehow\nknew the size, this seems important for\nunderstanding indexes.",
    "start": "606510",
    "end": "613590"
  },
  {
    "text": "Let's just assume that\nI knew that magically in constant time. ",
    "start": "613590",
    "end": "619980"
  },
  {
    "text": "Then, I claim that the\nsize of the left subtree-- so why don't I expand\nthis diagram a little bit?",
    "start": "619980",
    "end": "625350"
  },
  {
    "text": " So we have node as before.",
    "start": "625350",
    "end": "631910"
  },
  {
    "text": "But we have left subtree\nand a right subtree. So this node here is node.left.",
    "start": "631910",
    "end": "637700"
  },
  {
    "text": "This node here is node.right. They might not exist, but let's\nignore those exceptional cases for now.",
    "start": "637700",
    "end": "643760"
  },
  {
    "start": "643000",
    "end": "820000"
  },
  {
    "text": "Let's suppose we knew not\nonly the size of node, but we knew the\nsize of node.left,",
    "start": "643760",
    "end": "649280"
  },
  {
    "text": "so that is the size of\nthis tree on the left. I'm going to call that nL.",
    "start": "649280",
    "end": "655070"
  },
  {
    "text": "So let's suppose that there\nare nL nodes down here. I claim that lets me do the\nequivalent of a binary search.",
    "start": "655070",
    "end": "663770"
  },
  {
    "text": "Because I'm looking\nfor some index i. And if i is less than nL, then I\nknow that it must be down here.",
    "start": "663770",
    "end": "670737"
  },
  {
    "text": "For example, if i\nequals 0, it's going to be in the left subtree, as\nlong as nL is greater than 0,",
    "start": "670737",
    "end": "676490"
  },
  {
    "text": "right? So that's exactly this check. If i is less than nL,\nI'm going to recurse to the left, call subtree\nat of node.left, i.",
    "start": "676490",
    "end": "685860"
  },
  {
    "text": "That's what's written here. If i equals nL, if you think\nabout it for a second-- so nL",
    "start": "685860",
    "end": "691430"
  },
  {
    "text": "is the number of nodes here. And so that means this\nnode has index nL.",
    "start": "691430",
    "end": "697340"
  },
  {
    "text": "The index of this node is nL. And so if i equals-- if the\none index we're looking for",
    "start": "697340",
    "end": "702770"
  },
  {
    "text": "is that one, then we\njust return this node. We're done. And otherwise, i\nis greater than nL.",
    "start": "702770",
    "end": "708920"
  },
  {
    "text": "And that means that the\nnode we're looking for is in the right subtree,\nbecause it comes after the root.",
    "start": "708920",
    "end": "714589"
  },
  {
    "text": "Again, that's what it means. That's what traversal\norder means. So if we define it\nto be sequence order,",
    "start": "714590",
    "end": "720830"
  },
  {
    "text": "then we know all the things\nthat come after this node, which is index nL, must be over here.",
    "start": "720830",
    "end": "726120"
  },
  {
    "text": "Now when we recurse down here,\nour numbering system changes. Because for node, 0 is here.",
    "start": "726120",
    "end": "732320"
  },
  {
    "text": "And then for node.right is here. So we need to do a little bit\nof subtraction here, which",
    "start": "732320",
    "end": "737630"
  },
  {
    "text": "is when we recurse\nto the right, we take i minus nL minus 1--\nminus nL for these guys, minus 1 for the root node.",
    "start": "737630",
    "end": "745925"
  },
  {
    "text": "And that will give us\nthe index we're looking for within this subtree.",
    "start": "745925",
    "end": "750980"
  },
  {
    "text": "So my point is, this\nalgorithm is basically the same as this algorithm. But this one uses keys, because\nwe're dealing with a set,",
    "start": "750980",
    "end": "759079"
  },
  {
    "text": "and in sets we assume\nitems have keys. Over here, items don't\nhave to have keys. In fact, we're not\ntouching the items at all.",
    "start": "759080",
    "end": "765810"
  },
  {
    "text": "We're just asking, what is the\nith item in my sequence, which is the same thing as what is the\nith item in my traversal order,",
    "start": "765810",
    "end": "772490"
  },
  {
    "text": "which is the same thing\nas asking what is the ith node in the traversal order? And this algorithm\ngives it to you",
    "start": "772490",
    "end": "778310"
  },
  {
    "text": "exactly the same\nway in order h time. ",
    "start": "778310",
    "end": "783547"
  },
  {
    "text": "Now, I'm not going to show\nyou all the operations. But you can use subtree_at\nto implement get_at set_at.",
    "start": "783547",
    "end": "791930"
  },
  {
    "text": "You just find the appropriate\nnode and return the item or modify the item.",
    "start": "791930",
    "end": "797180"
  },
  {
    "text": "Or you can use it to-- most crucially, you can use\nit to do insert_at delete_at. This is a new thing we've\nnever been able to do before.",
    "start": "797180",
    "end": "805090"
  },
  {
    "text": "What do you do? Just like over here, if I'm\ntrying to insert an item, I search for that\nitem over here.",
    "start": "805090",
    "end": "813300"
  },
  {
    "text": "So if I'm trying to insert at\ni, for example, I look for i. And then for insert_at i,\nwant to add a new item just",
    "start": "813300",
    "end": "823490"
  },
  {
    "start": "820000",
    "end": "909000"
  },
  {
    "text": "before that one. And conveniently,\nwe already have-- I didn't mention, but we\nhave a subtree insert.",
    "start": "823490",
    "end": "830810"
  },
  {
    "text": "We had two versions--\nbefore and after. I think we covered after,\nwhich I use successor",
    "start": "830810",
    "end": "839269"
  },
  {
    "text": "before I use predecessor. But we can just\ncall subtree insert",
    "start": "839270",
    "end": "844280"
  },
  {
    "text": "before at that node, and\nboom, we will have added",
    "start": "844280",
    "end": "849470"
  },
  {
    "text": "a new item just before it. And great, so\nmagically, somehow, we",
    "start": "849470",
    "end": "855709"
  },
  {
    "text": "have inserted in the\nmiddle of this sequence. And all of the indices update,\nbecause I'm not storing",
    "start": "855710",
    "end": "861980"
  },
  {
    "text": "indices. Instead, to search for\nan item at index i, I'm using the search algorithm.",
    "start": "861980",
    "end": "868820"
  },
  {
    "text": "But there's a problem. What's the problem? ",
    "start": "868820",
    "end": "876519"
  },
  {
    "text": "This seems a little\ntoo good to be true. I insert in the\nmiddle of this tree, and then somehow, I can\nmagically search and still",
    "start": "876520",
    "end": "884350"
  },
  {
    "text": "find the ith item, even though\nall the indices to the right of that item incremented by 1. ",
    "start": "884350",
    "end": "892580"
  },
  {
    "text": "It's almost true. Answer? ",
    "start": "892580",
    "end": "898019"
  },
  {
    "text": "Yeah? AUDIENCE: [INAUDIBLE] ERIK DEMAINE: Because we have\nto update the sizes, right.",
    "start": "898020",
    "end": "903130"
  },
  {
    "text": "I didn't say, how do I compute\nthe size of the left subtree? So that is the next topic. ",
    "start": "903130",
    "end": "911949"
  },
  {
    "start": "909000",
    "end": "1007000"
  },
  {
    "text": "We're almost done. This will actually work. It's really quite awesome. But for it to work,\nwe need something",
    "start": "911950",
    "end": "918790"
  },
  {
    "text": "called subtree\naugmentation, which I'll talk about generally.",
    "start": "918790",
    "end": "923920"
  },
  {
    "text": "And then, we'll\napply it to size. ",
    "start": "923920",
    "end": "930370"
  },
  {
    "text": "So the idea with\nsubtree augmentation is that each node\nin our binary tree",
    "start": "930370",
    "end": "937900"
  },
  {
    "text": "can store a constant\nnumber of extra fields.",
    "start": "937900",
    "end": "945100"
  },
  {
    "text": "Why not? And in particular,\nif these fields are of a particular type--",
    "start": "945100",
    "end": "951610"
  },
  {
    "text": "maybe I'll call them properties. ",
    "start": "951610",
    "end": "957700"
  },
  {
    "text": "I'm going to define\na subtree property",
    "start": "957700",
    "end": "970030"
  },
  {
    "text": "to be something\nthat can be computed",
    "start": "970030",
    "end": "981330"
  },
  {
    "text": "from the properties of\nthe nodes' children. ",
    "start": "981330",
    "end": "988740"
  },
  {
    "text": "So I should say\nthis is of a node. ",
    "start": "988740",
    "end": "997230"
  },
  {
    "text": "So children are\nnode.left and node.right. You can also access constant\namount of other stuff,",
    "start": "997230",
    "end": "1004655"
  },
  {
    "text": "for example the node itself. But the point of\na subtree property is it's downward looking.",
    "start": "1004655",
    "end": "1010490"
  },
  {
    "start": "1007000",
    "end": "1097000"
  },
  {
    "text": "If I have a node\nhere, and I want",
    "start": "1010490",
    "end": "1017360"
  },
  {
    "text": "to compute some\nproperty about it-- call it, we want to\nstore P of the node--",
    "start": "1017360",
    "end": "1026000"
  },
  {
    "text": "and suppose we already\nknow P over here, the property computed\nfor the left subtree",
    "start": "1026000",
    "end": "1031910"
  },
  {
    "text": "or for the left\nnode, and we already know the property for the\nright node, then what I'd like",
    "start": "1031910",
    "end": "1037970"
  },
  {
    "text": "is for this to be\ncomputable in constant time. ",
    "start": "1037970",
    "end": "1046160"
  },
  {
    "text": "So I can compute P of this\nnode given P of the left node and P of the right node. That's a subtree property.",
    "start": "1046160",
    "end": "1052340"
  },
  {
    "text": "Now, in particular, size\nis a substrate property.",
    "start": "1052340",
    "end": "1058340"
  },
  {
    "text": "Why? Because I can write\nthis kind of recurrence,",
    "start": "1058340",
    "end": "1063830"
  },
  {
    "text": "node.size equals\nnode.left.size--",
    "start": "1063830",
    "end": "1069282"
  },
  {
    "text": "this is very tedious to write-- plus node.right.size, plus?",
    "start": "1069282",
    "end": "1079580"
  },
  {
    "text": " 1, thank you.",
    "start": "1079580",
    "end": "1085955"
  },
  {
    "text": "The size of the entire\nsubtree here, called node,",
    "start": "1085955",
    "end": "1091184"
  },
  {
    "text": "is the size of the left subtree\nplus size of the right subtree, plus 1 for that node itself.",
    "start": "1091185",
    "end": "1097290"
  },
  {
    "text": "So this is an update rule. It takes constant\ntime to evaluate. It's two editions.",
    "start": "1097290",
    "end": "1102990"
  },
  {
    "text": "Sorry, my t's look kind\nof like plus signs. I'll make the pluses\na little bigger.",
    "start": "1102990",
    "end": "1109390"
  },
  {
    "start": "1109390",
    "end": "1115750"
  },
  {
    "text": "So we're just summing\nthose three things. Boom, we can get node.size. So I claim that as long as\nmy property has this feature,",
    "start": "1115750",
    "end": "1126980"
  },
  {
    "text": "I can maintain it dynamically\nas I'm changing the tree. Now, this is a little bit\nof a forward reference,",
    "start": "1126980",
    "end": "1133722"
  },
  {
    "text": "because we haven't\nsaid exactly how we're going to change the tree yet. But question? AUDIENCE: If node.size\nis recursive,",
    "start": "1133722",
    "end": "1141100"
  },
  {
    "start": "1139000",
    "end": "1266000"
  },
  {
    "text": "then how is it happening\nin constant time? Wouldn't it be\nhappening [INAUDIBLE]?? ERIK DEMAINE: Why is this--",
    "start": "1141100",
    "end": "1146275"
  },
  {
    "text": "OK, good question. So one natural\nway, you can think of this as a recursion,\nwhich gives you a recursive algorithm.",
    "start": "1146275",
    "end": "1152750"
  },
  {
    "text": "So I wrote-- but\ndidn't write it. But I could have written\nsize of node equals this--",
    "start": "1152750",
    "end": "1158140"
  },
  {
    "text": "size of node.left\nplus-- and that would give you a linear time\nalgorithm to count the size. And if you don't\nhave any information,",
    "start": "1158140",
    "end": "1164710"
  },
  {
    "text": "that is what you would do. And that would be very painful. So that would make this\nalgorithm really slow.",
    "start": "1164710",
    "end": "1170427"
  },
  {
    "text": "If I'm calling size as a\nrecursive function, it's bad. What I'm instead doing\nis storing the sizes",
    "start": "1170427",
    "end": "1176410"
  },
  {
    "text": "on every single node\nand pre-computing this.",
    "start": "1176410",
    "end": "1181510"
  },
  {
    "text": "So in fact, I'm going to\ndefine the size of node in-- so this is the definition\nmathematically.",
    "start": "1181510",
    "end": "1188440"
  },
  {
    "text": "But the algorithm\nfor this function is just going to be\nreturn node.size.",
    "start": "1188440",
    "end": "1193600"
  },
  {
    "text": "So that's constant time. So the challenge now is I\nhave to keep these sizes up to date, no matter\nwhat I do to the tree.",
    "start": "1193600",
    "end": "1200470"
  },
  {
    "text": "And you could look\nback at last lecture and see, OK, what were all the\nchanges that I did in a tree?",
    "start": "1200470",
    "end": "1206500"
  },
  {
    "text": "We only did changes\nduring insert and delete. And I will just claim to you,\nwhen we did insert and delete,",
    "start": "1206500",
    "end": "1216940"
  },
  {
    "text": "what they ended up\ndoing in the end,",
    "start": "1216940",
    "end": "1222639"
  },
  {
    "text": "they add or remove\na leaf of the tree.",
    "start": "1222640",
    "end": "1229090"
  },
  {
    "start": "1229090",
    "end": "1235049"
  },
  {
    "text": "Remember, a leaf was a\nnode with no children. So let's just think about if\nI add a new leaf in a tree--",
    "start": "1235050",
    "end": "1242730"
  },
  {
    "text": "here's a tree, suppose\nI add a leaf here-- which subtrees change?",
    "start": "1242730",
    "end": "1248159"
  },
  {
    "text": "Well, which subtrees\ncontain that node? It is its own new subtree.",
    "start": "1248160",
    "end": "1254039"
  },
  {
    "text": "Then it's in its parent subtree,\nand its grandparent subtree, and the overall subtree.",
    "start": "1254040",
    "end": "1260970"
  },
  {
    "text": "In general, these nodes\nare called the ancestors of this node that we added.",
    "start": "1260970",
    "end": "1266250"
  },
  {
    "text": "And those are the\nones that update. This subtree over\nhere didn't change. It didn't change size.",
    "start": "1266250",
    "end": "1271559"
  },
  {
    "text": "And because it's a\nsubtree property, no subtree property\nwill change over here, because the subtree\nwas untouched.",
    "start": "1271560",
    "end": "1278370"
  },
  {
    "text": "So when I touch this\nguy, I just have to update the subtree\nproperty here,",
    "start": "1278370",
    "end": "1284610"
  },
  {
    "text": "update the subtree\nproperty here, update subtree property here. How many of these are there? ",
    "start": "1284610",
    "end": "1292220"
  },
  {
    "text": "Yeah? h-- I'll say order h to be safe. But I think it's exactly h.",
    "start": "1292220",
    "end": "1300090"
  },
  {
    "text": "So also, when I remove\na leaf, the same thing-- if I remove this leaf,\nthen the subtrees that change are exactly\nits former ancestors.",
    "start": "1300090",
    "end": "1306870"
  },
  {
    "text": " Cool, so we're going\nto update those order h",
    "start": "1306870",
    "end": "1321360"
  },
  {
    "text": "ancestors in order up the tree.",
    "start": "1321360",
    "end": "1333770"
  },
  {
    "text": "So what do I mean by update? I mean apply this rule. For size, it's this rule.",
    "start": "1333770",
    "end": "1341809"
  },
  {
    "text": "But in general, the\nsubtree property gives me an update rule\nthat takes constant time. And so I'm going to\napply that update rule",
    "start": "1341810",
    "end": "1348820"
  },
  {
    "text": "to this node, which will fix\nwhatever property is stored in there. Maybe there's more\nthan one property.",
    "start": "1348820",
    "end": "1355130"
  },
  {
    "text": "And then I'll apply\nit to this node. And because this is already\ncorrect by induction, and this is already correct\nbecause I didn't touch this",
    "start": "1355130",
    "end": "1362470"
  },
  {
    "text": "subtree-- it's unchanged-- then I can update the\nvalue at this node-- the property at this\nnode in constant time.",
    "start": "1362470",
    "end": "1369160"
  },
  {
    "text": "Then I update this one. And because this one is\nalready correct by induction, and this one is already\ncorrect because this subtree is",
    "start": "1369160",
    "end": "1375760"
  },
  {
    "text": "unchanged, I can update\nthe property correctly here in constant time. So when I make a\nchange in order h time,",
    "start": "1375760",
    "end": "1383170"
  },
  {
    "text": "because I'm making h calls to\nthis constant time algorithm, I can update a constant\nnumber of subtree properties.",
    "start": "1383170",
    "end": "1391570"
  },
  {
    "text": "This is very powerful. Data structure augmentation\nis super useful. You will use it on\nyour problem set. We will use it again today.",
    "start": "1391570",
    "end": "1399080"
  },
  {
    "text": "Let me give you some examples\nof subtree properties. ",
    "start": "1399080",
    "end": "1407980"
  },
  {
    "text": "They could be-- common ones are,\nlike, the sum, or the product,",
    "start": "1407980",
    "end": "1415059"
  },
  {
    "text": "or the min, or the\nmax, or sum of squares,",
    "start": "1415060",
    "end": "1422290"
  },
  {
    "text": "or all sorts of\nthings, of some feature",
    "start": "1422290",
    "end": "1430090"
  },
  {
    "text": "of every node in the subtree. ",
    "start": "1430090",
    "end": "1437860"
  },
  {
    "text": "In fact, subtree size is\nan example of such a thing. It is the sum over all nodes\nin the subtree of the value 1.",
    "start": "1437860",
    "end": "1445990"
  },
  {
    "text": "It's another way to say\ncount the number of nodes. But you could also\nsay, what's the sum of the keys in these nodes?",
    "start": "1445990",
    "end": "1451697"
  },
  {
    "text": "Or you could say, what's the\nmaximum key in these nodes? Or you could say, what is the\nmaximum value in these nodes?",
    "start": "1451697",
    "end": "1461737"
  },
  {
    "text": "You can take any property. It doesn't have to be key. It doesn't have to be\nanything in particular. It's very powerful. You can take all sums,\nproducts and maintain them",
    "start": "1461737",
    "end": "1468808"
  },
  {
    "text": "as long as they're\ndownward looking-- as long as you're only\nthinking about the subtree.",
    "start": "1468808",
    "end": "1473890"
  },
  {
    "text": "Some examples of things\nyou cannot maintain are-- ",
    "start": "1473890",
    "end": "1481880"
  },
  {
    "text": "not a nodes index. ",
    "start": "1481880",
    "end": "1488480"
  },
  {
    "text": "So if you get a little bit too\nexcited about augmentation, you might think, oh,\nI could do everything.",
    "start": "1488480",
    "end": "1494150"
  },
  {
    "text": "I needed to support\nsubtree_at, or let's just say, get_at\nglobally, I wanted",
    "start": "1494150",
    "end": "1499370"
  },
  {
    "text": "to know what is the\nith node in my tree? Well, I'll just use data\nstructure augmentation and store in every node what is\nits index, 0 through n minus 1.",
    "start": "1499370",
    "end": "1509240"
  },
  {
    "text": "I can't maintain\nthat efficiently. Because if I insert\nat the beginning of my traversal order, then\nall the indices change.",
    "start": "1509240",
    "end": "1518340"
  },
  {
    "text": "So that's an example of a edit. So if I insert a\nnew node over here,",
    "start": "1518340",
    "end": "1523530"
  },
  {
    "text": "so this guy's index\nwas 0, now it's 1. This guy's index\nwas 1, now it's 2. This was 2, now\nit's 3, and so on.",
    "start": "1523530",
    "end": "1529430"
  },
  {
    "text": "Every node changes its index. Index is not a subtree\nproperty, and that's why we can't maintain it.",
    "start": "1529430",
    "end": "1535280"
  },
  {
    "text": "Because it depends on all\nof the nodes in the tree. Or it depends on all\nthe nodes to its left-- all the predecessors.",
    "start": "1535280",
    "end": "1540899"
  },
  {
    "text": "So for example, this\nguy's index depends on how many nodes are over\nhere on the left, which is not",
    "start": "1540900",
    "end": "1546139"
  },
  {
    "start": "1541000",
    "end": "1609000"
  },
  {
    "text": "in the subtree of that node. So that's where you\nhave to be careful. Don't use global\nproperties of the tree.",
    "start": "1546140",
    "end": "1552630"
  },
  {
    "text": "You can only use\nsubtree properties.",
    "start": "1552630",
    "end": "1557760"
  },
  {
    "text": "Another example is depth. Depth Is annoying to maintain,\nbut it's not obvious why yet.",
    "start": "1557760",
    "end": "1568220"
  },
  {
    "text": "We will see that in a moment. ",
    "start": "1568220",
    "end": "1574610"
  },
  {
    "text": "The rest of today is about\ngoing from order h order log",
    "start": "1574610",
    "end": "1580220"
  },
  {
    "text": "n, which is what this\nslide is showing us. So at this point, you should\nbelieve that we can do all",
    "start": "1580220",
    "end": "1586460"
  },
  {
    "text": "of the sequence data structure\noperations in order h time-- except for build and iterate,\nwhich take linear time--",
    "start": "1586460",
    "end": "1593130"
  },
  {
    "text": "and that we can do all of the\nset operations in order h time, except build and\niterate, which take",
    "start": "1593130",
    "end": "1598460"
  },
  {
    "text": "n log n and n respectively. And our goal is to\nnow bound h by log n.",
    "start": "1598460",
    "end": "1610790"
  },
  {
    "text": "We know it's possible\nat some level, because there are trees that\nhave logarithmic height.",
    "start": "1610790",
    "end": "1617450"
  },
  {
    "text": "That's like this\nperfect tree here. But we also know we\nhave to be careful, because there are some bad\ntrees, like this chain.",
    "start": "1617450",
    "end": "1624320"
  },
  {
    "text": " So if h equals log n, we call\nthis a balanced binary tree.",
    "start": "1624320",
    "end": "1635140"
  },
  {
    "text": " There are many\nbalanced binary trees",
    "start": "1635140",
    "end": "1641200"
  },
  {
    "text": "in the world, maybe\na dozen or two-- a lot of different\ndata structures. Question?",
    "start": "1641200",
    "end": "1646260"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]\nyou said not to think about things\non a global level so we'll think of\nthem [INAUDIBLE]..",
    "start": "1646260",
    "end": "1652433"
  },
  {
    "text": "Can you explain what\nthat means a little more? ERIK DEMAINE: OK,\nwhat does it mean for a property to be local\nto a subtree versus global?",
    "start": "1652433",
    "end": "1660520"
  },
  {
    "start": "1654000",
    "end": "1740000"
  },
  {
    "text": "The best answer is\nthis definition. But that's maybe not the\nmost intuitive definition. This is what I mean.",
    "start": "1660520",
    "end": "1666033"
  },
  {
    "text": "Something that can be computed\njust knowing information about your left\nand right children, that is the meaning\nof such a property.",
    "start": "1666033",
    "end": "1672220"
  },
  {
    "text": "And those are the only things\nyou're allowed to maintain. Because those are\nthe only things",
    "start": "1672220",
    "end": "1677320"
  },
  {
    "text": "that are easy to update\nby walking up this path. And the contrast is that\nglobal property like index,",
    "start": "1677320",
    "end": "1686050"
  },
  {
    "text": "it's global, in\nparticular, because I can do one change, add one\nnode, and all of the node's",
    "start": "1686050",
    "end": "1692140"
  },
  {
    "text": "properties change. So that's an extreme\nexample of global. We want this very\nparticular notion of local,",
    "start": "1692140",
    "end": "1700179"
  },
  {
    "text": "because that's what we can\nactually afford to recompute. Hopefully that clarifies. Yeah?",
    "start": "1700180",
    "end": "1707008"
  },
  {
    "text": "AUDIENCE: Doesn't size not\nwork with that [INAUDIBLE]?? ERIK DEMAINE: You're\nright that if we added--",
    "start": "1707008",
    "end": "1713700"
  },
  {
    "text": "oh, no. OK, let's think about that. If we added a new\nparent to the tree-- this is not something\nthat we've ever done.",
    "start": "1713700",
    "end": "1720600"
  },
  {
    "text": "But even if we did that,\nwhich subtrees change? Only this one.",
    "start": "1720600",
    "end": "1727740"
  },
  {
    "text": "This node, it's a\ntotally new subtree. But the subtree of this node\nis completely unchanged.",
    "start": "1727740",
    "end": "1732780"
  },
  {
    "text": "Because subtrees are\nalways downward looking, if I added a new root, I\ndidn't change any subtrees",
    "start": "1732780",
    "end": "1738270"
  },
  {
    "text": "except for one. So size is a subtree property. Now, there are--",
    "start": "1738270",
    "end": "1743490"
  },
  {
    "start": "1740000",
    "end": "1794000"
  },
  {
    "text": "I mean, I could completely\nredraw the tree. And that's an operation\nthat requires everything to be recomputed.",
    "start": "1743490",
    "end": "1748980"
  },
  {
    "text": "So it is limited exactly what\nI'm allowed to do in the tree. But I claim everything\nwe'll do, last class and today, we can afford\nthis augmentation.",
    "start": "1748980",
    "end": "1758409"
  },
  {
    "text": "So it's a feature, not of\nall binary trees necessarily, but of the ones\nthat we would cover. Yeah? AUDIENCE: What is a min?",
    "start": "1758410",
    "end": "1764395"
  },
  {
    "text": "ERIK DEMAINE: What is a min? AUDIENCE: [INAUDIBLE] ERIK DEMAINE: Binary tree, yeah.",
    "start": "1764395",
    "end": "1771360"
  },
  {
    "text": "OK, this will make a little\nmore sense in a moment when I say what we're actually\ngoing to do with trees.",
    "start": "1771360",
    "end": "1778100"
  },
  {
    "start": "1778100",
    "end": "1789059"
  },
  {
    "text": "We need a new tool for\nmanipulating a tree. What we've done so far, we've\ndone some swapping of items.",
    "start": "1789060",
    "end": "1796529"
  },
  {
    "start": "1794000",
    "end": "1811000"
  },
  {
    "text": "And we did adding\nand removing a leaf. That's not enough. We're going to need\nsomething else to let us",
    "start": "1796530",
    "end": "1801990"
  },
  {
    "text": "guarantee logarithmic height. And that something else\nis called a rotation.",
    "start": "1801990",
    "end": "1807899"
  },
  {
    "text": " What does this something\nelse need to do?",
    "start": "1807900",
    "end": "1815350"
  },
  {
    "start": "1811000",
    "end": "1956000"
  },
  {
    "text": "This is just a tool for\nrebalancing the tree. So it should not change the data\nthat's represented by the tree.",
    "start": "1815350",
    "end": "1822280"
  },
  {
    "text": "What is the data\nrepresented by the tree? Traversal order. Traversal order is sacrosanct.",
    "start": "1822280",
    "end": "1827659"
  },
  {
    "text": "We're not allowed to touch it. It's already defined\ntwo different ways, depending on whether you're\nusing a set or sequence.",
    "start": "1827660",
    "end": "1834410"
  },
  {
    "text": "So we want to modify the\ntree in a way that doesn't modify the traversal order. So we're exploiting redundancy.",
    "start": "1834410",
    "end": "1841510"
  },
  {
    "text": "If you wrote down the\ntraversal order in an array, there's exactly\none representation of a given order.",
    "start": "1841510",
    "end": "1846940"
  },
  {
    "text": "But in a tree, there's\nmany representations. It could be a long line. It could be a balance thing.",
    "start": "1846940",
    "end": "1852520"
  },
  {
    "text": "They could represent the\nexact same order on the nodes if you label them right. In fact, there are exponentially\nmany different representations",
    "start": "1852520",
    "end": "1859299"
  },
  {
    "text": "of the same thing. And we're going to exploit that,\nthe same order, and define--",
    "start": "1859300",
    "end": "1864880"
  },
  {
    "text": "this is just a thing\nyou need to know. ",
    "start": "1864880",
    "end": "1880364"
  },
  {
    "text": "Let me label, A, X, B,\nY, C. You can tell I've",
    "start": "1880364",
    "end": "1887820"
  },
  {
    "text": "drawn this diagram\nbefore many, many times. This is a very powerful tool\nin all tree data structures,",
    "start": "1887820",
    "end": "1895059"
  },
  {
    "text": "which are most of\ndata structures. And they are called right rotate\nof y and left rotate of x.",
    "start": "1895060",
    "end": "1906940"
  },
  {
    "start": "1906940",
    "end": "1913860"
  },
  {
    "text": "So if I have this tree-- which I'm just black\nboxing some of the subtrees into little triangles.",
    "start": "1913860",
    "end": "1919410"
  },
  {
    "text": "If I have a node, and\nit has a left child, then I'm allowed to right rotate\nthis edge, which means take",
    "start": "1919410",
    "end": "1925590"
  },
  {
    "text": "this edge and go like this-- 90 degrees, kind of. Or you could just think of\nit as rewriting it this way.",
    "start": "1925590",
    "end": "1931350"
  },
  {
    "text": "Now, you might also have keeping\ntrack of the parent pointer. Parent pointer moves around.",
    "start": "1931350",
    "end": "1936720"
  },
  {
    "text": "Before, this was\nthe parent of y. Now it's the parent of x. So x and y are switching places.",
    "start": "1936720",
    "end": "1943980"
  },
  {
    "text": "But we couldn't just\nswap these items around, because that would\nchange traversal order.",
    "start": "1943980",
    "end": "1949980"
  },
  {
    "text": "In this picture,\nx comes before y, because x is in the left\nsubtree of y in traversal order.",
    "start": "1949980",
    "end": "1956850"
  },
  {
    "start": "1956000",
    "end": "1999000"
  },
  {
    "text": "And over here, now y is\nin the right subtree of x. So it comes after x. So in both cases,\nx comes before y.",
    "start": "1956850",
    "end": "1963600"
  },
  {
    "text": "And indeed, in all of these\npictures the traversal order--",
    "start": "1963600",
    "end": "1968610"
  },
  {
    "text": "I mean, not just for x and\ny, but also for A, B, and C, the traversal order\nis consistent. It is A, X, B, y, C, where,\nwhen I write a triangle,",
    "start": "1968610",
    "end": "1981975"
  },
  {
    "text": "I mean recursively the\ntraversal order of all the things in the triangle. So if you just apply the\ntraversal order algorithm here",
    "start": "1981975",
    "end": "1987870"
  },
  {
    "text": "versus here, you\nget the same output, which means these operations\npreserve traversal order.",
    "start": "1987870",
    "end": "1992970"
  },
  {
    "start": "1992970",
    "end": "1998770"
  },
  {
    "text": "Great, so this is\na thing that we can do in a tree that won't\naffect any of the stuff",
    "start": "1998770",
    "end": "2004890"
  },
  {
    "start": "1999000",
    "end": "2111000"
  },
  {
    "text": "we've done so far. It's a tool that we\ncan use to rebalance. Notice how deep things\nare in the tree changes.",
    "start": "2004890",
    "end": "2014190"
  },
  {
    "text": "Our problem with\nthis linear tree is that there are some\nnodes of linear depth.",
    "start": "2014190",
    "end": "2019200"
  },
  {
    "text": "We want to get rid of those. How? Well, we could take these edges\nand start rotating them up. If you look at depths,\nin this picture,",
    "start": "2019200",
    "end": "2027850"
  },
  {
    "text": "A and B are deeper than\nC. And in this picture, B and C are deeper than\nA. So it's a trade off.",
    "start": "2027850",
    "end": "2035100"
  },
  {
    "text": "This one moved up. This one moved down. This one stayed\nat the same depth.",
    "start": "2035100",
    "end": "2041040"
  },
  {
    "text": "So hopefully, if A is too\ndeep and C is too shallow,",
    "start": "2041040",
    "end": "2047130"
  },
  {
    "text": "they can trade off like this. It may sound difficult,\nbut in fact, there's a pretty simple way, which\nare called AVL trees, that",
    "start": "2047130",
    "end": "2058770"
  },
  {
    "text": "maintain balance in a particular\nway called height balance.",
    "start": "2058770",
    "end": "2064439"
  },
  {
    "start": "2064439",
    "end": "2074730"
  },
  {
    "text": "This is if we take the\nheight of node.left--",
    "start": "2074730",
    "end": "2082710"
  },
  {
    "text": " actually, I'd prefer to-- ",
    "start": "2082710",
    "end": "2090080"
  },
  {
    "text": "node.right, minus\nheight of node.left,",
    "start": "2090080",
    "end": "2103190"
  },
  {
    "text": "so this thing is called\nskew of the node.",
    "start": "2103190",
    "end": "2111050"
  },
  {
    "start": "2111000",
    "end": "2179000"
  },
  {
    "text": "I want this to always be\nminus 1, 0, or plus 1. ",
    "start": "2111050",
    "end": "2117890"
  },
  {
    "text": "So this is saying that\nif I have any node, and I look if its left\nsubtree and its right subtree,",
    "start": "2117890",
    "end": "2125371"
  },
  {
    "text": "I measure their\nheights-- remember, that's downward distance,\nmaximum distance to a leaf--",
    "start": "2125372",
    "end": "2130670"
  },
  {
    "text": "I measure the height\nof this tree-- maximum height-- and I\nmeasure the maximum height of this subtree, I want these\nto be within 1 of each other.",
    "start": "2130670",
    "end": "2139012"
  },
  {
    "text": "Ideally, they're equal. That would be the perfect case. But let's let them differ by 1.",
    "start": "2139012",
    "end": "2144140"
  },
  {
    "text": "So maybe this is k\nand this is k plus 1. Or maybe this is k\nand this is k minus 1.",
    "start": "2144140",
    "end": "2151670"
  },
  {
    "text": "In this picture, what is\nthe height of this node? It's good practice.",
    "start": "2151670",
    "end": "2156812"
  },
  {
    "text": "k plus 2, good. What's the longest path\nfrom this node to a leaf? Well, it could go\nthrough this subtree.",
    "start": "2156812",
    "end": "2163460"
  },
  {
    "text": "And that would be length k\nplus 1, because it's k in here plus 1 for this edge. Or it could be through here,\nand that's k plus 1 plus 1.",
    "start": "2163460",
    "end": "2170450"
  },
  {
    "text": "So the biggest is\nto go to the right. So the height-- if I told you\nthe height of these subtrees, we can derive the\nheight of this node.",
    "start": "2170450",
    "end": "2176443"
  },
  {
    "text": "We're going to use\nthat a lot in a moment. So, the first claim\nis that if I could",
    "start": "2176443",
    "end": "2181490"
  },
  {
    "start": "2179000",
    "end": "2648000"
  },
  {
    "text": "maintain height\nbalance, then I will",
    "start": "2181490",
    "end": "2186619"
  },
  {
    "text": "guarantee that h equals log n. So in other words, height\nbalance implies balance.",
    "start": "2186620",
    "end": "2192180"
  },
  {
    "text": "So let's prove\nthat first quickly. And then, the interesting part\nis how do we actually prove--",
    "start": "2192180",
    "end": "2200505"
  },
  {
    "text": " or how do we actually\nmaintain the balance property?",
    "start": "2200505",
    "end": "2207825"
  },
  {
    "text": "We're going to do\nthat using rotations. But how is a big question. ",
    "start": "2207825",
    "end": "2221720"
  },
  {
    "text": "So why does height\nbalance imply balance?",
    "start": "2221720",
    "end": "2227420"
  },
  {
    "start": "2227420",
    "end": "2236549"
  },
  {
    "text": "So what this is saying is\nthat all height balanced trees have logarithmic height.",
    "start": "2236550",
    "end": "2244810"
  },
  {
    "text": "So what I'd like\nto think about is sort of the least balanced\nheight balanced tree.",
    "start": "2244810",
    "end": "2250890"
  },
  {
    "text": "The least balanced one is going\nto have every node a mismatch.",
    "start": "2250890",
    "end": "2256069"
  },
  {
    "text": "Let's say the left\nsubtree is shallower than the right subtree by 1, and\nrecursively all the way down.",
    "start": "2256070",
    "end": "2262799"
  },
  {
    "text": "So every node has\na gap here, a-- ",
    "start": "2262800",
    "end": "2269522"
  },
  {
    "text": "what do we call it-- a skew of 1, which\nI'm going to write--",
    "start": "2269522",
    "end": "2276520"
  },
  {
    "text": "I'm going to introduce\nsome notation. I'll write a dissenting\nrightward arrow of this one is higher than the left subtree.",
    "start": "2276520",
    "end": "2283165"
  },
  {
    "text": " So the easy way to\nthink about this",
    "start": "2283165",
    "end": "2288270"
  },
  {
    "text": "is this is sort\nof our worst case. This is going to be the fewest\nnodes for the maximum depth.",
    "start": "2288270",
    "end": "2294260"
  },
  {
    "text": "Let's just count how many\nnodes are in this tree. I'm going to write that\nas a recurrence, which",
    "start": "2294260",
    "end": "2301310"
  },
  {
    "text": "is the number of nodes\nin a tree of height h. So if this whole tree has height\nh, as we said in this picture,",
    "start": "2301310",
    "end": "2312680"
  },
  {
    "text": "if I just subtract 2\nfrom all these numbers, then this one has\nheight h minus 2,",
    "start": "2312680",
    "end": "2320270"
  },
  {
    "text": "and this one has\nheight h minus 1. So how many nodes are in here?",
    "start": "2320270",
    "end": "2325833"
  },
  {
    "text": "Well, this is a recurrence\nI'm going to write. So this will be N sub h minus 2.",
    "start": "2325833",
    "end": "2332060"
  },
  {
    "text": "This will be N sub h minus 1. And then I just count how many\nnodes are in this picture.",
    "start": "2332060",
    "end": "2337910"
  },
  {
    "text": "It is Nh minus 1 plus Nh\nminus 2 plus 1, or this node.",
    "start": "2337910",
    "end": "2346099"
  },
  {
    "text": "Now you might ask, what\nis Nh a recurrence for? But it is the number of nodes\nin this sort of worst case",
    "start": "2346100",
    "end": "2355760"
  },
  {
    "text": "if the worst case\nhas total height h. So you can also\nthink of it as what is the minimum number\nof nodes I could",
    "start": "2355760",
    "end": "2362090"
  },
  {
    "text": "have in an AVL tree, which is\na height balanced tree, that has a height h in a\nheight balanced tree?",
    "start": "2362090",
    "end": "2378610"
  },
  {
    "text": "OK, so now I just need\nto solve this recurrence. This recurrence\nlook familiar-ish? ",
    "start": "2378610",
    "end": "2388050"
  },
  {
    "text": "It's like Fibonacci numbers. If I remove the plus\n1, it's Fibonacci. And if you happen to know\nthe Fibonacci numbers grow",
    "start": "2388050",
    "end": "2394319"
  },
  {
    "text": "as, like, a golden\nratio to the n, then we know that\nthis is exponential, which is what we want.",
    "start": "2394320",
    "end": "2399540"
  },
  {
    "text": "Because if Nh is\nexponential in h, that means h is\nlogarithmic in N,",
    "start": "2399540",
    "end": "2404670"
  },
  {
    "text": "because log is inverse\nof exponential. But maybe you don't know\nabout Fibonacci numbers. And so we can still easily\nshow that this is exponential",
    "start": "2404670",
    "end": "2414299"
  },
  {
    "text": "as follows. I want to prove that it's\nat least an exponential, because that gives me that\nh is at most logarithmic.",
    "start": "2414300",
    "end": "2422830"
  },
  {
    "text": "So we need a lower bound. And so we have these two terms\nwhich are hard to compare-- Nh minus 1 and Nh minus 2.",
    "start": "2422830",
    "end": "2428850"
  },
  {
    "text": "It's kind of ugly. But if we're allowed\nto be sloppy-- and we'll see if\nwe're not too sloppy-- and still get an\nexponential answer,",
    "start": "2428850",
    "end": "2435570"
  },
  {
    "text": "let's just make\nthem equal like so. ",
    "start": "2435570",
    "end": "2444150"
  },
  {
    "text": "So this is a true statement,\nin fact, strictly greater than. Why? Because I removed the plus 1.",
    "start": "2444150",
    "end": "2450420"
  },
  {
    "text": "That should only make\nsomething smaller. And I replaced Nh minus\n1 with Nh minus 2.",
    "start": "2450420",
    "end": "2456600"
  },
  {
    "text": "Here, I'm implicitly\nusing a fact, which is obvious by induction,\nthat this tree on height--",
    "start": "2456600",
    "end": "2463170"
  },
  {
    "text": "if I take this tree\nversus this tree, this one has more\nnodes than this one. If I have larger height,\nthis construction",
    "start": "2463170",
    "end": "2470130"
  },
  {
    "text": "is going to build a bigger\ntree, at least as big. It doesn't even need\nto be strictly bigger.",
    "start": "2470130",
    "end": "2475710"
  },
  {
    "text": "So certainly, Nh minus 1\nis greater than or equal to Nh minus 2. Now, this is 2 times Nh minus 2.",
    "start": "2475710",
    "end": "2484230"
  },
  {
    "text": "And this is an easy recurrence. This is just powers of 2. I keep multiplying by 2,\nand subtracting 2 from h.",
    "start": "2484230",
    "end": "2491460"
  },
  {
    "text": "So this solves to\n2 to the h over 2, maybe with a floor or something.",
    "start": "2491460",
    "end": "2497880"
  },
  {
    "text": "But I'm using a base case here,\nwhich is N sub 0 equals 1.",
    "start": "2497880",
    "end": "2503490"
  },
  {
    "text": " Maybe it's a ceiling then. But the point is\nthis is exponential.",
    "start": "2503490",
    "end": "2509380"
  },
  {
    "text": "So this implies that the height\nis always, at most, 2 times log n.",
    "start": "2509380",
    "end": "2515730"
  },
  {
    "text": "This 2 corresponds to this 2. If you just invert\nthis formula, this was a number of nodes is\ngoing to be at least 2",
    "start": "2515730",
    "end": "2524500"
  },
  {
    "text": "to the h over 2. And so h is, at most, 2 log n. So it's not log n. That would be perfect.",
    "start": "2524500",
    "end": "2529830"
  },
  {
    "text": "But it's within a\nfactor of 2 of log n. So AVL trees are\nalways quite balanced.",
    "start": "2529830",
    "end": "2535510"
  },
  {
    "text": "Number of levels\nis at most double what you need to store n nodes. Great. ",
    "start": "2535510",
    "end": "2543980"
  },
  {
    "text": "We're left with the main magic-- not domain magic. That's different.",
    "start": "2543980",
    "end": "2551060"
  },
  {
    "text": "And let's see, we're going\nto use subtree augmentation. ",
    "start": "2551060",
    "end": "2557550"
  },
  {
    "text": "Keep that. ",
    "start": "2557550",
    "end": "2565510"
  },
  {
    "text": "Big remaining\nchallenge is how do we maintain this high balance\nproperty using rotations?",
    "start": "2565510",
    "end": "2571240"
  },
  {
    "text": "We have all the ingredients\nlined up for us. We have subtree augmentation.",
    "start": "2571240",
    "end": "2576670"
  },
  {
    "text": "What does that let me do?  It's relevant to AVL trees.",
    "start": "2576670",
    "end": "2582710"
  },
  {
    "text": "Well, it lets me store height. I need to be able to compute\nthe height of a node.",
    "start": "2582710",
    "end": "2591230"
  },
  {
    "text": "That, in general,\ntakes linear time, because I have to look at\nall the downward paths-- all the leaves\nwithin that subtree.",
    "start": "2591230",
    "end": "2596660"
  },
  {
    "text": "But height is a\nsubtree property-- so, yes-- height.",
    "start": "2596660",
    "end": "2607470"
  },
  {
    "text": "Why? Because-- let me\njust write it here--",
    "start": "2607470",
    "end": "2613670"
  },
  {
    "text": "node.height equals 1 plus\nmax of node.left.height",
    "start": "2613670",
    "end": "2629140"
  },
  {
    "text": "and node.right.height\nand of max.",
    "start": "2629140",
    "end": "2637150"
  },
  {
    "text": "Let me put this in a box. This equation, or I guess\nit's an assignment operation--",
    "start": "2637150",
    "end": "2645549"
  },
  {
    "text": "this is a 1-- is the thing we've been\ndoing over and over. When I said what is the\nheight of this node,",
    "start": "2645550",
    "end": "2651660"
  },
  {
    "start": "2648000",
    "end": "2768000"
  },
  {
    "text": "you just figured\nthat out, right? You took the height of\nthe left subtree maxed with the height of\nthe right subtree and added 1 to account\nfor these edges.",
    "start": "2651660",
    "end": "2659250"
  },
  {
    "text": "So this is a\ngeneral update rule. It matches this subtree\nproperty pattern. If I have the property\nof left and right,",
    "start": "2659250",
    "end": "2665280"
  },
  {
    "text": "I can compute it for node. And this takes\nconstant time to do. And so it's a subtree property.",
    "start": "2665280",
    "end": "2670900"
  },
  {
    "text": "And so I can maintain, through\nall the things I'm doing, the height of every node. Oh by the way, whenever\nI do a rotation,",
    "start": "2670900",
    "end": "2677800"
  },
  {
    "text": "I'm also going to have to\nupdate my subtree properties. When I rotate this edge, A does\nnot change, B does not change,",
    "start": "2677800",
    "end": "2685720"
  },
  {
    "text": "C does not change. So that's good. But x's subtree changes. It now has y.",
    "start": "2685720",
    "end": "2690840"
  },
  {
    "text": "It didn't before. So we're going to have to also\nupdate the augmentation here",
    "start": "2690840",
    "end": "2696620"
  },
  {
    "text": "in y. And we're going to have to\nupdate the augmentation in x.",
    "start": "2696620",
    "end": "2703550"
  },
  {
    "text": "And we're going\nto have to update the augmentation of all of\nthe ancestors of x eventually.",
    "start": "2703550",
    "end": "2710280"
  },
  {
    "text": "So rotation is\nlocally just changing a constant number of pointers. So I usually think of rotations\nas taking constant time.",
    "start": "2710280",
    "end": "2718049"
  },
  {
    "text": "But eventually, we\nwill have to do-- this is constant time locally. ",
    "start": "2718050",
    "end": "2725250"
  },
  {
    "text": "But we will need to update\nh ancestors in order",
    "start": "2725250",
    "end": "2735720"
  },
  {
    "text": "to store all of-- keep all of\nour augmentations up to date. We'll worry about that later. ",
    "start": "2735720",
    "end": "2743380"
  },
  {
    "text": "All right, so great. Now we have the height\nof all the nodes. We can compute the skew\nof all the nodes, cool.",
    "start": "2743380",
    "end": "2750860"
  },
  {
    "text": "We have this rotation operation. And we want to maintain this\nheight balance property.",
    "start": "2750860",
    "end": "2758320"
  },
  {
    "text": "Height of left node-- left\nand right of every node-- is plus or minus 1, or 0.",
    "start": "2758320",
    "end": "2763630"
  },
  {
    "text": " Cool, so I said over here\nsomewhere, whenever we--",
    "start": "2763630",
    "end": "2773740"
  },
  {
    "start": "2768000",
    "end": "2844000"
  },
  {
    "text": "so the only things\nthat change the tree are when we insert\nor delete a new node. And the way that we\nimplemented those so far",
    "start": "2773740",
    "end": "2780210"
  },
  {
    "text": "is to add or remove a leaf. So we should still be thinking\nabout adding or removing a leaf. The problem is, when\nI add a new leaf,",
    "start": "2780210",
    "end": "2787410"
  },
  {
    "text": "now maybe this tree is\nhigher than it used to be. So some node here may no\nlonger be height balanced.",
    "start": "2787410",
    "end": "2795270"
  },
  {
    "text": "But because height is\na subtree property, the only nodes we\nneed to check are the ones up this ancestor path.",
    "start": "2795270",
    "end": "2802330"
  },
  {
    "text": "And there's only log n of them,\nbecause now height is log n. That's what we just proved as\nlong as we have this property.",
    "start": "2802330",
    "end": "2807660"
  },
  {
    "text": "Now, we right now don't\nhave it for, like, maybe these few nodes. But it was long n before.",
    "start": "2807660",
    "end": "2813570"
  },
  {
    "text": "It's at most log n-- 2 log n plus 1 right now,\nbecause we just added a node. So what I want to do is\ncheck all of these ancestor",
    "start": "2813570",
    "end": "2820920"
  },
  {
    "text": "nodes in sequence from\nbottom up, and find one that's out of balance.",
    "start": "2820920",
    "end": "2826550"
  },
  {
    "text": "So let's take the lowest\nout of balance node.",
    "start": "2826550",
    "end": "2835710"
  },
  {
    "start": "2835710",
    "end": "2841540"
  },
  {
    "text": "I'm going to call that x. Now, because we just insert\nor deleted a single leaf,",
    "start": "2841540",
    "end": "2848370"
  },
  {
    "text": "it's only out of balance\nby 1, because we only changed height--",
    "start": "2848370",
    "end": "2853590"
  },
  {
    "text": "one height went up by 1, or\none height went down by 1. And before, all of our skews\nwere plus or minus 1, or 0.",
    "start": "2853590",
    "end": "2860730"
  },
  {
    "text": "So now, it's-- the bad case\nis when it's plus or minus 2. If it happens to still be in\nthis range for all the nodes,",
    "start": "2860730",
    "end": "2866640"
  },
  {
    "text": "we're happy. But if it's outside this range,\nit's only going to be out by 1. So this means the skew\nis n plus 2 or minus 2.",
    "start": "2866640",
    "end": "2878550"
  },
  {
    "text": "And let's say that\nit's 2 by symmetry. So my picture is--",
    "start": "2878550",
    "end": "2886098"
  },
  {
    "text": "I'm going to draw\ndouble right arrow to say that this subtree is\n2 higher than this subtree.",
    "start": "2886098",
    "end": "2898590"
  },
  {
    "start": "2894000",
    "end": "2934000"
  },
  {
    "text": "OK, so that's bad and\nwe want to fix it. The obvious thing to do\nis to rotate this edge.",
    "start": "2898590",
    "end": "2905265"
  },
  {
    "text": "Because that'll make this--  this is too high\nand this is too low.",
    "start": "2905265",
    "end": "2911590"
  },
  {
    "text": "So if we rotate, this\nshould go down by 1 and this should go up by 1. And that works most of the time.",
    "start": "2911590",
    "end": "2918070"
  },
  {
    "text": "So case one is the skew of y.",
    "start": "2918070",
    "end": "2925200"
  },
  {
    "text": "What is y? I want y to be the\nright child of x. Because we have a positive skew,\nwe know there is a right child.",
    "start": "2925200",
    "end": "2934260"
  },
  {
    "text": "Now, because this was\nthe lowest bad node, we know that y is actually good. It's either right heavy--\nor even the two subtrees",
    "start": "2934260",
    "end": "2942300"
  },
  {
    "text": "have the same height--\nor left heavy. The easy cases\nare when skew of y",
    "start": "2942300",
    "end": "2953940"
  },
  {
    "text": "is either 1 or 0,\nwhich I will draw.",
    "start": "2953940",
    "end": "2962720"
  },
  {
    "start": "2962720",
    "end": "2969980"
  },
  {
    "text": "So a double right arrow,\nlet's say single right arrow-- ",
    "start": "2969980",
    "end": "2980430"
  },
  {
    "text": "so I'm just going to\nadd some labels here to make this\npicture consistent--",
    "start": "2980430",
    "end": "2988562"
  },
  {
    "text": "k plus 1, k plus 2. I'm riding the heights. So this is an example\nwhere C is taller",
    "start": "2988562",
    "end": "2996010"
  },
  {
    "text": "than B. A and B are\nthe same height. And then if you compute\nthe heights up here, indeed this one\nis right leaning.",
    "start": "2996010",
    "end": "3003480"
  },
  {
    "text": "This one is doubly\nright leaning. Because this one\nhas height k plus 1. This one has height k minus 1. That's bad.",
    "start": "3003480",
    "end": "3008890"
  },
  {
    "text": "But if we do this\nright rotation on x, we get exactly what we want.",
    "start": "3008890",
    "end": "3014100"
  },
  {
    "text": " So I'm just going to copy\nthe labels on A, B, C--",
    "start": "3014100",
    "end": "3020940"
  },
  {
    "text": "we have k minus 1,\nk minus 1, and k-- and then recompute. That means this\nguy has height k,",
    "start": "3020940",
    "end": "3026400"
  },
  {
    "text": "this one has height k plus 1. And now, all the nodes in this\npicture that I've highlighted--",
    "start": "3026400",
    "end": "3031653"
  },
  {
    "text": "A, B, and C haven't changed. They were height\nbalanced before. They still are. But now, x and y--",
    "start": "3031653",
    "end": "3036720"
  },
  {
    "text": "x wasn't height\nbalanced before, y was. Now, both x and y\nare height balanced.",
    "start": "3036720",
    "end": "3042420"
  },
  {
    "text": "That's case one. In case two, the\nskew of y is flat,",
    "start": "3042420",
    "end": "3049390"
  },
  {
    "text": "which means that this\nis a k, and this is a k,",
    "start": "3049390",
    "end": "3054869"
  },
  {
    "text": "and this is a k plus 1,\nand this is a k plus 2. But still, all the\nnodes are balanced--",
    "start": "3054870",
    "end": "3060743"
  },
  {
    "text": "height balanced. They're still plus or minus 1. So those are the easy cases. Unfortunately, there\nis a hard case--",
    "start": "3060743",
    "end": "3067240"
  },
  {
    "text": "case three. But there's only one, and\nit's not that much harder. ",
    "start": "3067240",
    "end": "3076320"
  },
  {
    "text": "So it's when skew\nof y is minus 1.",
    "start": "3076320",
    "end": "3081780"
  },
  {
    "text": "In this case, we need to\nlook at the left child of y. ",
    "start": "3081780",
    "end": "3088590"
  },
  {
    "text": "And to be alphabetical, I'm\ngoing to rename this to z. ",
    "start": "3088590",
    "end": "3094470"
  },
  {
    "text": "So this one, again,\nis double right arrow. This one is now left arrow.",
    "start": "3094470",
    "end": "3099540"
  },
  {
    "text": "And this is letter y. And so we have A, B, C, and D\npotential subtrees hanging off",
    "start": "3099540",
    "end": "3109950"
  },
  {
    "text": "of them. And I'm going to label the\nheights of these things. These are each k\nminus 1 or k minus 2.",
    "start": "3109950",
    "end": "3119010"
  },
  {
    "text": "This one's k minus 1. And now, compute the inside. So this is going to height k\nfor this to be left leaning.",
    "start": "3119010",
    "end": "3126690"
  },
  {
    "text": "So this is k plus 1,\nand this is k plus 2. But the problem is this\nis 2 higher than this.",
    "start": "3126690",
    "end": "3133680"
  },
  {
    "text": "The height of z is 2 higher\nthan the height of A. This case, if I\ndo this rotation,",
    "start": "3133680",
    "end": "3138990"
  },
  {
    "text": "things get worse, actually. I'll just tell you the\nright thing to do is--",
    "start": "3138990",
    "end": "3146609"
  },
  {
    "text": "this is the one thing\nyou need to memorize. ",
    "start": "3146610",
    "end": "3161700"
  },
  {
    "text": "And let me draw the results. You can also just think of it\nas redrawing the tree like this.",
    "start": "3161700",
    "end": "3167300"
  },
  {
    "text": "But it's easier from\nan analysis perspective to think about it\nas two rotations. Then we can just reduce.",
    "start": "3167300",
    "end": "3172940"
  },
  {
    "text": "As long as we know\nhow rotations work, then we know that\nthis thing works-- \"works\" meaning it\npreserves traversal order",
    "start": "3172940",
    "end": "3179060"
  },
  {
    "text": "and we can maintain\nall the augmentations. So now, if I copy over these\nlabels-- the height labels--",
    "start": "3179060",
    "end": "3184339"
  },
  {
    "text": "I have k minus 1. I have, for these two guys,\nk minus 1 or k minus 2. The biggest one is k minus 1.",
    "start": "3184340",
    "end": "3191100"
  },
  {
    "text": "This is k minus 1. And so this will be k. This will be k.",
    "start": "3191100",
    "end": "3197450"
  },
  {
    "text": "This will be k plus 1. And lo and behold, we have\na nice, height balanced tree",
    "start": "3197450",
    "end": "3202490"
  },
  {
    "text": "in all three cases\nfor this one node. Now, this was the lowest node. Once we update\nthis one, it could",
    "start": "3202490",
    "end": "3208880"
  },
  {
    "text": "be that we changed the\nheight of the root. Before it was k plus\n2, now it's k plus 1.",
    "start": "3208880",
    "end": "3215750"
  },
  {
    "text": "Or sometimes, we keep it the\nsame, like over in this case. And so now, we have\nto check the parent.",
    "start": "3215750",
    "end": "3221150"
  },
  {
    "text": "Maybe the parent\nis out of balance. And we just keep\nwalking up the node, and also maintain all the\naugmentations as we go.",
    "start": "3221150",
    "end": "3227660"
  },
  {
    "text": "Then, we'll keep track of\nheight and subtree size if we want them, or any\nother augmentations. And after order h\noperations, we will",
    "start": "3227660",
    "end": "3234425"
  },
  {
    "text": "have restored height\nbalanced property, which means all the way through,\nh equals order log n. And so all of our operations\nnow are magically order log n.",
    "start": "3234425",
    "end": "3243250"
  },
  {
    "start": "3243250",
    "end": "3248354"
  }
]