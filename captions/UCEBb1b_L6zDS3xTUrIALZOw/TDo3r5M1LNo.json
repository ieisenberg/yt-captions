[
  {
    "text": "[SQUEAKING] [RUSTLING] [CLICKING]",
    "start": "0",
    "end": "6487"
  },
  {
    "start": "6487",
    "end": "11969"
  },
  {
    "text": "ERIK DEMAINE: All right. Welcome back to 006 and our\ndynamic programming quadruple",
    "start": "11970",
    "end": "18010"
  },
  {
    "text": "of lectures. We are over halfway through,\ninto lecture three of four.",
    "start": "18010",
    "end": "23410"
  },
  {
    "text": "Today, we're going to follow\nup on this idea of problem constraints and expansion that\nwas mentioned, especially,",
    "start": "23410",
    "end": "30310"
  },
  {
    "text": "towards the end of last lecture. We saw an example of subproblem\nexpansion by a factor of 2",
    "start": "30310",
    "end": "36910"
  },
  {
    "text": "in the two-player\ngame with coins where we wanted to have\ntwo versions of the game,",
    "start": "36910",
    "end": "43150"
  },
  {
    "text": "one where I go first and\none where you go first. So this was expanding the\nnumber of such problems by a factor of 2.",
    "start": "43150",
    "end": "48610"
  },
  {
    "text": "Today, we'll see a bunch\nmore examples of this idea, including in one setting\nwe've seen already,",
    "start": "48610",
    "end": "53620"
  },
  {
    "text": "which is Bellman-Ford,\nwhich you can think of as a dynamic program. Maybe it's a good\ntime to mention",
    "start": "53620",
    "end": "58900"
  },
  {
    "text": "that Bellman invented dynamic\nprogramming in the '50s. Same Bellman in the\nBellman-Ford algorithm.",
    "start": "58900",
    "end": "65100"
  },
  {
    "text": "This was actually an\nindependent discovery by both of them--\nand other people.",
    "start": "65100",
    "end": "71049"
  },
  {
    "text": "He invented dynamic programming,\nand then, a few years later, he applied it to solve the\nsingle-source shortest paths problem.",
    "start": "71050",
    "end": "76538"
  },
  {
    "text": "We saw them in the other order. We saw single-source\nshortest paths first, because it was a little easier. And now we're seeing the general\nframework that this fits into.",
    "start": "76538",
    "end": "84370"
  },
  {
    "text": "And so we'll see how that works. Why did Bellman call\ndynamic programming dynamic programming?",
    "start": "84370",
    "end": "89530"
  },
  {
    "text": "Mostly because it\nsounded cool, and he was trying to impress government\nagencies giving him grants.",
    "start": "89530",
    "end": "95375"
  },
  {
    "text": "I mean, how can you argue with\nsomething as cool-sounding as dynamic programming? But there is some logic to it.",
    "start": "95375",
    "end": "101050"
  },
  {
    "text": "Programming is a reference to\nan old form of this word, which means optimization. And generally, we're\ntrying to optimize things.",
    "start": "101050",
    "end": "107050"
  },
  {
    "text": "And instead of\noptimizing according to some static kind of\napproach or program,",
    "start": "107050",
    "end": "113034"
  },
  {
    "text": "we're doing it dynamically. This is a reference to the\nlocal brute force we're doing to optimize at each stage.",
    "start": "113035",
    "end": "118780"
  },
  {
    "text": "You can't tell, at\nthe top, what you're going to do in the middle. And so it's kind of-- each subproblem is\nbehaving differently.",
    "start": "118780",
    "end": "126620"
  },
  {
    "text": "And so, in that sense, dynamic. And it sounds cool. All right. Then we'll go to\nall-pairs shortest paths.",
    "start": "126620",
    "end": "132550"
  },
  {
    "text": "We'll see a new algorithm for\nthat that's not asymptotically any better, but it's\nnice and simple,",
    "start": "132550",
    "end": "138460"
  },
  {
    "text": "and another way to-- a cool way\nto see subproblem expansion. And then we'll look at a couple\nof sort of practical problems--",
    "start": "138460",
    "end": "145810"
  },
  {
    "text": "parenthesizing\narithmetic expressions and a real-world problem,\npiano and guitar fingering,",
    "start": "145810",
    "end": "150840"
  },
  {
    "text": "so assigning a fingering\nhow to play a piece. And we're going to do that\nwith our SRTBOT framework.",
    "start": "150840",
    "end": "156730"
  },
  {
    "text": "Quick recollection\nof what that is. We define subproblems. And we saw how to do\nthat for sequences.",
    "start": "156730",
    "end": "161920"
  },
  {
    "text": "We try either prefixes,\nsuffixes, or substrings. We prefer prefixes and suffixes\nbecause there's fewer of them.",
    "start": "161920",
    "end": "168490"
  },
  {
    "text": "If there's more\nthan one sequence, we take the product\nof those spaces. And then the idea we're\ngoing to stress today",
    "start": "168490",
    "end": "175090"
  },
  {
    "text": "is, we can always\nadd subproblems to make the next step easier. In particular, adding\nconstraints to subproblems,",
    "start": "175090",
    "end": "181720"
  },
  {
    "text": "in some sense, lets us remember\nthings about the subproblem that's calling us--\nor about the past,",
    "start": "181720",
    "end": "188440"
  },
  {
    "text": "is one way to think about it-- or in general, to\n\"remember state.\" Just by adding more subproblems,\nwe can remember more stuff--",
    "start": "188440",
    "end": "194860"
  },
  {
    "text": "not just what things we're\nworking on, but some context. And that's what we'll see\nlots of examples of today.",
    "start": "194860",
    "end": "201190"
  },
  {
    "text": "It will hopefully make sense\nby the end of the lecture. Then, we need to relate these\nsubproblems with the recurrence",
    "start": "201190",
    "end": "206410"
  },
  {
    "text": "relation-- actually, we usually\njust call it a relation. And the key idea here is\nto come up with a question",
    "start": "206410",
    "end": "213069"
  },
  {
    "text": "that, if you knew the\nanswer to that question, you could reduce the\nsubproblem you're",
    "start": "213070",
    "end": "220360"
  },
  {
    "text": "trying to solve to smaller\nsubproblem solutions.",
    "start": "220360",
    "end": "225940"
  },
  {
    "text": "This question is sort of\nthe fundamental aspect of-- some fundamental\naspect of a solution.",
    "start": "225940",
    "end": "231670"
  },
  {
    "text": "Typically, when you're\ndealing with suffixes, you want to ask some question\nabout the first item, s of i. When you're dealing\nwith prefixes,",
    "start": "231670",
    "end": "237970"
  },
  {
    "text": "you want to ask a\nquestion about some-- near the last item,\ns of i minus 1.",
    "start": "237970",
    "end": "243790"
  },
  {
    "text": "And for substrings, who knows? Somewhere in the middle. We'll see an example\nof that today.",
    "start": "243790",
    "end": "249920"
  },
  {
    "text": "Once you have-- oh,\nthis is a reveal. Something coming later.",
    "start": "249920",
    "end": "254950"
  },
  {
    "text": "Once you have identified\nsuch a question, the dynamic programming\napproach is, don't be smart about how\nto answer that question--",
    "start": "254950",
    "end": "261790"
  },
  {
    "text": "just locally brute force. Try all possible\nanswers to the question. For each one, recurse,\nand take the best solution",
    "start": "261790",
    "end": "269052"
  },
  {
    "text": "according to whatever metric\nyou're trying to do, typically minimization or maximization.",
    "start": "269052",
    "end": "274090"
  },
  {
    "text": "Another way to think of\nthis local brute force, which I like to\nthink in my head-- so maybe some people like\nthis, some people don't--",
    "start": "274090",
    "end": "279940"
  },
  {
    "text": "is to think about guessing\nthe answer to the question. So maybe the answer\ncould be 0, 1, or 2.",
    "start": "279940",
    "end": "287200"
  },
  {
    "text": "And my algorithm will say,\nguess which is the right answer. And I'll assume that my\nalgorithm correctly guesses",
    "start": "287200",
    "end": "294370"
  },
  {
    "text": "the answer and analyze that. So we can think of the program\nas going straight through--",
    "start": "294370",
    "end": "300880"
  },
  {
    "text": "guessing the answer\nand then recursing, and then combining\nthe solutions however. But then, at the\nend, of course, we",
    "start": "300880",
    "end": "307210"
  },
  {
    "text": "can't assume that the\nguess was correct. In fact, we have to loop\nover all of those guesses. So it's the same thing.",
    "start": "307210",
    "end": "312360"
  },
  {
    "text": "Just, if you think\nof it this way, there's less looping\nin your program. But when you analyze\nit, definitely, the loop",
    "start": "312360",
    "end": "318750"
  },
  {
    "text": "is really there. You have to pay for all\nof the possible answers. OK.",
    "start": "318750",
    "end": "323790"
  },
  {
    "text": "Then we need to make sure\nthis relation is acyclic, get a subproblem DAG. And I like to specify an\nexplicit topological order",
    "start": "323790",
    "end": "330030"
  },
  {
    "text": "to make that clear. We have base cases\nfor the relation. We have to solve\nthe original problem in terms of these\nsubproblems, and then we",
    "start": "330030",
    "end": "336040"
  },
  {
    "text": "analyze the running\ntime, usually, as the number of subproblems\ntimes the non-recursive work",
    "start": "336040",
    "end": "341610"
  },
  {
    "text": "in the relation. So recursion is free\nbecause we're multiplying by the number of subproblems.",
    "start": "341610",
    "end": "347280"
  },
  {
    "text": "You can also sum\nover the subproblems. Sometimes that gives\nyou a tighter bound. And then, of\ncourse, we also have",
    "start": "347280",
    "end": "352380"
  },
  {
    "text": "to add on the running time we\nspend in the original problem. All right. That was a quick recap.",
    "start": "352380",
    "end": "359280"
  },
  {
    "text": "Now, one problem we saw\nin this framework two lectures ago-- the\nfirst lecture was single-source shortest\npaths in a DAG,",
    "start": "359280",
    "end": "367380"
  },
  {
    "text": "which, a lot of dynamic\nprograms actually can be reduced to a\nsingle-source shortest paths in a DAG.",
    "start": "367380",
    "end": "372630"
  },
  {
    "text": "In fact, the reverse is true. Single-source shortest paths\nin a DAG can be thought of. The DAG relaxation\nalgorithm we saw",
    "start": "372630",
    "end": "378840"
  },
  {
    "text": "is essentially a dynamic program\nwhere the subproblems are delta of s, v. The relation\nof delta of s, v is the min.",
    "start": "378840",
    "end": "386490"
  },
  {
    "text": "So what are we\nthinking about here? We're guessing-- this is sort\nof a new phrase I want to add.",
    "start": "386490",
    "end": "396287"
  },
  {
    "text": "Actually, I wrote it right here. The last edge, u, v, on\na shortest s to v path.",
    "start": "396287",
    "end": "401892"
  },
  {
    "text": "That's a delta of\ns, v. The problem we're trying to solve is,\nfind shortest s to v path.",
    "start": "401892",
    "end": "407730"
  },
  {
    "text": "And it's some path, and we\ndon't know what it looks like, but some feature of the\nsolution of this path",
    "start": "407730",
    "end": "415439"
  },
  {
    "text": "we're trying to find is,\nwell, what's the last edge? It comes from some vertex here,\nunless the path is of length 0",
    "start": "415440",
    "end": "422270"
  },
  {
    "text": "and s equals v. That's\na special case dealt with in the base case. Otherwise, there's\nsome vertex u before v.",
    "start": "422270",
    "end": "428543"
  },
  {
    "text": "We don't know what\nit is, so we're going to locally brute force, or\nguess what the right answer is. So look at all\nincoming edges from u",
    "start": "428543",
    "end": "435210"
  },
  {
    "text": "to v, and for each of them,\ntake the recursive shortest path from s to u, plus the\nweight of the edge.",
    "start": "435210",
    "end": "440530"
  },
  {
    "text": "So this is the guessing or\nlocal brute force perspective. And the reason this works\nis because G is acyclic,",
    "start": "440530",
    "end": "447360"
  },
  {
    "text": "and so it has a\ntopological order. Otherwise, if the\ngraph has a cycle--",
    "start": "447360",
    "end": "452760"
  },
  {
    "text": "and that's the case we\nwant to go to next-- this recursive call from\ndelta of s, v to delta of s,",
    "start": "452760",
    "end": "458150"
  },
  {
    "text": "u will have loops in it. And so you'll never\nevaluate this recursion.",
    "start": "458150",
    "end": "463177"
  },
  {
    "text": "You'll never finish. You'll never minimalize. You'll be sad. It will take infinite time. So don't use this algorithm\nunless you have a DAG.",
    "start": "463177",
    "end": "470790"
  },
  {
    "text": "For DAG, it's great. It's linear time. So that was a little review. Now, here is a\nsingle-source shortest paths",
    "start": "470790",
    "end": "478410"
  },
  {
    "text": "in general graphs, which\nwe know as Bellman-Ford, but rephrased into\nthe SRTBOT framework.",
    "start": "478410",
    "end": "485789"
  },
  {
    "text": "So we defined this problem,\nin the Bellman-Ford lecture, delta sub k of s,\nv. Remember, this",
    "start": "485790",
    "end": "493530"
  },
  {
    "text": "was the weight of a\nshortest path from s to v that is restricted\nto use, at most, k edges.",
    "start": "493530",
    "end": "500979"
  },
  {
    "text": "This made the problem feasible. We ended up taking the\nproduct of the graph into all of these different\nsubproblems, in fact.",
    "start": "500980",
    "end": "509450"
  },
  {
    "text": "But from the perspective\nof dynamic programming, we think of this as a\nsubproblem constraint. What we really want is\nthe shortest s to v path,",
    "start": "509450",
    "end": "515890"
  },
  {
    "text": "but that's hard. So we're going to break\nit up into smaller pieces. For each k between\n0 and v, we're",
    "start": "515890",
    "end": "521867"
  },
  {
    "text": "going to say, well, let's think\nabout this problem restricted to use, at most, k edges. And for simple paths, if there\nare no negative weight cycles,",
    "start": "521868",
    "end": "529300"
  },
  {
    "text": "we only have to go\nup to v minus 1. We proved that. And we know we're--\nthen we're happy. ",
    "start": "529300",
    "end": "535820"
  },
  {
    "text": "But that's sort of the last\nthing we want to solve. So if we look down at the\noriginal problem we want,",
    "start": "535820",
    "end": "541640"
  },
  {
    "text": "it's delta sub v minus\n1 of s, v for all v. So if we could solve\nthese subproblems,",
    "start": "541640",
    "end": "548390"
  },
  {
    "text": "as we saw with\nBellman-Ford, we can solve the original\nproblem-- unless there are negative weight cycles. And we use delta sub v of s,\nv to check whether they're",
    "start": "548390",
    "end": "555891"
  },
  {
    "text": "negative weight cycles. I don't want to repeat\nthat, but that's the all in the original problem. And then we can\ntake this relation",
    "start": "555892",
    "end": "563780"
  },
  {
    "text": "that we wrote for\nDAG shortest paths and just port it over here.",
    "start": "563780",
    "end": "569100"
  },
  {
    "text": "So remember, for\na general graph, this has cycles,\nso we can't use it, because we're just referring\nto arbitrary delta of s,",
    "start": "569100",
    "end": "575250"
  },
  {
    "text": "vs, so there's no reason\nto expect no cycles there. In fact, the call graph\nis exactly the graph G,",
    "start": "575250",
    "end": "582800"
  },
  {
    "text": "so it has a cycle if\nand only if G does. But now, over here, I'm running\nexactly the same formula",
    "start": "582800",
    "end": "591050"
  },
  {
    "text": "for this min, but I\nadded a sub k here and a sub k minus 1\nhere, the observation",
    "start": "591050",
    "end": "597320"
  },
  {
    "text": "being, if I've\nalready guessed what the last edge u, v\nis for this path,",
    "start": "597320",
    "end": "602360"
  },
  {
    "text": "then if this whole thing\nhas length at most k, then this piece has\nlength at most k minus 1.",
    "start": "602360",
    "end": "611380"
  },
  {
    "text": "So I only need to solve delta\nsub k minus 1 of s, v here.",
    "start": "611380",
    "end": "617840"
  },
  {
    "text": "And so that's what I\nwrote-- sorry, of s, u. That's what I wrote here. There's one other\nthing, which is,",
    "start": "617840",
    "end": "625140"
  },
  {
    "text": "as I mentioned a\nlittle while ago, it could be that we\nuse fewer than k edges. And so let's consider\nthe case where",
    "start": "625140",
    "end": "631670"
  },
  {
    "text": "we don't follow the last edge,\nand we just add to this min the shortest path using,\nat most, k minus 1 edges.",
    "start": "631670",
    "end": "639170"
  },
  {
    "text": "That's one option for\nhaving, at most, k edges. If we wrote equality\nhere, then we",
    "start": "639170",
    "end": "644360"
  },
  {
    "text": "would remove that, like\nthe last problem section. OK, good.",
    "start": "644360",
    "end": "652110"
  },
  {
    "text": "The key observation here is\nthat this recurrence does not have cycles.",
    "start": "652110",
    "end": "657630"
  },
  {
    "text": "Just by adding this index,\nif we solve these problems in order of increasing k, all\nof the references from delta sub",
    "start": "657630",
    "end": "664620"
  },
  {
    "text": "care in terms of\ndelta k minus 1. And so this is now\nmagically acyclic. This is why Bellman-Ford worked.",
    "start": "664620",
    "end": "672180"
  },
  {
    "text": "But now, I think in\na very pleasing way, we're taking our graph acyclic. And by spreading it out\nover various copies of k",
    "start": "672180",
    "end": "678870"
  },
  {
    "text": "and referencing always\nthe smaller one, we get an acyclic graph-- acyclic relations.",
    "start": "678870",
    "end": "684600"
  },
  {
    "text": "We have base cases, like normal. And then we can analyze\nthe running time in the usual way,\nwhich is summing--",
    "start": "684600",
    "end": "691910"
  },
  {
    "text": " how much does this cost? We're going to take the cost of\ncomputing the relation, which",
    "start": "691910",
    "end": "699390"
  },
  {
    "text": "is the number of\nincoming edges to v-- that's this theta-- and then\nsome overall subproblem.",
    "start": "699390",
    "end": "706790"
  },
  {
    "text": "So sum over k and\nsum over v. Wrote it as a sum instead of a\nproduct because this thing",
    "start": "706790",
    "end": "713670"
  },
  {
    "text": "is theta E. The sum of incoming\nedges over all vertices",
    "start": "713670",
    "end": "719880"
  },
  {
    "text": "is exactly the size of\nE. And then we sum-- there's no k in this formula,\nso we just multiply by v",
    "start": "719880",
    "end": "725520"
  },
  {
    "text": "and we get v E. So our good\nfriend Bellman-Ford recast kind of the opposite way.",
    "start": "725520",
    "end": "731940"
  },
  {
    "text": "Before, we were\nusing relaxations. Now, we're just writing\nthe min explicitly. But essentially the\nsame computation, just",
    "start": "731940",
    "end": "737580"
  },
  {
    "text": "in a different order. OK, cool. Those are reviews\nof old algorithms,",
    "start": "737580",
    "end": "744400"
  },
  {
    "text": "but in this new framework\nto show how powerful it is. Let's look at another\nexample, which is our friend--",
    "start": "744400",
    "end": "755850"
  },
  {
    "text": "right here-- all-pair\nshortest paths. A few lectures ago, we\nsaw Johnson's algorithm,",
    "start": "755850",
    "end": "763410"
  },
  {
    "text": "which solves this very well. So one option we\ncould use is just",
    "start": "763410",
    "end": "771570"
  },
  {
    "text": "this same set of subproblems,\nbut for all u and v. For u and v and v--",
    "start": "771570",
    "end": "779040"
  },
  {
    "text": "that's what we\nreally care about. And then we could say k up\nto v. Something like that.",
    "start": "779040",
    "end": "785910"
  },
  {
    "text": "So this would work, but it\nwould give the same running time as running Bellman-Ford v times.",
    "start": "785910",
    "end": "791180"
  },
  {
    "text": "This is one solution\nwe know, but not the best solution we know, for\nhow to solve shortest paths. This would give v squared E,\nwhich is at most v to the 4th.",
    "start": "791180",
    "end": "804860"
  },
  {
    "text": "For dense graphs, it\nis theta v to the 4th. So this is v times v\ntimes v. But worst case",
    "start": "804860",
    "end": "811280"
  },
  {
    "text": "is v to the 4th\nwhat I would like to show you now\nis a different way to solve this problem--\nalmost identical, but gives",
    "start": "811280",
    "end": "818600"
  },
  {
    "text": "v cubed running time, which, for\ndense graphs, is really good. So we're going to reduce\nthis 4 down to a 3.",
    "start": "818600",
    "end": "825730"
  },
  {
    "text": "And this is an algorithm\ncalled Floyd-Warshall. It's definitely not\nan obvious algorithm.",
    "start": "825730",
    "end": "831150"
  },
  {
    "text": "It's a very cool idea. And it's a nice example\nof a different way-- remember, this is\nsubproblem expansion.",
    "start": "831150",
    "end": "836800"
  },
  {
    "text": "We took the problems we\ncared about multiplied by this choice of k. Here, we're going to\ndo the same thing,",
    "start": "836800",
    "end": "842080"
  },
  {
    "text": "but define it differently. We're going to define those\nsubproblems differently.",
    "start": "842080",
    "end": "847509"
  },
  {
    "text": "First, I want to\nnumber the vertices,",
    "start": "847510",
    "end": "854380"
  },
  {
    "text": "starting at 1 for convenience. So let's see, y-- and then we're going to\ndefine some subproblems, which",
    "start": "854380",
    "end": "862330"
  },
  {
    "text": "are delta-- I'll call it u, v, comma k.",
    "start": "862330",
    "end": "867615"
  },
  {
    "text": " Maybe, to avoid conflict,\nI will write a d here.",
    "start": "867615",
    "end": "877050"
  },
  {
    "text": "This is just a definition\nlocal to this algorithm. So I want the weight of\nshortest s to v path.",
    "start": "877050",
    "end": "887265"
  },
  {
    "text": " So far, just the same\nas the problem we",
    "start": "887265",
    "end": "893522"
  },
  {
    "text": "actually want to solve. This is delta of-- sorry, u, v. But I'm going to\nadd a constraint, which is,",
    "start": "893522",
    "end": "904740"
  },
  {
    "text": "using only vertices in\nu, v and 1 to up to k.",
    "start": "904740",
    "end": "919970"
  },
  {
    "text": "This is the divine inspiration\nto define subproblems this way. It's a different constraint\nthan the one we saw here,",
    "start": "919970",
    "end": "926760"
  },
  {
    "text": "which was using,\nat most, k edges. So in some sense,\nwhat's slow about",
    "start": "926760",
    "end": "932720"
  },
  {
    "text": "this algorithm is that\nwe have to loop over all of the incoming vertices.",
    "start": "932720",
    "end": "937860"
  },
  {
    "text": "This is expensive. Costs order the degree,\nwhich ends up with an E term. We're going to try to convert\nthat E term into a v term",
    "start": "937860",
    "end": "945630"
  },
  {
    "text": "by just knowing which\nvertex to come from-- which sounds impossible.",
    "start": "945630",
    "end": "951220"
  },
  {
    "text": "But it turns out, if you write\nthe subproblems this way-- so I'm naming the vertices.",
    "start": "951220",
    "end": "956860"
  },
  {
    "text": "And say, well, let me just\nfind a path that uses u, v and the vertex labeled 1.",
    "start": "956860",
    "end": "963980"
  },
  {
    "text": "There's only, like, two options. I could go straight from u to v,\nor I could go from u to 1 to v. And then, how about with 1\nand 2, and 1 and 2 and 3?",
    "start": "963980",
    "end": "971980"
  },
  {
    "text": "The same vertices. By label instead of\nby counting them.",
    "start": "971980",
    "end": "978110"
  },
  {
    "text": "Slight tweak, but it turns out\nthis speeds up the algorithm.",
    "start": "978110",
    "end": "983329"
  },
  {
    "text": "So let me first tell you how\nmany subproblems there are. ",
    "start": "983330",
    "end": "991820"
  },
  {
    "text": "This is v cubed subproblems. Two choices for u and v,\nand I have v choices for--",
    "start": "991820",
    "end": "999600"
  },
  {
    "text": "sorry, I have v choices\nfor u, v choices for v, and v choices for k, roughly.",
    "start": "999600",
    "end": "1006040"
  },
  {
    "text": "v cubed of these. But the key thing is--\nthat sounds like a lot.",
    "start": "1006040",
    "end": "1011140"
  },
  {
    "text": "But the relation\nbecomes cheaper now, because I can just\nwrite delta u--",
    "start": "1011140",
    "end": "1017740"
  },
  {
    "text": "sorry, d of u v k is the\nmin of two things, d of u,",
    "start": "1017740",
    "end": "1027429"
  },
  {
    "text": "v, k minus 1 and d of u,\nk, k minus 1, plus d of k,",
    "start": "1027430",
    "end": "1039385"
  },
  {
    "text": "v, k minus 1. It's a strange formula\nbecause we're using indices",
    "start": "1039385",
    "end": "1048420"
  },
  {
    "text": "like k for vertices also, as\nwell as u and v for vertices,",
    "start": "1048420",
    "end": "1054360"
  },
  {
    "text": "but we're also using\nk as a counter. But we can do this because\nour vertices are numbered. OK. So the idea is the following.",
    "start": "1054360",
    "end": "1060460"
  },
  {
    "text": "We have vertex u, have a\nvertex v. And we've already found the shortest path\nthat uses vertices 1",
    "start": "1060460",
    "end": "1068430"
  },
  {
    "text": "through k minus 1. That's what this quantity is.",
    "start": "1068430",
    "end": "1073510"
  },
  {
    "text": "So it could be-- and now, we're trying\nto add in this vertex k and think about, what are\nall the paths that could",
    "start": "1073510",
    "end": "1079530"
  },
  {
    "text": "go from u to v using 1 up to k? Well, it could be the\nshortest path from u to v using 1 up to k\ndoesn't use vertex k.",
    "start": "1079530",
    "end": "1086700"
  },
  {
    "text": "That's the first option. Just use vertices\n1 up to k minus 1. Maybe we don't need to use k.",
    "start": "1086700",
    "end": "1092640"
  },
  {
    "text": "Or it could be that the\npath goes through k. Well, it starts at\nu, and it goes to k,",
    "start": "1092640",
    "end": "1098340"
  },
  {
    "text": "and then it goes from\nk to v, all using-- for simple paths, if we assume\nthere are no negative weight",
    "start": "1098340",
    "end": "1104370"
  },
  {
    "text": "cycles and you have to run\nBellman-Ford to detect them-- but assuming no negative\nweight cycles, the shortest path from u to v through k must\nstart by using vertices less",
    "start": "1104370",
    "end": "1112630"
  },
  {
    "text": "than k and then use\nvertices less than k again. And that's what\nI've written here. It's from u to k using k minus\n1 up to k minus 1 labels,",
    "start": "1112630",
    "end": "1121590"
  },
  {
    "text": "and from k to v using\nlabels up to k minus 1. The cool thing here is,\nthe min only has two terms.",
    "start": "1121590",
    "end": "1127890"
  },
  {
    "text": "So this takes constant\ntime non-recursive work. So this is, k is not\non the shortest path.",
    "start": "1127890",
    "end": "1136720"
  },
  {
    "text": "And this is, k is on\nthe shortest path. ",
    "start": "1136720",
    "end": "1142520"
  },
  {
    "text": "Cool. So this is constant\nnon-recursive work. ",
    "start": "1142520",
    "end": "1149540"
  },
  {
    "text": "If we jump ahead to the running\ntime for this algorithm,",
    "start": "1149540",
    "end": "1154770"
  },
  {
    "text": "we get the number of\nsubproblems, which is v cubed,",
    "start": "1154770",
    "end": "1160130"
  },
  {
    "text": "times the amount of work per\nsubproblem, which is constant.",
    "start": "1160130",
    "end": "1166200"
  },
  {
    "text": "So that's just a\nv cubed algorithm. For dense graphs,\nthis is really good.",
    "start": "1166200",
    "end": "1173590"
  },
  {
    "text": "When E is v squared, then this\nis the same thing as v times E, so as good as Bellman-Ford.",
    "start": "1173590",
    "end": "1179830"
  },
  {
    "text": "It's not as good as\nJohnson for sparse graphs. Sparse graphs, remember--\nor, in general, with Johnson,",
    "start": "1179830",
    "end": "1187059"
  },
  {
    "text": "we got v squared log n\nplus v. And this is always",
    "start": "1187060",
    "end": "1192100"
  },
  {
    "text": "spending v cubed. But it's cool because it's\na very simple algorithm. Let's quickly write\nthe topological order.",
    "start": "1192100",
    "end": "1199929"
  },
  {
    "text": " All we need is to guarantee that\nwe solve problems in increasing",
    "start": "1199930",
    "end": "1208779"
  },
  {
    "text": "k order, because\nevery reference here is to a smaller k for\nthe third argument.",
    "start": "1208780",
    "end": "1216110"
  },
  {
    "text": "And so, for example,\nyou can just write a triply nested loop-- k equals 0, 1 up to v,\nand u and v, and v and v.",
    "start": "1216110",
    "end": "1230805"
  },
  {
    "text": "So if you wanted to write\nthis algorithm bottom-up, you just write this\ntriple four-loop and then plug in this\nrecurrence relation here.",
    "start": "1230805",
    "end": "1238870"
  },
  {
    "text": "And think of d as a\ntable, as a set mapping, instead of as a function call.",
    "start": "1238870",
    "end": "1245830"
  },
  {
    "text": "And boom, in four lines,\nyou've got your algorithm-- except you also\nneed a base case. The base case here is u, v, 0.",
    "start": "1245830",
    "end": "1257080"
  },
  {
    "text": "So I have to define\nwhat that means. But when k equals 0, the\n1 through k set is empty.",
    "start": "1257080",
    "end": "1262780"
  },
  {
    "text": "So all I'm allowed to use\nare my vertices u and v. There are three cases for this--",
    "start": "1262780",
    "end": "1268450"
  },
  {
    "text": "0 if u equals v. It's w of u, v\nif there's an edge from u to v.",
    "start": "1268450",
    "end": "1278980"
  },
  {
    "text": "And it's infinity otherwise. ",
    "start": "1278980",
    "end": "1284990"
  },
  {
    "text": "OK. But easy base case,\nconstant time for each. And then the original\nproblems we want to solve",
    "start": "1284990",
    "end": "1293419"
  },
  {
    "text": "are delta u, v, size of\nv. Because I remember the vertices 1 through size of\nv. And if k equals size of v,",
    "start": "1293420",
    "end": "1301168"
  },
  {
    "text": "that means I get to\nuse all of my vertices. So that is regular\nshortest paths. This is assuming no\nnegative weight cycles.",
    "start": "1301168",
    "end": "1308660"
  },
  {
    "text": " We already know how to\ndo negative weight cycle detection, so I'm not going\nto talk about that again.",
    "start": "1308660",
    "end": "1317690"
  },
  {
    "text": "But then, this will be my\nshortest pathway because-- yeah. I implicitly assumed here\nthat my path was simple",
    "start": "1317690",
    "end": "1324980"
  },
  {
    "text": "because I imagined that\nI only use k once-- 0 or 1 time. And that's true if there are\nno negative weight cycles.",
    "start": "1324980",
    "end": "1333530"
  },
  {
    "text": "Cool. And we already did the\ntime part of SRTBOT. So v cubed algorithm. Very simple.",
    "start": "1333530",
    "end": "1340929"
  },
  {
    "text": "Basically, five lines\nof code, and you've got all-pairs shortest paths. And if your graph is dense,\nthis is a great running time.",
    "start": "1340930",
    "end": "1348220"
  },
  {
    "text": "If your graph is not\ndense, you should use Johnson, like you will in-- or like you have implemented\nin your problem set.",
    "start": "1348220",
    "end": "1355600"
  },
  {
    "text": "Yeah. AUDIENCE: So how does\nthis this compare to just running Dijkstra's\nalgorithm a bunch of times? ERIK DEMAINE: What\nabout using Dijkstra?",
    "start": "1355600",
    "end": "1361750"
  },
  {
    "text": "Let's compute. Running Dijkstra v times is\nthe running time of Johnson.",
    "start": "1361750",
    "end": "1370840"
  },
  {
    "start": "1370840",
    "end": "1376534"
  },
  {
    "text": "Running Dijkstra\na bunch of times is great if your graph has\nonly non-negative edge weights. Then you should\njust run Dijkstra.",
    "start": "1376535",
    "end": "1383520"
  },
  {
    "text": "You get this running time. And for sparse graphs,\nthis is superior. If you have negative\nedge weights,",
    "start": "1383520",
    "end": "1388740"
  },
  {
    "text": "you should run Johnson, which\nis Bellman-Ford once and then Dijkstra three times.",
    "start": "1388740",
    "end": "1393900"
  },
  {
    "text": "And we're comparing this to\nv cubed, which we just got.",
    "start": "1393900",
    "end": "1401010"
  },
  {
    "text": "So this-- I mean,\nhow these compare depends on how v and E relate. On the one hand,\nmaybe v is theta E.",
    "start": "1401010",
    "end": "1410190"
  },
  {
    "text": "That's what I would call\na very sparse graph. And it's quite common. Then, the running time we\nget here is v squared log v--",
    "start": "1410190",
    "end": "1422280"
  },
  {
    "text": "roughly v squared. On the other hand, if we\nhave a very dense graph,",
    "start": "1422280",
    "end": "1428340"
  },
  {
    "text": "v is theta E squared-- which, for simple graphs, is\nthe most we could hope for--",
    "start": "1428340",
    "end": "1433380"
  },
  {
    "text": "then this running\ntime is v cubed.",
    "start": "1433380",
    "end": "1440630"
  },
  {
    "text": "If you know the v\nis near E squared, then this is giving you v\ncubed anyway, from the vE term.",
    "start": "1440630",
    "end": "1446090"
  },
  {
    "text": "So why not just\nuse this algorithm? And often, you know, a\npriori, whether your graph is very sparse or very dense\nor somewhere in between.",
    "start": "1446090",
    "end": "1452168"
  },
  {
    "text": "If it's somewhere\nin between, you should still use\nJohnson's algorithm, because you're going to get\nthe benefit from sparsity",
    "start": "1452168",
    "end": "1457610"
  },
  {
    "text": "and only have to pay this\nvE instead of the v cubed. But if you know ahead of\ntime, constant fraction",
    "start": "1457610",
    "end": "1463280"
  },
  {
    "text": "of the edges are\nthere, then just use-- or you have a small enough\ngraph that you don't care,",
    "start": "1463280",
    "end": "1469040"
  },
  {
    "text": "just Floyd-Warshall because\nit's simple and fast. Good question.",
    "start": "1469040",
    "end": "1475539"
  },
  {
    "text": "Any other questions? This is an example of\nsubproblem expansion-- a very non-intuitive\none, where we use",
    "start": "1475540",
    "end": "1482909"
  },
  {
    "text": "some prefix of the vertices. But notice, it's\nprefixes again-- a number of the\nvertices from 1 up to v.",
    "start": "1482910",
    "end": "1488790"
  },
  {
    "text": "And I took a prefix\nof those vertices. So I just solved the problem\nusing prefix vertices 1",
    "start": "1488790",
    "end": "1493950"
  },
  {
    "text": "through k. So it's actually\na familiar idea. If all you had seen are all\ndynamic programming examples",
    "start": "1493950",
    "end": "1500010"
  },
  {
    "text": "of prefixes, suffixes,\nsubstrings, actually, it's pretty natural way\nto solve shortest paths-- maybe even more\nnatural than this.",
    "start": "1500010",
    "end": "1508610"
  },
  {
    "text": "Anyway, all right. Enough shortest paths.",
    "start": "1508610",
    "end": "1513760"
  },
  {
    "text": "Let's solve two\nmore problems that are more in our\nstandard wheelhouse that",
    "start": "1513760",
    "end": "1519060"
  },
  {
    "text": "will involve sequences\nof inputs, not graphs. First one is arithmetic\nparenthesization.",
    "start": "1519060",
    "end": "1526610"
  },
  {
    "text": "First, let me\ndefine this problem. ",
    "start": "1526610",
    "end": "1548700"
  },
  {
    "text": "OK. We are given a formula\nwith, say, plus and times.",
    "start": "1548700",
    "end": "1554630"
  },
  {
    "text": "Let me give you an\nactual example-- 7 plus 4 times 3 plus 5.",
    "start": "1554630",
    "end": "1564365"
  },
  {
    "text": " Now, when you read this, because\nyou've been well-trained,",
    "start": "1564365",
    "end": "1570910"
  },
  {
    "text": "you think, OK, I'm going\nto multiply 4 and 3 first because that has a\nhigher precedence, and then I'll add\nthe results up.",
    "start": "1570910",
    "end": "1576970"
  },
  {
    "text": "But what I'm going to let you do\nis parenthesize this expression however you want. For example, you can add\nparentheses here and here.",
    "start": "1576970",
    "end": "1584080"
  },
  {
    "text": "You must make a balanced\nparenthesis expression, a valid way to pair up-- or not just pair\nup, but a valid way",
    "start": "1584080",
    "end": "1590710"
  },
  {
    "text": "to evaluate this expression. Any order you want. I could be inconsistent. I could, for example, do this\nsum, and then do this product,",
    "start": "1590710",
    "end": "1600100"
  },
  {
    "text": "and then do this sum. But some kind of\nexpression tree over this.",
    "start": "1600100",
    "end": "1606799"
  },
  {
    "text": "And each one evaluates\nto something. This is 11 and this is\n8, and so this is 88.",
    "start": "1606800",
    "end": "1614540"
  },
  {
    "text": "And my goal is to\nmaximize that computation. And I claim that this\nis the way to maximize",
    "start": "1614540",
    "end": "1619880"
  },
  {
    "text": "that particular example. Let me write it in general,\nand get my notation",
    "start": "1619880",
    "end": "1627050"
  },
  {
    "text": "to match my notes. Given a formula a 0,\nstar 1, a 1, star 2, a 2,",
    "start": "1627050",
    "end": "1643540"
  },
  {
    "text": "and so on up to\nstar n minus 1, a n",
    "start": "1643540",
    "end": "1648820"
  },
  {
    "text": "minus 1, where each a\ni is an integer, as we",
    "start": "1648820",
    "end": "1657320"
  },
  {
    "text": "like in this class, and each\nstar i is either plus or times.",
    "start": "1657320",
    "end": "1665590"
  },
  {
    "text": "OK so I'm using star\nas a generic operator. I chose star because it is\nthe superposition of star",
    "start": "1665590",
    "end": "1671110"
  },
  {
    "text": "on top of a times symbol. So it's clear.",
    "start": "1671110",
    "end": "1676240"
  },
  {
    "text": "So you're given some formula,\nany mixture of plus and times that you like,\ninvolving n integers.",
    "start": "1676240",
    "end": "1682820"
  },
  {
    "text": "And your goal is to\nplace parentheses",
    "start": "1682820",
    "end": "1688639"
  },
  {
    "text": "to maximize the result. So you\ncan try all of the combinations",
    "start": "1688640",
    "end": "1696380"
  },
  {
    "text": "here. If I, for example, take the\nproduct of 4 times 3, I get 12. If I do that first, I get 12.",
    "start": "1696380",
    "end": "1702890"
  },
  {
    "text": "Then if I add 5 and 7, I get\n24, which is less than 88.",
    "start": "1702890",
    "end": "1709250"
  },
  {
    "text": "And I check them\nall, and this one is the maximum for that example.",
    "start": "1709250",
    "end": "1715610"
  },
  {
    "text": "Interesting problem. It's a bit of a toy\nproblem, but it's",
    "start": "1715610",
    "end": "1720860"
  },
  {
    "text": "motivated by lots of\nactual problems, which I won't go into here.",
    "start": "1720860",
    "end": "1726630"
  },
  {
    "text": " To apply this framework, we need\nto identify some subproblems.",
    "start": "1726630",
    "end": "1734870"
  },
  {
    "text": "This is a sequence problem. We're given a\nsequence of symbols. And so the natural thing is\nto try prefixes, suffixes,",
    "start": "1734870",
    "end": "1742049"
  },
  {
    "text": "and substrings. I'm going to jump ahead and\nthink about the relation first. I want to identify some\nquestion about a subproblem",
    "start": "1742050",
    "end": "1749390"
  },
  {
    "text": "or its solution\nthat would let me reduce to smaller subproblems. This is a little trickier. This is very different.",
    "start": "1749390",
    "end": "1755220"
  },
  {
    "text": "We're not always doing something\non the left or on the right, or we can't assume there's\nsomething happening on the left, because maybe we\ntake a product in the middle",
    "start": "1755220",
    "end": "1762740"
  },
  {
    "text": "first. If I take a product\nin the middle first, then I have some result here,\nbut I still have three things.",
    "start": "1762740",
    "end": "1768658"
  },
  {
    "text": "I have the thing to the left,\nI have the thing in the middle, and I have the\nthing on the right. It turns out to be very\nmessy to think about what",
    "start": "1768658",
    "end": "1774632"
  },
  {
    "text": "the first operation is. Because we can think\nof this as a tree,",
    "start": "1774632",
    "end": "1780950"
  },
  {
    "text": "where we take a product here-- we take a sum of 7 and\n4 and 3 and 5 over here",
    "start": "1780950",
    "end": "1791150"
  },
  {
    "text": "and then take the\nproduct at the root. But I don't know what\nthe tree is, right? I only know these numbers\nand these operators,",
    "start": "1791150",
    "end": "1796820"
  },
  {
    "text": "but I don't know how\nto organize this tree. The idea is, if you\nthink of this tree,",
    "start": "1796820",
    "end": "1802220"
  },
  {
    "text": "what is the one thing\nthat's easiest to identify? It's the root. The root corresponds\nto the last operation",
    "start": "1802220",
    "end": "1809120"
  },
  {
    "text": "I do in this computation. The last thing I did\nwas take a product. And that's a lot easier, because\nif I guess who is at the root--",
    "start": "1809120",
    "end": "1817070"
  },
  {
    "text": "which operator is at the root-- that naturally decomposes\ninto the left subtree and the right subtree.",
    "start": "1817070",
    "end": "1822500"
  },
  {
    "text": "And those will\nalways be substrings. We kind of know this.",
    "start": "1822500",
    "end": "1828110"
  },
  {
    "text": "This node corresponds\nto everything left of this operator, and\nthis substring or this subtree",
    "start": "1828110",
    "end": "1837440"
  },
  {
    "text": "corresponds to everything to\nthe right of the operator. So this is our idea, is we're\ngoing to guess which operation,",
    "start": "1837440",
    "end": "1851690"
  },
  {
    "text": "star i, is evaluated last-- ",
    "start": "1851690",
    "end": "1859950"
  },
  {
    "text": "or, in other words, at the root. So this is the question.",
    "start": "1859950",
    "end": "1864990"
  },
  {
    "text": "It has n possible answers-- I guess, actually, n\nminus 1 from operator 1,",
    "start": "1864990",
    "end": "1870720"
  },
  {
    "text": "operator n minus 1. And so we'll just brute\nforce all of those choices.",
    "start": "1870720",
    "end": "1878630"
  },
  {
    "text": "I wanted to start here because-- to realize that if,\nI choose some star",
    "start": "1878630",
    "end": "1883700"
  },
  {
    "text": "i in the middle, which\nmight be the right thing, like in this example. Star i is the middle one--",
    "start": "1883700",
    "end": "1889850"
  },
  {
    "text": "middle operator. I naturally decompose\ninto everything to the left of that\noperator and everything to the right of that operator.",
    "start": "1889850",
    "end": "1896120"
  },
  {
    "text": "This is a prefix. This is a suffix. So you might think, oh, my\nsubproblems are all prefixes",
    "start": "1896120",
    "end": "1903520"
  },
  {
    "text": "and all suffixes. But that would be\nwrong, because if you have a bunch of operators--",
    "start": "1903520",
    "end": "1909610"
  },
  {
    "text": "and say you choose\nthis one to be last.  So I have a prefix\nhere and a suffix here.",
    "start": "1909610",
    "end": "1916770"
  },
  {
    "text": "And then there will be some-- within this suffix, I'll\nchoose some operator to be the root of that\none, and I have a prefix",
    "start": "1916770",
    "end": "1924490"
  },
  {
    "text": "and a suffix of this suffix. But in particular, I\nwill have to evaluate this subproblem, which\nis a prefix of a suffix--",
    "start": "1924490",
    "end": "1931320"
  },
  {
    "text": "in other words, a substring. So never use a mixture\nof prefixes and suffixes. If you need both, you\nprobably need all substrings.",
    "start": "1931320",
    "end": "1940320"
  },
  {
    "text": "So our subproblems are\ngoing to be substrings.",
    "start": "1940320",
    "end": "1950605"
  },
  {
    "start": "1950605",
    "end": "1956429"
  },
  {
    "text": "OK. I'm not going to write\nthe subproblems quite yet, because there's\nanother idea we need.",
    "start": "1956430",
    "end": "1961779"
  },
  {
    "text": "So what do I need to\ndo with the substring? I'm going to guess\nthe middle operator",
    "start": "1961780",
    "end": "1967700"
  },
  {
    "text": "and then evaluate\nthe left substring, evaluate the right substring. What am I trying to do\nwith those substring? I guess I'm trying to\nsolve this problem, which",
    "start": "1967700",
    "end": "1975130"
  },
  {
    "text": "is, place parentheses in\norder to maximize the result, and then return\nwhat the result is.",
    "start": "1975130",
    "end": "1981440"
  },
  {
    "text": "And I can use paren\npointers to reconstruct what the parentheses actually are. ",
    "start": "1981440",
    "end": "1990200"
  },
  {
    "text": "Once I guess what\nthe last operator is, it enough to maximize\nthe part to the right and maximize the\npart to the left?",
    "start": "1990200",
    "end": "1996970"
  },
  {
    "text": "Will that always maximize\nmy sum or product according to what\nthis operator is?",
    "start": "1996970",
    "end": "2002560"
  },
  {
    "text": "And if you think\nabout it for a while. Yeah. If I want to maximize the sum,\nI should maximize the two parts.",
    "start": "2002560",
    "end": "2008920"
  },
  {
    "text": "And if I want to\nmaximize a product, I should maximize the two parts. That seems right. Except, I didn't say that\nmy integers are positive.",
    "start": "2008920",
    "end": "2017740"
  },
  {
    "text": "That's true if your\nintegers are positive. But to make this problem\nmore interesting, we're going to allow the\nintegers to be negative.",
    "start": "2017740",
    "end": "2025240"
  },
  {
    "text": "For example, 7 plus minus\n4 times 3 plus minus 5.",
    "start": "2025240",
    "end": "2033670"
  },
  {
    "text": "So I just added a\ncouple of minuses to a couple of the numbers here.",
    "start": "2033670",
    "end": "2040740"
  },
  {
    "text": "Then it's no longer best\nto pair them this way. If I pair them this\nway, like this,",
    "start": "2040740",
    "end": "2046110"
  },
  {
    "text": "or if I add parentheses\nthis way, I get 3 here, and I get minus 2 here.",
    "start": "2046110",
    "end": "2052960"
  },
  {
    "text": "So I get-- the product\nof that is negative 6, which i probably\nnot the maximum. In fact, I can do\nbetter, I believe,",
    "start": "2052960",
    "end": "2059790"
  },
  {
    "text": "by doing the left operator last. ",
    "start": "2059790",
    "end": "2068469"
  },
  {
    "text": "So this, I claim, the\nbest parenthisization, if I remembered it correctly. This is, minus 2 times\nminus 4 is 8, plus 7 is 15.",
    "start": "2068469",
    "end": "2083544"
  },
  {
    "text": "So I got a positive\nnumber-- definitely better than the\nnegative number I got. I claim this is the best. And the key property\nhere is, when",
    "start": "2083545",
    "end": "2090138"
  },
  {
    "text": "we take a product of\ntwo negative numbers, we get a positive number. Sometimes, you actually\nwant to make things small,",
    "start": "2090139",
    "end": "2096359"
  },
  {
    "text": "because small might\nmean very negative. You take two very big\nnegative numbers--",
    "start": "2096360",
    "end": "2101460"
  },
  {
    "text": "very small negative\nnumbers, in other words. You take their product, you get\na very big product, positively,",
    "start": "2101460",
    "end": "2107490"
  },
  {
    "text": "because the signs cancel. OK. So this seems tricky. We want to work on\nsubstrings, but we",
    "start": "2107490",
    "end": "2112950"
  },
  {
    "text": "don't know whether we're\ntrying to maximize, or you might think,\nwell, maybe I'm trying to maximize\nthe absolute value.",
    "start": "2112950",
    "end": "2118980"
  },
  {
    "text": "But that's not good. Maybe overall, on this\nentire expression, I get negative 1 million.",
    "start": "2118980",
    "end": "2124410"
  },
  {
    "text": "And that's not what I wanted. I wanted to maximize the sum. So I still need to\nsolve the max evaluation",
    "start": "2124410",
    "end": "2132450"
  },
  {
    "text": "that I can get, the\nmax parenthesization, but I also need to solve\nthe min parenthesization.",
    "start": "2132450",
    "end": "2138660"
  },
  {
    "text": "If I can solve max and min,\nI'll know the entire range that I could get.",
    "start": "2138660",
    "end": "2143680"
  },
  {
    "text": "And I really only-- I'll care about min especially\nwhen it lets me go negative. But let's just solve, in all\ncases, the min and the max,",
    "start": "2143680",
    "end": "2152250"
  },
  {
    "text": "and then just brute\nforce the rest. That's what I'm\ngoing to write down. So that was some motivation\nand why we are going",
    "start": "2152250",
    "end": "2159760"
  },
  {
    "text": "to define subproblems this way. I'm going to define x of i,\ncomma j, comma opt to be--",
    "start": "2159760",
    "end": "2168390"
  },
  {
    "text": "opt, here, is going to\nbe either min or max.",
    "start": "2168390",
    "end": "2173400"
  },
  {
    "text": "And this is my\nsubproblem expansion. I really just care about\nmax at the very end,",
    "start": "2173400",
    "end": "2179040"
  },
  {
    "text": "but I'm going to care\nabout min along the way. And i, j is going to\nspecify my substring.",
    "start": "2179040",
    "end": "2185880"
  },
  {
    "text": "So this is going to\nbe the opt value-- opt stands for \"optimum\"\nhere, or \"optimization.\"",
    "start": "2185880",
    "end": "2194369"
  },
  {
    "text": "The opt value I can get for\nthe substring a i star plus 1,",
    "start": "2194370",
    "end": "2201780"
  },
  {
    "text": "a i plus 1, and so on to\nstar j minus 1, a j minus 1.",
    "start": "2201780",
    "end": "2211410"
  },
  {
    "text": "OK. Being careful to get my\nindices correct here. And I want 0 less than or\nequal to i, less than j,",
    "start": "2211410",
    "end": "2222359"
  },
  {
    "text": "less than equal to n. I claim and opt like this.",
    "start": "2222360",
    "end": "2228730"
  },
  {
    "text": "OK. I'm going to get the min value\nand the max value separately. Those are two\ndifferent subproblems.",
    "start": "2228730",
    "end": "2233790"
  },
  {
    "text": "This is my expansion. This is the\nconstraint I'm adding. And I'm only focusing on this\nsubstring from i inclusive",
    "start": "2233790",
    "end": "2240450"
  },
  {
    "text": "to j exclusive. OK. So I claim those are\ngood subproblems.",
    "start": "2240450",
    "end": "2247609"
  },
  {
    "text": "Let's write down a\nrecurrence relation. ",
    "start": "2247610",
    "end": "2268210"
  },
  {
    "text": "OK. Relate. ",
    "start": "2268210",
    "end": "2275840"
  },
  {
    "text": "I want to write x of\ni, j, opt on the left.",
    "start": "2275840",
    "end": "2281910"
  },
  {
    "text": "And I want to optimize-- so\nthis will be min or max-- on a set of choices.",
    "start": "2281910",
    "end": "2289720"
  },
  {
    "text": "What is my set of choices? Well, like I said,\nI want to guess what is the last\noperation evaluated.",
    "start": "2289720",
    "end": "2297070"
  },
  {
    "text": "I wrote star i here, but\nstar i is already defined, so I'm going to use star k.",
    "start": "2297070",
    "end": "2302110"
  },
  {
    "text": "So I'm going to guess which\nof my operations between i plus 1 and j minus 1 is the\nlast one, and I evaluate.",
    "start": "2302110",
    "end": "2310990"
  },
  {
    "text": "And that decomposes\neverything left of k. So that would be x of i,\ncomma k, comma something.",
    "start": "2310990",
    "end": "2322880"
  },
  {
    "text": "And then we will do\noperator star k on the part",
    "start": "2322880",
    "end": "2328059"
  },
  {
    "text": "after k, which is from\nk to j, something.",
    "start": "2328060",
    "end": "2334280"
  },
  {
    "text": "And I'm choosing between-- I think it's i less\nthan k less than j.",
    "start": "2334280",
    "end": "2341180"
  },
  {
    "text": "k is some operator in between,\nbecause I started i plus 1 and I ended j minus 1.",
    "start": "2341180",
    "end": "2346260"
  },
  {
    "text": "So those are the\npossible choices for k. I tried them all. That's my local brute force.",
    "start": "2346260",
    "end": "2352950"
  },
  {
    "text": "And then I take what I\ncan get on the left, what I can get on the right,\nand multiply or add them",
    "start": "2352950",
    "end": "2358290"
  },
  {
    "text": "according to whether the\noperator is plus or times. Now, should I maximize\nor minimize this one?",
    "start": "2358290",
    "end": "2365100"
  },
  {
    "text": "Should I maximize or\nminimize this one? I don't know. So I'm just going to do\nmore local brute force.",
    "start": "2365100",
    "end": "2373030"
  },
  {
    "text": "Well, let's just say\nopt prime for the left-- or maybe I'll call\nit opt L for the left",
    "start": "2373030",
    "end": "2379080"
  },
  {
    "text": "and opt R for the right part. And I'll just add\nthis to my four-loop.",
    "start": "2379080",
    "end": "2384240"
  },
  {
    "text": "Let's just try opt L and opt R.\nJust take all possible choices",
    "start": "2384240",
    "end": "2390960"
  },
  {
    "text": "among min and max.  Now, you could think hard--\nand for addition, for example,",
    "start": "2390960",
    "end": "2398770"
  },
  {
    "text": "if you're maximizing,\nyou really only need to maximize the two parts. And if you're minimizing,\nyou can prove you all",
    "start": "2398770",
    "end": "2404690"
  },
  {
    "text": "need to minimize the two parts. But for multiplication,\nit's messy. It could be, really,\nany of the options.",
    "start": "2404690",
    "end": "2412470"
  },
  {
    "text": "Because sometimes,\nwhen you minimize, you get a negative term. Sometimes, you don't.",
    "start": "2412470",
    "end": "2418120"
  },
  {
    "text": "And so it depends what\nyou're trying to do. You have to consider\nall the signs. But we don't need to think hard.",
    "start": "2418120",
    "end": "2424830"
  },
  {
    "text": "We can just try all options. There's only four\nchoices for opt L and opt R among min and max.",
    "start": "2424830",
    "end": "2430020"
  },
  {
    "text": "You could do min-min,\nmin-max, max-min, and max-max. So try-- it's just a\nmultiplication by 4",
    "start": "2430020",
    "end": "2435690"
  },
  {
    "text": "in this four-loop. The big cost is\nactually this one, because there are j\nminus i choices for k.",
    "start": "2435690",
    "end": "2443550"
  },
  {
    "text": "There's a constant number of\nchoices for opt L and opt R. And you need to prove\nthat this is correct. I won't do it here.",
    "start": "2443550",
    "end": "2450609"
  },
  {
    "text": "But the idea is, if you're\ntrying to minimize or maximize your sum or product,\nit's enough to know what",
    "start": "2450610",
    "end": "2458550"
  },
  {
    "text": "ranges these could come in. And the optimal\nchoice will always be an extreme in that range.",
    "start": "2458550",
    "end": "2464020"
  },
  {
    "text": "We consider all of them here. And so we get this recurrence. Now, it needs a base\ncase, and we need",
    "start": "2464020",
    "end": "2470290"
  },
  {
    "text": "to check that it's acyclic. But topological order is\njust increasing j minus i.",
    "start": "2470290",
    "end": "2479550"
  },
  {
    "text": "This is the usual order\nfor substring problems,",
    "start": "2479550",
    "end": "2485470"
  },
  {
    "text": "because this is increasing\nlength of the substring. So start with very\ntiny substrings. Here, we'll start with\nlength 1 substrings.",
    "start": "2485470",
    "end": "2491320"
  },
  {
    "text": "We just have an a, i there. So that's going to\nbe our base case. And you grow up to\nthe entire string.",
    "start": "2491320",
    "end": "2497553"
  },
  {
    "text": "And it doesn't\nmatter how we order relative to opt as long as we\nare increasing in j minus i, because i to k and\nk to j will always",
    "start": "2497553",
    "end": "2504790"
  },
  {
    "text": "be strictly smaller than i to\nj, and so this will be acyclic. The base case is x\nof i, i plus 1, opt.",
    "start": "2504790",
    "end": "2515230"
  },
  {
    "text": "This is always a i. Doesn't matter what\nopt is, because there's nothing-- there's no choice. You just have a single\nnumber in that substring,",
    "start": "2515230",
    "end": "2522520"
  },
  {
    "text": "because we're\nexclusive on i plus 1.  And then the original\nproblem we want to solve",
    "start": "2522520",
    "end": "2528970"
  },
  {
    "text": "is x of 0, n, max. You could also solve min and\nsee how small you can get it.",
    "start": "2528970",
    "end": "2536510"
  },
  {
    "text": "So if you wanted to\nmaximize the absolute value, you could solve the max\nproblem and the min problem and take the largest\nof those two options.",
    "start": "2536510",
    "end": "2545280"
  },
  {
    "text": "And how much time\ndoes this take? Well, how many\nsubproblems are there? For substring problems, we\nhave n squared subproblems.",
    "start": "2545280",
    "end": "2552060"
  },
  {
    "text": "Now, we multiply the\nnumber of subproblems by 2, but that's still n squared. So we have n\nsquared subproblems.",
    "start": "2552060",
    "end": "2558869"
  },
  {
    "text": " And how much work per\nsubproblem are we doing?",
    "start": "2558870",
    "end": "2565350"
  },
  {
    "text": "Well, as I mentioned, we're\ndoing j minus i choices for k and a constant number of\nchoices for opt L and opt R.",
    "start": "2565350",
    "end": "2572130"
  },
  {
    "text": "So this is theta j minus i,\nwhich, if I'll be sloppy, that's at most big O of n.",
    "start": "2572130",
    "end": "2578070"
  },
  {
    "text": "And it turns out to be\nthe right answer anyway. So there's a linear amount\nof non-recursive work.",
    "start": "2578070",
    "end": "2585325"
  },
  {
    "text": "In fact, it's like\na triangular number, but that's still theta n cubed.",
    "start": "2585325",
    "end": "2591365"
  },
  {
    "text": " Same running time as\nv cubed we just got.",
    "start": "2591365",
    "end": "2598819"
  },
  {
    "text": "But polynomial time. And this is pretty impressive,\nbecause we're really brute forcing all possible\nparenthesizations.",
    "start": "2598820",
    "end": "2605240"
  },
  {
    "text": "There about 4 to the\nn, exponentially many, parenthesizations\nof an expression.",
    "start": "2605240",
    "end": "2611000"
  },
  {
    "text": "But we're finding the biggest-- the one that evaluates the\nlargest value and the one that evaluates to the\nsmallest value in just n",
    "start": "2611000",
    "end": "2617510"
  },
  {
    "text": "cubed time-- polynomial. And a key here was\nsubproblem expansion,",
    "start": "2617510",
    "end": "2624130"
  },
  {
    "text": "where we, in addition to\nsolving the max problem, we also solved the min\nproblem, because sometimes, you",
    "start": "2624130",
    "end": "2630130"
  },
  {
    "text": "want to take two very\nsmall negative numbers and product them together to\nget a larger positive number.",
    "start": "2630130",
    "end": "2636430"
  },
  {
    "text": " Cool. Question?",
    "start": "2636430",
    "end": "2641975"
  },
  {
    "text": "AUDIENCE: Would\nanything go wrong if I added minus or divide? ERIK DEMAINE: So what if I had\noperators minus and divide?",
    "start": "2641975",
    "end": "2651049"
  },
  {
    "text": "It's a good question. I'm certain that minus\nshould work fine. If we do min and max,\nthis should still",
    "start": "2651050",
    "end": "2659510"
  },
  {
    "text": "evaluate the largest\nthing for division. I need to think about the cases. I would guess it\nworks, but what we",
    "start": "2659510",
    "end": "2666589"
  },
  {
    "text": "need to prove is that the\nway to maximize or minimize a division, say, given two\nnumbers in the left and right,",
    "start": "2666590",
    "end": "2676250"
  },
  {
    "text": "is that it either corresponds\nto maximizing or minimizing the thing on the left and\nthen maximizing or minimizing",
    "start": "2676250",
    "end": "2682609"
  },
  {
    "text": "the thing on the right. So as long as you have\nthis kind of-- it's not exactly monotonicity. It's just that, in order\nto compute max or min,",
    "start": "2682610",
    "end": "2688760"
  },
  {
    "text": "it suffices to know the max\nand min of the two parts.",
    "start": "2688760",
    "end": "2693950"
  },
  {
    "text": "It's like interval arithmetic. You know, interval arithmetic? I want to know, what\nare the extremes I",
    "start": "2693950",
    "end": "2698960"
  },
  {
    "text": "can get on the\noutput of a division if I'm given that a number\nis in some interval here and some interval here?",
    "start": "2698960",
    "end": "2704420"
  },
  {
    "text": "If the answer is always, use\none of the extreme endpoints here and use one of the\nextreme endpoints here, then this algorithm will work.",
    "start": "2704420",
    "end": "2710440"
  },
  {
    "text": "Otherwise, all bets are off. Cool. So if you negate--",
    "start": "2710440",
    "end": "2716210"
  },
  {
    "text": "if you put a minus here,\nthat will work fine, because it's\nnegating this range. And then it's just like sum.",
    "start": "2716210",
    "end": "2721320"
  },
  {
    "text": "But-- AUDIENCE: [INAUDIBLE] ERIK DEMAINE: Oh, a divider--\nif you're careful about 0, yeah. Actually, it doesn't\nwork, because we",
    "start": "2721320",
    "end": "2727970"
  },
  {
    "text": "care about how close this\ncan get to 0 for division. It might be enough\nto consider those.",
    "start": "2727970",
    "end": "2735170"
  },
  {
    "text": "It's like, instead of minimizing\nand-- instead of computing this",
    "start": "2735170",
    "end": "2740760"
  },
  {
    "text": "entire interval, if\nthis interval spans 0, maybe I need to know-- if 0 is here, I need\nto know how close to 0",
    "start": "2740760",
    "end": "2748350"
  },
  {
    "text": "I can get on the left\nside and how close to 0 I can get on the right side. Still just four\nquantities I need to know. I would guess, for\ndivision, that's enough.",
    "start": "2748350",
    "end": "2755072"
  },
  {
    "text": "Yeah. Nice. Solved a little problem. Then, we would be multiplying\nthe subproblem space, instead of by 2, by 4.",
    "start": "2755072",
    "end": "2761858"
  },
  {
    "text": "Hey, maybe we should\nput this on the final. No, just kidding. Now it's in lecture,\nso we can't use it.",
    "start": "2761858",
    "end": "2767310"
  },
  {
    "text": "But it's a cool set\nof problems, right? You can do a lot with\ndynamic programming.",
    "start": "2767310",
    "end": "2774060"
  },
  {
    "text": "You don't need to be that\nclever, just brute force anything that seems hard. And when it works,\nit works great.",
    "start": "2774060",
    "end": "2779880"
  },
  {
    "text": " And this class is all about\nunderstanding when it works",
    "start": "2779880",
    "end": "2785369"
  },
  {
    "text": "and when it doesn't work. Of course, we will only give\nyou problems where it works.",
    "start": "2785370",
    "end": "2791330"
  },
  {
    "text": "But it's important to\nunderstand when it doesn't work. For example, DAG shortest\npaths-- that algorithm",
    "start": "2791330",
    "end": "2796420"
  },
  {
    "text": "on a non-DAG, very bad. Infinite time. OK.",
    "start": "2796420",
    "end": "2801770"
  },
  {
    "text": "Our last example\nis piano fingering. ",
    "start": "2801770",
    "end": "2814029"
  },
  {
    "text": "Here, we're given a\nsequence of notes t 0, t 1--",
    "start": "2814030",
    "end": "2825730"
  },
  {
    "text": "t for note-- up to t n minus 1.",
    "start": "2825730",
    "end": "2831280"
  },
  {
    "text": "These are single notes.  And all of the single notes--",
    "start": "2831280",
    "end": "2838059"
  },
  {
    "text": "all of the single notes, right? And we have fingers\non our hands.",
    "start": "2838060",
    "end": "2844040"
  },
  {
    "text": "This is not like\ntwo-finger algorithm. This is the\nfive-finger algorithm.",
    "start": "2844040",
    "end": "2849830"
  },
  {
    "text": "So in general, I'm\ngoing to assume an arbitrary\nanthropomorphic object.",
    "start": "2849830",
    "end": "2858260"
  },
  {
    "text": "So this is 5 for humans-- most humans. Some humans-- I think the\nmaximum on each hand is 7.",
    "start": "2858260",
    "end": "2865569"
  },
  {
    "text": "Could be smaller. Maybe you've had an accident. I'll solve it for arbitrary F.\nAnd what we would like to do",
    "start": "2865570",
    "end": "2872560"
  },
  {
    "text": "is assign fingers to notes\nto tell our pianist which",
    "start": "2872560",
    "end": "2878530"
  },
  {
    "text": "finger to use for each note. Normally, when you're\ngiven sheet music, it just gives you a sequence\nof notes you want to play.",
    "start": "2878530",
    "end": "2884260"
  },
  {
    "text": "It doesn't tell you which\nfinger you want to play it with, unless you have some\nnice training booklets",
    "start": "2884260",
    "end": "2890980"
  },
  {
    "text": "and they have a little\nnumber on top of each. And I number them\n1, 2, 3, 4 or 5, and symmetrically,\n1, 2, 3, 4, 5.",
    "start": "2890980",
    "end": "2899530"
  },
  {
    "text": "Here's a giant piano\nfor my giant hands.",
    "start": "2899530",
    "end": "2905050"
  },
  {
    "text": "If Jason were here, he\ncould sing these notes. So maybe I play this\nwith my first finger, this with my second finger.",
    "start": "2905050",
    "end": "2910600"
  },
  {
    "text": "Let's just say\nI'm doing a scale. So I can walk. And now, I think,\nthe typical way to do a scale is to reach\nover with your first finger--",
    "start": "2910600",
    "end": "2917410"
  },
  {
    "text": "second finger, I guess, and\nthen do something like this. No? OK. Clearly, I don't know scales\nor how to play a piano.",
    "start": "2917410",
    "end": "2925420"
  },
  {
    "text": "But there's limits here. I can-- if I'm\ngoing from this note and I want to go to\nanother note over here,",
    "start": "2925420",
    "end": "2932560"
  },
  {
    "text": "OK, maybe I have a decent\nspan from first finger to fifth finger, but my\nspan for my first finger",
    "start": "2932560",
    "end": "2938090"
  },
  {
    "text": "to my second finger\nis not as big. I can't reach as far. So if I want to play this\nnote and then this note,",
    "start": "2938090",
    "end": "2943120"
  },
  {
    "text": "I would like to start here\nwith a very extreme figure on the left and then go to\nat a very extreme figure",
    "start": "2943120",
    "end": "2948940"
  },
  {
    "text": "on the right. I'm going to formalize this\nproblem pretty abstractly,",
    "start": "2948940",
    "end": "2954069"
  },
  {
    "text": "because I don't want to\nget into music performance. I'm going to say that\nthere is a metric d for,",
    "start": "2954070",
    "end": "2963760"
  },
  {
    "text": "if I'm at note t\nwith finger f, and I want to go to note\nt prime with finger f prime, then this function,\nd of t, f, t prime, f prime,",
    "start": "2963760",
    "end": "2974980"
  },
  {
    "text": "gives me the difficulty\nof doing that-- ",
    "start": "2974980",
    "end": "2982530"
  },
  {
    "text": "the difficulty of playing\nnote t with finger f",
    "start": "2982530",
    "end": "2990870"
  },
  {
    "text": "and then playing note t\nprime with finger f prime.",
    "start": "2990870",
    "end": "2998390"
  },
  {
    "text": "This w is \"with.\" So this is a\ntransition difficulty. I'm not going to worry about the\ndifficulty of the whole piece",
    "start": "2998390",
    "end": "3006063"
  },
  {
    "text": "other than saying, well,\nI've got to play this note, then I've got to play this note. And for now, just single notes. You play a single note\nwith your right hand,",
    "start": "3006063",
    "end": "3012585"
  },
  {
    "text": "then you play\nanother single note with your right hand,\nthen another single note with your right hand. Let's assume no pauses\nfor now-- no rests.",
    "start": "3012585",
    "end": "3018280"
  },
  {
    "text": " Great. So we have this difficulty\nfrom going from the ith note",
    "start": "3018280",
    "end": "3025720"
  },
  {
    "text": "to the i plus first note. And then our goal is to minimize\nthe sum of difficulties.",
    "start": "3025720",
    "end": "3032470"
  },
  {
    "text": "Minimum sum of d ti\nfi ti plus 1, plus 1.",
    "start": "3032470",
    "end": "3043390"
  },
  {
    "text": "And these-- f i's and f i plus\n1 is what we want to compute.",
    "start": "3043390",
    "end": "3048621"
  },
  {
    "text": "We don't know which\nfingers to use. We're only given\nwhich notes to play.",
    "start": "3048622",
    "end": "3053642"
  },
  {
    "text": "This is actually\na natural problem. There are lots of papers\nabout this problem. I've read a bunch of them-- obviously not super well,\nbut how to play scales.",
    "start": "3053642",
    "end": "3060920"
  },
  {
    "text": "But there are notes like-- there are constraints\nin this-- usually,",
    "start": "3060920",
    "end": "3066080"
  },
  {
    "text": "people write this metric as a\nsum of different penalty terms, if I want to\nminimize difficulty.",
    "start": "3066080",
    "end": "3072320"
  },
  {
    "text": "Difficulty is high if I\nplay a note far on the left.",
    "start": "3072320",
    "end": "3078720"
  },
  {
    "text": "So if I go from a low\nnote to a high note, that's easier to do if I\nuse a lower-numbered finger",
    "start": "3078720",
    "end": "3085891"
  },
  {
    "text": "and go to a\nhigher-numbered finger. You don't want to\ngo, like I was doing,",
    "start": "3085892",
    "end": "3091280"
  },
  {
    "text": "from a high-numbered finger\nto a low-numbered finger to play a note on the right.",
    "start": "3091280",
    "end": "3097010"
  },
  {
    "text": "That's annoying. I would like to do an\nassignment, if I can, that avoids that. So I'll just have some penalty\nof, like, 100 if that happens,",
    "start": "3097010",
    "end": "3103099"
  },
  {
    "text": "and 0 if it doesn't happen, sum\nup a bunch of terms like that. Other examples are, avoid the\nfourth and fifth fingers--",
    "start": "3103100",
    "end": "3109720"
  },
  {
    "text": "weak fingers-- or, if I'm playing a portion\nof the song that is legato,",
    "start": "3109720",
    "end": "3115369"
  },
  {
    "text": "then I don't want to\nuse the same finger to play two notes\nright after the other.",
    "start": "3115370",
    "end": "3120590"
  },
  {
    "text": "I've got to use two\ndifferent fingers for that. So you have a penalty if f i\nequals f i plus 1 and these two",
    "start": "3120590",
    "end": "3126289"
  },
  {
    "text": "notes are not the same. Then-- and we're\nin legato mode-- then we add a penalty term.",
    "start": "3126290",
    "end": "3132465"
  },
  {
    "text": "And things like that. I would prefer-- if I'm going\nfrom a very low note to a very",
    "start": "3132465",
    "end": "3137480"
  },
  {
    "text": "high note, I would like to\nuse more extreme fingers. Things like that. But we're just going to assume\nthis d function is given to us.",
    "start": "3137480",
    "end": "3145529"
  },
  {
    "text": "It's some polynomial size.",
    "start": "3145530",
    "end": "3150710"
  },
  {
    "text": "If you imagine the\nnotes on your keyboard are end notes or m notes, then\nsome polynomial and m size",
    "start": "3150710",
    "end": "3157592"
  },
  {
    "text": "to this function. ",
    "start": "3157592",
    "end": "3163430"
  },
  {
    "text": "How do we solve this problem? I'm running low on time, so\nlet me give you the idea.",
    "start": "3163430",
    "end": "3177599"
  },
  {
    "text": " And this is going to use\nsubproblem expansion.",
    "start": "3177600",
    "end": "3183810"
  },
  {
    "text": " So the subproblems are going\nto be x of i, comma f--",
    "start": "3183810",
    "end": "3192320"
  },
  {
    "text": "this is the minimum total\ndifficulty to play suffix--",
    "start": "3192320",
    "end": "3201520"
  },
  {
    "text": "because I like suffixes-- t i up to t n minus 1, starting\nwith finger f on note t i.",
    "start": "3201520",
    "end": "3223290"
  },
  {
    "text": "The obvious subproblems would\nbe without this constraint. This here is a\nproblem constraint.",
    "start": "3223290",
    "end": "3230350"
  },
  {
    "text": "And you could try to define\nthe subproblems just as, what's the best way\nto play a suffix? But I claim it's\nimportant to know",
    "start": "3230350",
    "end": "3236590"
  },
  {
    "text": "which finger we start with. So we're going to multiply\nthe number of subproblems by capital F, which is just 5.",
    "start": "3236590",
    "end": "3242320"
  },
  {
    "text": "So a very small\nsubproblem expansion. And then we're\ngoing to constrain these subproblems to\nsay, well, what if I",
    "start": "3242320",
    "end": "3247690"
  },
  {
    "text": "started with my first finger? What if I started\nwith my second finger? What if-- up to\nthe fifth finger. Try them all.",
    "start": "3247690",
    "end": "3254050"
  },
  {
    "text": "Then, it turns out, I can\nwrite a relation, which is X of i f equals the min.",
    "start": "3254050",
    "end": "3264760"
  },
  {
    "text": "What should I min over? I'll just guess this-- I'm already told what my\nfirst finger is to use--",
    "start": "3264760",
    "end": "3273369"
  },
  {
    "text": "which finger I\nshould use for t i. So what's the next\nthing that matters? Well, I guess what finger\nto use for the t i plus 1,",
    "start": "3273370",
    "end": "3280210"
  },
  {
    "text": "the very next note. What is the next finger I use? I will call that f\nprime and minimize over",
    "start": "3280210",
    "end": "3287830"
  },
  {
    "text": "f prime, between\none and capital, F of the remaining\nsuffix, starting",
    "start": "3287830",
    "end": "3295059"
  },
  {
    "text": "with f prime, plus my difficulty\nfunction from t i, comma f,",
    "start": "3295060",
    "end": "3301060"
  },
  {
    "text": "to t i plus 1, comma f prime. End of bracket.",
    "start": "3301060",
    "end": "3307300"
  },
  {
    "text": "OK. So there's kind of\na lot going on here. This is a lowercase f prime.",
    "start": "3307300",
    "end": "3315478"
  },
  {
    "text": "But actually, if\nyou think about what I would like to write\nthe recurrence on, well, I start with\nthe suffix i, I",
    "start": "3315478",
    "end": "3320767"
  },
  {
    "text": "would like to recurse\non the smaller suffix, so that's X of i plus 1. ",
    "start": "3320767",
    "end": "3327030"
  },
  {
    "text": "So here, if I know that\nI'm prioritizing my finger number for i, will\nthen I'm in order",
    "start": "3327030",
    "end": "3333450"
  },
  {
    "text": "to even call this\nfunction, I need to know what finger\nI'm using 4 plus 1. Once you decide on\nthese subproblems, it's really obvious you need to\nguess, what is the next finger,",
    "start": "3333450",
    "end": "3341549"
  },
  {
    "text": "and then recurse\non that finger-- recurse on the remaining\nsuffix of that finger.",
    "start": "3341550",
    "end": "3346620"
  },
  {
    "text": "Now, why did we need to know\nwhat these fingers were? Why not just guess what\nthe first finger is?",
    "start": "3346620",
    "end": "3354210"
  },
  {
    "text": "Well, it has to do with\nthis difficulty function. For this difficulty\nfunction, I know that I want to measure\nthe difficulty from t i",
    "start": "3354210",
    "end": "3359757"
  },
  {
    "text": "to t i plus 1. And to do that, because this\nfunction is parameterized by four things, I need to\nknow both the finger for t i",
    "start": "3359757",
    "end": "3367540"
  },
  {
    "text": "and, at the same time,\nthe finger for t i plus 1. If I remove this f, I could\nadd a min over one finger,",
    "start": "3367540",
    "end": "3374770"
  },
  {
    "text": "but I can't really add\na min over two fingers. So what this does, by\nparameterizing by f here",
    "start": "3374770",
    "end": "3380860"
  },
  {
    "text": "and writing down the optimal\nfor each starting finger f, I can-- in some sense,\nI'm remembering,",
    "start": "3380860",
    "end": "3389020"
  },
  {
    "text": "in this call, what\nfinger I started with. Because I told it, you have\nto start with finger f prime.",
    "start": "3389020",
    "end": "3395500"
  },
  {
    "text": "And so locally to X i, f,\nI know what finger f prime",
    "start": "3395500",
    "end": "3402240"
  },
  {
    "text": "is being used for t i plus 1. And also, because of the\ndefinition of X i, f, I know what finger\nI'm using for t i.",
    "start": "3402240",
    "end": "3408150"
  },
  {
    "text": "And so I get to know\nboth of these fingers. One comes out of this\nmin and the other is given to me as\nthis parameter.",
    "start": "3408150",
    "end": "3415510"
  },
  {
    "text": "And then, of course, if I\ncan solve these problems, I can solve the original problem\nby just one more min of 1",
    "start": "3415510",
    "end": "3424110"
  },
  {
    "text": "up to capital F of x 0 little f.",
    "start": "3424110",
    "end": "3430913"
  },
  {
    "text": "I don't know which\nfinger to start with, but that's just f choices. And so then, this recurrence\ngives me the overall solution.",
    "start": "3430913",
    "end": "3438440"
  },
  {
    "text": "And I'll just jump to the time. We need a base case\nand topological order.",
    "start": "3438440",
    "end": "3444800"
  },
  {
    "text": "But it is n f squared time. There are n times\nf subproblems here.",
    "start": "3444800",
    "end": "3451240"
  },
  {
    "text": "And for each one, I'm doing an\noptimization over f choices, so I get n times f squared.",
    "start": "3451240",
    "end": "3457270"
  },
  {
    "text": "It's a polynomial. And if f is a constant, this\nis actually linear time. Very fast DP.",
    "start": "3457270",
    "end": "3462279"
  },
  {
    "text": "Now, what I described\nhere is for one hand, one note at a time. But you can generalize this to\ntwo hands, each with one note.",
    "start": "3462280",
    "end": "3469230"
  },
  {
    "text": "Well, that's just ten fingers. So you could solve this\nseparately for the right hand and left hand if you know\nwhich notes are being played",
    "start": "3469230",
    "end": "3475550"
  },
  {
    "text": "with left hand and right hand. But some pieces,\nthat's not obvious.",
    "start": "3475550",
    "end": "3481040"
  },
  {
    "text": "So to make it more interesting,\nwhat if you have multiple notes at the same time? And let's say-- I think it's reasonable to say\nyou can only play up to f notes",
    "start": "3481040",
    "end": "3489310"
  },
  {
    "text": "at a time, 1 for each finger. And so you have an upper\nbound on the number of notes at a time that\nwe're playing, which is good.",
    "start": "3489310",
    "end": "3498730"
  },
  {
    "text": "Oh, I have a drawing\nof this DP, by the way, as a subproblem DAG.",
    "start": "3498730",
    "end": "3505570"
  },
  {
    "text": "This is the original\nproblem, which is, we don't know which\nfinger to start with.",
    "start": "3505570",
    "end": "3510680"
  },
  {
    "text": "But then we just have a\ncomplete bipartite graph here, where we write on each\nof these edges, what is the difficulty\nof this transition?",
    "start": "3510680",
    "end": "3518410"
  },
  {
    "text": "The y-axis here is\nwhich finger I'm using-- 1, 2, 3, 4, 5--\nand the x-axis is which suffix I'm considering.",
    "start": "3518410",
    "end": "3525160"
  },
  {
    "text": "Which note do I start on? And so you could solve this\nwith shortest paths in a DAG,",
    "start": "3525160",
    "end": "3530320"
  },
  {
    "text": "or you could just\nsolve it directly as DP, either\ntop-down or bottom-up. OK.",
    "start": "3530320",
    "end": "3536690"
  },
  {
    "text": "Jumping ahead, if you do\nmultiple notes at a time, instead of this finger choice,\nwhich just had f choices,",
    "start": "3536690",
    "end": "3544760"
  },
  {
    "text": "we have--  what do I write here?",
    "start": "3544760",
    "end": "3550980"
  },
  {
    "text": "t to the f possible\nstates, where",
    "start": "3550980",
    "end": "3559369"
  },
  {
    "text": "t is the maximum number of\nnotes that I could play at once. ",
    "start": "3559370",
    "end": "3568109"
  },
  {
    "text": "And usually, this is at\nmost f, 1 for finger. But we could generalize. And this is number of fingers.",
    "start": "3568110",
    "end": "3574455"
  },
  {
    "text": " So I could deal with all 10\nfingers of a typical human set",
    "start": "3574455",
    "end": "3582690"
  },
  {
    "text": "of arms-- hands-- and say\nthere's at most 10. And so this is 10 to the 10. It's a big constant,\nbut it's constant--",
    "start": "3582690",
    "end": "3590220"
  },
  {
    "text": "like 1 billion right? 10 billion? But then it's that times n.",
    "start": "3590220",
    "end": "3596630"
  },
  {
    "text": "And maybe that\nsquared times n will let me exhaustively enumerate\nall of the possible things",
    "start": "3596630",
    "end": "3601640"
  },
  {
    "text": "I could do be doing\nwith all of my hands. You can apply this not\nonly to piano fingering,",
    "start": "3601640",
    "end": "3608240"
  },
  {
    "text": "but also to guitar\nfingering-- also to Rock Band. Rock Band is an easy\ncase where you just have five buttons, and usually\nonly four fingers that you use.",
    "start": "3608240",
    "end": "3617385"
  },
  {
    "text": "And this doesn't\nreally make any sound, so it's not that exciting. So the case where f equals 4 you\ncan apply to optimally figure",
    "start": "3617385",
    "end": "3626390"
  },
  {
    "text": "out which finger-- once you have\na difficulty function of what transitions are easy\nand hard for Rock Band,",
    "start": "3626390",
    "end": "3633320"
  },
  {
    "text": "then you can optimally\nfigure out your fingering for Rock Band songs. With a real guitar, this\nis a little bit harder",
    "start": "3633320",
    "end": "3643700"
  },
  {
    "text": "because there are\nactually multiple ways to play the same note. For example, I can play the\nnote of this string like this.",
    "start": "3643700",
    "end": "3653990"
  },
  {
    "text": "These should both\nsound the same-- if my guitar were perfectly\ntuned, which it's not.",
    "start": "3653990",
    "end": "3660589"
  },
  {
    "text": "And that's properties\nof strings and the way these things are played. So in addition to\nwhat finger I use,",
    "start": "3660590",
    "end": "3666770"
  },
  {
    "text": "I should also decide which\nstring to play that note on. If all I'm given is sheet\nmusic, different notes to play,",
    "start": "3666770",
    "end": "3672200"
  },
  {
    "text": "another thing I\ncould guess is which string to play that note on. So for example, maybe I want\nto play my favorite song here.",
    "start": "3672200",
    "end": "3681218"
  },
  {
    "text": "[PLAYING MUSIC] AUDIENCE: [APPLAUSE]",
    "start": "3681218",
    "end": "3687600"
  },
  {
    "text": "ERIK DEMAINE: Super Mario\nBrothers, my favorite song. I could keep going, but I\nactually can't keep going. It won't be as impressive.",
    "start": "3687600",
    "end": "3694040"
  },
  {
    "text": "I don't actually know\nhow to play guitar. But there are a lot of\nchoices there, right? I started with playing this\nnote down on this string.",
    "start": "3694040",
    "end": "3705380"
  },
  {
    "text": "That's good. I could have also played\nit on this string. But that's more\nwork for my finger,",
    "start": "3705380",
    "end": "3710869"
  },
  {
    "text": "so I have a penalty\nfunction that says, well, if I play an open\nstring, that's a lot easier.",
    "start": "3710870",
    "end": "3715970"
  },
  {
    "text": "And then I had a\ntransition from here-- this note [PLAYING A NOTE]\nto this note [PLAYING A NOTE]",
    "start": "3715970",
    "end": "3721390"
  },
  {
    "text": "to this note. [PLAYING A NOTE] And if you\nfocus on my fingering here, I chose to use my index\nfinger for the first one,",
    "start": "3721390",
    "end": "3729490"
  },
  {
    "text": "because that index finger is\nalways the easiest to use, but it also gives\nme lots of room to move my pinky over to here.",
    "start": "3729490",
    "end": "3734950"
  },
  {
    "text": "And then I like to use my\nmiddle finger to come up here. You could also use\nyour index finger.",
    "start": "3734950",
    "end": "3740050"
  },
  {
    "text": "It's just a little\nbit more of a reach. So you have to define\nsome difficulty function. It might depend on how\nbig your fingers are.",
    "start": "3740050",
    "end": "3746650"
  },
  {
    "text": "But you can do that,\nand then optimize, using these algorithms,\nwhat is the best guitar fingering for a given piece--",
    "start": "3746650",
    "end": "3753790"
  },
  {
    "text": "one note a time or\nseveral notes at a time. You could even add\nin parameters like, oh, maybe I want to play a bar.",
    "start": "3753790",
    "end": "3761200"
  },
  {
    "text": "That's not a perfect bar. But this would be great\nfor my playing this note down here and this note here--",
    "start": "3761200",
    "end": "3769780"
  },
  {
    "text": "bad example. So you could do other\nthings with a guitar to make it more interesting and\ngeneralize this dynamic program",
    "start": "3769780",
    "end": "3777430"
  },
  {
    "text": "suitably. But I think this\ngives you a flavor how, with subproblem\nexpansion, I",
    "start": "3777430",
    "end": "3783700"
  },
  {
    "text": "can capture almost any aspect\nof a problem that I want. As long as the number of states\nthat I need to keep track of",
    "start": "3783700",
    "end": "3789670"
  },
  {
    "text": "is small, I can just multiply\nthe number of subproblems by that state, and I can keep\ntrack of any kind of transition",
    "start": "3789670",
    "end": "3796480"
  },
  {
    "text": "from one state to another, which\nI could also do with taking the product of a graph.",
    "start": "3796480",
    "end": "3802060"
  },
  {
    "text": "But dynamic programming gives\nyou a kind of methodical way to think about this, by\nfiguring out some property--",
    "start": "3802060",
    "end": "3808300"
  },
  {
    "text": "in this case, the state of\nhow my fingers are applied to the instrument-- and then\njust sort of brute forcing",
    "start": "3808300",
    "end": "3815770"
  },
  {
    "text": "the rest-- a very powerful framework. ",
    "start": "3815770",
    "end": "3825000"
  }
]