[
  {
    "start": "0",
    "end": "0"
  },
  {
    "text": "Here's another approach to improving the latency\nof our adder, this time focusing just on the",
    "start": "1030",
    "end": "5939"
  },
  {
    "text": "carry logic.",
    "start": "5939",
    "end": "7190"
  },
  {
    "text": "Early on in the course, we learned that by\ngoing from a chain of logic gates to a tree",
    "start": "7190",
    "end": "12089"
  },
  {
    "text": "of logic gates, we could go from a linear\nlatency to a logarithmic latency.",
    "start": "12089",
    "end": "17500"
  },
  {
    "text": "Let's try to do that here.",
    "start": "17500",
    "end": "20090"
  },
  {
    "text": "We'll start by rewriting the equations for\nthe carry-out from the full adder module.",
    "start": "20090",
    "end": "24680"
  },
  {
    "text": "The final form of the rewritten equation has\ntwo terms.",
    "start": "24680",
    "end": "28360"
  },
  {
    "text": "The G, or generate, term is true when the\ninputs will cause the module to generate a",
    "start": "28360",
    "end": "33370"
  },
  {
    "text": "carry-out right away, without having to wait\nfor the carry-in to arrive.",
    "start": "33370",
    "end": "38410"
  },
  {
    "text": "The P, or propagate, term is true if the module\nwill generate a carry-out only if there's",
    "start": "38410",
    "end": "43070"
  },
  {
    "text": "a carry-in.",
    "start": "43070",
    "end": "45569"
  },
  {
    "text": "So there only two ways to get a carry-out\nfrom the module: it's either generated by",
    "start": "45569",
    "end": "50350"
  },
  {
    "text": "the current module or the carry-in is propagated\nfrom the previous module.",
    "start": "50350",
    "end": "55329"
  },
  {
    "text": "Actually, it's usual to change the logic for\nthe P term from \"A OR B\" to \"A XOR B\".",
    "start": "55329",
    "end": "61908"
  },
  {
    "text": "This doesn't change the truth table for the\ncarry-out but will allow us to express the",
    "start": "61909",
    "end": "65950"
  },
  {
    "text": "sum output as \"P XOR carry-in\".",
    "start": "65950",
    "end": "69789"
  },
  {
    "text": "Here's the schematic for the reorganized full\nadder module.",
    "start": "69790",
    "end": "73450"
  },
  {
    "text": "The little sum-of-products circuit for the\ncarry-out can be implemented using 3 2-input",
    "start": "73450",
    "end": "78201"
  },
  {
    "text": "NAND gates, which is a bit more compact than\nthe implementation for the three product terms",
    "start": "78201",
    "end": "83130"
  },
  {
    "text": "we suggested in Lab 2.",
    "start": "83130",
    "end": "85420"
  },
  {
    "text": "Time to update your full adder circuit!",
    "start": "85420",
    "end": "88610"
  },
  {
    "start": "88000",
    "end": "88000"
  },
  {
    "text": "Now consider two adjacent adder modules in\na larger adder circuit:",
    "start": "88610",
    "end": "93030"
  },
  {
    "text": "we'll use the label H to refer to the high-order\nmodule and the label L to refer to the low-order",
    "start": "93030",
    "end": "99000"
  },
  {
    "text": "module.",
    "start": "99000",
    "end": "100070"
  },
  {
    "text": "We can use the generate and propagate information\nfrom each of the modules to develop equations",
    "start": "100070",
    "end": "104649"
  },
  {
    "text": "for the carry-out from the pair of modules\ntreated as a single block.",
    "start": "104649",
    "end": "109009"
  },
  {
    "text": "We'll generate a carry-out from the block\nwhen a carry-out is generated by the H module,",
    "start": "109009",
    "end": "114950"
  },
  {
    "text": "or when a carry-out is generated by the L\nmodule and propagated by the H module.",
    "start": "114950",
    "end": "121460"
  },
  {
    "text": "And we'll propagate the carry-in through the\nblock only if the L module propagates its",
    "start": "121460",
    "end": "126399"
  },
  {
    "text": "carry-in to the intermediate carry-out and\nH module propagates that to the final carry-out.",
    "start": "126399",
    "end": "132970"
  },
  {
    "text": "So we have two simple equations requiring\nonly a couple of logic gates to implement.",
    "start": "132970",
    "end": "139870"
  },
  {
    "text": "Let's use these equations to build a generate-propagate\n(GP) module and hook it to the H and L modules",
    "start": "139870",
    "end": "146450"
  },
  {
    "text": "as shown.",
    "start": "146450",
    "end": "147980"
  },
  {
    "text": "The G and P outputs of the GP module tell\nus under what conditions we'll get a carry-out",
    "start": "147980",
    "end": "152790"
  },
  {
    "text": "from the two individual modules treated as\na single, larger block.",
    "start": "152790",
    "end": "158610"
  },
  {
    "start": "158000",
    "end": "158000"
  },
  {
    "text": "We can use additional layers of GP modules\nto build a tree of logic that computes the",
    "start": "158610",
    "end": "163120"
  },
  {
    "text": "generate and propagate logic for adders with\nany number of inputs.",
    "start": "163120",
    "end": "168099"
  },
  {
    "text": "For an adder with N inputs, the tree will\ncontain a total of N-1 GP modules and have",
    "start": "168099",
    "end": "173780"
  },
  {
    "text": "a latency that's order log(N).",
    "start": "173780",
    "end": "176909"
  },
  {
    "text": "In the next step, we'll see how to use the\ngenerate and propagate information to quickly",
    "start": "176909",
    "end": "180659"
  },
  {
    "text": "compute the carry-in for each of the original\nfull adder modules.",
    "start": "180659",
    "end": "186569"
  },
  {
    "start": "186000",
    "end": "186000"
  },
  {
    "text": "Once we're given the carry-in C_0 for the\nlow-order bit, we can hierarchically compute",
    "start": "186569",
    "end": "191379"
  },
  {
    "text": "the carry-in for each full adder module.",
    "start": "191379",
    "end": "194819"
  },
  {
    "text": "Given the carry-in to a block of adders, we\nsimply pass it along as the carry-in to the",
    "start": "194819",
    "end": "199410"
  },
  {
    "text": "low-half of the block.",
    "start": "199410",
    "end": "201200"
  },
  {
    "text": "The carry-in for the high-half of the block\nis computed the using the generate and propagate",
    "start": "201200",
    "end": "205239"
  },
  {
    "text": "information from the low-half of the block.",
    "start": "205239",
    "end": "208280"
  },
  {
    "text": "We can use these equations to build a C module\nand arrange the C modules in a tree as shown",
    "start": "208280",
    "end": "213900"
  },
  {
    "text": "to use the C_0 carry-in to hierarchically\ncompute the carry-in to each layer of successively",
    "start": "213900",
    "end": "220140"
  },
  {
    "text": "smaller blocks, until we finally reach the\nfull adder modules.",
    "start": "220140",
    "end": "224980"
  },
  {
    "text": "For example, these equations show how C4 is\ncomputed from C0, and C6 is computed from",
    "start": "224980",
    "end": "231180"
  },
  {
    "text": "C4.",
    "start": "231180",
    "end": "233280"
  },
  {
    "text": "Again the total propagation delay from the\narrival of the C_0 input to the carry-ins",
    "start": "233280",
    "end": "238269"
  },
  {
    "text": "for each full adder is order log(N).",
    "start": "238269",
    "end": "242379"
  },
  {
    "text": "Notice that the G_L and P_L inputs to a particular\nC module are the same as two of the inputs",
    "start": "242379",
    "end": "249209"
  },
  {
    "text": "to the GP module in the same position in the\nGP tree.",
    "start": "249209",
    "end": "253110"
  },
  {
    "text": "We can combine the GP module and C module\nto form a single carry-lookahead module that",
    "start": "253110",
    "end": "258669"
  },
  {
    "text": "passes generate and propagate information\nup the tree and carry-in information down",
    "start": "258669",
    "end": "263940"
  },
  {
    "text": "the tree.",
    "start": "263940",
    "end": "265130"
  },
  {
    "text": "The schematic at the top shows how to wire\nup the tree of carry-lookahead modules.",
    "start": "265130",
    "end": "270430"
  },
  {
    "text": "And now we get to the payoff for all this\nhard work!",
    "start": "270430",
    "end": "273970"
  },
  {
    "start": "271000",
    "end": "271000"
  },
  {
    "text": "The combined propagation delay to hierarchically\ncompute the generate and propagate information",
    "start": "273970",
    "end": "279060"
  },
  {
    "text": "on the way up and the carry-in information\non the way down is order log(N),",
    "start": "279060",
    "end": "285370"
  },
  {
    "text": "which is then the latency for the entire adder\nsince computing the sum outputs only takes",
    "start": "285370",
    "end": "290690"
  },
  {
    "text": "one additional XOR delay.",
    "start": "290690",
    "end": "293680"
  },
  {
    "text": "This is a considerable improvement over the\norder N latency of the ripple-carry adder.",
    "start": "293680",
    "end": "299020"
  },
  {
    "text": "A final design note: we no longer need the\ncarry-out circuitry in the full adder module,",
    "start": "299020",
    "end": "304638"
  },
  {
    "text": "so it can be removed.",
    "start": "304639",
    "end": "307169"
  },
  {
    "text": "Variations on this generate-propagate strategy\nform the basis for the fastest-known adder",
    "start": "307169",
    "end": "312740"
  },
  {
    "text": "circuits.",
    "start": "312740",
    "end": "313870"
  },
  {
    "text": "If you'd like to learn more, look up \"Kogge-Stone\nadders\" on Wikipedia.",
    "start": "313870",
    "end": "318000"
  }
]