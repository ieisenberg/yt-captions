[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: Welcome to 6.851\nAdvanced Data Structures.",
    "start": "18450",
    "end": "25279"
  },
  {
    "text": "I am Erik Demaine. You can call me Erik. We have two TAs, Tom\nMorgan and Justin Zhang.",
    "start": "25280",
    "end": "31600"
  },
  {
    "text": "Tom's back there. Justin is late. And this class is\nabout all kinds",
    "start": "31600",
    "end": "38600"
  },
  {
    "text": "of very cool data structures. You should have already\nseen basic data structures like balance binary\nsearch trees and things",
    "start": "38600",
    "end": "45200"
  },
  {
    "text": "like that, log n\ntime to do wherever you want in one dimension. And here we're going to turn\nall those data structures",
    "start": "45200",
    "end": "52310"
  },
  {
    "text": "on their head and\nconsider them in all sorts of different models and\nadditional cool problems. Today we're going to talk about\ntime travel or temporal data",
    "start": "52310",
    "end": "59630"
  },
  {
    "text": "structures, where\nyou're manipulating time as any good time\ntraveler should.",
    "start": "59630",
    "end": "65510"
  },
  {
    "text": "Then we'll do geometry where\nwe have higher dimensional data, more than one dimension. Then we'll look at\na problem called",
    "start": "65510",
    "end": "71120"
  },
  {
    "text": "dynamic optimality, which is,\nis there one best binary search tree that rules them all?",
    "start": "71120",
    "end": "76642"
  },
  {
    "text": "Then we'll look at something\ncalled memory hierarchy, which is a way to model more realistic\ncomputers which have cache",
    "start": "76642",
    "end": "82580"
  },
  {
    "text": "and then more cache\nand then main memory and then dish and all\nthese different levels. How do you optimize for that?",
    "start": "82580",
    "end": "88579"
  },
  {
    "text": "Hashing is probably the most\nfamous, and most popular, most used data structure\nin computer science.",
    "start": "88580",
    "end": "93670"
  },
  {
    "text": "We'll do a little bit on that. Integers, when you know that\nyour data is integers and not",
    "start": "93670",
    "end": "99049"
  },
  {
    "text": "just arbitrary black boxes that\nyou can compare or do whatever, you can do a lot\nbetter with integers. You usually beat log n time.",
    "start": "99050",
    "end": "105140"
  },
  {
    "text": "Often you can get constant time. For example, if you want\nto do priority queues, you can do square\nroot log log n time.",
    "start": "105140",
    "end": "111799"
  },
  {
    "text": "That's the best\nknown randomized. Dynamic graphs, you have\na graph you want to store,",
    "start": "111800",
    "end": "118010"
  },
  {
    "text": "and the edges are being added\nand maybe deleted, like you're representing a social network. And people are friending\nand de-friending.",
    "start": "118010",
    "end": "124040"
  },
  {
    "text": "You want to maintain some\ninteresting information about that graph. Strings, you have\na piece of text,",
    "start": "124040",
    "end": "130669"
  },
  {
    "text": "such as the entire\nworldwide web. And you want to search\nfor a substring. How do you do that efficiently? It's sort of the Google problem.",
    "start": "130669",
    "end": "137420"
  },
  {
    "text": "Or you searching through\nDNA for patterns, whenever. And finally succinct\ndata structures, which is all about\ntaking what we normally",
    "start": "137420",
    "end": "144170"
  },
  {
    "text": "consider optimal\nspace or n space and reducing it down to the very\nbare minimum of bits of space.",
    "start": "144170",
    "end": "150440"
  },
  {
    "text": "Usually if you want\nto store something where there's 2 to\nthe n possibilities, you want to get away\nwith n bits of space,",
    "start": "150440",
    "end": "156620"
  },
  {
    "text": "maybe plus square root of\nn or something very tiny. So that's the sync\ndata structures.",
    "start": "156620",
    "end": "162740"
  },
  {
    "text": "So that's an overview\nof the entire class. And these are sort of the\nsections we'll be following.",
    "start": "162740",
    "end": "167969"
  },
  {
    "text": "Let me give you a quick\nadministrative overview of what we're doing.",
    "start": "167970",
    "end": "174349"
  },
  {
    "text": "Requirements for the class-- I guess, first,\nattending lecture. Obviously if you\ndon't attend lecture,",
    "start": "174350",
    "end": "179900"
  },
  {
    "text": "there'll be videos online. So that's resolvable. But let me know if you're\nnot going to make it.",
    "start": "179900",
    "end": "185000"
  },
  {
    "text": "We're going to have problems\nsets roughly every week. If you're taking the\nclass for credit, they have a very simple rule\nof one page in, one page out.",
    "start": "185000",
    "end": "192500"
  },
  {
    "text": "This is more constraint on\nus to write problems that have easy or short answers. You probably need\nto think about them",
    "start": "192500",
    "end": "198260"
  },
  {
    "text": "a little bit before they're\ntransparent, but then easy to write up. And then scribing lectures--\nso we have a scribe for today,",
    "start": "198260",
    "end": "206430"
  },
  {
    "text": "I hope. Here? Yes, good. So most of the\nlectures have already",
    "start": "206430",
    "end": "212209"
  },
  {
    "text": "been scribed in some\nversion, and your goal is to revise that scribe\nnotes that if you don't like",
    "start": "212210",
    "end": "218420"
  },
  {
    "text": "handwritten notes, which\nare also online, then easier for people to read.",
    "start": "218420",
    "end": "224320"
  },
  {
    "text": "Let's see. Listeners welcome. We're going to have an\nopen problem session. I really like open problems. I really like solving\nopen problems.",
    "start": "224320",
    "end": "230730"
  },
  {
    "text": "So we've done this every time\nthis class has been offered. So if you're interested in\nalso solving open problems,",
    "start": "230730",
    "end": "235790"
  },
  {
    "text": "it's optional. I will organize-- in\na couple of weeks, we'll have a weekly\nopen problem session",
    "start": "235790",
    "end": "243110"
  },
  {
    "text": "and try to solve\nall the things that push the frontier of\nadvanced data structures.",
    "start": "243110",
    "end": "249080"
  },
  {
    "text": "So in classes, we'll see\nthe state of the art. And then we'll change the state\nof the art in those sessions.",
    "start": "249080",
    "end": "255670"
  },
  {
    "text": "I think that's it. Any questions about\nthe class before we get into the fun stuff? ",
    "start": "255671",
    "end": "262979"
  },
  {
    "text": "All right. Let's do some time traveling. Before I get to time\ntraveling, though, I",
    "start": "262980",
    "end": "268850"
  },
  {
    "text": "need to define our\nmodel of computation. A theme in this class is that\nthe model of computation you're",
    "start": "268850",
    "end": "275716"
  },
  {
    "text": "working with matters. Models matter. And there's lots of different\nmodels of computation. We'll see a few of the\nmain ones in this class.",
    "start": "275716",
    "end": "285889"
  },
  {
    "text": "And the starting\npoint, and the one we'll be using throughout today,\nis called a pointer machine.",
    "start": "285890",
    "end": "293099"
  },
  {
    "text": "It's an old one from the '80s.  And it corresponds to\nwhat you might think about",
    "start": "293100",
    "end": "299240"
  },
  {
    "text": "if you've done a lot of\nobject-oriented programming, and before that,\nstructure-oriented programming,",
    "start": "299240",
    "end": "304949"
  },
  {
    "text": "I guess. So you have a bunch of nodes. They have some fields in them,\na constant number of fields.",
    "start": "304950",
    "end": "313970"
  },
  {
    "text": "You can think of these\nas objects or strucs in c It used to be records\nback in Pascal days,",
    "start": "313970",
    "end": "320270"
  },
  {
    "text": "so a lot of the papers\ncall them records. You could just have a\nconstant number of fields. You could think of\nthose numbered, labeled.",
    "start": "320270",
    "end": "325300"
  },
  {
    "text": "It doesn't really matter\nbecause there's only a constant number of them. Each of the fields could be\na pointer to another node,",
    "start": "325300",
    "end": "332240"
  },
  {
    "text": "could be a null pointer, or\ncould have some data in it. So I'll just assume that\nall my data is integers.",
    "start": "332240",
    "end": "337759"
  },
  {
    "start": "337760",
    "end": "343130"
  },
  {
    "text": "You can have a\npointer to yourself. You can have a pointer over\nhere, whatever you want.",
    "start": "343130",
    "end": "348440"
  },
  {
    "text": "A pointer machine would\nlook something like this. In any moment, this is the\nstate of the pointer machine.",
    "start": "348440",
    "end": "355040"
  },
  {
    "text": "So you think this as the memory\nof your computer storing. And then you have\nsome operations",
    "start": "355040",
    "end": "362210"
  },
  {
    "text": "that you're allowed to do. That's the computation\npart of the model.",
    "start": "362210",
    "end": "367800"
  },
  {
    "text": "You can think of this\nas the memory model. What you're allowed to\ndo are create nodes.",
    "start": "367800",
    "end": "373100"
  },
  {
    "text": "You can say something\nlike, x equals new node. ",
    "start": "373100",
    "end": "379909"
  },
  {
    "text": "You can, I don't\nknow, look at fields.",
    "start": "379910",
    "end": "384990"
  },
  {
    "text": "You can do x equals y.field. You can set fields,\nx.field equals y.",
    "start": "384990",
    "end": "393560"
  },
  {
    "text": "You can compute on these\ndata, so you can add 5 and 7, do things like that.",
    "start": "393560",
    "end": "399110"
  },
  {
    "text": "I'm not going to worry about-- I'll just write et cetera. This is more a model\nabout how everything's",
    "start": "399110",
    "end": "405680"
  },
  {
    "text": "organized in memory, not so\nmuch about what you're allowed to do to the data items. In this lecture, it\nwon't matter what",
    "start": "405680",
    "end": "410870"
  },
  {
    "text": "you're doing to the data items. We never touch them. We just copy them around.",
    "start": "410870",
    "end": "416840"
  },
  {
    "text": "So am I missing anything? Probably. I guess you could destroy\nnodes if you felt like it.",
    "start": "416840",
    "end": "423950"
  },
  {
    "text": "But we won't have\nto today, because we don't want to\nthrow anything away when you're time traveling.",
    "start": "423950",
    "end": "429200"
  },
  {
    "text": "It's too dangerous.  And then the one catch\nhere is, what are x and y?",
    "start": "429200",
    "end": "438569"
  },
  {
    "text": "There's going to be one\nnode in this data structure or in your memory\ncalled the root node.",
    "start": "438570",
    "end": "444184"
  },
  {
    "text": "And you could think of that\nas that's the thing you always have in your head. This is like your\ncache, if you will.",
    "start": "444184",
    "end": "449389"
  },
  {
    "text": "It's just got a constant\nnumber of things, just like any other node. And x and y are\nfields of the root.",
    "start": "449390",
    "end": "457490"
  },
  {
    "text": " So that sort of\nties things down.",
    "start": "457490",
    "end": "462530"
  },
  {
    "text": "You're always working\nrelative to the root. But you can look at the data,\nbasically follow this pointer,",
    "start": "462530",
    "end": "470030"
  },
  {
    "text": "by looking at the field. You could set one\nof these pointers--",
    "start": "470030",
    "end": "475850"
  },
  {
    "text": "I think I probably need\nanother operation here, like x equals y.field1,\nfield2, that sort of thing,",
    "start": "475850",
    "end": "483936"
  },
  {
    "text": "and maybe the reverse. But you can manipulate\nall nodes sort",
    "start": "483936",
    "end": "489199"
  },
  {
    "text": "of via the root is the idea. You follow pointers,\ndo whatever. So pretty obvious,\nslightly annoying",
    "start": "489200",
    "end": "494780"
  },
  {
    "text": "to write down formally. But that is pointer machine. ",
    "start": "494780",
    "end": "503460"
  },
  {
    "text": "And what we're going to\nbe talking about today in time travel is\nsuppose someone",
    "start": "503460",
    "end": "508829"
  },
  {
    "text": "gives me a pointer machine\ndata structure, for example, balanced binary search\ntree, linked list. A lot of data structures,\nespecially classic data",
    "start": "508829",
    "end": "516030"
  },
  {
    "text": "structures, follow\npointer machine model. What we'd like to do is\ntransform that data structure",
    "start": "516030",
    "end": "521400"
  },
  {
    "text": "or make a new\npointer machine data structure that does\nextra cool things, namely travel through time.",
    "start": "521400",
    "end": "527470"
  },
  {
    "text": "So that's what\nwe're going to do.",
    "start": "527470",
    "end": "533339"
  },
  {
    "text": "There's two senses of time\ntravel or temporal data structures that we're going\nto cover in this class.",
    "start": "533340",
    "end": "542200"
  },
  {
    "text": "The one for today is\ncalled persistence, where you don't forget\nanything, like an elephant.",
    "start": "542200",
    "end": "548310"
  },
  {
    "text": "And the other one\nis retroactivity. ",
    "start": "548310",
    "end": "555240"
  },
  {
    "text": "Persistence will be today. Retroactivity is next class. Basically, these correspond\nto two models of time travel.",
    "start": "555240",
    "end": "561670"
  },
  {
    "text": "Persistence is the branching\nuniverse time travel model, where if you make a\nchange in the past, you get a new universe.",
    "start": "561670",
    "end": "567350"
  },
  {
    "text": "You never destroy old universes. Retroactivity is more\nlike Back to the Future,",
    "start": "567350",
    "end": "573255"
  },
  {
    "text": "when you go back, make\na change, and then you can return to the present\nand see what happened. This is a lot harder to do.",
    "start": "573255",
    "end": "579709"
  },
  {
    "text": "And we'll work on\nthat next class. Persistence is what\nwe will do today.",
    "start": "579710",
    "end": "586360"
  },
  {
    "text": "So persistence. ",
    "start": "586360",
    "end": "597940"
  },
  {
    "text": "The general idea of persistence\nis to remember everything-- the general goal, I would say.",
    "start": "597940",
    "end": "605110"
  },
  {
    "text": "And by everything, I\nmean different versions of the data structure. So you're doing data\nstructures in general.",
    "start": "605110",
    "end": "611290"
  },
  {
    "text": "We have update operations\nand query operations. We're mainly concerned\nabout updates here.",
    "start": "611290",
    "end": "616386"
  },
  {
    "text": "Every time you do an\nupdate, you think of it as taking a version of the data\nstructure and making a new one.",
    "start": "616387",
    "end": "621730"
  },
  {
    "text": "And you never want to\ndestroy old versions. So even though an update\nlike an insert or something changes the data structure, we\nwant to remember that past data",
    "start": "621730",
    "end": "629230"
  },
  {
    "text": "as well. And then let's make\nthis reasonable. All data structure operations\nare relative to a specified",
    "start": "629230",
    "end": "637791"
  },
  {
    "text": "version. ",
    "start": "637791",
    "end": "647199"
  },
  {
    "text": "So an update makes and\nreturns a new version.",
    "start": "647200",
    "end": "657210"
  },
  {
    "start": "657210",
    "end": "665690"
  },
  {
    "text": "So when you do an\ninsert, you specify a version of your data\nstructure and the thing",
    "start": "665690",
    "end": "670850"
  },
  {
    "text": "you want to insert. And the output is a new version. So then you could insert into\nthat new version, keep going,",
    "start": "670850",
    "end": "676550"
  },
  {
    "text": "or maybe go back to the\nold version, modify that. I haven't said exactly\nwhat's allowed here,",
    "start": "676550",
    "end": "682450"
  },
  {
    "text": "but this is sort of\nthe general goal. And then there are four\nlevels of persistence",
    "start": "682450",
    "end": "690950"
  },
  {
    "text": "that you might want to get. First level is called\npartial persistence.",
    "start": "690950",
    "end": "697440"
  },
  {
    "text": "This is the easiest to obtain. ",
    "start": "697440",
    "end": "704300"
  },
  {
    "text": "And in partial\npersistence, you're only allowed to update\nthe latest version, which",
    "start": "704300",
    "end": "715460"
  },
  {
    "text": "means the versions\nare linearly ordered.",
    "start": "715460",
    "end": "721670"
  },
  {
    "text": "This is the easiest\nto think about. And time travel can easily get\nconfusing, so start simple.",
    "start": "721670",
    "end": "729300"
  },
  {
    "text": "We have a timeline of\nvarious versions on it.",
    "start": "729300",
    "end": "734779"
  },
  {
    "text": "This is the latest. And what we can do is\nupdate that version.",
    "start": "734780",
    "end": "739850"
  },
  {
    "text": "We'll get a new version, and\nthen our latest is this one. What this allows is looking back\nat the past to an old version",
    "start": "739850",
    "end": "747950"
  },
  {
    "text": "and querying that version. So you can still ask questions\nabout the old version, if you want to be able to do\na search on any of these data",
    "start": "747950",
    "end": "753830"
  },
  {
    "text": "structures. But you can't change them. You can only change the\nmost recent version. So that's nice.",
    "start": "753830",
    "end": "759470"
  },
  {
    "text": "It's kind of like time\nmachine on Mac, I guess.",
    "start": "759470",
    "end": "764689"
  },
  {
    "text": "If you've ever seen the\nmovie Deja Vu, which is not very common, but it's\na good time travel movie, in the first half of\nthe movie, all they can do",
    "start": "764690",
    "end": "771500"
  },
  {
    "text": "is look back at the past. Later they discover\nthat actually they have a full persistence model.",
    "start": "771500",
    "end": "777850"
  },
  {
    "text": "It takes a while\nfor dramatic effect. ",
    "start": "777850",
    "end": "784250"
  },
  {
    "text": "In full persistence, you can\nupdate anything you want-- so update any version.",
    "start": "784250",
    "end": "791015"
  },
  {
    "start": "791015",
    "end": "798070"
  },
  {
    "text": "and so then the\nversions form a tree.",
    "start": "798070",
    "end": "804200"
  },
  {
    "text": " OK. So in this model,\nmaybe you initially",
    "start": "804200",
    "end": "810200"
  },
  {
    "text": "have a nice line of versions. But now if I go back to\nthis version and update it, I branch, get a\nnew version here.",
    "start": "810200",
    "end": "817339"
  },
  {
    "text": "And then I might keep modifying\nthat version sometimes. Any of these guys can branch. ",
    "start": "817340",
    "end": "824240"
  },
  {
    "text": "So this is why I call it the\nbranching universe model, when you update your branch.",
    "start": "824240",
    "end": "829685"
  },
  {
    "text": " So no version ever\ngets destroyed here. Again, you can\nquery all versions.",
    "start": "829685",
    "end": "836720"
  },
  {
    "text": "But now you can also\nupdate any version. But you just make a new version. It's a totally new world.",
    "start": "836720",
    "end": "842660"
  },
  {
    "text": "When I update this\nversion, this version knows nothing about all the-- this doesn't know\nabout this future.",
    "start": "842660",
    "end": "847940"
  },
  {
    "text": "It's created its own future. There's no way to sort of\nmerge those universes together.",
    "start": "847940",
    "end": "854310"
  },
  {
    "text": "It's kind of sad. That's why we have the\nthird level of persistence,",
    "start": "854310",
    "end": "862220"
  },
  {
    "text": "which lets us merge timelines. It's great for lots\nof fiction out there.",
    "start": "862220",
    "end": "867940"
  },
  {
    "start": "867940",
    "end": "875880"
  },
  {
    "text": "If you've seen the\nold TV show Sliders, that would be\nconfluent persistence. ",
    "start": "875880",
    "end": "890829"
  },
  {
    "text": "So confluent persistence,\nyou can combine two versions",
    "start": "890830",
    "end": "901790"
  },
  {
    "text": "to create a new version. ",
    "start": "901790",
    "end": "909220"
  },
  {
    "text": "And in this case, again, you\ncan't destroy old versions. In persistence, you\nnever destroy versions.",
    "start": "909220",
    "end": "916259"
  },
  {
    "text": "So now the versions form a\nDAG, directed acyclic graph.",
    "start": "916260",
    "end": "922520"
  },
  {
    "text": "So now we're allowing-- OK, you make some\nchanges, whatever. You branch your universe,\nmake some changes.",
    "start": "922520",
    "end": "930274"
  },
  {
    "text": "And now I can say, OK, take\nthis version of the data structure and this version\nand recombine them.",
    "start": "930274",
    "end": "935510"
  },
  {
    "text": "Get a new version, and then\nmaybe make some more changes. OK, what does combine mean?",
    "start": "935510",
    "end": "940654"
  },
  {
    "text": "Well, it depends on\nyour data structure. A lot of data structures\nhave combine operations like if you have linked lists,\nyou have two linked lists,",
    "start": "940654",
    "end": "948029"
  },
  {
    "text": "you can concatenate them. That's an easy operation. Even if you have\nbinary search trees, you can concatenate\nthem reasonably easy",
    "start": "948029",
    "end": "953750"
  },
  {
    "text": "and combine it into one\nbig binary search tree. So if your data structure\nhas an operation that",
    "start": "953750",
    "end": "959060"
  },
  {
    "text": "takes as input two\ndata structures, then what we're saying is now\nit can take two versions, which",
    "start": "959060",
    "end": "965149"
  },
  {
    "text": "is more general. So I could take the\nsame data structure, make some changes in\none way, separately make",
    "start": "965150",
    "end": "970430"
  },
  {
    "text": "some changes in a\ndifferent way, and then try to concatenate them\nor do something crazy. This is hard to\ndo, and most of it",
    "start": "970430",
    "end": "976550"
  },
  {
    "text": "is an open problem\nwhether it can be done. But I'll tell you about it.",
    "start": "976550",
    "end": "981590"
  },
  {
    "text": "Then there's another level\neven more than confluent persistence. This is hard to interpret\nin the time travel world,",
    "start": "981590",
    "end": "990589"
  },
  {
    "text": "but it would be functional\ndata structures. If you've ever programmed\nin a functional programming language, it's a little bit\nannoying from an algorithm's",
    "start": "990590",
    "end": "996800"
  },
  {
    "text": "perspective, because it\nconstrains you to work in a purely functional world.",
    "start": "996800",
    "end": "1003220"
  },
  {
    "text": "You can never modify anything. OK. Now, we don't want\nto modify versions.",
    "start": "1003220",
    "end": "1009220"
  },
  {
    "text": "That's fine. But in a functional\ndata structure, you're not allowed to\nmodify any nodes ever. All you can do is\nmake new notes.",
    "start": "1009220",
    "end": "1015720"
  },
  {
    "start": "1015720",
    "end": "1023670"
  },
  {
    "text": "This is constraining,\nand you can't always get optimal running times\nin the functional world.",
    "start": "1023670",
    "end": "1029400"
  },
  {
    "text": "But if you can get a\nfunctional data structure, you have all these\nthings, because you can't destroy anything. If you can't destroy\nnodes, then in particular,",
    "start": "1029400",
    "end": "1036215"
  },
  {
    "text": "you can't destroy versions. And all of these things\njust work for free. And so a bunch of\nspecial cases are known,",
    "start": "1036216",
    "end": "1042957"
  },
  {
    "text": "interesting special\ncases, like search trees you can do in the\nfunctional world. And that makes all\nof these things easy.",
    "start": "1042957",
    "end": "1049049"
  },
  {
    "text": "So the rest of this\nlecture is going to be general techniques for\ndoing partial full persistence,",
    "start": "1049050",
    "end": "1054270"
  },
  {
    "text": "what we know about\nconfluent, and what we know about functional,\nbrief overview.",
    "start": "1054270",
    "end": "1061060"
  },
  {
    "text": "Any questions about those\ngoals, problem definitions? ",
    "start": "1061060",
    "end": "1067640"
  },
  {
    "text": "Yeah. AUDIENCE: I'm still confused\nabout functional, because-- ERIK DEMAINE: What\ndoes functional mean? AUDIENCE: [INAUDIBLE]",
    "start": "1067640",
    "end": "1075260"
  },
  {
    "text": "ERIK DEMAINE: Yeah, I\nguess you'll see what-- functional looks like all\nthe other things, I agree. You'll see in a moment\nhow we actually implement",
    "start": "1075260",
    "end": "1082360"
  },
  {
    "text": "partial and persistence. We're going to be\nchanging nodes a lot.",
    "start": "1082360",
    "end": "1087490"
  },
  {
    "text": "As long as we still\nrepresent the same data in the old versions, we\ndon't have to represent it",
    "start": "1087490",
    "end": "1093040"
  },
  {
    "text": "in the same way. That lets us do things\nmore efficiently. Whereas in functional,\nyou have to represent all the old versions\nin exactly the way",
    "start": "1093040",
    "end": "1099429"
  },
  {
    "text": "you used to represent them. Here we can kind of\nmangle things around and it makes things faster. Yeah, good question.",
    "start": "1099430",
    "end": "1105490"
  },
  {
    "text": "So it seems almost the same,\nbut it's nodes versus versions. I haven't really\ndefined a version.",
    "start": "1105490",
    "end": "1111340"
  },
  {
    "text": "But it's just that all the\nqueries answer the same way. That's what you need\nfor persistence.",
    "start": "1111340",
    "end": "1118580"
  },
  {
    "text": "Other questions? All right.",
    "start": "1118580",
    "end": "1123620"
  },
  {
    "text": "Well, let's do some\nreal data structures. ",
    "start": "1123620",
    "end": "1129660"
  },
  {
    "text": "We start with\npartial persistence. ",
    "start": "1129660",
    "end": "1135907"
  },
  {
    "text": "This is the easiest.  For both partial and\nfull persistence,",
    "start": "1135907",
    "end": "1142080"
  },
  {
    "text": "there is the following result.\nAny pointer machine data structure, one catch with a\nconstant number of pointers",
    "start": "1142080",
    "end": "1159660"
  },
  {
    "text": "to any node-- so this is constant n degree. ",
    "start": "1159660",
    "end": "1167726"
  },
  {
    "text": "In a pointer machine, you\nalways have a constant number of pointers out\nof a node at most. But for this result\nto hold, we also",
    "start": "1167726",
    "end": "1174540"
  },
  {
    "text": "need a constant number of\npointers into any node. So this is an extra constraint. ",
    "start": "1174540",
    "end": "1182910"
  },
  {
    "text": "Can be transformed into\nanother data structure that is partially persistent and does\nall the things it used to do--",
    "start": "1182910",
    "end": "1193769"
  },
  {
    "text": "so I'll just say, can be\nmade partially persistent. ",
    "start": "1193770",
    "end": "1200300"
  },
  {
    "text": "You have to pay something, but\nyou have to pay very little-- constant amortized\nfactor overhead,",
    "start": "1200300",
    "end": "1212550"
  },
  {
    "text": "multiplicative overhead\nand constant amount",
    "start": "1212550",
    "end": "1221860"
  },
  {
    "text": "of additive space per change\nin the data structure.",
    "start": "1221860",
    "end": "1230290"
  },
  {
    "text": "So every time you do a\nmodification in your pointer machine-- you set one of\nthe fields to something--",
    "start": "1230290",
    "end": "1236260"
  },
  {
    "text": "you have to store that forever. So, I mean, this is the\nbest you could hope to do. You've got to store\neverything that happened.",
    "start": "1236260",
    "end": "1243250"
  },
  {
    "text": "You pay a constant\nfactor overhead, eh. We're theoreticians. That doesn't matter. Then you get any data\nstructure in this world",
    "start": "1243250",
    "end": "1250840"
  },
  {
    "text": "can be made\npartially persistent. That's nice. Let's prove it. ",
    "start": "1250840",
    "end": "1260330"
  },
  {
    "text": "OK, the idea is pretty simple.  Pointer machines are all\nabout nodes and fields.",
    "start": "1260330",
    "end": "1266790"
  },
  {
    "text": "So we just need to simulate\nwhatever the data structure is doing to those nodes\nand fields in a way that we don't lose\nall the information",
    "start": "1266790",
    "end": "1273539"
  },
  {
    "text": "and we can still\nsearch it very quickly. First idea is to\nstore back pointers.",
    "start": "1273540",
    "end": "1281190"
  },
  {
    "text": "And this is why we need the\nconstant n degree constraint. ",
    "start": "1281190",
    "end": "1287529"
  },
  {
    "text": "So if we have a node-- how do I want to\ndraw a node here?",
    "start": "1287530",
    "end": "1292610"
  },
  {
    "text": " So maybe these are the\nthree fields of the node.",
    "start": "1292610",
    "end": "1298700"
  },
  {
    "text": "I want to also store\nsome back pointers. Whenever there is a node\nthat points to this node,",
    "start": "1298700",
    "end": "1308480"
  },
  {
    "text": "I want to have a\nback pointer that points back so I know where\nall the pointers came from.",
    "start": "1308480",
    "end": "1314210"
  },
  {
    "text": "If there's only p pointers,\nthen this is fine. There'll be p fields here.",
    "start": "1314210",
    "end": "1320960"
  },
  {
    "text": "So still constant, still in\nthe pointier machine model. OK, I'm going to need\nsome other stuff too. ",
    "start": "1320960",
    "end": "1328670"
  },
  {
    "text": "So this is a simple thing,\ndefinitely want this. Because if my nodes\never move around, I've got to update\nthe pointers to them.",
    "start": "1328670",
    "end": "1335172"
  },
  {
    "text": "And where are those pointers? Well, the back pointers\ntell you where they are. Nodes will still\nbe constant size,",
    "start": "1335172",
    "end": "1342410"
  },
  {
    "text": "remain in pointer\nmachine data structure. OK. That's idea one.",
    "start": "1342410",
    "end": "1348230"
  },
  {
    "text": "Idea two is this part.",
    "start": "1348230",
    "end": "1355080"
  },
  {
    "text": "This is going to store\nsomething called mods. It could stand for something,\nbut I'll leave it as mods.",
    "start": "1355080",
    "end": "1364020"
  },
  {
    "text": "So these are two of the\nfields of the data structure.",
    "start": "1364020",
    "end": "1376530"
  },
  {
    "text": "Ah, one convenience here\nis for back pointers, I'm only going to store it for\nthe latest version of the data",
    "start": "1376530",
    "end": "1384840"
  },
  {
    "text": "structure. ",
    "start": "1384840",
    "end": "1396310"
  },
  {
    "text": "Sorry. I forgot about that. We'll come back to that later.",
    "start": "1396310",
    "end": "1401397"
  },
  {
    "text": "And then the idea is to\nstore these modifications. How many modifications? Let's say up to p, twice p.",
    "start": "1401397",
    "end": "1409610"
  },
  {
    "start": "1409610",
    "end": "1414835"
  },
  {
    "text": "p was the bound on the\nn degree of a node. So I'm going to allow 2p\nmodifications over here.",
    "start": "1414835",
    "end": "1423870"
  },
  {
    "text": "And what's a\nmodification look like?  It's going to consist\nof three things--",
    "start": "1423870",
    "end": "1430770"
  },
  {
    "text": "get them in the right order-- the version in which\nsomething was changed,",
    "start": "1430770",
    "end": "1436850"
  },
  {
    "text": "the field that got changed,\nand the value it go changed to.",
    "start": "1436850",
    "end": "1442830"
  },
  {
    "text": "So the idea is that these\nare the fields here.",
    "start": "1442830",
    "end": "1447919"
  },
  {
    "text": "We're not going to touch those. Once they're set to something-- or, I mean, whatever\nthey are initially,",
    "start": "1447920",
    "end": "1453450"
  },
  {
    "text": "they will stay that way. And so instead of actually\nchanging things like the data structure normally\nwould, we're just",
    "start": "1453450",
    "end": "1459920"
  },
  {
    "text": "going to add modifications\nhere to say, oh, well at this time, this field\nchanged to the value of 5.",
    "start": "1459920",
    "end": "1465410"
  },
  {
    "text": "And then later on, it\nchanged to the value 7. And then later on, this one\nchanged to the value 23,",
    "start": "1465410",
    "end": "1471380"
  },
  {
    "text": "whatever. So that's what\nthey'll look like. There's a limit to how many--",
    "start": "1471380",
    "end": "1477500"
  },
  {
    "text": "we can only store a constant\nnumber of mods to each node. And our constant will be 2p.",
    "start": "1477500",
    "end": "1484580"
  },
  {
    "text": "OK. Those are the\nideas, and now it's just a matter of\nmaking this all work and analyzing that it's\nconstant amortized overhead.",
    "start": "1484580",
    "end": "1490510"
  },
  {
    "text": " So first thing is if you\nwant to read a field,",
    "start": "1490510",
    "end": "1506230"
  },
  {
    "text": "how would I read a field? This is really easy. ",
    "start": "1506230",
    "end": "1511720"
  },
  {
    "text": "First you look at what the\nfield is in the node itself. But then it might\nhave been changed.",
    "start": "1511720",
    "end": "1517831"
  },
  {
    "text": "And so remember when\nI say read the field, I actually mean while\nI'm given some version, v, I want to know what is the\nvalue of this field at version",
    "start": "1517831",
    "end": "1524655"
  },
  {
    "text": "v, because I want to be able\nto look at any of the old data structures too. So this would be at\nversion v. I just",
    "start": "1524655",
    "end": "1537370"
  },
  {
    "text": "look through all\nthe modifications. There's constantly many,\nso it takes constant time to just flip through them\nand say, well, what changes",
    "start": "1537370",
    "end": "1543730"
  },
  {
    "text": "have happened up to version v? So I look at mods\nwith version less than",
    "start": "1543730",
    "end": "1556750"
  },
  {
    "text": "or equal to v. That will be all\nthe changes that happened up to this point. I see, did this field change?",
    "start": "1556750",
    "end": "1562060"
  },
  {
    "text": "I look at the latest one. That will be how I read\nthe field of the node, so",
    "start": "1562060",
    "end": "1567250"
  },
  {
    "text": "constant time. There's lots of ways to make\nthis efficient in practice. But for our purposes,\nit doesn't matter.",
    "start": "1567250",
    "end": "1573730"
  },
  {
    "text": "It's constant. The hard part is how\ndo you change a field?",
    "start": "1573730",
    "end": "1578890"
  },
  {
    "text": "Because there might not be\nany room in the mod structure. ",
    "start": "1578890",
    "end": "1595850"
  },
  {
    "text": "So to modify, say we want to\nset node.field equal to x.",
    "start": "1595850",
    "end": "1604525"
  },
  {
    "text": " What we do is first\nwe check, is there",
    "start": "1604525",
    "end": "1612740"
  },
  {
    "text": "any space in the mod structure? If there's any blank mods,\nso if the node is not full,",
    "start": "1612740",
    "end": "1623080"
  },
  {
    "text": "we just add a mod. So a mod will look\nlike now field x.",
    "start": "1623080",
    "end": "1633106"
  },
  {
    "text": "Just throw that in there. Because right at this moment-- so we maintain a time\ncounter, just increment",
    "start": "1633106",
    "end": "1639560"
  },
  {
    "text": "it ever time we do a change. This field changed that value. So that's the easy case. The trouble, of course,\nis if the node is full--",
    "start": "1639560",
    "end": "1649340"
  },
  {
    "text": "the moment you've\nall been waiting for. So what we're going to do\nhere is make a new node. We've ran out of space.",
    "start": "1649340",
    "end": "1654690"
  },
  {
    "text": "So we need to make a new node. We're not going to touch the old\nnode, just going to let it sit. It still maintains all\nthose old versions.",
    "start": "1654690",
    "end": "1660530"
  },
  {
    "text": "Now we want a new node\nthat represents the latest and greatest of this node. OK. So make a new node.",
    "start": "1660530",
    "end": "1667700"
  },
  {
    "text": " I'll call it node prime to\ndistinguish from node, where",
    "start": "1667700",
    "end": "1677060"
  },
  {
    "text": "with all the mods, and this\nmodification in particular,",
    "start": "1677060",
    "end": "1684705"
  },
  {
    "text": "applied.  OK, so we make a new\nversion of this node.",
    "start": "1684705",
    "end": "1691160"
  },
  {
    "text": "It's going to have some\ndifferent fields, whatever was the latest version\nrepresented by those mods.",
    "start": "1691160",
    "end": "1698730"
  },
  {
    "text": "It's still going to\nhave back pointers, so we have to maintain\nall those back pointers.",
    "start": "1698730",
    "end": "1704810"
  },
  {
    "text": "And now the mod,\ninitially, is going to be empty, because we\njust applied them all. So this new node doesn't\nhave any recent mods.",
    "start": "1704810",
    "end": "1712460"
  },
  {
    "text": "Old node represents\nthe old versions. This node is going to\nrepresent the new versions.",
    "start": "1712460",
    "end": "1717934"
  },
  {
    "text": "What's wrong with this picture? AUDIENCE: Update pointers. ERIK DEMAINE: Update pointers. Yeah, there's pointers\nto the old version",
    "start": "1717935",
    "end": "1723890"
  },
  {
    "text": "of the node, which are fine for\nthe old versions of the data structure. But for the latest version\nof the data structure,",
    "start": "1723890",
    "end": "1730300"
  },
  {
    "text": "this node has moved\nto this new location. So if there are any old\npointers to that node,",
    "start": "1730300",
    "end": "1736070"
  },
  {
    "text": "we've got to update them\nin the current version. We have to update them to\npoint to this node instead. The old versions are fine, but\nthe new version is in trouble.",
    "start": "1736070",
    "end": "1744059"
  },
  {
    "text": "Other questions or\nall the same answer? Yeah. AUDIENCE: So if you wanted\nto read an old version",
    "start": "1744060",
    "end": "1750719"
  },
  {
    "text": "but you just have the\nnew version, [INAUDIBLE]? ERIK DEMAINE: OK--",
    "start": "1750719",
    "end": "1756555"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] ERIK DEMAINE: The\nquestion is essentially, how do we hold on to versions?",
    "start": "1756555",
    "end": "1762059"
  },
  {
    "text": "Essentially, you can think of\na version of the data structure as where the root node is. That's probably the easiest.",
    "start": "1762059",
    "end": "1767570"
  },
  {
    "text": "I mean, in general, we're\nrepresenting versions by a number, v. But we\nalways start at the root.",
    "start": "1767570",
    "end": "1773120"
  },
  {
    "text": "And so you've given\nthe data structure, which is represented\nby the root node. And you say, search\nfor the value 5.",
    "start": "1773120",
    "end": "1780020"
  },
  {
    "text": "Is it in this binary\nsearch tree or whatever? And then you just start\nnavigating from the root,",
    "start": "1780020",
    "end": "1785330"
  },
  {
    "text": "but you know I'm inversion\na million or whatever. I know what version\nI'm looking for.",
    "start": "1785330",
    "end": "1791340"
  },
  {
    "text": "So you start with the root,\nwhich never changes, let's say. And then you follow\npointers that",
    "start": "1791340",
    "end": "1798320"
  },
  {
    "text": "essentially tell\nyou for that version where you should be going. I guess at the root version,\nit's a little trickier.",
    "start": "1798320",
    "end": "1803780"
  },
  {
    "text": "You probably want a little array\nthat says for this version, here's the root node.",
    "start": "1803780",
    "end": "1808899"
  },
  {
    "text": "But that's a special case. Yeah. Another question? AUDIENCE: So on the\nnew node that you",
    "start": "1808900",
    "end": "1815222"
  },
  {
    "text": "created, the fields that you\ncopied, you also have to have a version for them, right?",
    "start": "1815222",
    "end": "1820689"
  },
  {
    "text": "Because [INAUDIBLE]? ",
    "start": "1820689",
    "end": "1826670"
  },
  {
    "text": "ERIK DEMAINE: These-- AUDIENCE: Or do you\nversion the whole node? ERIK DEMAINE: Here we're\nversioning the whole node.",
    "start": "1826670",
    "end": "1832649"
  },
  {
    "text": "The original field\nvalues represent what was originally there,\nwhenever this node was created.",
    "start": "1832650",
    "end": "1837940"
  },
  {
    "text": "Then the mods specify what\ntime the fields change. So I don't think\nwe need times here.",
    "start": "1837940",
    "end": "1844200"
  },
  {
    "text": "All right. So we've got to update\ntwo kinds of pointers. There's regular\npointers, which live in the fields, which are\nthings pointing to the node.",
    "start": "1844200",
    "end": "1852140"
  },
  {
    "text": "But then there's\nalso back pointers. Because if this is\na pointer to a node, then there'll be a back\npointer back to the node.",
    "start": "1852140",
    "end": "1857950"
  },
  {
    "text": "And all of those have to change. Conveniently, the back\npointers are easy.",
    "start": "1857950",
    "end": "1863765"
  },
  {
    "start": "1863765",
    "end": "1871700"
  },
  {
    "text": "So if they're back\npointers to the node, we change them to\nthe node prime. How do we find\nthe back pointers? Well, we just follow\nall the pointers",
    "start": "1871700",
    "end": "1877621"
  },
  {
    "text": "and then there will be\nback pointers there. Because I said we're\nonly maintaining",
    "start": "1877621",
    "end": "1883039"
  },
  {
    "text": "backed pointers for\nthe latest version, I don't need to preserve\nthe old versions",
    "start": "1883040",
    "end": "1888299"
  },
  {
    "text": "of those backed pointers. So I just go in\nand I change them. It takes constant time,\nbecause the constant number of things I point to, each\none as a back pointer.",
    "start": "1888299",
    "end": "1895700"
  },
  {
    "text": "So this is cheap. There's no persistence here. That's an advantage of\npartial persistence.",
    "start": "1895700",
    "end": "1901940"
  },
  {
    "text": "The hard part is\nupdating the pointers because those live in fields. I need to remember the old\nversions of those fields.",
    "start": "1901940",
    "end": "1907850"
  },
  {
    "text": "And that we do recursively. ",
    "start": "1907850",
    "end": "1918746"
  },
  {
    "text": "Because to change\nthose pointers, that's a field update. That's something\nexactly of this form. So that's the same operation\nbut on a different node.",
    "start": "1918746",
    "end": "1925970"
  },
  {
    "text": "So I just do that. I claim this is good. That's the end of the algorithm.",
    "start": "1925970",
    "end": "1931400"
  },
  {
    "text": "Now we need to analyze it. ",
    "start": "1931400",
    "end": "1944886"
  },
  {
    "text": "How do we analyze it? Any guesses?  AUDIENCE: Amortize it.",
    "start": "1944886",
    "end": "1950500"
  },
  {
    "text": "ERIK DEMAINE: Amortized\nanalysis, exactly the answer I was looking for. OK. [INAUDIBLE] amortization.",
    "start": "1950500",
    "end": "1956289"
  },
  {
    "text": "The most powerful\ntechnique in amortization is probably the\npotential method. So we're going to use that.",
    "start": "1956290",
    "end": "1962370"
  },
  {
    "text": "There's a sort of more-- you'll see a charging\nargument in a moment.",
    "start": "1962370",
    "end": "1967990"
  },
  {
    "text": " We want the potential function\nto represent when this data",
    "start": "1967990",
    "end": "1973330"
  },
  {
    "text": "structure is in a bad state. Intuitively, it's in a bad state\nwhen a lot of nodes are full.",
    "start": "1973330",
    "end": "1978807"
  },
  {
    "text": "Because then as soon as\nyou make a change in them, they will burst, and you have\nto do all this crazy recursion and stuff.",
    "start": "1978807",
    "end": "1984580"
  },
  {
    "text": "This case is nice and cheap. We just add a modification,\nconstant time. This case, not so nice\nbecause we recurse.",
    "start": "1984580",
    "end": "1990430"
  },
  {
    "text": "And then that's going\nto cause more recursions and all sorts of\nchaos could happen.",
    "start": "1990430",
    "end": "1996040"
  },
  {
    "text": "So there's probably a few\ndifferent potential functions that would work here.",
    "start": "1996040",
    "end": "2001080"
  },
  {
    "text": "And an old version\nof these nodes I said should be the number\nof full nodes. But I think we can make\nlife a little bit easier",
    "start": "2001080",
    "end": "2007679"
  },
  {
    "text": "by the following. Basically, the total\nnumber of modifications--",
    "start": "2007680",
    "end": "2016674"
  },
  {
    "text": "not quite the total,\nalmost the total. So I'm going to do c times\nthe sum of the number of mods",
    "start": "2016674",
    "end": "2029760"
  },
  {
    "text": "in latest version nodes.",
    "start": "2029760",
    "end": "2036190"
  },
  {
    "text": " OK. So because we sort\nof really only",
    "start": "2036190",
    "end": "2042984"
  },
  {
    "text": "care about-- we're only\nchanging the latest version, so I really only\ncare about nodes that live in the latest version.",
    "start": "2042984",
    "end": "2048569"
  },
  {
    "text": "What do I mean by this? Well, when I made\nthis new node prime, this becomes the new\nrepresentation of that node.",
    "start": "2048570",
    "end": "2054000"
  },
  {
    "text": "The old version is dead. We will never change it again. If we're modifying, we will\nnever even look at it again.",
    "start": "2054000",
    "end": "2061080"
  },
  {
    "text": "Because now everything\npoints to here. So I don't really\ncare about that node.",
    "start": "2061080",
    "end": "2066429"
  },
  {
    "text": "It's got a ton of mods. But what's nice is that when\nI create this new node, now the mod list is empty.",
    "start": "2066429",
    "end": "2071881"
  },
  {
    "text": "So I start from scratch,\njust like reinstalling your operating system. It's a good feeling.",
    "start": "2071882",
    "end": "2078010"
  },
  {
    "text": "And so the potential goes down\nby, I guess, c times 2 times p.",
    "start": "2078010",
    "end": "2085090"
  },
  {
    "text": "When I do this change, potential\ngoes down by basically p. AUDIENCE: Is c any constant or--",
    "start": "2085090",
    "end": "2092230"
  },
  {
    "text": "ERIK DEMAINE: c will be a\nconstant to be determined. I mean, it could be 1. It depends how you\nwant to define it.",
    "start": "2092230",
    "end": "2098770"
  },
  {
    "text": "I'm going to use the CLRS\nnotion of amortized cost, which is actual cost plus\nchange in potential.",
    "start": "2098770",
    "end": "2106776"
  },
  {
    "text": "And then I need a\nconstant here, because I'm measuring a running time versus\nsome combinatorial quantity.",
    "start": "2106777",
    "end": "2112850"
  },
  {
    "text": "So this will be to match the\nrunning time that we'll get to. OK.",
    "start": "2112850",
    "end": "2117990"
  },
  {
    "text": "So what is amortized cost? There's sort of two\ncases modification.",
    "start": "2117990",
    "end": "2124920"
  },
  {
    "text": "There's the cheap case\nand the not so cheap case. In general, amortized cost--",
    "start": "2124920",
    "end": "2130944"
  },
  {
    "text": " in both cases, it's\ngoing to be at most--",
    "start": "2130945",
    "end": "2137920"
  },
  {
    "text": "well, first of all, we\ndo some constant work just to figure out all this\nstuff, make copies, whatever.",
    "start": "2137920",
    "end": "2144640"
  },
  {
    "text": "So that's some constant time.",
    "start": "2144640",
    "end": "2149680"
  },
  {
    "text": "That's the part that I don't\nwant to try to measure. Then potentially,\nwe add a new mod.",
    "start": "2149680",
    "end": "2155140"
  },
  {
    "text": "If we add a mod, that\nincreases the potential by c. Because we're just counting\nmods, multiplying by c.",
    "start": "2155140",
    "end": "2162069"
  },
  {
    "text": "So we might get plus 1 mod. This is going to\nbe an upper bound. We don't always add 1, but\nworst case, we always had 1,",
    "start": "2162070",
    "end": "2169720"
  },
  {
    "text": "let's say. And then there's\nthis annoying part. And this might happen,\nmight not happen.",
    "start": "2169720",
    "end": "2176500"
  },
  {
    "text": "So then there's a plus maybe. If this happens, we\ndecrease the potential",
    "start": "2176500",
    "end": "2183310"
  },
  {
    "text": "because we empty out the\nmods for that node in terms of the latest version. So then we get a negative\n2cp, change in potential.",
    "start": "2183310",
    "end": "2194500"
  },
  {
    "text": "And then we'd have to pay\nI guess up to p recursions.",
    "start": "2194500",
    "end": "2202120"
  },
  {
    "start": "2202120",
    "end": "2209250"
  },
  {
    "text": "Because we have to-- how many pointers\nare there to me? Well, at most p of them, because\nthere are at most p pointers",
    "start": "2209250",
    "end": "2218490"
  },
  {
    "text": "to any node.  OK. This is kind of a weird--",
    "start": "2218490",
    "end": "2225110"
  },
  {
    "text": "it's not exactly algebra here. I have this thing, recursions. But if you think about\nhow this would expand,",
    "start": "2225110",
    "end": "2231610"
  },
  {
    "text": "all right, this\nis constant time. That's good. And then if we do this-- I'll put a question mark here. It might be here.",
    "start": "2231610",
    "end": "2236868"
  },
  {
    "text": "It might not. If it's not here, find constant. If it is here, then this gets\nexpanded into this thing.",
    "start": "2236868",
    "end": "2244280"
  },
  {
    "text": "It's a weird way to\nwrite a recurrence. But we get p times whatever\nis in this right hand side.",
    "start": "2244280",
    "end": "2250539"
  },
  {
    "text": "OK. But then there's this minus 2cp. So we're going to\nget p times 2c here.",
    "start": "2250540",
    "end": "2256560"
  },
  {
    "text": "That's the initial cost. So that will cancel with this. And then we might get\nanother recursion.",
    "start": "2256560",
    "end": "2261910"
  },
  {
    "text": "But every time we get a\nrecursion, all the terms cancel. So it doesn't matter\nwhether this is here or not.",
    "start": "2261910",
    "end": "2266940"
  },
  {
    "text": "You get 0, which is great. And you're left with\nthe original 2c.",
    "start": "2266940",
    "end": "2273400"
  },
  {
    "text": "Constant. OK. [INAUDIBLE] potential functions\nare always a little crazy.",
    "start": "2273400",
    "end": "2279120"
  },
  {
    "text": "What's happening here is\nthat, OK, maybe you add a mod. That's cheap.",
    "start": "2279120",
    "end": "2285150"
  },
  {
    "text": "But when we have to do this\nwork and we have to do this recursion-- this is up to\n2p updates or recursions--",
    "start": "2285150",
    "end": "2294390"
  },
  {
    "text": "we are charging it to the\nemptying of this node. The number of mods\nwent from 2p down to 0.",
    "start": "2294390",
    "end": "2301110"
  },
  {
    "text": "And so we're just\ncharging this update cost to that modification. So if you like charging schemes,\nthis is much more intuitive.",
    "start": "2301110",
    "end": "2306600"
  },
  {
    "text": "But with charging schemes,\nit's always a little careful. You have to make sure\nyou're not double charging. Here it's obvious that\nyou're not double charging.",
    "start": "2306600",
    "end": "2314790"
  },
  {
    "text": "Kind of a cool and magical. This is a paper by\nDriscoll, Sarnak, Sleator,",
    "start": "2314790",
    "end": "2322010"
  },
  {
    "text": "Tarjan from 1989. So it's very early\ndays of amortization. But they knew how to do it.",
    "start": "2322010",
    "end": "2327760"
  },
  {
    "text": "Question? AUDIENCE: [INAUDIBLE] ERIK DEMAINE: What happens\nif you overflow the root? Yeah, I never thought about\nthe root before today.",
    "start": "2327760",
    "end": "2334753"
  },
  {
    "text": "But I think the way\nto fix the root is just you have one big table\nthat says, for a given version--",
    "start": "2334753",
    "end": "2342780"
  },
  {
    "text": "I guess a simple\nway would be to say, not only is a version\na number, but it's also a pointer to the root. There we go. Pointer machine.",
    "start": "2342780",
    "end": "2349242"
  },
  {
    "text": "So that way you're just\nalways explicitly maintaining the root copy or the pointer.",
    "start": "2349242",
    "end": "2355109"
  },
  {
    "text": "Because otherwise,\nyou're in trouble. AUDIENCE: Then can you\ngo back to [INAUDIBLE].",
    "start": "2355110",
    "end": "2361530"
  },
  {
    "text": "ERIK DEMAINE: So in order\nto refer to an old version, you have to have the\npointer to that root node.",
    "start": "2361530",
    "end": "2366750"
  },
  {
    "text": "If you want to do it just\nfrom a version number, look at the data structure. Just from a version\nnumber, you would need some kind of\nlookup table, which",
    "start": "2366750",
    "end": "2373249"
  },
  {
    "text": "is outside the pointer machine. So you could do it\nin a real computer, but a pointer machine is\nnot technically allowed.",
    "start": "2373249",
    "end": "2379210"
  },
  {
    "text": "So it's slightly awkward. No arrays are allowed\nin pointer machines, in case that wasn't clear. Another question?",
    "start": "2379210",
    "end": "2384274"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] constant\nspace to store for [INAUDIBLE]. And also, what if we have\nreally big numbers [INAUDIBLE]?",
    "start": "2384274",
    "end": "2394294"
  },
  {
    "text": "ERIK DEMAINE: In this model,\nin the pointer machine model, we're assuming that whatever\nthe data is in the items take constant space each.",
    "start": "2394294",
    "end": "2401480"
  },
  {
    "text": "If you want to know about\nbigger things in here, then refer to future lectures. This is time travel, after all.",
    "start": "2401480",
    "end": "2406910"
  },
  {
    "text": "Just go to a future\nclass and then come back. [LAUGHS] So we'll get\nthere, but right now,",
    "start": "2406910",
    "end": "2411920"
  },
  {
    "text": "we're not thinking\nabout what's in here. Whatever big thing\nyou're trying to store, you reduce it down to\nconstant size things.",
    "start": "2411920",
    "end": "2419810"
  },
  {
    "text": "And then you spread them around\nnodes of a pointer machine. How you do that, that's\nup to the data structure.",
    "start": "2419810",
    "end": "2425250"
  },
  {
    "text": "We're just transforming the\ndata structure to be persistent. OK, you could ask about other\nmodels than pointer machines,",
    "start": "2425250",
    "end": "2430458"
  },
  {
    "text": "but we're going to stick\nto pointer machines here. All right.",
    "start": "2430458",
    "end": "2436220"
  },
  {
    "text": "That was partial persistence. Let's do full persistence.",
    "start": "2436220",
    "end": "2441540"
  },
  {
    "text": "That was too easy.  Same paper does\nfull persistence.",
    "start": "2441540",
    "end": "2448970"
  },
  {
    "text": "Systems That was just a warm up. Full persistence is actually\nnot that much harder. ",
    "start": "2448970",
    "end": "2455070"
  },
  {
    "text": "So let me tell you\nbasically what changes. ",
    "start": "2455070",
    "end": "2464240"
  },
  {
    "text": "There are two issues. One is that everything here\nhas to change and not by much.",
    "start": "2464240",
    "end": "2469440"
  },
  {
    "text": "We're still going to\nuse back pointers. We're still going\nto have my mods. The number of mods is going\nto be slightly different",
    "start": "2469440",
    "end": "2475026"
  },
  {
    "text": "but basically the same. Back pointers no longer just\nrefer to the latest version. We have to maintain back\npointers in all versions.",
    "start": "2475026",
    "end": "2481410"
  },
  {
    "text": "So that's annoying. But hey, that's life. The amortization, the\npotential function will change slightly\nbut basically not much.",
    "start": "2481410",
    "end": "2488190"
  },
  {
    "text": " Sort of the bigger issue you\nmight first wonder about, and it's actually the most\nchallenging technically,",
    "start": "2488190",
    "end": "2495240"
  },
  {
    "text": "is versions are\nno longer numbers. Because it's not a line. Versions are nodes in a tree.",
    "start": "2495240",
    "end": "2501246"
  },
  {
    "text": "You should probably\ncall them vertices in a tree to distinguish them\nfrom nodes in the pointer machine.",
    "start": "2501247",
    "end": "2506580"
  },
  {
    "text": "OK, so you've got\nthis tree of versions. And then versions are just\nsome point on that tree.",
    "start": "2506580",
    "end": "2513930"
  },
  {
    "text": "This is annoying\nbecause we like lines. We don't like trees as much. So what we're going to\ndo is linearize the tree.",
    "start": "2513930",
    "end": "2520770"
  },
  {
    "text": " Like, when in doubt, cheat.",
    "start": "2520770",
    "end": "2525900"
  },
  {
    "start": "2525900",
    "end": "2532200"
  },
  {
    "text": "How do we do this? With tree traversal. Imagine I'm going to draw\na super complicated tree",
    "start": "2532200",
    "end": "2538240"
  },
  {
    "text": "of versions. Say there are three versions. OK. I don't want to number\nthem, because that would be",
    "start": "2538240",
    "end": "2544890"
  },
  {
    "text": "kind of begging the question. So let's just call\nthem x, y, and z.",
    "start": "2544890",
    "end": "2550530"
  },
  {
    "text": " All right. I mean, it's a directed\ntree, because we",
    "start": "2550530",
    "end": "2556050"
  },
  {
    "text": "have the older versions. This is like the\noriginal version. And we made a change. We made a different change\non the same version.",
    "start": "2556050",
    "end": "2562690"
  },
  {
    "text": "What I'd like to do is a\ntraversal of that tree, like a regular, as if you're\ngoing to sort those nodes.",
    "start": "2562690",
    "end": "2568170"
  },
  {
    "text": "Actually, let me use\ncolor, high def here.",
    "start": "2568170",
    "end": "2573420"
  },
  {
    "text": "So here's our\ntraversal of the tree. ",
    "start": "2573420",
    "end": "2579030"
  },
  {
    "text": "And I want to look at the\nfirst and the last time I visit each node. So here's the first\ntime I visit x.",
    "start": "2579030",
    "end": "2585359"
  },
  {
    "text": "So I'll write this is\nthe beginning of x. Capital X. Then this is\nthe first time I visit y,",
    "start": "2585360",
    "end": "2593550"
  },
  {
    "text": "so it's beginning of y. And then this is the last time\nI visit y, so it's the end of y.",
    "start": "2593550",
    "end": "2599070"
  },
  {
    "text": "And then, don't care. Then this is the beginning of z.",
    "start": "2599070",
    "end": "2604800"
  },
  {
    "text": "And this is the end of z. And then this is the end x. If I write those sequentially,\nI get bxbyeybzez,",
    "start": "2604800",
    "end": "2618830"
  },
  {
    "text": "because this is so easy, ex. OK, you can think of these\nas parentheses, right?",
    "start": "2618830",
    "end": "2625529"
  },
  {
    "text": "For whatever reason I chose b\nand e for beginning and ending, but this is like open\nparens, close parens. This is easy to\ndo in linear time.",
    "start": "2625530",
    "end": "2632310"
  },
  {
    "text": "I think you all know how. Except it's not\na static problem. Versions are changing\nall the time. We're adding versions.",
    "start": "2632310",
    "end": "2637500"
  },
  {
    "text": "We're never deleting\nversions, but we're always adding stuff to here. It's a little\nawkward, but the idea is I want to\nmaintain this order,",
    "start": "2637500",
    "end": "2645839"
  },
  {
    "text": "maintain the begin and\nthe end of each you",
    "start": "2645840",
    "end": "2656010"
  },
  {
    "text": "might say subtree of versions. ",
    "start": "2656010",
    "end": "2663520"
  },
  {
    "text": "This string, from\nbx to ex, represents all of the stuff in x's\nsubtree, in the rooted tree",
    "start": "2663520",
    "end": "2669820"
  },
  {
    "text": "starting at x.  How do I maintain that?",
    "start": "2669820",
    "end": "2674930"
  },
  {
    "start": "2674930",
    "end": "2680550"
  },
  {
    "text": "Using a data structure. ",
    "start": "2680550",
    "end": "2696490"
  },
  {
    "text": "So we're going to use something,\na data structure we haven't yet seen.",
    "start": "2696490",
    "end": "2702210"
  },
  {
    "text": "It will be in lecture 8. This is a time travel\ndata structure, so I'm allowed to do that.",
    "start": "2702210",
    "end": "2710280"
  },
  {
    "text": "So order maintenance\ndata structure. You can think of this as\na magical linked list.",
    "start": "2710280",
    "end": "2716970"
  },
  {
    "text": "Let me tell you what the\nmagical linked list can do. You can insert--",
    "start": "2716970",
    "end": "2722871"
  },
  {
    "text": "I'm going to call it\nan item, because node would be kind of confusing\ngiven where we are right now.",
    "start": "2722871",
    "end": "2728640"
  },
  {
    "text": "You can insert a new item in\nthe list immediately before or after a given item.",
    "start": "2728640",
    "end": "2734850"
  },
  {
    "text": " OK. This is like a\nregular linked list.",
    "start": "2734850",
    "end": "2741390"
  },
  {
    "text": "Here's a regular linked list. And if I'm given a particular\nitem like this one,",
    "start": "2741390",
    "end": "2748290"
  },
  {
    "text": "I can say, well, insert\na new item right here. You say, OK. Fine. I'll just make a new node and\nrelink here, relink there.",
    "start": "2748290",
    "end": "2757060"
  },
  {
    "text": "Constant time, right? So in an order maintenance\ndata structure, you can do this\nin constant time. Wow!",
    "start": "2757060",
    "end": "2762900"
  },
  {
    "text": "So amazing. OK, catch is the second\noperation you can do.",
    "start": "2762900",
    "end": "2768410"
  },
  {
    "text": "Maybe I'll number these. This is the update. Then there's the query.",
    "start": "2768410",
    "end": "2773490"
  },
  {
    "text": "The query is, what\nis the relative order of two notes, of two items?",
    "start": "2773490",
    "end": "2780360"
  },
  {
    "text": " x and y.",
    "start": "2780360",
    "end": "2787089"
  },
  {
    "text": "So now I give you this\nnode and this node. And I say, which is to the left?",
    "start": "2787090",
    "end": "2792420"
  },
  {
    "text": "Which is earlier in the order? I want to know, is x\nbasically less than y in terms of the\norder in the list?",
    "start": "2792420",
    "end": "2797690"
  },
  {
    "text": "Or is y less than x? And an order maintenance\ndata structure",
    "start": "2797690",
    "end": "2802760"
  },
  {
    "text": "can do this in constant time. Now it doesn't look like your\nmother's linked list, I guess.",
    "start": "2802760",
    "end": "2810485"
  },
  {
    "text": "It's not the link list\nyou learned in school. It's a magical linked\nlist that can somehow answer these queries.",
    "start": "2810486",
    "end": "2815810"
  },
  {
    "text": "How? Go to lecture 7. OK. Forward reference,\nlecture 8, sorry.",
    "start": "2815810",
    "end": "2823174"
  },
  {
    "text": "For now, we're just going to\nassume that this magical data structure exists. So in constant\ntime, this is great.",
    "start": "2823174",
    "end": "2829340"
  },
  {
    "text": "Because if we're maintaining\nthese b's and e's, we want to maintain the order\nthat these things appear in.",
    "start": "2829340",
    "end": "2836089"
  },
  {
    "text": "If we want to create\na new version, like suppose we were\njust creating version z, well, it used to be everything\nwithout this bz, ez.",
    "start": "2836090",
    "end": "2843140"
  },
  {
    "text": "And we'd just insert two\nitems in here, bz and ez. They're right next\nto each other.",
    "start": "2843140",
    "end": "2848590"
  },
  {
    "text": "And if we were given version\nx, we could just say, oh, we'll look at ex and insert\ntwo items right before it.",
    "start": "2848590",
    "end": "2854300"
  },
  {
    "text": "Or you can put them\nright after bx. I mean, there's no\nactual order here. So it could have been y first\nand then z or z first and then",
    "start": "2854300",
    "end": "2860690"
  },
  {
    "text": "y. So it's really easy to add a\nnew version in constant time. You just do two of\nthese insert operations.",
    "start": "2860690",
    "end": "2867590"
  },
  {
    "text": "And now you have this magical\norder operation, which if I'm given two versions--",
    "start": "2867590",
    "end": "2874500"
  },
  {
    "text": "I don't know, v and w-- and I want to know is\nv an ancestor of w,",
    "start": "2874500",
    "end": "2880250"
  },
  {
    "text": "now I can do it\nin constant time. So this lets me do a third\noperation, which is, is version",
    "start": "2880250",
    "end": "2889700"
  },
  {
    "text": "v an ancestor of version w?",
    "start": "2889700",
    "end": "2901849"
  },
  {
    "text": "Because that's going to\nbe true if and only if bv is an ev nest around bw and ew.",
    "start": "2901850",
    "end": "2917195"
  },
  {
    "text": " OK. So that's just three tests. They're probably not\nall even necessary.",
    "start": "2917195",
    "end": "2923980"
  },
  {
    "text": "This one always holds. But if these guys fit in between\nthese guys, then you know--",
    "start": "2923980",
    "end": "2930670"
  },
  {
    "text": "now, what this tells us,\nwhat we care about here, is reading fields.",
    "start": "2930670",
    "end": "2938020"
  },
  {
    "text": "When we read a field,\nwe said, oh, we'll apply all the modifications\nthat apply to version v. Before that, that\nwas a linear order.",
    "start": "2938020",
    "end": "2944510"
  },
  {
    "text": "So it's just all versions\nless than or equal to v. Now it's all versions that are\nancestors of v. Given a mod,",
    "start": "2944510",
    "end": "2950799"
  },
  {
    "text": "we need to know, does this\nmod apply to my version? And now I tell you, I can\ndo that in constant time",
    "start": "2950800",
    "end": "2956560"
  },
  {
    "text": "through magic. I just test these\norder relations. If they hold, then that\nmod applies to my version.",
    "start": "2956560",
    "end": "2964360"
  },
  {
    "text": "So w's the version\nwe're testing. v is some version in the mod.",
    "start": "2964360",
    "end": "2969430"
  },
  {
    "text": "And I want to know, am\ndescendant of that version? If so, the mod applies. And I update what the field is.",
    "start": "2969430",
    "end": "2976630"
  },
  {
    "text": "I can do all pairwise ancestor\nchecks and figure out, what is the most recent\nversion in my ancestor history",
    "start": "2976630",
    "end": "2983200"
  },
  {
    "text": "that modified a given field? That lets me read a\nfield in constant time. Constants are getting\nkind of big at this point,",
    "start": "2983200",
    "end": "2989080"
  },
  {
    "text": "but it can be done.  Clear?",
    "start": "2989080",
    "end": "2994550"
  },
  {
    "text": "A little bit of\na black box here. But now we've gotten\nas far as reading.",
    "start": "2994550",
    "end": "3001920"
  },
  {
    "text": "And we don't need\nto change much else. So this is good news",
    "start": "3001920",
    "end": "3011780"
  },
  {
    "text": "Maybe I'll give you\na bit of a diff. So full persistence,\nfully persistent theorem--",
    "start": "3011780",
    "end": "3026340"
  },
  {
    "text": "done. OK. Same theorem just\nwith full persistence. How do we do it? We store back pointers\nnow for all versions.",
    "start": "3026340",
    "end": "3035542"
  },
  {
    "text": "It's a little bit annoying. But how many mods do we use?",
    "start": "3035542",
    "end": "3040832"
  },
  {
    "text": "There's lots of ways\nto get this to work, but I'm going to\nchange this number to 2 times d plus p plus 1.",
    "start": "3040832",
    "end": "3051702"
  },
  {
    "text": "Wait, what's d? d is the\nnumber of fields here. OK.",
    "start": "3051702",
    "end": "3057140"
  },
  {
    "text": "We said it was\nconstant number fields. I never said what that constant\nis. d for out degree, I guess.",
    "start": "3057140",
    "end": "3063680"
  },
  {
    "text": "So p is in degree, max in\ndegree. d is max out degree.",
    "start": "3063680",
    "end": "3069288"
  },
  {
    "text": "So just slightly more--\nthat main reason for this is because back pointers now\nare treated like everyone else.",
    "start": "3069289",
    "end": "3074450"
  },
  {
    "text": "We have to treat both the out\npointers and the in pointers as basically the same. So instead of p,\nwe have d plus p.",
    "start": "3074450",
    "end": "3079880"
  },
  {
    "text": "And there's a plus\n1 just for safety. It gets my amortization\nto work, hopefully.",
    "start": "3079880",
    "end": "3088330"
  },
  {
    "text": "OK. Not much else-- this\npage is all the same. Mods are still, you give\nversions, fields, values,",
    "start": "3088330",
    "end": "3095829"
  },
  {
    "text": "reading. OK, well, this is no longer\nless than or equal to v. But",
    "start": "3095830",
    "end": "3101030"
  },
  {
    "text": "this is now with a version, sort\nof the nearest version, that's",
    "start": "3101030",
    "end": "3107060"
  },
  {
    "text": "an ancestor of v. That's what we were\njust talking about.",
    "start": "3107060",
    "end": "3112719"
  },
  {
    "text": "So that can be done\nin constant time. Check it for all of\nthem, constant work. OK.",
    "start": "3112719",
    "end": "3118130"
  },
  {
    "text": "That was the first part. ",
    "start": "3118130",
    "end": "3124710"
  },
  {
    "text": "Now we get to the hard\npart, which is modification. This is going to be different. Maybe you I should just erase--",
    "start": "3124710",
    "end": "3130809"
  },
  {
    "text": "yeah, I think I'll\nerase everything, except the first clause. ",
    "start": "3130810",
    "end": "3144270"
  },
  {
    "text": "OK. If a node is not\nfull, we'll just add a mod, just like before. What changes is\nwhen a node is full.",
    "start": "3144270",
    "end": "3151040"
  },
  {
    "text": " Here we have to do something\ncompletely different.",
    "start": "3151040",
    "end": "3158220"
  },
  {
    "text": "Why? Because if we just\nmake a new version of this node that has empty\nmods, this one's still full.",
    "start": "3158220",
    "end": "3165050"
  },
  {
    "text": "And I can keep modifying\nthe same version. This new node that I just erased\nrepresents some new version.",
    "start": "3165050",
    "end": "3172830"
  },
  {
    "text": "But if I keep modifying\nan old version, which I can do in full persistence,\nthis node keeps being full. And I keep paying\npotentially huge cost.",
    "start": "3172830",
    "end": "3180019"
  },
  {
    "text": "If all the nodes were full,\nand when I make this change every node gets\ncopied, and then I make a change to\nthe same version,",
    "start": "3180019",
    "end": "3186180"
  },
  {
    "text": "every node gets copied again. This is going to take\nlinear time per operation. So I can't do the old strategy.",
    "start": "3186180",
    "end": "3191940"
  },
  {
    "text": "I need to somehow make\nthis node less full. This is where we're\ndefinitely not functional.",
    "start": "3191940",
    "end": "3197220"
  },
  {
    "text": "None of this was\nfunctional, but now I'm going to change an old node, not\njust make a new one in a more",
    "start": "3197220",
    "end": "3204240"
  },
  {
    "text": "drastic way. Before I was adding a mod. That's not a\nfunctional operation. Now I'm actually going to remove\nmods from a node to rebalance.",
    "start": "3204240",
    "end": "3213870"
  },
  {
    "text": "So what I'd like to do is\nsplit the node into two halves.",
    "start": "3213870",
    "end": "3223050"
  },
  {
    "text": "OK. So I had some big\nnode that was-- I'll draw it-- completely full.",
    "start": "3223050",
    "end": "3230190"
  },
  {
    "text": "Now I'm going to make two nodes. Here we go. ",
    "start": "3230190",
    "end": "3239020"
  },
  {
    "text": "This one is going\nto be half full. This one's going to\nbe half full of mods.",
    "start": "3239020",
    "end": "3244930"
  },
  {
    "text": "OK. The only question left is, what\ndo I do with all these things? ",
    "start": "3244930",
    "end": "3252150"
  },
  {
    "text": "Basically what I'd like\nto do is have the-- on the one hand, I want\nto have the old node.",
    "start": "3252150",
    "end": "3258720"
  },
  {
    "text": "It's just where it used to be. I've just removed half of\nthe mods, the second half,",
    "start": "3258720",
    "end": "3263820"
  },
  {
    "text": "the later half. What does that mean? I don't know. Figure it out.",
    "start": "3263820",
    "end": "3269319"
  },
  {
    "text": "It's linearized. I haven't thought\ndeeply about that. Now we're going to make a\nnew node with the second half",
    "start": "3269320",
    "end": "3276300"
  },
  {
    "text": "of the mods.  It's more painful\nthan I thought.",
    "start": "3276300",
    "end": "3281640"
  },
  {
    "text": "In reality, these mods represent\na tree of modifications. And what you need to do is\nfind a partition of that tree",
    "start": "3281640",
    "end": "3288450"
  },
  {
    "text": "into two roughly equal halves. You can actually do a\none third, 2/3 split. That's also in a future lecture,\nwhich whose number I forget.",
    "start": "3288450",
    "end": "3297049"
  },
  {
    "text": "So really, you're\nsplitting this tree into two roughly\nbalanced halves. And so this 2 might actually\nneed to change to a 3,",
    "start": "3297049",
    "end": "3303750"
  },
  {
    "text": "but it's a constant. OK. What I want is for\nthis to represent",
    "start": "3303750",
    "end": "3309330"
  },
  {
    "text": "a subtree of versions. Let me draw the picture. So here's a tree of versions\nrepresented by the old mods.",
    "start": "3309330",
    "end": "3315180"
  },
  {
    "text": "I'd like to cut out a\nsubtree rooted at some node. So let's just assume\nfor now this has exactly",
    "start": "3315180",
    "end": "3321540"
  },
  {
    "text": "half the nodes. And this has half the nodes. In reality, I think it\ncan be one third, 2/3.",
    "start": "3321540",
    "end": "3329180"
  },
  {
    "text": "OK. But let's keep it convenient. So I want the new\nnode to represent",
    "start": "3329180",
    "end": "3334750"
  },
  {
    "text": "this subtree and this node\nto represent everything else. This node is as if this\nstuff hasn't happened yet.",
    "start": "3334750",
    "end": "3341650"
  },
  {
    "text": "I mean, so it represents all\nthese old versions that do not, that are not in the subtree. This represents all\nthe latest stuff.",
    "start": "3341650",
    "end": "3347799"
  },
  {
    "text": "So what I'm going to\ndo is like before, I want to apply some\nmods to these fields.",
    "start": "3347800",
    "end": "3354090"
  },
  {
    "text": "And whatever minds were\nrelevant at this point, whatever had been applied, I apply\nthose to the fields here.",
    "start": "3354090",
    "end": "3362610"
  },
  {
    "text": "And so that means I can\nremove all of these mods. I only cared about these ones.",
    "start": "3362610",
    "end": "3369359"
  },
  {
    "text": "Update these fields accordingly. I still have the other mods to\nrepresent all the other changes that could be in that subtree.",
    "start": "3369360",
    "end": "3376030"
  },
  {
    "text": "OK. So we actually split the tree,\nand we apply mods to new nodes.",
    "start": "3376030",
    "end": "3393255"
  },
  {
    "start": "3393255",
    "end": "3398680"
  },
  {
    "text": "Anything else I need to say?  Oh, now we need to\nupdate pointers.",
    "start": "3398680",
    "end": "3404000"
  },
  {
    "text": "That's always the fun part. ",
    "start": "3404000",
    "end": "3409550"
  },
  {
    "text": "Let's go over here. ",
    "start": "3409550",
    "end": "3425300"
  },
  {
    "text": "So old node hasn't moved. But this new node has moved. So for all of these\nversions, I want",
    "start": "3425300",
    "end": "3433880"
  },
  {
    "text": "to change the pointer that\nused to point to old node should now point to new node.",
    "start": "3433880",
    "end": "3440806"
  },
  {
    "text": "In this version, it's fine. It should still\npoint to old node, because this represents\nall those old versions. But for the new version,\nthat version in the subtree,",
    "start": "3440806",
    "end": "3448170"
  },
  {
    "text": "I've got to point here instead. OK. So how many pointers could\nthere be to this node",
    "start": "3448170",
    "end": "3457330"
  },
  {
    "text": "that need to change. That's a tricky part\nin this analysis. Think about it for a while.",
    "start": "3457330",
    "end": "3465200"
  },
  {
    "text": "I mean, in this\nnew node, whatever is pointed to by either here or\nhere in the new node also has",
    "start": "3465200",
    "end": "3470222"
  },
  {
    "text": "a return pointer. All pointers are bidirectional. So we don't really care\nabout whether they're forward or backward. How many pointers\nare there here?",
    "start": "3470222",
    "end": "3476300"
  },
  {
    "text": "Well, there's d here\nand there's p here. But then there's also\nsome additional pointers represented over here.",
    "start": "3476300",
    "end": "3482750"
  },
  {
    "text": "How many? Well, if we assume this\nmagical 50/50 split, there's right now d plus p plus\n1 mods over here, half of them.",
    "start": "3482750",
    "end": "3492920"
  },
  {
    "text": "Each of them might be a pointer\nto some other place, which has a return pointer\nin that version.",
    "start": "3492920",
    "end": "3498715"
  },
  {
    "text": "So number of back pointers\nthat we need to update is going to be this, 2\ntimes d 2 times p plus 1.",
    "start": "3498715",
    "end": "3507150"
  },
  {
    "text": " So recursively update at\nmost 2 times d plus 2 times p",
    "start": "3507150",
    "end": "3521849"
  },
  {
    "text": "plus 1 pointers to the node. ",
    "start": "3521850",
    "end": "3530270"
  },
  {
    "text": "The good news is this is\nreally only half of them or some fraction of them. It used to be--",
    "start": "3530270",
    "end": "3537417"
  },
  {
    "text": "well, there were\nmore pointers before. We don't have to\ndeal with these ones. That's where we're\nsaving, and that's why this amortization works.",
    "start": "3537417",
    "end": "3543622"
  },
  {
    "text": "Let me give you a potential\nfunction that makes this work-- ",
    "start": "3543622",
    "end": "3552950"
  },
  {
    "text": "is minus c times sum of the\nnumber of empty mod slots.",
    "start": "3552950",
    "end": "3563760"
  },
  {
    "text": "It's kind of the same\npotential but before we had this notion of\ndead and alive nodes. Now everything's alive\nbecause everything",
    "start": "3563760",
    "end": "3570450"
  },
  {
    "text": "could change at any moment. So instead, I'm going to\nmeasure how much room I have",
    "start": "3570450",
    "end": "3576030"
  },
  {
    "text": "in each node. Before I had no\nroom in this node. Now I have half the\nspace in both nodes.",
    "start": "3576030",
    "end": "3581760"
  },
  {
    "text": "So that's good news. Whenever we have\nthis recursion, we",
    "start": "3581760",
    "end": "3588300"
  },
  {
    "text": "can charge it to a\npotential decrease.",
    "start": "3588300",
    "end": "3596630"
  },
  {
    "text": "Fee goes down by-- because I have a\nnegative sign here--",
    "start": "3596630",
    "end": "3603720"
  },
  {
    "text": "c times, oh man, 2 times\nd plus p plus 1, I think.",
    "start": "3603720",
    "end": "3613740"
  },
  {
    "text": "Because there's d plus\np plus 1 space here, d plus p plus 1 space here. I mean, we added\none whole new node.",
    "start": "3613740",
    "end": "3618990"
  },
  {
    "text": "And total capacity\nof a node in mods is 2 times d plus p plus 1. So we get that times c.",
    "start": "3618990",
    "end": "3626010"
  },
  {
    "text": "And this is basically\njust enough, because this is 2 times\nd plus 2 times p plus 2.",
    "start": "3626010",
    "end": "3632010"
  },
  {
    "text": "And here we have a plus 1. And so the recursion gets\nannihilated by 2 times d plus",
    "start": "3632010",
    "end": "3639690"
  },
  {
    "text": "2 times p plus 1. And then there's one\nc left over to absorb whatever constant cost there\nwas to do all this other work.",
    "start": "3639690",
    "end": "3647241"
  },
  {
    "text": "So I got the constants\njust to work, except that I cheated and it's\nreally a one third, 2/3 split.",
    "start": "3647241",
    "end": "3654340"
  },
  {
    "text": "So probably all of these\nconstants have to change, such is life. But I think you get the idea.",
    "start": "3654340",
    "end": "3661490"
  },
  {
    "text": "Any questions about\nfull persistence? ",
    "start": "3661490",
    "end": "3667109"
  },
  {
    "text": "This is fun stuff, time travel. Yeah? AUDIENCE: So in the first\nhalf of the thing where",
    "start": "3667110",
    "end": "3674630"
  },
  {
    "text": "the if, there's room\nyou can put it in. ERIK DEMAINE: Right. AUDIENCE: I have a\nquestion about how we represent the version. Because before when we said\nrestore now [INAUDIBLE].",
    "start": "3674630",
    "end": "3683015"
  },
  {
    "text": "It made more sense if now was\nlike a timestamp or something. ERIK DEMAINE: OK. Right, so how do we represent a\nversion even here or anywhere?",
    "start": "3683016",
    "end": "3691470"
  },
  {
    "text": "When we do a modification, an\nupdate, in the data structure, we want to return\nthe new version. Basically, we're going\nto actually store",
    "start": "3691470",
    "end": "3699809"
  },
  {
    "text": "the DAG of versions. And a version is going to\nbe represented by a pointer into this DAG. One of the nodes in this\nDAG becomes a version.",
    "start": "3699810",
    "end": "3707339"
  },
  {
    "text": "Every node in this DAG is\ngoing to store a pointer to the corresponding b character\nand a corresponding e character",
    "start": "3707340",
    "end": "3713640"
  },
  {
    "text": "in this data\nstructure, which then lets you do anything you want. Then you can query\nagainst that version,",
    "start": "3713640",
    "end": "3719590"
  },
  {
    "text": "whether it's an ancestor\nof another version. So yeah, I didn't mention that. Versions are nodes in here. Nodes in here have pointers\nto the b's and e's.",
    "start": "3719590",
    "end": "3726647"
  },
  {
    "text": "And vice versa, the b's\nand e's have pointers back to the corresponding\nversion node. And then you can keep\ntrack of everything.",
    "start": "3726647",
    "end": "3732480"
  },
  {
    "text": "Good question. Yeah? AUDIENCE: [INAUDIBLE] question. Remind me what d is in this. ERIK DEMAINE: Oh, d was\nthe maximum out degree.",
    "start": "3732480",
    "end": "3739108"
  },
  {
    "text": "It's the number of fields in\na node, as defined right here.",
    "start": "3739108",
    "end": "3746970"
  },
  {
    "text": "Other questions? Whew. OK, a little breather. That was partial persistence,\nfull persistence.",
    "start": "3746970",
    "end": "3753450"
  },
  {
    "text": "This is, unfortunately, the\nend of the really good results. As long as we have\nconstant degree nodes,",
    "start": "3753450",
    "end": "3758650"
  },
  {
    "text": "in and out degree,\nwe can do all. We can do for\npersistence for free.",
    "start": "3758650",
    "end": "3764830"
  },
  {
    "text": "Obviously there are practical\nconstants involved here. But in theory, you\ncan do this perfectly.",
    "start": "3764830",
    "end": "3773170"
  },
  {
    "text": "Before we go on to\nconfluence, there is one positive result,\nwhich is what if you",
    "start": "3773170",
    "end": "3778210"
  },
  {
    "text": "don't like amortize bounds. There are various reasons\namortize bounds might not be good. Maybe you really care\nabout every operation",
    "start": "3778210",
    "end": "3784861"
  },
  {
    "text": "being no slower than it was\nexcept by a constant factor. We're amortizing here, so some\noperations get really slow.",
    "start": "3784861",
    "end": "3791500"
  },
  {
    "text": "But the others are all\nfast to compensate. You can deamortize, it's called.",
    "start": "3791500",
    "end": "3799540"
  },
  {
    "text": " You can get constant\nworst case slowdown",
    "start": "3799540",
    "end": "3810280"
  },
  {
    "text": "for partial persistence. ",
    "start": "3810280",
    "end": "3816770"
  },
  {
    "text": "This is a result of Garret\nBrodle from the late '90s, '97.",
    "start": "3816770",
    "end": "3824260"
  },
  {
    "text": "For full persistence--\nso it's an open problem. I don't know if people\nhave worked on that. ",
    "start": "3824260",
    "end": "3835801"
  },
  {
    "text": "All right. So some, mostly good results. Let's move on to confluent\npersistence where things",
    "start": "3835801",
    "end": "3841640"
  },
  {
    "text": "get a lot more challenging. ",
    "start": "3841640",
    "end": "3857511"
  },
  {
    "text": "Lots of things go out the window\nwith confluent persistence. In particular, your\nversions are now a DAG.",
    "start": "3857511",
    "end": "3863520"
  },
  {
    "text": "It's a lot harder\nto linearize a DAG. Trees are not that\nfar from pads.",
    "start": "3863520",
    "end": "3868980"
  },
  {
    "text": "But DAGs are quite far\nfrom pads, unfortunately. But that's not all\nthat goes wrong.",
    "start": "3868980",
    "end": "3875130"
  },
  {
    "start": "3875130",
    "end": "3884660"
  },
  {
    "text": "Let me first tell you the\nkind of end effect as a user.",
    "start": "3884660",
    "end": "3890059"
  },
  {
    "text": "Imagine you have\na data structure.  Think of it as a\nlist, I guess, which",
    "start": "3890060",
    "end": "3897500"
  },
  {
    "text": "is a list of characters\nin your document. You're using vi or Word,\nyour favorite, whatever.",
    "start": "3897500",
    "end": "3903410"
  },
  {
    "text": "It's a text editor. You've got a string of words. And now you like to do\nthings like copy and paste.",
    "start": "3903410",
    "end": "3909785"
  },
  {
    "text": "It's a nice operation. So you select an interval of\nthe string and you copy it.",
    "start": "3909785",
    "end": "3916340"
  },
  {
    "text": "And then you paste\nit somewhere else. So now you've got two\ncopies of that string.",
    "start": "3916340",
    "end": "3921950"
  },
  {
    "text": "This is, in some\nsense, what you might call a confluent\noperation, because--",
    "start": "3921950",
    "end": "3927960"
  },
  {
    "text": "yeah, maybe a cleaner way to\nthink of it is the following. You have your string. Now I have an operation,\nwhich is split it.",
    "start": "3927960",
    "end": "3933950"
  },
  {
    "text": "So now I have two strings. OK. And now I have an operation,\nwhich is split it. Now I have three strings.",
    "start": "3933950",
    "end": "3940770"
  },
  {
    "text": "OK. Now I have an operation\nwhich is concatenate. So I can, for\nexample, reconstruct",
    "start": "3940770",
    "end": "3947330"
  },
  {
    "text": "the original string-- actually,\nI have the original string. No biggie. Let's say-- because\nI have all versions.",
    "start": "3947330",
    "end": "3954470"
  },
  {
    "text": "I never lose them. So now instead, I'm going to\ncut the string here, let's say. So now I have this and this.",
    "start": "3954470",
    "end": "3963710"
  },
  {
    "text": "And now I can do\nthings like concatenate from here to here to here.",
    "start": "3963710",
    "end": "3970010"
  },
  {
    "text": "And I will get this\nplus this plus this.",
    "start": "3970010",
    "end": "3976801"
  },
  {
    "text": "OK. This guy moved here. So that's a copy/paste\noperation with a constant number of splits and concatenates.",
    "start": "3976801",
    "end": "3982100"
  },
  {
    "text": "I could also do cut and paste. With confluence, I can\ndo crazy cuts and pastes in all sorts of ways.",
    "start": "3982100",
    "end": "3988950"
  },
  {
    "text": "So what? Well, the so what\nis I can actually double the size of\nmy data structure",
    "start": "3988950",
    "end": "3993990"
  },
  {
    "text": "in a constant number\nof operations. I can take, for example,\nthe entire string and concatenate it to itself.",
    "start": "3993990",
    "end": "4000031"
  },
  {
    "text": "That will double the\nnumber of characters, number of elements in there. I can do that again\nand again and again.",
    "start": "4000031",
    "end": "4005900"
  },
  {
    "text": "So in u updates,\nI can potentially",
    "start": "4005900",
    "end": "4011380"
  },
  {
    "text": "get a data structure\nsize 2 to the u. ",
    "start": "4011380",
    "end": "4017770"
  },
  {
    "text": "Kind of nifty. I think this is why\nconfluence is cool. It's also why it's hard. So not a big surprise.",
    "start": "4017770",
    "end": "4023900"
  },
  {
    "text": "But, here we go. In that case, the version DAG,\nfor reference, looks like this.",
    "start": "4023900",
    "end": "4033490"
  },
  {
    "text": "You're taking the same\nversion, combining it. So here I'm assuming I have\na concatenate operation.",
    "start": "4033490",
    "end": "4040460"
  },
  {
    "text": "And so the effect here,\nevery time I do this, I double the size. ",
    "start": "4040460",
    "end": "4064210"
  },
  {
    "text": "All right. What do I want to say about\nconfluent persistence? All right. Let me start with the\nmost general result, which",
    "start": "4064210",
    "end": "4073200"
  },
  {
    "text": "is by Fiat and Kaplan in 2003.",
    "start": "4073200",
    "end": "4084339"
  },
  {
    "text": "They define a notion called\neffective depth of a version. Let me just write it down.",
    "start": "4084340",
    "end": "4089900"
  },
  {
    "start": "4089900",
    "end": "4101179"
  },
  {
    "text": "It's kind of like\nif you took this DAG and expanded it out to be a\ntree of all possible paths.",
    "start": "4101180",
    "end": "4110112"
  },
  {
    "text": "Instead of point\nto the same node, you could just\nduplicate that node and then have pointers\nleft and right.",
    "start": "4110113",
    "end": "4115259"
  },
  {
    "text": "OK. So if I did that, of course,\nthis size grows exponentially. It explicitly represents the\nsize of my data structure.",
    "start": "4115260",
    "end": "4121309"
  },
  {
    "text": "At the bottom, if\nI have u things, I'm going to have 2 to the\nu leaves at the bottom. But then I can easily\nmeasure the number of paths",
    "start": "4121310",
    "end": "4129080"
  },
  {
    "text": "from the root to\nthe same version. At the bottom, I still\nlabel it, oh, those are all v. They're all the\nsame version down there.",
    "start": "4129080",
    "end": "4134630"
  },
  {
    "text": "So exponential number\nof paths, if I take log, I get what I call\neffective depth. It's like if you somehow\ncould rebalance that tree,",
    "start": "4134630",
    "end": "4142250"
  },
  {
    "text": "this is the best you\ncould hope to do. It's not really a lower bound.",
    "start": "4142250",
    "end": "4147270"
  },
  {
    "text": "But it's a number. It's a thing. OK. Then the result they achieve\nis that the overhead is",
    "start": "4147270",
    "end": "4157370"
  },
  {
    "text": "log the number of\nupdates plus-- this is a multiplicative overhead,\nso you take your running time. You multiply it by this.",
    "start": "4157370",
    "end": "4165979"
  },
  {
    "text": "And this is a time\nand a space overhead. ",
    "start": "4165979",
    "end": "4171528"
  },
  {
    "text": "So maximum effective depth\nof all versions, maybe even sum of effective depths, but\nwe'll just say max to be safe.",
    "start": "4171529",
    "end": "4179099"
  },
  {
    "text": "Sorry-- sum over\nall the operations. This is per operation. You pay basically\nthe effective depth",
    "start": "4179100",
    "end": "4184670"
  },
  {
    "text": "of that operation as a factor. Now, the annoying thing is if\nyou have this kind of set up",
    "start": "4184670",
    "end": "4191329"
  },
  {
    "text": "where the size\ngrew exponentially, then number of paths\nis exponential.",
    "start": "4191330",
    "end": "4196490"
  },
  {
    "text": "Log of the number of\npaths is linear in u. And so this factor could be\nas much as u, linear slowdown.",
    "start": "4196490",
    "end": "4206420"
  },
  {
    "text": "Now, Fiat and Kaplan argue\nlinear slowdown is not that bad, because if you weren't\neven persistent, if you did",
    "start": "4206420",
    "end": "4213440"
  },
  {
    "text": "this in the naive way of\njust recopying the data, you were actually spending\nexponential time to build",
    "start": "4213440",
    "end": "4221579"
  },
  {
    "text": "the final data structure. It has exponential size. Just to represent it explicitly\nrequires exponential time,",
    "start": "4221579",
    "end": "4226800"
  },
  {
    "text": "so losing a linear\nfactor to do u operations and now u squared time\ninstead of 2 to the u. So it's a big\nimprovement to do this.",
    "start": "4226800",
    "end": "4235190"
  },
  {
    "text": "The downside of this approach is\nthat even if you have a version",
    "start": "4235190",
    "end": "4240440"
  },
  {
    "text": "DAG that looks like this,\neven if the size of the data structure is staying\nnormal, staying linear, so",
    "start": "4240440",
    "end": "4246402"
  },
  {
    "text": "this potential, you could\nbe doubling the size. But we don't know what\nthis merge operation is. Maybe it just throws\naway one of the versions",
    "start": "4246402",
    "end": "4251794"
  },
  {
    "text": "or does something-- somehow takes half\nthe nodes from one side, half the nodes from\nthe other side maybe.",
    "start": "4251794",
    "end": "4257188"
  },
  {
    "text": "These operations\ndo preserve size. Then there's no great reason why\nit should be a linear slowdown,",
    "start": "4257188",
    "end": "4262520"
  },
  {
    "text": "but it is. OK? So it's all right but not great.",
    "start": "4262520",
    "end": "4267650"
  },
  {
    "text": " And it's the best\ngeneral result we know.",
    "start": "4267650",
    "end": "4273560"
  },
  {
    "text": "They also prove a lower bound. ",
    "start": "4273560",
    "end": "4281420"
  },
  {
    "text": "So lower bound is some effect\nof depth, total bits of space.",
    "start": "4281420",
    "end": "4290344"
  },
  {
    "start": "4290345",
    "end": "4297230"
  },
  {
    "text": "OK. What does this mean? So even if this\nis not happening, the number of bits\nof space you need",
    "start": "4297230",
    "end": "4304150"
  },
  {
    "text": "in the worst case--\nthis does not apply to every data structure. That's one catch.",
    "start": "4304150",
    "end": "4309790"
  },
  {
    "text": "They give a specific\ndata structure where you need this much space. So it's similar to\nthis kind of picture.",
    "start": "4309790",
    "end": "4317050"
  },
  {
    "text": "We'll go into the details. And you need this much space. Now, this is kind of\nbad, because if there's",
    "start": "4317050",
    "end": "4322719"
  },
  {
    "text": "u operations, and each of these\nis u, that's u squared space. So we actually need a\nfactor u blow up in space.",
    "start": "4322720",
    "end": "4329395"
  },
  {
    "text": "It looks like. But to be more precise,\nwhat this means is that you need omega e of\nv space, and therefore",
    "start": "4329395",
    "end": "4337270"
  },
  {
    "text": "time overhead per update, if--",
    "start": "4337270",
    "end": "4347830"
  },
  {
    "text": "this is not written\nin the paper-- queries are free. ",
    "start": "4347830",
    "end": "4355300"
  },
  {
    "text": "Implicit here, they just want\nto slow down and increase space",
    "start": "4355300",
    "end": "4360400"
  },
  {
    "text": "for the updates you do,\nwhich is pretty natural. Normally you think of queries\nas not increasing space.",
    "start": "4360400",
    "end": "4366870"
  },
  {
    "text": "But in order to construct\nthis lower bound, they actually do\nthis many queries.",
    "start": "4366870",
    "end": "4372360"
  },
  {
    "text": "So they do e of v queries\nand then one update. And they say, oh well, space\nhad to go up by an extra e of v.",
    "start": "4372360",
    "end": "4379409"
  },
  {
    "text": "So if you only charge\nupdates for the space, then yes, you have\nto lose potentially a linear factor, this effect\nof death, potentially u.",
    "start": "4379410",
    "end": "4387780"
  },
  {
    "text": "But if you also\ncharge the queries, it's still constant\nin their example.",
    "start": "4387780",
    "end": "4393270"
  },
  {
    "text": "So open question, for\nconfluent persistence, can you achieve\nconstant everything?",
    "start": "4393270",
    "end": "4401130"
  },
  {
    "text": "Constant time and\nspace overheads,",
    "start": "4401130",
    "end": "4407159"
  },
  {
    "text": "multiplicative\nfactor per operation,",
    "start": "4407160",
    "end": "4413610"
  },
  {
    "text": "both updates and queries. So if you charge the\nqueries, potentially you could get constant everything.",
    "start": "4413610",
    "end": "4418980"
  },
  {
    "text": "This is a relatively\nnew realization.  And no one knows\nhow to do this yet.",
    "start": "4418980",
    "end": "4427325"
  },
  {
    "text": "Nice challenge. I think maybe we'll work on that\nin our first problem session. I would like to. ",
    "start": "4427325",
    "end": "4433599"
  },
  {
    "text": "Questions about that result? I'm not going to\nprove the result. But it is a fancy\nrebalancing of those kinds",
    "start": "4433600",
    "end": "4439540"
  },
  {
    "text": "of pictures to get this log. ",
    "start": "4439540",
    "end": "4450265"
  },
  {
    "text": "There are other results\nI'd like to tell you about. ",
    "start": "4450266",
    "end": "4472630"
  },
  {
    "text": "So brand new result-- that was from 2003. This is from 2012--",
    "start": "4472630",
    "end": "4478300"
  },
  {
    "text": "no, '11, '11, sorry. It's SOTO, which is in January,\nso it's a little confusing.",
    "start": "4478300",
    "end": "4487480"
  },
  {
    "text": "Is it '11? Maybe '12. Actually now I'm not sure. It's February already, right?",
    "start": "4487480",
    "end": "4494750"
  },
  {
    "text": "A January, either this\nyear or last year. ",
    "start": "4494750",
    "end": "4500310"
  },
  {
    "text": "It's not as general\na transformation. It's only going to hold in\nwhat's called a disjoint case.",
    "start": "4500310",
    "end": "4505330"
  },
  {
    "text": "But it gets a very good bound-- not quite constant,\nbut logarithmic. OK, logarithmic\nwould also be nice.",
    "start": "4505330",
    "end": "4512420"
  },
  {
    "text": "Or log, log n, whatever n is. Pick your favorite n,\nnumber of operations, say.",
    "start": "4512420",
    "end": "4522450"
  },
  {
    "text": "OK.  If you assume that confluent\noperations are performed only",
    "start": "4522450",
    "end": "4539830"
  },
  {
    "text": "on two versions with\nno shared nodes--",
    "start": "4539830",
    "end": "4546070"
  },
  {
    "text": " OK, this would be a way to\nforbid this kind of behavior",
    "start": "4546070",
    "end": "4553869"
  },
  {
    "text": "where I concatenate the\ndata structure with itself. All the nodes are common. If I guarantee that maybe I, you\nknow, slice this up, slice it,",
    "start": "4553870",
    "end": "4561840"
  },
  {
    "text": "dice it, wherever, and\nthen re-emerge them in some other order, but\nI never use two copies of the same piece, that\nwould be a valid confluent",
    "start": "4561840",
    "end": "4570130"
  },
  {
    "text": "operation over here. This is quite a\nstrong restriction that you're not allowed.",
    "start": "4570130",
    "end": "4576580"
  },
  {
    "text": "If you try to, who\nknows what happens. Behavior's undefined. So won't tell you,\noh, those two versions",
    "start": "4576580",
    "end": "4581830"
  },
  {
    "text": "have this node in common. You've got to make\na second copy of it. So somehow you have to guarantee\nthat control and operations",
    "start": "4581830",
    "end": "4587099"
  },
  {
    "text": "never overlap. But they can be reordered. ",
    "start": "4587099",
    "end": "4593739"
  },
  {
    "text": "Then you can get\norder log n overhead.",
    "start": "4593740",
    "end": "4599500"
  },
  {
    "text": "n is the number of operations. ",
    "start": "4599500",
    "end": "4605390"
  },
  {
    "text": "I have a sketch\nof a proof of this but not very much\ntime to talk about it. All right. Let me give you a quick picture.",
    "start": "4605390",
    "end": "4611570"
  },
  {
    "text": "In general, the\nversions form a DAG. But if you make this assumption,\nand you look at a single node,",
    "start": "4611570",
    "end": "4620950"
  },
  {
    "text": "and look at all the versions\nwhere that node appears, that is a tree. Because you're not allowed\nto remerge versions",
    "start": "4620950",
    "end": "4627370"
  },
  {
    "text": "that have the same node. So while the big\npicture is a DAG, the small picture of a\nsingle guy is some tree.",
    "start": "4627370",
    "end": "4635090"
  },
  {
    "text": " I'm drawing all\nthese wiggly lines because there are all\nthese versions where the node isn't changing.",
    "start": "4635090",
    "end": "4641560"
  },
  {
    "text": "This is the entire version DAG. And then some of these nodes-- some of these versions,\nI should say--",
    "start": "4641560",
    "end": "4649000"
  },
  {
    "text": "that node that we're\nthinking about changes. OK, whenever it\nbranches, it's probably because the actual\nnode changed, maybe.",
    "start": "4649000",
    "end": "4656409"
  },
  {
    "text": "I don't know. Anyway there are some dots\nhere where the version changed, some of the leaves,\nmaybe, that changed.",
    "start": "4656410",
    "end": "4661960"
  },
  {
    "text": "Maybe some of them haven't yet. In fact, let's see.",
    "start": "4661960",
    "end": "4668350"
  },
  {
    "text": "Here where it's change, it could\nbe that we destroyed the node. Maybe it's gone from the\nactual data structure.",
    "start": "4668350",
    "end": "4674560"
  },
  {
    "text": "But there still may\nbe versions down here. It's not really a tree. It's a whole DAG of\nstuff down there. So that's kind of ugly.",
    "start": "4674560",
    "end": "4681400"
  },
  {
    "text": "Where never the\nnode still exists, I guess that is an\nactual leaf of the DAG. So those are OK.",
    "start": "4681400",
    "end": "4686650"
  },
  {
    "text": "But as soon as I maybe\ndelete that node, then there can be a\nwhole subtree down there. OK.",
    "start": "4686650",
    "end": "4692110"
  },
  {
    "text": "So now if you look at\nan arbitrary version, so what we're thinking about\nis how to implement reading,",
    "start": "4692110",
    "end": "4697580"
  },
  {
    "text": "let's say. Reading and writing are\nmore or less the same. I give you a version. I give you a node, and\nI give you a field.",
    "start": "4697580",
    "end": "4703719"
  },
  {
    "text": "I want to know, what is the\nvalue of that field, that node, that version? So now where could\na version fall?",
    "start": "4703720",
    "end": "4710014"
  },
  {
    "text": "Well it has to be\nin this subtree. Because the node has to exist. ",
    "start": "4710014",
    "end": "4716950"
  },
  {
    "text": "And then it's maybe a pointer. A pointer could be to\nanother node, which",
    "start": "4716950",
    "end": "4722830"
  },
  {
    "text": "also has this kind of picture. They could be overlapping trees. In general, there\nare three cases.",
    "start": "4722830",
    "end": "4728140"
  },
  {
    "text": "Either you're lucky, and the\nversion you're talking about is a version where\nthe node was changed.",
    "start": "4728140",
    "end": "4733960"
  },
  {
    "text": "In that case, the data is\njust stored right there. That's easy.",
    "start": "4733960",
    "end": "4739125"
  },
  {
    "text": "So you could just say, oh,\nhow did the node change? Oh, that's what the field is. OK, follow the pointer.",
    "start": "4739125",
    "end": "4745190"
  },
  {
    "text": "A slightly harder\ncase it's a version in between two such changes. And maybe these are not updates.",
    "start": "4745190",
    "end": "4751659"
  },
  {
    "text": "So I sort of want to know, what\nwas the previous version where",
    "start": "4751660",
    "end": "4757330"
  },
  {
    "text": "this node changed\nin constant time? It can be done.",
    "start": "4757330",
    "end": "4762620"
  },
  {
    "text": "Not constant time,\nactually, logarithmic time, using a data structure\ncalled link-cut trees,",
    "start": "4762620",
    "end": "4768120"
  },
  {
    "text": "another fun black\nbox for now, which we will cover in lecture\n19, far in the future.",
    "start": "4768120",
    "end": "4776171"
  },
  {
    "text": "OK.  Well, that's one case. There's also the version\nwhere maybe a version",
    "start": "4776171",
    "end": "4783190"
  },
  {
    "text": "is down here in a subtree. I guess then the\nnode didn't exist.",
    "start": "4783190",
    "end": "4788340"
  },
  {
    "text": "Well, all these\nthings can happen. And that's even harder. It's messy.",
    "start": "4788340",
    "end": "4793360"
  },
  {
    "text": "They use another trick, which\nis called fractional cascading,",
    "start": "4793360",
    "end": "4799719"
  },
  {
    "text": "which I'm not even going to\ntry to describe what it means. But it's got a very cool name. Because we'll be\ncovering it in lecture 3.",
    "start": "4799720",
    "end": "4806080"
  },
  {
    "text": "So stay tuned for that. I'm not going to say how\nit applies to this setting, but it's a necessary\nstep in here.",
    "start": "4806080",
    "end": "4813330"
  },
  {
    "text": "In the remaining\nzero minutes, let me tell you a little bit about\nfunctional data structures. [LAUGHTER]",
    "start": "4813330",
    "end": "4820005"
  },
  {
    "text": " Beauty of time travel.  Functional-- I just\nwant to give you",
    "start": "4820005",
    "end": "4831130"
  },
  {
    "text": "some examples of things that\ncan be done functionally. There's a whole book about\nfunctional data structures by Okasaki.",
    "start": "4831130",
    "end": "4836699"
  },
  {
    "text": "It's pretty cool. A simple example\nis balanced BSTs.",
    "start": "4836700",
    "end": "4842320"
  },
  {
    "text": "So if you just want to get\nlog n time for everything, you can do that functionally. It's actually really easy. You pick your favorite balance\nBST, like red black trees.",
    "start": "4842320",
    "end": "4848920"
  },
  {
    "text": "You implement it top down so you\nnever follow parent pointers. So you don't need\nparent pointers. So then as you make changes\ndown the tree, you just copy.",
    "start": "4848920",
    "end": "4857710"
  },
  {
    "text": "It's called path copying. Whenever you're about\nto make a change, make a copy of that node. So you end up copying all\nthe change nodes and all",
    "start": "4857710",
    "end": "4865449"
  },
  {
    "text": "their ancestors. There's only log n of them,\nso it takes log n time. Clear?",
    "start": "4865450",
    "end": "4870500"
  },
  {
    "text": "Easy. It's a nice technique. Sometimes path copying\nis very useful. Like link-cut\ntrees, for example,",
    "start": "4870500",
    "end": "4876170"
  },
  {
    "text": "can be made functional. We don't know what they are,\nbut they're basically a BST. And you can make\nthem functional.",
    "start": "4876170",
    "end": "4881280"
  },
  {
    "text": "We use that in a paper. All right. Deques. These are doubly ended queues.",
    "start": "4881280",
    "end": "4887800"
  },
  {
    "text": "So it's like a stack and\na queue and everything. You can insert and delete from\nthe beginning and the end.",
    "start": "4887800",
    "end": "4892900"
  },
  {
    "text": "People start to know\nwhat these are now, because Python calls him that. But you can also\ndo concatenation",
    "start": "4892900",
    "end": "4901090"
  },
  {
    "text": "with deques in constant\ntime per operation. This is cool. Deques are not very\nhard to make functional.",
    "start": "4901090",
    "end": "4906219"
  },
  {
    "text": "But you can do deques and\nyou can concatenate them like we were doing in the figure\nthat's right behind this board.",
    "start": "4906220",
    "end": "4911980"
  },
  {
    "text": "Constant time split\nis a little harder. That's actually one\nof my open problems. Can you do lists with split and\nconcatenate in constant time--",
    "start": "4911980",
    "end": "4921580"
  },
  {
    "text": "functionally or confluently,\npersistently, or whatever? Another example-- oh, you\ncan do a mix of the two.",
    "start": "4921580",
    "end": "4928580"
  },
  {
    "text": "You can get log n search in\nconstant time deque operations, is you can do tries.",
    "start": "4928580",
    "end": "4934870"
  },
  {
    "text": "So a try is a tree\nwith a fixed topology. Think of it as a directory tree.",
    "start": "4934870",
    "end": "4940010"
  },
  {
    "text": "So maybe you're\nusing Subversion. Subversion has time\ntravel operations. You can copy an entire\nsubtree from one version",
    "start": "4940010",
    "end": "4946240"
  },
  {
    "text": "and stick it into a new\nversion, another version. So you get a version DAG.",
    "start": "4946240",
    "end": "4952685"
  },
  {
    "text": "It's a confluently\npersistent data structure-- not implemented optimally,\nbecause we don't necessarily know how.",
    "start": "4952685",
    "end": "4958239"
  },
  {
    "text": "But there is one paper. This actually came from the open\nproblem section of this class",
    "start": "4958240",
    "end": "4963910"
  },
  {
    "text": "four years ago, I think. It's with Eric Price\nand Stefan Langerman.",
    "start": "4963910",
    "end": "4969520"
  },
  {
    "text": "You can get very good results. I won't write them down\nbecause it takes a while. Basically log the degree\nof the nodes factor",
    "start": "4969520",
    "end": "4976450"
  },
  {
    "text": "and get functional, and\nyou can be even fancier and get slightly better\nbounds like log log the degree",
    "start": "4976450",
    "end": "4982480"
  },
  {
    "text": "and get confluently persistent\nwith various tricks, including using all of\nthese data structures.",
    "start": "4982480",
    "end": "4987530"
  },
  {
    "text": "So if you want to implement\nsubversion optimally, that is known how to be done but\nhasn't actually been done yet.",
    "start": "4987530",
    "end": "4994389"
  },
  {
    "text": "Because there are those\npesky constant factors. I think that's all.",
    "start": "4994390",
    "end": "4999670"
  },
  {
    "text": "What is known about functional\nis there's a log n separation. You can be log n\naway from the best.",
    "start": "4999670",
    "end": "5006889"
  },
  {
    "text": "That's the worst\nseparation known, between functional and just\na regular old data structure.",
    "start": "5006890",
    "end": "5013012"
  },
  {
    "text": "It'd be nice to improve that. Lots of open problems here. Maybe we'll work\non them next time.",
    "start": "5013012",
    "end": "5018140"
  },
  {
    "start": "5018140",
    "end": "5023380"
  }
]