[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high-quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: All right. Today, we resume our theme of\nmemory hierarchy efficient data",
    "start": "18450",
    "end": "26480"
  },
  {
    "text": "structures. And last time, we saw\ncache-oblivious b-trees, which achieve log base B\nof N for all operations--",
    "start": "26480",
    "end": "37400"
  },
  {
    "text": " insert, delete, search.",
    "start": "37400",
    "end": "42410"
  },
  {
    "text": " And the cool part is\nthat we could do that",
    "start": "42410",
    "end": "48110"
  },
  {
    "text": "without knowing what B was. And it was basically\na binary search tree",
    "start": "48110",
    "end": "55160"
  },
  {
    "text": "stored in a funny order,\nthis van Emde Boas order, with an ordered file\non the bottom, which",
    "start": "55160",
    "end": "61040"
  },
  {
    "text": "we left as a black box. And today, we're\ngoing to see how to actually do ordered files-- in log squared N, data\nmoves per insert and delete.",
    "start": "61040",
    "end": "71960"
  },
  {
    "text": "And then as a little\ndiversion, we'll see a closer related\nproblem to this is called list labeling,\nwhich we needed in Lecture 1",
    "start": "71960",
    "end": "79160"
  },
  {
    "text": "and left it as a black\nbox for full persistence. We had this version tree\nwith full persistence,",
    "start": "79160",
    "end": "86030"
  },
  {
    "text": "and we needed to linearize\nthat version tree into a bunch of numbers\nso that we could then",
    "start": "86030",
    "end": "92810"
  },
  {
    "text": "compare whether one version\nwas an ancestor of another. And for that, we needed to be\nable to store a linked list,",
    "start": "92810",
    "end": "98240"
  },
  {
    "text": "and insert and delete\nin the linked list, and be able to query, who is\nthis node in the linked list,",
    "start": "98240",
    "end": "104930"
  },
  {
    "text": "precede this node\nin the linked list in constant time per operation. So we'll also do that\ntoday because it's time.",
    "start": "104930",
    "end": "114109"
  },
  {
    "text": "And then we're going to\ndo a completely different cache-oblivious data structure. That's interesting, mainly in\nthe way that it adapts to M,",
    "start": "114109",
    "end": "121670"
  },
  {
    "text": "not just B. So remember, B was\nthe size of a memory block. When we fetch\nsomething from memory,",
    "start": "121670",
    "end": "127850"
  },
  {
    "text": "we get the entire block of size\nB. M was the size of the cache. And so there were M over B\nblocks in the cache of size",
    "start": "127850",
    "end": "134810"
  },
  {
    "text": "B. So that's what\nwe'll do today.",
    "start": "134810",
    "end": "140180"
  },
  {
    "text": "I'm also going to need a claim-- ",
    "start": "140180",
    "end": "147332"
  },
  {
    "text": "which we won't prove here-- that you can sort\ncache-obliviously in N",
    "start": "147332",
    "end": "153270"
  },
  {
    "text": "over B log base N\nover B of N over B. So I'm going to use this\nas a black box today.",
    "start": "153270",
    "end": "159120"
  },
  {
    "text": "And we're not going to\nfill it in because it's not a data structure, and it's\na data structures class. To give you some feeling for\nwhy this is the right bound",
    "start": "159120",
    "end": "166340"
  },
  {
    "text": "for sorting, if\nyou know M and B, then the answer is M\nover B way mergesort.",
    "start": "166340",
    "end": "175040"
  },
  {
    "start": "175040",
    "end": "181480"
  },
  {
    "text": "So you all know\nbinary mergesort, where you split into two parts. If you split into M\nover B parts and then do",
    "start": "181480",
    "end": "188160"
  },
  {
    "text": "an M over B way merge,\nthat's exactly what a cache can handle. It can read one block\nfrom each of the lists",
    "start": "188160",
    "end": "195319"
  },
  {
    "text": "that it's trying to merge. It has just enough\ncache blocks for that.",
    "start": "195320",
    "end": "201000"
  },
  {
    "text": "And then you do the merge\nblock by block, load new blocks as necessary. That will give you\na linear time merge.",
    "start": "201000",
    "end": "206790"
  },
  {
    "text": "And so you'll get N over\nB times log base M over B. And it turns out the right\nthing in here is N over B or N",
    "start": "206790",
    "end": "212460"
  },
  {
    "text": "is basically the same,\nbecause it's inside the log. It's not a big deal.",
    "start": "212460",
    "end": "217530"
  },
  {
    "text": "So external memory wise,\nthat's how you do it. You can do this\ncache-obliviously in a similar way to--",
    "start": "217530",
    "end": "223125"
  },
  {
    "text": " roughly speaking, in a\nsimilar way to the way we do b-trees,\nwhere you're binary",
    "start": "223125",
    "end": "230070"
  },
  {
    "text": "searching in the\nnumber of ways you should divide your array into.",
    "start": "230070",
    "end": "237401"
  },
  {
    "text": "I'm not going to get\ninto details on that. We'll focus on\ncache-oblivious priority queues, which do a similar kind\nof thing, but get it a dynamic.",
    "start": "237401",
    "end": "246131"
  },
  {
    "text": "All right. But before we go there, let's\ndo ordered file maintenance. ",
    "start": "246131",
    "end": "260070"
  },
  {
    "text": "So let me first remind\nyou of the problem. We want to store N\nitems in a file, which",
    "start": "260070",
    "end": "272520"
  },
  {
    "text": "think of as an array, size\norder N. This constant's",
    "start": "272520",
    "end": "281039"
  },
  {
    "text": "bigger than 1, with\nconstant-sized gaps.",
    "start": "281040",
    "end": "286170"
  },
  {
    "start": "286170",
    "end": "293970"
  },
  {
    "text": "And then-- I should\nsay in specified order,",
    "start": "293970",
    "end": "306030"
  },
  {
    "text": "subject to inserting and\ndeleting items in that order. ",
    "start": "306030",
    "end": "329419"
  },
  {
    "text": "So this was the picture. We have an array.",
    "start": "329420",
    "end": "335069"
  },
  {
    "text": " We get to store some\nobjects in the array",
    "start": "335070",
    "end": "342680"
  },
  {
    "text": "and have these blank\ncells in between. But each of these gaps\nhas constant size. ",
    "start": "342680",
    "end": "352960"
  },
  {
    "text": "Maybe these data items\nare sorted, maybe not. ",
    "start": "352960",
    "end": "358540"
  },
  {
    "text": "And then we're able\nto say things like, OK, insert a new\nitem 8 right after 7.",
    "start": "358540",
    "end": "365550"
  },
  {
    "text": "And so then you'd\nlike to do that. Then you'd also, then, like to\nsay OK, now insert new item 9,",
    "start": "365550",
    "end": "372910"
  },
  {
    "text": "here. And then this guy will\nmaybe get shifted over. So 12 is over here.",
    "start": "372910",
    "end": "379570"
  },
  {
    "text": "This becomes blank, and then\nyou can fit the 9, and so on. You want to be able to do\ninsertions and deletions like that quickly.",
    "start": "379570",
    "end": "385810"
  },
  {
    "start": "385810",
    "end": "393970"
  },
  {
    "text": "And quickly, here,\nmeans whenever we do an insert or delete,\nwe're going to rearrange items in an interval.",
    "start": "393970",
    "end": "399180"
  },
  {
    "text": " And that interval is\ngoing to be small--",
    "start": "399180",
    "end": "406360"
  },
  {
    "text": "log squared N amortized. ",
    "start": "406360",
    "end": "415542"
  },
  {
    "text": "That's all I need to say here. ",
    "start": "415542",
    "end": "420689"
  },
  {
    "text": "I guess we also want\nto say that when we're moving these items\nin the interval, we can do it efficiently\ncache-obliviously, because we",
    "start": "420689",
    "end": "426229"
  },
  {
    "text": "really want log\nsquared N divided by B. And we say that via constant\nnumber of interleaved scans.",
    "start": "426230",
    "end": "439810"
  },
  {
    "text": "Scans, we know, as long as\nthere's a number of them and your cache has at least a\nconstant size number of blocks,",
    "start": "439810",
    "end": "446319"
  },
  {
    "text": "then interleave scans are\nalways going to be efficient. You always get to divide\nby B. But the focus",
    "start": "446319",
    "end": "452150"
  },
  {
    "text": "will be on making sure\nthe interval is small. The rearrangement will actually\nbe very simple, so not too hard to do.",
    "start": "452150",
    "end": "457540"
  },
  {
    "text": " So this will give us log squared\nN over B amortized memory",
    "start": "457540",
    "end": "469310"
  },
  {
    "text": "transfers. So that was the\nblack box we needed to get cache-oblivious b-trees.",
    "start": "469310",
    "end": "476120"
  },
  {
    "text": "Remember, we got rid of\nthe square in the log by using a level of indirection\nthat removed one of the logs.",
    "start": "476120",
    "end": "481310"
  },
  {
    "text": "So we got log N\nover B. So we were dominated by log\nbase B of N, which is what we had for\nthe search over here.",
    "start": "481310",
    "end": "489240"
  },
  {
    "text": "So this is the step we need. And this is a general\ntool used in a bunch of different cache-oblivious\ndata structures, sort",
    "start": "489240",
    "end": "494600"
  },
  {
    "text": "of one of the first\ncache-oblivious data structure tools. It's pretty handy.",
    "start": "494600",
    "end": "501090"
  },
  {
    "text": "It's actually much older\nthan cache-oblivious or external memory models. This results-- removing the\nlast line and this part,",
    "start": "501090",
    "end": "508790"
  },
  {
    "text": "which makes it\nefficient in this model. Just thinking about moving\naround intervals in a file",
    "start": "508790",
    "end": "514159"
  },
  {
    "text": "goes back to Itai,\nKonheim, and Rodeh in 1981. So it's pretty old.",
    "start": "514159",
    "end": "520070"
  },
  {
    "text": "And then it was brought to the\ncache-oblivious world in 2000, right when this model\nwas getting started.",
    "start": "520070",
    "end": "528740"
  },
  {
    "text": "So that's the goal. Now let me tell you how\nthis is going to work.",
    "start": "528740",
    "end": "536730"
  },
  {
    "text": "So a rough idea is very simple. You have your array. And when you insert an\nitem, what we want to do",
    "start": "536730",
    "end": "545550"
  },
  {
    "text": "is find an interval\ncontaining that item of some reasonable\nsize that's not",
    "start": "545550",
    "end": "552860"
  },
  {
    "text": "too full and not too sparse. If we can find--",
    "start": "552860",
    "end": "558089"
  },
  {
    "text": "so like right here,\nwhen we're inserting 9, it looks really bad\nright around there. And so there's, like,\ntoo many elements",
    "start": "558089",
    "end": "563150"
  },
  {
    "text": "packed right around\nthat element. And that feels bad to us. So we grow an interval around\nit until we've got enough gaps.",
    "start": "563150",
    "end": "569120"
  },
  {
    "text": "And then we just evenly\nredistribute the items in that interval. So that's basically\nwhat we're going to do.",
    "start": "569120",
    "end": "575460"
  },
  {
    "text": "We just have to\nfind the right size interval to rearrange items in. Then when we do\nthe rearrangement,",
    "start": "575460",
    "end": "581060"
  },
  {
    "text": "it's always going to be\nevenly redistributing within the interval. So that strategy is simple.",
    "start": "581060",
    "end": "586640"
  },
  {
    "text": "And to think about intervals\nin a nice controlled way, we're going to build\na binary tree--",
    "start": "586640",
    "end": "592620"
  },
  {
    "text": "our good friend. So let me just draw\nthis binary tree.",
    "start": "592620",
    "end": "602510"
  },
  {
    "start": "602510",
    "end": "607550"
  },
  {
    "text": "Now I need to do\nsomething a little bit special at the leaves. I'm going to cluster\ntogether log N items.",
    "start": "607550",
    "end": "617750"
  },
  {
    "text": "So down here is the array,\nand all of this stuff up here is conceptual. We don't really build it.",
    "start": "617750",
    "end": "623580"
  },
  {
    "text": " In my lecture notes, I\ncan just copy and paste",
    "start": "623580",
    "end": "630770"
  },
  {
    "text": "and this is a lot easier. So we have these chunks of\nsize theta log N at the bottom.",
    "start": "630770",
    "end": "637565"
  },
  {
    "text": " I don't really care\nwhat the constant is.",
    "start": "637565",
    "end": "645050"
  },
  {
    "text": "1 is probably fine. ",
    "start": "645050",
    "end": "654840"
  },
  {
    "text": "So this is the array\ndown here, and we're splitting every log N items,\nor log N cells in the array.",
    "start": "654840",
    "end": "663810"
  },
  {
    "text": "And then we say, OK,\nwell conceptually build a binary structure tree, here. And then this node\nrepresents this interval.",
    "start": "663810",
    "end": "671100"
  },
  {
    "text": "And this node represents\nthis interval. Every node just represents the\ninterval of all its descendant",
    "start": "671100",
    "end": "677730"
  },
  {
    "text": "leaves. We've seen this trick\nover and over again.",
    "start": "677730",
    "end": "683040"
  },
  {
    "text": "But we're not going to\nbuild any data structure or have some augmentation\nfor each of these nodes. This is how we're going\nto build the intervals.",
    "start": "683040",
    "end": "690649"
  },
  {
    "text": "We're going to\nstart at the leaf. Let's say we want to\ninsert an item in here. So we insert it here. If there's not room for it,\nwe're going to walk up the tree",
    "start": "690650",
    "end": "698155"
  },
  {
    "text": "and say, OK, if this\ninterval is too dense, I'll look at this node and\nits corresponding interval",
    "start": "698155",
    "end": "704579"
  },
  {
    "text": "here to here. If that's still too dense,\nI'll walk up to the parent, and so look at this\ninterval from here to here,",
    "start": "704580",
    "end": "712019"
  },
  {
    "text": "and so on, until I find\nthat in the end, at most, I redistribute the entire array.",
    "start": "712020",
    "end": "719280"
  },
  {
    "text": "And when I do that, I'll\njust evenly redistribute. Let me write down the\nalgorithm for update.",
    "start": "719280",
    "end": "729339"
  },
  {
    "text": "So for insert or\ndelete, same algorithm, you update the leaf log N chunk.",
    "start": "729340",
    "end": "741275"
  },
  {
    "text": " You can do that just by\nrewriting the entire chunk.",
    "start": "741275",
    "end": "748990"
  },
  {
    "text": "We're trying to get a\nlog squared N bound, so we can afford to\nrewrite it interval as size log N. So that's for free.",
    "start": "748990",
    "end": "755270"
  },
  {
    "text": " So whatever leaf\ncontains the element",
    "start": "755270",
    "end": "761210"
  },
  {
    "text": "you want to insert or delete. ",
    "start": "761210",
    "end": "767480"
  },
  {
    "text": "And then we're going to\nwalk up the tree until we find a suitable interval. ",
    "start": "767480",
    "end": "783640"
  },
  {
    "text": "And we're going to call\nthat node, or that interval,",
    "start": "783640",
    "end": "790470"
  },
  {
    "text": "within threshold. ",
    "start": "790470",
    "end": "800550"
  },
  {
    "text": "So let me define\nwithin threshold. We're going to look at\nthe density of a node,",
    "start": "800550",
    "end": "807300"
  },
  {
    "text": "or an interval. And that's just going to be the\nratio of the number of elements",
    "start": "807300",
    "end": "813840"
  },
  {
    "text": "that are actually down there\nversus the amount of slots in the array that\nare down there--",
    "start": "813840",
    "end": "818940"
  },
  {
    "text": " so just how much is occupied. ",
    "start": "818940",
    "end": "840794"
  },
  {
    "text": "So look at that ratio. If it's 100%, then there are\nno blank cells down there. If it's 0%, then\neverybody is blank.",
    "start": "840794",
    "end": "848149"
  },
  {
    "text": "So we don't want either\nof those extremes. We want something in between. And we're going to do that\nby specifying thresholds",
    "start": "848150",
    "end": "854010"
  },
  {
    "text": "on this density and\ntry to keep the density within those thresholds. Let me let me define\nthose thresholds.",
    "start": "854010",
    "end": "861604"
  },
  {
    "start": "861604",
    "end": "870800"
  },
  {
    "text": "The fun part is that the density\nthresholds that you maintain",
    "start": "870800",
    "end": "875870"
  },
  {
    "text": "depend on which level you are. ",
    "start": "875870",
    "end": "881120"
  },
  {
    "text": "Not, like, experience points,\nbut in which height of the tree you are.",
    "start": "881120",
    "end": "886190"
  },
  {
    "text": "So down here, we don't really\ncare how well-distributed the leaves are. I mean, it can't\nbe 0% because then",
    "start": "886190",
    "end": "893300"
  },
  {
    "text": "that would be a really big gap. But it could be say\nbetween 50% and 100%. It could be totally full.",
    "start": "893300",
    "end": "899300"
  },
  {
    "text": "And then once it's overflowing,\nthen we've got to go up. And the higher we go,\nthe stricter we get--",
    "start": "899300",
    "end": "906940"
  },
  {
    "text": "hopefully, yes-- strictest\nat the top of the tree.",
    "start": "906940",
    "end": "912570"
  },
  {
    "text": "So in general, if we have\na node of the depth, d,",
    "start": "912570",
    "end": "924800"
  },
  {
    "text": "then we want the density\nto be at least 1/2",
    "start": "924800",
    "end": "932810"
  },
  {
    "text": "minus 1/4 d over h. ",
    "start": "932810",
    "end": "939590"
  },
  {
    "text": "And we want the density to be at\nmost 3/4 plus 1/4 d over it h.",
    "start": "939590",
    "end": "952690"
  },
  {
    "text": "So h, here, is the height\nof this tree, which",
    "start": "952690",
    "end": "959165"
  },
  {
    "text": "is going to be something\nlike log N minus log-log N. But it doesn't really matter.",
    "start": "959165",
    "end": "964230"
  },
  {
    "text": "This is depth 0,\ndepth 1, depth h. ",
    "start": "964230",
    "end": "971850"
  },
  {
    "text": "We just are linearly\ninterpolating between-- let's see, this is always\nbetween 1/4 and 1/2--",
    "start": "971850",
    "end": "979905"
  },
  {
    "text": " 1/2 when this is 0,\n1/4 when this is h.",
    "start": "979905",
    "end": "986329"
  },
  {
    "text": "So you get a 1/2 minus 1/4. And this one is always\nin the range 3/4 to 1.",
    "start": "986330",
    "end": "995959"
  },
  {
    "text": "It's 3/4 when this is\n0, and 1 when this is h. So at the bottom--",
    "start": "995960",
    "end": "1002622"
  },
  {
    "text": "I was a little bit off. At the bottom, the leaf\nlevel, when these are both h--",
    "start": "1002622",
    "end": "1009400"
  },
  {
    "text": "the density has to be at\nleast a 1/4 and at most, 100%. And then at the root,\nit's going to have",
    "start": "1009400",
    "end": "1015430"
  },
  {
    "text": "to be between 1/2 and 3/4. So it's a narrower range.",
    "start": "1015430",
    "end": "1023110"
  },
  {
    "text": "And the higher you go up,\nthe more narrow the range on the density gets.",
    "start": "1023110",
    "end": "1028459"
  },
  {
    "text": "And we do it just sort of in\nthe obvious linear interpolation way. The not so obvious thing is that\nthis is the right way to do it.",
    "start": "1028459",
    "end": "1035609"
  },
  {
    "text": "There's a lot of choices\nfor how to set these density thresholds. But we have to basically\nmaintain constant density",
    "start": "1035609",
    "end": "1042010"
  },
  {
    "text": "everywhere because\nwe're trying to maintain gaps of constant size. So we don't have a\nlot of flexibility.",
    "start": "1042010",
    "end": "1048334"
  },
  {
    "text": "But it turns out,\nthis flexibility between two constants,\nlike 1/4 and 1/2 is enough to give us\nthe performance we need.",
    "start": "1048334",
    "end": "1057020"
  },
  {
    "text": "So let's see why.  Let me finish this algorithm.",
    "start": "1057020",
    "end": "1062870"
  },
  {
    "text": "We walk up the tree\nuntil reaching a node within threshold. Density is this.",
    "start": "1062870",
    "end": "1068260"
  },
  {
    "text": "Density threshold is this. So now we know within\nthreshold means. And then we evenly\nrebalance or redistribute",
    "start": "1068260",
    "end": "1079840"
  },
  {
    "text": "all the descendant\nelements in that interval",
    "start": "1079840",
    "end": "1088270"
  },
  {
    "text": "that is within threshold. ",
    "start": "1088270",
    "end": "1098629"
  },
  {
    "text": "So what you need to\ncheck is that you can do this with a\nconstant number of scans. It's not that hard.",
    "start": "1098629",
    "end": "1104220"
  },
  {
    "text": "Just read the elements in order. Write them out to\na temporary array, and then write them back. Or if you're fancy,\nyou can do it in place.",
    "start": "1104220",
    "end": "1110980"
  },
  {
    "text": "But you can just do it by\na constant number of scans through the array. ",
    "start": "1110980",
    "end": "1117390"
  },
  {
    "text": "Just compute what should\nbe the average gap between the elements.",
    "start": "1117390",
    "end": "1123230"
  },
  {
    "text": "Leave that many gaps.  So the algorithm\nis pretty simple",
    "start": "1123230",
    "end": "1130880"
  },
  {
    "text": "once you say, OK, I'm\ngoing to grow intervals. Then maybe, you think OK,\nI guess I'll grow intervals",
    "start": "1130880",
    "end": "1136776"
  },
  {
    "text": "according to a binary tree. It's a little bit\nmore controlled. Probably don't have\nto do it this way. You could just grow\nthem by a factor of 2,",
    "start": "1136776",
    "end": "1144800"
  },
  {
    "text": "just around your point. But it's easier to analyze in\nthe setting of a binary tree.",
    "start": "1144800",
    "end": "1150121"
  },
  {
    "text": "And then once you're doing\nthat, the tricky part is to set the\ndensity thresholds. But you fool around\nand this seems",
    "start": "1150121",
    "end": "1155210"
  },
  {
    "text": "to be the best way to do it. Now the question is,\nwhy does this work.",
    "start": "1155210",
    "end": "1160920"
  },
  {
    "text": "How do we prove log squared\namortized interval size when we",
    "start": "1160920",
    "end": "1167310"
  },
  {
    "text": "follow these dense thresholds? Notice that we're\nnot keeping intervals within density at all times.",
    "start": "1167310",
    "end": "1174350"
  },
  {
    "text": "I mean, the whole problem\nis that things are not within threshold\nright at the start.",
    "start": "1174350",
    "end": "1180220"
  },
  {
    "text": "And we have to walk up the tree\nquite a ways, potentially-- claim is only about log-log\nN levels up the tree--",
    "start": "1180220",
    "end": "1188480"
  },
  {
    "text": "to find something\nthat's within density. And then we can redistribute. And then we fix\neverything below us.",
    "start": "1188480",
    "end": "1195470"
  },
  {
    "text": "All right. Well, let's get to that. ",
    "start": "1195470",
    "end": "1211863"
  },
  {
    "text": "This is really the\ndirection we want. The thresholds are getting\ntighter and tighter, more constrained as we go up.",
    "start": "1211864",
    "end": "1216950"
  },
  {
    "text": "Because it means if\nwe walk up a lot, we, essentially, can pay for it\nbecause we bring that interval",
    "start": "1216950",
    "end": "1223640"
  },
  {
    "text": "even farther within threshold. So we have some node,\nwhich is within threshold.",
    "start": "1223640",
    "end": "1233400"
  },
  {
    "text": "So we bring it into the\ndensity thresholds of here. If we look at the\nchildren of that node, their density\nthresholds are smaller--",
    "start": "1233400",
    "end": "1242930"
  },
  {
    "text": "sorry, are more relaxed. So if we bring this\nnode into threshold by rewriting all the\nleaves down here,",
    "start": "1242930",
    "end": "1248450"
  },
  {
    "text": "these nodes will not\nonly be within threshold, they'll be far within threshold.",
    "start": "1248450",
    "end": "1254090"
  },
  {
    "text": "If you look at their ratios,\nyou know, their densities-- the number of elements in there,\ndivided by the array slots.",
    "start": "1254090",
    "end": "1261714"
  },
  {
    "text": "It's going to be\nexactly the same. The density is equal\nbecause we're uniformly",
    "start": "1261714",
    "end": "1267050"
  },
  {
    "text": "distributing the items here. And there's some\nrounding errors, but other than rounding.",
    "start": "1267050",
    "end": "1272070"
  },
  {
    "text": "And that's actually why we have\nthese leaves as size theta log N, so the rounding\ndoesn't bite us. ",
    "start": "1272070",
    "end": "1278990"
  },
  {
    "text": "We're evenly redistributing\nso the density is equal everywhere. Left child had the same\ndensity as the parent.",
    "start": "1278990",
    "end": "1285320"
  },
  {
    "text": "But if you look at the density\nthresholds of the child, they will be more relaxed\ncompared to the parent.",
    "start": "1285320",
    "end": "1291270"
  },
  {
    "text": "So if the parent is\nwithin threshold, the child will be\nfar within threshold by at least a d over\nh additive amount.",
    "start": "1291270",
    "end": "1300789"
  },
  {
    "text": "Sorry, 1 over h, because\ntheir depths differ by 1. If this is d, this\nwould be d plus 1.",
    "start": "1300790",
    "end": "1305960"
  },
  {
    "start": "1305960",
    "end": "1311480"
  },
  {
    "text": "When we rebalance a\nnode, we put the children",
    "start": "1311480",
    "end": "1328400"
  },
  {
    "text": "far within threshold. ",
    "start": "1328400",
    "end": "1335610"
  },
  {
    "text": "Meaning, if we look at\nthe absolute difference",
    "start": "1335610",
    "end": "1342380"
  },
  {
    "text": "between the density and\neither the upper threshold or the lower threshold, that\nwill be, I guess, at least 1",
    "start": "1342380",
    "end": "1355580"
  },
  {
    "text": "over 4h because we're\nincreasing d by 1.",
    "start": "1355580",
    "end": "1363960"
  },
  {
    "text": "And it's 1 over for 4h\nfor each step we take.",
    "start": "1363960",
    "end": "1369470"
  },
  {
    "text": "OK so the children\nare extra happy. We walked up here\nbecause before--",
    "start": "1369470",
    "end": "1375890"
  },
  {
    "text": "let's say we walked\nup this path. So we walked from\nthe right child. We didn't stop here,\nwhich means this node was",
    "start": "1375890",
    "end": "1383390"
  },
  {
    "text": "was beyond threshold. But now we walked up and now\nwe fixed this entire interval.",
    "start": "1383390",
    "end": "1393020"
  },
  {
    "text": "And now it's far\nwithin threshold. So before, you know, the\ndensity minus the threshold",
    "start": "1393020",
    "end": "1398360"
  },
  {
    "text": "went the wrong way,\nhad the wrong sign. Now we're good, and we're\ngood by at least a 1 over 4h.",
    "start": "1398360",
    "end": "1404370"
  },
  {
    "text": "Now h, here, was the\nheight of the tree. It's log N minus log-log N. All\nwe need is that this is theta",
    "start": "1404370",
    "end": "1412940"
  },
  {
    "text": "log N-- sorry, theta 1 over log\nN. h is theta log N.",
    "start": "1412940",
    "end": "1424220"
  },
  {
    "text": "And this is a ratio-- 1 over log N--",
    "start": "1424220",
    "end": "1430330"
  },
  {
    "text": "of the number of items\nversus the number of slots. But we know the\nnumber of slots we're",
    "start": "1430330",
    "end": "1435520"
  },
  {
    "text": "dealing with is theta log N. And\nso this is at least one item.",
    "start": "1435520",
    "end": "1442030"
  },
  {
    "text": "This log N is designed\nto balance the h, here.",
    "start": "1442030",
    "end": "1447340"
  },
  {
    "text": "OK, cool.  Let's go over here.",
    "start": "1447340",
    "end": "1452790"
  },
  {
    "start": "1452790",
    "end": "1459270"
  },
  {
    "text": "So the idea is if we're\nfar within threshold, we can charge to those items. That's our goal.",
    "start": "1459270",
    "end": "1464380"
  },
  {
    "start": "1464380",
    "end": "1490950"
  },
  {
    "text": "What we're interested\nin-- if we just rebalanced this node, say x. We want to know when is the\nnext time x can be rebalanced?",
    "start": "1490950",
    "end": "1498389"
  },
  {
    "text": "For x to have to be\nrebalanced, that means, again, one of its children will\nhave to be out of threshold.",
    "start": "1498390",
    "end": "1503880"
  },
  {
    "text": "And then we insert or\ndelete within that child. And then that\npropagates up to x.",
    "start": "1503880",
    "end": "1509130"
  },
  {
    "text": "But right now, the children\nare far within threshold. So the question is,\nhow long would it take for them to get\nout of threshold again?",
    "start": "1509130",
    "end": "1516060"
  },
  {
    "text": "Well, you'd have to change\nthe density by at least 1 over an additive-- 1 over log N. If you\nmultiply by the size,",
    "start": "1516060",
    "end": "1523800"
  },
  {
    "text": "it's the size of\nthe interval divided by log N. You've got to have\nat least that many insertions",
    "start": "1523800",
    "end": "1529080"
  },
  {
    "text": "or deletions.  Before this node rebalances\nagain, one of its children",
    "start": "1529080",
    "end": "1541131"
  },
  {
    "text": "must get out of balance. ",
    "start": "1541131",
    "end": "1547890"
  },
  {
    "text": "And so you must have\ndone at least the size",
    "start": "1547890",
    "end": "1554400"
  },
  {
    "text": "of the interval\ndivided by theta log N",
    "start": "1554400",
    "end": "1563460"
  },
  {
    "text": "updates for one of the children\nto become out of balance again.",
    "start": "1563460",
    "end": "1570570"
  },
  {
    "text": "Boom. So when this rebalance\nhappens again, we're going to charge to\nthose updates, which is good",
    "start": "1570570",
    "end": "1578350"
  },
  {
    "text": "because the time it takes\nus to do the rebalance is the size of the interval. ",
    "start": "1578350",
    "end": "1584679"
  },
  {
    "text": "We need to charge each of\nthese items log N times.",
    "start": "1584680",
    "end": "1590340"
  },
  {
    "text": "So charge the\nrebalance cost, which",
    "start": "1590340",
    "end": "1603130"
  },
  {
    "text": "is the size of the\ninterval to these updates.",
    "start": "1603130",
    "end": "1612930"
  },
  {
    "text": " And what we know\nis that the updates",
    "start": "1612930",
    "end": "1618930"
  },
  {
    "text": "are within the interval. ",
    "start": "1618930",
    "end": "1631360"
  },
  {
    "text": "So this looks like a log N\nbound, which is not right.",
    "start": "1631360",
    "end": "1636460"
  },
  {
    "text": "It should be a log\nsquared N bound. The idea is when we insert\ninto one of these leaves,",
    "start": "1636460",
    "end": "1647650"
  },
  {
    "text": "we're simultaneously making this\nnode worse and this node worse and this node worse.",
    "start": "1647650",
    "end": "1654760"
  },
  {
    "text": "Whenever we insert\na node, it belongs to log N intervals\nthat we care about. So in fact, not only\nare we losing this log",
    "start": "1654760",
    "end": "1661400"
  },
  {
    "text": "N, because there aren't quite\nenough items to charge to-- the log N factor less.",
    "start": "1661400",
    "end": "1666790"
  },
  {
    "text": "We're also charging to each item\nanother factor of log N times because it lives in all\nthese different intervals.",
    "start": "1666790",
    "end": "1673898"
  },
  {
    "start": "1673898",
    "end": "1683610"
  },
  {
    "text": "Each update gets charged at\nmost, h, which is order log",
    "start": "1683610",
    "end": "1694260"
  },
  {
    "text": "N times. ",
    "start": "1694260",
    "end": "1700770"
  },
  {
    "text": "We looked at what\nhappens for node x, but we have to apply this\nargument simultaneously",
    "start": "1700770",
    "end": "1706440"
  },
  {
    "text": "for all nodes x. Fortunately, this\nnode versus this node, they don't share\nany descendants.",
    "start": "1706440",
    "end": "1711750"
  },
  {
    "text": "And so there's no\nmultiple charging. But node x and its\nparent and grandparent and all its\nancestors, they're all",
    "start": "1711750",
    "end": "1718890"
  },
  {
    "text": "talking about the same nodes. And so they will\nmultiple charge, but only by a factor\nof log N. That's something we've seen a few\ntimes, charging log N times,",
    "start": "1718890",
    "end": "1726870"
  },
  {
    "text": "for every node in the\ntree, like range trees having N log N space\nin two dimensions.",
    "start": "1726870",
    "end": "1732720"
  },
  {
    "text": "Same deal. So we've got size of the\ninterval divided by log N guys",
    "start": "1732720",
    "end": "1738960"
  },
  {
    "text": "to charge to, which we multiply\ncharge log N times, so we get a log squared amortized bound.",
    "start": "1738960",
    "end": "1744290"
  },
  {
    "start": "1744290",
    "end": "1755180"
  },
  {
    "text": "So this log N is hard to avoid\nbecause we have a binary tree",
    "start": "1755180",
    "end": "1760490"
  },
  {
    "text": "that's pretty natural. This log N, essentially,\ncomes from this h.",
    "start": "1760490",
    "end": "1768050"
  },
  {
    "text": "The fact that we can only\ngo from one constant factor to another. And we've got log N\ndifferent steps to make.",
    "start": "1768050",
    "end": "1773570"
  },
  {
    "text": "We have to do 1 over log\nN increment every step. That's the best we could afford.",
    "start": "1773570",
    "end": "1779630"
  },
  {
    "text": "That's why these are evenly\nspaced out in this linear way.",
    "start": "1779630",
    "end": "1785880"
  },
  {
    "text": "But if we had a little more\nspace, we could do better. So that's going to lead us to\nthis list labeling problem.",
    "start": "1785880",
    "end": "1792194"
  },
  {
    "text": "But first, are\nthere any questions about order file maintenance? At this point, we are done. Yeah. AUDIENCE: Can you explain again\nhow is it that you get from",
    "start": "1792194",
    "end": "1799492"
  },
  {
    "text": "the size of the interval\n[INAUDIBLE] and that each-- ERIK DEMAINE: This amortization? AUDIENCE: Yeah, how you\ngot to the amortized.",
    "start": "1799492",
    "end": "1805899"
  },
  {
    "text": "ERIK DEMAINE: Yeah. So let me explain again. So when we do rebalance\nof an interval, the cost is the size\nof the interval.",
    "start": "1805899",
    "end": "1812252"
  },
  {
    "text": "We're trying to analyze, what\nis the size the interval? Prove that is log\nsquared N. So we have this cost of size of interval.",
    "start": "1812252",
    "end": "1818420"
  },
  {
    "text": "We're charging it to the\nitems which just got inserted",
    "start": "1818420",
    "end": "1823430"
  },
  {
    "text": "or deleted into that interval. Before this node rebalances\nagain, but in general,",
    "start": "1823430",
    "end": "1830000"
  },
  {
    "text": "we're interested in the-- we can afford to rebalance\nevery node at the beginning. And then whenever\na node rebalances--",
    "start": "1830000",
    "end": "1838010"
  },
  {
    "text": "before it rebalances,\none of its children had to be out of whack. For one of its children\nto be out of whack,",
    "start": "1838010",
    "end": "1846380"
  },
  {
    "text": "there had to have\nbeen an insertion of at least the size of the\ninterval divided by log N,",
    "start": "1846380",
    "end": "1852740"
  },
  {
    "text": "because log was h. There's a slight\ndiscrepancy, here. We're talking about\nthe size of the parent interval versus the size\nof the child interval,",
    "start": "1852740",
    "end": "1859528"
  },
  {
    "text": "but that's just a factor of 2. So that's incorporated\nby this theta. So you could have a little\ntheta here, too, if you like.",
    "start": "1859528",
    "end": "1867830"
  },
  {
    "text": "OK, so for the child\nto be out of whack, we had to have done updates of\nsize interval divided by log N.",
    "start": "1867830",
    "end": "1872870"
  },
  {
    "text": "So we charge this cost to them. And so we have to charge log\nN to each of those items,",
    "start": "1872870",
    "end": "1878690"
  },
  {
    "text": "each of those updates. And then there's\na second problem, which is everybody gets charged\nby all of its ancestors.",
    "start": "1878690",
    "end": "1886190"
  },
  {
    "text": "And it has log N ancestors. So in all, each update gets\ncharged at most log squared N",
    "start": "1886190",
    "end": "1892380"
  },
  {
    "text": "times. So you get amortized\nlog squared per update. ",
    "start": "1892380",
    "end": "1901400"
  },
  {
    "text": "Other questions? Cool. So that's ordered files.",
    "start": "1901400",
    "end": "1906480"
  },
  {
    "text": "Now we have b-trees. We can handle this log squared\nN. That was OK for B trees,",
    "start": "1906480",
    "end": "1913230"
  },
  {
    "text": "using a layer of indirection. But it's natural to wonder\nwhether you can do better.",
    "start": "1913230",
    "end": "1919470"
  },
  {
    "text": "In general, the conjecture\nis that for ordered files, you cannot do better. If this is your problem\nsetup, if you can only",
    "start": "1919470",
    "end": "1925740"
  },
  {
    "text": "have constant sized gaps,\nyou need a linear size array. You need log squared\nN interval updates,",
    "start": "1925740",
    "end": "1931110"
  },
  {
    "text": "but no one's proved\nthat lower bound. So that's one open question. Another fun fact is\nwe did amortized,",
    "start": "1931110",
    "end": "1939000"
  },
  {
    "text": "but it's actually\npossible to do worst case. It's complicated.",
    "start": "1939000",
    "end": "1944250"
  },
  {
    "text": "Willard did it in 1992.",
    "start": "1944250",
    "end": "1951690"
  },
  {
    "text": "But let's talk about\nrelaxing the problem. So instead of saying, well, the\narray has to be linear size,",
    "start": "1951690",
    "end": "1957230"
  },
  {
    "text": "what if we let it to be bigger? And then you can do better. ",
    "start": "1957230",
    "end": "1964889"
  },
  {
    "text": "And this is a problem\ncalled list labeling. ",
    "start": "1964890",
    "end": "1973740"
  },
  {
    "text": "So I'm going to rephrase it,\nbut it's essentially the same as order file maintenance.",
    "start": "1973740",
    "end": "1979550"
  },
  {
    "text": "It's a little bit\nless restriction.",
    "start": "1979550",
    "end": "1984959"
  },
  {
    "start": "1984959",
    "end": "2014309"
  },
  {
    "text": "So it's a dynamic\nlinked list problem, like we've seen before. And each node at all\ntimes stores a label such",
    "start": "2014310",
    "end": "2028580"
  },
  {
    "text": "that labels are always\nmonotone down the list.",
    "start": "2028580",
    "end": "2039289"
  },
  {
    "text": " So think of it this way. We have a linked list.",
    "start": "2039290",
    "end": "2046070"
  },
  {
    "start": "2046070",
    "end": "2051355"
  },
  {
    "text": "And all we're interested is\nmaintaining this linked list. So we want to be able to\nsay, OK, delete this item",
    "start": "2051355",
    "end": "2056780"
  },
  {
    "text": "and update these pointers. Or maybe, insert a\nnew item over here.",
    "start": "2056780",
    "end": "2063290"
  },
  {
    "text": "And so it's going to\nbe linked like that. And at all times in\nthis cell here, we're",
    "start": "2063290",
    "end": "2068388"
  },
  {
    "text": "storing a number, 3, 7,\n12, 14, 42, whatever.",
    "start": "2068389",
    "end": "2075273"
  },
  {
    "text": "It could be any\ninteger, let's say. And we need that the\nnumbers are increasing order",
    "start": "2075274",
    "end": "2080790"
  },
  {
    "text": "down the linked list. Now, I claim this is basically\nthe same as an ordered file",
    "start": "2080790",
    "end": "2087000"
  },
  {
    "text": "problem. Just think of this number as\nbeing the index in the array that you store it.",
    "start": "2087000",
    "end": "2092250"
  },
  {
    "text": "So this should be\nstrictly monotone-- ",
    "start": "2092250",
    "end": "2097280"
  },
  {
    "text": "I guess, increasing\ndown the list.",
    "start": "2097280",
    "end": "2103670"
  },
  {
    "text": "That means none of these\nnumbers are the same. So we can store the items-- whatever data is\nassociated with this node--",
    "start": "2103670",
    "end": "2110930"
  },
  {
    "text": "we can store that in\nthe array position 3, in the array position 7,\nin the array position 12.",
    "start": "2110930",
    "end": "2116690"
  },
  {
    "text": "When we insert, we have to find\na new label between 3 and 7.",
    "start": "2116690",
    "end": "2122114"
  },
  {
    "text": "Now we're allowed to change\nthe labels dynamically-- that's what makes\nthis possible-- which corresponds to\nmoving items in the array.",
    "start": "2122114",
    "end": "2129410"
  },
  {
    "text": "And the only difference is about\nhow this is physically done.",
    "start": "2129410",
    "end": "2134420"
  },
  {
    "text": "With ordered file, you have\nto physically move items in the array. Here, you just change a number\nand that's moving the item.",
    "start": "2134420",
    "end": "2143029"
  },
  {
    "text": "Where this gets interesting is\nif you allow the label space-- which is the storage\nspace of the array--",
    "start": "2143030",
    "end": "2148849"
  },
  {
    "text": "to become super linear. With ordered files, it doesn't\nreally make a lot of sense to go super linear, at least,\nnot by more than a couple log",
    "start": "2148850",
    "end": "2156529"
  },
  {
    "text": "factors because time is\nalways at least space. If you have a giant array,\nyou have to initialize it.",
    "start": "2156530",
    "end": "2163130"
  },
  {
    "text": "And you can't afford to\ninitialize an array of, say, N squared size, if you're\ntrying to maintain N items.",
    "start": "2163130",
    "end": "2168960"
  },
  {
    "text": "But in list labeling, you can. I mean, if you say all these\nnumbers are between 0 and N",
    "start": "2168960",
    "end": "2174380"
  },
  {
    "text": "squared, that's no\nbig deal because you can represent a number up to\nN squared, which is two log N",
    "start": "2174380",
    "end": "2181490"
  },
  {
    "text": "bits. So squaring the space is no\nbig deal for list labeling. It would be a big deal for\norder file maintenance,",
    "start": "2181490",
    "end": "2187290"
  },
  {
    "text": "so that's why we rephrase. But they're basically\nthe same problem-- just a little less useful\nfor cache-oblivious stuff.",
    "start": "2187290",
    "end": "2195140"
  },
  {
    "start": "2195140",
    "end": "2202740"
  },
  {
    "text": "Let me tell you what's\nknown about mislabelling. ",
    "start": "2202740",
    "end": "2216825"
  },
  {
    "text": "In terms of the amount of\nlabel space you're given,",
    "start": "2216825",
    "end": "2231220"
  },
  {
    "text": "and how good a running\ntime per update we can get, in terms\nof best known results.",
    "start": "2231220",
    "end": "2237460"
  },
  {
    "text": "So what we just saw\nis that if you do-- we just said linear space.",
    "start": "2237460",
    "end": "2242804"
  },
  {
    "text": "But in fact, you can get\n1 plus epsilon space. You can say, oh, I wouldn't want\nto waste 1% of my storage space",
    "start": "2242804",
    "end": "2248380"
  },
  {
    "text": "in the array. And if you set the\ntheta at the leaves, here, to the right value,\nthen you can just waste 1%",
    "start": "2248380",
    "end": "2256612"
  },
  {
    "text": "and still maintain\nan ordered file. I think this is cool from\na file system perspective. But in particular, it\ngives us what we need.",
    "start": "2256612",
    "end": "2264789"
  },
  {
    "text": "And if you go up\nto N log N space, it doesn't seem\nto help you much.",
    "start": "2264790",
    "end": "2270490"
  },
  {
    "text": "The best we know is log\nsquared N. As I mentioned, it could be amortized\nor worst case.",
    "start": "2270490",
    "end": "2278829"
  },
  {
    "text": "If you bump up the space to\nN to the 1 plus epsilon-- so a little bit super linear--",
    "start": "2278830",
    "end": "2284056"
  },
  {
    "text": "and anything polynomial, then\nthe best we know is log N.",
    "start": "2284056",
    "end": "2290121"
  },
  {
    "text": "And there is actually\na lower bound for this result in\na particular model.",
    "start": "2290122",
    "end": "2295130"
  },
  {
    "text": "So it seems pretty clear that-- at least for these style\nof data structures,",
    "start": "2295130",
    "end": "2301630"
  },
  {
    "text": "the best you can do in\nthis situation is log N. But hey, log N is\nbetter than log squared.",
    "start": "2301630",
    "end": "2307369"
  },
  {
    "text": "And the other obvious bound is\nif you have exponential space, you can do constant,\nessentially.",
    "start": "2307370",
    "end": "2314122"
  },
  {
    "text": "Because with\nexponential space, you can just keep\nbisecting the interval between two items\nin constant time",
    "start": "2314122",
    "end": "2319630"
  },
  {
    "text": "until you've inserted N items. And then you can rebuild\nthe whole data structure. So that's sort of\nthe trivial result.",
    "start": "2319630",
    "end": "2326560"
  },
  {
    "text": "If you don't care about\nhow big these labels get-- and how big they would\nget is 2 to the N--",
    "start": "2326560",
    "end": "2332151"
  },
  {
    "text": "then you can do constant time. That's really the only way\nwe know how to do constant. ",
    "start": "2332151",
    "end": "2338650"
  },
  {
    "text": "So the interesting\nnew result, here, that I'm talking about\nis for polynomial space, we can get log N.",
    "start": "2338650",
    "end": "2345370"
  },
  {
    "text": "And rough idea is you just\nfixed these density intervals. Now you don't have to make it--",
    "start": "2345370",
    "end": "2352480"
  },
  {
    "text": "I mean, you're still going\nto be divided by h, here, but your spread\ncan be much bigger.",
    "start": "2352480",
    "end": "2357530"
  },
  {
    "text": "So your densities no longer\nhave to be constants. Now we can afford a density-- near the root, we can get\na density of like 1 over--",
    "start": "2357530",
    "end": "2365050"
  },
  {
    "text": "actually, anywhere, we\ncan afford a density of 1 over N. Because if we have N\nsquared slots and only N items",
    "start": "2365050",
    "end": "2371980"
  },
  {
    "text": "to put in them, then a decent\ndensity is 1 over N, in fact. It could also be constant.",
    "start": "2371980",
    "end": "2377340"
  },
  {
    "text": "Constant would be all right. So we've got a big spread there,\nfrom 1 over N to constant. And so we can afford to\ntake much bigger jumps here,",
    "start": "2377340",
    "end": "2385260"
  },
  {
    "text": "of like 1 over N. And so that\ngets rid of this log N factor,",
    "start": "2385260",
    "end": "2393650"
  },
  {
    "text": "essentially. That was the rough sketch. I have written, here,\nthat the densities we use",
    "start": "2393650",
    "end": "2405950"
  },
  {
    "text": "are no longer uniformly spaced. The 1 over alpha to the d.",
    "start": "2405950",
    "end": "2411110"
  },
  {
    "text": "Alpha, here, is some constant\nin the interval between 1 and 2.",
    "start": "2411110",
    "end": "2419600"
  },
  {
    "text": "And d is the depth. So now we have exponentially\nincreasing densities which give you a big gap--",
    "start": "2419600",
    "end": "2428660"
  },
  {
    "text": "no longer lose\nthis log N factor. So you do exactly the\nsame data structure,",
    "start": "2428660",
    "end": "2434990"
  },
  {
    "text": "these different densities. Now you've got room to\nfill in a whole bunch more densities when you\nhave, say, N squared space.",
    "start": "2434990",
    "end": "2442840"
  },
  {
    "text": "And so you only get the log N\nfactor because of the number of ancestors of a node. And you lose the\nother log N factor.",
    "start": "2442840",
    "end": "2448970"
  },
  {
    "start": "2448970",
    "end": "2455470"
  },
  {
    "text": "Now let me tell you\nabout another problem building on this.",
    "start": "2455470",
    "end": "2460619"
  },
  {
    "start": "2460620",
    "end": "2471672"
  },
  {
    "text": "So this is the list order\nmaintenance problem. And this is the problem\nwe saw in a Lecture 1.",
    "start": "2471672",
    "end": "2477240"
  },
  {
    "start": "2477240",
    "end": "2482520"
  },
  {
    "text": "So here, same as before,\nmaintain a linked list,",
    "start": "2482520",
    "end": "2492540"
  },
  {
    "text": "subject to, insert a\nnode at this location,",
    "start": "2492540",
    "end": "2500880"
  },
  {
    "text": "delete a node at this\nlocation, and order queries.",
    "start": "2500880",
    "end": "2506835"
  },
  {
    "start": "2506835",
    "end": "2513720"
  },
  {
    "text": "Is node x before\nnode y in the list?",
    "start": "2513720",
    "end": "2520109"
  },
  {
    "text": " This is what we needed to\nsupport full persistence.",
    "start": "2520110",
    "end": "2526410"
  },
  {
    "text": "You have a big linked list. ",
    "start": "2526410",
    "end": "2534430"
  },
  {
    "text": "And then if I give you\nthis node and this node, I want to know that this\nnode is before that node in the list in constant time.",
    "start": "2534430",
    "end": "2541710"
  },
  {
    "text": "I claim that we can solve this\nproblem given our solutions to list labeling--",
    "start": "2541710",
    "end": "2548250"
  },
  {
    "text": "not so obvious, how. List labeling is\ngreat because it lets",
    "start": "2548250",
    "end": "2553784"
  },
  {
    "text": "you do order queries, right? You just compare the two\nlabels and you instantly discover which is before which.",
    "start": "2553784",
    "end": "2559680"
  },
  {
    "text": "And so if we could afford\nlog N time over there, we could just use this solution. And this is reasonable.",
    "start": "2559680",
    "end": "2565420"
  },
  {
    "text": "But we really want constant\ntime per operation. Now if we do constant\ntime per operation and we use exponential\nlabel space,",
    "start": "2565420",
    "end": "2572410"
  },
  {
    "text": "this is not so good\nbecause it means you need N bits to write down a label. So it's going to take,\nlike, linear time to modify",
    "start": "2572410",
    "end": "2578940"
  },
  {
    "text": "or to compare two labels. This doesn't save you.",
    "start": "2578940",
    "end": "2584540"
  },
  {
    "text": "We can afford to do this. This is only log\nN bits per label. And we assume all\nof our integers",
    "start": "2584540",
    "end": "2590760"
  },
  {
    "text": "can store at least log N bits-- something called\na Word RAM Model.",
    "start": "2590760",
    "end": "2596740"
  },
  {
    "text": "And so we can afford\nto store these labels, but we pay this log N time.",
    "start": "2596740",
    "end": "2602140"
  },
  {
    "text": "So you've got to\nremove a log N factor. How do we do that? Indirection-- just\nlike last class.",
    "start": "2602140",
    "end": "2608610"
  },
  {
    "start": "2608610",
    "end": "2614230"
  },
  {
    "text": "Let's do that on this board. ",
    "start": "2614230",
    "end": "2628859"
  },
  {
    "text": "On the top, we're going to\nstore N over log N items",
    "start": "2628860",
    "end": "2635670"
  },
  {
    "text": "using this list labeling with\nlabel space, say, N squared.",
    "start": "2635670",
    "end": "2651680"
  },
  {
    "text": "Any polynomial will do. And so this takes\nlog N per operation to do anything on these\nN over log N items.",
    "start": "2651680",
    "end": "2658480"
  },
  {
    "text": "And then at the\nbottom, we have lots of little structures\nof size log N. And that's supposed to eat up\na factor of log N in our update",
    "start": "2658480",
    "end": "2665910"
  },
  {
    "text": "time if we do it right. ",
    "start": "2665910",
    "end": "2675029"
  },
  {
    "text": "Actually, I can just do list\nlabeling down here as well. So if I'm only\nstoring log N items,",
    "start": "2675030",
    "end": "2681839"
  },
  {
    "text": "then I can afford to use\nthe exponential solution-- the trivial thing where I just\nbisect all the labels until all",
    "start": "2681840",
    "end": "2688770"
  },
  {
    "text": "the log items have changed. Then, rewrite them. Because 2 to the log N is only\nN. So here, in each of these,",
    "start": "2688770",
    "end": "2696000"
  },
  {
    "text": "I do a list labeling with\nspace 2 to the log N,",
    "start": "2696000",
    "end": "2704370"
  },
  {
    "text": "also known as N. So these guys are constant\ntime to do anything in",
    "start": "2704370",
    "end": "2710920"
  },
  {
    "text": "to maintain the labels. And to maintain levels up here-- so to maintain, basically, each\nof these N over log N guys,",
    "start": "2710920",
    "end": "2717750"
  },
  {
    "text": "is one representative element\nrepresenting this entire group as N over log N of these groups.",
    "start": "2717750",
    "end": "2724050"
  },
  {
    "text": " So this label\nstructure is supposed to distinguish the\ndifferent groups.",
    "start": "2724050",
    "end": "2730770"
  },
  {
    "text": "And then the labels in here\nare distinguishing the items within the group. Now this cost log N amortized\nto keep what we need up here.",
    "start": "2730770",
    "end": "2741620"
  },
  {
    "text": "But now if I want\nthe label of an item, I just take this label,\ncomma, this label.",
    "start": "2741620",
    "end": "2749030"
  },
  {
    "text": "So if I have an item\nhere, for example, at first, I look at\nthe label of this block",
    "start": "2749030",
    "end": "2754620"
  },
  {
    "text": "as stored by this\ndata structure. And then I look at the\nlabel within the block. And so my composite\nlabel is going",
    "start": "2754620",
    "end": "2765690"
  },
  {
    "text": "to be an ordered pair of top\nlabel, comma, the bottom label.",
    "start": "2765690",
    "end": "2772020"
  },
  {
    "start": "2772020",
    "end": "2778017"
  },
  {
    "text": "This is kind of funny\nbecause it looks like we're solving the list\nlabeling problem again, with now a space of N cubed.",
    "start": "2778017",
    "end": "2785030"
  },
  {
    "text": "We've got N squared for\nthe first coordinate, and then N for the\nsecond coordinate. So if you just\nconcatenate those two",
    "start": "2785030",
    "end": "2790970"
  },
  {
    "text": "labels, that lives in a bigger\nlabel space of size N cubed. And yet, I claim this\ntakes constant amortized",
    "start": "2790970",
    "end": "2798520"
  },
  {
    "text": "and is not a solution\nto list labeling. It's just a matter of, again,\nhow updates are performed.",
    "start": "2798520",
    "end": "2804560"
  },
  {
    "text": "With order file maintenance, we\nhad to physically move items. With list labeling\nproblem, we had to modify the number\nstored with each node.",
    "start": "2804560",
    "end": "2812450"
  },
  {
    "text": "That's expensive. In this world, if we\nchange a label up here,",
    "start": "2812450",
    "end": "2818570"
  },
  {
    "text": "we are basically\ninstantly-- say, we changed the label\ncorresponding to this group",
    "start": "2818570",
    "end": "2824450"
  },
  {
    "text": "in here. We changed the label all of\nthese items in one operation. Or actually, it\ntakes log N time.",
    "start": "2824450",
    "end": "2831170"
  },
  {
    "text": "And then we change the label\nof all log N of these items. So that's why we get\nconstant amortized.",
    "start": "2831170",
    "end": "2837080"
  },
  {
    "text": "So how does this work? If we insert a new\nitem, we stick it into one of these blocks.",
    "start": "2837080",
    "end": "2842240"
  },
  {
    "text": "The block that it fits into. If this block gets too full,\nmore than, say, 1 times log N,",
    "start": "2842240",
    "end": "2847849"
  },
  {
    "text": "then we split it in half. If it gets too sparse by\ndeletion, say, less than a 1/4 log N, then we'll merge it\nwith one of its neighbors,",
    "start": "2847850",
    "end": "2855079"
  },
  {
    "text": "and then possibly split. Each of those triggers a\nconstant number of operations up here. And so we pay log N,\nbut we only pay it",
    "start": "2855080",
    "end": "2861920"
  },
  {
    "text": "when we've made theta log N\nchanges to one of these blocks. So we can charge this log N\ncost to those log N updates.",
    "start": "2861920",
    "end": "2869150"
  },
  {
    "text": "And so this turns into constant. This down here is\nalways constant. And so it's constant amortized.",
    "start": "2869150",
    "end": "2874671"
  },
  {
    "start": "2874671",
    "end": "2882529"
  },
  {
    "text": "And if each of these\nblocks remembers what the corresponding-- and, basically, this\nis a linked list, here.",
    "start": "2882530",
    "end": "2889369"
  },
  {
    "text": "And then we have\nlinked list down here, and they have labels. And it's like a, what do you\ncall, a skip list with just two",
    "start": "2889370",
    "end": "2895940"
  },
  {
    "text": "levels. And every node\nhere just remembers what its parent is up here. So if you want to know\nyour composite label,",
    "start": "2895940",
    "end": "2902360"
  },
  {
    "text": "you just look at the bottom\nlabel and then walk up. Look at the top label. Those are just stored\nright there in the nodes.",
    "start": "2902360",
    "end": "2909140"
  },
  {
    "text": "And so in constant time,\nyou can find your top label, your bottom label. Therefore, you can compare\ntwo items in constant time.",
    "start": "2909140",
    "end": "2915210"
  },
  {
    "text": "So this solves the problem\nwe needed in Lecture 1. Question? AUDIENCE: Sorry, why isn't it\nthe same as the N cubed label",
    "start": "2915210",
    "end": "2921708"
  },
  {
    "text": "space? ERIK DEMAINE: OK. Why is it not same as N cubed\nlabel space, which I claim has a lower amount of log N?",
    "start": "2921708",
    "end": "2927769"
  },
  {
    "text": "The difference is\nwith list labeling, you have to explicitly change\nthe label of each items.",
    "start": "2927770",
    "end": "2933589"
  },
  {
    "text": "And here, we're\nbasically computing the label of a node now becomes\na constant time algorithm. We're allowed to\nlook at the label,",
    "start": "2933590",
    "end": "2939950"
  },
  {
    "text": "here, then walk up, then\nlook at the label, here. And by changing\nthe label up here, we change it simultaneously\nfor log N guys down there.",
    "start": "2939950",
    "end": "2946550"
  },
  {
    "text": "So that's the big difference\nbetween this list order maintenance problem from\nthe list labeling problem.",
    "start": "2946550",
    "end": "2953000"
  },
  {
    "text": "These were actually all\nsolved in the same paper by Dietz and Slater. But sort of successively--",
    "start": "2953000",
    "end": "2960200"
  },
  {
    "text": "slightly relaxing\non a problem makes a huge difference in the\nrunning time you can achieve. Obviously, we can't get\nany better than constant.",
    "start": "2960200",
    "end": "2966021"
  },
  {
    "text": "So we're done in-- of course, then there's\nexternal memory versions-- but in terms of regular\ndata structures.",
    "start": "2966021",
    "end": "2976350"
  },
  {
    "text": "And again, Willard made\nit worst case constant. That's a lot harder.",
    "start": "2976350",
    "end": "2983800"
  },
  {
    "text": "Other questions? Cool. So that does order file\nmaintenance and list labeling.",
    "start": "2983800",
    "end": "2992260"
  },
  {
    "text": "And so next, we're going to\nmove to a very different data structure, which is\ncache-oblivious priority queue.",
    "start": "2992260",
    "end": "2997520"
  },
  {
    "start": "2997520",
    "end": "3009912"
  },
  {
    "text": "We haven't really done\nany cache-oblivious data structures, yet. So it's time to return\nto our original goal.",
    "start": "3009912",
    "end": "3015710"
  },
  {
    "text": " We're not actually going\nto use ordered files.",
    "start": "3015710",
    "end": "3021819"
  },
  {
    "text": "Sadly, that was last lecture.  So All of this was a\ncontinuation of last lecture.",
    "start": "3021820",
    "end": "3030550"
  },
  {
    "text": "Now we're going to do a\ndifferent data structure. It's going to adapt\nto B, it's going to adapt to M. It's\ncache-oblivious.",
    "start": "3030550",
    "end": "3036170"
  },
  {
    "text": "And it achieves priority queue. Now remember, this\nsorting bound-- ",
    "start": "3036170",
    "end": "3044830"
  },
  {
    "text": "N over B log base M of N over\nB This is our sorting bound. Then the priority queue bound\nwe want is this divided by N.",
    "start": "3044830",
    "end": "3053270"
  },
  {
    "text": "So we want to be able to\ndo 1 over B log base M over B, N over b.",
    "start": "3053270",
    "end": "3061990"
  },
  {
    "text": "Insert and delete\nmin, let's say. And this is an interesting\nbound because it's usually",
    "start": "3061990",
    "end": "3068290"
  },
  {
    "text": "much less than 1. It's a sub constant bound. This is going to\nbe a little o of 1,",
    "start": "3068290",
    "end": "3074740"
  },
  {
    "text": "assuming this log is\nsmaller than this B.",
    "start": "3074740",
    "end": "3080530"
  },
  {
    "text": "So it's a little o of\n1 if, let's say, B is",
    "start": "3080530",
    "end": "3090190"
  },
  {
    "text": "bigger than the log N, roughly. This would, in\nparticular, be enough.",
    "start": "3090190",
    "end": "3097390"
  },
  {
    "text": "No pun intended-- be enough. So if our block size\nis reasonably big--",
    "start": "3097390",
    "end": "3103030"
  },
  {
    "text": "cache line is bigger\nthan log N, which is probably most likely\nin typical caches",
    "start": "3103030",
    "end": "3108549"
  },
  {
    "text": "and architectures-- then this is more like 1\nover B, never mind the log.",
    "start": "3108550",
    "end": "3114420"
  },
  {
    "text": "And so we have to do B\noperations in one step. And then to really\nget the log right,",
    "start": "3114420",
    "end": "3120250"
  },
  {
    "text": "we have to depend\non M, not just B.",
    "start": "3120250",
    "end": "3130690"
  },
  {
    "text": "As I mentioned, that's the\nbound we're going to achieve.",
    "start": "3130690",
    "end": "3136300"
  },
  {
    "text": "We do need to make an\nassumption about M and B and how they relate. So we're going to assume a\ntall cache, which is M is,",
    "start": "3136300",
    "end": "3151250"
  },
  {
    "text": "let's say, B to\nthe 1 plus epsilon. So it has to be substantially\nbigger than B, not",
    "start": "3151250",
    "end": "3158380"
  },
  {
    "text": "by a huge amount. It could be B squared. It could be B to the 1.1 power. But M is definitely\nat least B. And I want",
    "start": "3158380",
    "end": "3165242"
  },
  {
    "text": "it to be a little bit bigger. I want the number of\nblocks to be not so tiny. ",
    "start": "3165242",
    "end": "3173536"
  },
  {
    "text": "Here's how we do it. ",
    "start": "3173537",
    "end": "3199940"
  },
  {
    "text": "I think I need a big picture. ",
    "start": "3199940",
    "end": "3209260"
  },
  {
    "text": "So the kind of funny thing about\ncache-oblivious priority queues is we're not going to use trees. ",
    "start": "3209260",
    "end": "3216190"
  },
  {
    "text": "It's basically a bunch of\narrays in a linear order. ",
    "start": "3216190",
    "end": "3222814"
  },
  {
    "text": "In some ways, it's an\neasier data structure. But it's definitely\nmore complicated.",
    "start": "3222814",
    "end": "3228056"
  },
  {
    "text": " But, hey, it's\nfaster than b-trees.",
    "start": "3228056",
    "end": "3234786"
  },
  {
    "text": "If you don't need to be able\nto do searches-- if you just need to be able to delete\nmin, then priority queues are a lot faster than b-trees.",
    "start": "3234786",
    "end": "3241810"
  },
  {
    "start": "3241810",
    "end": "3250206"
  },
  {
    "text": "Let me draw this. ",
    "start": "3250206",
    "end": "3264420"
  },
  {
    "text": "I want to try to draw\nthis pseudo-accurate size. ",
    "start": "3264420",
    "end": "3291132"
  },
  {
    "text": "The only part that's\ninaccurate about this picture is the dot dot dots. Lets me cheat a little. ",
    "start": "3291132",
    "end": "3309160"
  },
  {
    "text": "So we have x to that\n9/4, x to the 3/2 and x.",
    "start": "3309160",
    "end": "3319440"
  },
  {
    "text": "This is sort of what the\nlevels are going to look like. So we have a linear\nsequence of levels.",
    "start": "3319440",
    "end": "3326510"
  },
  {
    "text": "They are increasing doubly\nexponentially in size.",
    "start": "3326510",
    "end": "3332090"
  },
  {
    "text": "If you look at what's\ngoing on here-- ",
    "start": "3332090",
    "end": "3338137"
  },
  {
    "text": "double exponential-- AUDIENCE: Are those\nexponentials the same as those? Or are they inverted? ERIK DEMAINE: It's\nsupposed to be this-- so this is the top level,\nand this is the bottom level.",
    "start": "3338137",
    "end": "3347400"
  },
  {
    "text": " So at the top, we're going\nto have something of size N.",
    "start": "3347400",
    "end": "3354060"
  },
  {
    "text": "And at the bottom, we're going\nto have something of a size C, constant. And what I've drawn is\nthe generic middle part.",
    "start": "3354060",
    "end": "3360370"
  },
  {
    "text": "So we go from x, to x\nto 3/2, to x to the 9/4. Or you could say x to the\n9/4, down to x to the 3/2,",
    "start": "3360370",
    "end": "3366520"
  },
  {
    "text": "down to x, according to\nthis exponential geometric",
    "start": "3366520",
    "end": "3372040"
  },
  {
    "text": "progression, I guess. So that's how they go. So I mean, if it was\njust exponential,",
    "start": "3372040",
    "end": "3378970"
  },
  {
    "text": "it would be, like, N,\nN over 2, N over 4. But we're doing--\nin logarithms, we're changing by constant factors.",
    "start": "3378970",
    "end": "3385200"
  },
  {
    "text": "So it's doubly exponential. And then each of the\nlevels is decomposed",
    "start": "3385200",
    "end": "3390700"
  },
  {
    "text": "into top buffers and bottom-- or, sorry, up buffers\nand down buffers.",
    "start": "3390700",
    "end": "3397120"
  },
  {
    "text": "And as you see, the\nsize of the top buffer is equal to the sum of the\nsizes of the bottom buffers.",
    "start": "3397120",
    "end": "3403600"
  },
  {
    "text": "So let me elaborate\non how this works.",
    "start": "3403600",
    "end": "3408920"
  },
  {
    "text": "It's level x to the 3/2. We're going to, generically,\nbe looking at x to the 3/2.",
    "start": "3408920",
    "end": "3416500"
  },
  {
    "text": "So I can easily go down. That's of size x. And up is x to the 9/4-- easily. ",
    "start": "3416500",
    "end": "3424660"
  },
  {
    "text": "There's always one up\nbuffer of size x to the 3/2.",
    "start": "3424660",
    "end": "3435325"
  },
  {
    "text": " So maybe some color. ",
    "start": "3435325",
    "end": "3442410"
  },
  {
    "text": "So this buffer, here,\nis x to the 3/2.",
    "start": "3442410",
    "end": "3447420"
  },
  {
    "text": "And then we also have up to x\nto the 1/2 down buffers, each",
    "start": "3447420",
    "end": "3463200"
  },
  {
    "text": "of size theta x. ",
    "start": "3463200",
    "end": "3469750"
  },
  {
    "text": "Each of these guys\nhas size theta x. ",
    "start": "3469750",
    "end": "3475700"
  },
  {
    "text": "And then the number of them\nis, at most, x to the 1/2. And so you take\nthe product, that's",
    "start": "3475700",
    "end": "3481840"
  },
  {
    "text": "x to 3/2, which is the\nsame as the up buffer. So that's the way\nthis cookie crumbles.",
    "start": "3481840",
    "end": "3488260"
  },
  {
    "text": "That's how each of these guys\ndecomposes into little pieces. And so, in particular, this\nup buffer, if you work it out,",
    "start": "3488260",
    "end": "3495550"
  },
  {
    "text": "should be exactly the same\nsize as this down buffer. Maybe it's easier\nto do these two.",
    "start": "3495550",
    "end": "3501250"
  },
  {
    "text": "So this down buffer has size x. And if you have a structure size\nx, the up buffer has size x.",
    "start": "3501250",
    "end": "3508070"
  },
  {
    "text": "x of 3/2 has an up\nbuffer size of x 3/2. So this will be size x. And so these match.",
    "start": "3508070",
    "end": "3515220"
  },
  {
    "text": "These are equal size. That's why I drew it this way. ",
    "start": "3515220",
    "end": "3520630"
  },
  {
    "text": "Now the dot dot dot hides the\nfact that they're x to the 1/2 of these. So there's a lot\nof down buffers. They're actually a lot\nsmaller than up buffers.",
    "start": "3520630",
    "end": "3527380"
  },
  {
    "text": "But these two match in\nsize and these two match in size, and so on. ",
    "start": "3527380",
    "end": "3539370"
  },
  {
    "text": "OK, there's a small exception. I'd put theta x here.",
    "start": "3539370",
    "end": "3544940"
  },
  {
    "text": "The exception is that the\nvery first down buffer might be mostly empty.",
    "start": "3544940",
    "end": "3550890"
  },
  {
    "text": "So this one is not\nactually data x. Each of these will be theta x.",
    "start": "3550890",
    "end": "3556380"
  },
  {
    "text": "And this one over on the\nleft will be big O of x. ",
    "start": "3556380",
    "end": "3562300"
  },
  {
    "text": "Small typo in the notes, here. ",
    "start": "3562300",
    "end": "3571010"
  },
  {
    "text": "So if that's not sufficiently\nmessy, let me redraw it-- make it a little cleaner.",
    "start": "3571010",
    "end": "3576640"
  },
  {
    "start": "3576640",
    "end": "3600059"
  },
  {
    "text": "I want to look at two\nconsecutive levels and specify invariants.",
    "start": "3600060",
    "end": "3606260"
  },
  {
    "start": "3606260",
    "end": "3612001"
  },
  {
    "text": "So after all, I'm trying to\nmaintain a priority queue. What the heck is this thing? The idea is that\ntowards the bottom,",
    "start": "3612001",
    "end": "3618630"
  },
  {
    "text": "that's where the min is. That would seem good,\nbecause at the bottom, you're constant size.",
    "start": "3618630",
    "end": "3624329"
  },
  {
    "text": "I can diddle with the\nthing of constant size if fits in a block\nor if it's in cache. It takes me zero time to\ntouch things near the bottom.",
    "start": "3624330",
    "end": "3631890"
  },
  {
    "text": "So as long as I always\nkeep the min down there, I can do fine min in zero time.",
    "start": "3631890",
    "end": "3636960"
  },
  {
    "text": "And delete min will\nalso be pretty fast. I'm also going to insert\nthere, because I don't know where else to put it.",
    "start": "3636960",
    "end": "3643200"
  },
  {
    "text": "I'd like the larger items\nto be at near the top. I'd like the smaller items\nto be near the bottom, but kind of hard to know,\nwhen I insert an item,",
    "start": "3643200",
    "end": "3651480"
  },
  {
    "text": "where it belongs. So I'll just start by\ninserting at the bottom. And the idea is as I insert,\ninsert, insert down here,",
    "start": "3651480",
    "end": "3658500"
  },
  {
    "text": "things will start to trickle up. That's what the up arrows mean,\nthat these items are moving up.",
    "start": "3658500",
    "end": "3663970"
  },
  {
    "text": "And then down arrow items are\nitems that are moving down. Somehow this is going to work.",
    "start": "3663970",
    "end": "3669820"
  },
  {
    "text": "So let me tell\nyou the invariants that will make this work. If you look at the down\nbuffers, they are sorted.",
    "start": "3669820",
    "end": "3678300"
  },
  {
    "text": "Or I should say, all\nthe items in here are less than all the\nitems in here, and so on. But within each down\nbuffer, it's disordered.",
    "start": "3678300",
    "end": "3687270"
  },
  {
    "text": "Then we also know this.",
    "start": "3687270",
    "end": "3696290"
  },
  {
    "text": "All the items in the up\nbuffer in a given level-- this is x to the 3/2, let's say.",
    "start": "3696290",
    "end": "3702175"
  },
  {
    "text": "And this is x. All of the up items are larger\nthan all of the down items.",
    "start": "3702175",
    "end": "3710930"
  },
  {
    "text": "I mean, it's just\nan inequality here. So these guys are\nbasically in a chain. Again, the items in\nhere are not sorted.",
    "start": "3710930",
    "end": "3718005"
  },
  {
    "text": "But all the items here are\nbigger than all the items here are bigger than all\nof the items here are bigger than all the items here. Now what about from\nlevel to level?",
    "start": "3718006",
    "end": "3725509"
  },
  {
    "text": "This is a little more subtle. What we know is this.",
    "start": "3725510",
    "end": "3730880"
  },
  {
    "text": " So again, we know that all\nthe down buffers are sorted.",
    "start": "3730880",
    "end": "3736380"
  },
  {
    "text": "And we know that\nthis down buffer, all these items come before\nall this down buffer items. But these up buffer\nitems, we don't know yet,",
    "start": "3736380",
    "end": "3743140"
  },
  {
    "text": "because they're still moving up. Now we know this. They need to move up.",
    "start": "3743140",
    "end": "3748361"
  },
  {
    "text": "But we still don't\nknow how far up. We don't know how these\nitems compare to these items. Or these items could\nhave to go higher,",
    "start": "3748362",
    "end": "3754590"
  },
  {
    "text": "could be they belong here,\nor are here, who knows. So basically, the down buffers\nare more or less sorted.",
    "start": "3754590",
    "end": "3761280"
  },
  {
    "text": "And so the mins are going\nto be down at the bottom. And the up buffer items, I\nmean, they're still moving up. We don't know where\nthey belong, yet.",
    "start": "3761280",
    "end": "3767430"
  },
  {
    "text": "But eventually they'll\nfind their place and start trickling down. Roughly speaking, an item\nwill go up for a while",
    "start": "3767430",
    "end": "3773001"
  },
  {
    "text": "and then come back down. Although, that's\nnot literally true. It's roughly true. ",
    "start": "3773001",
    "end": "3781100"
  },
  {
    "text": "I should say something\nabout how we actually store this in memory, because\nthe whole name of the game",
    "start": "3781100",
    "end": "3788240"
  },
  {
    "text": "is how you lay\nthings out in memory. In cache-oblivious, that's all\nyou get to choose, basically. The rest is algorithm,\nregular RAM algorithm.",
    "start": "3788240",
    "end": "3796700"
  },
  {
    "text": "And all we do is store\nthe items in order, say, from bottom to top. So store the entire C\nlevel, then the next level",
    "start": "3796700",
    "end": "3802400"
  },
  {
    "text": "up, to store these items\nas consecutive arrays. That's what we need to.",
    "start": "3802400",
    "end": "3808190"
  },
  {
    "text": "Leave enough space for x to\nthe 1/2 down buffers, each at size theta x. ",
    "start": "3808190",
    "end": "3834430"
  },
  {
    "text": "So how do we do\ninserts and deletes?",
    "start": "3834430",
    "end": "3839839"
  },
  {
    "start": "3839840",
    "end": "3846814"
  },
  {
    "text": "Let's start with insert. As I mentioned, we want to start\nby inserting in the bottom,",
    "start": "3846814",
    "end": "3853695"
  },
  {
    "text": "until we run out of\nroom in the bottom. And then things\nhave to trickle up. So here's the basic algorithm.",
    "start": "3853695",
    "end": "3859583"
  },
  {
    "start": "3859583",
    "end": "3872770"
  },
  {
    "text": "You look at the bottom level. You stick the item\ninto the up buffer.",
    "start": "3872770",
    "end": "3878030"
  },
  {
    "text": "This is not necessarily\nthe right thing to do. So here, you stick it\ninto the up buffer. But these things are supposed\nto be roughly sorted.",
    "start": "3878030",
    "end": "3884390"
  },
  {
    "text": "So once you stick it there,\nyou say, oh, well maybe I have to go down here. Go down here. The point is the up\nbuffer is the only one",
    "start": "3884390",
    "end": "3890650"
  },
  {
    "text": "I want to be growing in size. So I insert into the up buffer. And say, oh, potentially\nI have to swap down here.",
    "start": "3890650",
    "end": "3897369"
  },
  {
    "text": "Swap down here. I mean, this is constant size. I can afford to look at all\nthe items here in zero time",
    "start": "3897370",
    "end": "3903369"
  },
  {
    "text": "and find out which\nbuffer it belongs to. As I move the item\ndown here, I swap. So I take the max item here\nand move it up to here.",
    "start": "3903370",
    "end": "3911060"
  },
  {
    "text": "Move the max item from\nthe next down buffer and propagate it up, so that\nI keep these things in order.",
    "start": "3911060",
    "end": "3916630"
  },
  {
    "start": "3916630",
    "end": "3922529"
  },
  {
    "text": "Swap into bottom down\nbuffers if necessary--",
    "start": "3922530",
    "end": "3934030"
  },
  {
    "text": " or maybe, as necessary. You might have to\ndo a bunch of swaps.",
    "start": "3934030",
    "end": "3939909"
  },
  {
    "text": "But it's all constant.  And then the point\nis the only buffer",
    "start": "3939909",
    "end": "3947230"
  },
  {
    "text": "that got larger by one item was\nthe up buffer, because, here, we did swaps to preserve size.",
    "start": "3947230",
    "end": "3952480"
  },
  {
    "text": "And if that overflows, then\nwe do something interesting. ",
    "start": "3952480",
    "end": "3959580"
  },
  {
    "text": "And something interesting\nis called push. ",
    "start": "3959580",
    "end": "3966200"
  },
  {
    "text": "This is a separate team,\nwhich I'll define now.",
    "start": "3966200",
    "end": "3971720"
  },
  {
    "start": "3971720",
    "end": "3989000"
  },
  {
    "text": "So this is the\nbottom level push. But I wanted to find the\ngeneric level of push, which is we're going to be pushing\nx elements into level x",
    "start": "3989000",
    "end": "4001150"
  },
  {
    "text": "to the 3/2. ",
    "start": "4001150",
    "end": "4007500"
  },
  {
    "text": "So why is that? Check it out. If we're at level x and\nour up buffer overflows,",
    "start": "4007500",
    "end": "4016104"
  },
  {
    "text": "and we're trying to push\ninto the next level-- that's level x to 3/2-- then the up buffer that we're\ntrying to push has size x.",
    "start": "4016104",
    "end": "4025435"
  },
  {
    "text": "The up buffer has the same\nsize as the level name. So if we're at level\nx, this has size x.",
    "start": "4025435",
    "end": "4031190"
  },
  {
    "text": "We're trying to push x items\nup into the next thing. ",
    "start": "4031190",
    "end": "4038215"
  },
  {
    "text": "We're going to empty\nout the up buffer. Send all those items up there. ",
    "start": "4038215",
    "end": "4044330"
  },
  {
    "text": "Cool. So what do we do? How do we do this push? First thing we do\nis sort the items--",
    "start": "4044330",
    "end": "4051589"
  },
  {
    "text": "those x items. This is where I need\nthe black box, which is that we can sort\nN over B log base N",
    "start": "4051590",
    "end": "4059000"
  },
  {
    "text": "over B, N over B\ncache-obliviously. So we're going to use that here.",
    "start": "4059000",
    "end": "4065480"
  },
  {
    "text": "It's not hard, but I don't\nwant to spend time on it. Now the interesting bit\nis how we do the push.",
    "start": "4065480",
    "end": "4074480"
  },
  {
    "text": "The tricky part is we\nhave all these items, we know that they're bigger\nthan all the items below them. Maybe, here's a better picture.",
    "start": "4074480",
    "end": "4080770"
  },
  {
    "text": "We know these guys\nneed to go up. They're bigger than everything,\nall the down items below us.",
    "start": "4080770",
    "end": "4086300"
  },
  {
    "text": "But we don't know,\ndoes it fit here? Here? Here? Or here? But we do know that\nthese things are ordered.",
    "start": "4086300",
    "end": "4092480"
  },
  {
    "text": "And so if we sort these\nitems, then we can say, well, let's start\nby looking here. Do any of these items\nfit in this block?",
    "start": "4092480",
    "end": "4098989"
  },
  {
    "text": "Just look at the max, here. And if these guys are\nsmaller than the max, here, then they belong here.",
    "start": "4098990",
    "end": "4104818"
  },
  {
    "text": "So keep inserting there. Eventually, we'll get bigger\nthan the max, then we go here. Look at the max item, here.",
    "start": "4104819",
    "end": "4110649"
  },
  {
    "text": "As long as we have items here\nthat are smaller than the max here, insert, insert,\ninsert, insert, and so on.",
    "start": "4110649",
    "end": "4116810"
  },
  {
    "text": "And then when we're beyond\nall of these-- maybe we're immediately\nbeyond all of these. We have to check, oh,\nbigger than the max,",
    "start": "4116810",
    "end": "4122359"
  },
  {
    "text": "bigger than the max,\nbigger than the max. Then we put all the remaining\nitems into the up buffer.",
    "start": "4122359",
    "end": "4128370"
  },
  {
    "text": "This is called distribution. ",
    "start": "4128370",
    "end": "4151390"
  },
  {
    "text": "So we're looking at\nlevel x to the 3/2, and just scanning sequentially.",
    "start": "4151390",
    "end": "4157103"
  },
  {
    "text": " Because we just sorted them,\nwe're scanning them in order.",
    "start": "4157103",
    "end": "4165339"
  },
  {
    "text": "We visit the down\nbuffers in order. ",
    "start": "4165340",
    "end": "4178460"
  },
  {
    "text": "And insert into the appropriate\ndown buffer as we go. ",
    "start": "4178460",
    "end": "4183740"
  },
  {
    "text": "Now there's a little bit\nthat can happen, here. Our down buffers\nhave a limit in size.",
    "start": "4183740",
    "end": "4189710"
  },
  {
    "text": "Down buffers are supposed to\nhave size theta x at level x the 3/2. So as we're inserting into here,\na down buffer might overflow.",
    "start": "4189710",
    "end": "4197480"
  },
  {
    "text": "I've got theta slop, here. So when a down buffer overflows,\nI just split it in half. I then make two down buffers.",
    "start": "4197480",
    "end": "4204254"
  },
  {
    "text": "Well, actually,\nit would be, like, here and right next to it. I'm going to maintain a\nlinked list of down buffers.",
    "start": "4204254",
    "end": "4210920"
  },
  {
    "text": "And each of them will have\nspace for say, 2x items. But once I do a split,\nthey'll both be half full.",
    "start": "4210920",
    "end": "4219140"
  },
  {
    "text": "So when a down buffer\noverflows, split in half",
    "start": "4219140",
    "end": "4240670"
  },
  {
    "text": "and maintain a linked\nlist of down buffers. ",
    "start": "4240670",
    "end": "4248840"
  },
  {
    "text": "Another thing that can happen\nis when you increase the number down buffers, we have a limit\non how many down buffers",
    "start": "4248840",
    "end": "4254230"
  },
  {
    "text": "we can have-- up to x the 1/2 of them. So if we run out of down\nbuffers by splitting,",
    "start": "4254230",
    "end": "4260380"
  },
  {
    "text": "then we need to start\nusing the up buffer. So maybe here, we split,\nmaybe, this buffer--",
    "start": "4260380",
    "end": "4268860"
  },
  {
    "text": "is now too many\ndown buffers total. Then we'll just take\nall the elements in here and stick them into the\nup buffer, because that's",
    "start": "4268860",
    "end": "4275290"
  },
  {
    "text": "where they belong. So when the number\nof down buffers",
    "start": "4275290",
    "end": "4280840"
  },
  {
    "text": "is too big, when that\nnumber overflows,",
    "start": "4280840",
    "end": "4291599"
  },
  {
    "text": "move the last down buffer\ninto the up buffer.",
    "start": "4291600",
    "end": "4302720"
  },
  {
    "text": " So there's basically two\nways that elements are going",
    "start": "4302720",
    "end": "4309180"
  },
  {
    "text": "to get into the up buffer. One way is that we run\nout of down buffers, and so the last down\nbuffer starts getting",
    "start": "4309180",
    "end": "4314219"
  },
  {
    "text": "promoted into the up buffer. The other possibility\nis that we're inserting items that are\njust really big in value.",
    "start": "4314220",
    "end": "4321460"
  },
  {
    "text": "And if the items\nthat are getting promoted from here\ninto the next level just happen to be larger\nthan all these items,",
    "start": "4321460",
    "end": "4327430"
  },
  {
    "text": "we will immediately start\ninserting into the up buffer. But in general, we have to\nlook at this down buffer. Look at this one.",
    "start": "4327430",
    "end": "4332538"
  },
  {
    "text": "Look at this one, then that one. That is insert and push.",
    "start": "4332538",
    "end": "4338070"
  },
  {
    "text": "I think before I\ntalk about delete, I'd like to talk about the\nanalysis of just insert",
    "start": "4338070",
    "end": "4343170"
  },
  {
    "text": "and push. Keep it simple. And then I'll briefly\ntell you about deletion. ",
    "start": "4343170",
    "end": "4371620"
  },
  {
    "text": "Oh, I didn't say. Sorry. There's one more step,\nwhich is the recursion. ",
    "start": "4371620",
    "end": "4377990"
  },
  {
    "text": "Running out a room, here. Maybe I'll go over here. This is nothing relevant. ",
    "start": "4377990",
    "end": "4391112"
  },
  {
    "text": "So I need to recurse somehow.  At some point, inserting things\ninto the up offer, the up",
    "start": "4391112",
    "end": "4398740"
  },
  {
    "text": "buffer might overflow. That's the one last thing\nthat could overflow. When that happens, I just\npush it to the next level up.",
    "start": "4398740",
    "end": "4404680"
  },
  {
    "start": "4404680",
    "end": "4432030"
  },
  {
    "text": "So as we do\ninsertions in here, we might start inserting\na lot into here.",
    "start": "4432030",
    "end": "4437070"
  },
  {
    "text": "Eventually, this\nwill get too big. It's supposed to\nhave size x the 3/2. If it gets bigger than\nthat, take all these items",
    "start": "4437070",
    "end": "4442350"
  },
  {
    "text": "and just recursively push\nthem up to the next level. And conveniently, that's\nexactly the same size",
    "start": "4442350",
    "end": "4448010"
  },
  {
    "text": "as we were doing before. Here, we did x into\nlevel x to the 3/2. Next will be x to the 3/2 into\nlevel x to the 9/4, and so on.",
    "start": "4448010",
    "end": "4456646"
  },
  {
    "text": "Always the size\nof the up buffer. ",
    "start": "4456646",
    "end": "4462040"
  },
  {
    "text": "So the claim is if we\nlook at the push at level x to the 3/2-- which is what we\njust described--",
    "start": "4462040",
    "end": "4469679"
  },
  {
    "text": "and we ignore the recursion. ",
    "start": "4469680",
    "end": "4480910"
  },
  {
    "text": "Then the cost is x over B log\nbase M over B of x over B--",
    "start": "4480910",
    "end": "4491560"
  },
  {
    "text": "so sorting bound on x items. So we spend that right away\nin the very first step.",
    "start": "4491560",
    "end": "4497800"
  },
  {
    "text": "We sort x items. So that costs x over B. It has\nlog base M over B of x over B.",
    "start": "4497800",
    "end": "4504592"
  },
  {
    "text": "And the whole point\nof the analysis is to show that this\ndistribution step doesn't cost any more than the sorting step.",
    "start": "4504592",
    "end": "4511120"
  },
  {
    "text": " So let's prove this claim.",
    "start": "4511120",
    "end": "4519220"
  },
  {
    "text": "And the first\nobservation-- maybe, don't even need to\nwrite this down.",
    "start": "4519220",
    "end": "4524830"
  },
  {
    "text": "So remember, with\ncache-oblivious b-trees, we looked at a\nlevel of detail that was sort of the\nrelevant one that",
    "start": "4524830",
    "end": "4530224"
  },
  {
    "text": "straddled B. Now we\nhave this data structure and there's no longer recursive\nlevels in this picture.",
    "start": "4530224",
    "end": "4536800"
  },
  {
    "text": "It's just a list. But one of the things\nwe said is that if you look at the very\nsmall structures, those are free because\nthey just stay in cache.",
    "start": "4536800",
    "end": "4544119"
  },
  {
    "text": "I'm going to assume-- it's a little bit of a\nbastardization of notation-- assume that all the levels\nup to M fit in cache.",
    "start": "4544120",
    "end": "4552309"
  },
  {
    "text": "It's really up to, like,\nsize M over 2 or something, but let's just call it all. If x is less than\nM, then you know",
    "start": "4552310",
    "end": "4558550"
  },
  {
    "text": "all this stuff has size order\nM. And so let's just say-- by redefining what M is\nby a constant factor--",
    "start": "4558550",
    "end": "4564400"
  },
  {
    "text": "that just fits in cache. Because we can assume\nwhatever cache replacement strategy we want,\nassume that these things",
    "start": "4564400",
    "end": "4571090"
  },
  {
    "text": "stay in cache forever. So all of that bottom\nstuff, size up to M,",
    "start": "4571090",
    "end": "4580599"
  },
  {
    "text": "is permanently in cache\nand costs zero to access. So those levels are for free.",
    "start": "4580600",
    "end": "4585790"
  },
  {
    "text": "So it's all about when we\ntouch the upper levels. And, really, the\nmost important level would be the transition\nfrom the things that",
    "start": "4585790",
    "end": "4592180"
  },
  {
    "text": "fit in cache to the next level\nup that does not fit in cache. That's going to\nbe the key level. But in general,\nlet's look at push.",
    "start": "4592180",
    "end": "4604020"
  },
  {
    "text": "Or let's just assume x to\nthe 3/2 is bigger than M.",
    "start": "4604020",
    "end": "4617500"
  },
  {
    "text": "Because we're looking at a\npush at level x to the 3/2. And just by definition, if\nit's less than M, it's free.",
    "start": "4617500",
    "end": "4624969"
  },
  {
    "text": "Question? AUDIENCE: So how can\nyou assume that all of the things below\nthat particular size",
    "start": "4624970",
    "end": "4631471"
  },
  {
    "text": "always stay in cache empty? So you're making assumptions\non the cache replacement? ERIK DEMAINE: I'm\nmaking assumption",
    "start": "4631471",
    "end": "4636520"
  },
  {
    "text": "on the cache replacement\nstrategy, which I actually made last lecture. So I said, magically\nassume that we",
    "start": "4636520",
    "end": "4642850"
  },
  {
    "text": "use optimal cache replacement. So whatever I choose, opt is\ngoing to be better than that.",
    "start": "4642850",
    "end": "4649820"
  },
  {
    "text": "So you're right. The algorithm doesn't get to\nchoose what stays in cache. But for analysis purposes,\nI can say well, suppose",
    "start": "4649820",
    "end": "4655659"
  },
  {
    "text": "all these things stay in cache. If I prove an upper\nbound in that world, then the optimal\nreplacement will do better.",
    "start": "4655660",
    "end": "4662790"
  },
  {
    "text": "And the LRU or FIFO\nreplacement will do within a constant\nfactor of that,",
    "start": "4662790",
    "end": "4669940"
  },
  {
    "text": "again, by changing M\nby a constant factor. So I'm freely throwing away\nconstant factors in my cache size, but then I will get\nthat these effectively",
    "start": "4669940",
    "end": "4678080"
  },
  {
    "text": "stay in cache. FIFO or LRU will do that just\nas well, or almost as well.",
    "start": "4678080",
    "end": "4684010"
  },
  {
    "text": "Good question. So now we can just look at\nthe pushes above that level. And I really want to look\nat this transition level,",
    "start": "4684010",
    "end": "4690590"
  },
  {
    "text": "but we're going to have\nto look at all of them. So let's do this. Now I also have tall\ncache assumption.",
    "start": "4690590",
    "end": "4699850"
  },
  {
    "text": "M is at least B to\nthe 1 plus epsilon. I actually want a somewhat\nbigger assumption,",
    "start": "4699850",
    "end": "4705170"
  },
  {
    "text": "which is that M is greater\nthan or equal to B squared. If it's not B squared,\nyou have to change",
    "start": "4705170",
    "end": "4711940"
  },
  {
    "text": "this 3/2 and 9/4 and stuff\nto be something a little bit bigger than 1. And it gets really messy\nto write that down.",
    "start": "4711940",
    "end": "4718699"
  },
  {
    "text": "So this data structure with\nappropriate modification does work for other\ntall cache assumptions, but let's just assume this one.",
    "start": "4718700",
    "end": "4724780"
  },
  {
    "text": "So this means M over B\nis at least B. That's sort of the clean statement.",
    "start": "4724780",
    "end": "4729940"
  },
  {
    "text": "It's true for most caches also,\nbut this will be my assumption.",
    "start": "4729940",
    "end": "4736330"
  },
  {
    "text": "OK. Cool. So if we just do some algebra.",
    "start": "4736330",
    "end": "4743050"
  },
  {
    "text": "Claim is this is x is\ngreater than B to the 4/3.",
    "start": "4743050",
    "end": "4748369"
  },
  {
    "text": "So that's just taking\nthis inequality, x the 3/2 is greater than\nor equal to B squared",
    "start": "4748370",
    "end": "4754420"
  },
  {
    "text": "and raising to\nthe exponent, 2/3. And so this turns\ninto x and this turns into B to the 2 times\n2/3, which would be the 4/3.",
    "start": "4754420",
    "end": "4761570"
  },
  {
    "text": "So x is quite a\nbit bigger than B. In particular, this means that\nx over B is bigger than 1,",
    "start": "4761570",
    "end": "4770800"
  },
  {
    "text": "by a lot. But if we take ceiling's\non this, no big deal. So we don't have to\nworry about the ceilings.",
    "start": "4770800",
    "end": "4777751"
  },
  {
    "text": "All right. Now the claim is that the\ndistribution step costs--",
    "start": "4777751",
    "end": "4786380"
  },
  {
    "text": "this is really the\ninteresting part-- x over B plus x to the\n1/2 memory transfers.",
    "start": "4786380",
    "end": "4794030"
  },
  {
    "text": " OK. Why?",
    "start": "4794030",
    "end": "4799730"
  },
  {
    "text": "Remember, up here we have\nx to 1/2 down buffers that we're looking at. And we're visiting\nthem in order.",
    "start": "4799730",
    "end": "4805940"
  },
  {
    "text": "We touch this down buffer. And really, we just care\nabout the max, here.",
    "start": "4805940",
    "end": "4812990"
  },
  {
    "text": "And then we start writing\nelements one by one. But if we write\nelements one by one, the very first element we\nwrite costs an entire memory",
    "start": "4812990",
    "end": "4820231"
  },
  {
    "text": "transfer. We have to load in a block. But then we can fill that block\nand then write out that block.",
    "start": "4820231",
    "end": "4825300"
  },
  {
    "text": "So we get to write out\nB items in one step. So we pay x to\nthe 1/2 because we",
    "start": "4825300",
    "end": "4831050"
  },
  {
    "text": "have to touch the last\nblock of this down buffer, this down buffer,\nthis down buffer.",
    "start": "4831050",
    "end": "4837320"
  },
  {
    "text": "And they're x to the\n1/2 down buffers. So each one, we have to pay 1. That's this part. That's the expensive part.",
    "start": "4837320",
    "end": "4843377"
  },
  {
    "text": "But then, once we're\nactually writing items, if we stay here for a while,\nthat's basically for free.",
    "start": "4843377",
    "end": "4848900"
  },
  {
    "text": "Overall, we're writing x items. And so to write them all will\nonly take x over B ceiling,",
    "start": "4848900",
    "end": "4855920"
  },
  {
    "text": "sort of, over the\nentire summation. But we have to pay 1 to start\nout here, here, and here.",
    "start": "4855920",
    "end": "4862700"
  },
  {
    "text": "So this is the real\namount of time. And I want to amortize\nthat, essentially.",
    "start": "4862700",
    "end": "4868000"
  },
  {
    "text": " So there's two cases now.",
    "start": "4868000",
    "end": "4874610"
  },
  {
    "text": "If x is greater than or equal\nto B squared, then we're happy.",
    "start": "4874610",
    "end": "4880489"
  },
  {
    "text": "x is greater than or\nequal to B squared, then this term dominates.",
    "start": "4880490",
    "end": "4887510"
  },
  {
    "text": "And so this is tinier. All right. Say, x is B cubed, then\nthis is x to the 3/2--",
    "start": "4887510",
    "end": "4895010"
  },
  {
    "text": "sorry, this is the B to the 3/2. This is B squared,\nso this is bigger. And so then the cost\nis just x over B.",
    "start": "4895010",
    "end": "4904610"
  },
  {
    "text": "And we're done, because\nwe needed to prove it's x over B times log. We had to do this to sort, but\nthis distribution will be free.",
    "start": "4904610",
    "end": "4911690"
  },
  {
    "text": "Now that says all the\nhigh levels are free. All the low levels are free.",
    "start": "4911690",
    "end": "4916990"
  },
  {
    "text": " If you're less than B\nsquared, then your less than M and you're free.",
    "start": "4916990",
    "end": "4922354"
  },
  {
    "text": "It's saying, if you're bigger\nthan B squared, you're free. But there's going to be one\nlevel right in between where",
    "start": "4922354",
    "end": "4927710"
  },
  {
    "text": "you're not really\nbigger or smaller. ",
    "start": "4927710",
    "end": "4933100"
  },
  {
    "text": "So there's one level where it's\ngoing to B to the 4/3 less than",
    "start": "4933100",
    "end": "4940770"
  },
  {
    "text": "or equal to x less than\nor equal to B squared, strictly less than.",
    "start": "4940770",
    "end": "4945860"
  },
  {
    "text": "Because you're jumping in\nthis doubly exponential way, you might miss slightly.",
    "start": "4945860",
    "end": "4951179"
  },
  {
    "text": "And so you're in between\nthese two levels. ",
    "start": "4951180",
    "end": "4956920"
  },
  {
    "text": "Why is this? Because we only know that x\nto the 3/2 is less than M. We don't know that\nx is less than M.",
    "start": "4956920",
    "end": "4964400"
  },
  {
    "text": "So we have a bit of slot there. ",
    "start": "4964400",
    "end": "4972790"
  },
  {
    "text": "So then at this transition\npoint, what we do",
    "start": "4972790",
    "end": "4979720"
  },
  {
    "text": "is say, OK, we can't afford\nto store this whole-- x to 3/2",
    "start": "4979720",
    "end": "4986140"
  },
  {
    "text": "is not less than M.\nSo we can't afford to store all this in the cache. But we can afford to store\nthe last block of this guy",
    "start": "4986140",
    "end": "4992825"
  },
  {
    "text": "and the last block\nof this guy, all the down buffers we can store\nthe last block in cache. Why?",
    "start": "4992825",
    "end": "4999340"
  },
  {
    "text": "Because there's only\nx to the 1/2 of them.",
    "start": "4999340",
    "end": "5005409"
  },
  {
    "text": "And we know that x is\nless than B squared. So if x is less than B\nsquared, x to the 1/2",
    "start": "5005410",
    "end": "5012690"
  },
  {
    "text": "is less than B, which\nis less than M over B because M is least B squared,\nby tall cache assumption.",
    "start": "5012690",
    "end": "5020560"
  },
  {
    "text": "So this is the number of blocks\nthat we can afford in cache. This is number of\nblocks we want. I want 1 block\nfor each of these.",
    "start": "5020560",
    "end": "5027219"
  },
  {
    "text": "So basically then,\nthis x to the one half term disappears for the\none transition level.",
    "start": "5027220",
    "end": "5033520"
  },
  {
    "text": "So this is free. Because you can afford 1 block\nper down buffer in cache.",
    "start": "5033520",
    "end": "5051719"
  },
  {
    "text": "And so, again, we\nget an x over B cost. So the distribution\nis basically free.",
    "start": "5051720",
    "end": "5059100"
  },
  {
    "text": "The hard part is the sorting. And then the idea\nis that, well, OK--",
    "start": "5059100",
    "end": "5064200"
  },
  {
    "text": "now this is one push. When we do an insert, that item\nmight get pushed many times,",
    "start": "5064200",
    "end": "5069929"
  },
  {
    "text": "but basically can only\nget pushed once per level. So you end up taking this cost\nand summing it over all x.",
    "start": "5069930",
    "end": "5077970"
  },
  {
    "text": "So if you look at an insertion,\namortize what you pay-- or you look at the sum\nover all these things.",
    "start": "5077970",
    "end": "5085170"
  },
  {
    "text": " You get the sorting bound\non x-- summed over x where x",
    "start": "5085170",
    "end": "5092310"
  },
  {
    "text": "is growing doubly exponential. And so this becomes a\ngeometric series, or even super geometric.",
    "start": "5092310",
    "end": "5098310"
  },
  {
    "text": "And so you get-- I guess I should look\nat it per element.",
    "start": "5098310",
    "end": "5103650"
  },
  {
    "text": "You look at the amortized\ncost per element, so I get to divide by x.",
    "start": "5103650",
    "end": "5108780"
  },
  {
    "text": "Because when I do a\npush, I push x elements. So I get to divide by x, here. And then if an element\ngets pushed to all levels,",
    "start": "5108780",
    "end": "5115450"
  },
  {
    "text": "I have to sum over\nall these x's. But you do this summation\nand you get order--",
    "start": "5115450",
    "end": "5120920"
  },
  {
    "text": "it's dominated by the last term. ",
    "start": "5120920",
    "end": "5127360"
  },
  {
    "text": "Sorry, this should be N. This is the fun part.",
    "start": "5127360",
    "end": "5133350"
  },
  {
    "text": "We're taking logs, here,\nbut conveniently this was doubly exponential\ngrowing, the x over B.",
    "start": "5133350",
    "end": "5138659"
  },
  {
    "text": "So when we sum these\nis singly exponential. So it's a geometric series.",
    "start": "5138660",
    "end": "5144020"
  },
  {
    "text": "And so we are just dominated\nby the last term, which is where we get log base\nM over B of N over B. And this is our amortized\ncost per insertion.",
    "start": "5144020",
    "end": "5154320"
  },
  {
    "text": "Deletions are\nbasically the same. You just two pulls\ninstead of pushes. And you have, sort of, the\nreverse of a distribution",
    "start": "5154320",
    "end": "5160440"
  },
  {
    "text": "step-- in some\nways, even simpler. You don't have to do\nthis clever analysis.",
    "start": "5160440",
    "end": "5165840"
  },
  {
    "text": "Question? AUDIENCE: Can you\nexplain, once again, how is it that you got the\ndistributed cost of x over B?",
    "start": "5165840",
    "end": "5171173"
  },
  {
    "text": "So I understand\nthat every time, you need to pay that x to the\n1/2 because you need to load. But where did the x over B come?",
    "start": "5171173",
    "end": "5177170"
  },
  {
    "text": "ERIK DEMAINE: This\nis essentially amortized per element. We're just paying 1 over B.\nOnce the block has been loaded--",
    "start": "5177170",
    "end": "5182580"
  },
  {
    "text": "it's only after we\ninsert B items that we have to load another item. So that's why it's\nx over B, here.",
    "start": "5182580",
    "end": "5189940"
  },
  {
    "text": "Good. Question? AUDIENCE: Which buffers do\nwe keep sorted at all times? ERIK DEMAINE: Which buffer--",
    "start": "5189940",
    "end": "5195530"
  },
  {
    "text": "AUDIENCE: Which buffers\ndo we keep sorted? ERIK DEMAINE: We're only going\nto keep the very bottom buffer sorted at all times.",
    "start": "5195530",
    "end": "5201330"
  },
  {
    "text": "So I mean, it doesn't\nreally matter. You don't even have\nto keep those sorted, because you can afford\nto look at all of them. AUDIENCE: [INAUDIBLE] I\nthink the upper levels when",
    "start": "5201330",
    "end": "5207048"
  },
  {
    "text": "we're trying to figure\nout where it goes? ERIK DEMAINE: What we do\nneed-- we don't need them in sorted order. But we need to know\nwhere the max is, yeah.",
    "start": "5207048",
    "end": "5215130"
  },
  {
    "text": "So I guess, maybe, maintain\na linked list of the items would be one way to do it. So the sort order is in there,\nbut they're not physically",
    "start": "5215130",
    "end": "5221880"
  },
  {
    "text": "stored in sorted order. That would be a little bit\ntoo much to hope for, I think. Yeah. We do need to keep\ntrack of the max,",
    "start": "5221880",
    "end": "5227919"
  },
  {
    "text": "but that's easy to do\nas you're inserting. Cool. So that's priority queues.",
    "start": "5227919",
    "end": "5233790"
  },
  {
    "text": "You can look at the\nnotes for deletions.",
    "start": "5233790",
    "end": "5236670"
  }
]