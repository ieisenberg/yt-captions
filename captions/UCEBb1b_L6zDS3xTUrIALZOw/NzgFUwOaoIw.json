[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13330"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13330",
    "end": "21470"
  },
  {
    "text": "PROFESSOR: Let's get started. Welcome back to 6046. Today, we start\nan exciting series",
    "start": "21470",
    "end": "27660"
  },
  {
    "text": "of algorithms for graphs. We've done a lot\nof data structures. We're starting to get\nback into algorithms",
    "start": "27660",
    "end": "33910"
  },
  {
    "text": "with dynamic\nprogramming last week. And today and the\nnext few lectures, we're going to see lots of\ncool algorithms about graphs.",
    "start": "33910",
    "end": "42050"
  },
  {
    "text": "First a bit of\nrecall-- we're starting with shortest\npaths, which you've seen in 6006 in the context of\nsingle-source shortest paths.",
    "start": "42050",
    "end": "51250"
  },
  {
    "text": "So typically, like you do a\nGoogle Maps query, you think of, I want to go from A to B. But what you solved in 6006\nwas a harder problem, which",
    "start": "51250",
    "end": "59550"
  },
  {
    "text": "is I give you a point A-- here\nit's called S for the source. I give you a source vertex.",
    "start": "59550",
    "end": "66010"
  },
  {
    "text": "And capital V is a\nset of all vertices, capital E is a set of all\nedges, remember graph notation. Let's say it's a directed graph.",
    "start": "66010",
    "end": "72360"
  },
  {
    "text": "You've got edge\nweights, like the time it takes to traverse each road. And you want to\nknow how long's it",
    "start": "72360",
    "end": "78409"
  },
  {
    "text": "take me to get from\nS to V for all V. So this is from one given\npoint to everywhere.",
    "start": "78410",
    "end": "86580"
  },
  {
    "text": "Today, we're going\nto solve a harder problem, which is all-pairs. I want to go from all A to all\nB. But what you saw in 6006",
    "start": "86580",
    "end": "95029"
  },
  {
    "text": "was single-source, where I just\ngive you one of the vertices, and I want to know how\nto get to everywhere.",
    "start": "95029",
    "end": "100070"
  },
  {
    "text": "The reason you saw this version\nand not the A to B version is because the best way\nwe know to solve A to B",
    "start": "100070",
    "end": "105780"
  },
  {
    "text": "is to solve this problem. So at least from a\ntheory standpoint, we don't know how to\nbeat Dijkstra's algorithm",
    "start": "105780",
    "end": "111630"
  },
  {
    "text": "and Bellman-Ford's algorithm\nfor the A to B problem.",
    "start": "111630",
    "end": "116689"
  },
  {
    "text": "So you get a little bit\nmore than what you asked for sort of for the same price. So let me remind you in a\nfew different scenarios what",
    "start": "116690",
    "end": "128810"
  },
  {
    "text": "algorithms we have,\nand how long they take. ",
    "start": "128810",
    "end": "137170"
  },
  {
    "text": "So the scenarios of interest\nare the unweighted case, a non-negative weighted\ncase, the general case,",
    "start": "137170",
    "end": "152920"
  },
  {
    "text": "arbitrary weights,\npositive and negative, and DAGs acyclic graphs.",
    "start": "152920",
    "end": "158459"
  },
  {
    "text": " These are some\ninteresting special cases.",
    "start": "158460",
    "end": "164299"
  },
  {
    "text": "And you should have seen in 006\nalgorithms for each of them. Let's see if you remember.",
    "start": "164300",
    "end": "172290"
  },
  {
    "text": "So what's a good algorithm\nfor single-source shortest paths in an unweighted graph? BFS, good, Breadth-first\nSearch, that takes how long?",
    "start": "172290",
    "end": "181400"
  },
  {
    "text": " V plus E, good.",
    "start": "181400",
    "end": "187110"
  },
  {
    "text": "That's-- for graphs, V plus\nE is considered linear time. That's how long it takes\nto represent the input.",
    "start": "187110",
    "end": "192780"
  },
  {
    "text": "So you got to look at the\ninput, most algorithms, and the BFS is\noptimal against that.",
    "start": "192780",
    "end": "198110"
  },
  {
    "text": "But we're going to start\ngetting worse as we-- well, for these two situations. So for non-negative edge\nweights, what do you use?",
    "start": "198110",
    "end": "205630"
  },
  {
    "text": "Dijkstra. Ah, everyone's\nawake this morning. That's impressive.",
    "start": "205630",
    "end": "210870"
  },
  {
    "text": "And that takes how long? This is a tricky question. V log V plus E, wow, nice.",
    "start": "210870",
    "end": "218460"
  },
  {
    "text": "So this answer kind of depends\non which heap structure you use, but this\nis the best we know.",
    "start": "218460",
    "end": "225140"
  },
  {
    "text": "If you use a Fibonacci heap,\nwhich we don't actually cover but it's in\nthe textbook, you",
    "start": "225140",
    "end": "230530"
  },
  {
    "text": "achieve log V for extract\nkey and constant amortized for each decreased\nkey operation.",
    "start": "230530",
    "end": "238690"
  },
  {
    "text": "So sorry, this is\nfor extracted min, and this is for decrease key. And so this is the\nbest we know how to do with a Dijkstra-type approach.",
    "start": "238690",
    "end": "244730"
  },
  {
    "text": "If you use other heaps,\nyou get slightly worse, maybe you get a log factor here. But this is good. This is almost as good as V plus\nE. For moderately dense graphs,",
    "start": "244730",
    "end": "254280"
  },
  {
    "text": "if E is bigger than V log\nV, then these are the same. But if your graph is\nsparse, like E is order V,",
    "start": "254280",
    "end": "261396"
  },
  {
    "text": "then you lose a log factor. But hey, it's just a\nlog factor, not too bad. We're going to get worse. So for general weights,\nwhat do you use?",
    "start": "261396",
    "end": "269439"
  },
  {
    "text": "Bellman-ford. ",
    "start": "269439",
    "end": "276291"
  },
  {
    "text": "OK. Which takes how long? VE, that's the usual statement.",
    "start": "276291",
    "end": "281750"
  },
  {
    "text": "Technically, you should\nassume VE is at least V for this bound to hold. But that's the way\nto think of it.",
    "start": "281750",
    "end": "288189"
  },
  {
    "text": "So this is not nearly as good. This is a lot slower. If you think of-- we can\nthink of two situations.",
    "start": "288190",
    "end": "296210"
  },
  {
    "text": "One is when E is theta V, so a\nvery sparse graph like a tree or planar graph or something.",
    "start": "296210",
    "end": "302070"
  },
  {
    "text": "And we could think of\nwhen E is quadratic. That's the dense case.",
    "start": "302070",
    "end": "307200"
  },
  {
    "text": "So here we get, whatever,\nV and V squared for BFS.",
    "start": "307200",
    "end": "316710"
  },
  {
    "text": "For non-negative edge weights we\nget V log V in the sparse case. And we get V squared\nin the dense case.",
    "start": "316710",
    "end": "324880"
  },
  {
    "text": "And for Bellman-Ford, we get\nV squared in the sparse case, and V cubed in the dense case.",
    "start": "324880",
    "end": "331640"
  },
  {
    "text": "So this is like a V\nfactor, a linear factor larger than non-negative\nedge weights--",
    "start": "331640",
    "end": "336890"
  },
  {
    "text": "makes a huge difference. And finally for acyclic\ngraphs, what do you do?",
    "start": "336890",
    "end": "342180"
  },
  {
    "text": " STUDENT: Dynamic programming. PROFESSOR: Dynamic programming\nis one answer, yeah.",
    "start": "342180",
    "end": "349130"
  },
  {
    "text": "That works. In some sense all\nof these algorithms are-- especially Bellman-Ford\nis a dynamic program. We'll see that little bit.",
    "start": "349130",
    "end": "355639"
  },
  {
    "text": "Another interpretation?  Topological sort, and\nthen Bellman-Ford,",
    "start": "355640",
    "end": "361930"
  },
  {
    "text": "yeah-- say, one round\nof Bellman-Ford.",
    "start": "361930",
    "end": "374539"
  },
  {
    "text": "So Bellman-Ford actually\nworks really well if you know the order you\nshould relax the edges. And if in an acyclic graph,\nyou can do a topological sort,",
    "start": "374540",
    "end": "382000"
  },
  {
    "text": "meaning you visit\nall the vertices, so that whenever you visit\nthe right endpoint of an edge, you've already visited\nthe left endpoint.",
    "start": "382000",
    "end": "388250"
  },
  {
    "text": "If you do Bellman-Ford\nin that order, then you only have to do one\npass and you're done. Whereas normally, here,\nyou had to do it V times.",
    "start": "388250",
    "end": "396960"
  },
  {
    "text": "So the total cost of\nthis is just linear.  Good thing to remember,\nespecially on quizzes",
    "start": "396960",
    "end": "403860"
  },
  {
    "text": "and so on. If your graph is acyclic,\nyou can achieve linear time. But in the general\ncase, Bellman-Ford",
    "start": "403860",
    "end": "409530"
  },
  {
    "text": "is your answer\nfor single source. Now, these are the\nbest algorithms",
    "start": "409530",
    "end": "415270"
  },
  {
    "text": "we know for each of these cases. So I'm not going to\nimprove them today. You saw the state\nof the art 006.",
    "start": "415270",
    "end": "421890"
  },
  {
    "text": "But for all-pair shortest\npaths, we can in some sense do better, sort of.",
    "start": "421890",
    "end": "427770"
  },
  {
    "text": "So let me just quickly\ndefine the problem, and then tell you all\nof the results we know.",
    "start": "427770",
    "end": "434400"
  },
  {
    "text": " And also, the results\nwe're going to cover today.",
    "start": "434400",
    "end": "440710"
  },
  {
    "start": "440710",
    "end": "453850"
  },
  {
    "text": "I didn't remind you of\nthe delta definition. I want to go over this briefly. So delta of s comma\nv is the weight",
    "start": "453850",
    "end": "460910"
  },
  {
    "text": "of the shortest path from S to\nV. The weight is well-defined. Even though there may\nbe many shortest paths,",
    "start": "460910",
    "end": "465990"
  },
  {
    "text": "there's one best weight. But there's some special cases. It could be infinity,\nif there's no path.",
    "start": "465990",
    "end": "474420"
  },
  {
    "text": "That's sort of by definition. Say, well, it's infinite costs\nto get-- if there's no path, then we said there's\ninfinite weight one.",
    "start": "474420",
    "end": "482340"
  },
  {
    "text": "And it could be minus\ninfinity in the presence of negative weight cycles.",
    "start": "482340",
    "end": "489551"
  },
  {
    "text": "So let's say, if there's\na negative weight cycle on the way, if you\ncould reach a negative weight",
    "start": "489551",
    "end": "497539"
  },
  {
    "text": "cycle from s, and then still\nget to V from there, then the best way to get there\nis to go to that cycle loop",
    "start": "497540",
    "end": "504259"
  },
  {
    "text": "around infinitely many\ntimes, and then go to V. OK, so the algorithms\nyou saw probably",
    "start": "504260",
    "end": "509640"
  },
  {
    "text": "didn't actually compute\ncorrectly in this case. They just said,\nnegative weight cycle--",
    "start": "509640",
    "end": "515229"
  },
  {
    "text": "I don't know what to do. But it's actually not that hard. With a little bit\nmore effort, you can figure out where the\nnegative infinities are.",
    "start": "515230",
    "end": "520589"
  },
  {
    "text": "We're not going to rely\non that, but I'm just throwing it out there to make\nthis a well-defined definition.",
    "start": "520590",
    "end": "525914"
  },
  {
    "text": "Once you have the\nshortest path weights, you can also store\nparent pointers, get the shortest path\ntree, then you can actually",
    "start": "525914",
    "end": "531470"
  },
  {
    "text": "find shortest paths. But again, we're not\ngoing to talk about here. We'll focus on computing delta,\nbut with the usual techniques",
    "start": "531470",
    "end": "538470"
  },
  {
    "text": "you saw in 006, you could\nalso reconstruct paths.",
    "start": "538470",
    "end": "543980"
  },
  {
    "text": "So for all-pairs shortest\npaths, we have a similar set-up.",
    "start": "543980",
    "end": "551040"
  },
  {
    "text": "We have a directed graph, V,E.\nAnd we have an edge weight function w-- in general,\ncould have negative weights.",
    "start": "551040",
    "end": "558430"
  },
  {
    "text": "And our goal is to find delta of\nu comma v for all u and v. OK.",
    "start": "558430",
    "end": "570779"
  },
  {
    "text": "Single-source shortest\npaths is the sort of thing that you might want to do\na few-- just given a graph,",
    "start": "570780",
    "end": "576350"
  },
  {
    "text": "and you want to find a shortest\npath from A to B. I said, this is the best way we know\nhow to do A to B, essentially.",
    "start": "576350",
    "end": "582946"
  },
  {
    "text": "But all-pairs\nshortest paths is what you might want to do if\nyou're pre-processing. If you're Google\nMaps, and you want",
    "start": "582946",
    "end": "589050"
  },
  {
    "text": "to be able to very quickly\nsupport shortest path queries between major\ncities, then you",
    "start": "589050",
    "end": "594459"
  },
  {
    "text": "may want to first compute\nall-pair shortest paths for all major cities, because\nroad networks don't change",
    "start": "594460",
    "end": "600610"
  },
  {
    "text": "very much, the large scale. This is ignoring\ntraffic and so on. Pre-compute this, and then\ngiven a query of two vertices,",
    "start": "600610",
    "end": "609483"
  },
  {
    "text": "come in-- probably\nget a million queries a second-- you could\nvery quickly know what the answer is. And this is the basis for\nreal world shortest paths.",
    "start": "609484",
    "end": "617187"
  },
  {
    "text": "Typically, you don't compute\nshortest paths from A to B every single time. You use waypoints along the way.",
    "start": "617187",
    "end": "623220"
  },
  {
    "text": "And you have pre-computed\nall-pair shortest paths between waypoints. So that's the motivation. ",
    "start": "623220",
    "end": "629575"
  },
  {
    "text": "Yeah, I guess in some\nsense, internet routing is another situation\nwhere at any moment you may need to\nknow the shortest path to get to-- the\nfewest hop path say",
    "start": "629575",
    "end": "637950"
  },
  {
    "text": "to get to an internet site. You know the IP address. You need to know where to go. You don't need to\nknow the whole path.",
    "start": "637950",
    "end": "643080"
  },
  {
    "text": "You need to know the next step. But in some sense,\nyou're computing all-pair shortest paths. That's a more dynamic situation.",
    "start": "643080",
    "end": "649771"
  },
  {
    "text": "OK. So here are the results we know\nfor all-pair shortest paths. ",
    "start": "649771",
    "end": "658527"
  },
  {
    "text": "I think I'm going to cheat,\nand reuse this board.",
    "start": "658528",
    "end": "663540"
  },
  {
    "text": "So same situations,\nexcept I won't think",
    "start": "663540",
    "end": "668680"
  },
  {
    "text": "about acyclic graphs here. They're a little\nless interesting. ",
    "start": "668680",
    "end": "674899"
  },
  {
    "text": "Actually now, I'm\ncurious, but I didn't intend to talk about acyclic. ",
    "start": "674900",
    "end": "681410"
  },
  {
    "text": "And so the obvious thing to\ndo to solve all-pairs shortest paths is just run the single\nsource algorithm V times,",
    "start": "681410",
    "end": "688279"
  },
  {
    "text": "once from each source. So I could do V times\nBreadth-first Search, V times",
    "start": "688280",
    "end": "695240"
  },
  {
    "text": "Dijkstra, V times Bellman-Ford. And now, I just need\nto update my bounds.",
    "start": "695240",
    "end": "700265"
  },
  {
    "text": " OK so VE becomes\nV squared plus VE.",
    "start": "700265",
    "end": "708880"
  },
  {
    "text": "If you're a little bit clever,\nor you assume E is at least V,",
    "start": "708880",
    "end": "715740"
  },
  {
    "text": "that becomes VE. If I run Dijkstra\nV times, I'm going",
    "start": "715740",
    "end": "721899"
  },
  {
    "text": "to get V squared log\nV plus V times E.",
    "start": "721900",
    "end": "730080"
  },
  {
    "text": "And if I run Bellman-Ford\nV times, I get V squared E.",
    "start": "730080",
    "end": "741040"
  },
  {
    "text": "OK. And over here,\neverything's just going to increase by a V factor. So a little more intuitive is\nto think about the sparse case.",
    "start": "741040",
    "end": "747920"
  },
  {
    "text": "I get V squared, V squared\nlog V, and V cubed.",
    "start": "747920",
    "end": "754250"
  },
  {
    "text": "Check that those match\nover there-- 1 equals V. And over here, I get V cubed,\nV cubed, and V to the fourth.",
    "start": "754250",
    "end": "764290"
  },
  {
    "text": "OK. So pretty boring so far.",
    "start": "764290",
    "end": "769810"
  },
  {
    "text": "The interesting\nthing here is that we can beat the last result.\nThe last result, which",
    "start": "769810",
    "end": "775899"
  },
  {
    "text": "is the slowest one,\ncould take as long as V to the fourth time. We can shave off\na whole V factor.",
    "start": "775900",
    "end": "785310"
  },
  {
    "text": "So a better general\ncase algorithm",
    "start": "785310",
    "end": "790700"
  },
  {
    "text": "is called Johnson's algorithm. That will be the last\nalgorithm we cover today.",
    "start": "790700",
    "end": "797430"
  },
  {
    "text": "And it achieves\nthis bound, which",
    "start": "797430",
    "end": "806560"
  },
  {
    "text": "is the same as running\nDijkstra V times. So it's between V squared\nlog V and V cubed.",
    "start": "806560",
    "end": "818899"
  },
  {
    "text": "And that's cool, because\nthis is the best algorithm we know for all-pairs,\nnon-negative edge weight,",
    "start": "818900",
    "end": "825020"
  },
  {
    "text": "shortest paths, just\nrunning Dijkstra V times. Not very smart-- but it's the\nbest thing we know how to do.",
    "start": "825020",
    "end": "830810"
  },
  {
    "text": "And what this says is, even when\nwe have negative edge weights, actually we can achieve the\nsame bound as running Dijkstra.",
    "start": "830810",
    "end": "836980"
  },
  {
    "text": "This is a bit counter intuitive\nbecause in 006 you're always told, if you have negative edge\nweights, can't use Dijkstra.",
    "start": "836980",
    "end": "841990"
  },
  {
    "text": "Turns out, in the all-pairs\nshortest paths case, you kind of can. How can that be?",
    "start": "841990",
    "end": "847170"
  },
  {
    "text": "Because this is\na harder problem. If you could solve all-pairs\nshortest paths, of course you could solve single-source.",
    "start": "847170",
    "end": "854910"
  },
  {
    "text": "And that's actually the luxury. Because it's a\nharder problem, we have this VE term\nin the running time,",
    "start": "854910",
    "end": "861530"
  },
  {
    "text": "which lets us do things\nlike run Bellman-Ford once. And running\nBellman-Ford once will",
    "start": "861530",
    "end": "867860"
  },
  {
    "text": "let us run Dijkstra V times. That's the reason we\ncan achieve this bound.",
    "start": "867860",
    "end": "873610"
  },
  {
    "text": "But we won't be seeing\nthat for a while. For starters, I want to\nshow you some connections between all-pairs shortest\npaths, and dynamic programming,",
    "start": "873610",
    "end": "882300"
  },
  {
    "text": "and matrix multiplication,\nwhich turn out to give-- for\ndense graphs, we're",
    "start": "882300",
    "end": "889590"
  },
  {
    "text": "just achieving V cubed\nin all situations. So our first goal is going\nto be to achieve V cubed time",
    "start": "889590",
    "end": "897990"
  },
  {
    "text": "for general edge weights. So we're going to first\nachieve this bound. That will be a lot easier.",
    "start": "897990",
    "end": "904330"
  },
  {
    "text": "And then eventually, we\nwill achieve this bound. So the Floyd Warshall\nalgorithm and some of these",
    "start": "904330",
    "end": "911070"
  },
  {
    "text": "will get very close to V cubed. ",
    "start": "911070",
    "end": "918170"
  },
  {
    "text": "All right. So we're going to start\nwith our first approach to solving all-pairs\nshortest paths-- that is not",
    "start": "918170",
    "end": "925640"
  },
  {
    "text": "using an existing single\nsource algorithm-- is dynamic programming. ",
    "start": "925640",
    "end": "932350"
  },
  {
    "text": "Someone mentioned that already. It's a natural approach. Shortest paths is kind\nof dynamic programming.",
    "start": "932350",
    "end": "938079"
  },
  {
    "text": "In fact, most\ndynamic programs, you can convert to single-source\nshortest paths, typically in a DAG-- not all,\nbut a lot of them.",
    "start": "938080",
    "end": "947259"
  },
  {
    "text": "So we could try\ndynamic programming. Now, I'm going to preach\nto you a little bit",
    "start": "947260",
    "end": "953199"
  },
  {
    "text": "about my way of thinking\nabout dynamic programs. If you watched the\n006 OCW version, you've seen the five easy\nsteps to dynamic programming.",
    "start": "953200",
    "end": "962770"
  },
  {
    "text": "And if you haven't, this will\nbe new, otherwise, a reminder. First thing I like to think\nabout in a dynamic program",
    "start": "962770",
    "end": "968970"
  },
  {
    "text": "is, what are the subproblems? The second thing I like to think\nabout is, what am I guessing?",
    "start": "968970",
    "end": "974540"
  },
  {
    "text": " I'm going to guess some\nfeature of the solution.",
    "start": "974540",
    "end": "982320"
  },
  {
    "text": "Third thing is, I want to\nwrite a recurrence relating subproblems solutions.",
    "start": "982320",
    "end": "988339"
  },
  {
    "text": "Then, I'm basically\ndone, but there's a couple wrap up\nthings, which I'm",
    "start": "988340",
    "end": "993360"
  },
  {
    "text": "going to have to use\nanother board for. ",
    "start": "993360",
    "end": "1008490"
  },
  {
    "text": "So number four is, I need\nto check that I can actually",
    "start": "1008490",
    "end": "1015320"
  },
  {
    "text": "resolve these subproblems\nin some order that's valid. Basically, this is saying\nthat the constraint",
    "start": "1015320",
    "end": "1022550"
  },
  {
    "text": "graph on some problems\nshould be acyclic. Because if there's a cycle\nin the constraint graph, you take infinite time.",
    "start": "1022550",
    "end": "1028310"
  },
  {
    "text": "Even if you memoize, if you do\ninfinite recursion-- bad news. You'll never actually\nfinish anything, so you never actually write\nanything in the memo table.",
    "start": "1028310",
    "end": "1035029"
  },
  {
    "text": "So I want to make sure\nthat it's acyclic. I mean, this is\nreally the same thing we're talking about in\nthis erased row, which",
    "start": "1035030",
    "end": "1042230"
  },
  {
    "text": "is topological ordering. Personally, I like to-- you\ncould argue that it's acyclic.",
    "start": "1042230",
    "end": "1048199"
  },
  {
    "text": "I like to just write down,\nhere's a topological order. That's a nice proof\nthat it's acyclic. If you write that\ndown as for loops,",
    "start": "1048200",
    "end": "1054690"
  },
  {
    "text": "then you actually\nhave a bottom up dp. If you just take the recurrence,\nstick it inside the for loop,",
    "start": "1054690",
    "end": "1059710"
  },
  {
    "text": "you're done, which\nwe'll do in a moment. I guess I need a row for that.",
    "start": "1059710",
    "end": "1065640"
  },
  {
    "text": "And finally, you need to\nsolve the original problem.",
    "start": "1065640",
    "end": "1071529"
  },
  {
    "text": "And then, there's\nanalysis and so on. But for specifying\nthe algorithm, these are the key\nthings you need to know.",
    "start": "1071529",
    "end": "1077295"
  },
  {
    "text": "The hard part is figuring out\nwhat the subproblems should be, so that your dp becomes fast. Running time is going to\nbe number of subproblems",
    "start": "1077295",
    "end": "1083960"
  },
  {
    "text": "times time per subproblem. For each subproblem,\nusually we're",
    "start": "1083960",
    "end": "1089000"
  },
  {
    "text": "going to want to guess some\nfeature of the solution to that problem. Once we do that, the recurrence\nbecomes pretty trivial.",
    "start": "1089000",
    "end": "1096630"
  },
  {
    "text": "Just for each guess, you\nsay what it should be. So these are the\nreally hard two steps.",
    "start": "1096630",
    "end": "1102850"
  },
  {
    "text": "And then, OK, we checked\nthat it's acyclic. And we make sure\nthat we can actually solve our original problem\nusing one of the subproblems.",
    "start": "1102850",
    "end": "1109690"
  },
  {
    "text": "Sometimes, our original problems\nare some of the subproblems. I think that will happen here. But sometimes you need to do a\nlittle bit of post-computation",
    "start": "1109690",
    "end": "1117410"
  },
  {
    "text": "to get your answer. All right. So what am I going to\ndo for subproblems?",
    "start": "1117410",
    "end": "1124820"
  },
  {
    "text": "Well obviously, I have a bunch\nof different problems involving pairs of vertices.",
    "start": "1124820",
    "end": "1130700"
  },
  {
    "text": "I want to find delta of u,v for\nall u and v. That, I erased.",
    "start": "1130700",
    "end": "1136299"
  },
  {
    "text": "But that's the problem. So I want to know what is\nthe weight of the shortest",
    "start": "1136300",
    "end": "1144230"
  },
  {
    "text": "path from u to v?",
    "start": "1144230",
    "end": "1155020"
  },
  {
    "text": "If I stop there and said\nthat was my subproblems, bad things are going to\nhappen, because I will end up--",
    "start": "1155020",
    "end": "1161350"
  },
  {
    "text": "there's no natural way to\nmake this thing acyclic. If I want to solve u to\nv using, I don't know,",
    "start": "1161350",
    "end": "1166660"
  },
  {
    "text": "u to x, and then\nx to v, something like that-- there's\nno way to get out of the infinite recursion loop.",
    "start": "1166660",
    "end": "1173750"
  },
  {
    "text": "OK? So I need to add\nmore subproblems to add more features to my\nsolution, something that",
    "start": "1173750",
    "end": "1181690"
  },
  {
    "text": "makes it so that when I\ntry to solve my subproblem, I reduce it to\nother subproblems. Things get smaller, and so I\ncould actually make progress.",
    "start": "1181690",
    "end": "1190460"
  },
  {
    "text": "So there are actually two\nnatural ways to do this. I'll call them method\none a method two.",
    "start": "1190460",
    "end": "1196480"
  },
  {
    "text": "Method two is actually\nFloyd Warshall. But any suggestions on\nhow we might do this?",
    "start": "1196480",
    "end": "1201740"
  },
  {
    "text": "This is a harder problem. This is in some sense,\na kind of guessing, but it's like I'm\ngoing to guess ahead",
    "start": "1201740",
    "end": "1208580"
  },
  {
    "text": "of time that somehow\nthere's an important feature of the shortest path. I'm going to\nparameterize by that,",
    "start": "1208580",
    "end": "1214880"
  },
  {
    "text": "and somehow it's\ngoing to get smaller. ",
    "start": "1214880",
    "end": "1221978"
  },
  {
    "text": "Yeah? STUDENT: [INAUDIBLE]  PROFESSOR: Right,\nshortest path--",
    "start": "1221978",
    "end": "1227650"
  },
  {
    "text": "it uses at most a\ngiven number of edges. Let's parameterize\nby how many edges. I think I'll use m.",
    "start": "1227650",
    "end": "1232820"
  },
  {
    "text": " So using at most m edges.",
    "start": "1232820",
    "end": "1240095"
  },
  {
    "text": " Very good.",
    "start": "1240095",
    "end": "1245550"
  },
  {
    "text": "So good, I think it\ndeserves a purple Frisbee. All right, I'm getting\nbetter, slowly.",
    "start": "1245550",
    "end": "1251930"
  },
  {
    "text": "By the end the semester,\nI'll be pro at frisbee. I should enter a competition.",
    "start": "1251930",
    "end": "1257150"
  },
  {
    "text": "So this is, of course, an\nadditional restriction. But at the end of the day,\nthe problem I want to solve",
    "start": "1257150",
    "end": "1266990"
  },
  {
    "text": "is going to be essentially\nduv, let's say, n minus 1.",
    "start": "1266990",
    "end": "1272580"
  },
  {
    "text": " If I want a shortest\npath that does not",
    "start": "1272580",
    "end": "1277620"
  },
  {
    "text": "repeat any vertices,\nthen certainly it has at most n minus 1 edges.",
    "start": "1277620",
    "end": "1283210"
  },
  {
    "text": "So in fact, the claim would\nbe that duv equals duv n.",
    "start": "1283210",
    "end": "1288630"
  },
  {
    "text": "I mean, and so on. If you go larger than n minus\n1, it shouldn't help you. If you know that your\nshortest paths are",
    "start": "1288630",
    "end": "1294670"
  },
  {
    "text": "simple-- if you know that\nshortest paths don't repeat vertices. So this would be if there are\nno negative weight cycles.",
    "start": "1294670",
    "end": "1301635"
  },
  {
    "text": " If there are no\nnegative weight cycles,",
    "start": "1301635",
    "end": "1307380"
  },
  {
    "text": "then we know it never\nhelps to repeat vertices. So in that situation,\nwe would be",
    "start": "1307380",
    "end": "1313890"
  },
  {
    "text": "done, if we could\nsolve this for all m. Now, slight catch--\nwell, how do we",
    "start": "1313890",
    "end": "1318950"
  },
  {
    "text": "know there's no\nnegative weight cycles? You know, we could run\nBellman-Ford, I guess. That's a little tricky,\nbecause that only",
    "start": "1318950",
    "end": "1325760"
  },
  {
    "text": "finds reachable\nnegative weight cycles. In fact from this\npicture, we will end up knowing whether there are\nnegative weight cycles.",
    "start": "1325760",
    "end": "1334070"
  },
  {
    "text": "So there will be no negative\nweight cycles, if and only if there's no negative diagonal\nentry, say dvv n minus 1.",
    "start": "1334070",
    "end": "1347490"
  },
  {
    "text": "So it turns out,\nthis algorithm will detect there's a\nnegative weight cycle by finding that the distance\nfrom v to v is negative.",
    "start": "1347490",
    "end": "1353950"
  },
  {
    "text": "Initially, it's going to be 0. If it turns out\nto be negative, we know there's negative\nweight cycle. With more work,\nyou could actually",
    "start": "1353950",
    "end": "1359386"
  },
  {
    "text": "find all the reachable\npairs, and so on. But I'm not going to worry. I'm just going to say, hey,\na negative weight cycle. I'm going to throw my\nhands up in the air",
    "start": "1359386",
    "end": "1366008"
  },
  {
    "text": "and give up for today. OK.",
    "start": "1366008",
    "end": "1371471"
  },
  {
    "text": "Cool. So I can solve my\noriginal problem, if I can solve\nthese subproblems.",
    "start": "1371471",
    "end": "1377790"
  },
  {
    "text": "And now, things are easier,\nbecause we can essentially assume in solving this\nproblem that we've",
    "start": "1377790",
    "end": "1384289"
  },
  {
    "text": "solved smaller subproblems\nfor however we define smaller. That's what's given by\nthis topological order.",
    "start": "1384290",
    "end": "1390530"
  },
  {
    "text": "Obvious notion of\nsmaller is smaller m. Presumably, we\nwant to write this with an m in terms of this\nwith an m minus 1 or smaller.",
    "start": "1390530",
    "end": "1401570"
  },
  {
    "text": "So this gets to\nour guessing part. What feature of a\nshortest path could we",
    "start": "1401570",
    "end": "1408470"
  },
  {
    "text": "guess that would make\nit one edge shorter?  There's probably\ntwo good answers.",
    "start": "1408470",
    "end": "1414910"
  },
  {
    "text": "Yeah? The next edge, which I guess\nyou mean the first edge?",
    "start": "1414910",
    "end": "1420761"
  },
  {
    "text": "Sure. Could guess the\nfirst edge, or you could guess the second edge. Or no, that would be harder. Or I mean, the last edge,\nthat would also work.",
    "start": "1420761",
    "end": "1427570"
  },
  {
    "text": "Okay, this is a harder one. Uh, nope. Good thing there's students\neverywhere to catch it.",
    "start": "1427570",
    "end": "1436380"
  },
  {
    "text": "Cool. So I'm going to\nguess the last edge. That's just how I've\nwritten the notes. But first edge would\nalso work fine.",
    "start": "1436380",
    "end": "1442780"
  },
  {
    "text": " So I'll call the last\nedge x comma v. We",
    "start": "1442780",
    "end": "1451530"
  },
  {
    "text": "know we end by going into v. So\nlet's guess the vertex previous to it in the shortest path.",
    "start": "1451530",
    "end": "1458022"
  },
  {
    "text": "Now of course, we don't\nknow what that edge is. The guessing just means try\nthem all as you saw last time.",
    "start": "1458022",
    "end": "1464140"
  },
  {
    "text": "So now, it's really\neasy to write the recurrence-- see if I can do\nit without looking at my notes.",
    "start": "1464140",
    "end": "1469210"
  },
  {
    "text": "So we've got duv of m.",
    "start": "1469210",
    "end": "1474700"
  },
  {
    "text": "We want to write-- we want\nto find the shortest path, so it's probably going to\nbe a min on the outside. And we're going to consider\nthe paths of the form-- d go",
    "start": "1474700",
    "end": "1484919"
  },
  {
    "text": "from u to x using fewer edges. Right, if this is the last edge,\nthen we use m minus 1 edges",
    "start": "1484920",
    "end": "1492540"
  },
  {
    "text": "to get to x. And then, we follow\nthe edge x comma v. So I'll just add on the\nweight of the edge, x comma",
    "start": "1492540",
    "end": "1500270"
  },
  {
    "text": "v. If x was the right answer,\nthis would be the cost",
    "start": "1500270",
    "end": "1505620"
  },
  {
    "text": "to get from u to v\nvia x, where xv is a single edge at the very end.",
    "start": "1505620",
    "end": "1511646"
  },
  {
    "text": "We don't know what x\nshould be, so we're just going to do for loop\nover x for x in v.",
    "start": "1511646",
    "end": "1517640"
  },
  {
    "text": "So this is using\nPython notation. And that will find\nthe best answer.",
    "start": "1517640",
    "end": "1523210"
  },
  {
    "text": "Done, easy. Once you know what\nthe subproblems are, once you know what\nthe guessing is, basically, I'm just adding\nin a min and a for loop",
    "start": "1523210",
    "end": "1529980"
  },
  {
    "text": "to do the guessing. So that's my recurrence, except\nI should also have a base case.",
    "start": "1529980",
    "end": "1535070"
  },
  {
    "text": "Here it's especially important. So base case is going to\nbe when m is the smallest.",
    "start": "1535070",
    "end": "1540690"
  },
  {
    "text": "So that, let's say, is 0. What is the weight of getting\nsomewhere using 0 edges?",
    "start": "1540690",
    "end": "1547200"
  },
  {
    "text": "Well, typically it's\ngoing to be infinity. But there is an interesting\nsituation, where at 0 namely",
    "start": "1547200",
    "end": "1555929"
  },
  {
    "text": "when u equals v.\nHey, there is a way to get from u to\nitself with 0 edges.",
    "start": "1555930",
    "end": "1562350"
  },
  {
    "text": "And that costs 0. But anywhere else is\ngoing to cost infinity.",
    "start": "1562350",
    "end": "1567720"
  },
  {
    "text": "There's no path. So the sort of a\ndefinition, I should say.",
    "start": "1567720",
    "end": "1573230"
  },
  {
    "text": "If it exists, otherwise\nit's infinity. So then I get those infinities. But this is kind of important,\nbecause maybe I actually use",
    "start": "1573230",
    "end": "1581870"
  },
  {
    "text": "fewer than m edges. I wrote less than\nequal to m here. This is also less than equal\nto m minus 1 edges here.",
    "start": "1581870",
    "end": "1590350"
  },
  {
    "text": "But in some sense, I'm\nincluding the case here, where x equals v. So I just\nstay at v at the very end.",
    "start": "1590350",
    "end": "1597860"
  },
  {
    "text": "So it's because I have\na 0 here, I'm implicitly including a situation\nwhere actually, I",
    "start": "1597860",
    "end": "1603910"
  },
  {
    "text": "just use duv m minus 1. That's in that min here.",
    "start": "1603910",
    "end": "1609560"
  },
  {
    "text": "So it's important to\nget the base case right. Cool. Almost done.",
    "start": "1609560",
    "end": "1614920"
  },
  {
    "text": "I need an acyclic ordering. So as I said, things get\nsmaller when m is smaller.",
    "start": "1614920",
    "end": "1621240"
  },
  {
    "text": "So all that means is do the\nfor loop for m on the outside.",
    "start": "1621240",
    "end": "1627950"
  },
  {
    "text": "Then do the for loop for\nu in v. For those, it",
    "start": "1627950",
    "end": "1634490"
  },
  {
    "text": "doesn't matter what\norder you do it, as long as you've done\nall of m equals 0, before you do all of m equals\n1, before you do all of m",
    "start": "1634490",
    "end": "1641650"
  },
  {
    "text": "equals 2. So that's the nested for loops\nthat gives you the right order. And so, I guess I take this\nline and put it on the top.",
    "start": "1641650",
    "end": "1650950"
  },
  {
    "text": "And I take this line, the\ninduction of the currents, put it inside the for loops,\nthat is my bottom-up dp.",
    "start": "1650950",
    "end": "1658722"
  },
  {
    "text": "OK, I'm actually going to\nwrite it down explicitly here for kicks.",
    "start": "1658722",
    "end": "1663835"
  },
  {
    "text": " Should I bother?",
    "start": "1663835",
    "end": "1669184"
  },
  {
    "text": "Uh, what the hell. ",
    "start": "1669184",
    "end": "1676029"
  },
  {
    "text": "So first we do a for loop on m. ",
    "start": "1676030",
    "end": "1688890"
  },
  {
    "text": "Then, we're going to do\nthe for loops on u in V.",
    "start": "1688890",
    "end": "1694680"
  },
  {
    "text": "Now, inside the for loop,\nI want to compute this min.",
    "start": "1694680",
    "end": "1699870"
  },
  {
    "text": "I could use this\nsingle line, but I'm going to rewrite it slightly to\nconnect this back to shortest",
    "start": "1699870",
    "end": "1706285"
  },
  {
    "text": "paths. ",
    "start": "1706285",
    "end": "1731670"
  },
  {
    "text": "Because this type of\nstatement should look familiar from Dijkstra and Bellman-Ford.",
    "start": "1731670",
    "end": "1738770"
  },
  {
    "text": "This is called the\nrelaxation step. ",
    "start": "1738770",
    "end": "1748399"
  },
  {
    "text": "OK. It probably would\nlook more familiar if I wrote here w of x v.\nYou could also write wxv. That's an alternative\nfor both of these--",
    "start": "1748400",
    "end": "1763030"
  },
  {
    "text": "probably should\nwrite the same way. But in either case, we call\nthis a relaxation step,",
    "start": "1763030",
    "end": "1768400"
  },
  {
    "text": "because-- it's kind\nof a technical reason but-- what we'd\nlike to satisfy--",
    "start": "1768400",
    "end": "1774840"
  },
  {
    "text": "we know that shortest paths\nshould satisfy the triangle inequality. If you look, there's three\nvertices involved here,",
    "start": "1774840",
    "end": "1781220"
  },
  {
    "text": "u, v, and x. We're looking at the\nshortest path from u",
    "start": "1781220",
    "end": "1787100"
  },
  {
    "text": "to v compared to the\nshortest path for u to x, and the shortest\npath from x to v.",
    "start": "1787100",
    "end": "1792140"
  },
  {
    "text": "Certainly, the shortest\nway to get from u to v should be less than or equal\nto the shortest path of u to x plus x to v, because\none way to get from u to v",
    "start": "1792140",
    "end": "1800660"
  },
  {
    "text": "is to go via x. So this if condition\nwould be a violation",
    "start": "1800660",
    "end": "1807345"
  },
  {
    "text": "of the triangle inequality. It means we definitely do\nnot have the right distance estimates if duv is\ngreater than ux plus xv.",
    "start": "1807345",
    "end": "1814341"
  },
  {
    "text": "OK. So if it's greater, we're\ngoing to set it equal. Because here, we know a way\nto get from u to v via x.",
    "start": "1814341",
    "end": "1821690"
  },
  {
    "text": "We know that it's possible to do\nthis, assuming our d values are always upper bounds on reality.",
    "start": "1821690",
    "end": "1827880"
  },
  {
    "text": "Then, this will be an\nupper bound on the best way to get from u to v. So this is clearly\na valid thing to do.",
    "start": "1827880",
    "end": "1833700"
  },
  {
    "text": "Relaxations are never bad. If you start high,\nthese will always",
    "start": "1833700",
    "end": "1838950"
  },
  {
    "text": "improve your shortest paths,\nso you get better estimates. And that's exactly what\nDijkstra and Bellman-Ford did,",
    "start": "1838950",
    "end": "1844900"
  },
  {
    "text": "maybe with w instead\nof d, but they're all about fixing the\ntriangle inequality. And in general and\noptimization, there's",
    "start": "1844900",
    "end": "1851550"
  },
  {
    "text": "this notion of, if\nyou have a constraint, an inequality constraint\nlike the triangle inequality, and it's violated,\nthen you try to fix it",
    "start": "1851550",
    "end": "1858370"
  },
  {
    "text": "by the successive relaxations. So that's where the\nterm comes from-- doesn't really matter here,\nbut all of our shortest path",
    "start": "1858370",
    "end": "1865020"
  },
  {
    "text": "algorithms are going\nto do relaxations. All the shortest path algorithms\nI know do relaxations.",
    "start": "1865020",
    "end": "1871980"
  },
  {
    "text": "So this is familiar, but it's\nalso doing the same thing here. I just expanded out\nthe min as a for loop",
    "start": "1871980",
    "end": "1878800"
  },
  {
    "text": "over x, each time checking\nwhether each successive entry is better than\nwhat I had already.",
    "start": "1878800",
    "end": "1885070"
  },
  {
    "text": "And if it is, I update. So in the end, this will\ncompute a min, more or less. I cheated also because I\nomitted the superscripts here.",
    "start": "1885070",
    "end": "1893470"
  },
  {
    "text": "If I put m here, and m\nminus 1, here and 1 here, it would be exactly\nthe same algorithm.",
    "start": "1893470",
    "end": "1899940"
  },
  {
    "text": "I'm omitting all\nthe superscripts, because it can only help me.",
    "start": "1899940",
    "end": "1906450"
  },
  {
    "text": "Relaxing more can\nonly get better. And if I was guaranteed\ncorrect over there,",
    "start": "1906450",
    "end": "1911559"
  },
  {
    "text": "I'll still be guaranteed\ncorrect over here. You have to improve\nthe invariant, but you never--\nrelaxation is always safe.",
    "start": "1911559",
    "end": "1917190"
  },
  {
    "text": "If you start with upper bounds,\nyou always remain upper bounds. You're doing at least the\nrelaxations over there.",
    "start": "1917190",
    "end": "1922410"
  },
  {
    "text": "And so you will in the end\ncompute the correct shortest path weights. The advantage of that,\nmainly, is I save space.",
    "start": "1922410",
    "end": "1928260"
  },
  {
    "text": "And also, it's simpler. So now I only need\nquadratic space. If I had a superscript,\nI'd need cubic space.",
    "start": "1928260",
    "end": "1934620"
  },
  {
    "text": "Right? So I did a little simplification\ngoing from the five step process to here-- both of the\npolynomial time and space,",
    "start": "1934620",
    "end": "1941500"
  },
  {
    "text": "but this is a little\nbit, a little bit better. But how slow is this algorithm? How long does it take?",
    "start": "1941500",
    "end": "1948435"
  },
  {
    "text": "Yeah? V cubed, that would be great.",
    "start": "1948435",
    "end": "1953490"
  },
  {
    "text": "V to the fourth, yeah, good.  Sadly, we're not doing so great\nyet-- still V to the fourth.",
    "start": "1953490",
    "end": "1966130"
  },
  {
    "text": "V to the fourth, I guess\nI already knew how to do. That was if I just run\nBellman-Ford V times,",
    "start": "1966130",
    "end": "1973032"
  },
  {
    "text": "I already knew how to\ndo V to the fourth. So I haven't actually\nimproved anything. But at least you see, it's all\ndynamic programming in there.",
    "start": "1973032",
    "end": "1980720"
  },
  {
    "text": "So n here is the size of V.\nThat's probably the first time. ",
    "start": "1980720",
    "end": "1987690"
  },
  {
    "text": "Cool. I omitted 0, because\nthere was the base case. That's done separately in\nthe line that I didn't write. ",
    "start": "1987690",
    "end": "1995450"
  },
  {
    "text": "So that was dp one. ",
    "start": "1995450",
    "end": "2000630"
  },
  {
    "text": "Time for dp two, unless\nthere are questions? Everyone clear so far?",
    "start": "2000630",
    "end": "2006030"
  },
  {
    "text": "Yeah? STUDENT: When you\niterate over x, why do you do you\nevery [INAUDIBLE]",
    "start": "2006030",
    "end": "2012700"
  },
  {
    "text": "PROFESSOR: As opposed to--? STUDENT: Like, just adjacent\nvertices [INAUDIBLE] PROFESSOR: Oh, yeah. OK. Good, fair question-- why do I\niterate over all vertices, not",
    "start": "2012700",
    "end": "2022279"
  },
  {
    "text": "just the incoming? If I'm writing w of xv, I\ncould afford to just say, just",
    "start": "2022280",
    "end": "2028740"
  },
  {
    "text": "consider the incoming vertices. And that would let\nme improve probably from V to the fourth to V cubed\ntimes-- V squared times E,",
    "start": "2028740",
    "end": "2039190"
  },
  {
    "text": "I think, if you do\nthe arithmetic right. You could do that. It would be better.",
    "start": "2039190",
    "end": "2044679"
  },
  {
    "text": "For dense graphs, it's\nnot going to matter. For sparse graphs\nit will improve V squared to E, basically.",
    "start": "2044679",
    "end": "2051193"
  },
  {
    "text": "But we're going\nto do even better, so I'm not going to\ntry to optimize now. But, good question. When I say this at\nthe moment, if there",
    "start": "2051194",
    "end": "2058869"
  },
  {
    "text": "is no edge from x to v,\nI'm imagining that w of xv equals infinity.",
    "start": "2058870",
    "end": "2064290"
  },
  {
    "text": "So that will never\nbe the minimum choice to use a non-edge. I should say that.",
    "start": "2064290",
    "end": "2070010"
  },
  {
    "text": "If there's no edge here,\nI define the weight to be infinity. That will just make\nalgorithms cleaner to write.",
    "start": "2070010",
    "end": "2075559"
  },
  {
    "text": "But you could optimize\nit the way you said. So, where were you?",
    "start": "2075560",
    "end": "2080705"
  },
  {
    "text": "Yeah. Ah, perfect. OK. Other questions?",
    "start": "2080706",
    "end": "2087230"
  },
  {
    "text": "More Frisbee practice? No? OK. So that was dp one. Let me do dp two.",
    "start": "2087230",
    "end": "2094138"
  },
  {
    "text": " Not yet, sorry-- diversion.",
    "start": "2094139",
    "end": "2100920"
  },
  {
    "start": "2100920",
    "end": "2106450"
  },
  {
    "text": "Diversion is matrix\nmultiplication. Before I get to dp\ntwo, I want to talk about matrix multiplication. ",
    "start": "2106450",
    "end": "2119680"
  },
  {
    "text": "This is a cool connection. It won't help us directly\nfor shortest paths, but still pretty good.",
    "start": "2119680",
    "end": "2127690"
  },
  {
    "text": " And it will help-- it will\nsolve another problem especially",
    "start": "2127690",
    "end": "2133120"
  },
  {
    "text": "fast. ",
    "start": "2133120",
    "end": "2141260"
  },
  {
    "text": "So shortest paths is\nalso closely linked to matrix multiplication,\na problem we've seen a couple of times,\nfirst in the FFT lecture,",
    "start": "2141260",
    "end": "2148109"
  },
  {
    "text": "and then in the\nrandomization lecture for checking matrix multiplies. So you remember, you're\ngiven two matrices, A and B.",
    "start": "2148110",
    "end": "2156750"
  },
  {
    "text": "And you want to\ncompute C equals A times B. You've seen Strassen's\nalgorithm to do this.",
    "start": "2156750",
    "end": "2164030"
  },
  {
    "text": "There's also these--\nhere A and B are squared. OK. So the n by n, product\nwill be n by n.",
    "start": "2164030",
    "end": "2171610"
  },
  {
    "text": "So standard approach\nfor this is n cubed. With Strassen, if\nI can remember,",
    "start": "2171610",
    "end": "2178850"
  },
  {
    "text": "you can get n to the 2.807. And if you use CopperSmith\nWinograd, you get 2.376.",
    "start": "2178850",
    "end": "2188220"
  },
  {
    "text": "And then, if you use the\nnew Vassilevska-William's algorithm, you get n to\nthe 2.3728 and so on.",
    "start": "2188220",
    "end": "2198910"
  },
  {
    "text": "And that's the best\nalgorithm we know now. There's some evidence maybe\nyou can get 2 plus epsilon for any epsilon.",
    "start": "2198910",
    "end": "2204030"
  },
  {
    "text": "Turns out, those are going\nto help us too much here. But what I want to show is\nthat matrix multiplication",
    "start": "2204030",
    "end": "2209770"
  },
  {
    "text": "is essentially doing\nthis, if you redefine what plus and dot mean.",
    "start": "2209770",
    "end": "2216029"
  },
  {
    "text": "We redefine addition and\nmultiplication-- talk about whether that's valid\nin the moment--",
    "start": "2216030",
    "end": "2221740"
  },
  {
    "text": "so remember what is\nmatrix multiplication? Cij is a dot product\nof a row and a column.",
    "start": "2221740",
    "end": "2228060"
  },
  {
    "text": "So that's aik with bkIj. ",
    "start": "2228060",
    "end": "2233950"
  },
  {
    "text": "K equals 1 to n. OK. Now that sum looks\na lot like that min.",
    "start": "2233950",
    "end": "2242080"
  },
  {
    "text": "Actually, more like the\nway I wrote it over here, with the d's instead of the w's.",
    "start": "2242080",
    "end": "2248400"
  },
  {
    "text": "This-- right-- x is the\nthing that's varying here. So this is like, aik plus\nbkj, except, I have plus here,",
    "start": "2248400",
    "end": "2260330"
  },
  {
    "text": "whereas I have times over here. And I have a min out here,\nbut I have a sum over here.",
    "start": "2260330",
    "end": "2266310"
  },
  {
    "text": "So it sounds crazy, but let's\ndefine-- be very confusing",
    "start": "2266310",
    "end": "2271910"
  },
  {
    "text": "if I said define dot\nequals plus, so I'm going to define a new\nworld called circle world.",
    "start": "2271910",
    "end": "2278910"
  },
  {
    "text": "So if I put a circle around\na dot, what I mean is plus. And if I put a circle around\na plus, what I mean is min.",
    "start": "2278910",
    "end": "2288570"
  },
  {
    "text": "OK? So now, if I put a\ncircle around this dot, I mean circle everything. So I've got to circle the\nsummation, circle this thing.",
    "start": "2288570",
    "end": "2295660"
  },
  {
    "text": "So then I get shortest paths.  Crazy.",
    "start": "2295660",
    "end": "2300695"
  },
  {
    "text": " So all right, I'm going to\ndefine d to the m-th power.",
    "start": "2300695",
    "end": "2308535"
  },
  {
    "start": "2308535",
    "end": "2319150"
  },
  {
    "text": "I should probably\ncircle-- whatever. ",
    "start": "2319150",
    "end": "2331750"
  },
  {
    "text": "Slightly different. ",
    "start": "2331750",
    "end": "2339842"
  },
  {
    "text": "OK, I want to define,\nlike, three things at once. So let me write them down,\nand then talk about them.",
    "start": "2339842",
    "end": "2346390"
  },
  {
    "text": "So many infinities. All right. ",
    "start": "2346390",
    "end": "2385490"
  },
  {
    "text": "OK. I guess, I should\nwrite this too. ",
    "start": "2385490",
    "end": "2393121"
  },
  {
    "text": "OK. If I define the vert-- suppose\nI number the vertices 1 through n, OK? I just assume all vertices are\nan integer between 1 and n.",
    "start": "2393121",
    "end": "2400670"
  },
  {
    "text": "So then, I can actually express\nthings in a matrix, namely the weight matrix. This kind of defines\nthe graph, especially",
    "start": "2400670",
    "end": "2407620"
  },
  {
    "text": "if I say wij is infinity\nif there is no edge. Then, this is the matrix of\nall pairwise edge weights.",
    "start": "2407620",
    "end": "2415430"
  },
  {
    "text": "For every i and j, I\nhave a weight of ij. That gives me a matrix, once\nI set V to be 1 through n.",
    "start": "2415430",
    "end": "2422190"
  },
  {
    "text": "Now, I'm also defining this\ndistance estimate matrix. So remember, we\ndefined duvm-- I'm",
    "start": "2422190",
    "end": "2428700"
  },
  {
    "text": "going to now call it dijm,\nbecause the vertices are integers. That is, the weight\nof the shortest path",
    "start": "2428700",
    "end": "2434340"
  },
  {
    "text": "using, at most, m edges. If I define it that\nway, then I can put it into a matrix, which is for\nall pairs of vertices ij.",
    "start": "2434340",
    "end": "2442020"
  },
  {
    "text": "What is the distance,\nshortest pathways that uses it at most m edges? That gives me a matrix,\nd parenthesis m.",
    "start": "2442020",
    "end": "2450819"
  },
  {
    "text": "Then, I claim that if I take\ncircle product between d of m minus 1 and w, that is\nexactly what's happening here,",
    "start": "2450820",
    "end": "2462349"
  },
  {
    "text": "if you stare at it long enough. This is the inner\nproduct between row u",
    "start": "2462349",
    "end": "2468609"
  },
  {
    "text": "of d to the m minus\n1, and column v of w. And that's exactly what this\ncircle product will compute.",
    "start": "2468610",
    "end": "2476510"
  },
  {
    "text": "So this is dp. But when you look at\nthat statement, that's",
    "start": "2476510",
    "end": "2483990"
  },
  {
    "text": "saying that d to\nthe parentheses m is really w to the\ncircle power m, right?",
    "start": "2483990",
    "end": "2490010"
  },
  {
    "text": "This is a definition\nin some sense of power, of exponentiation,\nusing circle product.",
    "start": "2490010",
    "end": "2496740"
  },
  {
    "text": "So when I circle\nthe exponent, that means I'm doing circle\nexponentiation in circle land,",
    "start": "2496740",
    "end": "2502252"
  },
  {
    "text": "OK? OK so far? So this is circle land.",
    "start": "2502252",
    "end": "2510470"
  },
  {
    "text": "So you might say, well, then I\nshould compute these products using matrix multiplication.",
    "start": "2510470",
    "end": "2515990"
  },
  {
    "text": "Now, just to see how\ngood we're doing, if I execute this operation\nn times, because I",
    "start": "2515990",
    "end": "2525220"
  },
  {
    "text": "have to get to d\nto the n minus 1-- so it's basically d to the n. If I do this product n\ntimes, and for each one of I",
    "start": "2525220",
    "end": "2533410"
  },
  {
    "text": "spend n cubed time, then I get\nan n to the four algorithm. Same algorithm in fact,\nexactly the same algorithm--",
    "start": "2533410",
    "end": "2540135"
  },
  {
    "text": "I've just expressed it\nin this new language. OK, there are two ideas\non the table though.",
    "start": "2540135",
    "end": "2546490"
  },
  {
    "text": "One is, maybe I could use a\nbetter matrix multiplication algorithm. Let's shelve that for a moment.",
    "start": "2546490",
    "end": "2553726"
  },
  {
    "text": "The other possibility\nis, well, maybe I can exponentiate faster than\nmultiplying by myself n times,",
    "start": "2553726",
    "end": "2559940"
  },
  {
    "text": "or multiplying by w n times. How should I do it?",
    "start": "2559940",
    "end": "2565170"
  },
  {
    "text": "Repeated squaring, good. You've seen that\nprobably in 006. Repeated squaring idea is, we\ntake-- to compute w-- well,",
    "start": "2565170",
    "end": "2577180"
  },
  {
    "text": "I take w to the 0. I multiply it by w to the 0.",
    "start": "2577180",
    "end": "2582319"
  },
  {
    "text": "Sorry, circle 0--\nthat's this thing. Oh, that seems weird.",
    "start": "2582320",
    "end": "2588119"
  },
  {
    "text": "Let's start with 1. 1 seems better.",
    "start": "2588120",
    "end": "2593578"
  },
  {
    "text": "I'm not going to get much if\nI multiply that by itself. I should get exactly\nthe same matrix. So I take the circle product\nbetween w to the 1, w to the 1.",
    "start": "2593579",
    "end": "2601030"
  },
  {
    "text": "That gives me w to the 2. And then, I take w to\nthe 2 times w to the 2.",
    "start": "2601030",
    "end": "2609360"
  },
  {
    "text": "Everything's circled. I get w to the 4. Oh cool, I doubled my exponent\nwith one multiplication.",
    "start": "2609360",
    "end": "2617220"
  },
  {
    "text": "If I take w to the 4 by w to the\n4, I get w to the 8, and so on.",
    "start": "2617220",
    "end": "2623030"
  },
  {
    "text": "My goal is to get to n, so I\nhave to do this log n times. Log n squaring operations,\neach squaring operation",
    "start": "2623030",
    "end": "2629869"
  },
  {
    "text": "is an n cubed thing. So this is repeated squaring. ",
    "start": "2629870",
    "end": "2641000"
  },
  {
    "text": "And I get V cubed log V--\nfinally, an improvement.",
    "start": "2641000",
    "end": "2648510"
  },
  {
    "text": "So we went from V to the 4,\nwhich was in the dense case",
    "start": "2648510",
    "end": "2654040"
  },
  {
    "text": "the same performance\nas Bellman-Ford, running it V times. But now in the dense case,\nI'm getting V cubed log V,",
    "start": "2654040",
    "end": "2661370"
  },
  {
    "text": "which is actually pretty good. It's not quite V\ncubed, but close.",
    "start": "2661370",
    "end": "2667250"
  },
  {
    "text": " All right.",
    "start": "2667250",
    "end": "2672821"
  },
  {
    "text": "I'm pointing at V cubed. This is actually the one\nresult that is not optimal. This is the one we\nwant to improve.",
    "start": "2672821",
    "end": "2678130"
  },
  {
    "text": "But we're kind of-- we're\nin this space right now. We're getting close to as\ngood is this algorithm, the Johnson's algorithm.",
    "start": "2678130",
    "end": "2684456"
  },
  {
    "text": "But we still a log V Factor. So this is great,\njust by translating into matrix multiplication.",
    "start": "2684456",
    "end": "2690844"
  },
  {
    "text": "Now technically,\nyou have to check that repeated squaring actually\ngives you the same result.",
    "start": "2690844",
    "end": "2695860"
  },
  {
    "text": "Basically, this works because\nproducts are associative. Circle products of\nmatrices are associative,",
    "start": "2695860",
    "end": "2702130"
  },
  {
    "text": "which works because circle\nland is a semi-ring.",
    "start": "2702130",
    "end": "2707880"
  },
  {
    "text": "If you want the\nabstract algebra, a ring is something that\nyou wear on your a finger.",
    "start": "2707880",
    "end": "2715211"
  },
  {
    "text": "No. A ring is an algebra where\nyou define plus and times, and you have distributivity.",
    "start": "2715211",
    "end": "2721700"
  },
  {
    "text": "Semi-ring, there's no minus,\nbecause min has no inverse.",
    "start": "2721700",
    "end": "2728329"
  },
  {
    "text": "There's no way from\nthe min to re-compute the arguments, right? No matter what you apply to\nit, you can't-- you've lost",
    "start": "2728330",
    "end": "2735080"
  },
  {
    "text": "information. So that's the semi-ring. Normally, you have a minus. But semi-ring is enough\nfor the repeated squaring",
    "start": "2735080",
    "end": "2741760"
  },
  {
    "text": "to give you the right answer. However, semi-ring is not enough\nfor all these fancy algorithms.",
    "start": "2741760",
    "end": "2749220"
  },
  {
    "text": "So if you look at Strassen's\nalgorithm, the one you've seen, it uses minus. There's no way to get around\nthat, as far as we know.",
    "start": "2749220",
    "end": "2755750"
  },
  {
    "text": "So if you have no minus, n cubed\nis the best we know how to do. So sadly, we cannot improve\nbeyond this with this",
    "start": "2755750",
    "end": "2762349"
  },
  {
    "text": "technique. It sucks, but that's life. However, we can do something.",
    "start": "2762350",
    "end": "2770305"
  },
  {
    "start": "2770305",
    "end": "2781260"
  },
  {
    "text": "If we just change\nthe problem, there is another problem which\nthis is the best way to do. So let me briefly tell\nyou about that problem.",
    "start": "2781260",
    "end": "2788780"
  },
  {
    "text": "It's called transitive closure. ",
    "start": "2788780",
    "end": "2804140"
  },
  {
    "text": "Transitive closure\nis, I just want to know is there a\npath from i to j.",
    "start": "2804140",
    "end": "2810000"
  },
  {
    "text": "So it's going to be 1, if there\nexists a path from i to j.",
    "start": "2810000",
    "end": "2816270"
  },
  {
    "text": "And it's going to\nbe 0 otherwise.  OK.",
    "start": "2816270",
    "end": "2821300"
  },
  {
    "text": " I guess it's kind of like\nif you set all the weights",
    "start": "2821300",
    "end": "2827720"
  },
  {
    "text": "to 0 or infinity. Then, either there's\ngoing to be as 0 way path, or there's no path, meaning\nthere's an infinite way path.",
    "start": "2827720",
    "end": "2834966"
  },
  {
    "text": "So it's not quite the same. Here, I want 1 and 0. I flipped. It used to be, this was\ninfinity, and this was 0.",
    "start": "2834966",
    "end": "2843559"
  },
  {
    "text": "This is one saying there is a\npath from i and j, 0 otherwise. If I write it this\nway, and then I",
    "start": "2843560",
    "end": "2849350"
  },
  {
    "text": "think about what\nI need to do here, it is still in some sense\nplus and min, but not really.",
    "start": "2849350",
    "end": "2856950"
  },
  {
    "text": "Because I just want to\nknow, is there a path? So if I have a way to get\nthere and a way to get there,",
    "start": "2856950",
    "end": "2862694"
  },
  {
    "text": "instead of adding\nup those values, really I'm taking\nsome other operator.",
    "start": "2862694",
    "end": "2869230"
  },
  {
    "text": "So I want to know OR. Yeah, exactly-- who said OR? ",
    "start": "2869230",
    "end": "2875360"
  },
  {
    "text": "Yeah, all right, tough one.  Close, close, close.",
    "start": "2875360",
    "end": "2883360"
  },
  {
    "text": "So here, we have basically\na circle product is OR,",
    "start": "2883360",
    "end": "2890120"
  },
  {
    "text": "and circle sum is AND. OK? I mean plus and min\nwould work, but it's",
    "start": "2890120",
    "end": "2898670"
  },
  {
    "text": "a little bit nicer over here. ",
    "start": "2898670",
    "end": "2906710"
  },
  {
    "text": "Sorry, it's the other\nway around, I think. ",
    "start": "2906710",
    "end": "2912170"
  },
  {
    "text": "It's definitely Booleans. We want to know there is a\nway to get to x, and then",
    "start": "2912170",
    "end": "2917364"
  },
  {
    "text": "from x to where we're going. That's an AND. And then, to get\na path in general,",
    "start": "2917364",
    "end": "2922369"
  },
  {
    "text": "it has to work for some x. So that's the OR. And this is a ring.",
    "start": "2922370",
    "end": "2928170"
  },
  {
    "text": "And once you're ring,\nyou have negation. You can apply\nVassilevska-Williams.",
    "start": "2928170",
    "end": "2935460"
  },
  {
    "text": "And you solve this problem\nin n to the 2.3728.",
    "start": "2935460",
    "end": "2942420"
  },
  {
    "text": "And if I just make a little\nchange in the dot dot dot, I can absorb the log. So you could put a log n here.",
    "start": "2942420",
    "end": "2948470"
  },
  {
    "text": "And it's log n if you get\nthe exponent exactly right. But if you just tweak the\nexponent by 0.00000001,",
    "start": "2948470",
    "end": "2955830"
  },
  {
    "text": "that's bigger than log n. So we usually omit\nthe log there. Cool.",
    "start": "2955830",
    "end": "2962580"
  },
  {
    "text": "Transitive closure-- so it's\na problem you didn't know you want to solve, but it is\nactually a common problem.",
    "start": "2962580",
    "end": "2968301"
  },
  {
    "text": "And this is the\nbest way we know how to solve it for dense graphs. OK, it beats, you know, V cubed.",
    "start": "2968301",
    "end": "2975900"
  },
  {
    "text": "This is the algorithm we're\naiming for for dense graphs. For sparse graphs,\nwe can do better.",
    "start": "2975900",
    "end": "2981340"
  },
  {
    "text": "But for dense graphs,\nthis is better. ",
    "start": "2981340",
    "end": "2988799"
  },
  {
    "text": "Finally, we get to go to\ndynamic programming number two, also known as the\nFloyd-Warshall algorithm.",
    "start": "2988800",
    "end": "2997450"
  },
  {
    "text": "So we had this dp\nin V the fourth. If we forget about\ntransitive closure,",
    "start": "2997450",
    "end": "3003530"
  },
  {
    "text": "we've now are down\nto V cubed log V. Our next goal is to achieve V\ncubed, no log V. Let's do that.",
    "start": "3003530",
    "end": "3012170"
  },
  {
    "start": "3012170",
    "end": "3035859"
  },
  {
    "text": "So again, I'm going to\nexpress it in my five steps. First step is, what\nare subproblems?",
    "start": "3035860",
    "end": "3041740"
  },
  {
    "text": "And this is the key\ndifference, and the key insight for Floyd-Warshall is to\nredefine the dij problems.",
    "start": "3041740",
    "end": "3049640"
  },
  {
    "text": "To avoid conflict,\nI'm going to call them cij, or in this case,\ncuv, because here, the matrix",
    "start": "3049640",
    "end": "3059980"
  },
  {
    "text": "product view will\nnot work, I think. Yeah, it won't work.",
    "start": "3059980",
    "end": "3067399"
  },
  {
    "text": "So it's a totally\ndifferent universe. ",
    "start": "3067399",
    "end": "3100326"
  },
  {
    "text": "I'm still going to assume that\nmy vertices are numbered 1 through n. And now, the idea\nis, first I'm going",
    "start": "3100326",
    "end": "3107596"
  },
  {
    "text": "to think about the graph formed\nby the vertices 1 though k, roughly. And I want to know for every\nvertex u and every vertex v,",
    "start": "3107596",
    "end": "3115700"
  },
  {
    "text": "what is the shortest\npath from u to v, or the weight of the\nshortest path from u to v that only uses intermediate\nvertices from 1 through k.",
    "start": "3115700",
    "end": "3123670"
  },
  {
    "text": "So actually, u and\nv might not be-- they might be larger than k. But I want all the vertices\nin the path to be 1 through k.",
    "start": "3123670",
    "end": "3131330"
  },
  {
    "text": "This is a different way\nto slice up my space, and it's the right way. This is going to do\na factor of n better.",
    "start": "3131330",
    "end": "3138440"
  },
  {
    "text": "It turns out, and\nthat's just an insight you get from trying all the\ndp's you could think of.",
    "start": "3138440",
    "end": "3143799"
  },
  {
    "text": "And eventually, Floyd and\nWarshall found this one, I think in the '70s.",
    "start": "3143800",
    "end": "3149089"
  },
  {
    "text": "So it was easier back\nthen to get a new result.",
    "start": "3149090",
    "end": "3155930"
  },
  {
    "text": "But I mean, this is very\nclever-- so very cool idea. ",
    "start": "3155930",
    "end": "3164800"
  },
  {
    "text": "So now the question is,\nwhat should I guess?",
    "start": "3164800",
    "end": "3170960"
  },
  {
    "text": "Before I guessed what\nthe last edge was. That's not going to\nbe so useful here. Can anyone think of a\ndifferent thing to guess?",
    "start": "3170960",
    "end": "3178114"
  },
  {
    "text": "We're trying to solve\nthis problem where I get to use\nvertices 1 through k, and presumably I want\nto use subproblems",
    "start": "3178114",
    "end": "3183570"
  },
  {
    "text": "that involve smaller k,\nthat say involve vertices 1 through k minus 1.",
    "start": "3183570",
    "end": "3189090"
  },
  {
    "text": "So vertex k is relevant. What should I guess\nabout vertex k? ",
    "start": "3189090",
    "end": "3203646"
  },
  {
    "text": "Yeah? STUDENT: Guess that vertex\nk is the [INAUDIBLE] ",
    "start": "3203646",
    "end": "3211124"
  },
  {
    "text": "PROFESSOR: You want\nto guess vertex k is the i-th intermediate vertex. That would work, but I would\nneed to parameterize by i here,",
    "start": "3211124",
    "end": "3217869"
  },
  {
    "text": "and I lose another\nfactor of n if I do that. So I'd like to avoid that.",
    "start": "3217870",
    "end": "3223080"
  },
  {
    "text": "That is a good idea. Yeah? STUDENT: [INAUDIBLE] visit\nk, before you visit v.",
    "start": "3223080",
    "end": "3231265"
  },
  {
    "text": "PROFESSOR: You're going\nto guess that I visit k, and then I go to where\nI'm trying to go. OK.",
    "start": "3231265",
    "end": "3236700"
  },
  {
    "text": "That's not a-- OK. That's a statement.",
    "start": "3236700",
    "end": "3242610"
  },
  {
    "text": "But to guess, I should\nhave multiple choices. What's my other choice? STUDENT: [INAUDIBLE] ",
    "start": "3242610",
    "end": "3251025"
  },
  {
    "text": "PROFESSOR: Yes. So either I use\nvertex k, or I don't. That's the guess-- is k in\nthe path at all from u to v?",
    "start": "3251025",
    "end": "3265120"
  },
  {
    "text": "So that's a weaker\nthing than saying, k is at position i in the path.",
    "start": "3265120",
    "end": "3270700"
  },
  {
    "text": "Here I'm just saying,\nis k in the path at all? And that's nice,\nbecause as you say, I already know how to get\nthere without using k.",
    "start": "3270700",
    "end": "3277799"
  },
  {
    "text": "Because that's cuvk minus 1. And then, you just also have\nto consider the situation where",
    "start": "3277800",
    "end": "3282840"
  },
  {
    "text": "I go to k, and then I leave. So the recurrence is going to be\ncuvk is the min of two things.",
    "start": "3282840",
    "end": "3295460"
  },
  {
    "text": "One is when k is not in the\npath, that's cuvk minus 1.",
    "start": "3295460",
    "end": "3301580"
  },
  {
    "text": "And the other option is that\nI go to x first-- or sorry, I go to k first. It used to be x.",
    "start": "3301580",
    "end": "3306770"
  },
  {
    "text": "Now, I've renamed it k. I don't know why. k minus 1-- and then I go\nfrom k to the v-- k minus 1.",
    "start": "3306770",
    "end": "3318390"
  },
  {
    "text": " That's it. Min of two things-- before, I\nwas taking the min of n things.",
    "start": "3318390",
    "end": "3325240"
  },
  {
    "text": "Before, there were n\nchoices for my guess. Now, there are two\nchoices for my guess. Number of subproblems is\nthe same, still V cubed.",
    "start": "3325240",
    "end": "3332970"
  },
  {
    "text": "But the guessing part\nand the recurrence part is now constant time\ninstead of linear time. So I'm now V cubed\ntime-- progress.",
    "start": "3332970",
    "end": "3343170"
  },
  {
    "text": "OK? This is pretty cool. The old dp led us to this\nworld of matrix multiplication.",
    "start": "3343170",
    "end": "3348380"
  },
  {
    "text": "That's why I covered it. This new dp is just\na different way of thinking about\nit-- turns out to be faster, just by log factor,\nbut a little bit faster.",
    "start": "3348380",
    "end": "3358230"
  },
  {
    "text": "I need some base cases-- cuv\nof 0 is going to be-- now",
    "start": "3358230",
    "end": "3364950"
  },
  {
    "text": "it's the weight of the edge uv.",
    "start": "3364950",
    "end": "3370185"
  },
  {
    "text": "It's a different base case. Before, I was using 0 edges. Now, it's not using any\nintermediate vertices.",
    "start": "3370185",
    "end": "3375960"
  },
  {
    "text": "So that's how the weights\ncome into the picture, because actually there are\nno weights of edges up here. So that's a little weird.",
    "start": "3375960",
    "end": "3381860"
  },
  {
    "text": "The only place the weights\ncome in is when k equals 0. ",
    "start": "3381860",
    "end": "3388800"
  },
  {
    "text": "This is in some sense\nstill relaxation, but it's a little bit weirder,\nlittle bit different order.",
    "start": "3388800",
    "end": "3395720"
  },
  {
    "text": "I mean the key thing\nhere is, because the way we set up these subproblems\nwith the intermediate vertices,",
    "start": "3395720",
    "end": "3402630"
  },
  {
    "text": "we know k is the only\nvertex in question. Before it's like, well, I don't\nknow where you go at the end.",
    "start": "3402630",
    "end": "3407829"
  },
  {
    "text": "But now we know that either\nk is in there, or it's not. And in each case, we can compute\nit using smaller subproblems",
    "start": "3407830",
    "end": "3414540"
  },
  {
    "text": "and so we save\nthat linear factor. STUDENT: Is this only\nfor [INAUDIBLE] graphs,",
    "start": "3414540",
    "end": "3420447"
  },
  {
    "text": "or is does it also [INAUDIBLE] PROFESSOR: This is\nfor directed graphs.",
    "start": "3420447",
    "end": "3425570"
  },
  {
    "text": "u and v are ordered here. And this is the weight from u\nto v-- will work just as well.",
    "start": "3425570",
    "end": "3432290"
  },
  {
    "text": "It's probably a\nlittle bit instructive to write this down as\nnested for loops again.",
    "start": "3432290",
    "end": "3437970"
  },
  {
    "text": "Why not? Because then, you'll see\nit's just relaxation again. ",
    "start": "3437970",
    "end": "3445530"
  },
  {
    "text": "So I'll even write the base case\nhere, because it's very simple. ",
    "start": "3445530",
    "end": "3455330"
  },
  {
    "text": "We're doing k in\norder, let's say. These are really the\nsame kinds of for loops.",
    "start": "3455330",
    "end": "3460940"
  },
  {
    "text": " But I'll write them slightly\ndifferently, because here we",
    "start": "3460940",
    "end": "3466030"
  },
  {
    "text": "care about the order slightly. Here, we do care\nabout the order. Here, we don't care\nabout the order.",
    "start": "3466030",
    "end": "3471329"
  },
  {
    "text": "Vertices, and all we're\nsaying is-- almost exactly",
    "start": "3471330",
    "end": "3488510"
  },
  {
    "text": "the same code as before. This is, again, just\na relaxation step. We're just relaxing\ndifferent edges",
    "start": "3488510",
    "end": "3494140"
  },
  {
    "text": "in different orders, basically,\nbecause k is evolved in here.",
    "start": "3494140",
    "end": "3499150"
  },
  {
    "text": "We do that for k equals 1. Then for k equals 2, and so on. But in the end, it's\njust relaxations,",
    "start": "3499150",
    "end": "3504450"
  },
  {
    "text": "so you can use that to prove\nthat this actually computes the right shortest paths. I won't do that here.",
    "start": "3504450",
    "end": "3510130"
  },
  {
    "text": "But clearly, cubic time\ninstead of quartic. Pretty cool. That's Floyd-Warshall.",
    "start": "3510130",
    "end": "3515770"
  },
  {
    "text": "It's very simple. And so a lot of\npeople-- if you need to solve all-pairs shortest\npaths in dense graphs,",
    "start": "3515770",
    "end": "3521022"
  },
  {
    "text": "this is the best\nwe know how to do. So this is what you\nshould implement. It's like, five lines of code.",
    "start": "3521022",
    "end": "3526250"
  },
  {
    "text": "And you achieve this bound. But for our sparse\ngraphs, we can do better. And the rest of\nlecture is going to be",
    "start": "3526250",
    "end": "3532540"
  },
  {
    "text": "about Johnson's algorithm,\nwhere for sparse graphs we're going to get\ncloser to quadratic time.",
    "start": "3532540",
    "end": "3538170"
  },
  {
    "text": "We're going to match\nrunning Dijkstra, and it's V squared log\nV plus E times V, sorry.",
    "start": "3538170",
    "end": "3548010"
  },
  {
    "text": "So when E is small, that's\ngoing to be close to quadratic. When E is big, it's\ngoing to be cubic, again.",
    "start": "3548010",
    "end": "3553610"
  },
  {
    "text": "So we'll never be worse than\nthis Floyd-Warshall algorithm. But for sparse\ngraphs it's better.",
    "start": "3553610",
    "end": "3559170"
  },
  {
    "start": "3559170",
    "end": "3574579"
  },
  {
    "text": "OK. Johnson's algorithm. ",
    "start": "3574580",
    "end": "3589026"
  },
  {
    "text": "I was going to make some joke\nabout Johnson and Johnson, but I will pass. So Johnson's algorithm--\nI mean, dp is five steps,",
    "start": "3589027",
    "end": "3596620"
  },
  {
    "text": "but Johnson's algorithm's only\nthree steps-- clearly simpler. It's actually much\nmore complicated,",
    "start": "3596620",
    "end": "3601800"
  },
  {
    "text": "but it's all about\nwhat the steps are. So here's the crazy idea\nin Johnson's algorithm.",
    "start": "3601800",
    "end": "3608890"
  },
  {
    "text": "We're going to change\nthe weights on the edges. And to do that, we're going\nto assign weights to vertices.",
    "start": "3608890",
    "end": "3617789"
  },
  {
    "text": "We're going to\nchoose a function h. Think of it as a height\nfunction, I guess, that maps vertices\nto real numbers.",
    "start": "3617790",
    "end": "3624180"
  },
  {
    "text": "And then, we're going to\ndefine w sub h of u,v.",
    "start": "3624180",
    "end": "3629710"
  },
  {
    "text": "This is a new way to think about\nedge weights that depends on h that's defined in a simple way.",
    "start": "3629710",
    "end": "3635730"
  },
  {
    "text": "It's the old edge weight\nplus h of u minus h of v.",
    "start": "3635730",
    "end": "3642644"
  },
  {
    "text": "You could define\nit the other way, but it's better to\nbe consistent here. So this is a way to\ntweak edge weights.",
    "start": "3642644",
    "end": "3650140"
  },
  {
    "text": "For every edge-- this is\nfor directed graphs clearly. For u, u is the beginning,\nthe head of the-- I",
    "start": "3650140",
    "end": "3656962"
  },
  {
    "text": "don't know if it's\nthe head or the tail-- the beginning of the edge. v is the end of the edge. I'm going to add\non the height of h,",
    "start": "3656962",
    "end": "3664020"
  },
  {
    "text": "and subtract out\nthe height of v. OK? Why? Because that's the definition.",
    "start": "3664020",
    "end": "3671960"
  },
  {
    "text": "I want this to be greater\nthan or equal to 0. That's the such that. I want to assign a function\nh, so that these new weights",
    "start": "3671960",
    "end": "3679300"
  },
  {
    "text": "are all greater or equal to 0. This is for all u and\nv. Why would I do that?",
    "start": "3679300",
    "end": "3687605"
  },
  {
    "text": " STUDENT: To use\nDijkstra instead of-- PROFESSOR: To use Dijkstra\ninstead of Bellman-Ford,",
    "start": "3687605",
    "end": "3694790"
  },
  {
    "text": "exactly. So that's step 2. Run Dijkstra on, I\nguess, the usual graph.",
    "start": "3694790",
    "end": "3707434"
  },
  {
    "text": "But now, this new\nweight function, w sub h, if all the\nweights are non-negative, I can run Dijkstra.",
    "start": "3707434",
    "end": "3714490"
  },
  {
    "text": "So this will give me what I\ncall the shortest path sub h of u comma v for all u and v.",
    "start": "3714490",
    "end": "3722632"
  },
  {
    "text": "It doesn't give me the actual\nshortest path weights I want. It gives me the shortest\npath weights using this wh.",
    "start": "3722632",
    "end": "3728900"
  },
  {
    "text": "But I claim that's\nalmost the same. I claim that this\nre-weighting preserves",
    "start": "3728900",
    "end": "3736160"
  },
  {
    "text": "which paths are shortest. Because-- so in particular,\nI claim that delta of u,v is",
    "start": "3736160",
    "end": "3748130"
  },
  {
    "text": "delta sub h of u,v--\nshould be the other way-- minus h of u plus h of v. OK.",
    "start": "3748130",
    "end": "3757960"
  },
  {
    "text": "If this was a single edge, you\ncan see I'm just cancelling off these terms. But in fact, I claim for a whole\npath, every path from u to v",
    "start": "3757960",
    "end": "3766870"
  },
  {
    "text": "gets changed by exactly\nthe same amount. So this is a claim about\nthe shortest path--",
    "start": "3766870",
    "end": "3772180"
  },
  {
    "text": "in effect, a claim\nfor every path from u to v, shortest or not.",
    "start": "3772180",
    "end": "3777319"
  },
  {
    "text": "If I measure it in\nregular weights w, versus weights w sub\nh, the only difference",
    "start": "3777320",
    "end": "3784180"
  },
  {
    "text": "is this fixed amount,\nwhich depends only on u and v-- does not\ndepend on the path.",
    "start": "3784180",
    "end": "3789700"
  },
  {
    "text": "And therefore, which paths\nare shortest are preserved. And so when we compute\nthese shortest path weights,",
    "start": "3789700",
    "end": "3795589"
  },
  {
    "text": "we can translate\nthem back to what they should be in the\noriginal weighting function. And furthermore, if you\nhave parent pointers,",
    "start": "3795590",
    "end": "3801970"
  },
  {
    "text": "and you actually find the paths,\nthe paths will be the same. Shortest paths will be the same.",
    "start": "3801970",
    "end": "3807321"
  },
  {
    "text": "OK. So let's prove that claim. It's actually really simple. ",
    "start": "3807321",
    "end": "3826540"
  },
  {
    "text": "Let's look at a\npath from u to v.",
    "start": "3826540",
    "end": "3837840"
  },
  {
    "text": "So I'm going to label the\nvertices along the path. V0 is going to be u. That's the first one, then\nV1, then V2, and so on.",
    "start": "3837840",
    "end": "3847760"
  },
  {
    "text": "Let's say path has length k. And Vk is v. OK, that's just\na generic path from u to v.",
    "start": "3847760",
    "end": "3858430"
  },
  {
    "text": "And now, I want to compute\nthe w sub h of that path.",
    "start": "3858430",
    "end": "3869559"
  },
  {
    "text": "Excuse me. So the weight of a\npath is just the sum of the weights the edges.",
    "start": "3869560",
    "end": "3874690"
  },
  {
    "text": "So I could write this as\na sum from i equals 1 to k of w sub h of Vi\nminus 1 comma Vi.",
    "start": "3874690",
    "end": "3884965"
  },
  {
    "text": "I think that works,\ngot to be careful not to get the indices wrong.",
    "start": "3884965",
    "end": "3890750"
  },
  {
    "text": "OK, now, w sub h is defined\nto be this thing-- w",
    "start": "3890750",
    "end": "3895820"
  },
  {
    "text": "plus h of u minus h of v. So\nthis is the sum i equals 1 to k",
    "start": "3895820",
    "end": "3903471"
  },
  {
    "text": "of w Vi minus 1 Vi plus h\nof Vi minus 1 minus h of Vi.",
    "start": "3903471",
    "end": "3917470"
  },
  {
    "text": " What does the sum do?",
    "start": "3917470",
    "end": "3923275"
  },
  {
    "text": "Telescope. ",
    "start": "3923275",
    "end": "3937039"
  },
  {
    "text": "So success-- this Vi is going\nto-- this negative h of Vi is going to cancel with\nthe plus h of Vi minus 1",
    "start": "3937040",
    "end": "3942971"
  },
  {
    "text": "in the next term, except for\nthe very first one and the very last one. So this is going to be\nthis sum, which is just",
    "start": "3942971",
    "end": "3949860"
  },
  {
    "text": "the weight of the path according\nto regular weight function, plus h of V0 minus h of Vk.",
    "start": "3949860",
    "end": "3958464"
  },
  {
    "text": " And that is just the weight to\nthe path plus h of u minus h",
    "start": "3958465",
    "end": "3969325"
  },
  {
    "text": "of v. Did I get it right? Nope.",
    "start": "3969325",
    "end": "3975628"
  },
  {
    "text": "Yes? STUDENT: [INAUDIBLE]\nsubtract [INAUDIBLE] ",
    "start": "3975628",
    "end": "3982100"
  },
  {
    "text": "PROFESSOR: But it's not-- it's\nopposite of what I claimed. So right, because it's\nthe other side, good.",
    "start": "3982100",
    "end": "3989434"
  },
  {
    "text": "This has h on the\nright hand side. This has not h on\nthe left hand side. But here, I have h on the\nleft hand side, and not h",
    "start": "3989434",
    "end": "3995350"
  },
  {
    "text": "on the right hand side. So if I flip it around,\nif I take these two terms, put them on the\nleft hand side, then",
    "start": "3995350",
    "end": "4000590"
  },
  {
    "text": "I get this with the right sign. Cool, whew. Self-consistent. OK.",
    "start": "4000590",
    "end": "4005720"
  },
  {
    "text": "So this was talking\nabout are arbitrary path. And so this is proving\nthe stronger thing",
    "start": "4005720",
    "end": "4011990"
  },
  {
    "text": "I said, that every\npath gets lengthened by this function,\nwhich is purely",
    "start": "4011990",
    "end": "4017980"
  },
  {
    "text": "a function of the endpoints. So in particular, that means\nthe shortest path in w land will still be the shortest\npath in w sub h land--",
    "start": "4017980",
    "end": "4026380"
  },
  {
    "text": "slightly less cool name than\ncircle land, but oh well.",
    "start": "4026380",
    "end": "4031640"
  },
  {
    "text": "All right, so this means\nshortest paths are preserved. Shortest paths are\nstill shortest. ",
    "start": "4031640",
    "end": "4040450"
  },
  {
    "text": "And therefore, if I look at\nthe delta function, which is about the shortest path\nweights, this claim holds.",
    "start": "4040450",
    "end": "4047655"
  },
  {
    "text": "So that's the\nproof of the claim. ",
    "start": "4047655",
    "end": "4053771"
  },
  {
    "text": "Cool.  There's one gaping problem\nwith this algorithm,",
    "start": "4053771",
    "end": "4062050"
  },
  {
    "text": "which is how in the\nworld do you find this h? If we could find h, then we\nknow we could run Dijkstra,",
    "start": "4062050",
    "end": "4068300"
  },
  {
    "text": "and we can do this thing. And Dijkstra is going to\ncost the VE plus V squared",
    "start": "4068300",
    "end": "4073960"
  },
  {
    "text": "log V. I didn't say it, but\nwe run V times Dijkstra. All right, we run it V times.",
    "start": "4073960",
    "end": "4080410"
  },
  {
    "text": "That's going to take V\nsquared log V plus VE to do. This is just going to\ntake quadratic time,",
    "start": "4080410",
    "end": "4086600"
  },
  {
    "text": "V squared to update\nall the weights, update all the delta functions.",
    "start": "4086600",
    "end": "4091940"
  },
  {
    "text": "The missing step is how do\nwe find this weight function? I claim this problem of finding\nh that has this property,",
    "start": "4091940",
    "end": "4100778"
  },
  {
    "text": "is very closely related\nto shortest paths. It's weird, but we're going\nto use shortest paths to solve",
    "start": "4100779",
    "end": "4109040"
  },
  {
    "text": "shortest paths. ",
    "start": "4109040",
    "end": "4115189"
  },
  {
    "text": "So let's do it. ",
    "start": "4115189",
    "end": "4120818"
  },
  {
    "text": "Step 1, finding h.",
    "start": "4120819",
    "end": "4125859"
  },
  {
    "text": "What I want to do, so I\nwant to have w of u,v-- let me just copy that down--\nplus h of u plus h of v to be",
    "start": "4125859",
    "end": "4135359"
  },
  {
    "text": "greater than or equal to 0.  Whoops, minus.",
    "start": "4135359",
    "end": "4141859"
  },
  {
    "text": " I'm going to put the h's\non to the right hand side, and then flip it all around.",
    "start": "4141860",
    "end": "4148040"
  },
  {
    "text": "So this is like saying h of\nv minus h of u is less than",
    "start": "4148040",
    "end": "4153549"
  },
  {
    "text": "or equal to w of\nu,v for all u and v.",
    "start": "4153550",
    "end": "4165909"
  },
  {
    "text": "This is a problem we\nwant to solve, right? w's are given. h's are unknowns.",
    "start": "4165910",
    "end": "4170990"
  },
  {
    "text": "This is called a system\nof difference constraints. If you've heard about linear\nprogramming, for example,",
    "start": "4170990",
    "end": "4178778"
  },
  {
    "text": "this is a special case\nof linear programming. Don't worry if you haven't\nheard, because this",
    "start": "4178779",
    "end": "4184250"
  },
  {
    "text": "is an easy special case. We're going to solve it\nmuch faster than we know how to solve lineal programs.",
    "start": "4184250",
    "end": "4189759"
  },
  {
    "text": "It's a particular kind of thing. This is actually useful problem. You could think of,\nthese are maybe times",
    "start": "4189760",
    "end": "4194860"
  },
  {
    "text": "that various events happen. And these are constraints\nabout pairs of them. Says, well, the start\ntime of this event",
    "start": "4194860",
    "end": "4201690"
  },
  {
    "text": "minus the end time of that\nevent should be less than or equal to 1 second.",
    "start": "4201690",
    "end": "4206869"
  },
  {
    "text": "You can use this to do\ntemporal programming, if you could solve\nthese systems. We're going to solve\nthese systems, when",
    "start": "4206870",
    "end": "4214690"
  },
  {
    "text": "they have a solution. They don't always have a\nsolution, which is a bit weird,",
    "start": "4214690",
    "end": "4220350"
  },
  {
    "text": "because we're relying on them\nalways having a solution. How can that be?",
    "start": "4220350",
    "end": "4226370"
  },
  {
    "text": "Negative weight cycles. This is all going to work, when\nwe don't have negative weight",
    "start": "4226370",
    "end": "4231909"
  },
  {
    "text": "cycles. And that's exactly going\nto be the case when this system of difference\nconstraints has no solution.",
    "start": "4231910",
    "end": "4241110"
  },
  {
    "text": "So let me show you that\nin a couple of steps.",
    "start": "4241110",
    "end": "4247270"
  },
  {
    "text": "First theorem is that if the\ngraph V,E,w has a negative",
    "start": "4247270",
    "end": "4253640"
  },
  {
    "text": "weight cycle, then that\nsystem has no solution--",
    "start": "4253640",
    "end": "4272730"
  },
  {
    "text": "no solution to the\ndifference constraints. ",
    "start": "4272730",
    "end": "4279420"
  },
  {
    "text": "This is going to be,\nagain, an easy proof,",
    "start": "4279420",
    "end": "4284679"
  },
  {
    "text": "kind of similar to\nlast one actually.  So consider a\nnegative weight cycle.",
    "start": "4284680",
    "end": "4293800"
  },
  {
    "start": "4293800",
    "end": "4302659"
  },
  {
    "text": "Let's call it V0, to V1,\nto V2, to Vk, back to V0.",
    "start": "4302660",
    "end": "4311470"
  },
  {
    "text": "So the claim is the sum of\nthese weights is negative. And now, I'm just going to\nwrite down these constraints,",
    "start": "4311470",
    "end": "4317040"
  },
  {
    "text": "which are supposed to have a\nsolution, or maybe they won't. So if it has a\nsolution, then this",
    "start": "4317040",
    "end": "4322670"
  },
  {
    "text": "must be true, where u\nand v are plugged into be Vi and Vi minus 1, because\nthose are all edges.",
    "start": "4322670",
    "end": "4331480"
  },
  {
    "text": "So I'm going to write h of\nV1 minus h of V0 is less than",
    "start": "4331480",
    "end": "4341380"
  },
  {
    "text": "or equal to w of V0 wV1. And then h of V2 minus\nh of V1 less than",
    "start": "4341380",
    "end": "4351072"
  },
  {
    "text": "or equal to w of V1 V2. Repeat that k times,\nI'm going to get",
    "start": "4351072",
    "end": "4357429"
  },
  {
    "text": "h of Vk minus h of Vk minus 1. ",
    "start": "4357430",
    "end": "4369449"
  },
  {
    "text": "And then, the last\none, the wrap around h of V0 minus h of Vk w of V--\ndid I get it right-- Vk V0.",
    "start": "4369450",
    "end": "4387500"
  },
  {
    "text": " What do I do with\nthese inequalities?",
    "start": "4387500",
    "end": "4393469"
  },
  {
    "text": "Sum them. ",
    "start": "4393470",
    "end": "4399870"
  },
  {
    "text": "Time for a Good Will Hunting\nmoment-- do you remember?",
    "start": "4399870",
    "end": "4405465"
  },
  {
    "text": "I hope we've all seen\nGood Will Hunting. I don't have a\njanitor here, so I have to do all cancels\nby hand-- and this.",
    "start": "4405465",
    "end": "4415810"
  },
  {
    "text": "So I end up with\n0 at the bottom. Everything cancels, and then,\nover here I have less than",
    "start": "4415810",
    "end": "4424250"
  },
  {
    "text": "or equal to the weight\nof the whole cycle. I'm just adding up the\nweight of the cycle. I didn't give the cycle\na name-- call it C.",
    "start": "4424250",
    "end": "4431730"
  },
  {
    "text": "Now, the cycle has\nnegative weight. So this is less than zero,\nstrictly less than zero. So we're saying that 0\nis strictly less than 0.",
    "start": "4431730",
    "end": "4439690"
  },
  {
    "text": "That's not true. So that means\nthere's no way to get all of these constraints\nsimultaneously true-- proof",
    "start": "4439690",
    "end": "4445800"
  },
  {
    "text": "by a contradiction. So that establishes a\nconnection in the direction",
    "start": "4445800",
    "end": "4452480"
  },
  {
    "text": "we don't want it. What we want is\nthey're converse, which is if there's no\nnegative weight cycle,",
    "start": "4452480",
    "end": "4458160"
  },
  {
    "text": "then there is a solution. Luckily, that is also true. But this is a little\neasier to see.",
    "start": "4458160",
    "end": "4463739"
  },
  {
    "text": "So now, we do the other half. ",
    "start": "4463740",
    "end": "4474595"
  },
  {
    "text": "OK. ",
    "start": "4474595",
    "end": "4481620"
  },
  {
    "text": "And this will-- I mean, it's\ngoing to be constructive proof. So we're going to\nactually know how to solve this problem with an algorithm.",
    "start": "4481620",
    "end": "4491690"
  },
  {
    "start": "4491690",
    "end": "4509670"
  },
  {
    "text": "So it's going to be-- there\nis a negative weight cycle if and only if there's no solution. So in particular, the\ncase we care about",
    "start": "4509670",
    "end": "4517000"
  },
  {
    "text": "is if there's no\nnegative weight cycle, then there is a solution. We kind of care about both,\nbut this is the more practical",
    "start": "4517000",
    "end": "4523880"
  },
  {
    "text": "direction. So let's prove it. ",
    "start": "4523880",
    "end": "4530420"
  },
  {
    "text": "You can already\nsee-- you've seen that there's a connection\nin negative weight cycles. Now, I'm going to show there's\na real connection to shortest",
    "start": "4530420",
    "end": "4537150"
  },
  {
    "text": "paths. Negative weight\ncycles are just kind of a symptom of the shortest\npaths being involved.",
    "start": "4537150",
    "end": "4544949"
  },
  {
    "text": "So now, we're going\nto use shortest paths. Suppose we have some graph.",
    "start": "4544950",
    "end": "4551000"
  },
  {
    "text": "I'm going to draw a simple\nlittle graph with weights.",
    "start": "4551000",
    "end": "4556955"
  },
  {
    "text": " What I'd like to do is\ncompute shortest path",
    "start": "4556955",
    "end": "4563210"
  },
  {
    "text": "from a single source\nin this graph. The question is, which source? Because none of the vertices--\nI guess in this case,",
    "start": "4563210",
    "end": "4570960"
  },
  {
    "text": "this would be a pretty good\nsource, because it can reach. From here, I can\nget to every node.",
    "start": "4570960",
    "end": "4576150"
  },
  {
    "text": "But in general-- maybe\nthere's another vertex here-- draw a more\ncomplicated picture.",
    "start": "4576150",
    "end": "4584900"
  },
  {
    "text": "It could be, there's\nno one vertex that can reach all the others. For example, it may be\nthe graph is disconnected.",
    "start": "4584900",
    "end": "4590400"
  },
  {
    "text": "That's a good example. So there's no single source\nthat can reach everywhere. I really want to\nreach everywhere.",
    "start": "4590400",
    "end": "4596280"
  },
  {
    "text": "So what am I going to do? Add a new source. ",
    "start": "4596280",
    "end": "4602140"
  },
  {
    "text": "Call it s. I'm going to add an edge\nto every other vertex. Now, I can get\neverywhere from s.",
    "start": "4602140",
    "end": "4609141"
  },
  {
    "text": "OK? What are the weights? 0. 0 sounds good. I don't want to change the\nweights, in some sense.",
    "start": "4609141",
    "end": "4614590"
  },
  {
    "text": "So I put 0, and add\n0 to everything. That's not going to change much. Now, notice I add no\ncycles to the graph.",
    "start": "4614590",
    "end": "4621140"
  },
  {
    "text": "So if there were no negative\nweight cycles before, still no negative weight\ncycles, because the cycles are the same as they were before.",
    "start": "4621140",
    "end": "4627540"
  },
  {
    "text": "But now, from s I\ncan reach everywhere. If there's no negative\nweight cycles, that means there's a\nwell-defined, finite value",
    "start": "4627540",
    "end": "4633300"
  },
  {
    "text": "for delta of s comma v\nfor all V. And that is h.",
    "start": "4633300",
    "end": "4639889"
  },
  {
    "text": "What? It's crazy man. All right, so we add s to\nV. We're going to add s",
    "start": "4639890",
    "end": "4651110"
  },
  {
    "text": "comma v to e for all\nV. That's the old V.",
    "start": "4651110",
    "end": "4657670"
  },
  {
    "text": "And I'm going to set\nthe weight of s comma v to be 0 for all V. OK,\nthat's what i just did.",
    "start": "4657670",
    "end": "4666500"
  },
  {
    "text": "And so now, delta of s\ncomma v is finite for all V.",
    "start": "4666500",
    "end": "4676320"
  },
  {
    "text": "It's not plus\ninfinity, because I know there is-- it's got\nto be less than 0, right? I can get from s to everywhere.",
    "start": "4676320",
    "end": "4682250"
  },
  {
    "text": " So it's less than\npositive infinity. It's also not negative\ninfinity, because I've",
    "start": "4682250",
    "end": "4688440"
  },
  {
    "text": "assumed there's no negative\nweight cycles anywhere.  So I'm going to let h\nof v be delta of s,v.",
    "start": "4688440",
    "end": "4697710"
  },
  {
    "text": "I claim that just\nworks, magically. That's insane. Every time I see it, it's\nlike, got to be crazy",
    "start": "4697710",
    "end": "4705160"
  },
  {
    "text": "man-- crazy but correct. That's Johnson.",
    "start": "4705160",
    "end": "4710325"
  },
  {
    "text": " It's like you just pray that\nthis happens, and it works.",
    "start": "4710325",
    "end": "4716489"
  },
  {
    "text": "Why would it happen? Why would it be that--\nwhat do we want to say--",
    "start": "4716490",
    "end": "4722360"
  },
  {
    "text": "w of u,v plus h of\nu minus h of v--",
    "start": "4722360",
    "end": "4730300"
  },
  {
    "text": "we want this to be greater\nthan or equal to 0. I guess I had already\nrewritten this way.",
    "start": "4730300",
    "end": "4735710"
  },
  {
    "text": "Neither way is the right\nway, so it doesn't matter. So let's see. We have a weight of u,v. We have\nthe shortest path from s to u.",
    "start": "4735710",
    "end": "4744730"
  },
  {
    "text": "And we have this the\nshortest pathway from s to v. We want that to be\ngreater than or equal to 0.",
    "start": "4744730",
    "end": "4750929"
  },
  {
    "text": "Why? Put this over there, and I get\ndelta s,v is less than or equal",
    "start": "4750930",
    "end": "4758390"
  },
  {
    "text": "to delta of s,u plus\nw of u,v, which is?",
    "start": "4758390",
    "end": "4765620"
  },
  {
    "text": "Triangle inequality,\nwhich is true. ",
    "start": "4765620",
    "end": "4774200"
  },
  {
    "text": "It turns out, this thing we've\nbeen staring at for so long is actually just\ntriangle inequality.",
    "start": "4774200",
    "end": "4780110"
  },
  {
    "text": "So of course we want to\ncompute shortest paths, because shortest paths\nsatisfy triangle inequality. The whole name of the\ngame in shortest paths",
    "start": "4780110",
    "end": "4787250"
  },
  {
    "text": "is to find a place\nwhere you don't satisfy triangle inequality and fix it. So if it makes sense, if\nthat's possible to do,",
    "start": "4787250",
    "end": "4795860"
  },
  {
    "text": "Bellman-Ford will do it. So how we're going to do step 1? We're going to run\nBellman-Ford once.",
    "start": "4795860",
    "end": "4801770"
  },
  {
    "text": "We're going to add this\nsource vertex, so that there is a clear source to\nrun Bellman-Ford from,",
    "start": "4801770",
    "end": "4808040"
  },
  {
    "text": "and then, run Bellman-Ford\nfrom there only. That will give us\na weight function for the vertices,\nnamely how long",
    "start": "4808040",
    "end": "4814750"
  },
  {
    "text": "does it take to get from\ns to those vertices. Those weights will\nactually all be negative. But then, we're going\nto modify all the edge",
    "start": "4814750",
    "end": "4821280"
  },
  {
    "text": "weights according to\nthis formula, which negates some of them. So some of them are going\nto go up some, some of them are going to go down.",
    "start": "4821280",
    "end": "4826750"
  },
  {
    "text": "It's kind of weird. But when we're done,\nall of the weights will be non-negative because\nwe had triangle inequality.",
    "start": "4826750",
    "end": "4833260"
  },
  {
    "text": "And now, we can run\nDijkstra from every vertex. So it's like we\nbootstrap a little bit. We run Bellman-Ford\nonce, because we know",
    "start": "4833260",
    "end": "4839288"
  },
  {
    "text": "it handles negative weights. It will also tell us if there\nare any negative weight cycles. That's why we want this theorem.",
    "start": "4839288",
    "end": "4846400"
  },
  {
    "text": "Maybe Bellman-Ford says, I can't\nsatisfy triangle inequality, because there's a\nnegative weight cycle. I don't know what to do.",
    "start": "4846400",
    "end": "4851580"
  },
  {
    "text": "Then, we know, well actually,\nthen there was no solution. OK, that's kind of interesting.",
    "start": "4851580",
    "end": "4857830"
  },
  {
    "text": "But then, we'll have to\ndeal with the shortest paths-- sorry-- deal with\nthose negative weight cycles. I won't cover how\nto do that here.",
    "start": "4857830",
    "end": "4864060"
  },
  {
    "text": "But you can. And otherwise, there's no\nnegative weight cycles, then Bellman-Ford finds valid h.",
    "start": "4864060",
    "end": "4870190"
  },
  {
    "text": "Then, we plug that h into here. Then, we have\nnon-negative weights. So in VE time, we've\nreduced to the non-negative",
    "start": "4870190",
    "end": "4880410"
  },
  {
    "text": "all-pair shortest paths. And then, we run\nDijkstra V times. Then, we get almost\nour answers, but we",
    "start": "4880410",
    "end": "4885420"
  },
  {
    "text": "have to modify them to get\nback the correct weights on our shortest paths. And so we computed shortest\npaths in V squared log V",
    "start": "4885420",
    "end": "4895440"
  },
  {
    "text": "plus VE, because this is\nhow much Dijkstra costs, and because Bellman-Ford\ntakes less time.",
    "start": "4895440",
    "end": "4901590"
  },
  {
    "text": "We're good. That's the magic. And that's all-pairs\nshortest paths.",
    "start": "4901590",
    "end": "4906990"
  },
  {
    "start": "4906990",
    "end": "4908511"
  }
]