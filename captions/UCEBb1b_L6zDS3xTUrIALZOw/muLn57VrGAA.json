[
  {
    "start": "0",
    "end": "500"
  },
  {
    "text": "In the last lecture we\nintroduced the notion",
    "start": "500",
    "end": "2910"
  },
  {
    "text": "of virtual memory and added a\nMemory Management Unit (MMU)",
    "start": "2910",
    "end": "7130"
  },
  {
    "text": "to translate the virtual\naddresses generated by the CPU",
    "start": "7130",
    "end": "10140"
  },
  {
    "text": "to the physical addresses\nsent to main memory.",
    "start": "10140",
    "end": "14270"
  },
  {
    "text": "This gave us the\nability to share",
    "start": "14270",
    "end": "16040"
  },
  {
    "text": "physical memory between\nmany running programs",
    "start": "16040",
    "end": "18660"
  },
  {
    "text": "while still giving each\nprogram the illusion of having",
    "start": "18660",
    "end": "21400"
  },
  {
    "text": "its own large address space.",
    "start": "21400",
    "end": "24580"
  },
  {
    "text": "Both the virtual and\nphysical address spaces",
    "start": "24580",
    "end": "27110"
  },
  {
    "text": "are divided into a\nsequence of pages,",
    "start": "27110",
    "end": "29670"
  },
  {
    "text": "each holding some fixed\nnumber of locations.",
    "start": "29670",
    "end": "32810"
  },
  {
    "text": "For example if each\npage holds 2^12 bytes,",
    "start": "32810",
    "end": "36510"
  },
  {
    "text": "a 32-bit address would have\n2^32/2^12 = 2^20 pages.",
    "start": "36510",
    "end": "44760"
  },
  {
    "text": "In this example\nthe 32-bit address",
    "start": "44760",
    "end": "47269"
  },
  {
    "text": "can be thought of as\nhaving two fields:",
    "start": "47270",
    "end": "49440"
  },
  {
    "text": "a 20-bit page number formed\nfrom the high-order address",
    "start": "49440",
    "end": "52420"
  },
  {
    "text": "bits and a 12-bit\npage offset formed",
    "start": "52420",
    "end": "55730"
  },
  {
    "text": "from the low-order address bits.",
    "start": "55730",
    "end": "58230"
  },
  {
    "text": "This arrangement ensures\nthat nearby data will",
    "start": "58230",
    "end": "60579"
  },
  {
    "text": "be located on the same page.",
    "start": "60580",
    "end": "64140"
  },
  {
    "text": "The MMU translates\nvirtual page numbers",
    "start": "64140",
    "end": "66860"
  },
  {
    "text": "into physical page\nnumbers using a page map.",
    "start": "66860",
    "end": "70480"
  },
  {
    "text": "Conceptually the\npage map is an array",
    "start": "70480",
    "end": "72680"
  },
  {
    "text": "where each entry in the array\ncontains a physical page",
    "start": "72680",
    "end": "75960"
  },
  {
    "text": "number along with a couple\nof bits indicating the page",
    "start": "75960",
    "end": "79520"
  },
  {
    "text": "status.",
    "start": "79520",
    "end": "81469"
  },
  {
    "text": "The translation\nprocess is simple:",
    "start": "81470",
    "end": "83710"
  },
  {
    "text": "the virtual page number\nis used as an index",
    "start": "83710",
    "end": "86500"
  },
  {
    "text": "into the array to fetch the\ncorresponding physical page",
    "start": "86500",
    "end": "89440"
  },
  {
    "text": "number.",
    "start": "89440",
    "end": "90920"
  },
  {
    "text": "The physical page\nnumber is then combined",
    "start": "90920",
    "end": "93090"
  },
  {
    "text": "with the page offset to form\nthe complete physical address.",
    "start": "93090",
    "end": "98670"
  },
  {
    "text": "In the actual implementation the\npage map is usually organized",
    "start": "98670",
    "end": "101810"
  },
  {
    "text": "into multiple levels, which\npermits us to have resident",
    "start": "101810",
    "end": "105110"
  },
  {
    "text": "only the portion of the page\nmap we’re actively using.",
    "start": "105110",
    "end": "110060"
  },
  {
    "text": "And to avoid the costs\nof accessing the page",
    "start": "110060",
    "end": "112259"
  },
  {
    "text": "map on each address\ntranslation, we",
    "start": "112260",
    "end": "115060"
  },
  {
    "text": "use a cache (called the\ntranslation look-aside buffer)",
    "start": "115060",
    "end": "118500"
  },
  {
    "text": "to remember the results of\nrecent vpn-to-ppn translations.",
    "start": "118500",
    "end": "124460"
  },
  {
    "text": "All allocated locations of\neach virtual address space",
    "start": "124460",
    "end": "127580"
  },
  {
    "text": "can be found on\nsecondary storage.",
    "start": "127580",
    "end": "130340"
  },
  {
    "text": "Note that they may\nnot necessarily",
    "start": "130340",
    "end": "132269"
  },
  {
    "text": "be resident in main memory.",
    "start": "132270",
    "end": "134290"
  },
  {
    "text": "If the CPU attempts to access\na virtual address that’s not",
    "start": "134290",
    "end": "137860"
  },
  {
    "text": "resident in main memory,\na page fault is signaled",
    "start": "137860",
    "end": "141000"
  },
  {
    "text": "and the operating system will\narrange to move the desired",
    "start": "141000",
    "end": "143870"
  },
  {
    "text": "page from secondary\nstorage into main memory.",
    "start": "143870",
    "end": "148069"
  },
  {
    "text": "In practice, only the active\npages for each program",
    "start": "148070",
    "end": "151400"
  },
  {
    "text": "are resident in main\nmemory at any given time.",
    "start": "151400",
    "end": "156540"
  },
  {
    "text": "Here’s a diagram showing\nthe translation process.",
    "start": "156540",
    "end": "159709"
  },
  {
    "text": "First we check to see if the\nrequired vpn-to-ppn mapping is",
    "start": "159710",
    "end": "163230"
  },
  {
    "text": "cached in the TLB.",
    "start": "163230",
    "end": "165450"
  },
  {
    "text": "If not, we have to access\nthe hierarchical page map",
    "start": "165450",
    "end": "168450"
  },
  {
    "text": "to see if the page is\nresident and, if so,",
    "start": "168450",
    "end": "171379"
  },
  {
    "text": "lookup its physical page number.",
    "start": "171380",
    "end": "173880"
  },
  {
    "text": "If we discover that the\npage is not resident,",
    "start": "173880",
    "end": "176280"
  },
  {
    "text": "a page fault exception\nis signaled to the CPU",
    "start": "176280",
    "end": "179060"
  },
  {
    "text": "so that it can run a\nhandler to load the page",
    "start": "179060",
    "end": "181540"
  },
  {
    "text": "from secondary storage.",
    "start": "181540",
    "end": "184290"
  },
  {
    "text": "Note that access to a\nparticular mapping context",
    "start": "184290",
    "end": "187280"
  },
  {
    "text": "is controlled by two registers.",
    "start": "187280",
    "end": "189650"
  },
  {
    "text": "The context-number register\ncontrols which mappings",
    "start": "189650",
    "end": "192189"
  },
  {
    "text": "are accessible in the TLB.",
    "start": "192190",
    "end": "193500"
  },
  {
    "text": "And the page-directory\nregister indicates",
    "start": "193500",
    "end": "196770"
  },
  {
    "text": "which physical page\nholds the top tier",
    "start": "196770",
    "end": "199690"
  },
  {
    "text": "of the hierarchical page map.",
    "start": "199690",
    "end": "202440"
  },
  {
    "text": "We can switch to another context\nby simply reloading these two",
    "start": "202440",
    "end": "205950"
  },
  {
    "text": "registers.",
    "start": "205950",
    "end": "207540"
  },
  {
    "text": "To effectively accommodate\nmultiple contexts we’ll need",
    "start": "207540",
    "end": "210549"
  },
  {
    "text": "to have sufficient TLB capacity\nto simultaneously cache",
    "start": "210550",
    "end": "214670"
  },
  {
    "text": "the most frequent mappings\nfor all the processes.",
    "start": "214670",
    "end": "217690"
  },
  {
    "text": "And we’ll need some number\nof physical pages to hold",
    "start": "217690",
    "end": "220130"
  },
  {
    "text": "the required page directories\nand segments of the page",
    "start": "220130",
    "end": "223290"
  },
  {
    "text": "tables.",
    "start": "223290",
    "end": "224329"
  },
  {
    "text": "For example, for a\nparticular process,",
    "start": "224330",
    "end": "226510"
  },
  {
    "text": "three pages will suffice hold\nthe resident two-level page",
    "start": "226510",
    "end": "229830"
  },
  {
    "text": "map for 1024 pages at each end\nof the virtual address space,",
    "start": "229830",
    "end": "235690"
  },
  {
    "text": "providing access to up to 8MB\nof code, stack, and heap, more",
    "start": "235690",
    "end": "240950"
  },
  {
    "text": "than enough for many\nsimple programs.",
    "start": "240950",
    "end": "243860"
  },
  {
    "text": "The page map creates\nthe context needed",
    "start": "243860",
    "end": "246310"
  },
  {
    "text": "to translate virtual addresses\nto physical addresses.",
    "start": "246310",
    "end": "249760"
  },
  {
    "text": "In a computer system that’s\nworking on multiple tasks",
    "start": "249760",
    "end": "252360"
  },
  {
    "text": "at the same time, we would like\nto support multiple contexts",
    "start": "252360",
    "end": "256200"
  },
  {
    "text": "and to be able to quickly switch\nfrom one context to another.",
    "start": "256200",
    "end": "261148"
  },
  {
    "text": "Multiple contexts would allow\nus to share physical memory",
    "start": "261149",
    "end": "264840"
  },
  {
    "text": "between multiple programs.",
    "start": "264840",
    "end": "267580"
  },
  {
    "text": "Each program would have an\nindependent virtual address",
    "start": "267580",
    "end": "270250"
  },
  {
    "text": "space, e.g., two programs could\nboth access virtual address",
    "start": "270250",
    "end": "274360"
  },
  {
    "text": "0 as the address of\ntheir first instruction",
    "start": "274360",
    "end": "276620"
  },
  {
    "text": "and would end up accessing\ndifferent physical locations",
    "start": "276620",
    "end": "280190"
  },
  {
    "text": "in main memory.",
    "start": "280190",
    "end": "282050"
  },
  {
    "text": "When switching between programs,\nwe’d perform a “context switch”",
    "start": "282050",
    "end": "285569"
  },
  {
    "text": "to move to the\nappropriate MMU context.",
    "start": "285570",
    "end": "289600"
  },
  {
    "text": "The ability to share the\nCPU between many programs",
    "start": "289600",
    "end": "292490"
  },
  {
    "text": "seems like a great idea!",
    "start": "292490",
    "end": "294440"
  },
  {
    "text": "Let’s figure out the details\nof how that might work…",
    "start": "294440",
    "end": "297920"
  }
]