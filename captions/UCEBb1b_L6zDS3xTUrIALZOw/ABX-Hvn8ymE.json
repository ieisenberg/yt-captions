[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation, or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: All\nright, welcome back to Succinct Data\nStructures, part two of two.",
    "start": "18450",
    "end": "26580"
  },
  {
    "text": "Today we're going to take all\nthe stuff we know about tries and apply them to the main\nmotivating application, which",
    "start": "26580",
    "end": "32910"
  },
  {
    "text": "is suffix trees. And as we know, suffix\ntrees and suffix arrays are more or less equivalent.",
    "start": "32910",
    "end": "39510"
  },
  {
    "text": "But if you build one,\nyou can build the other. But what we're\ngoing to show today",
    "start": "39510",
    "end": "44940"
  },
  {
    "text": "is they're equivalent also\nfrom a space perspective. That will be the last topic. If you can succinctly\nrepresent a suffix array,",
    "start": "44940",
    "end": "52980"
  },
  {
    "text": "then you can transform-- with\na little o of n extra space, you can make a\nsuffix tree as well",
    "start": "52980",
    "end": "59430"
  },
  {
    "text": "and do searches in roughly\nthe time we're used to, which is p plus size of output.",
    "start": "59430",
    "end": "65844"
  },
  {
    "text": "It's not going to\nbe exactly that. We're going to lose like log\nto the epsilons and such. But that's mostly caused--\nthis transformation only",
    "start": "65844",
    "end": "72630"
  },
  {
    "text": "occurs like an additive log,\nlog, log, log, log, log n. You could have as\nmany logs as you want.",
    "start": "72630",
    "end": "79799"
  },
  {
    "text": "Take any arbitrarily,\nslowly growing function, that it will--",
    "start": "79800",
    "end": "84939"
  },
  {
    "text": "your space bound gets\ncloser and closer to linear. Anyway, that's what\nwe'll get to at the end. The bulk of the lecture will\nbe on building suffix arrays.",
    "start": "84940",
    "end": "92360"
  },
  {
    "text": "Here we're going to lose\na log to the epsilon time in the query. And we're going to start out\nimproving down to T log log T",
    "start": "92360",
    "end": "100901"
  },
  {
    "text": "space. Our bottom line\nis T log T space. That's a normal-- if you\njust stored a suffix array",
    "start": "100901",
    "end": "106020"
  },
  {
    "text": "as a bunch of numbers. First we'll add another log,\nthen we'll get down to linear.",
    "start": "106020",
    "end": "111600"
  },
  {
    "text": "That gives us a compact suffix\ntree, or sorry, suffix array. That's also knowing how to\ndo succinct suffix arrays.",
    "start": "111600",
    "end": "119490"
  },
  {
    "text": "But there are dozens of papers\non this topic, it's kind of a big field all to itself.",
    "start": "119490",
    "end": "125969"
  },
  {
    "text": "And a lot of the techniques\nare pretty complicated. So I'm going try to keep it\nto the bare minimum we can do,",
    "start": "125970",
    "end": "133140"
  },
  {
    "text": "that will give us linear-- linear number, bits of\nspace give us a compact data structure.",
    "start": "133140",
    "end": "138720"
  },
  {
    "text": "But before we go to\nthose data structures, I want to give you a little\nsurvey of what's known. ",
    "start": "138720",
    "end": "146680"
  },
  {
    "text": "So compact suffix arrays,\nand trees, start out with--",
    "start": "146680",
    "end": "154588"
  },
  {
    "text": "I'm going to start out\nwith the original results. And then I'll jump to sort of\nthe latest results, which are getting things to be succinct.",
    "start": "154589",
    "end": "160515"
  },
  {
    "text": " So the first result on this\ntopic that got a compact suffix",
    "start": "160515",
    "end": "168660"
  },
  {
    "text": "array, is by Grossi and Vitter. This was in 2000,\nspring of 2000.",
    "start": "168660",
    "end": "175709"
  },
  {
    "text": "And let me tell you the\nbounds that they achieve. This is actually the solution\nthat we're going to look at.",
    "start": "175710",
    "end": "181560"
  },
  {
    "start": "181560",
    "end": "206340"
  },
  {
    "text": "So this is the\nfirst space bound. ",
    "start": "206340",
    "end": "211670"
  },
  {
    "text": "I guess the big term\nhere is T log sigma. That's how many bits it takes\njust to write down the text.",
    "start": "211670",
    "end": "218030"
  },
  {
    "text": "So this is what you might\ncall optimal, in this world. I mean, if you have\nrandom text, you need that many bits\nto write it down.",
    "start": "218030",
    "end": "224720"
  },
  {
    "text": "So there's 1 times that. We're also going to have this\n1 over epsilon times that. And this is actually\nthe data structure.",
    "start": "224720",
    "end": "230750"
  },
  {
    "text": "It's going to store\nthe text, and then it's going to add on a data structure\nof 1 over epsilon times that. So it's order-- order [? ops. ?]\nThere's some lower-order terms.",
    "start": "230750",
    "end": "241325"
  },
  {
    "text": "We won't actually have\nthis lower-order term, because I'm going to focus\non binary alphabet here.",
    "start": "241326",
    "end": "246860"
  },
  {
    "text": "Keep it simple. But if you have a\nnon-binary alphabet, they have another order\nT bits, and so on.",
    "start": "246860",
    "end": "252410"
  },
  {
    "text": "But you get to\ncontrol this constant. This will work for any\nepsilon between 0 and 1. ",
    "start": "252410",
    "end": "259850"
  },
  {
    "text": "And why are you interested\nin a small epsilon? Because if epsilon is small,\nthis space bound goes up.",
    "start": "259850",
    "end": "267060"
  },
  {
    "text": "Well, that happens\nin the query bound. ",
    "start": "267060",
    "end": "288380"
  },
  {
    "text": "So in the query bound, there's\nthis multiplicative log to the epsilon of T. So if you\nreally want queries to go fast,",
    "start": "288380",
    "end": "295130"
  },
  {
    "text": "you don't want to pay\na big polylog here, then you're going to have\nto pay for it in space. So those are the same epsilons.",
    "start": "295130",
    "end": "300780"
  },
  {
    "text": " In the Grossi-Vitter paper,\nthey only multiply this",
    "start": "300781",
    "end": "308690"
  },
  {
    "text": "by the size of the output. So if you want to\njust output one guy, you only pay an additive\nlog to the epsilon. If you want to output\nall the matches",
    "start": "308690",
    "end": "314900"
  },
  {
    "text": "you have to pay a number\nof matches times log to the epsilon. They achieve the P bound.",
    "start": "314900",
    "end": "320330"
  },
  {
    "text": "In fact, they do a little bit\nbetter than order P query. On a RAM, you can hope to do--",
    "start": "320330",
    "end": "326150"
  },
  {
    "text": "save a log factor by reading log\nbase sigma of T, of the letters",
    "start": "326150",
    "end": "333169"
  },
  {
    "text": "in one word operation. So I'm not going to go\ninto how to do this-- I'm going to cover this paper\ntoday, or a simplification",
    "start": "333170",
    "end": "341257"
  },
  {
    "text": "of this paper. You might say, throw away. I'm going to get a slightly\nworse bounds than this. Space bound will be the\nsame, but I'm not going to--",
    "start": "341257",
    "end": "351170"
  },
  {
    "text": "I'm not going to worry\nabout this log factor. And in fact, both\nP and output are going to be multiplied\nby log to the epsilon.",
    "start": "351170",
    "end": "359539"
  },
  {
    "text": "So I won't achieve quite\nthe best query bound, but same space bound,\njust to give you an idea of how it works.",
    "start": "359540",
    "end": "366800"
  },
  {
    "text": "The next result-- yeah,\nI'll go to another board.",
    "start": "366800",
    "end": "372169"
  },
  {
    "text": "These bounds are a\nbit big, as you see.  The next result, which was\ndone later in the same year.",
    "start": "372170",
    "end": "379860"
  },
  {
    "text": "So these are\nprobably discovered, basically at the same time.",
    "start": "379860",
    "end": "385689"
  },
  {
    "text": "Because writing a paper\ntakes probably a year or so. So they were being\ndone in parallel,",
    "start": "385690",
    "end": "391550"
  },
  {
    "text": "and then this was published\nin the spring of 2000. This was published\nin the fall of 2000.",
    "start": "391550",
    "end": "396899"
  },
  {
    "text": "It's called the FM-index.  And it achieves\nthis bound, which",
    "start": "396899",
    "end": "403754"
  },
  {
    "text": "is going to take a\nlittle while to explain. ",
    "start": "403754",
    "end": "429270"
  },
  {
    "text": "OK. Think of this right now,\nas this is T log sigma.",
    "start": "429270",
    "end": "436160"
  },
  {
    "text": "Ignore this H. This\nis entropy stuff. But if you think of\nthis as T log sigma,",
    "start": "436160",
    "end": "441919"
  },
  {
    "text": "we're getting 5\ntimes T log sigma, plus some lower-order term.",
    "start": "441920",
    "end": "447800"
  },
  {
    "text": "So it's a little less\nflexible over here. We kind of got to\ncontrol the constant. Anything greater or equal\nto 2 would be all right.",
    "start": "447800",
    "end": "455600"
  },
  {
    "text": "Over here, it's\nalways at least 5. This has since been improved. I'm just telling\nyou the historical--",
    "start": "455600",
    "end": "461750"
  },
  {
    "text": "these days people can get\ndown to at least 4 or so. Actually, get down to 1. We'll talk about it in a moment.",
    "start": "461750",
    "end": "469730"
  },
  {
    "text": "Before I get to\nthe Hk part, I want to talk about the\nlower-order term. There's some scary\nparts like this.",
    "start": "469730",
    "end": "475340"
  },
  {
    "text": "If sigma is that at all\nlarge, this is big trouble. Or even sigma log n-- this is a super polynomial.",
    "start": "475340",
    "end": "483110"
  },
  {
    "text": "So this cannot handle\nvery large sigma, whereas this solution can. And other structures can,\nbut this is an early result.",
    "start": "483110",
    "end": "491930"
  },
  {
    "text": "This also gets bad when\nsigma's very large. Even bigger-- when sigma's\nbigger than log log T,",
    "start": "491930",
    "end": "497539"
  },
  {
    "text": "then this starts to dominate. OK, but for sigma small, think\nbinary alphabets, whatever.",
    "start": "497540",
    "end": "503779"
  },
  {
    "text": "This is good, and in many\nways is actually better than T log sigma. So let me tell you about\nthis Hk of T thing.",
    "start": "503779",
    "end": "511750"
  },
  {
    "text": "This is what's called k-th\norder empirical entropy. ",
    "start": "511750",
    "end": "525769"
  },
  {
    "text": "Maybe I should start with an\naside of 0-th order entropy, because we haven't\ntalked about--",
    "start": "525770",
    "end": "531020"
  },
  {
    "text": "I guess we talked about entropy\nin the context of binary search trees. We said, oh, if you've got-- if you access item i\nwith probability P i,",
    "start": "531020",
    "end": "539300"
  },
  {
    "text": "then there's this entropy bound,\nwhich is sum of P log 1/P.",
    "start": "539300",
    "end": "547450"
  },
  {
    "text": "So I don't know, let's\ncall this character x. So if you-- let's see,\nyou have H0 substring s.",
    "start": "547450",
    "end": "563420"
  },
  {
    "text": "You sum over all\ncharacters in the alphabet,",
    "start": "563420",
    "end": "570029"
  },
  {
    "text": "of the probability-- this\nis not really a probability. This is going to be the\nnumber of x's in s, divided",
    "start": "570030",
    "end": "580490"
  },
  {
    "text": "by the length of s. This is what's called\nempirical probability. It's what you observe\nfrom this string.",
    "start": "580490",
    "end": "586167"
  },
  {
    "text": "There's this many\noccurrences in the string. You divide by the\nlength of the string. That's kind of\nlike a probability. It's scaled to be\nlike a probability.",
    "start": "586167",
    "end": "592389"
  },
  {
    "text": "It's between 0 and 1. And if you take sum of P log\n1/P, that gives you a bound.",
    "start": "592390",
    "end": "597410"
  },
  {
    "text": "And this is the bound achieved\nby say, Huffman coding, or the optimal code.",
    "start": "597410",
    "end": "604542"
  },
  {
    "text": "If all you're allowed to\ndo is give a code word for each letter of the\nalphabet, and then you write down a binary code\nword for each letter",
    "start": "604542",
    "end": "610819"
  },
  {
    "text": "of the alphabet. And you write that down for each\nletter in s, then you achieve-- I guess Huffman codes\nachieve ceiling of this.",
    "start": "610820",
    "end": "617480"
  },
  {
    "text": "If you want to achieve\nexactly that bound, you can use arithmetic\ncoding, but we're not",
    "start": "617480",
    "end": "623660"
  },
  {
    "text": "going to get into\nthose kinds of details. So if you used what's called a\n0-th order code, where you just",
    "start": "623660",
    "end": "630740"
  },
  {
    "text": "have a code for each\ncharacter of the alphabet, then the space bound you\nwould achieve is H0 of s,",
    "start": "630740",
    "end": "637399"
  },
  {
    "text": "times the number\nof characters in s. So that would be if you\nsubstituted k equals 0 here.",
    "start": "637400",
    "end": "645800"
  },
  {
    "text": "So that's kind of neat. This is a compressed\nrepresentation of the string. Over here, we just\nwrote down the string.",
    "start": "645800",
    "end": "653150"
  },
  {
    "text": "And if the string\nis incompressible, yeah, T log sigma is optimal. But if the string is\ncompressible, like many strings",
    "start": "653150",
    "end": "659120"
  },
  {
    "text": "we want to store-- you're\nstoring English, whatever-- you should save somewhere\nbetween a factor of 2 and 10.",
    "start": "659120",
    "end": "664610"
  },
  {
    "text": "This will try to save it. Of course, factor\nbetween 2 and 10 is not-- is a little scary, when\nthere's this factor 5 out here.",
    "start": "664610",
    "end": "672020"
  },
  {
    "text": "That might dominate\nwhatever savings you get. But in theory, this\ncould be a lot better.",
    "start": "672020",
    "end": "677420"
  },
  {
    "text": "And this is just the first\nresult in this series. Now we can get 1 times\nHk of T, and then it's",
    "start": "677420",
    "end": "683240"
  },
  {
    "text": "a lot more interesting. OK, so that was\n0-th order entropy.",
    "start": "683240",
    "end": "690020"
  },
  {
    "text": "What's this k-th order\nentropy business? Essentially, it's about taking--\ninstead of writing a code word for a single letter,\nyou can write a code word",
    "start": "690020",
    "end": "697519"
  },
  {
    "text": "for a letter that depends on\nthe previous k characters.",
    "start": "697520",
    "end": "703670"
  },
  {
    "text": "So I'm going to write\ndown a definition. Hk of T is going to be the sum\nover all words of length k.",
    "start": "703670",
    "end": "714970"
  },
  {
    "text": "This is going to be our\ncontext of the probability, or empirical probability of w\noccurring times the 0-th order",
    "start": "714970",
    "end": "729740"
  },
  {
    "text": "entropy of the string of\nsuccessor characters of w.",
    "start": "729740",
    "end": "744005"
  },
  {
    "text": " So again, the empirical\nprobability of w occurring",
    "start": "744005",
    "end": "749660"
  },
  {
    "text": "is the number of occurrences\nof w, divided by T, basically.",
    "start": "749660",
    "end": "757730"
  },
  {
    "text": "So the idea is, now you get to\nencode a character depending",
    "start": "757730",
    "end": "764570"
  },
  {
    "text": "on the context of the\nlast k characters. So we're summing over\nall possible contexts",
    "start": "764570",
    "end": "770149"
  },
  {
    "text": "of k characters, and we're\ntaking the expectation over all possible context w.",
    "start": "770150",
    "end": "778040"
  },
  {
    "text": "That's the sum of the\nprobabilities times something. And then condition on w\nbeing the context, the last k",
    "start": "778040",
    "end": "785540"
  },
  {
    "text": "characters. We want to measure what\ncharacters follow that.",
    "start": "785540",
    "end": "790790"
  },
  {
    "text": "And there, we can use\na 0-th order encoding. I mean, we've\nalready conditioned on w being right there.",
    "start": "790790",
    "end": "797940"
  },
  {
    "text": "So for all occurrences of w,\nyou look at the next character right after it, and you\ntake 0-th order entropy",
    "start": "797940",
    "end": "803660"
  },
  {
    "text": "of that, that's called\nk-th order entropy. OK, you have to think\nabout it for a while, too.",
    "start": "803660",
    "end": "811230"
  },
  {
    "text": "But this essentially\nmeans the best, you can prove this is the\nbest encoding you can do,",
    "start": "811230",
    "end": "817400"
  },
  {
    "text": "if the codeword of a letter\ncan depend on the previous k characters. Of course, if you have such a\ncode it's easy to decompress,",
    "start": "817400",
    "end": "824000"
  },
  {
    "text": "because as you're decompressing,\nyou know what the previous k characters were. OK, interesting thing about this\nindex or this data structure,",
    "start": "824000",
    "end": "831980"
  },
  {
    "text": "is it's independent of k. The data structure\ndoesn't know what k is.",
    "start": "831980",
    "end": "837080"
  },
  {
    "text": "This works for all k. For any fixed k-- k has\nto be constant here.",
    "start": "837080",
    "end": "845032"
  },
  {
    "text": "There are other data structures\nlike [? KB, ?] logarithmic, or so. But here, we'll think\nof k as a constant.",
    "start": "845032",
    "end": "851020"
  },
  {
    "text": "And so this is really a neat\nthing about compression. There's a technique called\nthe Burrows-Wheeler transform.",
    "start": "851020",
    "end": "857750"
  },
  {
    "text": "And Lempel-Ziv does\nsimilar things. You may have heard of\nthose compression schemes. They're used in bzip,\nand things like-- bzip",
    "start": "857750",
    "end": "864430"
  },
  {
    "text": "is named after\nBurrows-Wheeler, I believe. And those compression\nschemes achieve",
    "start": "864430",
    "end": "872150"
  },
  {
    "text": "Hk of T bits per character-- so Hk of T times T--",
    "start": "872150",
    "end": "877220"
  },
  {
    "text": "for all k. So if your text is\nreally good, given",
    "start": "877220",
    "end": "882410"
  },
  {
    "text": "the context of the last five\nletters, or three letters. In some sense, the compression\nscheme adapts to that.",
    "start": "882410",
    "end": "889110"
  },
  {
    "text": "So this is what we call a\nself index, in that this also stores the string.",
    "start": "889110",
    "end": "894260"
  },
  {
    "text": "You can read the\ndata of the string. And so whereas\nover here, we just",
    "start": "894260",
    "end": "899360"
  },
  {
    "text": "stored the string uncompressed. Here we're effectively\nstoring the string in a compressed form,\nand the data structure",
    "start": "899360",
    "end": "905450"
  },
  {
    "text": "is similarly compressed. So if your string is\ncompressible by more than a factor of 5, this\nwill be really good.",
    "start": "905450",
    "end": "913600"
  },
  {
    "text": "And that's the FM-index bound. Now that you have that Hk\nstuff, it's a lot easier",
    "start": "913600",
    "end": "921530"
  },
  {
    "text": "to state all other results. So we have-- oh, I didn't\ngive a query bound.",
    "start": "921530",
    "end": "928370"
  },
  {
    "text": "That was the space. Query is P plus size of output\ntimes log to the epsilon T.",
    "start": "928370",
    "end": "946069"
  },
  {
    "text": "So, similar to this\none, but we don't have this trick over here.",
    "start": "946070",
    "end": "954470"
  },
  {
    "text": "Another early result\nis by Sadakane. ",
    "start": "954470",
    "end": "960205"
  },
  {
    "text": "I think also, maybe 2001, I have\nthe journal referenced as 2003.",
    "start": "960205",
    "end": "970510"
  },
  {
    "text": "This is in some ways\nbetter, some ways worse, it's kind of incomparable\nto the other results.",
    "start": "970510",
    "end": "975695"
  },
  {
    "start": "975695",
    "end": "992380"
  },
  {
    "text": "This is bits, and then the\nquery has an extra large factor.",
    "start": "992380",
    "end": "1000435"
  },
  {
    "start": "1000435",
    "end": "1008840"
  },
  {
    "text": "This is again,\nanother early result that I want to highlight. Now I'm going to start\nskipping results. The main innovation\nhere, is that it",
    "start": "1008840",
    "end": "1015320"
  },
  {
    "text": "works good for large alphabets. This is a very small\ndependence on sigma, whereas-- as I mentioned,\nthis structure really",
    "start": "1015320",
    "end": "1022841"
  },
  {
    "text": "doesn't work well\nfor large alphabets. Here we're getting-- not\ngetting k-th order entropy, we're getting 0-th\norder entropy.",
    "start": "1022841",
    "end": "1028010"
  },
  {
    "text": "It's a somewhat weaker result.\nThe dependence on epsilon is more like this one.",
    "start": "1028010",
    "end": "1033349"
  },
  {
    "text": " But if you just want\na log factor here,",
    "start": "1033349",
    "end": "1039079"
  },
  {
    "text": "then this is a 1 plus\nepsilon times H0. So in that sense,\nwe're doing better-- only a 1 plus epsilon,\nwhich is better.",
    "start": "1039079",
    "end": "1046880"
  },
  {
    "text": "This thing was\nalways at least 2. This thing was always at least\n5, the complete constant.",
    "start": "1046880",
    "end": "1053000"
  },
  {
    "text": "Here the lead constant\ncan be 1 plus epsilon. This is almost\nsuccinct, but not quite.",
    "start": "1053000",
    "end": "1058010"
  },
  {
    "text": "It doesn't quite\ncompress as well-- it only uses 0-th\norder entropy-- but that's still not bad.",
    "start": "1058010",
    "end": "1063140"
  },
  {
    "text": "And then the other\nbig innovation is the dependence\non sigma small. The query is a little bit worse.",
    "start": "1063140",
    "end": "1069800"
  },
  {
    "text": " OK, now fast forward\na little bit.",
    "start": "1069800",
    "end": "1075710"
  },
  {
    "text": " I want to talk about\nsuccinct data structures",
    "start": "1075710",
    "end": "1080750"
  },
  {
    "text": "for suffix-tree-like queries. ",
    "start": "1080750",
    "end": "1087350"
  },
  {
    "text": "So there's two succinct\ndata structures out there, with more or less the same\nauthors as the first two",
    "start": "1087350",
    "end": "1093620"
  },
  {
    "text": "results I talked about. So Grossi and Vitter,\ntogether with Gupta,",
    "start": "1093620",
    "end": "1099049"
  },
  {
    "text": "can get Hk of T times\nT, which is optimal even",
    "start": "1099050",
    "end": "1107510"
  },
  {
    "text": "with compression, with\nk-th order compression.",
    "start": "1107510",
    "end": "1113390"
  },
  {
    "text": "And a good dependence on sigma. ",
    "start": "1113390",
    "end": "1118440"
  },
  {
    "text": "Yeah, I guess-- T log sigma is the\nuncompressed bound. So you have to worry about--",
    "start": "1118440",
    "end": "1123606"
  },
  {
    "text": "when you're talking\nabout compression, so here we have\nthe optimal bound using k-th order entropy\nwith a lead constant of 1,",
    "start": "1123607",
    "end": "1130669"
  },
  {
    "text": "so that's great. That's what makes it succinct. As long as this is\nlittle o of that. This is going to be a little\no of that, as long as Hk of T",
    "start": "1130670",
    "end": "1138169"
  },
  {
    "text": "is not too small. If it's like 1 over log T, then\nactually this term dominates.",
    "start": "1138170",
    "end": "1146419"
  },
  {
    "text": "But as long as it's bigger\nthan log log T over log T, this thing, then you're fine.",
    "start": "1146420",
    "end": "1153809"
  },
  {
    "text": "Just as long as you're not\ncompressing a huge amount, then this will be lower-order. ",
    "start": "1153810",
    "end": "1161940"
  },
  {
    "text": "Sorry, query time. Query's a little\nbit worse, though. We have a log term with\na P, only a log sigma,",
    "start": "1161940",
    "end": "1170240"
  },
  {
    "text": "but then we also have this\nlog squared over log log. Times log sigma,\nand here I haven't--",
    "start": "1170240",
    "end": "1181280"
  },
  {
    "text": "there isn't a clear dependence\non the size of the output. So this is-- let's say\nsize of output is 1. You just want to find one match.",
    "start": "1181280",
    "end": "1189265"
  },
  {
    "text": "I won't write this dependence\non the size of the output. My guess is this is multiplied\nby the size of the output, but it's not stated\nexplicitly in the paper,",
    "start": "1189265",
    "end": "1196440"
  },
  {
    "text": "so I want to be careful. So we have a polylog\nadditive slowdown here.",
    "start": "1196440",
    "end": "1202460"
  },
  {
    "text": "So it's a little\nbit worse in time, but this space is\nobviously, a lot better. We've improved our constant\nfactor from 5, over here, to 1.",
    "start": "1202460",
    "end": "1212840"
  },
  {
    "text": "OK, and then there's\none more paper I want to mention, by Ferragina,\nManzini, Makinen, and Navarro.",
    "start": "1212840",
    "end": "1229075"
  },
  {
    "text": " This is from just five\nyears ago now, 2007.",
    "start": "1229075",
    "end": "1238880"
  },
  {
    "text": "They also achieved 1 times Hk\nof T times T as the lead term.",
    "start": "1238880",
    "end": "1247890"
  },
  {
    "text": "And they get T divided by log\nto the epsilon n, so this is--",
    "start": "1247890",
    "end": "1253160"
  },
  {
    "text": " yes, it's slight, there's\nprobably a log sigma here, too.",
    "start": "1253160",
    "end": "1259370"
  },
  {
    "text": "I'm not sure, it might just be\nT. Probably just T, actually. So we get rid of the log sigma,\nbut this log log over log",
    "start": "1259370",
    "end": "1267210"
  },
  {
    "text": "gets slightly smaller. It's only a log to\nthe epsilon now. But the query bound is\na little bit better.",
    "start": "1267210",
    "end": "1275550"
  },
  {
    "text": "So the P plus-- as the output times log to\nthe 1 plus epsilon T query.",
    "start": "1275550",
    "end": "1287380"
  },
  {
    "text": " So instead of basically log\nsquared, we have log to 1",
    "start": "1287380",
    "end": "1293010"
  },
  {
    "text": "plus epsilon, slightly better. They also have an\norder P counting query.",
    "start": "1293010",
    "end": "1299350"
  },
  {
    "text": "So if you just want to know\nhow many matches are there, they can do that really fast in\nkind of regular time order P.",
    "start": "1299350",
    "end": "1307529"
  },
  {
    "text": "And this is\nobviously very small. So this is probably\nthe best result so far, still obviously, lots of\nopen problems in this world.",
    "start": "1307530",
    "end": "1317039"
  },
  {
    "text": "Still an active\narea of research. There are papers\nsince these, but they don't achieve-- the\nspace bounds they",
    "start": "1317040",
    "end": "1323310"
  },
  {
    "text": "achieve are not quite as good. There may be like 2\ntimes Hk, and then they can get better query bounds. A lot of papers that\nI'm not talking about,",
    "start": "1323310",
    "end": "1329620"
  },
  {
    "text": "there's just a few too many. But if you just care about\nspace, this is the best so far.",
    "start": "1329620",
    "end": "1335549"
  },
  {
    "text": "Or I use these two, depending\non exactly how big sigma is.",
    "start": "1335550",
    "end": "1341612"
  },
  {
    "text": "Just to mention, there's some\nother cool things you can do. So these are small space\nstatic data structures.",
    "start": "1341612",
    "end": "1348240"
  },
  {
    "text": "Some of them can\nbe made dynamic. But in particular,\nthere's work on, how do you actually build these\ndata structures with low space?",
    "start": "1348240",
    "end": "1356100"
  },
  {
    "text": "Because you don't really want\nto build a huge suffix tree and then compress it. Because the whole point\nis you have a hard time",
    "start": "1356100",
    "end": "1362138"
  },
  {
    "text": "storing this data structure. So in fact, there's\nsome papers-- I think more along the lines\nof these original results--",
    "start": "1362138",
    "end": "1369480"
  },
  {
    "text": "the Grossi-Vitter, Ferragina,\nManzini, and Sadakane-- building those data structures.",
    "start": "1369480",
    "end": "1374820"
  },
  {
    "text": "And while you're building\nthe amount of working space is at least proportional to\nthe size of the final data",
    "start": "1374820",
    "end": "1381540"
  },
  {
    "text": "structure. So that can be done. We're not going to\ngo into it here. There are other papers about--",
    "start": "1381540",
    "end": "1388537"
  },
  {
    "text": "all of these papers\nare focused on how do I do a search, how do\nI search for a pattern, find all the matches. There's other things you\ncan do with suffix trees",
    "start": "1388537",
    "end": "1395490"
  },
  {
    "text": "like, given two suffixes,\nyou can find the longest common prefix of them.",
    "start": "1395490",
    "end": "1401100"
  },
  {
    "text": "So there's papers on how\nto do that kind of stuff in the compressed regime.",
    "start": "1401100",
    "end": "1406200"
  },
  {
    "text": "There's papers on-- or there is\na paper on how to do document retrieval, which is a problem\nwe looked at two lectures ago,",
    "start": "1406200",
    "end": "1412290"
  },
  {
    "text": "in the string lecture. You want to find--\nnot all the matches, you want to find all\nthe documents that have this substring in them.",
    "start": "1412290",
    "end": "1420360"
  },
  {
    "text": "So that can be--\nthat reduces the size of the output in these bounds.",
    "start": "1420360",
    "end": "1426150"
  },
  {
    "text": "That can also be done, Sadakane\nwrote a paper about that. Some work on dynamic-- there's actually a lot of work\nin implementing these data",
    "start": "1426150",
    "end": "1432690"
  },
  {
    "text": "structures, definitely\nFM-index, and I believe, maybe the Sadakane one.",
    "start": "1432690",
    "end": "1438850"
  },
  {
    "text": "And maybe this--\nversions of this one. I don't think the succinct\nones have been implemented, although I don't know for sure.",
    "start": "1438850",
    "end": "1444760"
  },
  {
    "text": "But there's a lot of work\nin implementing this, because people care,\nand indeed they're small and reasonably fast.",
    "start": "1444760",
    "end": "1451760"
  },
  {
    "text": "So if you need a\ntext index, there's freely available implementations\nof at least some of these.",
    "start": "1451760",
    "end": "1458490"
  },
  {
    "text": "So this is one of-- I mean this is\npractical stuff, too.",
    "start": "1458490",
    "end": "1465350"
  },
  {
    "text": "Cool. But as I said, I'm going to\nfocus on the simplest I know, which is Grossi and Vitter.",
    "start": "1465350",
    "end": "1472934"
  },
  {
    "text": "If you look at the\npaper, there are sort of successive improvements. And we're going to\ncover up to the point",
    "start": "1472934",
    "end": "1479279"
  },
  {
    "text": "where we get a good space\nbound, and the query won't be quite as good.",
    "start": "1479280",
    "end": "1484310"
  },
  {
    "text": "So that's going to be\nthe bulk of the lecture. It's how to get\nthat space bound. ",
    "start": "1484310",
    "end": "1492230"
  },
  {
    "text": "And as I mentioned,\nwe're going to start out with a weaker bound, which\nis getting T log log T bits, and then we'll see how\nto improve that to T.",
    "start": "1492230",
    "end": "1501050"
  },
  {
    "text": "And then we'll see how to\nimprove it to 1 over epsilon times T. So it will be a series\nof improvements.",
    "start": "1501050",
    "end": "1507758"
  },
  {
    "text": " And we're going to\nstart just with thinking",
    "start": "1507759",
    "end": "1513590"
  },
  {
    "text": "about suffix arrays. So what is the compressed\nsuffix array problem?",
    "start": "1513590",
    "end": "1519110"
  },
  {
    "text": "Well, it's just that I have-- I want to be able to do\nqueries of the form SA of k.",
    "start": "1519110",
    "end": "1527830"
  },
  {
    "text": "If I imagine the\nsuffixes in sorted order, what is the k-th suffix? Where does it begin? So I want to be able to\nrepresent that array.",
    "start": "1527830",
    "end": "1534940"
  },
  {
    "text": "And using that, you\ncould do searches, and later we'll see how to use\nthat to make a suffix tree.",
    "start": "1534940",
    "end": "1540590"
  },
  {
    "text": "But for now, that's just our\ngoal, is to compute SA of k. OK, well, the idea is actually\ngoing to be very familiar.",
    "start": "1540590",
    "end": "1547400"
  },
  {
    "text": "We saw it two lectures ago,\nwhen we did this divide and conquer for\nbuilding a suffix array. We did this-- we divided\nthe letters in our string",
    "start": "1547400",
    "end": "1555769"
  },
  {
    "text": "by 0, 1, and 2, mod 3. We won't need mod 3. We'll just do mod 2 here.",
    "start": "1555770",
    "end": "1561555"
  },
  {
    "text": "It won't actually matter\nwhat constant we use. But we're going to\nfollow that recursion",
    "start": "1561555",
    "end": "1567830"
  },
  {
    "text": "and use it to represent\nthe suffix array, instead of using it to build it. So the base case, and\nset up some notation.",
    "start": "1567830",
    "end": "1576020"
  },
  {
    "text": "T0 is going to represent T.\nThe length of that string I'm going to call n0 or n.",
    "start": "1576020",
    "end": "1582290"
  },
  {
    "text": " And we have a\nsuffix array, which",
    "start": "1582290",
    "end": "1591590"
  },
  {
    "text": "I'm going to call SA 0, which is\nthe suffix array of that text.",
    "start": "1591590",
    "end": "1597529"
  },
  {
    "text": "So that's just notation. We're not actually storing\nall of those things. ",
    "start": "1597530",
    "end": "1603230"
  },
  {
    "text": "Now, the recursion\nis T k plus 1.",
    "start": "1603230",
    "end": "1609410"
  },
  {
    "text": "That's going to be the next\nlevel, which is, we write-- we combine two letters, Tk--",
    "start": "1609410",
    "end": "1615880"
  },
  {
    "text": "sorry, square bracket-- 2i comma Tk square\nbracket 2i plus 1.",
    "start": "1615880",
    "end": "1622970"
  },
  {
    "text": "Combine two adjacent\nletters into one letter, and we do that for i\nequals 0, 1, up to n/2.",
    "start": "1622970",
    "end": "1632480"
  },
  {
    "text": " That's our new string.",
    "start": "1632480",
    "end": "1637820"
  },
  {
    "text": "I'm not going to\nsort these letters and remap the letters to\ncompress the alphabet. I'm just going to leave\nthose letters alone,",
    "start": "1637820",
    "end": "1643370"
  },
  {
    "text": "as an ordered pair. In general, at level\nTk, a single letter",
    "start": "1643370",
    "end": "1649370"
  },
  {
    "text": "is actually 2 to the k letters. But still, this is a useful\nway to think about it, because it lets me think\nabout fewer suffixes.",
    "start": "1649370",
    "end": "1656190"
  },
  {
    "text": "Here, we only have\nthe even suffixes, suffixes that begin at even\npositions relative to Tk.",
    "start": "1656190",
    "end": "1666650"
  },
  {
    "text": "The size of this string, in\nterms of number of letters, is 1/2 of the original. So in general, this is going\nto be n over 2 to the k.",
    "start": "1666650",
    "end": "1676429"
  },
  {
    "text": "And then we're interested in\nthe suffix array SA k plus 1.",
    "start": "1676430",
    "end": "1681680"
  },
  {
    "text": "This is going to be just\nlooking at the even values.",
    "start": "1681680",
    "end": "1687630"
  },
  {
    "text": "So if we extract even\nentries from sorry, SA k.",
    "start": "1687630",
    "end": "1697340"
  },
  {
    "text": "So if we already\nhave SA k, we just take the even values\nthat are in there.",
    "start": "1697340",
    "end": "1702380"
  },
  {
    "text": "Those are the ones that\nare existing suffixes. Extract those, divide by 2.",
    "start": "1702380",
    "end": "1708050"
  },
  {
    "text": "That will be the suffix\narray of this text. This is kind of\nbackwards from how",
    "start": "1708050",
    "end": "1713809"
  },
  {
    "text": "you would construct the thing. You would construct\nit bottom up. Here, we're\nimagining-- we already know the suffix arrays are\njust about representation.",
    "start": "1713810",
    "end": "1720590"
  },
  {
    "text": "So this is a top-down\nkind of definition of what we're trying to store.",
    "start": "1720590",
    "end": "1725649"
  },
  {
    "text": "OK, so this is\nwhat we want to do. Now we are going to\nbuild things bottom up. We're going to\nimagine we've already",
    "start": "1725650",
    "end": "1731689"
  },
  {
    "text": "represented SA k plus 1. And now we need\nto represent SA k.",
    "start": "1731689",
    "end": "1737059"
  },
  {
    "text": "If we can represent SA k\nin terms of SA k plus 1",
    "start": "1737060",
    "end": "1744050"
  },
  {
    "text": "with not too many\nbits, then you add up all of the levels of recursion. We'll have to talk about how\nmany levels of this recursion",
    "start": "1744050",
    "end": "1750530"
  },
  {
    "text": "we need to do. We're not going to go\ndown to constant size. We'll just go log log n levels.",
    "start": "1750530",
    "end": "1757309"
  },
  {
    "text": "But we just add up\nall those costs, and we'll get the overall\nsize of our data structure.",
    "start": "1757310",
    "end": "1763825"
  },
  {
    "text": " So how do we do\nthis representation?",
    "start": "1763826",
    "end": "1770080"
  },
  {
    "text": "I need to define two\nkind of weird things, and then we'll see why\nthey're interesting.",
    "start": "1770080",
    "end": "1777279"
  },
  {
    "text": "OK, the first thing is called\neven successor sub k of i.",
    "start": "1777280",
    "end": "1784920"
  },
  {
    "text": "So let me define it. It's going to be i if\nthe i-th suffix starts",
    "start": "1784920",
    "end": "1795700"
  },
  {
    "text": "in an even position. So it doesn't do anything\nfor the even guys.",
    "start": "1795700",
    "end": "1800754"
  },
  {
    "text": "The interesting thing\nis when the suffix starts in an odd position. Then we're going to write\ndown a different number j.",
    "start": "1800754",
    "end": "1806730"
  },
  {
    "text": " This is going to look kind\nof weird, but it's actually--",
    "start": "1806730",
    "end": "1814120"
  },
  {
    "text": "it's simple after you think\nabout it for 10 minutes.",
    "start": "1814120",
    "end": "1819330"
  },
  {
    "text": "This one is odd. OK, so the other\nsituation is that SA k--",
    "start": "1819330",
    "end": "1826330"
  },
  {
    "text": "the i-th suffix starts\nat an even position. So let me draw a little picture.",
    "start": "1826330",
    "end": "1831910"
  },
  {
    "text": "So here is SA of i. ",
    "start": "1831910",
    "end": "1839600"
  },
  {
    "text": "OK, if this happens to\nbe odd, this position in the text-- this is Tk.",
    "start": "1839600",
    "end": "1844645"
  },
  {
    "text": " Then I want to go here.",
    "start": "1844645",
    "end": "1850540"
  },
  {
    "text": "OK? Because that's an even\nposition, it's a suffix, it's right next to the\nsuffix I care about. It is what we call the\neven successor suffix.",
    "start": "1850540",
    "end": "1857710"
  },
  {
    "text": "But I don't want to\nknow the index of that. The index of that would\njust be SA k of i plus 1.",
    "start": "1857710",
    "end": "1863590"
  },
  {
    "text": "I want to map backwards\nthrough SA inverse. I want to know, what is\nthe rank of that suffix?",
    "start": "1863590",
    "end": "1872320"
  },
  {
    "text": "Which suffix j\nstarts right there? I want to know that the\nj-th suffix starts right",
    "start": "1872320",
    "end": "1879790"
  },
  {
    "text": "after the i-th suffix, and\nI want to write down j. We'll see why this is the\nright thing in a moment.",
    "start": "1879790",
    "end": "1886590"
  },
  {
    "text": "We're just mapping\nthrough SA, adding 1, and then mapping\nbackwards through SA.",
    "start": "1886590",
    "end": "1892350"
  },
  {
    "text": "So that's a function. We're going to store that\nfunction in a particular-- in a very weird way, which\nwe'll get to in a moment.",
    "start": "1892350",
    "end": "1900670"
  },
  {
    "text": "OK, next thing we need\nis called even rank. This is going to be\nlike our rank function.",
    "start": "1900670",
    "end": "1907910"
  },
  {
    "text": "We've had it before. This is going to be the\nnumber of even suffixes--",
    "start": "1907910",
    "end": "1915220"
  },
  {
    "text": "even suffixes are suffixes\nstarting at even positions-- preceding the i-th suffix.",
    "start": "1915220",
    "end": "1925600"
  },
  {
    "text": "i-th suffix meaning the\ni-th one in sorted order. So the suffix SA of i.",
    "start": "1925600",
    "end": "1931179"
  },
  {
    "text": " Yes, so this is-- let me be more precise.",
    "start": "1931180",
    "end": "1938169"
  },
  {
    "text": "This is the number of even\nvalues in SA k up to i.",
    "start": "1938170",
    "end": "1948460"
  },
  {
    "text": "So we're looking--\nso this was the text. Now we're looking at the\nsuffix array, which has",
    "start": "1948460",
    "end": "1953680"
  },
  {
    "text": "the suffixes in sorted order. We're looking at position i\nhere, and we want to know, of all of these values,\nwhich ones are even?",
    "start": "1953680",
    "end": "1961269"
  },
  {
    "text": "Or how many are even-- that's the even rank. Again, a weird thing,\nwe'll see why it's the right thing in a moment.",
    "start": "1961270",
    "end": "1967530"
  },
  {
    "start": "1967530",
    "end": "1975760"
  },
  {
    "text": "Right now, in fact. ",
    "start": "1975760",
    "end": "1982440"
  },
  {
    "text": "So here is observation 3,\nputting these together.",
    "start": "1982440",
    "end": "1987899"
  },
  {
    "text": "This is a rather long equation.  Ultimately, I want to know--",
    "start": "1987900",
    "end": "1993510"
  },
  {
    "text": "I want to represent Sk of i. I'm trying to represent that. And I want the right-hand side\nto only refer to SA k plus 1.",
    "start": "1993510",
    "end": "2002090"
  },
  {
    "text": "So here's the claim. Take 2 times SA k plus 1 of--",
    "start": "2002090",
    "end": "2008540"
  },
  {
    "start": "2008540",
    "end": "2015187"
  },
  {
    "text": "I'm going to need another board. ",
    "start": "2015187",
    "end": "2030240"
  },
  {
    "text": "Not of i. Even rank of even successor\nof i, minus 1 minus",
    "start": "2030240",
    "end": "2043110"
  },
  {
    "text": "is even suffix of i.",
    "start": "2043110",
    "end": "2054060"
  },
  {
    "text": "OK, so that's the equation. Let me unpack this a little bit.",
    "start": "2054060",
    "end": "2059580"
  },
  {
    "text": "The idea is, we want to\nknow about a suffix i. If i happens to be even-- sorry, not if i happens\nto be even-- if SA of i",
    "start": "2059580",
    "end": "2066929"
  },
  {
    "text": "happens to be\neven, we're golden. Because that suffix is\nrepresented by SA k plus 1,",
    "start": "2066929",
    "end": "2073260"
  },
  {
    "text": "but it might not be even. So we want to round\nit to an even suffix. Knowing about this odd\nsuffix is just about as good",
    "start": "2073260",
    "end": "2081149"
  },
  {
    "text": "as knowing about the suffix\nthat starts right after it. So that's what even\nsuccessor does.",
    "start": "2081150",
    "end": "2086310"
  },
  {
    "text": "This is rounding\nto an even suffix,",
    "start": "2086310",
    "end": "2091620"
  },
  {
    "text": "meaning a suffix starting\nat an even position. ",
    "start": "2091620",
    "end": "2099869"
  },
  {
    "text": "Now there's this issue\nthat over here, we have this relation between\nSA k and SA k plus 1,",
    "start": "2099870",
    "end": "2108630"
  },
  {
    "text": "but it extracts\nthe even entries. So if you think about the\nsuffix array, which now I'm",
    "start": "2108630",
    "end": "2114300"
  },
  {
    "text": "going to draw a vertical,\nbecause that's more normal. ",
    "start": "2114300",
    "end": "2119580"
  },
  {
    "text": "Some of these values\nare going to be even, but you don't really know which\nones are going to be even. It's arbitrary subset of--",
    "start": "2119580",
    "end": "2126529"
  },
  {
    "text": "in SA k, our even values. And those are the ones that you\nextract and form SA k plus 1.",
    "start": "2126530",
    "end": "2135950"
  },
  {
    "text": "But it's an arbitrary\nsubset, that's kind of a-- you can't just divide\nby 2 or something. It's not the right thing.",
    "start": "2135950",
    "end": "2142140"
  },
  {
    "text": "If I'm given an index into\nhere, even if it's an even one, I need to know what the\ncorresponding index is",
    "start": "2142140",
    "end": "2148470"
  },
  {
    "text": "over here. And that, I claim,\nis exactly even rank. Because what position does\nthis cell become over here?",
    "start": "2148470",
    "end": "2159089"
  },
  {
    "text": "Well, however many even\nnumbers there are above it. So you take-- that's what\nthis definition was, a number",
    "start": "2159090",
    "end": "2165839"
  },
  {
    "text": "of even values in that prefix. That is the position you\nwill be in, in SA k plus 1.",
    "start": "2165840",
    "end": "2172360"
  },
  {
    "text": "So this is what I\nwould call the name-- we've now rounded to\nan even suffix but now",
    "start": "2172360",
    "end": "2177630"
  },
  {
    "text": "we need to find the name\nof that even suffix-- in SA k plus 1.",
    "start": "2177630",
    "end": "2185070"
  },
  {
    "text": "So that's exactly\nwhat even rank does. So now we can dereference\nSA k plus 1 of that thing.",
    "start": "2185070",
    "end": "2193050"
  },
  {
    "text": "That will give us a\nposition into the text T k",
    "start": "2193050",
    "end": "2198120"
  },
  {
    "text": "plus 1, where that\nsuffix begins. Now that's an index into\nthis divided by 2 string,",
    "start": "2198120",
    "end": "2207960"
  },
  {
    "text": "we need to uncompress that to\nan index into the actual string. And there are two parts. One is we need to multiply by\n2, because every letter in T",
    "start": "2207960",
    "end": "2215220"
  },
  {
    "text": "k plus 1 is two letters in Tk. So multiply by 2. And sometimes we\nneed to subtract 1.",
    "start": "2215220",
    "end": "2221069"
  },
  {
    "text": "We basically need to subtract\n1 if if even successor did anything. If even successor essentially\nmoved us to the right by 1,",
    "start": "2221070",
    "end": "2228539"
  },
  {
    "text": "now we need to move\nback to the left by 1, if this moved us at all. So I have one more function\nhere, which is is even suffix.",
    "start": "2228540",
    "end": "2235620"
  },
  {
    "text": "Was SA of i an even-- SA sub k of i, an\neven number already.",
    "start": "2235620",
    "end": "2242490"
  },
  {
    "text": "Which means that even\nsuccessor did nothing. If it did nothing,\nthen 1 minus 1 is 0.,",
    "start": "2242490",
    "end": "2250180"
  },
  {
    "text": "and so nothing happens. If it did something,\nthen its even suffix will be 0, because it was odd.",
    "start": "2250180",
    "end": "2255780"
  },
  {
    "text": "And then we're subtracting 1. So this just means\nsubtract 1, if it was odd. You might say minus is\nodd suffix, instead of",
    "start": "2255780",
    "end": "2263130"
  },
  {
    "text": "1 minus is even suffix. But it turns out, this is\nthe thing I want to store, so I wrote it in a weird way.",
    "start": "2263130",
    "end": "2270424"
  },
  {
    "text": "Why did I write it that way? Because is even suffix\nis related to even rank.",
    "start": "2270424",
    "end": "2277380"
  },
  {
    "text": "Even rank is just rank\nsub 1 of is even suffix.",
    "start": "2277380",
    "end": "2284039"
  },
  {
    "text": "And we already saw\nhow to do rank sub 1, and so that's why I\nwanted to reuse it.",
    "start": "2284040",
    "end": "2289650"
  },
  {
    "text": "I think you see now why\nthis equation holds. What remains is how to\nstore is even suffix,",
    "start": "2289650",
    "end": "2296820"
  },
  {
    "text": "even rank, even successor. ",
    "start": "2296820",
    "end": "2303340"
  },
  {
    "text": "One other thing that\nremains, is to say when to stop this recursion.",
    "start": "2303340",
    "end": "2309240"
  },
  {
    "text": "So I claim it's enough to just\ndo this recursion for log log n levels. ",
    "start": "2309240",
    "end": "2323900"
  },
  {
    "text": "And then I'll call log\nlog n l, the number of levels in this recursion. Because at that point,\nn sub l equals n over--",
    "start": "2323900",
    "end": "2333440"
  },
  {
    "text": "it's n over 2 to\nthe l, so that's going to be n over log n. Once I have a string\nof length n over log n,",
    "start": "2333440",
    "end": "2340880"
  },
  {
    "text": "I can afford the regular\nboring representation of a suffix tree.",
    "start": "2340880",
    "end": "2351310"
  },
  {
    "text": "I can afford T log T bits,\nwhen T is only n over log n.",
    "start": "2351310",
    "end": "2356560"
  },
  {
    "text": "If you want to be a\nlittle extra clever, you can put a factor 2 here,\nand then there's a square here.",
    "start": "2356560",
    "end": "2362500"
  },
  {
    "text": "And so then you're really\npaying little o of T in order to store that thing. So once you get\ndown to here, you",
    "start": "2362500",
    "end": "2368860"
  },
  {
    "text": "can afford a simple\nrepresentation. Now let's think about\nhow to compute SA,",
    "start": "2368860",
    "end": "2376210"
  },
  {
    "text": "like the original SA,\nsub 0, of an index. Well I apply this\nformula at all times,",
    "start": "2376210",
    "end": "2386740"
  },
  {
    "text": "I do all these computations. And now I've reduced\nthe problem to SA 1,",
    "start": "2386740",
    "end": "2392806"
  },
  {
    "text": "and then I do\nthese computations. I reduce it to SA 2, and so on. After l steps, I'll have\nreduced it to an SA query",
    "start": "2392806",
    "end": "2400349"
  },
  {
    "text": "in a boring old\nsuffix array, which I've just stored as an array. So then I can answer it, and\nthen I pop up the recursion,",
    "start": "2400350",
    "end": "2407160"
  },
  {
    "text": "log log n times, doing these\nadjustments as appropriate. In the end, I get the correct\nindex into the original text T.",
    "start": "2407160",
    "end": "2415780"
  },
  {
    "text": "How much time did it take? Order log log n time. ",
    "start": "2415780",
    "end": "2423640"
  },
  {
    "text": "So I can do a log log\nn time query to SA.",
    "start": "2423640",
    "end": "2430049"
  },
  {
    "text": " This is, of course, assuming\nthat even rank, even successor,",
    "start": "2430050",
    "end": "2437940"
  },
  {
    "text": "and is even suffix are all\nconstant time operations. So what remains is\nto do each of these",
    "start": "2437940",
    "end": "2444340"
  },
  {
    "text": "in small space\nand constant time. Then my overall query time will\nonly go up by log log factor.",
    "start": "2444340",
    "end": "2450790"
  },
  {
    "text": "This is actually going\nto be pretty good, we're not going to-- we're going to\nachieve log log query",
    "start": "2450790",
    "end": "2456550"
  },
  {
    "text": "when we have T log log T bits. That'll be our first\nencoding of these things.",
    "start": "2456550",
    "end": "2462150"
  },
  {
    "text": "Later on, we're\ngoing have to go up to log to the epsilon, which\nis worse than log log n. ",
    "start": "2462150",
    "end": "2468619"
  },
  {
    "text": "Clear, so far? Everything is pretty\neasy at this point now. It's going to remain\neasy, it's just there's",
    "start": "2468620",
    "end": "2474280"
  },
  {
    "text": "a lot of pieces to the puzzle. This is the first--\nthis is the big idea. Next thing is some\nfancy encoding schemes",
    "start": "2474280",
    "end": "2481240"
  },
  {
    "text": "to make these\nthings quite small. Question? AUDIENCE: [INAUDIBLE] Did you\nsay what the space [INAUDIBLE] was?",
    "start": "2481240",
    "end": "2486640"
  },
  {
    "text": "ERIK DEMAINE: We haven't\nanalyzed space yet, because I haven't said\nhow we're actually storing these functions. If you stored these\nfunctions explicitly, you'd",
    "start": "2486640",
    "end": "2491770"
  },
  {
    "text": "have bad space, probably still\nT log T. But it turns out, these functions can be encoded\nin a clever way, that small--",
    "start": "2491770",
    "end": "2498400"
  },
  {
    "text": "smaller, it's going\nto be T log log T. And still has\nconstant time query.",
    "start": "2498400",
    "end": "2504710"
  },
  {
    "text": "AUDIENCE: Without the functions,\nhow much space are we using? ERIK DEMAINE: Without\nthe functions, we're using,\nessentially, no space.",
    "start": "2504710",
    "end": "2511089"
  },
  {
    "text": "I guess, at the end\nwhere we're using-- the only thing\nwe've said so far, is at the end we use an\nexplicit suffix array.",
    "start": "2511090",
    "end": "2518119"
  },
  {
    "text": "And if you set this\nto 2 log log T, then this would be like n\nover log n bits of space.",
    "start": "2518120",
    "end": "2524010"
  },
  {
    "text": "Because it's going\nto be this times-- I mean, the space at the bottom\nis going to be nl log nl.",
    "start": "2524010",
    "end": "2532980"
  },
  {
    "text": "That's to store an\nexplicit suffix array, so it's going to be\nthis times log of this, which is going to be n over\nlog n, if we put the 2 in.",
    "start": "2532980",
    "end": "2543190"
  },
  {
    "text": "So that part's really cheap,\nand that's little o of n. Of course, we probably also\nhave to store the text.",
    "start": "2543190",
    "end": "2548670"
  },
  {
    "text": "So that's n bits. I didn't mention--\nI'm going to assume, I don't think we need it yet.",
    "start": "2548670",
    "end": "2553780"
  },
  {
    "text": "At some point I will assume\nthat the alphabets binary. So I'm going to leave off--\nwhen I say n bits, really it's",
    "start": "2553780",
    "end": "2559700"
  },
  {
    "text": "n log sigma bits, or n\ncharacters, or whatever. But I'm not going to\nworry about that here.",
    "start": "2559700",
    "end": "2565850"
  },
  {
    "text": "Are there questions? So now, it's an\nencoding problem.",
    "start": "2565850",
    "end": "2571064"
  },
  {
    "text": "How do we encode these guys? ",
    "start": "2571064",
    "end": "2577119"
  },
  {
    "text": "Actually, even successor is the\nonly thing that's non-trivial. We're going to do the\nobvious thing for the rest.",
    "start": "2577120",
    "end": "2582460"
  },
  {
    "text": " So let me tell you about\nthe obvious ones, easy ones.",
    "start": "2582460",
    "end": "2587910"
  },
  {
    "start": "2587910",
    "end": "2596526"
  },
  {
    "text": "At least, the first\nrevision we're not going to do anything fancy\nwith them, later on we will. ",
    "start": "2596527",
    "end": "2606170"
  },
  {
    "text": "Sorry, is even suffix. ",
    "start": "2606170",
    "end": "2617010"
  },
  {
    "text": "We're just going to store\nthis as a bit vector. This is 1 if SA k is\neven, 0 if it's odd.",
    "start": "2617010",
    "end": "2627990"
  },
  {
    "text": "So if we just store\nthat is a bit vector, this is n sub k bits\nthat we can afford.",
    "start": "2627990",
    "end": "2635730"
  },
  {
    "text": "Because this is a\ngeometric series, it's going to be order n. ",
    "start": "2635730",
    "end": "2642030"
  },
  {
    "text": "Next is even rank.  This is just the\nrank one structure",
    "start": "2642030",
    "end": "2650550"
  },
  {
    "text": "that we covered last\nclass, on this thing. So this is going to be nk--",
    "start": "2650550",
    "end": "2659420"
  },
  {
    "text": "I think we did log\nlog nk over log nk.",
    "start": "2659420",
    "end": "2665609"
  },
  {
    "text": "And this can be improved\nto nk over log to the k-- or log to the something of nk.",
    "start": "2665610",
    "end": "2671760"
  },
  {
    "text": "But that's an OK bound. It's little o of N.\nAgain, this is geometric, so this overall will\nbe little o of n.",
    "start": "2671760",
    "end": "2679890"
  },
  {
    "text": "So those are easy, the remaining\npart is doing even successor.",
    "start": "2679890",
    "end": "2688032"
  },
  {
    "start": "2688032",
    "end": "2700119"
  },
  {
    "text": "A little optimization. If the i's where\nSk of i is even,",
    "start": "2700120",
    "end": "2709640"
  },
  {
    "text": "we don't really need\nto store anything. Because then, even successor\nis the identity function.",
    "start": "2709640",
    "end": "2714870"
  },
  {
    "text": "So let's forget\nabout those guys. I'll say, it's trivial\nfor even successors--",
    "start": "2714870",
    "end": "2721640"
  },
  {
    "text": "for even suffixes. ",
    "start": "2721640",
    "end": "2729350"
  },
  {
    "text": "So what I'd like to do, is store\nthe answers for odd suffixes. That's what we're going to do.",
    "start": "2729350",
    "end": "2736549"
  },
  {
    "text": "We're going to store them in\na weird way, as we will see. ",
    "start": "2736550",
    "end": "2750388"
  },
  {
    "text": "So that's the odd suffixes. There are nk over 2 evens,\nand there are nk over 2 odds.",
    "start": "2750388",
    "end": "2759054"
  },
  {
    "text": "So we've just saved\na factor of 2. This wasn't a very\ndeep observation. But it turns out, if you\nfocus in on the odd ones,",
    "start": "2759054",
    "end": "2766320"
  },
  {
    "text": "has a nice little\nstructure to them. ",
    "start": "2766320",
    "end": "2772330"
  },
  {
    "text": "This step isn't\nreally necessary, but it saves a factor of 2. ",
    "start": "2772330",
    "end": "2784910"
  },
  {
    "text": "Now the kind of\ninteresting observation. What I'd like to do is store\nthese answers in order by i.",
    "start": "2784910",
    "end": "2794269"
  },
  {
    "text": "That's the obvious thing to do. I want to store\nbasically an array. ",
    "start": "2794269",
    "end": "2800780"
  },
  {
    "text": "Just store it in\norder by i, so I'm skipping the even suffixes,\njust storing the answers",
    "start": "2800780",
    "end": "2806360"
  },
  {
    "text": "for the odd suffixes. So if I was given a number\ni, how would I look it up?",
    "start": "2806360",
    "end": "2812750"
  },
  {
    "text": "Well, given an index i\ninto the suffix array,",
    "start": "2812750",
    "end": "2819180"
  },
  {
    "text": "what I need to know is-- this is basically the inverse\nof what we did with SA k plus 1.",
    "start": "2819180",
    "end": "2825290"
  },
  {
    "text": "SA k plus 1 is extracting\nthe even entries, here we're extracting\nthe odd entries. So all I need to know\nis the odd rank of i,",
    "start": "2825290",
    "end": "2833660"
  },
  {
    "text": "and then I look\nup into this array at position odd rank of i. That will give me\nthe answer I want.",
    "start": "2833660",
    "end": "2840260"
  },
  {
    "text": "Well, first I check is\nis it an even suffix, which I have stored\nas a bit vector. If it's an even suffix, I\ndo nothing, I just return i.",
    "start": "2840260",
    "end": "2848990"
  },
  {
    "text": "But if it's an odd suffix,\nthen I compute the odd rank. How do I compute the odd rank?",
    "start": "2848990",
    "end": "2854290"
  },
  {
    "text": "I take the even rank\nand take i minus that. Odd rank, we don't need\nto store anything for it.",
    "start": "2854290",
    "end": "2862362"
  },
  {
    "text": "I mean, you could\nif you wanted to, but odd rank is just\ni minus even rank.",
    "start": "2862362",
    "end": "2867530"
  },
  {
    "text": " Because every index\nis either odd or even.",
    "start": "2867530",
    "end": "2875590"
  },
  {
    "text": "OK, great. So I can look up odd rank\nand then look at this array.",
    "start": "2875590",
    "end": "2880900"
  },
  {
    "text": "That'll give me\nthe answer I need. But I'm not going to actually\nstore this as an array. I lied.",
    "start": "2880900",
    "end": "2887350"
  },
  {
    "text": "But in any case, let's\nworry about how I'm going to store it in a moment. Let's think about i-- if I\nI'm storing these answers--",
    "start": "2887350",
    "end": "2895670"
  },
  {
    "text": "the even successor answers,\nthese j values, in order by i.",
    "start": "2895670",
    "end": "2901090"
  },
  {
    "text": "I claim that order is a very\nspecial order, because what does it mean to order by i?",
    "start": "2901091",
    "end": "2907099"
  },
  {
    "text": "Ordering by i, that means the\nsuffixes are sorted, right? So this is the same thing as\nordering by an odd suffix in Tk",
    "start": "2907100",
    "end": "2923240"
  },
  {
    "text": "from SA of i onwards. That's the suffix that we're--",
    "start": "2923240",
    "end": "2929360"
  },
  {
    "text": "sorting by that suffix,\nis sorting by i. ",
    "start": "2929360",
    "end": "2935059"
  },
  {
    "text": "Now we can unpack\nan odd suffix-- it has the first character--\nand then an even suffix.",
    "start": "2935060",
    "end": "2940190"
  },
  {
    "text": "So this is the same\nthing as ordering by-- this should look\nfamiliar because we",
    "start": "2940190",
    "end": "2945350"
  },
  {
    "text": "did the same kinds\nof tricks when we were building suffix trees. ",
    "start": "2945350",
    "end": "2961010"
  },
  {
    "text": "This is even. ",
    "start": "2961010",
    "end": "2966390"
  },
  {
    "text": "In fact, it's the\neven successor. ",
    "start": "2966390",
    "end": "2971673"
  },
  {
    "text": "There's a typo here,\n[? see ?] If we follow SA k,",
    "start": "2971674",
    "end": "2981560"
  },
  {
    "text": "and then we add 1. If we follow SA\nk backwards, that was the definition\nof even successor.",
    "start": "2981560",
    "end": "2988430"
  },
  {
    "text": "So I can rewrite this thing. This part is the same thing as\nTk SA k even successor k of i,",
    "start": "2988430",
    "end": "3006500"
  },
  {
    "text": "closed bracket,\ncolon, closed bracket. Get that right?",
    "start": "3006500",
    "end": "3011980"
  },
  {
    "text": "Yes. That was the definition\nof even successors. Even successor is the value j,\nfor which if I do SA k of j,",
    "start": "3011980",
    "end": "3020950"
  },
  {
    "text": "I get SA k of i plus 1. That's the definition. OK, now Tk of SA of k.",
    "start": "3020950",
    "end": "3030185"
  },
  {
    "text": " Sorry, the suffix--\nthat's not Tk of.",
    "start": "3030185",
    "end": "3035400"
  },
  {
    "text": "There's a colon here. The suffix of Tk\nstarting at SA k.",
    "start": "3035400",
    "end": "3040690"
  },
  {
    "text": "If I sort by those suffixes-- ",
    "start": "3040690",
    "end": "3046770"
  },
  {
    "text": "they're sorted, right? I mean, that was the\npoint of the suffix array, is to sort the suffixes.",
    "start": "3046770",
    "end": "3051860"
  },
  {
    "text": "So if I say I'm ordering by the\nsuffixes given in order by SA",
    "start": "3051860",
    "end": "3057350"
  },
  {
    "text": "k, they're already sorted. There's no reason to do\nthis Tk of SA k part.",
    "start": "3057350",
    "end": "3062720"
  },
  {
    "text": "This is going to be the\nsame thing as the order by this first letter, Tk SA\nk of i comma, even successor.",
    "start": "3062720",
    "end": "3076513"
  },
  {
    "text": " The suffix array is defined\nto have this property,",
    "start": "3076513",
    "end": "3082340"
  },
  {
    "text": "that these orders\nare the same thing.  And sorting by the\nsuffixes is the same thing",
    "start": "3082340",
    "end": "3088510"
  },
  {
    "text": "as sorting by the indices\ninto the suffix array.",
    "start": "3088510",
    "end": "3093590"
  },
  {
    "text": "Interesting, because this is\nwhat I want to store, right? Those are the answers\nthat I'm trying to store.",
    "start": "3093590",
    "end": "3098660"
  },
  {
    "text": "I'm trying to store even\nsuccessor for every i that has an odd--",
    "start": "3098660",
    "end": "3103910"
  },
  {
    "text": "that starts in an odd suffix.  So really, all I need to\ndo is order by this thing.",
    "start": "3103910",
    "end": "3111740"
  },
  {
    "text": "And then once I've\nordered by this thing, I'll store these guys\nin order by their value.",
    "start": "3111740",
    "end": "3120450"
  },
  {
    "text": "Cool. So these are the pairs\nI'm going to store. I'm not going to--",
    "start": "3120450",
    "end": "3125780"
  },
  {
    "text": "I'm going to store this comma\nthis, for all i, in order",
    "start": "3125780",
    "end": "3131110"
  },
  {
    "text": "by this value. That is my goal. If I can store these\nin order by this value, then by computing\nodd rank, I know",
    "start": "3131110",
    "end": "3138560"
  },
  {
    "text": "where in this list\nof pairs to go. And I just look at\nthe second value of the pair, that is my answer.",
    "start": "3138560",
    "end": "3146720"
  },
  {
    "text": "Why am I storing this? We'll see.  I don't know if you really\nneed to, but you can.",
    "start": "3146720",
    "end": "3153500"
  },
  {
    "text": " OK.",
    "start": "3153500",
    "end": "3158810"
  },
  {
    "text": "So what we're going to-- I feel like it's cheating. I say, actually\nstore these pairs.",
    "start": "3158810",
    "end": "3164780"
  },
  {
    "text": "We're not really going\nto actually store them. We still have another\ntrick up our sleeve. But more or less, we're\ngoing to store these pairs--",
    "start": "3164780",
    "end": "3171920"
  },
  {
    "text": "I'll cross out, actually. Store these pairs\nin order by value.",
    "start": "3171920",
    "end": "3182906"
  },
  {
    "text": "Storing them in\norder by value is the same thing as order by i. That's what we just proved.",
    "start": "3182906",
    "end": "3189150"
  },
  {
    "text": "And at this point,\nis when I'm going to assume a binary alphabet. ",
    "start": "3189150",
    "end": "3196971"
  },
  {
    "text": "OK. ",
    "start": "3196971",
    "end": "3202980"
  },
  {
    "text": "Maybe, I'll go through here.",
    "start": "3202980",
    "end": "3208330"
  },
  {
    "text": " Need lots of stuff. ",
    "start": "3208330",
    "end": "3215180"
  },
  {
    "text": "Think we don't need this\ngiant recursion up here. ",
    "start": "3215180",
    "end": "3221494"
  },
  {
    "text": "Just remember,\nit's enough to know how to compute even\nsuccessor, the rest is easy. ",
    "start": "3221494",
    "end": "3256620"
  },
  {
    "text": "So here we go.  We're trying to\nstore these pairs, so we're trying to store\na sorted array of nk",
    "start": "3256620",
    "end": "3270740"
  },
  {
    "text": "over 2 values.  That's how many odd\nsuffixes there are.",
    "start": "3270740",
    "end": "3277520"
  },
  {
    "text": "And they're each 2 to the k\nplus log nk bits, I claim.",
    "start": "3277520",
    "end": "3286460"
  },
  {
    "text": "Why? Because this was a\nsingle character in Tk.",
    "start": "3286460",
    "end": "3291510"
  },
  {
    "text": "But a single character in Tk\nwas actually 2 to the k bits, in the original string\nfor binary alphabet, and general sigma to the k.",
    "start": "3291510",
    "end": "3299120"
  },
  {
    "text": "So that's that part of\nthis 2 to the k bits. The even successor, well,\nthat's just an index into something of size nk.",
    "start": "3299120",
    "end": "3305570"
  },
  {
    "text": "So it's log nk bits. OK, fine. If I store that explicitly,\nI would be in trouble,",
    "start": "3305570",
    "end": "3311390"
  },
  {
    "text": "because 2 to the\nk times nk is n.",
    "start": "3311390",
    "end": "3316470"
  },
  {
    "text": "And so I would be storing\nn bits at every level-- well, so I guess they\nget n log log n space.",
    "start": "3316470",
    "end": "3323300"
  },
  {
    "text": "That part's actually OK. I can afford that\nmuch if I'm just going for an n log log n bound.",
    "start": "3323300",
    "end": "3329900"
  },
  {
    "text": "This part, not so much. Because in particular,\nwhen k equals 0,",
    "start": "3329900",
    "end": "3335270"
  },
  {
    "text": "that's going to\nbe n times log n. I don't want to\nspend n log n space.",
    "start": "3335270",
    "end": "3340431"
  },
  {
    "text": "And the whole point,\nis we're trying to avoid storing\nthese explicitly. Because if I did, I'd\nget n log n space.",
    "start": "3340431",
    "end": "3345920"
  },
  {
    "text": "So we're not going to\nstore them explicitly. ",
    "start": "3345920",
    "end": "3352010"
  },
  {
    "text": "As follows, we are\ngoing to store so there",
    "start": "3352010",
    "end": "3361397"
  },
  {
    "text": "are these big bit vectors. We're going to look at\nthe leading log nk bits.",
    "start": "3361397",
    "end": "3367550"
  },
  {
    "text": "This is kind of weird,\nbecause the log nk bits we care about are at the end. But we're going to look\nat the leading log nk bits",
    "start": "3367550",
    "end": "3374150"
  },
  {
    "text": "especially, because this is\na sorted list of bit vectors.",
    "start": "3374150",
    "end": "3380190"
  },
  {
    "text": "So if you look at the leading\nbits, most of the time, they're going to be the same. They don't change very much.",
    "start": "3380190",
    "end": "3386299"
  },
  {
    "text": "Leading bits are going to\nbe all 0's for a while, and then occasionally\nthey'll increment. How many times\nwill it increment?",
    "start": "3386300",
    "end": "3391904"
  },
  {
    "text": "nk times, at most, if we look\nat the leading log nk bits. ",
    "start": "3391904",
    "end": "3408274"
  },
  {
    "text": "Here's the crazy\nidea, we're going to use unary encoding,\nunary differential encoding. ",
    "start": "3408274",
    "end": "3419440"
  },
  {
    "text": "Differential encoding\nmeans, instead of storing a list of values,\nyou store the first value. Then the next value,\nminus the first value,",
    "start": "3419440",
    "end": "3427539"
  },
  {
    "text": "and then the next value\nminus that value, and so on. And unary means we're\ngoing to represent those differences in unary.",
    "start": "3427540",
    "end": "3434650"
  },
  {
    "text": "Seems like a bad idea, but it\nturns out it's a good idea. So here's what it looks\nlike, you look at--",
    "start": "3434650",
    "end": "3440230"
  },
  {
    "text": "I'm going to write down 0. I'm going to write down a bunch\nof 0's, however big v1 is.",
    "start": "3440230",
    "end": "3447270"
  },
  {
    "text": "Then I'm going to write a 1. Then I'm going to write\na bunch of 0's, however big v2 minus v1 is.",
    "start": "3447270",
    "end": "3455510"
  },
  {
    "text": "Then I'll write a 1, and so on. 0 to the lead, the\nleading bits of v--",
    "start": "3455510",
    "end": "3463200"
  },
  {
    "text": "sorry. It's the leading bits of v2\nminus the leading bits of v1.",
    "start": "3463200",
    "end": "3469190"
  },
  {
    "text": "That's what I meant. And then leading bits of v3\nminus the leading bits of v2.",
    "start": "3469190",
    "end": "3476240"
  },
  {
    "text": "And then 1, and so on. OK, that is unary\ndifferential encoding.",
    "start": "3476240",
    "end": "3482290"
  },
  {
    "text": "I claim this is small,\nlooks kind of crazy. But it's small, because how\nmany 0's are there total?",
    "start": "3482290",
    "end": "3489210"
  },
  {
    "text": "Well, at most, nk 0's. Because I start at the value 0.",
    "start": "3489210",
    "end": "3495340"
  },
  {
    "text": "With log nk bits, at most\nI get up to n k minus 1. So the number of times I\nincrement is, at most, nk.",
    "start": "3495340",
    "end": "3502505"
  },
  {
    "text": " How many 1's are there? ",
    "start": "3502505",
    "end": "3510040"
  },
  {
    "text": "Well, there's one 1, per value. So there's nk over 2 1's.",
    "start": "3510040",
    "end": "3515620"
  },
  {
    "start": "3515620",
    "end": "3520840"
  },
  {
    "text": "So total size of this\nbit factor is 3/2 nk.",
    "start": "3520840",
    "end": "3526030"
  },
  {
    "text": " So storing those leading bits\nin this weird way is cheap.",
    "start": "3526030",
    "end": "3534630"
  },
  {
    "text": "Linear-- again, this\ngeometric series is going to add up to 3/2. All right, it's going\nto add up to 3 times n.",
    "start": "3534630",
    "end": "3544640"
  },
  {
    "text": "Cool. But that's just\nthe leading bits-- I need to store this thing.",
    "start": "3544640",
    "end": "3549646"
  },
  {
    "text": "I need to store\nthe leading bits, and I need to store\nthe remaining bits. Now the remaining bits, there's\nonly 2 to the k remaining bits.",
    "start": "3549646",
    "end": "3555660"
  },
  {
    "text": "We switched the order. We looked at the\nhigh log nk bits, but then the low\nend bits, there's going to be 2 to the k of them.",
    "start": "3555660",
    "end": "3561390"
  },
  {
    "text": "That I already said was OK. We could afford that-- kind of, we'd lose\na log log factor.",
    "start": "3561390",
    "end": "3570019"
  },
  {
    "text": "So we store the trailing\n2 of the k bits. This we actually\nstore explicitly.",
    "start": "3570020",
    "end": "3576940"
  },
  {
    "text": " So this is going to\nbe 2 to the k times",
    "start": "3576940",
    "end": "3584350"
  },
  {
    "text": "nk over 2, which is n/2 bits.",
    "start": "3584350",
    "end": "3590520"
  },
  {
    "text": "nk is n over 2 to the k. Cancel, n over 2.",
    "start": "3590520",
    "end": "3596650"
  },
  {
    "text": "OK, so total number of\nbits-- we add these up-- is going to be 1/2\nn plus 3/2 nk plus--",
    "start": "3596650",
    "end": "3611130"
  },
  {
    "text": "we'll get to this later. And then the total, this we\nhave to do for log log n levels.",
    "start": "3611130",
    "end": "3619710"
  },
  {
    "text": "We're summing k\nequals 0 to log log n.",
    "start": "3619710",
    "end": "3625170"
  },
  {
    "text": "This thing. And this comes out\nto 1/2 n log log n.",
    "start": "3625170",
    "end": "3633604"
  },
  {
    "text": "This is bad, we want\nto get rid of that. But that was our first\naim, then we have 5n--",
    "start": "3633604",
    "end": "3642660"
  },
  {
    "text": "did I miss a term?  OK.",
    "start": "3642660",
    "end": "3648080"
  },
  {
    "start": "3648080",
    "end": "3653555"
  },
  {
    "text": "Where did I miss the nk? This was the cost\nfor even successor.",
    "start": "3653555",
    "end": "3661450"
  },
  {
    "text": "OK, but there was also, is\neven suffix, which was nk bits, and there was even rank,\nwhich was little o of that.",
    "start": "3661450",
    "end": "3668010"
  },
  {
    "text": "So there's an extra nk\nhere for is even suffix.",
    "start": "3668010",
    "end": "3673035"
  },
  {
    "text": " OK, so we have nk plus 3/2 nk.",
    "start": "3673035",
    "end": "3680490"
  },
  {
    "text": "That's 5/2 nk. And then the 1/2\ndisappears because it's a geometric series. So we end up with 5n,\nfor what it's worth.",
    "start": "3680490",
    "end": "3688710"
  },
  {
    "text": "Plus big O of something. OK, I left out something,\nbecause there's one data structure we\nhaven't yet described.",
    "start": "3688710",
    "end": "3695640"
  },
  {
    "text": "There's one more thing we need. And that comes up if you want\nto do a query in the structure. How do I do a query?",
    "start": "3695640",
    "end": "3701280"
  },
  {
    "text": " I already did odd\nrank, so I'm just",
    "start": "3701280",
    "end": "3706619"
  },
  {
    "text": "trying to look up into the\nsorted array, at a given index. Well, first thing is to\ncompute the leading bits.",
    "start": "3706620",
    "end": "3715740"
  },
  {
    "text": "Actually, computing\nleading bits is really easy if I have rank and select. What I want, if I'm trying\nto index into index i,",
    "start": "3715740",
    "end": "3725590"
  },
  {
    "text": "I want the i-th one bit. To look at the\ni-th one bit, which is select sub 1 of i, which\nwe already know how to do,",
    "start": "3725590",
    "end": "3738690"
  },
  {
    "text": "then that corresponds\nto the i-th value.",
    "start": "3738690",
    "end": "3744040"
  },
  {
    "text": "And in particular,\nif I look at how many 0's are there up\nto that point, it's",
    "start": "3744040",
    "end": "3750570"
  },
  {
    "text": "going to be the sum of this. Plus this, plus this,\nit's a telescoping sum. It's just going to give\nme the leading bits.",
    "start": "3750570",
    "end": "3759380"
  },
  {
    "text": "Because this plus this\nis just lead of v2. This plus that is lead of v3.",
    "start": "3759380",
    "end": "3764930"
  },
  {
    "text": "So they all cancel. I just count the\nnumber of 0 bits. That's exactly the\nvalue I want to know.",
    "start": "3764930",
    "end": "3770540"
  },
  {
    "text": "So I want to do rank\nsub 0 of that position.",
    "start": "3770540",
    "end": "3776960"
  },
  {
    "text": "That will tell me\nthe leading bits. In a query, it's not\nreally lead of i, I guess.",
    "start": "3776960",
    "end": "3788730"
  },
  {
    "text": "Lead of vi is what\nwe're trying to compute. Now, we also need\nthe trailing bits.",
    "start": "3788730",
    "end": "3794540"
  },
  {
    "text": "The trailing bits,\nthey're just in an array, so you just look that up. You get the trailing bits. You concatenate those\ntwo words, the leading",
    "start": "3794540",
    "end": "3800180"
  },
  {
    "text": "bits of the trailing bits--\nboom, you have your answer. That gives you the\neven successor.",
    "start": "3800180",
    "end": "3805820"
  },
  {
    "text": "So the only thing\nis we need to store rank and a select structure. And for rank, we used nk\nover log log nk space.",
    "start": "3805820",
    "end": "3816320"
  },
  {
    "text": "Again, that can be improved\nto nk over polylog nk. But let's not worry about that. ",
    "start": "3816320",
    "end": "3832289"
  },
  {
    "text": "Item 1 completes. We now have a T log\nlog T bit suffix array.",
    "start": "3832290",
    "end": "3839410"
  },
  {
    "text": "Next, we need to\nmake it order T, then we need to make\nit into suffix tree.",
    "start": "3839410",
    "end": "3845261"
  },
  {
    "text": "We're going to move\na little faster. ",
    "start": "3845261",
    "end": "3851570"
  },
  {
    "text": "Where to go now? ",
    "start": "3851570",
    "end": "3862080"
  },
  {
    "text": "Now I want a compact\nsuffix array. ",
    "start": "3862080",
    "end": "3871670"
  },
  {
    "text": "I'm going to use\nthe same definition. Everything's going to be\nmore or less the same.",
    "start": "3871670",
    "end": "3876849"
  },
  {
    "text": "I just can't afford to\nstore all these levels. ",
    "start": "3876849",
    "end": "3884034"
  },
  {
    "text": "There were log log n levels. Log log n levels\nis too expensive. Each one costs linear space.",
    "start": "3884034",
    "end": "3889240"
  },
  {
    "text": "So I'm only going to store\na constant number of levels. ",
    "start": "3889240",
    "end": "3894849"
  },
  {
    "text": "Only store 1 over\nepsilon plus 1 levels.",
    "start": "3894850",
    "end": "3900350"
  },
  {
    "text": " And not just any levels,\nbut the first level,",
    "start": "3900350",
    "end": "3906410"
  },
  {
    "text": "the epsilon l-th level,\nthe 2 epsilon l-th level, up to the l-th level.",
    "start": "3906410",
    "end": "3911660"
  },
  {
    "text": "So it's still log log n levels. I'm just going to\nskip a lot of them.",
    "start": "3911660",
    "end": "3917120"
  },
  {
    "text": "Now, it's going to be different. I can't use even\nsuccessor anymore. Instead, even is\ngoing to be replaced",
    "start": "3917120",
    "end": "3927080"
  },
  {
    "text": "with the notion of divisible\nby 2 to the epsilon l,",
    "start": "3927080",
    "end": "3932740"
  },
  {
    "text": "instead of divisible by 2.  So I do all this, but\nreplace the notion of even",
    "start": "3932740",
    "end": "3940310"
  },
  {
    "text": "with divisible by epsilon l. Because this is when you are\nin SA sub k plus 1 epsilon l.",
    "start": "3940310",
    "end": "3957860"
  },
  {
    "text": "The whole name of\nthe game is, you're trying to do a query\nin SA k epsilon l,",
    "start": "3957860",
    "end": "3963619"
  },
  {
    "text": "and now you want to reduce\nit to SA k plus 1 epsilon l. And these are the suffixes that\nare explicitly represented.",
    "start": "3963620",
    "end": "3970790"
  },
  {
    "text": "Everything else needs to be\nrounded to that value, then rounded back, like we had\nwith our giant formula before.",
    "start": "3970790",
    "end": "3977215"
  },
  {
    "text": "It's not so easy to write\na single formula anymore, it's now really an algorithm. ",
    "start": "3977215",
    "end": "3984440"
  },
  {
    "text": "So to compute SA\nk epsilon l of i,",
    "start": "3984440",
    "end": "3990010"
  },
  {
    "text": "what you do is follow\na new thing, which I'm going to call\njust successor of i,",
    "start": "3990010",
    "end": "3998600"
  },
  {
    "text": "repeatedly to get a new index j.",
    "start": "3998600",
    "end": "4005050"
  },
  {
    "text": " Or I guess call it i prime,\nmake it a little clearer--",
    "start": "4005050",
    "end": "4011810"
  },
  {
    "text": "until it's even. ",
    "start": "4011810",
    "end": "4020079"
  },
  {
    "text": "So before, we just\nhad to make one step, and then we were even. Now, we're going to have to make\npotentially epsilon l steps.",
    "start": "4020080",
    "end": "4026680"
  },
  {
    "text": "So this could cost log log n. Log log n, that's not much. Actually-- sorry, not log log n.",
    "start": "4026680",
    "end": "4034700"
  },
  {
    "text": "This is going to\ncost 2 to the epsilon l, because it's divisible\nby 2 to the epsilon l.",
    "start": "4034700",
    "end": "4040020"
  },
  {
    "text": "2 to the epsilon l is\nlog to the epsilon. So this now may take log\nto the epsilon T steps.",
    "start": "4040020",
    "end": "4053650"
  },
  {
    "text": "This is where we're going to get\nthe log to the epsilon penalty, in time.",
    "start": "4053650",
    "end": "4058800"
  },
  {
    "text": "OK, but it's simple linear\nsearch, nothing clever here. Now, what is successor?",
    "start": "4058800",
    "end": "4064039"
  },
  {
    "text": "Well, successor is\njust the same thing.  If you're even in this strong\nsense, then nothing happens.",
    "start": "4064040",
    "end": "4071740"
  },
  {
    "text": "Otherwise, you just--\nsame definition. This part is exactly the same. Just go to the next\nposition, the next suffix.",
    "start": "4071740",
    "end": "4079180"
  },
  {
    "text": "But now we have to\nfollow it several times, until we get to an even one.",
    "start": "4079180",
    "end": "4084220"
  },
  {
    "text": "OK. Then we recurse, just\nlike before on SA k plus",
    "start": "4084220",
    "end": "4093220"
  },
  {
    "text": "1, epsilon l. The next level down of the--",
    "start": "4093220",
    "end": "4100456"
  },
  {
    "text": "I think we can still\ncall it even rank. ",
    "start": "4100456",
    "end": "4115520"
  },
  {
    "text": "And then we multiply\nby 2 to the epsilon l.",
    "start": "4115520",
    "end": "4126370"
  },
  {
    "text": " And then subtract the number\nof steps we did, in 1.",
    "start": "4126370",
    "end": "4137020"
  },
  {
    "start": "4137020",
    "end": "4143318"
  },
  {
    "text": "We made several\nsteps here, we need to undo those steps at the end. That's it. So it's just the same as\nbefore, except before there",
    "start": "4143319",
    "end": "4149846"
  },
  {
    "text": "was one step here, and\nat most, one step here. Now you just count them,\nsubtract at the end. So exactly the\nsame template, just",
    "start": "4149846",
    "end": "4156620"
  },
  {
    "text": "skipping a lot of the levels. And now the space is going to be\n1 over epsilon, plus 1 times n.",
    "start": "4156620",
    "end": "4165528"
  },
  {
    "text": "That's it. OK, so let me\nanalyze a little bit. ",
    "start": "4165529",
    "end": "4175339"
  },
  {
    "text": "So you have to check\nthat all of this works. Is is even suffix, that's easy. It's still nk bits.",
    "start": "4175340",
    "end": "4180680"
  },
  {
    "text": "Even rank, still nk bits. Even successor, we did\nall this fancy encoding. The one thing you\ncan't do, is this part.",
    "start": "4180680",
    "end": "4187472"
  },
  {
    "text": "I mean, there aren't very\nmany even suffixes anymore. So it really doesn't help you,\nit buys you a very tiny factor.",
    "start": "4187472",
    "end": "4194970"
  },
  {
    "text": "But 1 over 2 to the epsilon\nl are going to be even.",
    "start": "4194970",
    "end": "4200840"
  },
  {
    "text": "So that's very few. So you still have to store\nall the answers, basically. But you can do all this\nordering trick, it still works.",
    "start": "4200840",
    "end": "4206730"
  },
  {
    "text": "We weren't really exploiting\nthe fact that it was odd. And now you have to-- this\nis not a single character,",
    "start": "4206730",
    "end": "4213290"
  },
  {
    "text": "it's a bunch of characters. But still-- and so now\ninstead of 2 to the k,",
    "start": "4213290",
    "end": "4219860"
  },
  {
    "text": "it's probably 2 to\nthe k epsilon l. But it all works out.",
    "start": "4219860",
    "end": "4225950"
  },
  {
    "text": "It's just a renaming\nof everything. It's still going to be linear\nnumber of bits, I claim.",
    "start": "4225950",
    "end": "4232665"
  },
  {
    "text": "I don't want to go through\na formal proof for that, we don't have time. ",
    "start": "4232665",
    "end": "4238290"
  },
  {
    "text": "But all the same tricks work. ",
    "start": "4238290",
    "end": "4245730"
  },
  {
    "text": "So the claim is\nspace going to be sum",
    "start": "4245730",
    "end": "4253500"
  },
  {
    "text": "k equals 0 to 1 over epsilon.",
    "start": "4253500",
    "end": "4258850"
  },
  {
    "text": "nk epsilon l, plus n,\nplus 2 nk epsilon l,",
    "start": "4258850",
    "end": "4265480"
  },
  {
    "text": "plus the select bound,\nn over log log n.",
    "start": "4265480",
    "end": "4272702"
  },
  {
    "text": " Why?",
    "start": "4272702",
    "end": "4277900"
  },
  {
    "text": "Because this is storing\nthe is even structure. That was just nk bits.",
    "start": "4277900",
    "end": "4283180"
  },
  {
    "text": "And then, this is the successor. This is, is even.",
    "start": "4283180",
    "end": "4289049"
  },
  {
    "text": " Same as we had over here,\nexcept there's no 1/2 anymore.",
    "start": "4289049",
    "end": "4296080"
  },
  {
    "text": "It's just n plus-- claim is 2 nk epsilon l.",
    "start": "4296080",
    "end": "4303429"
  },
  {
    "text": "That's the right answer. Yeah, that 3 was because\nof this, plus this. So we still have the 3, just\ndon't divide it by 2 anymore.",
    "start": "4303430",
    "end": "4310110"
  },
  {
    "start": "4310110",
    "end": "4315949"
  },
  {
    "text": "So this equals some\nconstant times n, 6n",
    "start": "4315950",
    "end": "4324060"
  },
  {
    "text": "plus 1 over epsilon n. ",
    "start": "4324060",
    "end": "4329409"
  },
  {
    "text": "Plus order n over\nlog log n bits.",
    "start": "4329410",
    "end": "4334416"
  },
  {
    "text": " OK, not bad.",
    "start": "4334416",
    "end": "4339840"
  },
  {
    "text": "Not quite as good as this\nbound for binary alphabet, so ignore the log sigma.",
    "start": "4339840",
    "end": "4345210"
  },
  {
    "text": "Before we had 1 plus\n1 over epsilon, now we have 6 plus 1 over epsilon. ",
    "start": "4345210",
    "end": "4352494"
  },
  {
    "text": "Kind of running out of time. I'll just tell you, you can\ntune this to 1 over epsilon n,",
    "start": "4352494",
    "end": "4360260"
  },
  {
    "text": "plus the little o, with\ntwo very simple tricks. Two simple observations.",
    "start": "4360260",
    "end": "4365309"
  },
  {
    "text": "The first one is, the\nsuccessor structure.",
    "start": "4365310",
    "end": "4371540"
  },
  {
    "text": "At level 0, there's\nnothing to do. Why? Because level 0--\na single step just",
    "start": "4371540",
    "end": "4382710"
  },
  {
    "text": "corresponds to\nwalking in the string. I've got to think about\nthis a little bit.",
    "start": "4382710",
    "end": "4388437"
  },
  {
    "text": "Successor-- Actually not quite\nclear to me why that's true,",
    "start": "4388437",
    "end": "4396420"
  },
  {
    "text": "but it turns out to be true. It's an exercise, I guess. At level 0, you don't need to\n[? the ?] successor structure.",
    "start": "4396420",
    "end": "4403580"
  },
  {
    "text": "So that actually saves you\na big factor, because if you can skip the very--",
    "start": "4403580",
    "end": "4408680"
  },
  {
    "text": "k equals 0, then you get to\nskip-- you get to divide by 2 to the epsilon l, the space.",
    "start": "4408680",
    "end": "4413869"
  },
  {
    "text": "So that gets rid of this term. Then there's this other\nterm, which you can skip,",
    "start": "4413870",
    "end": "4423630"
  },
  {
    "text": "or you can store is\neven more efficiently. So before is even,\nshould be a big factor. Because half of them\nare even, half of them",
    "start": "4423630",
    "end": "4430010"
  },
  {
    "text": "are odd, that's the\noptimal thing to do. But in this structure,\nmost of them are not even.",
    "start": "4430010",
    "end": "4435920"
  },
  {
    "text": "So you can save a little bit\nusing succinct dictionaries. Because there are\nvery few ones--",
    "start": "4435920",
    "end": "4441800"
  },
  {
    "text": "you can achieve log, the\ntotal number of things, choose the number of ones.",
    "start": "4441800",
    "end": "4448240"
  },
  {
    "text": "[? Bog ?] of that binomial\ncoefficient is the number of 0's plus 1's. Not going to work it out,\nit's worked out in the notes.",
    "start": "4448240",
    "end": "4455170"
  },
  {
    "text": "But if you store that more\nefficient dictionary, which we claimed could\nbe done last time, then this turns out to get a\nnice sort of cascading thing.",
    "start": "4455170",
    "end": "4463760"
  },
  {
    "text": "And it's little of\nof n, in the end. So that gets rid of this term.",
    "start": "4463760",
    "end": "4468920"
  },
  {
    "text": "And so you're left with\njust n times 1 over epsilon. Plus 1, because you have\nto store the text also.",
    "start": "4468920",
    "end": "4474680"
  },
  {
    "text": " Or maybe because of\nthis plus 1, anyway.",
    "start": "4474680",
    "end": "4483410"
  },
  {
    "text": "Boom. That's all I want to say\nabout this structure.",
    "start": "4483410",
    "end": "4488719"
  },
  {
    "text": "So I wanted to focus on\nthe ideas, which got us the T log log T. Just\napply the same ideas,",
    "start": "4488720",
    "end": "4494940"
  },
  {
    "text": "but much more sparsely. You lose in running\ntime, instead of paying log log T. Now we pay--",
    "start": "4494940",
    "end": "4500240"
  },
  {
    "text": "we pay log to the\nepsilon times log log T, but that's just log\nto some other epsilon. ",
    "start": "4500240",
    "end": "4506870"
  },
  {
    "text": "So that gives us better space. Now linear space, instead\nof n log log space.",
    "start": "4506870",
    "end": "4513699"
  },
  {
    "text": "Any questions about that? All right. ",
    "start": "4513700",
    "end": "4519310"
  },
  {
    "text": "Now, I get to hurry through\ntransforming suffix arrays,",
    "start": "4519310",
    "end": "4524740"
  },
  {
    "text": "into suffix trees. ",
    "start": "4524740",
    "end": "4535611"
  },
  {
    "text": "This is actually a\nmuch older paper. It's by [? Monroe, ?]\n[? Roman, ?] and [? Row. ?]",
    "start": "4535611",
    "end": "4545710"
  },
  {
    "text": "There's two versions of\nit in the same paper. First version is going to\nbe compact, second version",
    "start": "4545710",
    "end": "4551680"
  },
  {
    "text": "is succinct. Probably won't have much time\nto cover the succinct version, but here's what we do.",
    "start": "4551680",
    "end": "4557920"
  },
  {
    "text": "Start with compact. Store compressed--\nwe're going to assume",
    "start": "4557920",
    "end": "4564460"
  },
  {
    "text": "binary alphabet again, as\nthis paper does, I believe.",
    "start": "4564460",
    "end": "4572230"
  },
  {
    "text": "Store the suffix tree, but\nonly store the trie part of it. Suffix tree really\nconsists of trie--",
    "start": "4572230",
    "end": "4579510"
  },
  {
    "text": "binary trie, if it's\na binary alphabet. Plus, lengths on the edges.",
    "start": "4579510",
    "end": "4585219"
  },
  {
    "text": "Don't store the links. Or, as Ian likes to\ncall it, skip the skips.",
    "start": "4585220",
    "end": "4590980"
  },
  {
    "text": "The lengths of an\nedge is how many bits you're supposed to\nskip, so skip those.",
    "start": "4590980",
    "end": "4596530"
  },
  {
    "text": "Just store the trie structure. So the trie structure\nis on 2n plus 1 nodes,",
    "start": "4596530",
    "end": "4603250"
  },
  {
    "text": "because there is n\nleaves, and minus 1. Telling me it's plus\n1, I don't know. 2n plus a constant nodes.",
    "start": "4603250",
    "end": "4610820"
  },
  {
    "text": "So this is 4n bits. We know how to do\nbinary tries, finally",
    "start": "4610820",
    "end": "4617440"
  },
  {
    "text": "we're using last lecture. We use rank and select\na lot, but now are using the binary trie. We're going to store this using\nthe balanced paren structure.",
    "start": "4617440",
    "end": "4625670"
  },
  {
    "text": "OK, so you have to double that--\nthis linear number of bits, so if we're just looking\nfor compact, that's fine.",
    "start": "4625670",
    "end": "4631540"
  },
  {
    "text": "Now the hard part\nis in a search, where we go from one\nnode, to the next node.",
    "start": "4631540",
    "end": "4638630"
  },
  {
    "text": "We need to know the\nlength of this edge, we've got to figure that out. We need to know whether\nthe pattern jumped off,",
    "start": "4638630",
    "end": "4645100"
  },
  {
    "text": "or something. We need to know at position\ny, which letter of the pattern",
    "start": "4645100",
    "end": "4651190"
  },
  {
    "text": "should we branch on. So we need to\nmeasure this length.",
    "start": "4651190",
    "end": "4656320"
  },
  {
    "text": "Not too hard. What you do, you\nlook at this subtree. You look at the leftmost\nleaf and the rightmost leaf.",
    "start": "4656320",
    "end": "4664329"
  },
  {
    "text": "You look at their\nlongest common prefix, starting from the\ncharacter you care about. And you look at the longest\ncommon prefix with the pattern",
    "start": "4664330",
    "end": "4670720"
  },
  {
    "text": "P. All sounds easy-- how do you actually do it? So you need to be able to find\nthe leftmost leaf in a subtree.",
    "start": "4670720",
    "end": "4678700"
  },
  {
    "text": "Leaves in the balanced\nparen expression-- I think last class, I mistakenly\nthought they were that.",
    "start": "4678700",
    "end": "4685270"
  },
  {
    "text": "In fact, they are this. Think about it long enough. This was leaves in\nthe rooted order tree,",
    "start": "4685270",
    "end": "4691832"
  },
  {
    "text": "but what we care about are\nleaves in the binary tree. And they always look\nlike open paren, closed paren, and closed paren. So this is a leaf,\nand so what we're",
    "start": "4691832",
    "end": "4699820"
  },
  {
    "text": "asking for is in a subtree,\nwe'll find the first leaf. That's actually just going to\nbe right after this open paren.",
    "start": "4699820",
    "end": "4706120"
  },
  {
    "text": "Or, I guess, you do a\nselect, select sub this,",
    "start": "4706120",
    "end": "4712870"
  },
  {
    "text": "to jump to the next leaf. Then also, you can jump\nto the end of the subtree and then go back to the previous\nleaf, using rank and select.",
    "start": "4712870",
    "end": "4719890"
  },
  {
    "text": "So I won't go into details,\nbut that's easy to do. So you can identify\nthe two leaves using rank sub, this thing.",
    "start": "4719890",
    "end": "4727720"
  },
  {
    "text": "I can identify the leaf\nnumber, so I can identify where these leaves are.",
    "start": "4727720",
    "end": "4733090"
  },
  {
    "text": "Now, I have a suffix array. If I look up the suffix array\nof these two leaf numbers--",
    "start": "4733090",
    "end": "4738520"
  },
  {
    "text": "remember leaves are ordered\nby suffix in sorted order by suffix array. These are really indices\ninto the suffix array.",
    "start": "4738520",
    "end": "4745180"
  },
  {
    "text": "They're giving me-- oh,\nthis is the i-th suffix, this is the j-th suffix. So I look at those two\npositions of the suffix array,",
    "start": "4745180",
    "end": "4751078"
  },
  {
    "text": "I teleport over to the string T.\nNow I have the actual suffixes corresponding to this and this.",
    "start": "4751078",
    "end": "4757120"
  },
  {
    "text": "And I just look at\nwhere they match. I know that if I've already\ngone down to depth d,",
    "start": "4757120",
    "end": "4762940"
  },
  {
    "text": "letter depth d. I already know that they\nmatch the first d characters. I don't compare those. They're guaranteed to match.",
    "start": "4762940",
    "end": "4768460"
  },
  {
    "text": "So I start at position d plus 1. I know they should match,\nbut one more letter. How many more letters\ndo they match?",
    "start": "4768460",
    "end": "4774430"
  },
  {
    "text": "That is the length\nof this thing. OK. How can I afford\nto pay for that? I'm just going to pen linear\ncost, the total number",
    "start": "4774430",
    "end": "4781030"
  },
  {
    "text": "of characters I\ncompare, is going to be equal to the\nlength of the pattern. So we're going to end up\ngetting length of the pattern,",
    "start": "4781030",
    "end": "4787750"
  },
  {
    "text": "times the cost to do\na suffix array access. Because I have to do this\nat every single step,",
    "start": "4787750",
    "end": "4793720"
  },
  {
    "text": "in the worst case. So not perfect, but pretty good. Roughly P, suffix array access\nis like log to the epsilon.",
    "start": "4793720",
    "end": "4801864"
  },
  {
    "text": "So we're getting a P\nlog to the epsilon. Not quite as good as this\nbound, but because here the P",
    "start": "4801864",
    "end": "4808283"
  },
  {
    "text": "is not multiplied by\nlog to the epsilon. But, it's just log\nto the epsilon. If you want to see a\nbetter way to do it,",
    "start": "4808284",
    "end": "4813760"
  },
  {
    "text": "you can read the\nGrossi-Vitter paper. But this is a\ndecent way to do it. ",
    "start": "4813760",
    "end": "4820900"
  },
  {
    "text": "Now briefly, this is\nthe compact version,",
    "start": "4820900",
    "end": "4825997"
  },
  {
    "text": "and let me tell you how\nto make it succinct. ",
    "start": "4825997",
    "end": "4833504"
  },
  {
    "text": "I'm not going to touch\nthe suffix array. Suffix array, to make\nthat succinct is harder. But if I just want to make the\nsuffix tree parts succinct,",
    "start": "4833504",
    "end": "4841199"
  },
  {
    "text": "I can use this same\nidea, but I can't afford to store the whole trie.",
    "start": "4841200",
    "end": "4846300"
  },
  {
    "text": "So just going to use a\nlittle bit of indirection. You can use as\nlittle as you want, this is the log log log\nlog log log log n factor.",
    "start": "4846300",
    "end": "4854650"
  },
  {
    "start": "4854650",
    "end": "4860150"
  },
  {
    "text": "Use the suffix tree\nabove every b-th suffix.",
    "start": "4860150",
    "end": "4875250"
  },
  {
    "text": "So throw away all but a\n1/b fraction of the leaves. And then, take the\ntree that remains.",
    "start": "4875250",
    "end": "4882600"
  },
  {
    "text": "So once you do a search, you\nwon't find exactly the leaf you want, but you'll\nbe within an additive b of the leaf you want. b here\ncan be arbitrarily small.",
    "start": "4882600",
    "end": "4889860"
  },
  {
    "text": "This can be log\nlog log log log n. But something super constant. Then if I use this structure,\ninstead of being n--",
    "start": "4889860",
    "end": "4897180"
  },
  {
    "text": "order n over b space-- instead of being\norder n space, it's going to be order n over b bits.",
    "start": "4897180",
    "end": "4903000"
  },
  {
    "text": "So, we win. The only issue is\nnow, how do you find the correct leaf, as\nopposed to the incorrect leaf?",
    "start": "4903000",
    "end": "4909890"
  },
  {
    "text": " I don't really have\ntime to talk about it.",
    "start": "4909890",
    "end": "4914910"
  },
  {
    "text": "You can look at the notes. Rough idea is,\nwell, you can have a look-up table that lets you\ndo whatever you want on b bits.",
    "start": "4914910",
    "end": "4921810"
  },
  {
    "text": "As long as b is less\nthan, like, 1/2 log n. Then you can encompass the\nwhole trie, more or less.",
    "start": "4921810",
    "end": "4929730"
  },
  {
    "text": "And just hit it with\na big look-up table and do everything\nin constant time. It's not quite so\nsimple, because--",
    "start": "4929730",
    "end": "4940320"
  },
  {
    "text": "easy summary, here. ",
    "start": "4940320",
    "end": "4952900"
  },
  {
    "text": "Essentially, what\nyou're doing is--",
    "start": "4952900",
    "end": "4958840"
  },
  {
    "text": "these are the blocks. So this is length b. You're finding this suffix,\nand you want to know,",
    "start": "4958840",
    "end": "4965560"
  },
  {
    "text": "which of these is\nthe correct one. In some sense, you have to\ndo the search simultaneously for all b of these guys.",
    "start": "4965560",
    "end": "4971620"
  },
  {
    "text": "And so you run down\nthe search again, but instead of searching\nfor one pattern, you search for all b of these\npatterns at the same time.",
    "start": "4971620",
    "end": "4977980"
  },
  {
    "text": "Now they're mostly the\nsame, and so you can prove it doesn't hurt you much. Maybe it hurts\nyou an additive b.",
    "start": "4977980",
    "end": "4984389"
  },
  {
    "text": "I believe the correct answer\nis, in time, you end up paying quarter p plus b time.",
    "start": "4984390",
    "end": "4993430"
  },
  {
    "text": "Sorry, times the cost of\na suffix array access. OK, so we're still paying\nthe log to the epsilon,",
    "start": "4993430",
    "end": "4999490"
  },
  {
    "text": "because of the suffix array. If that was constant,\nit would be free. P plus b time is fine, if\nb is log log log log n.",
    "start": "4999490",
    "end": "5009082"
  },
  {
    "text": "Or you can make it log log n. Then you save a log log\nn factor in the bits. You pay an additive log log n.",
    "start": "5009082",
    "end": "5014760"
  },
  {
    "text": "That's going to be absorbed by\nthe log to the epsilon anyway. So it's pretty efficient. I guess you can make\nthis log to the epsilon,",
    "start": "5014760",
    "end": "5020625"
  },
  {
    "text": "if you felt like it,\nto balance out here. Still would be P times\nlog to the epsilon.",
    "start": "5020625",
    "end": "5025739"
  },
  {
    "text": "And so this stuff is\nreally quite cheap, see the notes for details. That ends our succinct coverage.",
    "start": "5025740",
    "end": "5034150"
  },
  {
    "text": "Sorry, it was a little more\nsuccinct than intended. Get the idea.",
    "start": "5034150",
    "end": "5039320"
  },
  {
    "start": "5039320",
    "end": "5039820"
  }
]