[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: All right. Today we start a new section\nin advanced data structures,",
    "start": "18450",
    "end": "25530"
  },
  {
    "text": "and it's data structures\nfor memory hierarchy. So the idea here is while\nalmost all data structures think",
    "start": "25530",
    "end": "32820"
  },
  {
    "text": "about memory as a flat thing. And in the RAM model,\nyou've got a giant array.",
    "start": "32820",
    "end": "39180"
  },
  {
    "text": "You can access the i-th\nelement in your giant array in constant time. The memory hierarchy,\nyou admit the reality",
    "start": "39180",
    "end": "47430"
  },
  {
    "text": "of almost all computers\nsince, I don't know, '80s,",
    "start": "47430",
    "end": "53080"
  },
  {
    "text": "which have caches. The idea is you have\nyour CPU connected",
    "start": "53080",
    "end": "61410"
  },
  {
    "text": "with a very high bandwidth\nchannel to a relatively small cache, which is\nconnected via a relatively",
    "start": "61410",
    "end": "68729"
  },
  {
    "text": "narrow bandwidth channel\nto a really big memory.",
    "start": "68730",
    "end": "74610"
  },
  {
    "text": "And in real computers,\nthis keeps going. You've got level 1 cache,\nthen level 2 cache, then level 3 cache maybe, then\nmain memory, then disk, then",
    "start": "74610",
    "end": "82740"
  },
  {
    "text": "network, whatever. Usually the disk has a cache. So you have this\nvery deep hierarchy,",
    "start": "82740",
    "end": "88420"
  },
  {
    "text": "which is typically growing\nexponentially in size, and also growing exponentially\nin slowness, in latency.",
    "start": "88420",
    "end": "96850"
  },
  {
    "text": "So you'd like to\ndesign data structures that most of the time are\nworking at the cache level,",
    "start": "96850",
    "end": "105180"
  },
  {
    "text": "because that's really fast. And as little as\npossible, you'd like to go to the deeper levels.",
    "start": "105180",
    "end": "111250"
  },
  {
    "text": "So we're going to define\ntwo models for working with memory hierarchies.",
    "start": "111250",
    "end": "116924"
  },
  {
    "text": "The first model is called\nthe external memory model. ",
    "start": "116925",
    "end": "124619"
  },
  {
    "text": "It's also called the I/O model. It's also called the\nDisk Access Model,",
    "start": "124620",
    "end": "133110"
  },
  {
    "text": "I think just so that it could\nbe called the DAM model. I usually call it the\nexternal memory model.",
    "start": "133110",
    "end": "140129"
  },
  {
    "text": "And this is sort of\nthe simplest model. It's also the most well\nstudied, I would say.",
    "start": "140130",
    "end": "146153"
  },
  {
    "text": "And it's going to relate\nclosely to the other models that we're going to look at. And the idea with the\nexternal memory model",
    "start": "146154",
    "end": "151405"
  },
  {
    "text": "is, yeah, OK, a\nreal computer has many levels in this hierarchy.",
    "start": "151405",
    "end": "157320"
  },
  {
    "text": "But let's just focus on the last\none and the next to last one, because typically that last\none is going to be way,",
    "start": "157320",
    "end": "164230"
  },
  {
    "text": "way slower than all the others. And so you really want\nto minimize how many memory transfers happen here.",
    "start": "164230",
    "end": "170560"
  },
  {
    "text": "So I want to count the number\nof memory transfers between two",
    "start": "170560",
    "end": "178410"
  },
  {
    "text": "levels. And so this model just\nthinks about two levels. I'll call them cache and disk.",
    "start": "178410",
    "end": "185730"
  },
  {
    "text": "We think of disk as\ninfinite and slow. We think of cache as not only\nfast, but infinitely fast.",
    "start": "185730",
    "end": "193500"
  },
  {
    "text": "It takes zero time to\naccess something in cache. All we're thinking\nabout is how many",
    "start": "193500",
    "end": "199200"
  },
  {
    "text": "transfers between the left\nand right have to happen. So computation here is free.",
    "start": "199200",
    "end": "204870"
  },
  {
    "text": "Access over here is free. And we just pay for this. That's the external\nmemory model. You can also think about running\ntime, make sure running time",
    "start": "204870",
    "end": "212361"
  },
  {
    "text": "is still optimal and that will\nguarantee this part's good. But usually the hard part\nis to minimize this part,",
    "start": "212361",
    "end": "218250"
  },
  {
    "text": "minimize number of\nmemory transfers. Now, to make this problem\nreally interesting,",
    "start": "218250",
    "end": "224380"
  },
  {
    "text": "we need to add one\nmore assumption. And this is also the\ncase in practice,",
    "start": "224380",
    "end": "230190"
  },
  {
    "text": "that when you request-- when you transfer an\nitem from disk to cache,",
    "start": "230190",
    "end": "236760"
  },
  {
    "text": "you get not just that\nitem, but entire block of items at the same speed.",
    "start": "236760",
    "end": "241830"
  },
  {
    "text": "So in fact, disk\nwe're going to think of as divided into blocks.",
    "start": "241830",
    "end": "247830"
  },
  {
    "text": "Block size here is B, capital B.",
    "start": "247830",
    "end": "255810"
  },
  {
    "text": "Also over here, caches are\ndivided into blocks of size B. And we have a limited\nnumber of them.",
    "start": "255810",
    "end": "264930"
  },
  {
    "text": "We're going to suppose we\nhave M over B cache lines",
    "start": "264930",
    "end": "270900"
  },
  {
    "text": "they're usually called\nat the cache level. And so the total\nsize of the cache is M. M stands for memory.",
    "start": "270900",
    "end": "277900"
  },
  {
    "text": "Sorry. This notation is\nslightly confusing for historical reasons,\nbut that's the way it is.",
    "start": "277900",
    "end": "284130"
  },
  {
    "text": "So B is block size. M is cache size,\ntotal cache size. There's M over B\nblocks of size B. Disk",
    "start": "284130",
    "end": "290670"
  },
  {
    "text": "has infinitely many\nblocks of size B. There's lots of\nmotivations for this. But basically, the main cost\nyou're paying here is latency.",
    "start": "290670",
    "end": "299850"
  },
  {
    "text": "You have to send\na request and then the answer has to come back. Think of that as the disk\nis far away from the CPU.",
    "start": "299850",
    "end": "307170"
  },
  {
    "text": "And so it takes a long time\nfor the request to get there and for the data to get back. So if you're sending\ndata back, you",
    "start": "307170",
    "end": "312300"
  },
  {
    "text": "might as well send-- it's just\nas fast to send a lot of data as a little bit of data. In fact, typically you\nset this block size",
    "start": "312300",
    "end": "318680"
  },
  {
    "text": "that the amount of time it\ntakes for data to arrive equals the latency to\nbalance those two costs.",
    "start": "318680",
    "end": "326270"
  },
  {
    "text": "With disk it's\nespecially the case, because you have this latency\nof moving the disk head. Once you move the disk\nhead, you might as well",
    "start": "326270",
    "end": "331935"
  },
  {
    "text": "read the entire track,\nthe entire circle of that if you're dealing\nwith hard drives. ",
    "start": "331936",
    "end": "338300"
  },
  {
    "text": "It's just as fast once\nthe head gets there. OK. So that's the model.",
    "start": "338300",
    "end": "344000"
  },
  {
    "text": "And so now we want to minimize\nthe number of block memory transfers this happens. And the blocks make things\na lot more interesting,",
    "start": "344000",
    "end": "350840"
  },
  {
    "text": "because that means\nwhen you read an item, you really want to use all\nthe items right around it soon, before it gets\nkicked out of cache.",
    "start": "350840",
    "end": "357391"
  },
  {
    "text": "Obviously, cache\nis limited size, so when you bring\nsomething, you've got to kick something out. That's the block\nreplacement strategy.",
    "start": "357391",
    "end": "363770"
  },
  {
    "text": "In the external memory model,\nyou can do whatever you want. You have full control\nover this cache.",
    "start": "363770",
    "end": "370970"
  },
  {
    "text": "So let's see. Let me write some\nobvious bounds.",
    "start": "370970",
    "end": "376880"
  },
  {
    "text": "And then I'll tell you some of\nthe main results in this model.",
    "start": "376880",
    "end": "382900"
  },
  {
    "text": "So number of memory transfers\nis what we care about. ",
    "start": "382900",
    "end": "390180"
  },
  {
    "text": "And it's going to be at most\nthe running time on a RAM,",
    "start": "390180",
    "end": "397070"
  },
  {
    "text": "so this is a comparison\nbetween two models. At most, every operation you\ndo on a RAM data structure",
    "start": "397070",
    "end": "404810"
  },
  {
    "text": "incurs one memory transfer. That would be the worst case. So that's what we want to beat.",
    "start": "404810",
    "end": "409820"
  },
  {
    "text": "There's also a lower bound. So this is also at least the\nnumber of cell probes divided",
    "start": "409820",
    "end": "423110"
  },
  {
    "text": "by B. I think we've talked\nbriefly about the cell probe model, I think in\nretroactive data structures.",
    "start": "423110",
    "end": "429360"
  },
  {
    "text": "Cell probe model is this\nmodel where all you count is-- you just count how\nmany words did I",
    "start": "429360",
    "end": "434930"
  },
  {
    "text": "have to read in order to do\nthis data structure operation? So computation is free.",
    "start": "434930",
    "end": "440389"
  },
  {
    "text": "We just count number of\nword reads from memory. So it's a lower bound\non RAM data structures.",
    "start": "440390",
    "end": "448139"
  },
  {
    "text": "And in this model, we're only\ncounting memory accesses, but where cell probes\nyou count word numbers,",
    "start": "448140",
    "end": "455480"
  },
  {
    "text": "here we're counting blocks. And so at best, we can\nimprove by a factor of B.",
    "start": "455480",
    "end": "461180"
  },
  {
    "text": "So this is a lower bound. This is an upper bound,\nso there's roughly a slop of a factor of B here.",
    "start": "461180",
    "end": "466730"
  },
  {
    "text": "We want to do closer to\nthis bound than this bound. This is the obvious thing. Want to get down to\nhere whenever we can.",
    "start": "466730",
    "end": "474120"
  },
  {
    "text": "So let me give you\nsome examples of that,",
    "start": "474120",
    "end": "479979"
  },
  {
    "text": "so sort of a bunch of basic\nresults in this model. ",
    "start": "479980",
    "end": "492070"
  },
  {
    "text": "Result 0 is scanning, so\nif I have an array of items",
    "start": "492070",
    "end": "502670"
  },
  {
    "text": "and I just want to,\nsay, add them all up or do a linear scan to search\nfor something, anything that",
    "start": "502670",
    "end": "510740"
  },
  {
    "text": "involves accessing\nthem in order, this will cost I guess\nceiling of N over B.",
    "start": "510740",
    "end": "522179"
  },
  {
    "text": "If the array has size N,\nnumber of blocks in that array is ceiling of N over B. And so\nthat's how many block accesses",
    "start": "522179",
    "end": "533310"
  },
  {
    "text": "it costs. So the annoying part\nhere is the ceiling.",
    "start": "533310",
    "end": "539110"
  },
  {
    "text": "If N is smaller than B,\nthen this is not great. I mean, you have to pay one\nmemory read, so it's optimal.",
    "start": "539110",
    "end": "546110"
  },
  {
    "text": "But anyway, that's scanning. Pretty boring. Slightly more interesting,\nalthough not that much more",
    "start": "546110",
    "end": "552110"
  },
  {
    "text": "interesting, is search trees. ",
    "start": "552110",
    "end": "559160"
  },
  {
    "text": "If you want to be able\nto search for an item in this external memory model-- in this external memory\nmodel, what do you do?",
    "start": "559160",
    "end": "565970"
  },
  {
    "start": "565970",
    "end": "575420"
  },
  {
    "text": "B-trees, conveniently\nnamed B-trees.",
    "start": "575420",
    "end": "581240"
  },
  {
    "text": "We want the branching\nfactor of a B-tree",
    "start": "581240",
    "end": "587060"
  },
  {
    "text": "to be B. Anything\nthat's theta B will do, but exactly B is great.",
    "start": "587060",
    "end": "592529"
  },
  {
    "text": "If you can read all\nof these pointers and read all of these key\nvalues, if that fits in B,",
    "start": "592530",
    "end": "598400"
  },
  {
    "text": "then we're happy.  So yeah, typically we assume\nthe branching factor here",
    "start": "598400",
    "end": "606990"
  },
  {
    "text": "is like B plus 1.  So in particular,\nif B is 1, you still",
    "start": "606990",
    "end": "613970"
  },
  {
    "text": "have a branching\nfactor of 2, just to make it a reasonable tree. And so now in a\nconstant number of block",
    "start": "613970",
    "end": "620750"
  },
  {
    "text": "reads you can read all the\ndata you need to decide which child pointer you follow.",
    "start": "620750",
    "end": "625850"
  },
  {
    "text": "You follow that child\npointer, and so it takes log base B plus\n1 of N to do a search.",
    "start": "625850",
    "end": "636620"
  },
  {
    "text": " This is counting\nmemory transfers.",
    "start": "636620",
    "end": "643699"
  },
  {
    "text": "So this is not as\nbig an improvement. Here, we've improved by\na factor of B roughly. Here we're improving by a\nfactor of basically log B.",
    "start": "643700",
    "end": "652640"
  },
  {
    "text": "So not as good as you might\nhope to do, dividing by B, but it turns out\nthis is optimal.",
    "start": "652640",
    "end": "658370"
  },
  {
    "text": "You need log base\nB plus 1 of N to do",
    "start": "658370",
    "end": "664730"
  },
  {
    "text": "a search in comparison model.",
    "start": "664730",
    "end": "672269"
  },
  {
    "start": "672270",
    "end": "682370"
  },
  {
    "text": "In the same way, you\nneed log base 2 of N time to do a search in\nthe comparison model, in this model you\nneed log base B of N.",
    "start": "682370",
    "end": "689019"
  },
  {
    "text": "Let me talk a little bit\nabout the proof of that. ",
    "start": "689019",
    "end": "694470"
  },
  {
    "text": "It's a pretty simple\ninformation theoretic argument. So we prove this lower bound.",
    "start": "694470",
    "end": "706300"
  },
  {
    "text": "The idea is the following. You want to figure\nout among N items here where your item fits.",
    "start": "706300",
    "end": "715779"
  },
  {
    "text": "Let's say it fits right here. So you want to know it's between\nthis element and this element.",
    "start": "715780",
    "end": "722380"
  },
  {
    "text": "How many bits of\ninformation is that? Well, there's I guess N plus\n1 different outcomes of where",
    "start": "722380",
    "end": "728380"
  },
  {
    "text": "your item could fit. If you allow it to exactly\nmatch, it's maybe twice that. But there's theta N\noptions for your answer.",
    "start": "728380",
    "end": "740770"
  },
  {
    "text": "And so if you take logs, that\nis log N bits of information.",
    "start": "740770",
    "end": "748806"
  },
  {
    "text": " And this is how\nyou normally show that you need log N comparison.",
    "start": "748806",
    "end": "755337"
  },
  {
    "text": "You need log N comparisons\nbecause each comparison could at most give you one\nbit of information, yes or no.",
    "start": "755337",
    "end": "761230"
  },
  {
    "text": "And there's log N bits to\nget, so that's the lower bound in binary search. But now we're in this\nmodel where we're not",
    "start": "761230",
    "end": "767260"
  },
  {
    "text": "counting comparisons,\neven though we're in the comparison model. We're counting number\nof block transfers.",
    "start": "767260",
    "end": "772570"
  },
  {
    "text": "So when I read in some data,\nI get B items from my array,",
    "start": "772570",
    "end": "779560"
  },
  {
    "text": "or from something. So when I do a block read, all\nI can do in the comparison model",
    "start": "779560",
    "end": "790440"
  },
  {
    "text": "is compare my item to\neverything that I read, so you might as well\ncompare all of them.",
    "start": "790440",
    "end": "796810"
  },
  {
    "text": "But the information you learn\nis only log B plus 1 bits,",
    "start": "796810",
    "end": "809080"
  },
  {
    "text": "because what you learn is among\nthese B items, where do I fit? ",
    "start": "809080",
    "end": "816920"
  },
  {
    "text": "And in the best case,\nthat is log of B plus 1 bits of information.",
    "start": "816920",
    "end": "822529"
  },
  {
    "text": "It could be worse, if these\nguys are not well distributed among your N items.",
    "start": "822530",
    "end": "827779"
  },
  {
    "text": "It's at most that. And so you take the ratio\nand you need log N over log B",
    "start": "827780",
    "end": "836750"
  },
  {
    "text": "plus 1 block reads. ",
    "start": "836750",
    "end": "844730"
  },
  {
    "text": "And that's log\nbase B plus 1 of N. AUDIENCE: [INAUDIBLE] ERIK DEMAINE: Yeah. Question?",
    "start": "844730",
    "end": "850263"
  },
  {
    "text": "AUDIENCE: Why is that you\nlearn log B plus 1 bits when you [INAUDIBLE]? ERIK DEMAINE: All right.",
    "start": "850263",
    "end": "855410"
  },
  {
    "text": "So the claim is, in\nthe comparison model, you compare your item\nto everyone in here.",
    "start": "855410",
    "end": "861500"
  },
  {
    "text": "But if your array is presorted,\nthen all you're learning is--",
    "start": "861500",
    "end": "866840"
  },
  {
    "text": "I mean, information\ntheoretically, all your learning is where your\nitem fits among these B items.",
    "start": "866840",
    "end": "873420"
  },
  {
    "text": "So there's order B options of\nwhere you fit, and so only log",
    "start": "873420",
    "end": "879680"
  },
  {
    "text": "B bits of information there. You might consider\nthis a vague argument.",
    "start": "879680",
    "end": "887750"
  },
  {
    "text": "You can do a more\nformal version of it. But I like the information\ntheoretic perspective.",
    "start": "887750",
    "end": "895380"
  },
  {
    "text": "Cool. So that's the best thing you\ncan do for search in this model.",
    "start": "895380",
    "end": "901170"
  },
  {
    "text": "Now, you might also wonder\nabout insertions and deletions. B-trees support insertions\nand deletions in log base B plus 1 of N time,\nbut that is not optimal.",
    "start": "901170",
    "end": "909730"
  },
  {
    "text": "We can do better. So for example, if\nyou want to sort,",
    "start": "909730",
    "end": "922976"
  },
  {
    "text": "the right answer for\nsorting is this crazy bound. ",
    "start": "922976",
    "end": "933899"
  },
  {
    "text": "N over B, which is\nreally good, that's linear time in this model, times\nlog base M over B of N over B.",
    "start": "933900",
    "end": "940920"
  },
  {
    "text": "This is a slight-- this is\nroughly log base M of N. The over B's don't make\ntoo big a difference.",
    "start": "940920",
    "end": "948730"
  },
  {
    "text": "So this is an improvement. Normally sorting takes\nN log N with a base 2.",
    "start": "948730",
    "end": "953870"
  },
  {
    "text": "We're improving the base of the\nlog to M over B instead of 2. And we're improving the overall\nrunning time by a factor of B.",
    "start": "953870",
    "end": "961769"
  },
  {
    "text": "So this is actually a\nreally big improvement. We're going faster than the\nRAM time divided by a B,",
    "start": "961770",
    "end": "970050"
  },
  {
    "text": "because to sort in\nthe cell probe model just takes linear time. You read all the data. You sort it. You put it back.",
    "start": "970050",
    "end": "976980"
  },
  {
    "text": "So we can't quite get N over\nB, but we get this log factor.",
    "start": "976980",
    "end": "982050"
  },
  {
    "text": "So this is really good. And it's something that would\nnot result from using B-trees.",
    "start": "982050",
    "end": "987210"
  },
  {
    "text": "This is a little funny,\nbecause in regular RAM model, if you insert everything into\na balanced binary search tree,",
    "start": "987210",
    "end": "995059"
  },
  {
    "text": "then do an in order\ntraversal, that's an optimal sorting algorithm. It gives you N log N.",
    "start": "995059",
    "end": "1000320"
  },
  {
    "text": "Here, it's not optimal. You throw everything\ninto a B-tree, you get N times log\nbase B of N. So there's",
    "start": "1000320",
    "end": "1006971"
  },
  {
    "text": "two things that are bad. One is that the base of\nthe log is slightly off. It's B versus M over B.\nThat's not so big a deal.",
    "start": "1006971",
    "end": "1014810"
  },
  {
    "text": "The big thing is it's\nN over B versus N. We don't want to pay N. We want\nto pay N over B. There's also",
    "start": "1014810",
    "end": "1024959"
  },
  {
    "text": "a matching lower bound in the\ncomparison model, which we will not cover here. ",
    "start": "1024959",
    "end": "1031709"
  },
  {
    "text": "By next lecture, we'll know\nhow to do sorting optimally.",
    "start": "1031710",
    "end": "1037279"
  },
  {
    "text": "First, I want to tell\nyou about a bunch of different ways or different\nproblems and results.",
    "start": "1037280",
    "end": "1044975"
  },
  {
    "text": " So a funny problem,\nwhich actually does",
    "start": "1044975",
    "end": "1053930"
  },
  {
    "text": "arise in practice, but\nit's interesting just to think about,\ninstead of sorting--",
    "start": "1053930",
    "end": "1060350"
  },
  {
    "text": "sorting is I give you an array. I don't know what order it's in. You have to find the\nright order and then put it into the right order.",
    "start": "1060350",
    "end": "1066380"
  },
  {
    "text": "There's an easier problem,\nwhich is called permuting. I give you an array. I give you a permutation\nthat I'd like to do.",
    "start": "1066380",
    "end": "1072889"
  },
  {
    "text": "I just want you to\nmove the items around. So you don't need to do any\ncomparisons to get here.",
    "start": "1072890",
    "end": "1079872"
  },
  {
    "text": "I tell you what the order is. You just have to\nphysically move the items. This is harder than it\nsounds, because when you read,",
    "start": "1079872",
    "end": "1086690"
  },
  {
    "text": "you read blocks of items\nin the original order. And so it's hard to just do\nan arbitrary permutation.",
    "start": "1086690",
    "end": "1092720"
  },
  {
    "text": "And there's two\nobvious algorithms. One is you could\nsort your items. So you could go to\nevery item in order",
    "start": "1092720",
    "end": "1099440"
  },
  {
    "text": "and just write down its desired\nnumber in the new permutation,",
    "start": "1099440",
    "end": "1105139"
  },
  {
    "text": "write down the permutation. Then run a sorting algorithm. That will take N over B log\nbase M over B of N over B.",
    "start": "1105140",
    "end": "1111890"
  },
  {
    "text": "Or the other obvious algorithm\nis to take the first item, put it where it belongs in the\narray, take the second item,",
    "start": "1111890",
    "end": "1118910"
  },
  {
    "text": "put it where it\nbelongs in the array, in a new copy of the array. And that will take at\nmost N memory transfers,",
    "start": "1118910",
    "end": "1126020"
  },
  {
    "text": "each one a completely\nseparate memory transfer. And the claim is\nthe optimal thing to do is the min of those two.",
    "start": "1126020",
    "end": "1132149"
  },
  {
    "text": "So you just check\nhow does N and B and M compare, do the better\nof the two algorithms.",
    "start": "1132150",
    "end": "1140460"
  },
  {
    "text": "Again, there's a lower bound. In a model called the\nindivisible model, which is assuming that\neach word of your data",
    "start": "1140460",
    "end": "1150710"
  },
  {
    "text": "doesn't get cut into subwords. So this is assuming-- the lower bound assuming\nyour words do not get cut up.",
    "start": "1150710",
    "end": "1160370"
  },
  {
    "text": " I believe it's still unsolved\nwhether you could do better",
    "start": "1160370",
    "end": "1166930"
  },
  {
    "text": "otherwise. The last result in this\nmodel I wanted to talk about",
    "start": "1166930",
    "end": "1172790"
  },
  {
    "text": "is called buffer trees. Buffer trees are pretty cool. ",
    "start": "1172790",
    "end": "1179619"
  },
  {
    "text": "They're essentially\na dynamic version of sorting, which\nis what we lack--",
    "start": "1179619",
    "end": "1184640"
  },
  {
    "text": "what B-trees do not give you. ",
    "start": "1184640",
    "end": "1210299"
  },
  {
    "text": "So they achieve\nthe sorting bound divided by N per operation,\nso this is optimal.",
    "start": "1210300",
    "end": "1216759"
  },
  {
    "text": "I haven't told you what\nthe operations are. The amount is amortized. It has to be amortized,\nbecause this bound is typically",
    "start": "1216759",
    "end": "1222720"
  },
  {
    "text": "little o of 1. Think of this as 1 over\nB. There's a log factor. But assuming that log factor is\nsmaller than B, which is often",
    "start": "1222720",
    "end": "1230550"
  },
  {
    "text": "the case, this is\nin order 1 over B. It's a little o of 1 cost,\nwhich is a little fun.",
    "start": "1230550",
    "end": "1235559"
  },
  {
    "text": "But of course, every\nreal cost is an integer. It's an integer number\nof block transfers. But amortized, you can\nget a little o of 1 bound.",
    "start": "1235560",
    "end": "1245510"
  },
  {
    "text": "And what it lets you do is\ndelayed queries and batch",
    "start": "1245510",
    "end": "1251185"
  },
  {
    "text": "updates. ",
    "start": "1251185",
    "end": "1264170"
  },
  {
    "text": "So I can do an insert\nand I can a delete. I can do many of them. And then I can do a query\nagainst the current data",
    "start": "1264170",
    "end": "1269870"
  },
  {
    "text": "structure. I want to know, I don't know,\nthe successor of an item. But I don't get the\nanswer right then.",
    "start": "1269870",
    "end": "1275690"
  },
  {
    "text": "It's delayed. The query will sit there. Eventually the\ndata structure will decide to give me an answer.",
    "start": "1275690",
    "end": "1282590"
  },
  {
    "text": "Or it may just never\ngive me an answer. But then there's a new operation\nat the end, which is flush,",
    "start": "1282590",
    "end": "1287612"
  },
  {
    "text": "which is give me all the\nanswers to all the questions that I asked. And the flush takes\nthis much time.",
    "start": "1287612",
    "end": "1293820"
  },
  {
    "text": "So if you do N operations\nand then say flush, then it doesn't\ntake any extra time.",
    "start": "1293820",
    "end": "1299240"
  },
  {
    "text": "It's going to cost\none sort of pass through the entire data\nstructure, one sorting step. ",
    "start": "1299240",
    "end": "1305880"
  },
  {
    "text": "Yeah. The one thing you can get for\nfree is a zero-cost find min.",
    "start": "1305880",
    "end": "1313670"
  },
  {
    "text": " All right.",
    "start": "1313670",
    "end": "1319020"
  },
  {
    "text": "So buffer tree, you can do\nfind min instantaneously. It maintains the\nmin all the time. So this lets you do\na priority queue.",
    "start": "1319020",
    "end": "1325470"
  },
  {
    "text": "You can do insert and delete\nmin in this much time online. ",
    "start": "1325470",
    "end": "1333886"
  },
  {
    "text": "But if you want to do\nother kinds of queries, then they're slow to answer.",
    "start": "1333886",
    "end": "1339000"
  },
  {
    "text": "You get the answer much later. So this is a dynamic\nversion of sorting. It lets you do\nsorting in particular.",
    "start": "1339000",
    "end": "1344254"
  },
  {
    "text": "It let's you do priority\nqueues, other great things. We will see not\nquite a buffer tree but another data structure\nachieving similar bounds",
    "start": "1344254",
    "end": "1351960"
  },
  {
    "text": "in the next lecture. Today's lecture\nis actually going to be about B-trees, which\nseems kind of boring,",
    "start": "1351960",
    "end": "1358980"
  },
  {
    "text": "because we already\nknow how to do B-trees. But we're going to do them\nin another model, which is the cache-oblivious model.",
    "start": "1358980",
    "end": "1367020"
  },
  {
    "text": "So let me tell you\nabout that model. ",
    "start": "1367020",
    "end": "1386376"
  },
  {
    "text": "All right. So the cache-oblivious\nmodel is much newer. It's from 1999.",
    "start": "1386376",
    "end": "1394050"
  },
  {
    "text": "And it's from MIT\noriginally, Charles Leiserson and his students\ninvented it back then,",
    "start": "1394050",
    "end": "1401820"
  },
  {
    "text": "in the context of\n6406, I believe. And it's almost the same as\nthis external memory model.",
    "start": "1401820",
    "end": "1409650"
  },
  {
    "text": "There's one change, which is\nthat the algorithm doesn't know what B or M is.",
    "start": "1409650",
    "end": "1415020"
  },
  {
    "start": "1415020",
    "end": "1424600"
  },
  {
    "text": "Now, this is both awkward\nand cool at the same time. So the assumption is that\nthe computer looks like this.",
    "start": "1424600",
    "end": "1434230"
  },
  {
    "text": "The algorithm has no-- and the algorithm\nknows that fact, but it doesn't know what the\nparameters of the cache are.",
    "start": "1434230",
    "end": "1441340"
  },
  {
    "text": "Doesn't know how the\nmemory is blocked. Now, as a consequence, it cannot\nmanually say, read this block,",
    "start": "1441340",
    "end": "1447250"
  },
  {
    "text": "write this block. It can't decide which\nblock to kick out. This is going to be more\nlike a typical algorithm.",
    "start": "1447250",
    "end": "1454270"
  },
  {
    "text": "I mean, the algorithm will look\nlike a regular RAM algorithm. It's going to say\nread this word,",
    "start": "1454270",
    "end": "1459780"
  },
  {
    "text": "write this word to memory,\ndo an addition, whatever.",
    "start": "1459780",
    "end": "1465550"
  },
  {
    "text": "So algorithm looks\nlike a RAM algorithm.",
    "start": "1465550",
    "end": "1474580"
  },
  {
    "text": "But the analysis is\ngoing to be different. ",
    "start": "1474580",
    "end": "1481610"
  },
  {
    "text": "So this is convenient,\nbecause algorithms-- I mean, how you implement\nan algorithm becomes",
    "start": "1481610",
    "end": "1486880"
  },
  {
    "text": "much clearer in this model. And this is-- now we're going\nto assume that the cache is maintained automatically.",
    "start": "1486880",
    "end": "1492782"
  },
  {
    "start": "1492782",
    "end": "1497980"
  },
  {
    "text": "In particular, the way\nthat blocks are replaced becomes automatic.",
    "start": "1497980",
    "end": "1503380"
  },
  {
    "text": " So the assumption is when\nyou read a word from memory,",
    "start": "1503380",
    "end": "1510010"
  },
  {
    "text": "the entire block comes over. You just don't know\nhow much data that is. And when something\ngets kicked out,",
    "start": "1510010",
    "end": "1515500"
  },
  {
    "text": "the entire block gets kicked\nout and written to memory. But you don't get\nto see how that's happening, because you don't\nknow anything about B or M.",
    "start": "1515500",
    "end": "1524800"
  },
  {
    "text": "We need to assume something\nabout this replacement strategy. And in the\ncache-oblivious model,",
    "start": "1524800",
    "end": "1529990"
  },
  {
    "text": "we assume that it is optimal. ",
    "start": "1529990",
    "end": "1535240"
  },
  {
    "text": "This is an offline\nnotion, saying what block we're\ngoing to kick out is the one that will be\nused farthest in the future,",
    "start": "1535240",
    "end": "1543140"
  },
  {
    "text": "so this is very hard to\nimplement in practice, because you need a crystal ball. But good news is, you\ncould use something",
    "start": "1543140",
    "end": "1550900"
  },
  {
    "text": "like LRU, Least Recently Used,\nkick that guy out, or even a very simple algorithm,\nfirst in, first out.",
    "start": "1550900",
    "end": "1558009"
  },
  {
    "text": "The most recent--\nthe oldest block that you brought in is\nthe one that you kick out. These are actually\nvery close to optimal.",
    "start": "1558010",
    "end": "1565809"
  },
  {
    "text": " They're constant\ncompetitive against or given",
    "start": "1565810",
    "end": "1576160"
  },
  {
    "text": "a cache of twice the size.  So this is from the early\ndays of competitive analysis.",
    "start": "1576160",
    "end": "1585910"
  },
  {
    "text": "It says if I compare offline\noptimal with a cache size M versus-- or let's say offline\noptimal with a cache size",
    "start": "1585910",
    "end": "1592890"
  },
  {
    "text": "M over 2, versus\nLRU or FIFO, which are online algorithms\non a cache of size M,",
    "start": "1592890",
    "end": "1598700"
  },
  {
    "text": "then this cost will be at\nmost I think twice this cost. Now, the good news is, you\nlook at all these bounds,",
    "start": "1598700",
    "end": "1605320"
  },
  {
    "text": "you change M by a factor\nof 2, nothing changes. Assuming everything is\nat least some constant,",
    "start": "1605320",
    "end": "1611600"
  },
  {
    "text": "and M and B are not\nsuper super close, then changing M by a factor of\n2 doesn't affect these bounds.",
    "start": "1611600",
    "end": "1618649"
  },
  {
    "text": "These ones don't even have M in\nthem, so it's not a big deal. So we're going to assume\nthis basically for analysis.",
    "start": "1618650",
    "end": "1626107"
  },
  {
    "text": "It's not really that big a deal. You could also analyze\nwith these models. The point is\nthey're all the same within a constant factor for\nthe algorithms we care about.",
    "start": "1626107",
    "end": "1637040"
  },
  {
    "text": "What other fun things?  If you have a good,\ncache-oblivious algorithm,",
    "start": "1637040",
    "end": "1645320"
  },
  {
    "text": "it's good simultaneously\nfor all B and M. That's the consequence. So whereas B-trees for\nexample, need to know B,",
    "start": "1645320",
    "end": "1652970"
  },
  {
    "text": "they need to have the right\nbranching factor for your value of B, the cache-oblivious\nmodel, you have to have--",
    "start": "1652970",
    "end": "1659600"
  },
  {
    "text": "your data structure\nhas to be correct, has to be optimized for all\nvalues of B and all values of M",
    "start": "1659600",
    "end": "1666140"
  },
  {
    "text": "simultaneously. So this has some\nnice side effects. In particular, you\nessentially adapt",
    "start": "1666140",
    "end": "1673820"
  },
  {
    "text": "to different values of B and\nM. So two nice side effects",
    "start": "1673820",
    "end": "1679460"
  },
  {
    "text": "of that are that if you have a\nmulti-level memory hierarchy, each level has its\nown B and its own M.",
    "start": "1679460",
    "end": "1686450"
  },
  {
    "text": "If you use a\ncache-oblivious algorithm and all of those caches are\nmaintained automatically using one of these\nstrategies, then",
    "start": "1686450",
    "end": "1692840"
  },
  {
    "text": "you optimize the number of--\nmaybe I should draw a picture. ",
    "start": "1692840",
    "end": "1699419"
  },
  {
    "text": "Here's a multi-level\nmemory hierarchy. You optimize the number\nof memory transfers",
    "start": "1699420",
    "end": "1705509"
  },
  {
    "text": "between these two levels. You optimize the number\nof memory transfers between these two levels,\nbetween these two levels, and between these two levels.",
    "start": "1705509",
    "end": "1712460"
  },
  {
    "text": "So you optimize everything. Each of them has some-- if you just think of this as\none big level versus this level",
    "start": "1712460",
    "end": "1719875"
  },
  {
    "text": "or versus all the\nlevels to the right, then that has some B\nand some M. And you're",
    "start": "1719875",
    "end": "1727190"
  },
  {
    "text": "minimizing the number of\nmemory transfers here. Also, if B and M are changing,\nlots of situations for that.",
    "start": "1727190",
    "end": "1734930"
  },
  {
    "text": "If you have multiple programs\nrunning at the same time, then your cache size\nmight effectively go down if they're\nreally running",
    "start": "1734930",
    "end": "1740840"
  },
  {
    "text": "in parallel on the same\ncomputer, or pseudo-parallel. Block size could change.",
    "start": "1740840",
    "end": "1746950"
  },
  {
    "text": "If you think of a disk\nand your block size is the size of your track,\nthen closer to the center,",
    "start": "1746950",
    "end": "1752242"
  },
  {
    "text": "the tracks are smaller. Closer to the rim of the\ndisk then blocks are bigger. All these things basically\nin the cache-oblivious model,",
    "start": "1752242",
    "end": "1759020"
  },
  {
    "text": "you don't care, because\nit will just work. Now, there's no\nnice formalization of adapting to changing\nvalues of B and M.",
    "start": "1759020",
    "end": "1764930"
  },
  {
    "text": "That's kind of an\nopen problem to make explicit what that means. But we're going to assume in\nthe cache-oblivious models you",
    "start": "1764930",
    "end": "1771170"
  },
  {
    "text": "have one fixed B, one fixed\nM, analyze relative to that. But of course, that analysis\napplies simultaneously to all",
    "start": "1771170",
    "end": "1777080"
  },
  {
    "text": "B's and all M's. And so it feels like you adapt\noptimally, whatever that means.",
    "start": "1777080",
    "end": "1783990"
  },
  {
    "text": " In some sense, the\nmost surprising thing about the cache-oblivious\nworld is that it's possible.",
    "start": "1783990",
    "end": "1792600"
  },
  {
    "text": "You can work in this\nmodel and get basically all of these results.",
    "start": "1792600",
    "end": "1798519"
  },
  {
    "text": "So let me go over these results. ",
    "start": "1798520",
    "end": "1824184"
  },
  {
    "text": "So in the cache-oblivious model,\nof course scans are still good. Scans didn't assume anything\nabout block size here,",
    "start": "1824184",
    "end": "1832520"
  },
  {
    "text": "except in the analysis. Scanning was just\na sequential read. In general, we can do\nconstant number of scans.",
    "start": "1832520",
    "end": "1840594"
  },
  {
    "text": "Some of them can go to left. Some of them could\ngo to the right. Some of them could be reading. Some of them could be writing. That's the general form of scan.",
    "start": "1840594",
    "end": "1847070"
  },
  {
    "text": "But all of that will take\norder N over B ceiling. ",
    "start": "1847070",
    "end": "1859670"
  },
  {
    "text": "OK. Search. ",
    "start": "1859670",
    "end": "1865010"
  },
  {
    "text": "This is what we're going\nto be focused on today.  You can achieve order log\nbase B plus 1 of N search,",
    "start": "1865010",
    "end": "1879890"
  },
  {
    "text": "insert, and delete. ",
    "start": "1879890",
    "end": "1887990"
  },
  {
    "text": "Just like B-trees, but\nwithout knowing what B is. We're going to do\nmost of that today.",
    "start": "1887990",
    "end": "1894470"
  },
  {
    "text": " What's next? Sorting. Sorting, you can\ndo the same bound.",
    "start": "1894470",
    "end": "1900395"
  },
  {
    "text": " That we'll see next lecture. ",
    "start": "1900395",
    "end": "1915430"
  },
  {
    "text": "OK. Next is permuting. ",
    "start": "1915430",
    "end": "1927690"
  },
  {
    "text": "Here there's actually a\nnegative result, which is that you can't do the min.",
    "start": "1927690",
    "end": "1934080"
  },
  {
    "text": "It doesn't say exactly\nwhat you can do. In particular, we\ncan certainly permute",
    "start": "1934080",
    "end": "1939440"
  },
  {
    "text": "as quickly as we can sort. And we can permute-- we can achieve this\nmin in a weird sense,",
    "start": "1939440",
    "end": "1945260"
  },
  {
    "text": "in that we can achieve N and\nwe can achieve the sorting bound for permutation in\nthe cache-oblivious model,",
    "start": "1945260",
    "end": "1950720"
  },
  {
    "text": "either one, but\nnot both with min around them, because to\nknow which one to apply, you need to know how\nB and M relate to N,",
    "start": "1950720",
    "end": "1957660"
  },
  {
    "text": "and you don't here. And so there's a\nlower bound saying you really can't\nachieve this bound, even up to constant factors.",
    "start": "1957660",
    "end": "1964640"
  },
  {
    "text": "But it doesn't explicitly\nsay anything more than that. So a little awkward.",
    "start": "1964640",
    "end": "1969770"
  },
  {
    "text": "Fortunately, permuting\nisn't that big a deal. And most of the time\nthe sorting bound",
    "start": "1969770",
    "end": "1975200"
  },
  {
    "text": "is much faster than the\nend bound, so not so bad. But slightly awkward.",
    "start": "1975200",
    "end": "1980810"
  },
  {
    "text": "So there's some\nthings you can't do. This was the first negative\nresult in cache-oblivious. Another fun negative result\nis actually in search trees.",
    "start": "1980810",
    "end": "1988460"
  },
  {
    "text": "You might ask, what is\nthis constant factor here in front of the log\nbase B plus 1 of N?",
    "start": "1988460",
    "end": "1995570"
  },
  {
    "text": "And for B-trees, the constant\nfactor is essentially 1. ",
    "start": "1995570",
    "end": "2003760"
  },
  {
    "text": "You get 1 times log\nbase B plus 1 of N. In cache-oblivious\nworld, you can",
    "start": "2003760",
    "end": "2009910"
  },
  {
    "text": "prove that 1 is unattainable\nand the best possible constant factor is log base\n2 of e, which was like 1.44.",
    "start": "2009910",
    "end": "2020450"
  },
  {
    "text": "So that is the right\nanswer for the constant. Today we'll get a\nconstant here of 4.",
    "start": "2020450",
    "end": "2026140"
  },
  {
    "text": "This is for search.  But 4 has since been improved\nto 1.44, so a tiny separation",
    "start": "2026140",
    "end": "2033490"
  },
  {
    "text": "there between cache-oblivious\nand external memory. ",
    "start": "2033490",
    "end": "2039470"
  },
  {
    "text": "Let's see. One more thing. ",
    "start": "2039470",
    "end": "2059620"
  },
  {
    "text": "Continuing over here\nis priority queue. ",
    "start": "2059620",
    "end": "2066810"
  },
  {
    "text": "Cache-oblivious we can\ndo in the optimal time 1 over B log base M\nover B of N over B.",
    "start": "2066810",
    "end": "2088050"
  },
  {
    "text": "Only catch with\nthat result is it assumes something called\nthe tall cache assumption.",
    "start": "2088050",
    "end": "2094215"
  },
  {
    "start": "2094215",
    "end": "2105640"
  },
  {
    "text": "Let's see what I\nwant to say here. ",
    "start": "2105640",
    "end": "2112740"
  },
  {
    "text": "We'll say M is omega B\nto the 1 plus epsilon.",
    "start": "2112740",
    "end": "2119270"
  },
  {
    "text": "That's an ugly-looking omega. ",
    "start": "2119270",
    "end": "2126690"
  },
  {
    "text": "Certainly M is at least B.\nIf you have one cache line, you have M equal\nB. But we'd like",
    "start": "2126690",
    "end": "2132330"
  },
  {
    "text": "M to be a little bit bigger than\nB. We'd like the cache to be-- if M was at least B squared,\nthen the height of the cache",
    "start": "2132330",
    "end": "2139620"
  },
  {
    "text": "would be at least as big as\nthe width of the cache, hence tall cache. But we don't even need\nM equal to B squared.",
    "start": "2139620",
    "end": "2145200"
  },
  {
    "text": "Just M to the-- M equaling B to the\n1.001 would be enough.",
    "start": "2145200",
    "end": "2151510"
  },
  {
    "text": "Then you can get this result. And there's a theorem that\nshows for cache-oblivious you need to assume this\ntall cache assumption.",
    "start": "2151510",
    "end": "2158730"
  },
  {
    "text": "You cannot achieve\nthis bound without it. But this is usually true for\nreal caches, so life is good.",
    "start": "2158730",
    "end": "2168760"
  },
  {
    "text": "All right. So that's a quick summary\nof cache-oblivious results. Any questions about those?",
    "start": "2168760",
    "end": "2174260"
  },
  {
    "text": " Then we proceed into achieving\nsearch trees log base B of N",
    "start": "2174260",
    "end": "2184950"
  },
  {
    "text": "performance cache-obliviously. Make it interesting,\nbecause external memory, we already know how to\ndo it with a B-tree.",
    "start": "2184950",
    "end": "2191520"
  },
  {
    "start": "2191520",
    "end": "2200020"
  },
  {
    "text": "So we did both models,\ncache-oblivious B-tree is what remain.",
    "start": "2200020",
    "end": "2205390"
  },
  {
    "start": "2205390",
    "end": "2211890"
  },
  {
    "text": "This was the first result\nin cache-oblivious data structures. I'm going to start with\nthe static problem.",
    "start": "2211890",
    "end": "2218600"
  },
  {
    "text": " Cache-oblivious\nstatic search trees.",
    "start": "2218600",
    "end": "2230805"
  },
  {
    "text": " This was actually in a MEng\nthesis here by Harold Prokop.",
    "start": "2230805",
    "end": "2240420"
  },
  {
    "text": "So the idea is very simple. We can't use B-trees because\nwe don't know what B is,",
    "start": "2240420",
    "end": "2246060"
  },
  {
    "text": "so we'll use binary\nsearch trees. Those have served\nus well so far.",
    "start": "2246060",
    "end": "2251490"
  },
  {
    "text": "So let's use a balanced\nbinary search tree. And because it's\nstatic, might as well",
    "start": "2251490",
    "end": "2257849"
  },
  {
    "text": "assume it's a perfect\nbalanced binary search tree. Let me draw one over here. ",
    "start": "2257850",
    "end": "2278610"
  },
  {
    "text": "I'll draw my favorite one. ",
    "start": "2278610",
    "end": "2292390"
  },
  {
    "text": "So how do you search in\na binary search tree? Binary search.",
    "start": "2292390",
    "end": "2298150"
  },
  {
    "text": "Our algorithm is fixed. So the only\nflexibility we have is how we map this tree into the\nsequential order in memory.",
    "start": "2298150",
    "end": "2309069"
  },
  {
    "text": "Memory is an array. So for each of\nthese nodes, we get to assign some\norder, some position",
    "start": "2309070",
    "end": "2317320"
  },
  {
    "text": "in the array of memory. And then each of these\nchild pointers, that",
    "start": "2317320",
    "end": "2323950"
  },
  {
    "text": "changes where they point to. And now\ncache-obliviously, you're going to follow some\nroot to leaf path.",
    "start": "2323950",
    "end": "2330730"
  },
  {
    "text": "You don't know which one. All of them are visiting\nnodes in some order,",
    "start": "2330730",
    "end": "2336460"
  },
  {
    "text": "which looks pretty random. In the array of\nmemory, it's going to be some sequence like this.",
    "start": "2336460",
    "end": "2345040"
  },
  {
    "text": "We would like the\nnumber of blocks that contain those nodes to\nbe relatively small somehow.",
    "start": "2345040",
    "end": "2352160"
  },
  {
    "text": " So that's the hard part.",
    "start": "2352160",
    "end": "2357820"
  },
  {
    "text": "Now, you could try level order. You could try in order,\npre order, post order.",
    "start": "2357820",
    "end": "2362950"
  },
  {
    "text": "All of them fail. The right order is something\ncalled van Emde Boas order.",
    "start": "2362950",
    "end": "2369460"
  },
  {
    "start": "2369460",
    "end": "2384980"
  },
  {
    "text": "So let's say there are N nodes. What we're going to\ndo is carve the tree",
    "start": "2384980",
    "end": "2393910"
  },
  {
    "text": "at the middle level of edges. ",
    "start": "2393910",
    "end": "2405109"
  },
  {
    "text": "So we have a tree like this. We divide in the middle.",
    "start": "2405110",
    "end": "2410470"
  },
  {
    "text": "Leaves us with the top\npart and many bottom parts.",
    "start": "2410470",
    "end": "2415750"
  },
  {
    "text": "There's going to be about\nsquare root of N nodes in each of these little\ntriangles, roughly speaking.",
    "start": "2415750",
    "end": "2423560"
  },
  {
    "text": "The number of\ntriangles down here is going to be roughly\nsquare root of N-- I think I have written here\nsquare root of N plus 1.",
    "start": "2423560",
    "end": "2431605"
  },
  {
    "text": "It's a little overestimate,\nbecause I multiply those two numbers, it's bigger than N. But it's roughly that.",
    "start": "2431605",
    "end": "2437212"
  },
  {
    "text": "If there were root\nN nodes up here, then there would be square\nroot of N plus 1 children, and square root of N\nplus 1 things down there.",
    "start": "2437212",
    "end": "2444220"
  },
  {
    "text": "So roughly, root N different\nthings, each of size root N. Then what we do is\nrecursively lay out",
    "start": "2444220",
    "end": "2456630"
  },
  {
    "text": "all those triangles of\nsize roughly squared of N,",
    "start": "2456630",
    "end": "2465279"
  },
  {
    "text": "and then concatenate. It's a very simple idea.",
    "start": "2465280",
    "end": "2472690"
  },
  {
    "text": "Let's apply it to this tree. So I split in the middle\nlevel and I recursively",
    "start": "2472690",
    "end": "2481690"
  },
  {
    "text": "lay out this triangle up here-- draw it as a box.",
    "start": "2481690",
    "end": "2487090"
  },
  {
    "text": "Then I recursively lay out this. Then I recursively lay out\nthis and this and this.",
    "start": "2487090",
    "end": "2493630"
  },
  {
    "text": "So up here, I mean,\nto lay this out, I would again split\nin the middle level,",
    "start": "2493630",
    "end": "2499410"
  },
  {
    "text": "lay out this piece, so this\nguy will go first, then this one, then this one.",
    "start": "2499410",
    "end": "2505180"
  },
  {
    "text": "Now I'll go over and recursively\ndo this, so it's 4, 5, 6. Then this one, 7, 8, 9,\n10, 11, 12, 13, 14, 15.",
    "start": "2505180",
    "end": "2518346"
  },
  {
    "text": "That is the order in\nwhich I store the nodes. And I claim that's a good order.",
    "start": "2518346",
    "end": "2523700"
  },
  {
    "text": "For example, if B equals\n3, this looks really good, because then all of these\nnodes are in the first block.",
    "start": "2523700",
    "end": "2531750"
  },
  {
    "text": "And so I get to choose which\nof these four children trees I should look at. I mean, I happen to go\nhere and then maybe here.",
    "start": "2531750",
    "end": "2539490"
  },
  {
    "text": "I look at those two nodes,\nlook at their keys to decide, oh, I should go\ninto this branch.",
    "start": "2539490",
    "end": "2546070"
  },
  {
    "text": "But I only pay one\nmemory transfer to look at all those nodes.",
    "start": "2546070",
    "end": "2551390"
  },
  {
    "text": "So this looks like a tree\ntuned for B equals 3. But it turns out it's tuned\nfor all B's simultaneously,",
    "start": "2551390",
    "end": "2557047"
  },
  {
    "text": "if we do this recursively. It's hard to draw\na small example where you see all\nthe B's at once,",
    "start": "2557047",
    "end": "2562100"
  },
  {
    "text": "but that's the best I can do. OK. ",
    "start": "2562100",
    "end": "2578030"
  },
  {
    "text": "Let's analyze this thing. So the order of\nthe nodes is clear.",
    "start": "2578030",
    "end": "2584310"
  },
  {
    "text": "If you know what the van\nEmde Boas data structure is, then you know why\nit's called this. Otherwise, see lecture\n10 or so in the future.",
    "start": "2584310",
    "end": "2593360"
  },
  {
    "text": "Forget exactly where\nwe're covering it. So this order was not\ninvented by van Emde Boas,",
    "start": "2593360",
    "end": "2598550"
  },
  {
    "text": "but it looks very similar\nto something else that was invented by van Emde\nBoas, so we call it that.",
    "start": "2598550",
    "end": "2603650"
  },
  {
    "text": "But that's the name\nof a guy, Peter. ",
    "start": "2603650",
    "end": "2609170"
  },
  {
    "text": "Analysis. Order's clear. The algorithm is clear. We follow our root to leaf path.",
    "start": "2609170",
    "end": "2615840"
  },
  {
    "text": "What we claim is any root to\nleaf path and any value of B,",
    "start": "2615840",
    "end": "2621860"
  },
  {
    "text": "the number of blocks visited\nis order log base B of N.",
    "start": "2621860",
    "end": "2627170"
  },
  {
    "text": "So to do that, in the analysis\nwe get to know what B is.",
    "start": "2627170",
    "end": "2634190"
  },
  {
    "text": "The algorithm didn't know. Algorithm here doesn't know\nB and doesn't need to know B.",
    "start": "2634190",
    "end": "2641420"
  },
  {
    "text": "But to analyze it, to prove\nan order log base B of N, we need to know what B is.",
    "start": "2641420",
    "end": "2650240"
  },
  {
    "text": "So while the algorithm\nrecurses all the way down,",
    "start": "2650240",
    "end": "2655640"
  },
  {
    "text": "keeps dividing these blocks\ninto smaller and smaller pieces, we're going to look\nat a particular level",
    "start": "2655640",
    "end": "2661320"
  },
  {
    "text": "of that recursion. I'm going to call that\na level of detail. ",
    "start": "2661320",
    "end": "2672160"
  },
  {
    "text": "Say I call it straddling B.",
    "start": "2672160",
    "end": "2679240"
  },
  {
    "text": "So my picture is going\nto be the following. ",
    "start": "2679240",
    "end": "2687220"
  },
  {
    "text": "These little triangles are\ngoing to be size less than B.",
    "start": "2687220",
    "end": "2693099"
  },
  {
    "text": "But these big triangles are\nsize greater than or equal to B.",
    "start": "2693100",
    "end": "2698490"
  },
  {
    "text": "OK. At some level of recursion\nthat happens, by monotonicity,",
    "start": "2698490",
    "end": "2711780"
  },
  {
    "text": "I guess. ",
    "start": "2711780",
    "end": "2722720"
  },
  {
    "text": "I could keep going. I mean, this tree is going\nto have substantial height. I don't really know\nhow tall it is,",
    "start": "2722720",
    "end": "2728120"
  },
  {
    "text": "or that's sort of\nthe central question. Draw in some pointers here. ",
    "start": "2728120",
    "end": "2735110"
  },
  {
    "text": "But just look at-- if you subdivide all\nthe big triangles until you get to these\nsmall triangles that",
    "start": "2735110",
    "end": "2741110"
  },
  {
    "text": "are size less than B,\nthen you stop recursing. Now, the algorithm, of course,\nwill recursively lay that out.",
    "start": "2741110",
    "end": "2746810"
  },
  {
    "text": "But what we know, we\nrecursively lay things out and then we concatenate, meaning\nthe recursive layouts remain",
    "start": "2746810",
    "end": "2752540"
  },
  {
    "text": "consecutive. We never like\ninterleave two layouts. So however this thing is laid\nout, we don't really care,",
    "start": "2752540",
    "end": "2759410"
  },
  {
    "text": "because at that point it's\ngoing to be stored in memory, which is this giant array.",
    "start": "2759410",
    "end": "2765059"
  },
  {
    "text": "It's going to be stored\nin interval of size less than B. So at worst,\nwhere are the block boundaries?",
    "start": "2765059",
    "end": "2773190"
  },
  {
    "text": "Maybe draw that in red. Block boundaries are size B. We\ndon't know exactly how they're",
    "start": "2773190",
    "end": "2780440"
  },
  {
    "text": "interspersed. Let's say these are\nthe block boundaries. So it could be that this little\nsubarray falls into two blocks,",
    "start": "2780440",
    "end": "2788990"
  },
  {
    "text": "but at most two blocks. So the little triangles\nof size less than B",
    "start": "2788990",
    "end": "2798710"
  },
  {
    "text": "live in at most\ntwo memory blocks. ",
    "start": "2798710",
    "end": "2809960"
  },
  {
    "text": "So to visit each of\nthese little triangles, we only spend two\nmemory reads at most.",
    "start": "2809960",
    "end": "2815260"
  },
  {
    "start": "2815260",
    "end": "2820660"
  },
  {
    "text": "So all that's left is to\ncount how many of those little triangles do we need to\nvisit on a root to leaf path?",
    "start": "2820660",
    "end": "2831565"
  },
  {
    "text": " I claim that's going\nto be log base B of N.",
    "start": "2831565",
    "end": "2838150"
  },
  {
    "text": "So I guess the first question\nis, what is the height of one",
    "start": "2838150",
    "end": "2844657"
  },
  {
    "text": "of these little triangles?  Well, we start with\na tree of height",
    "start": "2844657",
    "end": "2851230"
  },
  {
    "text": "log N. Then we divide it in\nhalf and we divide it in half and divide it in half. And we take floors and\nceilings, whatever.",
    "start": "2851230",
    "end": "2858430"
  },
  {
    "text": "But we repeatedly divide\nthe height in half. And we stop whenever the\nnumber of nodes in there",
    "start": "2858430",
    "end": "2864579"
  },
  {
    "text": "is less than B. So that\nmeans the height is going to be theta log B.\nIn fact, it's going",
    "start": "2864580",
    "end": "2872950"
  },
  {
    "text": "to be in the range\n1/2 log B to log B,",
    "start": "2872950",
    "end": "2879460"
  },
  {
    "text": "probably with a paren that way. Doesn't really matter, because\nyou stop as soon as you hit B.",
    "start": "2879460",
    "end": "2885744"
  },
  {
    "text": "You're dividing the\nheight in half repeatedly. You might overshoot\nby at most a half.",
    "start": "2885744",
    "end": "2891700"
  },
  {
    "text": "That's it. So height is log B. So if we look along\na root to leaf path,",
    "start": "2891700",
    "end": "2897730"
  },
  {
    "text": "each of these\nthings we visit, we make vertical progress\nlog B, theta log B.",
    "start": "2897730",
    "end": "2904470"
  },
  {
    "text": "And the total vertical progress\nwe need to make is log N, and so it's log N\ndivided by log B.",
    "start": "2904470",
    "end": "2912535"
  },
  {
    "text": "So I guess 4 times log\nN, 2 log N over log B.",
    "start": "2912535",
    "end": "2928690"
  },
  {
    "text": "Triangles, we reach a leaf. ",
    "start": "2928690",
    "end": "2934074"
  },
  {
    "text": "It's total progress we\nneed to make divided by 1/2 log B here, progress\nper triangle.",
    "start": "2934074",
    "end": "2941200"
  },
  {
    "text": "So we get 2 times log base B of\nN. And then for each triangle, we have to pay 2\nmemory reads, so",
    "start": "2941200",
    "end": "2947100"
  },
  {
    "text": "this implies at most 4 log\nbase B of N memory transfers.",
    "start": "2947100",
    "end": "2956430"
  },
  {
    "text": " And I implicitly assumed\nhere that B is not 1.",
    "start": "2956430",
    "end": "2964020"
  },
  {
    "text": "Otherwise, need a B plus\n1 here to be interesting.",
    "start": "2964020",
    "end": "2969710"
  },
  {
    "text": "So long as B isn't 1,\nthen it doesn't matter. OK. So that's the log base B of\nN analysis, actually really",
    "start": "2969710",
    "end": "2976680"
  },
  {
    "text": "simple. Essentially what\nwe're doing here is binary searching on B in a\nkind of weird way, using divide",
    "start": "2976680",
    "end": "2984720"
  },
  {
    "text": "and conquer and recursion. So we say, well, maybe\nB is the whole thing, then B equals N. Then we\ndon't have to do anything.",
    "start": "2984720",
    "end": "2991090"
  },
  {
    "text": "Everything fits in a block. Otherwise, let's imagine\ndividing here and supposing B is root N, and then\nwe need two accesses.",
    "start": "2991090",
    "end": "3001240"
  },
  {
    "text": "But B might be smaller than\nthat, so we keep recursing, keep going down. And because we're dividing\nin half each time--",
    "start": "3001240",
    "end": "3007550"
  },
  {
    "text": " sorry. We're not binary\nsearching on B. We're binary searching on log\nB, which is the height",
    "start": "3007550",
    "end": "3015830"
  },
  {
    "text": "of a tree with B nodes in it. And that's exactly what\nwe can afford to do.",
    "start": "3015830",
    "end": "3020870"
  },
  {
    "text": "And conveniently, it's\nall we need to do, because to get log\nbase B of N correct, you only need to\nget log B correct up to a constant factor.",
    "start": "3020870",
    "end": "3026740"
  },
  {
    "text": " All right.",
    "start": "3026740",
    "end": "3032210"
  },
  {
    "text": "Now, that was the easy part. Now the hard part is\nto make this dynamic. This is where\nthings get exciting.",
    "start": "3032210",
    "end": "3038270"
  },
  {
    "text": "This works fine\nfor a static tree. And this is how we do search. But we can't do inserts and\ndeletes in this world easily.",
    "start": "3038270",
    "end": "3047660"
  },
  {
    "text": "But I'll show you how\nto do it nonetheless. ",
    "start": "3047660",
    "end": "3065450"
  },
  {
    "text": "So this is what's called\na cache-oblivious B-tree. ",
    "start": "3065450",
    "end": "3075350"
  },
  {
    "text": "We're going to do\nit in five steps.  And the first step,\nunfortunately,",
    "start": "3075350",
    "end": "3081950"
  },
  {
    "text": "is delayed until next lecture,\nso I need a black box. It's a very useful black box.",
    "start": "3081950",
    "end": "3089310"
  },
  {
    "text": "It's actually one that we've\nbriefly talked about before, I think in the time travel. ",
    "start": "3089310",
    "end": "3100939"
  },
  {
    "text": "If you remember, in\ntime travel there was one black box, which\nwe still haven't seen but we will do finally\nnext lecture, which",
    "start": "3100939",
    "end": "3107080"
  },
  {
    "text": "was you can insert\ninto a linked list and then given two\nitems in the linked list know which one comes\nbefore which other one",
    "start": "3107080",
    "end": "3112321"
  },
  {
    "text": "in constant time per operation. Closely related to that is\na slightly different problem called order file maintenance.",
    "start": "3112321",
    "end": "3118900"
  },
  {
    "text": "Here's what it lets you do. You can store N elements,\nN words in specified order,",
    "start": "3118900",
    "end": "3128320"
  },
  {
    "text": "so just like it's a linked list. But we don't store\nit as a linked list.",
    "start": "3128320",
    "end": "3133650"
  },
  {
    "text": "We want to store it in\nan array of linear size.",
    "start": "3133650",
    "end": "3138744"
  },
  {
    "start": "3138745",
    "end": "3145510"
  },
  {
    "text": "So there's going to be some\nblank spots in this array. We've got N items, an array\nof size, say 2N or 1.1 times",
    "start": "3145510",
    "end": "3152410"
  },
  {
    "text": "N, anything like\nthat will suffice. The rest, we call them\ngaps, gaps in the array.",
    "start": "3152410",
    "end": "3161860"
  },
  {
    "text": "And the updates-- so this is\nphysically what you have to do.",
    "start": "3161860",
    "end": "3167250"
  },
  {
    "text": "You can change this\nset of elements by either deleting an element\nor inserting an element",
    "start": "3167250",
    "end": "3175300"
  },
  {
    "text": "between two given elements. ",
    "start": "3175300",
    "end": "3189776"
  },
  {
    "text": "So this is just like\nthe linked list updates. I can delete somebody\nfrom a linked list. I can insert a new item\nin between two given",
    "start": "3189776",
    "end": "3195640"
  },
  {
    "text": "items in the linked list. But now it has to be stored in\na physical array of linear size.",
    "start": "3195640",
    "end": "3201430"
  },
  {
    "text": "Now, we can't do this\nin constant time. But what we can do is\nmove elements around.",
    "start": "3201430",
    "end": "3225320"
  },
  {
    "start": "3225320",
    "end": "3244231"
  },
  {
    "text": "OK. So let me draw a picture. ",
    "start": "3244231",
    "end": "3268980"
  },
  {
    "text": "So maybe we have\nsome elements here. ",
    "start": "3268980",
    "end": "3275940"
  },
  {
    "text": "They could be in sorted\norder, maybe not. ",
    "start": "3275940",
    "end": "3282589"
  },
  {
    "text": "There are some gaps in between. I didn't mention it, but all\ngaps will have constant size.",
    "start": "3282590",
    "end": "3290234"
  },
  {
    "text": " So this will be\nconstant-sized gaps.",
    "start": "3290235",
    "end": "3298710"
  },
  {
    "text": "And we're able to do things\nlike insert a new item right after 42.",
    "start": "3298710",
    "end": "3304140"
  },
  {
    "text": "Let's say we insert 12. So 12, we could put it\nright here, no problem.",
    "start": "3304140",
    "end": "3309930"
  },
  {
    "text": "Now maybe we say insert\nright after 42 the number 6. And we're like, oh,\nthere's no room to put 6.",
    "start": "3309930",
    "end": "3317009"
  },
  {
    "text": "So I've got to move some stuff. Maybe I move 12 over here\nand then I put 6 here.",
    "start": "3317009",
    "end": "3323100"
  },
  {
    "text": "And then I say, OK, now insert\nright after 42 the number 7. And you're like, uh-oh.",
    "start": "3323100",
    "end": "3330960"
  },
  {
    "text": "I could move these guys over one\nand then put 7 here, and so on.",
    "start": "3330960",
    "end": "3337920"
  },
  {
    "text": "Obvious algorithm to do this. Takes linear time, linear\nnumber of shifts in order",
    "start": "3337920",
    "end": "3343020"
  },
  {
    "text": "to do one insertion. Claim is you can do an insertion\nin log squared amortized.",
    "start": "3343020",
    "end": "3348970"
  },
  {
    "text": "It's pretty cool. So worst case,\nyou'll still going to need to shift everybody. But just leaving\nconstant-sized gaps",
    "start": "3348970",
    "end": "3354600"
  },
  {
    "text": "will be enough to reduce\namortized costs to log squared. And this is conjectured\noptimal, though no one knows how to prove that.",
    "start": "3354600",
    "end": "3360850"
  },
  {
    "text": "And that's order\nfile maintenance. Now, we're going to assume\nthis is a black box. Next lecture, we'll\nactually do it.",
    "start": "3360850",
    "end": "3368430"
  },
  {
    "text": "But I want to first\nshow you how it lets us get cache-oblivious\ndynamic B-trees.",
    "start": "3368430",
    "end": "3375430"
  },
  {
    "start": "3375430",
    "end": "3381270"
  },
  {
    "text": "Log base B of N,\ninsert, delete, search. ",
    "start": "3381270",
    "end": "3392520"
  },
  {
    "text": "OK. We're going to use an\nordered file maintenance data structure to store our keys,\njust stick them in there.",
    "start": "3392520",
    "end": "3401910"
  },
  {
    "text": "Now, this is good-- well, it's really not\ngood for anything, although it's a starting point.",
    "start": "3401910",
    "end": "3408330"
  },
  {
    "text": "It can do updates in\nlog squared of N-- I didn't mention this part-- in a constant number of scans.",
    "start": "3408330",
    "end": "3415109"
  },
  {
    "text": "So think of these as\nthis kind of shift. I have to scan left to\nright, copy 23 to the left,",
    "start": "3415110",
    "end": "3421980"
  },
  {
    "text": "42 to the left, and so on. Scans are things we\nknow how to do fast in N",
    "start": "3421980",
    "end": "3427510"
  },
  {
    "text": "over B memory transfers. So if you're going\nto do log squared-- if you're going to update\nan interval log squared guys",
    "start": "3427510",
    "end": "3434880"
  },
  {
    "text": "using constant\nnumber of scans, this will take log squared N\nover B memory transfers.",
    "start": "3434880",
    "end": "3442920"
  },
  {
    "start": "3442920",
    "end": "3450369"
  },
  {
    "text": "Not quite the bound we want. We want log base B of N. This could be larger or\nsmaller than log base B of N.",
    "start": "3450370",
    "end": "3456220"
  },
  {
    "text": "It depends how big B is. But don't worry\nabout it for now. This is still-- at\nleast it's poly log.",
    "start": "3456220",
    "end": "3463210"
  },
  {
    "text": "Updates are kind\nof vaguely decent. We'll improve them later. On the other hand, search\nis really bad here.",
    "start": "3463210",
    "end": "3470829"
  },
  {
    "text": "I mean, we're\nmaintaining the items-- I didn't mention it, but we\nwill actually maintain the items in sorted order.",
    "start": "3470830",
    "end": "3475996"
  },
  {
    "text": "So yeah, you could\ndo a binary search. But binary search is really\nbad cache-obliviously, because most of the\ntime you'll be visiting",
    "start": "3475997",
    "end": "3481621"
  },
  {
    "text": "a new block until the very end. So binary search-- this\nis a fun exercise--",
    "start": "3481621",
    "end": "3487510"
  },
  {
    "text": "is log N minus log B. We\nwant log N divided by log B.",
    "start": "3487510",
    "end": "3492670"
  },
  {
    "text": "So we can't use binary search. We need to use van Emde\nBoas layouts, this thing.",
    "start": "3492670",
    "end": "3498580"
  },
  {
    "text": "So we just plug these together. We take this static\nsearch tree and stick it on top of an ordered file\nmaintenance data structure.",
    "start": "3498580",
    "end": "3506000"
  },
  {
    "text": "So here we have a van Emde\nBoas layout static tree",
    "start": "3506000",
    "end": "3512980"
  },
  {
    "text": "on top of this thing,\nwhich is an ordered file. ",
    "start": "3512980",
    "end": "3521980"
  },
  {
    "text": "And we have cross-linking. ",
    "start": "3521980",
    "end": "3527520"
  },
  {
    "text": "Really here we have gaps. And we don't store\nthe gaps up here.",
    "start": "3527520",
    "end": "3532590"
  },
  {
    "text": "Or do we? Yeah, sure. We do, actually. Store them all. Put it all in there. All right.",
    "start": "3532590",
    "end": "3537860"
  },
  {
    "text": "I'm going to have an\nactual example here. ",
    "start": "3537860",
    "end": "3554100"
  },
  {
    "text": "Let's do it 3 slash\n7, 9 slash 16, 21, 42.",
    "start": "3554100",
    "end": "3570760"
  },
  {
    "start": "3570760",
    "end": "3586400"
  },
  {
    "text": "OK. Cross-links between. I won't draw all of them. Then we store all the\ndata up here as well.",
    "start": "3586400",
    "end": "3593210"
  },
  {
    "start": "3593210",
    "end": "3598859"
  },
  {
    "text": "And then the internal\nnodes here are going to store the max\nof the whole subtree.",
    "start": "3598860",
    "end": "3603990"
  },
  {
    "text": "So here the max is 3. Here the max is 9,\n16, 42, 42, and 9.",
    "start": "3603990",
    "end": "3615510"
  },
  {
    "text": " If I store the max of every\nsubtree, then at the root.",
    "start": "3615510",
    "end": "3620934"
  },
  {
    "text": "If I want to decide should I\ngo left or should I go right, I look at the max\nof the left subtree and that will let\nme know whether I",
    "start": "3620934",
    "end": "3626740"
  },
  {
    "text": "should go left or right. So now I can do binary search.",
    "start": "3626740",
    "end": "3631780"
  },
  {
    "text": "I do a search up here. I want to do a search,\nI search the tree. This thing is laid\nout just like this.",
    "start": "3631780",
    "end": "3638619"
  },
  {
    "text": "And so we pay log base B of\nN to search up here, plus 1,",
    "start": "3638620",
    "end": "3646980"
  },
  {
    "text": "if you want. And then we get to a\nkey and we're done. That's all we wanted to know.",
    "start": "3646980",
    "end": "3652810"
  },
  {
    "text": "So search is now good. Updates, two problems.",
    "start": "3652810",
    "end": "3658250"
  },
  {
    "text": "One is that updating just\nthis bottom part is slow. Second problem is if I\nchange the bottom thing,",
    "start": "3658250",
    "end": "3663850"
  },
  {
    "text": "now I have to change\nthe top thing. But let's look at\nthat part first. It's not so bad to update--",
    "start": "3663850",
    "end": "3670780"
  },
  {
    "text": "I mean, this structure stays\nthe same, unless N doubles. Then we rebuild the\nentire data structure.",
    "start": "3670780",
    "end": "3677020"
  },
  {
    "text": "But basically, this\nthing will stay the same. It's just data is moving\naround in this array. And we have to\nupdate which values",
    "start": "3677020",
    "end": "3683620"
  },
  {
    "text": "are stored in this structure. The layout of the\nstructure, the order of the nodes, that\nall stays fixed. It's just the numbers\nthat are being",
    "start": "3683620",
    "end": "3689680"
  },
  {
    "text": "written in here that change. That's the cool idea. So that's step 2.",
    "start": "3689680",
    "end": "3701490"
  },
  {
    "text": "Let's go to step 3. ",
    "start": "3701490",
    "end": "3712650"
  },
  {
    "text": "I actually kind of wanted\nthat exact picture. That's OK. ",
    "start": "3712650",
    "end": "3718940"
  },
  {
    "text": "I need to specify\nhow updates are done. ",
    "start": "3718940",
    "end": "3725610"
  },
  {
    "text": "So let's say I want\nto do an insertion. ",
    "start": "3725610",
    "end": "3732069"
  },
  {
    "text": "If I want to insert a new\nkey, I search for the key. Maybe it fits between 7 and 9.",
    "start": "3732070",
    "end": "3737829"
  },
  {
    "text": "Then I do the insertion\nin the bottom structure in the ordered file. So we want to insert 8.",
    "start": "3737830",
    "end": "3744190"
  },
  {
    "text": "These guys move around. Then I have to propagate\nthat information up here. And the key thing\nI want to specify",
    "start": "3744190",
    "end": "3751210"
  },
  {
    "text": "is an update does a search. Then it updates\nthe ordered file.",
    "start": "3751210",
    "end": "3759220"
  },
  {
    "text": "That's going to take\nlog squared N over B.",
    "start": "3759220",
    "end": "3764830"
  },
  {
    "text": "And then we want to\npropagate changes into the tree in post-order,\npost-order traversal.",
    "start": "3764830",
    "end": "3782660"
  },
  {
    "text": "That's the one thing\nI wanted to specify, because it actually matters in\nwhat order I update the item.",
    "start": "3782660",
    "end": "3789270"
  },
  {
    "text": "So for example, suppose\nI move 9 to the right and then I insert 8 here.",
    "start": "3789270",
    "end": "3794720"
  },
  {
    "text": "So then this thing-- let's do it, what changes\nin that situation.",
    "start": "3794720",
    "end": "3802930"
  },
  {
    "text": "9 will change to\nan 8 here, which means this value has\nto change to an 8",
    "start": "3802930",
    "end": "3809599"
  },
  {
    "text": "and this value needs\nto change to an 8. And this one I can't\nquite update yet,",
    "start": "3809600",
    "end": "3815569"
  },
  {
    "text": "because I need to\ndo the other tree. So here I change\nthis value to a 9.",
    "start": "3815570",
    "end": "3823010"
  },
  {
    "text": "This one doesn't\nchange, so this is OK. This is OK. This is OK. Just taking the maxes\nas I propagate up.",
    "start": "3823010",
    "end": "3830210"
  },
  {
    "text": "So the red things are the\nnodes that I touch and compute the maxes of. And the order I did it was\na post-order traversal.",
    "start": "3830210",
    "end": "3835983"
  },
  {
    "text": "I need to do a post-order\ntraversal in order to compute maxes. I need to know what\nthe max of this subtree",
    "start": "3835983",
    "end": "3841130"
  },
  {
    "text": "is and this subtree before I can\nre-compute the max of the root. ",
    "start": "3841130",
    "end": "3846860"
  },
  {
    "text": "So it's really the\nobvious algorithm. Now, the interesting\npart is the analysis. ",
    "start": "3846860",
    "end": "3859590"
  },
  {
    "text": "So searches we've\nalready analyzed. We don't need to\ndo anything there. That's log base B of N.",
    "start": "3859590",
    "end": "3869790"
  },
  {
    "text": "But updates are the\ninteresting thing to analyze. ",
    "start": "3869790",
    "end": "3883859"
  },
  {
    "text": "And again we're going to look\nat the level of detail that",
    "start": "3883860",
    "end": "3889380"
  },
  {
    "text": "straddles B, just like before. ",
    "start": "3889380",
    "end": "3901490"
  },
  {
    "text": "So let me draw a good picture. ",
    "start": "3901490",
    "end": "3920182"
  },
  {
    "text": "I'm going to draw it\nslightly differently from how I drew it last time. ",
    "start": "3920182",
    "end": "3940340"
  },
  {
    "text": "OK.  What I'm drawing\nhere is actually",
    "start": "3940341",
    "end": "3945900"
  },
  {
    "text": "the bottom of the tree. So a real tree is like this. And I'm looking at\nthe bottom, where",
    "start": "3945900",
    "end": "3952820"
  },
  {
    "text": "the leaves are, because\nI care about where I connect to this ordered file. So there's the ordered\nfile at the bottom.",
    "start": "3952820",
    "end": "3959700"
  },
  {
    "text": "And I'm refining each\ntriangle recursively until they're size\nless than B. They're going to be somewhere\nbetween root B and B.",
    "start": "3959700",
    "end": "3966900"
  },
  {
    "text": "These big triangles\nare bigger than B. OK.",
    "start": "3966900",
    "end": "3973344"
  },
  {
    "text": "So that's where I want\nto look at things. Now, when we update\nin the ordered file,",
    "start": "3973344",
    "end": "3979015"
  },
  {
    "text": "we have this theorem. It says you move\nelements in an interval. So what changes is an interval.",
    "start": "3979015",
    "end": "3984600"
  },
  {
    "text": "The interval has size\nlog squared N amortized. So we are updating\nsome interval here,",
    "start": "3984600",
    "end": "3993900"
  },
  {
    "text": "maybe something like this. ",
    "start": "3993900",
    "end": "3999450"
  },
  {
    "text": "And so all of these\nitems change, let's say.",
    "start": "3999450",
    "end": "4004509"
  },
  {
    "text": "Now, this is not\ngoing to be too big. It's going to be log\nsquare N amortized. ",
    "start": "4004509",
    "end": "4013440"
  },
  {
    "text": "And all of the\nancestors of those nodes have to be updated, potentially. So all these guys are\ngoing to get updated.",
    "start": "4013440",
    "end": "4021150"
  },
  {
    "text": "Some of this tree, this\npath, all of this stuff is going to get updated,\nsome of this stuff,",
    "start": "4021150",
    "end": "4029070"
  },
  {
    "text": "the path up to here. The path up to the root\ngets updated, in general,",
    "start": "4029070",
    "end": "4034760"
  },
  {
    "text": "and all these nodes get touched. Now, I claim that's cheap, no\nmore expensive than updating",
    "start": "4034760",
    "end": "4040680"
  },
  {
    "text": "down here. Let's prove that. ",
    "start": "4040680",
    "end": "4066440"
  },
  {
    "text": "OK. First issue is, in what order\ndo I visit the nodes here? I want to think about\nthis post-order.",
    "start": "4066440",
    "end": "4072960"
  },
  {
    "text": "Maybe I'll use another\ncolor to draw that. So let's say we start\nby updating this guy.",
    "start": "4072960",
    "end": "4080760"
  },
  {
    "text": "We update this value. Then we go-- I'm doing a post-order\ntraversal, this tree.",
    "start": "4080760",
    "end": "4086220"
  },
  {
    "text": "Once I've completely\nfinished here, I can go up here, maybe go up\nhere, visit over down this way,",
    "start": "4086220",
    "end": "4094350"
  },
  {
    "text": "fix all the maxes here. Then I go up, fix\nall the maxes here, fix all the maxes, the maxes.",
    "start": "4094350",
    "end": "4100229"
  },
  {
    "text": "When I come up, then I can fix\nthe maxes up here, and so on. OK. Think about that order.",
    "start": "4100229",
    "end": "4106459"
  },
  {
    "text": "If you just look at\nthe big picture, which is which triangles are\nwe visiting, what we do is we visit this triangle, then\nthis one, then this triangle,",
    "start": "4106459",
    "end": "4113490"
  },
  {
    "text": "then this one, then this\ntriangle, then this one. I guess this is\nthe better picture. This triangle, left one,\nthis triangle, next child,",
    "start": "4113490",
    "end": "4120580"
  },
  {
    "text": "this parent, next child,\nthis parent, next child. And when we're done, we go\nover to the next big triangle.",
    "start": "4120580",
    "end": "4126990"
  },
  {
    "text": "Within a big\ntriangle, we alternate between two small triangles. As long as we have\nfour blocks of cache,",
    "start": "4126990",
    "end": "4137278"
  },
  {
    "text": "this will be good,\nbecause there's at most two blocks for\nthis little triangle, at most two blocks for\nthis little triangle.",
    "start": "4137279",
    "end": "4143100"
  },
  {
    "text": "So jumping back and\nforth between these is basically free. So we assume-- white chalk.",
    "start": "4143100",
    "end": "4152640"
  },
  {
    "text": " We assume that we have at\nleast four blocks of cache.",
    "start": "4152640",
    "end": "4162130"
  },
  {
    "text": "Post-order traversal alternates\nbetween two little triangles.",
    "start": "4162130",
    "end": "4177839"
  },
  {
    "text": "So this part is free. The only issue is, how\nmany little triangles do I need to load overall?",
    "start": "4177840",
    "end": "4184560"
  },
  {
    "text": " Sorry.",
    "start": "4184560",
    "end": "4189818"
  },
  {
    "text": "I should say I'm just looking\nat the little triangles in the bottom two levels. So this is in the\nbottom two levels.",
    "start": "4189819",
    "end": "4202041"
  },
  {
    "text": "Sorry. I forgot to mention that. As soon as you go outside\nthe bottom big triangle, let's not think about it yet.",
    "start": "4202041",
    "end": "4208380"
  },
  {
    "text": "Worry about that later. So just looking at these\nbottom two levels that I drew, we're just doing\nthis alternation.",
    "start": "4208380",
    "end": "4214565"
  },
  {
    "text": "And so the only issue is,\nhow many little triangles do I have to load? So there could be these guys.",
    "start": "4214565",
    "end": "4222389"
  },
  {
    "text": "These guys are good, because\nI'm touching all these nodes. The number of nodes\nhere was bigger than B,",
    "start": "4222390",
    "end": "4228030"
  },
  {
    "text": "so if I take this divided\nby B in the ceiling, the ceiling doesn't hurt me,\nbecause the overall size is",
    "start": "4228030",
    "end": "4233400"
  },
  {
    "text": "bigger than B. These guys I have to be\na little bit careful. Here the ceiling might\nhurt me, because I only",
    "start": "4233400",
    "end": "4239250"
  },
  {
    "text": "read some of these nodes. It may be much less\nthan B. It could be as low as root B. I divide\nby B, take the ceiling, I get 1,",
    "start": "4239250",
    "end": "4246240"
  },
  {
    "text": "so I have to pay 1 at the\nbeginning, 1 at the end. But in between, I\nget to divide by B.",
    "start": "4246240",
    "end": "4253710"
  },
  {
    "text": "So the number of little\ntriangles in the bottom two levels that I visit is going to\nbe 1 plus log squared N over B",
    "start": "4253710",
    "end": "4273719"
  },
  {
    "text": "amortized. The size of the interval\nis log squared N amortized, so this would be if I'm perfect.",
    "start": "4273720",
    "end": "4280650"
  },
  {
    "text": "But I get a plus 1 because\nof various ceilings. ",
    "start": "4280650",
    "end": "4287070"
  },
  {
    "text": "And also, the number\nof blocks is the same,",
    "start": "4287070",
    "end": "4294719"
  },
  {
    "text": "because each of these\nlittle triangles fits inside at most two blocks.",
    "start": "4294720",
    "end": "4300780"
  },
  {
    "text": "So it's going to be order 1\nplus log squared N over B. OK. So I can touch all\nthose in this much time,",
    "start": "4300780",
    "end": "4311940"
  },
  {
    "text": "because I assume that I can\nalternate between two of them quickly. And once I finish one\nof these leaf blocks,",
    "start": "4311940",
    "end": "4318030"
  },
  {
    "text": "I never touch it again, so I\nvisit each block essentially only once as long as\nmy cache is this big.",
    "start": "4318030",
    "end": "4326830"
  },
  {
    "text": "Cool. So that deals with\nthe bottom two levels. I claim the bottom two\nlevels only pay this. And we were already paying that\nto update the ordered file,",
    "start": "4326830",
    "end": "4334200"
  },
  {
    "text": "so it's no worse. Now, there's the levels above\nthis one that we can't see.",
    "start": "4334200",
    "end": "4340620"
  },
  {
    "text": "I claim that's also OK. Sorry. Also need number of memory\ntransfers is equal to that.",
    "start": "4340620",
    "end": "4355260"
  },
  {
    "text": "OK. One more part of the argument. ",
    "start": "4355260",
    "end": "4371010"
  },
  {
    "text": "Levels above the bottom two. ",
    "start": "4371010",
    "end": "4379920"
  },
  {
    "text": "Nice thing about the\nlevels above the bottom two is there aren't\ntoo many triangles.",
    "start": "4379920",
    "end": "4387281"
  },
  {
    "text": "All right. Well, there aren't too\nmany nodes involved. Let's see. So down here, there were\nlike log squared N nodes.",
    "start": "4387281",
    "end": "4395730"
  },
  {
    "text": "There was a lot of nodes. Once I go up two levels,\nhow many of these nodes can there be, these roots?",
    "start": "4395730",
    "end": "4402230"
  },
  {
    "text": " Well, it was log\nsquared N at the bottom.",
    "start": "4402230",
    "end": "4409020"
  },
  {
    "text": "And then I basically shaved\noff a factor of B here, so the number of these roots\nis at most log squared N",
    "start": "4409020",
    "end": "4415380"
  },
  {
    "text": "over B. That's small. For those nodes, I could\nafford to do an entire memory",
    "start": "4415380",
    "end": "4422610"
  },
  {
    "text": "transfer for every single node.  So the number of nodes\nthat need updating--",
    "start": "4422610",
    "end": "4431949"
  },
  {
    "text": "these are ancestors--\nis order log squared",
    "start": "4431950",
    "end": "4442110"
  },
  {
    "text": "N over B. That's the number\nof leaves down there.",
    "start": "4442110",
    "end": "4447507"
  },
  {
    "text": "At some point, you reach\nthe common ancestor of those leaves. That tree-- so here,\ndraw a big picture.",
    "start": "4447507",
    "end": "4454390"
  },
  {
    "text": "Here's the bottom two layers. ",
    "start": "4454390",
    "end": "4461340"
  },
  {
    "text": "We're shaving that off.  Up here, the number of nodes\nhere, these roots that we're",
    "start": "4461340",
    "end": "4471690"
  },
  {
    "text": "dealing with, that's the\nlog squared N over B. So if we build a\ntree on those nodes,",
    "start": "4471690",
    "end": "4478920"
  },
  {
    "text": "total number of nodes\nin here is only log squared N over B times 2,\nbecause it's a binary tree.",
    "start": "4478920",
    "end": "4485640"
  },
  {
    "text": "But then there's also\nthese nodes up here. This is potentially log N nodes. ",
    "start": "4485640",
    "end": "4493099"
  },
  {
    "text": "So number of nodes\nthat need updating is at most this plus log\nN. So what's going on here",
    "start": "4493099",
    "end": "4500520"
  },
  {
    "text": "is we first analyzed\nthe bottom two layers. That was OK because of\nthis ordering thing,",
    "start": "4500520",
    "end": "4507000"
  },
  {
    "text": "that we're only dealing\nwith two triangles at once and therefore we pay\nthis size divided by B,",
    "start": "4507000",
    "end": "4513020"
  },
  {
    "text": "log squared N over B. Then there's the common\nancestors of those nodes. That forms a little binary tree\nof size log squared N over B.",
    "start": "4513020",
    "end": "4520790"
  },
  {
    "text": "For these nodes,\nthis triangle up here, we can afford to pay one\nmemory transfer for every node,",
    "start": "4520790",
    "end": "4526740"
  },
  {
    "text": "so we don't care that we're\nefficient up here, which is-- I mean, well, let's not\nworry about whether we are.",
    "start": "4526740",
    "end": "4534035"
  },
  {
    "text": "It doesn't matter. So for these nodes, we pay at\nmost one memory transfer each.",
    "start": "4534035",
    "end": "4548100"
  },
  {
    "text": "And so we pay at most log\nsquared N over B for them. That's fine, because we\nalready paid that much.",
    "start": "4548100",
    "end": "4553950"
  },
  {
    "text": "And finally, we have\nto pay for these nodes up here, which are from the\ncommon ancestors of these guys",
    "start": "4553950",
    "end": "4559170"
  },
  {
    "text": "up to the root. That has length at most\nlog N. Could be smaller if this was a big interval.",
    "start": "4559170",
    "end": "4565120"
  },
  {
    "text": "So for these guys, we pay\norder log base B of N. Why?",
    "start": "4565120",
    "end": "4575970"
  },
  {
    "text": "Because this is a\nroot to node path. And this is the static analysis. We already know that\nfollowing a root to node path",
    "start": "4575970",
    "end": "4582719"
  },
  {
    "text": "we pay at most log base B of N. So we pay log base\nB of N plus log",
    "start": "4582720",
    "end": "4588440"
  },
  {
    "text": "squared N over B for this, plus\nlog squared N over B for this, plus log squared N over\nB for the ordered file.",
    "start": "4588440",
    "end": "4596730"
  },
  {
    "text": "So overall running\ntime for an update is log base B of N plus\nlog squared N over B.",
    "start": "4596730",
    "end": "4609780"
  },
  {
    "text": "We actually paid log\nbase B of N twice, once to do the initial search. I said an update first\nhas to search for the key.",
    "start": "4609780",
    "end": "4616190"
  },
  {
    "text": "Then it updates the order file. That's where we've paid the\nfirst log squared N over B. And then to propagate all\nthe changes up the tree,",
    "start": "4616190",
    "end": "4622980"
  },
  {
    "text": "we pay log squared N\nover B for this part, and then another log base\nB of N for this part. ",
    "start": "4622980",
    "end": "4630410"
  },
  {
    "text": "OK. That's updates with a bad bound. It turns out we're almost there.",
    "start": "4630410",
    "end": "4635890"
  },
  {
    "text": "So at this point we\nhave searches optimal, because searches are just\nsearching through the van Emde Boas thing.",
    "start": "4635890",
    "end": "4640920"
  },
  {
    "text": "That's log base B of N. Updates, not quite optimal. I mean not quite matching\na B-tree, I should say,",
    "start": "4640920",
    "end": "4647885"
  },
  {
    "text": "because it's not an optimal\nbound we're aiming for. We're just aiming for B-trees. We'd want to get this\nbound, same as searching.",
    "start": "4647885",
    "end": "4656010"
  },
  {
    "text": "But we have this\nextra term, which if B is small, for\nexample if B is log N,",
    "start": "4656010",
    "end": "4663690"
  },
  {
    "text": "this term will be\nbigger than this one. The breakpoint is when B\nequals log n times log log N.",
    "start": "4663690",
    "end": "4670160"
  },
  {
    "text": "So for small B, we're not happy. And we want to be happy\nfor all B's simultaneously. So I want to fix this.",
    "start": "4670160",
    "end": "4677239"
  },
  {
    "text": "We're going to fix it\nusing a general technique, great technique,\ncalled indirection.",
    "start": "4677240",
    "end": "4684420"
  },
  {
    "text": "So this is step 5, indirection. ",
    "start": "4684420",
    "end": "4692310"
  },
  {
    "text": "The idea is simple. We want to use the\nprevious data structure",
    "start": "4692310",
    "end": "4700880"
  },
  {
    "text": "on N over log N items.",
    "start": "4700880",
    "end": "4706380"
  },
  {
    "text": "And, well, we need to store N\nitems, so where do we put them? On the bottom. So I'm going to have theta\nlog N nodes down here,",
    "start": "4706380",
    "end": "4715370"
  },
  {
    "text": "theta log N nodes next to them-- or items, I should say.",
    "start": "4715370",
    "end": "4721550"
  },
  {
    "text": "Theta log N. OK. And then one of these items,\nlet's say the min item,",
    "start": "4721550",
    "end": "4728840"
  },
  {
    "text": "gets stored in this tree. The min item over here\ngets stored in this tree. The min item here\ngets stored up here.",
    "start": "4728840",
    "end": "4738840"
  },
  {
    "text": "OK. So this item only-- the data structure\nwe just developed, I only store N over\nlog N of the items.",
    "start": "4738840",
    "end": "4745990"
  },
  {
    "text": "The rest that fit in\nbetween those items are stored down here. Now I use standard\nB-tree tricks, actually.",
    "start": "4745990",
    "end": "4752800"
  },
  {
    "text": "If I want to do an insertion,\nhow do I do a search? I follow a root to leaf path.",
    "start": "4752800",
    "end": "4758200"
  },
  {
    "text": "And then I do a linear scan\nof this entire structure. How much does it cost to\ndo a linear scan of log N?",
    "start": "4758200",
    "end": "4763780"
  },
  {
    "text": "Only log N divided by B. This\nis smaller than log base B of N, so the hard part of search\nis the log base B of N.",
    "start": "4763780",
    "end": "4772551"
  },
  {
    "text": "OK. How do I do an update? Well, first, I\nsearch for the guy. I find the block that it\nfits into and just insert",
    "start": "4772551",
    "end": "4778210"
  },
  {
    "text": "into that block. Done. As long as this block\ndoesn't get too big,",
    "start": "4778210",
    "end": "4785170"
  },
  {
    "text": "how do I insert into a block? Rewrite the entire block. It's a scan. It only takes log\nN over B, so it's",
    "start": "4785170",
    "end": "4792190"
  },
  {
    "text": "basically free to rewrite\nthis entire block every time as long as it has size at most\nlog N. If it gets too full,",
    "start": "4792190",
    "end": "4799210"
  },
  {
    "text": "then I split it into two\nparts that are half-full. So in general, each\nof these blocks",
    "start": "4799210",
    "end": "4806560"
  },
  {
    "text": "will maintain the size to be\nbetween 1/4 log N and log N.",
    "start": "4806560",
    "end": "4814294"
  },
  {
    "text": "So if it gets\nbigger than log N, I split into two guys of 1/2 size. If it gets smaller\nthan 1/4 log N,",
    "start": "4814294",
    "end": "4820119"
  },
  {
    "text": "then I'll merge it with\none of its neighbors and then possibly\nhave to re-split it.",
    "start": "4820120",
    "end": "4825637"
  },
  {
    "text": "Or you can think of it\nas stealing neighbors from your siblings. That's what you do in B-trees.",
    "start": "4825637",
    "end": "4831190"
  },
  {
    "text": "But with a constant number\nof merges and splits, you can restore the property\nthat these guys have sizes very close to\n1/2 log N. And so",
    "start": "4831190",
    "end": "4839110"
  },
  {
    "text": "if they end up getting\nfull, that means you inserted 1/2 log N items. If they ended up\ngetting empty, that means you deleted\n1/4 log N items.",
    "start": "4839110",
    "end": "4848170"
  },
  {
    "text": "And so in both cases, you\nhave log N items to charge to. Whenever you do an\nupdate up here--",
    "start": "4848170",
    "end": "4853870"
  },
  {
    "text": "so we update up here\nevery time we split or merge down here,\nbecause this guy has to keep track of the blocks,\nnot the items in the blocks.",
    "start": "4853870",
    "end": "4861070"
  },
  {
    "text": "So we effectively\nslow down the updates",
    "start": "4861070",
    "end": "4866320"
  },
  {
    "text": "in the top structure\nby a factor log N,",
    "start": "4866320",
    "end": "4881210"
  },
  {
    "text": "which is great, because\nwe take this update bound and we get to divide it by log\nN, which removes this square.",
    "start": "4881210",
    "end": "4889070"
  },
  {
    "text": "So we end up with-- ",
    "start": "4889070",
    "end": "4894410"
  },
  {
    "text": "so we used to have log base B\nof N plus log squared N over B.",
    "start": "4894410",
    "end": "4900770"
  },
  {
    "text": "We get to divide\nthat by log N, plus we have to do this\npart at the bottom.",
    "start": "4900770",
    "end": "4910309"
  },
  {
    "text": "Plus we're doing log N\nover B at the bottom.",
    "start": "4910310",
    "end": "4915650"
  },
  {
    "text": "So basically, this log\ncancels with this square, so this is log N over B as well.",
    "start": "4915650",
    "end": "4921650"
  },
  {
    "text": "This thing gets even\nsmaller, so we end up being able to do\nupdates in log N over B.",
    "start": "4921650",
    "end": "4927980"
  },
  {
    "text": "Not really though,\nbecause at the beginning, we have to do a search to figure\nout where to do the update. If you knew where\nyou had to update,",
    "start": "4927980",
    "end": "4933950"
  },
  {
    "text": "you could update\na little faster. You could update\nin log N divided by B. If you don't\nknow where to update, you've got to spend log base\nB of N to search initially.",
    "start": "4933950",
    "end": "4943429"
  },
  {
    "text": "But that's the fun part. We can now update\nthis data structure fast, just with this one layer\nof indirection with log N",
    "start": "4943430",
    "end": "4950090"
  },
  {
    "text": "chunks at the bottom, speeding\nthis data structure up by a factor of\nlog N for updates. Searches don't take any longer.",
    "start": "4950090",
    "end": "4955401"
  },
  {
    "text": "You just pay this\nextra term, which was already much smaller than\nwhat we were paying before. Phew.",
    "start": "4955401",
    "end": "4961280"
  },
  {
    "text": "That's cache-oblivious\nB-trees, other than ordered file maintenance, which\nwe'll do next class.",
    "start": "4961280",
    "end": "4967420"
  },
  {
    "start": "4967420",
    "end": "4968605"
  }
]