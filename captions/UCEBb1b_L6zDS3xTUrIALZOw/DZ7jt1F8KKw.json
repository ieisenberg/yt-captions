[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu",
    "start": "13320",
    "end": "21110"
  },
  {
    "text": "PROFESSOR: All right today we\nbegin a topic dear to my heart. It's a problem that's\nstill pretty open,",
    "start": "21110",
    "end": "26430"
  },
  {
    "text": "but I've worked on a lot. Dynamic optimality. Central question here is, is\nthere one binary search tree",
    "start": "26430",
    "end": "32850"
  },
  {
    "text": "that's at least as good as\nall other binary search trees? Is there one binary search\ntree to rule them all?",
    "start": "32850",
    "end": "38580"
  },
  {
    "text": "It's kind of a\nfundamental question. Goes back to the '80s. In particular splay trees, which\nyou have probably seen before.",
    "start": "38580",
    "end": "46579"
  },
  {
    "text": "We'll review them briefly here. And there's a lot of\ntechnology built up, which we'll talk about this\nlecture and next lecture,",
    "start": "46580",
    "end": "53670"
  },
  {
    "text": "about how to tackle\nthis problem. It's still active\narea of research.",
    "start": "53670",
    "end": "59309"
  },
  {
    "text": "So before I get to-- well\nthe central question here is,",
    "start": "59310",
    "end": "66580"
  },
  {
    "text": "is there one best\nbinary search tree?",
    "start": "66580",
    "end": "73500"
  },
  {
    "text": " It's a natural question because\nwe use binary search trees",
    "start": "73500",
    "end": "79050"
  },
  {
    "text": "all the time. Already in this class,\nprobably every lecture, we've used a binary\nsearch tree for something.",
    "start": "79050",
    "end": "84190"
  },
  {
    "text": "And we all know how to do order\nlog in balanced binary search",
    "start": "84190",
    "end": "90880"
  },
  {
    "text": "trees.  And the question becomes,\nis this the best you can do?",
    "start": "90880",
    "end": "98940"
  },
  {
    "start": "98940",
    "end": "109590"
  },
  {
    "text": "To make this more formal\nof a problem, well, yeah.",
    "start": "109590",
    "end": "119259"
  },
  {
    "text": "I want to define binary search\ntree as a model of computation.",
    "start": "119260",
    "end": "125340"
  },
  {
    "text": "OK we've talked about\npointer machine model. Binary search tree model is\na more restricted version",
    "start": "125340",
    "end": "130929"
  },
  {
    "text": "of pointer machine. So it's less than\npointer machine. ",
    "start": "130930",
    "end": "138270"
  },
  {
    "text": "Just so it's clear what\nthe name of this game is, we require the data to be\nstored in a binary search",
    "start": "138270",
    "end": "150820"
  },
  {
    "text": "tree as it's keys. ",
    "start": "150820",
    "end": "160120"
  },
  {
    "text": "And then we allow\nbasic operations. ",
    "start": "160120",
    "end": "166610"
  },
  {
    "text": "Let me make sure I\nget the right list.",
    "start": "166610",
    "end": "171910"
  },
  {
    "start": "171910",
    "end": "181950"
  },
  {
    "text": "You can follow\npointers, and we're going to assume our BST\nhas left triad pointers,",
    "start": "181950",
    "end": "187140"
  },
  {
    "text": "right triad pointers,\nand parent pointers. You can do each of\nthese in constant time. And then the interesting one,\ninteresting thing you can do,",
    "start": "187140",
    "end": "194849"
  },
  {
    "text": "is rotate a node and its parent. ",
    "start": "194850",
    "end": "203550"
  },
  {
    "text": "So sure you've seen\nrotations before. ",
    "start": "203550",
    "end": "214160"
  },
  {
    "text": "If this is my node\nx, and I do rotate x, it's going to be my\ndefinition of rotation,",
    "start": "214160",
    "end": "223070"
  },
  {
    "text": "x moves to the root. It's in this case because x\nis to the right of it's parent it remains now to the\nright of it's, what",
    "start": "223070",
    "end": "231870"
  },
  {
    "text": "now becomes it's child.  These sub-trees come\nalong for the ride.",
    "start": "231870",
    "end": "238250"
  },
  {
    "text": "This preserves the binary\nsearch tree property. And you could get\nback by rotating y.",
    "start": "238250",
    "end": "243564"
  },
  {
    "text": " OK by this definition\nof rotate we don't need to\ndistinguish between left",
    "start": "243564",
    "end": "250129"
  },
  {
    "text": "and right rotations. We always name the child and\nit's parent is well defined.",
    "start": "250130",
    "end": "255489"
  },
  {
    "text": "That's who we rotate with. So it's just flipping this edge. So these are the operations\nyou can do, and in this model",
    "start": "255490",
    "end": "263120"
  },
  {
    "text": "really the only thing\nyou can do is a search. Suppose I want to\nsearch for a key. The model is to do a search I\nstart at the root of the tree,",
    "start": "263120",
    "end": "278300"
  },
  {
    "text": "of the binary search tree. I can do these walks. I could do rotations. And I must visit--",
    "start": "278300",
    "end": "284930"
  },
  {
    "text": "if I'm going to search for x,\nmust visit the node with key",
    "start": "284930",
    "end": "295970"
  },
  {
    "text": "equal to x. And we're going to assume\nthroughout these lectures that searches are\nalways successful.",
    "start": "295970",
    "end": "301850"
  },
  {
    "text": "You're only searching for\nkeys that are in the tree. Doesn't make that\nmuch of a difference if you're searching for keys\nthat are not in the tree.",
    "start": "301850",
    "end": "308000"
  },
  {
    "text": "Think of it as searching for the\npredecessor or the successor. Not a big deal. And so for\nsimplicity, we're just",
    "start": "308000",
    "end": "313520"
  },
  {
    "text": "going to assume\nsuccessful searches. We're also going to assume\nno insertions and deletions",
    "start": "313520",
    "end": "319790"
  },
  {
    "text": "in this model, because they just\nmake problem a little messier. Some papers have considered\ninsertions and deletions,",
    "start": "319790",
    "end": "326690"
  },
  {
    "text": "and to the large extent\nthings just work. So, we're going to\nfocus on searches. Searches is interesting\nenough for this problem.",
    "start": "326690",
    "end": "334740"
  },
  {
    "text": "Suppose I have n items. Now the model is clear. I store them in a\nbinary search tree.",
    "start": "334740",
    "end": "340067"
  },
  {
    "text": "These are the only\nthings I'm allowed to do. ",
    "start": "340067",
    "end": "346520"
  },
  {
    "text": "Could I imagine beating log n? Well, no in the worst case.",
    "start": "346520",
    "end": "354860"
  },
  {
    "text": "This is best possible\nin the worst case. ",
    "start": "354860",
    "end": "362930"
  },
  {
    "text": "Why? Because your tree has\nto have depth at least log n if you're going to store\nn things, and if it's binary.",
    "start": "362930",
    "end": "370550"
  },
  {
    "text": "So your adversary could\nalways be, could always just look at your tree\nand say, Oh I'm going to pick anybody who's\na log in depth or lower,",
    "start": "370550",
    "end": "378214"
  },
  {
    "text": "and if you're going\nto start at the root and walk left and\nright to get there, you're going to have\nto pay log n time every single, every\nsingle operation.",
    "start": "378214",
    "end": "387010"
  },
  {
    "text": "So actually there's a lot\nof sequences, in fact, most sequences. You take an average sequence,\nthis will be the case.",
    "start": "387010",
    "end": "392870"
  },
  {
    "text": "But we'll see formal ways\nto prove that next class. But, easy adversary\nargument tells you",
    "start": "392870",
    "end": "398720"
  },
  {
    "text": "you need to go down,\nlog n in the worst case. ",
    "start": "398720",
    "end": "404900"
  },
  {
    "text": "But, that's the worst case. The name of the game\nin dynamic optimality",
    "start": "404900",
    "end": "410150"
  },
  {
    "text": "is to consider every case\nseparately, and do as well as you can all the time. In general, the answer\nto this question is that,",
    "start": "410150",
    "end": "418190"
  },
  {
    "text": "is log n best possible? Depends on the access sequence.",
    "start": "418190",
    "end": "423519"
  },
  {
    "text": "Depends on what\nyou're searching for. ",
    "start": "423519",
    "end": "435750"
  },
  {
    "text": "So, let's say we're, to\nmake things a little clean,",
    "start": "435750",
    "end": "443310"
  },
  {
    "text": "let's assume that the\nkey is we're storing are the numbers,\nintegers, one up to n.",
    "start": "443310",
    "end": "450132"
  },
  {
    "text": "So in particular\nthere's n of them. And really we just\ncare about their order, so I'm going to relabel\nthem to be one up to n.",
    "start": "450132",
    "end": "457080"
  },
  {
    "text": "And say we search for x 1\nfirst, then we search for x 2,",
    "start": "457080",
    "end": "466620"
  },
  {
    "text": "and so on, up to x m. So, these indices\nare time, basically.",
    "start": "466620",
    "end": "474300"
  },
  {
    "text": "Over time, and you can\nplot this if you like. Here is time.",
    "start": "474300",
    "end": "479900"
  },
  {
    "text": "Here is space. So at the first time\nunit we search at x 1,",
    "start": "479900",
    "end": "487830"
  },
  {
    "text": "then some other place,\nthen some other place. We can have repeats, whatever.",
    "start": "487830",
    "end": "495590"
  },
  {
    "text": "OK. Some search sequences\nare going to be slow, they're going to require\nlog n time per access.",
    "start": "495590",
    "end": "501630"
  },
  {
    "text": "In particular, if I always,\nif the adversary chooses x i to be the deepest node\nin the tree repeatedly.",
    "start": "501630",
    "end": "507180"
  },
  {
    "text": "But some search sequences\nare going to be fast. ",
    "start": "507180",
    "end": "513240"
  },
  {
    "text": "Any suggestions, if you don't\nhave the notes in front of you, of access sequences that we\ncan do in less than log n",
    "start": "513240",
    "end": "522344"
  },
  {
    "text": "time per operation. Let's A constant. There's a lot of possible\nanswers, I think.",
    "start": "522344",
    "end": "528410"
  },
  {
    "start": "528410",
    "end": "534709"
  },
  {
    "text": "Yeah? AUDIENCE: N divided by two. PROFESSOR: N divided by two. What do you mean.",
    "start": "534710",
    "end": "541070"
  },
  {
    "text": "AUDIENCE: Like it's\ngoing to be [INAUDIBLE] PROFESSOR: Oh, if you're\nsearching for the median",
    "start": "541070",
    "end": "546980"
  },
  {
    "text": "in a perfectly balanced tree? Yeah, that's true. So if you're always searching\nfor the root of the tree,",
    "start": "546980",
    "end": "553250"
  },
  {
    "text": "in particular, that's\ngoing to be good. That's hard to, that\ndepends on the tree though.",
    "start": "553250",
    "end": "559430"
  },
  {
    "text": "I'd like a particular\naccess sequence that I can always serve\nas well, with some tree.",
    "start": "559430",
    "end": "567450"
  },
  {
    "text": "AUDIENCE: n order walk. PROFESSOR: n order walk. Yeah, good. So this has a name.",
    "start": "567450",
    "end": "577440"
  },
  {
    "text": "Sequential access property. ",
    "start": "577440",
    "end": "586870"
  },
  {
    "text": "If you want to access the\nelements in order, so one through n, this should only\ncost constant amortized.",
    "start": "586870",
    "end": "596520"
  },
  {
    "start": "596520",
    "end": "602737"
  },
  {
    "text": "Because for any tree\nyou can do and in order walk in linear time. And so per search, if you're\ncareful about how you do this,",
    "start": "602737",
    "end": "610689"
  },
  {
    "text": "now this is not totally obvious\nin the model that I've set up, because I said search\nalways starts at the root.",
    "start": "610690",
    "end": "617690"
  },
  {
    "text": "If you let your search\nstart where you left off, then you can definitely do this. It turns out you can\nassume this or not,",
    "start": "617690",
    "end": "624760"
  },
  {
    "text": "it doesn't make a difference. That's maybe a fun exercise. But if, you can essentially\nreroute the tree to be wherever you left off.",
    "start": "624760",
    "end": "631842"
  },
  {
    "text": "I'm not going to\nprove that here. OK, but in particular, some\ntrees have this property.",
    "start": "631842",
    "end": "638920"
  },
  {
    "text": "Some don't. I mean if you use a red black\ntree, and you search for one, then search for two,\nthen search for n, you're not going to\nget constant amortized,",
    "start": "638920",
    "end": "645610"
  },
  {
    "text": "because it doesn't\nrealize this is happening. But if you're clever, of\ncourse, this can be achieved.",
    "start": "645610",
    "end": "651616"
  },
  {
    "text": "Easy way to see\nhow to achieve it is, this is your\nbinary search tree.",
    "start": "651616",
    "end": "657500"
  },
  {
    "text": "You access one, then\nyou do a rotation with the right child of one. So then you have this\nbinary search tree,",
    "start": "657500",
    "end": "665350"
  },
  {
    "text": "and then you access two,\nand then you do a rotation. This is basically a\nway to make a deck.",
    "start": "665350",
    "end": "674709"
  },
  {
    "text": "View a, use a link, simulate a\nlinked list in a binary search tree.",
    "start": "674710",
    "end": "680260"
  },
  {
    "text": "OK, so it definitely can be\ndone by some binary search tree. A stronger version of the\nsequential access property,",
    "start": "680260",
    "end": "688305"
  },
  {
    "text": "it's a little more interesting,\nis dynamic finger property. This is something that should\nhold for every access sequence,",
    "start": "688305",
    "end": "695740"
  },
  {
    "text": "and it gives you a measure\nof how expensive an access sequence is. So we're doing x\none x two up to x m.",
    "start": "695740",
    "end": "703240"
  },
  {
    "text": "And we say, if we\nmeasure the key distance",
    "start": "703240",
    "end": "710350"
  },
  {
    "text": "between our current access,\nx i and the previous access, x i minus 1. If that equals k,\nthen ideally we",
    "start": "710350",
    "end": "719500"
  },
  {
    "text": "should be able to do log\nk amortize per operation. ",
    "start": "719500",
    "end": "726183"
  },
  {
    "text": "So in the worst\ncase this is going to be log n, but if I look\nat my space-time diagram",
    "start": "726184",
    "end": "732940"
  },
  {
    "text": "here, if for example, if\nI do sequential access,",
    "start": "732940",
    "end": "737950"
  },
  {
    "text": "then this number is always one,\nand so I get constant time. If I do something like this,\nwhere my spatial distance is",
    "start": "737950",
    "end": "746920"
  },
  {
    "text": "not changing too much,\nand this is the reason I numbered the keys like this. What I really mean is, in\nthe sorted order of the keys,",
    "start": "746920",
    "end": "753700"
  },
  {
    "text": "how do the ranks differ. But if I number the\nkeys one through n, that's just their\nabsolute difference.",
    "start": "753700",
    "end": "760589"
  },
  {
    "text": "So anything like\nthis, dynamic finger properly tells you\nyou're doing well.",
    "start": "760589",
    "end": "765874"
  },
  {
    "text": "Dynamic finger property can\nbe achieved by a binary search tree, but it's quite difficult\nas you might imagine.",
    "start": "765874",
    "end": "771540"
  },
  {
    "text": "Or it's difficult, let's say\nnot necessarily super hard. If you don't need to do it in\na binary search tree model,",
    "start": "771540",
    "end": "778980"
  },
  {
    "text": "an easy way to do\nit is with what's called a level linked tree. ",
    "start": "778980",
    "end": "784849"
  },
  {
    "text": "So a level link tree\nlooks like this, and I add pointers\nbetween adjacent nodes in the same level.",
    "start": "784849",
    "end": "790282"
  },
  {
    "text": "This is a pointer\nmachine data structure, it's not a binary search\ntree, because binary search trees we only allowed to do walk\nleft, walk right, walk parent,",
    "start": "790282",
    "end": "798120"
  },
  {
    "text": "But it's an easy way\nto do dynamic finger. You start from\nsomewhere, you basically",
    "start": "798120",
    "end": "803399"
  },
  {
    "text": "walk up to the right level,\nmove over, walk back down, and you can do a search for x\ni from x i minus one relatively",
    "start": "803400",
    "end": "813840"
  },
  {
    "text": "quickly. It turns out this can be\nstimulated by a binary search tree, but we won't\ngo into it here.",
    "start": "813840",
    "end": "818970"
  },
  {
    "text": "Lots of fun puzzles here. Let's move on to some\nmore bounds or properties.",
    "start": "818970",
    "end": "830190"
  },
  {
    "start": "830190",
    "end": "838320"
  },
  {
    "text": "So, next property is called\nthe entropy property, or entropy bound.",
    "start": "838320",
    "end": "844010"
  },
  {
    "text": "And it says if key k appears\np sub k fraction of the time,",
    "start": "844010",
    "end": "857310"
  },
  {
    "text": "then I'd like to achieve\na bound of entropy p",
    "start": "857310",
    "end": "866640"
  },
  {
    "text": "k log one over p\nk per operation. This is, everything here\ntoday will be amortized.",
    "start": "866640",
    "end": "874071"
  },
  {
    "text": " So, if you haven't seen\nentropy, that's the definition.",
    "start": "874072",
    "end": "879905"
  },
  {
    "text": "It's the entropy of\nthis distribution. We're thinking of\nthese as probabilities, although they're not\nreally probabilities.",
    "start": "879905",
    "end": "886870"
  },
  {
    "text": "They're, because this is\nover a particular sample. We have this sequence x1 to x\nn, There's no randomness here,",
    "start": "886870",
    "end": "894670"
  },
  {
    "text": "but we just measure\nwhat is the fraction, what is sort of the observed\nprobability for each of these x i's.",
    "start": "894670",
    "end": "900210"
  },
  {
    "text": "And then just say,\nwhat is the, what is the entropy of\nthat distribution? In the worst case\nit's log n, if say",
    "start": "900210",
    "end": "906870"
  },
  {
    "text": "everybody's equally likely,\neveryone's accessed once, or the same number of times. But if it's highly\nskewed, like if only one",
    "start": "906870",
    "end": "914130"
  },
  {
    "text": "element is accessed, the\nentropy will be constant. If a small number of\nelements are accessed, entropy will be constant.",
    "start": "914130",
    "end": "919311"
  },
  {
    "text": " So this can be\nachieved, and in fact, if you disallow\nrotations, so if I change",
    "start": "919311",
    "end": "927270"
  },
  {
    "text": "the model to forbid\nrotations, all I get to do is set up some\nbinary search tree, and then I have to walk left,\nwalk right, walk parent,",
    "start": "927270",
    "end": "934459"
  },
  {
    "text": "from in that binary\nsearch tree to do this. So if I get to\nsee the x i's then",
    "start": "934460",
    "end": "939899"
  },
  {
    "text": "I get to build a\nbinary search tree. One binary search tree.",
    "start": "939900",
    "end": "945210"
  },
  {
    "text": "This is what's called\nthe static optimal, when you're not allowed to change the\ntree as you're doing searches.",
    "start": "945210",
    "end": "950310"
  },
  {
    "text": "Entropy is the best\nbound you can get. And roughly speaking, key k\nappears at height, or depth,",
    "start": "950310",
    "end": "957990"
  },
  {
    "text": "log one over p k in the\ntree, maybe plus one. And you can show there's always\na tree where every node ends up",
    "start": "957990",
    "end": "966480"
  },
  {
    "text": "at depth log one over p k. Again, not hard, but\nwe won't do it here.",
    "start": "966480",
    "end": "973470"
  },
  {
    "text": "OK, a related property,\nit's called the working set",
    "start": "973470",
    "end": "979029"
  },
  {
    "text": "property. ",
    "start": "979030",
    "end": "988770"
  },
  {
    "text": "Little bit harder to state. ",
    "start": "988770",
    "end": "1023020"
  },
  {
    "text": "For each search we\ndo x i, we're going to see when that's some key,\nwhen was the last time that key",
    "start": "1023020",
    "end": "1030970"
  },
  {
    "text": "was accessed. So, in our space-time diagram\nwe have some access at time i,",
    "start": "1030970",
    "end": "1039214"
  },
  {
    "text": "we want to look backwards\nin time to the last time that key was accessed.",
    "start": "1039215",
    "end": "1044319"
  },
  {
    "text": "Say that was, well some other\ntime j, and in this interval",
    "start": "1044319",
    "end": "1050860"
  },
  {
    "text": "we want to know, how many\ndistinct keys were accessed.",
    "start": "1050860",
    "end": "1056559"
  },
  {
    "text": "So it's at most, i\nminus j, but maybe there were some repeated accesses,\nwe only count those as one.",
    "start": "1056560",
    "end": "1064340"
  },
  {
    "text": "So how many different\nkeys were accessed during that time interval? Claim is, we only have\nto pay log of that.",
    "start": "1064340",
    "end": "1072260"
  },
  {
    "text": "So what this means, what this\nimplies, is in particular, if you're only accessing say\nk different elements at all,",
    "start": "1072260",
    "end": "1079690"
  },
  {
    "text": "and you ignore all\nthe other elements, then you'll only pay\nlog k per operation. That's why it's sort\nof a working set.",
    "start": "1079690",
    "end": "1085450"
  },
  {
    "text": "If you're focusing\nyour attention on k elements for a\nwhile, you only pay log k. But in general, for any access\nsequence you can compute,",
    "start": "1085450",
    "end": "1092860"
  },
  {
    "text": "what is the working\nset costs, which is you sum over all\nthe i's of log t i, that is your total cost\nfor the access sequence.",
    "start": "1092860",
    "end": "1099940"
  },
  {
    "text": "Divide by n, that's\nthe amortized cost. OK? That's another\nnice property, not",
    "start": "1099940",
    "end": "1106390"
  },
  {
    "text": "so obvious is that working\nset implies the entropy bound, so this is a stronger property.",
    "start": "1106390",
    "end": "1113350"
  },
  {
    "text": "I guess dynamic finger\nimplies sequential access, but there's no relation between\nworking set and dynamic finger.",
    "start": "1113350",
    "end": "1120950"
  },
  {
    "text": "In fact, they're kind of\ntransposes of each other. Working set is\nabout, if you access",
    "start": "1120950",
    "end": "1126030"
  },
  {
    "text": "a key that was accessed\nrecently, then it's fast. Dynamic finger is\nsaying, if you access",
    "start": "1126030",
    "end": "1131470"
  },
  {
    "text": "a key that is close in space\nto the previous access, so here we're looking\nat a key and basically",
    "start": "1131470",
    "end": "1139240"
  },
  {
    "text": "in the very previous\ntime step we're looking at how far\naway it was vertically,",
    "start": "1139240",
    "end": "1144400"
  },
  {
    "text": "here we're looking at how\nfar away it was horizontally. So they're almost\nduals of each other.",
    "start": "1144400",
    "end": "1149679"
  },
  {
    "text": "Be nice if you could\nhave one property that included both dynamic\nfinger and working set.",
    "start": "1149680",
    "end": "1155710"
  },
  {
    "text": "I should mention, again\nthis is not obvious how to do it with a\nbinary search tree, but it can be done.",
    "start": "1155710",
    "end": "1161570"
  },
  {
    "text": "Leave it at that. We'll see eventually\nsome trees that have it. ",
    "start": "1161570",
    "end": "1168586"
  },
  {
    "text": "For now I just\nwant to cover what are the conceivable\ngoals we should aim for. All right, log n is too easy, so\nwe need more challenging goals.",
    "start": "1168586",
    "end": "1176230"
  },
  {
    "text": " So the next property,\nit was introduced,",
    "start": "1176230",
    "end": "1181870"
  },
  {
    "text": "this is we're getting into\nmore recent territory, 2001,",
    "start": "1181870",
    "end": "1188710"
  },
  {
    "text": "it's called the\nunified property. Natural name, and it tries\nto unify dynamic finger",
    "start": "1188710",
    "end": "1194770"
  },
  {
    "text": "with working set. And the rough idea\nis, that if you access a key that\nis close in space",
    "start": "1194770",
    "end": "1202630"
  },
  {
    "text": "to a key that was\naccessed recently in time, then your access should be fast.",
    "start": "1202630",
    "end": "1208010"
  },
  {
    "text": "So, here's the formal statement. ",
    "start": "1208010",
    "end": "1256789"
  },
  {
    "text": "So here's the unified bound. Let's draw a picture.",
    "start": "1256790",
    "end": "1263059"
  },
  {
    "text": "So here we're accessing\nx i at time i, sorry j.",
    "start": "1263060",
    "end": "1271740"
  },
  {
    "text": "Change of notation. Time j. We want to evaluate\nthe cost of x j,",
    "start": "1271740",
    "end": "1278260"
  },
  {
    "text": "and we're basically\ngoing to look in-- I guess one way to think\nof it is this cone.",
    "start": "1278260",
    "end": "1286750"
  },
  {
    "text": "90 degree cone, where\nthese are 45 degree angles. And if there's something--",
    "start": "1286750",
    "end": "1293590"
  },
  {
    "text": "and look at the first thing\nthat you hit in that cone. Is that the right\nway to think of it?",
    "start": "1293590",
    "end": "1298960"
  },
  {
    "text": "Maybe not. It's like you're growing a box,\nthis is probably more accurate,",
    "start": "1298960",
    "end": "1304810"
  },
  {
    "text": "and you find the first key\nthat you hit in that box. It's a little more\nsubtle than that because we're only\ncounting distinct keys,",
    "start": "1304810",
    "end": "1310980"
  },
  {
    "text": "and let's say you find this\nkey, and this key is good because it's temporal distance,\nthis time, is only this big.",
    "start": "1310980",
    "end": "1323470"
  },
  {
    "text": "It's spatial distance\nis only this big. What we're going to\npay is, log of the sum",
    "start": "1323470",
    "end": "1328600"
  },
  {
    "text": "of the spatial distance,\nand the temporal distance. And temporal\ndistance is measured as the number of distinct keys\naccessed in this time interval.",
    "start": "1328600",
    "end": "1336640"
  },
  {
    "text": " So, as long as there is some\nkey in the recent past that",
    "start": "1336640",
    "end": "1343810"
  },
  {
    "text": "is close in space, you take\nthe min over all such keys, magically a unified\nstructure has",
    "start": "1343810",
    "end": "1349810"
  },
  {
    "text": "to find what is the\nmost recent close item and search from there,\nand achieve log of that.",
    "start": "1349810",
    "end": "1355860"
  },
  {
    "text": "There's a plus 2 just to make\nsure if these things are zero, you still get a constant.",
    "start": "1355860",
    "end": "1361179"
  },
  {
    "text": "Always have to\npay constant time. OK, so that's a\nunified property.",
    "start": "1361180",
    "end": "1366970"
  },
  {
    "text": "Fairly natural generalization of\ndynamic finger and working set. I mean you could change this\nplus to a product or a max,",
    "start": "1366970",
    "end": "1374270"
  },
  {
    "text": "doesn't make a difference.  Yeah.",
    "start": "1374270",
    "end": "1380380"
  },
  {
    "text": "Sadly we don't\nknow whether there is any binary search tree that\nachieves the unified property.",
    "start": "1380380",
    "end": "1385720"
  },
  {
    "text": "What we know is that\nthis can be done, this property can be achieved\nby a pointer machine data",
    "start": "1385720",
    "end": "1395140"
  },
  {
    "text": "structure, which is more\npowerful than a binary search tree. ",
    "start": "1395140",
    "end": "1404100"
  },
  {
    "text": "But we don't know whether\nit's possible to achieve by a binary search tree.",
    "start": "1404100",
    "end": "1412390"
  },
  {
    "text": "Best bound so far, is\nthat you can achieve this bound plus log log n.",
    "start": "1412390",
    "end": "1419169"
  },
  {
    "text": "So as long as this\nnever gets too small, as long as this quantity\nnever gets smaller than log n,",
    "start": "1419170",
    "end": "1424429"
  },
  {
    "text": "then this thing will be\nlog log n, and it's fine. But in particular,\nif this is constant, then it's only achieving\nlog log n, so it's not--",
    "start": "1424430",
    "end": "1431669"
  },
  {
    "text": "there's an additive log\nlog n per operation loss. That's the best binary\nsearch, unified binary search",
    "start": "1431670",
    "end": "1437429"
  },
  {
    "text": "tree known.  OK, so this is all good.",
    "start": "1437430",
    "end": "1444090"
  },
  {
    "text": "And this is sort of where the,\nwhat we call analytic bounds, here ends.",
    "start": "1444090",
    "end": "1450610"
  },
  {
    "text": "There are various attempts to-- in general we want\nto characterize, what is the optimal\nthing we could hope for.",
    "start": "1450610",
    "end": "1457720"
  },
  {
    "text": "When can we do\nbetter than log n? These are all\nspecific cases where we can do better than\nlog n, but it's not",
    "start": "1457720",
    "end": "1462848"
  },
  {
    "text": "a complete characterization. There are sequences that\nhave large unified bound, but have no--",
    "start": "1462848",
    "end": "1469165"
  },
  {
    "text": " yet they can be\naccessed more quickly by the optimal\nbinary search tree.",
    "start": "1469165",
    "end": "1475624"
  },
  {
    "text": "And so, while it would\nbe nice to characterize with some clean algebraic,\nwhatever, most of the work,",
    "start": "1475624",
    "end": "1481780"
  },
  {
    "text": "beyond what I've\ntold you about here, is just trying to\nfigure out what opt is. Instead of trying to write\nit down, try to compute it.",
    "start": "1481780",
    "end": "1490259"
  },
  {
    "text": "Instead of trying\nto define something that happens to\nmatch the optimal, let's just go for optimal.",
    "start": "1490259",
    "end": "1496100"
  },
  {
    "text": "And this is the notion\nof dynamic optimality. ",
    "start": "1496100",
    "end": "1502510"
  },
  {
    "text": "And in modern\nterminology this would be called constant\ncompetitive, but the paper then",
    "start": "1502510",
    "end": "1509860"
  },
  {
    "text": "introduced dynamic optimality\npreceded competitive analysis, so it has another name.",
    "start": "1509860",
    "end": "1515980"
  },
  {
    "text": "What we'd like, is that\nthe total cost of all your accesses, so this\nis like amortized cost,",
    "start": "1515980",
    "end": "1522530"
  },
  {
    "text": "is within a constant\nfactor of the optimal. What's the optimal?",
    "start": "1522530",
    "end": "1529240"
  },
  {
    "text": "This is the-- over all\nbinary search trees, I mean to be precise I should\ntalk about binary search tree",
    "start": "1529240",
    "end": "1535720"
  },
  {
    "text": "algorithms, meaning you specify\nsomehow how to do a search, and it may involve\nrotations and walks.",
    "start": "1535720",
    "end": "1541900"
  },
  {
    "text": "So, you know, it could\nbe red black tree, it could be an AVL tree,\ncould be a [? BB ?] alpha tree, anything that can be\nimplemented in this way.",
    "start": "1541900",
    "end": "1549639"
  },
  {
    "text": "Those are all kind of boring. More sophisticated is\nsomething like a splay tree.",
    "start": "1549640",
    "end": "1555850"
  },
  {
    "text": "Ideally, you take\nthe min over all-- ",
    "start": "1555850",
    "end": "1562840"
  },
  {
    "text": "min over all binary\nsearch tree algorithms. The cost of that algorithm, on\nthat access sequence x, and you",
    "start": "1562840",
    "end": "1573820"
  },
  {
    "text": "want the total cost\nof your algorithm on x to be within a constant\nfactor of the optimal algorithm",
    "start": "1573820",
    "end": "1579760"
  },
  {
    "text": "on x. x is a vector. So this is what you call\nthe offline optimal,",
    "start": "1579760",
    "end": "1586540"
  },
  {
    "text": "because here you basically get\nto choose the binary search tree algorithm to\nbe customized to x,",
    "start": "1586540",
    "end": "1593799"
  },
  {
    "text": "and yet somehow you want to\nachieve dynamic optimality.",
    "start": "1593800",
    "end": "1600310"
  },
  {
    "text": "Open question, is this possible? ",
    "start": "1600310",
    "end": "1613990"
  },
  {
    "text": "And, of course, we're only\ninterested in online solutions. So, you want to build a\nbinary search tree that",
    "start": "1613990",
    "end": "1619432"
  },
  {
    "text": "doesn't know the\nfuture, it doesn't know what accesses\nare to come, but it has to be within a constant\nfactor of the offline solution",
    "start": "1619432",
    "end": "1626020"
  },
  {
    "text": "that does know. And we don't know\nwhether this is possible. Another interesting\nquestion, is whether it's",
    "start": "1626020",
    "end": "1632530"
  },
  {
    "text": "possible for a pointer\nmachine, because save",
    "start": "1632530",
    "end": "1637634"
  },
  {
    "text": "for the unified property\nwe know how to get it for a pointer machine. And there's two versions\nof this question.",
    "start": "1637634",
    "end": "1643730"
  },
  {
    "text": "You can consider, is\nthere a pointer machine that matches the optimal\nbinary search tree, or you could ask, is there a\npointer machine that matches",
    "start": "1643730",
    "end": "1650470"
  },
  {
    "text": "the optimal pointer machine. That's a little less defined,\nalthough there are some-- I have some ideas on how to\ndefine that problem, maybe will",
    "start": "1650470",
    "end": "1656528"
  },
  {
    "text": "work on it. But all versions of this\nproblem are open, basically. So, this may seem\nrather depressing.",
    "start": "1656528",
    "end": "1663580"
  },
  {
    "text": "What else am I going to do\nfor a lecture and a half? But actually, there's a lot\nof study of this problem,",
    "start": "1663580",
    "end": "1668680"
  },
  {
    "text": "and we do know some good things. For example, we can get\nlog log n competitive.",
    "start": "1668680",
    "end": "1676907"
  },
  {
    "text": " So, not within a\nconstant factor,",
    "start": "1676907",
    "end": "1682540"
  },
  {
    "text": "but we can get within a log\nlog n factor of the optimal. So, that's pretty good.",
    "start": "1682540",
    "end": "1687785"
  },
  {
    "text": "An easy result is to\nget log n competitive. Any balanced binary\nsearch tree is log n",
    "start": "1687785",
    "end": "1693310"
  },
  {
    "text": "competitive, because best case\nyou could hope for is constant, the worst case you\ncan hope for is log n. So at least within\nthe log factor,",
    "start": "1693310",
    "end": "1699962"
  },
  {
    "text": "but we can do\nexponentially better. We'll do that next class. Before we go there, I want to\ntell you about two structures,",
    "start": "1699962",
    "end": "1711820"
  },
  {
    "text": "to binary search trees that\nwe conjecture are dynamically optimal, but we can't prove it.",
    "start": "1711820",
    "end": "1718030"
  },
  {
    "start": "1718030",
    "end": "1741300"
  },
  {
    "text": "So first one, and the classic\none, is splayed trees. I don't want to spend too\nmuch time on splay trees,",
    "start": "1741300",
    "end": "1746790"
  },
  {
    "text": "but just to let you know what\nthey are if you don't already know. If you want to search\nfor x, you search for x.",
    "start": "1746790",
    "end": "1754900"
  },
  {
    "text": "You do a binary search\nfor x in the tree. You locate x, and then you--",
    "start": "1754900",
    "end": "1759930"
  },
  {
    "text": "splay trees always\nmove x to the root. So, this is what we call\na self-adjusting tree.",
    "start": "1759930",
    "end": "1767230"
  },
  {
    "text": "It changes the structure of\nthe tree as you do searches, not just when you're\ndoing updates,",
    "start": "1767230",
    "end": "1774160"
  },
  {
    "text": "and there are two cases. If you look at x, and its\nparent and its grandparent,",
    "start": "1774160",
    "end": "1779200"
  },
  {
    "text": "if they're oriented\nthe same way. So, here it's two left pointers,\ncould be two right pointers. Then you flip them.",
    "start": "1779200",
    "end": "1786850"
  },
  {
    "text": "So we rotate y, and then rotate\nx, so it's in this model.",
    "start": "1786850",
    "end": "1797660"
  },
  {
    "text": "And we get x y z\nin the other order. There's pretty much\nonly one way to move",
    "start": "1797660",
    "end": "1804610"
  },
  {
    "text": "x to the root in that picture.  Then the other case is\nthe zigzag case, y, w, x.",
    "start": "1804610",
    "end": "1817255"
  },
  {
    "text": " So, here the two parent pointers\nare in different directions,",
    "start": "1817255",
    "end": "1822890"
  },
  {
    "text": "one is left, one is right. There's a symmetric picture. In this case, we rotate\nin the other order.",
    "start": "1822890",
    "end": "1829760"
  },
  {
    "text": "So, we rotate x, and\nthen we rotate y. ",
    "start": "1829760",
    "end": "1835930"
  },
  {
    "text": "And in that case you get x\nnice, x, w, y, and the subtrees",
    "start": "1835930",
    "end": "1844465"
  },
  {
    "text": "hang off. I'm not labeling the\nsubtrees, but they have to be labeled in the\nsame order, left to right.",
    "start": "1844465",
    "end": "1850940"
  },
  {
    "text": "OK, this is splay trees. You do this for x. x is\nthe thing you search for,",
    "start": "1850940",
    "end": "1856360"
  },
  {
    "text": "now x is up here,\nthen you repeat. You look at it's two parents,\nit's one of these two cases,",
    "start": "1856360",
    "end": "1861409"
  },
  {
    "text": "you do the appropriate\ntwo rotations. Until x is either the\nroot, and you're done, or it's one child from\nthe root, and then",
    "start": "1861410",
    "end": "1867370"
  },
  {
    "text": "you do one rotation\nto make it the root.  Seems simple enough.",
    "start": "1867370",
    "end": "1874120"
  },
  {
    "text": "It's slightly more sophisticated\nthan an algorithm known as move to root, which is just\nrotate x, rotate x,",
    "start": "1874120",
    "end": "1879780"
  },
  {
    "text": "rotate x, which would\neventually propagate it up. Move to root is a\nreally bad algorithm. It can show its can be a\nfactor of square root of n.",
    "start": "1879780",
    "end": "1886769"
  },
  {
    "text": "It can be square root of n per\noperation if you're unlucky. Splay trees are always, at most\nlog n amortized per operation,",
    "start": "1886770",
    "end": "1894510"
  },
  {
    "text": "although that's\nnot at all obvious. Rough intuition, is if you\nlook at the path, the route",
    "start": "1894510",
    "end": "1899670"
  },
  {
    "text": "to x path, half of the nodes,\nat most half of the nodes",
    "start": "1899670",
    "end": "1904740"
  },
  {
    "text": "go down when you splay. So why is that? Here, see y stays\nat the same level.",
    "start": "1904740",
    "end": "1912250"
  },
  {
    "text": "z goes down, but x goes up. Here, w stays at the same level,\nx goes up, y goes down by one,",
    "start": "1912250",
    "end": "1920710"
  },
  {
    "text": "x goes up by two, so you might\ncall that a net improvement. But in general you don't\nmess up the path too much.",
    "start": "1920710",
    "end": "1926940"
  },
  {
    "text": "Half the items stay\nwhere they are, and so it's something\nlike your bisecting--",
    "start": "1926940",
    "end": "1932399"
  },
  {
    "text": "if you repeatedly\nsearch for x, well I'm not really searching\nfor x, but if you repeatedly search for things\nin that path, you're",
    "start": "1932400",
    "end": "1937673"
  },
  {
    "text": "kind of cutting the path\nand half repeatedly. It'll look kind of logarithmic,\nthat's a very vague argument.",
    "start": "1937673",
    "end": "1943710"
  },
  {
    "text": "And in the advanced\nalgorithms, it's proved why this is\nlog n amortized. Question? AUDIENCE: [INAUDIBLE]",
    "start": "1943710",
    "end": "1955180"
  },
  {
    "text": "PROFESSOR: Rotate x, rotate\nx, I think you're right. Yeah, y would go\nsomewhere else, thanks.",
    "start": "1955180",
    "end": "1962390"
  },
  {
    "text": "Yeah, so here it looks like\nmove to root, here it doesn't.",
    "start": "1962390",
    "end": "1968580"
  },
  {
    "text": "Good, and there's lots of\nthings known about splay trees. So for example, they satisfy\nthe sequential access property.",
    "start": "1968580",
    "end": "1976580"
  },
  {
    "text": "There's an entire paper,\ncombinatoric on 1985 Tarjan I believe, proving splay trees\nhave the sequential access",
    "start": "1976580",
    "end": "1983860"
  },
  {
    "text": "property. Not at all obvious,\nbut it's true. They have the\nworking set property,",
    "start": "1983860",
    "end": "1990040"
  },
  {
    "text": "and therefore they have\nthe entropy property. That's in the original\nsplay tree paper. It's not that hard to prove.",
    "start": "1990040",
    "end": "1995320"
  },
  {
    "text": "Once you prove log n, with\na little bit more effort you can prove the\nworking set property. We won't do it here.",
    "start": "1995320",
    "end": "2001890"
  },
  {
    "text": "It's a cool amortization. Splay trees also have the\ndynamic finger property.",
    "start": "2001890",
    "end": "2009690"
  },
  {
    "text": "This is a series of two\npapers, over 100 pages long. Very difficult to prove. In general, splay trees\nare hard to work with,",
    "start": "2009690",
    "end": "2016620"
  },
  {
    "text": "because it's hard to keep\ntrack of what's going on. You can define\npotential functions, and that will prove this,\nand with a lot of effort",
    "start": "2016620",
    "end": "2023070"
  },
  {
    "text": "it will prove this. We don't know whether\nsplay trees satisfy the unified property,\nand more to the point,",
    "start": "2023070",
    "end": "2028364"
  },
  {
    "text": "we don't know whether splay\ntrees are dynamically optimal. This is the big question, and\nin the original splay tree paper",
    "start": "2028364",
    "end": "2033900"
  },
  {
    "text": "it asked this question,\nare splay trees dynamically optimal. Still open, I wish I knew\nthe answer, but we don't.",
    "start": "2033900",
    "end": "2041700"
  },
  {
    "text": " So what the rest of today's\nlecture is going to be about",
    "start": "2041700",
    "end": "2048138"
  },
  {
    "text": "is a geometric view, which\nI've kind of been hinting at with this picture, but\nit's, there's more to it",
    "start": "2048139",
    "end": "2054830"
  },
  {
    "text": "than just plot the\npoints of searches. There's a way, not only to\nsee what the searches are,",
    "start": "2054830",
    "end": "2061158"
  },
  {
    "text": "but to see what the binary\nsearch tree algorithm is. So, at this point binary\nsearch tree algorithms",
    "start": "2061159",
    "end": "2066860"
  },
  {
    "text": "are kind of abstract. I mean, we've kind\nof drawn pictures, and how to do\nspecific cases, you know how red black\ntrees or something work.",
    "start": "2066860",
    "end": "2074850"
  },
  {
    "text": "But, you know, it's\ncomplicated to write down one of these algorithms. How would we think\nabout all of them?",
    "start": "2074850",
    "end": "2081050"
  },
  {
    "text": "What would you think\nabout the optimal one? Turns out there's a geometric\nview, in which it's actually very easy to see what\nthe algorithm is,",
    "start": "2081050",
    "end": "2088790"
  },
  {
    "text": "but it takes a\nlittle bit of work to prove that it's\nthe right thing. And it suggests a totally\nobvious offline optimal",
    "start": "2088790",
    "end": "2097820"
  },
  {
    "text": "algorithm, which we\ndon't know is optimal, but we think is offline optimal.",
    "start": "2097820",
    "end": "2103940"
  },
  {
    "text": "It's like the obvious thing\nto do, which we'll get to,",
    "start": "2103940",
    "end": "2110150"
  },
  {
    "text": "and we can actually\nmake it online. So, this is-- this\ngives us a binary search tree that is so\nobviously optimal,",
    "start": "2110150",
    "end": "2117110"
  },
  {
    "text": "where splay trees is kind\nof vaguely feels good, this is really obvious,\nyet we can't prove it.",
    "start": "2117110",
    "end": "2123275"
  },
  {
    "text": "So it's like we're one step\ncloser, but not quite there. ",
    "start": "2123275",
    "end": "2129594"
  },
  {
    "text": "So that's where we're going. ",
    "start": "2129594",
    "end": "2156550"
  },
  {
    "text": "So this geometric view was\nthe topic of [? Deion ?] [? Harmon's ?] PhD\nthesis, here at MIT.",
    "start": "2156550",
    "end": "2161740"
  },
  {
    "text": "And it's also with John Iacono,\n[? Danielle ?] [? Caine, ?] who was an undergrad here, and\n[? Mihal ?] [? Piotrowski, ?]",
    "start": "2161740",
    "end": "2167050"
  },
  {
    "text": "who was an undergrad\nand a PhD here. It was published\nthree years ago, 2009.",
    "start": "2167050",
    "end": "2173890"
  },
  {
    "text": "So, here's the idea. Access sequence, this is the\nsequence of searches you do.",
    "start": "2173890",
    "end": "2181779"
  },
  {
    "text": "That's very easy, you just\nmap it to the set of points",
    "start": "2181780",
    "end": "2186970"
  },
  {
    "text": "where, I guess I'm going\nto switch things on you. Sorry about that.",
    "start": "2186970",
    "end": "2193030"
  },
  {
    "text": "X-axis is going to be space,\ny-axis is going to be time.",
    "start": "2193030",
    "end": "2198280"
  },
  {
    "text": "And I'm going to look at a\nspecific example of this. ",
    "start": "2198280",
    "end": "2204720"
  },
  {
    "text": "Sort of pinwheel. Four accesses at--\nthe first time",
    "start": "2204720",
    "end": "2209819"
  },
  {
    "text": "we access key three, then\nwe access key one, then key four, then key two. We've been drawing this\npicture throughout the lecture.",
    "start": "2209820",
    "end": "2217710"
  },
  {
    "text": "Now the interesting part, is\nif you look at a binary search tree that actually\naccesses these elements,",
    "start": "2217710",
    "end": "2226870"
  },
  {
    "text": "here's the exciting part. We're going to map this\nto a point set, which",
    "start": "2226870",
    "end": "2234359"
  },
  {
    "text": "is which nodes get\ntouched during a search,",
    "start": "2234360",
    "end": "2249570"
  },
  {
    "text": "during each search. ",
    "start": "2249570",
    "end": "2257720"
  },
  {
    "text": "OK, this is the fun part. So, what does touched mean? I erased the model, but in\ngeneral with a binary search",
    "start": "2257720",
    "end": "2265205"
  },
  {
    "text": "tree, we only have one\npointer into the tree. It starts at the root, it\ncan go left, it can go right, it can go to the parent.",
    "start": "2265205",
    "end": "2271569"
  },
  {
    "text": "Every node that gets\nvisited during-- it can do rotations,\nevery node that gets visited by walking, that's\nwhat I call a touched node.",
    "start": "2271570",
    "end": "2281590"
  },
  {
    "text": "Just look at all of them. So for example,\nin this picture-- ",
    "start": "2281590",
    "end": "2291260"
  },
  {
    "text": "color-- suppose,\nmaybe we're lucky, and key three is at the root.",
    "start": "2291260",
    "end": "2297089"
  },
  {
    "text": "So that's the only\nthing I touch. If that's the case,\nwhen I access one,",
    "start": "2297090",
    "end": "2302772"
  },
  {
    "text": "it's definitely not the root. So, in particular, I definitely\nhave to have touched that node.",
    "start": "2302772",
    "end": "2309310"
  },
  {
    "text": "And I'm just going to fill\nin a reasonable choice.",
    "start": "2309310",
    "end": "2316370"
  },
  {
    "text": "I happen to know, this is\na valid binary search tree. Not so obvious, but\nyou can find one.",
    "start": "2316370",
    "end": "2322910"
  },
  {
    "text": "I'm using here, the\ngreedy algorithm actually, I'm cheating. We'll get to what that is.",
    "start": "2322910",
    "end": "2329460"
  },
  {
    "text": "But in general, some point\nsets, like this point set, are not valid. There's no binary search tree\nthat has this touch pattern.",
    "start": "2329460",
    "end": "2336020"
  },
  {
    "text": "You just can't jump\naround, teleport, without getting somewhere.",
    "start": "2336020",
    "end": "2341490"
  },
  {
    "text": "But, this one is valid. So, which ones are valid? Oh sorry I need one more point. ",
    "start": "2341490",
    "end": "2348726"
  },
  {
    "text": "Which ones are valid,\nwhich ones are invalid? How did I know that\nthat was invalid, and now this one is valid?",
    "start": "2348726",
    "end": "2354150"
  },
  {
    "text": "Well, there's a\ntheorem tell you. Then what I was just doing\nthere will become clear.",
    "start": "2354150",
    "end": "2359869"
  },
  {
    "start": "2359870",
    "end": "2376970"
  },
  {
    "text": "So, I want to know when is\nthe point set a valid BST execution, and I claim\nit is, if and only",
    "start": "2376970",
    "end": "2387849"
  },
  {
    "text": "if, in every rectangle\nspanned by two points",
    "start": "2387850",
    "end": "2407530"
  },
  {
    "text": "not on a common horizontal\nor vertical line,",
    "start": "2407530",
    "end": "2426160"
  },
  {
    "text": "in every rectangle, there\nthere's another point. ",
    "start": "2426160",
    "end": "2437710"
  },
  {
    "text": "So, let me draw a picture. I have some point set. We'll look at this\none in a moment.",
    "start": "2437710",
    "end": "2443200"
  },
  {
    "text": "In general, I take\nany two points that are not horizontally\nor vertically aligned, that spans a rectangle.",
    "start": "2443200",
    "end": "2450187"
  },
  {
    "text": "In other words, the\nrectangle with those two as opposite corners. There's got to be another\npoint in there, somewhere.",
    "start": "2450187",
    "end": "2456082"
  },
  {
    "text": "Could be on the boundary,\ncould be interior.  OK, in fact, you can\npump this a little bit.",
    "start": "2456082",
    "end": "2462770"
  },
  {
    "text": "So once I find some point,\nlet's say on the interior, then my picture looks like this.",
    "start": "2462770",
    "end": "2469480"
  },
  {
    "text": "Maybe I'll just\ndraw it as a circle. Well, here's another rectangle.",
    "start": "2469480",
    "end": "2474670"
  },
  {
    "text": "That one has to have\na point inside it. Here's another\nrectangle, that one has to have a point inside it.",
    "start": "2474670",
    "end": "2480410"
  },
  {
    "text": "You could keep going, until you\nknow maybe I'd put one here,",
    "start": "2480410",
    "end": "2485589"
  },
  {
    "text": "maybe I put one here. OK if I update the\npicture then, I still have a little\nrectangle like that,",
    "start": "2485590",
    "end": "2493410"
  },
  {
    "text": "little rectangle like that,\nlittle rectangle like this. At this point, this point\nis no longer involved",
    "start": "2493410",
    "end": "2498760"
  },
  {
    "text": "in any rectangles\nessentially, because there's no rectangle between\nthese two points because they're\nhorizontally aligned.",
    "start": "2498760",
    "end": "2505480"
  },
  {
    "text": "I could finish this off,\nfinally, by adding points,",
    "start": "2505480",
    "end": "2510490"
  },
  {
    "text": "let's say at the corners. Once I add points at the\ncorners this will be satisfied.",
    "start": "2510490",
    "end": "2515860"
  },
  {
    "text": "We call this property\narborally satisfied. Gotta look up the spelling.",
    "start": "2515860",
    "end": "2521770"
  },
  {
    "text": "Arboral satisfaction. Arboral means having\nto do with a tree.",
    "start": "2521770",
    "end": "2530170"
  },
  {
    "text": "OK, so this is saying that\npoint set is treelike, if it has this property.",
    "start": "2530170",
    "end": "2535570"
  },
  {
    "text": "OK this picture is\ngetting a little messy, but if I have any monotone path,\nlike this, this is satisfied.",
    "start": "2535570",
    "end": "2543460"
  },
  {
    "text": "If you look at any rectangle,\nsay this one, it has points-- other points in it.",
    "start": "2543460",
    "end": "2549170"
  },
  {
    "text": "OK, if I look at, I\ndon't know, this one, it has another point in it. But look at this one, that one\ndoesn't count because it's just",
    "start": "2549170",
    "end": "2555493"
  },
  {
    "text": "a vertical line. So it has to have non-zero area. If you look at any two\npoints, this one and this one,",
    "start": "2555493",
    "end": "2561970"
  },
  {
    "text": "they span a rectangle, there's\nanother point in there. So, monotone paths are good. This point set.",
    "start": "2561970",
    "end": "2567040"
  },
  {
    "text": "If I drew it correctly, is good. I look at any rectangle here,\nit's got another point in it.",
    "start": "2567040",
    "end": "2574480"
  },
  {
    "text": " Takes some practice to be able\nto see all the rectangles,",
    "start": "2574480",
    "end": "2582670"
  },
  {
    "text": "but check it. Eventually this one is good. This one's obviously bad. It has lots of wrecked-- we\ncall these empty rectangles,",
    "start": "2582670",
    "end": "2588940"
  },
  {
    "text": "unsatisfied rectangles, that\nhave no extra points in them. So, this is a valid BST\nexecution, this is not.",
    "start": "2588940",
    "end": "2595772"
  },
  {
    "text": "Let's prove this theorem\nit's actually not that hard. ",
    "start": "2595772",
    "end": "2611470"
  },
  {
    "text": "The consequence\nof the theorem, is it tells us what we need to do.",
    "start": "2611470",
    "end": "2617440"
  },
  {
    "text": "We are given a\npoint set like this, we want a point set like this.",
    "start": "2617440",
    "end": "2622960"
  },
  {
    "text": "We can define the cost\nof a binary search tree to be how many\nnodes does it touch.",
    "start": "2622960",
    "end": "2629640"
  },
  {
    "text": "That's within a constant factor\nof how many operations you do. If you don't want to,\nit's pointless to touch",
    "start": "2629640",
    "end": "2634920"
  },
  {
    "text": "a node more than a\nconstant number of times. You can prove that. So, really we just care about\nhow many nodes get touched.",
    "start": "2634920",
    "end": "2642060"
  },
  {
    "text": "So, what we want to do is find\na minimum superset of this point set that is satisfied.",
    "start": "2642060",
    "end": "2648150"
  },
  {
    "text": "We're given a set to\nrepresent or access sequence that is not satisfied. We need to act-- we need\nto touch those points.",
    "start": "2648150",
    "end": "2654000"
  },
  {
    "text": "That's the definition of search. And now we'd just like to also\ntouch some other points that",
    "start": "2654000",
    "end": "2659010"
  },
  {
    "text": "make it satisfied. This is a geometric\ninterpretation of dynamic opt.",
    "start": "2659010",
    "end": "2664050"
  },
  {
    "text": "Can you find the\noffline optimal, is-- what's the minimum\nnumber of points to add in order to make your\npoint set arborally satisfied.",
    "start": "2664050",
    "end": "2673560"
  },
  {
    "text": "We don't know whether\nthat problem is NP hard. Probably it is. We don't know how to compute it.",
    "start": "2673560",
    "end": "2680068"
  },
  {
    "text": "We don't know how to\nfind a constant factor approximation, unfortunately. Yeah?",
    "start": "2680069",
    "end": "2685881"
  },
  {
    "text": "AUDIENCE: So, this is for and\naccess sequence, so every time corresponds to just\nseeking like one",
    "start": "2685882",
    "end": "2693399"
  },
  {
    "text": "individually thing in the tree? PROFESSOR: Right. AUDIENCE: OK, that\nmakes more sense. PROFESSOR: Yes, so the input-- there is a unique\nthing, a key, that",
    "start": "2693399",
    "end": "2701370"
  },
  {
    "text": "gets accessed at each time. So if you draw any horizontal\nline, in the input point",
    "start": "2701370",
    "end": "2707250"
  },
  {
    "text": "set there's only one point\nin each horizontal line. There can be multiple points\nin each vertical line, which",
    "start": "2707250",
    "end": "2712680"
  },
  {
    "text": "would mean that key gets\naccessed more than one time. That's the obvious\ninterpretation terms of binary search tree, turns\nout you don't need to assume",
    "start": "2712680",
    "end": "2719435"
  },
  {
    "text": "either of those things. You could allow a\nsort of multi-search, where I say during this round\nyou have to access key 5 and 7,",
    "start": "2719435",
    "end": "2726870"
  },
  {
    "text": "I don't care in what order. Whereas normally I say,\nyou have access key 5, then you have to access key 7.",
    "start": "2726870",
    "end": "2732544"
  },
  {
    "text": "You could do a\nmulti-search, where there's multiple\npoints in a single row. All of the things I'll say\nwork, it doesn't really",
    "start": "2732544",
    "end": "2739260"
  },
  {
    "text": "make a difference as the claim. You could also assume that no\nkey is accessed more than once,",
    "start": "2739260",
    "end": "2745740"
  },
  {
    "text": "so then there's only one-- those would be the\nopposite extreme. You can assume there's\nonly one key per column.",
    "start": "2745740",
    "end": "2751809"
  },
  {
    "text": "That turns out not to\nmake much difference. If there's multiple keys\nin the same position, just spread them out\na little and you'll",
    "start": "2751809",
    "end": "2758220"
  },
  {
    "text": "get roughly the same cost. So, good question. But in the natural\ninterpretation",
    "start": "2758220",
    "end": "2763560"
  },
  {
    "text": "there's one per row,\nmultiple per column, but it doesn't,\nneither one matters. ",
    "start": "2763560",
    "end": "2769855"
  },
  {
    "text": "OK.  So this becomes the problem,\ngo from this to this,",
    "start": "2769855",
    "end": "2777359"
  },
  {
    "text": "with a minimum number\nof added points. We do know a log log n\napproximation to that problem.",
    "start": "2777360",
    "end": "2784130"
  },
  {
    "text": "That's the best we know. You just take this\nbinary search tree, and apply this transformation,\nand it tells you",
    "start": "2784130",
    "end": "2793170"
  },
  {
    "text": "if you have a\nbinary search tree, you can turn it into a way\nto satisfy a point set. But this is actually the\nbest approximation algorithm",
    "start": "2793170",
    "end": "2799230"
  },
  {
    "text": "that we know. But as you'll see, the geometric\nview offers a lot of insight. Gives us a lot of\npower, and in some sense",
    "start": "2799230",
    "end": "2805870"
  },
  {
    "text": "we use it to construct this. OK, so let's prove the theorem.",
    "start": "2805870",
    "end": "2813484"
  },
  {
    "start": "2813485",
    "end": "2821360"
  },
  {
    "text": "So there's two directions. We'll start with\nthe easy direction. If you have a\nbinary search tree,",
    "start": "2821360",
    "end": "2826619"
  },
  {
    "text": "then it must be\narborally satisfied. Then we'll have\nto do the reverse, actually build a binary search\ntree out of a point set.",
    "start": "2826620",
    "end": "2833190"
  },
  {
    "text": "That's kind of the harder step. So, let's say we\nhave two points.",
    "start": "2833190",
    "end": "2839670"
  },
  {
    "text": " Let's say this is that\ntime i, we access key x,",
    "start": "2839670",
    "end": "2847860"
  },
  {
    "text": "and this one is at time\nj, we access key y. Let's suppose y\nis greater than x,",
    "start": "2847860",
    "end": "2853340"
  },
  {
    "text": "there's the symmetric picture. We want to argue that\nthere is some other point in this rectangle.",
    "start": "2853340",
    "end": "2862010"
  },
  {
    "text": "OK, here's the plan, let a be\nthe lowest common ancestor of x",
    "start": "2862010",
    "end": "2871050"
  },
  {
    "text": "and y. x is a key, y is a key,\nthey are nodes in the tree.",
    "start": "2871050",
    "end": "2877109"
  },
  {
    "text": "This is a changing quantity. As the tree wiggles\naround those rotations, the least common\nancestor changes.",
    "start": "2877110",
    "end": "2882830"
  },
  {
    "text": "But at every time,\nthere is, it has some of these common ancestor. Might be x, might be y,\nmight be some other node.",
    "start": "2882830",
    "end": "2890250"
  },
  {
    "text": "OK? I want to look at\na couple of things. ",
    "start": "2890250",
    "end": "2897460"
  },
  {
    "text": "Let's say, right before\nx is touched at time i,",
    "start": "2897460",
    "end": "2914200"
  },
  {
    "text": "or I guess right before time i\nwould be the proper phrasing. ",
    "start": "2914200",
    "end": "2921970"
  },
  {
    "text": "So we're at this moment, I\nwant to know does a equal x?",
    "start": "2921970",
    "end": "2927250"
  },
  {
    "text": " If a does not equal\nx, then I'm going",
    "start": "2927250",
    "end": "2938090"
  },
  {
    "text": "to use the point a comma i. OK? Least common ancestor has the\nproperty that x is less than",
    "start": "2938090",
    "end": "2947870"
  },
  {
    "text": "or equal to a, is less\nthan or equal to y. Common ancestor,\nleast common ancestor will be between x and y.",
    "start": "2947870",
    "end": "2955760"
  },
  {
    "text": "And we also know that\nit's an ancestor of x, and it's an ancestor of y. So, if you're going to\ntouch x, you must touch a.",
    "start": "2955760",
    "end": "2962550"
  },
  {
    "text": "If you're going to touch\ny, you must touch a. So a comma i is going to\nbe some point here, which",
    "start": "2962550",
    "end": "2970520"
  },
  {
    "text": "is what we need. Except, if a equals x, sorry,\nwhat the heck did I do?",
    "start": "2970520",
    "end": "2981079"
  },
  {
    "text": "Transposed again. OK, this is time i, time\nj, x, y, sorry about that.",
    "start": "2981080",
    "end": "2989748"
  },
  {
    "text": "OK, here's time i, here is a. So, if a does not equal\nx, we know at time i,",
    "start": "2989748",
    "end": "2999035"
  },
  {
    "text": "we must access\nall ancestor of x, we must touch all ancestors\nof x, before we touch x. Therefore, this is\na point and we're",
    "start": "2999035",
    "end": "3006130"
  },
  {
    "text": "done, unless a equals\nx at this time, because then it's\nthe same point. We didn't get a third\npoint, we at least",
    "start": "3006130",
    "end": "3012336"
  },
  {
    "text": "need to find some different\npoint other than these two. OK, so that would be good.",
    "start": "3012336",
    "end": "3017619"
  },
  {
    "text": "We can-- so it must actually be\nthat at this time, at time i,",
    "start": "3017620",
    "end": "3023140"
  },
  {
    "text": "a is right here. Let's then look at time j. ",
    "start": "3023140",
    "end": "3032110"
  },
  {
    "text": "Same deal, at time j,\nhere's y that gets access. We must also access a.",
    "start": "3032110",
    "end": "3038620"
  },
  {
    "text": "Now it could be its equal to y,\nor it could be somewhere else. It could be here, or\ncould be still here.",
    "start": "3038620",
    "end": "3045250"
  },
  {
    "text": "In those cases we're\nhappy, but this one also could have been at the corner.",
    "start": "3045250",
    "end": "3051190"
  },
  {
    "text": "The case we're not happy is when\nb equals x, sorry, a equals y.",
    "start": "3051190",
    "end": "3057700"
  },
  {
    "text": "Getting my letters mixed up. As long as a does\nnot equal y, then we can use the point a\ncomma j, that must be,",
    "start": "3057700",
    "end": "3065512"
  },
  {
    "text": "these are always\nin your execution, and if a does not equal y, then\nwe're, that's a third point and we're done.",
    "start": "3065512",
    "end": "3073130"
  },
  {
    "text": "So we're left with one more\ncase, which is that at time i, a is here, here's a, and\nat time j, a is here.",
    "start": "3073130",
    "end": "3085450"
  },
  {
    "text": "Question is, what\nhappened in between? a changed. ",
    "start": "3085450",
    "end": "3092130"
  },
  {
    "text": "For a to change, something\nin here has to get rotated.",
    "start": "3092130",
    "end": "3097559"
  },
  {
    "text": "That's the [? clam. ?] I mean\nhere's the picture, you have a, actually-- picture is\nat the beginning a is x.",
    "start": "3097560",
    "end": "3106890"
  },
  {
    "text": "So, here we have x, and then\ny is an ancestor, sorry,",
    "start": "3106890",
    "end": "3111960"
  },
  {
    "text": "y is a descendant of\nx, because this is a. And then somehow we\nhave to transition",
    "start": "3111960",
    "end": "3117150"
  },
  {
    "text": "to the reverse picture,\nwhich is that y is the least common ancestor, x.",
    "start": "3117150",
    "end": "3123550"
  },
  {
    "text": "And for this to happen, somebody\nhere has to get rotated. I guess, in particular x.",
    "start": "3123550",
    "end": "3130500"
  },
  {
    "text": "At some point x had to\novertake y, had to be moved up.",
    "start": "3130500",
    "end": "3136120"
  },
  {
    "text": "So, at some point x was\nrotated, and that would correspond to a point here. ",
    "start": "3136120",
    "end": "3143030"
  },
  {
    "text": "So else x must be\nrotated at some time",
    "start": "3143030",
    "end": "3152310"
  },
  {
    "text": "k, where k is between i and j. ",
    "start": "3152310",
    "end": "3167710"
  },
  {
    "text": "And if we set it up right, I\nguess because here a was still x, and here a is y, then it\nmust be strictly between.",
    "start": "3167710",
    "end": "3180339"
  },
  {
    "text": " Maybe like this would\nbe what we want.",
    "start": "3180340",
    "end": "3186250"
  },
  {
    "text": " And so then we use\nthe point k comma x.",
    "start": "3186250",
    "end": "3193620"
  },
  {
    "start": "3193620",
    "end": "3199886"
  },
  {
    "text": "Is that more or less clear?  This was the easy case.",
    "start": "3199886",
    "end": "3205480"
  },
  {
    "text": " I guess it depends\nwhat you consider easy.",
    "start": "3205480",
    "end": "3210790"
  },
  {
    "text": "Here we're just, we're\ngiven a search tree and the short version is, look\nat the least common ancestor.",
    "start": "3210790",
    "end": "3218810"
  },
  {
    "text": "It's got to move around at\nsome point, or not, either way you're happy.",
    "start": "3218810",
    "end": "3224450"
  },
  {
    "text": "So the least common\nancestor gives you the points you care about. So for that we just needed the\nleast common ancestor idea.",
    "start": "3224450",
    "end": "3231819"
  },
  {
    "text": "For the other\ndirection, if we're given a point set\nthat corresponds to, that has this\nsatisfaction property,",
    "start": "3231820",
    "end": "3238510"
  },
  {
    "text": "we have to somehow build from\nscratch a binary search tree. How the heck are we going to\nbuild a binary search tree?",
    "start": "3238510",
    "end": "3244540"
  },
  {
    "text": "Well, with treaps. ",
    "start": "3244540",
    "end": "3277369"
  },
  {
    "text": "So, this is the other direction. ",
    "start": "3277370",
    "end": "3286520"
  },
  {
    "text": "Treap is a portmanteau\nof tree and heap.",
    "start": "3286520",
    "end": "3292356"
  },
  {
    "text": "Underline it\ncorrectly, tree, heap. So, it's simultaneously a binary\nsearch tree and a min heap,",
    "start": "3292356",
    "end": "3301160"
  },
  {
    "text": "in this case. It's a binary search tree\nbecause it has to be. It's a binary search\ntree on the keys.",
    "start": "3301160",
    "end": "3307790"
  },
  {
    "text": "It's going to be heap on\na different set of values. So, binary search tree on\nthe keys, and it's heap",
    "start": "3307790",
    "end": "3322400"
  },
  {
    "text": "ordered, min heap\nordered, by next access.",
    "start": "3322400",
    "end": "3332420"
  },
  {
    "text": " I didn't say I was going to\ngive you an online algorithm,",
    "start": "3332420",
    "end": "3338000"
  },
  {
    "text": "this is an offline algorithm. So it looks-- if\nI look at a key,",
    "start": "3338000",
    "end": "3344060"
  },
  {
    "text": "and it's going to be accessed\nnext, it better be at the root. Next access will\nalways be at the root,",
    "start": "3344060",
    "end": "3350730"
  },
  {
    "text": "if you're heap ordered. If you're a min\nheap by next access. This is great, that\nmeans the thing you're",
    "start": "3350730",
    "end": "3356150"
  },
  {
    "text": "searching for is\nalways at the root, and it's basically\nfree to touch. But you may choose\nto touch other nodes.",
    "start": "3356150",
    "end": "3363295"
  },
  {
    "text": "And in fact, we're told\nhow to touch notes. We're given a pattern\nthat says, well, at this time you have-- you\nwill touch this node, this node,",
    "start": "3363295",
    "end": "3370820"
  },
  {
    "text": "and this node. By that definition, this\none will be at the root,",
    "start": "3370820",
    "end": "3376437"
  },
  {
    "text": "but you're going to\ntouch these nodes, and possibly you\ncould rotate them. Change the tree.",
    "start": "3376437",
    "end": "3382460"
  },
  {
    "text": "You'll have to, actually,\nbecause next access time is constantly changing. And as soon as you\naccess an item,",
    "start": "3382460",
    "end": "3388490"
  },
  {
    "text": "it's next access goes in\nsometime in the future, possibly infinity, and so you'd\nlike to start pushing it down",
    "start": "3388490",
    "end": "3394010"
  },
  {
    "text": "in the tree.  So, what we need to\ndo is show that we",
    "start": "3394010",
    "end": "3399420"
  },
  {
    "text": "can maintain-- it's always going\nto be a binary search tree, because we only do rotations. We have to somehow use rotations\nto maintain this heap order",
    "start": "3399420",
    "end": "3406480"
  },
  {
    "text": "property, and only touch\nthe nodes that we're",
    "start": "3406480",
    "end": "3412240"
  },
  {
    "text": "supposed to touch. That's the challenge.",
    "start": "3412240",
    "end": "3417380"
  },
  {
    "text": "So, I should mention, this is\nnot a uniquely defined tree. Usually treaps are unique,\nif you specify a key order,",
    "start": "3417380",
    "end": "3425440"
  },
  {
    "text": "and you specify a\nheap order, there is exactly one tree that\nsatisfies both of them.",
    "start": "3425440",
    "end": "3430840"
  },
  {
    "text": "But here it's not quite\nunique, because the next access time-- there are many keys that\nare going, sorry, next touch.",
    "start": "3430840",
    "end": "3437210"
  },
  {
    "text": " Next touch time.",
    "start": "3437210",
    "end": "3443020"
  },
  {
    "text": "So, for example, at this\nmoment all three of these nodes",
    "start": "3443020",
    "end": "3449410"
  },
  {
    "text": "are going to be accessed\nat the same time. And so you don't\nknow, or I'm not",
    "start": "3449410",
    "end": "3454975"
  },
  {
    "text": "specifying how they're supposed\nto be heap ordered in the tree. Just break ties arbitrarily,\nit doesn't matter.",
    "start": "3454975",
    "end": "3461270"
  },
  {
    "text": "OK. So, let's look at a time i.",
    "start": "3461270",
    "end": "3473800"
  },
  {
    "text": "When we reach that\ntime i, the nodes to touch form and connected\nsubtree containing the root.",
    "start": "3473800",
    "end": "3490265"
  },
  {
    "text": " Because according to\nheap order, they're all,",
    "start": "3490266",
    "end": "3495820"
  },
  {
    "text": "they all want to be at the root. So we break ties arbitrarily,\nsomehow, you know all the nodes",
    "start": "3495820",
    "end": "3503440"
  },
  {
    "text": "that we're supposed to touch,\nlive in some connected subtree of the root.",
    "start": "3503440",
    "end": "3510300"
  },
  {
    "text": "Sorry, some connected\nsubtree containing the root. Everything down here has\na later next touch time,",
    "start": "3510300",
    "end": "3520420"
  },
  {
    "text": "and so they're below, by\ndefinition of heap order. OK, now one of these is the\none we actually want to access.",
    "start": "3520420",
    "end": "3527729"
  },
  {
    "text": "But we need to touch all of\nthem, so touch all of them, you know, navigate. Walk left, right, whatever. The big question is, what\nshould we change this tree into?",
    "start": "3527729",
    "end": "3535359"
  },
  {
    "text": "I'd like to change it to\nsome other top structure.",
    "start": "3535360",
    "end": "3541930"
  },
  {
    "text": "I can't touch\nanything down here, I'm only allowed to\ntouch these points. I only want to\nrotate these somehow.",
    "start": "3541930",
    "end": "3549507"
  },
  {
    "text": "There's a convenient\ntheorem, if you have one tree and you want to convert\nit into another, you can always do it in a\nlinear number of rotations.",
    "start": "3549507",
    "end": "3555970"
  },
  {
    "text": "So, rotations are basically\nfree and this model, it's just about how\nmany nodes we touch. We're told which nodes to touch.",
    "start": "3555970",
    "end": "3562270"
  },
  {
    "text": "We want to somehow rearrange\nthem to restore this heap order property. Right? As soon as we touch\nall these nodes,",
    "start": "3562270",
    "end": "3568090"
  },
  {
    "text": "their next touch time will\nbe sometime in the future. We need to rearrange the\ntree to still be heap ordered",
    "start": "3568090",
    "end": "3574700"
  },
  {
    "text": "by that new next touch time.  OK, here's what we do.",
    "start": "3574700",
    "end": "3582250"
  },
  {
    "text": " I mean there's only\none thing to do. ",
    "start": "3582250",
    "end": "3589869"
  },
  {
    "text": "Rearrange those nodes in\nthis connected subtree to be a local treap by\nthe new next touch time.",
    "start": "3589870",
    "end": "3604240"
  },
  {
    "text": "These are the only nodes to\nget a new next touch time,",
    "start": "3604240",
    "end": "3611680"
  },
  {
    "text": "so it's more or less unique\nhow to rearrange them. Do that.",
    "start": "3611680",
    "end": "3617260"
  },
  {
    "text": "Now the hard part is to argue\nthat the whole thing is now a treap. ",
    "start": "3617260",
    "end": "3624140"
  },
  {
    "text": "Why was it enough to\nonly modify these nodes?",
    "start": "3624140",
    "end": "3629210"
  },
  {
    "text": "Maybe you set one of these nodes\nto have a very large next touch time, so it's got to be\nreally deep down there.",
    "start": "3629210",
    "end": "3635199"
  },
  {
    "text": "And you can't afford to push it\ndown deep, because you're not allowed to touch\nany of these nodes.",
    "start": "3635199",
    "end": "3640200"
  },
  {
    "text": "Looks worrisome, but\nturns out, it just works. ",
    "start": "3640200",
    "end": "3647390"
  },
  {
    "text": "So, if there were a failure,\npicture would be like this.",
    "start": "3647390",
    "end": "3655349"
  },
  {
    "text": "We rearrange these nodes\nperfectly, in particular, let's look at some\nnode x that has a child",
    "start": "3655350",
    "end": "3661720"
  },
  {
    "text": "y, that was not touched. So x was touched, all of\nit's ancestors were touched, but y was not touched.",
    "start": "3661720",
    "end": "3669390"
  },
  {
    "text": "So we know that the\nnext touch time of x is greater than or equal to the\nnext touch time of its parent,",
    "start": "3669390",
    "end": "3675450"
  },
  {
    "text": "of it's ancestor,\nup to the root. The worry would be that\nthe next touch time of x",
    "start": "3675450",
    "end": "3680850"
  },
  {
    "text": "is greater than the\nnext touch time of y. So suppose next touch of x is\ngreater than next touch of y.",
    "start": "3680850",
    "end": "3698802"
  },
  {
    "text": "This would be a problem, because\nthen you would not be a heap. ",
    "start": "3698802",
    "end": "3706000"
  },
  {
    "text": "So, claim is we get an\nunsatisfied rectangle",
    "start": "3706000",
    "end": "3737850"
  },
  {
    "text": "based on x and it's next touch\ntime, and y and it's next touch time. So let's draw the picture.",
    "start": "3737850",
    "end": "3744030"
  },
  {
    "text": "Here's time, here's\nspace, I'm going",
    "start": "3744030",
    "end": "3750540"
  },
  {
    "text": "to assume by symmetry x\nis to the left of y and [? keyspace, ?] and\nnow we're supposing",
    "start": "3750540",
    "end": "3758970"
  },
  {
    "text": "the next touch time of y is\nearlier than the next touch time of x. So it looks like this.",
    "start": "3758970",
    "end": "3765820"
  },
  {
    "text": "So this is next touch time of\nx, this is the next time of y,",
    "start": "3765820",
    "end": "3773730"
  },
  {
    "text": "and I claim that there are\nno other points in here.",
    "start": "3773730",
    "end": "3780041"
  },
  {
    "text": "That would be a contradiction,\nbecause we assume that the thing is satisfied. ",
    "start": "3780041",
    "end": "3790650"
  },
  {
    "text": "To prove this, I need to go back\na little bit to the definition,",
    "start": "3790650",
    "end": "3796349"
  },
  {
    "text": "over here.  There are actually a\ncouple of different ways",
    "start": "3796350",
    "end": "3802830"
  },
  {
    "text": "to think about satisfaction,\nwhich I was getting at here, but I didn't solidify.",
    "start": "3802830",
    "end": "3808140"
  },
  {
    "text": "So, I said OK, if\nyou have two points and that rectangle\nis satisfied, there is some point, possibly in the\ninterior, in that rectangle.",
    "start": "3808140",
    "end": "3815980"
  },
  {
    "text": "But if it's interior,\nthen I can keep going. If I keep going, in the end I\ncan conclude that not only is",
    "start": "3815980",
    "end": "3825840"
  },
  {
    "text": "this rectangle\nnon-empty, but there has to be a point on\none of these two sides,",
    "start": "3825840",
    "end": "3832880"
  },
  {
    "text": "because if I choose\nany other point, I get a smaller rectangle. Eventually, I have to get one\non one of those two sides.",
    "start": "3832880",
    "end": "3838859"
  },
  {
    "text": "Could be at the\ncorner, or this corner, but one of those two sides\nhas to have a point on it. Also, one of these two sides\nhas to have a point on it.",
    "start": "3838860",
    "end": "3846789"
  },
  {
    "text": "It could be both of\nthese constraints are met at once by having\none point in the corner.",
    "start": "3846789",
    "end": "3852300"
  },
  {
    "text": "Well that's a somewhat stronger\nformulation, but equivalent formulation of the\nsatisfaction property.",
    "start": "3852300",
    "end": "3858120"
  },
  {
    "text": "So in particular over\nhere, it should be the case",
    "start": "3858120",
    "end": "3863160"
  },
  {
    "text": "that there's a point,\neither here or here, and there should be a\npoint, either here or here.",
    "start": "3863160",
    "end": "3868410"
  },
  {
    "text": "I claim that one of\nthose is violated. ",
    "start": "3868410",
    "end": "3885649"
  },
  {
    "text": "You think I'd know this stuff,\nI wrote the paper, but--  it's all these subtle\ndetails, easy to get wrong.",
    "start": "3885649",
    "end": "3894089"
  },
  {
    "text": "I think what I want\nto look at is, now,",
    "start": "3894090",
    "end": "3900040"
  },
  {
    "text": "which is the moment we're\ndrawing this diagram, versus the next time of y.",
    "start": "3900040",
    "end": "3906010"
  },
  {
    "text": "Sorry, so this is x comma now. ",
    "start": "3906010",
    "end": "3911354"
  },
  {
    "text": "That's what my diagram\nlooks like there, so I think that's what I mean. So ignore this picture. ",
    "start": "3911354",
    "end": "3920190"
  },
  {
    "text": "What we learn, what we know\nis the next access to x, is sometime in the future.",
    "start": "3920190",
    "end": "3925194"
  },
  {
    "text": "That's what we're told here. Next touch of x is greater\nthan next touch of y.",
    "start": "3925194",
    "end": "3930460"
  },
  {
    "text": "So next touch of x is up here,\nwhich means this is empty.",
    "start": "3930460",
    "end": "3935580"
  },
  {
    "text": "OK, if that's empty,\nthis better not be empty. All right that's what we\nclaim, one of these two",
    "start": "3935580",
    "end": "3942010"
  },
  {
    "text": "has to have a point in it. This one's empty, so\nthis better not be empty,",
    "start": "3942010",
    "end": "3947440"
  },
  {
    "text": "but I claim this is empty. Suppose it's not, suppose it\nis, suppose it's not empty--",
    "start": "3947440",
    "end": "3953401"
  },
  {
    "text": "Wait, no, one of these. Suppose it's not empty, should\nbe the correct scenario.",
    "start": "3953401",
    "end": "3960849"
  },
  {
    "text": "Look at the left most\npoint in this range. ",
    "start": "3960850",
    "end": "3969960"
  },
  {
    "text": "This guy. ",
    "start": "3969960",
    "end": "3975620"
  },
  {
    "text": "It's a point between x and\ny, in terms of key value. So, in this picture,\nwhere could it be?",
    "start": "3975620",
    "end": "3983870"
  },
  {
    "text": "Where are the points between\nx and y in this diagram?",
    "start": "3983870",
    "end": "3989470"
  },
  {
    "text": "They have to be in\nthe left subtree of y. Right? The only points in a binary\nsearch-- if x and y are--",
    "start": "3989470",
    "end": "3994827"
  },
  {
    "text": "if y is a child of x, the\nonly points in the binary tree that are between x and y,\nor the left subtree of y,",
    "start": "3994827",
    "end": "4000640"
  },
  {
    "text": "or there's a symmetric case,\nbut in this picture left subtree of y. But I put an x here.",
    "start": "4000640",
    "end": "4005970"
  },
  {
    "text": "That means that whoever\nwe're looking at, some point between x and y,\nhas to be in this top tree.",
    "start": "4005970",
    "end": "4012760"
  },
  {
    "text": "Contradiction, done, OK? If this guy is in there,\nthen y was also in there,",
    "start": "4012760",
    "end": "4018130"
  },
  {
    "text": "which meant there\nwas a point here, and that's what we're\nassuming did not happen.",
    "start": "4018130",
    "end": "4023470"
  },
  {
    "text": "This is supposed\nto be an interface between inside the\nset of touched nodes, and outside the set\nof touched nodes.",
    "start": "4023470",
    "end": "4030740"
  },
  {
    "text": "So there can't be\nany points in here, which means this is empty, which\nmeans you weren't satisfied.",
    "start": "4030740",
    "end": "4037686"
  },
  {
    "text": "OK, maybe I should\nwrite down the words to go with that argument, but-- ",
    "start": "4037686",
    "end": "4045680"
  },
  {
    "text": "So, this part is empty by\nnext touch of x being greater",
    "start": "4045680",
    "end": "4054770"
  },
  {
    "text": "than next touch of y. And this part is empty\nelse, or it's empty",
    "start": "4054770",
    "end": "4065180"
  },
  {
    "text": "because any key\nbetween x and y is",
    "start": "4065180",
    "end": "4083960"
  },
  {
    "text": "in the left subtree of\ny, which would imply",
    "start": "4083960",
    "end": "4098189"
  },
  {
    "text": "if it's touched then so is y.",
    "start": "4098189",
    "end": "4108930"
  },
  {
    "text": "But y cannot be\ntouched, by assumption. So that's the end of that proof.",
    "start": "4108930",
    "end": "4114960"
  },
  {
    "text": "A little bit longer,\nbut hopefully it's pretty clear at this point. Question?",
    "start": "4114960",
    "end": "4120777"
  },
  {
    "text": "AUDIENCE: Can't\nthere be something like a descendent of x,\nbut an ancestor of y,",
    "start": "4120778",
    "end": "4125810"
  },
  {
    "text": "instead of being in\na subtree with y? PROFESSOR: Would,\nso you could say it could be in between here.",
    "start": "4125810",
    "end": "4131883"
  },
  {
    "text": "It could be a descendant\nof x, but an ancestor of y, but we're assuming here that\nthis was a child relation. y was a child of x.",
    "start": "4131884",
    "end": "4138310"
  },
  {
    "text": "This was a-- I didn't say that\nat the beginning. On a claim that's a\nglobal treap, if it's not",
    "start": "4138310",
    "end": "4143410"
  },
  {
    "text": "a global treap, there is\nsome edge that's violated, that does not have\nheap order property. So assuming this was\nan edge, x is OK,",
    "start": "4143410",
    "end": "4151179"
  },
  {
    "text": "it was in the local\ntreap, y somehow is going to be bad, because\nit's next touch time was, should be higher.",
    "start": "4151180",
    "end": "4156970"
  },
  {
    "text": "Should be above. Other question? AUDIENCE: So that\n[INAUDIBLE] you drew, and all the everything in that\nsubtree root that gets taken",
    "start": "4156970",
    "end": "4165980"
  },
  {
    "text": "to-- Like the picture on\nthe right is also, it's the same subtree right? But after you change\ntheir [INAUDIBLE]",
    "start": "4165980",
    "end": "4172479"
  },
  {
    "text": "PROFESSOR: These two subtrees\nhave the same set of nodes, they've just been\nrotated somehow. AUDIENCE: OK, but then\nhow do you-- but didn't",
    "start": "4172479",
    "end": "4178925"
  },
  {
    "text": "we change the next touch times\nof all the nodes in there? So how you do know if\nthe root is still going to be some guy in that subtree?",
    "start": "4178926",
    "end": "4185420"
  },
  {
    "text": " PROFESSOR: Buy this argument. So the question is\nsay, after we do this,",
    "start": "4185420",
    "end": "4193339"
  },
  {
    "text": "we make some root,\nwhich is going, the root is going to\nbe among all the nodes that just got touched now, who\nis going to be touched next?",
    "start": "4193340",
    "end": "4202280"
  },
  {
    "text": "That's who we put at the root. And the claim is, that\nis globally the node that will be touched next.",
    "start": "4202280",
    "end": "4208099"
  },
  {
    "text": "Why? By this argument. If there were some other node\ndown here that has a smaller",
    "start": "4208100",
    "end": "4215360"
  },
  {
    "text": "next access time, then-- ",
    "start": "4215360",
    "end": "4222947"
  },
  {
    "text": "but we know that it was\nheap ordered before, so all of these guys\nare heap ordered. So, this guy would\nthen have the minimum.",
    "start": "4222947",
    "end": "4228680"
  },
  {
    "text": "And then we look\nat that interface, and the claim is by the\nsatisfaction property, actually this point should\nhave been in the set.",
    "start": "4228680",
    "end": "4235305"
  },
  {
    "text": "So, what this tells\nyou is the guy that has to be accessed\nnext, in particular, must be in your set.",
    "start": "4235306",
    "end": "4241340"
  },
  {
    "text": "Must be touched now. ",
    "start": "4241340",
    "end": "4246949"
  },
  {
    "text": "Kind of magical. Well actually, it's because\nthey're tie-breaking I think, that this works out.",
    "start": "4246950",
    "end": "4253690"
  },
  {
    "text": "Anyway, another question? AUDIENCE: So, like when you're\nrearranging the [INAUDIBLE]",
    "start": "4253690",
    "end": "4259406"
  },
  {
    "text": "in the sort of subtree\non top [INAUDIBLE]",
    "start": "4259406",
    "end": "4264800"
  },
  {
    "text": "PROFESSOR: Yeah, we're\ndoing this transformation of the top tree into the\nlocal tree by rotations. I mentioned--",
    "start": "4264800",
    "end": "4269930"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]\nIt's always-- PROFESSOR: Right,\nso we're staying within the binary search tree\nmodel, and in particular then",
    "start": "4269930",
    "end": "4276548"
  },
  {
    "text": "we stay a binary search tree. So, we can't mess things up. And there's a nice theorem that\nif you have two binary search trees on the same,\nkeys there's a way",
    "start": "4276548",
    "end": "4283000"
  },
  {
    "text": "to get there with the\nlinear number of rotates, so that's for free.",
    "start": "4283000",
    "end": "4288130"
  },
  {
    "text": "So, our new cost model\nis just to count points. The cost of this access is\none, the cost of this access",
    "start": "4288130",
    "end": "4294580"
  },
  {
    "text": "is two, two, three. If we just count how\nmany nodes are touched,",
    "start": "4294580",
    "end": "4300369"
  },
  {
    "text": "then the cost of the\nbinary search tree is equal to the cost of\nthe minimum satisfied",
    "start": "4300370",
    "end": "4308829"
  },
  {
    "text": "superset of your point. So this is the problem now. Sadly we don't know how\nto solve the problem.",
    "start": "4308830",
    "end": "4316389"
  },
  {
    "text": "We do know some things. I don't think I'll go\nthrough an example of this,",
    "start": "4316390",
    "end": "4323822"
  },
  {
    "text": "it's not very exciting. You could run\nthrough this picture, and see how the binary\n[? structure ?] changes.",
    "start": "4323822",
    "end": "4330250"
  },
  {
    "text": "Actually the binary\n[? structure ?] won't change it all here, so\nit's a little anticlimactic of an example. You can see it in the notes.",
    "start": "4330250",
    "end": "4338199"
  },
  {
    "text": "I want to get to the greedy\nalgorithm, so let's go here.",
    "start": "4338200",
    "end": "4345540"
  },
  {
    "start": "4345540",
    "end": "4354850"
  },
  {
    "text": "Last bullet. ",
    "start": "4354850",
    "end": "4394860"
  },
  {
    "text": "The idea is to imagine\nyour points are added one at a time, bottom up.",
    "start": "4394860",
    "end": "4400700"
  },
  {
    "text": " So I'm going to do\nthe same example. First we add this point.",
    "start": "4400700",
    "end": "4407780"
  },
  {
    "text": "That's a satisfied set, done. In general add necessary points\non the same row as the search.",
    "start": "4407780",
    "end": "4430230"
  },
  {
    "text": "OK, there's nothing to add here. Next point we add is over here. I've got the orientation\ncorrect, yeah.",
    "start": "4430230",
    "end": "4436170"
  },
  {
    "text": "So this was three, this was one. Is this satisfied? No, there's a bad\nrectangle here.",
    "start": "4436170",
    "end": "4442937"
  },
  {
    "text": "There's two obvious ways\nto satisfy the rectangle, I could add a point here,\nor I could add a point here. I'm going to add a point\nhere, because that's the row,",
    "start": "4442937",
    "end": "4449800"
  },
  {
    "text": "this is current time. OK, it's like a\nsweep line algorithm. We go up, next\npoint is over here.",
    "start": "4449800",
    "end": "4458720"
  },
  {
    "text": "That's the Next\nposition to sweep line. Now there's a bad rectangle. We fix it by adding this point.",
    "start": "4458721",
    "end": "4464420"
  },
  {
    "text": " Now we're good, all\nrectangles are satisfied.",
    "start": "4464420",
    "end": "4469949"
  },
  {
    "text": "Next level is,\nthere's a point here. Now there's two bad rectangles.",
    "start": "4469950",
    "end": "4475440"
  },
  {
    "text": "This one, I'm going\nto add a point here, and this one, I'm going\nto add a point here.",
    "start": "4475440",
    "end": "4480976"
  },
  {
    "text": " Now we're good.",
    "start": "4480976",
    "end": "4486620"
  },
  {
    "text": "And that should be\nwhat I did here. Yeah. ",
    "start": "4486620",
    "end": "4492619"
  },
  {
    "text": "So that's how I\nfound that point set, and in general claim is\nthis is a good algorithm. It seems, in fact,\npretty obvious.",
    "start": "4492619",
    "end": "4501320"
  },
  {
    "text": "There was a choice of\ncourse, we could satisfy this corner or this corner. Or some monotone\npath in between.",
    "start": "4501320",
    "end": "4509330"
  },
  {
    "text": "But the claim would be that-- ",
    "start": "4509330",
    "end": "4515510"
  },
  {
    "text": "doesn't make that\nbig a difference. Doing things later\nis always better. It's kind of a lazy property.",
    "start": "4515510",
    "end": "4520550"
  },
  {
    "text": "Or you could think of this-- Originally actually\nthis algorithm goes back in tree land.",
    "start": "4520550",
    "end": "4526159"
  },
  {
    "text": "And in tree land, if you follow\nthrough this reduction, which we did, you know\nif you convert this into a treap, what\nthis is saying is,",
    "start": "4526160",
    "end": "4533750"
  },
  {
    "text": "look you search for an\nitem, you follow a path. Take all the nodes on\nthe path that you follow,",
    "start": "4533750",
    "end": "4539150"
  },
  {
    "text": "rearrange them optimally\nfor the future, build a heap based on the next\naccess time, next touch time,",
    "start": "4539150",
    "end": "4545690"
  },
  {
    "text": "whenever that happens to be. Next access time\nactually, in that case.",
    "start": "4545690",
    "end": "4551060"
  },
  {
    "text": "That is equivalent\nto this algorithm. That seems like the right\nthing to do offline.",
    "start": "4551060",
    "end": "4557457"
  },
  {
    "text": "You visit your item, you do the\nminimum amount you have to do, which is following\nthe search path. You rearrange those items to\nbe optimal for the future.",
    "start": "4557457",
    "end": "4564590"
  },
  {
    "text": "It's an offline algorithm,\nseems like a really good one. The only thing\nit's missing out on is maybe you should\ngo off the path",
    "start": "4564590",
    "end": "4570920"
  },
  {
    "text": "and bring other guys\ncloser to the root. But if you believe, which\nwe don't know how to prove,",
    "start": "4570920",
    "end": "4576170"
  },
  {
    "text": "if you believe that there's no-- it doesn't really\nbuy you anything to go off the path now,\nyou can always do it later,",
    "start": "4576170",
    "end": "4582290"
  },
  {
    "text": "then this algorithm\nis optimal offline. And in terms of the\npoint set it's--",
    "start": "4582290",
    "end": "4588000"
  },
  {
    "text": "in the point set of\nview it's kind of nice because it almost\nlooks online, right. You only have to\nlook at each time",
    "start": "4588000",
    "end": "4593510"
  },
  {
    "text": "and add the points at\nthat time that are useful, in terms of the past. You only had to satisfy\nthe rectangles of the past.",
    "start": "4593510",
    "end": "4601444"
  },
  {
    "text": "So this is where\nthings get interesting, because in terms of a tree\nview, with this transformation, this looks like an\noffline tree because it",
    "start": "4601444",
    "end": "4608810"
  },
  {
    "text": "needs to know the future. And it does if you\nwant to build a heap. OK, but if you look\nat in the geometric",
    "start": "4608810",
    "end": "4614360"
  },
  {
    "text": "view, suddenly it looks\nonline, because you're only looking at the points\nand all the points you've accessed in the past.",
    "start": "4614360",
    "end": "4619940"
  },
  {
    "text": "So, in fact, there's a\nway to make this online. ",
    "start": "4619940",
    "end": "4628550"
  },
  {
    "text": "This is where things\nget interesting. There is a transformation\nthat if you have an online satisfying\npoint set, meaning you",
    "start": "4628550",
    "end": "4637100"
  },
  {
    "text": "can decide what points to\nadd based only on the past, not on the future. So it's a fancier version\nof this transformation,",
    "start": "4637100",
    "end": "4643770"
  },
  {
    "text": "you get an actual online\nbinary search tree. So, this algorithm goes\nback to the '90s I think.",
    "start": "4643770",
    "end": "4653510"
  },
  {
    "text": "Actually '88, it's in a\nthesis 1988 as rediscovered by my PhD adviser in 2000.",
    "start": "4653510",
    "end": "4662630"
  },
  {
    "text": "It's totally natural\nalgorithm, but they thought it was an offline algorithm. With this view, it's\nan online algorithm.",
    "start": "4662630",
    "end": "4669260"
  },
  {
    "text": "Let me quickly convince\nyou, or sketch to you, how we make this online.",
    "start": "4669260",
    "end": "4674450"
  },
  {
    "text": "So we do the same thing, except\nwe don't know how to heapify,",
    "start": "4674450",
    "end": "4681647"
  },
  {
    "text": "because we don't know\nthe next access times. But we know whatever\nwe touch, it's some connected\nsubtree of the root.",
    "start": "4681647",
    "end": "4686989"
  },
  {
    "text": "We know what we touch. We touch whatever greedy\ntells us to touch. We'll touch all\nthese guys, whatever.",
    "start": "4686990",
    "end": "4692699"
  },
  {
    "text": "How do we rearrange them? We don't rearrange them. We store them into something\ncalled a split tree.",
    "start": "4692699",
    "end": "4698300"
  },
  {
    "text": " Split tree has the\nfeature, it's a tree.",
    "start": "4698300",
    "end": "4703340"
  },
  {
    "text": "Binary search tree, and if\nyou ask for some item x, you can move x to the root.",
    "start": "4703340",
    "end": "4711230"
  },
  {
    "text": "So then you have a\nleft subtree of x, right subtree of x,\nand then delete x,",
    "start": "4711230",
    "end": "4717410"
  },
  {
    "text": "and now you're left with\nthings that are less than x, and things that\nare greater than x. Things are greater than x.",
    "start": "4717410",
    "end": "4724550"
  },
  {
    "text": "And you can do all this\nin constant amortize time. ",
    "start": "4724550",
    "end": "4731030"
  },
  {
    "text": "This is what we need,\nif you think about here. I'm going to take all these\nitems that were touched,",
    "start": "4731030",
    "end": "4736460"
  },
  {
    "text": "throw them into a split tree. My resulting structure will\nbe a tree of split trees.",
    "start": "4736460",
    "end": "4742429"
  },
  {
    "text": "So think of it as, when\nI touch all these items I just sort of throw\nthem all in the root, but that root is\nrepresented by a split tree.",
    "start": "4742430",
    "end": "4749540"
  },
  {
    "text": "And then hanging off here, there\nare other split trees which may have several keys in them.",
    "start": "4749540",
    "end": "4756290"
  },
  {
    "text": "When I do, when I\nnow touch a node, you can show that if I'm\ntrying to touch some node here,",
    "start": "4756290",
    "end": "4762170"
  },
  {
    "text": "I can't just magically\ntouch a node here. I've got to, I had\nto have followed in the actual tree, whatever\nthe optimal tree is,",
    "start": "4762170",
    "end": "4768170"
  },
  {
    "text": "I had to follow some\nroute to leave path. So in fact, the\npredecessor and successor here had to have been touched\nbefore I touched this one.",
    "start": "4768170",
    "end": "4776390"
  },
  {
    "text": "Which means I'm going\nto split those nodes. So, when I actually-- this\nis basically lazy evaluation.",
    "start": "4776390",
    "end": "4784199"
  },
  {
    "text": "When I actually access\nsomething in here, that means I want to\npull it to the root. I wanted to pretend that\nit was at the root, that's",
    "start": "4784200",
    "end": "4791520"
  },
  {
    "text": "what the treap would have done. So basically pull it\nup, be a root, split,",
    "start": "4791520",
    "end": "4796619"
  },
  {
    "text": "because now there's\ntwo structures left where I don't know\ntheir orders, but I know that this item was first.",
    "start": "4796620",
    "end": "4803880"
  },
  {
    "text": "And so I end up with-- I don't actually remove\nit, but I remove it from the split trees, so\nI make it look like this.",
    "start": "4803880",
    "end": "4811570"
  },
  {
    "text": "And here's the guy where I\nwanted to access something. So, I split this root\ninto two split trees,",
    "start": "4811570",
    "end": "4817250"
  },
  {
    "text": "and I have an\nindividual node up here. If I can do this in\nconstant amortize time, it's as if this node was at\nthe root in the first place.",
    "start": "4817250",
    "end": "4824140"
  },
  {
    "text": "And so I simulate this\nperfect treap order, but using a data\nstructure, split trees,",
    "start": "4824140",
    "end": "4829530"
  },
  {
    "text": "which can actually be solved. How do you solve split trees? You just do the obvious\nthing, more or less.",
    "start": "4829530",
    "end": "4837110"
  },
  {
    "text": "Ideas, you know red\nblack trees, take your favorite balanced\nbinary search tree, red black trees work fine.",
    "start": "4837110",
    "end": "4845620"
  },
  {
    "text": "If you're given a node,\nyou can split there. You basically just\ncarve it in half.",
    "start": "4845620",
    "end": "4851670"
  },
  {
    "text": "How much does it cost to split? Well if you're a\nlittle bit clever, let me go to a\nboard of cleverness.",
    "start": "4851670",
    "end": "4857886"
  },
  {
    "text": " The one thing we\nhave to optimize for is, what if you're\nsplitting like right",
    "start": "4857887",
    "end": "4863425"
  },
  {
    "text": "here, very close to the left? If you're clever,\nyou'll search from here,",
    "start": "4863425",
    "end": "4868579"
  },
  {
    "text": "and cut off this part in\ntime basically proportional to the height of that tree. OK, you might get some\npropagation up here,",
    "start": "4868580",
    "end": "4875180"
  },
  {
    "text": "but that's very small amortized. OK, on the other hand,\nif you search over here, you'd like to spend only\ntime proportional to this.",
    "start": "4875180",
    "end": "4882600"
  },
  {
    "text": "So in general, if you just\nsearch in parallel here, you can split in--",
    "start": "4882600",
    "end": "4889570"
  },
  {
    "text": "let's say this has size n one,\nand the rest has size n two. You can split in order log\nthe min of n one and n two.",
    "start": "4889570",
    "end": "4901710"
  },
  {
    "text": "And you can show that if you\njust-- that's straightforward splitting, that's\nreally easy to do. You can show that that\nimplies constant amortized,",
    "start": "4901710",
    "end": "4908930"
  },
  {
    "text": "because either you're cutting\noff a very little nibble and the cost is small,\nor you're cutting things more or less in half, but\nthat can't happen very much.",
    "start": "4908930",
    "end": "4915650"
  },
  {
    "text": "Then you charge to the fact\nthat log n is going down by one, and overall you get a linear\ncost to splitting nodes.",
    "start": "4915650",
    "end": "4923400"
  },
  {
    "text": " It's an amortization. Now the trouble is this is\nnot a binary search tree.",
    "start": "4923400",
    "end": "4929300"
  },
  {
    "text": "How in the heck do\nI have to pointers that in parallel search? Well you have to take these\ntwo halves of the tree",
    "start": "4929300",
    "end": "4934880"
  },
  {
    "text": "and interleave them to make\nthem a binary search tree. It's kind of awkward, but just\nput it, mash it all together.",
    "start": "4934880",
    "end": "4941210"
  },
  {
    "text": "Fold it in half, basically\nand turn it upside down, and you've got a\nbinary search tree. So there's some\nmessy stuff there,",
    "start": "4941210",
    "end": "4947390"
  },
  {
    "text": "but that's just a\nhand-wavy argument that you can make greedy online.",
    "start": "4947390",
    "end": "4952400"
  },
  {
    "text": "Next class we'll talk about\nlower bounds, which almost proved the greedy is optimal. But not quite.",
    "start": "4952400",
    "end": "4958630"
  }
]