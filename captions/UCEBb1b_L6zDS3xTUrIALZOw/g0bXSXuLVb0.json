[
  {
    "start": "0",
    "end": "96000"
  },
  {
    "text": "[SQUEAKING] [RUSTLING] [CLICKING]",
    "start": "0",
    "end": "5772"
  },
  {
    "start": "5772",
    "end": "12510"
  },
  {
    "text": "ERIK DEMAINE: All right. Welcome to practice\nproblem session 3, 006.",
    "start": "12510",
    "end": "18080"
  },
  {
    "text": "Today, we are going to go\nthrough a bunch of problems, which you should have already.",
    "start": "18080",
    "end": "23497"
  },
  {
    "text": "I was thinking of skipping\nthe very first problem, because it's just\na mechanical thing. If we have time at the end,\nwe can come back to it.",
    "start": "23497",
    "end": "28910"
  },
  {
    "text": "But there's not really any\ninsight I can give you in how to approach this problem. It's just, do you\nunderstand hashing?",
    "start": "28910",
    "end": "34220"
  },
  {
    "text": "So I want to go into the\nmore creative problems first. Let's start with problem\n3.2, hash sequence.",
    "start": "34220",
    "end": "41010"
  },
  {
    "text": "So I'll just read it. And then our first task is\nto convert the word problem",
    "start": "41010",
    "end": "46070"
  },
  {
    "text": "into a concise formal algorithms\nthing we need to achieve. Then we need to come up with\nideas for how to achieve it.",
    "start": "46070",
    "end": "52010"
  },
  {
    "text": "And we need to\ncheck the details. That'll be our general pattern. So this problem\nsays, hash tables",
    "start": "52010",
    "end": "57260"
  },
  {
    "text": "are not only useful for\nimplementing set operations, they can also be used\nto implement sequences. Remember from lecture 2,\nwe have a set interface,",
    "start": "57260",
    "end": "64729"
  },
  {
    "text": "which is about querying\nitems by their key and sort of intrinsic\norder that's about the items themselves,\nversus a sequence",
    "start": "64730",
    "end": "71672"
  },
  {
    "text": "interface that we started\nout with, with linked lists and so on, and arrays,\nwhere we're given an order,",
    "start": "71672",
    "end": "78481"
  },
  {
    "text": "and we want to\nmaintain that order. And that order may\nnot have anything to do with the items themselves. So that's what we call\nan extrinsic order.",
    "start": "78482",
    "end": "84890"
  },
  {
    "text": "We're told what the\norder is by saying, insert this item after this one,\nor append this one to the end, or prepend it to the beginning.",
    "start": "84890",
    "end": "91619"
  },
  {
    "text": "So in lecture last week, we\nsaw hash tables implement sets.",
    "start": "91620",
    "end": "96830"
  },
  {
    "start": "96000",
    "end": "185000"
  },
  {
    "text": "And let me just remind you\nsome things that they can do.",
    "start": "96830",
    "end": "103470"
  },
  {
    "text": "So we have, on the\none hand, set hashing. ",
    "start": "103470",
    "end": "110330"
  },
  {
    "text": "So we're going to\nneed this in a moment.",
    "start": "110330",
    "end": "115760"
  },
  {
    "text": "This is just a\nreminder from lecture. We can build one in\nlinear time expected.",
    "start": "115760",
    "end": "121909"
  },
  {
    "text": "We can find an item in\nconstant timed expected by key. And we can insert\nor delete an item",
    "start": "121910",
    "end": "132319"
  },
  {
    "text": "in constant expected amortized.",
    "start": "132320",
    "end": "137480"
  },
  {
    "text": " OK, so this is a black\nbox that we're given.",
    "start": "137480",
    "end": "145070"
  },
  {
    "text": "And the problem statement\nsays that, imagine you're",
    "start": "145070",
    "end": "151130"
  },
  {
    "text": "given a hash table\nas a black box, which means we're giving a thing\nthat behaves just like a--",
    "start": "151130",
    "end": "157160"
  },
  {
    "text": "thank you, 2. We're given something\nthat is a hash table. But it's black box in\nthe sense we're not",
    "start": "157160",
    "end": "163653"
  },
  {
    "text": "allowed to reach in and change\nthe implementation details. We're supposed to use it as is,\njust by calling its interface.",
    "start": "163653",
    "end": "169190"
  },
  {
    "text": "So in particular, we're\ngiving these three operations. I'll maybe also use iter to\niterate through the items.",
    "start": "169190",
    "end": "175105"
  },
  {
    "text": "So we're allowed to build\nsomething in linear time, find, and insert and delete in\nconstant expected amortized.",
    "start": "175105",
    "end": "182120"
  },
  {
    "text": "And what the\nproblem is asking is to build out of\nthis data structure a sequence with\nparticular time balance.",
    "start": "182120",
    "end": "191540"
  },
  {
    "text": "So this is what we call\na reduction in that we're",
    "start": "191540",
    "end": "197000"
  },
  {
    "text": "going to convert-- I guess technically, we're\nreducing the sequence problem",
    "start": "197000",
    "end": "202819"
  },
  {
    "text": "to the set problem,\nbecause we're showing how to solve the\nsequence problem using the set",
    "start": "202820",
    "end": "208130"
  },
  {
    "text": "problem. But the way we'll think about\nit is in the other direction. We're given a data\nstructure that solves set. And we're going to convert\nit into a data structure that",
    "start": "208130",
    "end": "214550"
  },
  {
    "text": "solves sequence. So given that we already know\nhow to do this from lecture, we're going to learn\nhow to do this.",
    "start": "214550",
    "end": "220661"
  },
  {
    "text": "This is teaching you new\nstuff in a problem set. So the specific\nbounds that we're told to achieve are build\nin constant expected time,",
    "start": "220661",
    "end": "231020"
  },
  {
    "text": "get and set_at in\nconstant expected time,",
    "start": "231020",
    "end": "240290"
  },
  {
    "text": "insert and delete_at in\nlinear expected time,",
    "start": "240290",
    "end": "252769"
  },
  {
    "text": "and insert and delete\nfirst and last in--",
    "start": "252770",
    "end": "263930"
  },
  {
    "text": "we're running out of room here-- constant expected amortized.",
    "start": "263930",
    "end": "271550"
  },
  {
    "text": "OK. So this is just what\nwe're told to do.",
    "start": "271550",
    "end": "276560"
  },
  {
    "text": "And now we start thinking. So we're given this. We want to build this.",
    "start": "276560",
    "end": "282500"
  },
  {
    "text": "And so I'm going to tell you\na little bit about my thought process. When I'm presented with\na problem like this, the first thing is\nto read the problem",
    "start": "282500",
    "end": "289070"
  },
  {
    "text": "and see, OK, what's\nthe hard part here? What are the challenges? So clearly, we\nhave to do all four",
    "start": "289070",
    "end": "295009"
  },
  {
    "text": "of these types of operations. Build in linear expected time--\nthat's basically everything we've seen.",
    "start": "295010",
    "end": "300139"
  },
  {
    "text": "Get or set_at in constant\nexpected time-- that's fast. And that feels kind of\nlike this find operation.",
    "start": "300140",
    "end": "307400"
  },
  {
    "text": "So both of these seem\npretty matchy-matchy. So that looks like\na good mapping.",
    "start": "307400",
    "end": "312770"
  },
  {
    "text": "I'm going to try to build\nthese operations using those operations. Insert and delete at\na specific location",
    "start": "312770",
    "end": "320259"
  },
  {
    "text": "in constant expected time-- sorry, linear expected\ntime-- that's big.",
    "start": "320260",
    "end": "325270"
  },
  {
    "text": "Linear expected time means I\ncan rebuild the entire data structure every time\nI do an operation.",
    "start": "325270",
    "end": "330730"
  },
  {
    "text": "So this is easy. OK, that's the first\nthing to realize. This is big.",
    "start": "330730",
    "end": "336350"
  },
  {
    "text": "Great. So I don't really have to\nworry about these operations. I mean, I do have\nto implement them. But it's not hard to do it that\nfast, because I can rebuild.",
    "start": "336350",
    "end": "346480"
  },
  {
    "text": "And then here, insert and delete\nat the beginning and the end of the array, these are the DEQ,\nDouble-Ended Queue operations,",
    "start": "346480",
    "end": "352300"
  },
  {
    "text": "insert and delete at\neither end, in constant expected amortized time. This, I feel like,\nis a tricky one.",
    "start": "352300",
    "end": "358970"
  },
  {
    "text": "You've seen one way to\ndo this in a problem set. But now we're going to\nsee another way with--",
    "start": "358970",
    "end": "364480"
  },
  {
    "text": "OK, the other thing to notice\nis these \"expected\" words. In this case, we're\ntold to use hashing.",
    "start": "364480",
    "end": "370780"
  },
  {
    "text": "But with lot of the problems,\nyou're not told how to solve it or what you should be\nbasing your thing on.",
    "start": "370780",
    "end": "376569"
  },
  {
    "text": "And so \"expected\" is\nalways a good keyword, because it means randomization\nis involved somehow.",
    "start": "376570",
    "end": "381729"
  },
  {
    "text": "If you're told the bound\nis going to be expected, you probably need to\nuse randomization.",
    "start": "381730",
    "end": "388030"
  },
  {
    "text": "And in this class, the only form\nof randomization you will use is essentially hashing. So that's a good hint.",
    "start": "388030",
    "end": "395645"
  },
  {
    "text": "In this case, we know what\nwe're supposed to use hashing. All right, so this is\ngoing to be the challenge.",
    "start": "395645",
    "end": "403870"
  },
  {
    "text": " But any ideas on how we\nmight tackle this problem?",
    "start": "403870",
    "end": "409460"
  },
  {
    "text": "How can we-- so set, remember,\nevery item has a key. In a sequence, items\nare just items.",
    "start": "409460",
    "end": "415823"
  },
  {
    "text": "And we're told to\ninsert and delete them at particular locations. But they don't have keys.",
    "start": "415823",
    "end": "421060"
  },
  {
    "text": "So one of the\nchallenges is going to be to take our items\nhere, give them keys so that we can\nstore them in a set.",
    "start": "421060",
    "end": "427460"
  },
  {
    "text": "Otherwise, we can't use find.",
    "start": "427460",
    "end": "432556"
  },
  {
    "text": "If there's no keys\nthere, there's no way to search by key. ",
    "start": "432556",
    "end": "438100"
  },
  {
    "text": "Ideas? ",
    "start": "438100",
    "end": "443870"
  },
  {
    "text": "So let's think about\nwhat we want to do. Let's start with-- so\nbuild, I think, is fine.",
    "start": "443870",
    "end": "451370"
  },
  {
    "text": "If you just want to\nbuild a data structure, you don't need to do anything. The hard part are the\nqueries or updates",
    "start": "451370",
    "end": "457460"
  },
  {
    "text": "you want to be able to do\non your data structure. Let's start with this\noperation, get and set_at.",
    "start": "457460",
    "end": "462900"
  },
  {
    "text": "So remember, get_at,\nyou're given an index i, and you want to find\nthe item at position i.",
    "start": "462900",
    "end": "473950"
  },
  {
    "start": "465000",
    "end": "560000"
  },
  {
    "text": "And set_at, we're\ngiven a position, and we want to change the\nitem stored at that position,",
    "start": "473950",
    "end": "480965"
  },
  {
    "text": "at that index, i. Now, over here,\nwhat we're given,",
    "start": "480965",
    "end": "486419"
  },
  {
    "text": "we can insert and delete. But the main sort of lookup-- let's think about get_at first.",
    "start": "486420",
    "end": "491870"
  },
  {
    "text": "A natural mapping, given\nthis arrow, is find. Find will search\nfor an item by key.",
    "start": "491870",
    "end": "499500"
  },
  {
    "text": "So here's-- just\nstaring at that, let's look at all the possible\npairings you could do. We have find by key over here.",
    "start": "499500",
    "end": "505759"
  },
  {
    "text": "And we need to implement\nget_at by index. So let's make the indices keys.",
    "start": "505760",
    "end": "511460"
  },
  {
    "text": "OK, so this is idea number one-- index-- assign a\nkey to each item",
    "start": "511460",
    "end": "527870"
  },
  {
    "text": "equal to index in sequence. ",
    "start": "527870",
    "end": "535790"
  },
  {
    "text": "OK, so then, when I do-- to implement get_at,\nI can just call find of i if i is also a key.",
    "start": "535790",
    "end": "546380"
  },
  {
    "text": "And that should give me\nthe thing that I want. Maybe for this to\nmake sense, let me tell you how I'm building.",
    "start": "546380",
    "end": "551780"
  },
  {
    "text": "So if I'm given, say, an array\nA of items, and they're both--",
    "start": "551780",
    "end": "556820"
  },
  {
    "text": "the only name conflict\nhere is build. So let me call this\none sequence build. ",
    "start": "556820",
    "end": "564260"
  },
  {
    "start": "560000",
    "end": "701000"
  },
  {
    "text": "And I'm going to implement\nit using set build. ",
    "start": "564260",
    "end": "569600"
  },
  {
    "text": "And I'll use some\nshorthand notation here. Let's say I want to\nmake an object that",
    "start": "569600",
    "end": "575870"
  },
  {
    "text": "has a key equal to i and\na value equal to A of i--",
    "start": "575870",
    "end": "587960"
  },
  {
    "text": "that's my object notation-- for i equals 0, 1, up\nto size of A minus 1.",
    "start": "587960",
    "end": "598100"
  },
  {
    "text": "That's a little bit code-like,\nbut not quite literal code. So I'm just going\nto use this to say,",
    "start": "598100",
    "end": "603750"
  },
  {
    "text": "let's make an object\nthat has two parts. One is called the key.",
    "start": "603750",
    "end": "608779"
  },
  {
    "text": "So we can talk about the\nobject.key, so we can-- which sets want to do. And we're also going to store a\nvalue, which is the actual item",
    "start": "608780",
    "end": "615710"
  },
  {
    "text": "that we're given. So I'm just-- because these\nare given in the sequence, I'm just representing\nthat sequence order",
    "start": "615710",
    "end": "621738"
  },
  {
    "text": "by assigning i to be the key. And so now, if I want to\nfind the item at index i, I can do find of i.",
    "start": "621738",
    "end": "627589"
  },
  {
    "text": "And technically, I should\nprobably do .value. That will give me\nthe actual item that's stored at that position.",
    "start": "627590",
    "end": "634550"
  },
  {
    "text": "When I do find of i, I'm\ngoing to get this whole object with the key of i. And then I want to get\nthe value part of it.",
    "start": "634550",
    "end": "641720"
  },
  {
    "text": "So then set_at, I\ncan just use this find operation to get the\nobject and set its value to x.",
    "start": "641720",
    "end": "652860"
  },
  {
    "text": "Boom. We've implemented array-like\nsemantics, get_at i and set_at i, using a set.",
    "start": "652860",
    "end": "661130"
  },
  {
    "text": "If you've ever\nprogrammed in JavaScript, this should feel very familiar,\nbecause JavaScript actually implements arrays, at least\nat the conceptual level,",
    "start": "661130",
    "end": "670130"
  },
  {
    "text": "as just general mapping\ntypes, which are-- they call them objects, but\nthey are basically sets.",
    "start": "670130",
    "end": "676820"
  },
  {
    "text": "And it's even grosser. They convert the integers\ninto strings and then index everything by the\nstrings, semantically, anyway.",
    "start": "676820",
    "end": "684815"
  },
  {
    "text": "Implementation details\ncan be more efficient. But conceptually,\nthat's what's going on. And so that's the idea we're\ndoing here, which seems great.",
    "start": "684815",
    "end": "694910"
  },
  {
    "text": "Any problems? So let's see. There's insert_at and delete_at. As I mentioned,\nwhat I'm going to do",
    "start": "694910",
    "end": "701420"
  },
  {
    "start": "701000",
    "end": "741000"
  },
  {
    "text": "for those operations is just\nrebuild the entire structure. I'll just write that briefly.",
    "start": "701420",
    "end": "706715"
  },
  {
    "text": " Basically, let's just\niterate all the items.",
    "start": "706715",
    "end": "714122"
  },
  {
    "text": "Iterate all items, let's\nsay, into an array.",
    "start": "714122",
    "end": "720950"
  },
  {
    "text": "Insert, delete one of them. And then rebuild.",
    "start": "720950",
    "end": "727290"
  },
  {
    "text": "OK, and if I was\nwriting a P set answer, I would say a little\nbit more detail what I mean in this step.",
    "start": "727290",
    "end": "734482"
  },
  {
    "text": "I've done it in the notes. Not that hard. But we can afford\nlinear expected time. I can afford to\ncall build again.",
    "start": "734482",
    "end": "740735"
  },
  {
    "text": "I guess, technically,\nI'm calling this build, sequence build. ",
    "start": "740735",
    "end": "747462"
  },
  {
    "start": "741000",
    "end": "1033000"
  },
  {
    "text": "So I can afford just to\nextract things into an array, do the linear time\noperation on the array with the shifting\nand everything,",
    "start": "747462",
    "end": "752820"
  },
  {
    "text": "and then just call build again. Yeah, question? AUDIENCE: I had a\nquestion about get_at. ERIK DEMAINE: Yeah. AUDIENCE: [INAUDIBLE] get_at.",
    "start": "752820",
    "end": "761340"
  },
  {
    "text": "ERIK DEMAINE: Sorry, no. These are separate\ndefinitions, yeah?",
    "start": "761340",
    "end": "766800"
  },
  {
    "text": "Sorry, they got a little close. AUDIENCE: Oh. ERIK DEMAINE: So this is\nthe definition of get_at. This is the definition\nof sequence build.",
    "start": "766800",
    "end": "771840"
  },
  {
    "text": "AUDIENCE: Oh, I see. ERIK DEMAINE: Yeah. Thanks for asking. ",
    "start": "771840",
    "end": "777340"
  },
  {
    "text": "OK, all good, yeah? AUDIENCE: Can you explain\nthe insert and delete again?",
    "start": "777340",
    "end": "782652"
  },
  {
    "text": "ERIK DEMAINE: Explain\ninsert and delete. OK, so maybe I should actually\nwrite one of them down,",
    "start": "782653",
    "end": "789270"
  },
  {
    "text": "or I'll just draw\na picture, maybe. So we have this data structure,\nwhich is now a sequence data",
    "start": "789270",
    "end": "795720"
  },
  {
    "text": "structure, represents\nsome sequence of items. And my goal is to say,\ndelete the i-th item.",
    "start": "795720",
    "end": "803459"
  },
  {
    "text": "So there's some items in\nhere, x0 up to xn minus 1. I want to remove xi\nfrom the sequence.",
    "start": "803460",
    "end": "811320"
  },
  {
    "text": "Or I guess I should\ndraw it this way. It's coming out. So what I'm going to do is\nfirst extract all the items",
    "start": "811320",
    "end": "818020"
  },
  {
    "text": "from the sequence. And I didn't write\nit, but there's an interface over here called\niter, which just gives me",
    "start": "818020",
    "end": "824650"
  },
  {
    "text": "all the items in order. So I'm going to extract\nthis into an array sequence.",
    "start": "824650",
    "end": "830320"
  },
  {
    "text": " Let's say I'll just build\na static array of size n.",
    "start": "830320",
    "end": "839620"
  },
  {
    "text": "I also have a length\noperation that tells me how many items are in here. And the iter operation will\ngive me all the items in order.",
    "start": "839620",
    "end": "846910"
  },
  {
    "text": "And so I'll put into my\narray x0 and then x1, and so on, as they come out.",
    "start": "846910",
    "end": "853700"
  },
  {
    "text": "Then I go to position i. And I want to delete that item\nand shift all the others over.",
    "start": "853700",
    "end": "860890"
  },
  {
    "text": "This is the boring-- I think we even said how to\ndo delete_at in dynamic arrays",
    "start": "860890",
    "end": "868600"
  },
  {
    "text": "in recitation 2, pretty sure. So I'm just mimicking that. I'm building this just to\nget the new order of things.",
    "start": "868600",
    "end": "875830"
  },
  {
    "text": "And then I'm applying,\nvia the build operation, I'm building a\ntotally new sequence.",
    "start": "875830",
    "end": "883570"
  },
  {
    "text": "And that's how I would\nimplement delete_at, one way. There are other ways. Yeah? AUDIENCE: Do you have\n[INAUDIBLE] space [INAUDIBLE],,",
    "start": "883570",
    "end": "890960"
  },
  {
    "text": "or-- ERIK DEMAINE: How much\nspace is this using? Oh, problem with space\nif you're inserting-- if you're inserting,\nyou probably",
    "start": "890960",
    "end": "896890"
  },
  {
    "text": "want to allocate a static\narray of size n plus 1. You know exactly\nwhat's going to happen. So just allocate a\nlittle bit bigger.",
    "start": "896890",
    "end": "903130"
  },
  {
    "text": "Then you can do the shift. You could also use\ndynamic arrays. But then you would\nget maybe an--",
    "start": "903130",
    "end": "908240"
  },
  {
    "text": "it's not an amortized\nbound, because you're only doing one insertion. The point is this\nis really easy.",
    "start": "908240",
    "end": "914180"
  },
  {
    "text": "We can spend linear time. So we can rebuild the-- we can rebuild this array\nthree times if we wanted.",
    "start": "914180",
    "end": "920930"
  },
  {
    "text": "Question? AUDIENCE: What if\nyou weren't allowed external non-constant space?",
    "start": "920930",
    "end": "927488"
  },
  {
    "text": "ERIK DEMAINE: Huh. You're going to throw\nme and open problem. What if you only have\nconstant extra space? ",
    "start": "927488",
    "end": "936750"
  },
  {
    "text": "Right. Then I think we need to\nuse insert and delete. So we could-- good question.",
    "start": "936750",
    "end": "944160"
  },
  {
    "text": "We could conceptually\ndo this shifting, but do it using\ninsert and delete. So we can-- so let's do\nthe delete case again.",
    "start": "944160",
    "end": "953730"
  },
  {
    "text": "So we want to-- here's xi. We want to replace it\nwith xi plus 1 and so on.",
    "start": "953730",
    "end": "960330"
  },
  {
    "text": " And so we can start out by\ndeleting the item with key i.",
    "start": "960330",
    "end": "970170"
  },
  {
    "text": "That will get rid of this guy. Then we can delete the\nitem with key i plus 1.",
    "start": "970170",
    "end": "976920"
  },
  {
    "text": "And that gives us the item. And then we can reassign its\nkey to i instead of i plus 1",
    "start": "976920",
    "end": "983310"
  },
  {
    "text": "and then reinsert it. So we can take this item out. It has a key, which is--",
    "start": "983310",
    "end": "990516"
  },
  {
    "text": "I'll draw this properly. So we have key i\nplus 1 and value xi",
    "start": "990516",
    "end": "997200"
  },
  {
    "text": "plus 1 stored in\nthis data structure. Then we update the key to i.",
    "start": "997200",
    "end": "1003259"
  },
  {
    "text": "And then we reinsert it. And it takes the\nplace of this guy. So you could do that. You could go down this\nlist and-- or not the list,",
    "start": "1003260",
    "end": "1010220"
  },
  {
    "text": "but you could iterate\nfor i equals-- sorry, for j equals i to n minus 1,\nand for each of those items,",
    "start": "1010220",
    "end": "1016370"
  },
  {
    "text": "delete it, change its key,\nreinsert it with the new key. And then you don't have to\nbuild this intermediate data",
    "start": "1016370",
    "end": "1021980"
  },
  {
    "text": "structure. So if you're told to\nminimize space, great. And maybe you think\nof that as simpler. I like to think of this\nas simpler, because I--",
    "start": "1021980",
    "end": "1029000"
  },
  {
    "text": "point is, I have linear time. I can do crazy, silly, very\nnon-data-structures-y things,",
    "start": "1029000",
    "end": "1034069"
  },
  {
    "start": "1033000",
    "end": "1238000"
  },
  {
    "text": "where I just start from scratch. OK, great. But there's one more\nset of operations,",
    "start": "1034069",
    "end": "1040510"
  },
  {
    "text": "insert, delete, first and last. Are these easy?",
    "start": "1040510",
    "end": "1046339"
  },
  {
    "text": "Good? ",
    "start": "1046339",
    "end": "1053540"
  },
  {
    "text": "Shall we try? We can insert last.",
    "start": "1053540",
    "end": "1060440"
  },
  {
    "text": "So this is given an item,\nx, we want to add it to the end of the structure.",
    "start": "1060440",
    "end": "1065790"
  },
  {
    "text": "So that means its index is going\nto be equal to-- because we start at 0, it's going to\nbe equal to the length,",
    "start": "1065790",
    "end": "1070970"
  },
  {
    "text": "current length of the structure. So let's just insert\na new object, which",
    "start": "1070970",
    "end": "1077350"
  },
  {
    "text": "has key equal to the length. And it has value equal to x.",
    "start": "1077350",
    "end": "1084240"
  },
  {
    "text": "We're done. Delete last, similar. Just delete the item\nwith key length minus 1.",
    "start": "1084240",
    "end": "1090740"
  },
  {
    "text": "OK, what about first? ",
    "start": "1090740",
    "end": "1097170"
  },
  {
    "text": "This is supposed to add x to\nthe beginning of my sequence. ",
    "start": "1097170",
    "end": "1102810"
  },
  {
    "text": "Well, now I realize\nI have a problem, because I want this\nnew item to have key 0,",
    "start": "1102810",
    "end": "1109830"
  },
  {
    "text": "because after I do an\ninsert first, get_at of 0 should return this item.",
    "start": "1109830",
    "end": "1115529"
  },
  {
    "text": "But I already have an item with\nkey 0, and an item with key 1, and an item with key 2,\nand so on down the way.",
    "start": "1115530",
    "end": "1121990"
  },
  {
    "text": "And so if I wanted\nto give x a key of 0, I have to shift the keys\nof all of those items, just like we were doing here.",
    "start": "1121990",
    "end": "1128320"
  },
  {
    "text": "And that's going to\ntake linear time. But we were supposed to do this\nin constant expected amortized",
    "start": "1128320",
    "end": "1134320"
  },
  {
    "text": "time. So that's no good. So this idea is not enough.",
    "start": "1134320",
    "end": "1140890"
  },
  {
    "text": "It's not a bad idea. It's still a good idea. But it's no longer what\nwe actually want to do. It's only morally\nwhat we want to do.",
    "start": "1140890",
    "end": "1149430"
  },
  {
    "text": "So do you have any thoughts\non how we might get around this problem?",
    "start": "1149430",
    "end": "1155760"
  },
  {
    "text": "Seems like inserting\nat position 0, I need to shift everything\ndown, linear time. That really sucks.",
    "start": "1155760",
    "end": "1160965"
  },
  {
    "start": "1160965",
    "end": "1168679"
  },
  {
    "text": "Yeah? AUDIENCE: You could create some\nsort of link to something else.",
    "start": "1168680",
    "end": "1176210"
  },
  {
    "text": "ERIK DEMAINE: Link this data\nstructure with another one. So we could build\nmore than one set. That's certainly allowed. ",
    "start": "1176210",
    "end": "1185260"
  },
  {
    "text": "I don't know how\nto do-- oh, I see. You're saying maybe build\na whole other structure for the items that\ncome before 0?",
    "start": "1185260",
    "end": "1191620"
  },
  {
    "text": "AUDIENCE: Yeah. ERIK DEMAINE: Yeah, actually. That would work, I think, maybe.",
    "start": "1191620",
    "end": "1197260"
  },
  {
    "text": "It's like in the P set. Then you have to deal\nwith when-- if you delete one of them, it becomes empty.",
    "start": "1197260",
    "end": "1202630"
  },
  {
    "text": "Then things get messy. Delete first is also going\nto be a problem, because I delete beginning of\nthis data structure,",
    "start": "1202630",
    "end": "1211970"
  },
  {
    "text": "then I lose my 0 item. And I want the new 0\nitem to be the 1 item. And again, all\nthe indices shift.",
    "start": "1211970",
    "end": "1218500"
  },
  {
    "text": "So delete and inserting\nat the first is hard. So we could do that trick\nlike in the P set, but--",
    "start": "1218500",
    "end": "1223720"
  },
  {
    "text": "or like in the last\nproblem session and so on. But there's a much simpler idea.",
    "start": "1223720",
    "end": "1231629"
  },
  {
    "text": "AUDIENCE: Can you\nhave an extra variable to keep track of where\nis the beginning? ERIK DEMAINE: Nice. I can have an extra\nvariable to keep track",
    "start": "1231629",
    "end": "1238930"
  },
  {
    "start": "1238000",
    "end": "1426000"
  },
  {
    "text": "of where the beginning is. ",
    "start": "1238930",
    "end": "1252084"
  },
  {
    "text": "Call this first. This is going to be the key\nof the first item, index 0.",
    "start": "1252084",
    "end": "1268090"
  },
  {
    "text": "Another way to say\nthis is, let's just use negative integers, right?",
    "start": "1268090",
    "end": "1273100"
  },
  {
    "text": "Sets work for any\nkeys, any integer keys. OK, actually, we\ntechnically said, make sure you use\nkeys 0 to u minus 1.",
    "start": "1273100",
    "end": "1279670"
  },
  {
    "text": "But then, if you have negative\nnumbers, you can easily fold-- AUDIENCE: Wait, doesn't\nit [INAUDIBLE] to like",
    "start": "1279670",
    "end": "1286435"
  },
  {
    "text": "[INAUDIBLE]? ERIK DEMAINE: Ah. Python negative numbers\nmean something else. But we're not using\na Python interface.",
    "start": "1286435",
    "end": "1291475"
  },
  {
    "text": "We're using our custom\nmagical set interface, which we show how to implement\nin recitation notes, which",
    "start": "1291475",
    "end": "1298090"
  },
  {
    "text": "can take an arbitrary key. It hashes that key and finds\na place to put that item.",
    "start": "1298090",
    "end": "1306040"
  },
  {
    "text": "So we're not actually\nstoring things in order here. We're storing things\nin a hash table. But we're not supposed to\nget into the implementation",
    "start": "1306040",
    "end": "1312160"
  },
  {
    "text": "details. I think the way we presented\nhashing with our universal hash functions, we only\nallowed positive numbers.",
    "start": "1312160",
    "end": "1319220"
  },
  {
    "text": "So maybe, technically,\nI should point out, if you have positive\nand negative numbers,",
    "start": "1319220",
    "end": "1327429"
  },
  {
    "text": "you can fold this in half by\nmapping 0 to 0, 1 to 2, 2 to 4,",
    "start": "1327430",
    "end": "1335260"
  },
  {
    "text": "spreading it out. And then you can take\nminus 1 and map it to plus 1, and minus 2\nand map it to plus 3.",
    "start": "1335260",
    "end": "1343750"
  },
  {
    "text": "So this is like multiplying\neach of these guys by 2, and multiplying each of these\nguys by minus 2 and adding 1.",
    "start": "1343750",
    "end": "1350200"
  },
  {
    "text": "And then you get non-negative\nintegers out of all integers.",
    "start": "1350200",
    "end": "1355960"
  },
  {
    "text": "This is a typical\nmath trick for showing that the number of integers\nis equal to the number",
    "start": "1355960",
    "end": "1362320"
  },
  {
    "text": "of non-negative integers,\nwhich may seem weird to you. But they're both\ncountably infinite.",
    "start": "1362320",
    "end": "1368410"
  },
  {
    "text": "So you could-- if your\nstructure only supports non-negative keys, you could\nmap negative keys in this way",
    "start": "1368410",
    "end": "1373929"
  },
  {
    "text": "and throw them into\nthe hash table, OK? So now, I allow\nnegative things for--",
    "start": "1373930",
    "end": "1380169"
  },
  {
    "text": " like that. And so, great.",
    "start": "1380170",
    "end": "1385230"
  },
  {
    "text": "If I want to insert at the\nbeginning, what I can do is just decrement my\nfirst variable, which",
    "start": "1385230",
    "end": "1394080"
  },
  {
    "text": "is keeping track of the index. So initially, first\nis going to be 0. So I'm going to\nadd into my build.",
    "start": "1394080",
    "end": "1400590"
  },
  {
    "text": "First, I'm going\nto say first equals 0, because I start with\nkey 0 when I initially",
    "start": "1400590",
    "end": "1408270"
  },
  {
    "text": "build a structure. And if I want to-- if I\nneed more room before 0, I just set first to minus 1.",
    "start": "1408270",
    "end": "1414240"
  },
  {
    "text": "And if I already have\na minus 1 element, I'll decrement it to minus 2. Decrement means decrease by 1--",
    "start": "1414240",
    "end": "1420600"
  },
  {
    "text": "shows my assembly\nlanguage programming. This is usually a built-in\noperation on most computers. And then I can insert an item\nwith key first and value x.",
    "start": "1420600",
    "end": "1435690"
  },
  {
    "text": " Great. And if I want to\ndelete the first item,",
    "start": "1435690",
    "end": "1441020"
  },
  {
    "text": "I would delete the item with key\nfirst and then increment first. And now all of my operations\nhave to change a little bit--",
    "start": "1441020",
    "end": "1448720"
  },
  {
    "text": "let me use another color-- because I was\nimplicitly assuming here that all my indices\nstarted at i.",
    "start": "1448720",
    "end": "1455320"
  },
  {
    "text": "But now they start at first. The index 0 maps to key first.",
    "start": "1455320",
    "end": "1462730"
  },
  {
    "text": "And so the right\nthing to do here is plus first and plus first.",
    "start": "1462730",
    "end": "1471370"
  },
  {
    "text": "Basically, add a whole bunch\nof plus firsts throughout. This one is probably fine.",
    "start": "1471370",
    "end": "1477080"
  },
  {
    "text": "If I'm globally rebuilding,\nI can reassign all my labels. But this one should\nbe first plus length.",
    "start": "1477080",
    "end": "1484840"
  },
  {
    "text": " OK, so just by keeping track\nof where my keys are starting,",
    "start": "1484840",
    "end": "1492760"
  },
  {
    "text": "I can do this shifting and\nnot have to worry about stuff. And this is a lot easier\nthan having to worry about",
    "start": "1492760",
    "end": "1499630"
  },
  {
    "text": "maintaining two structures, and\nkeeping them both non-empty, and stuff like\nthat, because of--",
    "start": "1499630",
    "end": "1506070"
  },
  {
    "text": "if I assume my\nmindset has this power of dealing with negative\nintegers, and strings,",
    "start": "1506070",
    "end": "1511420"
  },
  {
    "text": "and whatever else. Cool? Yeah? AUDIENCE: Is there a\nreason why you didn't do",
    "start": "1511420",
    "end": "1517330"
  },
  {
    "text": "like the sorting-- like, have [INAUDIBLE]? ERIK DEMAINE: Oh, why\ndidn't I use a linked list?",
    "start": "1517330",
    "end": "1524130"
  },
  {
    "text": "Because this. Linked lists are very bad at\nget and set at a given index.",
    "start": "1524130",
    "end": "1532440"
  },
  {
    "text": "AUDIENCE: Is that the-- the bottom idea, is\nthat a linked list? ERIK DEMAINE: This\nis not a linked list. This is just storing\na single number",
    "start": "1532440",
    "end": "1538200"
  },
  {
    "text": "as integer in your data\nstructure that says, what is the smallest key\nin my data structure?",
    "start": "1538200",
    "end": "1544660"
  },
  {
    "text": "That's all it this. It's a counter. AUDIENCE: Ah. ERIK DEMAINE: OK,\nso data structure",
    "start": "1544660",
    "end": "1550027"
  },
  {
    "text": "keeps track of its length. And it keeps track\nof the minimum key. And so it will always\nconsist-- the invariant is,",
    "start": "1550027",
    "end": "1555100"
  },
  {
    "text": "you will always\nhave keys from first up to first plus length minus 1.",
    "start": "1555100",
    "end": "1560290"
  },
  {
    "text": "And that's what we're\nexploiting here. We have no idea\nwhere first will be.",
    "start": "1560290",
    "end": "1566330"
  },
  {
    "text": "It depends how many\noperations you've done, how many inserts at the\nbeginning, and so on. But the keys-- keys will\nalways be first to first plus",
    "start": "1566330",
    "end": "1583520"
  },
  {
    "start": "1571000",
    "end": "1738000"
  },
  {
    "text": "length minus 1. This is what we\ncall an invariant. Useful to write\nthese things down so",
    "start": "1583520",
    "end": "1591200"
  },
  {
    "text": "you can understand\nwhat the heck-- why is your data\nstructure correct? Because of invariants\nlike this, which",
    "start": "1591200",
    "end": "1596660"
  },
  {
    "text": "you can prove by\ninduction, by showing, each time you do\nan operation, this is maintained, even when\nI'm changing first in order",
    "start": "1596660",
    "end": "1604130"
  },
  {
    "text": "to maintain this invariant. Cool. Sometimes you come up\nwith the invariant first.",
    "start": "1604130",
    "end": "1610310"
  },
  {
    "text": "In this case, I came up with\nit post facto, after the fact.",
    "start": "1610310",
    "end": "1617010"
  },
  {
    "text": "Cool. Let's move on to problem 3,\nwhich is called critter sort.",
    "start": "1617010",
    "end": "1638760"
  },
  {
    "text": "And the other key thing I\nwant you to learn about-- question? Sorry. AUDIENCE: Yeah. So when you do\nfirst, first plus 1,",
    "start": "1638760",
    "end": "1645547"
  },
  {
    "text": "is that a rebuilding\nof the [INAUDIBLE]?? ERIK DEMAINE: This\nis just a sentence. It is not an algorithm\nor data structure.",
    "start": "1645547",
    "end": "1652720"
  },
  {
    "text": "This is a mathematical property. AUDIENCE: [INAUDIBLE] ERIK DEMAINE: This\nis not an assignment. This is a mathematically\nis equal to.",
    "start": "1652720",
    "end": "1658800"
  },
  {
    "text": "AUDIENCE: But you are\nre-indexing it though, because you're\ndoing first plus 1. ERIK DEMAINE: So are you asking\nabout one of these operations,",
    "start": "1658800",
    "end": "1666480"
  },
  {
    "text": "like this one? AUDIENCE: Oh, OK. Never mind. I get it. OK. ERIK DEMAINE: Yeah.",
    "start": "1666480",
    "end": "1671830"
  },
  {
    "text": "OK. So the other\nimportant takeaway I want you to get about\nreading our problem sets is that they have\nhidden humor inside.",
    "start": "1671830",
    "end": "1678630"
  },
  {
    "text": "I don't know if you've noticed. But here's an example of a\nproblem called critter sort. Ashley Gettem collects\nand trains pocket critters",
    "start": "1678630",
    "end": "1685769"
  },
  {
    "text": "to fight other pocket\ncritters in battle. What is this a reference to? AUDIENCE: Digimon. ERIK DEMAINE: Digimon.",
    "start": "1685770",
    "end": "1691230"
  },
  {
    "text": "Wow, you guys are so young. Pokemon, the ancient form.",
    "start": "1691230",
    "end": "1696990"
  },
  {
    "text": "Pokemon is short\nfor pocket monsters. And in fact, in the original-- AUDIENCE: [INAUDIBLE] ERIK DEMAINE: --anime--",
    "start": "1696990",
    "end": "1702448"
  },
  {
    "text": "AUDIENCE: Actually,\nthere's [INAUDIBLE].. ERIK DEMAINE: I don't know. This is all after my time.",
    "start": "1702448",
    "end": "1707880"
  },
  {
    "text": "We can debate after. So pocket critters\nis a reference to pocket monsters,\nwhich is Pokemon.",
    "start": "1707880",
    "end": "1713130"
  },
  {
    "text": "Who's Ashley Gettem? AUDIENCE: Ash. ERIK DEMAINE: Ash\nKetchum is his full name",
    "start": "1713130",
    "end": "1718470"
  },
  {
    "text": "in the English version. Totally different name\nin the Japanese version. But they're both puns on\ncollect them all, right?",
    "start": "1718470",
    "end": "1726090"
  },
  {
    "text": "All right, so that's\nthe important stuff. We'll see more jokes later. So there's this setup.",
    "start": "1726090",
    "end": "1731640"
  },
  {
    "text": "But basically, we\nhave n critters. And we want to sort them\nby four different things.",
    "start": "1731640",
    "end": "1737290"
  },
  {
    "text": "And so I'm just going\nto abstract this problem to sort n objects by the\nfollowing types of keys.",
    "start": "1737290",
    "end": "1744438"
  },
  {
    "start": "1738000",
    "end": "2189000"
  },
  {
    "text": "And for each one, we want to\nknow what the best sorting algorithm is. And there's this footnote\nthat's very important that says,",
    "start": "1744438",
    "end": "1750990"
  },
  {
    "text": "faster correct algorithms\nwill receive more points than slower correct algorithms. Also, correct algorithms\nwill receive more points",
    "start": "1750990",
    "end": "1757980"
  },
  {
    "text": "than incorrect algorithms. But that's implicit. Incorrect generally gets zero. OK, so part a, it\nsays, species ID.",
    "start": "1757980",
    "end": "1767340"
  },
  {
    "text": "But basically, we have integers\nand the range minus n to n.",
    "start": "1767340",
    "end": "1776400"
  },
  {
    "text": "So if I want to sort n integers\nin the range minus n to n, what should I do?",
    "start": "1776400",
    "end": "1782340"
  },
  {
    "text": "This is a reference to\nyesterday's lecture. ",
    "start": "1782340",
    "end": "1790170"
  },
  {
    "text": "Yeah? Radix sort, yeah. Always a good answer. Or almost always a good\nanswer when you have integers.",
    "start": "1790170",
    "end": "1796990"
  },
  {
    "text": "It's a good answer whenever\nyou have small integers. Now, radix sort, the\nway we phrased it-- let me maybe put it down here.",
    "start": "1796990",
    "end": "1804010"
  },
  {
    "text": "Radix sort sorts n integers in\nthe range 0 to u minus 1 in n",
    "start": "1804010",
    "end": "1820270"
  },
  {
    "text": "plus n log base n of u time.",
    "start": "1820270",
    "end": "1825910"
  },
  {
    "text": " And in particular,\nthis is linear time",
    "start": "1825910",
    "end": "1831799"
  },
  {
    "text": "if u is n to some\nconstant power.",
    "start": "1831800",
    "end": "1838420"
  },
  {
    "text": "OK, so can I just apply this\nas is to these integers?",
    "start": "1838420",
    "end": "1843430"
  },
  {
    "text": "No, because they're negative. So what should I do? Maybe I should do\nmy folding trick. We just saw how to take negative\nnumbers and fold them in,",
    "start": "1843430",
    "end": "1851440"
  },
  {
    "text": "interspersed with\npositive numbers. If I sort that, will that work?",
    "start": "1851440",
    "end": "1857900"
  },
  {
    "text": "No, because that does\nnot preserve order. It would intersperse.",
    "start": "1857900",
    "end": "1863335"
  },
  {
    "text": "We want all the negative\nnumbers to come before all the positive numbers. Yeah? AUDIENCE: Can you just\nadd n to all the integers?",
    "start": "1863335",
    "end": "1868672"
  },
  {
    "text": "ERIK DEMAINE: Just add n, yep. Boom. Plus n. Now we have integers\nin the range--",
    "start": "1868672",
    "end": "1874730"
  },
  {
    "text": "let's be careful-- 0 to 2n. ",
    "start": "1874730",
    "end": "1881130"
  },
  {
    "text": "Cool. Now we can apply this. Now u equals,\ntechnically, 2n plus 1, because we're only supposed\nto go to u minus 1.",
    "start": "1881130",
    "end": "1887833"
  },
  {
    "text": "But that's fine. That's linear. And so we can sort\nin linear time, easy. This is a super easy problem.",
    "start": "1887833",
    "end": "1894850"
  },
  {
    "text": "But in each one, we might need\nto do some transformation. Part b is a little\nmore interesting.",
    "start": "1894850",
    "end": "1901410"
  },
  {
    "text": "So we have strings over 26\nletters of length at most",
    "start": "1901410",
    "end": "1918230"
  },
  {
    "text": "10 ceiling log n. ",
    "start": "1918230",
    "end": "1923640"
  },
  {
    "text": "OK, this is a little trickier. What could I do? Again, I'd like to see\nwhether radix sort applies.",
    "start": "1923640",
    "end": "1930350"
  },
  {
    "text": "I should say radix sort sorts. ",
    "start": "1930350",
    "end": "1935420"
  },
  {
    "text": "I'd like to see if\nradix sort applies. To do that, I have to map these\nstrings into integers somehow.",
    "start": "1935420",
    "end": "1940550"
  },
  {
    "text": "Any way to do that?  This is easy if you\nunderstand radix sort.",
    "start": "1940550",
    "end": "1946155"
  },
  {
    "text": "Yeah? AUDIENCE: Can you just\nindex the letters? ERIK DEMAINE:\nIndex, the letters. Yeah. ",
    "start": "1946155",
    "end": "1954610"
  },
  {
    "text": "Yeah, we can map-- right. So we can map A to 0, B to 1. Then what?",
    "start": "1954610",
    "end": "1959650"
  },
  {
    "text": " AUDIENCE: Oh, wait. Length--",
    "start": "1959650",
    "end": "1965169"
  },
  {
    "text": "ERIK DEMAINE: So\nthat's for each letter. But we have a lot of letters.",
    "start": "1965170",
    "end": "1972520"
  },
  {
    "text": "There are only 26 letters. But then we have 10 log\nn letters in a string.",
    "start": "1972520",
    "end": "1978070"
  },
  {
    "text": "That is, together, a single\nkey that we need to sort. ",
    "start": "1978070",
    "end": "1985130"
  },
  {
    "text": "Yeah? AUDIENCE: Can't we just sort by\nthe first letter first, then-- ERIK DEMAINE: Sort by the first\nletter, then the second letter.",
    "start": "1985130",
    "end": "1992620"
  },
  {
    "text": "That is exactly the\nopposite of radix sort. Remember, radix sort,\nwe want to start by the last letter, and then\nthe next to last letter,",
    "start": "1992620",
    "end": "1998980"
  },
  {
    "text": "and finally, the first letter. AUDIENCE: But you want\nto sort by the first one in order to alphabetize things. ERIK DEMAINE: No,\nto alphabetize--",
    "start": "1998980",
    "end": "2004650"
  },
  {
    "text": "we do want to, in the end,\nsort by the first letter. But that's at the end. So at the end--\nremember, radix sort",
    "start": "2004650",
    "end": "2010690"
  },
  {
    "text": "always goes backwards\nfrom the least significant to the most significant. And so indeed, that\nis what we want to do.",
    "start": "2010690",
    "end": "2016090"
  },
  {
    "text": "You're just saying,\nuse radix sort. But what am I radix sort on? What am I radix sorting on?",
    "start": "2016090",
    "end": "2021149"
  },
  {
    "text": "AUDIENCE: Yeah, on the last\nletters, not the first letters. ERIK DEMAINE: So\ntechnically, that would be using counting\nsort on the last letter,",
    "start": "2021150",
    "end": "2027953"
  },
  {
    "text": "counting sort of the\nnext to last letter, dot, dot, dot, counting sort\non the first letter.",
    "start": "2027953",
    "end": "2033330"
  },
  {
    "text": "But that is, together,\nradix sort on something, or Jason likes to call\nthis tuple sorting.",
    "start": "2033330",
    "end": "2041580"
  },
  {
    "text": "Tuple sort is the thing-- is the algorithm that says,\nsort by the last thing, then sort by the previous\nthing, and so on.",
    "start": "2041580",
    "end": "2048580"
  },
  {
    "text": "You can also think of\nthis as radix sorting on a number written in base 26. ",
    "start": "2048580",
    "end": "2055549"
  },
  {
    "text": "They're the same thing. ",
    "start": "2055550",
    "end": "2064440"
  },
  {
    "text": "But in the end, we can\nsort in linear time. AUDIENCE: How do you\nensure that the letters are",
    "start": "2064440",
    "end": "2070830"
  },
  {
    "text": "sorted in order, though? Like, how do you ensure that--\nhow do you tell the algorithm",
    "start": "2070830",
    "end": "2076975"
  },
  {
    "text": "that you want A to come-- just like not-- 0 is less\nthan 1, A is less than B.",
    "start": "2076975",
    "end": "2082596"
  },
  {
    "text": "ERIK DEMAINE: Right. So I mean, technically,\nwhen you call something like tuple sort-- or maybe it's even clearer\nwhen you call radix sort.",
    "start": "2082596",
    "end": "2089810"
  },
  {
    "text": "Radix sort, you're giving\nit a bunch of numbers. So you're taking these strings\nand mapping them to numbers.",
    "start": "2089810",
    "end": "2095560"
  },
  {
    "text": "And when you do that, you\nget to decide which letter is the most\nsignificant, which is the least significant, right?",
    "start": "2095560",
    "end": "2101099"
  },
  {
    "text": "So you will choose to always map\nthe first letter in your string to position--",
    "start": "2101100",
    "end": "2107250"
  },
  {
    "text": "to value, or the--\nwhat do you call it?",
    "start": "2107250",
    "end": "2113130"
  },
  {
    "text": "Position in positional notation. Position 26 to the power 10\nlog n as the most significant.",
    "start": "2113130",
    "end": "2119590"
  },
  {
    "text": "So it's always the\nmost significant. Even if your string\nis of length 1, you want to put that in\nthe most significant digit.",
    "start": "2119590",
    "end": "2125070"
  },
  {
    "text": "And you'll pad with\nzeros at the end if you run out of\nletters in your string. AUDIENCE: How many times are\nyou running counting sort here?",
    "start": "2125070",
    "end": "2131970"
  },
  {
    "text": "ERIK DEMAINE: How many times\nam I running counting sort? Oh, 10 log n times. Whoops. Yeah, good question.",
    "start": "2131970",
    "end": "2137880"
  },
  {
    "text": "Good point. Yeah, I computed this wrong. So right.",
    "start": "2137880",
    "end": "2142980"
  },
  {
    "text": "There are log n\ndigits in the string. So that is bad.",
    "start": "2142980",
    "end": "2149309"
  },
  {
    "text": "I mean, it's OK. We'll end up with n log n\nrunning time by the tuple sort.",
    "start": "2149310",
    "end": "2157480"
  },
  {
    "text": " However-- so that's\nthe tuple sort.",
    "start": "2157480",
    "end": "2163920"
  },
  {
    "text": "So I should really make\nthis not equivalent. If I run tuple short letter\nby letter, I'm going to do--",
    "start": "2163920",
    "end": "2170410"
  },
  {
    "text": "I'm running counting\nsort log n times. And so I get n log n, because\neach one takes linear time.",
    "start": "2170410",
    "end": "2176310"
  },
  {
    "text": "If I map my strings\ninto numbers first, radix sort doesn't use base 26.",
    "start": "2176310",
    "end": "2182355"
  },
  {
    "text": "It uses base n. And then it will\nonly run 10 times,",
    "start": "2182355",
    "end": "2188070"
  },
  {
    "text": "because 2 to the 10\nlog n is n to the 10.",
    "start": "2188070",
    "end": "2198520"
  },
  {
    "start": "2189000",
    "end": "2669000"
  },
  {
    "text": "And so the numbers that we're\nsorting are between 0 and n to the 10.",
    "start": "2198520",
    "end": "2204040"
  },
  {
    "text": "And so u is n to the 10. And so that's the case when\nradix sort runs in linear time.",
    "start": "2204040",
    "end": "2209380"
  },
  {
    "text": "So if you run tuple short\nletter by letter, it's slow. If you run radix sort,\nit's doing a whole bunch",
    "start": "2209380",
    "end": "2215700"
  },
  {
    "text": "of letters at once. Effectively, it's\ndoing log n letters at a time in a single\ncall to counting sort.",
    "start": "2215700",
    "end": "2221700"
  },
  {
    "text": "And so the radix sort will\nactually win and get linear. ",
    "start": "2221700",
    "end": "2229882"
  },
  {
    "text": "There's a subtlety\nhere, which is, I'm assuming that we can\nactually take these strings and convert them into integers\nin constant time each.",
    "start": "2229883",
    "end": "2238380"
  },
  {
    "text": "And this problem\nset was ambiguous. And both answers were accepted. If you assume these letters\nare nice and compactly",
    "start": "2238380",
    "end": "2245010"
  },
  {
    "text": "stored, and they\nfit in 10 words, because a word is at\nleast log n bits long,",
    "start": "2245010",
    "end": "2251280"
  },
  {
    "text": "then you can actually do this. If you store each letter\nin a separate word,",
    "start": "2251280",
    "end": "2256650"
  },
  {
    "text": "then just reading the entire\ninput will take n log n time. So that's a subtlety which we\ndon't need to worry too much",
    "start": "2256650",
    "end": "2264947"
  },
  {
    "text": "about in this class. Yeah? AUDIENCE: So [INAUDIBLE]\nbounding the letters to numbers.",
    "start": "2264947",
    "end": "2270312"
  },
  {
    "text": "And like, how would that help? Because we still have to do 26-- ERIK DEMAINE: Yeah, there\nare 26 possible letters,",
    "start": "2270312",
    "end": "2278339"
  },
  {
    "text": "numbering them 0 to 25. And then when we take\na string, like AA,",
    "start": "2278340",
    "end": "2285450"
  },
  {
    "text": "we map this into 00 in base 26. ",
    "start": "2285450",
    "end": "2292350"
  },
  {
    "text": "That's a number. If we do BB, for\nexample, this maps to 11",
    "start": "2292350",
    "end": "2298349"
  },
  {
    "text": "in base 26, which means 1\ntimes 26 plus 1, which is 27.",
    "start": "2298350",
    "end": "2305820"
  },
  {
    "text": "OK, so that's the\nmapping that I mean. AUDIENCE: You're mapping the\nwhole string [INAUDIBLE]??",
    "start": "2305820",
    "end": "2311250"
  },
  {
    "text": "ERIK DEMAINE: The whole string\nto a single number, yeah. And there's a subtlety,\nbecause I want lexicographic.",
    "start": "2311250",
    "end": "2316740"
  },
  {
    "text": "I need to pad things\nwith spaces at the end or pad them with As\nat the end in case they're shorter than 10 log n.",
    "start": "2316740",
    "end": "2324410"
  },
  {
    "text": "OK, cool. That was b. ",
    "start": "2324410",
    "end": "2330330"
  },
  {
    "text": "c is not very interesting. It's integers in the\nrange 0 to n squared.",
    "start": "2330330",
    "end": "2340410"
  },
  {
    "text": "This, I can just\nsolve with radix sort, because my radix\nsort, at this point, we've done it a third time.",
    "start": "2340410",
    "end": "2346160"
  },
  {
    "text": "Radix sort, we can sort as\nlong as the integers are bounded by a polynomial. Here, it's a fixed polynomial\nwith a constant exponent.",
    "start": "2346160",
    "end": "2353940"
  },
  {
    "text": "So this will-- and\nthis is radix sort, like we saw, that just\ncalls counting sort twice,",
    "start": "2353940",
    "end": "2359220"
  },
  {
    "text": "linear time. d is where things\nget more interesting.",
    "start": "2359220",
    "end": "2364240"
  },
  {
    "text": "Let me get this\nphrasing the same. So in d, we have rational\nnumbers of the form w over f.",
    "start": "2364240",
    "end": "2376230"
  },
  {
    "text": "This is some win ratio. Always in the range 0 to 1.",
    "start": "2376230",
    "end": "2382230"
  },
  {
    "text": "So we saw w is at most f. And 0 is less than w, is\nless than f, is less than n",
    "start": "2382230",
    "end": "2389549"
  },
  {
    "text": "squared, because the-- that is really confusing-- ",
    "start": "2389550",
    "end": "2395920"
  },
  {
    "text": "is less than n squared-- those are separate statements-- because the f actually\ncomes from part c.",
    "start": "2395920",
    "end": "2402240"
  },
  {
    "text": "And c is really a\nsetup for this one. Doesn't really matter\nwhat this means. It's just that we\nhave numbers w and f,",
    "start": "2402240",
    "end": "2409050"
  },
  {
    "text": "where w is always less than f. And they're between\n0 and n squared. So you should think, this is\na good range for me, right?",
    "start": "2409050",
    "end": "2415500"
  },
  {
    "text": "That I'm representing\nthis rational in terms of two numbers\nbetween 0 and n squared. So there's like n to\nthe 4th possible choices",
    "start": "2415500",
    "end": "2422700"
  },
  {
    "text": "for what w and f are. So the range of my\nvalues is n to the 4th. That's the setting where\nradix sort should run fast.",
    "start": "2422700",
    "end": "2429780"
  },
  {
    "text": "Unfortunately, these numbers--\nwhat I want to sort by is not an integer. It's a rational.",
    "start": "2429780",
    "end": "2436650"
  },
  {
    "text": "And that's annoying. So there are a couple of\nways to solve this problem.",
    "start": "2436650",
    "end": "2443850"
  },
  {
    "text": "In general, a good way to solve\nsorting is to use merge sort.",
    "start": "2443850",
    "end": "2448980"
  },
  {
    "text": "Merge sort is always\na good answer. It's not the best answer. In these cases, we\nshaved off a log.",
    "start": "2448980",
    "end": "2454540"
  },
  {
    "text": "We got to linear time. But n log n is pretty good. It's pretty close to n. So first goal might\nbe, can we even achieve",
    "start": "2454540",
    "end": "2461820"
  },
  {
    "text": "n log n via merge sort?  What would I need to do in order\nto actually apply merge sort",
    "start": "2461820",
    "end": "2473805"
  },
  {
    "text": "to this instance?  What does merge\nsort do to its keys?",
    "start": "2473805",
    "end": "2481690"
  },
  {
    "start": "2481690",
    "end": "2492109"
  },
  {
    "text": "Sorry? AUDIENCE: Isolate\nand compare them. ERIK DEMAINE: It isolates and\ncompares them, yeah, right. So there's an array\ndata structure.",
    "start": "2492110",
    "end": "2499030"
  },
  {
    "text": "And it indexes into the array. That's the isolation. But then the thing it actually\ndoes with the items themselves",
    "start": "2499030",
    "end": "2505330"
  },
  {
    "text": "is always a comparison. And this is why we introduced\nthe comparison model and proved an n log n lower\nbound in the comparison model,",
    "start": "2505330",
    "end": "2511150"
  },
  {
    "text": "because merge sort,\nand insertion sort, and selection sort are\nall comparison algorithms. Radix sort is not.",
    "start": "2511150",
    "end": "2517442"
  },
  {
    "text": "But this one is. But to apply merge sort, I need\nto say, how do I compare wi",
    "start": "2517443",
    "end": "2523150"
  },
  {
    "text": "over fi versus wj over fj?",
    "start": "2523150",
    "end": "2529375"
  },
  {
    "text": " My computer only\ndeals with integers.",
    "start": "2529375",
    "end": "2535580"
  },
  {
    "text": "We can't actually\nrepresent wi over fi explicitly in binary, because\nit has infinitely many bits.",
    "start": "2535580",
    "end": "2543710"
  },
  {
    "text": "But I can represent\nit implicitly by storing wi and fi. Yeah? AUDIENCE: Multiply by fi and fj.",
    "start": "2543710",
    "end": "2549620"
  },
  {
    "text": "ERIK DEMAINE: Multiply\nby fi and fj, yeah. When I went-- I\ndidn't go to school, but then we learned\ncross multiplication,",
    "start": "2549620",
    "end": "2557123"
  },
  {
    "text": "which is the same as\nmultiplying both sides by fi and multiplying both\nsides by fj, as you said. So then we get fi fj less\nthan question mark f--",
    "start": "2557123",
    "end": "2568880"
  },
  {
    "text": "whatever-- fi wj. When we do that, we better\nmake sure that the things",
    "start": "2568880",
    "end": "2575600"
  },
  {
    "text": "we're multiplying\nby are non-negative. Otherwise, the sign flips. But here, we assume\nthey're all non-negative.",
    "start": "2575600",
    "end": "2581870"
  },
  {
    "text": "So this is good. And now we're just\nmultiplying two integers here, multiplying two integers\nhere, and comparing.",
    "start": "2581870",
    "end": "2586970"
  },
  {
    "text": "Those are all things I\ncan do in a word RAM.  So this was actually\nthe intended solution",
    "start": "2586970",
    "end": "2593599"
  },
  {
    "text": "when this problem was posed. Here's a way to do\ncomparison sort. We get n log n. But in fact, you can\nachieve linear time.",
    "start": "2593600",
    "end": "2601140"
  },
  {
    "text": "Yeah? AUDIENCE: [INAUDIBLE] that\nsolution, how would you quickly say which one's bigger? Because wi times f\nof j, one of them",
    "start": "2601140",
    "end": "2609573"
  },
  {
    "text": "belongs to one of the\nPokemons, and the other one is [INAUDIBLE].",
    "start": "2609573",
    "end": "2614852"
  },
  {
    "text": "ERIK DEMAINE: I feel like\nthere's a joke here, like-- AUDIENCE: [INAUDIBLE] ERIK DEMAINE:\nPikachu is superior.",
    "start": "2614852",
    "end": "2619940"
  },
  {
    "text": "That's always the answer. So how do I tell\nwhether one Pokemon",
    "start": "2619940",
    "end": "2624950"
  },
  {
    "text": "is superior to the other? If I multiply my--",
    "start": "2624950",
    "end": "2631510"
  },
  {
    "text": "I multiply i's f value\nwith j's w value. And I see whether that's\ngreater than i's w",
    "start": "2631510",
    "end": "2639890"
  },
  {
    "text": "value times j's f value. And if it is-- so these are equivalent.",
    "start": "2639890",
    "end": "2646718"
  },
  {
    "text": "If this one is\ngreater than this one, I know that this is\ngreater than this. These are equivalent sentences\nby mathematics, by algebra.",
    "start": "2646718",
    "end": "2654349"
  },
  {
    "text": "And so this is what\nI want to know. This would say j\nis superior to i. And so I determine that\nby actually doing this.",
    "start": "2654350",
    "end": "2662010"
  },
  {
    "text": "So then I don't have to divide\nand deal with real numbers, because I don't know how,\nbecause I'm a computer.",
    "start": "2662010",
    "end": "2667790"
  },
  {
    "text": " We're all computers in the end. ",
    "start": "2667790",
    "end": "2679345"
  },
  {
    "start": "2669000",
    "end": "3166000"
  },
  {
    "text": "OK. ",
    "start": "2679345",
    "end": "2693050"
  },
  {
    "text": "So it would be great\nif my numbers all had the same denominator.",
    "start": "2693050",
    "end": "2698670"
  },
  {
    "text": "If they all had the same f, then\nI could just compare the w's. So that's one intuition\nfor why we can actually",
    "start": "2698670",
    "end": "2706220"
  },
  {
    "text": "do this in linear time. But the way I like to\nthink about it-- so let's",
    "start": "2706220",
    "end": "2711440"
  },
  {
    "text": "just draw the real\ninterval from 0 to 1. And there are various spots\nall over here that represent--",
    "start": "2711440",
    "end": "2723040"
  },
  {
    "text": "I can't actually compute this. But conceptually, each of\nthese wi fi's falls somewhere in that interval from 0 to 1.",
    "start": "2723040",
    "end": "2729790"
  },
  {
    "text": "And I want to sort them somehow. So one thing that\nwould be great is",
    "start": "2729790",
    "end": "2735470"
  },
  {
    "text": "if I could take\nthese real numbers and somehow map\nthem to integers,",
    "start": "2735470",
    "end": "2742830"
  },
  {
    "text": "which are uniformly spaced,\nmaybe a few more of them. But these go from\n0 to u minus 1.",
    "start": "2742830",
    "end": "2750620"
  },
  {
    "text": "And if I could get\nu relatively small, and I could map each of these-- so I want that mapping\nto be order preserving.",
    "start": "2750620",
    "end": "2758450"
  },
  {
    "text": "And I want two very close,\nbut distinct items to map to-- distinct keys here.",
    "start": "2758450",
    "end": "2764599"
  },
  {
    "text": "I want them to map to\ndistinct integers down here. If I could do that, then I\njust sort by the integers. And that's the same as\nsorting by the real numbers.",
    "start": "2764600",
    "end": "2773070"
  },
  {
    "text": "And so at this point,\nI wonder, how close can two of these numbers be?",
    "start": "2773070",
    "end": "2780349"
  },
  {
    "text": "So how close can two keys be?",
    "start": "2780350",
    "end": "2790010"
  },
  {
    "text": "So I want to consider wi\nover fi minus wj over fj",
    "start": "2790010",
    "end": "2797510"
  },
  {
    "text": "in absolute value.  Now I do algebra.",
    "start": "2797510",
    "end": "2803550"
  },
  {
    "text": "So this is-- I'd like to bring\nthis into one ratio. So this is--",
    "start": "2803550",
    "end": "2809089"
  },
  {
    "text": "I can do that by multiplying\n1 by fi, 1 by fj. Now that's wi fj minus\nwj fi, which should",
    "start": "2809090",
    "end": "2818359"
  },
  {
    "text": "look a lot like something here. But never mind. I'm sure there's a\ndeep connection here.",
    "start": "2818360",
    "end": "2824520"
  },
  {
    "text": "I can probably use this to\nprove that and vice versa. Cool. So with some absolute\nvalues, same thing.",
    "start": "2824520",
    "end": "2831980"
  },
  {
    "text": "Maybe these are non-negative,\nso I can actually just put absolute\nvalues on the top part.",
    "start": "2831980",
    "end": "2838220"
  },
  {
    "text": "And OK, wi is an integer, fj is\nan integer, wj is an integer,",
    "start": "2838220",
    "end": "2844070"
  },
  {
    "text": "fi is an integer, all\ngreater than or equal to 0. So this thing is an integer.",
    "start": "2844070",
    "end": "2850560"
  },
  {
    "text": "So it could be equal to 0. It's a non-negative integer,\nbecause all the things are non-negative.",
    "start": "2850560",
    "end": "2856400"
  },
  {
    "text": "It could be equal to 0. But if they're\nequal to 0, that's actually identical\nratios, right?",
    "start": "2856400",
    "end": "2861589"
  },
  {
    "text": "If this is 0, the\nwhole thing is 0. And so these two\nvalues were the same. OK, but let's\nsuppose it's not 0.",
    "start": "2861590",
    "end": "2867559"
  },
  {
    "text": "If it's not 0, it's\nactually at least 1, the absolute value,\nbecause it's an integer.",
    "start": "2867560",
    "end": "2873950"
  },
  {
    "text": "What about the bottom? fi-- so now we want this-- I want to know how\nsmall this ratio can be.",
    "start": "2873950",
    "end": "2880040"
  },
  {
    "text": "It's going to be small when\nthis is small and this is big. How big could fi fj be? Well, we're told that all the\nf's are less than n squared.",
    "start": "2880040",
    "end": "2887720"
  },
  {
    "text": "So this thing is\nat most n squared, n to the 4th, less\nthan n the 4th--",
    "start": "2887720",
    "end": "2894380"
  },
  {
    "text": "n squared minus 1 squared,\nless than n to the 4th. AUDIENCE: [INAUDIBLE]",
    "start": "2894380",
    "end": "2900050"
  },
  {
    "text": "ERIK DEMAINE: fi is\nat most n squared. fj is at most n squared. So it's n squared squared.",
    "start": "2900050",
    "end": "2906450"
  },
  {
    "text": "So this is at least\n1 over n to the 4th. So the closest the two\npoints can get here",
    "start": "2906450",
    "end": "2912830"
  },
  {
    "text": "is 1 over n to the 4th. So what can I do to scale\nthat up to make them",
    "start": "2912830",
    "end": "2919430"
  },
  {
    "text": "kind of like integers? Multiply by n to the 4th.",
    "start": "2919430",
    "end": "2925400"
  },
  {
    "text": "So just multiply by n to\nthe 4th and then floor.",
    "start": "2925400",
    "end": "2934220"
  },
  {
    "text": "So we're going to\ntake each fi over-- I'd like to compute this ratio.",
    "start": "2934220",
    "end": "2940640"
  },
  {
    "text": "But I don't know how. So instead, I'm going\nto take fi, multiply-- OK.",
    "start": "2940640",
    "end": "2945890"
  },
  {
    "text": "Conceptually, what I want to\ndo is multiply by n to the 4th and take the floor. How do I actually do this\nin a machine that doesn't",
    "start": "2945890",
    "end": "2956840"
  },
  {
    "text": "have real numbers like this?  So I don't have a\nfloor operation.",
    "start": "2956840",
    "end": "2963575"
  },
  {
    "text": "I just have integer operations. Then I can take fi,\nmultiply it by n to the 4th,",
    "start": "2963575",
    "end": "2976609"
  },
  {
    "text": "and integer divide by wj.  That is the same--",
    "start": "2976610",
    "end": "2982400"
  },
  {
    "text": "that computes exactly\nthis, because I can do the multiplication\nand the division in either order in real space.",
    "start": "2982400",
    "end": "2990192"
  },
  {
    "text": "And then this does the floor\nat the appropriate time. But this is just\noperations on integers. And now these are\nintegers representing",
    "start": "2990192",
    "end": "2997010"
  },
  {
    "text": "how good my Pokemon are. They have the property that\nany two distinct ones--",
    "start": "2997010",
    "end": "3002110"
  },
  {
    "text": "before I take the floor, any\ntwo distinct ones are at least 1 apart. So after I take the floor,\nthey will remain 1 apart.",
    "start": "3002110",
    "end": "3007660"
  },
  {
    "text": "They will remain\ndistinct integers. And so I have successfully\nmapped my real numbers to integers where distinct\nreal numbers match",
    "start": "3007660",
    "end": "3014710"
  },
  {
    "text": "distinct integers. Yeah? AUDIENCE: Wait. So why is fi now in\nthe numerator, and wi in the denominator?",
    "start": "3014710",
    "end": "3019760"
  },
  {
    "text": "ERIK DEMAINE: Did I flip them? Yeah, sorry. Please invert\neverything-- just here.",
    "start": "3019760",
    "end": "3026619"
  },
  {
    "text": "This is w and fi. That was just a typo. ",
    "start": "3026620",
    "end": "3033390"
  },
  {
    "text": "That's all of them. OK. AUDIENCE: Are they\nboth i's or j's? ",
    "start": "3033390",
    "end": "3041839"
  },
  {
    "text": "ERIK DEMAINE: These are\nsupposed to both be i's, yeah. Thank you. This was for each\nPokemon, i, we're",
    "start": "3041840",
    "end": "3049680"
  },
  {
    "text": "going to compute\nthis as our key. And then we're going to\nsort by those integer keys.",
    "start": "3049680",
    "end": "3054720"
  },
  {
    "text": "And that will sort the\nPokemon by their ratios. ",
    "start": "3054720",
    "end": "3060930"
  },
  {
    "text": "Let's write mon for monster. Yeah? AUDIENCE: [INAUDIBLE]\nu minus 1 [INAUDIBLE]??",
    "start": "3060930",
    "end": "3070560"
  },
  {
    "text": "ERIK DEMAINE: So u was just a-- sorry, this is-- a label on\nthis thing might help you.",
    "start": "3070560",
    "end": "3076028"
  },
  {
    "text": "AUDIENCE: Oh. ERIK DEMAINE: Yeah. So now my u-- oh, right.",
    "start": "3076028",
    "end": "3081720"
  },
  {
    "text": "What is my u? What is my largest key? ",
    "start": "3081720",
    "end": "3092048"
  },
  {
    "text": "It occurs to me, I really would\nlike fi to be bigger than 0. But let's not worry about it.",
    "start": "3092048",
    "end": "3100540"
  },
  {
    "text": "How big can u be? Well, the biggest this\ncan be is if fi is small, and this is big.",
    "start": "3100540",
    "end": "3106240"
  },
  {
    "text": "Let's say fi can\nonly go down to 1. Otherwise, we'll\nget a division by 0. We have to deal with\ninfinity especially.",
    "start": "3106240",
    "end": "3111910"
  },
  {
    "text": "Probably, the problem isn't\neven well defined then. How big could this be? Well, I know the wi's--",
    "start": "3111910",
    "end": "3117049"
  },
  {
    "text": "AUDIENCE: f's are\ndefined as positive. ERIK DEMAINE: Oh, good. Thank you. So there's also a\npositive constraint here.",
    "start": "3117049",
    "end": "3122290"
  },
  {
    "text": "Just I failed to preserve\nthat constraint in my mapping",
    "start": "3122290",
    "end": "3127720"
  },
  {
    "text": "from the word problem\ninto the formal problem. ",
    "start": "3127720",
    "end": "3132950"
  },
  {
    "text": "So f is the least 1. Good. But worst case is when it's 1. And when wi-- how\nbig could it be?",
    "start": "3132950",
    "end": "3139730"
  },
  {
    "text": "Well, n squared minus 1. So this could be,\nbasically, n squared times n to the 4th divided\nby 1, which is n to the 6th.",
    "start": "3139730",
    "end": "3147415"
  },
  {
    "text": "So w-- or sorry, u, the\nlargest key I can have plus 1, is n to the 6th.",
    "start": "3147415",
    "end": "3153550"
  },
  {
    "text": "But that's OK, because\nradix sort can handle any fixed polynomial in n.",
    "start": "3153550",
    "end": "3158779"
  },
  {
    "text": "So it's going to end up doing\nsix counting sort passes. ",
    "start": "3158780",
    "end": "3166960"
  },
  {
    "start": "3166000",
    "end": "3206000"
  },
  {
    "text": "OK, that's problem 3. Let's move on to problem 4.",
    "start": "3166960",
    "end": "3174640"
  },
  {
    "start": "3174640",
    "end": "3198390"
  },
  {
    "text": "So problem 4, MIT has\nemployed Gank Frehry. Who's that? ",
    "start": "3198390",
    "end": "3206610"
  },
  {
    "start": "3206000",
    "end": "3244000"
  },
  {
    "text": "Frank Gehry, yeah. This is a common encoding\nthat Jason really likes.",
    "start": "3206610",
    "end": "3214970"
  },
  {
    "text": "I've grown to like it. This is called spoonerism,\nwhere you replace some part",
    "start": "3214970",
    "end": "3222720"
  },
  {
    "text": "of the beginning of your thing. OK, that's one joke. There's another joke\nin this problem.",
    "start": "3222720",
    "end": "3229357"
  },
  {
    "text": "Anyway, they're building a\nnew wing of the Stata Center, as one does. We have a bunch of cubes.",
    "start": "3229357",
    "end": "3235510"
  },
  {
    "text": "If you read long enough, you\nrealize that's a red herring. Cubes do not play a\nrole in this problem.",
    "start": "3235510",
    "end": "3240810"
  },
  {
    "text": "In the end, what\nwe have is a bunch of integers, which happen to be\nthe side length of the cubes.",
    "start": "3240810",
    "end": "3250197"
  },
  {
    "start": "3244000",
    "end": "3599000"
  },
  {
    "text": "But we just care about\nthe side lengths, not their volume or anything-- s n minus 1.",
    "start": "3250197",
    "end": "3261640"
  },
  {
    "text": "And we want two numbers\nin s summing to h.",
    "start": "3261640",
    "end": "3272015"
  },
  {
    "text": "AUDIENCE: This is\ndumb, but how can cubes have more than six sides? ERIK DEMAINE: This\nis a side length, not",
    "start": "3272015",
    "end": "3278220"
  },
  {
    "text": "the number of sides. So a cube-- AUDIENCE: Oh, OK.",
    "start": "3278220",
    "end": "3283518"
  },
  {
    "text": "ERIK DEMAINE: Cool. I didn't know we'd be\ndoing 3D geometry today. That's si. OK, so you got little cubes.",
    "start": "3283518",
    "end": "3289800"
  },
  {
    "text": "You've got big cubes. This is a small si. This is a big si. Doesn't matter, though.",
    "start": "3289800",
    "end": "3294868"
  },
  {
    "text": "They're just numbers. We're not using them at all. In the problem,\nyou're trying to like stack one cube on the other. But all we really care\nabout is two numbers",
    "start": "3294868",
    "end": "3301820"
  },
  {
    "text": "whose sum, regular old\nsum, is exactly h, ideally.",
    "start": "3301820",
    "end": "3306930"
  },
  {
    "text": "There's going to be two\nversions of this problem. And so the first goal\nis to solve this exactly",
    "start": "3306930",
    "end": "3312360"
  },
  {
    "text": "in linear expected time.",
    "start": "3312360",
    "end": "3317550"
  },
  {
    "text": "That's what the problem says. So what do we know?",
    "start": "3317550",
    "end": "3323110"
  },
  {
    "text": "Well, linear time, that's-- can't get much faster than\nthat, because we need that just to read the input.",
    "start": "3323110",
    "end": "3328170"
  },
  {
    "text": "Expected time-- hashing, right? We're told, basically,\nwe should use hashing.",
    "start": "3328170",
    "end": "3334680"
  },
  {
    "text": "Now, if we're really\nannoying, maybe we throw that in even\nwhen you don't need it. But that's pretty rare.",
    "start": "3334680",
    "end": "3340750"
  },
  {
    "text": "So when we see expected,\nwe should, in a problem set setting like\nthis-- in real life, you never know what\nyou should use.",
    "start": "3340750",
    "end": "3346728"
  },
  {
    "text": "But in our-- with your\nlearning in this class, we're going to tell\nyou basically what tricks you're allowed to use.",
    "start": "3346728",
    "end": "3352290"
  },
  {
    "text": "Here, you're allowed\nto use randomization. So probably, we need it. Indeed, you need it\nto achieve this bound.",
    "start": "3352290",
    "end": "3359760"
  },
  {
    "text": "Cool. Hashing. Not obvious how to approach\nthis problem with hashing.",
    "start": "3359760",
    "end": "3365460"
  },
  {
    "text": "So I'm going to\ngive you the way I-- it's hard for me to not\nknow this algorithm.",
    "start": "3365460",
    "end": "3370799"
  },
  {
    "text": "But to me, the first thing\nyou should think about is if I have linear\ntime and n things,",
    "start": "3370800",
    "end": "3377760"
  },
  {
    "text": "and I'm going to use hashing,\nthe obvious thing to do",
    "start": "3377760",
    "end": "3382800"
  },
  {
    "text": "is to take those n things\nand put them in a hash table. Build. Why not?",
    "start": "3382800",
    "end": "3388539"
  },
  {
    "text": "So let's just build a hash\ntable on all the keys in s.",
    "start": "3388540",
    "end": "3398400"
  },
  {
    "text": "That's idea one. ",
    "start": "3398400",
    "end": "3405510"
  },
  {
    "text": "Seems like the\nfirst thing to try. So what does that let me do? It lets me--",
    "start": "3405510",
    "end": "3410640"
  },
  {
    "text": "I just erased the\ninterface for hash tables. But I can build a\nsequence out of it. But normally, it gives\nme a set interface.",
    "start": "3410640",
    "end": "3417630"
  },
  {
    "text": "So I can call find\nnow in constant time. It lets me, given the\nnumber, determine immediately",
    "start": "3417630",
    "end": "3423329"
  },
  {
    "text": "whether that number is in s. Well, that sounds\ninteresting, because I'm looking for two numbers in s.",
    "start": "3423330",
    "end": "3429990"
  },
  {
    "text": "So it lets me find one of them. So I call it twice? No. Calling it twice and only\nspending constant time",
    "start": "3429990",
    "end": "3437341"
  },
  {
    "text": "on this beautiful data\nstructure will not give you anything useful. ",
    "start": "3437342",
    "end": "3443310"
  },
  {
    "text": "But we have linear time, right? So in addition to\nbuilding a table, we could call find on\nthat table a linear number",
    "start": "3443310",
    "end": "3449730"
  },
  {
    "text": "of times, because each find\nonly takes constant expected amortized time. So if I do n of them, that\nwill take linear expected time.",
    "start": "3449730",
    "end": "3457410"
  },
  {
    "text": "The amortization disappears,\nbecause I'm using it n times. AUDIENCE: [INAUDIBLE] ERIK DEMAINE: Oh, right.",
    "start": "3457410",
    "end": "3462725"
  },
  {
    "text": "Find never has amortization. So it doesn't disappear,\nbecause it was never there. Never mind. I can afford n calls,\nor 5n calls, to find,",
    "start": "3462725",
    "end": "3472530"
  },
  {
    "text": "because each one costs\nconstant expected. And the total for that\nwill be linear time. So the next idea is let's\njust somehow call find",
    "start": "3472530",
    "end": "3484966"
  },
  {
    "text": "a linear number of times, OK?",
    "start": "3484966",
    "end": "3492280"
  },
  {
    "text": "So I want to find two numbers\nsumming to a given value, h. That wasn't maybe\nclear, but h is given.",
    "start": "3492280",
    "end": "3499540"
  },
  {
    "text": "AUDIENCE: Sorry. How long does it take\nto build the hash table? ERIK DEMAINE: How long does\nit take to build a hash table? It was previously on this\nboard-- linear expected time.",
    "start": "3499540",
    "end": "3506422"
  },
  {
    "text": " See previous lecture.",
    "start": "3506422",
    "end": "3512421"
  },
  {
    "text": "No, two years ago. OK. Well, if we're going to do\nthis a linear number of times, I guess we should\nhave a for loop.",
    "start": "3512421",
    "end": "3519309"
  },
  {
    "text": "Let's do a for loop\nover the numbers. That's the next idea.",
    "start": "3519310",
    "end": "3524370"
  },
  {
    "text": "Loop over s. And at this point,\nwe're done, almost.",
    "start": "3524370",
    "end": "3529830"
  },
  {
    "text": " I want space.",
    "start": "3529830",
    "end": "3535330"
  },
  {
    "text": "So I want to loop\nover the numbers. And each one, I\nwant to do a find. That's kind of all\nI have time to do.",
    "start": "3535330",
    "end": "3540900"
  },
  {
    "text": "So seems like a\nnatural thing to try. This is by no means easy.",
    "start": "3540900",
    "end": "3546670"
  },
  {
    "text": "Don't get me wrong. Having these ideas is-- while I'm explaining them\nas the obvious ideas,",
    "start": "3546670",
    "end": "3552150"
  },
  {
    "text": "they're not obvious. But they are easy,\nat least, just not obvious to come up\nwith the easy ideas.",
    "start": "3552150",
    "end": "3559300"
  },
  {
    "text": "So let's loop over\ns, somehow call find, using our hash table. So the order is actually, we're\ngoing to build the hash table,",
    "start": "3559300",
    "end": "3565859"
  },
  {
    "text": "then loop. And inside the loop, we're\ngoing to call find once per loop iteration.",
    "start": "3565860",
    "end": "3571000"
  },
  {
    "text": "So let's do it. Let's say, for si in S--",
    "start": "3571000",
    "end": "3577410"
  },
  {
    "text": " so I want to find two numbers. Here, I have exhaustively\nlooped over one number.",
    "start": "3577410",
    "end": "3586050"
  },
  {
    "text": "I just need to find\nthe second number that can possibly add up, right? I want to find whether\nthere's an sj in S such",
    "start": "3586050",
    "end": "3597390"
  },
  {
    "text": "that si plus sj equals h.",
    "start": "3597390",
    "end": "3605089"
  },
  {
    "text": " Can I do that query with find? ",
    "start": "3605090",
    "end": "3612290"
  },
  {
    "text": "How?  So what does find do?",
    "start": "3612290",
    "end": "3617790"
  },
  {
    "text": "Find says, if I give you a key,\nit will tell me whether-- like, if I knew what sj\nwas, it would tell me",
    "start": "3617790",
    "end": "3625800"
  },
  {
    "text": "whether it's in S. Yeah? AUDIENCE: Can't you\njust subtract h from si",
    "start": "3625800",
    "end": "3631776"
  },
  {
    "text": "and then see if [INAUDIBLE]? ERIK DEMAINE: Subtract h from\nsi and see whether that exists.",
    "start": "3631776",
    "end": "3638859"
  },
  {
    "text": "Did get it right? AUDIENCE: h minus si. ERIK DEMAINE: h minus si. I always get it wrong. ",
    "start": "3638860",
    "end": "3646500"
  },
  {
    "text": "Don't feel bad that\nyou also got it wrong. It makes me feel better,\nbecause I always get it wrong. So the claim is this.",
    "start": "3646500",
    "end": "3652650"
  },
  {
    "text": "Why? Because what we\nwant to do is find-- well, OK.",
    "start": "3652650",
    "end": "3658890"
  },
  {
    "text": "Let's see what it\nsays over here. So if we do h minus\nsi equals sj--",
    "start": "3658890",
    "end": "3665100"
  },
  {
    "text": "so these are\nequivalent statements, just by moving the si over.",
    "start": "3665100",
    "end": "3670320"
  },
  {
    "text": "And this is a query we can do. So let's remember, these\nare things we know.",
    "start": "3670320",
    "end": "3675330"
  },
  {
    "text": " And s.j is something\nwe don't know.",
    "start": "3675330",
    "end": "3681870"
  },
  {
    "text": "All that we know\nis that it's an s. OK, so we know these two things. So if we bring them\nover to the same side,",
    "start": "3681870",
    "end": "3687970"
  },
  {
    "text": "we're searching for\nan unknown thing, which is equal to exactly this\nthing that we can compute.",
    "start": "3687970",
    "end": "3693030"
  },
  {
    "text": "So we just compute h minus si. We call find. That will tell us whether\nthere is an sj equal to this.",
    "start": "3693030",
    "end": "3700230"
  },
  {
    "text": "OK, so this is like a comment. And this is what we actually do.",
    "start": "3700230",
    "end": "3705990"
  },
  {
    "text": "And if there is a pair\nof numbers summing to h, this will find it. How much time did it take?",
    "start": "3705990",
    "end": "3712089"
  },
  {
    "text": "Well, we're doing n\niterations of this loop. Each one, we're calling\na single find operation.",
    "start": "3712090",
    "end": "3717450"
  },
  {
    "text": "And find costs\nconstant expected time. And so the total is\nlinear expected time.",
    "start": "3717450",
    "end": "3725700"
  },
  {
    "text": "Great. Part A done. ",
    "start": "3725700",
    "end": "3739560"
  },
  {
    "text": "Then they throw part b\nat us, make it harder. Those pesky instructors.",
    "start": "3739560",
    "end": "3745950"
  },
  {
    "start": "3745950",
    "end": "3753680"
  },
  {
    "text": "So we read part b. Part b says two things\nto make it harder.",
    "start": "3753680",
    "end": "3761240"
  },
  {
    "text": "So first of all, we want\nlinear worst-case time. ",
    "start": "3761240",
    "end": "3770290"
  },
  {
    "text": "And furthermore-- so we\ncan't use hashing anymore. Furthermore-- so\nhere, we just needed",
    "start": "3770290",
    "end": "3777270"
  },
  {
    "text": "to solve the exact problem\nto find whether the two numbers sum exactly to h. Now we would like to find the\nbest solution smaller than",
    "start": "3777270",
    "end": "3784349"
  },
  {
    "text": "or equal to h. So find biggest\npairwise sum that's",
    "start": "3784350",
    "end": "3797730"
  },
  {
    "text": "less than or equal to h if\nthere's no perfect pair.",
    "start": "3797730",
    "end": "3802890"
  },
  {
    "text": "But we're given a little bit\nof extra information, which",
    "start": "3802890",
    "end": "3808619"
  },
  {
    "text": "is, we can assume h\nequals 600 n to the 6th.",
    "start": "3808620",
    "end": "3817122"
  },
  {
    "text": "That's a weird polynomial. Took me a while to even notice\nthat that was a joke in here--",
    "start": "3817122",
    "end": "3823380"
  },
  {
    "text": "6006, hiding in a polynomial. All right, so polynomial.",
    "start": "3823380",
    "end": "3829470"
  },
  {
    "text": "Hm. That should make you\nthink radix sort. It is radix sort week. So that is a natural\nthing to try.",
    "start": "3829470",
    "end": "3836160"
  },
  {
    "text": "But in general, even\nlater in the semester, when you see a nice\npolynomial with a fixed",
    "start": "3836160",
    "end": "3842580"
  },
  {
    "text": "constant like this,\nand it's somehow related to the integers\nwe're dealing with, you should think radix sort. Especially because now, we\nwant constant worst-case time,",
    "start": "3842580",
    "end": "3849730"
  },
  {
    "text": "radix sort seems like\na good thing to do. Don't know what\nto do with it yet. In fact, I can't even\napply radix sort.",
    "start": "3849730",
    "end": "3855809"
  },
  {
    "text": "But idea one is radix sort. Just because I see\nthat polynomial,",
    "start": "3855810",
    "end": "3861000"
  },
  {
    "text": "I think maybe I should try it. Now, there's a problem here,\nbecause we're given some",
    "start": "3861000",
    "end": "3867690"
  },
  {
    "text": "numbers, some integers, si's. We're also given h. We're told now that is a\nnice, small polynomial.",
    "start": "3867690",
    "end": "3874510"
  },
  {
    "text": "But we have no idea how\nbig these numbers are. So the problem with\nthis idea is that--",
    "start": "3874510",
    "end": "3879540"
  },
  {
    "text": " but si could be bigger than h.",
    "start": "3879540",
    "end": "3886260"
  },
  {
    "text": "We have no idea how\nbig the si's are.  What can I say\nabout si's that are",
    "start": "3886260",
    "end": "3893510"
  },
  {
    "text": "bigger than h for this problem? ",
    "start": "3893510",
    "end": "3900099"
  },
  {
    "text": "Summing to h. Oh. I didn't say it, but all these\nnumbers are non-negative.",
    "start": "3900100",
    "end": "3905193"
  },
  {
    "text": "That's important. That looks like [INAUDIBLE]. Greater than or equal to 0.",
    "start": "3905193",
    "end": "3911580"
  },
  {
    "text": " Yeah?",
    "start": "3911581",
    "end": "3917080"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]\nsolution [INAUDIBLE].. ERIK DEMAINE: Right. If I'm finding a sum that's\nless than or equal to h, they're non-negative.",
    "start": "3917080",
    "end": "3922809"
  },
  {
    "text": "And any number that's greater\nthan h, I can just throw away.",
    "start": "3922810",
    "end": "3928540"
  },
  {
    "text": "They'll never be in a solution. So they already-- a sum of\none number is bigger than h. So two is only going to get\nbigger if they're non-negative.",
    "start": "3928540",
    "end": "3935174"
  },
  {
    "text": " So idea number two is let's\njust throw out all the big si's,",
    "start": "3935175",
    "end": "3941830"
  },
  {
    "text": "anything bigger than h. Now, that won't change the\nanswer, because those can never be in a solution.",
    "start": "3941830",
    "end": "3947320"
  },
  {
    "text": "And now I have all\nthe si's having the property that they're\nless than or equal to h. And so they are small,\nbounded by a fixed polynomial.",
    "start": "3947320",
    "end": "3956150"
  },
  {
    "text": "And now I can apply radix sort. So after this idea, I\ncan apply this idea.",
    "start": "3956150",
    "end": "3961370"
  },
  {
    "text": "OK, this gives you\na flavor of how I like to think about problems. I see clues, like a polynomial.",
    "start": "3961370",
    "end": "3966820"
  },
  {
    "text": "I think radix sort doesn't work. But with some more ideas,\nI can get it to work.",
    "start": "3966820",
    "end": "3972655"
  },
  {
    "text": "OK. What goes with the--\nso now I've sorted si. OK, great.",
    "start": "3972655",
    "end": "3978380"
  },
  {
    "text": "S is sorted. ",
    "start": "3978380",
    "end": "3983650"
  },
  {
    "text": "I guess we can try to\ndo the same algorithm, except I don't have\na hash table anymore.",
    "start": "3983650",
    "end": "3989540"
  },
  {
    "text": "So let's just try doing a\nfor loop over the S. Why not?",
    "start": "3989540",
    "end": "3994820"
  },
  {
    "text": "So let's do for si in\nS. But now it's sorted.",
    "start": "3994820",
    "end": "4000270"
  },
  {
    "text": "So presumably, I should\nexploit the sorted order. So let's do them in order.",
    "start": "4000270",
    "end": "4005859"
  },
  {
    "text": "So i equals 0, 1,\nup to n minus 1. Let's say that s0\nis the smallest.",
    "start": "4005860",
    "end": "4012030"
  },
  {
    "text": "s1 is the next smallest. sn minus 1 is the biggest. So I want to do something with--",
    "start": "4012030",
    "end": "4018120"
  },
  {
    "text": "so I have si. And I want to figure out\nwhether h minus si is in there.",
    "start": "4018120",
    "end": "4025200"
  },
  {
    "text": " Hard to do that better than--",
    "start": "4025200",
    "end": "4032040"
  },
  {
    "text": "actually, I could do\nthis with binary search. I'm looking for this value.",
    "start": "4032040",
    "end": "4038730"
  },
  {
    "text": "And I have a sorted array now. So I could binary\nsearch for h minus si. And in log n time, I will find\nwhether that guy is in there.",
    "start": "4038730",
    "end": "4046599"
  },
  {
    "text": "And if not, keep looping. I can keep track of the\nbest thing that I found. And so in n log n time, I\ncan definitely solve this.",
    "start": "4046600",
    "end": "4052430"
  },
  {
    "text": "But I'd like to get linear time. Do you have a question? AUDIENCE: Well,\nI'm just wondering, how would you [INAUDIBLE]?",
    "start": "4052430",
    "end": "4058512"
  },
  {
    "text": "Like, why would you\n[INAUDIBLE] whether that is in there [INAUDIBLE]? ERIK DEMAINE: I'm\nnot looking for si. I'm going to compute h minus si.",
    "start": "4058512",
    "end": "4065910"
  },
  {
    "text": "So this is-- maybe I shouldn't\neven write this down, but-- AUDIENCE: She's asking about\nthe [INAUDIBLE] constraint of,",
    "start": "4065910",
    "end": "4072090"
  },
  {
    "text": "we're not looking for h. We're looking for\nsomething smaller than h. ERIK DEMAINE: This one? Or--",
    "start": "4072090",
    "end": "4077520"
  },
  {
    "text": "AUDIENCE: Something larger. ERIK DEMAINE: Oh, this thing. AUDIENCE: A large\nthing less than h. ERIK DEMAINE: Right. So in particular, if there\nare two items that sum to h,",
    "start": "4077520",
    "end": "4086100"
  },
  {
    "text": "I want to find it. So let's start with that. So I'm binary searching\nfor h minus si in S.",
    "start": "4086100",
    "end": "4094710"
  },
  {
    "text": "So I could certainly do that. And if I find it, great.",
    "start": "4094710",
    "end": "4099736"
  },
  {
    "text": "I found a pair that\nsum to exactly h. If I don't find it, binary\nsearch tells me not only that it's not there,\nbut it tells me",
    "start": "4099737",
    "end": "4106229"
  },
  {
    "text": "what the previous\nand next value are. So even though h\nminus si isn't there, I can get the next largest thing\nand the next smallest thing.",
    "start": "4106229",
    "end": "4113430"
  },
  {
    "text": "What I want is the\nnext smallest thing. And that will be the largest\nsum I can get using si.",
    "start": "4113430",
    "end": "4119969"
  },
  {
    "text": "And so then that's one\ncandidate for a sum less than or equal to h. I want to find the largest one.",
    "start": "4119970",
    "end": "4125790"
  },
  {
    "text": "So I do a for loop. I always keep track of-- I take a list of all\nthe candidates I got. Each time I do an iteration of\nthis loop, I get one candidate.",
    "start": "4125790",
    "end": "4133528"
  },
  {
    "text": "Then I take the largest one. OK, so return largest candidate.",
    "start": "4133529",
    "end": "4139592"
  },
  {
    "start": "4139593",
    "end": "4146859"
  },
  {
    "text": "So this gives me a candidate,\njust the previous item.",
    "start": "4146859",
    "end": "4152909"
  },
  {
    "text": "This is what we called find\nprevious, or find prev, probably, in our set interface.",
    "start": "4152910",
    "end": "4158220"
  },
  {
    "text": "And if you have a sorted set,\nyou can do that in log n time. So this is an n log n solution,\nbecause we do n iterations",
    "start": "4158220",
    "end": "4167381"
  },
  {
    "text": "through the loop. Each binary search takes log n. I want to get linear.",
    "start": "4167382",
    "end": "4172509"
  },
  {
    "text": "This is not obvious. ",
    "start": "4172510",
    "end": "4180689"
  },
  {
    "text": "The best intuition I can\nthink of for this next idea is, well, I start with the\nvery smallest item in S.",
    "start": "4180689",
    "end": "4189750"
  },
  {
    "text": "And I want to sum up to\nsomething that's kind of big, right? I threw away all the\nitems bigger than h.",
    "start": "4189750",
    "end": "4196920"
  },
  {
    "text": "If s0 is like tiny,\nlike close to 0, because it's the smallest\none, then maybe I",
    "start": "4196920",
    "end": "4202680"
  },
  {
    "text": "should look at the\nend of the array, because I want to\ncompare, or I want to add the smallest\nthing probably",
    "start": "4202680",
    "end": "4208670"
  },
  {
    "text": "with the biggest thing. That's as close\nas I can imagine. So then-- so here's my sorted S.\nIt's the smallest item, biggest",
    "start": "4208670",
    "end": "4220530"
  },
  {
    "text": "item. So I'm going to loop over\nthese items one by one. So let's start by comparing the\nfirst one with the last one.",
    "start": "4220530",
    "end": "4227850"
  },
  {
    "text": " The two-finger algorithm, OK?",
    "start": "4227850",
    "end": "4234630"
  },
  {
    "start": "4234630",
    "end": "4241949"
  },
  {
    "text": "This is the big idea. You're doing it all\nthe time in this class. It's super useful. We saw it in merge sorts, for\nexample, and merging two lists.",
    "start": "4241950",
    "end": "4248880"
  },
  {
    "text": "We have fingers in two\nlists that advance. And because they only advance,\nit takes linear total time.",
    "start": "4248880",
    "end": "4254582"
  },
  {
    "text": "So we're going to do this kind\nof folded in backwards here. We're going to start here. This seems like a good\ncandidate to start with.",
    "start": "4254582",
    "end": "4260699"
  },
  {
    "text": "Now, what else\ncould this add with? Well, maybe smaller items. And maybe I have to go\nall the way through here.",
    "start": "4260700",
    "end": "4267929"
  },
  {
    "text": "And then I've got to\nadvance my left finger. Yeah, OK. So here's the idea.",
    "start": "4267930",
    "end": "4275020"
  },
  {
    "text": "So let's look at-- so I'm going to call this\nfinger i and this finger j.",
    "start": "4275020",
    "end": "4282650"
  },
  {
    "text": "So we want to sum two things. So I guess one other\ninspiration here is, we want to add two things up.",
    "start": "4282650",
    "end": "4288390"
  },
  {
    "text": "And we have one algorithm\nthat has the word \"two\" in it. And it's the\ntwo-finger algorithm. So let's try that.",
    "start": "4288390",
    "end": "4294978"
  },
  {
    "text": "So we're going to\nstart at i equals 0 and j equals n minus 1. We're going to look at si plus\nsj and see, how good is it?",
    "start": "4294978",
    "end": "4304770"
  },
  {
    "text": "How close to summing to h is it? Well, in particular, it's\neither less than or equal to h",
    "start": "4304770",
    "end": "4311400"
  },
  {
    "text": "or bigger than h. ",
    "start": "4311400",
    "end": "4317940"
  },
  {
    "text": "If it's bigger than h-- so this sum is too big. I can't even use\nit as a candidate.",
    "start": "4317940",
    "end": "4323520"
  },
  {
    "text": "Well, that means I really\ndon't need this guy, right? It's too big overall. I'm adding the smallest\nitem to this item.",
    "start": "4323520",
    "end": "4330450"
  },
  {
    "text": "And it's too big. Well, then I should\ngo to the left. I should move my right\nfinger to the left. So in this case, we decrement j.",
    "start": "4330450",
    "end": "4339750"
  },
  {
    "text": "Move the right\nfinger to the left. So I'm guessing, in this\ncase, I increment i.",
    "start": "4339750",
    "end": "4346760"
  },
  {
    "text": "Why? If I add these two items\nup, and this is too small,",
    "start": "4346760",
    "end": "4352395"
  },
  {
    "text": "it's smaller than h, then this\nitem was probably too small. It might actually--\nit's an OK solution.",
    "start": "4352395",
    "end": "4358215"
  },
  {
    "text": "It's less than or equal to h. So I should keep\nit as a candidate. Let's say add candidate.",
    "start": "4358215",
    "end": "4367800"
  },
  {
    "text": "So I'm just going to keep a\nlist of candidates that I see. So this is a possible solution.",
    "start": "4367800",
    "end": "4372900"
  },
  {
    "text": "It might not be the best one. But it's one to add to my list. And then I'm going to increase i\nand now work on this sub-array,",
    "start": "4372900",
    "end": "4380400"
  },
  {
    "text": "because that will be\na little bit bigger. I can't go this way\nto make it bigger, because I'm at the last item.",
    "start": "4380400",
    "end": "4385860"
  },
  {
    "text": "And it's not obvious\nthat this works. I think there's a nice invariant\nthat will help somewhere.",
    "start": "4385860",
    "end": "4395920"
  },
  {
    "text": "Where'd I put my piece of paper? ",
    "start": "4395920",
    "end": "4402429"
  },
  {
    "text": "Yeah.  So here's an invariant.",
    "start": "4402430",
    "end": "4408750"
  },
  {
    "start": "4408750",
    "end": "4417076"
  },
  {
    "text": "Oh, yes. ",
    "start": "4417076",
    "end": "4440672"
  },
  {
    "text": "It's really clear this\nis the right thing to do in the first step. And the tricky part is to argue\nthat it works in all steps,",
    "start": "4440672",
    "end": "4446340"
  },
  {
    "text": "because when I really have the\nsmallest item and the largest item, it's clear that I should\nadvance one or the other",
    "start": "4446340",
    "end": "4451535"
  },
  {
    "text": "if I'm too small or too big. But the way to prove it\nin general by induction is to show this invariant that--",
    "start": "4451535",
    "end": "4457290"
  },
  {
    "text": "so at some point\nthrough this execution, i and j are somewhere. And I want to say that if I\ntake any j from the right--",
    "start": "4457290",
    "end": "4463829"
  },
  {
    "text": "any j prime to the right of\nj and any i prime to the left of i, unstrictly, then\nall of those pairs,",
    "start": "4463830",
    "end": "4470310"
  },
  {
    "text": "all those pairwise sums,\nare either too big-- and that's when we decrease j-- or they're less than or equal\nto the largest candidate",
    "start": "4470310",
    "end": "4477450"
  },
  {
    "text": "that we've seen so far. That's because we added\nthese candidates in there. So that invariant will\nhold by induction,",
    "start": "4477450",
    "end": "4485280"
  },
  {
    "text": "because whenever there's a\npossible thing that's good, I add it to my candidate list. And then, at the end\nof the algorithm,",
    "start": "4485280",
    "end": "4491160"
  },
  {
    "text": "I just loop through my\ncandidate list, compute the max, return that pair. ",
    "start": "4491160",
    "end": "4498389"
  },
  {
    "text": "OK, so that is\ntwo-finger algorithm, which solves the\nnon-exact problem",
    "start": "4498390",
    "end": "4504360"
  },
  {
    "text": "in linear worst-case time. Yeah? AUDIENCE: i cannot\nequal j, right? ERIK DEMAINE: Oh,\ni cannot-- right. So what are the\ntermination conditions?",
    "start": "4504360",
    "end": "4510900"
  },
  {
    "text": "When i equals j, that's\nprobably when you want to stop. It depends. You could say, if i is\ngreater than j, stop.",
    "start": "4510900",
    "end": "4519540"
  },
  {
    "text": "Return max candidate.  There are two ways to\ninterpret this problem.",
    "start": "4519540",
    "end": "4525880"
  },
  {
    "text": "One is that the two\nvalues you choose in S need to be different\nvalues, or you",
    "start": "4525880",
    "end": "4531840"
  },
  {
    "text": "allow them to be the same value,\nlike they can both be h over 2. And either way is\neasier to solve. If you want to allow\ns over 2, then I",
    "start": "4531840",
    "end": "4539489"
  },
  {
    "text": "would put greater than here. If you don't want\nto allow h over 2, then I would put greater\nthan or equal to--",
    "start": "4539490",
    "end": "4546990"
  },
  {
    "text": "either way. Both of these problems,\nyou can solve both ways. Or both algorithms can\nhandle both situations.",
    "start": "4546990",
    "end": "4554820"
  },
  {
    "text": "OK, one more problem. ",
    "start": "4554820",
    "end": "4560950"
  },
  {
    "text": "All right. Yeah, I'm all out of time. But I'm getting\nfaster and faster.",
    "start": "4560950",
    "end": "4566740"
  },
  {
    "text": "Of course, on the\nhardest problem, I can do it the fastest. All right, so Meff Ja--",
    "start": "4566740",
    "end": "4574179"
  },
  {
    "text": "this is a reference to Jeff\nMa of the MIT Blackjack Team, who I got to speak here\nat LSC a bunch of years ago.",
    "start": "4574180",
    "end": "4579909"
  },
  {
    "text": "But he's featured in\nthe movie 21 and so on-- fictionalized.",
    "start": "4579910",
    "end": "4585909"
  },
  {
    "text": "So I was playing this game. It's a great setup. You should definitely\nread this problem--",
    "start": "4585910",
    "end": "4591220"
  },
  {
    "text": "Po- k -er. And he has a deck of\ncards, where each card has",
    "start": "4591220",
    "end": "4598930"
  },
  {
    "text": "a letter of the alphabet on it. I guess this is\nthe right way up. So I, of course,\nhave such a deck.",
    "start": "4598930",
    "end": "4604929"
  },
  {
    "text": "Doesn't everyone? You can buy these. I have several, actually. And so we can do a\nquick magic trick,",
    "start": "4604930",
    "end": "4610990"
  },
  {
    "text": "like pick a card, any\ncard-- here, pick a card. [INAUDIBLE] OK, good choice.",
    "start": "4610990",
    "end": "4617710"
  },
  {
    "text": "I can't force, so it\ndoesn't really matter. OK, and so this is\nyour card, right?",
    "start": "4617710",
    "end": "4624160"
  },
  {
    "text": "And your card is an s, right? OK, good.",
    "start": "4624160",
    "end": "4629560"
  },
  {
    "text": "No, not all the cards are s's. [LAUGHTER]",
    "start": "4629560",
    "end": "4634923"
  },
  {
    "text": "But he has mirrors\nin his glasses. No. I can reveal later\nhow that's done.",
    "start": "4634923",
    "end": "4640630"
  },
  {
    "text": "OK, so a deck of cards. Each card has 26\npossible letters on it.",
    "start": "4640630",
    "end": "4645730"
  },
  {
    "text": "And there's this\nweird dealing process. Even just defining\nthis problem is going to take a little while.",
    "start": "4645730",
    "end": "4651369"
  },
  {
    "text": "Oh, here's my piece of paper.  So we have this dealing process.",
    "start": "4651370",
    "end": "4658000"
  },
  {
    "text": "Here's an example that's\nin the program, abcdbc. ",
    "start": "4658000",
    "end": "4665020"
  },
  {
    "text": "So you know the\norder of the cards. This is the top card. This is the bottom card. And now, randomly, you do a cut.",
    "start": "4665020",
    "end": "4673449"
  },
  {
    "text": "Cut is this. So I take some chunk off the\ntop, move it to the bottom,",
    "start": "4673450",
    "end": "4680140"
  },
  {
    "text": "once, randomly. So for example, I\ncould take this cut.",
    "start": "4680140",
    "end": "4686079"
  },
  {
    "text": "And then what I would get\nis cdbc for this part that's",
    "start": "4686080",
    "end": "4693190"
  },
  {
    "text": "copied here, and ab as the--",
    "start": "4693190",
    "end": "4698840"
  },
  {
    "text": "so this is-- so the first\nthing we do is cut at i. This is position i.",
    "start": "4698840",
    "end": "4704780"
  },
  {
    "text": "In this example, i equals 2. OK, then we deal\nthe top k cards.",
    "start": "4704780",
    "end": "4713610"
  },
  {
    "text": "So let's say we deal the\ntop four cards, k equals 4. So this is deal k.",
    "start": "4713610",
    "end": "4722960"
  },
  {
    "text": "So we get cdbc, in that order. But the order doesn't matter,\nbecause the last operation",
    "start": "4722960",
    "end": "4728270"
  },
  {
    "text": "we do in the problem is\nsort them, which is bccd,",
    "start": "4728270",
    "end": "4733882"
  },
  {
    "text": "like you do when you\nget a hand of cards. You tend to sort them. OK, so this is a process. Given a deck-- so the\ndeck here is fixed.",
    "start": "4733882",
    "end": "4743330"
  },
  {
    "text": "We call this process, I\nthink, P of D comma i comma k.",
    "start": "4743330",
    "end": "4750200"
  },
  {
    "text": "We're told what D is. We're told what k is. i is chosen randomly.",
    "start": "4750200",
    "end": "4755210"
  },
  {
    "text": "And we'd like to know what\nhappens with different i's. ",
    "start": "4755210",
    "end": "4761159"
  },
  {
    "text": "So if you stare at this problem\nenough, it begins to simplify. So this is a complicated setup.",
    "start": "4761160",
    "end": "4766382"
  },
  {
    "text": "But what's really going on is\nwe're starting at position i. And we're taking the next k\ncards from there cyclically.",
    "start": "4766382",
    "end": "4772830"
  },
  {
    "text": "So here, we just\ntook those four. If i equaled 3, we would deal\nd, then b, then c, then a.",
    "start": "4772830",
    "end": "4778410"
  },
  {
    "text": "But then we sort them. OK, so we're getting different\nsubstrings of length k, cyclically.",
    "start": "4778410",
    "end": "4784350"
  },
  {
    "text": "But then we're\nsorting those letters. Sorting is really\ncrucial for this problem to at all be feasible.",
    "start": "4784350",
    "end": "4790890"
  },
  {
    "text": "It took me a while even to\nsee how to solve this problem. But the key is sorting,\nthat they get sorted,",
    "start": "4790890",
    "end": "4796949"
  },
  {
    "text": "because that means-- because we sort, it\ndoesn't matter whether you have aaba, or baaa, or abaa.",
    "start": "4796950",
    "end": "4808050"
  },
  {
    "text": "These are all the same. If you take these\ncards dealt, you sort them to the\nsame thing, which is",
    "start": "4808050",
    "end": "4815130"
  },
  {
    "text": "the one I didn't write, aaab. All of these get sorted\nto the same thing.",
    "start": "4815130",
    "end": "4820150"
  },
  {
    "text": "So we lost some information\nwhen we sort, lost the order. The first question\nto get you thinking",
    "start": "4820150",
    "end": "4825680"
  },
  {
    "text": "in this direction, part a,\nsays, build a data structure given D and k that lets me know,\ngiven two indices, i and j,",
    "start": "4825680",
    "end": "4836600"
  },
  {
    "text": "do I end up with\nthe exact same hand? This thing is called a hand.",
    "start": "4836600",
    "end": "4843080"
  },
  {
    "text": "And it's exactly this P D, i, k. So I want to do P D,\ni, k and P, d, j, k.",
    "start": "4843080",
    "end": "4850610"
  },
  {
    "text": "And I want to know-- JK. And I want to know whether\nthose two things are equal in constant time.",
    "start": "4850610",
    "end": "4857340"
  },
  {
    "text": "That's what this says-- constant time. Doesn't say worst case,\nbut worst case is possible.",
    "start": "4857340",
    "end": "4862835"
  },
  {
    "text": " And that sounds hard,\nbecause, I mean,",
    "start": "4862835",
    "end": "4868160"
  },
  {
    "text": "there's k symbols for one\nof them, another k symbols for the other guy. But we don't have to\ncompare the symbols. We just need to compare the\nsorting of those strings.",
    "start": "4868160",
    "end": "4877220"
  },
  {
    "text": "And this, we can compress. So this is a subtlety. But all I really need to know\nis that there are three a's",
    "start": "4877220",
    "end": "4884210"
  },
  {
    "text": "here, and one b, and zero\nc's, and zero d's, and zero",
    "start": "4884210",
    "end": "4890260"
  },
  {
    "text": "e's, and so on. But because there's only\n26 letters in this deck--",
    "start": "4890260",
    "end": "4895310"
  },
  {
    "text": "and indeed, in this deck, it\nhappens upper and lowercase a through z. But we might have n cards.",
    "start": "4895310",
    "end": "4901220"
  },
  {
    "text": "But there are only\n26 possible labels. So in fact, a lot\nof them are going to be equal if n is large.",
    "start": "4901220",
    "end": "4906390"
  },
  {
    "text": "So this is a good\ncompression scheme, because to represent the things\nI get after sorting, I just",
    "start": "4906390",
    "end": "4912620"
  },
  {
    "text": "need to give you 26 numbers. And for us, 26 is small,\nbecause 26 is a constant.",
    "start": "4912620",
    "end": "4918050"
  },
  {
    "text": "Independent of the number of\ncards, I just need to say, how many a's are there? It could be anywhere\nbetween 0 and n.",
    "start": "4918050",
    "end": "4923630"
  },
  {
    "text": "How many b's are there? Between 0 and n. How many c's are there? Between 0 and n. So 26 numbers in\nthe range 0 to n--",
    "start": "4923630",
    "end": "4935690"
  },
  {
    "text": "I like to think of this as a\n26-digit number base n plus 1.",
    "start": "4935690",
    "end": "4944480"
  },
  {
    "text": "We can map this\ninto base n plus 1. And we get 26\ndigits In that base.",
    "start": "4944480",
    "end": "4956360"
  },
  {
    "text": "Another way to say it is\nthat the number of possible combinations here-- how many\na's, how many b's, how many",
    "start": "4956360",
    "end": "4962240"
  },
  {
    "text": "c's-- is not even theta. It is n plus 1, anything between\n0 and n, to the power of 26.",
    "start": "4962240",
    "end": "4971120"
  },
  {
    "text": "This is a good polynomial. So I can do stuff\nlike radix sort.",
    "start": "4971120",
    "end": "4978630"
  },
  {
    "text": " Cool. So let me summarize a little\nbit how we solve part a.",
    "start": "4978630",
    "end": "4987330"
  },
  {
    "text": "So I want to build a\ndata structure, which is, for each value i,\nI know I'm going",
    "start": "4987330",
    "end": "4992960"
  },
  {
    "text": "to end up serving these four\ncards, or in general, k cards. So for those cards, I\nwould like to compute",
    "start": "4992960",
    "end": "5000915"
  },
  {
    "text": "how many a's, how many b's,\nhow many c's are there? And then just write\ndown this number. This is a number\nwhich I can write down",
    "start": "5000915",
    "end": "5007470"
  },
  {
    "text": "in at most 26 words, because we\ncan represent numbers between 0 and n in a single word.",
    "start": "5007470",
    "end": "5013660"
  },
  {
    "text": "That's the w is at\nleast log n assumption. So it's constant size. In a constant\nnumber of numbers, I",
    "start": "5013660",
    "end": "5021130"
  },
  {
    "text": "can represent all I need to\nknow about a thing of size-- of length k here.",
    "start": "5021130",
    "end": "5026480"
  },
  {
    "text": "So I don't need to know\nwhich letters is where. I just need to know\nthe sorted order. So I just need to know-- this\nis called a frequency table--",
    "start": "5026480",
    "end": "5033489"
  },
  {
    "text": "how many a's, how many b's? And so if I can compute those,\nthen given that representation",
    "start": "5033490",
    "end": "5039010"
  },
  {
    "text": "for starting at i, and\ngiven that representation for starting at j,\nsay, which would",
    "start": "5039010",
    "end": "5044300"
  },
  {
    "text": "be these two and these\ntwo, I can compare them by just comparing\nthose 26 numbers.",
    "start": "5044300",
    "end": "5049780"
  },
  {
    "text": "If they're all\nequal, then they're the same string after sorting. And if there's any difference,\nthen they're different.",
    "start": "5049780",
    "end": "5055510"
  },
  {
    "text": "So that's how I could\ndo it in constant time if I can compute\nthese representations. And it's not hard to do that.",
    "start": "5055510",
    "end": "5061660"
  },
  {
    "text": "It's called a sliding window\ntechnique, where you compute it for the first k guys. And then you remove this\nitem and add this item.",
    "start": "5061660",
    "end": "5069370"
  },
  {
    "text": "And just by incrementing\nthe counter for b, decrementing the\ncounter for a, now I know the representation\nfor these guys.",
    "start": "5069370",
    "end": "5077180"
  },
  {
    "text": "Make a copy of that, which is\na copy of those 26 numbers, constant. Then I add on c, remove b.",
    "start": "5077180",
    "end": "5083110"
  },
  {
    "text": "Then I add on a, remove c,\nadd on d, remove d, add on c,",
    "start": "5083110",
    "end": "5089530"
  },
  {
    "text": "remove b, and add\non d, and remove c. Well, I got back\nto the beginning.",
    "start": "5089530",
    "end": "5095400"
  },
  {
    "text": "So now I have\nrepresentation of those. OK, so by sliding\nthis window, I'm only changing at the two ends.",
    "start": "5095400",
    "end": "5102640"
  },
  {
    "text": "I add one guy on. I increment one\nof these counters. I decrement one\nof these counters. So in constant time,\ngiven the representation",
    "start": "5102640",
    "end": "5109620"
  },
  {
    "text": "of one of these substrings, I\ncan compute the representation of the next one. And that's how I,\nin linear time,",
    "start": "5109620",
    "end": "5114760"
  },
  {
    "text": "can build such a\ndata structure that lets me tell whether\nany two hands are equal.",
    "start": "5114760",
    "end": "5119860"
  },
  {
    "text": "The next problem,\npart b, is, given all these\nrepresentations, can you",
    "start": "5119860",
    "end": "5125650"
  },
  {
    "text": "find which one is\nthe most common? Because we were choosing\ni uniformly at random, I want to know what the most\nlikely hand that you get is.",
    "start": "5125650",
    "end": "5133930"
  },
  {
    "text": "And I think the\neasiest way to say this is you can do\nthat by radix sorting. You take all these\nrepresentations.",
    "start": "5133930",
    "end": "5140179"
  },
  {
    "text": "They are nice numbers\nin the range 0 to n plus 1 to the 26th power. So I can just run radix\nsort and sort them all.",
    "start": "5140180",
    "end": "5147489"
  },
  {
    "text": "And then with a single\nscan through the array, I can see which one\nis the most common. Or rather, I can--",
    "start": "5147490",
    "end": "5153120"
  },
  {
    "text": "in a single scan, I can compute,\nOK, how many of the same things are at the front? If they're sorted, then all the\nequal ones will be together.",
    "start": "5153120",
    "end": "5160310"
  },
  {
    "text": "So how many are there? Then how many equal ones next? And how many equal ones next? Each time, comparing each\nitem to the previous one.",
    "start": "5160310",
    "end": "5167949"
  },
  {
    "text": "Then I get frequency counts\nfor all of these hands. And then I do another scan\nto find the most common one.",
    "start": "5167950",
    "end": "5173770"
  },
  {
    "text": "And I can do another scan to\nfind the lexically best one, lexically last one.",
    "start": "5173770",
    "end": "5179005"
  },
  {
    "text": "And that's how you\nsolve problem 5. ",
    "start": "5179005",
    "end": "5188000"
  }
]