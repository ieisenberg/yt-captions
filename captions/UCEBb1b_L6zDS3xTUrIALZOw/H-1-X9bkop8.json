[
  {
    "start": "0",
    "end": "66000"
  },
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "7040"
  },
  {
    "text": "continue to offer high quality,\neducational resources for free. To make a donation or to\nview additional materials",
    "start": "7040",
    "end": "13865"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13865",
    "end": "19026"
  },
  {
    "text": " JULIAN SHUN: So welcome to\nthe second lecture of 6.172,",
    "start": "19026",
    "end": "25980"
  },
  {
    "text": "performance engineering\nof software systems. Today, we're going to be\ntalking about Bentley rules",
    "start": "25980",
    "end": "32219"
  },
  {
    "text": "for optimizing work. All right, so work, does\nanyone know what work means?",
    "start": "32220",
    "end": "41496"
  },
  {
    "text": "You're all at MIT,\nso you should know. So in terms of\ncomputer programming,",
    "start": "41496",
    "end": "48239"
  },
  {
    "text": "there's actually a formal\ndefinition of work. The work of a program\non a particular input",
    "start": "48240",
    "end": "54015"
  },
  {
    "text": "is defined to be the sum total\nof all the operations executed by the program.",
    "start": "54015",
    "end": "59199"
  },
  {
    "text": "So it's basically\na gross measure of how much stuff the\nprogram needs to do. ",
    "start": "59200",
    "end": "66306"
  },
  {
    "start": "66000",
    "end": "66000"
  },
  {
    "text": "And the idea of\noptimizing work is to reduce the amount of\nstuff that the program needs to do in order to improve the\nrunning time of your program,",
    "start": "66306",
    "end": "74840"
  },
  {
    "text": "improve its performance. So algorithm design can\nproduce dramatic reductions",
    "start": "74840",
    "end": "80250"
  },
  {
    "text": "in the work of a program. For example, if you want to\nsort an array of elements,",
    "start": "80250",
    "end": "85740"
  },
  {
    "text": "you can use a nlogn\ntime QuickSort. Or you can use an n squared\ntime sort, like insertion sort.",
    "start": "85740",
    "end": "92640"
  },
  {
    "text": "So you've probably\nseen this before in your algorithm courses. And for large\nenough values of n,",
    "start": "92640",
    "end": "98910"
  },
  {
    "text": "a nlogn time sort\nis going to be much faster than a n squared sort.",
    "start": "98910",
    "end": "103935"
  },
  {
    "text": "So today, I'm not going to be\ntalking about algorithm design. You'll see more of this in\nother courses here at MIT.",
    "start": "103935",
    "end": "110410"
  },
  {
    "text": "And we'll also talk a little\nbit about algorithm design later on in this semester. ",
    "start": "110410",
    "end": "118116"
  },
  {
    "text": "We will be talking about many\nother cool tricks for reducing the work of a program. But I do want to point\nout, that reducing",
    "start": "118116",
    "end": "123900"
  },
  {
    "text": "the work of our program\ndoesn't automatically translate to a reduction in running time. And this is because\nof the complex nature",
    "start": "123900",
    "end": "130860"
  },
  {
    "text": "of computer hardware. So there's a lot of things\ngoing on that aren't captured by this definition of work.",
    "start": "130860",
    "end": "137610"
  },
  {
    "text": "There's instruction level\nparallelism, caching, vectorization, speculation and\nbranch prediction, and so on.",
    "start": "137610",
    "end": "144569"
  },
  {
    "text": "And we'll learn about\nsome of these things throughout this semester. But reducing the\nwork of our program",
    "start": "144570",
    "end": "150599"
  },
  {
    "text": "does serve as a good\nheuristic for reducing the overall running time\nof a program, at least",
    "start": "150600",
    "end": "155850"
  },
  {
    "text": "to a first order. So today, we'll be\nlearning about many ways to reduce the work\nof your program.",
    "start": "155850",
    "end": "163328"
  },
  {
    "text": "So rules we'll be\nlooking at, we call them Bentley optimization rules,\nin honor of John Lewis Bentley.",
    "start": "163328",
    "end": "172120"
  },
  {
    "start": "170000",
    "end": "170000"
  },
  {
    "text": "So John Lewis Bentley wrote\na nice little book back in 1982 called Writing\nEfficient Programs.",
    "start": "172120",
    "end": "178750"
  },
  {
    "text": "And inside this book there\nare various techniques for reducing the work\nof a computer program.",
    "start": "178750",
    "end": "185860"
  },
  {
    "text": "So if you haven't seen this\nbook before, it's very good. So I highly encourage\nyou to read it.",
    "start": "185860",
    "end": "192730"
  },
  {
    "text": " Many of the original\nrules in Bentley's book",
    "start": "192730",
    "end": "199209"
  },
  {
    "start": "198000",
    "end": "198000"
  },
  {
    "text": "had to deal with the vagaries\nof computer architecture three and a half decades ago.",
    "start": "199210",
    "end": "205146"
  },
  {
    "text": "So today, we've\ncreated a new set of Bentley rules just dealing\nwith the work of a program.",
    "start": "205146",
    "end": "210355"
  },
  {
    "text": "We'll be talking about\narchitecture-specific optimizations later\non in the semester.",
    "start": "210355",
    "end": "215880"
  },
  {
    "text": "But today, we won't\nbe talking about this. ",
    "start": "215880",
    "end": "221241"
  },
  {
    "text": "One cool fact is that John\nLewis Bentley is actually my academic great grandfather.",
    "start": "221242",
    "end": "227530"
  },
  {
    "text": "So John Bentley was one\nof Charles Leiseron's academic advisors.",
    "start": "227530",
    "end": "232795"
  },
  {
    "text": "Charles Leiserson was Guy\nBlelloch's academic advisor. And Guy Blelloch, who's a\nprofessor at Carnegie Mellon,",
    "start": "232795",
    "end": "238629"
  },
  {
    "text": "was my advisor when I was\na graduate student at CMU. So it's a nice little fact.",
    "start": "238630",
    "end": "243880"
  },
  {
    "text": "And I had the honor of meeting\nJohn Bentley a couple of years ago at a conference. And he told me that he was my\nacademic great grandfather.",
    "start": "243880",
    "end": "250720"
  },
  {
    "text": "[LAUGHING]  Yeah, and Charles is my\nacademic grandfather.",
    "start": "250720",
    "end": "256614"
  },
  {
    "text": "And all of Charles's students\nare my academic aunts and uncles-- [LAUGHING] ",
    "start": "256614",
    "end": "262546"
  },
  {
    "text": "--including your T.A. Helen.  OK, so here's a list of\nall the work optimizations",
    "start": "262546",
    "end": "271195"
  },
  {
    "text": "that we'll be looking at today. So they're grouped into four\ncategories, data structures,",
    "start": "271195",
    "end": "277285"
  },
  {
    "start": "272000",
    "end": "272000"
  },
  {
    "text": "loops, and functions. So there's a list of 22\nrules on this slide today.",
    "start": "277285",
    "end": "283728"
  },
  {
    "text": "In fact, we'll actually be able\nto look at all of them today. So today's lecture is\ngoing to be structured as a series of many lectures.",
    "start": "283728",
    "end": "290155"
  },
  {
    "text": "And I'm going to be spending\none to three slides on each one of these optimizations.",
    "start": "290155",
    "end": "296398"
  },
  {
    "text": "All right, so let's\nstart with optimizations for data structures.",
    "start": "296398",
    "end": "303195"
  },
  {
    "text": "So first optimization\nis packing and encoding your data structure.",
    "start": "303196",
    "end": "308990"
  },
  {
    "text": "And the idea of packing is to\nstore more than one data value in a machine word. And the related\nidea of encoding is",
    "start": "308990",
    "end": "315860"
  },
  {
    "text": "to convert data values\ninto a representation that requires fewer bits.",
    "start": "315860",
    "end": "320960"
  },
  {
    "text": "So does anyone know why\nthis could possibly reduce the running time of a program? ",
    "start": "320960",
    "end": "328470"
  },
  {
    "text": "Yes? AUDIENCE: Need less\nmemory fetches. JULIAN SHUN: Right,\nso good answer. The answer was, it might\nneed less memory fetches.",
    "start": "328470",
    "end": "335035"
  },
  {
    "text": "And it turns out\nthat that's correct, because computer program\nspends a lot of time moving",
    "start": "335035",
    "end": "340539"
  },
  {
    "text": "stuff around in memory. And if you reduce\nthe number of things that you have to move\naround in memory,",
    "start": "340540",
    "end": "346060"
  },
  {
    "text": "then that's a good heuristic\nfor reducing the running time of your program.",
    "start": "346060",
    "end": "351175"
  },
  {
    "text": "So let's look at an example. Let's say we wanted\nto encode dates. So let's say we wanted to code\nthis string, September 11,",
    "start": "351175",
    "end": "359470"
  },
  {
    "text": "2018. You can store this\nusing 18 bytes. So you can use one byte\nper character here.",
    "start": "359470",
    "end": "367300"
  },
  {
    "text": "And this would require\nmore than two double words, because each double word\nis eight bytes or 64 bits.",
    "start": "367300",
    "end": "373720"
  },
  {
    "text": "And you have 18 bytes. You need more than\ntwo double words. And you have to move\naround these words",
    "start": "373720",
    "end": "378970"
  },
  {
    "text": "every time you want to\nmanipulate the date. But turns out that\nyou can actually",
    "start": "378970",
    "end": "385240"
  },
  {
    "text": "do better than using 18 bytes. So let's assume that we\nonly want to store years",
    "start": "385240",
    "end": "391180"
  },
  {
    "text": "between 4096 BCE and 4096 CE.",
    "start": "391180",
    "end": "397030"
  },
  {
    "text": "So there are about\n365.25 times 8,192 dates",
    "start": "397030",
    "end": "403480"
  },
  {
    "text": "in this range, which is\nthree million approximately. And you can use log base\ntwo of three million bits",
    "start": "403480",
    "end": "410740"
  },
  {
    "text": "to represent all the\ndates within this range. So the notation lg here\nmeans log base of two.",
    "start": "410740",
    "end": "417600"
  },
  {
    "text": "That's going to be the notation\nI'll be using in this class. And L-O-G will mean log base 10.",
    "start": "417600",
    "end": "425110"
  },
  {
    "text": "So we take the ceiling of log\nbase two or three million, and that gives us 22 bits.",
    "start": "425110",
    "end": "431995"
  },
  {
    "text": "So a good way to remember\nhow to compute the log base two of something, you\ncan remember that the log base",
    "start": "431995",
    "end": "439780"
  },
  {
    "text": "two of one million is 20,\nlog base two of 1,000 is 10. And then you can factor this\nout and then add in log base",
    "start": "439780",
    "end": "447820"
  },
  {
    "text": "two of three, rounded\nup, which is two. So that gives you 22 bits. And that easily fits\nwithin one 32-bit words.",
    "start": "447820",
    "end": "455680"
  },
  {
    "text": "Now, you only need one word\ninstead of three words, as you did in the\noriginal representation.",
    "start": "455680",
    "end": "461860"
  },
  {
    "text": "But with this modified\nrepresentation, now determining the month\nof a particular date will take more work, because\nnow you're not explicitly",
    "start": "461860",
    "end": "469315"
  },
  {
    "text": "storing the month in\nyour representation. Whereas, with the\nstring representation, you are explicitly storing it\nat the beginning of the string.",
    "start": "469315",
    "end": "478074"
  },
  {
    "text": "So this does take more work,\nbut it requires less space. So any questions so far?",
    "start": "478075",
    "end": "483460"
  },
  {
    "start": "483460",
    "end": "489781"
  },
  {
    "text": "OK, so it turns out\nthat there's another way to store this, which\nalso makes it easy",
    "start": "489782",
    "end": "496770"
  },
  {
    "start": "494000",
    "end": "494000"
  },
  {
    "text": "for you to fetch the\nmonth, the year, or the day for a particular date.",
    "start": "496770",
    "end": "503380"
  },
  {
    "text": "So here, we're going to use\nthe bit fields facilities in C. So we're going to create a\nstruct called date underscore t",
    "start": "503380",
    "end": "512054"
  },
  {
    "text": "with three fields, the year,\nthe month, and the date. And the integer\nafter the semicolon",
    "start": "512054",
    "end": "518610"
  },
  {
    "text": "specifies how many\nbits I want to assign to this particular\nfield in the struct. So this says, I need\n13 bits for the year,",
    "start": "518610",
    "end": "526680"
  },
  {
    "text": "four bits for the month,\nand five bits for the day. So the 13 bits for\nthe year is, because I",
    "start": "526680",
    "end": "531840"
  },
  {
    "text": "have 8,192 possible years. So I need 13 bits to store that.",
    "start": "531840",
    "end": "537930"
  },
  {
    "text": "For the month, I have\n12 possible months. So I need log base two of 12\nrounded up, which is four.",
    "start": "537930",
    "end": "543480"
  },
  {
    "text": "And then finally,\nfor the day, I need log base two of 31\nrounded up, which is five.",
    "start": "543480",
    "end": "549270"
  },
  {
    "text": "So in total, this\nstill takes 22 bits. But now the individual\nfields can now",
    "start": "549270",
    "end": "554790"
  },
  {
    "text": "be accessed much more\nquickly, than if we had just encoded the three million dates\nusing sequential integers,",
    "start": "554790",
    "end": "562320"
  },
  {
    "text": "because now you can just extract\na month just by saying whatever",
    "start": "562320",
    "end": "568223"
  },
  {
    "text": "you named your struct. You can just say that\nstruct dot month. And that give you the month.",
    "start": "568223",
    "end": "573570"
  },
  {
    "text": "Yes? AUDIENCE: Does C actually\nstore it like that, because I know C++\nit makes it finalize.",
    "start": "573570",
    "end": "579094"
  },
  {
    "text": "So then you end up\ntaking more space. JULIAN SHUN: Yeah,\nso this will actually pad the struct a little\nbit at the end, yeah.",
    "start": "579094",
    "end": "587220"
  },
  {
    "text": "So you actually do require a\nlittle bit more than 22 bits. That's a good question.",
    "start": "587220",
    "end": "592889"
  },
  {
    "text": " But this representation is\nmuch more easy to access,",
    "start": "592890",
    "end": "599175"
  },
  {
    "text": "than if you just had\nencoded the integers as sequential integers. ",
    "start": "599175",
    "end": "609090"
  },
  {
    "text": "Another point is that sometimes\nunpacking and decoding are the optimization,\nbecause sometimes it",
    "start": "609090",
    "end": "614880"
  },
  {
    "text": "takes a lot of work to encode\nthe values and to extract them.",
    "start": "614880",
    "end": "621630"
  },
  {
    "text": "So sometimes you want to\nactually unpack the values so that they take more space,\nbut they're faster to access.",
    "start": "621630",
    "end": "628170"
  },
  {
    "text": "So it depends on your\nparticular application. You might want to do\none thing or the other. And the way to figure this out\nis just to experiment with it.",
    "start": "628170",
    "end": "635610"
  },
  {
    "text": " OK, so any other questions?",
    "start": "635610",
    "end": "641235"
  },
  {
    "start": "641235",
    "end": "650893"
  },
  {
    "text": "All right, so the\nsecond optimization is data structure augmentation.",
    "start": "650893",
    "end": "657030"
  },
  {
    "start": "653000",
    "end": "653000"
  },
  {
    "text": "And the idea here is to add\ninformation to a data structure to make common\noperations do less work,",
    "start": "657030",
    "end": "663259"
  },
  {
    "text": "so that they're faster. And let's look at an example. Let's say we had two\nsingly linked list",
    "start": "663260",
    "end": "670090"
  },
  {
    "text": "and we wanted to\nappend them together. And let's say we only stored\nthe head pointer to the list,",
    "start": "670090",
    "end": "677240"
  },
  {
    "text": "and then each\nelement in the list has a pointer to the\nnext element in the list.",
    "start": "677240",
    "end": "682725"
  },
  {
    "text": "Now, if you want to spend\none list to another list, well, that's going to require\nyou walking down the first list",
    "start": "682726",
    "end": "689930"
  },
  {
    "text": "to find the last\nelement, so that you can change the pointer\nof the last element to point to the beginning\nof the next list.",
    "start": "689930",
    "end": "697024"
  },
  {
    "text": "And this might be very slow if\nthe first list is very long.",
    "start": "697025",
    "end": "702400"
  },
  {
    "text": "So does anyone see a way to\naugment this data structure so that appending two lists can\nbe done much more efficiently?",
    "start": "702400",
    "end": "710790"
  },
  {
    "text": "Yes? AUDIENCE: Store a pointer\nto the last value. JULIAN SHUN: Yeah,\nso the answer is",
    "start": "710790",
    "end": "716610"
  },
  {
    "text": "to store a pointer\nto the last value. And we call that\nthe tail pointer. So now we have two pointers,\nboth the head and the tail.",
    "start": "716610",
    "end": "723195"
  },
  {
    "text": "The head points to the\nbeginning of the list. The tail points to\nthe end of the list. And now you can just append\ntwo lists in constant time,",
    "start": "723195",
    "end": "730230"
  },
  {
    "text": "because you can access the\nlast element in the list by following the tail pointer. And then now you just\nchange the successor pointer",
    "start": "730230",
    "end": "736980"
  },
  {
    "text": "of the last element to point\nto the head of the second list. And then now you also\nhave to update the tail",
    "start": "736980",
    "end": "742860"
  },
  {
    "text": "to point to the end\nof the second list. OK, so that's the idea of\ndata structure augmentation.",
    "start": "742860",
    "end": "748650"
  },
  {
    "text": "We added a little bit\nof extra information to the data structure,\nsuch that now appending",
    "start": "748650",
    "end": "753960"
  },
  {
    "text": "two lists is much more efficient\nthan in the original method, where we only had\na head pointer. ",
    "start": "753960",
    "end": "761120"
  },
  {
    "text": "Questions? ",
    "start": "761120",
    "end": "767667"
  },
  {
    "text": "OK, so the next optimization\nis precomputation.",
    "start": "767667",
    "end": "773740"
  },
  {
    "start": "772000",
    "end": "772000"
  },
  {
    "text": "The idea of precomputation is\nto perform some calculations in advance so as to avoid\ndoing these computations",
    "start": "773740",
    "end": "780615"
  },
  {
    "text": "at mission-critical times, to\navoid doing them at runtime. So let's say we had\na program that needed",
    "start": "780615",
    "end": "788639"
  },
  {
    "text": "to use binomial coefficients. And here's a definition\nof a binomial coefficient.",
    "start": "788640",
    "end": "794820"
  },
  {
    "text": "So it's basically\nthe choose function. So you want to count\nthe number of ways",
    "start": "794820",
    "end": "799860"
  },
  {
    "text": "that you can choose k things\nfrom a set of n things. And the formula\nfor computing this",
    "start": "799860",
    "end": "805470"
  },
  {
    "text": "is, n factorial divided by the\nproduct of k factorial and n minus k factorial.",
    "start": "805470",
    "end": "812650"
  },
  {
    "text": "Computing this choose\nfunction can actually be quite expensive,\nbecause you have to do a lot of multiplications\nto compute the factorial,",
    "start": "812650",
    "end": "820570"
  },
  {
    "text": "even if the final\nresult is not that big, because you have to compute one\nterm in the numerator and then",
    "start": "820570",
    "end": "827220"
  },
  {
    "text": "two factorial terms\nin the denominator. And then you also might run\ninto integer overflow issues,",
    "start": "827220",
    "end": "832920"
  },
  {
    "text": "because n factorial\ngrows very fast. It grows super exponentially.",
    "start": "832920",
    "end": "838420"
  },
  {
    "text": "It grows like n to the n,\nwhich is even faster than two to the n, which is exponential.",
    "start": "838420",
    "end": "843900"
  },
  {
    "text": "So doing this\ncomputation, you have to be very careful with\ninteger overflow issues. ",
    "start": "843900",
    "end": "852062"
  },
  {
    "text": "So one idea to speed\nup a program that uses these binomials\ncoefficients is to precompute a\ntable of coefficients",
    "start": "852062",
    "end": "858780"
  },
  {
    "text": "when you initialize\nthe program, and then just perform table lookup\non this precomputed table",
    "start": "858780",
    "end": "864240"
  },
  {
    "text": "at runtime when you need\nthe binomial coefficient. So does anyone know\nwhat the table that",
    "start": "864240",
    "end": "872010"
  },
  {
    "text": "stores binomial\ncoefficients is called? Yes? AUDIENCE: [INAUDIBLE]",
    "start": "872010",
    "end": "878402"
  },
  {
    "text": "JULIAN SHUN: Yea,\nPascal's triangles, good. So here is what Pascal's\ntriangle looks like.",
    "start": "878402",
    "end": "886160"
  },
  {
    "start": "885000",
    "end": "885000"
  },
  {
    "text": "So on the vertical axis, we\nhave different values of n. And then on the horizontal axis,\nwe have different values of k.",
    "start": "886160",
    "end": "893540"
  },
  {
    "text": "And then to get\nand choose k, you just go to the nth\nrow in the case column",
    "start": "893540",
    "end": "899465"
  },
  {
    "text": "and look up that entry. Pascal's triangle\nhas a nice property,",
    "start": "899465",
    "end": "904505"
  },
  {
    "text": "that for every element,\nit can be computed as a sum of the element\ndirectly above it and above it",
    "start": "904505",
    "end": "912230"
  },
  {
    "text": "and to the left of it. So here, 56 is the\nsum of 35 and 21.",
    "start": "912230",
    "end": "919201"
  },
  {
    "text": "And this gives us a\nnice formula to compute the binomial coefficients.",
    "start": "919201",
    "end": "925315"
  },
  {
    "text": "So we first check if n is less\nthan k in this choose function.",
    "start": "925315",
    "end": "931640"
  },
  {
    "text": "If n is less than\nk, then we just return zero,\nbecause we're trying to choose more things\nthan there are in a set.",
    "start": "931640",
    "end": "939971"
  },
  {
    "text": "If n is equal to\nzero, then we just return one, because here k\nmust also be equal to zero,",
    "start": "939971",
    "end": "948800"
  },
  {
    "text": "since we had the condition\nn less than k above. And there's one way\nto choose zero things from a set of zero things.",
    "start": "948800",
    "end": "955970"
  },
  {
    "text": "And then if k is\nequal to zero, we also return one, because\nthere's only one way to choose zero things from a\nset of any number of things.",
    "start": "955970",
    "end": "964400"
  },
  {
    "text": "You just don't pick anything. And then finally, we recursively\ncall this choose function.",
    "start": "964400",
    "end": "970279"
  },
  {
    "text": "So we call choose of n\nminus one k minus one. This is essentially the entry\nabove and diagonal to this.",
    "start": "970280",
    "end": "979196"
  },
  {
    "text": "And then we add in choose\nof n minus one k, which is the entry directly above it.",
    "start": "979196",
    "end": "986576"
  },
  {
    "text": "So this is a recursive function\nfor generating this Pascal's triangle.",
    "start": "986576",
    "end": "992180"
  },
  {
    "text": "But notice that we're actually\nstill not doing precomputation, because every time we\ncall this choose function,",
    "start": "992180",
    "end": "998390"
  },
  {
    "text": "we're making two\nrecursive calls. And this can still\nbe pretty expensive.",
    "start": "998390",
    "end": "1004582"
  },
  {
    "text": "So how can we actually\nprecompute this table? ",
    "start": "1004582",
    "end": "1011438"
  },
  {
    "start": "1010000",
    "end": "1010000"
  },
  {
    "text": "So here's some C code for\nprecomputing Pascal's triangle. And let's say we only\nwanted coefficients up",
    "start": "1011438",
    "end": "1019110"
  },
  {
    "text": "to choose sides of 100. So we initialize\nmatrix of 100 by 100.",
    "start": "1019110",
    "end": "1026681"
  },
  {
    "text": "And then we call this\nan init choose function. So first it goes from n\nequal zero, all the way up",
    "start": "1026681",
    "end": "1033119"
  },
  {
    "text": "to choose size minus one. And then it says, choose\nn of zero to be one.",
    "start": "1033119",
    "end": "1038334"
  },
  {
    "text": "It also sets choose\nof n, n to be one. So the first line\nis, because there's",
    "start": "1038334",
    "end": "1044490"
  },
  {
    "text": "only one way to\nchoose zero things from any number of things. And the second line is,\nbecause there's only one way",
    "start": "1044490",
    "end": "1049945"
  },
  {
    "text": "to choose n things\nfrom n things, which is just to pick all of them. And then now we\nhave a second loop,",
    "start": "1049945",
    "end": "1056129"
  },
  {
    "text": "which goes from n equals\none, all the way up to choose size minus one. Then first we set\nchoose of zero n",
    "start": "1056130",
    "end": "1064410"
  },
  {
    "text": "to be zero, because here n is-- or k is greater than n.",
    "start": "1064410",
    "end": "1069520"
  },
  {
    "text": "So there's no way to\npick more elements from a set of things that is\nless than the number of things",
    "start": "1069520",
    "end": "1077789"
  },
  {
    "text": "you want to pick. And then now you loop from k\nequals one, all the way up to n minus one.",
    "start": "1077790",
    "end": "1082950"
  },
  {
    "text": "And then your apply\nthis recursive formula. So choose of n, k is\nequal to choose of n minus one, k minus one plus\nchoose of n minus one k.",
    "start": "1082950",
    "end": "1091986"
  },
  {
    "text": "And then you also set\nchoose of k, n to be zero. So this is basically all of\nthe entries above the diagonal",
    "start": "1091986",
    "end": "1099090"
  },
  {
    "text": "here, where k is greater than n. And then now inside\nthe program whenever",
    "start": "1099090",
    "end": "1105330"
  },
  {
    "text": "we need a binomial coefficient\nthat's less than 100, we can just do table\nlookup into this table.",
    "start": "1105330",
    "end": "1111919"
  },
  {
    "text": "And we just index and\nthen just choose array. ",
    "start": "1111920",
    "end": "1117484"
  },
  {
    "text": "So does this make sense? Any questions? ",
    "start": "1117484",
    "end": "1123688"
  },
  {
    "text": "It's pretty easy so far, right? ",
    "start": "1123688",
    "end": "1128929"
  },
  {
    "text": "So one thing to note\nis, that we're still computing this table\nat runtime, because we have to initialize\nthis table at runtime.",
    "start": "1128930",
    "end": "1135730"
  },
  {
    "text": "And if we want to run\nour program many times, then we have to initialize\nthis table many times.",
    "start": "1135730",
    "end": "1142850"
  },
  {
    "text": "So is there a way to only\ninitialize this table once, even though we might want to\nrun the program many times?",
    "start": "1142850",
    "end": "1150705"
  },
  {
    "text": "Yes? AUDIENCE: Put in\nthe source code. JULIAN SHUN: Yeah, so good,\nso put it in the source code.",
    "start": "1150706",
    "end": "1158633"
  },
  {
    "text": "And so we're going to do\ncompile-time initialization. And if you put the table\nin the source code,",
    "start": "1158634",
    "end": "1164710"
  },
  {
    "text": "then the compiler\nwill compile this code and generate the table\nfor you that compile time. So now whenever you\nrun it, you don't",
    "start": "1164710",
    "end": "1171022"
  },
  {
    "text": "have to spend time\ninitializing the table. So idea of compile-time\ninitialization",
    "start": "1171022",
    "end": "1176065"
  },
  {
    "text": "is to store the\nvalues of constants during compilation\nand, therefore, saving work at runtime.",
    "start": "1176065",
    "end": "1183946"
  },
  {
    "text": "So let's say we wanted\nchoose values up to 10. This is the table, the\n10 by 10 table storing",
    "start": "1183946",
    "end": "1192010"
  },
  {
    "text": "all of the binomial\ncoefficients up to 10. So if you put this\nin your source code,",
    "start": "1192010",
    "end": "1197289"
  },
  {
    "text": "now when you run\nthe program, you can just index into this table\nto get the appropriate constant",
    "start": "1197290",
    "end": "1203500"
  },
  {
    "text": "here. But this table was\njust a 10 by 10 table.",
    "start": "1203500",
    "end": "1208764"
  },
  {
    "text": "What if you wanted a\ntable of 1,000 by 1,000? Does anyone actually want to\ntype this in, a table of 1,000",
    "start": "1208765",
    "end": "1216400"
  },
  {
    "text": "by 1,000? So probably not.",
    "start": "1216400",
    "end": "1222210"
  },
  {
    "text": "So is there any way\nto get around this? ",
    "start": "1222210",
    "end": "1228260"
  },
  {
    "text": "Yes? AUDIENCE: You could make\na program that uses it. And the function will be\ndefined [INAUDIBLE] prints out the zero [INAUDIBLE].",
    "start": "1228260",
    "end": "1234293"
  },
  {
    "text": "JULIAN SHUN: Yeah,\nso the answer is to write a program that\nwrites your program for you.",
    "start": "1234293",
    "end": "1240640"
  },
  {
    "text": "And that's called\nmetaprogramming. So here's a snippet\nof code that will",
    "start": "1240640",
    "end": "1246400"
  },
  {
    "text": "generate this table for you. So it's going to call\nthis init choose function",
    "start": "1246400",
    "end": "1251980"
  },
  {
    "text": "that we defined before. And then now it's just\ngoing to print out C code. So it's going to print out\nthe declaration of this array",
    "start": "1251980",
    "end": "1259149"
  },
  {
    "text": "choose, followed\nby a left bracket. And then for each\nrow of the table,",
    "start": "1259150",
    "end": "1264760"
  },
  {
    "start": "1264000",
    "end": "1264000"
  },
  {
    "text": "we're going to print\nanother left bracket and then print the value of\neach entry in that row, followed",
    "start": "1264760",
    "end": "1269860"
  },
  {
    "text": "by a right bracket. And we do that for every row. So this will give\nyou the C code. And then now you can just copy\nand paste this and place it",
    "start": "1269860",
    "end": "1277539"
  },
  {
    "text": "into your source code. This is a pretty cool\ntechnique to get your computer",
    "start": "1277540",
    "end": "1284530"
  },
  {
    "text": "to do work for you. And you're welcome to use this\ntechnique in your homeworks and projects if you'd need\nto generate large tables",
    "start": "1284530",
    "end": "1293320"
  },
  {
    "text": "of constant values. So this is a very good\ntechnique to know. ",
    "start": "1293320",
    "end": "1299875"
  },
  {
    "text": "So any questions? Yes? AUDIENCE: Is there a way to\nwrite the output other programs to a file, as oppose to\nhaving to copy and paste",
    "start": "1299875",
    "end": "1307100"
  },
  {
    "text": "into the source code? JULIAN SHUN: Yeah, so you can\npipe the output of this program",
    "start": "1307100",
    "end": "1313179"
  },
  {
    "text": "to a file. ",
    "start": "1313180",
    "end": "1319039"
  },
  {
    "text": "Yes? AUDIENCE: So are there\ncompiler tools that can-- so we have three\nprocessor tools. Is there [INAUDIBLE]\nprocessor can do that?",
    "start": "1319040",
    "end": "1326274"
  },
  {
    "text": "We compile the code, run\nit, and then [INAUDIBLE].. JULIAN SHUN: Yeah,\nso I think you can write macros to actually\ngenerate this table.",
    "start": "1326275",
    "end": "1333390"
  },
  {
    "text": "And then the compiler\nwill run those macros to generate this table for you.",
    "start": "1333390",
    "end": "1339120"
  },
  {
    "text": "Yeah, so you don't actually need\nto copy and paste it yourself. Yeah? CHARLES: And you\nknow, you don't have",
    "start": "1339120",
    "end": "1348420"
  },
  {
    "text": "to write it in C. If it's\nquicker to write with Python, you'd be writing in Python,\njust put it in the make file",
    "start": "1348420",
    "end": "1356110"
  },
  {
    "text": "for the system you're building. So if it's in the\nmake file, says, well, we're making\nthis thing, first",
    "start": "1356110",
    "end": "1361830"
  },
  {
    "text": "generate the file in\nthe table and now you include that in whatever\nyou're compiling",
    "start": "1361830",
    "end": "1369020"
  },
  {
    "text": "or/and it's just one\nmore step in the process.",
    "start": "1369020",
    "end": "1375616"
  },
  {
    "text": "And for sure, it's\ngenerally easier to write these tables with the\nscripting language like Python",
    "start": "1375616",
    "end": "1381510"
  },
  {
    "text": "than writing them in\nC. On the other hand, if you need experience writing\nin C, practice writing in C.",
    "start": "1381510",
    "end": "1388242"
  },
  {
    "text": "JULIAN SHUN: Right,\nso as Charles says, you can write your metaprogram\nusing any language.",
    "start": "1388242",
    "end": "1393659"
  },
  {
    "text": "You don't have to write it in\nC. You can write it in Python if you're more\nfamiliar with that. And it's often easier to\nwrite it using a scripting",
    "start": "1393660",
    "end": "1400560"
  },
  {
    "text": "language like Python. ",
    "start": "1400560",
    "end": "1406845"
  },
  {
    "text": "OK, so let's look at\nthe next optimization. So we're already\ngone through a couple of mini lectures already.",
    "start": "1406845",
    "end": "1413435"
  },
  {
    "start": "1412000",
    "end": "1412000"
  },
  {
    "text": "So congratulations to all\nof you who are still here.",
    "start": "1413435",
    "end": "1419000"
  },
  {
    "text": "So the next\noptimization is caching. The idea of caching\nis to store results that have been\naccessed recently,",
    "start": "1419000",
    "end": "1424645"
  },
  {
    "text": "so that you don't need\nto compute them again in the program. So let's look at an example.",
    "start": "1424645",
    "end": "1431350"
  },
  {
    "text": "Let's say we wanted to\ncompute the hypotenuse of a right triangle with\nside lengths A and B.",
    "start": "1431350",
    "end": "1437690"
  },
  {
    "text": "So the formula for\ncomputing this is, you take the square root of A\ntimes A plus B times B. OK, so",
    "start": "1437690",
    "end": "1451179"
  },
  {
    "text": "turns out that the square\nroot operator is actually a relatively expensive, more\nexpensive than additions",
    "start": "1451180",
    "end": "1456840"
  },
  {
    "text": "and multiplications\non modern machines. So you don't want to have\nto call the square root",
    "start": "1456840",
    "end": "1462330"
  },
  {
    "text": "function if you don't have to. And one way to avoid doing\nthat is to create a cache.",
    "start": "1462330",
    "end": "1468080"
  },
  {
    "text": "So here I have a cache just\nstoring the previous hypotenuse that I calculated.",
    "start": "1468080",
    "end": "1473100"
  },
  {
    "text": "And I also store the\nvalues of A and B that were passed\nto the function.",
    "start": "1473100",
    "end": "1478350"
  },
  {
    "text": "And then now when I call\nthe hypotenuse function, I can first check if A is\nequal to the cached value of A",
    "start": "1478350",
    "end": "1485190"
  },
  {
    "text": "and if B is equal to\nthe cached value of B. And if both of\nthose are true, then I already computed\nthe hypotenuse before.",
    "start": "1485190",
    "end": "1491309"
  },
  {
    "text": "And then I can just\nreturn cached of h. But if it's not in my cache, now\nI need to actually compute it.",
    "start": "1491310",
    "end": "1498389"
  },
  {
    "text": "So I need to call the\nsquare root function. And then I store the\nresult into cached h.",
    "start": "1498390",
    "end": "1503790"
  },
  {
    "text": "And I also store A\nand B into cached A and cached B respectively. And then finally, I\nreturned cached h.",
    "start": "1503790",
    "end": "1511641"
  },
  {
    "text": "So this example isn't\nactually very realistic, because my cache\nis only a size one.",
    "start": "1511641",
    "end": "1517408"
  },
  {
    "text": "And it's very\nunlikely, in a program, you're going to repeatedly\ncall some function with the same input arguments.",
    "start": "1517408",
    "end": "1524335"
  },
  {
    "text": "But you can actually\nmake a larger cache. You can make a\ncache of size 1,000, storing the 1,000 most recently\ncomputer hypotenuse values.",
    "start": "1524335",
    "end": "1532840"
  },
  {
    "text": "And then now when you call\nthe hypotenuse function, you can just check if\nit's in your cache.",
    "start": "1532840",
    "end": "1538160"
  },
  {
    "text": "Checking the larger\ncache is going to be more expensive,\nbecause there are more values to look at.",
    "start": "1538160",
    "end": "1543701"
  },
  {
    "text": "But they can still\nsave you time overall.  And hardware also\ndoes caching for you,",
    "start": "1543702",
    "end": "1552580"
  },
  {
    "text": "as we'll talk about\nlater on in the semester. But the point of\nthis optimization is that you can also\ndo caching yourself.",
    "start": "1552580",
    "end": "1559362"
  },
  {
    "text": "You can do it in software. You don't have to let\nhardware do it for you. And turns out for this\nparticular program here,",
    "start": "1559362",
    "end": "1566875"
  },
  {
    "text": "actually, it is about 30%\nfaster if you do hit the cache about 2/3 of the time.",
    "start": "1566875",
    "end": "1573285"
  },
  {
    "text": "So it does actually\nsave you time if you do repeatedly compute\nthe same values over and over again.",
    "start": "1573285",
    "end": "1580180"
  },
  {
    "text": "So that's caching. ",
    "start": "1580180",
    "end": "1585374"
  },
  {
    "text": "Any questions? ",
    "start": "1585374",
    "end": "1592198"
  },
  {
    "text": "OK, so the next optimization\nwe'll look at is sparsity.",
    "start": "1592198",
    "end": "1597695"
  },
  {
    "text": "The idea of exploiting\nsparsity, in an input, is to avoid storage\nand computing on zero elements of that input.",
    "start": "1597695",
    "end": "1605570"
  },
  {
    "text": "And the fastest way\nto compute on zero is to just not compute\non them at all, because we know that\nany value plus zero",
    "start": "1605570",
    "end": "1612510"
  },
  {
    "text": "is just that original value. And any value times\nzero is just zero. So why waste a computation\ndoing that when",
    "start": "1612510",
    "end": "1619200"
  },
  {
    "text": "you already know the result? So let's look at an example. This is matrix-vector\nmultiplication.",
    "start": "1619200",
    "end": "1626230"
  },
  {
    "text": "So we want to multiply a n by\nn matrix by a n by one vector.",
    "start": "1626230",
    "end": "1632391"
  },
  {
    "text": "We can do dense\nmatrix-vector multiplication by just doing a dot product\nof each row in the matrix",
    "start": "1632391",
    "end": "1638805"
  },
  {
    "text": "with the column vector. And then that will give\nus the output vector. But if you do dense\nmatrix-vector multiplication,",
    "start": "1638805",
    "end": "1646500"
  },
  {
    "text": "that's going to perform\nn squared or 36, in this example,\nscalar multiplies.",
    "start": "1646500",
    "end": "1653110"
  },
  {
    "text": "But it turns out, only 14 of\nthese entries in this matrix are zero or are non-zero.",
    "start": "1653110",
    "end": "1659290"
  },
  {
    "text": "So you just wasted work doing\nthe multiplication on the zero elements, because you know that\nzero times any other element",
    "start": "1659290",
    "end": "1667350"
  },
  {
    "text": "is just zero.  So a better way to do\nthis, is instead of",
    "start": "1667350",
    "end": "1675318"
  },
  {
    "text": "doing the multiplication\nfor every element, you first check if one\nof the arguments is zero. And if it is zero,\nthen you don't",
    "start": "1675318",
    "end": "1682120"
  },
  {
    "text": "have to actually do\nthe multiplication. But this is still kind of\nslow, because you still",
    "start": "1682120",
    "end": "1689020"
  },
  {
    "text": "have to do a check for\nevery entry in your matrix, even though many of\nthe entries are zero. ",
    "start": "1689020",
    "end": "1696520"
  },
  {
    "text": "So it's actually a pretty\ncool data structure that won't actually\nstore these zero entries.",
    "start": "1696520",
    "end": "1702550"
  },
  {
    "start": "1700000",
    "end": "1700000"
  },
  {
    "text": "And this will speed up your\nmatrix-vector multiplication if your matrix is sparse enough.",
    "start": "1702550",
    "end": "1709345"
  },
  {
    "text": "So let me describe how\nthis data structure works. It's called compressed\nsparse row or CSR.",
    "start": "1709345",
    "end": "1714820"
  },
  {
    "text": "There is an analogous\nrepresentation called compressed\nsparse column or CSC. But today, I'm just\ngoing to talk about CSR.",
    "start": "1714820",
    "end": "1723190"
  },
  {
    "text": "So we have three arrays. First, we have the rows array. The length of the rows array\nis just equal to the number",
    "start": "1723190",
    "end": "1729580"
  },
  {
    "text": "of rows in a matrix plus one. And then each entry\nin the rows array",
    "start": "1729580",
    "end": "1735805"
  },
  {
    "text": "just stores an offset\ninto the columns array or the cols array. And inside the cols\narray, I'm storing",
    "start": "1735805",
    "end": "1743065"
  },
  {
    "text": "the indices of the non-zero\nentries in each of the rows. So if we take row\none, for example,",
    "start": "1743065",
    "end": "1751760"
  },
  {
    "text": "we have rows of one\nis equal to two. That means I start looking\nat the second entry",
    "start": "1751760",
    "end": "1756940"
  },
  {
    "text": "in the cols array. And then now I have the\nindices of the non-zero columns",
    "start": "1756940",
    "end": "1763015"
  },
  {
    "text": "in the first row. So it's just one,\ntwo, four, and five. ",
    "start": "1763015",
    "end": "1769269"
  },
  {
    "text": "These are the indices\nfor the non-zero entries. And then I have another\narray called vals.",
    "start": "1769270",
    "end": "1775150"
  },
  {
    "text": "The length of this array is\nthe same as the cols array. And then this array just\nstores the actual value",
    "start": "1775150",
    "end": "1780490"
  },
  {
    "text": "in these indices here. So the vals array\nfor row one is going",
    "start": "1780490",
    "end": "1785770"
  },
  {
    "text": "to store four, one, five,\nand nine, because these are the non-zero entries\nin the first row.",
    "start": "1785770",
    "end": "1791799"
  },
  {
    "text": "Right, so the rows array\njust serves as an index into this cols array.",
    "start": "1791800",
    "end": "1797620"
  },
  {
    "text": "So you can basically\nget the starting index in this cols array\nfor any row just",
    "start": "1797620",
    "end": "1804039"
  },
  {
    "text": "by looking at the entry stored\nat the corresponding location in the rows array. So for example, row two\nstarts at location six.",
    "start": "1804040",
    "end": "1812245"
  },
  {
    "text": "So it starts here. And you have indices\nthree and five, which are the non-zero indices.",
    "start": "1812245",
    "end": "1817600"
  },
  {
    "text": " So does anyone\nknow how to compute the length, the number\nof non-zeros in a row",
    "start": "1817600",
    "end": "1824180"
  },
  {
    "text": "by looking at the rows array?  Yes, yes?",
    "start": "1824180",
    "end": "1830370"
  },
  {
    "text": "AUDIENCE: You go\nto the rows array and just drag the [INAUDIBLE] JULIAN SHUN: Right.",
    "start": "1830370",
    "end": "1836159"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] the\nnumber of elements that are [INAUDIBLE]. JULIAN SHUN: Yeah, so to\nget the length of a row,",
    "start": "1836160",
    "end": "1842404"
  },
  {
    "text": "you just take the difference\nbetween that row's offset and the next row's offset. So we can see that the length\nof the first row is four,",
    "start": "1842405",
    "end": "1850250"
  },
  {
    "text": "because it's offset is two. And the offset for\nrow two is six. So you just take the difference\nbetween those two entries.",
    "start": "1850250",
    "end": "1857030"
  },
  {
    "text": " We have an additional\nentry here. So we have the sixth\nrow here, because we",
    "start": "1857030",
    "end": "1867029"
  },
  {
    "text": "want to be able to compute\nthe length of the last row without overflowing\nin our array. So we just created an additional\nentry in the rows array",
    "start": "1867030",
    "end": "1874750"
  },
  {
    "text": "for that. ",
    "start": "1874750",
    "end": "1880410"
  },
  {
    "text": "So turns out that this\nrepresentation will save you space if your matrix is sparse.",
    "start": "1880410",
    "end": "1887240"
  },
  {
    "text": "So the storage required\nby the CSR format is order n plus nnz, where\nnnz is the number of non-zeros",
    "start": "1887240",
    "end": "1894220"
  },
  {
    "text": "in your matrix. And the reason why\nyou have n plus nnz,",
    "start": "1894220",
    "end": "1899480"
  },
  {
    "text": "well, you have two arrays\nhere, cols and vals, whose length is equal to\nthe number of non-zeros",
    "start": "1899480",
    "end": "1905230"
  },
  {
    "text": "in the matrix. And then you also\nhave this rows array, whose length is n plus one.",
    "start": "1905230",
    "end": "1910420"
  },
  {
    "text": "So that's why we\nhave n plus nnz. And if the number of non-zeros\nis much less than n squared,",
    "start": "1910420",
    "end": "1915460"
  },
  {
    "text": "then this is going to be\nsignificantly more compact than the dense matrix\nrepresentation.",
    "start": "1915460",
    "end": "1921220"
  },
  {
    "text": " However, this isn't always\ngoing to be the most",
    "start": "1921220",
    "end": "1926419"
  },
  {
    "text": "compact representation. Does anyone see why? ",
    "start": "1926420",
    "end": "1932030"
  },
  {
    "text": "Why might the dense\nrepresentation sometimes take less space?",
    "start": "1932030",
    "end": "1937446"
  },
  {
    "text": "Yeah? Sorry. AUDIENCE: Less\nspace or more space? JULIAN SHUN: Why might the dense\nrepresentation sometimes take",
    "start": "1937446",
    "end": "1942820"
  },
  {
    "text": "less space? AUDIENCE: I mean, if\nyou have not many zeros, then you can figure it out n\nsquared plus something else",
    "start": "1942820",
    "end": "1950210"
  },
  {
    "text": "with the sparse created. JULIAN SHUN: Right. So if you have a\nrelatively dense matrix,",
    "start": "1950210",
    "end": "1957650"
  },
  {
    "text": "then it might take more\nspace than storing it. It might take more space\nin the CSR representation,",
    "start": "1957650",
    "end": "1963015"
  },
  {
    "text": "because you have\nthese two arrays. So if you take the extreme\ncase where all of the entries",
    "start": "1963015",
    "end": "1968160"
  },
  {
    "text": "are non-zeros, then\nboth of these arrays are going to be of\nlength and squares. So you already have\n2n squared there.",
    "start": "1968160",
    "end": "1974325"
  },
  {
    "text": "And then you also need\nthis rows array, which is of length and plus one. ",
    "start": "1974325",
    "end": "1981908"
  },
  {
    "text": "OK, so now I gave you this\nmore compact representation for storing the matrix.",
    "start": "1981908",
    "end": "1988455"
  },
  {
    "text": "So how do we actually do stuff\nwith this representation? So turns out that\nyou can still do",
    "start": "1988455",
    "end": "1994970"
  },
  {
    "text": "matrix-vector\nmultiplication using this compressed\nsparse row format.",
    "start": "1994970",
    "end": "2000331"
  },
  {
    "text": "And here's the\ncode for doing it. So we have this\nstruct here, which is the CSR representation.",
    "start": "2000332",
    "end": "2007330"
  },
  {
    "text": "We have the rows array, the cols\narray, and then the vals array.",
    "start": "2007330",
    "end": "2012451"
  },
  {
    "text": "And then we also have the number\nof rows, n, and the number of non-zeros, nnz.",
    "start": "2012452",
    "end": "2020056"
  },
  {
    "text": "And then now what we do,\nwe call this SPMV or sparse matrix-vector multiply.",
    "start": "2020056",
    "end": "2025710"
  },
  {
    "text": "We pass in our CSR\nrepresentation, which is A, and then the\ninput array, which is x.",
    "start": "2025710",
    "end": "2032440"
  },
  {
    "text": "And then we store the\nresult in an output array y. So first, we loop\nthrough all the rows.",
    "start": "2032440",
    "end": "2040000"
  },
  {
    "text": "And then we set y\nof i to be zero. This is just initialization.",
    "start": "2040000",
    "end": "2045426"
  },
  {
    "text": "And then for each\nof my rows, I'm going to look at\nthe column indices",
    "start": "2045426",
    "end": "2051849"
  },
  {
    "text": "for the non-zero elements. And I can do that by starting\nat k equals to rows of i",
    "start": "2051850",
    "end": "2058510"
  },
  {
    "text": "and going up to\nrows of i plus one. And then for each\none of these entries,",
    "start": "2058510",
    "end": "2064149"
  },
  {
    "text": "I just look up the\nindex, the column index for the non-zero element.",
    "start": "2064150",
    "end": "2070569"
  },
  {
    "text": "And I can do that with cols\nof k, so let that be j. And then now I know which\nelements to multiply.",
    "start": "2070570",
    "end": "2077273"
  },
  {
    "text": "I multiply vals of k by x of j. And then now I just\nadd that to y of i.",
    "start": "2077274",
    "end": "2084788"
  },
  {
    "text": "And then after I finish with\nall of these multiplications and additions, this will\ngive me the same result",
    "start": "2084788",
    "end": "2091210"
  },
  {
    "text": "as if I did the dense\nmatrix-vector multiplication.",
    "start": "2091210",
    "end": "2096610"
  },
  {
    "text": "So this is actually a\npretty cool program. So I encourage you to look\nat this program offline,",
    "start": "2096611",
    "end": "2102125"
  },
  {
    "text": "to convince yourself\nthat it's actually computing the same thing\nas the dense matrix-vector",
    "start": "2102125",
    "end": "2108055"
  },
  {
    "text": "multiplication version. So I'm not going to approve\nthis during lecture today. But you can feel free to\nask me or any of your TAs",
    "start": "2108055",
    "end": "2115750"
  },
  {
    "text": "after class, if you have\nquestions about this. And the number of\nscalar multiplication",
    "start": "2115750",
    "end": "2120849"
  },
  {
    "text": "that you have to\ndo using this code is just going to be nnz,\nbecause you're just operating on the non-zero elements.",
    "start": "2120850",
    "end": "2126954"
  },
  {
    "text": "You don't have to touch\nall of the zero elements. And in contrast, the dense\nmatrix-vector multiply",
    "start": "2126955",
    "end": "2132760"
  },
  {
    "text": "algorithm would take n\nsquared multiplication. So this can be significantly\nfaster for a sparse matrices.",
    "start": "2132760",
    "end": "2138550"
  },
  {
    "text": " So turns out that you can\nalso use a similar structure",
    "start": "2138550",
    "end": "2145910"
  },
  {
    "text": "to store a sparse static graph. So I assume many of\nyou have seen graphs",
    "start": "2145910",
    "end": "2151175"
  },
  {
    "start": "2146000",
    "end": "2146000"
  },
  {
    "text": "in your previous courses. See, here's what the\nsparse graph representation",
    "start": "2151175",
    "end": "2158375"
  },
  {
    "text": "looks like. So again, we have these arrays. We have these two arrays.",
    "start": "2158375",
    "end": "2163790"
  },
  {
    "text": "We have offsets and edges. The offsets array is\nanalogous to the rows array. And the edges array is\nanalogous to the columns array",
    "start": "2163790",
    "end": "2170869"
  },
  {
    "text": "for the CSR representation. And then in this offsets\narray, we store for each vertex",
    "start": "2170870",
    "end": "2178160"
  },
  {
    "text": "where its neighbor's\nstart in this edges array. And then in the\nedges array, we just",
    "start": "2178160",
    "end": "2183380"
  },
  {
    "text": "write the indices of\nits neighbor's there. So let's take vertex\none, for example.",
    "start": "2183380",
    "end": "2189090"
  },
  {
    "text": "The offset of vertex one is two. So we know that its\noutgoing neighbor start at position two\nin this edges array.",
    "start": "2189090",
    "end": "2196230"
  },
  {
    "text": "And then we see that vertex one\nhas outgoing edges to vertices two, three, and four.",
    "start": "2196230",
    "end": "2201890"
  },
  {
    "text": "And we see in the edges array\ntwo, three, four listed there. And you can also get the\ndegree of each vertex, which",
    "start": "2201890",
    "end": "2209220"
  },
  {
    "text": "is analogous to the\nlength of each row, by taking the difference\nbetween consecutive offsets. So here we see that the\ndegree of vertex one",
    "start": "2209220",
    "end": "2215810"
  },
  {
    "text": "is three, because\nits offset is two. And the offset of\nvertex two is five.",
    "start": "2215810",
    "end": "2221670"
  },
  {
    "text": " And it turns out that\nusing this representation,",
    "start": "2221670",
    "end": "2227150"
  },
  {
    "text": "you can run many\nclassic graph algorithms such as breadth-first\nsearch and PageRank",
    "start": "2227150",
    "end": "2232280"
  },
  {
    "text": "quite efficiently, especially\nwhen the graph is sparse. So this would be\nmuch more efficient",
    "start": "2232280",
    "end": "2238190"
  },
  {
    "text": "than using a dense matrix\nto represent the graph and running these algorithms. ",
    "start": "2238190",
    "end": "2245995"
  },
  {
    "text": "You can also store\nweights on the edges. And one way to do that is to\njust create an additional array",
    "start": "2245995",
    "end": "2252480"
  },
  {
    "text": "called weights, whose length\nis equal to the number of edges in the graph. And then you just store\nthe weights in that array.",
    "start": "2252480",
    "end": "2258660"
  },
  {
    "text": "And this is analogous to\nthe values array in the CSR representation.",
    "start": "2258660",
    "end": "2263826"
  },
  {
    "text": "But there's actually a more\nefficient way to store this, if you always need to\naccess the weight whenever",
    "start": "2263826",
    "end": "2269190"
  },
  {
    "text": "you access an edge. And the way to do this is\nto interleave the weights with the edges, so to store the\nweight for a particular edge",
    "start": "2269190",
    "end": "2277680"
  },
  {
    "text": "right next to that edge,\nand create an array of twice number of edges in the graph.",
    "start": "2277680",
    "end": "2283440"
  },
  {
    "text": "And the reason why\nthis is more efficient is, because it gives you\nimproved cache locality.",
    "start": "2283440",
    "end": "2289184"
  },
  {
    "text": "And we'll talk much more\nabout cache locality later on in this course. But the high-level idea is, that\nwhenever you access an edge,",
    "start": "2289185",
    "end": "2298140"
  },
  {
    "text": "the weight for\nthat edge will also likely to be on the\nsame cache line. So you don't need\nto go to main memory",
    "start": "2298140",
    "end": "2303390"
  },
  {
    "text": "to access the weight\nof that edge again. And later on in\nthe semester we'll",
    "start": "2303390",
    "end": "2310080"
  },
  {
    "text": "actually have a whole lecture\non doing optimizations for graph algorithms.",
    "start": "2310080",
    "end": "2315725"
  },
  {
    "text": "And today, I'm just going to\ntalk about one representation",
    "start": "2315726",
    "end": "2320745"
  },
  {
    "text": "of graphs. But we'll talk much more\nabout this later on. Any questions? ",
    "start": "2320745",
    "end": "2336071"
  },
  {
    "text": "OK, so that's it for the\ndata structure optimizations.",
    "start": "2336072",
    "end": "2341640"
  },
  {
    "text": "We still have three\nmore categories of optimizations to go over. ",
    "start": "2341640",
    "end": "2347795"
  },
  {
    "text": "So it's a pretty fun lecture. We get to learn about many\ncool tricks for reducing the work of your program.",
    "start": "2347795",
    "end": "2354965"
  },
  {
    "text": "So in the next class\nof optimizations we'll look at is logic, so\nfirst thing is constant folding",
    "start": "2354965",
    "end": "2361670"
  },
  {
    "text": "and propagation. The idea of constant\nfolding and propagation is to evaluate\nconstant expressions",
    "start": "2361670",
    "end": "2367520"
  },
  {
    "text": "and substitute the result\ninto further expressions, all at compilation times. You don't have to\ndo it at runtime.",
    "start": "2367520",
    "end": "2373538"
  },
  {
    "text": " So again, let's\nlook at an example.",
    "start": "2373538",
    "end": "2378876"
  },
  {
    "text": "So here we have this\nfunction called orrery. Does anyone know\nwhat orrery means?",
    "start": "2378876",
    "end": "2383940"
  },
  {
    "start": "2383940",
    "end": "2398141"
  },
  {
    "text": "You can look it up on Google. [LAUGHING] ",
    "start": "2398142",
    "end": "2403688"
  },
  {
    "text": "OK, so an orrery is a\nmodel of a solar system.",
    "start": "2403688",
    "end": "2409130"
  },
  {
    "start": "2406000",
    "end": "2406000"
  },
  {
    "text": "So here we're constructing\na digital orrery. And in an orrery we\nhave these whole bunch",
    "start": "2409130",
    "end": "2416627"
  },
  {
    "text": "of different constants. We have the radius, the\ndiameter, the circumference, cross area, surface area,\nand also the volume.",
    "start": "2416627",
    "end": "2424350"
  },
  {
    "text": " But if you look\nat this code, you",
    "start": "2424350",
    "end": "2429720"
  },
  {
    "text": "can notice that actually\nall of these constants can be defined in compile\ntime once we fix the radius.",
    "start": "2429720",
    "end": "2435770"
  },
  {
    "text": "So here we set the radius\nto be this constant here, six million, 371,000.",
    "start": "2435770",
    "end": "2445267"
  },
  {
    "text": "I don't know where that\nconstant comes from, by the way. But Charles made these\nslides, so he probably does.",
    "start": "2445267",
    "end": "2451701"
  },
  {
    "text": "CHARLES: [INAUDIBLE] JULIAN SHUN: Sorry? CHARLES: Radius of the Earth. JULIAN SHUN: OK,\nradius of the Earth.",
    "start": "2451701",
    "end": "2457911"
  },
  {
    "text": "Now, the diameter is\njust twice this radius. The circumference is just\npi times the diameter.",
    "start": "2457911",
    "end": "2463830"
  },
  {
    "text": "Cross area is pi times\nthe radius squared. Surface area is circumference\ntimes the diameter.",
    "start": "2463830",
    "end": "2471180"
  },
  {
    "text": "And finally, volume is four\ntimes pi times the radius cube divided by three.",
    "start": "2471180",
    "end": "2477806"
  },
  {
    "text": "So you can actually evaluate\nall of these two constants at compile time. So with a sufficiently\nhigh level of optimization,",
    "start": "2477806",
    "end": "2486480"
  },
  {
    "text": "the compiler will actually\nevaluate all of these things at compile time.",
    "start": "2486480",
    "end": "2491501"
  },
  {
    "text": "And that's the idea of constant\nfolding and propagation. It's a good idea to know about\nthis, even though the compiler",
    "start": "2491501",
    "end": "2497760"
  },
  {
    "text": "is pretty good at doing\nthis, because sometimes the compiler won't do it.",
    "start": "2497760",
    "end": "2502925"
  },
  {
    "text": "And in those cases,\nyou can do it yourself. And you can also figure\nout whether the compiler is actually doing it when you\nlook at the assembly code.",
    "start": "2502925",
    "end": "2510450"
  },
  {
    "start": "2510450",
    "end": "2516213"
  },
  {
    "text": "OK, so the next optimization\nis common subexpression",
    "start": "2516214",
    "end": "2521440"
  },
  {
    "start": "2520000",
    "end": "2520000"
  },
  {
    "text": "elimination. And the idea here is to avoid\ncomputing the same expression multiple times by evaluating\nthe expression once and storing",
    "start": "2521440",
    "end": "2529109"
  },
  {
    "text": "the result for later use. So let's look at this\nsimple four-line program.",
    "start": "2529110",
    "end": "2535740"
  },
  {
    "text": "We have a equal to b plus c. The we set b equal to a minus d. Then we set c equal to b plus c.",
    "start": "2535740",
    "end": "2542220"
  },
  {
    "text": "And finally, we set\nd equal to a minus d. So notice her that the\nsecond and the fourth lines",
    "start": "2542220",
    "end": "2549530"
  },
  {
    "text": "are computing the\nsame expression. They're both\ncomputing a minus d. And they evaluate\nto the same thing.",
    "start": "2549530",
    "end": "2557106"
  },
  {
    "text": "So the idea of common\nsubexpression elimination would be to just substitute the\nresult of the first evaluation",
    "start": "2557106",
    "end": "2564605"
  },
  {
    "text": "into the place where you\nneed it in future line.",
    "start": "2564605",
    "end": "2569990"
  },
  {
    "text": "So here, we still evaluate\nthe first line for a minus d. But now in the second\ntime we need a minus d.",
    "start": "2569990",
    "end": "2576920"
  },
  {
    "text": "We just set the value to b. So now d is equal to b\ninstead of a minus d. ",
    "start": "2576920",
    "end": "2584560"
  },
  {
    "text": "So in this example, the\nfirst and the third line, the right hand side of those\nlines actually look the same.",
    "start": "2584560",
    "end": "2590960"
  },
  {
    "text": "They're both b plus c. Does anyone see why you\ncan't do common subexpression elimination here?",
    "start": "2590960",
    "end": "2596750"
  },
  {
    "text": " AUDIENCE: b minus\nchanges the second line.",
    "start": "2596750",
    "end": "2601830"
  },
  {
    "text": "JULIAN SHUN: Yeah, so you\ncan't do common subexpression for the first and the third\nlines, because the value of b",
    "start": "2601830",
    "end": "2610140"
  },
  {
    "text": "changes in between. So the value of b changes\non the second line. So on the third line\nwhen you do b plus c,",
    "start": "2610140",
    "end": "2615829"
  },
  {
    "text": "it's not actually\ncomputing the same thing as the first\nevaluation of b plus c.",
    "start": "2615830",
    "end": "2622370"
  },
  {
    "text": "So again, the\ncompiler is usually smart enough to figure\nthis optimization out.",
    "start": "2622370",
    "end": "2627510"
  },
  {
    "text": "So it will do this optimization\nfor you in your code. But again, it doesn't\nalways do it for you.",
    "start": "2627510",
    "end": "2633480"
  },
  {
    "text": "So it's a good idea to know\nabout this optimization so that you can do this\noptimization by hand when",
    "start": "2633480",
    "end": "2640079"
  },
  {
    "text": "the compiler doesn't\ndo it for you. Questions so far? ",
    "start": "2640080",
    "end": "2656750"
  },
  {
    "text": "OK, so next, let's look\nat algebraic identities. The idea of exploiting\nalgebraic identities",
    "start": "2656750",
    "end": "2662680"
  },
  {
    "text": "is to replace more expensive\nalgebraic expressions with equivalent expressions\nthat are cheaper to evaluate.",
    "start": "2662680",
    "end": "2672010"
  },
  {
    "text": "So let's look at an example. Let's say we have a\nwhole bunch of balls. And we want to detect\nwhether two balls collide",
    "start": "2672010",
    "end": "2679170"
  },
  {
    "text": "with each other. Say, ball has a x-coordinate,\na y-coordinate, a z-coordinate,",
    "start": "2679170",
    "end": "2685184"
  },
  {
    "text": "as well as a radius. And the collision\ntest works as follows.",
    "start": "2685185",
    "end": "2691515"
  },
  {
    "text": "We set d equal to\nthe square root of the sum of the squares of\nthe differences between each",
    "start": "2691515",
    "end": "2698120"
  },
  {
    "text": "of the three coordinates\nof the two balls. So here, we're taking the\nsquare of b1's x-coordinate",
    "start": "2698120",
    "end": "2703860"
  },
  {
    "text": "minus b2's\nx-coordinate, and then adding the square\nof b1's y-coordinate minus b2's y-coordinate,\nand finally,",
    "start": "2703860",
    "end": "2711150"
  },
  {
    "text": "adding the square\nof b1 z-coordinate minus b2's z-coordinate. And then we take the\nsquare root of all of that.",
    "start": "2711150",
    "end": "2717119"
  },
  {
    "text": "And then if the\nresult is less than or equal to the sum of\nthe two radii of the ball,",
    "start": "2717120",
    "end": "2723951"
  },
  {
    "text": "then that means\nthere is a collision, and otherwise, that means\nthere's not a collision.",
    "start": "2723951",
    "end": "2732096"
  },
  {
    "text": "But it turns out that\nthe square root operator, as I mentioned before, is\nrelatively expensive compared",
    "start": "2732096",
    "end": "2738515"
  },
  {
    "text": "to doing multiplications and\nadditions and subtractions on modern machines.",
    "start": "2738515",
    "end": "2744160"
  },
  {
    "text": "So how can we do this without\nusing the square root operator?",
    "start": "2744160",
    "end": "2750410"
  },
  {
    "text": "Yes. AUDIENCE: You add the two radii,\nand the distance is more than the distance\nbetween the centers,",
    "start": "2750410",
    "end": "2755866"
  },
  {
    "text": "then you know that\nthey must be overlying. JULIAN SHUN: Right, so that's\nactually a good fast path",
    "start": "2755866",
    "end": "2762570"
  },
  {
    "text": "check. I don't think it\nnecessarily always gives you the right answer.",
    "start": "2762570",
    "end": "2768321"
  },
  {
    "text": "Is there another? Yes? AUDIENCE: You can square\nthe ignition of the radii and compare that\ninstead of taking",
    "start": "2768321",
    "end": "2773638"
  },
  {
    "text": "the square root of [INAUDIBLE]. JULIAN SHUN: Right,\nright, so the answer is, that you can actually\ntake the square of both sides.",
    "start": "2773638",
    "end": "2780365"
  },
  {
    "start": "2779000",
    "end": "2779000"
  },
  {
    "text": "So now you don't have to\ntake the square root anymore. So we're going to\nuse the identity that says, that if the\nsquare root of u",
    "start": "2780365",
    "end": "2787800"
  },
  {
    "text": "is less than or equal to v\nexactly when u is less than or equal to v squared. So we're just going to take\nthe square of both sides.",
    "start": "2787800",
    "end": "2794525"
  },
  {
    "text": "And here's the modified code. So now I don't have this square\nroot anymore on the right hand",
    "start": "2794525",
    "end": "2801240"
  },
  {
    "text": "side when I compute d squared. But instead, I square\nthe sum of the two radii.",
    "start": "2801240",
    "end": "2808193"
  },
  {
    "text": "So this will give\nyou the same answer. However, you do have to be\ncareful with floating point",
    "start": "2808194",
    "end": "2813900"
  },
  {
    "text": "operations, because\nthey don't work exactly in the same way as real numbers. So some numbers might run into\noverflow issues or rounding",
    "start": "2813900",
    "end": "2822630"
  },
  {
    "text": "issues. So you do have to\nbe careful if you're using algebraic identities and\nfloating point computations.",
    "start": "2822630",
    "end": "2829512"
  },
  {
    "text": "But the high-level\nidea is that you can use equivalent algebraic\nexpressions to reduce the work of your program.",
    "start": "2829512",
    "end": "2835110"
  },
  {
    "start": "2835110",
    "end": "2843320"
  },
  {
    "text": "And we'll come back\nto this example late on in this\nlecture when we talk about some other optimizations,\nsuch as the fast path",
    "start": "2843320",
    "end": "2849869"
  },
  {
    "text": "optimization, as one of\nthe students pointed out. Yes? AUDIENCE: Why do\nyou square the sum",
    "start": "2849870",
    "end": "2856152"
  },
  {
    "text": "of these squares [INAUDIBLE]? ",
    "start": "2856152",
    "end": "2862900"
  },
  {
    "text": "JULIAN SHUN: Which? Are you talking about-- AUDIENCE: Yeah. JULIAN SHUN: --this line? So before we were comparing d.",
    "start": "2862900",
    "end": "2869803"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]. JULIAN SHUN: Yeah,\nyeah, OK, is that clear?",
    "start": "2869803",
    "end": "2874830"
  },
  {
    "text": "OK. ",
    "start": "2874830",
    "end": "2882500"
  },
  {
    "text": "OK, so the next optimization\nis short-circuiting. The idea here is,\nthat when we're",
    "start": "2882500",
    "end": "2888710"
  },
  {
    "start": "2886000",
    "end": "2886000"
  },
  {
    "text": "performing a series of\ntests, we can actually stop evaluating\nthis series of tests",
    "start": "2888710",
    "end": "2893900"
  },
  {
    "text": "as soon as we know what the\nanswer is So here's an example.",
    "start": "2893900",
    "end": "2900720"
  },
  {
    "text": "Let's say we have an\narray, a, containing all non-negative integers.",
    "start": "2900720",
    "end": "2908461"
  },
  {
    "text": "And we want to check if\nthe sum of the values in a exceed some limit.",
    "start": "2908461",
    "end": "2914370"
  },
  {
    "text": "So the simple way to\ndo this is, you just sum up all of the values of\nthe array using a for loop.",
    "start": "2914371",
    "end": "2919720"
  },
  {
    "text": "And then at the end, you\ncheck if the total sum is greater than the limit. So using this\napproach, you always",
    "start": "2919720",
    "end": "2926450"
  },
  {
    "text": "have to look at all the\nelements in the array.  But there's actually a\nbetter way to do this.",
    "start": "2926450",
    "end": "2934230"
  },
  {
    "text": "And the idea here\nis, that once you know the partial sum exceeds\nthe limit that you're",
    "start": "2934230",
    "end": "2940120"
  },
  {
    "text": "testing against, then\nyou can just return true, because at that point you know\nthat the sum of the elements",
    "start": "2940120",
    "end": "2946480"
  },
  {
    "text": "in the array will\nexceed the limit, because all of the elements\nin the array are non-negative.",
    "start": "2946480",
    "end": "2952111"
  },
  {
    "text": "And then if you get all the way\nto the end of this for loop, that means you didn't\nexceed this limit.",
    "start": "2952111",
    "end": "2957460"
  },
  {
    "text": "And you can just return false. ",
    "start": "2957460",
    "end": "2963091"
  },
  {
    "text": "So this second program\nhere will usually be faster, if most\nof the time you",
    "start": "2963091",
    "end": "2969490"
  },
  {
    "text": "exceed the limit\npretty early on when you loop through the array. But if you actually end up\nlooking at most of the elements",
    "start": "2969490",
    "end": "2976465"
  },
  {
    "text": "anyways, or even looking\nat all the elements, this second program\nwill actually be a little bit slower, because\nyou have this additional check",
    "start": "2976465",
    "end": "2983650"
  },
  {
    "text": "inside this for loop that has\nto be done for every iteration.",
    "start": "2983650",
    "end": "2989089"
  },
  {
    "text": "So when you apply\nthis optimization, you should be aware of\nwhether this will actually be faster or slower, based\non the frequency of when",
    "start": "2989090",
    "end": "2998768"
  },
  {
    "text": "you can short-circuit the test. ",
    "start": "2998768",
    "end": "3005040"
  },
  {
    "text": "Questions? ",
    "start": "3005040",
    "end": "3012531"
  },
  {
    "text": "OK, and I want to point out\nthat there are short-circuiting logical operators.",
    "start": "3012531",
    "end": "3018109"
  },
  {
    "text": "So if you do double\nampersand, that's short-circuiting\nlogical and operator.",
    "start": "3018110",
    "end": "3023760"
  },
  {
    "text": " So if it evaluates the\nleft side to be false,",
    "start": "3023760",
    "end": "3030303"
  },
  {
    "text": "it means that the whole\nthing has to be false. So it's not even going to\nevaluate the right side. And then the double\nvertical bar is going",
    "start": "3030303",
    "end": "3037680"
  },
  {
    "text": "to be a short-circuiting or. So if it knows that\nthe left side is true, it knows the whole thing has\nto be true, because or just",
    "start": "3037680",
    "end": "3045150"
  },
  {
    "text": "requires one of the\ntwo sides to be true. And it's going to short circuit. In contrast, if you just\nhave a single ampersand",
    "start": "3045150",
    "end": "3051355"
  },
  {
    "text": "or a single vertical\nbar, these are not short-circuiting operators. They're going to evaluate\nboth sides of the argument.",
    "start": "3051355",
    "end": "3057180"
  },
  {
    "text": "The single ampersand\nand single vertical bar turn out to be\npretty useful when you're doing bit manipulation.",
    "start": "3057180",
    "end": "3062520"
  },
  {
    "text": "And we'll be talking\nabout these operators more on Thursday's lecture. Yes?",
    "start": "3062520",
    "end": "3067665"
  },
  {
    "text": "AUDIENCE: So if your\nprogram going to send false, if it were to call the\nfunction and that function was on the right hand\nside of an ampersand,",
    "start": "3067665",
    "end": "3074157"
  },
  {
    "text": "would it mean that\nwould never get called, even though-- and\nyou possibly now find out that, the right\nhand side would crash simply",
    "start": "3074157",
    "end": "3082061"
  },
  {
    "text": "because the left\nhand side was false? JULIAN SHUN: Yeah, if you\nuse a double ampersand, then that would be true.",
    "start": "3082061",
    "end": "3087119"
  },
  {
    "text": "Yes?  AUDIENCE: [INAUDIBLE]\ncheck [INAUDIBLE]",
    "start": "3087120",
    "end": "3093170"
  },
  {
    "text": "that would cause the\ncycle of left hand, so that the right hand\ndoesn't get [INAUDIBLE].. JULIAN SHUN: Yeah. ",
    "start": "3093170",
    "end": "3103150"
  },
  {
    "text": "I guess one example is, if\nyou might possibly index an array out of\nbalance, you can first check whether you would exceed\nthe limit or be out of bounds.",
    "start": "3103150",
    "end": "3113260"
  },
  {
    "text": "And if so, then you don't\nactually do the index. ",
    "start": "3113260",
    "end": "3120786"
  },
  {
    "text": "OK, a related idea is\nto order tests, suss out the tests that are more\noften successful or earlier.",
    "start": "3120787",
    "end": "3128720"
  },
  {
    "text": "And the ones that are\nless frequently successful are later in the\norder, because you",
    "start": "3128720",
    "end": "3135260"
  },
  {
    "text": "want to take advantage\nof short-circuiting. And similarly, inexpensive tests\nshould precede expensive tests,",
    "start": "3135260",
    "end": "3142819"
  },
  {
    "text": "because if you do the\ninexpensive tests and your test short-circuit,\nthen you don't have to do the more expensive tests.",
    "start": "3142820",
    "end": "3148762"
  },
  {
    "text": " So here's an example. Here, we're checking whether\na character is whitespace.",
    "start": "3148762",
    "end": "3157520"
  },
  {
    "text": "So character's\nwhitespace, if it's equal to the carriage\nreturn character, if it's equal to\nthe tab character,",
    "start": "3157520",
    "end": "3163890"
  },
  {
    "text": "if it's equal to\nspace, or if it's equal to the newline character.",
    "start": "3163890",
    "end": "3170222"
  },
  {
    "text": "So which one of\nthese tests do you think should go\nat the beginning? ",
    "start": "3170222",
    "end": "3178851"
  },
  {
    "text": "Yes? AUDIENCE: Probably the space. JULIAN SHUN: Why is that? AUDIENCE: Oh, I\nmean [INAUDIBLE]..",
    "start": "3178852",
    "end": "3184062"
  },
  {
    "text": "Well, maybe the\nnewline [INAUDIBLE].. Either of those\ncould be [INAUDIBLE].. JULIAN SHUN: Yeah,\nyeah, so it turns out",
    "start": "3184062",
    "end": "3193140"
  },
  {
    "text": "that the space and\nthe newline characters appear more frequently\nthan the carriage return. And the tab and the space\nis the most frequent,",
    "start": "3193140",
    "end": "3200490"
  },
  {
    "text": "because you have a\nlot of spaces in text. So here I've reordered the test,\nso that the check for space",
    "start": "3200490",
    "end": "3210210"
  },
  {
    "text": "is first. And then now if you have a\ncharacter, that's a space. You can just short circuit\nthis test and return true.",
    "start": "3210210",
    "end": "3218295"
  },
  {
    "text": "Next, the newline character,\nI have it as a second test, because these are\nalso pretty frequent.",
    "start": "3218295",
    "end": "3224580"
  },
  {
    "text": "You have a newline for\nevery new line in your text. And then less frequent\nis the tab character,",
    "start": "3224580",
    "end": "3231680"
  },
  {
    "text": "and finally, the carriage\nreturn for character isn't that frequently\nused nowadays.",
    "start": "3231680",
    "end": "3237990"
  },
  {
    "text": "So now with this ordering,\nthe most frequently successful",
    "start": "3237990",
    "end": "3243405"
  },
  {
    "text": "tests are going to appear first. ",
    "start": "3243405",
    "end": "3249607"
  },
  {
    "text": "Notice that this only\nactually saves you work if the character is\na whitespace character.",
    "start": "3249607",
    "end": "3254740"
  },
  {
    "text": "It it's not a\nwhitespace character, than you're going to end up\nevaluating all of these tests anyways. ",
    "start": "3254740",
    "end": "3264475"
  },
  {
    "text": "OK, so now let's go back to this\nexample of detecting collision",
    "start": "3264476",
    "end": "3269880"
  },
  {
    "text": "of balls.  So we're going to look at the\nidea of creating a fast path.",
    "start": "3269880",
    "end": "3277270"
  },
  {
    "text": "And the idea of\ncreating a fast path is, that there might\npossibly be a check that will enable you to\nexit the program early,",
    "start": "3277270",
    "end": "3284500"
  },
  {
    "text": "because you already\nknow what the result is. And one fast path check\nfor this particular program",
    "start": "3284500",
    "end": "3292450"
  },
  {
    "text": "here is, you can check whether\nthe bounding boxes of the two balls intersect. If you know the bounding\nboxes of the two balls",
    "start": "3292450",
    "end": "3298780"
  },
  {
    "start": "3295000",
    "end": "3295000"
  },
  {
    "text": "don't intersect, then you know\nthat the balls cannot collide. If the bounding boxes of\nthe two balls do intersect,",
    "start": "3298780",
    "end": "3306025"
  },
  {
    "text": "well, then you have to do\nthe more expensive test, because that doesn't\nnecessarily mean that the balls will collide.",
    "start": "3306025",
    "end": "3312339"
  },
  {
    "text": "So here's what the fast\npath test looks like. We're first going to check\nwhether the bounding boxes",
    "start": "3312340",
    "end": "3320440"
  },
  {
    "text": "intersect. And we can do this by\nlooking at the absolute value of the difference on\neach of the coordinates",
    "start": "3320440",
    "end": "3327250"
  },
  {
    "text": "and checking if that's greater\nthan the sum of the two radii. And if so, that means that\nfor that particular coordinate",
    "start": "3327250",
    "end": "3335855"
  },
  {
    "text": "the bounding boxes\ncannot intersect. And therefore, the\nballs cannot collide. And then we can return\nfalse of any one",
    "start": "3335855",
    "end": "3342130"
  },
  {
    "text": "of these tests returned true. And otherwise, we'll do\nthe more expensive test of comparing d square to the\nsquare of the sum of the two",
    "start": "3342130",
    "end": "3350530"
  },
  {
    "text": "radii. And the reason why\nthis is a fast path is, because this test\nhere is actually cheaper",
    "start": "3350530",
    "end": "3356770"
  },
  {
    "text": "to evaluate than\nthis test below. Here, we're just doing\nsubtractions, additions,",
    "start": "3356770",
    "end": "3363130"
  },
  {
    "text": "and comparisons. And below we're using the\nsquare operator, which requires a multiplication.",
    "start": "3363130",
    "end": "3368994"
  },
  {
    "text": "And multiplications are usually\nmore expensive than additions on modern machines.",
    "start": "3368995",
    "end": "3374275"
  },
  {
    "text": "So ideally, if we don't need\nto do the multiplication, we can avoid it by going\nthrough our fast path.",
    "start": "3374275",
    "end": "3380830"
  },
  {
    "text": " So for this example,\nit probably isn't",
    "start": "3380830",
    "end": "3387720"
  },
  {
    "text": "worth it to do the fast\npath check since it's such a small program. But in practice there are\nmany applications and graphics",
    "start": "3387720",
    "end": "3395565"
  },
  {
    "text": "that benefit greatly from\ndoing fast path checks. And the fast path\ncheck will greatly",
    "start": "3395565",
    "end": "3401100"
  },
  {
    "text": "improve the performance of\nthese graphics programs. There's actually\nanother optimization",
    "start": "3401100",
    "end": "3407065"
  },
  {
    "text": "that we can do here. I talked about this optimization\ncouple of slides ago. Does anyone see it?",
    "start": "3407065",
    "end": "3413950"
  },
  {
    "text": "Yes? AUDIENCE: You can factor\nout the sum of the radii for [INAUDIBLE].",
    "start": "3413950",
    "end": "3419157"
  },
  {
    "text": "JULIAN SHUN: Right. So we can apply common\nsubexpression elimination here, because we're computing the sum\nof the two radii four times.",
    "start": "3419157",
    "end": "3427770"
  },
  {
    "text": "We can actually just compute it\nonce, store it in a variable, and then use it for the\nsubsequent three calls.",
    "start": "3427770",
    "end": "3433865"
  },
  {
    "text": "And then similarly,\nwhen we're taking the difference between\neach of the coordinates,",
    "start": "3433865",
    "end": "3439110"
  },
  {
    "text": "we're also doing it twice. So again, we can store\nthat in a variable and then just use the\nresult in the second time.",
    "start": "3439110",
    "end": "3445800"
  },
  {
    "text": " Any questions?",
    "start": "3445800",
    "end": "3451135"
  },
  {
    "start": "3451135",
    "end": "3456955"
  },
  {
    "text": "OK, so the next idea is\nto combine tests together. So here, we're going to\nreplace a sequence of tests",
    "start": "3456955",
    "end": "3463970"
  },
  {
    "start": "3458000",
    "end": "3458000"
  },
  {
    "text": "with just one test\nor switch statement. So here's an implementation\nof a full adder.",
    "start": "3463970",
    "end": "3470970"
  },
  {
    "text": "So a full adder is\na hardware device that takes us input three bits. And then it returns the carry\nbit and the sum bit as output.",
    "start": "3470970",
    "end": "3479430"
  },
  {
    "text": "So here's a table that specifies\nfor every possible input to the full adder of what\nthe output should be.",
    "start": "3479430",
    "end": "3487244"
  },
  {
    "text": "And there are eight possible\ninputs to the full adder, because it takes three bits. And there are eight\npossibilities there.",
    "start": "3487245",
    "end": "3494470"
  },
  {
    "text": "And this program here is going\nto check all the possibilities. It's first going to check\nif a is equal to zero.",
    "start": "3494470",
    "end": "3500680"
  },
  {
    "text": "If so, it checks if\nb is equal to zero. If so, it checks if\nc is equal to zero.",
    "start": "3500680",
    "end": "3505779"
  },
  {
    "text": "And if that's true, it returns\nzero and zero for the two bits. And otherwise, it returns\none and zero and so on.",
    "start": "3505780",
    "end": "3513510"
  },
  {
    "text": "So this is basically\na whole bunch of if else statements\nnested together.",
    "start": "3513510",
    "end": "3520416"
  },
  {
    "text": "Does anyone think this is a\ngood way to write the program? Who thinks this is a bad\nway to write the program?",
    "start": "3520416",
    "end": "3529331"
  },
  {
    "text": "OK, so most of you think it's\na bad way to write the program. And hopefully, I can\nconvince the rest of you",
    "start": "3529332",
    "end": "3536890"
  },
  {
    "text": "who didn't raise your hand. So here's a better way\nto write this program.",
    "start": "3536890",
    "end": "3542820"
  },
  {
    "text": "So we're going to replace\nthese multiple if else clauses with a single switch statement.",
    "start": "3542821",
    "end": "3549730"
  },
  {
    "text": "And what we're going\nto do is, we're going to create this test variable. That is a three-bit variable.",
    "start": "3549730",
    "end": "3555565"
  },
  {
    "text": "So we're going to\nplace the c bit in the least significant digit. The b bit, we're going\nto shift it over by one,",
    "start": "3555565",
    "end": "3563172"
  },
  {
    "text": "so in the second least\nsignificant digit, and then the a bit in the\nthird least significant digit.",
    "start": "3563172",
    "end": "3568660"
  },
  {
    "text": "And now the value of\nthis test variable is going to range\nfrom zero to seven. And then for each\npossibility, we",
    "start": "3568660",
    "end": "3575080"
  },
  {
    "text": "can just specify what the sum\nand the carry bits should be. And this requires just a single\nswitch statement, instead of",
    "start": "3575080",
    "end": "3583930"
  },
  {
    "text": "a whole bunch of\nif else clauses.  There's actually an even\nbetter way to do this,",
    "start": "3583930",
    "end": "3590930"
  },
  {
    "text": "for this example, which\nis to use table lookups. You just precompute all these\nanswers, store it in a table,",
    "start": "3590930",
    "end": "3597619"
  },
  {
    "text": "and then just look\nit up at runtime.  But the idea here is that you\ncan combine multiple tests",
    "start": "3597620",
    "end": "3606320"
  },
  {
    "text": "in a single test. And this not only makes\nyour code cleaner, but it can also improve the\nperformance of your program,",
    "start": "3606320",
    "end": "3612613"
  },
  {
    "text": "because you're not\ndoing so many checks. And you won't have as\nmany branch misses.",
    "start": "3612613",
    "end": "3619418"
  },
  {
    "text": "Yes? AUDIENCE: Would coming up\nwith logic gates for this be better or no? JULIAN SHUN: Maybe.",
    "start": "3619418",
    "end": "3626630"
  },
  {
    "text": "Yeah, I mean, I encourage you\nto see if you can write a faster program for this.",
    "start": "3626630",
    "end": "3632420"
  },
  {
    "text": "All right, so we're\ndone with two categories of optimizations. We still have two more to go. ",
    "start": "3632420",
    "end": "3639349"
  },
  {
    "text": "The third category is\ngoing to be about loops. So if we didn't have any\nloops in our programs,",
    "start": "3639350",
    "end": "3646780"
  },
  {
    "text": "well, there wouldn't be\nmany interesting programs to optimize, because\nmost of our programs wouldn't be very long running.",
    "start": "3646780",
    "end": "3653425"
  },
  {
    "text": "But with loops we can\nactually optimize these loops and then realize the benefits\nof performance engineering.",
    "start": "3653425",
    "end": "3662020"
  },
  {
    "text": "The first loop optimization I\nwant to talk about is hoisting. The goal of hoisting, which is\nalso called loop-invariant code",
    "start": "3662020",
    "end": "3668710"
  },
  {
    "text": "motion, is to avoid recomputing\na loop-invariant code each time through\nthe body of a loop.",
    "start": "3668710",
    "end": "3674859"
  },
  {
    "text": "So if you have a for loop\nwhere in each iteration are computing the\nsame thing, well, you",
    "start": "3674860",
    "end": "3682060"
  },
  {
    "text": "can actually save work by\njust computing it once. So in this example\nhere, I'm looping",
    "start": "3682060",
    "end": "3688270"
  },
  {
    "text": "over an array of length N.\nAnd them I'm setting Y of i equal to X of i times the\nexponential of the square root",
    "start": "3688270",
    "end": "3695859"
  },
  {
    "text": "of pi over two. But this exponential\nsquare root of pi over two",
    "start": "3695860",
    "end": "3701440"
  },
  {
    "text": "is actually the same\nin every iteration. So I don't actually have\nto compute that every time.",
    "start": "3701440",
    "end": "3708792"
  },
  {
    "text": "So here's a version of the\ncode that does hoisting. I just move this expression\noutside of the for loop",
    "start": "3708792",
    "end": "3714760"
  },
  {
    "text": "and stored it in\na variable factor. And then now inside\nthe for loop, I just have to\nmultiply by factor.",
    "start": "3714760",
    "end": "3719920"
  },
  {
    "text": "I already computed what\nthis expression is. And this can save running\ntime, because computing",
    "start": "3719920",
    "end": "3728035"
  },
  {
    "text": "the exponential, the\nsquare root of pi over two, is actually\nrelatively expensive. ",
    "start": "3728035",
    "end": "3735290"
  },
  {
    "text": "So turns out that for\nthis example, you know, the compiler can\nprobably figure it out",
    "start": "3735290",
    "end": "3740640"
  },
  {
    "text": "and do this hoisting for you. But in some cases,\nthe compiler might not be able to figure\nit out, especially",
    "start": "3740640",
    "end": "3746865"
  },
  {
    "text": "if these functions here might\nchange throughout the program. So it's a good idea to know\nwhat this optimization is,",
    "start": "3746865",
    "end": "3755610"
  },
  {
    "text": "so you can apply it in your code\nwhen the compiler doesn't do it for you. ",
    "start": "3755610",
    "end": "3766717"
  },
  {
    "text": "OK, sentinels, so sentinels\nare special dummy values placed in a data structure to\nsimplify the logic of handling",
    "start": "3766717",
    "end": "3774550"
  },
  {
    "text": "boundary conditions, and in\nparticular the handling of loop exit tests. ",
    "start": "3774550",
    "end": "3782394"
  },
  {
    "text": "So here, I, again, have this\nprogram that checks whether--",
    "start": "3782394",
    "end": "3788073"
  },
  {
    "text": "so I have this\nprogram that checks whether the sum of the\nelements in sum array A",
    "start": "3788073",
    "end": "3794505"
  },
  {
    "text": "will overflow if I added all\nof the elements together. And here, I've specified\nthat all of the elements of A",
    "start": "3794505",
    "end": "3801055"
  },
  {
    "text": "are non-negative. So how I do this is,\nin every iteration",
    "start": "3801055",
    "end": "3806815"
  },
  {
    "text": "I'm going to increment\nsome by A of i. And then I'll check if the\nresulting sum is less than A",
    "start": "3806815",
    "end": "3812859"
  },
  {
    "text": "of i. Does anyone see why this will\ndetect if I had an overflow? ",
    "start": "3812860",
    "end": "3823300"
  },
  {
    "text": "Yes? AUDIENCE: We're a\nclosed algorithm. It's not taking any values. JULIAN SHUN: Yeah, so\nif the thing I added in",
    "start": "3823300",
    "end": "3829860"
  },
  {
    "text": "causes an overflow, then the\nresult is going to wrap around. And it's going to be less\nthan the thing I added in.",
    "start": "3829860",
    "end": "3835630"
  },
  {
    "text": "So this is why the\ncheck here, that checks whether the sum\nis less than negative i, will detect an overflow.",
    "start": "3835630",
    "end": "3840920"
  },
  {
    "text": " OK, so I'm going to do this\ncheck in every iteration.",
    "start": "3840920",
    "end": "3847359"
  },
  {
    "text": "If it's true, I'll\njust return true. And otherwise, I get to\nthe end of this for loop where I just return false.",
    "start": "3847360",
    "end": "3854800"
  },
  {
    "text": "But here on every iteration,\nI'm doing two checks. I'm first checking\nwhether I should exit the body of this loop.",
    "start": "3854800",
    "end": "3861250"
  },
  {
    "text": "And then secondly, I'm checking\nwhether the sum is less than A of i.",
    "start": "3861250",
    "end": "3866720"
  },
  {
    "text": "It turns out that I can\nactually modify this program, so that I only need\nto do one check in every iteration of the loop.",
    "start": "3866720",
    "end": "3873025"
  },
  {
    "text": "So here's a modified\nversion of this program. So here, I'm going\nto assume that I have two additional\nentries in my array A.",
    "start": "3873025",
    "end": "3879580"
  },
  {
    "text": "So these are A of n\nand A of n minus one. So I assume I can\nuse these locations.",
    "start": "3879580",
    "end": "3885550"
  },
  {
    "text": "And I'm going to set A of n\nto be the largest possible 64-bit integer, or INT64 MAX.",
    "start": "3885550",
    "end": "3892435"
  },
  {
    "text": "And I'm going to set A\nof n plus one to be one. And then now I'm going to\ninitialize my loop variable",
    "start": "3892435",
    "end": "3898960"
  },
  {
    "text": "i to be zero. And then I'm going to set the\nsum equal to the first element in A or A of zero.",
    "start": "3898960",
    "end": "3906040"
  },
  {
    "text": "And then now I\nhave this loop that checks whether the sum is\ngreater than or equal to A",
    "start": "3906040",
    "end": "3912160"
  },
  {
    "text": "of i. And if so, I'm going to add\nA of i plus one to the sum.",
    "start": "3912160",
    "end": "3917380"
  },
  {
    "text": "And then I also increment i. OK, and this code here\ndoes the same thing",
    "start": "3917380",
    "end": "3925840"
  },
  {
    "text": "as a thing on the left,\nbecause the only way I'm going to exit this while\nloop is, if I overflow.",
    "start": "3925840",
    "end": "3931860"
  },
  {
    "text": "And I'll overflow if A of\ni becomes greater than sum, or if the sum\nbecomes less than A",
    "start": "3931860",
    "end": "3937839"
  },
  {
    "text": "of i, which is what I had\nin my original program. And then otherwise, I'm going\nto just increment sum by A of i.",
    "start": "3937840",
    "end": "3946315"
  },
  {
    "text": "And then this code here is\ngoing to eventually overflow, because if the\nelements in my array A",
    "start": "3946315",
    "end": "3953019"
  },
  {
    "text": "don't cause the\nprogram to overflow, I'm going to get to A of n. And A of n is a\nvery large integer.",
    "start": "3953020",
    "end": "3958859"
  },
  {
    "text": "And if I add that\nto what I have, it's going to cause the\nprogram to overflow. And at that point,\nI'm going to exit this",
    "start": "3958860",
    "end": "3964690"
  },
  {
    "text": "for loop or this while loop. And then after I exit this loop,\nI can check why I overflowed.",
    "start": "3964690",
    "end": "3972220"
  },
  {
    "text": "If I overflowed because\nof sum element of A, then the loop index i is\ngoing to be less than n,",
    "start": "3972220",
    "end": "3979619"
  },
  {
    "text": "and I return true. But if I overflowed because\nI added in this huge integer,",
    "start": "3979620",
    "end": "3985045"
  },
  {
    "text": "well, than i is going\nto be equal to n. And then I know that\nthe elements of A didn't caused me to overflow,\nthe A of n value here did.",
    "start": "3985045",
    "end": "3994750"
  },
  {
    "text": "So then I just return false. So does this makes sense?",
    "start": "3994750",
    "end": "4001210"
  },
  {
    "text": "So here in each\niteration, I only have to do one check\ninstead of two checks, as in my original code.",
    "start": "4001210",
    "end": "4007440"
  },
  {
    "text": "I only have to check whether\nthe sum is greater than or equal to A of i.",
    "start": "4007440",
    "end": "4013204"
  },
  {
    "text": "Does anyone know why I set A\nof n plus one equal to one?",
    "start": "4013204",
    "end": "4019155"
  },
  {
    "text": "Yes? AUDIENCE: If everything else\nin the array was zero, then you still wouldn't\nhave overflowed. If you had been at 64\nmax, it would overflow.",
    "start": "4019155",
    "end": "4026620"
  },
  {
    "text": "JULIAN SHUN: Yeah, so good. So the answer is, because\nif all of my elements were zero in my original\narray, that even",
    "start": "4026620",
    "end": "4033750"
  },
  {
    "text": "though I add in\nthis huge integer, it's still not\ngoing to overflow. But now when I get\nto A of n plus one,",
    "start": "4033750",
    "end": "4041099"
  },
  {
    "text": "I'm going to add one to it. And then that will cause\nthe sum to overflow. And then I can exit there. So this is a deal with\nthe boundary condition",
    "start": "4041100",
    "end": "4048600"
  },
  {
    "text": "when all the entries\nin my array are zero. ",
    "start": "4048600",
    "end": "4056832"
  },
  {
    "text": "OK, so next, loop\nunrolling, so loop unrolling attempts to save\nwork by combining",
    "start": "4056832",
    "end": "4063420"
  },
  {
    "text": "several consecutive\niterations of a loop into a single iteration. Thereby, reducing\nthe total number",
    "start": "4063420",
    "end": "4069510"
  },
  {
    "text": "of iterations of the\nloop and consequently the number of times that the\ninstructions that control",
    "start": "4069510",
    "end": "4074730"
  },
  {
    "text": "the loop have to be executed. So there are two types\nof loop unrolling.",
    "start": "4074730",
    "end": "4080000"
  },
  {
    "text": "There's full loop\nunrolling, where I unroll all of the\niterations of the for loop, and I just get rid of the\ncontrol-flow logic entirely.",
    "start": "4080000",
    "end": "4088700"
  },
  {
    "text": "Then there's partial loop\nunrolling, where I only unroll some of the iterations\nbut not all of the iterations.",
    "start": "4088700",
    "end": "4095230"
  },
  {
    "text": "So I still have some\ncontrol-flow code in my loop.",
    "start": "4095230",
    "end": "4100359"
  },
  {
    "text": "So let's first look at\nfull loop unrolling. So here, I have a\nsimple program that",
    "start": "4100360",
    "end": "4106460"
  },
  {
    "text": "just loops for 10 iterations. The fully unrolled loop\njust looks like the code",
    "start": "4106460",
    "end": "4112401"
  },
  {
    "text": "on the right hand side. I just wrote out all\nof the lines of code that I have to do in\nstraight-line code,",
    "start": "4112401",
    "end": "4117799"
  },
  {
    "text": "instead of using a for loop. And now I don't need to\ncheck on every iteration, whether I need to\nexit the for loop.",
    "start": "4117800",
    "end": "4125732"
  },
  {
    "text": "So this is for loop unrolling. This is actually\nnot very common,",
    "start": "4125732",
    "end": "4131720"
  },
  {
    "text": "because most of\nyour loops are going to be much larger than 10. And oftentimes, many\nof your loop bounds",
    "start": "4131720",
    "end": "4138500"
  },
  {
    "text": "are not going to be\ndetermined at compile time. They're determined at runtime. So the compiler can't fully\nunroll that loop for you.",
    "start": "4138500",
    "end": "4146960"
  },
  {
    "text": "For small loops like\nthis, the compiler will probably unroll\nthe loop for you.",
    "start": "4146960",
    "end": "4152530"
  },
  {
    "text": "But for larger\nloops, it actually doesn't benefit to\nunroll the loop fully,",
    "start": "4152531",
    "end": "4158479"
  },
  {
    "text": "because you're going to\nhave a lot of instructions. And that's going to pollute\nyour instruction cache.",
    "start": "4158479",
    "end": "4165496"
  },
  {
    "text": "So the more common\nform of loop unrolling is partial loop unrolling.",
    "start": "4165496",
    "end": "4171062"
  },
  {
    "text": "And here, in this\nexample here, I've unrolled the loop\nby a factor of four.",
    "start": "4171062",
    "end": "4177452"
  },
  {
    "text": "So I reduce the number of\niterations of my for loop by a factor of four. And then inside the\nbody of each iteration",
    "start": "4177452",
    "end": "4184700"
  },
  {
    "text": "I have four instructions. And then notice, I\nalso changed the logic",
    "start": "4184700",
    "end": "4191779"
  },
  {
    "text": "in the control-flow\nof my for loops. So now I'm incrementing\nthe variable j by four instead of just by one.",
    "start": "4191780",
    "end": "4199885"
  },
  {
    "text": "And then since n\nmight not necessarily be divisible by four, I have\nto deal with the remaining",
    "start": "4199886",
    "end": "4205350"
  },
  {
    "text": "elements. And this is what the second\nfor loop is doing here. It's just dealing with\nthe remaining elements.",
    "start": "4205350",
    "end": "4211976"
  },
  {
    "text": "And this is the more common\nform of loop unrolling.",
    "start": "4211976",
    "end": "4217390"
  },
  {
    "text": "So the first benefit\nof doing this is, that you have fewer\nchecks to the exit condition",
    "start": "4217390",
    "end": "4225812"
  },
  {
    "text": "for the loop,\nbecause you only have to do this check every\nfour iterations instead of every iteration.",
    "start": "4225812",
    "end": "4231724"
  },
  {
    "text": "But the second and\nmuch bigger benefit is, that it allows more\ncompiler optimizations,",
    "start": "4231725",
    "end": "4236929"
  },
  {
    "text": "because it increases the\nsize of the loop body. And it gives the\ncompiler more freedom to play around with code\nand to find ways to optimize",
    "start": "4236930",
    "end": "4245081"
  },
  {
    "text": "the performance of that code. So that's usually\nthe bigger benefit.",
    "start": "4245082",
    "end": "4250520"
  },
  {
    "text": "If you unroll the\nloop by too much, that actually isn't very\ngood, because now you're",
    "start": "4250520",
    "end": "4257179"
  },
  {
    "text": "going to be pleading\nyour instruction cache. And every time you\nfetch an instruction,",
    "start": "4257180",
    "end": "4262485"
  },
  {
    "text": "it's likely going to be a miss\nin your instruction cache. And that's going to decrease\nthe performance of your program.",
    "start": "4262485",
    "end": "4269236"
  },
  {
    "text": "And furthermore, if your loop\nbody is already very big, you don't really get\nadditional improvements",
    "start": "4269236",
    "end": "4274385"
  },
  {
    "text": "from having the compiler\ndo more optimizations, because it already has\nenough code to work with.",
    "start": "4274385",
    "end": "4280699"
  },
  {
    "text": "So giving it more code doesn't\nactually give you much there. ",
    "start": "4280700",
    "end": "4287378"
  },
  {
    "text": "OK, so I just said this. The benefits of loop unrolling\na lower number of instructions",
    "start": "4287378",
    "end": "4292630"
  },
  {
    "text": "and loop control code. And then it also enables\nmore compiler optimizations. And the second benefit here is\nusually the much more important",
    "start": "4292630",
    "end": "4299590"
  },
  {
    "text": "benefit. And we'll talk more about\ncompiler optimizations in a couple of lectures.",
    "start": "4299590",
    "end": "4306664"
  },
  {
    "text": "OK, any questions? ",
    "start": "4306664",
    "end": "4316010"
  },
  {
    "text": "OK, so the next\noptimization is loop fusion. This is also called jamming. And the idea here is to\ncombine multiple loops",
    "start": "4316010",
    "end": "4322699"
  },
  {
    "text": "over the same index\nrange into a single loop, thereby saving the\noverhead of loop control.",
    "start": "4322700",
    "end": "4330646"
  },
  {
    "text": "So here, I have two loops. They're both looping from i\nequal zero, all the way up to n minus one.",
    "start": "4330646",
    "end": "4336870"
  },
  {
    "text": "The first loop, I'm computing\nthe minimum of A of i and B of i and storing\nthe result in C of i.",
    "start": "4336870",
    "end": "4343864"
  },
  {
    "text": "The second loop, I'm computing\nthe maximum of A of i and B of i and storing\nthe result in D of i.",
    "start": "4343865",
    "end": "4353090"
  },
  {
    "text": "So since these are going\nover the same index rang, I can fused together\nthe two loops,",
    "start": "4353090",
    "end": "4358520"
  },
  {
    "text": "giving me a single loop that\ndoes both of these lines here.",
    "start": "4358520",
    "end": "4364620"
  },
  {
    "text": "And this reduces the overhead\nof loop control code, because now instead of doing\nthis exit condition check two n",
    "start": "4364620",
    "end": "4372410"
  },
  {
    "text": "times, I only have\nto do it n times. This also gives you\nbetter cache locality.",
    "start": "4372410",
    "end": "4378978"
  },
  {
    "text": "Again, we'll talk more\nabout cache locality in a future lecture. But at a high\nlevel here, what it",
    "start": "4378978",
    "end": "4386210"
  },
  {
    "text": "gives you is, that once you load\nA of i and B of i into cache, when you compute\nC of i, it's also",
    "start": "4386210",
    "end": "4391310"
  },
  {
    "text": "going to be in cache\nwhen you compute D of i. Whereas, in the original\ncode, when you compute D of i,",
    "start": "4391310",
    "end": "4397639"
  },
  {
    "text": "it's very likely that\nA of i and B of i are going to be kicked\nout of cache already, even though you brought it\nin when you computed C of i.",
    "start": "4397640",
    "end": "4403550"
  },
  {
    "text": " For this example\nhere, again, there's",
    "start": "4403550",
    "end": "4410489"
  },
  {
    "text": "another optimization you\ncan do, common subexpression elimination, since you're\ncomputing this expression",
    "start": "4410490",
    "end": "4416400"
  },
  {
    "text": "A of i is less than or\nequal to B of i twice. ",
    "start": "4416400",
    "end": "4424005"
  },
  {
    "text": "OK, next, let's look at\neliminating wasted iterations. The idea of eliminating\nwasted iterations",
    "start": "4424005",
    "end": "4429945"
  },
  {
    "text": "is to modify the\nloop bounds to avoid executing loop iterations over\nessentially empty loop bodies.",
    "start": "4429945",
    "end": "4437090"
  },
  {
    "text": "So here, I have some code\nto transpose, a matrix. So I go from i equal\nzero to n minus one,",
    "start": "4437090",
    "end": "4443670"
  },
  {
    "text": "from j equals zero\nto n minus one. And then I check if\ni is greater than j. And if so, I'll swap the entries\nin A of i, j and A of j, i.",
    "start": "4443670",
    "end": "4452775"
  },
  {
    "text": "The reason why I\nhave this check here is, because I don't want\nto do the swap twice. Otherwise, I'll just end up with\nthe same matrix I had before.",
    "start": "4452775",
    "end": "4459750"
  },
  {
    "text": "So I only have to do the swap\nwhen i is greater than j.",
    "start": "4459750",
    "end": "4464960"
  },
  {
    "text": "One disadvantage of this\ncode here is, I still have to loop for n\nsquared iterations,",
    "start": "4464960",
    "end": "4470745"
  },
  {
    "text": "even though only about\nhalf of the iterations are actually doing useful\nwork, because about half",
    "start": "4470745",
    "end": "4476670"
  },
  {
    "text": "of the iterations are going\nto fail this check here, that checks whether\ni is greater than j.",
    "start": "4476670",
    "end": "4482841"
  },
  {
    "text": "So here's a modified version of\nthe program, where I basically eliminate these\nwasted iterations.",
    "start": "4482841",
    "end": "4489545"
  },
  {
    "text": "So now I'm going to loop from\ni equals one to n minus one, and then from j equals zero\nall the way up to i minus one.",
    "start": "4489545",
    "end": "4496260"
  },
  {
    "text": "So now instead of going\nup to n minus one, I'm going just up\nto i minus one. And that basically\nputs this check,",
    "start": "4496260",
    "end": "4504719"
  },
  {
    "text": "whether i is greater than j,\ninto the loop control code. And that saves me the\nextra wasted iterations.",
    "start": "4504720",
    "end": "4510699"
  },
  {
    "text": " OK, so that's the last\noptimization on loops.",
    "start": "4510700",
    "end": "4517620"
  },
  {
    "text": "Are there any questions? Yes? AUDIENCE: Isn't the checks\nstill have [INAUDIBLE]??",
    "start": "4517620",
    "end": "4524120"
  },
  {
    "text": " JULIAN SHUN: So the check is--",
    "start": "4524120",
    "end": "4529910"
  },
  {
    "text": "so you still have to do the\ncheck in the loop control code. But here, you also had to do it. And now you just don't\nhave to do it again",
    "start": "4529910",
    "end": "4536530"
  },
  {
    "text": "inside the body of the loop.  Yes?",
    "start": "4536530",
    "end": "4541635"
  },
  {
    "text": "AUDIENCE: In some\ncases, where it might be more complex\nto do it, is it also [INAUDIBLE]\nbefore you optimize it,",
    "start": "4541635",
    "end": "4550200"
  },
  {
    "text": "but it's still going to be\nfast enough [INAUDIBLE].. Like in the first example,\neven though the loop is empty,",
    "start": "4550200",
    "end": "4557720"
  },
  {
    "text": "most of the time you'll be\nable to process [INAUDIBLE]",
    "start": "4557720",
    "end": "4563971"
  },
  {
    "text": "run the instructions. JULIAN SHUN: Yes,\nso most of these",
    "start": "4563971",
    "end": "4570333"
  },
  {
    "text": "are going to be branch hits. So it's still going\nto be pretty fast. But it's going to be\neven faster if you just",
    "start": "4570333",
    "end": "4576780"
  },
  {
    "text": "don't do that check at all. So I mean, basically you\nshould just text it out",
    "start": "4576780",
    "end": "4583130"
  },
  {
    "text": "in your code to see\nwhether it will give you a runtime improvement. ",
    "start": "4583130",
    "end": "4591100"
  },
  {
    "text": "OK, so last category of\noptimizations is functions.",
    "start": "4591100",
    "end": "4596656"
  },
  {
    "text": "So first, the idea\nof inlining is to avoid the overhead\nof a function call by replacing a call to\nthe function with the body",
    "start": "4596656",
    "end": "4604130"
  },
  {
    "text": "of the function itself.  So here, I have a\npiece of code that's",
    "start": "4604130",
    "end": "4610239"
  },
  {
    "text": "computing the sum of squares\nof elements in an array A. And so I have this for\nloop that in each iteration",
    "start": "4610240",
    "end": "4618940"
  },
  {
    "text": "is calling this square function. And the square function\nis defined above here. It just does x times x\nfor input argument x.",
    "start": "4618940",
    "end": "4629046"
  },
  {
    "text": "But it turns out that there\nis actually some overhead to doing a function call. And the idea here is\nto just put the body",
    "start": "4629046",
    "end": "4636370"
  },
  {
    "text": "of the function inside the\nfunction that's calling it. So instead of calling\nthe square function,",
    "start": "4636370",
    "end": "4642760"
  },
  {
    "text": "I'm just going to\ncreate a variable temp. And then I set sum equal to\nsum plus temp times temp.",
    "start": "4642760",
    "end": "4652168"
  },
  {
    "text": "So now I don't have to do\nthe additional function call. ",
    "start": "4652168",
    "end": "4658070"
  },
  {
    "text": "You don't actually have\nto do this manually. So if you declare your\nfunction to be static inline,",
    "start": "4658070",
    "end": "4664739"
  },
  {
    "text": "then the compiler\nis going to try to inline this function\nfor you by placing the body of the function inside\nthe code that's calling it.",
    "start": "4664740",
    "end": "4672655"
  },
  {
    "text": "And nowadays, the compiler\nis pretty good at doing this. So even if you don't\ndeclare static inline, the compiler will probably\nstill inline this code for you.",
    "start": "4672655",
    "end": "4680800"
  },
  {
    "text": "But just to make sure, if you\nwant to inline a function, you should declare\nit as static inline.",
    "start": "4680800",
    "end": "4688096"
  },
  {
    "text": "And you might ask, why can't\nyou just use a macro to do this? But it turns out, that inline\nfunctions nowadays are just",
    "start": "4688096",
    "end": "4694120"
  },
  {
    "text": "as efficient as macros. But they're better structured,\nbecause they evaluate all of their arguments.",
    "start": "4694120",
    "end": "4699475"
  },
  {
    "text": "Whereas, macros just do\na textual substitution. So if you have an\nargument that's very expensive to\nevaluate, the macro",
    "start": "4699475",
    "end": "4705970"
  },
  {
    "text": "might actually paste that\nexpression multiple times in your code. And if the compiler\nisn't good enough",
    "start": "4705970",
    "end": "4711880"
  },
  {
    "text": "to do common\nsubexpression elimination, then you've just\nwasted a lot of work. ",
    "start": "4711880",
    "end": "4720061"
  },
  {
    "text": "OK, so there's one\nmore optimization--",
    "start": "4720061",
    "end": "4725220"
  },
  {
    "text": "or there's two\nmore optimizations that I'm not going to\nhave time to talk about. But I'm going to post these\nslides on Learning Modules,",
    "start": "4725220",
    "end": "4731340"
  },
  {
    "text": "so please take a look at them,\ntail-recursion elimination and coarsening recursion.",
    "start": "4731340",
    "end": "4739958"
  },
  {
    "text": "So here are a list\nof most of the roles that we looked at today.",
    "start": "4739958",
    "end": "4744990"
  },
  {
    "text": "There are two of the\nfunction optimizations I didn't get to talk\nabout, please take a look at that offline,\nand ask your TAs if you",
    "start": "4744990",
    "end": "4752880"
  },
  {
    "text": "have any questions. And some closing\nadvice is, you should avoid premature optimizations.",
    "start": "4752880",
    "end": "4758787"
  },
  {
    "text": "So all of the things\nI've talked about today improve the performance\nof your program. But you first need to make sure\nthat your program is correct.",
    "start": "4758787",
    "end": "4765090"
  },
  {
    "text": "If you have a program that\ndoesn't do the right thing, then it doesn't really\nbenefit you to make it faster.",
    "start": "4765090",
    "end": "4771969"
  },
  {
    "text": "And to preserve correctness, you\nshould do regression testing, so develop a suite\nof tests to check",
    "start": "4771970",
    "end": "4777770"
  },
  {
    "text": "the correctness of\nyour program every time you change the program. And as I said before,\nreducing the work of a program",
    "start": "4777770",
    "end": "4785489"
  },
  {
    "text": "doesn't necessarily\ndecrease its running time. But it's a good heuristic. And finally, the\ncompiler automates",
    "start": "4785490",
    "end": "4790740"
  },
  {
    "text": "many low-level optimizations. And you can look at\nthe assembly code to see whether the\ncompiler did something.",
    "start": "4790740",
    "end": "4797510"
  },
  {
    "start": "4797510",
    "end": "4809896"
  }
]