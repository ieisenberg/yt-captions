[
  {
    "start": "0",
    "end": "22000"
  },
  {
    "text": " The following content is\nprovided under a Creative Commons license.",
    "start": "0",
    "end": "5310"
  },
  {
    "text": "Your support will help\nMIT Open Courseware continue to offer high quality\neducational resources for free.",
    "start": "5310",
    "end": "11610"
  },
  {
    "text": "To make a donation or to\nview additional materials from hundreds of MIT courses,\nvisit MIT OpenCourseware",
    "start": "11610",
    "end": "17604"
  },
  {
    "text": "at ocw.mit.edu.  JULIAN SHUN: Good\nafternoon, everyone.",
    "start": "17604",
    "end": "24259"
  },
  {
    "start": "22000",
    "end": "75000"
  },
  {
    "text": "So today, we have\nTB Schardl here. He's going to give us the\nlecture on C to assembly.",
    "start": "24260",
    "end": "30910"
  },
  {
    "text": "So TB's a research\nscientist here at MIT working with Charles Leiserson.",
    "start": "30910",
    "end": "36160"
  },
  {
    "text": "He also taught this\nclass with me last year, and he got one of the best\nratings ever for this class.",
    "start": "36160",
    "end": "43720"
  },
  {
    "text": "So I'm really looking\nforward to his lecture. TAO SCHARDL: All right, great.",
    "start": "43720",
    "end": "50680"
  },
  {
    "text": "So thank you for the\nintroduction, Julian. So I hear you just submitted\nthe beta for project 1.",
    "start": "50680",
    "end": "58750"
  },
  {
    "text": "Hopefully, that\nwent pretty well. How many of you slept\nin the last 24 hours?",
    "start": "58750",
    "end": "65930"
  },
  {
    "text": "OK, good. All right, so it\nwent pretty well. That sounds great.",
    "start": "65930",
    "end": "71240"
  },
  {
    "text": "Yeah, so today, we're going to\nbe talking about C to assembly. And this is really\na continuation",
    "start": "71240",
    "end": "77260"
  },
  {
    "text": "from the topic of\nlast lecture, where you saw computer architecture,\nif I understand correctly. Is that right?",
    "start": "77260",
    "end": "82869"
  },
  {
    "text": "You looked at computer\narchitecture, x86-64 assembly, that sort of thing.",
    "start": "82870",
    "end": "89320"
  },
  {
    "text": "So how many of you walked away\nfrom that lecture thinking, oh yeah, x86-64 assembly,\nthis is easy?",
    "start": "89320",
    "end": "96039"
  },
  {
    "text": "This is totally intuitive. Everything makes perfect sense. There's no weirdness\ngoing on here whatsoever.",
    "start": "96040",
    "end": "102800"
  },
  {
    "text": "How many of you walked\naway not thinking that? Thinking that perhaps this\nis a little bit strange,",
    "start": "102800",
    "end": "109020"
  },
  {
    "text": "this whole assembly language. Yeah, I'm really in\nthe later cab. x86 is kind of a strange beast.",
    "start": "109020",
    "end": "115200"
  },
  {
    "text": "There are things in\nthere that make no sense. Quad word has 8 bytes. P stands for integer,\nthat sort of thing.",
    "start": "115200",
    "end": "122939"
  },
  {
    "text": " So when we move on to the\ntopic of seeing how C code gets",
    "start": "122940",
    "end": "131130"
  },
  {
    "text": "translated into assembly,\nwe're translating into something that's\nalready pretty complicated.",
    "start": "131130",
    "end": "137137"
  },
  {
    "text": "And the translation\nitself isn't going to be that straightforward. So we're going to have to find\na way to work through that.",
    "start": "137137",
    "end": "144180"
  },
  {
    "text": "And I'll outline the\nstrategy that we'll be using in the start\nof this presentation.",
    "start": "144180",
    "end": "150447"
  },
  {
    "start": "150000",
    "end": "555000"
  },
  {
    "text": "But first, let's quickly review. Why do we care about\nlooking at assembly? You should have seen this\nslide from the last lecture.",
    "start": "150447",
    "end": "157620"
  },
  {
    "text": "But essentially, assembly is\na more precise representation of the program than\nthe C code itself.",
    "start": "157620",
    "end": "164750"
  },
  {
    "text": "And if you look at\nthe assembly, that can reveal details about the\nprogram that are not obvious",
    "start": "164750",
    "end": "170140"
  },
  {
    "text": "when you just look at\nthe C code directly. There are implicit things\ngoing on in the C code,",
    "start": "170140",
    "end": "175870"
  },
  {
    "text": "such as type cast or\nthe usage of registers versus memory on the machine.",
    "start": "175870",
    "end": "181390"
  },
  {
    "text": "And those can have\nperformance implications. So it's valuable to take a look\nat the assembly code directly.",
    "start": "181390",
    "end": "187750"
  },
  {
    "text": "It can also reveal what\nthe compiler did or did not do when it tried to\noptimize the program.",
    "start": "187750",
    "end": "193810"
  },
  {
    "text": "For example, you may have\nwritten a division operation or a multiply operation. But somehow, the\ncompiler figured out",
    "start": "193810",
    "end": "200560"
  },
  {
    "text": "that it didn't really\nneed to do a divide or multiply to implement\nthat operation. It could implement it more\nquickly using simpler, faster",
    "start": "200560",
    "end": "208420"
  },
  {
    "text": "operations, like addition\nand subtraction or shift. And you would be\nable to see that",
    "start": "208420",
    "end": "213490"
  },
  {
    "text": "from looking at the assembly. Bugs can also arise\nonly at a low level.",
    "start": "213490",
    "end": "218980"
  },
  {
    "text": "For example, there may be a\nbug in the program that only creates unexpected behavior when\nyou optimize the code at 03.",
    "start": "218980",
    "end": "228790"
  },
  {
    "text": "So that means, when you're\ndebugging and with that OG or -01, you wouldn't see\nany unusual behaviors.",
    "start": "228790",
    "end": "234610"
  },
  {
    "text": "But when you crank up\nthe optimization level, suddenly, things\nstart to fall apart.",
    "start": "234610",
    "end": "239860"
  },
  {
    "text": "Because the C code\nitself didn't change, it can be hard to\nspot those bugs. Looking at the assembly can\nhelp out in that regard.",
    "start": "239860",
    "end": "247799"
  },
  {
    "text": "And when worse comes\nto worse, if you really want to make your\ncode fast, it is possible to modify the\nassembly code by hand.",
    "start": "247800",
    "end": "255665"
  },
  {
    "text": "One of my favorite uses of\nlooking at the assembly, though, is actually\nreverse engineering. If you can read the\nassembly for some code,",
    "start": "255665",
    "end": "263620"
  },
  {
    "text": "you can actually decipher\nwhat that program does, even when you only have access\nto the binary of that program,",
    "start": "263620",
    "end": "270569"
  },
  {
    "text": "which is kind of a cool thing. It takes some practice to\nread assembly at that level.",
    "start": "270570",
    "end": "276180"
  },
  {
    "text": "One trick that some of us in\nProfessor Leiserson's research group have used\nin the past to say",
    "start": "276180",
    "end": "283348"
  },
  {
    "text": "figure out what Intel's\nMath Kernel Library is doing to multiply matrices. ",
    "start": "283348",
    "end": "289600"
  },
  {
    "text": "Now, as I mentioned before,\nat the end of last lecture, you saw some computer\narchitecture.",
    "start": "289600",
    "end": "295110"
  },
  {
    "text": "And you saw the basics\nof x86-64 assembly, including all the stuff,\nlike the instructions,",
    "start": "295110",
    "end": "302280"
  },
  {
    "text": "the registers, the various data\ntypes, memory addressing modes, the RFLAGS registered with\nthose condition codes,",
    "start": "302280",
    "end": "309792"
  },
  {
    "text": "and that sort of thing. And today, we want to talk about\nhow C code gets implemented in that assembly language.",
    "start": "309792",
    "end": "317070"
  },
  {
    "text": "OK, well, if we consider\nhow C code becomes assembly and what that process\nactually looks like,",
    "start": "317070",
    "end": "324580"
  },
  {
    "text": "we know that there is\na compiler involved. And the compiler is a\npretty sophisticated piece of software.",
    "start": "324580",
    "end": "329757"
  },
  {
    "text": "And, frankly, the\ncompiler has a lot of work to do in order to translate\na C program into assembly.",
    "start": "329757",
    "end": "336300"
  },
  {
    "text": "For example, it has to choose\nwhat assembly instructions are going to be used to\nimplement those C operations.",
    "start": "336300",
    "end": "342509"
  },
  {
    "text": "It has to implement C\nconditionals and loops-- those if, then, elses and\nthose for and why loops--",
    "start": "342510",
    "end": "348810"
  },
  {
    "text": "into jumps and branches. It has to choose registers\nand memory locations to store all of the\ndata in the program.",
    "start": "348810",
    "end": "357240"
  },
  {
    "text": "It may have to move data among\nthe registers and the memory locations in order to satisfy\nvarious data dependencies.",
    "start": "357240",
    "end": "363540"
  },
  {
    "text": "It has to coordinate all\nthe function calls that happen when subroutine A calls\nB and calls C, and then returns,",
    "start": "363540",
    "end": "369540"
  },
  {
    "text": "and so on and so forth. And on top of that,\nthese days, we expect our compiler\nto try really",
    "start": "369540",
    "end": "375360"
  },
  {
    "text": "hard to make that code fast. So that's a lot of work\nthat the compiler has to do.",
    "start": "375360",
    "end": "380560"
  },
  {
    "text": "And as a result,\nif we take a look at the assembly for any\narbitrary piece of C code,",
    "start": "380560",
    "end": "386550"
  },
  {
    "text": "the mapping from that\nC code to the assembly is not exactly\nobvious, which makes",
    "start": "386550",
    "end": "394950"
  },
  {
    "text": "it hard to execute this\nparticular lecture and hard to, in general, read the binary or\nthe assembly for some program",
    "start": "394950",
    "end": "403800"
  },
  {
    "text": "and figure out what's\nreally going on. So what we're going to do today\nto understand this translation",
    "start": "403800",
    "end": "409560"
  },
  {
    "text": "process is we're going\nto take a look at how that compiler actually\nreasons about translating",
    "start": "409560",
    "end": "416490"
  },
  {
    "text": "C code into assembly. Now this is not\na compiler class. 6172 is not a class you\ntake if you want to learn",
    "start": "416490",
    "end": "423659"
  },
  {
    "text": "how to build a compiler. And you're not going to\nneed to know everything about a compiler to\nfollow today's lecture.",
    "start": "423660",
    "end": "431400"
  },
  {
    "text": "But what we will see is\njust a little bit about how the compiler\nunderstands a program",
    "start": "431400",
    "end": "437970"
  },
  {
    "text": "and, later on, how the compiler\ncan translate that program into assembly code.",
    "start": "437970",
    "end": "444870"
  },
  {
    "text": "Now when a compiler\ncompiles a program, it does so through a\nsequence of stages, which",
    "start": "444870",
    "end": "450240"
  },
  {
    "text": "are illustrated on this slide. Starting from the C code, it\nfirst pre-processes that code,",
    "start": "450240",
    "end": "455430"
  },
  {
    "text": "dealing with all the macros. And that produces a\npre-process source.",
    "start": "455430",
    "end": "461310"
  },
  {
    "text": "Then the compiler will\ntranslate that source code into an intermediate\nrepresentation. For the client compiler\nthat you're using,",
    "start": "461310",
    "end": "468000"
  },
  {
    "text": "that intermediate representation\nis called LLVM IR. LLVM being the name of\nthe underlying compiler,",
    "start": "468000",
    "end": "473760"
  },
  {
    "text": "and IR being the creative\nname for the intermediate representation.",
    "start": "473760",
    "end": "480180"
  },
  {
    "text": "That LLVM IR is really a\nsort of pseudo-assembly. It's kind of like\nassembly, but as we'll see,",
    "start": "480180",
    "end": "488129"
  },
  {
    "text": "it's actually a lot simpler\nthan x86-64 assembly. And that's why we'll use it\nto understand this translation",
    "start": "488130",
    "end": "495000"
  },
  {
    "text": "process. Now it turns out\nthat the compiler does a whole lot of work on that\nintermediate representation.",
    "start": "495000",
    "end": "502090"
  },
  {
    "text": "We're not going to\nworry about that today. We'll just skip to the\nend of this pipeline when the compiler translates\nLLVM IR into assembly code.",
    "start": "502090",
    "end": "512950"
  },
  {
    "text": "Now the nice thing about\ntaking a look at the LLVM IR is that If you're\ncurious, you can actually follow along with the compiler.",
    "start": "512950",
    "end": "519309"
  },
  {
    "text": "It is possible to ask\nclang to compile your code and give you the LLVM IR\nrather than the assembly.",
    "start": "519309",
    "end": "526629"
  },
  {
    "text": "And the flags to do that\nare somewhat familiar. Rather than passing the dash s\nflag, which, hopefully, you've",
    "start": "526630",
    "end": "532810"
  },
  {
    "text": "already seen, that will\ntranslate C code directly into assembly. If you pass dash\ns dash omit LLVM,",
    "start": "532810",
    "end": "539660"
  },
  {
    "text": "that will produce the LLVM IR.  You can also ask clang to\ntranslate LLVM IR itself",
    "start": "539660",
    "end": "546990"
  },
  {
    "text": "directly into assembly\ncode, and that process is pretty straightforward. You just use the dash\nS flag once again.",
    "start": "546990",
    "end": "553529"
  },
  {
    "text": " So this is the outline\nof today's lecture. First, we're going to start\nwith a simple primer on LLVM IR.",
    "start": "553530",
    "end": "561370"
  },
  {
    "start": "555000",
    "end": "625000"
  },
  {
    "text": "I know that LLVM IR sounds\nlike another language. Oh, gosh, we have to\nlearn another language.",
    "start": "561370",
    "end": "566560"
  },
  {
    "text": "But don't worry. This primer, I would say, is\nsimpler than the x86-64 primer.",
    "start": "566560",
    "end": "572080"
  },
  {
    "text": "Based on the slides,\nfor x86-64, that primer was 20-some slides long.",
    "start": "572080",
    "end": "577630"
  },
  {
    "text": "This primer is six slides, so\nmaybe a little over a quarter.",
    "start": "577630",
    "end": "583660"
  },
  {
    "text": "Then we'll take a look at how\nthe various constructs in the C programming language get\ntranslated into LLVM IR,",
    "start": "583660",
    "end": "589780"
  },
  {
    "text": "including straight line code,\nC functions, conditionals-- in other words, if, then, else--",
    "start": "589780",
    "end": "595210"
  },
  {
    "text": "loops. And we'll conclude that section\nwith just a brief mention of LLVM IR attributes.",
    "start": "595210",
    "end": "600660"
  },
  {
    "text": "And finally, we'll take a\nlook at how LLVM IR gets translated into assembly.",
    "start": "600660",
    "end": "605680"
  },
  {
    "text": "And for that,\nwe'll have to focus on what's called the Linux\nx86-64 calling convention.",
    "start": "605680",
    "end": "612378"
  },
  {
    "text": "And we'll conclude with\na case study, where we see how this whole process\nworks on a very simple code",
    "start": "612378",
    "end": "618339"
  },
  {
    "text": "to compute Fibonacci numbers. Any questions so far? ",
    "start": "618340",
    "end": "624750"
  },
  {
    "text": "All right, let's get started. Brief primer on LLVM IR--",
    "start": "624750",
    "end": "630010"
  },
  {
    "start": "625000",
    "end": "685000"
  },
  {
    "text": "so I've shown this in smaller\nfont on some previous slides, but here is a snippet\nof LLVM IR code.",
    "start": "630010",
    "end": "636430"
  },
  {
    "text": "In particular, this\nis one function within an LLVM IR file. And just from\nlooking at this code,",
    "start": "636430",
    "end": "643430"
  },
  {
    "text": "we can see a couple of the\nbasic components of LLVM IR. ",
    "start": "643430",
    "end": "648730"
  },
  {
    "text": "In LLVM IR, we have functions. That's how code is organized\ninto these chunks--",
    "start": "648730",
    "end": "654220"
  },
  {
    "text": "chunks called functions. And within each function, the\noperations of the function",
    "start": "654220",
    "end": "659740"
  },
  {
    "text": "are encoded within instructions. And each instruction shows\nup, at least on this slide,",
    "start": "659740",
    "end": "665320"
  },
  {
    "text": "on a separate line. Those functions operate on what\nare called LLVM IR registers.",
    "start": "665320",
    "end": "671440"
  },
  {
    "text": "These are kind of\nlike the variables. And each of those variables\nhas some associated type.",
    "start": "671440",
    "end": "677050"
  },
  {
    "text": "So the types are actually\nexplicit within the IR. And we'll take a look\nat the types in more",
    "start": "677050",
    "end": "682959"
  },
  {
    "text": "detail in a couple of slides.  So based on that\nhigh-level overview,",
    "start": "682960",
    "end": "691459"
  },
  {
    "start": "685000",
    "end": "789000"
  },
  {
    "text": "we can do a little bit of\na comparison between LLVM IR and assembly language. The first thing that we\nsee is that it looks kind",
    "start": "691460",
    "end": "698250"
  },
  {
    "text": "of similar to assembly, right? It still has a simple\ninstruction format.",
    "start": "698250",
    "end": "703620"
  },
  {
    "text": "There is some destination\noperand, which we are calling a register. And then there is an equal sign\nand then an op code, be it add,",
    "start": "703620",
    "end": "712110"
  },
  {
    "text": "or call, or what\nhave you, and then some list of source operations. That's roughly what each\ninstruction looks like.",
    "start": "712110",
    "end": "719340"
  },
  {
    "text": "We can also see that the\nLLVM IR code, it'll turn out.",
    "start": "719340",
    "end": "724680"
  },
  {
    "text": "The LLVM IR code adopts\na similar structure to the assembly code itself.",
    "start": "724680",
    "end": "730800"
  },
  {
    "text": "And control flow, once\nagain, is implemented using conditional branches, as\nwell as unconditional branches.",
    "start": "730800",
    "end": "737662"
  },
  {
    "text": "But one thing that we'll\nnotice is that LLVM IR is simpler than assembly. It has a much smaller\ninstruction set.",
    "start": "737662",
    "end": "744270"
  },
  {
    "text": "And unlike assembly\nlanguage, LLVM IR supports an infinite\nnumber of registers. If you can name it,\nit's a register.",
    "start": "744270",
    "end": "750960"
  },
  {
    "text": "So in that sense, LLVM's\nnotion of registers is a lot closer to C's\nnotion of variables.",
    "start": "750960",
    "end": "757990"
  },
  {
    "text": "And when you read LLVM IR,\nand you see those registers, you should just think\nabout C variables.",
    "start": "757990",
    "end": "764910"
  },
  {
    "text": "There's no implicit RFLAGS\nregister, and there no implicit condition codes going on. Everything is pretty explicit\nin terms of the LLVM.",
    "start": "764910",
    "end": "773670"
  },
  {
    "text": "There's no explicit stack\npointer or frame pointer. There's a type system that's\nexplicit in the IR itself.",
    "start": "773670",
    "end": "781050"
  },
  {
    "text": "And it's C like in\nnature, and there are C-like functions for\norganizing the code overall.",
    "start": "781050",
    "end": "788967"
  },
  {
    "text": "So let's take a look at\neach of these components, starting with LLVM IR registers. This is basically LLVM's\nname for a variable.",
    "start": "788968",
    "end": "796080"
  },
  {
    "start": "789000",
    "end": "895000"
  },
  {
    "text": "All of the data in LLVM IR\nis stored in these variables, which are called registers. And the syntax is a percent\nsymbol followed by a name.",
    "start": "796080",
    "end": "803779"
  },
  {
    "text": "So %0, %1, %2,\nthat sort of thing. And as I mentioned\nbefore, LLVM IR registers",
    "start": "803780",
    "end": "810480"
  },
  {
    "text": "are a lot like c variables. LLVM supports an infinite\nnumber of these things, and each distinct register is\njust distinguished by its name.",
    "start": "810480",
    "end": "819040"
  },
  {
    "text": "So %0 is different from %1,\nbecause they have different names. Register names are also local\nto each LLVM IR function.",
    "start": "819040",
    "end": "828310"
  },
  {
    "text": "And in this regard, they're\nalso similar to C variables. If you wrote a C program\nwith two functions, A and B,",
    "start": "828310",
    "end": "835260"
  },
  {
    "text": "and each function had\na local variable apple, those are two different apples.",
    "start": "835260",
    "end": "840300"
  },
  {
    "text": "The apple in A is not the\nsame thing as the apple in B. Similarly, if you had two\ndifferent LLVM IR functions,",
    "start": "840300",
    "end": "847139"
  },
  {
    "text": "and they both described\nsome register five, those are two\ndifferent variables.",
    "start": "847140",
    "end": "854568"
  },
  {
    "text": "They're not\nautomatically aliased.  So here's an example\nof an LLVM IR snippet.",
    "start": "854568",
    "end": "860639"
  },
  {
    "text": "And what we've done\nhere is just highlighted all of the registers. Some of them are being\nassigned, because they're on the left-hand side\nof an equal symbol.",
    "start": "860640",
    "end": "867779"
  },
  {
    "text": "And some of them are being used\nas arguments when they show up on the right-hand side. There is one catch, which\nwe'll see later on, namely",
    "start": "867780",
    "end": "876240"
  },
  {
    "text": "that the syntax\nfor LLVM registers ends up being hijacked\nwhen LLVM needs to refer",
    "start": "876240",
    "end": "882960"
  },
  {
    "text": "to different basic blocks. We haven't defined\nbasic blocks yet. We'll see what that's all about\nin just a couple of slides.",
    "start": "882960",
    "end": "889774"
  },
  {
    "text": "Everyone good so far? ",
    "start": "889775",
    "end": "896990"
  },
  {
    "start": "895000",
    "end": "1026000"
  },
  {
    "text": "So LLVM IR code is\norganized into instructions,",
    "start": "896990",
    "end": "902060"
  },
  {
    "text": "and the syntax for\nthese instructions is pretty straightforward. We have a register name\non the left-hand side,",
    "start": "902060",
    "end": "909958"
  },
  {
    "text": "then an equal symbol,\nand then and op code, followed by an operand list. For example, the top\nhighlight instruction",
    "start": "909958",
    "end": "918440"
  },
  {
    "text": "has register six equal\nto add of sum arguments.",
    "start": "918440",
    "end": "924100"
  },
  {
    "text": "And we'll see a little bit more\nabout those arguments later. That's the syntax for when\nan instruction actually",
    "start": "924100",
    "end": "930440"
  },
  {
    "text": "returns some value. So addition returns the\nsum of the two operands.",
    "start": "930440",
    "end": "935840"
  },
  {
    "text": "Other instructions don't\nreturn a value, per se, not a value that you'd\nstore in a local register.",
    "start": "935840",
    "end": "942230"
  },
  {
    "text": "And so the syntax for\nthose instructions is just an op code followed\nby a list of operands.",
    "start": "942230",
    "end": "948080"
  },
  {
    "text": "Ironically, the\nreturn instruction that you'd find at\nthe end of a function",
    "start": "948080",
    "end": "954649"
  },
  {
    "text": "doesn't assign a\nparticular register value. And of course, the operands\ncan be either registers,",
    "start": "954650",
    "end": "961990"
  },
  {
    "text": "or constants, or, as\nwe'll see later on, they can identify basic\nblocks within the function.",
    "start": "961990",
    "end": "967720"
  },
  {
    "text": " The LLVM IR instruction set\nis smaller than that of x86.",
    "start": "967720",
    "end": "974980"
  },
  {
    "text": "x86 contains hundreds\nof instructions when you start counting up\nall the vector instructions. And LLVM IR is far more\nmodest in that regard.",
    "start": "974980",
    "end": "982800"
  },
  {
    "text": "There's some instructions\nfor data movements, including stack allocation,\nreading memory, writing memory,",
    "start": "982800",
    "end": "990240"
  },
  {
    "text": "converting between types.  Yeah, that's pretty much it.",
    "start": "990240",
    "end": "995920"
  },
  {
    "text": "There are some instructions\nfor doing arithmetic or logic, including integer arithmetic,\nfloating-point arithmetic,",
    "start": "995920",
    "end": "1002300"
  },
  {
    "text": "Boolean logic, binary logic,\nor address calculations. And then there are a\ncouple of instructions",
    "start": "1002300",
    "end": "1008779"
  },
  {
    "text": "to do control flow. There are unconditional\nbranches or jumps, conditional branches\nor jumps, subroutines--",
    "start": "1008780",
    "end": "1016010"
  },
  {
    "text": "that's call or return-- and then there's this\nmagical phi function, which we'll see more of\nlater on in these slides.",
    "start": "1016010",
    "end": "1026689"
  },
  {
    "start": "1026000",
    "end": "1115000"
  },
  {
    "text": "Finally, as I mentioned\nbefore, everything in LLVM IR is explicitly typed. It's a strongly-typed\nlanguage in that sense.",
    "start": "1026690",
    "end": "1033630"
  },
  {
    "text": "And the type system looks\nsomething like this. For integers, whenever there's\na variable of an integer type,",
    "start": "1033630",
    "end": "1039740"
  },
  {
    "text": "you'll see an i\nfollowed by some number. And that number defines the\nnumber of bits in that integer.",
    "start": "1039740",
    "end": "1046260"
  },
  {
    "text": "So if you see a\nvariable of type i64, that means it's\na 64-bit integer.",
    "start": "1046260",
    "end": "1053029"
  },
  {
    "text": "If you see a\nvariable of type i1, that would be a 1-bit\ninteger or, in other words,",
    "start": "1053030",
    "end": "1059160"
  },
  {
    "text": "a Boolean value. There are also\nfloating-point types, such as double and float.",
    "start": "1059160",
    "end": "1065030"
  },
  {
    "text": "There are pointer types,\nwhen you follow an integer or floating-point type with\na star, much like in C,",
    "start": "1065030",
    "end": "1071960"
  },
  {
    "text": "you can have a raise. And that uses a square\nbracket notation, where, within the\nsquare brackets,",
    "start": "1071960",
    "end": "1078080"
  },
  {
    "text": "you'll have some number and then\ntimes and then some other type. Maybe it's a primitive\ntype, like an integer",
    "start": "1078080",
    "end": "1084080"
  },
  {
    "text": "or a floating-point. Maybe it's something\nmore complicated. You can have structs\nwith an LLVM IR.",
    "start": "1084080",
    "end": "1090080"
  },
  {
    "text": "And that uses squiggly\nbrackets with types enumerated on the inside.",
    "start": "1090080",
    "end": "1095300"
  },
  {
    "text": "You can have vector types,\nwhich uses angle brackets and otherwise adopts a similar\nsyntax to the array type.",
    "start": "1095300",
    "end": "1103410"
  },
  {
    "text": "Finally, you can\noccasionally see a variable, which looks like an\nordinary register,",
    "start": "1103410",
    "end": "1108560"
  },
  {
    "text": "except that its type is label. And that actually\nrefers to a basic block. ",
    "start": "1108560",
    "end": "1115670"
  },
  {
    "start": "1115000",
    "end": "1320000"
  },
  {
    "text": "Those are the basic\ncomponents of LLVM IR. Any questions so far? ",
    "start": "1115670",
    "end": "1122430"
  },
  {
    "text": "Everything clear? Everything unclear?  STUDENT: What's the\nbasic [INAUDIBLE]??",
    "start": "1122430",
    "end": "1130360"
  },
  {
    "text": "TAO SCHARDL: That\nshould be unclear, and we'll talk about it. Yeah? STUDENT: Is the\nvector notation there",
    "start": "1130360",
    "end": "1136540"
  },
  {
    "text": "for the vectorization that's\ndone, like the special register is used?",
    "start": "1136540",
    "end": "1142120"
  },
  {
    "text": "TAO SCHARDL: Is the vector\nnotation used for the vector registers? In a sense, yes.",
    "start": "1142120",
    "end": "1148360"
  },
  {
    "text": "The vector operations\nwith an LLVM don't look like\nSEC or AVX, per se.",
    "start": "1148360",
    "end": "1154660"
  },
  {
    "text": "They look more like\nordinary operations, except those ordinary operations\nwork on a vector type.",
    "start": "1154660",
    "end": "1160690"
  },
  {
    "text": "So that's how the vector\noperations show up in LLVM IR. That make some sense?",
    "start": "1160690",
    "end": "1166240"
  },
  {
    "text": "Cool. Anything else? ",
    "start": "1166240",
    "end": "1172610"
  },
  {
    "text": "OK, that's the whole primer. That's pretty much\nall of the language that you're going\nto need to know,",
    "start": "1172610",
    "end": "1177640"
  },
  {
    "text": "at least for this slide deck. We'll cover some of the\ndetails as we go along.",
    "start": "1177640",
    "end": "1182690"
  },
  {
    "text": "Let's start translating\nC code into LLVM IR. Is that good?",
    "start": "1182690",
    "end": "1188060"
  },
  {
    "text": "All right, let's start with\npretty much the simplest thing we can-- straight line C code.",
    "start": "1188060",
    "end": "1193490"
  },
  {
    "text": "What do I mean by\nstraight line C code? I mean that this\nis a blob of C code that contains no\nconditionals or loops.",
    "start": "1193490",
    "end": "1200420"
  },
  {
    "text": "So it's just a whole\nsequence of operations. And that sequence of\noperations in C code",
    "start": "1200420",
    "end": "1207410"
  },
  {
    "text": "turns into a sequence of\noperations in LLVM IR. So in this example here,\nwe have foo of n minus 1",
    "start": "1207410",
    "end": "1215840"
  },
  {
    "text": "plus bar of n minus 2. That is a sequence\nof operations. And it turns into the\nLLVM IR on the right.",
    "start": "1215840",
    "end": "1223283"
  },
  {
    "text": "We can see how that happens. There are a couple\nrules of thumb when reading\nstraight line C code and interpreting it in the IR.",
    "start": "1223283",
    "end": "1230150"
  },
  {
    "text": "Arguments to any\noperation are evaluated before the operation itself.",
    "start": "1230150",
    "end": "1235527"
  },
  {
    "text": "So what do I mean by that? Well, in this case, we\nneed to evaluate n minus 1",
    "start": "1235527",
    "end": "1240750"
  },
  {
    "text": "before we pass the\nresults to foo. And what we see\nin the LLVM IR is",
    "start": "1240750",
    "end": "1246500"
  },
  {
    "text": "that we have an\naddition operation that computes n minus 1. And then the result of that--",
    "start": "1246500",
    "end": "1251750"
  },
  {
    "text": "stored into register 4--\ngets passed to the call instruction on the\nnext line, which calls out to function foo.",
    "start": "1251750",
    "end": "1259226"
  },
  {
    "text": "Sound good? Similarly, we need\nto evaluate n minus 2",
    "start": "1259226",
    "end": "1265510"
  },
  {
    "text": "before passing its results\nto the function bar. And we see that\nsequence of instructions",
    "start": "1265510",
    "end": "1271539"
  },
  {
    "text": "showing up next in the LLVM IR. And now, we actually need\nthe return value-- oh, yeah? Question?",
    "start": "1271540",
    "end": "1276800"
  },
  {
    "text": "STUDENT: What is NSW? TAO SCHARDL: NSW? ",
    "start": "1276800",
    "end": "1282093"
  },
  {
    "text": "Essentially, that\nis an attribute, which we'll talk about later. These are things that decorate\nthe instructions, as well",
    "start": "1282093",
    "end": "1288730"
  },
  {
    "text": "as the types, within\nLLVM IR, basically, as the compiler\nfigures stuff out. So it helps the compiler along\nwith analysis and optimization.",
    "start": "1288730",
    "end": "1298648"
  },
  {
    "text": "Good? So for the last\noperation here, we had to evaluate both foo and\nbar and get their return values",
    "start": "1298648",
    "end": "1308110"
  },
  {
    "text": "before we could\nadd them together. And so the very last\noperation in this sequence is the addition.",
    "start": "1308110",
    "end": "1314230"
  },
  {
    "text": "That just takes us those return\nvalues and computes their sum. ",
    "start": "1314230",
    "end": "1321630"
  },
  {
    "start": "1320000",
    "end": "1447000"
  },
  {
    "text": "Now all of that used primitive\ntypes, in particular, integers. But it's possible that your\ncode uses aggregate types.",
    "start": "1321630",
    "end": "1329399"
  },
  {
    "text": "By aggregating types, I\nmean, arrays or struts, that sort of thing. And aggregate types are harder\nto store within registers,",
    "start": "1329400",
    "end": "1337260"
  },
  {
    "text": "typically speaking. And so they're typically\nstored within memory.",
    "start": "1337260",
    "end": "1342630"
  },
  {
    "text": "As a result, if you\nwant to access something within an aggregate type, if you\nwant to read some elements out",
    "start": "1342630",
    "end": "1348090"
  },
  {
    "text": "of an array, that involves\nperforming a memory access or, more precisely, computing\nsome address into memory,",
    "start": "1348090",
    "end": "1355680"
  },
  {
    "text": "and then loading or\nstoring that address. So here, for example, we have\nan array A of seven integers.",
    "start": "1355680",
    "end": "1363460"
  },
  {
    "text": "And we're going\nto access A sub x. In LLVM IR, that turns\ninto two instructions--",
    "start": "1363460",
    "end": "1369150"
  },
  {
    "text": "this getelementptr\nfollowed by a load. And in the getelementptr\ncase, this computes an address",
    "start": "1369150",
    "end": "1377700"
  },
  {
    "text": "into memory and\nstores the result of that address into a register,\nin this case, register 5.",
    "start": "1377700",
    "end": "1383520"
  },
  {
    "text": "The next instruction,\nthe load, takes the address stored in\nregister 5 and simply loads",
    "start": "1383520",
    "end": "1390300"
  },
  {
    "text": "that particular memory\naddress, storing the result into another\nregister, in this case, 6.",
    "start": "1390300",
    "end": "1396608"
  },
  {
    "text": "Pretty simple.  When reading the\ngetelementptr instruction,",
    "start": "1396608",
    "end": "1403340"
  },
  {
    "text": "the basic syntax\ninvolves a pointer into memory followed by\na sequence of indices.",
    "start": "1403340",
    "end": "1409740"
  },
  {
    "text": "And all that\ngetelementptr really does is it computes an\naddress by taking that pointer",
    "start": "1409740",
    "end": "1415530"
  },
  {
    "text": "and then adding on that\nsequence of indices. So in this case, we have a\ngetelementptr instruction,",
    "start": "1415530",
    "end": "1422070"
  },
  {
    "text": "which takes the\naddress in register 2, and then adds onto it--",
    "start": "1422070",
    "end": "1428490"
  },
  {
    "text": "yeah, that's a\npointer into memory-- and then it adds\nonto it to indices. One is the literal\nvalue 0, and the other",
    "start": "1428490",
    "end": "1435360"
  },
  {
    "text": "is the value stored\nin register 4. So that just\ncomputes the address, starting at 2 plus 0 plus\nwhatever was in register 4.",
    "start": "1435360",
    "end": "1444419"
  },
  {
    "text": " That's all for\nstraight line code.",
    "start": "1444420",
    "end": "1450279"
  },
  {
    "start": "1447000",
    "end": "1607000"
  },
  {
    "text": "Good so far?  feel free to interrupt\nif you have questions.",
    "start": "1450280",
    "end": "1457260"
  },
  {
    "text": "Cool. Functions-- let's talk\nabout C functions. So when there's a\nfunction in your C code,",
    "start": "1457260",
    "end": "1464970"
  },
  {
    "text": "generally speaking, you'll have\na function within the LLVM code as well.",
    "start": "1464970",
    "end": "1470708"
  },
  {
    "text": "And similarly, when there's a\nreturn statement in the C code, you'll end up with a return\nstatement in the LLVM IR.",
    "start": "1470708",
    "end": "1476520"
  },
  {
    "text": "So here, we have\njust the bare bones C code for this fib routine.",
    "start": "1476520",
    "end": "1482160"
  },
  {
    "text": "That corresponds to this\nfib function within LLVM IR.",
    "start": "1482160",
    "end": "1489720"
  },
  {
    "text": "And the function\ndeclaration itself looks pretty similar to what\nyou would get in ordinary C.",
    "start": "1489720",
    "end": "1499820"
  },
  {
    "text": "The return statement\nis also similar. It may take an argument,\nif you're returning",
    "start": "1499820",
    "end": "1505490"
  },
  {
    "text": "some value to the caller. In this case, for\nthe fib routine, we're going to return\na 64-bit integer.",
    "start": "1505490",
    "end": "1511670"
  },
  {
    "text": "And so we see that this\nreturn statement returns the 64-bit integer stored in\nregister 0, a lot like in C.",
    "start": "1511670",
    "end": "1524460"
  },
  {
    "text": "Functions can have parameters. And when you have a C function\nwith a list of parameters, basically, in LLVM\nIR, you're going",
    "start": "1524460",
    "end": "1530570"
  },
  {
    "text": "to end up with a\nsimilar looking function with the exact same list\nof parameters translated",
    "start": "1530570",
    "end": "1536820"
  },
  {
    "text": "into LLVM IR. So here, we have this C code\nfor the mm base routine.",
    "start": "1536820",
    "end": "1544150"
  },
  {
    "text": "And we have the\ncorresponding LLVM IR for an mm-based function. And what we see is we\nhave a pointer to a double",
    "start": "1544150",
    "end": "1552270"
  },
  {
    "text": "as the first parameter,\nfollowed by a 32-bit integer, followed by another\npointer to a double,",
    "start": "1552270",
    "end": "1558210"
  },
  {
    "text": "followed by another\n32-bit integer, following another\npointer to a double, and another 33-bit integer,\nand another 32-bit integer.",
    "start": "1558210",
    "end": "1568390"
  },
  {
    "text": "One implicit thing with an\nLLVM IR if you're looking at a function declaration\nor definition,",
    "start": "1568390",
    "end": "1573520"
  },
  {
    "text": "the parameters are\nautomatically named %0, %1, %2, so on and so forth.",
    "start": "1573520",
    "end": "1579710"
  },
  {
    "text": "There's one unfortunate\nthing about LLVM IR. The registers are a\nlot like C functions, but unfortunately,\nthat implies that when",
    "start": "1579710",
    "end": "1586450"
  },
  {
    "text": "you're reading LLVM IR,\nit's a lot like reading the code from your teammate, who\nalways insists on naming things",
    "start": "1586450",
    "end": "1594639"
  },
  {
    "text": "with nondescript,\nsingle-letter variable names. Also, that teammate doesn't\ncomment his code, or her code,",
    "start": "1594640",
    "end": "1600407"
  },
  {
    "text": "or their code. ",
    "start": "1600407",
    "end": "1607990"
  },
  {
    "start": "1607000",
    "end": "1960000"
  },
  {
    "text": "OK, so basic blocks-- when we look at the\ncode within a function, that code gets\npartitioned into chunks,",
    "start": "1607990",
    "end": "1616270"
  },
  {
    "text": "which are called basic blocks. A basic block has\na property that's a sequence of instructions.",
    "start": "1616270",
    "end": "1622299"
  },
  {
    "text": "In other words, it's a\nblob a straight line code, where control can only enter\nfrom the first instruction",
    "start": "1622300",
    "end": "1629230"
  },
  {
    "text": "in that block. And it can only leave from the\nlast instruction in that block.",
    "start": "1629230",
    "end": "1635750"
  },
  {
    "text": "So here we have the C code\nfor this routine fib.c. We're going to see a lot of\nthis routine fib.c, by the way.",
    "start": "1635750",
    "end": "1642640"
  },
  {
    "text": "And we have the\ncorresponding LLVM IR. And what we have in the C\ncode, what the C code is",
    "start": "1642640",
    "end": "1648130"
  },
  {
    "text": "telling us is that\nif n is less than 2, you want to do one thing. Otherwise, you want to do\nsome complicated computation",
    "start": "1648130",
    "end": "1656230"
  },
  {
    "text": "and then return that result. And if we think about that. We've got this branch\nin our control flow.",
    "start": "1656230",
    "end": "1662740"
  },
  {
    "text": "And what we'll end up with\nare three different blocks within the LLVM IR.",
    "start": "1662740",
    "end": "1669330"
  },
  {
    "text": "So we end up with\none block, which does the computation\nis n less than 2.",
    "start": "1669330",
    "end": "1676110"
  },
  {
    "text": "And then we end up with\nanother block that says, well, in one case, just go ahead and\nreturn something, in this case,",
    "start": "1676110",
    "end": "1683770"
  },
  {
    "text": "the input to the function. In the other case, do some\ncomplicated calculations,",
    "start": "1683770",
    "end": "1689560"
  },
  {
    "text": "some straight line code,\nand then return that result.",
    "start": "1689560",
    "end": "1697170"
  },
  {
    "text": "Now when we partition\nthe code of a function",
    "start": "1697170",
    "end": "1702240"
  },
  {
    "text": "into these basic\nblocks, we actually have connections\nbetween the basic blocks based on how control can move\nbetween the basic blocks.",
    "start": "1702240",
    "end": "1711730"
  },
  {
    "text": "These control flow instructions,\nin particular, the branch instructions, as we'll\nsee, induce edges",
    "start": "1711730",
    "end": "1717970"
  },
  {
    "text": "among these basic blocks. Whenever there's a branch\ninstruction that can specify,",
    "start": "1717970",
    "end": "1724000"
  },
  {
    "text": "that control can\nleave this basic block and go to that\nother basic block,",
    "start": "1724000",
    "end": "1729100"
  },
  {
    "text": "or that other basic block,\nor maybe one or the other, depending on how the result\nof some computation unfolded.",
    "start": "1729100",
    "end": "1737769"
  },
  {
    "text": "And so for the fib function\nthat we saw before, we had those three basic blocks. And based on whether or\nnot n was than 2, either",
    "start": "1737770",
    "end": "1745510"
  },
  {
    "text": "we would execute the\nsimple return statement, or we would execute the\nblob of straight line code shown on the left.",
    "start": "1745510",
    "end": "1751540"
  },
  {
    "text": " So those are basic\nblocks and functions.",
    "start": "1751540",
    "end": "1758019"
  },
  {
    "text": "Everyone still good so far? Any questions?",
    "start": "1758020",
    "end": "1763910"
  },
  {
    "text": "Clear as mud? ",
    "start": "1763910",
    "end": "1770360"
  },
  {
    "text": "Let's talk about conditionals. You've already seen one\nof these conditionals. That's given rise to these basic\nblocks and these control flow",
    "start": "1770360",
    "end": "1776559"
  },
  {
    "text": "edges. So let's tease that apart\na little bit further. When we have a C\nconditional-- in other words,",
    "start": "1776560",
    "end": "1783309"
  },
  {
    "text": "an if-then-else statement\nor a switch statement, for that matter-- that gets translated\ninto a conditional branch",
    "start": "1783310",
    "end": "1791740"
  },
  {
    "text": "instruction, or BR, in the\nLLVM IR representation. So what we saw before is that\nwe have this if n less than 2",
    "start": "1791740",
    "end": "1801850"
  },
  {
    "text": "and this basic block\nwith two outgoing edges. If we take a really close look\nat that first basic block,",
    "start": "1801850",
    "end": "1809170"
  },
  {
    "text": "we can tease it apart and\nsee what each operation does.",
    "start": "1809170",
    "end": "1814450"
  },
  {
    "text": "So first, in order to do\nthis conditional operation, we need to compute whether\nor not n is less than 2.",
    "start": "1814450",
    "end": "1820520"
  },
  {
    "text": "We need to do a\ncomparison between n and the literal value 2. That comparison operation\nturns into an icmp instruction",
    "start": "1820520",
    "end": "1829270"
  },
  {
    "text": "within the LLVM IR, an integer\ncomparison in the LLVM IR.",
    "start": "1829270",
    "end": "1834730"
  },
  {
    "text": "The result of that\ncomparison then gets passed to a conditional\nbranch as one of its arguments,",
    "start": "1834730",
    "end": "1840610"
  },
  {
    "text": "and the conditional branch\nspecifies a couple of things beyond that one argument.",
    "start": "1840610",
    "end": "1847809"
  },
  {
    "text": "In particular, that conditional\nbranch takes out 1-bit integer-- that Boolean result--",
    "start": "1847810",
    "end": "1853390"
  },
  {
    "text": "as well as labels of two\ndifferent basic blocks. So that Boolean value\nis called the predicate.",
    "start": "1853390",
    "end": "1861522"
  },
  {
    "text": "And that's, in this case,\na result of that comparison from before. And then the two\nbasic blocks say",
    "start": "1861522",
    "end": "1866670"
  },
  {
    "text": "where to go if the\npredicate is true or where to go if the\npredicate is false.",
    "start": "1866670",
    "end": "1871990"
  },
  {
    "text": "The first label is the\ndestination when it's true, second label destination\nwhen it's false--",
    "start": "1871990",
    "end": "1877080"
  },
  {
    "text": "pretty straightforward.  And if we decide to map\nthis onto our control flow",
    "start": "1877080",
    "end": "1884299"
  },
  {
    "text": "graph, which we were\nlooking at before, we can identify the\ntwo branches coming out",
    "start": "1884300",
    "end": "1890210"
  },
  {
    "text": "of our first basic block\nas either the true branch or the false branch\nbased on whether or not",
    "start": "1890210",
    "end": "1896690"
  },
  {
    "text": "you follow that edge when\nthe predicate is true or you follow it when\nthe predicate is false.",
    "start": "1896690",
    "end": "1901880"
  },
  {
    "text": "Sound good? That should be straightforward. Let me know if it's not.",
    "start": "1901880",
    "end": "1907650"
  },
  {
    "text": "Let me know if it's confusing. ",
    "start": "1907650",
    "end": "1913620"
  },
  {
    "text": "Now it's also\npossible that you can have an unconditional\nbranch in LLVM IR.",
    "start": "1913620",
    "end": "1918840"
  },
  {
    "text": "You can just have a branch\ninstruction with one operand, and that one operand\nspecifies a basic block.",
    "start": "1918840",
    "end": "1925620"
  },
  {
    "text": "There's no predicate. There is no true or false. It's just the one basic block. And what that instruction\nsays is, when you get here,",
    "start": "1925620",
    "end": "1933900"
  },
  {
    "text": "now, go to that\nother basic block. This might seem kind\nof silly, right? Why wouldn't we just need to\njump to another basic block?",
    "start": "1933900",
    "end": "1942340"
  },
  {
    "text": "Why not just merge\nthis code with the code in the subsequent basic block?",
    "start": "1942340",
    "end": "1947362"
  },
  {
    "text": "Any thoughts?  STUDENT: For instance,\nin this case,",
    "start": "1947363",
    "end": "1952860"
  },
  {
    "text": "other things might jump in. TAO SCHARDL: Correct. Other things might go\nto that basic block.",
    "start": "1952860",
    "end": "1958080"
  },
  {
    "text": "And in general, when we\nlook at the structure that we get for any\nparticular conditional in C,",
    "start": "1958080",
    "end": "1965679"
  },
  {
    "start": "1960000",
    "end": "2091000"
  },
  {
    "text": "we end up with this\nsort of diamond shape. And in order to implement\nthat diamond shape, we need these\nunconditional branches.",
    "start": "1965680",
    "end": "1973150"
  },
  {
    "text": "So there's a good reason\nfor them to be around. And here, we just\nhave an example of a slightly more\ncomplicated conditional",
    "start": "1973150",
    "end": "1980799"
  },
  {
    "text": "that creates this diamond shape\nin our control flow graph. So lets tease this\npiece of code apart.",
    "start": "1980800",
    "end": "1988059"
  },
  {
    "text": "In the first block, we're going\nto evaluate if some predicate-- and in this case, our\npredicate is x bitwise and 1.",
    "start": "1988060",
    "end": "1995710"
  },
  {
    "text": "And what we see in\nthe first basic block is that we compute the\nbitwise and store that result,",
    "start": "1995710",
    "end": "2001350"
  },
  {
    "text": "do a comparison between that\nresult, and the value 1. That gives us a Boolean value,\nwhich is stored in register 3.",
    "start": "2001350",
    "end": "2010050"
  },
  {
    "text": "And we branch conditionally\non whether 3 is true or false.",
    "start": "2010050",
    "end": "2015190"
  },
  {
    "text": "In the case that it's true,\nwe'll branch to block 4. And in block 4, that contains\nthe code for the consequence,",
    "start": "2015190",
    "end": "2022680"
  },
  {
    "text": "the then clause of\nthe if, then, else. And in the call square,\nwe just call function foo.",
    "start": "2022680",
    "end": "2028110"
  },
  {
    "text": "And then we need to\nleave the conditional, so we'll just branch\nunconditionally.",
    "start": "2028110",
    "end": "2033830"
  },
  {
    "text": "The alternative, if x and\n1 is zero, if it's false,",
    "start": "2033830",
    "end": "2040640"
  },
  {
    "text": "then we will execute\nthe function bar, but then also need to\nleave the conditional.",
    "start": "2040640",
    "end": "2047450"
  },
  {
    "text": "And so we see in\nblock 5, following the false branch\nthat we call bar, then we'd just\nbranch to block 6.",
    "start": "2047450",
    "end": "2054408"
  },
  {
    "text": "And finally, in block\n6, we return the result. So we end up with this\ndiamond pattern whenever we",
    "start": "2054409",
    "end": "2060860"
  },
  {
    "text": "have a conditional, in general. We may delete\ncertain basic blocks if the conditional in the\ncode is particularly simple.",
    "start": "2060860",
    "end": "2068049"
  },
  {
    "text": "But in general, it's\ngoing to be this kind of diamond-looking thing. Everyone good so far?",
    "start": "2068050",
    "end": "2073840"
  },
  {
    "text": " One last C construct-- loops.",
    "start": "2073840",
    "end": "2079340"
  },
  {
    "text": "Unfortunately, this is the\nmost complicated C construct when it comes to the LLVM IR.",
    "start": "2079340",
    "end": "2084919"
  },
  {
    "text": "But things haven't\nbeen too bad so far. So yeah, let's walk into\nthis with some confidence.",
    "start": "2084920",
    "end": "2092138"
  },
  {
    "start": "2091000",
    "end": "2287000"
  },
  {
    "text": "So the simple part is\nthat what we will see",
    "start": "2092139",
    "end": "2097539"
  },
  {
    "text": "is the C code for\na loop translates into LLVM IR that, in\nthe control flow graph",
    "start": "2097540",
    "end": "2104270"
  },
  {
    "text": "representation, is a loop. So a loop in C is\nliterally a loop",
    "start": "2104270",
    "end": "2109590"
  },
  {
    "text": "in this graph representation,\nwhich is kind of nice. But to figure out what's really\ngoing on with these loops,",
    "start": "2109590",
    "end": "2117140"
  },
  {
    "text": "let's first tease apart\nthe components of a C loop. Because we have a couple\nof different pieces",
    "start": "2117140",
    "end": "2122460"
  },
  {
    "text": "in an arbitrary C loop. We have a loop body,\nwhich is what's executed on each iteration. And then we have\nsome loop control,",
    "start": "2122460",
    "end": "2129059"
  },
  {
    "text": "which manages all of the\niterations of that loop.",
    "start": "2129060",
    "end": "2134430"
  },
  {
    "text": "So in this case, we\nhave a simple C loop, which multiplies each\nelement of an input vector x by some scale over a\nand stores the result into y.",
    "start": "2134430",
    "end": "2142280"
  },
  {
    "text": "That body gets translated into\na blob of straight line code. I won't step through all of the\nstraight line code just now.",
    "start": "2142280",
    "end": "2148530"
  },
  {
    "text": "There's plenty of\nit, and you'll be able to see the slides\nafter this lecture.",
    "start": "2148530",
    "end": "2154740"
  },
  {
    "text": "But that blob of\nstraight line code corresponds to a loop body. And the rest of the code\nin the LLVM IR snippet",
    "start": "2154740",
    "end": "2160470"
  },
  {
    "text": "corresponds to the loop control. So we have the\ninitial assignment",
    "start": "2160470",
    "end": "2166830"
  },
  {
    "text": "of the induction variable. The comparison would\nbe end of the loop and the increment\noperation at the end.",
    "start": "2166830",
    "end": "2173150"
  },
  {
    "text": "All of that gets encoded in the\nstuff highlighted in yellow, that loop control part.",
    "start": "2173150",
    "end": "2178250"
  },
  {
    "text": " Now if we take a\nlook at this code,",
    "start": "2178250",
    "end": "2183930"
  },
  {
    "text": "there's one odd piece that we\nhaven't really understood yet,",
    "start": "2183930",
    "end": "2189040"
  },
  {
    "text": "and it's this phi\ninstruction at the beginning. The phi instruction is weird,\nand it arises pretty commonly",
    "start": "2189040",
    "end": "2197848"
  },
  {
    "text": "when you're dealing with loops.  It basically is there\nto solve a problem",
    "start": "2197848",
    "end": "2204690"
  },
  {
    "text": "with LLVM's representation\nof the code. So before we describe\nthe phi instruction, let's actually take\na look at the problem",
    "start": "2204690",
    "end": "2211710"
  },
  {
    "text": "that this phi instruction\ntries to solve. ",
    "start": "2211710",
    "end": "2219119"
  },
  {
    "text": "So let's first tease apart the\nloop to reveal the problem.",
    "start": "2219120",
    "end": "2224370"
  },
  {
    "text": "The C loop produces\nthis looping pattern in the control flow graph,\nliterally, an edge that goes back to the beginning.",
    "start": "2224370",
    "end": "2230758"
  },
  {
    "text": "If we look at the different\nbasic blocks we have, we have one block at\nthe beginning, which initializes the induction\nvariable and sees",
    "start": "2230758",
    "end": "2237330"
  },
  {
    "text": "if there are any iterations of\nthe loop that need to be run. ",
    "start": "2237330",
    "end": "2243847"
  },
  {
    "text": "If there aren't any\niterations, then they'll branch directly to\nthe end of loop. It will just skip\nthe loop entirely.",
    "start": "2243847",
    "end": "2249540"
  },
  {
    "text": "No need to try to\nexecute any of that code. And in this case, it\nwill simply return.",
    "start": "2249540",
    "end": "2255810"
  },
  {
    "text": "And then inside\nthe loop block, we have these two\nincoming edges-- one from the entry point of\nthe loop, where i has just",
    "start": "2255810",
    "end": "2263670"
  },
  {
    "text": "been set to zero, and another\nwhere we're repeating the loop, where we've decided there's\none more iteration to execute.",
    "start": "2263670",
    "end": "2271355"
  },
  {
    "text": "And we're going to go back\nfrom the end of the loop to the beginning. And that back edge is what\ncreates the loop structure",
    "start": "2271355",
    "end": "2277020"
  },
  {
    "text": "in the control flow graph. Make sense? ",
    "start": "2277020",
    "end": "2282346"
  },
  {
    "text": "I at least see one\nnod over there. So that's encouraging. ",
    "start": "2282346",
    "end": "2288390"
  },
  {
    "start": "2287000",
    "end": "2397000"
  },
  {
    "text": "OK, so if we take a look\nat the loop control, there are a couple of\ncomponents to that loop control.",
    "start": "2288390",
    "end": "2293829"
  },
  {
    "text": "There's the initialization\nof the induction variable. There is the condition,\nand there's the increment.",
    "start": "2293830",
    "end": "2299339"
  },
  {
    "text": "Condition says when do you exit. Increment updates the value\nof the induction variable.",
    "start": "2299340",
    "end": "2306580"
  },
  {
    "text": "And we can translate\neach of these components from the C code for\nthe loop control into the LLVM IR\ncode for that loop.",
    "start": "2306580",
    "end": "2315010"
  },
  {
    "text": "So the increment,\nwe would expect to see some sort of addition\nwhere we add 1 to some register",
    "start": "2315010",
    "end": "2322510"
  },
  {
    "text": "somewhere. And lo and behold, there\nis an add operation. So we'll call that\nthe increment.",
    "start": "2322510",
    "end": "2328789"
  },
  {
    "text": "For the condition, we expect\nsome comparison operation and a conditional branch\nbased on that comparison.",
    "start": "2328790",
    "end": "2334910"
  },
  {
    "text": "Look at that. Right after the\nincrement, there's a compare and a\nconditional branch that we'll either take us back\nto the beginning of the loop",
    "start": "2334910",
    "end": "2341890"
  },
  {
    "text": "or out of the loop entirely. ",
    "start": "2341890",
    "end": "2347200"
  },
  {
    "text": "And we do see that there is\nsome form of initialization. The initial value of this\ninduction variable is 0.",
    "start": "2347200",
    "end": "2355029"
  },
  {
    "text": "And we do see a 0 among\nthis loop control code. It's kind of squirreled away\nin that weird notation there.",
    "start": "2355030",
    "end": "2361490"
  },
  {
    "text": "And that weird notation\nis sitting next to the phi instruction. What's not so clear\nhere is where exactly",
    "start": "2361490",
    "end": "2369319"
  },
  {
    "text": "is the induction variable. We had this single\nvariable i in our C code.",
    "start": "2369320",
    "end": "2374640"
  },
  {
    "text": "And what we're looking\nat in the LLVM IR are a whole bunch of\ndifferent registers. We have a register\nthat stores what",
    "start": "2374640",
    "end": "2380840"
  },
  {
    "text": "we're claiming to\nbe i plus 1, then we do this comparison\nand branch thing. And then we have\nthis phi instruction",
    "start": "2380840",
    "end": "2388160"
  },
  {
    "text": "that takes 0 or the\nresult of the increment.",
    "start": "2388160",
    "end": "2393260"
  },
  {
    "text": "Where did i actually go? ",
    "start": "2393260",
    "end": "2398820"
  },
  {
    "text": "So the problem here\nis that i is really represented across all\nof those instructions.",
    "start": "2398820",
    "end": "2405570"
  },
  {
    "text": "And that happens because the\nvalue of the induction variable changes as you execute the loop.",
    "start": "2405570",
    "end": "2411330"
  },
  {
    "text": "The value of i is different on\niteration 0 versus iteration 1 versus iteration 2\nversus iteration 3",
    "start": "2411330",
    "end": "2417210"
  },
  {
    "text": "and so on and so forth. i is changing as you\nexecute the loop. And there's this\nfunny invariant.",
    "start": "2417210",
    "end": "2424910"
  },
  {
    "text": "Yeah, so if we try to map that\ninduction variable to the LLVM IR, it kind of maps to\nall of these locations.",
    "start": "2424910",
    "end": "2432470"
  },
  {
    "text": "It maps to various\nuses in the loop body. It maps, roughly speaking, to\nthe return value of this field",
    "start": "2432470",
    "end": "2438109"
  },
  {
    "text": "instruction, even though we're\nnot sure what that's all about. But we can tell it maps to\nthat, because we're going",
    "start": "2438110",
    "end": "2443367"
  },
  {
    "text": "to increment that later on. And we're going to use\nthat in a comparison. So it kind of maps\nall over the place.",
    "start": "2443367",
    "end": "2448730"
  },
  {
    "start": "2448730",
    "end": "2453779"
  },
  {
    "text": "And because it changes values\nwith the increment operation,",
    "start": "2453779",
    "end": "2461200"
  },
  {
    "text": "we're going to encounter-- so why does it change registers? Well, we have this\nproperty in LLVM",
    "start": "2461200",
    "end": "2468520"
  },
  {
    "text": "that each instruction\ndefines the value of a register, at most, once.",
    "start": "2468520",
    "end": "2474220"
  },
  {
    "text": "So for any particular\nregister with LLVM, we can identify a\nunique place in the code",
    "start": "2474220",
    "end": "2480120"
  },
  {
    "text": "of the function that\ndefines that register value. This invariant is called\nthe static single assignment",
    "start": "2480120",
    "end": "2487180"
  },
  {
    "start": "2485000",
    "end": "2537000"
  },
  {
    "text": "invariant. And it seems a little bit\nweird, but it turns out to be an extremely powerful\ninvariant within the compiler.",
    "start": "2487180",
    "end": "2495530"
  },
  {
    "text": "It assists with a lot of\nthe compiler analysis. And it also can help\nwith reading the LLVM IR if you expect it.",
    "start": "2495530",
    "end": "2505809"
  },
  {
    "text": "So this is a nice\ninvariant, but it poses a problem\nwhen we're dealing with induction variables, which\nchange as the loop unfolds.",
    "start": "2505810",
    "end": "2515780"
  },
  {
    "text": "And so what happens when\ncontrol flow merges at the entry",
    "start": "2515780",
    "end": "2520870"
  },
  {
    "text": "point of a loop, for example? How do we define\nwhat the induction variable is at that location?",
    "start": "2520870",
    "end": "2526760"
  },
  {
    "text": "Because it could\neither be 0, if this is the first time through the\nloop, or whatever you lost incremented.",
    "start": "2526760",
    "end": "2532680"
  },
  {
    "text": "And the solution to that\nproblem is the phi instruction. ",
    "start": "2532680",
    "end": "2538059"
  },
  {
    "start": "2537000",
    "end": "2648000"
  },
  {
    "text": "The phi instruction defines\na register that says,",
    "start": "2538060",
    "end": "2543130"
  },
  {
    "text": "depending on how you get to\nthis location in the code, this register will have one\nof several different values.",
    "start": "2543130",
    "end": "2551140"
  },
  {
    "text": "And the phi instruction\nsimply lists what the value of\nthat register will be, depending on which basic\nblock you came from.",
    "start": "2551140",
    "end": "2559720"
  },
  {
    "text": "So in this particular code,\nthe phi instruction says, if you came from block\n6, which was the entry",
    "start": "2559720",
    "end": "2565690"
  },
  {
    "text": "point of the loop, where you\ninitially checked if there were any loop iterations to perform,\nif you come from that block,",
    "start": "2565690",
    "end": "2574299"
  },
  {
    "text": "then this register 9 is\ngoing to adopt the value 0. If, however, you followed\nthe back edge of the loop,",
    "start": "2574300",
    "end": "2581593"
  },
  {
    "text": "then the register is\ngoing to adopt the value, in this case, 14. And 14, lo and\nbehold, is the result",
    "start": "2581593",
    "end": "2587200"
  },
  {
    "text": "of the incremental operation. And so this phi\ninstruction says, either you're going\nto start from zero,",
    "start": "2587200",
    "end": "2592510"
  },
  {
    "text": "or you're going to be i plus 1. ",
    "start": "2592510",
    "end": "2598015"
  },
  {
    "text": "Just to note, the\nphi instruction is not a real instruction. It's really a solution to\na problem with an LLVM.",
    "start": "2598015",
    "end": "2605390"
  },
  {
    "text": "And when you translate\nthis code into assembly, the phi instruction\nisn't going to map to any particular\nassembly instruction.",
    "start": "2605390",
    "end": "2612470"
  },
  {
    "text": "It's really a\nrepresentational trick. Does that make some sense? Any questions about that?",
    "start": "2612470",
    "end": "2618420"
  },
  {
    "text": "Yeah? STUDENT: Why is it called phi? TAO SCHARDL: Why\nis it called phi? That's a great question.",
    "start": "2618420",
    "end": "2623580"
  },
  {
    "text": "I actually don't know why\nthey chose the name phi. I don't think they had\na particular affinity",
    "start": "2623580",
    "end": "2628970"
  },
  {
    "text": "for the Golden\nRatio, but I'm not sure what the rationale was. I don't know if\nanyone else knows.",
    "start": "2628970",
    "end": "2635335"
  },
  {
    "text": " Yeah? Google knows all, sort of.",
    "start": "2635335",
    "end": "2640980"
  },
  {
    "text": " Yeah, so adopt the value 0 from\nblock 6 or 14 from block 8.",
    "start": "2640980",
    "end": "2650430"
  },
  {
    "text": "So that's all of\nthe basic components of C translated into LLVM IR.",
    "start": "2650430",
    "end": "2655642"
  },
  {
    "text": "The last thing I\nwant to leave you with in this section on\nLLVM IR is a discussion of these attributes.",
    "start": "2655643",
    "end": "2660797"
  },
  {
    "text": "And we already saw one of\nthese attributes before. It was this NSW thing\nattached the add instruction.",
    "start": "2660797",
    "end": "2667920"
  },
  {
    "start": "2667000",
    "end": "2790000"
  },
  {
    "text": "In general, these\nLLVM IR constructs might be decorated with these\nextra words and keywords.",
    "start": "2667920",
    "end": "2676140"
  },
  {
    "text": "And those are the keywords I'm\nreferring to as attributes. Those attributes convey\na variety of information.",
    "start": "2676140",
    "end": "2685059"
  },
  {
    "text": "So in this case, what\nwe have here is C code that performs this\nmemory calculation,",
    "start": "2685060",
    "end": "2691880"
  },
  {
    "text": "which you might have seen\nfrom our previous lecture. And what we see in the\ncorresponding LLVM IR",
    "start": "2691880",
    "end": "2697710"
  },
  {
    "text": "is that there's some extra\nstuff tacked onto that load instruction where\nyou load memory.",
    "start": "2697710",
    "end": "2704090"
  },
  {
    "text": "One of those pieces of extra\ninformation is this align 4. And what that align\n4 attribute says",
    "start": "2704090",
    "end": "2711670"
  },
  {
    "text": "is it describes the alignment\nof that read from memory. And so if subsequent\nstages of the compiler",
    "start": "2711670",
    "end": "2717770"
  },
  {
    "text": "can employ that information,\nif they can optimize reads that are 4-byte aligned,\nthen this attribute will say,",
    "start": "2717770",
    "end": "2726170"
  },
  {
    "text": "this is a load that you\ncan go ahead and optimize. ",
    "start": "2726170",
    "end": "2731974"
  },
  {
    "text": "There are a bunch\nof places where attributes might come from. Some of them are derived\ndirectly from the source code.",
    "start": "2731975",
    "end": "2737100"
  },
  {
    "text": "If you write a\nfunction that takes a parameter marked as const,\nor marked as restrict, then",
    "start": "2737100",
    "end": "2742740"
  },
  {
    "text": "in the LLVM IR, you might see\nthat the corresponding function parameter is marked as no alias,\nbecause the restricted keyword",
    "start": "2742740",
    "end": "2749700"
  },
  {
    "text": "said this pointer can ever\nalias or the const keyword says, you're only ever going to\nread from this pointer.",
    "start": "2749700",
    "end": "2755760"
  },
  {
    "text": "So this pointer is going\nto be marked read-only. So in that case, the source\ncode itself-- the C code--",
    "start": "2755760",
    "end": "2762539"
  },
  {
    "text": "was the source of\nthe information for those attributes. There are some other\nattributes that occur simply",
    "start": "2762540",
    "end": "2769770"
  },
  {
    "text": "because the compiler\nis smart, and it does some clever analysis. So in this case, the LLVM\nIR has a load operation",
    "start": "2769770",
    "end": "2778050"
  },
  {
    "text": "that's 8-byte aligned. It was really analysis that\nfigured out the alignment",
    "start": "2778050",
    "end": "2783120"
  },
  {
    "text": "of that load operation.  Good so far?",
    "start": "2783120",
    "end": "2790110"
  },
  {
    "text": "Cool. So let's summarize this part\nof the discussion with what",
    "start": "2790110",
    "end": "2796569"
  },
  {
    "text": "we've seen about LLVM IR. LLVM IR is similar to\nassembly, but a lot simpler",
    "start": "2796570",
    "end": "2802339"
  },
  {
    "text": "in many, many ways. All of the computed values\nare stored in registers. And, really, when\nyou're reading LLVM IR,",
    "start": "2802340",
    "end": "2808640"
  },
  {
    "text": "you can think of\nthose registers a lot like ordinary C variables.",
    "start": "2808640",
    "end": "2815059"
  },
  {
    "text": "LLVM IR is a little\nbit funny in that it adopts a static, single\nassignment paradigm-- this invariant-- where each\nregistered name, each variable",
    "start": "2815060",
    "end": "2823460"
  },
  {
    "text": "is written by, at most, one\ninstruction within the LLVM IR code.",
    "start": "2823460",
    "end": "2829600"
  },
  {
    "text": "So if you're ever curious where\n%14 is defined within this function, just do a search for\nwhere %14 is on the left-hand",
    "start": "2829600",
    "end": "2836950"
  },
  {
    "text": "side of an equals,\nand there you go. We can model of\nfunction in LLVM IR",
    "start": "2836950",
    "end": "2843040"
  },
  {
    "text": "as a control flow\ngraph, whose nodes correspond to basic blocks-- these blobs of\nstraight line code--",
    "start": "2843040",
    "end": "2849250"
  },
  {
    "text": "and whose edges do node control\nflow among those basic blocks. And compared to C, LLVM\nIR is pretty similar,",
    "start": "2849250",
    "end": "2857330"
  },
  {
    "text": "except that all of these\noperations are explicit. The types are\nexplicit everywhere. The integer sizes\nare all apparent.",
    "start": "2857330",
    "end": "2864630"
  },
  {
    "text": "You don't have to\nremember that int really means a 32-bit\ninteger, and you need n-64 to be a 64-bit integer,\nor you need a long or anything.",
    "start": "2864630",
    "end": "2873050"
  },
  {
    "text": "It's just i and\nthen a bit width. There no implicit operations\nat the LLVM IR level.",
    "start": "2873050",
    "end": "2879730"
  },
  {
    "text": "All the typecasts are explicit. In some sense, LLVM\nIR is like assembly",
    "start": "2879730",
    "end": "2887440"
  },
  {
    "text": "if assembly were more like c. And that's doubly a\nstatement that would not have made sense 40 minutes ago.",
    "start": "2887440",
    "end": "2893160"
  },
  {
    "text": " All right, so you've seen how to\ntranslate C code into LLVM IR.",
    "start": "2893160",
    "end": "2902800"
  },
  {
    "text": "There's one last step. We want to translate the\nLLVM IR into assembly. And it turns out that\nstructurally speaking,",
    "start": "2902800",
    "end": "2910520"
  },
  {
    "text": "LLVM IR is very\nsimilar to assembly. We can, more or less,\nmap each line of LLVM IR",
    "start": "2910520",
    "end": "2917470"
  },
  {
    "text": "to some sequence of lines\nin the final assembly code.",
    "start": "2917470",
    "end": "2923230"
  },
  {
    "text": "But there is some\nadditional complexity. The compiler isn't\ndone with its work yet when it's compiling\nC to LLVM IR to assembly.",
    "start": "2923230",
    "end": "2933040"
  },
  {
    "text": "There are three main tasks\nthat the compiler still has to perform in order\nto generate x86-64.",
    "start": "2933040",
    "end": "2941440"
  },
  {
    "text": "First, it has to select\nthe actual x86 assembly instructions that are going to\nimplement these various LLVM IR",
    "start": "2941440",
    "end": "2947300"
  },
  {
    "text": "operations. It has to decide which general\npurpose registers are going to hold different\nvalues and which values",
    "start": "2947300",
    "end": "2954789"
  },
  {
    "text": "need to be squirreled\naway into memory, because it just has\nno other choice. And it has to coordinate\nall of the function calls.",
    "start": "2954790",
    "end": "2962260"
  },
  {
    "text": "And it's not just\nthe function calls within this particular\nsource file. It's also function calls\nbetween that source file,",
    "start": "2962260",
    "end": "2969820"
  },
  {
    "text": "and other source files\nthat you're compiling, and binary libraries that are\njust sitting on the system.",
    "start": "2969820",
    "end": "2975727"
  },
  {
    "text": "But the compiler never\nreally gets to touch. It has to coordinate\nall of those calls. That's a bit complicated.",
    "start": "2975727",
    "end": "2981410"
  },
  {
    "text": "That is going to be the reason\nfor a lot of the remaining complexity. And that's what brings our\ndiscussion to the Linux",
    "start": "2981410",
    "end": "2988960"
  },
  {
    "start": "2986000",
    "end": "3003000"
  },
  {
    "text": "x86-64 calling convention. This isn't a very\nfun convention.",
    "start": "2988960",
    "end": "2994660"
  },
  {
    "text": "Don't worry. But nevertheless, it's useful.",
    "start": "2994660",
    "end": "2999990"
  },
  {
    "text": "So to talk about\nthis convention, let's first take a look at\nhow a program gets laid out",
    "start": "2999990",
    "end": "3005540"
  },
  {
    "start": "3003000",
    "end": "3334000"
  },
  {
    "text": "in memory when you run it. So when a program\nexecutes, virtually memory",
    "start": "3005540",
    "end": "3011240"
  },
  {
    "text": "gets organized into a whole\nbunch of different chunks which are called segments. There's a segment that\ncorresponds to the stack that's",
    "start": "3011240",
    "end": "3018620"
  },
  {
    "text": "actually located near the\ntop of virtual memory, and it grows downwards. The stack grows down.",
    "start": "3018620",
    "end": "3023660"
  },
  {
    "text": "Remember this. There is a heap segment,\nwhich grows upwards from a middle\nlocation in memory.",
    "start": "3023660",
    "end": "3031160"
  },
  {
    "text": "And those two\ndynamically-allocated segments",
    "start": "3031160",
    "end": "3036859"
  },
  {
    "text": "live at the top of the\nvirtual address space. There are then two\nadditional segments-- the bss segment for\nuninitialized data",
    "start": "3036860",
    "end": "3045050"
  },
  {
    "text": "and the data segment\nfor initialized data. And finally, at the bottom\nof virtual address space,",
    "start": "3045050",
    "end": "3050780"
  },
  {
    "text": "there's a tech segment. And that just stores the\ncode of the program itself. ",
    "start": "3050780",
    "end": "3058910"
  },
  {
    "text": "Now when you read\nassembly code directly, you'll see that\nthe assembly code",
    "start": "3058910",
    "end": "3064880"
  },
  {
    "text": "contains more than just some\nlabels and some instructions. In fact, it's decorated with\na whole bunch of other stuff.",
    "start": "3064880",
    "end": "3073200"
  },
  {
    "text": "And these are called\nassembler directives, and these directives operate\non different sections",
    "start": "3073200",
    "end": "3079460"
  },
  {
    "text": "of the assembly code. Some of those directives\nrefer to the various segments of virtual memory.",
    "start": "3079460",
    "end": "3085539"
  },
  {
    "text": "And those segment\ndirectives are used to organize the content\nof the assembly file.",
    "start": "3085540",
    "end": "3092119"
  },
  {
    "text": "For example, the .text\ndirective identifies some chunk of the assembly, which is really\ncode and should be located",
    "start": "3092120",
    "end": "3099200"
  },
  {
    "text": "in the text segment\nwhen the program is run. The .bss segment\nidentifies stuff that lives",
    "start": "3099200",
    "end": "3105470"
  },
  {
    "text": "in the assembler directive\nto identify stuff in the bss segment. The .data directive identify\nstuff in the data segment,",
    "start": "3105470",
    "end": "3113150"
  },
  {
    "text": "so on and so forth. There are also various\nstorage directives that will store\ncontent of some variety",
    "start": "3113150",
    "end": "3119480"
  },
  {
    "text": "directly into the current\nsegment-- whatever was last identified by a\nsegment directive.",
    "start": "3119480",
    "end": "3124940"
  },
  {
    "text": "So if, at some point, there\nis a directive x colon",
    "start": "3124940",
    "end": "3130319"
  },
  {
    "text": "dot space 20, that\nspace directive says, allocate some amount of memory. And in this case, it says,\nallocate 20 bytes of memory.",
    "start": "3130320",
    "end": "3138300"
  },
  {
    "text": "And we're going to\nlabel that location x. The .long segment says, store\na constant long integer value--",
    "start": "3138300",
    "end": "3147268"
  },
  {
    "text": "in this case, 172--  in this example, at location y.",
    "start": "3147268",
    "end": "3154329"
  },
  {
    "text": "The asciz segment\nsimilarly stores a string at that particular location.",
    "start": "3154330",
    "end": "3160250"
  },
  {
    "text": "So here, we're storing the\nstring 6.172 at location z. There is an align\ndirective that aligns",
    "start": "3160250",
    "end": "3168460"
  },
  {
    "text": "the next content in the assembly\nfile to an 8-byte boundary.",
    "start": "3168460",
    "end": "3175540"
  },
  {
    "text": "There are additional segments\nfor the linker to obey, and those are the scope\nand linkage directives.",
    "start": "3175540",
    "end": "3181450"
  },
  {
    "text": "For example, you might see\n.globl in front of a label. And that single is linker\nthat that particular symbol",
    "start": "3181450",
    "end": "3189640"
  },
  {
    "text": "should be visible to the other\nfiles that the linker touches. In this case, .globl fib makes\nfib visible to the other object",
    "start": "3189640",
    "end": "3199330"
  },
  {
    "text": "files, and that allows this\nother object files to call or refer to this fib location.",
    "start": "3199330",
    "end": "3204625"
  },
  {
    "text": " Now, let's turn our\nattention to the segment",
    "start": "3204625",
    "end": "3210800"
  },
  {
    "text": "at the top, the stack segment. This segment is used to store\ndata and memory in order",
    "start": "3210800",
    "end": "3217250"
  },
  {
    "text": "to manage function\ncalls and returns. That's a nice high-level\ndescription, but what exactly",
    "start": "3217250",
    "end": "3224029"
  },
  {
    "text": "ends up in the stack segment? Why do we need a stack? What data will end\nup going there?",
    "start": "3224030",
    "end": "3229537"
  },
  {
    "text": "Can anyone tell me? ",
    "start": "3229538",
    "end": "3235120"
  },
  {
    "text": "STUDENT: Local\nvariables in function? TAO SCHARDL: Local\nvariables in function. Anything else?",
    "start": "3235120",
    "end": "3241240"
  },
  {
    "text": "You already answered once. I may call on you again. Go ahead. STUDENT: Function arguments? TAO SCHARDL: Sorry? STUDENT: Function arguments?",
    "start": "3241240",
    "end": "3247000"
  },
  {
    "text": "TAO SCHARDL: Function\narguments-- very good. Anything else? I thought I saw a\nhand over here, but--",
    "start": "3247000",
    "end": "3252385"
  },
  {
    "text": " STUDENT: The return address?",
    "start": "3252385",
    "end": "3258210"
  },
  {
    "text": "TAO SCHARDL: The return address.  Anything else? Yeah?",
    "start": "3258210",
    "end": "3263430"
  },
  {
    "text": " There's one other\nimportant thing",
    "start": "3263430",
    "end": "3269500"
  },
  {
    "text": "that gets stored on stack. ",
    "start": "3269500",
    "end": "3275020"
  },
  {
    "text": "Yeah? STUDENT: The return value? TAO SCHARDL: The return value--",
    "start": "3275020",
    "end": "3280135"
  },
  {
    "text": "actually, that\none's interesting. It might be stored on the\nstack, but it might not be stored on the stack.",
    "start": "3280135",
    "end": "3287270"
  },
  {
    "text": "Good guess, though. Yeah? STUDENT: Intermediate results? TAO SCHARDL:\nIntermediate results, in a manner of speaking, yes.",
    "start": "3287270",
    "end": "3294000"
  },
  {
    "text": "There are more\nintermediate results than meets the eye when\nit comes to assembly",
    "start": "3294000",
    "end": "3299760"
  },
  {
    "text": "or comparing it to\nC. But in particular, by intermediate results,\nlet's say, register state.",
    "start": "3299760",
    "end": "3307579"
  },
  {
    "text": "There are only so many\nregisters on the machine. And sometimes,\nthat's not enough.",
    "start": "3307580",
    "end": "3313970"
  },
  {
    "text": "And so the function may\nwant to squirrel away some data that's in registers\nand stash it somewhere",
    "start": "3313970",
    "end": "3319970"
  },
  {
    "text": "in order to read it back later. The stack is a very\nnatural place to do it. That's the dedicated\nplace to do it.",
    "start": "3319970",
    "end": "3326456"
  },
  {
    "text": "So yeah, that's pretty\nmuch all the content of what ends up on the call\nstack as the program executes.",
    "start": "3326456",
    "end": "3335099"
  },
  {
    "text": "Now, here's the thing. There are a whole bunch of\nfunctions in the program. Some of them may have been\ndefined in the source file",
    "start": "3335100",
    "end": "3345950"
  },
  {
    "text": "that you're compiling right now. Some of them might be defined\nin other source files. Some of them might be\ndefined in libraries",
    "start": "3345950",
    "end": "3351830"
  },
  {
    "text": "that were compiled\nby someone else, possibly using a different\ncompiler, with different flags,",
    "start": "3351830",
    "end": "3357140"
  },
  {
    "text": "under different\nparameters, presumably, for this architecture--\nat least, one hopes. But those libraries are\ncompletely out of your control.",
    "start": "3357140",
    "end": "3367870"
  },
  {
    "text": "And now, we have this problem. All those object files might\ndefine these functions.",
    "start": "3367870",
    "end": "3373287"
  },
  {
    "text": "And those functions want to\ncall each other, regardless of where those functions\nare necessarily defined.",
    "start": "3373288",
    "end": "3378460"
  },
  {
    "text": "And so somehow, we need to\ncoordinate all those function calls and make sure that\nif one function wants",
    "start": "3378460",
    "end": "3384700"
  },
  {
    "text": "to use these registers,\nand this other function wants to use the same\nregisters, those functions aren't going to interfere\nwith each other.",
    "start": "3384700",
    "end": "3392160"
  },
  {
    "text": "Or if they both want\nto read stack memory, they're not going to\nclobber each other's stacks.",
    "start": "3392160",
    "end": "3398080"
  },
  {
    "text": "So how do we deal with\nthis coordination problem? At a high level, what's\nthe high-level strategy",
    "start": "3398080",
    "end": "3404590"
  },
  {
    "text": "we're going to adopt to deal\nwith this coordination problem? ",
    "start": "3404590",
    "end": "3410399"
  },
  {
    "text": "STUDENT: Put the values of\nthe registers on the stack before you go into the function. TAO SCHARDL: That\nwill be part of it.",
    "start": "3410399",
    "end": "3416480"
  },
  {
    "text": "But for the higher\nlevel strategy-- so that's a component of\nthis higher level strategy.",
    "start": "3416480",
    "end": "3422190"
  },
  {
    "text": "Yeah? Go ahead. STUDENT: Calling convention? TAO SCHARDL: Calling convention. You remembered the title of\nthis section of the talk.",
    "start": "3422190",
    "end": "3427250"
  },
  {
    "text": "Great. We're going to make sure\nthat every single function, regardless of where it's\ndefined, they all abide",
    "start": "3427250",
    "end": "3434600"
  },
  {
    "text": "by the same calling convention. So it's a standard\nthat all the functions will obey in order to make sure\nthey all play nicely together.",
    "start": "3434600",
    "end": "3444280"
  },
  {
    "start": "3443000",
    "end": "3599000"
  },
  {
    "text": "So let's unpack the Linux\nx86-64 calling convention. Well, not the whole thing,\nbecause it's actually",
    "start": "3444280",
    "end": "3449380"
  },
  {
    "text": "pretty complicated, but at\nleast enough to understand the basics of what's going on.",
    "start": "3449380",
    "end": "3454960"
  },
  {
    "text": "So a high level, this calling\nconvention organizes the stack segment into frames, such that\neach function instantiation--",
    "start": "3454960",
    "end": "3463630"
  },
  {
    "text": "each time you call a function-- that instantiation gets a\nsingle frame all to itself.",
    "start": "3463630",
    "end": "3470890"
  },
  {
    "text": "And to manage all\nthose stack frames, the calling convention is going\nto use these two pointers-- rbp",
    "start": "3470890",
    "end": "3475930"
  },
  {
    "text": "and rsp, which you\nshould've seen last time. rbp, the base pointer,\nwill point to the top",
    "start": "3475930",
    "end": "3481840"
  },
  {
    "text": "of the current stack frame. rsp will point to the bottom\nup the current stack frame. And remember, the stack grows.",
    "start": "3481840",
    "end": "3487720"
  },
  {
    "text": " Now when the code executes\ncall-and-return instructions,",
    "start": "3487720",
    "end": "3495130"
  },
  {
    "text": "those instructions\nare going to operate on the stack, these various\nstock pointers, as well",
    "start": "3495130",
    "end": "3502630"
  },
  {
    "text": "as the instruction\npointer, rip, in order to manage the return\naddress of each function.",
    "start": "3502630",
    "end": "3508960"
  },
  {
    "text": "In particular, when a call\ninstruction gets executed, in x86, that call\ninstruction will",
    "start": "3508960",
    "end": "3515319"
  },
  {
    "text": "push the current value\nof rip onto the stack, and that will be\nthe return address.",
    "start": "3515320",
    "end": "3520980"
  },
  {
    "text": "And then the call instruction\nwill jump to its operand. It's operand being the address\nof some function in the program",
    "start": "3520980",
    "end": "3530020"
  },
  {
    "text": "memory, or, at least, one hopes. Perhaps there was buffer\noverflow corruption",
    "start": "3530020",
    "end": "3535150"
  },
  {
    "text": "of some kind, and your\nprogram is in dire straits. But presumably, it's the\naddress of a function.",
    "start": "3535150",
    "end": "3544950"
  },
  {
    "text": "The return instruction\ncomplements the call, and it's going to undo the\noperations of that call instruction.",
    "start": "3544950",
    "end": "3550630"
  },
  {
    "text": "It'll pop the return\naddress off the stack and put that into rip.",
    "start": "3550630",
    "end": "3556180"
  },
  {
    "text": "And that will\ncause the execution to return to the caller\nand resume execution",
    "start": "3556180",
    "end": "3561579"
  },
  {
    "text": "from the statement right\nafter the original call. ",
    "start": "3561580",
    "end": "3567039"
  },
  {
    "text": "So that's the high level of\nhow the stack gets managed as well as the return address. How about, how do we\nmaintain registers",
    "start": "3567040",
    "end": "3573420"
  },
  {
    "text": "across all those calls? Well, there's a\nbit of a problem. Because we might have\ntwo different functions",
    "start": "3573420",
    "end": "3579420"
  },
  {
    "text": "that want to use\nthe same registers. Some of this might be review,\nby the way, from 6004.",
    "start": "3579420",
    "end": "3589200"
  },
  {
    "text": "If you have questions,\njust let me know. So we have this problem,\nwhere two different functions,",
    "start": "3589200",
    "end": "3594220"
  },
  {
    "text": "function A, which might\ncall another function B. Those two functions might\nwant to use the same registers.",
    "start": "3594220",
    "end": "3600670"
  },
  {
    "text": "So who's responsible\nfor making sure that if function B operates\non the same registers as A,",
    "start": "3600670",
    "end": "3607720"
  },
  {
    "text": "that when B is done,\nA doesn't end up with corrupted state\nin its registers?",
    "start": "3607720",
    "end": "3613210"
  },
  {
    "text": "Well, they're two\ndifferent strategies that could be adopted. One is to have the caller\nsave off the register",
    "start": "3613210",
    "end": "3619760"
  },
  {
    "text": "state before invoking a call. But that has some downsides. The caller might waste\nwork, saying, well,",
    "start": "3619760",
    "end": "3626750"
  },
  {
    "text": "I have to save all of this\nregister state in case the function I'm calling\nwants to use those registers.",
    "start": "3626750",
    "end": "3632923"
  },
  {
    "text": "If the calling function\ndoesn't use those registers, that was a bunch of wasted work.",
    "start": "3632923",
    "end": "3638030"
  },
  {
    "text": "So on the other side,\nyou might say, well, let's just have the callee\nsave all that registered state.",
    "start": "3638030",
    "end": "3643655"
  },
  {
    "text": "But that could waste\nwork if the callee is going to save off register\nstate that the caller wasn't using.",
    "start": "3643655",
    "end": "3649022"
  },
  {
    "text": "So if the callee\nsays, well, I want to use all these registers. I don't know what the\ncalling function used,",
    "start": "3649022",
    "end": "3654500"
  },
  {
    "text": "so I'm just going to push\neverything on the stack, that could be a lot of wasted work.",
    "start": "3654500",
    "end": "3659569"
  },
  {
    "text": "So what does the x86\ncalling convention do, if you had to guess? ",
    "start": "3659570",
    "end": "3667920"
  },
  {
    "text": "Yeah? STUDENT: [INAUDIBLE]",
    "start": "3667920",
    "end": "3674473"
  },
  {
    "text": "TAO SCHARDL: That's\nexactly right. It does a little bit of both. It specifies some\nof the registers as being callee-saved registers,\nand the rest of the registers",
    "start": "3674473",
    "end": "3683109"
  },
  {
    "text": "are caller-saved registers. And so the caller will\nbe responsible for saving",
    "start": "3683110",
    "end": "3688180"
  },
  {
    "text": "some stuff. The callee will be responsible\nfor saving other stuff. And if either of those\nfunctions doesn't",
    "start": "3688180",
    "end": "3695380"
  },
  {
    "text": "need one of those registers,\nthen it can avoid wasted work.",
    "start": "3695380",
    "end": "3700396"
  },
  {
    "text": "In x86-64, in this\ncalling convention, turns out that the rbx, rbp,\nand r12 through r15 registers",
    "start": "3700396",
    "end": "3707980"
  },
  {
    "text": "are all callee saved, and\nthe rest of the registers are caller saved. In particular, the\nC linkage defined",
    "start": "3707980",
    "end": "3714700"
  },
  {
    "text": "by this calling convention\nfor all the registers looks something like this. And that identifies\nlots of stuff.",
    "start": "3714700",
    "end": "3722609"
  },
  {
    "text": "It identifies a register for\nstoring the return value, registers for storing a\nbunch of the arguments,",
    "start": "3722610",
    "end": "3728350"
  },
  {
    "text": "caller-save registers,\ncallee-saved registers, a register just for linking.",
    "start": "3728350",
    "end": "3734140"
  },
  {
    "text": "I don't expect you to\nmemorize this in 12 seconds. And I think on\nany quiz-- well, I",
    "start": "3734140",
    "end": "3740529"
  },
  {
    "text": "won't say what the course app\nwill do on quizzes this year. STUDENT: [INAUDIBLE] everyone.",
    "start": "3740530",
    "end": "3745560"
  },
  {
    "text": "TAO SCHARDL: Yeah, OK,\nwell, there you go. So you'll have\nthese slides later. You can practice\nmemorizing them.",
    "start": "3745560",
    "end": "3750910"
  },
  {
    "text": " Not sure on this slide. There are a couple\nother registers",
    "start": "3750910",
    "end": "3757250"
  },
  {
    "text": "that are used for saving\nfunction arguments and return values. And, in particular, whenever\nyou're passing floating point",
    "start": "3757250",
    "end": "3764990"
  },
  {
    "text": "stuff around, the xmm\nregister 0 through 7 are used to deal with those\nfloating point values.",
    "start": "3764990",
    "end": "3772680"
  },
  {
    "text": "Cool. So we have strategies for\nmaintaining the stack. We have strategies for\nmaintaining register states.",
    "start": "3772680",
    "end": "3780170"
  },
  {
    "text": "But we still have\nthe situation where functions may want\nto use overlapping parts of stack memory.",
    "start": "3780170",
    "end": "3786677"
  },
  {
    "text": "And so we need to coordinate how\nall those functions are going to use the stack memory itself.",
    "start": "3786677",
    "end": "3793320"
  },
  {
    "text": "This is a bit hard to describe. The cleanest way I know\ndescribe it is just to work through an example.",
    "start": "3793320",
    "end": "3799030"
  },
  {
    "text": "So here's the setup. Let's imagine that we\nhave some function A that is called of\nfunction B. And we're",
    "start": "3799030",
    "end": "3805290"
  },
  {
    "text": "in the midst of\nexecuting function B, and now, function B is about\nto call some other function C.",
    "start": "3805290",
    "end": "3813519"
  },
  {
    "text": "As we mentioned before, B\nhas a frame all to itself. And that frame contains\na whole bunch of stuff.",
    "start": "3813520",
    "end": "3819760"
  },
  {
    "text": "It contains arguments\nthat A passed to B. It contains a return address. It contains a base pointer.",
    "start": "3819760",
    "end": "3825910"
  },
  {
    "text": "It contains some\nlocal variables. And because B is\nabout to call C, it's also going to contain\nsome data for arguments",
    "start": "3825910",
    "end": "3832390"
  },
  {
    "text": "that B will pass to C. So that's our setup.",
    "start": "3832390",
    "end": "3837820"
  },
  {
    "text": "We have one function\nready to call another. Let's take a look at\nhow this stack memory",
    "start": "3837820",
    "end": "3843820"
  },
  {
    "text": "is organized first. So at the top, we have what's\ncalled a linkage block.",
    "start": "3843820",
    "end": "3849750"
  },
  {
    "text": "And in this linkage\nblock, this is the region of stack memory,\nwhere function B will access non-register arguments\nfrom its caller, function A.",
    "start": "3849750",
    "end": "3859400"
  },
  {
    "text": "It will access these\nby indexing off of the base pointer, rbp,\nusing positive offsets.",
    "start": "3859400",
    "end": "3864960"
  },
  {
    "text": "Again, the stack grows down. ",
    "start": "3864960",
    "end": "3872100"
  },
  {
    "text": "B will also have a\nblock of stack space after the linkage block\nand return address and bass",
    "start": "3872100",
    "end": "3878260"
  },
  {
    "text": "pointer. It will have a region of its\nframe for local variables, and it can access\nthose local variables",
    "start": "3878260",
    "end": "3884109"
  },
  {
    "text": "by indexing off of rbp in\nthe negative direction. Stack grows down.",
    "start": "3884110",
    "end": "3889420"
  },
  {
    "text": "If you don't have anything\nelse, stack grows down. ",
    "start": "3889420",
    "end": "3895349"
  },
  {
    "text": "Now B is about to\ncall a function C, and we want to see how\nall of this unfolds.",
    "start": "3895350",
    "end": "3902740"
  },
  {
    "text": "So before calling C, B is going\nto place non-register arguments for C on to a reserved linkage\nblock in its own stack memory",
    "start": "3902740",
    "end": "3913730"
  },
  {
    "text": "below its local variables.  And it will access\nthose by indexing rbp",
    "start": "3913730",
    "end": "3919530"
  },
  {
    "text": "with negative offsets. So those arguments\nfrom B to its callers",
    "start": "3919530",
    "end": "3924579"
  },
  {
    "text": "will specify those to be\narguments from B to C. And then what's going to happen?",
    "start": "3924580",
    "end": "3929950"
  },
  {
    "text": "Then B is going to call\nC. And as we saw before, the call instruction saves\noff the return address",
    "start": "3929950",
    "end": "3936039"
  },
  {
    "text": "onto the stack, and\nthen it branches control to the entry\npoint of function C.",
    "start": "3936040",
    "end": "3945619"
  },
  {
    "text": "When the function C\nstarts, it's going to execute what's called\nthe function prologue. And the function prologue\nconsists of a couple of steps.",
    "start": "3945620",
    "end": "3952590"
  },
  {
    "text": "First, it's going\nto save off the base pointer for B's stack frame. So it'll just squirrel away the\nvalue of rbp onto the stack.",
    "start": "3952590",
    "end": "3961900"
  },
  {
    "text": "Then it's going to\nset rbp equal to rsp, because we're now\nentering a brand new frame for the invocation of C.",
    "start": "3961900",
    "end": "3970740"
  },
  {
    "text": "And then C can go ahead\nand allocate the space that it needs on the stack. This will be space that C needs\nfor its own local variables,",
    "start": "3970740",
    "end": "3978990"
  },
  {
    "text": "as well as space that C will\nuse for any linkage blocks that it creates for the\nthings that it calls.",
    "start": "3978990",
    "end": "3986520"
  },
  {
    "text": " Now there is one\ncommon optimization",
    "start": "3986520",
    "end": "3992890"
  },
  {
    "text": "that the compiler will\nattempt to perform. If a function never needs to\nperform stack allocations,",
    "start": "3992890",
    "end": "4000720"
  },
  {
    "text": "except to handle\nthese function calls-- in other words, if the\ndifference between rbp and rsp",
    "start": "4000720",
    "end": "4006630"
  },
  {
    "text": "is a compile time\nconstant, then the compiler might go ahead and\njust get rid of rbp",
    "start": "4006630",
    "end": "4013080"
  },
  {
    "text": "and do all of the indexing\nbased off the stack pointer rsp. And the reason it'll do\nthat is because, if it",
    "start": "4013080",
    "end": "4019500"
  },
  {
    "text": "could get one more general\npurpose register out of our rbp, well, now,\nrpb is general purpose.",
    "start": "4019500",
    "end": "4025859"
  },
  {
    "text": "And it has one extra\nregister to use to do all of its calculations. Reading from a register\ntakes some time.",
    "start": "4025860",
    "end": "4032430"
  },
  {
    "text": "Reading from even L1 cache takes\nsignificantly more, I think, four times that amount.",
    "start": "4032430",
    "end": "4039600"
  },
  {
    "text": "And so this is a\ncommon optimization that the compiler\nwill want to perform. Now, turns out that\nthere's a lot more",
    "start": "4039600",
    "end": "4045640"
  },
  {
    "text": "to the calling\nconvention than just what's shown on these slides. We're not going to go\nthrough that today.",
    "start": "4045640",
    "end": "4051309"
  },
  {
    "text": "If you'd like to\nhave more details, there's a nice document--\nthe System V ABI--",
    "start": "4051310",
    "end": "4056950"
  },
  {
    "text": "that describes the whole\ncalling convention. Any questions so far? ",
    "start": "4056950",
    "end": "4066730"
  },
  {
    "text": "All right, so let's wrap all\nthis up with a final case study, and let's take a look\nat how all these components fit",
    "start": "4066730",
    "end": "4073940"
  },
  {
    "text": "together. When we're\ntranslating a simple C function to compute\nFibonacci numbers",
    "start": "4073940",
    "end": "4078980"
  },
  {
    "text": "all the way down to assembly. And as you've been\ndescribing this whole time, we're going to take\nthis in two steps.",
    "start": "4078980",
    "end": "4086410"
  },
  {
    "text": "Let's describe our\nstarting point, fib.c. This should be basically no\nsurprise to you at this point.",
    "start": "4086410",
    "end": "4091530"
  },
  {
    "text": "This is a C function fib, which\ncomputes the nth Fibonacci number in one of the worst\ncomputational ways possible,",
    "start": "4091530",
    "end": "4100318"
  },
  {
    "text": "it turns out. But it computes the\nnth Fibonacci number f of n recursively\nusing the formula f of n",
    "start": "4100319",
    "end": "4106200"
  },
  {
    "text": "is equal to n when\nn is either 0 or 1. Or it computes f of n\nminus 1 and f of n minus 2",
    "start": "4106200",
    "end": "4113640"
  },
  {
    "text": "and takes their sum. This is an exponential\ntime algorithm to compute Fibonacci numbers.",
    "start": "4113640",
    "end": "4118659"
  },
  {
    "text": "I would say, don't\nrun this at home, except, invariably,\nyou'll run this at home. There are much faster algorithms\nto compute Fibonacci numbers.",
    "start": "4118660",
    "end": "4125528"
  },
  {
    "text": "But this is good enough\nfor a didactic example. We're not really worried\nabout how fast can we compute fib today.",
    "start": "4125529",
    "end": "4132750"
  },
  {
    "text": "Now the C code fib.c\nis even simpler than the recurrence implies. We're not even going to bother\nchecking that the input value",
    "start": "4132750",
    "end": "4140369"
  },
  {
    "text": "n is some non-negative value. What we're going to do is say,\nlook, if n is less than 2,",
    "start": "4140369",
    "end": "4145770"
  },
  {
    "text": "go ahead and return\nthat value of n. Otherwise, do the\nrecursive thing.",
    "start": "4145770",
    "end": "4151710"
  },
  {
    "text": "We've already seen this\ngo a couple of times. Everyone good so far? Any questions on\nthese three lines?",
    "start": "4151710",
    "end": "4158096"
  },
  {
    "text": "Great. All right, so let's\ntranslate fib.c into fib.ll.",
    "start": "4158096",
    "end": "4163890"
  },
  {
    "text": "We've seen a lot of these\npieces in lectures so far. And here, we've just\nrewritten fib.c a little bit",
    "start": "4163890",
    "end": "4170580"
  },
  {
    "text": "to make drawing all the\nlines a little bit simpler.",
    "start": "4170580",
    "end": "4175810"
  },
  {
    "text": "So here, we have the\nC code for fib.c. The corresponding LLVM\nIR looks like this.",
    "start": "4175810",
    "end": "4181949"
  },
  {
    "text": "And as we could guess from\nlooking at the code for fib.c, we have this\nconditional and then",
    "start": "4181950",
    "end": "4189750"
  },
  {
    "text": "two different things\nthat might occur based on whether or not n is less than 2. And so we end up with three\nbasic blocks within the LLVM",
    "start": "4189750",
    "end": "4197040"
  },
  {
    "text": "IR. The first basic block\nchecks event is less than 2 and then branches\nbased on that result.",
    "start": "4197040",
    "end": "4203800"
  },
  {
    "text": "And we've seen how all\nthat works previously. If n happens to be less than\n2, then the consequent--",
    "start": "4203800",
    "end": "4210850"
  },
  {
    "text": "the true case of that branch-- ends up showing up at the end. And all it does is it\nreturns the input value,",
    "start": "4210850",
    "end": "4217160"
  },
  {
    "text": "which is stored in register 0. Otherwise, it's going\nto do some straight line",
    "start": "4217160",
    "end": "4222810"
  },
  {
    "text": "code to compute fib of n\nminus 1 and fib of n minus 2.",
    "start": "4222810",
    "end": "4227960"
  },
  {
    "text": "It will take those return\nvalues, add them together, return that result. That's\nthe end Fibonacci number.",
    "start": "4227960",
    "end": "4235810"
  },
  {
    "text": "So that gets us from\nC code to LLVM IR. Questions about that? ",
    "start": "4235810",
    "end": "4245130"
  },
  {
    "text": "All right, fib n minus 1, fib\nn minus 2, add them, return it. We're good. OK, so one last step.",
    "start": "4245130",
    "end": "4251500"
  },
  {
    "text": "We want to compile LLVM IR\nall the way down to assembly. As I alluded to before,\nroughly speaking,",
    "start": "4251500",
    "end": "4258370"
  },
  {
    "text": "the structure of the LLVM\nIR resembles the structure of the assembly code. There's just extra stuff\nin the assembly code.",
    "start": "4258370",
    "end": "4266270"
  },
  {
    "text": "And so we're going to translate\nthe LLVM IR, more or less, line by line into\nthe assembly code",
    "start": "4266270",
    "end": "4271960"
  },
  {
    "text": "and see where that\nextra stuff shows up. ",
    "start": "4271960",
    "end": "4277600"
  },
  {
    "text": "So at the beginning,\nwe have a function. We were defining a function fib. And in the assembly\ncode, we make",
    "start": "4277600",
    "end": "4283230"
  },
  {
    "text": "sure that fib is a globally\naccessible function using",
    "start": "4283230",
    "end": "4288360"
  },
  {
    "text": "some assembler directives,\nthe globlfib directive. We do an alignment to\nmake sure that function",
    "start": "4288360",
    "end": "4294710"
  },
  {
    "text": "lies in a nice location\nin the instruction memory, and then we declare the symbol\nfib, which just defines where",
    "start": "4294710",
    "end": "4304980"
  },
  {
    "text": "this function lives in memory. All right, let's take a\nlook at this assembly.",
    "start": "4304980",
    "end": "4313380"
  },
  {
    "text": "The next thing that\nwe see here are these two instructions--\na push queue or rbp",
    "start": "4313380",
    "end": "4318390"
  },
  {
    "text": "and a movq of rsp, rbp. Who can tell me what these do?",
    "start": "4318390",
    "end": "4323506"
  },
  {
    "start": "4323506",
    "end": "4332440"
  },
  {
    "text": "Yes? STUDENT: Push the base\n[INAUDIBLE] on the stack, then [INAUDIBLE].",
    "start": "4332440",
    "end": "4338590"
  },
  {
    "text": "TAO SCHARDL: Cool. Does that sound like a familiar\nthing we described earlier",
    "start": "4338590",
    "end": "4343750"
  },
  {
    "text": "in this lecture? STUDENT: the calling convention? TAO SCHARDL: Yep, it's part\nof the calling convention.",
    "start": "4343750",
    "end": "4350650"
  },
  {
    "text": "This is part of the\nfunction prologue. Save off rpb, and then\nset rbp equal to rsp.",
    "start": "4350650",
    "end": "4357640"
  },
  {
    "text": "So we already have a\ncouple extra instructions that weren't in the LLVM IR,\nbut must be in the assembly in order to coordinate everyone.",
    "start": "4357640",
    "end": "4365040"
  },
  {
    "text": "OK, so now, we have\nthese two instructions. We're now going to push a couple\nmore registers onto the stack.",
    "start": "4365040",
    "end": "4372980"
  },
  {
    "text": "So why does the\nassembly do this? Any guesses?",
    "start": "4372980",
    "end": "4378766"
  },
  {
    "text": "Yeah? STUDENT: Callee-saved registers? TAO SCHARDL:\nCallee-saved registers--",
    "start": "4378766",
    "end": "4384140"
  },
  {
    "text": "yes, callee-saved registers. The fib routing,\nwe're guessing, will",
    "start": "4384140",
    "end": "4389560"
  },
  {
    "text": "want to use r14 rbx\nduring this calculation. And so if there are interesting\nvalues in those registers,",
    "start": "4389560",
    "end": "4396310"
  },
  {
    "text": "save them off onto the stack. Presumably, we'll\nrestore them later. ",
    "start": "4396310",
    "end": "4402850"
  },
  {
    "text": "Then we have this move\ninstruction for rdi into rbx.",
    "start": "4402850",
    "end": "4410598"
  },
  {
    "text": "This requires a little\nbit more arcane knowledge, but any guesses as\nto what this is for? ",
    "start": "4410598",
    "end": "4422332"
  },
  {
    "text": "STUDENT: rdi is probably the\nargument to the function. TAO SCHARDL: rdi is the\nargument to the function.",
    "start": "4422332",
    "end": "4428230"
  },
  {
    "text": "Exactly. That's the arcane knowledge. So this is implicit\nfrom the assembly, which",
    "start": "4428230",
    "end": "4434860"
  },
  {
    "text": "is why you either have to\nmemorize that huge chart of GPR",
    "start": "4434860",
    "end": "4441300"
  },
  {
    "text": "C linkage nonsense. But all this operation\ndoes is it takes whatever",
    "start": "4441300",
    "end": "4446650"
  },
  {
    "text": "that argument was, and it's\nsquirrels it away into the rbx register for some purpose that\nwe'll find out about soon.",
    "start": "4446650",
    "end": "4454824"
  },
  {
    "text": " Then we have this instruction,\nand this corresponds",
    "start": "4454825",
    "end": "4461270"
  },
  {
    "text": "to the highlighted\ninstruction on the left, in case that gives any hints. What does this instruction do?",
    "start": "4461270",
    "end": "4469199"
  },
  {
    "text": "STUDENT: [INAUDIBLE]. TAO SCHARDL: Sorry. STUDENT: It calculates whether\nn is small [INAUDIBLE].. TAO SCHARDL: Correct.",
    "start": "4469200",
    "end": "4474930"
  },
  {
    "text": "It evaluates the predicate. It's just going\nto do a comparison between the value of n and\nthe literal value of 2,",
    "start": "4474930",
    "end": "4484780"
  },
  {
    "text": "comparing against 2. So based on the result of that\ncomparison, if you recall,",
    "start": "4484780",
    "end": "4490920"
  },
  {
    "text": "last lecture, the\nresults of a comparison will set some bits in this\nimplicit EFLAGS flags register,",
    "start": "4490920",
    "end": "4498150"
  },
  {
    "text": "or RFLAGS register. And based on the\nsetting of those bits,",
    "start": "4498150",
    "end": "4503520"
  },
  {
    "text": "the various conditional jumps\nthat occur next in the code will have varying behavior.",
    "start": "4503520",
    "end": "4509860"
  },
  {
    "text": "So in case the comparison\nresults to false-- if n is, in fact, greater\nthan or equal to 2--",
    "start": "4509860",
    "end": "4514889"
  },
  {
    "text": "then the next instruction is\njge, will jump to the label",
    "start": "4514890",
    "end": "4520790"
  },
  {
    "text": "LBB0 underscore 1. You can tell already that\nreading assembly is super-fun. ",
    "start": "4520790",
    "end": "4528900"
  },
  {
    "text": "Now that's a conditional jump. And it's possible that the\nsetting of bits in RFLAGS",
    "start": "4528900",
    "end": "4536840"
  },
  {
    "text": "doesn't evaluate true\nfor that condition code.",
    "start": "4536840",
    "end": "4542114"
  },
  {
    "text": "And so it's possible that the\ncode will just fall through pass this jge instruction\nand, instead, execute",
    "start": "4542115",
    "end": "4547400"
  },
  {
    "text": "these operations. And these operations correspond\nto the true side of the LLVM IR branch operation.",
    "start": "4547400",
    "end": "4553429"
  },
  {
    "text": "When n is less than 2,\nthis will move n into rax, and then jumped to\nthe label LBB03.",
    "start": "4553430",
    "end": "4562150"
  },
  {
    "text": "Any guesses as to why\nit moves n into our rax? ",
    "start": "4562150",
    "end": "4571236"
  },
  {
    "text": "Yeah? STUDENT: That's\nthe return value. TAO SCHARDL: That's a\nreturn value-- exactly.",
    "start": "4571236",
    "end": "4576510"
  },
  {
    "text": "If it can return a\nvalue through registers, it will return it through rax. Very good.",
    "start": "4576510",
    "end": "4583570"
  },
  {
    "text": "So now, we see this label LBBO1. That's the label,\nas we saw before, for the false side\nof the LLVM branch.",
    "start": "4583570",
    "end": "4589500"
  },
  {
    "text": " And the first thing in that\nlabel is this operation--",
    "start": "4589500",
    "end": "4595699"
  },
  {
    "text": "leaq minus 1 of rbx rdi. Any guesses as to\nwhat that's for?",
    "start": "4595700",
    "end": "4601119"
  },
  {
    "text": "The corresponding LLVM IR\nis highlighted on the left, by the way. The lea instruction means\nload-effective address.",
    "start": "4601120",
    "end": "4610330"
  },
  {
    "text": "All lea does is an\naddress calculation. But something that\ncompilers really like to do",
    "start": "4610330",
    "end": "4616210"
  },
  {
    "text": "is exploit the lea instruction\nto do simple integer arithmetic as long as that integer\narithmetic fits with the things",
    "start": "4616210",
    "end": "4624340"
  },
  {
    "text": "that lea can actually compute. And so all this\ninstruction is doing is adding negative 1 to rbx.",
    "start": "4624340",
    "end": "4631420"
  },
  {
    "text": "And rbx, as we recall,\nstored the input value of n. And it will store\nthe result into rdi.",
    "start": "4631420",
    "end": "4637600"
  },
  {
    "text": " That's all that this\ninstruction does.",
    "start": "4637600",
    "end": "4644680"
  },
  {
    "text": "So it computes the negative\n1, stores it into rbi. How about this instruction?",
    "start": "4644680",
    "end": "4650090"
  },
  {
    "text": "This one should be easier. STUDENT: For the previous one,\nhow did you get [INAUDIBLE]??",
    "start": "4650090",
    "end": "4658104"
  },
  {
    "text": "I'm familiar with [INAUDIBLE]\nbecause [INAUDIBLE].. But is there no add\nimmediate instruction in x86?",
    "start": "4658104",
    "end": "4666105"
  },
  {
    "text": "TAO SCHARDL: Is there no\nadd immediate instruction? So you can do an add\ninstruction in x86",
    "start": "4666105",
    "end": "4671170"
  },
  {
    "text": "and specify an immediate value. The advantage of\nthis instruction is that you can specify a\ndifferent destination operand.",
    "start": "4671170",
    "end": "4679720"
  },
  {
    "text": "That's why compilers\nlike to use it. More arcane knowledge. I don't blame you if\nthis kind of thing",
    "start": "4679720",
    "end": "4687099"
  },
  {
    "text": "turns you off from reading x86. It certainly turns me\noff from reading x86. ",
    "start": "4687100",
    "end": "4693250"
  },
  {
    "text": "So this instruction should\nbe a little bit easier. Guess as to why it does? Feel free to shout\nit out, because we're running a little short on time.",
    "start": "4693250",
    "end": "4699850"
  },
  {
    "text": "STUDENT: Calls a function. TAO SCHARDL: Calls a function. What function? STUDENT: Call fib. TAO SCHARDL: Call fib, exactly. Great.",
    "start": "4699850",
    "end": "4705820"
  },
  {
    "text": "Then we have this\nmove operation, which moves rax into r14. Any guess as to why we do this?",
    "start": "4705820",
    "end": "4711192"
  },
  {
    "text": " Say it. STUDENT: Get the\nresult of the call.",
    "start": "4711192",
    "end": "4717282"
  },
  {
    "text": "TAO SCHARDL: Get the\nresult of the call. So rax is going to store the\nreturn value of that call.",
    "start": "4717283",
    "end": "4722867"
  },
  {
    "text": "And we're just going to\nsquirrel it away into r14. Question? STUDENT: [INAUDIBLE]",
    "start": "4722867",
    "end": "4727938"
  },
  {
    "text": "TAO SCHARDL: Sorry. STUDENT: It stores [INAUDIBLE]? TAO SCHARDL: It'll actually\nstore the whole return value",
    "start": "4727938",
    "end": "4733820"
  },
  {
    "text": "from the previous call. STUDENT: [INAUDIBLE]",
    "start": "4733820",
    "end": "4739838"
  },
  {
    "text": "TAO SCHARDL: It's part\nof that result. This will be a component in\ncomputing the return value for this call of fib.",
    "start": "4739838",
    "end": "4745349"
  },
  {
    "text": "You're exactly right. But we need to save\noff this result, because we're going to do, as\nwe see, another call to fib.",
    "start": "4745350",
    "end": "4752400"
  },
  {
    "text": "And that's going to clobber rax. Make sense?",
    "start": "4752400",
    "end": "4757640"
  },
  {
    "text": "Cool. So rax stores the\nresult of the function. Save it into r14. Great. ",
    "start": "4757640",
    "end": "4765550"
  },
  {
    "text": "Since we're running\nshort of time, anyone want to tell\nme really quickly what these instructions do?",
    "start": "4765550",
    "end": "4770920"
  },
  {
    "text": "Just a wild guess if you had to. ",
    "start": "4770920",
    "end": "4777561"
  },
  {
    "text": "STUDENT: N minus 2 TAO SCHARDL: n minus 2. Compute n minus 2 by\nthis addition operation.",
    "start": "4777562",
    "end": "4782860"
  },
  {
    "text": "Stash it into rdi. And then you call\nfib on n minus 2.",
    "start": "4782860",
    "end": "4789100"
  },
  {
    "text": "And that will return the results\ninto rax, as we saw before.",
    "start": "4789100",
    "end": "4794740"
  },
  {
    "text": "So now, we do this operation. Add r14 into rax. And this does what?",
    "start": "4794740",
    "end": "4799962"
  },
  {
    "text": " STUDENT: Ends our last\nfunction return to what",
    "start": "4799962",
    "end": "4806765"
  },
  {
    "text": "was going off this one. TAO SCHARDL: Exactly. So rax stores the result of\nthe last function return.",
    "start": "4806766",
    "end": "4812540"
  },
  {
    "text": "Add it into r14, which\nis where we stashed the result of fib of n minus 1. Cool.",
    "start": "4812540",
    "end": "4818028"
  },
  {
    "text": " Then we have a label for\nthe true side of the branch.",
    "start": "4818028",
    "end": "4825490"
  },
  {
    "text": "This is the last pop\nquiz question I'll ask. Pop quiz-- God, I didn't\neven intend that one.",
    "start": "4825490",
    "end": "4832510"
  },
  {
    "text": "Why do we do these\npop operations? ",
    "start": "4832510",
    "end": "4841868"
  },
  {
    "text": "In the front. STUDENT: To restore the register\nbefore exiting the stack frame? TAO SCHARDL: Restore\nthe registers",
    "start": "4841868",
    "end": "4847030"
  },
  {
    "text": "before exiting the\nstack frame-- exactly. In calling convention\nterms, that's called the function epilogue.",
    "start": "4847030",
    "end": "4853990"
  },
  {
    "text": "And then finally, we return. ",
    "start": "4853990",
    "end": "4859460"
  },
  {
    "text": "So that is how we get\nfrom C to assembly. This is just a summary slide\nof everything we covered today.",
    "start": "4859460",
    "end": "4867940"
  },
  {
    "text": "We took the trip from C\nto assembly via LLVM IR. And we saw how we can represent\nthings in a control flow graph",
    "start": "4867940",
    "end": "4875860"
  },
  {
    "text": "as basic blocks connected\nby control flow edges. And then there's\nadditional complexity",
    "start": "4875860",
    "end": "4881080"
  },
  {
    "text": "when you get to the actual\nassembly, mostly to deal with this calling invention. That's all I have for you today.",
    "start": "4881080",
    "end": "4887300"
  },
  {
    "text": "Thanks for your time. ",
    "start": "4887300",
    "end": "4889750"
  }
]