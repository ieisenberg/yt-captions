[
  {
    "start": "0",
    "end": "40000"
  },
  {
    "text": "[SQUEAKING] [RUSTLING] [CLICKING]",
    "start": "0",
    "end": "6776"
  },
  {
    "start": "6776",
    "end": "14425"
  },
  {
    "text": "ERIK DEMAINE: Good morning. AUDIENCE: Morning! ERIK DEMAINE: Welcome to 006,\nIntroduction to Algorithms,",
    "start": "14425",
    "end": "19630"
  },
  {
    "text": "lecture two. I am Erik Demaine and\nI love algorithms. Are you with me?",
    "start": "19630",
    "end": "24640"
  },
  {
    "text": "[APPLAUSE] Yeah. Today, we're not\ndoing algorithms. No, we're doing data structures.",
    "start": "24640",
    "end": "30920"
  },
  {
    "text": "It's OK. There's lots of algorithms\nin each data structure. It's like multiple\nalgorithms for free.",
    "start": "30920",
    "end": "36280"
  },
  {
    "text": "We're going to talk\nabout sequences, and sets, and linked\nlists, and dynamic arrays.",
    "start": "36280",
    "end": "42309"
  },
  {
    "start": "40000",
    "end": "480000"
  },
  {
    "text": "Fairly simple data\nstructures today. This is the beginning of\nseveral data structures we'll be talking about\nin the next few lectures.",
    "start": "42310",
    "end": "48920"
  },
  {
    "text": "But before we actually\nstart with one, let me tell you/remind remind\nyou of the difference between",
    "start": "48920",
    "end": "57520"
  },
  {
    "text": "an interface-- which\nyou might call an API if you're a programmer, or\nan ADT if you're an ancient",
    "start": "57520",
    "end": "63010"
  },
  {
    "text": "algorithms person like me-- versus a data structure. ",
    "start": "63010",
    "end": "71450"
  },
  {
    "text": "These are useful distinctions. The idea is that an interface\nsays what you want to do.",
    "start": "71450",
    "end": "78490"
  },
  {
    "text": "A data structure\nsays how you do it. So you might call\nthis a specification. ",
    "start": "78490",
    "end": "85600"
  },
  {
    "text": "And in the context\nof data structures, we're trying to store some data. So the interface will specify\nwhat data you can store,",
    "start": "85600",
    "end": "95579"
  },
  {
    "text": "whereas the data\nstructure will give you an actual representation and\ntell you how to store it.",
    "start": "95580",
    "end": "100690"
  },
  {
    "start": "100690",
    "end": "108140"
  },
  {
    "text": "This is pretty boring. Just storing data\nis really easy. You just throw it in\na file or something.",
    "start": "108140",
    "end": "114650"
  },
  {
    "text": "What makes it interesting is\nhaving operations on that data.",
    "start": "114650",
    "end": "119930"
  },
  {
    "text": "In the interface, you specify\nwhat the operations do,",
    "start": "119930",
    "end": "125630"
  },
  {
    "text": "what operations are\nsupported, and in some sense,",
    "start": "125630",
    "end": "136364"
  },
  {
    "text": "what they mean. ",
    "start": "136365",
    "end": "142720"
  },
  {
    "text": "And the data structure\nactually gives you algorithms-- this is where the\nalgorithms come in--",
    "start": "142720",
    "end": "148390"
  },
  {
    "text": "for how to support\nthose operations. ",
    "start": "148390",
    "end": "162870"
  },
  {
    "text": "All right. In this class, we're going to\nfocus on two main interfaces",
    "start": "162870",
    "end": "171510"
  },
  {
    "text": "and various special of them. The idea is to separate what you\nwant to do versus how to do it.",
    "start": "171510",
    "end": "178050"
  },
  {
    "text": "Because-- you can think of\nthis as the problem statement. Yesterday-- or, last class,\nJason talked about problems",
    "start": "178050",
    "end": "186870"
  },
  {
    "text": "and defined what a problem was\nversus algorithmic solutions to the problem.",
    "start": "186870",
    "end": "193000"
  },
  {
    "text": "And this is the analogous notion\nfor data structures, where we want to maintain\nsome data according",
    "start": "193000",
    "end": "198540"
  },
  {
    "text": "to various operations. The same problem can be\nsolved by many different data",
    "start": "198540",
    "end": "203819"
  },
  {
    "text": "structures. And we're going to see that. And different data\nstructures are going to have different advantages. They might support some\noperations faster than others.",
    "start": "203820",
    "end": "210390"
  },
  {
    "text": "And depending on\nwhat you actually use those data\nstructures for, you choose the right data structure.",
    "start": "210390",
    "end": "215760"
  },
  {
    "text": "But you can maintain\nthe same interface. We're going to think\nabout two data structures. One is called a set and\none is called a sequence.",
    "start": "215760",
    "end": "225780"
  },
  {
    "text": "These are highly loaded terms. Set means something\nto a mathematician. It means something else\nto a Python programmer.",
    "start": "225780",
    "end": "231300"
  },
  {
    "text": "Sequence, similarly. I guess there's not a Python\nsequence data type built in.",
    "start": "231300",
    "end": "238290"
  },
  {
    "text": "The idea is, we want\nto store n things. The things will be\nfairly arbitrary.",
    "start": "238290",
    "end": "243540"
  },
  {
    "text": "Think of them as\nintegers or strings. And on the one hand, we\ncare about their values.",
    "start": "243540",
    "end": "250110"
  },
  {
    "text": "And maybe we want to\nmaintain them in sorted order and be able to search\nfor a given value, which",
    "start": "250110",
    "end": "255349"
  },
  {
    "text": "we'll call a key. And on the other hand, we\ncare about representing a particular sequence\nthat we care about.",
    "start": "255350",
    "end": "262980"
  },
  {
    "text": "Maybe we want to represent\nthe numbers 5, 2, 9, 7 in that order and store that.",
    "start": "262980",
    "end": "270060"
  },
  {
    "text": "In Python, you could store\nthat in a list, for example. And it will keep\ntrack of that order. And this is the first item,\nthe second item, the last item.",
    "start": "270060",
    "end": "279030"
  },
  {
    "text": "Today, we're going to be\nfocusing on this sequence data structure, although\nat the end, I'll mention the interface for sets.",
    "start": "279030",
    "end": "286349"
  },
  {
    "text": "But we're going to be actually\nsolving sequences today. And in the next\nseveral lectures, we'll be bouncing back\nand forth between these.",
    "start": "286350",
    "end": "292230"
  },
  {
    "text": "They're closely related. Pretty abstract at the moment.",
    "start": "292230",
    "end": "297250"
  },
  {
    "text": "On the other hand, we're\ngoing to have two main-- ",
    "start": "297250",
    "end": "303080"
  },
  {
    "text": "let's call them data\nstructure tools or approaches. ",
    "start": "303080",
    "end": "313980"
  },
  {
    "text": "One is arrays and the\nother is pointers--",
    "start": "313980",
    "end": "321200"
  },
  {
    "text": "pointer-based or\nlinked data structures. You may have seen these.",
    "start": "321200",
    "end": "326810"
  },
  {
    "text": "They're used a lot in\nprogramming, of course. But we're going to see\nboth of these today. I'll come back to this sort\nof highlight in a moment.",
    "start": "326810",
    "end": "334740"
  },
  {
    "text": "Let's jump into the sequence\ninterface, which I conveniently have part of here.",
    "start": "334740",
    "end": "341610"
  },
  {
    "text": "There's a few different\nlevels of sequences that we might care about. I'm going to start with the\nstatic sequence interface.",
    "start": "341610",
    "end": "347810"
  },
  {
    "text": "This is where the number\nof items doesn't change,",
    "start": "347810",
    "end": "354160"
  },
  {
    "text": "though the actual items might. Here, we have n items. I'm going to label them x 0\nto x n minus 1, as in Python.",
    "start": "354160",
    "end": "362389"
  },
  {
    "text": "So the number of items is n. And the operations I want\nto support are build, length, iteration, get, and set.",
    "start": "362390",
    "end": "370790"
  },
  {
    "text": "So what do these do? Build is how you get started. To build a data structure\nin this interface,",
    "start": "370790",
    "end": "377060"
  },
  {
    "text": "you call build of x. Exactly how you specify x isn't\ntoo important, but the idea is,",
    "start": "377060",
    "end": "382790"
  },
  {
    "text": "I give you some\nitems in some order. In Python, this\nwould be an iterable. I'm going to want to\nalso know its length.",
    "start": "382790",
    "end": "389569"
  },
  {
    "text": "And I want to make a new\ndata structure of size and a new static\nsequence of size n that has those\nitems in that order.",
    "start": "389570",
    "end": "396220"
  },
  {
    "text": "So that's how you\nbuild one of these. Because somehow, we\nhave to specify n to this data structure,\nbecause n is not",
    "start": "396220",
    "end": "402037"
  },
  {
    "text": "going to be allowed to change. I'm going to give\nyou a length method. ",
    "start": "402037",
    "end": "409300"
  },
  {
    "text": "Methods are the\nobject-oriented way of thinking of operations\nthat your interface supports.",
    "start": "409300",
    "end": "417850"
  },
  {
    "text": "Length will just return\nthis fixed value n. Iter sequence. This is the sense in which we\nwant to maintain the order.",
    "start": "417850",
    "end": "423250"
  },
  {
    "text": "I want to be able to output\nx 0 through x n minus 1 in the sequence order,\nin that specified order",
    "start": "423250",
    "end": "428949"
  },
  {
    "text": "that they were built in\nor that it was changed to. This is going to iterate\nthrough all of the items.",
    "start": "428950",
    "end": "437470"
  },
  {
    "text": "So it's going to take at least\nlinear time to output that. But more interesting is, we\ncan dynamically access anywhere",
    "start": "437470",
    "end": "443770"
  },
  {
    "text": "in the middle of the sequence. We can get the ith item,\nx i, given the value i,",
    "start": "443770",
    "end": "449320"
  },
  {
    "text": "and we can change x i\nto a given new item. OK.",
    "start": "449320",
    "end": "454430"
  },
  {
    "text": "So that's called\nget_at and set_at. Pretty straightforward. This should remind you\nvery closely of something--",
    "start": "454430",
    "end": "462639"
  },
  {
    "text": "a data structure. So this is an interface. This is something I\nmight want to solve. But what is the\nobvious data structure",
    "start": "462640",
    "end": "468770"
  },
  {
    "text": "that solves this problem? Yeah? AUDIENCE: A list. ERIK DEMAINE: A list. In Python, it's called a list.",
    "start": "468770",
    "end": "474530"
  },
  {
    "text": "I prefer to call it an\narray, but to each their own. We're going to use \"list.\" List could mean many\nthings, but the solution",
    "start": "474530",
    "end": "487730"
  },
  {
    "start": "480000",
    "end": "870000"
  },
  {
    "text": "to this interface problem-- the natural solution-- is\nwhat I'll call a static array.",
    "start": "487730",
    "end": "500330"
  },
  {
    "text": " Jason mentioned\nthese in lecture one.",
    "start": "500330",
    "end": "508613"
  },
  {
    "text": "It's a little\ntricky because there are no static arrays in Python. There are only\ndynamic arrays, which is something we will get to.",
    "start": "508613",
    "end": "514080"
  },
  {
    "text": "But I want to talk about, what\nis a static array, really? And this relates\nto our notion of--",
    "start": "514080",
    "end": "522479"
  },
  {
    "text": "our model of computation,\nJason also talked about, which we call the\nword RAM, remember?",
    "start": "522480",
    "end": "529380"
  },
  {
    "start": "529380",
    "end": "538580"
  },
  {
    "text": "The idea, in word RAM,\nis that your memory is an array of w-bit words.",
    "start": "538580",
    "end": "548362"
  },
  {
    "text": "This is a bit circular. I'm going to define an array\nin terms of the word RAM, which is defined in terms of arrays. But I think you know the idea.",
    "start": "548362",
    "end": "558780"
  },
  {
    "text": "So we have a big memory which\ngoes off to infinity, maybe. It's divided into words.",
    "start": "558780",
    "end": "566390"
  },
  {
    "text": "Each word here is w bits long. This is word 0, word 1, word 2.",
    "start": "566390",
    "end": "572240"
  },
  {
    "text": "And you can access\nthis array randomly-- random access memory. So I can give you the number\n5 and get 0 1, 2, 3, 4,",
    "start": "572240",
    "end": "581210"
  },
  {
    "text": "5, the fifth word in this RAM. That's how actual memories work.",
    "start": "581210",
    "end": "589160"
  },
  {
    "text": "You can access any of\nthem equally quickly. OK, so that's memory.",
    "start": "589160",
    "end": "597300"
  },
  {
    "text": "And so what we want to do\nis, when we say an array,",
    "start": "597300",
    "end": "603200"
  },
  {
    "text": "we want this to be a\nconsecutive chunk of memory.",
    "start": "603200",
    "end": "611150"
  },
  {
    "start": "611150",
    "end": "616460"
  },
  {
    "text": "Let me get color. ",
    "start": "616460",
    "end": "622180"
  },
  {
    "text": "Let's say I have an array\nof size 4 and it lives here. ",
    "start": "622180",
    "end": "629690"
  },
  {
    "text": "Jason can't spell,\nbut I can't count. So I think that's four. We've got-- so the array starts\nhere and it ends over here.",
    "start": "629690",
    "end": "640310"
  },
  {
    "text": "It's of size 4. And it's consecutive,\nwhich means,",
    "start": "640310",
    "end": "645450"
  },
  {
    "text": "if I want to access\nthe array at position--",
    "start": "645450",
    "end": "652920"
  },
  {
    "text": "at index i, then this\nis the same thing as accessing my memory\narray at position--",
    "start": "652920",
    "end": "663449"
  },
  {
    "text": "wherever the array\nstarts, which I'll call the address of the array--",
    "start": "663450",
    "end": "670440"
  },
  {
    "text": "in Python, this is ID of array-- plus i.",
    "start": "670440",
    "end": "676269"
  },
  {
    "text": "OK. This is just simple\noffset arithmetic. If I want to know the\n0th item of the array,",
    "start": "676270",
    "end": "681509"
  },
  {
    "text": "it's right here,\nwhere it starts. The first item is\none after that. The second item\nis one after that.",
    "start": "681510",
    "end": "686620"
  },
  {
    "text": "So as long as I store my\narray consecutively in memory, I can access the array\nin constant time.",
    "start": "686620",
    "end": "693690"
  },
  {
    "text": "I can do get_at and\nset_at as quickly as I can randomly access\nthe memory and get value--",
    "start": "693690",
    "end": "700290"
  },
  {
    "text": "or set a value-- which we're\nassuming is constant time. ",
    "start": "700290",
    "end": "710870"
  },
  {
    "text": "My array access\nis constant time. ",
    "start": "710870",
    "end": "717879"
  },
  {
    "text": "This is what allows\na static array to actually solve this problem\nin constant time per get_at",
    "start": "717880",
    "end": "726310"
  },
  {
    "text": "and set_at operation. This may seem simple, but we're\nreally going to need this model",
    "start": "726310",
    "end": "732610"
  },
  {
    "text": "and really rely on this model\nincreasingly as we get to more interesting data structures. This is the first time\nwe're actually needing it.",
    "start": "732610",
    "end": "740890"
  },
  {
    "text": "Let's see. Length is also constant time. We're just going to\nstore that number n, along with its address.",
    "start": "740890",
    "end": "749230"
  },
  {
    "text": "And build is going\nto take linear time. Iteration will take linear time.",
    "start": "749230",
    "end": "754690"
  },
  {
    "start": "754690",
    "end": "763350"
  },
  {
    "text": "Pretty straightforward. I guess one thing\nhere, when defining build, I need to introduce\na little bit more",
    "start": "763350",
    "end": "769950"
  },
  {
    "text": "of our model of\ncomputation, which is, how do you create an\narray in the beginning?",
    "start": "769950",
    "end": "774980"
  },
  {
    "text": "I claim I could do\nit in linear time, but that's just\npart of the model. This is called the\nmemory allocation model.",
    "start": "774980",
    "end": "781370"
  },
  {
    "start": "781370",
    "end": "789450"
  },
  {
    "text": "There are a few\npossible choices here, but the cleanest one\nis just to assume that you can allocate an array\nof size n in theta n time.",
    "start": "789450",
    "end": "805630"
  },
  {
    "text": "So it takes linear time to\nmake an array of size n. You could imagine\nthis being constant.",
    "start": "805630",
    "end": "810760"
  },
  {
    "text": "It doesn't really matter much. But it does take work. And in particular, if you just\nallocate some chunk of memory,",
    "start": "810760",
    "end": "816540"
  },
  {
    "text": "you have no idea whether\nit's initialized. So initializing that array\nto 0s will cost linear time. It won't really matter,\nconstant versus linear,",
    "start": "816540",
    "end": "823380"
  },
  {
    "text": "but a nice side effect of\nthis model is that space-- if you're just\nallocating arrays,",
    "start": "823380",
    "end": "830342"
  },
  {
    "text": "the amount of space you use\nis, at most, the amount of time you use. Or, I guess, big O of that.",
    "start": "830342",
    "end": "837240"
  },
  {
    "text": "So that's a nice feature. It's pretty weird\nif you imagine-- it's unrealistic to imagine you\ncan allocate an array that's",
    "start": "837240",
    "end": "844889"
  },
  {
    "text": "infinite size and then just\nuse a few items out of it. That won't give you a\ngood data structure.",
    "start": "844890",
    "end": "850540"
  },
  {
    "text": "So we'll assume it costs\nto allocate memory. OK, great. We solved the sequence problem.",
    "start": "850540",
    "end": "856890"
  },
  {
    "text": "Very simple, kind of boring. These are optimal running times. Now, let's make it interesting--\nmake sure I didn't miss",
    "start": "856890",
    "end": "864780"
  },
  {
    "text": "anything-- and talk about-- oh,\nthere is one thing I want",
    "start": "864780",
    "end": "872460"
  },
  {
    "start": "870000",
    "end": "1020000"
  },
  {
    "text": "to talk about in the word RAM. A side effect of this assumption\nthat array access should",
    "start": "872460",
    "end": "879270"
  },
  {
    "text": "take constant time, and that\naccessing these positions in my memory should\ntake constant time,",
    "start": "879270",
    "end": "885660"
  },
  {
    "text": "is that we need to assume\nw is at least log n or so.",
    "start": "885660",
    "end": "895410"
  },
  {
    "text": " w, remember, is the\nmachine word size.",
    "start": "895410",
    "end": "900880"
  },
  {
    "text": "In real computers,\nthis is currently 64-- or 256, in some\nbizarre instructions.",
    "start": "900880",
    "end": "908420"
  },
  {
    "text": "But we don't usually\nthink of the machine as getting bigger over time, but\nyou should think of the machine",
    "start": "908420",
    "end": "913663"
  },
  {
    "text": "as getting bigger over time. This is a statement\nthat says, the word size has to grow with n.",
    "start": "913663",
    "end": "919149"
  },
  {
    "text": "It might faster\nthan log n, but it has to grow at least\nas fast as log n. Why do I say that? Because if I have n things\nthat I'm dealing with-- n,",
    "start": "919150",
    "end": "926560"
  },
  {
    "text": "here, is the problem size. Maybe it's the array I'm\ntrying to store-- whatever. If I'm having to deal with\nn things in my memory,",
    "start": "926560",
    "end": "933610"
  },
  {
    "text": "at the very least, I need\nto be able to address them. I should be able to\nsay, give me the ith one and represent that\nnumber i in a word.",
    "start": "933610",
    "end": "940570"
  },
  {
    "text": "Otherwise-- because the machine\nis designed to only work with w-bit words\nin constant time, they'll want to be\nable to access the ith",
    "start": "940570",
    "end": "946600"
  },
  {
    "text": "word in constant time,\nI need a word size that's at least log n just\nto address that and n things in my input.",
    "start": "946600",
    "end": "952798"
  },
  {
    "text": "So this is a totally\nreasonable assumption. It may seem weird because\nyou think of a real machine as having constant\nsize, but a real machine",
    "start": "952798",
    "end": "959199"
  },
  {
    "text": "has constant size RAM, also. My machine has 24 gigs\nof RAM, or whatever.",
    "start": "959200",
    "end": "964450"
  },
  {
    "text": "That laptop has 8. But you don't think of\nthat as changing over time. But of course, if you want\nit to process a larger input,",
    "start": "964450",
    "end": "970900"
  },
  {
    "text": "you would buy more RAM. So eventually, when our\nn's get really, really big,",
    "start": "970900",
    "end": "976330"
  },
  {
    "text": "we're going to have\nto increase w just so we can address that RAM. That's the intuition here.",
    "start": "976330",
    "end": "982350"
  },
  {
    "text": "But this is a way to\nbridge reality, which are fixed machines, with theory.",
    "start": "982350",
    "end": "987509"
  },
  {
    "text": "In. Algorithms, we care about\nscalability for very large n. We want to know what that\ngrowth function is and ignore",
    "start": "987510",
    "end": "993320"
  },
  {
    "text": "the lead constant factor. That's what asymptotic\nnotation is all about. And for that, we need a notion\nof word size also changing",
    "start": "993320",
    "end": "1000699"
  },
  {
    "text": "in this asymptotic way. All right. That would be more\nimportant next week,",
    "start": "1000700",
    "end": "1006220"
  },
  {
    "text": "when we talk about\nhashing and why hashing is a reasonable thing to do.",
    "start": "1006220",
    "end": "1011880"
  },
  {
    "text": "But let's move on to\ndynamic sequences, which is",
    "start": "1011880",
    "end": "1017480"
  },
  {
    "text": "where things get interesting.  I have the update here.",
    "start": "1017480",
    "end": "1024309"
  },
  {
    "text": "We start with static sequences. All of these\noperations are still",
    "start": "1024310",
    "end": "1029805"
  },
  {
    "text": "something we want to support\nin a dynamic sequence, but we add two\ndynamic operations--",
    "start": "1029805",
    "end": "1034990"
  },
  {
    "text": "somewhat controversial\noperations, very exciting. I want to be able to insert\nin the middle of my sequence",
    "start": "1034990",
    "end": "1041530"
  },
  {
    "text": "and I want to be able to delete\nfrom the middle of my sequence. Here's my sequence, which I'm\ngoing to think of in a picture.",
    "start": "1041530",
    "end": "1048735"
  },
  {
    "text": "I'm going to draw\nit as an array. But it's stored\nhowever it's stored. We don't know. This is an interface,\nnot an implementation.",
    "start": "1048735",
    "end": "1054530"
  },
  {
    "text": "So we have x 0, x 1, x 2, x 3. ",
    "start": "1054530",
    "end": "1061840"
  },
  {
    "text": "And let's say I\ninsert at position 2.",
    "start": "1061840",
    "end": "1066940"
  },
  {
    "text": "Position 2 is here. So I come in with\nmy new x, and I would like x to be the\nnew x 2, but I don't",
    "start": "1066940",
    "end": "1073900"
  },
  {
    "text": "want to lose any information. If I did set_at 2, then I\nwould erase this and replace it with x.",
    "start": "1073900",
    "end": "1079433"
  },
  {
    "text": "But I want to do insert_at,\nwhich means all of these guys, conceptually, are\ngoing to shift over by 1 in terms of their indices.",
    "start": "1079433",
    "end": "1085750"
  },
  {
    "text": "Then, I would get this\npicture that's one bigger. ",
    "start": "1085750",
    "end": "1093510"
  },
  {
    "text": "And now I've got the new x. I've got what was the\nold x 2, which I don't--",
    "start": "1093510",
    "end": "1098840"
  },
  {
    "text": "I hesitate to call x 2 because\nthat's its old name, not its new name. I'm going to draw arrows to\nsay, these guys get copied over.",
    "start": "1098840",
    "end": "1107620"
  },
  {
    "text": "These ones are\ndefinitely unchanged. Our new x 2, which\nprime is x This",
    "start": "1107620",
    "end": "1114220"
  },
  {
    "text": "is x3 prime, 4 prime, and so on. I want to be careful here--\nand of course, the new n prime",
    "start": "1114220",
    "end": "1122770"
  },
  {
    "text": "is n plus 1.  I want to be careful about the\nlabeling, because the key--",
    "start": "1122770",
    "end": "1129070"
  },
  {
    "text": "what makes insert_at interesting\nis that, later, when I call get_at, it's with\nthe new indexing.",
    "start": "1129070",
    "end": "1134680"
  },
  {
    "text": "So previously, if I did get_at\nat 2, I would get this value. And afterwards, if\nI did get_at at 2,",
    "start": "1134680",
    "end": "1141427"
  },
  {
    "text": "I would get the new value. If I did get_at\nat 3 down here, I would get the value\nthat used to be X 2.",
    "start": "1141427",
    "end": "1148280"
  },
  {
    "text": "That's maybe hard to track. But this is a conceptually\nvery useful thing to do, especially when\nyou're inserting or deleting",
    "start": "1148280",
    "end": "1156340"
  },
  {
    "text": "at the ends. So we're going to define, in\nparticular, insert and delete",
    "start": "1156340",
    "end": "1166490"
  },
  {
    "text": "first and last. ",
    "start": "1166490",
    "end": "1173270"
  },
  {
    "text": "These are sometimes given--\nif you have an insert, it has an x.",
    "start": "1173270",
    "end": "1179600"
  },
  {
    "text": "If you do a delete,\nit has no argument. This means insert_at the\nbeginning of the array, which",
    "start": "1179600",
    "end": "1186530"
  },
  {
    "text": "would be like adding it here. And insert_last means\nadding it on here.",
    "start": "1186530",
    "end": "1192110"
  },
  {
    "text": "insert_last doesn't\nchange the indices of any of the old items. That's a nice feature\nof insert_last. Insert-first\nchanges all of them.",
    "start": "1192110",
    "end": "1199460"
  },
  {
    "text": "They all get incremented by 1. And we're also interested\nin the similar things here.",
    "start": "1199460",
    "end": "1205520"
  },
  {
    "text": "We could do get-first or\n-last or set-first or -last,",
    "start": "1205520",
    "end": "1222550"
  },
  {
    "text": "which are the obvious special\ncases of get_at and set_at. Now, these special\ncases are particularly",
    "start": "1222550",
    "end": "1227560"
  },
  {
    "text": "interesting in an\nalgorithms context. If you were a mathematician,\nyou would say, well, why do I even bother?",
    "start": "1227560",
    "end": "1232630"
  },
  {
    "text": "This is just shorthand for a\nparticular call to get or set. But what makes it interesting\nfrom a data structures",
    "start": "1232630",
    "end": "1240340"
  },
  {
    "text": "perspective is that we care\nabout algorithms for supporting these operations. And maybe, the\nalgorithm for supporting",
    "start": "1240340",
    "end": "1246670"
  },
  {
    "text": "get-first or set-first, or in\nparticular, insert-first or insert_last, might\nbe more efficient.",
    "start": "1246670",
    "end": "1252910"
  },
  {
    "text": "Maybe we can solve\nthis problem better than we can solve insert_at. So while, ideally,\nwe could solve",
    "start": "1252910",
    "end": "1258370"
  },
  {
    "text": "the entire dynamic sequence\ninterface constant time preparation, that's\nnot actually possible. You can prove that.",
    "start": "1258370",
    "end": "1264490"
  },
  {
    "text": "But special cases of\nit-- where we're just inserting and leading from\nthe end, say-- we can do that.",
    "start": "1264490",
    "end": "1270190"
  },
  {
    "text": "That's why it's interesting to\nintroduce special cases that we care about.",
    "start": "1270190",
    "end": "1276180"
  },
  {
    "text": "Cool. That's the definition of the\ndynamic sequence interface. Now, we're going to\nactually solve it. ",
    "start": "1276180",
    "end": "1287830"
  },
  {
    "text": "Our first data structure for\nthis is called linked lists. You've taken, probably-- you've\nprobably seen linked lists",
    "start": "1287830",
    "end": "1299810"
  },
  {
    "start": "1290000",
    "end": "1505000"
  },
  {
    "text": "before at some point. But the main new\npart here is, we're going to actually analyze them\nand see how efficiently they",
    "start": "1299810",
    "end": "1306650"
  },
  {
    "text": "implement all of these\noperations we might care about. First, review. What is a linked list?",
    "start": "1306650",
    "end": "1312620"
  },
  {
    "text": "We store our items\nin a bunch of nodes.",
    "start": "1312620",
    "end": "1320910"
  },
  {
    "start": "1320910",
    "end": "1332470"
  },
  {
    "text": "Each node has an item\nin it and a next field.",
    "start": "1332470",
    "end": "1340150"
  },
  {
    "text": "So you can think of\nthese as class objects with two class variables, the\nitem and the next pointer.",
    "start": "1340150",
    "end": "1348340"
  },
  {
    "text": "And we assemble those into\nthis kind of structure where we store-- in the item fields, we're going\nto store the actual values",
    "start": "1348340",
    "end": "1355929"
  },
  {
    "text": "that we want to represent\nin our sequence, x 0 through x n minus 1, in order.",
    "start": "1355930",
    "end": "1361690"
  },
  {
    "text": "And then we're going to use\nthe next pointers to link these all together in that order. So the next pointers are what\nactually give us the order.",
    "start": "1361690",
    "end": "1368980"
  },
  {
    "text": "And in addition, we're going\nto keep track of what's called the head of the list. The data structure is going\nto be represented by a head.",
    "start": "1368980",
    "end": "1376720"
  },
  {
    "text": "If you wanted to, you\ncould also store length. This could be the\ndata structure itself.",
    "start": "1376720",
    "end": "1382179"
  },
  {
    "text": " And it's pointing to all of\nthese types of data structures.",
    "start": "1382180",
    "end": "1388010"
  },
  {
    "text": "Notice, we've just seen an\narray-based data structure, which is just a static\narray, and we've",
    "start": "1388010",
    "end": "1394340"
  },
  {
    "text": "seen a pointer-based\ndata structure. And we're relying on the fact\nthat pointers can be stored",
    "start": "1394340",
    "end": "1402179"
  },
  {
    "text": "in a single word, which means\nwe can de-reference them-- we can see what's on the\nother side of the pointer--",
    "start": "1402180",
    "end": "1407640"
  },
  {
    "text": "in constant time in\nour word RAM model. In reality, each of these\nnodes is stored somewhere",
    "start": "1407640",
    "end": "1414330"
  },
  {
    "text": "in the array of the computer. So maybe each one\nis two words long,",
    "start": "1414330",
    "end": "1420420"
  },
  {
    "text": "so maybe one node is--\nthe first node is here. Maybe the second node is here.",
    "start": "1420420",
    "end": "1425580"
  },
  {
    "text": "The third node is here. They're in some arbitrary order. We're using this fact, that we\ncan allocate an array of size n",
    "start": "1425580",
    "end": "1434190"
  },
  {
    "text": "in linear time--\nin this case, we're going to have arrays of size 2. We can just say, oh, please\ngive me a new array of size 2.",
    "start": "1434190",
    "end": "1440800"
  },
  {
    "text": "And that will make us\none of these nodes.",
    "start": "1440800",
    "end": "1445830"
  },
  {
    "text": "And then we're storing pointers. Pointers are just indices\ninto the giant memory array.",
    "start": "1445830",
    "end": "1451380"
  },
  {
    "text": "They're just, what is the\naddress of this little array? If you've ever wondered how\npointers are implemented,",
    "start": "1451380",
    "end": "1457170"
  },
  {
    "text": "they're just numbers that\nsay where, in memory, is this thing over here? And in memory, they're\nin arbitrary order.",
    "start": "1457170",
    "end": "1463950"
  },
  {
    "text": "This is really nice because\nit's easy to manipulate the order of a linked\nlist without actually physically moving nodes around,\nwhereas arrays are problematic.",
    "start": "1463950",
    "end": "1474900"
  },
  {
    "text": "Maybe it's worth mentioning. Let's start analyzing things. So we care about these\ndynamic sequence operations.",
    "start": "1474900",
    "end": "1482970"
  },
  {
    "text": "And we could try to apply\nit to the static array data structure, or we could try\nto implement these operations",
    "start": "1482970",
    "end": "1492600"
  },
  {
    "text": "in a static array. It's possible, just not\ngoing to be very good.",
    "start": "1492600",
    "end": "1497730"
  },
  {
    "text": "And we can try to implement\nit with linked lists. And it's also not\ngoing to be that great.",
    "start": "1497730",
    "end": "1502990"
  },
  {
    "text": "Let's go over here. ",
    "start": "1502990",
    "end": "1511110"
  },
  {
    "start": "1505000",
    "end": "1570000"
  },
  {
    "text": "Our goal is the\nnext data structure, which is dynamic arrays. But linked lists and\nstatic arrays each",
    "start": "1511110",
    "end": "1516690"
  },
  {
    "text": "have their advantages. ",
    "start": "1516690",
    "end": "1522560"
  },
  {
    "text": "Let's first analyze dynamic\nsequence operations,",
    "start": "1522560",
    "end": "1533730"
  },
  {
    "text": "first on a static array\nand then on a linked list.",
    "start": "1533730",
    "end": "1541440"
  },
  {
    "start": "1541440",
    "end": "1546889"
  },
  {
    "text": "On a static array,\nI think you all see, if I try to insert at the\nbeginning of the static array--",
    "start": "1546890",
    "end": "1554210"
  },
  {
    "text": "that's kind of the worst case. If I insert first, then\neverybody has to shift over.",
    "start": "1554210",
    "end": "1559970"
  },
  {
    "text": "If I'm going to\nmaintain this invariant, that the ith item in\nthe array represents-- I guess I didn't write\nit anywhere here.",
    "start": "1559970",
    "end": "1568880"
  },
  {
    "text": "Maybe here. ",
    "start": "1568880",
    "end": "1574610"
  },
  {
    "text": "Static array. We're going to maintain\nthis invariant that a of i represents x i. ",
    "start": "1574610",
    "end": "1582050"
  },
  {
    "text": "If I want to maintain\nthat at all times, when I insert a new\nthing in the front, because the indices of all\nthe previous items change,",
    "start": "1582050",
    "end": "1587870"
  },
  {
    "text": "I have to spend time\nto copy those over. You can do it in linear\ntime, but no better. ",
    "start": "1587870",
    "end": "1596030"
  },
  {
    "text": "Static array. Insert and delete anywhere\ncosts theta n time--",
    "start": "1596030",
    "end": "1613000"
  },
  {
    "text": " actually, for two reasons.",
    "start": "1613000",
    "end": "1618670"
  },
  {
    "text": "Reason number one is that,\nif we're near the front, then we have to do shifting.",
    "start": "1618670",
    "end": "1625365"
  },
  {
    "text": " What about insert or delete\nthe last element of an array?",
    "start": "1625365",
    "end": "1633640"
  },
  {
    "text": "Is that any easier? Because then, if I insert\nthe very last element, none of the indices change.",
    "start": "1633640",
    "end": "1639049"
  },
  {
    "text": "I'm just adding a new element. ",
    "start": "1639050",
    "end": "1644158"
  },
  {
    "text": "So I don't have to do shifting.  So can I do insert and\ndelete last in constant time",
    "start": "1644158",
    "end": "1651830"
  },
  {
    "text": "in a static array? ",
    "start": "1651830",
    "end": "1656919"
  },
  {
    "text": "Yeah? AUDIENCE: No, because\nthe size is constant. ERIK DEMAINE: No, because\nthe size is constant.",
    "start": "1656920",
    "end": "1662053"
  },
  {
    "text": "So our model is that\nremember allocation model is that we can allocate a\nstatic array of size em",
    "start": "1662053",
    "end": "1670340"
  },
  {
    "text": "but it's just a size\nn I can't just say please make it bigger\nby 1 I need I need space",
    "start": "1670340",
    "end": "1675500"
  },
  {
    "text": "to store this extra element. And if you think about where\nthings are in memory, when you call to this\nmemory allocator, which",
    "start": "1675500",
    "end": "1682195"
  },
  {
    "text": "is part of your\noperating system, you say, please give\nme a chunk of memory.",
    "start": "1682195",
    "end": "1688070"
  },
  {
    "text": "It's going to place them in\nvarious places in memory, and some of them might\nbe next to each other. So if I try to grow\nthis array by 1,",
    "start": "1688070",
    "end": "1694665"
  },
  {
    "text": "there might already\nbe something there. And that's not possible\nwithout first shifting. So even though, in\nthe array, I don't",
    "start": "1694665",
    "end": "1700100"
  },
  {
    "text": "have to do any\nshifting, in memory, I might have to do shifting. And that's outside the model. So we're going to stick\nto this model of just--",
    "start": "1700100",
    "end": "1706280"
  },
  {
    "text": "you can allocate memory. You can also de-allocate memory,\njust to keep space usage small.",
    "start": "1706280",
    "end": "1711530"
  },
  {
    "text": "But the only way\nto get more space is to ask for a new array. And that new array won't be\ncontiguous to your old one.",
    "start": "1711530",
    "end": "1719220"
  },
  {
    "text": "Question? AUDIENCE: [INAUDIBLE] ",
    "start": "1719220",
    "end": "1726455"
  },
  {
    "text": "ERIK DEMAINE: What\nis the dynamic array will be the next topic, so\nmaybe we'll come back to that. Yeah?",
    "start": "1726455",
    "end": "1732399"
  },
  {
    "text": "In a static array, you're just\nnot allowed to make it bigger. And so you have to\nallocate a new array, which",
    "start": "1732400",
    "end": "1740500"
  },
  {
    "text": "we say takes linear time. Even if allocating the new\narray didn't take linear time, you have to copy all\nthe elements over",
    "start": "1740500",
    "end": "1747303"
  },
  {
    "text": "from the old array\nto the new one. Then you can throw\naway the old one.",
    "start": "1747303",
    "end": "1752470"
  },
  {
    "text": "Just the copying\nfrom an array of size n to an array of size n plus\n1, that will take linear time.",
    "start": "1752470",
    "end": "1757639"
  },
  {
    "text": "So static arrays are really\nbad for dynamic operations-- no surprise. But you could do them.",
    "start": "1757640",
    "end": "1763970"
  },
  {
    "text": "That's static array. Now, linked lists are going\nto be almost the opposite--",
    "start": "1763970",
    "end": "1769960"
  },
  {
    "text": "well, almost. If we store the length, OK,\nwe can compute the length",
    "start": "1769960",
    "end": "1776500"
  },
  {
    "text": "of the array very quickly. We can insert and delete at\nthe front really efficiently.",
    "start": "1776500",
    "end": "1784510"
  },
  {
    "text": "If I want to add a new item as\na new first item, then what do?",
    "start": "1784510",
    "end": "1791080"
  },
  {
    "text": "I do I allocate a new\nnode, which I'll call x. This is insert-first of x.",
    "start": "1791080",
    "end": "1801059"
  },
  {
    "text": "I'll allocate a new\narray of size 2. I'm going to change-- let me do it in red.",
    "start": "1801060",
    "end": "1808110"
  },
  {
    "text": "I'm going to change\nthis head pointer. Maybe I should do that later.",
    "start": "1808110",
    "end": "1813539"
  },
  {
    "text": "I'm going to set the next\npointer here to this one, and then I'm going\nto change this head pointer to point to here.",
    "start": "1813540",
    "end": "1820679"
  },
  {
    "text": "And, boom, now I've\ngot a linked list. Again, we don't know anything\nabout the order and memory of these lists.",
    "start": "1820680",
    "end": "1826692"
  },
  {
    "text": "We just care about\nthe order that's represented implicitly\nby following the next pointers repeatedly.",
    "start": "1826692",
    "end": "1832700"
  },
  {
    "text": "Now, I've got a new list that\nhas x in front, and then x 0, and then x 1, and so on. So insert- and delete_first,\nat least are really efficient.",
    "start": "1832700",
    "end": "1841044"
  },
  {
    "text": "We won't get much\nmore than that, but the linked list, insert- and\ndelete_first are constant time.",
    "start": "1841045",
    "end": "1855010"
  },
  {
    "start": "1855010",
    "end": "1860350"
  },
  {
    "text": "So that's cool. However, everything else\nis going to be slow. If I want to get the 10th\nitem in a linked list,",
    "start": "1860350",
    "end": "1870490"
  },
  {
    "text": "I have to follow these\npointers 10 times. I go 0, 1, 2, 3, and so on.",
    "start": "1870490",
    "end": "1877510"
  },
  {
    "text": "Follow 10 next pointers\nand I'll get the 10th item. Accessing the ith item is\ngoing to take order i time.",
    "start": "1877510",
    "end": "1883480"
  },
  {
    "start": "1883480",
    "end": "1889090"
  },
  {
    "text": "Get- and set_at need i time,\nwhich, in the worst case,",
    "start": "1889090",
    "end": "1900500"
  },
  {
    "text": "is theta n. ",
    "start": "1900500",
    "end": "1908830"
  },
  {
    "text": "We have sort of complementary\ndata structures here. On the one hand, a static\narray can do constant time",
    "start": "1908830",
    "end": "1914470"
  },
  {
    "text": "get_at/set_at. So it's very fast at\nthe random access aspect because it's an array. Linked lists are very\nbad at random access,",
    "start": "1914470",
    "end": "1921470"
  },
  {
    "text": "but they're better\nat being dynamic. We can insert and delete--\nat the beginning, at least--",
    "start": "1921470",
    "end": "1926620"
  },
  {
    "text": "in constant time. Now, if we want to\nactually insert and delete at a particular position,\nthat's still hard,",
    "start": "1926620",
    "end": "1933670"
  },
  {
    "text": "because we have to\nwalk to that position. Even inserting and leading\nat the end of the list is hard, although\nthat's fixable.",
    "start": "1933670",
    "end": "1940435"
  },
  {
    "text": " And maybe I'll leave that for\nproblem session or problem set.",
    "start": "1940435",
    "end": "1946690"
  },
  {
    "text": "But an easy-- here's\na small puzzle. Suppose you wanted\nto solve get-last",
    "start": "1946690",
    "end": "1955670"
  },
  {
    "text": "efficiently in a linked list. How would you solve\nthat in constant time?",
    "start": "1955670",
    "end": "1960710"
  },
  {
    "text": " Yeah? AUDIENCE: Doubly linked list. ERIK DEMAINE:\nDoubly linked list.",
    "start": "1960710",
    "end": "1966715"
  },
  {
    "text": "It's a good idea, but\nactually not the right answer. That's an answer to the\nnext question I might ask.",
    "start": "1966715",
    "end": "1972029"
  },
  {
    "text": "Yeah? AUDIENCE: [INAUDIBLE] ERIK DEMAINE: [INAUDIBLE]\npointer to the last element.",
    "start": "1972030",
    "end": "1977900"
  },
  {
    "text": "That's all we need here. And often, a doubly\nlinked list has this.",
    "start": "1977900",
    "end": "1983150"
  },
  {
    "text": "They usually call this\nthe tail-- head and tail. And if we always just store\na pointer to the last list--",
    "start": "1983150",
    "end": "1989720"
  },
  {
    "text": "this is what we call data\nstructure augmentation, where we add some extra\ninformation to the data structure and--",
    "start": "1989720",
    "end": "1995419"
  },
  {
    "text": "we have to keep it up\nto date all the time. So if we do an\ninsert_last or something, insert_last also becomes\neasy because I can just",
    "start": "1995420",
    "end": "2002920"
  },
  {
    "text": "add a new node here and\nupdate the pointer here. delete_last is trickier. That's where you get\na doubly linked list.",
    "start": "2002920",
    "end": "2009700"
  },
  {
    "text": "But whenever I add something\nto the end of this list, I have to update the\ntail pointer also. As long as I maintain this,\nnow, suddenly get-last",
    "start": "2009700",
    "end": "2016840"
  },
  {
    "text": "is fast in constant time. So linked lists are great if\nyou're working on the ends, even dynamically.",
    "start": "2016840",
    "end": "2022060"
  },
  {
    "text": "Arrays are great if you're\ndoing random access and nothing dynamic-- nothing adding or deleting\nat the ends or in the middle.",
    "start": "2022060",
    "end": "2028450"
  },
  {
    "text": " Our final goal for\ntoday is to get",
    "start": "2028450",
    "end": "2034210"
  },
  {
    "text": "sort of the best of both\nworlds with dynamic arrays. We're going to try to get\nall of the good running times",
    "start": "2034210",
    "end": "2039968"
  },
  {
    "text": "of linked lists and all\nof the good running times of static arrays. We won't get quite all of\nthem, but most of them.",
    "start": "2039968",
    "end": "2045370"
  },
  {
    "start": "2045370",
    "end": "2052060"
  },
  {
    "text": "And in some sense,\nanother way to describe",
    "start": "2052060",
    "end": "2059980"
  },
  {
    "text": "what these introductory\nlectures are about is telling you about how\nPython is implemented.",
    "start": "2059980",
    "end": "2066969"
  },
  {
    "text": "What we're going to talk\nabout next, dynamic arrays, I've alluded to many times.",
    "start": "2066969",
    "end": "2073089"
  },
  {
    "text": "But these are what\nPython calls lists. ",
    "start": "2073090",
    "end": "2083300"
  },
  {
    "text": "You don't have to implement\na dynamic array by hand because it's already built\ninto many fancy new languages",
    "start": "2083300",
    "end": "2090739"
  },
  {
    "text": "for free, because\nthey're so darn useful. This lecture is about how\nthese are actually implemented",
    "start": "2090739",
    "end": "2096138"
  },
  {
    "text": "and why they're efficient. And in recitation\nnodes, you'll see how to actually\nimplement them if all you",
    "start": "2096139",
    "end": "2102530"
  },
  {
    "text": "had were static arrays. But luckily, we\nhave dynamic arrays, so we don't have to\nactually implement them.",
    "start": "2102530",
    "end": "2108410"
  },
  {
    "text": "But inside the\nPython interpreter, this is exactly\nwhat's happening.",
    "start": "2108410",
    "end": "2114500"
  },
  {
    "text": "The idea is to relax\nthe constraint--",
    "start": "2114500",
    "end": "2123200"
  },
  {
    "text": "or the invariant, whatever-- that the size of\nthe array we use",
    "start": "2123200",
    "end": "2130339"
  },
  {
    "text": "equals n, which is the number\nof items in the sequence.",
    "start": "2130340",
    "end": "2137150"
  },
  {
    "text": " Remember, in the\nsequence problem,",
    "start": "2137150",
    "end": "2142190"
  },
  {
    "text": "we're supposed to\nrepresent n items. With a static array, we\nallocated an array of size exactly n.",
    "start": "2142190",
    "end": "2148730"
  },
  {
    "text": "So let's relax that. Let's not make it exactly n. Let's make it roughly n.",
    "start": "2148730",
    "end": "2154099"
  },
  {
    "text": "How roughly, you can\nthink about for a while. But from an algorithms\nperspective,",
    "start": "2154100",
    "end": "2159799"
  },
  {
    "text": "usually, when we say\nroughly, we mean throw away constant factors. And that turns out to be\nthe right answer here. It's not always\nthe right answer.",
    "start": "2159800",
    "end": "2166040"
  },
  {
    "text": "But we're going to enforce\nthat the size of the array",
    "start": "2166040",
    "end": "2171980"
  },
  {
    "text": "is theta n-- probably also greater\nthan or equal to n. 0.5 n would not be very helpful.",
    "start": "2171980",
    "end": "2178200"
  },
  {
    "text": "So it's going to be\nat least n, and it's going to be at most\nsome constant times n.",
    "start": "2178200",
    "end": "2185430"
  },
  {
    "text": "2n, 10n, 1.1 times n. Any of these\nconstants will work. I'm going to use 2n here, but\nthere are lots of options.",
    "start": "2185430",
    "end": "2192840"
  },
  {
    "text": " And now, things\nalmost work for free.",
    "start": "2192840",
    "end": "2198740"
  },
  {
    "text": "There's going to be\none subtlety here. And I'm going to focus on--",
    "start": "2198740",
    "end": "2204310"
  },
  {
    "text": "we're still going to maintain\nthat the ith item of the array",
    "start": "2204310",
    "end": "2210990"
  },
  {
    "text": "represents x i. This data structure--\nlet me draw a picture.",
    "start": "2210990",
    "end": "2218240"
  },
  {
    "text": "We've got an array of some size. The first few items are\nused to store the sequence.",
    "start": "2218240",
    "end": "2227849"
  },
  {
    "text": "But then, there's going to be\nsome blank ones at the end. Maybe we'll keep track of this--",
    "start": "2227850",
    "end": "2233440"
  },
  {
    "text": "so the data structure itself is\ngoing to have an array and it's going to have a length.",
    "start": "2233440",
    "end": "2239099"
  },
  {
    "text": "Something like this. We're also going to keep\ntrack of the length. So we know that the\nfirst length items",
    "start": "2239100",
    "end": "2244500"
  },
  {
    "text": "are where the data is, and\nthe remainder are meaningless.",
    "start": "2244500",
    "end": "2250500"
  },
  {
    "text": "So now, if I want to go and do\nan insert_last, what do I do?",
    "start": "2250500",
    "end": "2259760"
  },
  {
    "text": "I just go to a of\nlength and set it to x. ",
    "start": "2259760",
    "end": "2268480"
  },
  {
    "text": "And then I increment length. Boom. Easy. Constant time.",
    "start": "2268480",
    "end": "2273849"
  },
  {
    "text": "Yeah? AUDIENCE: [INAUDIBLE] ERIK DEMAINE: How do\nyou have enough room. Indeed, I don't.",
    "start": "2273850",
    "end": "2279390"
  },
  {
    "text": "This was an incorrect algorithm. But it's usually correct. As long as I have\nextra space, this",
    "start": "2279390",
    "end": "2284760"
  },
  {
    "text": "is all I need to\ndo for insert_last. But I am also going to\nstore the size of the array.",
    "start": "2284760",
    "end": "2294100"
  },
  {
    "text": "This is the actual-- this whole thing is size,\nand this part is length.",
    "start": "2294100",
    "end": "2302860"
  },
  {
    "text": "Length is always going to be\nless than or equal to size. And so there's a problem.",
    "start": "2302860",
    "end": "2307869"
  },
  {
    "text": "If length equals size, then\nI don't have any space. ",
    "start": "2307870",
    "end": "2316040"
  },
  {
    "text": "Just add to end\nunless n equals size.",
    "start": "2316040",
    "end": "2328070"
  },
  {
    "text": "I'm using n length\nfor the same thing. So length here is the same as n.",
    "start": "2328070",
    "end": "2335859"
  },
  {
    "text": "That's our actual\nnumber of things we're trying to represent. And size-- this is great. This is the interface size.",
    "start": "2335860",
    "end": "2343305"
  },
  {
    "text": "This is what we're\ntrying to represent. And this is the\nrepresentation size. This is the size of my array.",
    "start": "2343305",
    "end": "2349155"
  },
  {
    "text": "These are the\nnumber of items I'm trying to store in that array. This is the interface\nversus data structure.",
    "start": "2349155",
    "end": "2354275"
  },
  {
    "text": "Here's the interface. Here's the data structure. OK, cool. ",
    "start": "2354275",
    "end": "2362559"
  },
  {
    "start": "2360000",
    "end": "2510000"
  },
  {
    "text": "What do I do in the\ncase when n equals size? ",
    "start": "2362560",
    "end": "2373280"
  },
  {
    "text": "I'm going to have to\nmake my array bigger. This should sound just\nlike static arrays.",
    "start": "2373280",
    "end": "2380075"
  },
  {
    "text": "For static arrays, we made\nour array bigger every time we inserted. And that was this linear\ncost of allocation.",
    "start": "2380075",
    "end": "2389420"
  },
  {
    "text": "We're going to do\nthat sometimes. With static arrays, we had\nto do it every single time, because size equaled n.",
    "start": "2389420",
    "end": "2395450"
  },
  {
    "text": "Now, we have some flexibility. We're only going\nto do it sometimes. It's like, cookies are a\nsometimes food, apparently,",
    "start": "2395450",
    "end": "2403770"
  },
  {
    "text": "according to modern\nCookie Monster. I don't understand. But if n equals\nsize, we're going",
    "start": "2403770",
    "end": "2412470"
  },
  {
    "text": "to allocate a new\narray of size--",
    "start": "2412470",
    "end": "2425625"
  },
  {
    "text": " any suggestions?",
    "start": "2425625",
    "end": "2431060"
  },
  {
    "text": "AUDIENCE: Bigger. ERIK DEMAINE: Bigger. I like it. Greater than size. How much bigger?",
    "start": "2431060",
    "end": "2436790"
  },
  {
    "text": "AUDIENCE: Twice. ERIK DEMAINE: Twice. JASON KU: Five things. ERIK DEMAINE: Five things.",
    "start": "2436790",
    "end": "2443020"
  },
  {
    "text": "Size plus 5? Come on, Jason. Trolling me.",
    "start": "2443020",
    "end": "2448700"
  },
  {
    "text": "All right. There are a couple of\nnatural choices here. One is a constant factor larger. You could use 1.1, or\n1.01, or two, or 5, or 10.",
    "start": "2448700",
    "end": "2457540"
  },
  {
    "text": "They will all work. Or you could use Jason's\ntrolling answer of size plus a constant, like 5.",
    "start": "2457540",
    "end": "2466420"
  },
  {
    "text": "Why is this bad?  Yeah? AUDIENCE: [INAUDIBLE]",
    "start": "2466420",
    "end": "2473289"
  },
  {
    "text": " ERIK DEMAINE: You'll\nhave to do it again.",
    "start": "2473290",
    "end": "2479780"
  },
  {
    "text": "You'll have to\nresize frequently. When? Five steps later.",
    "start": "2479780",
    "end": "2485599"
  },
  {
    "text": "In the original\nstatic array, we were reallocating every single time. That's like n plus 1.",
    "start": "2485600",
    "end": "2490970"
  },
  {
    "text": "If we do n plus 5, that\nreally doesn't change things if we ignore constant factors. Now, we'll have to spend linear\ntime every five steps instead",
    "start": "2490970",
    "end": "2497839"
  },
  {
    "text": "of linear time every one step. That's still linear time\nper operation, just, we're changing the\nconstant factor.",
    "start": "2497840",
    "end": "2504710"
  },
  {
    "text": "Whereas 2 times\nsize, well, now we have to think a\nlittle bit harder. Let's just think\nabout the case where",
    "start": "2504710",
    "end": "2511370"
  },
  {
    "start": "2510000",
    "end": "2790000"
  },
  {
    "text": "we're inserting at\nthe end of an array. Let's say we do n insert_lasts\nfrom an empty array.",
    "start": "2511370",
    "end": "2525470"
  },
  {
    "start": "2525470",
    "end": "2532010"
  },
  {
    "text": "When do we resize? Well, at the beginning-- I guess I didn't say what\nwe do for an empty array. Let's say size equals 1.",
    "start": "2532010",
    "end": "2538670"
  },
  {
    "text": "We can insert one item for free. As soon as we insert the second\nitem, then we have to resize. That seems bad.",
    "start": "2538670",
    "end": "2544460"
  },
  {
    "text": "Immediately, we have to resize. Then we insert the third item. OK, now let's draw a picture.",
    "start": "2544460",
    "end": "2550110"
  },
  {
    "text": "So we start with one item. We fill it up. Then, we grow to size 2,\nbecause that's twice 1.",
    "start": "2550110",
    "end": "2557000"
  },
  {
    "text": "Then we fill it up. Immediately, we have\nto resize again. But now we start to\nget some benefit. Now, we have size 4, and\nso we can insert two items",
    "start": "2557000",
    "end": "2565100"
  },
  {
    "text": "before we have to resize. And now, we're\nsize 8, and we get",
    "start": "2565100",
    "end": "2570740"
  },
  {
    "text": "to insert four items\nbefore we refill. This is going to resize--",
    "start": "2570740",
    "end": "2577970"
  },
  {
    "text": "and again, resizes\nare expensive both because we have to pay to\nallocate the new array-- I drew it as just extending\nit, but in fact, we're",
    "start": "2577970",
    "end": "2584890"
  },
  {
    "text": "creating a whole\nnew array, and then we have to copy all\nof the items over. So there's the allocation cost\nand then the copying costs.",
    "start": "2584890",
    "end": "2591710"
  },
  {
    "text": "It's linear either way. But we're going to resize\nat n equals 1, 2, 4, 8,",
    "start": "2591710",
    "end": "2600500"
  },
  {
    "text": "16-- you know this sequence. All the powers of 2,\nbecause we're doubling. That is exactly powers of 2.",
    "start": "2600500",
    "end": "2608240"
  },
  {
    "text": "So we pay a linear cost. This resize cost, the\nallocation and the copying,",
    "start": "2608240",
    "end": "2617150"
  },
  {
    "text": "is going to be-- it's\nlinear each time. So it's 1 plus 2 plus\n4 plus 8 plus 16.",
    "start": "2617150",
    "end": "2626480"
  },
  {
    "text": "Really, I should write\nthis as sum from i equals 1 to roughly log n.",
    "start": "2626480",
    "end": "2633680"
  },
  {
    "text": "Log base 2 of n is\nlG of 2 to the i. ",
    "start": "2633680",
    "end": "2641160"
  },
  {
    "text": "If you want a terminus\nhere, it's roughly n. It's actually the next-- the previous power of\n2 of n, or something.",
    "start": "2641160",
    "end": "2649109"
  },
  {
    "text": "But that won't matter. That will just affect\nthings by a constant factor. What is the sum of 2 to the i?",
    "start": "2649110",
    "end": "2656510"
  },
  {
    "text": "This is a geometric series. Anyone know the answer? ",
    "start": "2656510",
    "end": "2665690"
  },
  {
    "text": "Yeah? AUDIENCE: [INAUDIBLE] ERIK DEMAINE: 2 to the\ntop limit plus 1 minus 1.",
    "start": "2665690",
    "end": "2673799"
  },
  {
    "text": "Yeah. So this is the identity. Sum of 2 to the i from i equals\n1 to k is 2 to the k plus 1,",
    "start": "2673800",
    "end": "2685760"
  },
  {
    "text": "plus 1 minus 1. So the plus 1 is upstairs. The minus one is downstairs. An easy way to remember this\nis if you think in binary--",
    "start": "2685760",
    "end": "2693290"
  },
  {
    "text": "as we all should. We're computer scientists. 2 to the i means you\nset the ith bit to 1.",
    "start": "2693290",
    "end": "2700850"
  },
  {
    "text": "Here's a bit string. This is the ith bit. This is 2 to the i. 0 is down here.",
    "start": "2700850",
    "end": "2705950"
  },
  {
    "text": "If I sum them all up, what that\nmeans is, I'm putting 1s here.",
    "start": "2705950",
    "end": "2711500"
  },
  {
    "text": "And if you think about what this\nmeans, this is up to k from 0-- sorry, I should\ndo 0 to be proper.",
    "start": "2711500",
    "end": "2719750"
  },
  {
    "text": "If I write-- that's\nthe left-hand side. The right-hand side is 2 to the\nk plus 1, which is a 1 here,",
    "start": "2719750",
    "end": "2727700"
  },
  {
    "text": "and the rest 0s. So if you know your\nbinary arithmetic, you subtract-- if you add\n1 to this, you get this.",
    "start": "2727700",
    "end": "2734329"
  },
  {
    "text": "Or if you subtract 1\nfrom this, you get this. This is why this identity holds.",
    "start": "2734330",
    "end": "2739609"
  },
  {
    "text": "Or the higher-level\nthing is to say, oh, this is a geometric series. So I know-- you\nshould know this.",
    "start": "2739610",
    "end": "2746420"
  },
  {
    "text": "I'm telling you now. Geometric series are dominated\nby the last term-- the biggest term.",
    "start": "2746420",
    "end": "2751490"
  },
  {
    "text": "If you have any series you can\nidentify as geometric, which means it's growing at\nleast exponentially, then in terms of\ntheta notation, you",
    "start": "2751490",
    "end": "2759134"
  },
  {
    "text": "can just look at the last term\nand put a theta around it, and you're done. So this is theta\nof the last term,",
    "start": "2759135",
    "end": "2765290"
  },
  {
    "text": "like 2 to the log\nn, which is theta n. ",
    "start": "2765290",
    "end": "2772920"
  },
  {
    "text": "Cool. Linear time. Linear time for all\nof my operations.",
    "start": "2772920",
    "end": "2778140"
  },
  {
    "text": "I'm doing n operations here,\nand I spent linear total time to do all of the resizing.",
    "start": "2778140",
    "end": "2784020"
  },
  {
    "text": "That's good. That's like constant\neach, kind of. The \"kind of\" is\nan important notion",
    "start": "2784020",
    "end": "2791849"
  },
  {
    "start": "2790000",
    "end": "3017000"
  },
  {
    "text": "which we call amortization. ",
    "start": "2791850",
    "end": "2805360"
  },
  {
    "text": "I want to say an\noperation takes t of n",
    "start": "2805360",
    "end": "2815560"
  },
  {
    "text": "amortized time if, let's say,\nany k of those operations",
    "start": "2815560",
    "end": "2833540"
  },
  {
    "text": "take, at most, k\ntimes t of n time.",
    "start": "2833540",
    "end": "2839790"
  },
  {
    "text": "This is a little bit\nsloppy, but be good enough. The idea is here, if\nthis works for n or k,",
    "start": "2839790",
    "end": "2846110"
  },
  {
    "text": "to do n operations from\nan empty array here takes linear time,\nwhich means I would",
    "start": "2846110",
    "end": "2853280"
  },
  {
    "text": "call this constant amortized. Amortized means a particular\nkind of averaging--",
    "start": "2853280",
    "end": "2862390"
  },
  {
    "text": "averaging over the\nsequence of operations. So while individual\noperations will be expensive, one near the end, when I\nhave to resize the array,",
    "start": "2862390",
    "end": "2869980"
  },
  {
    "text": "is going to take linear time\njust for that one operation. But most of the\noperations are cheap. Most of them are constant.",
    "start": "2869980",
    "end": "2876109"
  },
  {
    "text": "So I can think of\ncharging that high cost to all of the other operations\nthat made it happen.",
    "start": "2876110",
    "end": "2884620"
  },
  {
    "text": "This is averaging over\nthe operation sequence.",
    "start": "2884620",
    "end": "2891880"
  },
  {
    "text": "Every insert_last over there\nonly takes constant time,",
    "start": "2891880",
    "end": "2897160"
  },
  {
    "text": "on average, over the sequence\nof operations that we do.",
    "start": "2897160",
    "end": "2903750"
  },
  {
    "text": "And so it's almost constant. It's not quite as good\nas constant, worst case, but it's almost as good. And it's as good\nas you could hope",
    "start": "2903750",
    "end": "2910280"
  },
  {
    "text": "to do in this dynamic\narray allocation model. Let me put this into a table.",
    "start": "2910280",
    "end": "2917610"
  },
  {
    "text": "And you'll find these in\nthe lecture notes, also. We have, on the top,\nthe main operations of sequence interface, which we\nwill revisit in lecture seven.",
    "start": "2917610",
    "end": "2925130"
  },
  {
    "text": "We'll see some other\ndata structures for this. Get_at and set_at\nin the first column. Insert_ and delete_first,\ninsert_ and delete_last,",
    "start": "2925130",
    "end": "2931250"
  },
  {
    "text": "insert_ and delete_at\nan arbitrary position. We've seen three\ndata structures now.",
    "start": "2931250",
    "end": "2936710"
  },
  {
    "text": "Arrays were really\ngood at get_at/set_at. They took constant time. That's the blue one.",
    "start": "2936710",
    "end": "2942050"
  },
  {
    "text": "We're omitting the thetas here. All of the other operations\ntook linear time, no matter where they were.",
    "start": "2942050",
    "end": "2947359"
  },
  {
    "text": "Linked lists were really good\nat insert- and delete_first. They took constant time,\nbut everything else took linear time,\nin the worst case.",
    "start": "2947360",
    "end": "2953690"
  },
  {
    "text": "These new dynamic arrays\nachieve get_at and set_at in constant time because they\nmaintain this invariant here",
    "start": "2953690",
    "end": "2964059"
  },
  {
    "text": "that a of i equals x i. So we can still do get-\nand set_at quickly.",
    "start": "2964060",
    "end": "2969920"
  },
  {
    "text": "And we also just\nshowed that insert_last is constant amortized. delete_last, you don't\nhave to resize the array.",
    "start": "2969920",
    "end": "2978500"
  },
  {
    "text": "You could just decrease\nlength and, boom, you've deleted the last item. It's not so satisfying,\nbecause if you insert n items",
    "start": "2978500",
    "end": "2985430"
  },
  {
    "text": "and then delete n\nitems, you'll still have an array of size theta n,\neven though your current value of n is 0.",
    "start": "2985430",
    "end": "2992119"
  },
  {
    "text": "You can get around that\nwith a little bit more trickery, which are described\nin the lecture notes. But it's beyond the-- we're\nonly going to do very simple",
    "start": "2992120",
    "end": "2999530"
  },
  {
    "text": "amortized analysis\nin this class-- to prove that that\nalgorithm is also constant amortized, which it is.",
    "start": "2999530",
    "end": "3005320"
  },
  {
    "text": "You'll see in 046, or you\ncan find it in the CLRS book. That's it for today.",
    "start": "3005320",
    "end": "3011820"
  },
  {
    "start": "3011820",
    "end": "3018000"
  }
]