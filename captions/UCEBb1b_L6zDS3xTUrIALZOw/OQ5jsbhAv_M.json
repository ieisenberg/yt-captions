[
  {
    "start": "0",
    "end": "430000"
  },
  {
    "text": "The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6350"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6350",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13320",
    "end": "21130"
  },
  {
    "text": "PROFESSOR: We're going to start\na brand new, exciting topic, dynamic programming. AUDIENCE: Yes! PROFESSOR: Yeah!",
    "start": "21130",
    "end": "26830"
  },
  {
    "text": "So exciting. Actually, I am really excited\nbecause dynamic programming is my favorite thing in\nthe world, in algorithms.",
    "start": "26830",
    "end": "33820"
  },
  {
    "text": "And it's going to be\nthe next four lectures, it's so exciting. It has lots of different facets.",
    "start": "33820",
    "end": "40380"
  },
  {
    "text": "It's a very general,\npowerful design technique. We don't talk a lot about\nalgorithm design in this class,",
    "start": "40380",
    "end": "47390"
  },
  {
    "text": "but dynamic programming is\none that's so important. And also takes a little\nwhile to settle in. We like to inject it\ninto you now, in 006.",
    "start": "47390",
    "end": "57510"
  },
  {
    "text": "So in general, our\nmotivation is designing new algorithms and dynamic\nprogramming, also called DP,",
    "start": "57510",
    "end": "70600"
  },
  {
    "text": "is a great way-- or a very general,\npowerful way to do this.",
    "start": "70600",
    "end": "78365"
  },
  {
    "start": "78365",
    "end": "93860"
  },
  {
    "text": "It's especially good, and\nintended for, optimization problems, things\nlike shortest paths.",
    "start": "93860",
    "end": "99100"
  },
  {
    "text": "You want to find the\nbest way to do something. Shortest path is you\nwant to find the shortest path, the minimum-length path.",
    "start": "99100",
    "end": "106600"
  },
  {
    "text": "You want to minimize,\nmaximize something, that's an optimization\nproblem, and typically good algorithms to solve them\ninvolve dynamic programming.",
    "start": "106600",
    "end": "114090"
  },
  {
    "text": "It's a bit of a broad statement. You can also think of\ndynamic programming as a kind of exhaustive search.",
    "start": "114090",
    "end": "121700"
  },
  {
    "text": "Which is usually a bad\nthing to do because it leads to exponential time. But if you do it in a clever\nway, via dynamic programming,",
    "start": "121700",
    "end": "129449"
  },
  {
    "text": "you typically get\npolynomial time. So one perspective is\nthat dynamic programming",
    "start": "129449",
    "end": "137430"
  },
  {
    "text": "is approximately\ncareful brute force.",
    "start": "137430",
    "end": "143170"
  },
  {
    "text": "It's kind of a\nfunny combination. A bit of an oxymoron.",
    "start": "143170",
    "end": "149340"
  },
  {
    "text": "But we take the idea of\nbrute force, which is, try all possibilities\nand you do it carefully",
    "start": "149340",
    "end": "155690"
  },
  {
    "text": "and you get it to\npolynomial time. There are a lot of\nproblems where essentially the only known\npolynomial-time algorithm is",
    "start": "155690",
    "end": "161650"
  },
  {
    "text": "via dynamic programming. It doesn't always work,\nthere's some problems where we don't think there are\npolynomial-time algorithms,",
    "start": "161650",
    "end": "166857"
  },
  {
    "text": "but when it's possible\nDP is a nice, sort of, general approach to it.",
    "start": "166857",
    "end": "174037"
  },
  {
    "text": "And we're going to be talking a\nlot about dynamic programming. There's a lot of different\nways to think about it.",
    "start": "174037",
    "end": "179849"
  },
  {
    "text": "We'll look at a few today. We're going to warm up today\nwith some fairly easy problems",
    "start": "179850",
    "end": "185753"
  },
  {
    "text": "that we already\nknow how to solve, namely computing\nFibonacci numbers. It's pretty easy.",
    "start": "185753",
    "end": "191210"
  },
  {
    "text": "And computing shortest paths. And then in the\nnext three lectures we're going to get to\nmore interesting examples",
    "start": "191210",
    "end": "196530"
  },
  {
    "text": "where it's pretty surprising\nthat you can even solve the problem in polynomial time.",
    "start": "196530",
    "end": "204159"
  },
  {
    "text": "Probably the first burning\nquestion on your mind, though, is why is it\ncalled dynamic programming?",
    "start": "204160",
    "end": "209280"
  },
  {
    "text": "What does that even mean? And I used to have this\nspiel about, well, you know,",
    "start": "209280",
    "end": "214920"
  },
  {
    "text": "programming refers to the-- I think it's the British\nnotion of the word, where it's about optimization.",
    "start": "214920",
    "end": "222040"
  },
  {
    "text": "Optimization in American\nEnglish is something like programming\nin British English,",
    "start": "222040",
    "end": "227690"
  },
  {
    "text": "where you want to\nset up the program-- the schedule for your\ntrains or something,",
    "start": "227690",
    "end": "232800"
  },
  {
    "text": "where programming\ncomes from originally. But I looked up the\nactual history of, why is it called\ndynamic programming.",
    "start": "232800",
    "end": "240730"
  },
  {
    "text": "Dynamic programming was invented\nby a guy named Richard Bellman. You may have heard of Bellman\nin the Bellman-Ford algorithm.",
    "start": "240730",
    "end": "247850"
  },
  {
    "text": "So this is actually the\nprecursor to Bellman-Ford. And we're going to see\nBellman-Ford come up naturally",
    "start": "247850",
    "end": "253290"
  },
  {
    "text": "in this setting. So here's a quote about him. It says, Bellman\nexplained that he",
    "start": "253290",
    "end": "259299"
  },
  {
    "text": "invented the name\ndynamic programming to hide the fact that he was\ndoing mathematical research.",
    "start": "259300",
    "end": "265840"
  },
  {
    "text": "He was working at this\nplace called Rand, and under a secretary\nof defense who had a pathological fear and\nhatred for the term research.",
    "start": "265840",
    "end": "275095"
  },
  {
    "text": "So he settled on the\nterm dynamic programming because it would be\ndifficult to give a pejorative meaning to it.",
    "start": "275095",
    "end": "282000"
  },
  {
    "text": "And because it was\nsomething not even a congressman could object to. Basically, it sounded cool.",
    "start": "282000",
    "end": "289430"
  },
  {
    "text": "So that's the origin of the\nname dynamic programming. So why is the called that? Who knows.",
    "start": "289430",
    "end": "295450"
  },
  {
    "text": "I mean, now you know. But it's not--\nit's a weird term. Just take it for what it is.",
    "start": "295450",
    "end": "300720"
  },
  {
    "text": " It may make some\nkind of sense, but--",
    "start": "300720",
    "end": "306820"
  },
  {
    "text": "All right. So we are going to start\nwith this example of how",
    "start": "306820",
    "end": "314570"
  },
  {
    "text": "to compute Fibonacci numbers. And maybe before\nwe actually start I'm going to give you a sneak\npeek of what you can think",
    "start": "314570",
    "end": "323670"
  },
  {
    "text": "of dynamic programming as. And this equation,\nso to speak, is",
    "start": "323670",
    "end": "337830"
  },
  {
    "text": "going to change throughout\ntoday's lecture. In the end we'll\nsettle on a sort",
    "start": "337830",
    "end": "343970"
  },
  {
    "text": "of more accurate perspective. The basic idea of\ndynamic programming",
    "start": "343970",
    "end": "349020"
  },
  {
    "text": "is to take a problem,\nsplit it into subproblems, solve those subproblems,\nand reuse the solutions",
    "start": "349020",
    "end": "355780"
  },
  {
    "text": "to your subproblems. It's like a lesson in recycling. So we'll see that in\nFibonacci numbers.",
    "start": "355780",
    "end": "363289"
  },
  {
    "text": "So you remember\nFibonacci numbers, right? The number of rabbits you have\non day n, if they reproduce.",
    "start": "363290",
    "end": "370444"
  },
  {
    "text": " We've mentioned them before,\nwe're talking about AVL trees,",
    "start": "370445",
    "end": "378629"
  },
  {
    "text": "I think. So this is the usual-- you can think of it as\na recursive definition",
    "start": "378630",
    "end": "385009"
  },
  {
    "text": "or recurrence on\nFibonacci numbers. It's the definition of what\nthe nth Fibonacci number is.",
    "start": "385010",
    "end": "390889"
  },
  {
    "text": "So let's suppose our goal-- an algorithmic problem is,\ncompute the nth Fibonacci",
    "start": "390890",
    "end": "396400"
  },
  {
    "text": "number. And I'm going to assume here\nthat that fits in a word.",
    "start": "396400",
    "end": "402710"
  },
  {
    "text": "And so basic arithmetic,\naddition, whatever, is constant time per operation.",
    "start": "402710",
    "end": "408100"
  },
  {
    "text": "So how do we do it? You all know how to do it. Anyways-- but I'm\ngoing to give you",
    "start": "408100",
    "end": "415410"
  },
  {
    "text": "the dynamic-programming\nperspective on things. So this will seem kind\nof obvious, but it is--",
    "start": "415410",
    "end": "421610"
  },
  {
    "text": "we're going to apply\nexactly the same principles that we will apply over and\nover in dynamic-programming. But here it's in a\nvery familiar setting.",
    "start": "421610",
    "end": "431909"
  },
  {
    "start": "430000",
    "end": "680000"
  },
  {
    "text": "So we're going to start with\nthe naive recursive algorithm. ",
    "start": "431910",
    "end": "444850"
  },
  {
    "text": "And that is, if you want to\ncompute the nth Fibonacci number, you check whether\nyou're in the base case.",
    "start": "444850",
    "end": "452009"
  },
  {
    "text": " I'm going to write it this way.",
    "start": "452010",
    "end": "458520"
  },
  {
    "start": "458520",
    "end": "475229"
  },
  {
    "text": "So f is just our return value. You'll see why I write\nit this way in a moment. Then you return f.",
    "start": "475230",
    "end": "481270"
  },
  {
    "text": "In the base case it's 1,\notherwise you recursively call Fibonacci of n minus 1. You recursively call\nFibonacci of n minus 2.",
    "start": "481270",
    "end": "488520"
  },
  {
    "text": "Add them together, return that. This is a correct algorithm. Is it a good algorithm?",
    "start": "488520",
    "end": "495160"
  },
  {
    "text": "No. It's very bad. Exponential time. ",
    "start": "495160",
    "end": "503450"
  },
  {
    "text": "How do we know it's\nexponential time, other than from experience? Well, we can write the\nrunning time as recurrence.",
    "start": "503450",
    "end": "511880"
  },
  {
    "text": "T of n represents the time\nto compute the nth Fibonacci number. How can I write the recurrence?",
    "start": "511880",
    "end": "519440"
  },
  {
    "text": "You're gonna throwback to\nthe early lectures, divide and conquer. ",
    "start": "519440",
    "end": "528950"
  },
  {
    "text": "I hear whispers. Yeah? AUDIENCE: [INAUDIBLE]. ",
    "start": "528950",
    "end": "535320"
  },
  {
    "text": "PROFESSOR: Yeah. T of n minus 1 plus t of\nn minus 2 plus constant.",
    "start": "535320",
    "end": "543339"
  },
  {
    "text": " I don't know how\nmany you have by now.",
    "start": "543340",
    "end": "548865"
  },
  {
    "text": " So to create the\nnth Fibonacci number we have to compute the n\nminus first Fibonacci number,",
    "start": "548865",
    "end": "555790"
  },
  {
    "text": "and the n minus second\nFibonacci number. That's these two recursions. And then we take\nconstant time otherwise.",
    "start": "555790",
    "end": "561760"
  },
  {
    "text": "We do constant number of\nadditions, comparisons. Return all these operations-- take constant time.",
    "start": "561760",
    "end": "567920"
  },
  {
    "text": "So that's a recurrence. How do we solve this recurrence? Well one way is to see this\nis the Fibonacci recurrence.",
    "start": "567920",
    "end": "575720"
  },
  {
    "text": "So it's the same thing. There's this plus whatever. But in particular, this is at\nleast the nth Fibonacci number.",
    "start": "575720",
    "end": "581720"
  },
  {
    "text": "And if you know\nFibonacci stuff, that's about the golden ratio\nto the nth power.",
    "start": "581720",
    "end": "588440"
  },
  {
    "text": "Which is bad. We had a similar\nrecurrence in AVL trees. And so another way to solve it--",
    "start": "588440",
    "end": "595495"
  },
  {
    "text": "it's just good review-- say, oh well, that's at\nleast 2 times t of n minus 2.",
    "start": "595495",
    "end": "603600"
  },
  {
    "text": "Because it's going\nto be monotone. The bigger n is, the\nmore work you have to do. Because to do the\nnth thing you have",
    "start": "603600",
    "end": "608830"
  },
  {
    "text": "to do the n minus first thing. So we could just reduce t of\nn minus 1 to t of n minus 2.",
    "start": "608830",
    "end": "614260"
  },
  {
    "text": "That will give us a lower bound. And now these two terms-- now\nthis is sort of an easy thing.",
    "start": "614260",
    "end": "619700"
  },
  {
    "text": "You see that you're\nmultiplying by 2 each time. You're subtracting\n2 from n each time. How many times can\nI subtract 2 from n?",
    "start": "619700",
    "end": "627269"
  },
  {
    "text": "N/2 times, before I\nget down to a constant. And so this is equal\nto 2 to the n over 2--",
    "start": "627270",
    "end": "637740"
  },
  {
    "text": "I mean, times some\nconstant, which is what you get in the base case. So I guess I should say theta.",
    "start": "637740",
    "end": "645970"
  },
  {
    "text": "This thing is theta that. OK. So it's at least that big.",
    "start": "645970",
    "end": "651320"
  },
  {
    "text": "And the right constant is phi. And the base of the exponent.",
    "start": "651320",
    "end": "658620"
  },
  {
    "text": "OK. So that's a bad algorithm. We all know it's\na bad algorithm.",
    "start": "658620",
    "end": "663690"
  },
  {
    "text": "But I'm going to give you a\ngeneral approach for making bad algorithms like this good.",
    "start": "663690",
    "end": "669000"
  },
  {
    "text": "And that general approach\nis called memoization. ",
    "start": "669000",
    "end": "674170"
  },
  {
    "text": "We'll go over here. ",
    "start": "674170",
    "end": "679910"
  },
  {
    "text": "And this is a technique\nof dynamic programming.  So I'm going to call this the\nmemoized dynamic programming",
    "start": "679910",
    "end": "688370"
  },
  {
    "start": "680000",
    "end": "945000"
  },
  {
    "text": "algorithm. ",
    "start": "688370",
    "end": "696839"
  },
  {
    "text": "So did I settle on\nusing memo in the notes?",
    "start": "696840",
    "end": "704270"
  },
  {
    "text": "Yeah.  The idea is simple.",
    "start": "704270",
    "end": "710520"
  },
  {
    "text": "Whenever we compute\na Fibonacci number we put it in a dictionary. And then when we need to\ncompute the nth Fibonacci",
    "start": "710520",
    "end": "717250"
  },
  {
    "text": "number we check, is it\nalready in the dictionary? Did we already\nsolve this problem? If so, return that answer.",
    "start": "717250",
    "end": "723020"
  },
  {
    "text": "Otherwise, compute it. You'll see the transformation\nis very simple. ",
    "start": "723020",
    "end": "777810"
  },
  {
    "text": "OK. These two lines are\nidentical to these two lines.",
    "start": "777810",
    "end": "784649"
  },
  {
    "text": "So you can see how\nthe transformation works in general. You could do this with\nany recursive algorithm.",
    "start": "784650",
    "end": "790855"
  },
  {
    "text": "The memoization transformation\non that algorithm-- which is, we initially make an\nempty dictionary called memo.",
    "start": "790856",
    "end": "799050"
  },
  {
    "text": "And before we actually do\nthe computation we say, well, check whether this version\nof the Fibonacci problem,",
    "start": "799050",
    "end": "806820"
  },
  {
    "text": "computing f of n, is\nalready in our dictionary. So if that key is already\nin the dictionary,",
    "start": "806820",
    "end": "813265"
  },
  {
    "text": "we return the corresponding\nvalue in the dictionary. ",
    "start": "813265",
    "end": "818960"
  },
  {
    "text": "And then once we've computed\nthe nth Fibonacci number, if we bothered to do this,\nif this didn't apply,",
    "start": "818960",
    "end": "824780"
  },
  {
    "text": "then we store it\nin the memo table. So we say well, if you ever\nneed to compute f of n again,",
    "start": "824780",
    "end": "830900"
  },
  {
    "text": "here it is. And then we return that value. So this is a general procedure.",
    "start": "830900",
    "end": "837192"
  },
  {
    "text": "It can apply to any\nrecursive algorithm with no side effects\nI guess, technically.",
    "start": "837192",
    "end": "844899"
  },
  {
    "text": "And it turns out, this makes\nthe algorithm efficient. Now there's a lot of ways\nto see why it's efficient.",
    "start": "844900",
    "end": "849955"
  },
  {
    "text": " In general, maybe it's helpful\nto think about the recursion",
    "start": "849955",
    "end": "855260"
  },
  {
    "text": "tree. So if you want to compute\nfn in the old algorithm, we compute fn minus\n1 and fn minus two",
    "start": "855260",
    "end": "862550"
  },
  {
    "text": "completely separately. To compute fn minus 1 we compute\nfn minus 2 and fn minus 3.",
    "start": "862550",
    "end": "869820"
  },
  {
    "text": "To compute fn minus 2 we compute\nfn minus 3 and fn minus 4. And so on.",
    "start": "869820",
    "end": "875620"
  },
  {
    "text": "And you can see why\nthat's exponential in n. Because we're only decrementing\nn by one or two each time.",
    "start": "875620",
    "end": "884250"
  },
  {
    "text": "But then you observe, hey,\nthese fn minus 3's are the same. I should really only have\nto compute them once.",
    "start": "884250",
    "end": "890935"
  },
  {
    "text": "And that's what\nwe're doing here. The first time you call\nfn minus 3, you do work. But once it's done\nand you go over",
    "start": "890935",
    "end": "897889"
  },
  {
    "text": "to this other recursive call,\nthis will just get cut off. There's no tree here. Here we might have\nsome recursive calling.",
    "start": "897890",
    "end": "904180"
  },
  {
    "text": "Here we won't, because it's\nalready in the memo table. In fact, this already\nhappens with fn minus 2.",
    "start": "904180",
    "end": "911930"
  },
  {
    "text": "This whole tree disappears\nbecause fn minus 2 has already been done.",
    "start": "911930",
    "end": "917610"
  },
  {
    "text": "OK. So it's clear why\nit improves things. So in fact you can argue\nthat this call will be free",
    "start": "917610",
    "end": "924750"
  },
  {
    "text": "because you already\ndid the work in here. But I want to give you\na very particular way",
    "start": "924750",
    "end": "929940"
  },
  {
    "text": "of thinking about why this is\nefficient, which is following.",
    "start": "929940",
    "end": "940015"
  },
  {
    "start": "940015",
    "end": "966550"
  },
  {
    "start": "945000",
    "end": "1165000"
  },
  {
    "text": "So you could write down a\nrecurrence for the running time here. But in some sense recurrences\naren't quite the right way",
    "start": "966550",
    "end": "973050"
  },
  {
    "text": "of thinking about\nthis because recursion is kind of a rare thing. If you're calling\nFibonacci of some value, k,",
    "start": "973050",
    "end": "980839"
  },
  {
    "text": "you're only going to make\nrecursive calls the first time you call Fibonacci of k. Because henceforth,\nyou've put it",
    "start": "980840",
    "end": "988250"
  },
  {
    "text": "in the memo table\nyou will not recurse. So you can think of\nthere being two versions",
    "start": "988250",
    "end": "995370"
  },
  {
    "text": "of calling Fibonacci of k. There's the first time, which\nis the non-memoized version that",
    "start": "995370",
    "end": "1000950"
  },
  {
    "text": "does recursion-- does some work. And then every time\nhenceforth you're",
    "start": "1000950",
    "end": "1006090"
  },
  {
    "text": "doing memoized calls\nof Fibonacci of k, and those cost constant time.",
    "start": "1006090",
    "end": "1011620"
  },
  {
    "text": "So the memoized calls\ncost constant time.",
    "start": "1011620",
    "end": "1019820"
  },
  {
    "text": "So we can think of\nthem as basically free. That's when you call\nFibonacci of n minus 2,",
    "start": "1019820",
    "end": "1026209"
  },
  {
    "text": "because that's a\nmemoized call, you really don't pay anything for it. I mean, you're already\npaying constant time",
    "start": "1026210",
    "end": "1032782"
  },
  {
    "text": "to do addition and whatever. So you don't have to\nworry about the time. There's no recursion here.",
    "start": "1032782",
    "end": "1038900"
  },
  {
    "text": "And then what we care\nabout is that the number of non-memorized calls,\nwhich is the first time you",
    "start": "1038900",
    "end": "1046949"
  },
  {
    "text": "call Fibonacci of k, is n.",
    "start": "1046950",
    "end": "1053924"
  },
  {
    "text": "No theta is even necessary. We are going to\ncall Fibonacci of 1.",
    "start": "1053925",
    "end": "1058990"
  },
  {
    "text": "At some point we're going\nto call Fibonacci of 2 at some point, and the original\ncall is Fibonacci of n.",
    "start": "1058990",
    "end": "1066038"
  },
  {
    "text": "All of those things will\nbe called at some point. That's pretty easy to see. But in particular,\ncertainly at most this,",
    "start": "1066038",
    "end": "1072050"
  },
  {
    "text": "we never call\nFibonacci of n plus 1 to compute Fibonacci of n. So it's at most n calls.",
    "start": "1072050",
    "end": "1077460"
  },
  {
    "text": "Indeed it will be exactly n\ncalls that are not memoized. Those ones we have to pay for. How much do we have to pay?",
    "start": "1077460",
    "end": "1083650"
  },
  {
    "text": "Well, if you don't\ncount the recursion-- which is what this recurrence\ndoes-- if you ignore recursion",
    "start": "1083650",
    "end": "1091068"
  },
  {
    "text": "then the total amount of\nwork done here is constant. ",
    "start": "1091068",
    "end": "1096110"
  },
  {
    "text": "So I will say the non-recursive\nwork per call is constant.",
    "start": "1096110",
    "end": "1110630"
  },
  {
    "text": "And therefore I claim that\nthe running time is constant-- I'm sorry, is linear.",
    "start": "1110630",
    "end": "1117870"
  },
  {
    "text": "Constant would be\npretty amazing. This is actually not the\nbest algorithm-- as an aside.",
    "start": "1117870",
    "end": "1124310"
  },
  {
    "text": "The best algorithm for computing\nthe nth Fibonacci number uses log n arithmetic\noperations.",
    "start": "1124310",
    "end": "1130207"
  },
  {
    "text": "So you can do better,\nbut if you want to see that you should take 6046.",
    "start": "1130207",
    "end": "1135430"
  },
  {
    "text": "OK. We're just going to get\nto linear today, which is a lot better than exponential.",
    "start": "1135430",
    "end": "1141429"
  },
  {
    "text": "So why linear? Because there's n non-memoized\ncalls, and each of them",
    "start": "1141430",
    "end": "1147700"
  },
  {
    "text": "cost constant. So it's the product\nof those two numbers. This is an important idea.",
    "start": "1147700",
    "end": "1154820"
  },
  {
    "text": "And it's so important\nI'm going to write it down again in a slightly\nmore general framework.",
    "start": "1154820",
    "end": "1165080"
  },
  {
    "start": "1165000",
    "end": "1660000"
  },
  {
    "text": "In general, in\ndynamic programming-- ",
    "start": "1165080",
    "end": "1177400"
  },
  {
    "text": "I didn't say why it's\ncalled memoization. The idea is you have this\nmemo pad where you write",
    "start": "1177400",
    "end": "1182670"
  },
  {
    "text": "down all your scratch work. That's this memo dictionary. And to memoize is to write\ndown on your memo pad.",
    "start": "1182670",
    "end": "1189390"
  },
  {
    "text": "I didn't make it up. Another crazy term. It means remember.",
    "start": "1189390",
    "end": "1195450"
  },
  {
    "text": "And then you remember all the\nsolutions that you've done. And then you reuse\nthose solutions.",
    "start": "1195450",
    "end": "1202380"
  },
  {
    "text": "Now these solutions are\nnot really a solution to the problem\nthat I care about. The problem I care about is\ncomputing the nth Fibonacci",
    "start": "1202380",
    "end": "1208970"
  },
  {
    "text": "number. To get there I had to compute\nother Fibonacci numbers. Why?",
    "start": "1208970",
    "end": "1215059"
  },
  {
    "text": "Because I had a\nrecursive formulation. This is not always the\nway to solve a problem. But usually when you're\nsolving something",
    "start": "1215060",
    "end": "1222549"
  },
  {
    "text": "you can split it into parts,\ninto subproblems, we call them.",
    "start": "1222550",
    "end": "1228030"
  },
  {
    "text": "They're not always\nof the same flavor as your original goal\nproblem, but there's some kind of related parts.",
    "start": "1228030",
    "end": "1234289"
  },
  {
    "text": "And this is the big\nchallenge in designing a dynamic program, is to figure\nout what are the subproblems.",
    "start": "1234290",
    "end": "1241410"
  },
  {
    "text": "Let's say, the\nfirst thing I want to know about a dynamic program,\nis what are the subproblems. ",
    "start": "1241410",
    "end": "1247610"
  },
  {
    "text": "Somehow they are designed to\nhelp solve your actual problem. ",
    "start": "1247610",
    "end": "1258650"
  },
  {
    "text": "And the idea of memoization is,\nonce you solve a subproblem, write down the answer. If you ever need to solve\nthat same subproblem again",
    "start": "1258650",
    "end": "1265350"
  },
  {
    "text": "you reuse the answer. So that is the core idea. And so in this sense\ndynamic programming",
    "start": "1265350",
    "end": "1270800"
  },
  {
    "text": "is essentially recursion\nplus memoization.",
    "start": "1270800",
    "end": "1276025"
  },
  {
    "start": "1276025",
    "end": "1283490"
  },
  {
    "text": "And so in this case these\nare the subproblems. Fibonacci of 1 through\nFibonacci of n.",
    "start": "1283490",
    "end": "1289950"
  },
  {
    "text": "The one we care about\nis Fibonacci of n. But to get there we solve\nthese other subproblems. ",
    "start": "1289950",
    "end": "1296290"
  },
  {
    "text": "In all cases, if this\nis the situation-- so for any dynamic\nprogram, the running time",
    "start": "1296290",
    "end": "1303279"
  },
  {
    "text": "is going to be equal to the\nnumber of different subproblems you might have to solve,\nor that you do solve,",
    "start": "1303280",
    "end": "1310590"
  },
  {
    "text": "times the amount of time\nyou spend per subproblem. ",
    "start": "1310590",
    "end": "1320950"
  },
  {
    "text": "OK. In this situation we\nhad n subproblems.",
    "start": "1320950",
    "end": "1326960"
  },
  {
    "text": "And for each of them\nwe spent constant time. And when I measure the\ntime per subproblem",
    "start": "1326960",
    "end": "1333580"
  },
  {
    "text": "which, in the Fibonacci\ncase I claim is constant, I ignore recursive calls.",
    "start": "1333580",
    "end": "1338790"
  },
  {
    "text": "That's the key. We don't have to\nsolve recurrences with dynamic programming. Yay. No recurrences necessary.",
    "start": "1338790",
    "end": "1345250"
  },
  {
    "text": "OK. Don't count recursions. ",
    "start": "1345250",
    "end": "1354279"
  },
  {
    "text": "Obviously, don't count\nmemoized recursions. The reason is, I only\nneed to count them once.",
    "start": "1354280",
    "end": "1359750"
  },
  {
    "text": "After the first time\nI do it, it's free. So I count how many different\nsubproblems do I need to do?",
    "start": "1359750",
    "end": "1365835"
  },
  {
    "text": "These are they going to be\nthe expensive recursions where I do work, I do\nsome amount of work, but I don't count the\nrecursions because otherwise I'd",
    "start": "1365835",
    "end": "1372060"
  },
  {
    "text": "be double counting. I only want to count\neach subproblem once, and then this will solve it.",
    "start": "1372060",
    "end": "1379010"
  },
  {
    "text": "So a simple idea. In general, dynamic programming\nis a super simple idea. It's nothing fancy.",
    "start": "1379010",
    "end": "1385390"
  },
  {
    "text": "It's basically just memoization. There is one extra trick\nwe're going to pull out,",
    "start": "1385390",
    "end": "1390730"
  },
  {
    "text": "but that's the idea. All right. Let me tell you\nanother perspective.",
    "start": "1390730",
    "end": "1404010"
  },
  {
    "text": "This is the one maybe\nmost commonly taught. Is to think of-- but I'm\nnot a particular fan of it.",
    "start": "1404010",
    "end": "1411260"
  },
  {
    "text": "I really like memoization. I think it's a simple idea. And as long as you\nremember this formula here,",
    "start": "1411260",
    "end": "1418500"
  },
  {
    "text": "it's really easy to work with.  But some people like to\nthink of it this way.",
    "start": "1418500",
    "end": "1425559"
  },
  {
    "text": "And so you can pick whichever\nway you find most intuitive. Instead of thinking of a\nrecursive algorithm, which",
    "start": "1425560",
    "end": "1431440"
  },
  {
    "text": "in some sense starts at the\ntop of what you want to solve and works its way down,\nyou could do the reverse.",
    "start": "1431440",
    "end": "1438659"
  },
  {
    "text": "You could start at the\nbottom and work your way up. And this is probably\nhow you normally think about computing\nFibonacci numbers",
    "start": "1438660",
    "end": "1443995"
  },
  {
    "text": "or how you learned it before. I'm going to write it\nin a slightly funny way. ",
    "start": "1443995",
    "end": "1471655"
  },
  {
    "text": "The point I want to make\nis that the transformation I'm doing from the naive\nrecursive algorithm,",
    "start": "1471655",
    "end": "1478840"
  },
  {
    "text": "to the memoized algorithm,\nto the bottom-up algorithm is completely automated.",
    "start": "1478840",
    "end": "1484029"
  },
  {
    "text": "I'm not thinking,\nI'm just doing. OK. It's easy.",
    "start": "1484030",
    "end": "1489500"
  },
  {
    "text": "This code is exactly\nthe same as this code and as that code, except\nI replaced n by k.",
    "start": "1489500",
    "end": "1496590"
  },
  {
    "text": "Just because I needed a couple\nof different n values here. Or I want to iterate\nover n values. ",
    "start": "1496590",
    "end": "1504110"
  },
  {
    "text": "And then there's this\nstuff around that code which is just formulaic. ",
    "start": "1504110",
    "end": "1511000"
  },
  {
    "text": "A little bit of thought\ngoes into this for loop, but that's it. OK. This does exactly the same\nthing as the memoized algorithm.",
    "start": "1511000",
    "end": "1519110"
  },
  {
    "text": " Maybe it takes a\nlittle bit of thinking",
    "start": "1519110",
    "end": "1524150"
  },
  {
    "text": "to realize, if you unroll all\nthe recursion that's happening here and just write\nit out sequentially,",
    "start": "1524150",
    "end": "1529350"
  },
  {
    "text": "this is exactly\nwhat's happening. This code does exactly the\nsame additions, exactly",
    "start": "1529350",
    "end": "1534580"
  },
  {
    "text": "the same computations as this. The only difference\nis how you get there.",
    "start": "1534580",
    "end": "1539690"
  },
  {
    "text": "Here we're using a loop,\nhere we're using recursion. But the same things\nhappen in the same order.",
    "start": "1539690",
    "end": "1545558"
  },
  {
    "text": "It's really no difference\nbetween the code. This code's probably going\nto be more efficient practice because you don't make\nfunction calls so much.",
    "start": "1545558",
    "end": "1552980"
  },
  {
    "text": "In fact I made a\nlittle mistake here. This is not a\nfunction call, it's just a lookup into a table.",
    "start": "1552980",
    "end": "1559470"
  },
  {
    "text": "Here I'm using a hash\ntable to be simple, but of course you\ncould use an array. ",
    "start": "1559470",
    "end": "1565920"
  },
  {
    "text": "But they're both constant\ntime with good hashing. All right. So is it clear\nwhat this is doing?",
    "start": "1565920",
    "end": "1572380"
  },
  {
    "text": "I think so. I think I made a little typo. So we have to compute--",
    "start": "1572380",
    "end": "1579220"
  },
  {
    "text": "oh, another typo. We have to compute f1 up to\nfn, which in python is that.",
    "start": "1579220",
    "end": "1587010"
  },
  {
    "text": "And we compute it\nexactly how we used to. Except now, instead\nof recursing,",
    "start": "1587010",
    "end": "1594020"
  },
  {
    "text": "I know that when I'm computing\nthe k Fibonacci number-- man. So many typos.",
    "start": "1594020",
    "end": "1599135"
  },
  {
    "text": "AUDIENCE: [LAUGHTER] PROFESSOR: You\nguys are laughing. When I compute the\nkth Fibonacci number",
    "start": "1599135",
    "end": "1605230"
  },
  {
    "text": "I know that I've already\ncomputed the previous two. Why? Because I'm doing them\nin increasing order.",
    "start": "1605230",
    "end": "1610549"
  },
  {
    "text": "Nothing fancy. Then I can just do\nthis and the solutions will just be waiting there.",
    "start": "1610550",
    "end": "1616750"
  },
  {
    "text": "If they work, I'd\nget a key error. So I'd know that there's a bug. But in fact, I won't\nget a key error. I will have always computed\nthese things already.",
    "start": "1616750",
    "end": "1625090"
  },
  {
    "text": "Then I store it in my table. Then I iterate. Eventually I've solved all the\nsubproblems, f1 through fn.",
    "start": "1625090",
    "end": "1631250"
  },
  {
    "text": "And the one I cared\nabout was the nth one. OK. So straightforward.",
    "start": "1631250",
    "end": "1637490"
  },
  {
    "text": "I do this because\nI don't really want to have to go through\nthis transformation for every single problem we do.",
    "start": "1637490",
    "end": "1642537"
  },
  {
    "text": "I'm doing it in\nFibonacci because it's super easy to write the\ncode out explicitly. But you can do it for all\nof the dynamic programs",
    "start": "1642537",
    "end": "1649200"
  },
  {
    "text": "that we cover in the\nnext four lectures. OK. I'm going to give you\nnow the general case.",
    "start": "1649200",
    "end": "1655810"
  },
  {
    "text": "This was the special\nFibonacci version. In general, the bottom-up does\nexactly the same computation",
    "start": "1655810",
    "end": "1664230"
  },
  {
    "start": "1660000",
    "end": "1880000"
  },
  {
    "text": "as the memoized version. ",
    "start": "1664230",
    "end": "1671269"
  },
  {
    "text": "And what we're doing is\nactually a topological sort",
    "start": "1671270",
    "end": "1679920"
  },
  {
    "text": "of the subproblem\ndependency DAG.",
    "start": "1679920",
    "end": "1685195"
  },
  {
    "start": "1685195",
    "end": "1693840"
  },
  {
    "text": "So in this case, the\ndependency DAG is very simple. In order to compute--",
    "start": "1693840",
    "end": "1699504"
  },
  {
    "text": "I'll do it backwards. In order to compute fn,\nI need to know fn minus 1",
    "start": "1699504",
    "end": "1706450"
  },
  {
    "text": "and fn minus 2. If I know those\nI can compute fn.",
    "start": "1706450",
    "end": "1712090"
  },
  {
    "text": "Then there's fn\nminus 3, which is necessary to compute this\none, and that one, and so on.",
    "start": "1712090",
    "end": "1718450"
  },
  {
    "text": "So you see what\nthis DAG looks like. Now, I've drawn\nit conveniently so all the edges go left to right.",
    "start": "1718450",
    "end": "1723510"
  },
  {
    "text": "So this is a topological\norder from left to right. And so I just need to do\nf1, f2, up to fn in order.",
    "start": "1723510",
    "end": "1730760"
  },
  {
    "text": "Usually it's totally\nobvious what order to solve the subproblems in. But in general, what\nyou should have in mind",
    "start": "1730760",
    "end": "1738320"
  },
  {
    "text": "is that we are doing\na topological sort. Here we just did it in our\nheads because it's so easy. And usually it's so easy.",
    "start": "1738320",
    "end": "1744220"
  },
  {
    "text": "It's just a for loop. Nothing fancy. ",
    "start": "1744220",
    "end": "1749900"
  },
  {
    "text": "All right.  I'm missing an arrow. ",
    "start": "1749900",
    "end": "1760029"
  },
  {
    "text": "All right. Let's do something a little\nmore interesting, shall we? ",
    "start": "1760030",
    "end": "1777970"
  },
  {
    "text": "All right. One thing you can do from\nthis bottom-up perspective is you can save space. ",
    "start": "1777970",
    "end": "1786310"
  },
  {
    "text": "Storage space in the algorithm. We don't usually worry\nabout space in this class, but it matters in reality.",
    "start": "1786310",
    "end": "1795910"
  },
  {
    "text": "So here we're\nbuilding a table size, n, but in fact we really only\nneed to remember the last two values.",
    "start": "1795910",
    "end": "1802279"
  },
  {
    "text": "So you could just store\nthe last two values, and each time you make a\nnew one delete the oldest.",
    "start": "1802280",
    "end": "1807620"
  },
  {
    "text": "so by thinking a\nlittle bit here you realize you only\nneed constant space. Still linear time,\nbut constant space.",
    "start": "1807620",
    "end": "1815789"
  },
  {
    "text": "And that's often the case. From the bottom-up\nperspective you see what you really\nneed to store, what you need to keep track of.",
    "start": "1815790",
    "end": "1821990"
  },
  {
    "text": " All right. I guess another nice thing\nabout this perspective",
    "start": "1821990",
    "end": "1828400"
  },
  {
    "text": "is, the running time\nis totally obvious. This is clearly constant time. So this is clearly linear time.",
    "start": "1828400",
    "end": "1834730"
  },
  {
    "text": "Whereas, in this\nmemoized algorithm you have to think\nabout, when's it",
    "start": "1834730",
    "end": "1840110"
  },
  {
    "text": "going to be memoized,\nwhen is it not? I still like this perspective\nbecause, with this rule, just multiply a\nnumber of subproblems",
    "start": "1840110",
    "end": "1846520"
  },
  {
    "text": "by time per subproblem,\nyou get the answer. But it's a little less\nobvious than code like this.",
    "start": "1846520",
    "end": "1854299"
  },
  {
    "text": "So choose however you\nlike to think about it. ",
    "start": "1854300",
    "end": "1860340"
  },
  {
    "text": "All right. We move on to shortest paths. ",
    "start": "1860340",
    "end": "1888889"
  },
  {
    "start": "1880000",
    "end": "1955000"
  },
  {
    "text": "So I'm again, as usual, thinking\nabout single-source shortest paths.",
    "start": "1888890",
    "end": "1893980"
  },
  {
    "text": "So we want to compute the\nshortest pathway from s to v for all v. OK.",
    "start": "1893980",
    "end": "1901550"
  },
  {
    "text": "I'd like to write this initially\nas a naive recursive algorithm, which I can then memoize,\nwhich I can then bottom-upify.",
    "start": "1901550",
    "end": "1909900"
  },
  {
    "text": "I just made that up. So how could I write this as\na naive recursive algorithm?",
    "start": "1909900",
    "end": "1917080"
  },
  {
    "text": "It's not so obvious. But first I'm going to tell you\nhow, just as an oracle tells",
    "start": "1917080",
    "end": "1926850"
  },
  {
    "text": "you, here's what you should do. But then we're going to think\nabout-- go back, step back. Actually, it's up to you.",
    "start": "1926850",
    "end": "1931992"
  },
  {
    "text": "I could tell you\nthe answer and then we could figure out\nhow we got there, or we could just\nfigure out the answer.",
    "start": "1931992",
    "end": "1938380"
  },
  {
    "text": "Preferences?  Figure it out. All right.",
    "start": "1938380",
    "end": "1943433"
  },
  {
    "text": "Good. No divine inspiration allowed. So let me give you a tool.",
    "start": "1943433",
    "end": "1957584"
  },
  {
    "start": "1955000",
    "end": "2100000"
  },
  {
    "text": "The tool is guessing. ",
    "start": "1957584",
    "end": "1962660"
  },
  {
    "text": "This may sound silly, but\nit's a very powerful tool. ",
    "start": "1962660",
    "end": "1968500"
  },
  {
    "text": "The general idea is, suppose\nyou don't know something but you'd like to know it. So what's the answer\nto this question?",
    "start": "1968500",
    "end": "1975350"
  },
  {
    "text": "I don't know. Man, I really want a cushion. How am I going to\nanswer the question? Guess.",
    "start": "1975350",
    "end": "1980440"
  },
  {
    "text": "OK? AUDIENCE: [LAUGHTER] PROFESSOR: It's a\ntried and tested method for solving any problem.",
    "start": "1980440",
    "end": "1985490"
  },
  {
    "start": "1985490",
    "end": "1996920"
  },
  {
    "text": "I'm kind of belaboring\nthe point here. The algorithmic concept is,\ndon't just try any guess.",
    "start": "1996920",
    "end": "2003610"
  },
  {
    "text": "Try them all. OK? AUDIENCE: [LAUGHTER]",
    "start": "2003610",
    "end": "2009490"
  },
  {
    "text": "PROFESSOR: Also pretty simple. I said dynamic\nprogramming was simple. OK. ",
    "start": "2009490",
    "end": "2018400"
  },
  {
    "text": "Try all guesses. This is central to the\ndynamic programming.",
    "start": "2018400",
    "end": "2025430"
  },
  {
    "text": "I know it sounds obvious, but if\nI want to fix my equation here,",
    "start": "2025430",
    "end": "2032470"
  },
  {
    "text": "dynamic programming is roughly\nrecursion plus memoization.",
    "start": "2032470",
    "end": "2038260"
  },
  {
    "text": "This should really\nbe, plus guessing. Memoization, which is obvious,\nguessing which is obvious,",
    "start": "2038260",
    "end": "2046340"
  },
  {
    "text": "are the central concepts\nto dynamic programming. I'm trying to make it sound\neasy because usually people have trouble with\ndynamic programming.",
    "start": "2046340",
    "end": "2052802"
  },
  {
    "text": "It is easy. Try all the guesses. That's something a\ncomputer can do great.",
    "start": "2052802",
    "end": "2058500"
  },
  {
    "text": "This is the brute force part. OK. But we're going to\ndo it carefully.",
    "start": "2058500",
    "end": "2063690"
  },
  {
    "text": "Not that carefully. I mean, we're just\ntrying all the guesses. Take the best one. ",
    "start": "2063690",
    "end": "2073960"
  },
  {
    "text": "That's kind of important\nthat we can choose one to be called best. That's why dynamic\nprogramming is good for optimization problems.",
    "start": "2073960",
    "end": "2079610"
  },
  {
    "text": "You want to maximize\nsomething, minimize something, you try them all and then you\ncan forget about all of them",
    "start": "2079610",
    "end": "2085129"
  },
  {
    "text": "and just reduce it\ndown to one thing which is the best one, or a best one.",
    "start": "2085130",
    "end": "2090888"
  },
  {
    "text": "OK. So now I want you to try\nto apply this principle to shortest paths.",
    "start": "2090889",
    "end": "2096638"
  },
  {
    "text": "Now I'm going to draw a\npicture which may help. We have the source, s,\nwe have some vertex,",
    "start": "2096639",
    "end": "2108789"
  },
  {
    "text": "v. We'd like to\nfind the shortest-- a shortest path from s to v.",
    "start": "2108790",
    "end": "2113870"
  },
  {
    "text": "Suppose I want to know\nwhat this shortest path is. Suppose this was it. You have an idea already?",
    "start": "2113870",
    "end": "2119790"
  },
  {
    "text": "Yeah. AUDIENCE: What you could do is\nyou could look at everywhere",
    "start": "2119790",
    "end": "2127550"
  },
  {
    "text": "you can go from s. And then: okay, what's shortest\npath of each of those notes.",
    "start": "2127550",
    "end": "2133073"
  },
  {
    "text": "PROFESSOR: Good. So I can look at all the\nplaces I could go from s, and then look at the shortest\npaths from there to v.",
    "start": "2133073",
    "end": "2141790"
  },
  {
    "text": "So we could call this s prime. So here's the idea. There's some hypothetical\nshortest path.",
    "start": "2141790",
    "end": "2150720"
  },
  {
    "text": "I don't know where\nit goes first, so I will guess\nwhere it goes first.",
    "start": "2150720",
    "end": "2156080"
  },
  {
    "text": "I know the first\nedge must be one of the outgoing edges from s. I don't know which one.",
    "start": "2156080",
    "end": "2161100"
  },
  {
    "text": "Try them all. Very simple idea. Then from each of\nthose, if somehow I can compute the shortest\npath from there to v,",
    "start": "2161100",
    "end": "2170590"
  },
  {
    "text": "just do that and\ntake the best choice for what that first edge was.",
    "start": "2170590",
    "end": "2175650"
  },
  {
    "text": "So this would be the\nguess first edge approach. ",
    "start": "2175650",
    "end": "2182339"
  },
  {
    "text": "It's a very good idea. Not quite the one I wanted\nbecause unfortunately",
    "start": "2182340",
    "end": "2188470"
  },
  {
    "text": "that changes s. And so this would\nwork, it would just be slightly less\nefficient if I'm solving",
    "start": "2188470",
    "end": "2193940"
  },
  {
    "text": "single-source shortest paths. So I'm going to tweak\nthat idea slightly by guessing the last edge\ninstead of the first edge.",
    "start": "2193940",
    "end": "2200310"
  },
  {
    "text": "They're really equivalent. If I was doing this\nI'd essentially be solving a single-target\nshortest paths,",
    "start": "2200310",
    "end": "2206480"
  },
  {
    "text": "which we talked about before. So I'm going to draw\nthe same picture.",
    "start": "2206480",
    "end": "2211645"
  },
  {
    "text": " I want to get to v. I'm\ngoing to guess the last edge,",
    "start": "2211645",
    "end": "2219430"
  },
  {
    "text": "call it uv. I know it's one of the\nincoming edges to v--",
    "start": "2219430",
    "end": "2225130"
  },
  {
    "text": "unless s equals v, then\nthere's a special case. As long as this path has\nlength of at least 1, there's some last edge.",
    "start": "2225130",
    "end": "2231289"
  },
  {
    "text": "What is it? I don't know. Guess. Guess all the possible\nincoming edges",
    "start": "2231290",
    "end": "2236310"
  },
  {
    "text": "to v, and then recursively\ncompute the shortest",
    "start": "2236310",
    "end": "2241390"
  },
  {
    "text": "path from s to u. And then add on the edge v. OK. So what is this shortest path?",
    "start": "2241390",
    "end": "2247750"
  },
  {
    "text": "It's delta of s comma\nu, which looks the same. It's another subproblem\nthat I want to solve.",
    "start": "2247750",
    "end": "2254910"
  },
  {
    "text": "There's v subproblems\nhere I care about. . So that's good. I take that. I add on the weight\nof the edge uv.",
    "start": "2254910",
    "end": "2261805"
  },
  {
    "text": " And that should hopefully\ngive me delta of s comma v.",
    "start": "2261805",
    "end": "2270020"
  },
  {
    "text": "Well, if I was lucky and I\nguessed the right choice of u. In reality, I'm not lucky.",
    "start": "2270020",
    "end": "2275490"
  },
  {
    "text": "So I have to minimize\nover all edges uv.",
    "start": "2275490",
    "end": "2282790"
  },
  {
    "text": "So this is the-- we're minimizing\nover the choice of u. V is already given here.",
    "start": "2282790",
    "end": "2288420"
  },
  {
    "text": "So I take the minimum over\nall edges of the shortest path from s to u, plus\nthe weight of the edge uv.",
    "start": "2288420",
    "end": "2297323"
  },
  {
    "text": "That should give me the shortest\npath because this gave me the shortest path from s to u. Then I added on the edge\nI need to get there.",
    "start": "2297323",
    "end": "2304110"
  },
  {
    "text": "And wherever the shortest path\nis, it uses some last edge, uv.",
    "start": "2304110",
    "end": "2310120"
  },
  {
    "text": "There's got to be some choice\nof u that is the right one. That's the good guess\nthat we're hoping for.",
    "start": "2310120",
    "end": "2315244"
  },
  {
    "text": "We don't know what\nthe good guess is so we just try them all. But whatever it is, this will\nbe the weight of that path.",
    "start": "2315245",
    "end": "2323265"
  },
  {
    "text": "It's going to take\nthe best path from s to u because sub\npaths are shortest paths are shortest paths. Optimal substructure.",
    "start": "2323265",
    "end": "2328900"
  },
  {
    "text": "So this part will\nbe delta of su. This part is obviously w of uv.",
    "start": "2328900",
    "end": "2333950"
  },
  {
    "text": "So this will give\nthe right answer. Hopefully.",
    "start": "2333950",
    "end": "2339610"
  },
  {
    "text": "OK. It's certainly going to-- I mean, this is the analog of\nthe naive recursive algorithm",
    "start": "2339610",
    "end": "2345100"
  },
  {
    "text": "for Fibonacci. So it's not going to\nbe efficient if I-- I mean, this is an\nalgorithm, right? You could say-- this\nis a recursive call.",
    "start": "2345100",
    "end": "2353720"
  },
  {
    "text": "We're going to treat this\nas recursive call instead of just a definition.",
    "start": "2353720",
    "end": "2359910"
  },
  {
    "text": "Then this is a\nrecursive algorithm. How good or bad is this\nrecursive algorithm?",
    "start": "2359910",
    "end": "2367086"
  },
  {
    "text": "AUDIENCE: Terrible. PROFESSOR: Terrible. Very good. Very bad, I should say. ",
    "start": "2367086",
    "end": "2374000"
  },
  {
    "text": "It's definitely going\nto be exponential without memoization.",
    "start": "2374000",
    "end": "2379120"
  },
  {
    "text": "But we know. We know how to make\nalgorithms better. We memoize. OK. So I think you know how to write\nthis as a memoized algorithm.",
    "start": "2379120",
    "end": "2386849"
  },
  {
    "text": "To define the function delta\nof sv, you first check, is s comma v in the memo table?",
    "start": "2386850",
    "end": "2394080"
  },
  {
    "text": "If so return that value. Otherwise, do this computation\nwhere this is a recursive call",
    "start": "2394080",
    "end": "2399450"
  },
  {
    "text": "and then store it\nin the memo table. OK. I don't think I need\nto write that down.",
    "start": "2399450",
    "end": "2405127"
  },
  {
    "text": "It's just like the\nmemoized code over there. Just there's now two\narguments instead of one.",
    "start": "2405127",
    "end": "2411190"
  },
  {
    "text": "In fact, s isn't changing. So I only need to store\nwith v instead of s comma v.",
    "start": "2411190",
    "end": "2418500"
  },
  {
    "text": "Is that a good algorithm? I claim memoization\nmakes everything faster.",
    "start": "2418500",
    "end": "2423570"
  },
  {
    "text": "Is that a fast algorithm? ",
    "start": "2423570",
    "end": "2436560"
  },
  {
    "text": "Not so obvious, I guess. ",
    "start": "2436560",
    "end": "2451079"
  },
  {
    "text": "Yes? How many people think, yes,\nthat's a good algorithm? AUDIENCE: Better. PROFESSOR: Better. Definitely better.",
    "start": "2451080",
    "end": "2457090"
  },
  {
    "text": "Can't be worse. How many people think it's\na bad algorithm still? OK. So three for yes, zero for no.",
    "start": "2457090",
    "end": "2464760"
  },
  {
    "text": "How many people aren't sure? Including the yes votes?",
    "start": "2464760",
    "end": "2469870"
  },
  {
    "text": "Good.  All right. It's not so tricky. Let me draw you a graph.",
    "start": "2469870",
    "end": "2475414"
  },
  {
    "start": "2475415",
    "end": "2487372"
  },
  {
    "text": "Something like that. So we wanted to commit\ndelta of s comma v. Let me",
    "start": "2487372",
    "end": "2494660"
  },
  {
    "text": "give these guys names, a and b. So we compute delta of\ns comma v. To compute that we need to know delta of s\ncomma a and delta of s comma b.",
    "start": "2494660",
    "end": "2507609"
  },
  {
    "text": "All right? Those are the two ways-- sorry, actually\nwe just need one. Only one incoming edge to v.\nSo its delta of s comma a.",
    "start": "2507610",
    "end": "2517640"
  },
  {
    "text": " Sorry-- I should have\nput a base case here too.",
    "start": "2517640",
    "end": "2524089"
  },
  {
    "text": "Delta of s comma s equals 0. ",
    "start": "2524090",
    "end": "2530200"
  },
  {
    "text": "OK. Delta of s comma\na plus the edge. OK. There is some\nshortest path to a. To compute the shortest\npath to a we look",
    "start": "2530200",
    "end": "2536710"
  },
  {
    "text": "at all the incoming edges to a. There's only one. So delta of s comma b.",
    "start": "2536710",
    "end": "2542319"
  },
  {
    "text": "Now I want to compute the\nshortest paths from b. Well, there's two\nways to get to b. One of them is\ndelta of s comma b--",
    "start": "2542320",
    "end": "2550760"
  },
  {
    "text": "sorry, s comma s. Came from s. The other way is delta of s\ncomma v. Do you see a problem?",
    "start": "2550760",
    "end": "2562760"
  },
  {
    "text": "Yeah. Delta of s comma v is what\nwe were trying to figure out. ",
    "start": "2562760",
    "end": "2570079"
  },
  {
    "text": "Now you might say, oh,\nit's OK because we're going to memoize our\nanswer to delta s comma v and then we can reuse it here.",
    "start": "2570080",
    "end": "2575310"
  },
  {
    "text": "Except, we haven't finished\ncomputing delta of s comma v. We can only put it in\nthe memo table once we're done.",
    "start": "2575310",
    "end": "2582340"
  },
  {
    "text": "So when this call happens the\nmemo table has not been set. And we're going to\ndo the same thing",
    "start": "2582340",
    "end": "2587930"
  },
  {
    "text": "over and over and over again. This is an infinite algorithm. Oops.",
    "start": "2587930",
    "end": "2594740"
  },
  {
    "text": "Not so hot.  So it's going to be infinite\ntime on graphs with cycles.",
    "start": "2594740",
    "end": "2610160"
  },
  {
    "text": " OK.",
    "start": "2610160",
    "end": "2615655"
  },
  {
    "text": "For DAGs, for acyclic graphs, it\nactually runs in v plus e time.",
    "start": "2615655",
    "end": "2622400"
  },
  {
    "text": "This is the good case. In this situation we\ncan use this formula. The time is equal to the\nnumber of subproblems",
    "start": "2622400",
    "end": "2628940"
  },
  {
    "text": "times the time per subproblem. So I guess we have to think\nabout that a little bit.",
    "start": "2628940",
    "end": "2635040"
  },
  {
    "text": "Where's my code? Here's my code. Number of subproblems is v.\nThere's v different subproblems",
    "start": "2635040",
    "end": "2642230"
  },
  {
    "text": "that I'm using here. I'm always reusing\nsubproblems of the form delta s comma something. The something could be\nany of the v vertices.",
    "start": "2642230",
    "end": "2650309"
  },
  {
    "text": "How much time do I\nspend per subproblem? That's a little tricky.",
    "start": "2650310",
    "end": "2655790"
  },
  {
    "text": "It's the number\nof incoming edges to v. So time for a\nsub problem delta of sv",
    "start": "2655790",
    "end": "2670710"
  },
  {
    "text": "is the indegree of v. The\nnumber of incoming edges to v.",
    "start": "2670710",
    "end": "2676849"
  },
  {
    "text": "So this depends on v.\nSo I can't just take a straightforward product here. What this is really\nsaying is, you",
    "start": "2676850",
    "end": "2682119"
  },
  {
    "text": "should sum up over\nall sub problems of the time per sub problem. So total time is the sum over\nall v and v, the indegree of v.",
    "start": "2682120",
    "end": "2698360"
  },
  {
    "text": "And we know this\nis number of edges. It's really-- so indegree\nplus 1, indegree plus 1.",
    "start": "2698360",
    "end": "2706650"
  },
  {
    "text": "So this is v plus v. OK. Handshaking lemma again.",
    "start": "2706650",
    "end": "2714060"
  },
  {
    "text": "OK. Now we already knew an algorithm\nfor shortest paths and DAGs. And it ran in v plus e time. So it's another way\nto do the same thing.",
    "start": "2714060",
    "end": "2721369"
  },
  {
    "text": "If you think about\nit long enough, this algorithm\nmemoized, is essentially",
    "start": "2721370",
    "end": "2727339"
  },
  {
    "text": "doing a depth-first search to\ndo a topological sort to run one round of Bellman-Ford.",
    "start": "2727340",
    "end": "2733440"
  },
  {
    "text": "So we had topological sort\nplus one round of Bellman-Ford. This is kind of it\nall rolled into one. This should look kind of like\nthe Bellman Ford relaxation",
    "start": "2733440",
    "end": "2740630"
  },
  {
    "text": "step, or shortest\npaths relaxation step. It is. This min is really\ndoing the same thing.",
    "start": "2740630",
    "end": "2746723"
  },
  {
    "text": "So it's really the\nsame algorithm. But we come at it from\na different perspective. ",
    "start": "2746723",
    "end": "2752400"
  },
  {
    "text": "OK. But I claim I can use\nthis same approach to solve shortest paths in\ngeneral graphs, even when they",
    "start": "2752400",
    "end": "2758830"
  },
  {
    "text": "have cycles. How am I going to do that?",
    "start": "2758830",
    "end": "2764170"
  },
  {
    "text": "DAGs seem fine-- oh, what\nwas the lesson learned here? Lesson learned is that\nsubproblem dependencies",
    "start": "2764170",
    "end": "2778400"
  },
  {
    "text": "should be acyclic. Otherwise, we get an\ninfinite algorithm. For memoization to work\nthis is what you need.",
    "start": "2778400",
    "end": "2784990"
  },
  {
    "text": "It's all you need.  OK.",
    "start": "2784990",
    "end": "2790090"
  },
  {
    "text": "We've almost seen this already. Because I said that, to\ndo a bottom up algorithm you do a topological sort of\nthis subproblem dependency DAG.",
    "start": "2790090",
    "end": "2799140"
  },
  {
    "text": "I already said it\nshould be acyclic. OK. We just forgot. I didn't tell you yet. So for that to work\nit better be acyclic.",
    "start": "2799140",
    "end": "2805580"
  },
  {
    "text": "For DP to work, for memoization\nto work, it better be acyclic. If you're acyclic then\nthis is the running time.",
    "start": "2805580",
    "end": "2815530"
  },
  {
    "text": "So that's all general. OK. So somehow I need to\ntake a cyclic graph",
    "start": "2815530",
    "end": "2822060"
  },
  {
    "text": "and make it acyclic. ",
    "start": "2822060",
    "end": "2828047"
  },
  {
    "text": "We've actually done this\nalready in recitation. ",
    "start": "2828047",
    "end": "2838740"
  },
  {
    "text": "So if I have a graph-- let's take a very\nsimple cyclic graph.",
    "start": "2838740",
    "end": "2845850"
  },
  {
    "text": "OK. One thing I could do is explode\nit into multiple layers. We did this on quiz\ntwo in various forms.",
    "start": "2845850",
    "end": "2852400"
  },
  {
    "text": "It's like the only cool thing\nyou can do with shortest paths, I feel like.",
    "start": "2852400",
    "end": "2857882"
  },
  {
    "text": "If you want to make a\nshortest path problem harder, require that you reduce your\ngraph to k copies of the graph.",
    "start": "2857882",
    "end": "2865585"
  },
  {
    "text": "I'm going to do it in\na particular way here-- which I think you've\nseen in recitation-- which is to think of\nthis axis as time,",
    "start": "2865585",
    "end": "2873369"
  },
  {
    "text": "or however you want, and\nmake all of the edges go from each layer\nto the next layer. ",
    "start": "2873370",
    "end": "2881080"
  },
  {
    "text": "This should be a\nfamiliar technique. So the idea is, every time\nI follow an edge I go down",
    "start": "2881080",
    "end": "2886400"
  },
  {
    "text": "to the next layer. This makes any graph acyclic. Done.",
    "start": "2886400",
    "end": "2891510"
  },
  {
    "text": "What in the world\ndoes this mean? What is it doing? ",
    "start": "2891510",
    "end": "2900070"
  },
  {
    "text": "What does it mean? Double rainbow. All right. AUDIENCE: [LAUGHTER] PROFESSOR: So-- I\ndon't know how I've",
    "start": "2900070",
    "end": "2906693"
  },
  {
    "text": "gone so long in the\nsemester without referring to double rainbow. It used to be my favorite. All right. So here's what it means.",
    "start": "2906693",
    "end": "2914569"
  },
  {
    "text": "Delta sub k of sv. I'm going to define this\nfirst-- this is a new kind of subproblem--",
    "start": "2914570",
    "end": "2921460"
  },
  {
    "text": "which is, what is the shortest-- what is the weight of\nthe shortest s to v path",
    "start": "2921460",
    "end": "2932940"
  },
  {
    "text": "that uses, at most, k edges. ",
    "start": "2932940",
    "end": "2938732"
  },
  {
    "text": "So I want it to be shortest\nin terms of total weight, but I also want it to\nuse few edges total. So this is going to be 0.",
    "start": "2938732",
    "end": "2945200"
  },
  {
    "text": "In some sense, if you look at-- so here's s and I'm always\ngoing to make s this.",
    "start": "2945200",
    "end": "2951890"
  },
  {
    "text": "And then this is going to\nbe v in the zero situation. This is going to be v in\nthe one situation, v--",
    "start": "2951890",
    "end": "2958150"
  },
  {
    "text": "so if I look at this v, I look\nat the shortest path from s to v, that is delta sub 0 of sv.",
    "start": "2958150",
    "end": "2964040"
  },
  {
    "text": "So maybe I'll call this v\nsub 0, v sub 1, v sub 2. OK. Shortest path from here\nto here is, there's",
    "start": "2964040",
    "end": "2970990"
  },
  {
    "text": "no way to get there on 0 edges. Shortest path from\nhere to here, that is the best way to get there\nwith, at most, one edge.",
    "start": "2970990",
    "end": "2978165"
  },
  {
    "text": "Shortest path from\nhere to here-- well, if I add some\nvertical edges too, I guess, cheating a little bit.",
    "start": "2978165",
    "end": "2983435"
  },
  {
    "text": "Then this is the best\nway to get from s to v using at most two edges. And then you get\na recurrence which",
    "start": "2983435",
    "end": "2991000"
  },
  {
    "text": "is the min over all last edges. So I'm just copying\nthat recurrence,",
    "start": "2991000",
    "end": "2996570"
  },
  {
    "text": "but realizing that the s to\nu part uses one fewer edge.",
    "start": "2996570",
    "end": "3003040"
  },
  {
    "text": "And then I use the edge uv.  OK. That's our new recurrence.",
    "start": "3003040",
    "end": "3009330"
  },
  {
    "text": "By adding this k parameter\nI've made this recurrence on subproblems acyclic. Unfortunately, I've increased\nthe number of subproblems.",
    "start": "3009330",
    "end": "3017050"
  },
  {
    "text": "The number of subproblems\nnow is v squared.",
    "start": "3017050",
    "end": "3028250"
  },
  {
    "text": "Technically, v times v minus 1. Because I really--\nactually, v squared. Sorry.",
    "start": "3028250",
    "end": "3034130"
  },
  {
    "text": "I start at 0. And what I care about, my goal,\nis delta sub v minus 1 of sv.",
    "start": "3034130",
    "end": "3046210"
  },
  {
    "text": "Because by\nBellman-Ford analysis I know that I only care about\nsimple paths, paths of length",
    "start": "3046210",
    "end": "3051270"
  },
  {
    "text": "at most v minus 1. I'm assuming here no\nnegative-weight cycles. I should've said that earlier. If you assume that, then\nthis is what I care about.",
    "start": "3051270",
    "end": "3058619"
  },
  {
    "text": "So k ranges from 0 to v minus 1. So there are v choices for k. There are v choices for v.\nSo the number of subproblems",
    "start": "3058620",
    "end": "3064859"
  },
  {
    "text": "is v squared. How much time do I\nspend per subproblem? Well, the same as before. The indegree-- where\ndid I write it?",
    "start": "3064860",
    "end": "3069890"
  },
  {
    "text": "Up here-- the indegree\nof that problem. So what I'm really\ndoing is summing over all v of the indegree.",
    "start": "3069890",
    "end": "3077400"
  },
  {
    "text": "And then I multiply it by\nv. So the running time, total running time is ve.",
    "start": "3077400",
    "end": "3085240"
  },
  {
    "text": "Sound familiar? This is Bellman-Ford's\nalgorithm again. And this is actually where\nBellman-Ford algorithm",
    "start": "3085240",
    "end": "3092410"
  },
  {
    "text": "came from is this view\non dynamic programming. So we're seeing yet another\nway to do Bellman-Ford.",
    "start": "3092410",
    "end": "3098640"
  },
  {
    "text": "It may seem familiar. But in the next\nthree lectures we're going to see a whole\nbunch of problems that can succumb to the same approach.",
    "start": "3098640",
    "end": "3104650"
  },
  {
    "text": "And that's super cool.",
    "start": "3104650",
    "end": "3107039"
  }
]