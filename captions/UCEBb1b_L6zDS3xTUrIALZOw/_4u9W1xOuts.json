[
  {
    "start": "0",
    "end": "35000"
  },
  {
    "text": " The following content is\nprovided under a Creative Commons License.",
    "start": "0",
    "end": "5340"
  },
  {
    "text": "Your support will help\nMIT OpenCourseWare continue to offer high quality\neducational resources for free.",
    "start": "5340",
    "end": "11640"
  },
  {
    "text": "To make a donation or to\nview additional materials from hundreds of MIT courses,\nvisit MIT OpenCourseWare",
    "start": "11640",
    "end": "18110"
  },
  {
    "text": "at ocw.mit.edu.  JOE LEAVITT: Good afternoon.",
    "start": "18110",
    "end": "23580"
  },
  {
    "text": "My name is Joe Leavitt. My group members are Ben Ayton,\nJess Noss, Erlend Harbitz, Jake Barnwell, and\nSam Pinto, and we're",
    "start": "23580",
    "end": "29869"
  },
  {
    "text": "going to introduce you to\nthe topic incremental path planning. Listed on screen are just\nsome of the references",
    "start": "29870",
    "end": "37160"
  },
  {
    "start": "35000",
    "end": "70000"
  },
  {
    "text": "we used in putting\ntogether this lecture. The top three are the\nmain references we used",
    "start": "37160",
    "end": "42332"
  },
  {
    "text": "in developing our material\non the D* Lite algorithm, but also take note of\nthe bottom reference,",
    "start": "42332",
    "end": "48980"
  },
  {
    "text": "which is a paper done within\nProfessor William's group here at MIT. It talks about\nall-pairs, shortest paths",
    "start": "48980",
    "end": "56180"
  },
  {
    "text": "incremental search method. So if you're interested\nin more incremental search methods than those we're\ngoing to talk about today,",
    "start": "56180",
    "end": "61740"
  },
  {
    "text": "please get into this. Especially if you're going\nto go ahead and do our P set, these references will\nbe very helpful to you.",
    "start": "61740",
    "end": "70570"
  },
  {
    "start": "70000",
    "end": "98000"
  },
  {
    "text": "So today, we're going\nto first Monday problem, then we're going to introduce\nthe idea of incremental search.",
    "start": "70570",
    "end": "76260"
  },
  {
    "text": "Then we're going to go\ninto detail on the D* Lite algorithm, which is type of\nincremental path planning,",
    "start": "76260",
    "end": "81285"
  },
  {
    "text": "an algorithm used for\nincremental path planning, run through an\nexample of D* Lite, talk about when it is good to\nuse incremental path planning",
    "start": "81285",
    "end": "88600"
  },
  {
    "text": "when other path planners\nmight be better, and then I'll go into\nsome algorithm extensions",
    "start": "88600",
    "end": "94110"
  },
  {
    "text": "and related topics, and\nsome applications in mobile robotics. So in order to\nmotivate the problem,",
    "start": "94110",
    "end": "100480"
  },
  {
    "start": "98000",
    "end": "230000"
  },
  {
    "text": "we're going to use a robot\nliving in a grid world. It's at a start location trying\nto get to a goal location.",
    "start": "100480",
    "end": "107640"
  },
  {
    "text": "It can move up, down, left,\nor right, or diagonally. And it can only see the\neight cells around it,",
    "start": "107640",
    "end": "114130"
  },
  {
    "text": "as it's moving through\nthis grid world. And we're going to give some\npretty fine map of the world. This is a map that has the\nworld before it starts moving.",
    "start": "114130",
    "end": "122270"
  },
  {
    "text": "And it's possibly moving\nthrough some of these, new obstacles could appear,\nor obstacles could go away.",
    "start": "122270",
    "end": "128649"
  },
  {
    "text": "And the idea is that it's\ngoing to make observations as it's moving to this\nworld and update its plane",
    "start": "128650",
    "end": "133655"
  },
  {
    "text": "to get to the goal based on what\nit sees as it's moving along. ",
    "start": "133655",
    "end": "140750"
  },
  {
    "text": "So I must correct myself. The map that you're\nseeing now is the map that the robot\nhas ahead of time.",
    "start": "140750",
    "end": "146903"
  },
  {
    "text": "The previous map is what\nthe environment actually looks like. So as it starts\nmoving, it's going",
    "start": "146904",
    "end": "152420"
  },
  {
    "text": "to make a plan to get from\nthe start to the goal, and that's what\nwe want it to do. And it's going to move\nto the next position",
    "start": "152420",
    "end": "158262"
  },
  {
    "text": "and then realize that there's\nan obstacle in the path that it previously\nplanned, and now it must replan in order to find\na valid path to the goal.",
    "start": "158262",
    "end": "167250"
  },
  {
    "text": "And so now, it\nreplans, and continues to move on the new plan, and\nnow it finds another obstacle that it has to replan around,\nand it does the same thing.",
    "start": "167250",
    "end": "174810"
  },
  {
    "text": "And then it continues\nto walk through until it gets to a\npoint where we have a change in the environment.",
    "start": "174810",
    "end": "181140"
  },
  {
    "text": "The change is represented\nby these two cells going black here, and\nnow its original plane",
    "start": "181140",
    "end": "186200"
  },
  {
    "text": "is no longer valid again. And what we want it\nto do is to replan to find a new valid\noptimal path to the goal.",
    "start": "186200",
    "end": "193580"
  },
  {
    "text": "This is just showing here what\nhappened to our environment. And then the robot\nreplans and continues",
    "start": "193580",
    "end": "201740"
  },
  {
    "text": "to march towards\nthe goal So this is the behavior we want\nfrom a mobile robot, whether it's a two-dimensional\npath-planning problem,",
    "start": "201740",
    "end": "207517"
  },
  {
    "text": "or we're talking about\nmulti-dimensional robot arms, planning, working with\nhumans on a manufacturing",
    "start": "207518",
    "end": "215510"
  },
  {
    "text": "environment, or an\nactivity-planning process. The idea is that\nwe want the robot",
    "start": "215510",
    "end": "220540"
  },
  {
    "text": "to be able to account for\nnew obstacles or changes in its representation\nof the environment and continue to plan on the\nfly quickly and optimally.",
    "start": "220540",
    "end": "230150"
  },
  {
    "start": "230000",
    "end": "317000"
  },
  {
    "text": "So there's methods\nthat accomplish this. One method used to\nin path planning",
    "start": "230150",
    "end": "236330"
  },
  {
    "text": "is rapidly exploring\nrandom trees, or RRTs. RRTs are basically\ngoing to plan, replan,",
    "start": "236330",
    "end": "243930"
  },
  {
    "text": "on every time step based on\nchanges in the environment. And one problem in\nmy experience here,",
    "start": "243930",
    "end": "249420"
  },
  {
    "text": "though, is that RRTs are\nsuboptimal, even though fast. ",
    "start": "249420",
    "end": "262198"
  },
  {
    "text": "See, here you see the robot\nhas come up with a plan. It's seeing new obstacles,\nthe table in front of it. The coffee cup.",
    "start": "262198",
    "end": "267705"
  },
  {
    "text": "And its planning for those\nthings, so the plan it came up with is clearly not optimal.",
    "start": "267705",
    "end": "273541"
  },
  {
    "start": "273541",
    "end": "278729"
  },
  {
    "text": "So we can perform some\nadditional computation. We can use a method that\nbuilds upon the RRT, RRT*,",
    "start": "278730",
    "end": "285360"
  },
  {
    "text": "that it finds an optimal path,\nbut that requires a pretty significant amount of\noffline computation time, and then you can accomplish\nsomething that looks a little",
    "start": "285360",
    "end": "293189"
  },
  {
    "text": "more normal. Again, we have to\nallow the robot to perform a lot of the\ncomputation off-line.",
    "start": "293190",
    "end": "300548"
  },
  {
    "text": " So how do we accomplish\nwhat we want to?",
    "start": "300549",
    "end": "308820"
  },
  {
    "text": "We want to compute quickly. We want to compute\noptimally, and then have the robot continue\nto move as it's",
    "start": "308820",
    "end": "314560"
  },
  {
    "text": "received new information\ncoming to the environment. Some problems we're\nfacing, there's",
    "start": "314560",
    "end": "319660"
  },
  {
    "start": "317000",
    "end": "328000"
  },
  {
    "text": "changing environmental\nconditions. There's sensor limitations. You might not be able\nto see everything in the environment\naround you, and then we",
    "start": "319660",
    "end": "325570"
  },
  {
    "text": "have limited computation time.  And the solution that\nwe're going to explore here",
    "start": "325570",
    "end": "332090"
  },
  {
    "start": "328000",
    "end": "458000"
  },
  {
    "text": "is to reuse that from\nthe previous search, in order to speed up\nthe search process,",
    "start": "332090",
    "end": "337580"
  },
  {
    "text": "and continue to plan optimally. And the method we're going\nto use to accomplish this",
    "start": "337580",
    "end": "342710"
  },
  {
    "text": "is incremental search. So now, we're going\nto talk about what incremental search means.",
    "start": "342710",
    "end": "349170"
  },
  {
    "text": "First to show you kind of how\npowerful incremental search can be, this is one example of\nan incremental search method,",
    "start": "349170",
    "end": "355290"
  },
  {
    "text": "incremental all-pairs\nshortest paths, which allows you to online\ncompute paths between any start",
    "start": "355290",
    "end": "361190"
  },
  {
    "text": "and goal location. The idea is that you have\na robot that's trying to move around one obstacle.",
    "start": "361190",
    "end": "366590"
  },
  {
    "text": "That's what you see in the\nupper sequence of events there. And another obstacle\nis added, and now it has to plan around\nthis new obstacle.",
    "start": "366590",
    "end": "373120"
  },
  {
    "text": "In using this algorithm, you\nhave a significant increase in performance and\ncomputation time",
    "start": "373120",
    "end": "378950"
  },
  {
    "text": "using the all-pairs shortest\npaths versus an RRT. RRT can act as another\nversion of an RRT,",
    "start": "378950",
    "end": "384379"
  },
  {
    "text": "where you're planning basically\nfrom both the goal and start and connecting your paths.",
    "start": "384380",
    "end": "390080"
  },
  {
    "text": "It's on the order of\nwhat you get with RRT, but this RRT connect\nalgorithm doesn't give you",
    "start": "390080",
    "end": "397890"
  },
  {
    "text": "an optimal result.\nAnd then it's even fast than another\nalgorithm probablistic road mapping, where you're randomly\nsampling the environment,",
    "start": "397890",
    "end": "404320"
  },
  {
    "text": "and connecting points\nto produce a path. So the idea here is\nthat we can really",
    "start": "404320",
    "end": "410540"
  },
  {
    "text": "leverage this idea of reusing\nresults from previous searches to accomplish fast\nreplanning online.",
    "start": "410540",
    "end": "417005"
  },
  {
    "text": " So the whole idea of\nincremental search is that we're going to\nform a normal graph search,",
    "start": "417005",
    "end": "425289"
  },
  {
    "text": "just like anybody's used to. And then we're going to\nrepeat as the robot moves",
    "start": "425290",
    "end": "431620"
  },
  {
    "text": "through the environment, or\nyou're executing your plan, you're going to execute\nthe next point in the plan,",
    "start": "431620",
    "end": "436830"
  },
  {
    "text": "or the next action in the plan. We're going to receive\nchanges from the environment,",
    "start": "436830",
    "end": "443130"
  },
  {
    "text": "either through our sensors or\ninformation from the outside. And then we're going\nto use that information",
    "start": "443130",
    "end": "449510"
  },
  {
    "text": "to update our previous search\nresults instead of completely replanning, and then\ncontinue to form that loop,",
    "start": "449510",
    "end": "456190"
  },
  {
    "text": "until you reach your goal. So before we get into too many\nof the details of how we're",
    "start": "456190",
    "end": "461650"
  },
  {
    "start": "458000",
    "end": "634000"
  },
  {
    "text": "going to accomplish\nthis, first, we want to review the\ngraph search problem. So in graph search, you\nhave a graph consisting",
    "start": "461650",
    "end": "469300"
  },
  {
    "text": "of vertices or nodes. We're going to use nodes\nthroughout this lecture to talk about the vertices\nor nodes in the graph that",
    "start": "469300",
    "end": "477670"
  },
  {
    "text": "are connected by edges. And then, there's an\nedge weighting function that describes the cost going\nfrom one node to another.",
    "start": "477670",
    "end": "484800"
  },
  {
    "text": "And then, a heuristic\nfunction is an estimate of the cost to get from a\ncurrent node to the goal node.",
    "start": "484800",
    "end": "491576"
  },
  {
    "text": "And then we a start\nvertex and a gold vertex. ",
    "start": "491576",
    "end": "498108"
  },
  {
    "text": "In the graph search\nproblem, we're also going to have this idea\nof a g value, or a cost so far.",
    "start": "498108",
    "end": "503310"
  },
  {
    "text": "We're going to use term g\nvalue, which is essentially the cost that it's taken to\nget to some predecessor node,",
    "start": "503310",
    "end": "509070"
  },
  {
    "text": "plus the cost of the node that\nyou're actually expanding. So you would have this\nW start to S1 cost",
    "start": "509070",
    "end": "517059"
  },
  {
    "text": "to get from start to S1. And then the g value\nfor S goal would be the weight from S1 of the\ngoal plus the S1's g value.",
    "start": "517059",
    "end": "526300"
  },
  {
    "text": "Yes, go ahead. AUDIENCE: What is W? JOE LEAVITT: W is the\nweighting function that I talked about\npreviously here.",
    "start": "526300",
    "end": "531640"
  },
  {
    "text": "So the weighting function\ndescribes the cost to get from one node to another\nalong any edge in a graph.",
    "start": "531640",
    "end": "540510"
  },
  {
    "text": "And then we'd use\nthose waiting functions to develop the idea\nof the G value. So W is just the edge cost.",
    "start": "540510",
    "end": "550839"
  },
  {
    "text": "And then our\nheuristic value, like, we use our heuristic function\nto establish a heuristic",
    "start": "550840",
    "end": "557990"
  },
  {
    "text": "value from one goal to\nanother, and we're going to call that our h value, or h. And then the total estimated\ncost to get from a node",
    "start": "557990",
    "end": "565240"
  },
  {
    "text": "that we're currently\nexpanding in a graph search is f, which is your cost so far,\nplus your estimated cost to go.",
    "start": "565241",
    "end": "574556"
  },
  {
    "text": "I think I might have\nmessed that up in there. Call g value associated\ncost so far, not cost to go, and then h is an\nestimate of cost to go.",
    "start": "574556",
    "end": "580560"
  },
  {
    "text": " So in order to reason about\na real-world environment,",
    "start": "580560",
    "end": "588087"
  },
  {
    "text": "we first have to\ntake that environment and convert it to a graph,\nso we can form graph search, and then do everything\nwe're talking about.",
    "start": "588087",
    "end": "594330"
  },
  {
    "text": "Some of the examples,\nwe're going to talk about, and some of the ones we've\nalready talked about, we're using this\nnotion of a grid world.",
    "start": "594330",
    "end": "599510"
  },
  {
    "text": "You can have a four\nconnected graph or a grid, where a robot can\nmove up, down, left, or right,",
    "start": "599510",
    "end": "605670"
  },
  {
    "text": "basically in x or y directions,\nor an eight connected graph, where you can also move\nalong the diagonals. And then had here,\nwe just showed",
    "start": "605670",
    "end": "611370"
  },
  {
    "text": "the graphs associated\nwith those, with the nodes and edges. And then you would have an\nassociated admissible heuristic",
    "start": "611370",
    "end": "619510"
  },
  {
    "text": "with those if you're going\nto form a heuristic search. So just know up front\nthat any time we're",
    "start": "619510",
    "end": "626450"
  },
  {
    "text": "moving from a real\nworld environment, that we're trying to reason\nabout these search methods, we have to develop\nan associated graph.",
    "start": "626450",
    "end": "634690"
  },
  {
    "text": "And one more thing that\nis important as far as understanding\nincremental searches, is the notion or\nidea of relaxation.",
    "start": "634690",
    "end": "642360"
  },
  {
    "text": "We're going use\nDijkstra's algorithm. Everybody here familiar\nwith Dijkstra's algorithm,",
    "start": "642360",
    "end": "647445"
  },
  {
    "text": "I'm assuming, in the past. We're going to use\nDijkstra's algorithm to kind of illustrate\nthe idea of relaxation",
    "start": "647445",
    "end": "653008"
  },
  {
    "text": "and remind everybody of what\nthat means, because it's an important concept\nwhen we're talking about incremental\nsearch algorithms.",
    "start": "653008",
    "end": "658972"
  },
  {
    "text": "So essentially, in\nDijkstra's algorithm, it's a single source, shortest\npath algorithm, a best",
    "start": "658972",
    "end": "663980"
  },
  {
    "text": "first search. So we're going to make eight\nexpanding nodes according to their best g\nvalue, or cost so far.",
    "start": "663980",
    "end": "670830"
  },
  {
    "text": "And we have our start\nnode initialized to zero cost so far,\nbecause at your start,",
    "start": "670830",
    "end": "677670"
  },
  {
    "text": "haven't accrued any cost. And then, every\nother node is going to be initialized to infinity. And the idea is we're\ngoing to find the shortest",
    "start": "677670",
    "end": "683730"
  },
  {
    "text": "distance to all\nof the other nodes by relaxing the cost to\nthose nodes from infinity",
    "start": "683730",
    "end": "690810"
  },
  {
    "text": "down to their actual shortest\nor lowest cost value. So we start by expanding\nthe start node,",
    "start": "690810",
    "end": "698769"
  },
  {
    "text": "and then you find\nthe cost so far to each of the children\nnodes of the start node.",
    "start": "698770",
    "end": "704640"
  },
  {
    "text": "So you have an edge way\nto one, and so the node on the bottom as a value of 1.",
    "start": "704640",
    "end": "710170"
  },
  {
    "text": "Similarly for the middle node\nat 5, and the top node for 3. Now, the next node\nwe're going to expand,",
    "start": "710170",
    "end": "715289"
  },
  {
    "text": "can anybody tell me\nwhat the next node we're going to expand based on\nperforming best first search here using cost so far?",
    "start": "715289",
    "end": "722970"
  },
  {
    "text": "AUDIENCE: The 1? 1? JOE LEAVITT: Yes. So the node labeled 1 here,\nthat has a g value of 1",
    "start": "722970",
    "end": "728820"
  },
  {
    "text": "is the lowest out of 1,\n3, and 5, and infinity. So we're going to go\nahead and expand 1 next.",
    "start": "728820",
    "end": "735110"
  },
  {
    "text": "And now, we find that using\nthis value of 1 plus 3",
    "start": "735110",
    "end": "740370"
  },
  {
    "text": "equals 4, which is less\nthan what we previously had here as 4. So now the center node has\nbeen relaxed from a value of 5",
    "start": "740370",
    "end": "746020"
  },
  {
    "text": "down to 4. So now the shortest path we\nfound to the center node is 4.",
    "start": "746020",
    "end": "752480"
  },
  {
    "text": "And we're going to\ncontinue to perform this by going through each node\nin order of the lowest cost.",
    "start": "752480",
    "end": "760199"
  },
  {
    "text": "And similarly, you\nsaw how the top node was relaxed to 6 by going\nthrough 1, 3, and 2, where",
    "start": "760200",
    "end": "766400"
  },
  {
    "text": "as previously, it had a\nlowest cost of 7 going through 3 and 4. And if we format\nthrough the whole graph",
    "start": "766400",
    "end": "772790"
  },
  {
    "text": "until all nodes have\nbeen unexpanded, then we've relaxed\nevery node in the graph to its shortest path value.",
    "start": "772790",
    "end": "779460"
  },
  {
    "text": "And then, we can just\ndo a greedy search from a chosen goal node,\nback through the graph",
    "start": "779460",
    "end": "786800"
  },
  {
    "text": "to find shortest path.  AUDIENCE: Is the term\nrelaxation standard?",
    "start": "786800",
    "end": "793770"
  },
  {
    "text": "Because the fact that you're\nbringing numbers from infinity double to small\nvalue sounds more",
    "start": "793770",
    "end": "800300"
  },
  {
    "text": "like tightening as\nopposed to relaxation. So I was just wondering\nif people use it as like, a standard--",
    "start": "800300",
    "end": "805830"
  },
  {
    "text": "JOE LEAVITT: I'm not sure\nif it is in all areas, but I have seen it\nin multiple places.",
    "start": "805830",
    "end": "813230"
  },
  {
    "text": "When you're talking\nabout graph search, specifically with respect\nto Dijkstra's algorithm,",
    "start": "813230",
    "end": "818940"
  },
  {
    "text": "that is where the term\nrelaxation is used. And we're going to use\nthat as we go throughout and talk about\nincremental search.",
    "start": "818940",
    "end": "825660"
  },
  {
    "text": "We're kind of repairing the\nresults because of new edge weights and things like that. We're going to figure\nout which nodes",
    "start": "825660",
    "end": "831031"
  },
  {
    "text": "we have to relax back down\nto their shortest value to be able to find\nthe new shortest path.",
    "start": "831031",
    "end": "836571"
  },
  {
    "text": "So that's the term\nwe're going to use here if it's not used universally. I can't say for certain.",
    "start": "836571",
    "end": "842730"
  },
  {
    "text": "But we will use relaxation\nto talk about reducing--",
    "start": "842730",
    "end": "847920"
  },
  {
    "text": "it's kind of related to-- think about like,\na tension spring.",
    "start": "847920",
    "end": "853829"
  },
  {
    "text": "As you reduce the\nconstraints on it, it'll slowly relax to its\ncompletely relaxed position.",
    "start": "853830",
    "end": "861122"
  },
  {
    "text": "That's kind of the idea here.  So now that we have talked\nabout the ideas of relaxation",
    "start": "861122",
    "end": "869510"
  },
  {
    "start": "864000",
    "end": "945000"
  },
  {
    "text": "and graph search, how\ndo we reuse the results from a previous search\nin a new search field",
    "start": "869510",
    "end": "876110"
  },
  {
    "text": "to employ an incremental\nsearch method where you have done a search,\nyou found the shortest path,",
    "start": "876110",
    "end": "883430"
  },
  {
    "text": "and now, you had some\nchanges to your graph, and you want to use your\nprevious results to come up",
    "start": "883430",
    "end": "890110"
  },
  {
    "text": "with your new shortest path. So the way we're\ngoing to do that, is we're going to store\nour optimal results from a previous search.",
    "start": "890110",
    "end": "898219"
  },
  {
    "text": "This can be done in\na number of ways. It's going to depend\non the algorithm. But you can soar like,\na list of shortest paths",
    "start": "898219",
    "end": "906020"
  },
  {
    "text": "as an incremental all-pairs\nshortest paths problem. The one we're going to talk\nmost about is storing g values,",
    "start": "906020",
    "end": "912620"
  },
  {
    "text": "and that's what's done\nin a D* Lite algorithm, where you're finding the\nshortest distance from any",
    "start": "912620",
    "end": "918690"
  },
  {
    "text": "given node that you've\nexpanded so far in your search to the goal node.",
    "start": "918690",
    "end": "925160"
  },
  {
    "text": "And then, you'll use that\ndata to find out, find the shortest path. And then when you go to\nperform your next iteration,",
    "start": "925160",
    "end": "931520"
  },
  {
    "text": "you'll look for\ninconsistencies in that graph. And then in order to\nfind a new shortest path,",
    "start": "931520",
    "end": "937030"
  },
  {
    "text": "we'll leverage that previous\ndata and the inconsistencies for relaxations to come up\nwith a new optimal solution.",
    "start": "937030",
    "end": "945464"
  },
  {
    "start": "945000",
    "end": "975000"
  },
  {
    "text": "And that's all\nwe're showing here. On the right side of\nthese two graphics is you have the initial search. You have an obstacle that\nis now in a place that",
    "start": "945464",
    "end": "953000"
  },
  {
    "text": "was wasn't there\npreviously, which causes you to update edge\nweights in the graph associated",
    "start": "953000",
    "end": "958100"
  },
  {
    "text": "with this grid world. And then using\nthese values which represent the g values\nin the graph search,",
    "start": "958100",
    "end": "965690"
  },
  {
    "text": "you only update\nthe ones you need to update to find\na new optimal path.",
    "start": "965690",
    "end": "971870"
  },
  {
    "text": "And so completely\nreperforming our search. So what incremental\nsearch methods",
    "start": "971870",
    "end": "977820"
  },
  {
    "start": "975000",
    "end": "1186000"
  },
  {
    "text": "exist, now that we've kind\nof talked about what they are",
    "start": "977820",
    "end": "982850"
  },
  {
    "text": "and what we can do with them? So the whole idea\nof this slide here",
    "start": "982850",
    "end": "987889"
  },
  {
    "text": "is to show you that\nincremental search can be used across many domains. It's not just specific\nto path planning.",
    "start": "987890",
    "end": "994810"
  },
  {
    "text": "It's used in temporal\nplanning to determine temporal consistency. It can be used propositional\nsatisfiability.",
    "start": "994810",
    "end": "1001100"
  },
  {
    "text": " Instead of every time you're\nupdating another algorithm,",
    "start": "1001100",
    "end": "1008870"
  },
  {
    "text": "you can use your\nprevious results. And the one we're going to\nfocus on today is D* Lite,",
    "start": "1008870",
    "end": "1014860"
  },
  {
    "text": "which is specific to\nmobile and robots. But the ideas and concepts\nwe're going to talk about there are applicable\nelsewhere, and you",
    "start": "1014860",
    "end": "1021759"
  },
  {
    "text": "can use to help you learn\nabout and expand your knowledge in other incremental search.",
    "start": "1021760",
    "end": "1029175"
  },
  {
    "text": "So the D* incremental\npath planning approach. The whole idea behind\nit is that we're going to take the idea\nof incremental search",
    "start": "1029175",
    "end": "1036349"
  },
  {
    "text": "that we just talked\nit about, and we're going to combine it with\nheuristic search, which is an optimal solution.",
    "start": "1036349",
    "end": "1042599"
  },
  {
    "text": "And the idea is\nthat two things are orthogonal so we\ncan combine them,",
    "start": "1042599",
    "end": "1048559"
  },
  {
    "text": "and then we can form\nefficient incremental path planning, getting both\nan optimal result, and quickly getting\na new path when",
    "start": "1048560",
    "end": "1055452"
  },
  {
    "text": "things change in the\nenvironment without having to completely replan. And so what that\nlooks like, when",
    "start": "1055452",
    "end": "1062330"
  },
  {
    "text": "we have a grid world, which is\nshown in four instances here up on the board, and we're trying\nto plan from a start node",
    "start": "1062330",
    "end": "1068690"
  },
  {
    "text": "to a goal node, and showing\neach of these sections. And in the upper left or\non the left axis, we have--",
    "start": "1068690",
    "end": "1075522"
  },
  {
    "text": "whether we're performing\na complete search or an incremental search. And on the horizontal\naxis, whether it's",
    "start": "1075522",
    "end": "1082280"
  },
  {
    "text": "an uninformed search\nor a heuristic search. So the upper left is\na complete search,",
    "start": "1082280",
    "end": "1087679"
  },
  {
    "text": "just using best-first\nsearch and no heuristics. And what it's showing is all\nthe nodes that are expanded, and trying to find a path\nfrom the start to the goal.",
    "start": "1087680",
    "end": "1096046"
  },
  {
    "text": "In the upper right is\na heuristic search, A*. Employing the heuristic,\nwe're able to collapse",
    "start": "1096046",
    "end": "1101330"
  },
  {
    "text": "the number of nodes\nexpanded by quite a bit. In the bottom left is an\nincremental search method",
    "start": "1101330",
    "end": "1108620"
  },
  {
    "text": "that's using uninformed\nsearch or best-first search as an underlying\nsearch algorithm,",
    "start": "1108620",
    "end": "1115070"
  },
  {
    "text": "so it's going to expand the same\nnodes as the best-first search. And then in the bottom\nright, you see an incremental",
    "start": "1115070",
    "end": "1122330"
  },
  {
    "text": "heuristic search, the lifelong\nplanning A* algorithm, which is kind of the baseline\nfor the D* Lite we're going",
    "start": "1122330",
    "end": "1129447"
  },
  {
    "text": "to talk about, that the initial\nsearch will expand the same nodes as the heuristic search,\nsince it's using A* as its",
    "start": "1129447",
    "end": "1135510"
  },
  {
    "text": "baseline. So now let's say\nthe robot moves.",
    "start": "1135510",
    "end": "1140990"
  },
  {
    "text": "We get an update\nto the environment. There's a bunch\nof changed edges. And now best-first\nsearch, as you can see,",
    "start": "1140990",
    "end": "1148280"
  },
  {
    "text": "is going to have to expand\npretty much the same number, if not more nodes, then\nour previous search.",
    "start": "1148280",
    "end": "1154820"
  },
  {
    "text": "And A* also is going to expand\nabout the same number of nodes as it did previously. The incremental search method\nusing best-first search,",
    "start": "1154820",
    "end": "1162919"
  },
  {
    "text": "by using previous results,\nreduces significantly the number of nodes that\nneeds to be expanded. And then, lifelong planning\nA*, the incremental search plus",
    "start": "1162920",
    "end": "1170195"
  },
  {
    "text": "the heuristic search, reduces\nthat number by even more.",
    "start": "1170195",
    "end": "1175399"
  },
  {
    "text": "Even when there's quite a few\nchanges in the environment, you have very few\nnodes that you need to expand on the\nnext search in order",
    "start": "1175400",
    "end": "1181010"
  },
  {
    "text": "to find a new optimal path. With that, I'll turn it over to\nBen to talk about the D* Lite",
    "start": "1181010",
    "end": "1189872"
  },
  {
    "start": "1186000",
    "end": "1935000"
  },
  {
    "text": "algorithm. BEN AYTON: Thanks. So I'll be walking you through\nthe D* Light algorithm today.",
    "start": "1189872",
    "end": "1196800"
  },
  {
    "text": "Now as we're emphasizing,\nthe D* Lite is not the only incremental algorithm, as\nwe mentioned previously.",
    "start": "1196800",
    "end": "1202190"
  },
  {
    "text": "But it is a widely used\nincremental algorithm, and you'll see it's quite\nefficient in what it does.",
    "start": "1202190",
    "end": "1209179"
  },
  {
    "text": "D* Lite is an algorithm that\nsearches from a single start node to a single goal node.",
    "start": "1209180",
    "end": "1214480"
  },
  {
    "text": "But as we see changes occur\nin the path along the way, we'll adjust that.",
    "start": "1214480",
    "end": "1220019"
  },
  {
    "text": "So it's nice to think about\nD* Lite from two perspectives. One is to think about it as a\nmodification of the principle",
    "start": "1220020",
    "end": "1226860"
  },
  {
    "text": "space. Now, you'll see that D* Lite\nin its first iteration or its first run through before any\nmodifications behaves very",
    "start": "1226860",
    "end": "1233750"
  },
  {
    "text": "similar to A*, and that's where\nit's nice to keep that main model in mind. And you'll see that in\nan example further along.",
    "start": "1233750",
    "end": "1241040"
  },
  {
    "text": "The second perspective to look\nat A* is from the perspective of Dijkstra's algorithm,\nfrom which we see many",
    "start": "1241040",
    "end": "1247730"
  },
  {
    "text": "of the principles of relaxation\nthat we covered beforehand. From this perspective, we see\nthat when we do reparations",
    "start": "1247730",
    "end": "1254600"
  },
  {
    "text": "to the graph or changes to the\ngraph, our methods of repairs the graph is essentially to\nrelax down our changed edge",
    "start": "1254600",
    "end": "1262000"
  },
  {
    "text": "weights until they\nreach their truth. Now, where we differ from\nDijkstra's algorithm with something like D* Lite is\nselecting only the nodes that",
    "start": "1262000",
    "end": "1271010"
  },
  {
    "text": "we want to hit efficiently. So whereas Dijkstra's algorithm\ntried to fit the entire graph,",
    "start": "1271010",
    "end": "1277159"
  },
  {
    "text": "we only want to travel\nfrom a single start node to a single goal node. And so D* Lite behaves like\nDijkstra's, but a guided",
    "start": "1277160",
    "end": "1284860"
  },
  {
    "text": "Dijkstra's. So I'd like to just remind you\nof several concepts from A*",
    "start": "1284860",
    "end": "1290400"
  },
  {
    "text": "first, because it's easier to\nintroduce them in that context. And then we'll modify\nthem a little bit. So Joe mentioned\nbefore that for A*,",
    "start": "1290400",
    "end": "1298340"
  },
  {
    "text": "we're searching from a\nstart node to a goal node. We're sorting the\nnodes in our queue",
    "start": "1298340",
    "end": "1303380"
  },
  {
    "text": "by total cost, which is the sum\nof what we're calling g, which are costs to get\nto a single node,",
    "start": "1303380",
    "end": "1310495"
  },
  {
    "text": "and our heuristic, which is\nthe cost to get from a node, s, to the goal node, your s.",
    "start": "1310495",
    "end": "1315546"
  },
  {
    "text": " Now, what we don't\nusually consider with A*,",
    "start": "1315546",
    "end": "1321320"
  },
  {
    "text": "but is very important for D*, is\nhow to distinguish between ties when two different nodes on the\nsearch cube have the same total",
    "start": "1321320",
    "end": "1328880"
  },
  {
    "text": "cost. So here's what\nwe're doing is we're introducing a couplet, which\nconsists of two values.",
    "start": "1328880",
    "end": "1334770"
  },
  {
    "text": "The first, which I'm calling\nf1 here for any given state, is the same as what\nwe're usually used to.",
    "start": "1334770",
    "end": "1340370"
  },
  {
    "text": "It's the linear\ncombination of your cost to reach the goal node\nand heuristic function. But we also introduced\na second value",
    "start": "1340370",
    "end": "1348770"
  },
  {
    "text": "for this couplet that's used\nin the case for only those to draw. And that is simply the\ncost to go, that g value.",
    "start": "1348770",
    "end": "1355290"
  },
  {
    "text": "So the order of expansion\nof nodes from the q will order them in\nterms of f1 first,",
    "start": "1355290",
    "end": "1361880"
  },
  {
    "text": "and if two nodes at\nthe front of the cube tie in terms of\ntheir f1 value, we select the node with\nthe lowest g value.",
    "start": "1361880",
    "end": "1369110"
  },
  {
    "text": "So looking at our\ngraph down here, we're looking at our\nstates s1 here and s2 here.",
    "start": "1369110",
    "end": "1376250"
  },
  {
    "text": "Can anyone tell me the\ntotal cost for our node s1",
    "start": "1376250",
    "end": "1381350"
  },
  {
    "text": "which, remember, is a couplet\nof two different values? ",
    "start": "1381350",
    "end": "1391230"
  },
  {
    "text": "5, 3. So five, yes, is\nour cost to reach",
    "start": "1391230",
    "end": "1396789"
  },
  {
    "text": "this node one, plus the\nheuristic, which is 2 here. And also, 3 is our second value,\nbecause it's only our g value",
    "start": "1396790",
    "end": "1404804"
  },
  {
    "text": "there. And so what would the value\nbe by the same logic for s2 down here?",
    "start": "1404804",
    "end": "1410960"
  },
  {
    "text": "AUDIENCE: 5, 2. BEN AYTON: 5, 2. That's exactly right. And so, bearing in mind\nwhat I told you before,",
    "start": "1410960",
    "end": "1417540"
  },
  {
    "text": "where should we take\noff the q first? AUDIENCE: S2? BEN AYTON: That's exactly right,\nbecause the first value, f1,",
    "start": "1417540",
    "end": "1425260"
  },
  {
    "text": "for these two nodes\nis exactly the same. But the second value\nis lower is f(s)2.",
    "start": "1425260",
    "end": "1432210"
  },
  {
    "text": "I'd also like to introduce\nthe concept of successors and predecessors\nof any given node.",
    "start": "1432210",
    "end": "1438390"
  },
  {
    "text": "In general, a graph\nconsists of directed edges. And we could have a graph\nwith undirected edges, but we can think of\nas just any edge being",
    "start": "1438390",
    "end": "1445889"
  },
  {
    "text": "directed in both direction. So here, we define the concept\nof a successor of a node, which",
    "start": "1445890",
    "end": "1451080"
  },
  {
    "text": "is every node can be reached\nfrom a given node, along edges that can be found.",
    "start": "1451080",
    "end": "1457430"
  },
  {
    "text": "So the successors of\nthis given red node are these two blue nodes here.",
    "start": "1457430",
    "end": "1462769"
  },
  {
    "text": "We also introduced the\nconcept of predecessors, which is every node from which\nthat node can be reached,",
    "start": "1462770",
    "end": "1468990"
  },
  {
    "text": "meaning nodes from\nwhich we can follow our directed edge to our node. So for our red node,\nthe predecessors",
    "start": "1468990",
    "end": "1475690"
  },
  {
    "text": "are these two nodes. What I'd like to\nemphasize here is comparing the two,\nthat this node here",
    "start": "1475690",
    "end": "1481500"
  },
  {
    "text": "was both the processor and\nthe successor of our red node. And that's fine. That occurs when we have\nundirected edges or edges",
    "start": "1481500",
    "end": "1489460"
  },
  {
    "text": "that direct in both directions. So think about D* Lite in\nthe sense that is a repeated",
    "start": "1489460",
    "end": "1496660"
  },
  {
    "text": "best-first search, which is\nwhere the A* principles come in through a graph with changing\nedge weights as that graph is",
    "start": "1496660",
    "end": "1503970"
  },
  {
    "text": "traversed, meaning that as\nwe travel from our start node to our goal node along a\npath that we are planning,",
    "start": "1503970",
    "end": "1511780"
  },
  {
    "text": "we can see that edge\nweights are changing. And in this example,\nI'm modeling an obstacle coming in place\nbetween this node here",
    "start": "1511780",
    "end": "1519070"
  },
  {
    "text": "and the goal, which means that\nwe have removed that edge. And that's effectively the same\nas changing an edge weight.",
    "start": "1519070",
    "end": "1525381"
  },
  {
    "text": "We're just modeling it as\nchanging this edge weight to infinity, which means that\nedge can't be traveled along.",
    "start": "1525381",
    "end": "1531796"
  },
  {
    "text": "And as I mentioned\nbefore, we also view this as replanning through\nrelaxation of path costs.",
    "start": "1531796",
    "end": "1537470"
  },
  {
    "text": "So once we have\nmoved to this point, how do we find\nthe path from here to here when this edge has\nbeen removed, essentially?",
    "start": "1537470",
    "end": "1548690"
  },
  {
    "text": "So we want to make\nD* Lite efficient. And it's a repeated\nsearch through the graph",
    "start": "1548690",
    "end": "1554060"
  },
  {
    "text": "as we traverse it. So you'll see that since we're\nusing these g values, if we",
    "start": "1554060",
    "end": "1560830"
  },
  {
    "text": "maintain a formulation where\nwe're measuring the distance",
    "start": "1560830",
    "end": "1566510"
  },
  {
    "text": "to go or to reach a node\nfrom our start node, this is not preserved when\nwe move our start node.",
    "start": "1566510",
    "end": "1573059"
  },
  {
    "text": "And we move our start\nnode when we're updating the position of our vehicle. So let me show this\nthrough an example here.",
    "start": "1573059",
    "end": "1579800"
  },
  {
    "text": "The g value, or cost to\nget from one start node to our current node, s,\nhere is the combination",
    "start": "1579800",
    "end": "1585380"
  },
  {
    "text": "of these two edges. And so, it sums to 4. Now when we move along\nthat path that we've",
    "start": "1585380",
    "end": "1590750"
  },
  {
    "text": "planned to this next node, the\ng value to get to that same node is here too.",
    "start": "1590750",
    "end": "1596630"
  },
  {
    "text": "So this isn't preserved. And that means that we'd have\nto potentially reformulate things in our cue, which\nwould be very inefficient.",
    "start": "1596630",
    "end": "1603840"
  },
  {
    "text": "So what we do is we\nreformulate our search. And it's perfectly valid\nto reformulate our search",
    "start": "1603840",
    "end": "1608900"
  },
  {
    "text": "to search in the\nopposite direction. We're essentially measuring\nfor our g values now the cost",
    "start": "1608900",
    "end": "1614120"
  },
  {
    "text": "to reach the goal\nfrom a specific. And instead of heuristics,\nthen measure the costs",
    "start": "1614120",
    "end": "1620660"
  },
  {
    "text": "to get from this specific\nnode, or to get from the start node to our specific node. And so we search from the goal\nbackwards through the graph.",
    "start": "1620660",
    "end": "1628040"
  },
  {
    "text": "In this case, we see that\nregardless of whether our start node, we preserve our g values,\nand our cost to travel from",
    "start": "1628040",
    "end": "1635330"
  },
  {
    "text": "s to that goal. That's what we\nlike, and we we'll keep that reformulation\nto maximize efficiency.",
    "start": "1635330",
    "end": "1643490"
  },
  {
    "text": "So here, I want to give you a\nkind of overall understanding of the D* Lite algorithm before\nwe dive into specifics of what",
    "start": "1643490",
    "end": "1649510"
  },
  {
    "text": "it's doing. First we want to initialize\nall nodes as unexpanded. And what exactly, it means\nexpand a node neighbor",
    "start": "1649510",
    "end": "1656045"
  },
  {
    "text": "or cover. And then we're doing\na best-first search from the goal node\nto the start node",
    "start": "1656045",
    "end": "1662210"
  },
  {
    "text": "until the start node is\nconsistent with its neighbors. And I'll again say\nwhat that means later.",
    "start": "1662210",
    "end": "1668000"
  },
  {
    "text": "We then move our start node\nto the next best vertex, essentially our node moving\nalong the plan that we created.",
    "start": "1668000",
    "end": "1675580"
  },
  {
    "text": "And then we have to see if any\nof those edge costs change. We track how our heuristics\nchange, and then update",
    "start": "1675580",
    "end": "1681679"
  },
  {
    "text": "the source nodes of\nthose changed edges. And we essentially\nrepeat this process",
    "start": "1681680",
    "end": "1686690"
  },
  {
    "text": "until, again, we've converged to\na solution, and we keep moving.",
    "start": "1686690",
    "end": "1691889"
  },
  {
    "text": "So this best-first search, the\nA* Lite part of the algorithm, is where most of the computation\nis going to be occurring.",
    "start": "1691890",
    "end": "1698840"
  },
  {
    "text": "However, the\nincremental component is actually how can we\nadjust our edge costs",
    "start": "1698840",
    "end": "1705560"
  },
  {
    "text": "to make sure that we're\nusing most of the information that we previously gathered\nas efficiently as possible.",
    "start": "1705560",
    "end": "1711570"
  },
  {
    "text": "So I'm going to walk you\nthrough various steps of this. First, I'd like to walk\nyou through this step",
    "start": "1711570",
    "end": "1716810"
  },
  {
    "text": "of moving to the\nnext best vertex, just so you understand that.",
    "start": "1716810",
    "end": "1722050"
  },
  {
    "text": "So we can extract a\npath, given the path costs that have, through\nthis simple argument,",
    "start": "1722050",
    "end": "1728279"
  },
  {
    "text": "which says that we\nmap the successor, by which I mean we restate\nwhat the start node is,",
    "start": "1728280",
    "end": "1736502"
  },
  {
    "text": "because we're moving\nfrom one state to the next state, which\nbecomes the new start node, by this form, which essentially\nsays that we're taking the best",
    "start": "1736502",
    "end": "1745820"
  },
  {
    "text": "path in the sense that we're\nminimizing the total cost that",
    "start": "1745820",
    "end": "1751490"
  },
  {
    "text": "would be gained traveling\nby that path to this node. So in a sense, the g\nvalue to get to this node,",
    "start": "1751490",
    "end": "1760940"
  },
  {
    "text": "to the red from the green,\nor color stretching back through the graph, by\nthis path here, is 7.",
    "start": "1760940",
    "end": "1767620"
  },
  {
    "text": "But to get to this node\nfrom the lower node is 10. And so our g value that is\noptimal is 7 in this case,",
    "start": "1767620",
    "end": "1775130"
  },
  {
    "text": "and know that we pick the\nsuccessor as the green node up here.",
    "start": "1775130",
    "end": "1781240"
  },
  {
    "text": "So now to walk through\nsome principles that appear in both of these steps.",
    "start": "1781240",
    "end": "1788210"
  },
  {
    "text": "I want to show how we handle\nweight changes locally. And we do this\nbecause we don't want to track weight changes\nthroughout the entire graph.",
    "start": "1788210",
    "end": "1794716"
  },
  {
    "text": "We want to handle this\nefficiently and separate them, so we only need to\nhandle the changes that really impact our problem.",
    "start": "1794716",
    "end": "1801380"
  },
  {
    "text": "So this is the same formula\nthat defines our successor, or our g values\nfor a given node.",
    "start": "1801380",
    "end": "1807450"
  },
  {
    "text": "But we can see that\nthis may no longer hold when edge weights change. The example that I have\nhere is that I've changed",
    "start": "1807450",
    "end": "1813889"
  },
  {
    "text": "edge weight cost from 6 to 1. And so now we can reach the\nred node, searching back",
    "start": "1813890",
    "end": "1821420"
  },
  {
    "text": "through graph by a\nnew optimal path, coming down from this node\nhere, which would make our new g",
    "start": "1821420",
    "end": "1826820"
  },
  {
    "text": "value five instead. So this hasn't been preserved.",
    "start": "1826820",
    "end": "1833450"
  },
  {
    "text": "And then these changes then\npropagate to our predecessors, because the costs\nfor the processors",
    "start": "1833450",
    "end": "1839510"
  },
  {
    "text": "are each dependent on the g\nvalue for their successor. And so when we hit\na node, we have",
    "start": "1839510",
    "end": "1845180"
  },
  {
    "text": "to propagate that change all\nthe way back through the graph. So to do this efficiently,\nwe take an A* like approach,",
    "start": "1845180",
    "end": "1852110"
  },
  {
    "text": "where we update the\nlowest cost nodes first, and we don't expand a node until\nit is the next lowest cost.",
    "start": "1852110",
    "end": "1859360"
  },
  {
    "text": " To help us do this, we're\ngoing to store additional fact.",
    "start": "1859360",
    "end": "1865930"
  },
  {
    "text": "We'll call this rhs. Now the meaning\nbehind rhs, it comes",
    "start": "1865930",
    "end": "1871400"
  },
  {
    "text": "from the term right-hand side,\nwhich in the paper world, was first introduced and\nmade more sense than it",
    "start": "1871400",
    "end": "1876470"
  },
  {
    "text": "does so here. What you can think of your\nrhs value as is essentially you're corrected your g costs.",
    "start": "1876470",
    "end": "1883180"
  },
  {
    "text": "When edge costs\nchange, how G should be signed so that it's\ncorrect for a different graph.",
    "start": "1883180",
    "end": "1890741"
  },
  {
    "text": "And when your rhs value is not\nequal to your g value, that means that we have what is\ncalled a local inconsistency.",
    "start": "1890741",
    "end": "1898460"
  },
  {
    "text": "So given the logic that\nyour rhs value should be what your g value\nwould be corrected to be,",
    "start": "1898460",
    "end": "1905360"
  },
  {
    "text": "what would your rhs value\nbe for this graph here? ",
    "start": "1905360",
    "end": "1914420"
  },
  {
    "text": "AUDIENCE: 5? BEN AYTON: 5, yes. So this is the same graph\nthat I presented previously,",
    "start": "1914420",
    "end": "1920330"
  },
  {
    "text": "and I walked through\nhow g should be 5. rhs should be 5 here.",
    "start": "1920330",
    "end": "1925841"
  },
  {
    "text": "And what we're tracking\nis rhs and g differently. So g is what it should be,\nbut we haven't got the dated g",
    "start": "1925841",
    "end": "1933560"
  },
  {
    "text": "to be 5 yet. So we have two different\ntypes of local consistencies that we distinguish between.",
    "start": "1933560",
    "end": "1940340"
  },
  {
    "start": "1935000",
    "end": "1964000"
  },
  {
    "text": "We have what we call local\noverconsistency, where g is greater than your rhs value.",
    "start": "1940340",
    "end": "1946260"
  },
  {
    "text": "This is going to\nbehave more similarly to Dijkstra's algorithm,\nwhere the value that we're",
    "start": "1946260",
    "end": "1953269"
  },
  {
    "text": "associating to any\ngiven node now is higher than it should be, and\nwe're relaxing down to the true value.",
    "start": "1953270",
    "end": "1959880"
  },
  {
    "text": "However, we have a lovely\nunderconsistent case that we have to handle\nslightly differently. So now I'm going to walk through\nupdating and expanding nodes.",
    "start": "1959880",
    "end": "1968740"
  },
  {
    "start": "1964000",
    "end": "2331000"
  },
  {
    "text": "What I mean by updating a node\nis recomputing the rhs value, and then placing that node\non the priority queue,",
    "start": "1968740",
    "end": "1975470"
  },
  {
    "text": "if that node is\nlocally inconsistent. So to give an example here,\nI've changed this value,",
    "start": "1975470",
    "end": "1984320"
  },
  {
    "text": "moving from 6 at\nthe bottom to 1, and recomputing rhs,\nas we did beforehand.",
    "start": "1984320",
    "end": "1990950"
  },
  {
    "text": "Now we see that the node\nis locally inconsistent. In this case, it's\nlocally underconsistent.",
    "start": "1990950",
    "end": "1998530"
  },
  {
    "text": "And so we place that\non the priority queue. The priority queue values are\nbased on this new formula.",
    "start": "1998530",
    "end": "2008990"
  },
  {
    "text": "This new formula essentially\nhandles how we see G and rhs.",
    "start": "2008990",
    "end": "2014890"
  },
  {
    "text": "In essence, we want to take the\nminimum value of one of these, so that we can handle it\nthe first time that it",
    "start": "2014890",
    "end": "2023304"
  },
  {
    "text": "will cause changes that\npropagate through the graph. And so this is essentially our\nordering on our priority queue",
    "start": "2023305",
    "end": "2029155"
  },
  {
    "text": "which is essentially the same\ncoupling that we saw for A*.",
    "start": "2029155",
    "end": "2034740"
  },
  {
    "text": "But here, we just\nhave g of s replaced by the minimum of g\nof s and rhs of s.",
    "start": "2034740",
    "end": "2040770"
  },
  {
    "text": "And so, here your\nminimum of g and rhs is 5, plus a heuristic, leads\nto a total cost associated",
    "start": "2040770",
    "end": "2048550"
  },
  {
    "text": "with this node of 9, 5. So we expand our\nfive prior nodes",
    "start": "2048550",
    "end": "2054280"
  },
  {
    "text": "by then taking them off the\npriority queue and changing g. Now I said here that we\nhave an inconsistent.",
    "start": "2054280",
    "end": "2062290"
  },
  {
    "text": "And so, we update this in much\nthe way that we would expect.",
    "start": "2062290",
    "end": "2067449"
  },
  {
    "text": "Your g values are relaxing\ndown to your rhs values, and so we just set g\nto be equal to rhs.",
    "start": "2067449",
    "end": "2075320"
  },
  {
    "text": "In this case, our node is\nnow locally consistent, and it's going to stay that way. So can anyone think\nof some good reasons",
    "start": "2075320",
    "end": "2082270"
  },
  {
    "text": "why I go through the process\nof changing rhs and keeping track of that new value,\nonly to put on the queue,",
    "start": "2082270",
    "end": "2088879"
  },
  {
    "text": "and then take it\noff again, instead of just recomputing what g of\ns should be in the first place?",
    "start": "2088880",
    "end": "2094952"
  },
  {
    "text": "Does anyone have any ideas?  AUDIENCE: [INAUDIBLE]",
    "start": "2094953",
    "end": "2102825"
  },
  {
    "text": " BEN AYTON: What you can\nthink of is that you're",
    "start": "2102825",
    "end": "2108660"
  },
  {
    "text": "putting something on the queue. If we update that\nvalue immediately,",
    "start": "2108660",
    "end": "2115630"
  },
  {
    "text": "there are multiple nodes that\ncould change the same node that we just considered.",
    "start": "2115630",
    "end": "2121170"
  },
  {
    "text": "By, which I mean more work\nchanges as they propagate back through the graph,\ncould lead to changes",
    "start": "2121170",
    "end": "2127589"
  },
  {
    "text": "in rhs value of\nthat specific node. And so, what we would need to\ndo if we can recompute g of s",
    "start": "2127590",
    "end": "2134520"
  },
  {
    "text": "every time, is put\nit on the queue",
    "start": "2134520",
    "end": "2139760"
  },
  {
    "text": "to signal that we're\nrecomputing g of s, and do that recomputation, and\nthen new changes we've done,",
    "start": "2139760",
    "end": "2147730"
  },
  {
    "text": "perform that again, do\nthat again and again and again and again. And we want to avoid\nthat situation.",
    "start": "2147730",
    "end": "2153413"
  },
  {
    "text": "So what we're going\nto do is we're going to keep our rhs\nas essentially a temp value that can be adjusted\nwhen it's in the queue.",
    "start": "2153414",
    "end": "2159990"
  },
  {
    "text": "So when something is on the\nqueue, it's on there once, and it can be updated\nand taken off.",
    "start": "2159990",
    "end": "2165569"
  },
  {
    "text": "But we know when\nit's been taken off, that it's been taken\nfor the correct time, and won't need to\nbe handled again.",
    "start": "2165570",
    "end": "2171210"
  },
  {
    "text": "AUDIENCE: So if I\nunderstand this correctly, so if you had a single\nedge cost that we changed,",
    "start": "2171210",
    "end": "2180194"
  },
  {
    "text": "then you could just do what\nyou just said, in terms of, you could just update\nthe thing, and probably should be predecessor rate.",
    "start": "2180195",
    "end": "2186214"
  },
  {
    "text": "BEN AYTON: Yes. So if you knew for sure\nthat nothing else was coming back and down,\nthen we could just",
    "start": "2186215",
    "end": "2191400"
  },
  {
    "text": "do that change and propagate\nto all the predecessors, because nothing upstream\nof that node is affected. AUDIENCE: So am I\nunderstanding correctly--",
    "start": "2191400",
    "end": "2198150"
  },
  {
    "text": "so you're basically running\nthe programming, because you're",
    "start": "2198150",
    "end": "2203329"
  },
  {
    "text": "keeping the costs\nto goal to devote, and then what you're doing\nis every time you have",
    "start": "2203330",
    "end": "2210060"
  },
  {
    "text": "an edge that changes to a value\nthat could potentially make that node better\nthan it was before,",
    "start": "2210060",
    "end": "2215370"
  },
  {
    "text": "so if it changes the value\nof that node to something better than it was before,\nyou would change that node,",
    "start": "2215370",
    "end": "2225089"
  },
  {
    "text": "and then queue all\nthe predecessors, because those be\nchanged as well.",
    "start": "2225090",
    "end": "2230940"
  },
  {
    "text": "BEN AYTON: Yes. AUDIENCE: I mean, if\nthose nodes do not change, you don't do anything. You're moving from the queue.",
    "start": "2230940",
    "end": "2237140"
  },
  {
    "text": "They also change a\nbetter bell and keep propagating until you have\nnothing else to [INAUDIBLE].. BEN AYTON: Yeah. But we only do the\npropagation, or we",
    "start": "2237140",
    "end": "2246720"
  },
  {
    "text": "queue changes that occur\nearlier in the graph, but we only actually\nperform the change",
    "start": "2246720",
    "end": "2253500"
  },
  {
    "text": "resetting the g value,\nwhen it's expanded. AUDIENCE: And then\nthe reason for that",
    "start": "2253500",
    "end": "2258569"
  },
  {
    "text": "is for efficiency when you have\nmore than one edge changing?",
    "start": "2258570",
    "end": "2263726"
  },
  {
    "text": "BEN AYTON: Yes. AUDIENCE: So you could basically\nhave multiple paths affecting the same node. And in this situation,\nif you actually",
    "start": "2263726",
    "end": "2271380"
  },
  {
    "text": "allow your changes will\noccur and multiple edges, that's when the importance\nof the queue comes.",
    "start": "2271380",
    "end": "2277140"
  },
  {
    "text": "BEN AYTON: That's exactly. AUDIENCE: Which is\nactually, it prevents you from redoing the same\nwork over and over again. BEN AYTON: That's exactly right.",
    "start": "2277140",
    "end": "2282300"
  },
  {
    "text": "Because if another\nchange came through, then we'd put all the\npredecessors back in the queue again, and we'd do all of\nour updates for all of them",
    "start": "2282300",
    "end": "2287380"
  },
  {
    "text": "as well. We're avoiding that process. AUDIENCE: And the queue ensures\nthat we're only updating--",
    "start": "2287380",
    "end": "2293290"
  },
  {
    "text": "and I think that'll cover it. But in the manner in\nwhich we terminate, we don't necessarily-- we don't\nexpand every node in the queue.",
    "start": "2293290",
    "end": "2300434"
  },
  {
    "text": "We only expand those we need\nin order to find the shortest, and then we retain the queue\nfor that search in case",
    "start": "2300434",
    "end": "2305760"
  },
  {
    "text": "we need to update those in\nthe next round of the search. BEN AYTON: Right. ",
    "start": "2305760",
    "end": "2321410"
  },
  {
    "text": "So I have to correct a\nmistake in my language that I said before. I said that the node in my\nexamples that I gave before",
    "start": "2321410",
    "end": "2328072"
  },
  {
    "text": "was highly consistent,\n[INAUDIBLE] wasn't consistent. I apologize for that mistake. Other consistency is the easy\ncase that we're handling here,",
    "start": "2328072",
    "end": "2336800"
  },
  {
    "start": "2331000",
    "end": "2447000"
  },
  {
    "text": "where when we expand that\nnode, we have to take g of s and set that to be equal to\nthe rhs value for expansion.",
    "start": "2336800",
    "end": "2346079"
  },
  {
    "text": "And then we\npropagate that effect to all of the predecessors\nat that point,",
    "start": "2346080",
    "end": "2351170"
  },
  {
    "text": "which means we update\nthe predecessors and put those on the queue if\nit hasn't had an impact on them.",
    "start": "2351170",
    "end": "2360370"
  },
  {
    "text": "This means that the node is\nnot low key inconsistent, and it's going to remain\nthat way in that fashion.",
    "start": "2360370",
    "end": "2366650"
  },
  {
    "text": "The underconsistent\ncase, which was the opposite of what I showed,\nis the more difficult case.",
    "start": "2366650",
    "end": "2373890"
  },
  {
    "text": "In this case, the old\npath cost was better than the new rhs value. Rhs value has increased\nto above [INAUDIBLE]..",
    "start": "2373890",
    "end": "2381310"
  },
  {
    "text": "In this case, we can no longer\nrelax down to that g value from our Dijkstra's\nalgorithm respective.",
    "start": "2381310",
    "end": "2388280"
  },
  {
    "text": "So we have to think of a\nnew way to handle this. What we do is we\nessentially set our g value",
    "start": "2388280",
    "end": "2396099"
  },
  {
    "text": "to be equal to infinity. And this is an extra\nstep that's going to cause the node to go back on\nthe queue an additional time.",
    "start": "2396100",
    "end": "2405260"
  },
  {
    "text": "But what this mechanism assures\nis that that node goes back on the queue at most\none additional time,",
    "start": "2405260",
    "end": "2412000"
  },
  {
    "text": "which means that for D* Lite,\nwe only ever examine any node at most twice on the queue.",
    "start": "2412000",
    "end": "2419270"
  },
  {
    "text": "Once we've set g of s\nto be equal to infinity, then we can\nessentially relax down to the rhs value from the\nperspective that we had before.",
    "start": "2419270",
    "end": "2428120"
  },
  {
    "text": "So we set g of s to\nbe equal to infinity, and we update all\nthe predecessors of s",
    "start": "2428120",
    "end": "2433180"
  },
  {
    "text": "and s itself this time. As I was saying before, we\nneed to put that node node back on the cue so that\nwe handle it when",
    "start": "2433180",
    "end": "2439010"
  },
  {
    "text": "rhs has hit its minimal value. And this means that\nthat node is now going to locally consistent\nor overconsistent.",
    "start": "2439010",
    "end": "2446628"
  },
  {
    "text": "And we handle\noverconsistency in the case that I've shown you before. So to give you an idea of\nhow exactly this works,",
    "start": "2446628",
    "end": "2454940"
  },
  {
    "text": "I'm showing you an example here. We start off with this graph,\nand we introduce two changes.",
    "start": "2454940",
    "end": "2462980"
  },
  {
    "text": "We have increased\nthis edge cost to 5. And so rhs has now\nincreased to a total of 10.",
    "start": "2462980",
    "end": "2470500"
  },
  {
    "text": "But I've also changed\na value here for edges that you can't can see.",
    "start": "2470500",
    "end": "2476780"
  },
  {
    "text": "But assume that the rhs value\nof this node has also changed. So now we can put\nall of these nodes",
    "start": "2476780",
    "end": "2483450"
  },
  {
    "text": "on a cable ordered in this\nway, computed using the formula that we've seen for it.",
    "start": "2483450",
    "end": "2489036"
  },
  {
    "text": " We expand the node s1 first.",
    "start": "2489037",
    "end": "2495335"
  },
  {
    "text": "And because it's\nunderconsistent, we set g to be\nequal to infinity.",
    "start": "2495335",
    "end": "2502059"
  },
  {
    "text": "Then we propagate to all\npredecessors and s1 itself,",
    "start": "2502060",
    "end": "2510800"
  },
  {
    "text": "meaning those go\nback on the queue. Now, assuming that node\nchanges of any relevance happen in these nodes,\nwe recompute the costs",
    "start": "2510800",
    "end": "2519910"
  },
  {
    "text": "for s1, which has now\nchanged to 14, 10, because we're using the\nminimum of infinity and 10,",
    "start": "2519910",
    "end": "2525555"
  },
  {
    "text": "which is 10 plus 14,\ngoing behind the node s2.",
    "start": "2525555",
    "end": "2532069"
  },
  {
    "text": "Next, we expand this node s2. And because that was\nan overconsistent case, we can just set g to be\nequal to our rhs value.",
    "start": "2532070",
    "end": "2540040"
  },
  {
    "text": "We then have to propagate that\nto its predecessors, which includes s1, which has\nupdated its rhs value.",
    "start": "2540040",
    "end": "2547490"
  },
  {
    "text": "So if we didn't do\nthis, we wouldn't have handled this effect correctly.",
    "start": "2547490",
    "end": "2554420"
  },
  {
    "text": "When we set our rhs\nvalue here, we then have to put this node\nback on the queue.",
    "start": "2554420",
    "end": "2559890"
  },
  {
    "text": "So previously, s1 was\nalready on the queue, but the effect has to be\npropagated to this node, which",
    "start": "2559890",
    "end": "2567290"
  },
  {
    "text": "puts it on the\nqueue again, which would mean adjusting\nthe values, because rhs has been reduced by 1.",
    "start": "2567290",
    "end": "2573230"
  },
  {
    "text": "Both the costs here\nhave been reduced by 1. Then we expand that node.",
    "start": "2573230",
    "end": "2578930"
  },
  {
    "text": "We have an overconsistent case. We're setting g to\nbe equal to rhs. And finally, we've completed\nour graph search problem.",
    "start": "2578930",
    "end": "2585780"
  },
  {
    "text": " So now what we have to handle\nis an additional complication",
    "start": "2585780",
    "end": "2591840"
  },
  {
    "text": "that occurs between\nseveral steps, tracking how our\nheuristics have changed.",
    "start": "2591840",
    "end": "2597810"
  },
  {
    "text": "So we want to carry\nover prior queue, which was what was\nmentioned previously, between our different searches\nas our stock node moves.",
    "start": "2597810",
    "end": "2605940"
  },
  {
    "text": "But the problem is that we're\nmoving from our start node to a different point.",
    "start": "2605940",
    "end": "2611790"
  },
  {
    "text": "Recall that our heuristic value\nis measured from any given node to the stock node.",
    "start": "2611790",
    "end": "2616960"
  },
  {
    "text": "So when our stock\nnode has changed, the heuristic value is not\ngoing to be the same value",
    "start": "2616960",
    "end": "2622400"
  },
  {
    "text": "to the new stock mode. So we want what's\nalready on the queue to be comparable to\nwhat is being computed",
    "start": "2622400",
    "end": "2629556"
  },
  {
    "text": "for our new value, so we can\nuse the math and the algebra that we've already done. So how we handle this is we\nintroduce something called",
    "start": "2629556",
    "end": "2637170"
  },
  {
    "text": "the key modifier, where we\nmove from the previous start node, which here I indicated as\ns last, to the new start node,",
    "start": "2637170",
    "end": "2645030"
  },
  {
    "text": "all the heuristics for\nadmissible heuristic are lowered by at most a\nheuristic from the last start",
    "start": "2645030",
    "end": "2651370"
  },
  {
    "text": "node to the new start node. So now, when we add\nnew nodes to the queue, instead of subtracting that\nvalue from everything that's",
    "start": "2651370",
    "end": "2659220"
  },
  {
    "text": "already on the queue,\nwhat we do is we just increase for\nall nodes that we put on the queue, their\nvalues, by this new modifier.",
    "start": "2659220",
    "end": "2669840"
  },
  {
    "text": "Because essentially when\nwe're taking off of the queue, all that matters is the relative\ndifferences between the two.",
    "start": "2669840",
    "end": "2675670"
  },
  {
    "text": "And so, instead of subtracting\na value from everything on the queue, adding that\nvalue to all new values that",
    "start": "2675670",
    "end": "2681500"
  },
  {
    "text": "occur on the queue will\nachieve the same purpose. And so our key modifier\nis initialized to 0",
    "start": "2681500",
    "end": "2687160"
  },
  {
    "text": "at the start of the algorithm,\nand is increased every time that we update our\nstart by this new value,",
    "start": "2687160",
    "end": "2694890"
  },
  {
    "text": "by the heuristic\nbetween the last start node and the new start node. And then we update\nour total cost",
    "start": "2694890",
    "end": "2700890"
  },
  {
    "text": "to include the edition\nof the key modifier fire for our f1 term.",
    "start": "2700890",
    "end": "2706446"
  },
  {
    "text": "So now we've covered all of\nthe D* Lite algorithm basics.",
    "start": "2706446",
    "end": "2711980"
  },
  {
    "text": "And we can actually\nwalk through the slide that I showed you\nbefore with the math. So when we start, we\ninitialize all of our g values",
    "start": "2711980",
    "end": "2719700"
  },
  {
    "text": "to be equal to infinity,\nand all of our rhs values to be equal to infinity,\nexcept at the goal node. And that's to ensure that\nwe always have a node",
    "start": "2719700",
    "end": "2726480"
  },
  {
    "text": "to start from our search. We best-first search from the\ngoal node to the start node",
    "start": "2726480",
    "end": "2733025"
  },
  {
    "text": "until that's locally\nconsistent and expanded. We should now know\nwhat that means. And that signal that we\nhave found our best path,",
    "start": "2733025",
    "end": "2740030"
  },
  {
    "text": "we move according to\nour movement rule, and then if any of our\nedge costs have changed,",
    "start": "2740030",
    "end": "2745410"
  },
  {
    "text": "we update our key modifier,\nand update our rhs and queue positions for the source\nnodes of change in edge costs,",
    "start": "2745410",
    "end": "2752790"
  },
  {
    "text": "meaning the nodes from which\nthose edges originated. And then, we simply\nrepeat from two,",
    "start": "2752790",
    "end": "2759240"
  },
  {
    "text": "following best-first\nthrough the principles that I've walked you\nthrough for overconsistent and underconsistent nodes.",
    "start": "2759240",
    "end": "2766390"
  },
  {
    "text": "And as a reminder\ndown here, we always search or sort by this very\nlong couplet of two values.",
    "start": "2766390",
    "end": "2775044"
  },
  {
    "text": "So now, we're going to\nwalk through an example of [INAUDIBLE]. ",
    "start": "2775044",
    "end": "2783440"
  },
  {
    "text": "JESS NOSS: OK.  So again, here's the pseudo code\nthat Ben was just presenting.",
    "start": "2783440",
    "end": "2790530"
  },
  {
    "text": "And we're going to go through a\nquick example with five nodes, so this isn't going to show all\nof the properties of why you",
    "start": "2790530",
    "end": "2797957"
  },
  {
    "start": "2791000",
    "end": "3345000"
  },
  {
    "text": "would want to use\nincremental path planning, because when you\nhave only five nodes, you're going to end updating a\nlot of them a lot of the time.",
    "start": "2797957",
    "end": "2803760"
  },
  {
    "text": "But after the\nexample, you'll see how it makes more of a\ndifference on a larger graph. So in this graph,\nwe're going to have",
    "start": "2803760",
    "end": "2810320"
  },
  {
    "text": "prior nodes that go A, B, C,\nD, and G is our goal node. The robot will start\nat node A, and its goal",
    "start": "2810320",
    "end": "2816440"
  },
  {
    "text": "is to find the shortest\npath to node G, except that the\ngraph might change as the robot goes\nthrough, or the robot might gain new information.",
    "start": "2816440",
    "end": "2823670"
  },
  {
    "text": "So initially, the robot thinks\nthat every node is available. And it knows that the\npath lengths are all 1,",
    "start": "2823670",
    "end": "2829160"
  },
  {
    "text": "except for from D to G,\nthe path length is 10. So this is a\nbi-directional graph.",
    "start": "2829160",
    "end": "2834230"
  },
  {
    "text": "Every edge goes both directions. And the heuristic,\nas Ben described, will be with respect\nto the start node.",
    "start": "2834230",
    "end": "2842832"
  },
  {
    "text": "In this case, we'll just\nsay that the heuristic is the number of nodes\nto the start node. So we're ignoring the fact\nthat this edge length is 10.",
    "start": "2842832",
    "end": "2849825"
  },
  {
    "text": "So first, we'll initialize\nall the g and rhs values. So we have infinity\nat every node,",
    "start": "2849825",
    "end": "2856560"
  },
  {
    "text": "except for the goal node,\nwhich has an rhs value of 0. So this means that\nall of the nodes",
    "start": "2856560",
    "end": "2861920"
  },
  {
    "text": "are correctly\nlocally consistent, because their g and rhs values\nare the same, except the goal node.",
    "start": "2861920",
    "end": "2867270"
  },
  {
    "text": "So we put the goal\nnode on the queue using the formula that\nis on Ben's slide, which",
    "start": "2867270",
    "end": "2874227"
  },
  {
    "text": "I'll put here for reference. So the key is going\nto be these two terms.",
    "start": "2874228",
    "end": "2884970"
  },
  {
    "text": "First, we have the\nminimum of g and rhs",
    "start": "2884970",
    "end": "2891380"
  },
  {
    "text": "plus the heuristic value\nplus the key modifier, which",
    "start": "2891380",
    "end": "2897700"
  },
  {
    "text": "is initially 0. And then we have the\nsecond term, which is just the minimum, g of rhs.",
    "start": "2897700",
    "end": "2904042"
  },
  {
    "text": " So you can see how we\nwould get 3, 0 here,",
    "start": "2904042",
    "end": "2910580"
  },
  {
    "text": "because the 3 comes\nfrom the heuristic, and everything else was 0, so\nwe just added a bunch of 0's. ",
    "start": "2910580",
    "end": "2918348"
  },
  {
    "text": "So that's everything what\nhappens for the initialization. And now we have one\nnode on the queue. So we'll have to dequeue first.",
    "start": "2918348",
    "end": "2926549"
  },
  {
    "text": "This is an easy question. AUDIENCE: The node on the queue. JESS NOSS: The one\nnode on the queue. So we dequeue G. So we're going\nout to update its g value.",
    "start": "2926549",
    "end": "2933400"
  },
  {
    "text": "So as Ben said, the rhs value\nis sort of a look ahead. You can also think of rhs as\nbeing the shortest path that we",
    "start": "2933400",
    "end": "2942819"
  },
  {
    "text": "found so far, and G is the\nguaranteed shortest path to that node. So this one is trivial. The shortest path from\nthis node to itself",
    "start": "2942820",
    "end": "2949420"
  },
  {
    "text": "has length 0, because\nits the same node. So now we're going to update the\nrhs values and its neighbors.",
    "start": "2949420",
    "end": "2958970"
  },
  {
    "text": "So it has two neighbors,\nC and D, and in each case, the rhs value will\nbe the minimum--",
    "start": "2958970",
    "end": "2965640"
  },
  {
    "text": " this is not actual math, but its\nthe minimum of the edge cost,",
    "start": "2965640",
    "end": "2975420"
  },
  {
    "text": "the d value of a neighbor\nplus the edge cost. ",
    "start": "2975420",
    "end": "2982590"
  },
  {
    "text": "Which is the same thing as the\nedge weight or the weight w.",
    "start": "2982590",
    "end": "2988730"
  },
  {
    "text": "So we rhs is 10 here, because\nit's the distance from g to do, and then it's one,\nwhich is G to C.",
    "start": "2988730",
    "end": "2997010"
  },
  {
    "text": "So again, we can\ncalculate keys for those. So now we'll dequeue\nanother node. What should we dequeue next?",
    "start": "2997010",
    "end": "3002714"
  },
  {
    "text": " AUDIENCE: C. JESS NOSS: C. Because\nit has a smaller key.",
    "start": "3002714",
    "end": "3009450"
  },
  {
    "text": "So we dequeue C. We\nupdate its g value. So this is saying, now we know\nthat the shortest path to C",
    "start": "3009450",
    "end": "3016339"
  },
  {
    "text": "actually has length 1. And we can also compare this\nto A* star algorithm by drawing",
    "start": "3016340",
    "end": "3022150"
  },
  {
    "text": "a search tree. So in the beginning, we had A*. ",
    "start": "3022150",
    "end": "3034010"
  },
  {
    "text": "In the beginning,\nwe just had node G, because we were searching from\nG backward through the goal.",
    "start": "3034010",
    "end": "3039780"
  },
  {
    "text": "And then we expanded\nthat back to get C and D.",
    "start": "3039780",
    "end": "3047200"
  },
  {
    "text": "And then A* to keep track of the\npath length to that node plus",
    "start": "3047200",
    "end": "3052260"
  },
  {
    "text": "the heuristic at each node. So the pathway to C was\n1 plus the heuristic 2,",
    "start": "3052260",
    "end": "3058920"
  },
  {
    "text": "give us the value of 3. So if we go back a\nmoment, we can see-- ",
    "start": "3058920",
    "end": "3066018"
  },
  {
    "text": "is that OK?  So you can see that this 3 is\nthe same as the first point",
    "start": "3066018",
    "end": "3072900"
  },
  {
    "text": "of the key, and path\nlength one is the same as the second part of the key.",
    "start": "3072900",
    "end": "3078490"
  },
  {
    "text": "And then similarly at D, we\nhave the path length, which is 10, plus the 2, give us 12.",
    "start": "3078490",
    "end": "3089684"
  },
  {
    "text": "So this 12 is the 12 here, and\nthen the 10 is the path length.",
    "start": "3089685",
    "end": "3094702"
  },
  {
    "text": "And so you can see how if\nwe were doing this the A*, you would also dequeue C next.",
    "start": "3094702",
    "end": "3099912"
  },
  {
    "start": "3099912",
    "end": "3106030"
  },
  {
    "text": "OK. So now, we dequeue\nC, and we're going to update the rhs\nand its neighbors.",
    "start": "3106030",
    "end": "3112460"
  },
  {
    "text": "So B is pretty simple. Previously, it's\nrhs was infinity. Now the shortest path to\nB that we've found so far",
    "start": "3112460",
    "end": "3118190"
  },
  {
    "text": "has length 2. So here we have B was a path\nlength 2, plus a heuristic of 1",
    "start": "3118190",
    "end": "3125795"
  },
  {
    "text": "gives us 3.  But what about D? Previously, its\nrhs value was 10,",
    "start": "3125795",
    "end": "3132120"
  },
  {
    "text": "but do we now have\na shorter path to D, given that we're expanding C? ",
    "start": "3132120",
    "end": "3139795"
  },
  {
    "text": "Or is 10 still\nthe shortest path?  AUDIENCE: That is the\nshortest path, through C.",
    "start": "3139795",
    "end": "3146094"
  },
  {
    "text": "JESS NOSS: Yeah. So now that we're\nexpanding C, we see that you can actually get\nto D in only two units instead of 10 units. So that's better.",
    "start": "3146094",
    "end": "3153940"
  },
  {
    "text": "So we'll update\nthe rhs value to 2. And that means that we're going\nto change D's key accordingly.",
    "start": "3153940",
    "end": "3164190"
  },
  {
    "text": "And the way that maps to A* is,\nso if you already have the path length is 2, plus the\nheuristic is 2, gives us 4.",
    "start": "3164190",
    "end": "3171890"
  },
  {
    "text": "And the fact that we're\nchanging the key to 4, 2 means that we're never\ngoing to expand this D,",
    "start": "3171890",
    "end": "3177210"
  },
  {
    "text": "because A* uses an extended set,\nso it would always expand this D with a shorter\ncost before this one.",
    "start": "3177210",
    "end": "3184809"
  },
  {
    "text": "So that's indicated\nby-- removed by changing the key on the queue.",
    "start": "3184810",
    "end": "3190400"
  },
  {
    "text": "So what do we do next? Which node do we dequeue? ",
    "start": "3190400",
    "end": "3197453"
  },
  {
    "text": "AUDIENCE: B. JESS NOSS: B? Yeah, because it\nhas the smaller key.",
    "start": "3197454",
    "end": "3202710"
  },
  {
    "text": "So we'll dequeue B. We'll update\nits g value, which is again saying that we know now that\nthe shortest path to B is 2.",
    "start": "3202710",
    "end": "3211940"
  },
  {
    "text": "So we dequeue B, and\nthen we expand it. How many neighbors does B have?",
    "start": "3211940",
    "end": "3218609"
  },
  {
    "text": "AUDIENCE: Three. JESS NOSS: Three. So we're actually expanding to\nall three of those neighbors.",
    "start": "3218609",
    "end": "3225089"
  },
  {
    "text": "We have A, C, and D.\nCan we still see this?",
    "start": "3225090",
    "end": "3231488"
  },
  {
    "text": "We can.  So at A, it's pretty simple.",
    "start": "3231488",
    "end": "3237150"
  },
  {
    "text": "We have the rhs value is 3,\nbecause it's the shortest path through GCB to A. So that's\n3, plus the heuristic 0 plus 3.",
    "start": "3237150",
    "end": "3249040"
  },
  {
    "text": "What about-- oh, see, it\ndoesn't change, because--",
    "start": "3249040",
    "end": "3254060"
  },
  {
    "text": "you could go through\nB and back to C, but-- oh, C shouldn't\nactually be on here. Sorry.",
    "start": "3254060",
    "end": "3260114"
  },
  {
    "text": "C shouldn't be on\nhere, because we don't want a loop in our path. ",
    "start": "3260114",
    "end": "3266710"
  },
  {
    "text": "OK. So at D, can we do better\nthan this path length of 2?",
    "start": "3266710",
    "end": "3272203"
  },
  {
    "text": " AUDIENCE: No. JESS NOSS: No.",
    "start": "3272204",
    "end": "3277380"
  },
  {
    "text": "Because what happened\nwas originally, we had the path length\nof 10 through G, and then we had the\npath length of 2, 3 C,",
    "start": "3277380",
    "end": "3282515"
  },
  {
    "text": "and this path through\nB is not as good. So we're going to keep the\nsame rhs value and key at D.",
    "start": "3282516",
    "end": "3290230"
  },
  {
    "text": "And we can see that in a lot\nof he A*, where we would have, if we did do GCBD, we\nwould have a pathway of 3,",
    "start": "3290230",
    "end": "3298410"
  },
  {
    "text": "plus the heuristic of 2 is 5. But we would never actually\nwant to expand that D,",
    "start": "3298410",
    "end": "3305170"
  },
  {
    "text": "because it's not as\ngood as this one. OK. Now what would we dequeue?",
    "start": "3305170",
    "end": "3310750"
  },
  {
    "text": "Looks like we have two nodes\nin our queue currently. JOE LEAVITT: A.",
    "start": "3310750",
    "end": "3316402"
  },
  {
    "text": "JESS NOSS: A. So we\ndequeue A. That's where we trying to\nget to, because that's",
    "start": "3316402",
    "end": "3322993"
  },
  {
    "text": "the current start node. So we set the g\nvalue to 3, which means that that's actually\nthe shortest path.",
    "start": "3322993",
    "end": "3330410"
  },
  {
    "text": "And we're done. We found the shortest path. Well, we're done, except that\nthe path might have to change.",
    "start": "3330410",
    "end": "3335897"
  },
  {
    "text": "So one thing you notice\nhere is that we never have to actually set D's g value. So it's possible, maybe there's\nstill a shorter path to D,",
    "start": "3335897",
    "end": "3343910"
  },
  {
    "text": "but it doesn't matter. So now the robot will move\nto its next best place, which",
    "start": "3343910",
    "end": "3350540"
  },
  {
    "text": "is B, and we'll update the\nheuristics accordingly, because this is\nour new start node. So now, again, our\nheuristic is the number",
    "start": "3350540",
    "end": "3358430"
  },
  {
    "text": "of nodes away from\nthat green node. And we're keeping the same\nitems on the queue from before.",
    "start": "3358430",
    "end": "3365849"
  },
  {
    "text": "But we also have to\nupdate the key modifier. So now what happens is\nan obstacle appears.",
    "start": "3365850",
    "end": "3371750"
  },
  {
    "text": "So there's an obstacle at\nC that the robot can now see because it's moved\ncloser to node C,",
    "start": "3371750",
    "end": "3376780"
  },
  {
    "text": "but it couldn't see it before. So now, we're going to indicate\nthat by keeping all the edges,",
    "start": "3376780",
    "end": "3383650"
  },
  {
    "text": "but changing their\nrates to infinity. And that means that the robot\ncould try to get to see, but it wouldn't ever get there.",
    "start": "3383650",
    "end": "3390840"
  },
  {
    "text": "So what we do next in\nthe algorithm is we're going to update all of\nthe rhs values associated",
    "start": "3390840",
    "end": "3396170"
  },
  {
    "text": "with the source\nnodes of these edges. And in this case, the\nedges go both directions, so all four of these nodes are\naffected by the infinities.",
    "start": "3396170",
    "end": "3405300"
  },
  {
    "text": "So let's start with node C.\nWhat would be its new rhs value, given that rhs is the minimum\nfrom one of its neighbors to it",
    "start": "3405300",
    "end": "3414590"
  },
  {
    "text": "of the g plus edge cost? AUDIENCE: Infinity. JESS NOSS: Infinity. because\nall of the edge costs going to C",
    "start": "3414590",
    "end": "3421941"
  },
  {
    "text": "are infinity. So what would be the key? The tricky part here\nis the first part",
    "start": "3421941",
    "end": "3427840"
  },
  {
    "text": "of the key is the\nminimum of g and rhs. ",
    "start": "3427840",
    "end": "3436184"
  },
  {
    "text": "So the minimum of\ng or rhs is what? AUDIENCE: So it'd be 3, 1?",
    "start": "3436184",
    "end": "3443118"
  },
  {
    "text": "Yeah. JESS NOSS: Yeah, 3, 1, because\nthe minimum of g and rhs",
    "start": "3443118",
    "end": "3448940"
  },
  {
    "text": "is g, which is 1. The heuristic is 1, and\nthe key modifier is 1. OK.",
    "start": "3448940",
    "end": "3454370"
  },
  {
    "text": "How about node B? What's the new rhs value? ",
    "start": "3454370",
    "end": "3460349"
  },
  {
    "text": "So it has a neighbor\nhere with g as infinity, a neighbor here of g is\n1, except the edge length is infinity.",
    "start": "3460350",
    "end": "3466453"
  },
  {
    "text": "And then this guy with g is 3. ",
    "start": "3466454",
    "end": "3472861"
  },
  {
    "text": "AUDIENCE: So it's infinity, 4? JESS NOSS: 4. Yeah, because\ncurrently, we still",
    "start": "3472861",
    "end": "3478720"
  },
  {
    "text": "think that you can\nget to A and B units. So this is actually\ngoing to be 4.",
    "start": "3478720",
    "end": "3484400"
  },
  {
    "text": "So this is one of the\nsillier things that D* does, but luckily, it doesn't\ndo this very much, so it doesn't actually\nreally cost too much time.",
    "start": "3484400",
    "end": "3492750"
  },
  {
    "text": "And then how about D? What would be the new rhs value? ",
    "start": "3492750",
    "end": "3505860"
  },
  {
    "text": "AUDIENCE: 5, 3? rhs. JESS NOSS: So it has\nbeen 3 neighbors.",
    "start": "3505860",
    "end": "3512480"
  },
  {
    "text": "This edge length is infinity\nis useless, so that's useless. This one has g of 0\nplus 10 would be 10.",
    "start": "3512480",
    "end": "3518022"
  },
  {
    "text": "Yes, so this is the best one. G is 2, plus edge length of 1. So that would give us 3.",
    "start": "3518022",
    "end": "3524285"
  },
  {
    "text": "So now what do we dequeue? ",
    "start": "3524285",
    "end": "3530870"
  },
  {
    "text": "AUDIENCE: C? JESS NOSS: C. So this is one of\nthose tie breaking cases, where both of them have\nthe first value is 3,",
    "start": "3530870",
    "end": "3537010"
  },
  {
    "text": "but C has a better\nsecond value in its key, so we'll dequeue C. Is this\nover or under consistent?",
    "start": "3537010",
    "end": "3547364"
  },
  {
    "text": "So the definitions of\nover and under consistent that we had earlier, we had\nif g is greater than rhs,",
    "start": "3547364",
    "end": "3560359"
  },
  {
    "text": "then that's\noverconsistent, and we set g equal to rhs\nwhen we're updating g.",
    "start": "3560360",
    "end": "3567859"
  },
  {
    "text": "So that was the case\nthat we've seen so far. But then if g is less than\nrhs, it's underconsistent,",
    "start": "3567860",
    "end": "3577960"
  },
  {
    "text": "and we set g to infinity. So what is this?",
    "start": "3577960",
    "end": "3583790"
  },
  {
    "text": "AUDIENCE: Underconsistent. JESS NOSS: Underconsistent. So the reason\nintuitively why we're going to set g to\ninfinity is because we're",
    "start": "3583790",
    "end": "3589930"
  },
  {
    "text": "saying there's some sort\nof contradiction here. This one doesn't make any sense. It's less than the\nrhs value, so we're",
    "start": "3589930",
    "end": "3595310"
  },
  {
    "text": "going to just reset g and sort\nof start over with this node. So we set that to infinity.",
    "start": "3595310",
    "end": "3600812"
  },
  {
    "text": "And in this case,\nwe don't actually need to add the node\nback onto the queue, because it's now consistent. It's now locally consistent.",
    "start": "3600812",
    "end": "3608730"
  },
  {
    "text": "So next, we'll dequeue the one\nwith the smallest key, which is B. B is also underconsistent,\nso we're going to set its g",
    "start": "3608730",
    "end": "3617162"
  },
  {
    "text": "value back to infinity. So this is sort of resetting\nthe weird thing we did earlier that didn't make any sense.",
    "start": "3617162",
    "end": "3623830"
  },
  {
    "text": "We're going to update its\nneighbors' rhs values. So what would be the\nnew rhs value for A,",
    "start": "3623830",
    "end": "3630420"
  },
  {
    "text": "now that we know that we\ndon't actually have a path B?",
    "start": "3630420",
    "end": "3636744"
  },
  {
    "text": "AUDIENCE: Infinity? JESS NOSS: Infinity. Yeah. And then, how about\nrhs value to D?",
    "start": "3636745",
    "end": "3642770"
  },
  {
    "text": "Because currently,\nD got its rhs value by going from A to B to D.",
    "start": "3642770",
    "end": "3653602"
  },
  {
    "text": "AUDIENCE: 10. JESS NOSS: 10. 'Cause now the only way-- rhs is 10.",
    "start": "3653602",
    "end": "3658710"
  },
  {
    "text": "The key would have\nthat one also. Is that right?",
    "start": "3658710",
    "end": "3665454"
  },
  {
    "text": "Yeah. Because currently,\nthe best path to D, and actually, the best\npath to D you can see",
    "start": "3665454",
    "end": "3671860"
  },
  {
    "text": "is from G to D, because you\ncan't go through C anymore.",
    "start": "3671860",
    "end": "3676936"
  },
  {
    "text": "So now, we'll dequeue node A,\nbecause it has the smallest key. It was also underconsistent,\nso we would set G to infinity.",
    "start": "3676936",
    "end": "3686019"
  },
  {
    "text": "So we'll propagate\nthat to its neighbors. And if we continue doing\nthis, then we find--",
    "start": "3686020",
    "end": "3695510"
  },
  {
    "text": "eventually, we dequeue this\nnode, and in this case, we had to dequeue\neverything, so now the node's are locally consistent.",
    "start": "3695510",
    "end": "3702420"
  },
  {
    "text": "So what's the best path that\nwe've found from B to the goal? ",
    "start": "3702420",
    "end": "3710859"
  },
  {
    "text": "AUDIENCE: B, D, G? JESS NOSS: B, D,\nG. And that's also the only path in this case. And we had to update\nthese neighbors.",
    "start": "3710860",
    "end": "3718481"
  },
  {
    "text": "OK. So here's our new shortest path. Now, the robot will\nmove to node D. But now,",
    "start": "3718481",
    "end": "3723690"
  },
  {
    "text": "what's going to happen-- I think we updated\nour heuristics. But now what happens is it turns\nout it's a moving obstacle,",
    "start": "3723690",
    "end": "3728880"
  },
  {
    "text": "and it starts\nfollowing the robot. So now the obstacle\nhas moved to there. So as humans, we can see\nthat, obviously, the shortest",
    "start": "3728880",
    "end": "3735750"
  },
  {
    "text": "path is through C,\nbut the algorithm doesn't know this yet. So what would we do next?",
    "start": "3735750",
    "end": "3740990"
  },
  {
    "start": "3740990",
    "end": "3746990"
  },
  {
    "text": "So we just updated\nour edge weights. So now all the edges\nto B are infinity. But some of the edges to\nC are no longer infinity.",
    "start": "3746990",
    "end": "3754720"
  },
  {
    "text": "So we need to update the\nrhs values accordingly.",
    "start": "3754720",
    "end": "3759760"
  },
  {
    "text": "So we'll update all\nof the rhs values that were affected\nby this change. In this case, G's\nrhs value never",
    "start": "3759760",
    "end": "3766800"
  },
  {
    "text": "changes because the distance\nfrom G to itself is always 0. And this one doesn't\nchange because we still",
    "start": "3766800",
    "end": "3773810"
  },
  {
    "text": "use the G value here. ",
    "start": "3773810",
    "end": "3778910"
  },
  {
    "text": "OK. So now again, we can start\ndequeuing and planning a new path, so we'll\ndequeue this node. We'll propagate\nto its neighbors.",
    "start": "3778910",
    "end": "3786760"
  },
  {
    "text": "Dequeue that one. Update the rhs values. But in this case, we don't--",
    "start": "3786760",
    "end": "3793908"
  },
  {
    "text": "let me go back step. So we dequeue this node,\nand we update its G value, but we don't actually need\nto continue dequeuing things.",
    "start": "3793908",
    "end": "3803910"
  },
  {
    "text": "We should-- oh, this rhs\nvalue should be updated. Oh, it is updated. Why is this rhs infinity?",
    "start": "3803910",
    "end": "3812680"
  },
  {
    "text": "AUDIENCE: All edges\nto it are infinity. JESS NOSS: Yeah. All edges to it are infinity. You can't get there. But we don't actually have\nto bother expanding B,",
    "start": "3812680",
    "end": "3821424"
  },
  {
    "text": "because we've already\nfound the shortest path. So this gives you sort of a hint\nat when D* might be efficient. Because even if there were\na whole bunch of nodes",
    "start": "3821424",
    "end": "3828360"
  },
  {
    "text": "over there, I wouldn't\nneed to consider them, because we found\nthe shortest path. So now, the robot\ncan move up to C.",
    "start": "3828360",
    "end": "3837040"
  },
  {
    "text": "And let's say the obstacle\nchases the robot again. Do we need to find a new path?",
    "start": "3837040",
    "end": "3844221"
  },
  {
    "text": "No. So intuitively, we don't,\nbecause the obstacle's not in the way of our\ncurrent best path.",
    "start": "3844221",
    "end": "3849330"
  },
  {
    "text": "But we can also\nsee algorithmically why that's the case. So first of all, we'll\nupdate all of our rhs values",
    "start": "3849330",
    "end": "3855020"
  },
  {
    "text": "accordingly, because\nwe've changed all of the edge weights. ",
    "start": "3855020",
    "end": "3860788"
  },
  {
    "text": "But the reason algorithmically\nwhy we don't actually need to consider any\nof these change values",
    "start": "3860788",
    "end": "3867190"
  },
  {
    "text": "is because this node has\nthe smallest key, which means that this is the node\nthat has the shortest path to G",
    "start": "3867190",
    "end": "3874839"
  },
  {
    "text": "anyway. It is smaller key than\nall the other nodes that are on the queue. So dequeuing things\nwouldn't actually",
    "start": "3874840",
    "end": "3881470"
  },
  {
    "text": "help us find the shorter path. So the robot can move to the\ngoal, and we've succeeded.",
    "start": "3881470",
    "end": "3890007"
  },
  {
    "text": "Any questions on that? ",
    "start": "3890008",
    "end": "3896695"
  },
  {
    "text": "OK. So now then we'll\ntalk about sometimes when you would want to use\nincremental path planning,",
    "start": "3896695",
    "end": "3902500"
  },
  {
    "text": "other than this five node graph.  ERLEND HARBITZ: Thanks. So as Jess said, there\nare sometimes good reasons",
    "start": "3902500",
    "end": "3911395"
  },
  {
    "text": "to use incremental\npath planning, but there are also\ngood reasons not to in certain circumstances. In certain circumstances,\nwe can actually",
    "start": "3911395",
    "end": "3917470"
  },
  {
    "text": "formulate graph problems,\nwhere a problem is worse by using incremental planning.",
    "start": "3917470",
    "end": "3922640"
  },
  {
    "text": "Remember that I said that D*\nLite puts any node on the queue at most twice.",
    "start": "3922640",
    "end": "3928540"
  },
  {
    "text": "And so we can compare that to\nA*, or something like that, that does full replanning\nwhenever a search occurs.",
    "start": "3928540",
    "end": "3935660"
  },
  {
    "text": "That pus every node on the\nsearch queue at most once. So D* Lite is most beneficial\nwhen putting the nodes",
    "start": "3935660",
    "end": "3943730"
  },
  {
    "text": "on the queue, potentially\nmore than once, leads to less nodes\nbeing examined overall.",
    "start": "3943730",
    "end": "3950220"
  },
  {
    "text": " So here is essentially\nwhat I just said.",
    "start": "3950220",
    "end": "3957710"
  },
  {
    "text": "So A* might perform better for\ncertain problems if we only",
    "start": "3957710",
    "end": "3963440"
  },
  {
    "text": "have to consider a small\namount of nodes anyway. So putting nodes\non the graph twice",
    "start": "3963440",
    "end": "3971030"
  },
  {
    "text": "would actually lead\nto more expansions. And so, to get at an intuition\nof why that might occur",
    "start": "3971030",
    "end": "3979040"
  },
  {
    "text": "if changes are close\nto the start node, I want to show you\nan example here.",
    "start": "3979040",
    "end": "3985130"
  },
  {
    "text": "So here, we're actually\nshowing an example that's derived from [INAUDIBLE]. So we're searching forwards\nhere from the start node",
    "start": "3985130",
    "end": "3991832"
  },
  {
    "text": "to the goal node. And that's just a\ndifferent reformulation, so don't let that\nconfuse you too much.",
    "start": "3991832",
    "end": "3997730"
  },
  {
    "text": "When we walk forward through\nA* with a good heuristic, we might move directly from\nthe start node to goal node,",
    "start": "3997730",
    "end": "4004168"
  },
  {
    "text": "and find that path. Now, if a change occurs\nsomewhere upstream",
    "start": "4004168",
    "end": "4009599"
  },
  {
    "text": "of the start node,\nwhen we replanning, we essentially have to\nreplan the sections that",
    "start": "4009600",
    "end": "4017320"
  },
  {
    "text": "are beyond the change\nthat's occurred. So everything that's\nhere, to an extent, it's",
    "start": "4017320",
    "end": "4025569"
  },
  {
    "text": "relatively insensitive\nto this change. It could occur that\nwe would have to take",
    "start": "4025570",
    "end": "4031244"
  },
  {
    "text": "an entirely different route. But for the most\npart, it's likely that changes are going to\ncouple to our existing path",
    "start": "4031244",
    "end": "4038570"
  },
  {
    "text": "and so forth. And so we have an\nefficient search that will just go\naround from the path",
    "start": "4038570",
    "end": "4047500"
  },
  {
    "text": "that we've already\nplanned to our goal node. So in this sense,\nwe have an example",
    "start": "4047500",
    "end": "4053200"
  },
  {
    "text": "where incremental path planning\nwould be very efficient.",
    "start": "4053200",
    "end": "4058960"
  },
  {
    "text": "In this case, which\nis a different one, we introduce an obstacle\nvery near our start node.",
    "start": "4058960",
    "end": "4064660"
  },
  {
    "text": "This means that most of our\nexisting path is to charge. So where we start out from our\nstart node to our goal node,",
    "start": "4064660",
    "end": "4075880"
  },
  {
    "text": "we have to do a lot of\nrecomputation from scratch. And so an incremental\nsearching algorithm",
    "start": "4075880",
    "end": "4082006"
  },
  {
    "text": "is going to have to undo all\nsearches that we've already done, and then search\nthrough almost the entirety",
    "start": "4082007",
    "end": "4087940"
  },
  {
    "text": "of the graph again. So intuitively, in this case,\njust restarting with A* from",
    "start": "4087940",
    "end": "4093960"
  },
  {
    "text": "a blank slate, which we\nwould search directly down to the goal, instead of doing\nreparations that would send us",
    "start": "4093960",
    "end": "4100770"
  },
  {
    "text": "in one path, would be a\nbetter idea in this case. So since we're powering\nfrom the start to the goal,",
    "start": "4100770",
    "end": "4109250"
  },
  {
    "text": "in this example\nthat we're showing, it's worse to use incremental\npath planning algorithms",
    "start": "4109250",
    "end": "4114910"
  },
  {
    "text": "when your changes happen\nnear your start node. For something like D* Lite, we\nsearch back from the goal node",
    "start": "4114910",
    "end": "4123399"
  },
  {
    "text": "to the start node, it's\nbetter if changes occur nearer to the start node, which for our\nvehicles that we normally see",
    "start": "4123399",
    "end": "4130719"
  },
  {
    "text": "that have limited\nsensor horizons, is what's going to\noccur in the most case.",
    "start": "4130720",
    "end": "4135740"
  },
  {
    "text": "So in those type of situations,\nincremental path planning is going to be very efficient.",
    "start": "4135740",
    "end": "4140841"
  },
  {
    "text": "AUDIENCE: So I understand\nhow this could be a problem for LPA* and D* Lite over\nfinding a single path,",
    "start": "4140842",
    "end": "4147121"
  },
  {
    "text": "where you have like a\nsingle source or destination or something like that. But what if it's incremental,\nall-pairs shortest-paths,",
    "start": "4147122",
    "end": "4154299"
  },
  {
    "text": "where you've computed-- I'd assume you wouldn't\nexperience the same problems",
    "start": "4154300",
    "end": "4159750"
  },
  {
    "text": "if your algorithm was computing\nchoice paths between all pairs of nodes indirect. ERLEND HARBITZ: Yeah. It already exists.",
    "start": "4159750",
    "end": "4165881"
  },
  {
    "text": " Well, that depends. ",
    "start": "4165882",
    "end": "4173720"
  },
  {
    "text": "When you're redoing\nrecomputation,",
    "start": "4173720",
    "end": "4179470"
  },
  {
    "text": "between all the\nnodes in the path, it depends if our\nobstacle has changed",
    "start": "4179470",
    "end": "4185725"
  },
  {
    "text": "[INAUDIBLE] of something\nthere that we to conceive. And by that I mean\nimagining this graph we've computed, D, the\npaths and path costs,",
    "start": "4185726",
    "end": "4193540"
  },
  {
    "text": "to get from every single node\nto every single other node. Now, if introducing\nan obstacle here",
    "start": "4193540",
    "end": "4199520"
  },
  {
    "text": "only changed the path cost\nto get from our stock node to our goal node\nfrom example, then",
    "start": "4199520",
    "end": "4206580"
  },
  {
    "text": "replanning that specific\npair of paths from start node to the goal node\nwould use data that",
    "start": "4206580",
    "end": "4212720"
  },
  {
    "text": "already exists from the\nother nodes to the goal node. We already have that. But if introducing an\nobstacle would cause changes",
    "start": "4212720",
    "end": "4218449"
  },
  {
    "text": "throughout the\nentire graph, then we can potentially\ncreate what would have to be a very well-connected\ngraph, where again,",
    "start": "4218450",
    "end": "4226170"
  },
  {
    "text": "incremental path planning\nwould probably perform worse in that case. AUDIENCE: Yeah. So you could still end up in\nthe same situation [INAUDIBLE]..",
    "start": "4226170",
    "end": "4232255"
  },
  {
    "text": " ERLEND HARBITZ: Now\nthese algorithms are interesting, because they\nallow for some extensions that",
    "start": "4232255",
    "end": "4240050"
  },
  {
    "text": "allow us to do some some very\ndifferent things quite easily.",
    "start": "4240050",
    "end": "4245849"
  },
  {
    "text": "One example is greedy\nmapping, in terms of how can we design\nalgorithm using",
    "start": "4245850",
    "end": "4251960"
  },
  {
    "text": "what we know about\nincremental path planning, to hit every single\nnode on our graph.",
    "start": "4251960",
    "end": "4257810"
  },
  {
    "text": "And what we do is then we\nintroduce a faux goal node, essentially a node that doesn't\nexist that we can never reach.",
    "start": "4257810",
    "end": "4266610"
  },
  {
    "text": "And we add to our\ninitial beliefs,",
    "start": "4266610",
    "end": "4272570"
  },
  {
    "text": "our initial understanding\nof the graph connections between all\nnodes to this faux goal node.",
    "start": "4272570",
    "end": "4278670"
  },
  {
    "text": "Now, it's false in the sense\nthat whenever we move our start node to one of the nodes\nthat we've examined before,",
    "start": "4278670",
    "end": "4285530"
  },
  {
    "text": "what happens in terms of\nthe changes of the edge costs is removing that edge that\nconnected that node to the goal",
    "start": "4285530",
    "end": "4293415"
  },
  {
    "text": "node. So what this means\nin principle is that our vehicle,\nour poor vehicle,",
    "start": "4293415",
    "end": "4298469"
  },
  {
    "text": "can never reach the goal node. Whenever it reaches\na node that it thinks it can get to\nthe goal node from,",
    "start": "4298470",
    "end": "4304700"
  },
  {
    "text": "that path disappears. But what that causes it to\ndo is when it's replanning, it finds a path to a node that\nwe haven't visited before,",
    "start": "4304700",
    "end": "4313460"
  },
  {
    "text": "because it thinks there is a\npath that leads from that node to the goal node. And so this means\nthat it's efficient,",
    "start": "4313460",
    "end": "4319025"
  },
  {
    "text": "but replanning a root from his\ncurrent understanding to a node that it hasn't examined before.",
    "start": "4319025",
    "end": "4324990"
  },
  {
    "text": "And so it can apply something\nlike the D* Lite or LPA* with this formalism in order to\nsearch through the graph in its",
    "start": "4324990",
    "end": "4334430"
  },
  {
    "text": "entirety and make sure that in\na greedily efficient manner, we hit every single\nnode in the graph.",
    "start": "4334430",
    "end": "4343590"
  },
  {
    "text": "AUDIENCE: Is this\n[INAUDIBLE] TSP problem, or the traveling\nsolutions problem?",
    "start": "4343590",
    "end": "4349300"
  },
  {
    "text": "ERLEND HARBITZ: I'm not very\nfamiliar with the TSP problem. AUDIENCE: You try to--",
    "start": "4349300",
    "end": "4354320"
  },
  {
    "text": "and you try to cover\nall the Cs, and try to come up with a route\nthat is the most efficient,",
    "start": "4354320",
    "end": "4359980"
  },
  {
    "text": "and try to visit every\nknown C value once. ERLEND HARBITZ: OK. Then in that case, yes.",
    "start": "4359980",
    "end": "4365388"
  },
  {
    "text": "It's not going to be\nglobally efficient. As you said, it's going to\nbe an approximation for it.",
    "start": "4365388",
    "end": "4370909"
  },
  {
    "text": "In a sense, from each\nnode that you visited, you're searching for\nthe next best choice.",
    "start": "4370910",
    "end": "4376030"
  },
  {
    "text": "So it's possible you\ncan corner yourself. But it's a way that we use\nwhat we already implemented",
    "start": "4376030",
    "end": "4381884"
  },
  {
    "text": "and the methods\nthat we've already established to tackle a\ndifferent type of problem. AUDIENCE: And all this\n[INAUDIBLE] usually if",
    "start": "4381884",
    "end": "4388960"
  },
  {
    "text": "you have a strategy which is\nvisit the closest unvisited node, instead of making\nthis whole incremental path",
    "start": "4388960",
    "end": "4395810"
  },
  {
    "text": "from this study. If your policy is, always move\nto the closest unvisited node,",
    "start": "4395810",
    "end": "4401000"
  },
  {
    "text": "how worse does that\nget compared to this? ",
    "start": "4401000",
    "end": "4408850"
  },
  {
    "text": "ERLEND HARBITZ: I think it\nwould behave quite similarly. What we're just\ntrying to show here is that we can implement\nthat problem as an extension",
    "start": "4408850",
    "end": "4416560"
  },
  {
    "text": "if this happened. It may be an efficient\nway to do it. AUDIENCE: [INAUDIBLE]\nprobably like, zigzag.",
    "start": "4416560",
    "end": "4423960"
  },
  {
    "text": "ERLEND HARBITZ:\nAlso, if you're just going to the nearest\nconnected node,",
    "start": "4423960",
    "end": "4431060"
  },
  {
    "text": "if you corner yourself\nas we showed here, then you could potentially\nrun into issues",
    "start": "4431060",
    "end": "4437199"
  },
  {
    "text": "if your algorithm doesn't then\ndo an extended search for it. If it only considers nodes\nin its immediate neighborhood",
    "start": "4437200",
    "end": "4443080"
  },
  {
    "text": "that hasn't visited,\nonce it corners itself and doesn't know where to go. AUDIENCE: Just keep\ngoing through the graph",
    "start": "4443080",
    "end": "4449000"
  },
  {
    "text": "until you hit the\nnext inhibited node, assuming that you know how many\ninvocations you have to do.",
    "start": "4449000",
    "end": "4455400"
  },
  {
    "text": "AUDIENCE: Sort of like the\nrandom walk type approach? AUDIENCE: Well, I mean, kind of\nlike the greedy version of it.",
    "start": "4455400",
    "end": "4460683"
  },
  {
    "text": "You kind of start\nfrom a node, and then you keep searching,\nyou'll see, what is the next unvisited\nnode, and you pick that.",
    "start": "4460683",
    "end": "4467690"
  },
  {
    "text": "Kind of like-- [INAUDIBLE] some you see\nwhat you have covered. You see what's the\nnext best move.",
    "start": "4467690",
    "end": "4473960"
  },
  {
    "text": "You make that move. And you're done. ",
    "start": "4473960",
    "end": "4479950"
  },
  {
    "text": "[INAUDIBLE] So you probably\ndon't have this [INAUDIBLE]..",
    "start": "4479950",
    "end": "4490230"
  },
  {
    "start": "4490230",
    "end": "4497587"
  },
  {
    "text": "ERLEND HARBITZ: This\nbasically ensures you're going to find\nthe shortest path back to the next unvisited\nnode, I guess.",
    "start": "4497587",
    "end": "4502603"
  },
  {
    "start": "4502603",
    "end": "4508990"
  },
  {
    "text": "We also can use these\nincremental path planning algorithms\nfor anytime planners.",
    "start": "4508990",
    "end": "4514540"
  },
  {
    "text": "And the benefit of\nan anytime planner is that we quickly reach a\nplan which is suboptimal.",
    "start": "4514540",
    "end": "4522730"
  },
  {
    "text": "And then from there, we\nare repairing this plan to approach optimality.",
    "start": "4522730",
    "end": "4528480"
  },
  {
    "text": "And this is useful\nin the real world where you want to get a\nsolution that comes out quickly,",
    "start": "4528480",
    "end": "4534100"
  },
  {
    "text": "and we want to start\nalong our solution, and then repair it as we go. And once we start it, we\nneed o save some more time",
    "start": "4534100",
    "end": "4541390"
  },
  {
    "text": "if your reparations might lead\nto small changes and that type of thing. And this can be handled\nquite efficiently",
    "start": "4541390",
    "end": "4547630"
  },
  {
    "text": "using an incremental\npath planning. So what happens is we apply\nsomething, idea, called",
    "start": "4547630",
    "end": "4556500"
  },
  {
    "text": "inflated heuristics. And so these inflated\nheuristics are essentially increasing our\nheuristic values that",
    "start": "4556500",
    "end": "4562600"
  },
  {
    "text": "exist on our graph,\nin our true graph, by a cost of scale factor. And this is\ntypically very large,",
    "start": "4562600",
    "end": "4568570"
  },
  {
    "text": "so differences in heuristics\nbecome very large. This means that once\nwe start along a path,",
    "start": "4568570",
    "end": "4577630"
  },
  {
    "text": "we continue along it. And that causes us to very\nquickly find the first path",
    "start": "4577630",
    "end": "4583690"
  },
  {
    "text": "that actually works. Then, we can view reducing\nthose heuristics back",
    "start": "4583690",
    "end": "4588869"
  },
  {
    "text": "to their original values as\nessentially a form of changing",
    "start": "4588870",
    "end": "4594460"
  },
  {
    "text": "our [INAUDIBLE] causes or-- so it's a form of replanning.",
    "start": "4594460",
    "end": "4599920"
  },
  {
    "text": "And then by applying\nthe principles of an incremental planner, we\ncan efficiently use the data that we already have in\norder to perform the search",
    "start": "4599920",
    "end": "4609090"
  },
  {
    "text": "and repair our\nsolution as we go. Finally, we want to\nmake explicit to you",
    "start": "4609090",
    "end": "4616240"
  },
  {
    "text": "guys how we can actually\napply these algorithms to mobile robotics.",
    "start": "4616240",
    "end": "4622930"
  },
  {
    "text": "Because it may not\nimmediately clear how we go from a full\nspace to a graph.",
    "start": "4622930",
    "end": "4629679"
  },
  {
    "text": "Joe on this kind of briefly\nwhen he talked about we discretize the world. But we want to give you\nguys some ideas of how",
    "start": "4629680",
    "end": "4635800"
  },
  {
    "text": "we might do this cleverly. So in order to build a graph\nsystem out of our world state,",
    "start": "4635800",
    "end": "4644050"
  },
  {
    "text": "we differentiate between\nholonomic systems and nonholonomic systems,\nwhich their difference is just",
    "start": "4644050",
    "end": "4649630"
  },
  {
    "text": "in terms of whether your\nconstraints are differential in nature or not.",
    "start": "4649630",
    "end": "4655412"
  },
  {
    "text": "Then we are going to\noutline three methods here very briefly, cell\ndecomposition, using a visibility graph, and\nsampling-based construction",
    "start": "4655412",
    "end": "4662500"
  },
  {
    "text": "methods. So for cell\ndecomposition methods, we might to do what you would\nexpect, take the free space",
    "start": "4662500",
    "end": "4671350"
  },
  {
    "text": "in this region and split it up\ninto various different cells. And each of those cells\nis going to represent",
    "start": "4671350",
    "end": "4676530"
  },
  {
    "text": "a node in our graph. And how we can do this\nis we split the region up",
    "start": "4676530",
    "end": "4682630"
  },
  {
    "text": "based on each of the\nvertices of obstacles. So we draw a line vertically\nfrom each of our vertices",
    "start": "4682630",
    "end": "4693940"
  },
  {
    "text": "that goes in the direction\naway from the obstacle. So at the top here, it's going\nup and out of the obstacle.",
    "start": "4693940",
    "end": "4700560"
  },
  {
    "text": "But in the lower left corner\nthere, both up and down, don't intercept the obstacles.",
    "start": "4700560",
    "end": "4706600"
  },
  {
    "text": "We draw them in its entirely. So we can continue this\nthroughout the entirety of the state space,\nand then we can",
    "start": "4706600",
    "end": "4712420"
  },
  {
    "text": "attribute to each\nessential cell that we've defined through these regions,\na single point that represents",
    "start": "4712420",
    "end": "4718920"
  },
  {
    "text": "the midpoint of that cell,\nwhich is going to be our graph",
    "start": "4718920",
    "end": "4724090"
  },
  {
    "text": "node, because we attribute\na single set of coordinates to each of our graph nodes.",
    "start": "4724090",
    "end": "4730369"
  },
  {
    "text": "And we also, to make\nsure that our transitions between these cells\nare consistent,",
    "start": "4730370",
    "end": "4735790"
  },
  {
    "text": "additional nodes at the\nmidpoint of each of these lines that we've drawn, where we make\nthe distinction that from here,",
    "start": "4735790",
    "end": "4743110"
  },
  {
    "text": "we've actually drawn two lines. So we draw the midpoint\nbetween all of those. This allows us to\nessentially create a graph",
    "start": "4743110",
    "end": "4749575"
  },
  {
    "text": "through the entire system,\nand we connect each node",
    "start": "4749575",
    "end": "4755230"
  },
  {
    "text": "at the center of any\ngiven cell to nodes that are on the boundary\nof any given cell.",
    "start": "4755230",
    "end": "4761530"
  },
  {
    "text": "This allows us to create a\nfull graph through the system, that we can move\nthrough, guaranteeing",
    "start": "4761530",
    "end": "4766810"
  },
  {
    "text": "that none of these paths,\nif we follow them exactly collide with the obstacles.",
    "start": "4766810",
    "end": "4773439"
  },
  {
    "text": "Now, this works in environments\nwhere the obstacles are 2D polygons, and the path is\nfar from optimal, as we can see,",
    "start": "4773439",
    "end": "4779460"
  },
  {
    "text": "but we can plan an optimal\npath over the graph that we have defined.",
    "start": "4779460",
    "end": "4784810"
  },
  {
    "text": "And this only works\non holonomic systems. We can also define what\nis called a visibility",
    "start": "4784810",
    "end": "4790675"
  },
  {
    "text": "graph, where we essentially\ndraw a boundary between both our vehicle down there\nat that bottom left,",
    "start": "4790675",
    "end": "4796210"
  },
  {
    "text": "and boundaries\naround our obstacles. These boundaries are\nsufficiently sized so that if the center of the\nvehicle that we're defining",
    "start": "4796210",
    "end": "4806500"
  },
  {
    "text": "is along the extended\nedge of the obstacle, that the vehicle will not\ncollide with that obstacle.",
    "start": "4806500",
    "end": "4815090"
  },
  {
    "text": "Then for each of the vertices\nof the extended boundary that we've defined,\nwe add in a new node,",
    "start": "4815090",
    "end": "4823780"
  },
  {
    "text": "and we draw all lines\nbetween all nodes, which can be connected\nwithout intersecting",
    "start": "4823780",
    "end": "4829829"
  },
  {
    "text": "the extended obstacles,\nwhich we've drawn here. And this leads to a graph\nthat we can, again, plan over.",
    "start": "4829830",
    "end": "4839710"
  },
  {
    "text": "This, again, works\nin environments where the obstacles are 2D polygons. But what's nice\nabout this system is",
    "start": "4839710",
    "end": "4844930"
  },
  {
    "text": "that we do get an\noptimal path, provided that we assume that we\nassume that our extension",
    "start": "4844930",
    "end": "4850220"
  },
  {
    "text": "of the robot itself is valid,\nor doesn't act too much--",
    "start": "4850220",
    "end": "4856735"
  },
  {
    "text": " isn't too excessive\nfor constraint.",
    "start": "4856735",
    "end": "4863559"
  },
  {
    "text": "Finally, going back to some\nof the random sampling methods that we mentioned at the very\nbeginning of this lecture,",
    "start": "4863560",
    "end": "4870830"
  },
  {
    "text": "we've introduced sampling-based\nroadmap construction, wherein we choose nodes randomly\nor deterministically",
    "start": "4870830",
    "end": "4878440"
  },
  {
    "text": "throughout our environment. The difference here,\nthough, is that we then create a graph out\nof this system,",
    "start": "4878440",
    "end": "4883850"
  },
  {
    "text": "and that we reason over\nthat graph using something like an incremental\nplanning algorithm.",
    "start": "4883850",
    "end": "4889921"
  },
  {
    "text": "And so when we create that\ngraph, after we've sampled, we can use the [INAUDIBLE]\nneighbors of each node,",
    "start": "4889921",
    "end": "4897160"
  },
  {
    "text": "or we can connect each\nnode to every node within a certain radius, which\nis what we've drawn here.",
    "start": "4897160",
    "end": "4906650"
  },
  {
    "text": "Finally, in order to\nactually move between nodes, we need to have some\nknowledge about the dynamics",
    "start": "4906650",
    "end": "4914060"
  },
  {
    "text": "of the vehicle, which is\nwhat we're discussing here. And one method that we can do\nthis for nonholonomic systems",
    "start": "4914060",
    "end": "4920660"
  },
  {
    "text": "is we can distinguish\nbetween different paths that",
    "start": "4920660",
    "end": "4925750"
  },
  {
    "text": "use turning right, turning\nleft, and traveling in straight lines. It turns out that the shortest\npath between two points",
    "start": "4925750",
    "end": "4931719"
  },
  {
    "text": "can be defined using\none of these systems. And so we just have to search\nover a finite number of options",
    "start": "4931720",
    "end": "4939510"
  },
  {
    "text": "in order to find the best path\nthat can connect any two nodes. ",
    "start": "4939510",
    "end": "4946720"
  },
  {
    "text": "Hopefully, that has\ngiven you some intuition into how we can apply these\nincremental path planning",
    "start": "4946720",
    "end": "4954490"
  },
  {
    "text": "[INAUDIBLE] systems. Are there any questions?",
    "start": "4954490",
    "end": "4959810"
  },
  {
    "text": "[APPLAUSE] ",
    "start": "4959810",
    "end": "4965888"
  }
]