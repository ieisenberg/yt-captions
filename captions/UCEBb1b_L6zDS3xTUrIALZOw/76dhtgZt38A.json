[
  {
    "text": "all right let's get started welcome back to double06 today we are doing some of the coolest data",
    "start": "12880",
    "end": "18560"
  },
  {
    "text": "structures we will see in this class maybe some of the coolest data structures ever binary trees",
    "start": "18560",
    "end": "24400"
  },
  {
    "text": "uh you've certainly seen trees in many forms uh in the past including in this class",
    "start": "24400",
    "end": "30480"
  },
  {
    "text": "we've talked to use trees as a lower bound tool for uh in the decision tree model",
    "start": "30480",
    "end": "36320"
  },
  {
    "text": "but this lecture and the next lecture we're going to build one data structure that is almost",
    "start": "36320",
    "end": "42719"
  },
  {
    "text": "superior to all data structures we have seen and can do almost anything",
    "start": "42719",
    "end": "48000"
  },
  {
    "text": "really fast first recall all the data structures we've seen so far arrays",
    "start": "48000",
    "end": "53120"
  },
  {
    "text": "linked lists dynamic arrays sorted arrays hash tables and the two sets of operations we're",
    "start": "53120",
    "end": "60079"
  },
  {
    "text": "interested in supporting the two interfaces one was sequences where we're maintaining items in a specified order we want to be able to",
    "start": "60079",
    "end": "66400"
  },
  {
    "text": "insert an item right after another item or delete an item in the middle of the list and always be able to access the ith",
    "start": "66400",
    "end": "72000"
  },
  {
    "text": "item we haven't seen any good data structures for that problem we we're really good at",
    "start": "72000",
    "end": "77600"
  },
  {
    "text": "inserting and deleting at the beginning or the end of the sequence but we haven't seen anything",
    "start": "77600",
    "end": "82640"
  },
  {
    "text": "that's efficient at ins inserting in the middle of the list or deleting in the middle of the list linked list",
    "start": "82640",
    "end": "88240"
  },
  {
    "text": "you can't even get to the middle in less than linear time uh array you can get to the middle but",
    "start": "88240",
    "end": "93360"
  },
  {
    "text": "if you make any changes you have to do this shift which is very expensive so today or sorry next lecture for the",
    "start": "93360",
    "end": "100240"
  },
  {
    "text": "first time we will see all of those operations efficient",
    "start": "100240",
    "end": "106320"
  },
  {
    "text": "i'll mention our goal where efficient means",
    "start": "106640",
    "end": "111680"
  },
  {
    "text": "logarithmic so we're not quite as good as linked lists and dynamic arrays at",
    "start": "111680",
    "end": "117759"
  },
  {
    "text": "inserting and deleting at the ends those there that we achieve constant or constant amortized",
    "start": "117759",
    "end": "122960"
  },
  {
    "text": "time but up to this log factor we're going to get the best of all worlds where we can solve",
    "start": "122960",
    "end": "128000"
  },
  {
    "text": "all the things all the operations that don't build or iterate through the entire structure that of course takes linear",
    "start": "128000",
    "end": "134480"
  },
  {
    "text": "time but we can do all the others in logarithmic time for sets sets were maintained maintaining a bunch",
    "start": "134480",
    "end": "140800"
  },
  {
    "text": "of items which have intrinsic keys and we want to search by key so hash tables are great",
    "start": "140800",
    "end": "148319"
  },
  {
    "text": "if you're only doing exact searches if you want to find a key and get yes or no is it in there and if",
    "start": "148319",
    "end": "153760"
  },
  {
    "text": "it's in there give me the item that's what python dictionaries do and",
    "start": "153760",
    "end": "159120"
  },
  {
    "text": "they're great at inserting and deleting but they're really bad at find previous and find next this is a",
    "start": "159120",
    "end": "166319"
  },
  {
    "text": "the unsuccessful case if i search for a key and it's not in my structure i would like to know more than just the",
    "start": "166319",
    "end": "172640"
  },
  {
    "text": "answer no i'd like to know what the previous and next items that are actually in the structure",
    "start": "172640",
    "end": "178480"
  },
  {
    "text": "so what are my nearest matches when i search by key that's a natural query and the only data structure we have",
    "start": "178480",
    "end": "185200"
  },
  {
    "text": "that's good at it is a sorted array because binary search gives this to us if we search for a key by binary search",
    "start": "185200",
    "end": "191599"
  },
  {
    "text": "and we don't find it the position that we end up at is right between the previous and next one",
    "start": "191599",
    "end": "197680"
  },
  {
    "text": "but of course sorted arrays are terrible for dynamic operations we don't know how to maintain",
    "start": "197680",
    "end": "203760"
  },
  {
    "text": "we can't maintain a sorted array without any gaps when we're doing insertions and deletions in some sense today",
    "start": "203760",
    "end": "210000"
  },
  {
    "text": "and next class binary trees let us represent a sorted order or in general an order of",
    "start": "210000",
    "end": "215519"
  },
  {
    "text": "items dynamically and still allow us to do very fast things like get out of i and",
    "start": "215519",
    "end": "222319"
  },
  {
    "text": "find previous of the key so that's our goal we're not going to quite get to this goal today",
    "start": "222319",
    "end": "227680"
  },
  {
    "text": "we're going to get an incomparable thing called the height of the tree and then",
    "start": "227680",
    "end": "234159"
  },
  {
    "text": "on thursday we'll be able to finish and achieve this goal today is just in service to that goal",
    "start": "234159",
    "end": "241840"
  },
  {
    "text": "so what is a binary tree let me draw an example",
    "start": "242239",
    "end": "249439"
  },
  {
    "text": "and then define it more precisely mathematicians will call this a rooted binary tree",
    "start": "249439",
    "end": "255200"
  },
  {
    "text": "because in case you've seen that in o42 say here is a picture",
    "start": "255200",
    "end": "269840"
  },
  {
    "text": "so this is an example of a binary tree it has a bunch of nodes which we're drawing in circles it has",
    "start": "276320",
    "end": "281680"
  },
  {
    "text": "items in the nodes which were i'm writing as letters here so this is item a item b item c and it",
    "start": "281680",
    "end": "288320"
  },
  {
    "text": "has these links between them this is like linked lists but in general a node",
    "start": "288320",
    "end": "296000"
  },
  {
    "text": "x is going to have a parent pointer",
    "start": "296000",
    "end": "301040"
  },
  {
    "text": "a left child left pointer and a right child",
    "start": "301520",
    "end": "307759"
  },
  {
    "text": "right pointer and it also has an item inside of it so i'm going to",
    "start": "307759",
    "end": "314479"
  },
  {
    "text": "talk about node.left is a pointer to the left the node down here node.right",
    "start": "314479",
    "end": "321520"
  },
  {
    "text": "node.parent node.item gives me so if i",
    "start": "321520",
    "end": "326720"
  },
  {
    "text": "look at the node a its item is a so let me draw for you",
    "start": "326720",
    "end": "335360"
  },
  {
    "text": "some examples",
    "start": "337120",
    "end": "353759"
  },
  {
    "text": "okay the parent of a is nothing so we call a the root node there's going to be a unique node that has no parent",
    "start": "353759",
    "end": "361360"
  },
  {
    "text": "it's uh sad to have no parents but there you go then we have node b which whose parent",
    "start": "361360",
    "end": "367600"
  },
  {
    "text": "is a node c is parent its apparent is a node d its parent is b",
    "start": "367600",
    "end": "372800"
  },
  {
    "text": "node e its parent is b and node f its parent is d",
    "start": "372800",
    "end": "378160"
  },
  {
    "text": "alphabetical order here happens to be ordered by parent then we have left pointers i'll just do",
    "start": "378160",
    "end": "384720"
  },
  {
    "text": "a few of them so left pointer of a is b right pointer of a",
    "start": "384720",
    "end": "390639"
  },
  {
    "text": "sorry b the node uh these should all be notes",
    "start": "390639",
    "end": "395600"
  },
  {
    "text": "i'm circling for nodes and just writing the letter for the item make it clear that those are different things uh the right pointer for a",
    "start": "396880",
    "end": "403840"
  },
  {
    "text": "is c left pointer for b is d right pointer for b is e and so on",
    "start": "403840",
    "end": "411039"
  },
  {
    "text": "okay so in other words each of these lines is a bi-directional pointer uh in this direction it's the parent",
    "start": "411039",
    "end": "416720"
  },
  {
    "text": "direction in this direction it's left in this case because it's bidirectional we don't draw the arrows we just draw",
    "start": "416720",
    "end": "424319"
  },
  {
    "text": "undirected lines okay this is in general what a binary tree looks like",
    "start": "424319",
    "end": "431280"
  },
  {
    "text": "a key invariant is that if you take a node and say go to its left pointer left",
    "start": "431280",
    "end": "438080"
  },
  {
    "text": "child and then go to that node's parent this should be the same as node right so",
    "start": "438080",
    "end": "445440"
  },
  {
    "text": "that's just saying these are in parent is always the inverse of a left or right operation",
    "start": "445440",
    "end": "450479"
  },
  {
    "text": "this is also true for write okay and that's a binary tree now the",
    "start": "450479",
    "end": "456639"
  },
  {
    "text": "intuition of what's going on here is you could you could say it's we're inspired by",
    "start": "456639",
    "end": "461680"
  },
  {
    "text": "a linked list linked list had a very similar structure",
    "start": "461680",
    "end": "467440"
  },
  {
    "text": "maybe an item or there's a node it had an item in it and it had a next pointer and it had a",
    "start": "467440",
    "end": "474319"
  },
  {
    "text": "previous pointer so in some sense what we're if it's doubly linked we had a previous pointer",
    "start": "474319",
    "end": "479680"
  },
  {
    "text": "it was singly linked we only had a next pointer and if you think about the limits of",
    "start": "479680",
    "end": "485520"
  },
  {
    "text": "linked lists especially singly linked lists if you just have one pointer per node you can only build a list",
    "start": "485520",
    "end": "492160"
  },
  {
    "text": "and so the result is uh you know this this node is going to have",
    "start": "492160",
    "end": "500319"
  },
  {
    "text": "depth linear depth means how many pointers do i have to follow to get here",
    "start": "500319",
    "end": "505840"
  },
  {
    "text": "from the root of the structure which for linked lists was the head it was doubly linked okay i can have a",
    "start": "505840",
    "end": "511039"
  },
  {
    "text": "head and a tail and i can put bi-directions on here but then still the middle item has depth linear so there's no way to",
    "start": "511039",
    "end": "517599"
  },
  {
    "text": "get there in less than linear time with binary trees because we use two types of next pointers left and",
    "start": "517599",
    "end": "524399"
  },
  {
    "text": "right we can build a tree and we know trees in general have logarithmic can have logarithmic height",
    "start": "524399",
    "end": "532080"
  },
  {
    "text": "and so it's possible in a tree to get to any node starting from the root in only",
    "start": "532080",
    "end": "537760"
  },
  {
    "text": "log n traversals so that's the intuition of what's going on now today",
    "start": "537760",
    "end": "543680"
  },
  {
    "text": "we're going to talk about the height of a tree so let me define",
    "start": "544800",
    "end": "551120"
  },
  {
    "text": "i'm going to need a couple definitions here",
    "start": "552560",
    "end": "556240"
  },
  {
    "text": "subtree and height",
    "start": "558560",
    "end": "563839"
  },
  {
    "text": "of a node uh so a tree decomposes into sub trees",
    "start": "563839",
    "end": "570480"
  },
  {
    "text": "so for example the subtree rooted at b or the subtree of b is this portion of the tree",
    "start": "570480",
    "end": "580000"
  },
  {
    "text": "so it's that node and all of the descendants of this node so because we have parents and children",
    "start": "580320",
    "end": "586080"
  },
  {
    "text": "we can generalize in the familial tree sense we can talk about ancestors of a node so",
    "start": "586080",
    "end": "592000"
  },
  {
    "text": "the ancestors of f are its parent its grandparents its great grandparents and so on",
    "start": "592000",
    "end": "597279"
  },
  {
    "text": "together all of these are called ancestors it's a it doesn't quite correspond to",
    "start": "597279",
    "end": "602800"
  },
  {
    "text": "familiar trees because familial trees you have two parents here you only have a unique parent",
    "start": "602800",
    "end": "610000"
  },
  {
    "text": "or the poor root has no parent we also talk about it's like mixed",
    "start": "610000",
    "end": "615839"
  },
  {
    "text": "metaphors leaves of the tree these are",
    "start": "615839",
    "end": "622079"
  },
  {
    "text": "people with no children parents will complain about this but many like many of us in this room we",
    "start": "623519",
    "end": "631920"
  },
  {
    "text": "have no children yet so we were called leaves you can tell your parents hey i'm just a leaf you know blowing in the wind",
    "start": "631920",
    "end": "639440"
  },
  {
    "text": "so uh you know like this it's so many mixed metaphors but we always draw trees downwards like the",
    "start": "639440",
    "end": "646640"
  },
  {
    "text": "root structure of a tree yet we call the ends of the roots leaves which is upside down",
    "start": "646640",
    "end": "652640"
  },
  {
    "text": "anyway that's trees for you lots of entertaining analogies okay but ancestors are useful descendants are",
    "start": "652640",
    "end": "659440"
  },
  {
    "text": "also useful so the descendants of b are all of its children and all of its grandchildren and all the way down",
    "start": "659440",
    "end": "664800"
  },
  {
    "text": "but just within the subtree so subtree of x consists of x and its descendants",
    "start": "664800",
    "end": "675839"
  },
  {
    "text": "and we think of x being the root of that subtree so we're kind of",
    "start": "676880",
    "end": "682240"
  },
  {
    "text": "forgetting about everything outside of the sub tree when we talk about sub tree of x let's",
    "start": "682240",
    "end": "688399"
  },
  {
    "text": "talk about the depth of a node depth of the node is",
    "start": "688399",
    "end": "696399"
  },
  {
    "text": "i guess the number of its ancestors",
    "start": "696880",
    "end": "703440"
  },
  {
    "text": "right um but way i usually think of it is the number of number of edges",
    "start": "703440",
    "end": "712320"
  },
  {
    "text": "and in the path from x up to the root",
    "start": "712880",
    "end": "721760"
  },
  {
    "text": "so every node has a unique path that goes upwards until it can't go up anymore so the",
    "start": "722480",
    "end": "728880"
  },
  {
    "text": "depth of e is two because there are two edges uh one two in the path from the root a to e",
    "start": "728880",
    "end": "736399"
  },
  {
    "text": "so maybe i'll write some depths uh depth of e is two depth of these guys is one depth of the",
    "start": "736399",
    "end": "742560"
  },
  {
    "text": "root is zero two three so those are",
    "start": "742560",
    "end": "748399"
  },
  {
    "text": "depth i'm going to clean this up a little bit",
    "start": "748399",
    "end": "758880"
  },
  {
    "text": "so we can focus on the image all right height so depth is measuring downwards because we you know if you",
    "start": "758880",
    "end": "764800"
  },
  {
    "text": "imagine depth within water this is uh the surface of the water and then we measure how deep you are from",
    "start": "764800",
    "end": "771200"
  },
  {
    "text": "the surface height is in the reverse direction we're going to measure from the leaf level up because leaves are the bottom of the",
    "start": "771200",
    "end": "778079"
  },
  {
    "text": "tree so height of a node is going to be",
    "start": "778079",
    "end": "783440"
  },
  {
    "text": "the number of edges in the longest downward path",
    "start": "783440",
    "end": "791519"
  },
  {
    "text": "okay which is the same thing as the maximum depth of a node",
    "start": "799519",
    "end": "806000"
  },
  {
    "text": "in x's subtree",
    "start": "806000",
    "end": "809200"
  },
  {
    "text": "let's do height in red so uh how long is the longest path from",
    "start": "812800",
    "end": "819120"
  },
  {
    "text": "f to a leaf well f is a leaf so all leaves have depth zero sorry height zero",
    "start": "819120",
    "end": "825920"
  },
  {
    "text": "get it backwards um d here it's so there are two",
    "start": "825920",
    "end": "832399"
  },
  {
    "text": "ways to go down this doesn't go to a leaf uh this one goes to a leaf and its height is zero so this height is",
    "start": "832399",
    "end": "839600"
  },
  {
    "text": "one there's one edge to a leaf here b has two leaves it can get to we take the",
    "start": "839600",
    "end": "845199"
  },
  {
    "text": "longest one so that's length two a similarly has height three",
    "start": "845199",
    "end": "856240"
  },
  {
    "text": "okay so height we measure upward depth we measure downward well one thing we care about uh",
    "start": "856240",
    "end": "863360"
  },
  {
    "text": "is just the height of the overall tree uh which is the height of the root",
    "start": "863360",
    "end": "871839"
  },
  {
    "text": "and i'm going to call that h because we're going to use it a lot",
    "start": "872720",
    "end": "876880"
  },
  {
    "text": "and what we're going to achieve today is all of these running times instead of being log n they're going to be order h",
    "start": "879440",
    "end": "887760"
  },
  {
    "text": "so today our goal is to get all the operations we care about in order h type",
    "start": "888720",
    "end": "896320"
  },
  {
    "text": "and then next lecture we're going to guarantee that h is always log n and then we'll get log n time so we need",
    "start": "897040",
    "end": "904000"
  },
  {
    "text": "to do a bunch of work to achieve log n today we'll do the work that's all the tree manipulation and as long as your tree is nice and",
    "start": "904000",
    "end": "910480"
  },
  {
    "text": "shallow it doesn't have high height if it has logarithmic height everything will be log n of course there are trees",
    "start": "910480",
    "end": "916480"
  },
  {
    "text": "that are really bad right we can have a tree",
    "start": "916480",
    "end": "921199"
  },
  {
    "text": "a tree like this which is basically a linked list where we only use right pointers and all",
    "start": "924800",
    "end": "931120"
  },
  {
    "text": "the left pointers are none so there are height there are trees that are very high have high height um we want to avoid",
    "start": "931120",
    "end": "938639"
  },
  {
    "text": "these but we won't worry about that till next lecture question",
    "start": "938639",
    "end": "942959"
  },
  {
    "text": "what is the height of node c height of node c is zero because the length of the longest path the number of edges in the longest",
    "start": "945440",
    "end": "952000"
  },
  {
    "text": "downward path is zero yeah we're counting edges not vertices",
    "start": "952000",
    "end": "958079"
  },
  {
    "text": "uh yeah so the height of the tree is of course just the depth",
    "start": "958399",
    "end": "963600"
  },
  {
    "text": "the maximum depth i think that's right so the height here is three and the maximum depth is this",
    "start": "963600",
    "end": "969600"
  },
  {
    "text": "terribly drawn three so these happen to correspond in the maximum case but we use height to always mean maximum",
    "start": "969600",
    "end": "977279"
  },
  {
    "text": "and so that's why we talk about the height of the tree depth of the tree is not defined just depths of notes okay",
    "start": "977279",
    "end": "985920"
  },
  {
    "text": "um how do we use these trees to represent either a sequence or a set uh",
    "start": "985920",
    "end": "993279"
  },
  {
    "text": "i claim that there is a natural order in trees called the traversal order",
    "start": "993279",
    "end": "1000639"
  },
  {
    "text": "of nodes or items and the tree so i'm going to define a",
    "start": "1007839",
    "end": "1014399"
  },
  {
    "text": "particular order uh say in this example",
    "start": "1014399",
    "end": "1019680"
  },
  {
    "text": "let's do the example first the traversal order",
    "start": "1019680",
    "end": "1027199"
  },
  {
    "text": "is going to be f d b",
    "start": "1029839",
    "end": "1036798"
  },
  {
    "text": "e a c i feel like i'm in music class this is",
    "start": "1036839",
    "end": "1043360"
  },
  {
    "text": "my guitar or something but it's not i hope um if it is a coincidence so",
    "start": "1043360",
    "end": "1050640"
  },
  {
    "text": "what is this order what i'd like to do is um recursively define an order where the",
    "start": "1050640",
    "end": "1057440"
  },
  {
    "text": "root of the tree is somewhere in the middle and everything in the left subtree is left",
    "start": "1057440",
    "end": "1062960"
  },
  {
    "text": "earlier in the order than the root and everything in the right subtree is later so you can see here c comes after a and",
    "start": "1062960",
    "end": "1070160"
  },
  {
    "text": "then all the other nodes come before a and recursively if i look at a node b",
    "start": "1070160",
    "end": "1075919"
  },
  {
    "text": "this node b which appears over here e is to the right of it but it's this is all to the left of a so",
    "start": "1075919",
    "end": "1083120"
  },
  {
    "text": "e is between b and a would be on the left and then f and d are to the left of that",
    "start": "1083120",
    "end": "1088960"
  },
  {
    "text": "and again f comes before d because f is in the left subtree of d",
    "start": "1088960",
    "end": "1094640"
  },
  {
    "text": "okay so we say for every node",
    "start": "1094640",
    "end": "1101840"
  },
  {
    "text": "the nodes in x dot left are before x",
    "start": "1104400",
    "end": "1113520"
  },
  {
    "text": "and the nodes in x dot right are come after x",
    "start": "1114480",
    "end": "1123120"
  },
  {
    "text": "and this uniquely defines an order called a traversal order it's also called the in-order traversal order it's called in order because it's",
    "start": "1123120",
    "end": "1130480"
  },
  {
    "text": "in the traversal order so it's very circular but you may have seen inorder traversal this",
    "start": "1130480",
    "end": "1135760"
  },
  {
    "text": "is the same thing there's a very simple algorithm for computing this if i want to iterate",
    "start": "1135760",
    "end": "1144080"
  },
  {
    "text": "uh let's call this yeah if i want to iterate all the nodes within a subtree x rooted",
    "start": "1144080",
    "end": "1151600"
  },
  {
    "text": "by x i just iterate on all of the nodes in the left subtree then i output",
    "start": "1151600",
    "end": "1159919"
  },
  {
    "text": "x itself then i iterate on all the nodes in the",
    "start": "1159919",
    "end": "1165200"
  },
  {
    "text": "right subtree",
    "start": "1165200",
    "end": "1167840"
  },
  {
    "text": "okay you may have seen that algorithm before this is just another way to codify the same thing the result is all the nodes within a",
    "start": "1170720",
    "end": "1177520"
  },
  {
    "text": "subtree appear continuously with no interruptions and then the parent parent's going to",
    "start": "1177520",
    "end": "1183360"
  },
  {
    "text": "come before after depending on whether it's the left or right child",
    "start": "1183360",
    "end": "1188080"
  },
  {
    "text": "okay so and now it's just a matter of connecting the dots because we're representing an order",
    "start": "1188400",
    "end": "1194640"
  },
  {
    "text": "and for sequence that is going to be the sequence order if we want to store n items x0 through x1",
    "start": "1194640",
    "end": "1200160"
  },
  {
    "text": "we're going to build some kind of tree we're going to put x0 here x1 here x2 here x3 here x4 here x5",
    "start": "1200160",
    "end": "1207520"
  },
  {
    "text": "here you can see i'm very used to dealing with traversal orders it takes a little while uh you could also see it here we're",
    "start": "1207520",
    "end": "1212960"
  },
  {
    "text": "going to put x1 on this node x2 sorry x0 here x1 here x2 here and so on",
    "start": "1212960",
    "end": "1218320"
  },
  {
    "text": "that's the same order that i gave okay that's for sequences for sets that",
    "start": "1218320",
    "end": "1223600"
  },
  {
    "text": "order is just going to be the sorted order and we're going to be effectively representing the sorted order of keys",
    "start": "1223600",
    "end": "1229360"
  },
  {
    "text": "say increasing but before we get to that let's talk about different operations we",
    "start": "1229360",
    "end": "1236480"
  },
  {
    "text": "can do just playing around with traversal order",
    "start": "1236480",
    "end": "1243600"
  },
  {
    "text": "and then we're going to use these to build the sequence and set operations that we care about",
    "start": "1243840",
    "end": "1249520"
  },
  {
    "text": "so first operation i'll call subtree first seems appropriate that",
    "start": "1249520",
    "end": "1255440"
  },
  {
    "text": "it's called first it's the first one so given a node",
    "start": "1255440",
    "end": "1262640"
  },
  {
    "text": "which i'll call node uh this defines a subtree",
    "start": "1262640",
    "end": "1268880"
  },
  {
    "text": "which usually we draw subtrees as triangles hanging off of the node",
    "start": "1270080",
    "end": "1276240"
  },
  {
    "text": "so here i would write x and then there's some subtree of all the descendants of x",
    "start": "1276240",
    "end": "1283120"
  },
  {
    "text": "so with subtree first i would like to say among all the nodes in this subtree",
    "start": "1283120",
    "end": "1291840"
  },
  {
    "text": "which comes first in traversal order",
    "start": "1294240",
    "end": "1298799"
  },
  {
    "text": "so just restricting to that subtree so tree of that",
    "start": "1303120",
    "end": "1311279"
  },
  {
    "text": "so where is it in this tree",
    "start": "1315039",
    "end": "1319840"
  },
  {
    "text": "uh note is actually part of many sub trees good question uh f f is in its own in the sub tree of f",
    "start": "1323840",
    "end": "1330000"
  },
  {
    "text": "uh f is also in the subtree of d f is in the sub tree of b like i drew f is in the subtree of a it's in the",
    "start": "1330000",
    "end": "1335840"
  },
  {
    "text": "subtree of exactly its ancestors but in this operation when we define",
    "start": "1335840",
    "end": "1343120"
  },
  {
    "text": "node our node only defines one sub-tree it is the root of only one sub-tree and that's the sub-tree we're talking",
    "start": "1343120",
    "end": "1349360"
  },
  {
    "text": "about and then i want to know among all those nodes which includes node itself",
    "start": "1349360",
    "end": "1354559"
  },
  {
    "text": "and other things uh which one comes first in this traversal order this is like practice with traversal orders",
    "start": "1354559",
    "end": "1362400"
  },
  {
    "text": "so where should i look for this node",
    "start": "1362400",
    "end": "1365760"
  },
  {
    "text": "yeah the leftmost leaf in the picture it's here but pictures",
    "start": "1369200",
    "end": "1374960"
  },
  {
    "text": "can be deceiving we just want to go left",
    "start": "1374960",
    "end": "1380240"
  },
  {
    "text": "as much as possible when i say go left i mean this iteration node equals",
    "start": "1380240",
    "end": "1386480"
  },
  {
    "text": "node.left you just look at our definition all the nodes on the left come before x",
    "start": "1386840",
    "end": "1393280"
  },
  {
    "text": "and all the nodes in the right so it's got to be in the left subtree if there is one uh",
    "start": "1393280",
    "end": "1398559"
  },
  {
    "text": "of course we can't do this forever so say until we would fall off the tree",
    "start": "1398559",
    "end": "1406640"
  },
  {
    "text": "which means uh node is none",
    "start": "1408159",
    "end": "1413840"
  },
  {
    "text": "okay but we stopped uh before that would happen so this is like uh the directions like",
    "start": "1414720",
    "end": "1421600"
  },
  {
    "text": "oh you keep driving until you see the store and it's the block right before that it's like well that's not very helpful",
    "start": "1421600",
    "end": "1427679"
  },
  {
    "text": "so uh you keep iterating node equals no dot left until node becomes none and then you undo one step okay you",
    "start": "1427679",
    "end": "1433840"
  },
  {
    "text": "all know how to program that it's not hard um so that last non-none",
    "start": "1433840",
    "end": "1438960"
  },
  {
    "text": "node which might actually be the root it might be node maybe it has no left children but in",
    "start": "1438960",
    "end": "1444880"
  },
  {
    "text": "that case i claim node is the very first in its in its subtree traversal order because if there are no nodes in the left that",
    "start": "1444880",
    "end": "1451919"
  },
  {
    "text": "come before x then x is actually first okay and that so that's it uh return",
    "start": "1451919",
    "end": "1458400"
  },
  {
    "text": "node so i'm modifying node in place here and",
    "start": "1458400",
    "end": "1464640"
  },
  {
    "text": "the very last one before i hit none that's the minimum that's the first item in the traversal",
    "start": "1464640",
    "end": "1469679"
  },
  {
    "text": "order similarly you can define subtree last okay let's do a more interesting one",
    "start": "1469679",
    "end": "1475360"
  },
  {
    "text": "successor",
    "start": "1475360",
    "end": "1478000"
  },
  {
    "text": "node so in this case i want to know what is the next",
    "start": "1481360",
    "end": "1488158"
  },
  {
    "text": "after node in the overall tree's traversal order okay here",
    "start": "1490000",
    "end": "1496960"
  },
  {
    "text": "i was restricting to uh a single sub tree now i'm thinking about the entire tree in the entire",
    "start": "1496960",
    "end": "1503520"
  },
  {
    "text": "traversal order and given a node i want to know which one comes next call this the successor i feel like i",
    "start": "1503520",
    "end": "1511360"
  },
  {
    "text": "should make some kind of royal family joke now but i don't know how um so",
    "start": "1511360",
    "end": "1518640"
  },
  {
    "text": "every node has a unique successor let's do let's do some examples so we can start with f the successor of",
    "start": "1518640",
    "end": "1526080"
  },
  {
    "text": "f if we just index into this list the successor is d okay",
    "start": "1526080",
    "end": "1531120"
  },
  {
    "text": "successor of d is b successor b is ease okay it's very easy to read successors off",
    "start": "1531120",
    "end": "1536159"
  },
  {
    "text": "when i have the traversal order written down but let's think about how to do it in the tree",
    "start": "1536159",
    "end": "1541440"
  },
  {
    "text": "okay uh let's see there are going to be two",
    "start": "1541440",
    "end": "1546559"
  },
  {
    "text": "cases if i look at the successor of a it has a",
    "start": "1546559",
    "end": "1552159"
  },
  {
    "text": "right child and in this case the right child of a is the successor but that's not always the",
    "start": "1552159",
    "end": "1557919"
  },
  {
    "text": "case i don't have a good example but if i had another node here let's call it",
    "start": "1557919",
    "end": "1564080"
  },
  {
    "text": "g uh the successor of a is actually g right because",
    "start": "1564080",
    "end": "1571360"
  },
  {
    "text": "all of these items come after a in the order but which one comes first the leftmost",
    "start": "1571360",
    "end": "1577200"
  },
  {
    "text": "leaf okay that's the problem we just solved so if a has a right child",
    "start": "1577200",
    "end": "1582640"
  },
  {
    "text": "what we want is the leftmost leaf the first thing in that subtree",
    "start": "1582640",
    "end": "1589919"
  },
  {
    "text": "the right subtree right child sub tree so this is case one if uh node.right",
    "start": "1590000",
    "end": "1597760"
  },
  {
    "text": "so if we have a right child then what we want is",
    "start": "1597760",
    "end": "1604559"
  },
  {
    "text": "subtree first of the right child",
    "start": "1604640",
    "end": "1613840"
  },
  {
    "text": "great we can reduce to this other operation but what if the node doesn't have a",
    "start": "1614799",
    "end": "1621679"
  },
  {
    "text": "right child so for example it could be a leaf say we're taking the successor of i mean it doesn't have",
    "start": "1621679",
    "end": "1628400"
  },
  {
    "text": "to be a leaf could be f which has no children it could be d which has one child but no right child",
    "start": "1628400",
    "end": "1634080"
  },
  {
    "text": "so what's the successor of f well it's d which in this case is the parent but",
    "start": "1634080",
    "end": "1639840"
  },
  {
    "text": "it's not always for example if we do successor of e its parent is actually earlier in the order because e was a right child",
    "start": "1639840",
    "end": "1646480"
  },
  {
    "text": "here f was a left child and so its parent was after",
    "start": "1646480",
    "end": "1653120"
  },
  {
    "text": "successor of d happens to be b because uh it's per it was the left child of its",
    "start": "1653760",
    "end": "1659440"
  },
  {
    "text": "parent okay so that seems like the easy case if we're the left child of our parent then our successor is our parent okay",
    "start": "1659440",
    "end": "1667039"
  },
  {
    "text": "basing on this small example but we can argue it generally in a moment what's the successor of e uh well it's",
    "start": "1667039",
    "end": "1672799"
  },
  {
    "text": "not b because that comes earlier in fact all the things in this in b sub tree come earlier or equal to",
    "start": "1672799",
    "end": "1679520"
  },
  {
    "text": "e um so we have to keep going up and then it turns out the successor of e",
    "start": "1679520",
    "end": "1685600"
  },
  {
    "text": "is a because this subtree was the left child of a because b was a",
    "start": "1685600",
    "end": "1690720"
  },
  {
    "text": "left child with a so the general strategy is walk up the tree",
    "start": "1690720",
    "end": "1697520"
  },
  {
    "text": "until we are we we go up a traversal whose reverse direction",
    "start": "1697520",
    "end": "1703039"
  },
  {
    "text": "would be left okay so um walk up the tree when i say walk up i mean",
    "start": "1703039",
    "end": "1710799"
  },
  {
    "text": "node equals node.parent iteration",
    "start": "1710799",
    "end": "1714960"
  },
  {
    "text": "until we go up a left",
    "start": "1720320",
    "end": "1726799"
  },
  {
    "text": "branch so this would mean that node before we",
    "start": "1726799",
    "end": "1733679"
  },
  {
    "text": "do the change node equals node.parent node.parent.left",
    "start": "1733679",
    "end": "1740240"
  },
  {
    "text": "okay so we can check that and then after we do that traversal that parent is exactly the node we're looking for",
    "start": "1742960",
    "end": "1753520"
  },
  {
    "text": "okay why is this true in general let me draw a more generic picture so we're starting at some node",
    "start": "1753520",
    "end": "1761278"
  },
  {
    "text": "and let's say its parent is to the right so it comes later in the order",
    "start": "1761760",
    "end": "1767440"
  },
  {
    "text": "for a while sorry get this backwards we're doing successor",
    "start": "1767440",
    "end": "1773360"
  },
  {
    "text": "so it goes to left for a while so these are all these nodes will come",
    "start": "1774480",
    "end": "1779919"
  },
  {
    "text": "earlier in the order because by the definition everything in the right subtree comes after and at some point we have a parent",
    "start": "1779919",
    "end": "1785440"
  },
  {
    "text": "that's to the right meaning this node was the left child of this parent and that node by",
    "start": "1785440",
    "end": "1790960"
  },
  {
    "text": "definition will come after all of the nodes in here and could there be anything in between",
    "start": "1790960",
    "end": "1797200"
  },
  {
    "text": "node and this uh this parent grandparent ancestor",
    "start": "1797200",
    "end": "1803200"
  },
  {
    "text": "only if there was something in this subtree and we're in the case here where there is no right subtree of our",
    "start": "1803200",
    "end": "1808799"
  },
  {
    "text": "original node so this this is where all the nodes in between node and here would be but there aren't any and therefore this",
    "start": "1808799",
    "end": "1815600"
  },
  {
    "text": "is the successor so that's sort of the general argument why this",
    "start": "1815600",
    "end": "1821360"
  },
  {
    "text": "works i see a question yeah",
    "start": "1821360",
    "end": "1837039"
  },
  {
    "text": "placed into the traverse order so the traversal order is never explicitly computed what we're taught it's always implicit",
    "start": "1837039",
    "end": "1844080"
  },
  {
    "text": "we can't afford to maintain this as say an array this is just",
    "start": "1844080",
    "end": "1849200"
  },
  {
    "text": "in our heads maybe i will draw it with a cloud around it we're just thinking this",
    "start": "1849200",
    "end": "1857519"
  },
  {
    "text": "okay it's not in the computer explicitly in the computer all we store is this",
    "start": "1857519",
    "end": "1863120"
  },
  {
    "text": "and the reason is this is expensive we don't we can't maintain an array of things and be able to insert in the",
    "start": "1863120",
    "end": "1868320"
  },
  {
    "text": "middle whereas this is cheap i can afford to maintain this structure and do all these things and so the",
    "start": "1868320",
    "end": "1874159"
  },
  {
    "text": "reason we're talking about these operations is they're letting us manipulate the order or in this case letting us",
    "start": "1874159",
    "end": "1879840"
  },
  {
    "text": "iterate through the order so this was an algorithm for iterating through the entire order but that takes linear time this was",
    "start": "1879840",
    "end": "1887200"
  },
  {
    "text": "getting started in the order find me the first first thing the order and this was given",
    "start": "1887200",
    "end": "1892240"
  },
  {
    "text": "one node find me the next one how long do these operations take",
    "start": "1892240",
    "end": "1907840"
  },
  {
    "text": "right at most the height of the entire tree in fact it's going to be the depth of that first node but in the",
    "start": "1916480",
    "end": "1922480"
  },
  {
    "text": "worst case that's the height of the entire tree in general all of these operations are going to be order h",
    "start": "1922480",
    "end": "1928720"
  },
  {
    "text": "we need to think about it in each case except for this one which is order n so iterating through the whole thing um",
    "start": "1928720",
    "end": "1936240"
  },
  {
    "text": "this in this case we're just calling subtree first so that takes order h time here we're walking up the tree instead of down but",
    "start": "1936240",
    "end": "1942480"
  },
  {
    "text": "that's going to cost exactly the height of the node we happen to stop early but worst case order h",
    "start": "1942480",
    "end": "1948320"
  },
  {
    "text": "for all this all the operations we consider today we just want to get an order h bound and later we will bound h so the point",
    "start": "1948320",
    "end": "1955840"
  },
  {
    "text": "is these are fast if h is small like log n these are almost instantaneous",
    "start": "1955840",
    "end": "1961760"
  },
  {
    "text": "whereas if i had to update the explicit traversal order say as an array i would have to spend",
    "start": "1961760",
    "end": "1967120"
  },
  {
    "text": "linear time every time i make a change and yes it would be fast to do successor",
    "start": "1967120",
    "end": "1972480"
  },
  {
    "text": "if i had this stored explicitly but maintaining it would be impossible maintaining it efficiently would be",
    "start": "1972480",
    "end": "1977600"
  },
  {
    "text": "impossible question questions",
    "start": "1977600",
    "end": "1981519"
  },
  {
    "text": "yes okay",
    "start": "1984960",
    "end": "1991840"
  },
  {
    "text": "cool um so these were queries where i want to follow",
    "start": "1993840",
    "end": "2001200"
  },
  {
    "text": "see what's what's next in the traversal sequence now let's talk about actually changing the traversal sequence so these",
    "start": "2001200",
    "end": "2006960"
  },
  {
    "text": "are insert and delete operations these will correspond roughly to insert at or delete at",
    "start": "2006960",
    "end": "2013200"
  },
  {
    "text": "but they're not quite we're not quite in sequence world yet instead we're going to focus on",
    "start": "2013200",
    "end": "2018320"
  },
  {
    "text": "inserting or deleting in the middle of a subtree",
    "start": "2018320",
    "end": "2023279"
  },
  {
    "text": "so i'm going to have two nodes",
    "start": "2027440",
    "end": "2033840"
  },
  {
    "text": "so the in the traversal order",
    "start": "2036240",
    "end": "2043679"
  },
  {
    "text": "so node already exists in the tree new is a new node that does not yet exist in the tree hence i call it new",
    "start": "2043679",
    "end": "2050158"
  },
  {
    "text": "and what i'd like to do is insert new right after node and there's a symmetric",
    "start": "2050159",
    "end": "2056960"
  },
  {
    "text": "operation which is insert before it will be implemented almost identically so we'll just focus on after",
    "start": "2056960",
    "end": "2064638"
  },
  {
    "text": "so i want to insert this new node in the traversal order which again is in our heads this is all in in our thought bubble",
    "start": "2064639",
    "end": "2072320"
  },
  {
    "text": "that's what we want to achieve and we have to do it by manipulating this tree and however we change the tree",
    "start": "2073280",
    "end": "2079760"
  },
  {
    "text": "it defines a new traversal order so maybe let's do an example first",
    "start": "2079760",
    "end": "2089838"
  },
  {
    "text": "actually i probably want this universal order keep track of that so uh",
    "start": "2101680",
    "end": "2109520"
  },
  {
    "text": "let's say the first thing we want to do uh is insert",
    "start": "2109520",
    "end": "2118559"
  },
  {
    "text": "g before e i want to illustrate both of the",
    "start": "2119280",
    "end": "2124880"
  },
  {
    "text": "operations insert h",
    "start": "2124880",
    "end": "2130720"
  },
  {
    "text": "after e a",
    "start": "2130720",
    "end": "2136240"
  },
  {
    "text": "okay um so insert g before e so conceptually",
    "start": "2137920",
    "end": "2144560"
  },
  {
    "text": "what we want to do is insert g here and the way so we're given the node",
    "start": "2144560",
    "end": "2150320"
  },
  {
    "text": "e and we're given a sort of empty node i mean a node that just contains g it doesn't have any pointers yet",
    "start": "2150320",
    "end": "2156640"
  },
  {
    "text": "and we would like to put it before e where should i put it",
    "start": "2156640",
    "end": "2162000"
  },
  {
    "text": "left child all right so that's this is an easy case if i'm trying to",
    "start": "2162000",
    "end": "2167440"
  },
  {
    "text": "insert before and there's no left child stick it there if i'm trying to insert after and there's no right child",
    "start": "2167440",
    "end": "2173200"
  },
  {
    "text": "stick it there easy so let me write down case one",
    "start": "2173200",
    "end": "2178320"
  },
  {
    "text": "so here we're inserting after so if there's no uh right child",
    "start": "2180560",
    "end": "2188800"
  },
  {
    "text": "put new there okay i'm using informal language",
    "start": "2191359",
    "end": "2198000"
  },
  {
    "text": "here putting this new node there b instead of writing for example",
    "start": "2198000",
    "end": "2204480"
  },
  {
    "text": "node.write equals new because that's only one operation you need to do one thing you would do is set",
    "start": "2204480",
    "end": "2211119"
  },
  {
    "text": "node.write equals to new but you also have to set new's parent to be node.write so instead of worrying about those two",
    "start": "2211119",
    "end": "2218240"
  },
  {
    "text": "pointer changes because we always do bi-directional pointer changes i'm just going to use pseudocode and then in recitation you'll",
    "start": "2218240",
    "end": "2223680"
  },
  {
    "text": "see actual python code that does all this uh so then there's the other case",
    "start": "2223680",
    "end": "2232240"
  },
  {
    "text": "so that should be the second example insert h after a right",
    "start": "2232400",
    "end": "2240400"
  },
  {
    "text": "insert h after a so we already have a node after a in the right child in this right subtree",
    "start": "2240400",
    "end": "2248640"
  },
  {
    "text": "so where do i want to put h relative to a",
    "start": "2249119",
    "end": "2255680"
  },
  {
    "text": "well it should be to the right of a but it should be before c it should be to the left of c",
    "start": "2255680",
    "end": "2263280"
  },
  {
    "text": "so that would mean we want to put it here okay in this case it was pretty easy because this tree was small",
    "start": "2263280",
    "end": "2270240"
  },
  {
    "text": "where do i want to put it in general well wherever",
    "start": "2270240",
    "end": "2274880"
  },
  {
    "text": "subtree first tells me to put it right subtree first is going to give me the successor these are all kind of",
    "start": "2275359",
    "end": "2281680"
  },
  {
    "text": "parallel um we're in the case now where our node has",
    "start": "2281680",
    "end": "2287119"
  },
  {
    "text": "a right child and then successor tells us where the successor is it is the first",
    "start": "2287119",
    "end": "2293040"
  },
  {
    "text": "node which is the leftmost descendant in the right subtree of the node okay a lot of",
    "start": "2293040",
    "end": "2299680"
  },
  {
    "text": "pointers to follow in that sentence but it's clear in the picture so this",
    "start": "2299680",
    "end": "2306079"
  },
  {
    "text": "in this case we had node and there was no right child so we just added new to be its right child okay in the",
    "start": "2306079",
    "end": "2314160"
  },
  {
    "text": "other case we had a right child so here is node",
    "start": "2314160",
    "end": "2321040"
  },
  {
    "text": "there's uh there's this node here node.right which now we're supposing exists",
    "start": "2321040",
    "end": "2328400"
  },
  {
    "text": "and it defines a whole subtree there's this one which is the first node in the traversal",
    "start": "2329040",
    "end": "2336720"
  },
  {
    "text": "order of the subtree also known as the successor of node so i'll call this successor",
    "start": "2336720",
    "end": "2343599"
  },
  {
    "text": "of node in the current traversal order but of course we'd like to make new the new successor of the node so",
    "start": "2344240",
    "end": "2350960"
  },
  {
    "text": "where does it go here",
    "start": "2350960",
    "end": "2355838"
  },
  {
    "text": "we want to add it as a left child to the old successor",
    "start": "2356880",
    "end": "2363359"
  },
  {
    "text": "okay so put uh node as",
    "start": "2363599",
    "end": "2371520"
  },
  {
    "text": "so take the successor and if you look at the code for successor we're in this case so we know it will just call",
    "start": "2380320",
    "end": "2385520"
  },
  {
    "text": "subtree first of node.right and remember subtree first went left as much as it possibly could",
    "start": "2385520",
    "end": "2392720"
  },
  {
    "text": "so what that means is this successor node is guaranteed to not have a left child right because it was",
    "start": "2392720",
    "end": "2398720"
  },
  {
    "text": "defined by going right once and then going left as much as you could so there's no more left which means we",
    "start": "2398720",
    "end": "2404240"
  },
  {
    "text": "can make one more left just add new there and we're done now if you look at the traversal order",
    "start": "2404240",
    "end": "2411040"
  },
  {
    "text": "it will be node then new then the old successor and then the rest of that subtree",
    "start": "2411040",
    "end": "2416160"
  },
  {
    "text": "okay it's kind of cool in all cases uh i mean this was constant time",
    "start": "2416160",
    "end": "2422640"
  },
  {
    "text": "here we spent constant time after we called successor successor costs order h time so this is order h",
    "start": "2422640",
    "end": "2430480"
  },
  {
    "text": "new new okay put new there",
    "start": "2434240",
    "end": "2441359"
  },
  {
    "text": "clear okay that was insertion let's do deletion",
    "start": "2444640",
    "end": "2453838"
  },
  {
    "text": "get the spec right and the example",
    "start": "2454400",
    "end": "2467838"
  },
  {
    "text": "all of these are going to have two cases uh so let me",
    "start": "2470319",
    "end": "2475359"
  },
  {
    "text": "oh i didn't update so now h is after a so it should be like this",
    "start": "2475359",
    "end": "2480480"
  },
  {
    "text": "you can check the new traverse order of this tree is exactly that",
    "start": "2480480",
    "end": "2485280"
  },
  {
    "text": "next i'm going to do a couple of deletions let's delete",
    "start": "2486160",
    "end": "2492078"
  },
  {
    "text": "f first and then we're going to",
    "start": "2493119",
    "end": "2498720"
  },
  {
    "text": "well this is confusing",
    "start": "2498720",
    "end": "2504640"
  },
  {
    "text": "and then we're going to delete a so where's f we're supposing we're given a",
    "start": "2507599",
    "end": "2513040"
  },
  {
    "text": "pointer to f this node well it's a leaf so if i want to delete it i just erase it",
    "start": "2513040",
    "end": "2519520"
  },
  {
    "text": "easy leaves are easy to delete there's no work to do so what that means is i'm",
    "start": "2519520",
    "end": "2525200"
  },
  {
    "text": "removing the pointer from d to f okay we just erase that guy",
    "start": "2525200",
    "end": "2530800"
  },
  {
    "text": "uh okay now here's a trickier one suppose i want to delete the root of the tree this is kind of the hardest case but in general it would",
    "start": "2530800",
    "end": "2537599"
  },
  {
    "text": "be somewhere in between leaf and root so if i want to delete a if i just",
    "start": "2537599",
    "end": "2542720"
  },
  {
    "text": "erased it then suddenly there are these pointers to nowhere and i disconnect the tree into two parts i don't want to do that i need to keep",
    "start": "2542720",
    "end": "2548640"
  },
  {
    "text": "my tree connected so i'm going to play this trick",
    "start": "2548640",
    "end": "2554079"
  },
  {
    "text": "which is i forget if i use successor or predecessor predecessor",
    "start": "2554079",
    "end": "2561440"
  },
  {
    "text": "so i'm going to uh look at a we already have defined successor and",
    "start": "2563520",
    "end": "2569119"
  },
  {
    "text": "there by predecessor so i'm going to look at the predecessor of a which is e you can check that here the",
    "start": "2569119",
    "end": "2577359"
  },
  {
    "text": "one before a is e this is in the left subtree uh find me the rightmost item keep going",
    "start": "2577359",
    "end": "2583440"
  },
  {
    "text": "right until i can't that's e so now these guys are adjacent in the order and i'm about to remove a from the",
    "start": "2583440",
    "end": "2589040"
  },
  {
    "text": "order so i can momentarily cheat and swap their labels i'm going to erase a and e here and put",
    "start": "2589040",
    "end": "2596480"
  },
  {
    "text": "e after a why because it moves a down in the tree and if i get to the",
    "start": "2596480",
    "end": "2603520"
  },
  {
    "text": "leaf i'm done so i'm not quite done because this is not a leaf so again i look at a's predecessor it's now",
    "start": "2603520",
    "end": "2608800"
  },
  {
    "text": "g predecessor we hope is always in the uh",
    "start": "2608800",
    "end": "2614960"
  },
  {
    "text": "farther down in the tree and then i swap a with g",
    "start": "2614960",
    "end": "2621839"
  },
  {
    "text": "okay i have preserved the traversal order except where a falls just by moving a earlier in the",
    "start": "2622240",
    "end": "2628400"
  },
  {
    "text": "order here and now a is a leaf and i can erase it",
    "start": "2628400",
    "end": "2634240"
  },
  {
    "text": "okay so that's what we're going to follow now in actuality it's a little tricky sometimes we need to use",
    "start": "2634240",
    "end": "2639359"
  },
  {
    "text": "predecessors sometimes we need to use successor okay so the cases are",
    "start": "2639359",
    "end": "2645599"
  },
  {
    "text": "if the node is a leaf just detach it from the parent easy",
    "start": "2645599",
    "end": "2653838"
  },
  {
    "text": "that's sort of our base case in the recursion otherwise",
    "start": "2653920",
    "end": "2658880"
  },
  {
    "text": "there are two cases if so if we're not a leaf that means we",
    "start": "2658960",
    "end": "2664640"
  },
  {
    "text": "have a left child or a right child or both both is going to be the easy case but in general i have either there's a",
    "start": "2664640",
    "end": "2671839"
  },
  {
    "text": "left child or there's a right child in either case i'm going to be happy so i don't need a",
    "start": "2671839",
    "end": "2678079"
  },
  {
    "text": "both case uh okay so what do i do in if i have a",
    "start": "2678079",
    "end": "2684079"
  },
  {
    "text": "left child that guarantees to me that if the node's predecessor is inside that left sub-tree which means",
    "start": "2684079",
    "end": "2690640"
  },
  {
    "text": "it's lower in the tree if i didn't have a left child the predecessor would actually be higher in",
    "start": "2690640",
    "end": "2695839"
  },
  {
    "text": "the tree and i don't want to go higher okay so if i have a left child i know the predecessor is lower",
    "start": "2695839",
    "end": "2701440"
  },
  {
    "text": "and so i'm going to swap my item the contents of my node",
    "start": "2701440",
    "end": "2708800"
  },
  {
    "text": "with my predecessor's item",
    "start": "2708800",
    "end": "2718960"
  },
  {
    "text": "and then i'm going to recursively delete the predecessor okay that's the case",
    "start": "2718960",
    "end": "2732720"
  },
  {
    "text": "that we looked at in this code in this example because we always had a left child if we have a right child but",
    "start": "2732720",
    "end": "2737839"
  },
  {
    "text": "no left child we just do the reverse we swap with our successors item and then delete the successor in",
    "start": "2737839",
    "end": "2743760"
  },
  {
    "text": "either case we're going down and so if we start at some node like the route every time we do this operation",
    "start": "2743760",
    "end": "2750240"
  },
  {
    "text": "we're walking down and then we're walking down and in general we'll keep walking down",
    "start": "2750240",
    "end": "2755359"
  },
  {
    "text": "resuming where we left off which means total amount of time we spend is proportional to",
    "start": "2755359",
    "end": "2760560"
  },
  {
    "text": "the height of the tree in the worst case",
    "start": "2760560",
    "end": "2764880"
  },
  {
    "text": "question right so e didn't used to have a right child so we're changing identities of",
    "start": "2772839",
    "end": "2778880"
  },
  {
    "text": "nodes when we do this because we uh this that we didn't actually move this circle the circle stayed in place and",
    "start": "2778880",
    "end": "2785280"
  },
  {
    "text": "what we changed was the item that was stored in that circle so whether you call this node e or a",
    "start": "2785280",
    "end": "2792000"
  },
  {
    "text": "it doesn't really matter it is just the root note okay so we're gonna play a lot of these",
    "start": "2792000",
    "end": "2797040"
  },
  {
    "text": "tricks of moving the items around so far we hadn't been doing that we've just been creating nodes and placing them somewhere but now",
    "start": "2797040",
    "end": "2804000"
  },
  {
    "text": "we're in this delete operation is the first time where we're changing what's stored in the nodes",
    "start": "2804000",
    "end": "2809119"
  },
  {
    "text": "but we still can define the traversal order right the traverse order of this tree is dbgehc",
    "start": "2809119",
    "end": "2815359"
  },
  {
    "text": "which should be what we get here if i delete f and a",
    "start": "2815359",
    "end": "2821519"
  },
  {
    "text": "and sorry can f",
    "start": "2822800",
    "end": "2831760"
  },
  {
    "text": "trees will not preserve connections that's just the name of the game we are we have to allow this otherwise we can't",
    "start": "2831760",
    "end": "2837040"
  },
  {
    "text": "do anything that's the short version okay okay in the last few",
    "start": "2837040",
    "end": "2842160"
  },
  {
    "text": "minutes let me talk about how we take these trees and implement a set",
    "start": "2842160",
    "end": "2847280"
  },
  {
    "text": "or sequence okay i've already alluded to this",
    "start": "2847280",
    "end": "2852319"
  },
  {
    "text": "so for a sequence",
    "start": "2854800",
    "end": "2859839"
  },
  {
    "text": "we just make the traversal order equal to the the order that we're trying",
    "start": "2860160",
    "end": "2868240"
  },
  {
    "text": "to represent the sequence order",
    "start": "2868240",
    "end": "2873440"
  },
  {
    "text": "and if we're trying to source set items with keys we're going to make the traversal order",
    "start": "2873440",
    "end": "2880000"
  },
  {
    "text": "equal to ordered by increasing key increasing item",
    "start": "2880800",
    "end": "2888319"
  },
  {
    "text": "key some sense that's it but then we need to",
    "start": "2888319",
    "end": "2895280"
  },
  {
    "text": "think about how do we implement all of these operations so maybe most enlightening is for starters is",
    "start": "2895280",
    "end": "2903440"
  },
  {
    "text": "finding a key in a tree so this is going to correspond to binary",
    "start": "2903440",
    "end": "2909599"
  },
  {
    "text": "search if i'm searching for a key let's say i'm",
    "start": "2909599",
    "end": "2914880"
  },
  {
    "text": "searching for g's key and i know this may be hard in this example maybe i'll",
    "start": "2914880",
    "end": "2921200"
  },
  {
    "text": "replace these all with numbers so i can think about key values",
    "start": "2921200",
    "end": "2928559"
  },
  {
    "text": "okay so let's say 1 7 12 17",
    "start": "2928559",
    "end": "2934960"
  },
  {
    "text": "19 and 23. this is now in key order if you think of",
    "start": "2934960",
    "end": "2941119"
  },
  {
    "text": "the traversal order the property is that all the keys in the left subtree of the root",
    "start": "2941119",
    "end": "2946400"
  },
  {
    "text": "are less than the root and the root is less than all the keys in the right subtree and recursively all the way down",
    "start": "2946400",
    "end": "2951520"
  },
  {
    "text": "this is something called the binary search tree property bst property",
    "start": "2951520",
    "end": "2958640"
  },
  {
    "text": "these here we're calling them binary tree sets or set binary trees but they're",
    "start": "2958640",
    "end": "2965599"
  },
  {
    "text": "also known in the literature as binary search trees term you may have heard before so this is a special case of what we're",
    "start": "2965599",
    "end": "2970800"
  },
  {
    "text": "doing where we're storing the keys in order and then if i want to search for a key like uh 13",
    "start": "2970800",
    "end": "2977760"
  },
  {
    "text": "i compare that key with the root i see oh it's not equal and it's to the left because it's",
    "start": "2977760",
    "end": "2983520"
  },
  {
    "text": "less than 17. so 13 is left of here 13 is right of 7 13 is right of 12 and so i know that",
    "start": "2983520",
    "end": "2991599"
  },
  {
    "text": "this is where 13 would belong but there's no right child there and so i know in find i just returned nothing",
    "start": "2991599",
    "end": "2998559"
  },
  {
    "text": "if i was doing find previous i would return this note because i have tried to go to the right",
    "start": "2998559",
    "end": "3005760"
  },
  {
    "text": "the last time before i fell off the tree i was trying to go to the right and therefore that last note i had was the",
    "start": "3005760",
    "end": "3012000"
  },
  {
    "text": "previous item if i was trying to define next what would i do i would just take this node and compute its successor",
    "start": "3012000",
    "end": "3018160"
  },
  {
    "text": "which we already know how to do and that happens to be the root okay so now i can do these inexact",
    "start": "3018160",
    "end": "3024000"
  },
  {
    "text": "searches when i do find previous and find next when i fall off the tree i find either the previous or the next",
    "start": "3024000",
    "end": "3029839"
  },
  {
    "text": "and then with predecessor or successor i can find the other one okay so that's how we can do find and",
    "start": "3029839",
    "end": "3036079"
  },
  {
    "text": "find previous and find next to do",
    "start": "3036079",
    "end": "3042800"
  },
  {
    "text": "uh sequences we need a little bit more work we'll do that next time",
    "start": "3042800",
    "end": "3055838"
  },
  {
    "text": "you",
    "start": "3057760",
    "end": "3059839"
  }
]