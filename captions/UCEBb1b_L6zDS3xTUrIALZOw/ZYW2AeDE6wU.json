[
  {
    "start": "0",
    "end": "164000"
  },
  {
    "text": " The following\ncontent is provided under a Creative\nCommons license. Your support will help MIT\nOpenCourseWare continue",
    "start": "0",
    "end": "6870"
  },
  {
    "text": "to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6870",
    "end": "13330"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13330",
    "end": "27790"
  },
  {
    "text": "PROFESSOR: Well, welcome back to\ncomputational systems biology.",
    "start": "27790",
    "end": "33820"
  },
  {
    "text": "We're back here today talking\nabout genome assembly. How many people have ever\nassembled a genome before?",
    "start": "33820",
    "end": "43150"
  },
  {
    "text": "In your spare time? Anybody done any\ngenome assembly here? One person?",
    "start": "43150",
    "end": "48330"
  },
  {
    "text": "I think genome assembly\nis a fascinating topic. And as you know, it's at the\nbedrock of all modern biology.",
    "start": "48330",
    "end": "54830"
  },
  {
    "text": "We rely upon genome references\nfor almost everything in terms of studying evolution, looking\nat the structure of genes,",
    "start": "54830",
    "end": "63690"
  },
  {
    "text": "regulation of genes,\ndifferences between individuals. So it's really a very\nfundamental concept.",
    "start": "63690",
    "end": "71970"
  },
  {
    "text": "And we're going to talk today\nabout two different ways of assembling genomes. And I think one of the takeaway\nmessages from today's lecture",
    "start": "71970",
    "end": "78289"
  },
  {
    "text": "is going to be that\ngenome assembly is more of an art, in some\nsense, than a science.",
    "start": "78290",
    "end": "83740"
  },
  {
    "text": "And one has to always\nbe a little bit suspicious of a\ngenome assembly given what you're about\nto learn today.",
    "start": "83740",
    "end": "90299"
  },
  {
    "text": "And, of course, genome assembly\nis becoming even more complex because it used to be that\nassembling the human genome",
    "start": "90300",
    "end": "97700"
  },
  {
    "text": "was the big task scientifically\nin front of the community. But now there are billions\nof genomes waiting",
    "start": "97700",
    "end": "104229"
  },
  {
    "text": "to be sequenced-- all the\nindividuals in the world and to try and interpret them.",
    "start": "104230",
    "end": "109329"
  },
  {
    "text": "And now you can get\nyour genome sequence for between $5,000 and $10,000. How many people here are tempted\nto get their genome sequenced?",
    "start": "109330",
    "end": "117220"
  },
  {
    "text": "OK, I see about five\nhands-- six hands. Great. So let's look at the science\nbehind genome assembly.",
    "start": "117220",
    "end": "127950"
  },
  {
    "text": "The basic concept\nis that we're going to collect some sequence\nreads from the genome.",
    "start": "127950",
    "end": "135089"
  },
  {
    "text": "And we're going to\nassemble them know what are called contigs\nfor contiguous segments.",
    "start": "135089",
    "end": "140870"
  },
  {
    "text": "And these represent\nuninterrupted portions of the genome that are\ncompletely covered by reads that we believe\nare contiguous.",
    "start": "140870",
    "end": "146485"
  },
  {
    "text": " These contigs then will be\npaired together in scaffolds.",
    "start": "146485",
    "end": "153730"
  },
  {
    "text": "And scaffolds are like contigs\nexcept that there are missing parts between the\ncontigs in a scaffold.",
    "start": "153730",
    "end": "159560"
  },
  {
    "text": "We don't know what\nthose parts are. But we're able to actually\nglue them together",
    "start": "159560",
    "end": "164710"
  },
  {
    "start": "164000",
    "end": "164000"
  },
  {
    "text": "by using read pairs that allow\nus to jump over the missing parts because we have read\nboth ends of a molecule.",
    "start": "164710",
    "end": "170870"
  },
  {
    "text": "But we don't know\nwhat's in the middle. And then oftentimes we had\nphysical mapping technologies",
    "start": "170870",
    "end": "176730"
  },
  {
    "text": "where we actually can go back\nand assign location scaffolds to physical locations\non chromosomes",
    "start": "176730",
    "end": "183040"
  },
  {
    "text": "by using PCR sequences\nlike sequence tag sites",
    "start": "183040",
    "end": "188260"
  },
  {
    "text": "that physically locate\na particular sequence identity to a physical location\non a particular chromosome.",
    "start": "188260",
    "end": "196655"
  },
  {
    "text": "And that provides us\nwith a total genome map. So today we're\ngoing to be talking about how to go from a\nhard drive full sequence",
    "start": "196655",
    "end": "205440"
  },
  {
    "text": "reads all the way down\nto a set of scaffolds that include assembled contigs.",
    "start": "205440",
    "end": "211820"
  },
  {
    "text": "And the way to think\nabout this once again is that we start with\nconceptually a single copy",
    "start": "211820",
    "end": "218470"
  },
  {
    "text": "of the genome. We amplify this. And in order to sequence it\non contemporary instruments,",
    "start": "218470",
    "end": "227020"
  },
  {
    "text": "we have to fragment it. Now for those of you who were\nin last Friday's recitation, you heard Heng Li talking about\nthe idea that sequence reads",
    "start": "227020",
    "end": "234729"
  },
  {
    "text": "are getting longer. In fact, sequence\nreads up to 10 to 15 kilobases are now possible. And sequence reads\neven longer than that",
    "start": "234729",
    "end": "241687"
  },
  {
    "text": "are going to be possible,\nwhich will greatly simplify the assembly process. But for now we're talking\nabout the challenge",
    "start": "241687",
    "end": "247510"
  },
  {
    "text": "of assembling short reads--\nsay 100 base pair reads off of contemporary\nsequencing instruments.",
    "start": "247510",
    "end": "254400"
  },
  {
    "text": "So we take the fragmented\nreads and the notion is that we know\nthat they're going",
    "start": "254400",
    "end": "260250"
  },
  {
    "text": "to align up like a puzzle. And all we have\nto do is line the reads up to recover the read\nsequence at the bottom--",
    "start": "260250",
    "end": "267180"
  },
  {
    "text": "the original genome sequence. And I should add that many of\nthe illustrations in today's",
    "start": "267180",
    "end": "273840"
  },
  {
    "text": "lecture are from Ben Lagmi. He was kind enough to allow me\nto use them for today's talk.",
    "start": "273840",
    "end": "279840"
  },
  {
    "text": "So the goal is to come up with\nthat red sequence at the bottom",
    "start": "279840",
    "end": "284860"
  },
  {
    "text": "from the original set\nof reads but, of course, the read set that\nwe're talking about",
    "start": "284860",
    "end": "290690"
  },
  {
    "text": "is perhaps 200 million\nreads or even a billion reads as we'll see.",
    "start": "290690",
    "end": "295970"
  },
  {
    "text": "And so it's quite a tough task\nto put pieces together given that we really don't know\nwhere they came from.",
    "start": "295970",
    "end": "302170"
  },
  {
    "text": "And we don't know\nwhere they align because we don't have\nthe red part to guide us.",
    "start": "302170",
    "end": "308512"
  },
  {
    "text": "Now today we're\ngoing to be talking about what's called\nde novo assembly. That means starting\nfrom scratch.",
    "start": "308512",
    "end": "314490"
  },
  {
    "text": "You hand me your set of reads\nfor your favorite organism. And we're going to\nassemble it today.",
    "start": "314490",
    "end": "320572"
  },
  {
    "text": "That's different\nthan what's called reference-guided\nassembly because, for example, if you're going\nto re-sequence me or you,",
    "start": "320572",
    "end": "327490"
  },
  {
    "text": "there is a reference\nhuman genome. And it would be a simple matter\nto take the reads from you or I",
    "start": "327490",
    "end": "333900"
  },
  {
    "text": "and map them back onto\nthe reference genome as a guide to trying to\nreassemble our genomes.",
    "start": "333900",
    "end": "340050"
  },
  {
    "text": "However, as you can\ntell, if there's a large structural variation\nbetween the reference genome and our genomes,\nthat process can fail.",
    "start": "340050",
    "end": "348500"
  },
  {
    "text": "So we're going to be talking\ntoday about de novo assembly. And in the process\nof de novo assembly,",
    "start": "348500",
    "end": "357430"
  },
  {
    "text": "oftentimes we talk\nabout coverage, which is on average how\nmany sequencing bases do",
    "start": "357430",
    "end": "363570"
  },
  {
    "text": "we have for every\nbase of the genome. Here we have for this\nlittle illustrative example",
    "start": "363570",
    "end": "370540"
  },
  {
    "text": "coverage of about 7x. Now, at the origin of\nthe Human Genome Project,",
    "start": "370540",
    "end": "378220"
  },
  {
    "text": "some calculations were done\nabout how much coverage was required to cover\nthe human genome.",
    "start": "378220",
    "end": "383669"
  },
  {
    "text": "And we talked last time\nabout library complexity.",
    "start": "383670",
    "end": "388980"
  },
  {
    "start": "387000",
    "end": "387000"
  },
  {
    "text": "This is a slightly\ndifferent idea, which is we want to estimate\nthe probability the base is uncovered.",
    "start": "388980",
    "end": "394830"
  },
  {
    "text": "So if we have the genome size\nas G and the number of reads as N and L is the\nlength of a read,",
    "start": "394830",
    "end": "400090"
  },
  {
    "text": "then N times L is the total\nnumber bases that we have. And that divided by the\ngenome is the average coverage",
    "start": "400090",
    "end": "407120"
  },
  {
    "text": "of a base. And probably the probability\nthat a base is not covered",
    "start": "407120",
    "end": "412240"
  },
  {
    "text": "is the probability\nwe're going to observe zero reads to that base,\nwhich is e to the minus",
    "start": "412240",
    "end": "419090"
  },
  {
    "text": "lambda, roughly speaking, if\nwe use a Poisson approximation.",
    "start": "419090",
    "end": "424330"
  },
  {
    "text": "And therefore, the number of\nuncovered bases it will have is going to be roughly G\ntimes e to the minus lambda.",
    "start": "424330",
    "end": "432630"
  },
  {
    "text": "The next calculations can\nbe thought intuitively as the following way, which is\nif we have N reads, if there's",
    "start": "432630",
    "end": "439900"
  },
  {
    "text": "going to be a gap\nafter a read, there has to be an uncovered\nbase after it. And so the number of gaps we're\ngoing to have in our assembly",
    "start": "439900",
    "end": "446210"
  },
  {
    "text": "is roughly N times e\nto the minus lambda. So this is a back of\nthe envelop calculation.",
    "start": "446210",
    "end": "453280"
  },
  {
    "text": "And now if we take some of\nour 1,000 genomes data, which",
    "start": "453280",
    "end": "458290"
  },
  {
    "text": "we previously used and asked how\nwell this approximation works, we see something like\nthis where the x-axis is",
    "start": "458290",
    "end": "467400"
  },
  {
    "start": "466000",
    "end": "466000"
  },
  {
    "text": "the total number of reads and\nthe genome coverage in bases is shown on the y-axis. And these are all different\nsequencing experiments.",
    "start": "467400",
    "end": "474264"
  },
  {
    "text": " So you can see there the\nroughly green outline,",
    "start": "474265",
    "end": "480150"
  },
  {
    "text": "which follows the approximately\nwhat we saw before in this Lander-Waterman rule.",
    "start": "480150",
    "end": "486137"
  },
  {
    "text": "Could somebody tell\nme what they think is going on with the red lines\nthat actually don't match up with that green line?",
    "start": "486137",
    "end": "491200"
  },
  {
    "text": " Anybody have any\nideas about why we",
    "start": "491200",
    "end": "497970"
  },
  {
    "text": "need more reads out\nof those libraries to get better coverage? ",
    "start": "497970",
    "end": "504700"
  },
  {
    "text": "Yes? AUDIENCE: There is\nprobably some bias when you're amplifying them? PROFESSOR: Yeah,\nthere's probably skew in the original libraries\nwe talked about last time.",
    "start": "504700",
    "end": "512179"
  },
  {
    "text": "In fact, we talked\nabout last time why the Poisson was not\na great approximation",
    "start": "512179",
    "end": "517530"
  },
  {
    "text": "for looking at libraries. And in fact, we might\nwant to fit something like a negative binomial\nin this particular case.",
    "start": "517530",
    "end": "524850"
  },
  {
    "text": " So we've got our read set.",
    "start": "524850",
    "end": "530110"
  },
  {
    "text": "And we can also\ntalk about coverage at a particular base, which is\ndifferent than average coverage",
    "start": "530110",
    "end": "535940"
  },
  {
    "text": "just to be clear that there are\ntwo different kinds of coverage that one can think about. Here we see coverage\nat T of level six.",
    "start": "535940",
    "end": "545590"
  },
  {
    "text": " And the other thing that\nwe need to be cognizant of",
    "start": "545590",
    "end": "552310"
  },
  {
    "text": "is that there are two\nreasons that we might-- two common reasons why\nwe might actually see",
    "start": "552310",
    "end": "559130"
  },
  {
    "text": "reads that overlap but don't\nagree at all positions. The obvious reason\nis that there's",
    "start": "559130",
    "end": "564790"
  },
  {
    "text": "an error in one of the reads. We get quality\nscores and so forth. And that can help us\ndecide which is the truth.",
    "start": "564790",
    "end": "570610"
  },
  {
    "text": "But the other possibility\nis that as you know, you have one of each\nof your chromosomes",
    "start": "570610",
    "end": "576800"
  },
  {
    "text": "from mom one from your dad. And there could be\nallelic differences between these chromosomes. So when we're doing\nassembly, oftentimes we'll",
    "start": "576800",
    "end": "584810"
  },
  {
    "text": "find that these\nallelic differences are going to pop up in terms of\nnon-concordance of our reads.",
    "start": "584810",
    "end": "593230"
  },
  {
    "text": "And we'll have to\nultimately decide if we want to make a single\ndiploid approximation",
    "start": "593230",
    "end": "599510"
  },
  {
    "text": "of a human genome or\nwe want to attempt to assemble a diploid genome.",
    "start": "599510",
    "end": "609240"
  },
  {
    "text": "And if we're going to\ndo a diploid genome, then we have to be\nquite careful and use",
    "start": "609240",
    "end": "615250"
  },
  {
    "text": "somewhat different\nassembly techniques. But the common reference\ngenome is haploid.",
    "start": "615250",
    "end": "620760"
  },
  {
    "text": "It's only considering\none chromosomal sequence. Is that clear to everybody?",
    "start": "620760",
    "end": "627500"
  },
  {
    "text": "OK, great. So we're going to talk about two\ngeneral approaches to assembly",
    "start": "627500",
    "end": "633980"
  },
  {
    "text": "today. We're going to talk about\noverlap layout consensus",
    "start": "633980",
    "end": "638990"
  },
  {
    "start": "636000",
    "end": "636000"
  },
  {
    "text": "assemblers as exemplified\nby a string graph assembler. And we're also going to\ntalk about De Bruijn graph",
    "start": "638990",
    "end": "645820"
  },
  {
    "text": "assemblers today. Now, overlap\nconsensus assemblers",
    "start": "645820",
    "end": "652850"
  },
  {
    "text": "were the first ones that\nwere used in the Human Genome Project because reads\nwere longer back then.",
    "start": "652850",
    "end": "658940"
  },
  {
    "text": "However, as the number\nof reads has increased, those assemblers are\nmore difficult to utilize",
    "start": "658940",
    "end": "665720"
  },
  {
    "text": "in part because of the need to\nfind overlaps between reads, as we'll see in a moment.",
    "start": "665720",
    "end": "672239"
  },
  {
    "text": "Whereas to De Bruijn\ngraph assemblers are somewhat more efficient. But they lose certain\nkinds of information.",
    "start": "672239",
    "end": "678750"
  },
  {
    "text": "So let's begin with these\noverlap layout consensus assemblers.",
    "start": "678750",
    "end": "684830"
  },
  {
    "text": "And we're going to talk about\nthree steps to build contigs",
    "start": "684830",
    "end": "690720"
  },
  {
    "start": "687000",
    "end": "687000"
  },
  {
    "text": "and the scaffolding\nstep can be thought of a similar between either\nthe overlap layout consensus",
    "start": "690720",
    "end": "696490"
  },
  {
    "text": "assemblers or De Bruijn\ngraph-based assemblers. ",
    "start": "696490",
    "end": "702769"
  },
  {
    "text": "So we're going to first\nbuild an overlap graph. What's an overlap graph? The essential idea\nis that when we",
    "start": "702770",
    "end": "709870"
  },
  {
    "text": "take our collection\nof reads, we look for overlaps between\nthe suffix of one read",
    "start": "709870",
    "end": "715060"
  },
  {
    "text": "and the prefix of another read. And if we think of\nall of our reads, we want to build a graph that\ndescribes all of such overlaps.",
    "start": "715060",
    "end": "724130"
  },
  {
    "text": "And just to be\nclear, I'm not going to be talking today about\nthe reverse complement",
    "start": "724130",
    "end": "729750"
  },
  {
    "text": "of these reads. Actual assemblers have\nto represent that. But it just duplicates\nall the nodes at edges.",
    "start": "729750",
    "end": "736700"
  },
  {
    "text": "So we're going to\ntry and keep things uncluttered by-- that's OK. Thank you.",
    "start": "736700",
    "end": "743030"
  },
  {
    "text": "We're going to try and\nkeep things uncluttered by not considering those today.",
    "start": "743030",
    "end": "748520"
  },
  {
    "text": " Now, one of the\nchallenges is how",
    "start": "748520",
    "end": "756480"
  },
  {
    "start": "755000",
    "end": "755000"
  },
  {
    "text": "to construct those overlaps. And we're going to be\ntalking about graphs a lot. So I thought it was worthwhile\njust to review terminology.",
    "start": "756480",
    "end": "764212"
  },
  {
    "text": "We're going to represent overlap\ngraphs as directed graphs, which consists of a\nset of vertices, which are the objects represented by\nthe circles in the edges, which",
    "start": "764212",
    "end": "772019"
  },
  {
    "text": "are the lines and a directed\nedge goes from one vertex to another. ",
    "start": "772020",
    "end": "778670"
  },
  {
    "text": "And there's also an\nequivalent representation in notational form on the lower\npart of the right of the slide",
    "start": "778670",
    "end": "786540"
  },
  {
    "text": "as well as a graphical\nrepresentation. We're going to be using the\ngraphical representations of these directed graphs today.",
    "start": "786540",
    "end": "793710"
  },
  {
    "text": " So the overlap graph is\nsimply a representation",
    "start": "793710",
    "end": "803069"
  },
  {
    "text": "of the overlap between reads. And we pick a minimum\nlength of overlap at times.",
    "start": "803070",
    "end": "810340"
  },
  {
    "text": "But for the next few\nslides, I'm simply going to represent each\nnode as an individual read.",
    "start": "810340",
    "end": "819780"
  },
  {
    "text": "And the edges will be\nannotated with the amount of overlap between the reads.",
    "start": "819780",
    "end": "825190"
  },
  {
    "text": "So if I hand you a set of\nreads, all we need to do is to compute this\noverlap graph.",
    "start": "825190",
    "end": "831129"
  },
  {
    "text": "We'll talk about how\nto do that in a moment. And you'll see graphically\nthen what comes out",
    "start": "831130",
    "end": "838500"
  },
  {
    "text": "of the process of computing\nthe overlap graph.  Now, it's possible\nthat overlap graphs",
    "start": "838500",
    "end": "848700"
  },
  {
    "start": "842000",
    "end": "842000"
  },
  {
    "text": "are cyclic because there\nare circular chromosomes.",
    "start": "848700",
    "end": "854250"
  },
  {
    "text": "And as we'll see, it's also\npossible to get a cyclic graph out of a linear chromosome\nif in fact there",
    "start": "854250",
    "end": "861600"
  },
  {
    "text": "are repetitive structures\nin the chromosome that cause a graph to\ncycle back on itself.",
    "start": "861600",
    "end": "868130"
  },
  {
    "text": " So how to find overlaps\nin efficient time",
    "start": "868130",
    "end": "877770"
  },
  {
    "text": "is a key problem. And that's one of the reasons\nthat people have shied away from using these\ntypes of assemblers",
    "start": "877770",
    "end": "884430"
  },
  {
    "text": "is because the cost\nof computing overlaps has been thought to be N-squared\nwhere N is the number reads",
    "start": "884430",
    "end": "890630"
  },
  {
    "text": "because you have to compare\nall the reads to one another. However, a really\nclever algorithm",
    "start": "890630",
    "end": "898490"
  },
  {
    "text": "was devised that\nused the technology we talked about last time.",
    "start": "898490",
    "end": "904060"
  },
  {
    "text": "You recall the idea of the FM\nindex and Burroughs-Wheeler",
    "start": "904060",
    "end": "909330"
  },
  {
    "text": "transforms allowed us to index\na genome and then to look up",
    "start": "909330",
    "end": "916240"
  },
  {
    "text": "reads in time proportional\nto the length of the read. So here's the essential idea.",
    "start": "916240",
    "end": "922730"
  },
  {
    "text": "What we're going to do is we're\ngoing to take all of the reads that we collect.",
    "start": "922730",
    "end": "928480"
  },
  {
    "text": "And we're going to index them.  And we can do that\nroughly at N log N time.",
    "start": "928480",
    "end": "936480"
  },
  {
    "text": "And after we've indexed\nall of the reads, then we can use that same\nindex to find overlaps very,",
    "start": "936480",
    "end": "942497"
  },
  {
    "text": "very efficiently.  And you can conceptualize this\nas simply looking at a read",
    "start": "942497",
    "end": "949580"
  },
  {
    "text": "that you have in your hand and\nlooking it up in the index. And you'll find all the\nplaces that the suffix",
    "start": "949580",
    "end": "954960"
  },
  {
    "text": "or prefix of that read batches. And you can trace back till you\nfind all the places it matches",
    "start": "954960",
    "end": "960690"
  },
  {
    "text": "where they hit an end of a read. And those all correspond\nto edges in the graph.",
    "start": "960690",
    "end": "966030"
  },
  {
    "text": "And it turns out that\nthis is so clever that it eliminates\nredundant edges.",
    "start": "966030",
    "end": "972450"
  },
  {
    "text": "So, for example, if\nI have reads that look like this where I have\nread one overlaps with read",
    "start": "972450",
    "end": "981850"
  },
  {
    "text": "two which overlaps\nwith read three.",
    "start": "981850",
    "end": "987050"
  },
  {
    "text": "And read one and read\nthree also overlap.  An unreduced graph would have\na representation like this.",
    "start": "987050",
    "end": "999910"
  },
  {
    "text": "But it turns out\nthat we don't have to do that because we can\nsimply reduce our graph to this",
    "start": "999910",
    "end": "1010630"
  },
  {
    "text": "because we know that\nread one and read three. Actually, this is\nthe graph that we",
    "start": "1010630",
    "end": "1016700"
  },
  {
    "text": "would have that\nwould be unreduced. We can reduce the graph to\neliminate this transitive edge",
    "start": "1016700",
    "end": "1023649"
  },
  {
    "text": "and simply represent\nit in this fashion.",
    "start": "1023650",
    "end": "1029040"
  },
  {
    "text": "So when we use these\nindices, we eliminate these transitive edges\nas we'll see momentarily.",
    "start": "1029040",
    "end": "1034595"
  },
  {
    "text": " So here's an example graph.",
    "start": "1034595",
    "end": "1042260"
  },
  {
    "start": "1038000",
    "end": "1038000"
  },
  {
    "text": "The sequence is\nshown on the bottom. The read lengths are\nof length seven bases.",
    "start": "1042260",
    "end": "1050660"
  },
  {
    "text": "And we're going to consider all\noverlaps a minimum size three.",
    "start": "1050660",
    "end": "1056810"
  },
  {
    "text": "And the edge label\nis the actual length of the overlap\nbetween the reads.",
    "start": "1056810",
    "end": "1062870"
  },
  {
    "text": "And you can see\nthat at the outset that these overlap graphs\nare not necessarily simple.",
    "start": "1062870",
    "end": "1070310"
  },
  {
    "text": "That tracing a path\nof the graph that represents the original\nstring is not completely",
    "start": "1070310",
    "end": "1077030"
  },
  {
    "text": "and totally straightforward. So we need to come up with a\nway to articulate our metrics",
    "start": "1077030",
    "end": "1083970"
  },
  {
    "text": "for how to trace a path to the\ngraph to reconstruct a genome. ",
    "start": "1083970",
    "end": "1090940"
  },
  {
    "text": "And that comes to the\nquestion of layout, which is how do we formulate\nthe problem of tracing",
    "start": "1090940",
    "end": "1099760"
  },
  {
    "start": "1098000",
    "end": "1098000"
  },
  {
    "text": "a path through an overlap graph?",
    "start": "1099760",
    "end": "1105240"
  },
  {
    "text": "So we'll first start with\nthe idea of the shortest common superstring.",
    "start": "1105240",
    "end": "1112170"
  },
  {
    "text": "The shortest common\nsuperstring of a string S",
    "start": "1112170",
    "end": "1118240"
  },
  {
    "text": "is the shortest string that\ncontains all the strings in S as substrings for a particular\nlength of substring.",
    "start": "1118240",
    "end": "1128710"
  },
  {
    "text": "So, for example,\nif we didn't have the constraint of\nshortest, then just",
    "start": "1128710",
    "end": "1136014"
  },
  {
    "text": "finding a string that contains\nall the substrings is easy. You just put them all together.",
    "start": "1136014",
    "end": "1141540"
  },
  {
    "text": "But if we want the\nshortest, then we need to be more thoughtful\nin terms of the way",
    "start": "1141540",
    "end": "1150450"
  },
  {
    "text": "that we compute this\nshortest common substring. And here is an example of\nthe shortest common substring",
    "start": "1150450",
    "end": "1156529"
  },
  {
    "text": "for the substrings that I\nhave shown you up there.",
    "start": "1156530",
    "end": "1162700"
  },
  {
    "text": "So one way to think about\nthe assembly problem is that we're trying to compute\nthe shortest common substring",
    "start": "1162700",
    "end": "1168480"
  },
  {
    "text": "of all the reads that we have. And that will be the most\nefficient representation",
    "start": "1168480",
    "end": "1175419"
  },
  {
    "text": "of those reads in\na linear sequence.  Now, we can describe\nthis problem",
    "start": "1175420",
    "end": "1187350"
  },
  {
    "text": "in terms of an overlap graph. And if you think\nabout the way that we would solve this in overlap\ngraph, in the shortest strings,",
    "start": "1187350",
    "end": "1195390"
  },
  {
    "text": "we want the maximum\namount of overlap. So we want to trace a path\nthrough the overlap graph that",
    "start": "1195390",
    "end": "1202800"
  },
  {
    "text": "gives us the largest\namount of overlap, which gives us the\nshortest string.",
    "start": "1202800",
    "end": "1208919"
  },
  {
    "text": "Right? So if we simply\nnegate the overlaps,",
    "start": "1208920",
    "end": "1214680"
  },
  {
    "text": "we want to minimize the\ntotal cost of the graph.",
    "start": "1214680",
    "end": "1220340"
  },
  {
    "text": "Now, it turns out\nthat this problem is known to be a very hard\ncomputational problem. It's in the class of\nsomething called NP-hard",
    "start": "1220340",
    "end": "1227600"
  },
  {
    "text": "because it's known as the\ntraveling salesman problem. And when you think\nabout the fact that we're going to have\nhundreds of millions of reads,",
    "start": "1227600",
    "end": "1234180"
  },
  {
    "text": "this is not really\ngoing to be tractable. If we got rid of the\nweights, and we simply",
    "start": "1234180",
    "end": "1239740"
  },
  {
    "text": "wanted to find a path\nthrough the graph, that's called the\nHamiltonian Path problem. That's also NP-complete.",
    "start": "1239740",
    "end": "1246880"
  },
  {
    "text": "So the shortest common\nsubstring is a way to think about assembling.",
    "start": "1246880",
    "end": "1253390"
  },
  {
    "text": "But we can't really\nnecessarily optimize metrics because it's going\nto be intractable.",
    "start": "1253390",
    "end": "1259639"
  },
  {
    "text": "So think about ways of doing\nthis that are greedier.",
    "start": "1259640",
    "end": "1265165"
  },
  {
    "text": "So here's an example of how\nwe would compute the shortest common substring starting\nwith the first string.",
    "start": "1265165",
    "end": "1271460"
  },
  {
    "text": "And each step along the\nway, is a concatenation of strings or a\ncollapsing of strings that",
    "start": "1271460",
    "end": "1279150"
  },
  {
    "text": "works towards building the\nshortest common substring. And we get the input string\nand the output string.",
    "start": "1279150",
    "end": "1289490"
  },
  {
    "text": "So we could articulate\nour assembly problem as a greedy SCS algorithm\nto try and put all the",
    "start": "1289490",
    "end": "1297380"
  },
  {
    "text": "reads together to come\nup with a superstring. And let me just describe to you\nthis will give us an intuition",
    "start": "1297380",
    "end": "1309799"
  },
  {
    "text": "into what goes wrong with\nassembly in a moment. But we do know there are\nsome bounds on this--",
    "start": "1309800",
    "end": "1315580"
  },
  {
    "text": "that if we actually did\nthe greedy algorithm, then the assembly that we got would\nbe only two and a half times",
    "start": "1315580",
    "end": "1321940"
  },
  {
    "text": "longer than the true\nshortest common substring. That isn't really very\nmuch comfort to us.",
    "start": "1321940",
    "end": "1328340"
  },
  {
    "text": "So we're going to have to\ncome up with different, more heuristic ways of approaching\nthe assembly problem. ",
    "start": "1328340",
    "end": "1335870"
  },
  {
    "text": "Here is another example. Now, this is the one\nthat I want to show you where we start with\na string at the top",
    "start": "1335870",
    "end": "1343790"
  },
  {
    "text": "where we're going to be looking\nfor minimum overlaps of three and these are reads of six long.",
    "start": "1343790",
    "end": "1352530"
  },
  {
    "text": "And when we do this\ngreedy algorithm, we come up with a\nstring, which is shorter",
    "start": "1352530",
    "end": "1360620"
  },
  {
    "text": "than the original beginning\nstring we started with. Can somebody see\nwhat happened here?",
    "start": "1360620",
    "end": "1366080"
  },
  {
    "text": "Why are we missing part\nof the original string? ",
    "start": "1366080",
    "end": "1373156"
  },
  {
    "text": "Yes? AUDIENCE: The reads\nwere short enough. And they repeated enough\nthat we never found out",
    "start": "1373156",
    "end": "1379410"
  },
  {
    "text": "that it was of the length\nthat it actually was. And so we just kind of\n[INAUDIBLE] did it [INAUDIBLE].",
    "start": "1379410",
    "end": "1386530"
  },
  {
    "text": "PROFESSOR: So the point\nwas that the reads were too short to be able to\nunambiguously identify",
    "start": "1386530",
    "end": "1394120"
  },
  {
    "text": "the number of repeats\nof long that we had in the original sequence. That's absolutely correct.",
    "start": "1394120",
    "end": "1400090"
  },
  {
    "text": "So we're not able to\ndisambiguate what was going on. And perhaps if we went\nback to our graph formalism",
    "start": "1400090",
    "end": "1409832"
  },
  {
    "start": "1409000",
    "end": "1409000"
  },
  {
    "text": "we could solve this\nproblem, right? Because here we have our\ngraph and the overlaps are written in on the\nedges of the number",
    "start": "1409832",
    "end": "1418410"
  },
  {
    "text": "bases that each one of\nthese reads overlaps. And all we need to do is\nto trace through this graph to find the original string.",
    "start": "1418410",
    "end": "1425450"
  },
  {
    "text": "So here is one\ntracing, which gives a total overlap of 39, which\nactually faithfully reproduces",
    "start": "1425450",
    "end": "1433980"
  },
  {
    "text": "the original string, right? However, that's not\nthe best tracing.",
    "start": "1433980",
    "end": "1442150"
  },
  {
    "text": "A better tracing through this\ngraph or path through the graph would be this, which\ngives us more overlap",
    "start": "1442150",
    "end": "1449900"
  },
  {
    "text": "and gives us a shorter string. But as we know, even\nthough it's better according to this metric,\nit isn't really optimum",
    "start": "1449900",
    "end": "1456700"
  },
  {
    "text": "because it gives us\nthe wrong answer. It's better but wrong.",
    "start": "1456700",
    "end": "1463070"
  },
  {
    "text": "So we're going to have to take\ninto account other things when we do our assembly and\nour tracing of this graph",
    "start": "1463070",
    "end": "1469620"
  },
  {
    "text": "to be able to come up with\nthe best possible assembly. ",
    "start": "1469620",
    "end": "1475730"
  },
  {
    "text": "So if we increase\nthe read length",
    "start": "1475730",
    "end": "1480799"
  },
  {
    "text": "as was pointed out to\nspan appropriately, we will be able to reconstruct\nthe original sequence.",
    "start": "1480800",
    "end": "1489820"
  },
  {
    "text": "And the point of this\nexample is that we need to consider this when\nwe're thinking about recovering",
    "start": "1489820",
    "end": "1495830"
  },
  {
    "text": "repeat structures in genomes. So if we don't have\nlong enough reads,",
    "start": "1495830",
    "end": "1504850"
  },
  {
    "text": "in this case reads\nof length 8, we're not going to go to recover\nthe original repeat structure.",
    "start": "1504850",
    "end": "1512600"
  },
  {
    "text": " And if we look at this,\nrepeats are really",
    "start": "1512600",
    "end": "1520270"
  },
  {
    "text": "the bane of assemblers\nin some sense. And as you know, roughly\n50% of the human genome",
    "start": "1520270",
    "end": "1526740"
  },
  {
    "text": "is repetitive content. So we need to be very, very\ncareful in terms of the way",
    "start": "1526740",
    "end": "1534620"
  },
  {
    "text": "that we utilize reads to\nbe able to recover the best approximation of\nour genome sequence.",
    "start": "1534620",
    "end": "1540620"
  },
  {
    "text": " So here's another\nexample where we",
    "start": "1540620",
    "end": "1547680"
  },
  {
    "text": "look at l is minimum\nover length and k",
    "start": "1547680",
    "end": "1552880"
  },
  {
    "text": "is the length of the reads. And you can see the\nsequence that we're trying to recover-- It\nwas the best of times",
    "start": "1552880",
    "end": "1559333"
  },
  {
    "text": "it was the worst of\ntimes and the output from our greedy SCS assembler.",
    "start": "1559333",
    "end": "1567680"
  },
  {
    "text": "And as you can see,\nwe need to get up to a read length of\n13 characters for us",
    "start": "1567680",
    "end": "1575080"
  },
  {
    "text": "to be able to properly assemble\nthat original sentence. ",
    "start": "1575080",
    "end": "1581980"
  },
  {
    "text": "So the essential message\nhere is that unless you have reads that are long\nenough to span repeats,",
    "start": "1581980",
    "end": "1589860"
  },
  {
    "text": "you're not going\nto go to recover the original sequence exactly.",
    "start": "1589860",
    "end": "1595480"
  },
  {
    "text": "And this can be also thought\nof in the following example.",
    "start": "1595480",
    "end": "1601410"
  },
  {
    "text": "Imagine you have repeats\nthat are tandem repeats out at the end of a sequence.",
    "start": "1601410",
    "end": "1606931"
  },
  {
    "text": "And we're using the\nEnglish language here because it's easier\nto see than if I put up a bunch of genomic sequence.",
    "start": "1606931",
    "end": "1612770"
  },
  {
    "text": "But, of course, the\nprinciples are the same. You can see that\nunless we have reads",
    "start": "1612770",
    "end": "1618110"
  },
  {
    "text": "that actually are anchored\nand unique sequence and span out towards\na repetitive sequence,",
    "start": "1618110",
    "end": "1624560"
  },
  {
    "text": "we can't really tell\nhow many times the word bells is repeated. ",
    "start": "1624560",
    "end": "1632000"
  },
  {
    "text": "Another possibility\nis that we can actually coming from both sides. And if we can anchor our reads\nand unique sequence on both",
    "start": "1632000",
    "end": "1640450"
  },
  {
    "text": "the left and the right side\nof a repetitive element, then we can figure out how many\ncopies of something like bells",
    "start": "1640450",
    "end": "1646940"
  },
  {
    "text": "is present. But in the absence of that,\nwe really can't do it. In fact, we wind up with a\nstructure looks like this.",
    "start": "1646940",
    "end": "1654020"
  },
  {
    "text": "We wind up with-- there\nit is-- a structure where",
    "start": "1654020",
    "end": "1659900"
  },
  {
    "text": "we have-- let's\njust say that there are four different\nstretches of genome",
    "start": "1659900",
    "end": "1665299"
  },
  {
    "text": "in disparate parts\nof chromosomes and we repeat sequence\nin the middle. The blue parts of\nthe chromosomes",
    "start": "1665300",
    "end": "1673340"
  },
  {
    "text": "are unique sequence. And the red parts are\nrepetitive sequences.",
    "start": "1673340",
    "end": "1678450"
  },
  {
    "text": "What will happen is that if\nthe reads aren't long enough, we'll be able to find out in\neach one of the four locations",
    "start": "1678450",
    "end": "1686580"
  },
  {
    "text": "that we've gone from unique\nsequence to repeat sequence. And then we will get\nlost in the middle",
    "start": "1686580",
    "end": "1692000"
  },
  {
    "text": "of this identical\nrepeated sequence. And then on the\nright-hand side we'll",
    "start": "1692000",
    "end": "1698059"
  },
  {
    "text": "once again transition back\nfrom repeated sequence to unique sequence. But we won't know how to put\nthings together in the middle.",
    "start": "1698059",
    "end": "1704250"
  },
  {
    "text": "Right? We won't be able\nto figure out what the path is through these\nrepetitive elements.",
    "start": "1704250",
    "end": "1711150"
  },
  {
    "text": "So that's the essential point\nI'd like to make about repeats.",
    "start": "1711150",
    "end": "1716500"
  },
  {
    "text": "And we can now turn to\nthe question of layout and how to process an overlap\ngraph towards making contigs.",
    "start": "1716500",
    "end": "1724760"
  },
  {
    "text": "This is the actual layout graph. When we think about\nthat sentence up there.",
    "start": "1724760",
    "end": "1731940"
  },
  {
    "text": "And we say the minimum over\nthat length is four characters. And we have seven-character\nreads out of the sequence.",
    "start": "1731940",
    "end": "1738750"
  },
  {
    "text": "You can see it's a\npretty messy graph.",
    "start": "1738750",
    "end": "1744470"
  },
  {
    "text": "If we clean up the graph by\nremoving the redundant edges, the edges like\nthis that span over",
    "start": "1744470",
    "end": "1754429"
  },
  {
    "text": "reads and are implied\nby other reads, we can remove edges that\nare transitive over one",
    "start": "1754430",
    "end": "1760690"
  },
  {
    "text": "reads or two reads. Now, my presentation\nis going to talk",
    "start": "1760690",
    "end": "1768440"
  },
  {
    "text": "about how to remove these edges. However, as I said\nat the outset, if you use the algorithm\nby Simpson et al.,",
    "start": "1768440",
    "end": "1777110"
  },
  {
    "text": "you actually don't generate\nthese transitive edges in the first place. But assuming that you\ndidn't use an algorithm",
    "start": "1777110",
    "end": "1783759"
  },
  {
    "text": "and you did generate\nthem, you want to get rid of these\ntransitive edges like so.",
    "start": "1783760",
    "end": "1789480"
  },
  {
    "text": "And it starts getting\nsomewhat simpler as you begin\nsimplifying the graph,",
    "start": "1789480",
    "end": "1794870"
  },
  {
    "text": "removing these transitive edges. And then we can remove\nedges that skip two nodes.",
    "start": "1794870",
    "end": "1802370"
  },
  {
    "text": "So here's what happens after\nyou remove the single transitive edges in this graph. Yes? AUDIENCE: So it seems that the\ntransitive and verbal edges",
    "start": "1802370",
    "end": "1810464"
  },
  {
    "text": "gave us a little bit more\ninformation about the genome. Do we lose some useful\nordering principles by--",
    "start": "1810464",
    "end": "1818124"
  },
  {
    "text": "PROFESSOR: They provide\nredundant information. They don't really provide\nany additional information. It's the same linear sequence\nthat's implied by those edges.",
    "start": "1818124",
    "end": "1825165"
  },
  {
    "text": " Any other questions? ",
    "start": "1825165",
    "end": "1832640"
  },
  {
    "text": "So we can then remove\nedges that span two nodes.",
    "start": "1832640",
    "end": "1837820"
  },
  {
    "text": "And we get an even\nsimpler graph like this. Now this is beginning to look\nmore tractable because we",
    "start": "1837820",
    "end": "1843899"
  },
  {
    "text": "can look at this and we\ncan output contigs that correspond to linear\nportions of the graph, which",
    "start": "1843900",
    "end": "1851150"
  },
  {
    "text": "should be linear sequence. And when we do that what we\nwind up with are two contigs.",
    "start": "1851150",
    "end": "1860590"
  },
  {
    "text": "And there's just a bit of\nproblem in the middle, which is that we're unable to\nresolve the bit in the middle",
    "start": "1860590",
    "end": "1866980"
  },
  {
    "text": "and as a consequence,\nwe know that that is the number of terms that\nare in that original sentence",
    "start": "1866980",
    "end": "1875490"
  },
  {
    "text": "because we didn't\nhave a read long enough to be able\nto resolve that.",
    "start": "1875490",
    "end": "1881670"
  },
  {
    "text": "The other problem\nthat we can have in doing this kind of\nlayout is that when there are portions of\nthe genome that occur",
    "start": "1881670",
    "end": "1890120"
  },
  {
    "text": "or sequences in the genome that\noccur multiple times, when we actually do this\nlayout, we may find",
    "start": "1890120",
    "end": "1897308"
  },
  {
    "text": "that the portions\nof the genome that occur in two disparate locations\nline up with one another.",
    "start": "1897308",
    "end": "1902990"
  },
  {
    "text": "And it may be that as you\nexit the portion that's shared you get a\nmismatched base.",
    "start": "1902990",
    "end": "1908539"
  },
  {
    "text": "So that mismatch\ncould be because you have disparate parts of\nthe genome that actually have very similar sequence.",
    "start": "1908540",
    "end": "1914944"
  },
  {
    "text": "Or it could be\nthat you had a read error at the end of your read. And it's difficult to tell the\ntwo apart except by the amount",
    "start": "1914944",
    "end": "1923010"
  },
  {
    "text": "of coverage that you have. We'll talk about\nhow to prune graphs like this in a few moments.",
    "start": "1923010",
    "end": "1929929"
  },
  {
    "text": "But in any event, assuming\nthat we have pruned the graph, we have done our overlap.",
    "start": "1929930",
    "end": "1936154"
  },
  {
    "start": "1935000",
    "end": "1935000"
  },
  {
    "text": "We've done our layout. We've found our paths to\nthe graph for our contigs. And then what we find\nis that for each contig,",
    "start": "1936154",
    "end": "1942500"
  },
  {
    "text": "we have many reads. And we're going to\ntake those reads. And we're going to look at them.",
    "start": "1942500",
    "end": "1948910"
  },
  {
    "text": "And as you recall,\nwe could either have errors causing\ndisagreement among the reads.",
    "start": "1948910",
    "end": "1954100"
  },
  {
    "text": "We could have allelic\ndifferences between mom and dad causing those errors, well, not\nreally errors-- differences.",
    "start": "1954100",
    "end": "1961270"
  },
  {
    "text": "And then we can take\na consensus to come up with what the haploid genome is.",
    "start": "1961270",
    "end": "1968130"
  },
  {
    "text": "So that's the essential idea\nof a overlap layout consensus",
    "start": "1968130",
    "end": "1974610"
  },
  {
    "text": "assembler. We compute the overlap graph. During the layout phase we\nactually simplify the graph.",
    "start": "1974610",
    "end": "1981169"
  },
  {
    "text": "And we find pass through it. And during the consensus\nphase, we take our reads, and we build a consensus\nsequence of the genome.",
    "start": "1981170",
    "end": "1991280"
  },
  {
    "text": "And as I said, this graph\nbuilding can be slow.",
    "start": "1991280",
    "end": "1997890"
  },
  {
    "text": "Although, we'll\ntalk about how slow it is here in just a moment. And the challenge is that\nmodern sequencing data sets",
    "start": "1997890",
    "end": "2005440"
  },
  {
    "text": "are hundreds of\nmillions of reads. So let's talk about a\ncontemporary overlap-based",
    "start": "2005440",
    "end": "2013730"
  },
  {
    "text": "assembler-- something called\nthe stream graph assembler, which is done over at\nthe Sanger in the UK.",
    "start": "2013730",
    "end": "2019905"
  },
  {
    "text": "And there are three separate\nsteps it goes through. The first step is it\ntries to correct reads.",
    "start": "2019905",
    "end": "2025110"
  },
  {
    "text": "And the way it does\nthis is it actually looks at all the\nk-mers that occur in",
    "start": "2025110",
    "end": "2030340"
  },
  {
    "text": "reads-- it tries to find\nsequences that are very, very rare and find sequences\nthat are nearby",
    "start": "2030340",
    "end": "2037090"
  },
  {
    "text": "in sequence base\nthat aren't as rare. And it can correct bases that it\nbelieves are sequencing errors.",
    "start": "2037090",
    "end": "2044520"
  },
  {
    "text": "The next step is\nassembly once it has taken all these\nreads and corrected them. It indexes all the\nreads as I suggested",
    "start": "2044520",
    "end": "2050850"
  },
  {
    "text": "earlier using an FM index. And then it can find the overlap\nfrom that FM index directly.",
    "start": "2050850",
    "end": "2058790"
  },
  {
    "text": "And part of the assembly\nprocess is throwing away duplicate reads\nand throwing away reads that have\nlow quality scores.",
    "start": "2058790",
    "end": "2066250"
  },
  {
    "text": "So that's the filtering step. It then has the set of\ncontigs that it has generated.",
    "start": "2066250",
    "end": "2074859"
  },
  {
    "text": "And it does something\nquite interesting to find the scaffolds is that\nit takes the contigs it's assembled in terms\nof linear sequence.",
    "start": "2074860",
    "end": "2082859"
  },
  {
    "text": "And it completely re-indexes\nthem once again using an FM index. And then it takes all the\nreads that you started with.",
    "start": "2082860",
    "end": "2089643"
  },
  {
    "text": "And it maps them back\nonto the contigs. And by mapping the paired\nreads back on to the contigs,",
    "start": "2089643",
    "end": "2097100"
  },
  {
    "text": "it can actually figure\nout what contigs should be formed into scaffolds\nwhere there are holes that",
    "start": "2097100",
    "end": "2103890"
  },
  {
    "text": "are breached by\nthese longer reads. So it's using the FM indexed\nboth for correction to find out",
    "start": "2103890",
    "end": "2111420"
  },
  {
    "text": "nearby k-mers for\nassembly to find overlaps and for scaffolding to\nput things together.",
    "start": "2111420",
    "end": "2117290"
  },
  {
    "text": "And it does its indexing\nthree different times. And just to give you an\nidea of how long it takes",
    "start": "2117290",
    "end": "2124160"
  },
  {
    "start": "2123000",
    "end": "2123000"
  },
  {
    "text": "for a human-sized\ngenome, it's actually",
    "start": "2124160",
    "end": "2130299"
  },
  {
    "text": "quite expensive in\nterms of CPU time. It takes many days\nhave elapsed time",
    "start": "2130300",
    "end": "2136150"
  },
  {
    "text": "to assemble an entire\nhuman genome right now.",
    "start": "2136150",
    "end": "2141609"
  },
  {
    "text": "And it's thousands of\nCPU hours to actually put a genome together\nstarting from scratch.",
    "start": "2141610",
    "end": "2147930"
  },
  {
    "text": " OK, so that's the essential idea\nof an overlap-based assembler.",
    "start": "2147930",
    "end": "2155440"
  },
  {
    "text": "Are there any questions at all\nabout overlap-based assemblers? Yeah? AUDIENCE: So in the\ncase of an error ,",
    "start": "2155440",
    "end": "2161958"
  },
  {
    "text": "it's obvious how\nyou would call that. But in an allelic difference,\nhypothetically, there",
    "start": "2161958",
    "end": "2168284"
  },
  {
    "text": "would be 50% of the reads would\nhave one and 50% of the reads would have another. PROFESSOR: That's correct. AUDIENCE: So in that case\ndoes it assemble-- do you",
    "start": "2168284",
    "end": "2174590"
  },
  {
    "text": "just bias towards whichever\nones weren't easily amplified? Or do you assemble\ntwo sequences?",
    "start": "2174590",
    "end": "2181960"
  },
  {
    "text": "PROFESSOR: Most assemblers\nproduce a single sequence. And I don't know how SGA decides\nbetween the different alleles",
    "start": "2181960",
    "end": "2189750"
  },
  {
    "text": "because I don't recall what\nthe paper said they did. But they have to\nessentially flip a coin to come up with\na haploid sequence.",
    "start": "2189750",
    "end": "2197860"
  },
  {
    "text": "Yes? AUDIENCE: You said there was\nthree different times that you index. What are the three?",
    "start": "2197860",
    "end": "2204046"
  },
  {
    "text": "PROFESSOR: Yeah,\nthe question was I said there are three\ndifferent they indexed. They indexed at the\noutset to find errors.",
    "start": "2204046",
    "end": "2215620"
  },
  {
    "text": "They indexed the second time\nto do the overlap computation.",
    "start": "2215620",
    "end": "2222900"
  },
  {
    "text": "And they indexed the\nthird time to realign all the original reads to the\ncontigs they have to figure out",
    "start": "2222900",
    "end": "2229740"
  },
  {
    "text": "which contigs to put\ntogether into scaffolds. ",
    "start": "2229740",
    "end": "2235328"
  },
  {
    "text": "Right? But they have this essential\nfoundational platform, which is the FM index.",
    "start": "2235328",
    "end": "2241490"
  },
  {
    "text": "And so they use that\nover and over again to be able to do the assembly. ",
    "start": "2241490",
    "end": "2248045"
  },
  {
    "text": "These are all great questions.  All right, any other questions\nabout overlap-based assemblers.",
    "start": "2248045",
    "end": "2255295"
  },
  {
    "text": " And you can see that if you\nthink about how much coverage",
    "start": "2255295",
    "end": "2261550"
  },
  {
    "text": "they get out of an assembler\nlike this, it's actually, we'll compare all the\nassemblers at the very end. But if you look at the\nnumber of bases of autosomes",
    "start": "2261550",
    "end": "2270730"
  },
  {
    "text": "and the X chromosome\ncovered by an assembly,",
    "start": "2270730",
    "end": "2277000"
  },
  {
    "text": "you can consider\nthat as a function of the minimum alignment\nlength to a referenced genome.",
    "start": "2277000",
    "end": "2284180"
  },
  {
    "text": "And as the minimum\nalignment length goes up, that means you have to match\nlonger and longer portions",
    "start": "2284180",
    "end": "2290270"
  },
  {
    "text": "of the reference genome for\nyour assembly contig to count.",
    "start": "2290270",
    "end": "2296590"
  },
  {
    "text": "You can see that the number\nof bases dropped somewhat. In here they're\nshowing that they do better than another\nassembler called SOAPdenovo.",
    "start": "2296590",
    "end": "2304630"
  },
  {
    "text": "But they do get a\nfairly good coverage. On the other hand,\nthey don't get coverage",
    "start": "2304630",
    "end": "2311250"
  },
  {
    "text": "anywhere near as good as\nLander-Waterman might suggest because the coverage\nshould suggest",
    "start": "2311250",
    "end": "2316637"
  },
  {
    "text": "that the probability\nof uncovered base using Lander-Waterman would be roughly\ne to the minus 40th-- something",
    "start": "2316637",
    "end": "2322700"
  },
  {
    "text": "like that. And e to the minus 40th is like\n4 times 10 to the minus 18. So they're not\nanywhere near what",
    "start": "2322700",
    "end": "2328754"
  },
  {
    "text": "we would think the\nLander-Waterman bound would be for assembly. ",
    "start": "2328754",
    "end": "2335690"
  },
  {
    "text": "So we've talked about these\noverlap-based assemblers. Now I'm going to turn to\nDe Bruijn graph assemblers.",
    "start": "2335690",
    "end": "2342950"
  },
  {
    "text": "How many people have heard\nof De Bruijn graphs before? Anybody? One person?",
    "start": "2342950",
    "end": "2351210"
  },
  {
    "text": "So before we talk about De\nBruijn graphs themselves, let's just talk terminology.",
    "start": "2351210",
    "end": "2357640"
  },
  {
    "text": "So when I'm using\nterms we're all",
    "start": "2357640",
    "end": "2363414"
  },
  {
    "text": "on the same page where we were\ntalking about k-mers where the word mer is from\nthe Greek \"part.\"",
    "start": "2363415",
    "end": "2372080"
  },
  {
    "text": "And we talk about 4-mers\nof an original sequence as a sequence that's\nfour bases long.",
    "start": "2372080",
    "end": "2377900"
  },
  {
    "text": "And we can think about\nall of the 3-mers of an original sequence.",
    "start": "2377900",
    "end": "2383080"
  },
  {
    "text": "So we talk a lot about k-mers. And a k minus 1-mer is a\nsubstring of length k minus 1",
    "start": "2383080",
    "end": "2391620"
  },
  {
    "text": "obviously from a k-mer.  So if we think about the\ncollection of reads--",
    "start": "2391620",
    "end": "2398670"
  },
  {
    "text": "here these are our\nsuper-simple economy sequencers",
    "start": "2398670",
    "end": "2403790"
  },
  {
    "text": "producing reads of only\nlength three, which is pretty desperate. But at any rate we'll go\nwith that for the time being.",
    "start": "2403790",
    "end": "2409670"
  },
  {
    "text": "And we think about\neach one of these reads as having a left k minus 1-mer\nand a right k minus 1-mer.",
    "start": "2409670",
    "end": "2419040"
  },
  {
    "text": "We split them into\ntwo halves that way. And we're going to build a\ngraph that is as follows.",
    "start": "2419040",
    "end": "2433320"
  },
  {
    "text": "We're going to take all of the\nk minus 1-mers-- in this case the 2-mers. And for each read,\nwe're going to draw",
    "start": "2433320",
    "end": "2440850"
  },
  {
    "text": "an edge between its left\n2-mer and its right 2-mer.",
    "start": "2440850",
    "end": "2446340"
  },
  {
    "text": "OK, once again, for\neach read, these sort of anemic,\nthree-base-pair reads,",
    "start": "2446340",
    "end": "2451890"
  },
  {
    "text": "we're going to draw an\nedge between its left 2-mer and its right 2-mer. And they overlap in one base.",
    "start": "2451890",
    "end": "2458020"
  },
  {
    "text": "So all of the graphs that are\nDe Bruijn graphs, the edges represent an\noverlap of one base.",
    "start": "2458020",
    "end": "2465860"
  },
  {
    "text": "OK? So if you look at the\ngraph at the bottom, that represents the\noverlaps present",
    "start": "2465860",
    "end": "2475140"
  },
  {
    "text": "in the original sequence. You note that we have\nAA as one of the 2-mers.",
    "start": "2475140",
    "end": "2481260"
  },
  {
    "text": "And its left half and right half\nobviously overlap by one base.",
    "start": "2481260",
    "end": "2486310"
  },
  {
    "text": "The triple-A read has\nAA as its left read and AA as a right read--\nthay overlap at one base.",
    "start": "2486310",
    "end": "2493910"
  },
  {
    "text": "And that's why we have that\ncircular edge from A to itself. And the next edge\nfrom AA to AB comes",
    "start": "2493910",
    "end": "2502830"
  },
  {
    "text": "from the next\nread-- the AAB read. ",
    "start": "2502830",
    "end": "2510060"
  },
  {
    "text": "So each edge then represents\nan overlap of one base.",
    "start": "2510060",
    "end": "2516640"
  },
  {
    "text": "And therefore, each\nedge represents a unique k-mer sequence.",
    "start": "2516640",
    "end": "2521950"
  },
  {
    "text": "So the way to think\nabout this graph is it that all of the edges\nrepresent the original reads.",
    "start": "2521950",
    "end": "2528970"
  },
  {
    "text": "And we have represented the\nk minus 1 words as the nodes. OK?",
    "start": "2528970",
    "end": "2536150"
  },
  {
    "text": "So we can take this graph\nthen and generalize this idea.",
    "start": "2536150",
    "end": "2541549"
  },
  {
    "text": "And if we look at\nhow the graph changes",
    "start": "2541550",
    "end": "2547440"
  },
  {
    "text": "as we add more\nstructure, here you see that we've added an extra b. And we get another edge in the\ngraph back to the same node.",
    "start": "2547440",
    "end": "2555530"
  },
  {
    "text": "So when we're\nbuilding these graphs, if possible, we reuse a\nnode that already exists. ",
    "start": "2555530",
    "end": "2562900"
  },
  {
    "text": "Now the way to think\nabout coming back to the original sequence\nis finding a path",
    "start": "2562900",
    "end": "2568360"
  },
  {
    "text": "through this graph and emitting\nsequence as we trace the path. And we would like\nto have a path that",
    "start": "2568360",
    "end": "2574680"
  },
  {
    "text": "traverses all of the nodes. And so we have some\ndefinitions here,",
    "start": "2574680",
    "end": "2581180"
  },
  {
    "text": "which is that a node is\nbalanced if its indegree equals",
    "start": "2581180",
    "end": "2587390"
  },
  {
    "text": "it's outdegree. And you can see that not all\nthe nodes are balanced down",
    "start": "2587390",
    "end": "2593960"
  },
  {
    "text": "the graph of the lower,\nright-hand corner. And it's connected\nif all the components or nodes can be reached.",
    "start": "2593960",
    "end": "2600970"
  },
  {
    "text": "And a Eulerian walk visit\neach edge exactly once, which is what we would like to\nactually take a De Bruijn graph",
    "start": "2600970",
    "end": "2610690"
  },
  {
    "text": "and emit a genome sequence. Now, not all graphs\nhave these walks.",
    "start": "2610690",
    "end": "2617130"
  },
  {
    "start": "2616000",
    "end": "2616000"
  },
  {
    "text": " And graphs do our Eulerian.",
    "start": "2617130",
    "end": "2622290"
  },
  {
    "text": "And we won't distinguish\ndifferent types",
    "start": "2622290",
    "end": "2627520"
  },
  {
    "text": "of these graphs. And if a graph has two\nsemi-balanced nodes",
    "start": "2627520",
    "end": "2634379"
  },
  {
    "text": "and all the rest of\nthe nodes are balanced, then it will have\na walk through it.",
    "start": "2634379",
    "end": "2639650"
  },
  {
    "text": "So if we think about\nour original graph,",
    "start": "2639650",
    "end": "2644990"
  },
  {
    "text": "there are two arguments\nfor it having such a walk. The first argument is\nthat we show the walk.",
    "start": "2644990",
    "end": "2654120"
  },
  {
    "text": "And the second is that we\nhave two semi-balanced nodes and the rest of the\nnodes are balanced.",
    "start": "2654120",
    "end": "2660355"
  },
  {
    "text": " So the reason that\nwe care about this",
    "start": "2660355",
    "end": "2666340"
  },
  {
    "text": "is that we want to study\ncases where this goes wrong. ",
    "start": "2666340",
    "end": "2673760"
  },
  {
    "text": "So to build a De Bruijn\ngraph of a genome, we're going to take our\noriginal sequence reads.",
    "start": "2673760",
    "end": "2682120"
  },
  {
    "text": "And we're going to take\nall the k-mers that occur in those reads.",
    "start": "2682120",
    "end": "2688570"
  },
  {
    "text": "And we're going to add\nedges to a De Bruijn graph based upon those k-mers.",
    "start": "2688570",
    "end": "2694310"
  },
  {
    "text": "So if we have a read like\nthis, and we consider",
    "start": "2694310",
    "end": "2704530"
  },
  {
    "text": "a k-mer in the read,\nwe're going to add an edge in the graph between\nthe left k minus 1-mer",
    "start": "2704530",
    "end": "2711069"
  },
  {
    "text": "and the right k minus 1-mer. And we'll do that for every\nsingle k-mer in the read.",
    "start": "2711070",
    "end": "2718440"
  },
  {
    "text": "Now note what this does is\nit destroys some information. It destroys information\nabout the ordering",
    "start": "2718440",
    "end": "2726230"
  },
  {
    "text": "of certain of the k-mers in this\nread just destroying their read contiguity in order to make\nsome simplifying assumptions",
    "start": "2726230",
    "end": "2734400"
  },
  {
    "text": "to represent the\nsequence ordering of these k minus\n1-mers in the graph.",
    "start": "2734400",
    "end": "2743940"
  },
  {
    "text": "So we build the\ngraph in this way and if I were to build\nthe graph like this,",
    "start": "2743940",
    "end": "2756119"
  },
  {
    "text": "what is the minimum\nsequence overlap for two reads to actually share an\nedge in the resulting graph?",
    "start": "2756120",
    "end": "2762420"
  },
  {
    "text": " Can anybody see how\nlong the sequence",
    "start": "2762420",
    "end": "2768720"
  },
  {
    "text": "must be in the\nsecond read for it to actually overlap at\nedge with the first read? ",
    "start": "2768720",
    "end": "2780570"
  },
  {
    "text": "Well, if this second read\nalso has a k-mer, right? ",
    "start": "2780570",
    "end": "2785684"
  },
  {
    "text": "It's going to produce another\nstructure just like this one if these two do overlap. And thus the edge produced\nby this read and the edge",
    "start": "2785684",
    "end": "2794180"
  },
  {
    "text": "by this read will\noverlap like this.",
    "start": "2794180",
    "end": "2799520"
  },
  {
    "text": "And thus all of the nodes that\ncame from this part of read one",
    "start": "2799520",
    "end": "2807750"
  },
  {
    "text": "will feed into this graph. And then all the\nnodes to come out of this k-mer from the\npurple read will come out",
    "start": "2807750",
    "end": "2814640"
  },
  {
    "text": "of it like so, right? And thus when we're\ntracing the graph, the idea is that the\ngraph will be connected.",
    "start": "2814640",
    "end": "2821410"
  },
  {
    "text": "And we'll be able to\ncome between these reads and reconstruct\nthe sequence that was suggested by the overlap.",
    "start": "2821410",
    "end": "2827120"
  },
  {
    "text": " The thing, however, you should\nnote in this-- yes, question?",
    "start": "2827120",
    "end": "2835120"
  },
  {
    "text": "AUDIENCE: So you're\npicking two k minus 1 reads there-- are those\nfrom different reads?",
    "start": "2835120",
    "end": "2842970"
  },
  {
    "text": "Or from the white read? PROFESSOR: No, it's\nfrom the white read. These are the 2k minus 1-mers\nthat came out of this read.",
    "start": "2842970",
    "end": "2850549"
  },
  {
    "text": "So they actually overlap. AUDIENCE: Yeah,\nbut then you were talking about how the one\nwas purple in that case.",
    "start": "2850550",
    "end": "2858401"
  },
  {
    "text": "PROFESSOR: Right, well, this\nis the same sequence let's say. This is the same, exact\nsequence down here.",
    "start": "2858401",
    "end": "2864420"
  },
  {
    "text": "So if it's the same,\nexact sequence, it will have the\nsame k minus 1-mers.",
    "start": "2864420",
    "end": "2870930"
  },
  {
    "text": "And when we build the graph\nif a node already exists, we reuse it. ",
    "start": "2870930",
    "end": "2878430"
  },
  {
    "text": "And thus if we\nreuse the nodes that were created when we\nbuilt the graph nodes",
    "start": "2878430",
    "end": "2884850"
  },
  {
    "text": "and edges for the white read,\nthen when the purple read comes along, we're going to\nput another edge here",
    "start": "2884850",
    "end": "2891700"
  },
  {
    "text": "between these two k minus 1-mers\nbecause they are contained here as well. So these are identical\nsequences to this",
    "start": "2891700",
    "end": "2898260"
  },
  {
    "text": "because these two reads overlap. And this part is the same\nsequence as that part.",
    "start": "2898260",
    "end": "2903800"
  },
  {
    "text": "AUDIENCE: Yeah, so why do\nyou need k minus 1-mers if you have overlapped k?",
    "start": "2903800",
    "end": "2910250"
  },
  {
    "text": "PROFESSOR: Because\nthe way we're finding these overlaps is\nthrough the graph.",
    "start": "2910250",
    "end": "2915260"
  },
  {
    "text": "And we're not indexing\nthings of size k, right? We're indexing things\nof size k minus 1.",
    "start": "2915260",
    "end": "2921320"
  },
  {
    "start": "2921320",
    "end": "2927130"
  },
  {
    "text": "In each edge represents\na sequence of length k",
    "start": "2927130",
    "end": "2935502"
  },
  {
    "text": "because we know this\nsequence and this sequence are overlapped by one base. ",
    "start": "2935502",
    "end": "2942150"
  },
  {
    "text": "So when we find an edge that's\nthe same between the white and the purple read,\nwe know that they're overlapping by k bases.",
    "start": "2942150",
    "end": "2948369"
  },
  {
    "text": " Is that making sense to you? AUDIENCE: No.",
    "start": "2948370",
    "end": "2953560"
  },
  {
    "text": "PROFESSOR: No, OK, so\nlet's try it again. AUDIENCE: You can keep going.",
    "start": "2953560",
    "end": "2959136"
  },
  {
    "text": "PROFESSOR: No, it's OK. ",
    "start": "2959136",
    "end": "2964140"
  },
  {
    "text": "Let's just start with the purple\nread to start for a moment because I think if\nyou have a question,",
    "start": "2964140",
    "end": "2969570"
  },
  {
    "text": "other people may\nhave a question. So we have this sequence, which\nis this sequence right here,",
    "start": "2969570",
    "end": "2978220"
  },
  {
    "text": "right? And then we have\nthis sequence, which is the sequence right here.",
    "start": "2978220",
    "end": "2984070"
  },
  {
    "text": "They overlap by one base. And so we put an edge between\nthem like this in the graph.",
    "start": "2984070",
    "end": "2990099"
  },
  {
    "text": "OK?  AUDIENCE: Don't they overlap\nby more than one base?",
    "start": "2990100",
    "end": "2996234"
  },
  {
    "text": "They can only contain\none base from each k-mer. PROFESSOR: I'm sorry.",
    "start": "2996235",
    "end": "3001680"
  },
  {
    "text": "That's what I meant. Yeah.  And then the same thing\nis true down here.",
    "start": "3001680",
    "end": "3012070"
  },
  {
    "text": " And so we will find this k minus\n1-mer and this k minus 1-mer.",
    "start": "3012070",
    "end": "3020969"
  },
  {
    "text": "And then they overlap. ",
    "start": "3020969",
    "end": "3039350"
  },
  {
    "text": "For genome assembly, we\nrecord the forward and reverse",
    "start": "3039350",
    "end": "3046920"
  },
  {
    "text": "complement reads in twin nodes. And we're not going to\nshow those because it just complicates our\ngraphs without really",
    "start": "3046920",
    "end": "3053540"
  },
  {
    "text": "adding any illustrative power. And we always choose k to\nbe odd so that a node can't",
    "start": "3053540",
    "end": "3059854"
  },
  {
    "text": "be its own reversed complement. ",
    "start": "3059854",
    "end": "3067210"
  },
  {
    "text": "And here is the graph growing\nif we think about k equals 5.",
    "start": "3067210",
    "end": "3079200"
  },
  {
    "text": "So we have reads of length five. And we are adding\nsequences to the graph.",
    "start": "3079200",
    "end": "3085910"
  },
  {
    "text": "And you note that\nthe graph is acyclic until we get to the\nrepeated sequence. And we get to the second long\nthe sequence comes back around",
    "start": "3085910",
    "end": "3094000"
  },
  {
    "text": "begins a looping back on itself. And if we consider the last\npart of this De Bruijn graph",
    "start": "3094000",
    "end": "3102660"
  },
  {
    "text": "construction, then we wind\nup with the finished graph on the right-hand side.",
    "start": "3102660",
    "end": "3108859"
  },
  {
    "text": "And you can see the\nmultiplicity of the edges correspond to the\nnumber of times the long is repeated\nin this graph.",
    "start": "3108860",
    "end": "3115664"
  },
  {
    "text": " So once again, repeats are\ncausing the circular structure,",
    "start": "3115665",
    "end": "3123370"
  },
  {
    "text": "which only could be resolved if\nwe had sufficiently long reads, which we don't have in\nthis particular case.",
    "start": "3123370",
    "end": "3128464"
  },
  {
    "text": " However, if we consider\nperfect sequencing",
    "start": "3128465",
    "end": "3135920"
  },
  {
    "text": "we always have a\npath to the graph. And the reason is\nthat the leftmost part",
    "start": "3135920",
    "end": "3145750"
  },
  {
    "text": "of the genome, so to speak,\nis going to be semi-balanced.",
    "start": "3145750",
    "end": "3151040"
  },
  {
    "text": "And the rightmost part is\ngoing to be semi-balanced. And all the parts in between\nare going to be balanced.",
    "start": "3151040",
    "end": "3158350"
  },
  {
    "start": "3156000",
    "end": "3156000"
  },
  {
    "text": "So the k minus 1-mer on the\nvery left end is semi-balanced and the k minus 1-mer on\nthe right is semi-balanced.",
    "start": "3158350",
    "end": "3165650"
  },
  {
    "text": "And all the nodes in\nbetween are balanced. Now, this does not allow\nfor errors of course.",
    "start": "3165650",
    "end": "3175470"
  },
  {
    "text": "And we talk about following\nthis Eulerian walk",
    "start": "3175470",
    "end": "3184320"
  },
  {
    "text": "to find the original sequence. But the question we can ask\nourselves is whether or not this walk always\nreally corresponds",
    "start": "3184320",
    "end": "3190430"
  },
  {
    "text": "to the original genome sequence. It turns out I can show\nyou this example, which",
    "start": "3190430",
    "end": "3196010"
  },
  {
    "text": "is we have this graph\nfor this sequence. And there are two different\nwalks through this graph.",
    "start": "3196010",
    "end": "3205040"
  },
  {
    "text": "And the two different\nwalks produced",
    "start": "3205040",
    "end": "3211070"
  },
  {
    "text": "two different sequences. And they depend\nupon which way you start walking from the node AB.",
    "start": "3211070",
    "end": "3219580"
  },
  {
    "text": "So once again, here we\nhave seen that even when we have a path to the graph,\nthe path may not be unique.",
    "start": "3219580",
    "end": "3228480"
  },
  {
    "text": "It may not be able to\ngenerate the original sequence that we started with. ",
    "start": "3228480",
    "end": "3235750"
  },
  {
    "text": "So the other problem\nwe can have when",
    "start": "3235750",
    "end": "3241670"
  },
  {
    "text": "we are building a graph like\nthis is that gaps in coverage can create holes in the graph.",
    "start": "3241670",
    "end": "3247810"
  },
  {
    "text": "So if we omit\ncertain of our reads, we'll come up with a graph\nthat is broken into two parts.",
    "start": "3247810",
    "end": "3256640"
  },
  {
    "text": "And this corresponds\nto the idea that we're going to create two different\ncontigs that are contiguous",
    "start": "3256640",
    "end": "3262660"
  },
  {
    "text": "sequence but will be unable\nto fill in the middle part. OK? ",
    "start": "3262660",
    "end": "3269369"
  },
  {
    "text": "So we also can have differences\nin coverage of a graph",
    "start": "3269370",
    "end": "3279140"
  },
  {
    "text": "when we have extra reads\nat particular locations",
    "start": "3279140",
    "end": "3284480"
  },
  {
    "text": "in the genome. And that causes the degrees on\nthe individual nodes to vary",
    "start": "3284480",
    "end": "3291030"
  },
  {
    "text": "and causes us to not be able\nto rely upon the indegree",
    "start": "3291030",
    "end": "3296560"
  },
  {
    "text": "and outdegree as an\nabsolute metric for how to trace a path\nthrough the graph.",
    "start": "3296560",
    "end": "3302045"
  },
  {
    "start": "3302045",
    "end": "3307470"
  },
  {
    "text": "And the other thing is that\nif you have differences",
    "start": "3307470",
    "end": "3312544"
  },
  {
    "text": "between the chromosomes,\nwhich we talked about last time in our overlap\nlayout consensus assembler,",
    "start": "3312544",
    "end": "3320450"
  },
  {
    "text": "it also can cause\ngraphs to split apart and to have subgraphs\nthat correspond",
    "start": "3320450",
    "end": "3327119"
  },
  {
    "text": "to one allele versus the\nother allele, which is present perhaps in the main graph.",
    "start": "3327120",
    "end": "3333760"
  },
  {
    "text": "All right, so it's\nactually the case",
    "start": "3333760",
    "end": "3340000"
  },
  {
    "text": "that these graphs are attractive\nfor a very important reason,",
    "start": "3340000",
    "end": "3345710"
  },
  {
    "text": "which is there extraordinarily\nefficient to build. That is in order to\nbuild a graph like this,",
    "start": "3345710",
    "end": "3351599"
  },
  {
    "text": "you need to take each one\nof these k minus 1-mers and actually find the node,\nwhich you can do by hashing",
    "start": "3351600",
    "end": "3357516"
  },
  {
    "text": "and then put the\nedges into the graph. And so you find that you need\nto put in an edge and two nodes",
    "start": "3357517",
    "end": "3362870"
  },
  {
    "text": "for each k-mer. And if you have a hash map that\nencoded these nodes and edges,",
    "start": "3362870",
    "end": "3368810"
  },
  {
    "text": "it's constant time work. So you wind up\nwith a graph which",
    "start": "3368810",
    "end": "3374660"
  },
  {
    "text": "costs order of the\nnumber of reads to build. So it's a linear time\ngraph construction problem.",
    "start": "3374660",
    "end": "3381620"
  },
  {
    "text": "Recall that our last\noverlap construction, we thought we could\nget down to N log N.",
    "start": "3381620",
    "end": "3390130"
  },
  {
    "text": "And here is an example of\nsub-setting part of the lambda phage genome using a De\nBruijn graph assembler.",
    "start": "3390130",
    "end": "3398839"
  },
  {
    "text": "And you can see that\nroughly the time required to assemble parts\nof the genome is linear in the amount of genome\nsequence that you give it.",
    "start": "3398840",
    "end": "3405460"
  },
  {
    "text": " So these assemblers were\nfavored early on in the days",
    "start": "3405460",
    "end": "3419290"
  },
  {
    "text": "of short-read assembly in part\nbecause they were so efficient. And typically in\nsome of the projects,",
    "start": "3419290",
    "end": "3425395"
  },
  {
    "text": "you have very high coverage. And so you wind up with\ngraphs that actually have a huge number of\nedges between nodes.",
    "start": "3425395",
    "end": "3431980"
  },
  {
    "text": "And this can be\nsummarised in terms of a graph that simply\nannotates the edges",
    "start": "3431980",
    "end": "3437530"
  },
  {
    "text": "with the number of instances. And so you have a weighted graph\non the right-hand side, which",
    "start": "3437530",
    "end": "3445920"
  },
  {
    "text": "is easier in some sense to\ntrace because we can now",
    "start": "3445920",
    "end": "3451660"
  },
  {
    "text": "begin to eliminate low-coverage\nedges as potential anomalies.",
    "start": "3451660",
    "end": "3456744"
  },
  {
    "text": " But the essential idea is to\ntrace these graphs to produce",
    "start": "3456745",
    "end": "3463780"
  },
  {
    "text": "the ultimate genome sequence. And in order to\ndo so, we may need to do some error correction.",
    "start": "3463780",
    "end": "3471550"
  },
  {
    "text": "So we talked earlier about the\nidea that if we have an error,",
    "start": "3471550",
    "end": "3476570"
  },
  {
    "text": "we're going to actually produce\na portion of the graph that hangs off into outer space.",
    "start": "3476570",
    "end": "3483540"
  },
  {
    "start": "3479000",
    "end": "3479000"
  },
  {
    "text": "And we can cut these\ndead-end tips of the graph off if they are low coverage\nbecause they presumably",
    "start": "3483540",
    "end": "3493059"
  },
  {
    "text": "correspond to errors. If we get an error in\nthe middle of a read,",
    "start": "3493060",
    "end": "3499540"
  },
  {
    "text": "we can wind up with a so-called\nbubble in the graph, which once again is low coverage.",
    "start": "3499540",
    "end": "3505300"
  },
  {
    "text": "And we can get rid of these\nbubbles in a similar fashion.",
    "start": "3505300",
    "end": "3511800"
  },
  {
    "text": "And it's also possible to get\nchimeric edges of the graph. And those can be caused\nby errors as well.",
    "start": "3511800",
    "end": "3519730"
  },
  {
    "text": "And we can clip those edges. So there are different\nkinds of error correction",
    "start": "3519730",
    "end": "3525590"
  },
  {
    "text": "we can do in the graph. These are all quite heuristic. Each assembler has its\nown set of heuristics",
    "start": "3525590",
    "end": "3531030"
  },
  {
    "text": "for how to deal\nwith graph anomalies and how to eliminate edges in\nthe graph to permit assembly.",
    "start": "3531030",
    "end": "3541890"
  },
  {
    "text": "But these are getting\nrid of dead-end tips and popping bubbles and\ngetting rid of chimeric edges",
    "start": "3541890",
    "end": "3548630"
  },
  {
    "text": "are important things to\nconsider for any assembler. ",
    "start": "3548630",
    "end": "3554800"
  },
  {
    "text": "So the limitations\nof these graphs are the idea that\nwe're immediately",
    "start": "3554800",
    "end": "3560770"
  },
  {
    "text": "splitting these reads into this\nk-mer representation, which",
    "start": "3560770",
    "end": "3566640"
  },
  {
    "text": "is destroying information. And in order to\novercome this, one",
    "start": "3566640",
    "end": "3573460"
  },
  {
    "text": "of the things that people have\ndone in these De Bruijn graph assemblers is to take\nthe original reads",
    "start": "3573460",
    "end": "3582520"
  },
  {
    "text": "and to map them back\non to the graph. So when you're\nattempting to trace the path through the\ngraph, what you do",
    "start": "3582520",
    "end": "3588580"
  },
  {
    "text": "is you take the original reads. You thread them\nthrough the graph. And you know that\nthe original read represents contiguous\ngenome sequence.",
    "start": "3588580",
    "end": "3596390"
  },
  {
    "text": "So it provides you with\na path through the graph that you know is good. ",
    "start": "3596390",
    "end": "3602430"
  },
  {
    "text": "People have been\ndoing this in part because they didn't want to\ngo to the full overlap graph",
    "start": "3602430",
    "end": "3608380"
  },
  {
    "text": "implementation\nbecause of the cost. But I think that these overlap\ngraph implementations now",
    "start": "3608380",
    "end": "3615140"
  },
  {
    "text": "are sufficiently sophisticated\nthat I personally would use them instead of a\nDe Bruijn graph assembler.",
    "start": "3615140",
    "end": "3620710"
  },
  {
    "text": " And so the trade off\nreally centers around",
    "start": "3620710",
    "end": "3629580"
  },
  {
    "text": "speed and space versus accuracy.",
    "start": "3629580",
    "end": "3636070"
  },
  {
    "text": "So we can look at some\nexample assemblers",
    "start": "3636070",
    "end": "3642400"
  },
  {
    "text": "and look at their performance. But before I do that and\nwe leave De Bruijn graphs,",
    "start": "3642400",
    "end": "3648443"
  },
  {
    "text": "are there any other questions\nabout De Bruijin graph assemblers? ",
    "start": "3648444",
    "end": "3653570"
  },
  {
    "text": "AUDIENCE: I have one. PROFESSOR: Yeah, question. AUDIENCE: How long\nis k typically? PROFESSOR: We're going\nto talk about that.",
    "start": "3653570",
    "end": "3659090"
  },
  {
    "text": "The k typically is somewhere\naround 60-- something",
    "start": "3659090",
    "end": "3664260"
  },
  {
    "text": "like that-- Somewhere\nin that neighborhood. It's actually-- it\nhas to be odd, right?",
    "start": "3664260",
    "end": "3670500"
  },
  {
    "text": "So 61, 57-- something like that. Good question. Any other questions about\nDe Bruijin graph assemblers?",
    "start": "3670500",
    "end": "3677585"
  },
  {
    "start": "3677585",
    "end": "3685150"
  },
  {
    "text": "So once again returning\nto over our architecture,",
    "start": "3685150",
    "end": "3692670"
  },
  {
    "text": "we have these reads. We need to produce contigs. In the case of\noverlap graphs, we're",
    "start": "3692670",
    "end": "3700430"
  },
  {
    "text": "going to trace the\noverlap graphs. In the case of De\nBruijn graphs, we're going to trace the\nDe Bruijn graph. For scaffolding, we can use\nthe read pairs to put scaffolds",
    "start": "3700430",
    "end": "3709980"
  },
  {
    "text": "back together again. And here is some comparison\nof the performance",
    "start": "3709980",
    "end": "3717540"
  },
  {
    "text": "of these various assemblers. So the first assembler--\nSGA-- is an overlap layout",
    "start": "3717540",
    "end": "3725640"
  },
  {
    "text": "consensus-style assembler. Velvet/Abyss and SOAPdenovo\nare all De Bruijn,",
    "start": "3725640",
    "end": "3731160"
  },
  {
    "text": "graph-based assemblers. So these are all\ncontemporary assemblers that people use for\nassembling genomes.",
    "start": "3731160",
    "end": "3737190"
  },
  {
    "text": "An important metric\nfor assemblers is something called N50,\nwhich is the size of a contig",
    "start": "3737190",
    "end": "3742560"
  },
  {
    "text": "or scaffold where at that length\nor larger 50% of the bases",
    "start": "3742560",
    "end": "3748740"
  },
  {
    "text": "are present in scaffolds\nof that length. So, for example, for SGA, they\nsay that scaffold N50 size",
    "start": "3748740",
    "end": "3756340"
  },
  {
    "text": "is 26.3 kilobases, which\nmeans that in scaffolds",
    "start": "3756340",
    "end": "3761390"
  },
  {
    "text": "of length 26.3\nkilobases or larger, half of the bases\nof the assembly lie.",
    "start": "3761390",
    "end": "3767760"
  },
  {
    "text": "So the larger the N50 is,\nthe larger the scaffolds are that cover things.",
    "start": "3767760",
    "end": "3774670"
  },
  {
    "text": "And you want larger and\nlarger scaffolds or contigs so that you have fewer\ngaps in your assembly.",
    "start": "3774670",
    "end": "3781290"
  },
  {
    "text": "So the N50 number is a\nprinciple comparison metric",
    "start": "3781290",
    "end": "3787350"
  },
  {
    "text": "when one is thinking\nabout assemblers. So in this particular case,\nfor SGA the overlap metric",
    "start": "3787350",
    "end": "3796540"
  },
  {
    "text": "was that the reads had to\noverlap by at least 75 bases or more.",
    "start": "3796540",
    "end": "3803300"
  },
  {
    "text": "And these were\n100-base pair reads. You can see the\ndetails on the read data on the bottom line there.",
    "start": "3803300",
    "end": "3809260"
  },
  {
    "text": "So as long as the reads\noverlap by 75 bases, they were put\ntogether in the graph.",
    "start": "3809260",
    "end": "3815840"
  },
  {
    "text": "And the De Bruijn\ngraph assemblers each had their own\noptimum number for k.",
    "start": "3815840",
    "end": "3823589"
  },
  {
    "text": "And the way that you tune\nthese parameters is you run the assembler on\na range of k values.",
    "start": "3823590",
    "end": "3830040"
  },
  {
    "text": "And you see which k value\nproduced the assembly",
    "start": "3830040",
    "end": "3836290"
  },
  {
    "text": "with the highest N50. And you pick that k.",
    "start": "3836290",
    "end": "3842060"
  },
  {
    "text": "Can anybody think\nof a reason why it is that although\nthese are all roughly in the same ballpark,\ndifferent assemblers might have",
    "start": "3842060",
    "end": "3849360"
  },
  {
    "text": "different k values given that\nthe underlying technology is",
    "start": "3849360",
    "end": "3855245"
  },
  {
    "text": "quite similar? ",
    "start": "3855245",
    "end": "3862400"
  },
  {
    "text": "Any guesses about\nwhat is going on here? ",
    "start": "3862400",
    "end": "3872990"
  },
  {
    "text": "Well, we know that the\ndifferences in the assemblers really are rooted in the\nway that they are processing",
    "start": "3872990",
    "end": "3878560"
  },
  {
    "text": "the graphs and the way that\nthey are simplifying them. And therefore,\none has to imagine",
    "start": "3878560",
    "end": "3883970"
  },
  {
    "text": "that the differences lie in the\npost-processing of the graph once it's built and that\ncertain assemblers like larger k",
    "start": "3883970",
    "end": "3892780"
  },
  {
    "text": "values. Whereas other ones can\ntolerate smaller k values. And you can see if we look\nat the running statistics",
    "start": "3892780",
    "end": "3900750"
  },
  {
    "text": "for these, that the\nperformance of SGA",
    "start": "3900750",
    "end": "3906820"
  },
  {
    "text": "if you look at the\nreference bases covered by contigs greater\nthan one kilobase is roughly comparable to\nall the other assemblers.",
    "start": "3906820",
    "end": "3914470"
  },
  {
    "text": "But its mismatch\nperformance is much better. That is the other assemblers\nare producing-- well,",
    "start": "3914470",
    "end": "3922550"
  },
  {
    "text": "I take it back except\nfor SOAPdenovo. But it does quite a\ngood job at correcting",
    "start": "3922550",
    "end": "3927829"
  },
  {
    "text": "reads in coming up with\nthe correct sequence.  The last lines however tell the\nstory about running time, which",
    "start": "3927830",
    "end": "3936030"
  },
  {
    "text": "is that the overlap\nconsensus assembler is taking 41 hours of CPU time for\nC. elegans genome assembly.",
    "start": "3936030",
    "end": "3943339"
  },
  {
    "text": "Whereas the other assemblers,\nthe De Bruijn assembler are running much faster.",
    "start": "3943340",
    "end": "3948840"
  },
  {
    "text": " So the thing that I\nwanted to emphasize today",
    "start": "3948840",
    "end": "3958790"
  },
  {
    "text": "was that once you have\nthe final graph whether it be an overlap graph\nor a De Bruijn graph,",
    "start": "3958790",
    "end": "3967130"
  },
  {
    "text": "which represents possible\nways of putting back together again the jigsaw\npuzzle, it still",
    "start": "3967130",
    "end": "3974910"
  },
  {
    "text": "is an art to be able to\nbuild an assembler that uses appropriate heuristics\nto trace the graph",
    "start": "3974910",
    "end": "3981530"
  },
  {
    "text": "to come up with a\ngenome sequence. And I think another\nlesson is that repeats",
    "start": "3981530",
    "end": "3987560"
  },
  {
    "text": "are very problematic. With short reads, we really\ncannot resolve repeats exactly.",
    "start": "3987560",
    "end": "3994300"
  },
  {
    "text": "As a consequence, when we think\nabout any reference genome that we're dealing\nwith, if we consider",
    "start": "3994300",
    "end": "4002840"
  },
  {
    "text": "the size of the reads that were\nused to assemble that genome, then we need to\nbe mindful of what that tells us about\nwhether or not",
    "start": "4002840",
    "end": "4009070"
  },
  {
    "text": "the repeat structure that\nwe're observing in the genome is really an accurate\nrendition of what's going on in the genome itself.",
    "start": "4009070",
    "end": "4017170"
  },
  {
    "text": "And finally, I think\nthat we've talked today about the problem of\nassembling genomes",
    "start": "4017170",
    "end": "4023470"
  },
  {
    "text": "from a set of reads\nthat represent a uniform, single individual\nalbeit with possibilities",
    "start": "4023470",
    "end": "4033150"
  },
  {
    "text": "of differences of\nalleles between mom and dad in a diploid organism.",
    "start": "4033150",
    "end": "4038810"
  },
  {
    "text": "However, environmental\nsequencing where one takes up sea\nwater or other samples",
    "start": "4038810",
    "end": "4045410"
  },
  {
    "text": "and sequences all\nthe organisms in it and then attempts to assemble\nthose organisms de novo",
    "start": "4045410",
    "end": "4051650"
  },
  {
    "text": "admits the\npossibility that there are many different genomes\nthat you're considering.",
    "start": "4051650",
    "end": "4057290"
  },
  {
    "text": "And that, of course,\ncreates a whole new set of research problems,\nwhich I think are unsolved in part\nbecause of the read links",
    "start": "4057290",
    "end": "4065130"
  },
  {
    "text": "that we're currently\ndealing with. Are there any final\nquestions about assembly?",
    "start": "4065130",
    "end": "4070460"
  },
  {
    "text": " OK, great. Well, we will see\nyou then on Thursday",
    "start": "4070460",
    "end": "4077310"
  },
  {
    "text": "where we will talk about\nChIP-seq and IDR analysis. Until then, have\na great Wednesday.",
    "start": "4077310",
    "end": "4082550"
  },
  {
    "text": "Thank you very much. ",
    "start": "4082550",
    "end": "4093653"
  }
]