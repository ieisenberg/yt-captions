[
  {
    "start": "0",
    "end": "165000"
  },
  {
    "text": "[SQUEAKING]\n[RUSTLING] [CLICKING] ",
    "start": "0",
    "end": "12969"
  },
  {
    "text": "ERIK DEMAINE: All right,\nwelcome back to 006. Today we start a totally\nnew section of the class.",
    "start": "12970",
    "end": "18789"
  },
  {
    "text": "Up till now, we've\nmostly been showing you really cool and powerful\nalgorithms, sorting algorithms,",
    "start": "18790",
    "end": "25990"
  },
  {
    "text": "graph algorithms, data\nstructures, trees, lots of good stuff that you\ncan apply to solve tons of algorithmic problems,\neither by reducing to the data",
    "start": "25990",
    "end": "34540"
  },
  {
    "text": "structures that we showed you,\nor reducing to graph problems that we showed you,\nor by modifying",
    "start": "34540",
    "end": "40600"
  },
  {
    "text": "those algorithms a bit. Today we're going to start a new\nsection on algorithmic design--",
    "start": "40600",
    "end": "45850"
  },
  {
    "text": "how to, from scratch, come\nup with a polynomial time algorithm to solve a problem. ",
    "start": "45850",
    "end": "52697"
  },
  {
    "text": "And in particular,\nwe're going to talk about a algorithmic\ndesign paradigm called dynamic programming, which\nis extremely powerful.",
    "start": "52697",
    "end": "60190"
  },
  {
    "text": "It's probably the most powerful\nalgorithmic design paradigm. Very general. Can solve lots of problems.",
    "start": "60190",
    "end": "66340"
  },
  {
    "text": "It's a particular type of\nrecursive algorithm design. And in general, this class--",
    "start": "66340",
    "end": "74200"
  },
  {
    "text": "all of algorithms-- is about\nrecursive algorithm design at some level, because\nwe want to write",
    "start": "74200",
    "end": "79900"
  },
  {
    "text": "constant-sized pieces\nof code that solve problems of arbitrary size. We have some problem\nsize n and we're",
    "start": "79900",
    "end": "85690"
  },
  {
    "text": "trying to write 100 lines\nof code or whatever, some constant amount that\ndoesn't depend on the problem size.",
    "start": "85690",
    "end": "90720"
  },
  {
    "text": "We have one\nalgorithm that solves all instances of the problem. And so we have to write code\nthat is recursive or uses loops",
    "start": "90720",
    "end": "99400"
  },
  {
    "text": "or somehow reuses\nthe instructions that we give the computer. And you may know you can\nconvert any algorithm based",
    "start": "99400",
    "end": "106180"
  },
  {
    "text": "on loops into an\nalgorithm using recursion. And we're going to take\nthe recursive view today,",
    "start": "106180",
    "end": "111310"
  },
  {
    "text": "in particular\nbecause it fits very well with our proof-by-induction\ntechnique, which we've used throughout this class,\nbut also because it gives us",
    "start": "111310",
    "end": "120430"
  },
  {
    "text": "some structure on how different\nsubproblems relate in something called a subproblem graph, that\nwe'll be talking about today.",
    "start": "120430",
    "end": "128690"
  },
  {
    "text": "And so we're going to start\nout with, in general, how do we design recursive algorithms? That's sort of the overall,\nencompassing everything.",
    "start": "128690",
    "end": "136270"
  },
  {
    "text": "We have thought\nvery hard to come up with a cool acronym for this\nparadigm which we invented",
    "start": "136270",
    "end": "141910"
  },
  {
    "text": "called SRTBOT-- thanks, Jason. And so we'll talk-- it's\nnot actually for sorting.",
    "start": "141910",
    "end": "147940"
  },
  {
    "text": "It's just an acronym for\nsub-problems, relations,",
    "start": "147940",
    "end": "153580"
  },
  {
    "text": "topological order, base case,\noriginal problem, and time.",
    "start": "153580",
    "end": "159160"
  },
  {
    "text": "But it's an acronym that\nwill help you remember all the steps you need\nin order to specify",
    "start": "159160",
    "end": "164725"
  },
  {
    "text": "a recursive algorithm. And dynamic programming\nis going to build on this template by\nadding one new idea called",
    "start": "164725",
    "end": "172330"
  },
  {
    "start": "165000",
    "end": "360000"
  },
  {
    "text": "memoization, which is just\nthe idea of reusing work that you've done before. And that's going to let\nus solve tons of problems.",
    "start": "172330",
    "end": "180250"
  },
  {
    "text": "And let's see. I don't-- let's get into it.",
    "start": "180250",
    "end": "185540"
  },
  {
    "text": "So we'll start out\ntoday with SRTBOT. So here is SRTBOT\ndown the column here.",
    "start": "185540",
    "end": "193330"
  },
  {
    "text": "This is a recursive\nalgorithm design paradigm. And in general, what\nwe're going to do is take the problem that\nwe actually want to solve",
    "start": "193330",
    "end": "200560"
  },
  {
    "text": "and split it up into lots\nof possible sub problems. And so the first part\nis to define what",
    "start": "200560",
    "end": "206530"
  },
  {
    "text": "the heck are the subproblems. In general, we'll want some\npolynomial number of them. But it's pretty open-ended\nwhat these look like.",
    "start": "206530",
    "end": "214150"
  },
  {
    "text": "And the hardest part,\nusually, in defining a recursive algorithm\nis figuring out what the sub problems should be.",
    "start": "214150",
    "end": "220600"
  },
  {
    "text": "Usually they're related to\nthe problem you want to solve. Often the problem\nyou want to solve-- this is actually\nnear the last step--",
    "start": "220600",
    "end": "226908"
  },
  {
    "text": "the original problem\nyou're trying to solve is often one of\nthese sub problems. And then you use the\nsmaller sub problems",
    "start": "226908",
    "end": "233200"
  },
  {
    "text": "in order to build up the\nfinal, original problem. But sometimes at\nthe end, you need to take a bunch of\nsubproblems and combine them",
    "start": "233200",
    "end": "240519"
  },
  {
    "text": "into your original problem. You can think-- one analogy\nyou can think of here is divide and\nconquer algorithms,",
    "start": "240520",
    "end": "246160"
  },
  {
    "text": "which also had\nthis kind of style. But more generally, we're going\nto relate different sub problem",
    "start": "246160",
    "end": "252220"
  },
  {
    "text": "solutions with some recursive\nstructure-- some recurrence",
    "start": "252220",
    "end": "257440"
  },
  {
    "text": "relation. This is just a\nrecursive algorithm that defines how to solve\none problem in terms",
    "start": "257440",
    "end": "264640"
  },
  {
    "text": "of smaller sub-problems\nfor some notion of smaller. And this is given by\nthe topological order.",
    "start": "264640",
    "end": "271280"
  },
  {
    "text": "So if we think of the\nsubproblems as a graph and we draw an edge between--",
    "start": "271280",
    "end": "277500"
  },
  {
    "text": "so the vertices of the\ngraph are sub problems. The edges are the dependencies\nbetween those subproblems.",
    "start": "277500",
    "end": "282789"
  },
  {
    "text": "Then what we'd like is\nthe topological ordering, the topological sort problem\nwe talked about in the context",
    "start": "282790",
    "end": "288250"
  },
  {
    "text": "of DFS or DAG shortest paths. What we would like is that the\nsubproblems and the calls--",
    "start": "288250",
    "end": "296260"
  },
  {
    "text": "the recursive calls between them\nin this recursive relation-- forms a DAG. We want it to be\nacyclic, otherwise",
    "start": "296260",
    "end": "302560"
  },
  {
    "text": "you have an infinite loop\nin your recursive calls. If you have a cycle,\nyou'll never terminate.",
    "start": "302560",
    "end": "309220"
  },
  {
    "text": "And so to make sure\nthat these dependencies between subproblems given\nby this recurrence relation",
    "start": "309220",
    "end": "315540"
  },
  {
    "text": "is acyclic, one\nway to do that is to specify a topological order.",
    "start": "315540",
    "end": "320798"
  },
  {
    "text": "Or you could prove\nit some other way. But often it's just a for\nloop to say, just do it in this order.",
    "start": "320798",
    "end": "327290"
  },
  {
    "text": "Then of course any recursive\nstructure needs base cases. So that's a useful\nstep not to forget.",
    "start": "327290",
    "end": "333751"
  },
  {
    "text": "We want to solve the original\nproblem using these sub problems. And then we analyze a\nrunning time at the end.",
    "start": "333752",
    "end": "338810"
  },
  {
    "text": "So six easy steps. Actually, the hardest\nones are these two,",
    "start": "338810",
    "end": "343980"
  },
  {
    "text": "which are interrelated. And what we're going to see\nover the next four lectures--",
    "start": "343980",
    "end": "349073"
  },
  {
    "text": "this is the first\nof four lectures on dynamic programming-- is\nlots of examples of applying this paradigm over and over\ntogether with the memoization",
    "start": "349073",
    "end": "356820"
  },
  {
    "text": "idea, which we'll get to soon. Let's see an example first of\nan algorithm we've already seen,",
    "start": "356820",
    "end": "363009"
  },
  {
    "start": "360000",
    "end": "520000"
  },
  {
    "text": "which is merge sort, so a\ndivide and conquer algorithm, phrased with this\nstructure of SRTBOT.",
    "start": "363010",
    "end": "369120"
  },
  {
    "text": "So for the sub problems-- so our original problem is\nto sort the elements of A.",
    "start": "369120",
    "end": "374669"
  },
  {
    "text": "And some sub-problems that we\nsolve along the way are sorting different sub-arrays\nof A. So for every--",
    "start": "374670",
    "end": "381389"
  },
  {
    "text": "well, not for every i and\nj, but for some i and js, we sort the items from\ni up to j minus 1.",
    "start": "381390",
    "end": "388659"
  },
  {
    "text": "So I'm going to define that\nsubproblem to be s of ij. So this is something that\nI might want to solve.",
    "start": "388660",
    "end": "394650"
  },
  {
    "text": "The original problem\nthat I want to solve is s of 0 comma n, where n\nis the length of the array.",
    "start": "394650",
    "end": "400479"
  },
  {
    "text": "So that's what I actually\ncare about in the end. But we're going to solve that\nby writing it recursively",
    "start": "400480",
    "end": "405750"
  },
  {
    "text": "in terms of sorting different\nsub-arrays as follows. This is the recurrence relation.",
    "start": "405750",
    "end": "411825"
  },
  {
    "text": "I've written it\nvery simply here. Of course, there's\na merge algorithm, which is somewhat complicated.",
    "start": "411825",
    "end": "417150"
  },
  {
    "text": "But as we saw the two finger\nlinear time merge algorithm, given two sorted arrays--",
    "start": "417150",
    "end": "424170"
  },
  {
    "text": "so this is supposed\nto be the sorted array version of the\nitems i through m. m",
    "start": "424170",
    "end": "429210"
  },
  {
    "text": "is the middle element\nbetween i and j and the sorted array of\nthe items from m up to j.",
    "start": "429210",
    "end": "435810"
  },
  {
    "text": "If we merge those, that\ngives us the sorted array from i up to j.",
    "start": "435810",
    "end": "441699"
  },
  {
    "text": "And that's exactly\nwhat merge sort does. So in general, this\nrelation is just",
    "start": "441700",
    "end": "448210"
  },
  {
    "text": "some algorithm for if\nyou're given the solutions",
    "start": "448210",
    "end": "453460"
  },
  {
    "text": "to some smaller subproblems,\nhow do I solve the subproblem",
    "start": "453460",
    "end": "458560"
  },
  {
    "text": "that I want to solve? And so we need to make sure\nthat this problem is bigger",
    "start": "458560",
    "end": "466550"
  },
  {
    "text": "than the ones that we\nrecursively call on and that we don't get\nan infinite cyclic loop of recursions.",
    "start": "466550",
    "end": "471979"
  },
  {
    "text": "And here our valid\ntopological order is to say, solve these\nproblems in order",
    "start": "471980",
    "end": "477470"
  },
  {
    "text": "where j minus i-- the length of\nthe sub-array-- is increasing. And then you can check because\nm is strictly between i and j.",
    "start": "477470",
    "end": "485600"
  },
  {
    "text": "As long as we're not in a base\ncase, then we know we can--",
    "start": "485600",
    "end": "491660"
  },
  {
    "text": "these subarrays will be\nsmaller than this one. And so this increasing\norder gives us a valid topological order\non all of the problems, all",
    "start": "491660",
    "end": "499819"
  },
  {
    "text": "the subproblems. We have a base\ncase, which is if we don't want to sort anything,\nthat's the empty array,",
    "start": "499820",
    "end": "505880"
  },
  {
    "text": "or at least in the\noriginal problem. And then running time is-- I mean, there's no better way\nto solve it than the recurrence",
    "start": "505880",
    "end": "512780"
  },
  {
    "text": "that we already\nsaw how to solve. So this is just another\nway to think of n log n merge sort in this labeled\nframework of SRTBOT.",
    "start": "512780",
    "end": "521179"
  },
  {
    "start": "520000",
    "end": "820000"
  },
  {
    "text": "Let's get to\nanother problem that does not fit recursion so well.",
    "start": "521179",
    "end": "528380"
  },
  {
    "text": "But we can make it better. So this is-- we're\ngoing to start with a very simple\nproblem, which",
    "start": "528380",
    "end": "534620"
  },
  {
    "text": "is computing Fibonacci numbers. It's really just a toy problem\nto illustrate a very powerful",
    "start": "534620",
    "end": "542900"
  },
  {
    "text": "idea, which is memoization. So the problem I'm\ninterested in is I'm",
    "start": "542900",
    "end": "548449"
  },
  {
    "text": "given a particular number, n. And I want to compute\nthe nth Fibonacci number.",
    "start": "548450",
    "end": "554730"
  },
  {
    "text": "And in case you forgot,\nthe nth Fibonacci number is given by this recurrence. fn\nis fn minus 1 plus fn minus 2",
    "start": "554730",
    "end": "562190"
  },
  {
    "text": "with base case, let's say,\nf1 equals f2 equals 1. ",
    "start": "562190",
    "end": "569270"
  },
  {
    "text": "And so we'd like\nto compute this. This seems-- this\nis a recurrence. So it seems very\nnatural to write it",
    "start": "569270",
    "end": "576230"
  },
  {
    "text": "as a recursive algorithm. So let's try to do it. We start with what\nare the sub problems.",
    "start": "576230",
    "end": "581570"
  },
  {
    "text": "The obvious sub\nproblems are just the various Fibonacci numbers,\nf i for i between 1 and n.",
    "start": "581570",
    "end": "595628"
  },
  {
    "text": "So there are n of\nthese sub problems.  Cool.",
    "start": "595628",
    "end": "601529"
  },
  {
    "text": "Let's see. We want a relation between them. ",
    "start": "601530",
    "end": "607680"
  },
  {
    "text": "Well, maybe just to distinguish\nthe problems from the Fibonacci numbers, let me write f of i.",
    "start": "607680",
    "end": "613670"
  },
  {
    "text": "This is a function, an\nalgorithm we're going to define. And it's defined to be--",
    "start": "613670",
    "end": "618980"
  },
  {
    "text": "the goal we're trying to get\nis the ith Fibonacci number given i.",
    "start": "618980",
    "end": "623990"
  },
  {
    "text": "And then we can write\nthe recurrence relation on these guys, just f of\ni equals f of i minus 1",
    "start": "623990",
    "end": "631940"
  },
  {
    "text": "plus f of i minus 2. So in other words, recursively\ncompute those Fibonacci numbers",
    "start": "631940",
    "end": "637940"
  },
  {
    "text": "then add them together. That's an algorithm. Next is t for topological order.",
    "start": "637940",
    "end": "644300"
  },
  {
    "text": " Here, of course, we\njust want to compute",
    "start": "644300",
    "end": "651290"
  },
  {
    "text": "these in order of increasing\ni from the base case is up.",
    "start": "651290",
    "end": "657920"
  },
  {
    "text": "Another way I like to write\nthis is as a for loop for i equals 1 to n.",
    "start": "657920",
    "end": "664910"
  },
  {
    "text": "We will see why. But this gives an explicit order\nto compute these sub problems.",
    "start": "664910",
    "end": "670805"
  },
  {
    "text": " And base case is just the\nsame as the Fibonacci numbers,",
    "start": "670805",
    "end": "681460"
  },
  {
    "text": "but I guess I should\nwrite in parentheses.  The original problem we\nwant to solve is f of n.",
    "start": "681460",
    "end": "690460"
  },
  {
    "text": "And the time-- all\nright, here's where things get interesting or bad.",
    "start": "690460",
    "end": "695870"
  },
  {
    "text": "So what is the running time\nof this recursive algorithm? As I've stated it so\nfar, the running time",
    "start": "695870",
    "end": "702520"
  },
  {
    "text": "is given by a recurrence. Let's write the recurrence.",
    "start": "702520",
    "end": "707650"
  },
  {
    "text": "So in order to compute\nf of n, I recursively compute f of i minus 1\nor f of n minus 1 here.",
    "start": "707650",
    "end": "718580"
  },
  {
    "text": "And I recursively\ncompute f of n minus 2.",
    "start": "718580",
    "end": "723760"
  },
  {
    "text": "So that will take\nt of n minus 2. This first step will\ntake t of n minus 1. And now I need to\nsolve this recurrence.",
    "start": "723760",
    "end": "731510"
  },
  {
    "text": "This is not a recurrence that\nfalls to the master method. It doesn't have a divided by.",
    "start": "731510",
    "end": "737710"
  },
  {
    "text": "So we have to think\nabout it a little bit. But we don't have\nto think about it too hard, because\nthis recurrence is",
    "start": "737710",
    "end": "743110"
  },
  {
    "text": "the same as this\nrecurrence, which is the same as this recurrence. I've written it three times now. And so the solution to this\nis the nth Fibonacci number.",
    "start": "743110",
    "end": "752400"
  },
  {
    "text": "Oh, sorry. It's a little bit worse\nbecause in addition to those recursions, I\nalso spend constant time",
    "start": "752400",
    "end": "758610"
  },
  {
    "text": "to do the addition, maybe\nmore than constant time. But if we just count the\nnumber of additions we do,",
    "start": "758610",
    "end": "764850"
  },
  {
    "text": "it will be plus 1 additions.",
    "start": "764850",
    "end": "771360"
  },
  {
    "text": " OK. But this is bigger than\nthe nth Fibonacci number.",
    "start": "771360",
    "end": "778330"
  },
  {
    "text": "And if you know anything\nabout Fibonacci numbers, they grow exponentially.",
    "start": "778330",
    "end": "783850"
  },
  {
    "text": "They're about golden\nratio to the end. I'm wearing golden ratio, in\ncase you forgot the number.",
    "start": "783850",
    "end": "789570"
  },
  {
    "text": "So that's bad, because golden\nratio is bigger than 1. So this is exponential\ngrowth, as we know, especially",
    "start": "789570",
    "end": "796319"
  },
  {
    "text": "in this time, exponential\ngrowth is bad. In algorithms,\nexponential growth is bad, because we can only\nsolve very small problems",
    "start": "796320",
    "end": "802589"
  },
  {
    "text": "with exponential growth. Very small n. So this is a terrible way\nto compute the nth Fibonacci",
    "start": "802590",
    "end": "808530"
  },
  {
    "text": "number-- exponential bad.",
    "start": "808530",
    "end": "820260"
  },
  {
    "start": "820000",
    "end": "985000"
  },
  {
    "text": "OK, so don't do this. But there's a very tiny\ntweak to this algorithm",
    "start": "820260",
    "end": "827190"
  },
  {
    "text": "that makes it really good,\nwhich is memoization.",
    "start": "827190",
    "end": "833280"
  },
  {
    "text": "And this is a big idea. It is the big idea of\ndynamic programming.",
    "start": "833280",
    "end": "839884"
  },
  {
    "text": " It's a funny word, probably\nmade up by computer scientists.",
    "start": "839884",
    "end": "847709"
  },
  {
    "text": "Instead of memorization,\nit's memoization, because we're going to write\nthings down in a memo pad.",
    "start": "847710",
    "end": "854775"
  },
  {
    "text": "It's the idea. And it's a very\nsimple idea, which is just remember and reuse\nsolutions to sub-problems.",
    "start": "854775",
    "end": "864286"
  },
  {
    "start": "864286",
    "end": "875710"
  },
  {
    "text": "So let's draw the recursion tree\nfor this recursive algorithm",
    "start": "875710",
    "end": "882150"
  },
  {
    "text": "as we've done it so far. So at the top, we-- let me\nmake a little bit of space.",
    "start": "882150",
    "end": "888959"
  },
  {
    "text": "At the top we are\ncalling f of n. And then that calls f of n\nminus 1 and f of n minus 2.",
    "start": "888960",
    "end": "899100"
  },
  {
    "text": "And it does an addition up here. And then this calls\nf of n minus 2.",
    "start": "899100",
    "end": "904589"
  },
  {
    "text": "And this calls f of n minus 3. This calls f of n minus 3.",
    "start": "904590",
    "end": "911370"
  },
  {
    "text": "And this calls f of n minus 4. OK.",
    "start": "911370",
    "end": "916769"
  },
  {
    "text": "And we notice that\nthis sub problem is",
    "start": "916770",
    "end": "923710"
  },
  {
    "text": "the same as this sub problem. So to compute f of n minus\n1, I need f of minus 3. And also to compute f of n\nminus 2 I need f of n minus 3.",
    "start": "923710",
    "end": "932019"
  },
  {
    "text": "So why are we\ncomputing it twice? Let's just do it once. When we solve it, let's write\nit in a table somewhere.",
    "start": "932020",
    "end": "939459"
  },
  {
    "text": "And then when we need it again,\nwe'll just reuse that value. Question? AUDIENCE: What about\nthe f of n minus 2?",
    "start": "939460",
    "end": "944620"
  },
  {
    "text": "ERIK DEMAINE: f of n\nminus 2 is also shared. So let me use a\ndifferent symbol. f of n minus 2 is already here.",
    "start": "944620",
    "end": "953050"
  },
  {
    "text": "So this was at the same level. But we also get shared reuse\nbetween different levels. In fact, I wouldn't\neven call f of n minus 3",
    "start": "953050",
    "end": "959740"
  },
  {
    "text": "because this whole\npart doesn't need to be computed a second time. If I already\ncomputed it here, it",
    "start": "959740",
    "end": "965458"
  },
  {
    "text": "doesn't matter which\none comes first. Let's say this one comes first. Once this is done, I can write\nit down and reuse it over here.",
    "start": "965458",
    "end": "971830"
  },
  {
    "text": " And then in here, we're going\nto call f of n minus three.",
    "start": "971830",
    "end": "978000"
  },
  {
    "text": "So there's still another\ncomputation of f of n minus 3. When that one's done, I won't\nneed to do this recursively.",
    "start": "978000",
    "end": "985769"
  },
  {
    "start": "985000",
    "end": "1045000"
  },
  {
    "text": "OK, so magically\nthis is going to make this algorithm efficient\nwith this very simple tweak.",
    "start": "985770",
    "end": "992069"
  },
  {
    "text": "Let me write down the\ntweak more explicitly. I won't write code here. But just describe it\nas a data structure.",
    "start": "992070",
    "end": "1001920"
  },
  {
    "text": "So we're going to maintain our\ngood friend, the dictionary,",
    "start": "1001920",
    "end": "1007920"
  },
  {
    "text": "which is abstract data\ntype or interface. We could use different\ndata structures to do it.",
    "start": "1007920",
    "end": "1014870"
  },
  {
    "text": "But we're going to\nmap some problems to their solutions, at least the\nones that we've solved already.",
    "start": "1014870",
    "end": "1021830"
  },
  {
    "text": " And usually we can do this\nwith just a direct access",
    "start": "1021830",
    "end": "1027470"
  },
  {
    "text": "array, though you\ncould use a hash table. Just get expected bounce. So when we write the code\nfor our recursive function--",
    "start": "1027470",
    "end": "1043439"
  },
  {
    "text": "so in general, once we have\na sort bot description, we can turn this into code. We define f of i.",
    "start": "1043440",
    "end": "1050630"
  },
  {
    "start": "1045000",
    "end": "1251000"
  },
  {
    "text": "And it says am I in a base case? If so, return this. Otherwise, do this\nrecursive call.",
    "start": "1050630",
    "end": "1056780"
  },
  {
    "text": "That's our recursive algorithm. But we're going to\ndo a little more now. And first we're going to\ncheck whether this sub",
    "start": "1056780",
    "end": "1064940"
  },
  {
    "text": "problem that we're trying to\nsolve has already been solved. And if so, we return\nthat storage solution.",
    "start": "1064940",
    "end": "1075740"
  },
  {
    "text": "That's the easy case,\nbut it might not exist. ",
    "start": "1075740",
    "end": "1090960"
  },
  {
    "text": "And then we'll compute\nit in the usual way. So what the code then would\nlook like to define f of i",
    "start": "1090960",
    "end": "1099170"
  },
  {
    "text": "is first we check is i\nin our data structure. This is usually called the memo.",
    "start": "1099170",
    "end": "1105500"
  },
  {
    "text": " So we say, is this sub-problem--\nis i in my memo data structure?",
    "start": "1105500",
    "end": "1113350"
  },
  {
    "text": "If so just return memo of i. Done. No recursion necessary. Otherwise, check\nif I'm a base case.",
    "start": "1113350",
    "end": "1119220"
  },
  {
    "text": "If so, done. Otherwise, recurse. So recursively call f of i\nminus 1 and f of i minus 2.",
    "start": "1119220",
    "end": "1126120"
  },
  {
    "text": "And in this\nrecursion, we can see that after we call f\nof i minus 1, in fact, it will have already\ncomputed f of i minus 2.",
    "start": "1126120",
    "end": "1132750"
  },
  {
    "text": "So while this call is\nrecursive, this one will immediately terminate\nbecause i minus 2 will already be\nin the memo table.",
    "start": "1132750",
    "end": "1139690"
  },
  {
    "text": "And so if you think about\nwhat happens, in fact, we'll just have recursion down\nthe left branch of this thing.",
    "start": "1139690",
    "end": "1147643"
  },
  {
    "text": "And all the right\nbranches will be free. We can just look things\nup in the memo table. So what is the\noverall running time?",
    "start": "1147643",
    "end": "1154380"
  },
  {
    "text": "For Fibonacci, this\nshould be order n.",
    "start": "1154380",
    "end": "1165460"
  },
  {
    "text": "Why is it order n? This is number of additions. ",
    "start": "1165460",
    "end": "1171850"
  },
  {
    "text": "Come back to that in a second.  In general, the way to\nanalyze an algorithm",
    "start": "1171850",
    "end": "1179320"
  },
  {
    "text": "like this that uses\nmemoization is we just count how many different\nsub-problems are there? Because once we solve\nthe sub-problem,",
    "start": "1179320",
    "end": "1185290"
  },
  {
    "text": "we will never solve it again. That's the whole\nidea of a memo table. So we will solve each\nsub-problem at most once.",
    "start": "1185290",
    "end": "1191570"
  },
  {
    "text": "And so we just need to count,\nhow much time does it take to solve every sub-problem? And here you can\nsee it's constant.",
    "start": "1191570",
    "end": "1199000"
  },
  {
    "text": "Either it's a base case\nand it takes constant time or we recursively\ncall these things.",
    "start": "1199000",
    "end": "1204988"
  },
  {
    "text": "But those are\ndifferent sub-problems. So we're going to\ncount those later. And then the work\nthat's actually done by this recurrence\nis a single addition.",
    "start": "1204988",
    "end": "1212140"
  },
  {
    "text": "So in fact, it's n additions. To compute fn would be\nexactly n additions.",
    "start": "1212140",
    "end": "1220179"
  },
  {
    "text": "So it turns out to be very\nnice closed form in this case. It should be exactly n sub\nproblems to compute f of n",
    "start": "1220180",
    "end": "1229840"
  },
  {
    "text": "because we started as dot at 1. And each one has\none additional--",
    "start": "1229840",
    "end": "1235940"
  },
  {
    "text": "I guess not the base case. Maybe n minus 2. OK. Definitely order n.",
    "start": "1235940",
    "end": "1243050"
  },
  {
    "text": "Now, there's this\none subtlety which-- let's forget about dynamic\nprogramming for a moment",
    "start": "1243050",
    "end": "1248270"
  },
  {
    "text": "and go back to good old\nlecture one and two, talking about the word\nram model of computation.",
    "start": "1248270",
    "end": "1255020"
  },
  {
    "start": "1251000",
    "end": "1456000"
  },
  {
    "text": "A question here that usually\ndoesn't matter in this class. Usually we assume additions\ntake constant time.",
    "start": "1255020",
    "end": "1261540"
  },
  {
    "text": "And we usually do that\nbecause it's usually true. And in general, our model\nis the w bit additions--",
    "start": "1261540",
    "end": "1269750"
  },
  {
    "text": "where w is our\nmachine word size-- takes constant time. ",
    "start": "1269750",
    "end": "1279679"
  },
  {
    "text": "But for this problem\nand this problem only, pretty much, for\nFibonacci numbers, I happen to know\nthat the Fibonacci",
    "start": "1279680",
    "end": "1285620"
  },
  {
    "text": "numbers grow exponentially. So to write them down\nactually requires theta n bits",
    "start": "1285620",
    "end": "1292730"
  },
  {
    "text": "because they are some\nconstant to the n power. And so they're\nactually really big .",
    "start": "1292730",
    "end": "1298610"
  },
  {
    "text": "n is probably bigger than w. Usually you think of problems\nthat are much bigger than 64",
    "start": "1298610",
    "end": "1304570"
  },
  {
    "text": "or whatever your word\nsize happens to be. We do assume that w\nis at least log n. But n is probably bigger than w.",
    "start": "1304570",
    "end": "1311010"
  },
  {
    "text": "It might be bigger or smaller. We don't know. And in general, to do\nan n bit addition--",
    "start": "1311010",
    "end": "1317570"
  },
  {
    "text": "these are n bit additions-- is going to take ceiling\nof n over w time.",
    "start": "1317570",
    "end": "1327080"
  },
  {
    "text": "So in the end, we will\nspend this times n, because we have to do\nthat, many of them,",
    "start": "1327080",
    "end": "1332780"
  },
  {
    "text": "which is n plus n\nsquared over w time.",
    "start": "1332780",
    "end": "1338575"
  },
  {
    "text": "So a bit of a\nweird running time. But it's polynomial, whereas\nthis original recursive",
    "start": "1338575",
    "end": "1343970"
  },
  {
    "text": "algorithm was exponential here. Using this one simple\nidea of just remembering the work we've done, suddenly\nthis exponential time algorithm",
    "start": "1343970",
    "end": "1351492"
  },
  {
    "text": "becomes polynomial. Why? Because we have\nfew sub problems. We had n sub problems.",
    "start": "1351492",
    "end": "1359809"
  },
  {
    "text": "And for each sub problem,\nwe could write a recurrence relation that if we already knew\nthe solutions to smaller sub",
    "start": "1359810",
    "end": "1366320"
  },
  {
    "text": "problems, we could\ncompute this bigger problem very efficiently. This happened to be constant\ntime or constant additions.",
    "start": "1366320",
    "end": "1376250"
  },
  {
    "text": "n over w time. But as long as\nthis is polynomial and this is polynomial,\nwe're happy,",
    "start": "1376250",
    "end": "1382370"
  },
  {
    "text": "because we have this nice\nformula that the time it takes",
    "start": "1382370",
    "end": "1387500"
  },
  {
    "text": "is, at most, the sum over all\nsub problems of the relation",
    "start": "1387500",
    "end": "1395040"
  },
  {
    "text": "time.  So I'm referring to sub\nproblems, like a number of them",
    "start": "1395040",
    "end": "1403490"
  },
  {
    "text": "and the time it takes\nto evaluate this, ignoring the recursive calls. That's important.",
    "start": "1403490",
    "end": "1408980"
  },
  {
    "text": "This is the non recursive part. ",
    "start": "1408980",
    "end": "1418139"
  },
  {
    "text": "In the notes, I call\nthis non-recursive work. ",
    "start": "1418140",
    "end": "1425700"
  },
  {
    "text": "So this formula gives\nus a way to bound the running time of\none of these algorithms",
    "start": "1425700",
    "end": "1432240"
  },
  {
    "text": "if we use memoization. Without memoization,\nthis is not true, Fibonacci to exponential time.",
    "start": "1432240",
    "end": "1437730"
  },
  {
    "text": "But if we add memoization,\nwe know that we only solve each sub-problem once. And so we just need\nto see, for each one,",
    "start": "1437730",
    "end": "1443670"
  },
  {
    "text": "how much did it cost\nme to compute it, assuming all the\nrecursion work is free, because that's already taken\ninto account by the summation.",
    "start": "1443670",
    "end": "1451178"
  },
  {
    "text": "So in particular, this\nsummation is at most the number of sub-problems\ntimes the time per sub-problem, which in this case was order n.",
    "start": "1451178",
    "end": "1457500"
  },
  {
    "start": "1456000",
    "end": "1581000"
  },
  {
    "text": "We could try to apply that\nanalysis to merge sort, because after all, this is\nalso a recursive algorithm.",
    "start": "1457500",
    "end": "1463830"
  },
  {
    "text": "It happens to not\nbenefit from memoization. But we could throw\nin memoization. It wouldn't hurt us.",
    "start": "1463830",
    "end": "1469230"
  },
  {
    "text": "But if you think about\nthe call graph here, which is like s of 0\nm, which calls s of m--",
    "start": "1469230",
    "end": "1478500"
  },
  {
    "text": "0 n over 2 and o of\nn over 2n and so on.",
    "start": "1478500",
    "end": "1485610"
  },
  {
    "text": "It has the same picture,\nbut there's actually no common substructure here. You'll never see a\nrepeated sub-problem,",
    "start": "1485610",
    "end": "1491520"
  },
  {
    "text": "because this range is completely\ndisjoined from this range. But you could throw\nin memoization",
    "start": "1491520",
    "end": "1496980"
  },
  {
    "text": "and try to analyze\nin the same way and say, well, how many\nsub-problems are there? It looks like there's n choices\nfor i and not quite n choices",
    "start": "1496980",
    "end": "1507570"
  },
  {
    "text": "but it's at most n\nsquared different choices. In fact, it's the triangular\nnumber sum of i equals 1 to n",
    "start": "1507570",
    "end": "1516755"
  },
  {
    "text": "of i, different possible\nchoices for inj. But this is theta n\nsquared sub-problems,",
    "start": "1516755",
    "end": "1524780"
  },
  {
    "text": "which seems not so good. And then how much time are\nwe spending per sub problem?",
    "start": "1524780",
    "end": "1529960"
  },
  {
    "text": "Well, to solve s of\nij, we have to merge about that many elements.",
    "start": "1529960",
    "end": "1535140"
  },
  {
    "text": "We know merge takes linear time. And so this takes theta j\nminus i time to evaluate.",
    "start": "1535140",
    "end": "1543420"
  },
  {
    "text": "And so what we'd like to\ndo is sum over all the sub problems of j minus i. This is the not\ntriangular number",
    "start": "1543420",
    "end": "1551130"
  },
  {
    "text": "but the tetrahedral\nnumber, I guess. And so we end up\nthat the running time is, at most, n cubed.",
    "start": "1551130",
    "end": "1558044"
  },
  {
    "text": " Great. So it's true that n log n is\nless than or equal to n cubed,",
    "start": "1558045",
    "end": "1565950"
  },
  {
    "text": "but obviously not\nterribly useful. This algorithm by the way we\nalready know how to analyze it",
    "start": "1565950",
    "end": "1571200"
  },
  {
    "text": "is, indeed, n log n. And the running time turns\nout to be theta n log n.",
    "start": "1571200",
    "end": "1577059"
  },
  {
    "text": "So sometimes this equation\nis not what you want to use. But often it's good enough.",
    "start": "1577060",
    "end": "1582277"
  },
  {
    "text": "And especially if\nyou just want to get a polynomial upper\nbound, then you can try to optimize it later. This will give you\na polynomial upper",
    "start": "1582277",
    "end": "1588750"
  },
  {
    "text": "bound as long as the number\nof sub-problems is polynomial and the time per\nsub-problem is polynomial.",
    "start": "1588750",
    "end": "1594000"
  },
  {
    "text": "And indeed, n cubed\nis polynomial. It's not a great polynomial,\nbut this is an alternate way",
    "start": "1594000",
    "end": "1599550"
  },
  {
    "text": "to analyze merge sort. Obviously don't do\nthis for merge sort. But it illustrates\nthe technique.",
    "start": "1599550",
    "end": "1607586"
  },
  {
    "text": "Good so far? Any questions? All right.",
    "start": "1607586",
    "end": "1612760"
  },
  {
    "text": "Let me remember where we are. Cool.",
    "start": "1612760",
    "end": "1618190"
  },
  {
    "text": "So the next thing I'd like to do\nis show you one more algorithm that we've already seen in\nthis class that fits very",
    "start": "1618190",
    "end": "1624640"
  },
  {
    "text": "nicely into this structure-- arguably is a dynamic program-- and that is DAG shortest paths.",
    "start": "1624640",
    "end": "1633050"
  },
  {
    "text": "So just to close the loop here,\nwhen I say dynamic programming, I mean recursion\nwith memoization.",
    "start": "1633050",
    "end": "1641980"
  },
  {
    "text": "I mean, we take-- we write a recursive\npiece of code,",
    "start": "1641980",
    "end": "1648250"
  },
  {
    "text": "which is like def\nf of some args, some sub-problem specification.",
    "start": "1648250",
    "end": "1658150"
  },
  {
    "text": "We check is the problem\nin the memo table?",
    "start": "1658150",
    "end": "1664870"
  },
  {
    "text": "If so, return memo\nof sub-problem.",
    "start": "1664870",
    "end": "1672379"
  },
  {
    "text": " And otherwise check\nif it's a base case",
    "start": "1672379",
    "end": "1681460"
  },
  {
    "text": "and solve it if\nit's a base case. And otherwise, write\nthe recurrence recurse",
    "start": "1681460",
    "end": "1689660"
  },
  {
    "text": "via relation. ",
    "start": "1689660",
    "end": "1694720"
  },
  {
    "text": "And set the memo table\nof the sub-problem",
    "start": "1694720",
    "end": "1700600"
  },
  {
    "text": "to be one of those things. OK, so this is the\ngeneric dynamic program.",
    "start": "1700600",
    "end": "1706300"
  },
  {
    "text": "And implicitly, I'm writing\nFibonacci in that way.",
    "start": "1706300",
    "end": "1712090"
  },
  {
    "text": "And all of the dynamic programs\nhave this implicit structure where I start with a\nmemo table which is empty",
    "start": "1712090",
    "end": "1721059"
  },
  {
    "text": "and I always just check\nif I'm in the memo table. If I am, I return it. Otherwise I compute according\nto this recursive relation",
    "start": "1721060",
    "end": "1730570"
  },
  {
    "text": "by recursively calling f. And that's it. So this is every DP algorithm\nis going to have that structure.",
    "start": "1730570",
    "end": "1740450"
  },
  {
    "text": "And it's just using recursion\nand memoization together. OK, so now let's\napply that technique",
    "start": "1740450",
    "end": "1746929"
  },
  {
    "text": "to think about the DAG\nshortest paths problem. The problem was,\nI give you a DAG.",
    "start": "1746930",
    "end": "1752780"
  },
  {
    "text": "I give you a source vertex, S-- single source shortest paths. Compute the shortest path\nweight from S to every vertex.",
    "start": "1752780",
    "end": "1760490"
  },
  {
    "text": "That's the goal of the problem. And we saw a way to solve\nthat, which is DAG relaxation. I'm going to show you a\ndifferent way, which turns out",
    "start": "1760490",
    "end": "1767030"
  },
  {
    "text": "to be basically the same, but\nupside down, or flipped left right, depending which\nway you direct your edges.",
    "start": "1767030",
    "end": "1775650"
  },
  {
    "text": "So what are our sub-problems? Well, here, actually, they're\nkind of spelled out for us. We want to compute delta\nand SV for all these.",
    "start": "1775650",
    "end": "1782630"
  },
  {
    "text": "So that is size of\nthese sub-problems. That turns out to be enough\nfor this overall problem.",
    "start": "1782630",
    "end": "1791872"
  },
  {
    "text": "And the original\nproblem we want to solve is all of the sub-problems. We solve all the\nsub-problems, we're done.",
    "start": "1791872",
    "end": "1797000"
  },
  {
    "text": "And then we have-- I think we wrote this at\nsome point during the DAG",
    "start": "1797000",
    "end": "1802100"
  },
  {
    "text": "shortest paths lecture-- we have a recursive\nrelation saying that the shortest way\nto get from s to v",
    "start": "1802100",
    "end": "1809150"
  },
  {
    "text": "is the minimum of\nthe shortest path to get to some vertex u plus the\nweight of the edge from u to v.",
    "start": "1809150",
    "end": "1816230"
  },
  {
    "text": "Why? Because if we look at a vertex\nv, unless we started there, we came from somewhere.",
    "start": "1816230",
    "end": "1823250"
  },
  {
    "text": "And so we can consider all\nof the possible choices for the previous vertex u.",
    "start": "1823250",
    "end": "1830030"
  },
  {
    "text": "And if you start\nat s and get to v, you must go through one of them. And so this is finding the best\nway among all the choices of u.",
    "start": "1830030",
    "end": "1839317"
  },
  {
    "text": "What's the best way to get to u? And then take the edge from\nu to v for all edges uv.",
    "start": "1839317",
    "end": "1844400"
  },
  {
    "text": "And this is adjacency minus. We don't usually think of that. Usually we look at adjacency\nplus the outgoing edges.",
    "start": "1844400",
    "end": "1851040"
  },
  {
    "text": "This is the incoming edges. And so u is an incoming-- uv is an incoming edge into v.\nOK, if we take that minimum--",
    "start": "1851040",
    "end": "1859940"
  },
  {
    "text": "and of course, possible\nthere is no way to get to v. And so I'll also throw\ninfinity into the set.",
    "start": "1859940",
    "end": "1866000"
  },
  {
    "text": "Take the min of that set. That will give me\nthe shortest pathway in an acyclic graph from s to\nv. And great, this is recursive.",
    "start": "1866000",
    "end": "1873740"
  },
  {
    "text": "This was a sub problem. These are sub problems\nwhich are smaller, I guess.",
    "start": "1873740",
    "end": "1879612"
  },
  {
    "text": "There's no clear\nnotion of smaller here, except we already know\nthe clear notion of smaller",
    "start": "1879613",
    "end": "1885410"
  },
  {
    "text": "is the topological\norder of our DAG.",
    "start": "1885410",
    "end": "1890608"
  },
  {
    "text": "Because our graph\nis acyclic, we know it has a topological order. We know how to\ncompute it with DFS.",
    "start": "1890608",
    "end": "1896380"
  },
  {
    "text": "And so that guarantees\nthere's a topological order to compute these problems.",
    "start": "1896380",
    "end": "1901850"
  },
  {
    "text": "And in fact, the\nrelationship between problems",
    "start": "1901850",
    "end": "1906880"
  },
  {
    "text": "is exactly the given\ngraph, G. In order to compute the shortest\npathway from s to v,",
    "start": "1906880",
    "end": "1914290"
  },
  {
    "text": "I need to know the\nshortest pathway from s to all of the incoming\nvertices to v. And so this is I guess\nin the call graph,",
    "start": "1914290",
    "end": "1922210"
  },
  {
    "text": "this vertex calls this vertex,\nbut direct the edge this way",
    "start": "1922210",
    "end": "1927669"
  },
  {
    "text": "to say that this\nvertex requires-- this vertex needs to be\ncomputed before this one.",
    "start": "1927670",
    "end": "1934840"
  },
  {
    "text": "And so then I can complete\nthem in a topological order. OK, we have a base case,\nwhich is delta of ss equals 0.",
    "start": "1934840",
    "end": "1942770"
  },
  {
    "text": "And the running time is,\nagain, we can use this formula and say, let's just sum over\nall the sub problems of the non",
    "start": "1942770",
    "end": "1949910"
  },
  {
    "text": "recursive work in our\nrecurrence relation and so it's computing this min. If I gave you these\ndeltas for free",
    "start": "1949910",
    "end": "1958640"
  },
  {
    "text": "and I gave you these weights,\nwhich we know from our weight data structure, how long does\nit take to compute this min?",
    "start": "1958640",
    "end": "1964430"
  },
  {
    "text": "Well, however many\nthings there are, however many numbers we're\nminning, which is the size of the incoming\nadjacency list plus 1",
    "start": "1964430",
    "end": "1972500"
  },
  {
    "text": "for that infinity. And so if you compute this\nsum, sum of incoming edges to every vertex,\nthat's all the edges.",
    "start": "1972500",
    "end": "1980149"
  },
  {
    "text": "So this is v plus e. So in fact, this algorithm\nis morally the same algorithm",
    "start": "1980150",
    "end": "1989332"
  },
  {
    "text": "as the one that we saw\non the DAG shortest path lecture, which was compute a\ntopological order and process",
    "start": "1989332",
    "end": "1998070"
  },
  {
    "text": "vertices in that order and relax\nedges going out from vertices.",
    "start": "1998070",
    "end": "2003840"
  },
  {
    "text": "So here-- so in\nthat algorithm, we would have tried to relax this\nedge if there was a better",
    "start": "2003840",
    "end": "2010309"
  },
  {
    "text": "path to v. And the\nfirst one certainly is better than infinity. So the first one\nwe relax indeed.",
    "start": "2010310",
    "end": "2016850"
  },
  {
    "text": "The next edge, if this gave\na better path from s to v, then we would relax that\nedge and update the way here",
    "start": "2016850",
    "end": "2022400"
  },
  {
    "text": "and do the same here. In the end, we're just computing\nthis min in the relaxation algorithm but doing\nit step by step.",
    "start": "2022400",
    "end": "2028490"
  },
  {
    "text": "In the relaxation\nalgorithm, DAG relaxation, for each incoming edge to v, we\nupdate d of e if it's better.",
    "start": "2028490",
    "end": "2038920"
  },
  {
    "text": "And so if you repeatedly\nupdate if you're better, that ends up computing a min.",
    "start": "2038920",
    "end": "2044390"
  },
  {
    "text": "OK, so this is\nthe same algorithm just kind of flipped backwards. A funny thing,\nalthough we wrote down",
    "start": "2044390",
    "end": "2051199"
  },
  {
    "text": "the topological order\nof the sub problem graph here is the\ntopological order of g,",
    "start": "2051199",
    "end": "2056869"
  },
  {
    "text": "because the\nsub-problem graph is g,",
    "start": "2056870",
    "end": "2062030"
  },
  {
    "text": "the algorithm doesn't\nactually have to compute one. It's doing it\nautomatically for free. If you think about\nthis algorithm,",
    "start": "2062030",
    "end": "2071000"
  },
  {
    "text": "generic dp algorithm,\nwhich is check whether we're in a memo table. If so, return.",
    "start": "2071000",
    "end": "2076969"
  },
  {
    "text": "Otherwise, recurse,\nor base case. This actually is a\ndepth-first search",
    "start": "2076969",
    "end": "2083210"
  },
  {
    "text": "through the sub-problem graph--\ntechnically through the reverse of the sub-problem graph.",
    "start": "2083210",
    "end": "2088369"
  },
  {
    "text": "If I draw an edge-- so from small to big--",
    "start": "2088370",
    "end": "2098349"
  },
  {
    "text": "so I'm just saying, I orient\nthe edges from my smaller sub-problems to the\nones that need it--",
    "start": "2098350",
    "end": "2104320"
  },
  {
    "text": "then I'm actually depth-first\nsearching backwards in this graph because the\nbigger problem calls the smaller",
    "start": "2104320",
    "end": "2110470"
  },
  {
    "text": "problem. And the memo table is serving as\nthe \"have I visited this vertex",
    "start": "2110470",
    "end": "2116110"
  },
  {
    "text": "already\" check in DFS. So this is actually\na DFS algorithm. Plus we're doing some\ncomputation to actually solve",
    "start": "2116110",
    "end": "2124839"
  },
  {
    "text": "the sub-problems we care about. So implicit in this\nalgorithm, we are doing a DFS, and at the same time, we're\ndoing this shortest path",
    "start": "2124840",
    "end": "2132430"
  },
  {
    "text": "computation in the finishing\norder of that DFS traversal",
    "start": "2132430",
    "end": "2137720"
  },
  {
    "text": "because all the\nedges are backwards. This is the same as the\nreverse finishing order if the graph is forwards. So in the end, we're\ncomputing a topological order",
    "start": "2137720",
    "end": "2146320"
  },
  {
    "text": "because dynamic\nprogramming includes in it depth first search.",
    "start": "2146320",
    "end": "2152440"
  },
  {
    "text": "A lot of words. But it's kind of cool\nthat this framework just",
    "start": "2152440",
    "end": "2157900"
  },
  {
    "text": "solves DAG shortest\npaths without much work. I mean, we did a lot of\nwork in shortest paths",
    "start": "2157900",
    "end": "2164050"
  },
  {
    "text": "to prove that this\nrelation is true. Once you know it's\ntrue, the algorithm part is pretty much free.",
    "start": "2164050",
    "end": "2171280"
  },
  {
    "text": "You just write down\nSRTBOT and you're done. OK.",
    "start": "2171280",
    "end": "2178420"
  },
  {
    "text": "This brings us to in general--",
    "start": "2178420",
    "end": "2184099"
  },
  {
    "text": "at this point we have\nseen two examples of dynamic programming. I guess technically\nmerge sort you could think of as\na dynamic program,",
    "start": "2184100",
    "end": "2190130"
  },
  {
    "text": "but it doesn't actually\nreuse anything. So it's not interesting. And indeed, that gave\nus a really bad bound. We've definitely seen DAG\nshortest paths and Fibonacci",
    "start": "2190130",
    "end": "2197210"
  },
  {
    "text": "numbers as two\ninteresting examples. And what the next remainder of\nthis lecture and the next three",
    "start": "2197210",
    "end": "2203089"
  },
  {
    "text": "lectures are going to be about\nis more and more examples of dynamic programming\nand how you",
    "start": "2203090",
    "end": "2208580"
  },
  {
    "text": "can use it to solve\nincreasingly general problems. So far, we've just solved an\neasy problem and a problem",
    "start": "2208580",
    "end": "2213740"
  },
  {
    "text": "we already knew how to solve. Let's go to a new\nproblem, which is bowling.",
    "start": "2213740",
    "end": "2222680"
  },
  {
    "text": "Bowling is popular in Boston.  Boston likes to play\ncandlepin bowling, which",
    "start": "2222680",
    "end": "2230390"
  },
  {
    "text": "is a bit unusual. Today we're going to play\nan even more unusual bowling game, one that I made up\nbased on a bowling game",
    "start": "2230390",
    "end": "2239120"
  },
  {
    "text": "that Henry [INAUDIBLE]\nmade up in 1908. So ancient bowling,\nI'll call it,",
    "start": "2239120",
    "end": "2246109"
  },
  {
    "text": "or I think linear bowling\nis what I might call it. I'll just call it bowling here.",
    "start": "2246110",
    "end": "2251930"
  },
  {
    "text": "And now I'm going to attempt\nto draw a bowling pin. Not bad. They might get\nprogressively worse.",
    "start": "2251930",
    "end": "2259450"
  },
  {
    "text": "So imagine n identical\nbowling pins. Please pretend\nthese are identical. And I have a ball which is\napproximately the same size",
    "start": "2259450",
    "end": "2269020"
  },
  {
    "text": "as a bowling pin. These bowling pins are\npretty close together. I should have left\na little gap here.",
    "start": "2269020",
    "end": "2274720"
  },
  {
    "text": "And you are a\nreally good bowler. Now, unfortunately, these\nbowling pins are on a line.",
    "start": "2274720",
    "end": "2280810"
  },
  {
    "text": "And you're bowling from\nway down at infinity. So when you bowl, you\ncan only hit one pin",
    "start": "2280810",
    "end": "2288849"
  },
  {
    "text": "or two pins or zero pins. But probably you want\nto hit some pins. So if you bowl\nstraight out of pin,",
    "start": "2288850",
    "end": "2294970"
  },
  {
    "start": "2293000",
    "end": "2492000"
  },
  {
    "text": "you will just hit that one pin. And if you bowl in the\nmiddle between two pins,",
    "start": "2294970",
    "end": "2300700"
  },
  {
    "text": "you will knock down-- that's a ball, sorry-- you will knock down two pins.",
    "start": "2300700",
    "end": "2306010"
  },
  {
    "text": "And this is your model of\nbowling, model of computation. Now, what makes this interesting\nis that the pins have values.",
    "start": "2306010",
    "end": "2316060"
  },
  {
    "text": "Pin i has value-- this is obviously a toy\nproblem, though this problem--",
    "start": "2316060",
    "end": "2324339"
  },
  {
    "text": "this type of bowling\ndoes go back to 1908, it was also a toy\nproblem in that setting.",
    "start": "2324340",
    "end": "2330530"
  },
  {
    "text": "So each of these bowling\npins has some number on it,",
    "start": "2330530",
    "end": "2335590"
  },
  {
    "text": "let's say 1, 9, 9-- ",
    "start": "2335590",
    "end": "2341407"
  },
  {
    "text": "I'll do a slightly more\ninteresting example, maybe another one here and a\n2 and a 5 and a 5, something",
    "start": "2341407",
    "end": "2351130"
  },
  {
    "text": "like this. OK. Or maybe make it a\nlittle more interesting.",
    "start": "2351130",
    "end": "2357060"
  },
  {
    "text": "Let's put some negative\nnumbers on here. OK. And the model-- so you're\nat the carnival bowling.",
    "start": "2357060",
    "end": "2364160"
  },
  {
    "text": "Each pin has different--\npotentially different values. And the model is if you hit one\npin, i, then you get vi points.",
    "start": "2364160",
    "end": "2378350"
  },
  {
    "text": "So that's straight forward. To make it interesting,\nwhen you hit two pins, you get the product.",
    "start": "2378350",
    "end": "2385345"
  },
  {
    "text": "So if I hit two\npins, it's always i and i plus 1 for some I. You\nget vi times vi plus 1 points.",
    "start": "2385345",
    "end": "2393095"
  },
  {
    "text": " This is the game you're playing. And it doesn't really matter\nthat this is a product.",
    "start": "2393095",
    "end": "2400774"
  },
  {
    "text": "Product is just\nsome weird function that's hard to imagine. If you stare at\nthis long enough,",
    "start": "2400774",
    "end": "2407510"
  },
  {
    "text": "you should convince yourself\nthat the optimal solution is probably to-- so, for each of these\nnumbers, I could",
    "start": "2407510",
    "end": "2413330"
  },
  {
    "text": "leave it singleton or pair\nit with its left neighbor or pair it with\nits right neighbor. But the pairings can't overlap\nbecause once I hit a pin,",
    "start": "2413330",
    "end": "2419630"
  },
  {
    "text": "it's gone. It's knocked over. It disappears. So because of these nine, which\nare a very high value, what",
    "start": "2419630",
    "end": "2426410"
  },
  {
    "text": "I'd probably like to do is\nhit both of them together, so pair them up,\nbecause 9 times 9 is 81.",
    "start": "2426410",
    "end": "2432268"
  },
  {
    "text": "That's really big, much better\nthan hitting them individually or hitting 9 times\n1 or 9 times 2.",
    "start": "2432268",
    "end": "2437810"
  },
  {
    "text": "1 and 1 is kind of funny,\nbecause it's actually better to hit them individually. That will give you two points,\nwhereas if I'd pair them up,",
    "start": "2437810",
    "end": "2443900"
  },
  {
    "text": "I only get one point. 2 and minus 5, that seems bad. Negative 10 points.",
    "start": "2443900",
    "end": "2448940"
  },
  {
    "text": "My goal is to maximize score. ",
    "start": "2448940",
    "end": "2456980"
  },
  {
    "text": "Do you have to hit all the pins? Let's say no, you don't\nhave to hit all the pins.",
    "start": "2456980",
    "end": "2462470"
  },
  {
    "text": "So I could skip the minus fives. But in fact, here,\nbecause they're adjacent,",
    "start": "2462470",
    "end": "2467780"
  },
  {
    "text": "minus 5 times minus 5 is good. That's 25 points. So the optimal solution for\nthis particular instance",
    "start": "2467780",
    "end": "2474740"
  },
  {
    "text": "are to hit all the\npins, these positive, these together, these together.",
    "start": "2474740",
    "end": "2479990"
  },
  {
    "text": "If I added, for example,\nanother pin of minus 3 here, I would choose not\nto hit that pin.",
    "start": "2479990",
    "end": "2485599"
  },
  {
    "text": "Good question. So you just play\nuntil you are tired. When you decide to stop playing,\nhow can I maximize your score?",
    "start": "2485600",
    "end": "2492950"
  },
  {
    "start": "2492000",
    "end": "2710000"
  },
  {
    "text": "There are many\nvariations of this game. All of them-- basically\nany variation-- not literally every\nvariation, but many,",
    "start": "2492950",
    "end": "2500040"
  },
  {
    "text": "many variations of this problem\ncan all be solved quickly with dynamic programming. But let's solve\nthis particular one.",
    "start": "2500040",
    "end": "2507950"
  },
  {
    "text": "OK. ",
    "start": "2507950",
    "end": "2514980"
  },
  {
    "text": "So now we're really in\nalgorithmic design mode. We need to think about SRTBOT.",
    "start": "2514980",
    "end": "2521599"
  },
  {
    "text": "And in particular, we need to\nthink about what would the sub problems be here? And at this point, we\ndon't have a lot of help.",
    "start": "2521600",
    "end": "2528550"
  },
  {
    "text": "So I should probably\ngive you some tools. If I want to solve\na problem like this, the input is a\nsequence of numbers.",
    "start": "2528550",
    "end": "2538050"
  },
  {
    "text": "It's a sequenced data structure. Maybe it's an array of\nnumbers, which is this v array.",
    "start": "2538050",
    "end": "2543839"
  },
  {
    "text": " And let's see.",
    "start": "2543840",
    "end": "2548910"
  },
  {
    "text": " A general tool for\nsub-problem design",
    "start": "2548910",
    "end": "2559670"
  },
  {
    "text": "which will cover most of\nthe problems-- maybe all of the problems that\nwe see in this class",
    "start": "2559670",
    "end": "2565069"
  },
  {
    "text": "for dynamic programming. Here's a trick. If your input is a sequence,\nhere are some good sub-problems",
    "start": "2565070",
    "end": "2583734"
  },
  {
    "text": "to consider. ",
    "start": "2583735",
    "end": "2593070"
  },
  {
    "text": "We could do all prefixes. ",
    "start": "2593070",
    "end": "2598210"
  },
  {
    "text": "So let's call the sequence x. So we could do x prefix means\nup to a given i for all i.",
    "start": "2598210",
    "end": "2607710"
  },
  {
    "text": "We could do all the suffixes,\nx from i onward for all i.",
    "start": "2607710",
    "end": "2614880"
  },
  {
    "text": "Or we could do substrings,\nwhich are the consecutive items",
    "start": "2614880",
    "end": "2621299"
  },
  {
    "text": "from i to j. I don't write subsequence here. Subsequence means you can\nomit items in the middle.",
    "start": "2621300",
    "end": "2626955"
  },
  {
    "text": "So substring you have to\nstart in some position and do all the things up to j. So these are nice, easy to\nexpress in Python notation.",
    "start": "2626955",
    "end": "2635240"
  },
  {
    "text": "And these are great,\nbecause they're polynomial. If I have n things-- if the length of my\nsequence, x, is n,",
    "start": "2635240",
    "end": "2642170"
  },
  {
    "text": "then there are n prefixes--\ntechnically n plus 1. So let's do theta n prefixes.",
    "start": "2642170",
    "end": "2648350"
  },
  {
    "text": "There are theta n suffixes. And there are theta\nn squared substrings",
    "start": "2648350",
    "end": "2654290"
  },
  {
    "text": "because there's n-- roughly n\nchoices for i and j separately. Sorry?",
    "start": "2654290",
    "end": "2661070"
  },
  {
    "text": "Sub-sequences. Good. Right. I didn't write sub-sequences,\nbecause in fact, there are exponentially\nmany sub sequences.",
    "start": "2661070",
    "end": "2666740"
  },
  {
    "text": "It's 2 to the n. For every item, I\ncould choose it or not. So I don't want\nto parameterize--",
    "start": "2666740",
    "end": "2671900"
  },
  {
    "text": "I don't want my sub problems to\nbe sub sequences because that's guaranteed-- well,\nthen you're guaranteed",
    "start": "2671900",
    "end": "2677420"
  },
  {
    "text": "to get an exponential number\nof sub-problems, which is bad. We'd like to balance the numbers\nof sub-problems by polynomial.",
    "start": "2677420",
    "end": "2683540"
  },
  {
    "text": "So these are three natural\nways to get polynomial bounds. Now, prefixes and suffixes\nare obviously better",
    "start": "2683540",
    "end": "2690110"
  },
  {
    "text": "because there's fewer of them,\nlinear instead of quadratic. And usually almost every\nproblem you encounter,",
    "start": "2690110",
    "end": "2696650"
  },
  {
    "text": "prefixes and suffixes\nare equally good. It doesn't really matter\nwhich one you choose. So maybe you'd\nlike to think of--",
    "start": "2696650",
    "end": "2703270"
  },
  {
    "text": "well, we'll get to--  just choose whichever is\nmore comfortable for you.",
    "start": "2703270",
    "end": "2711180"
  },
  {
    "start": "2710000",
    "end": "3126000"
  },
  {
    "text": "But sometimes it's not enough. And we'll have to\ngo to substrings. That won't be for\nanother lecture or two.",
    "start": "2711180",
    "end": "2716300"
  },
  {
    "text": "Today I claim that\nprefixes or suffixes are enough to solve\nthe bowling problem.",
    "start": "2716300",
    "end": "2724830"
  },
  {
    "text": "So what we're going\nto do is think about-- I prefer suffixes\nusually, because I like to work from left to right,\nfrom the beginning to the end.",
    "start": "2724830",
    "end": "2732810"
  },
  {
    "text": "So we're going to think of a\nsuffix of the bowling pins. And so what is the\nsub-problem on a suffix?",
    "start": "2732810",
    "end": "2739770"
  },
  {
    "text": "Well, a natural version is just\nto solve the original problem, bowling. How do I maximize my\nscore if all I were given",
    "start": "2739770",
    "end": "2746600"
  },
  {
    "text": "were these pins? Suppose the pins to the\nleft of i didn't exist. How would I maximize my\nscore on the remaining pins?",
    "start": "2746600",
    "end": "2753349"
  },
  {
    "text": "Or for this suffix, given these\nfour pins, what would I do? And there's some weird\nsub problems here. If I just gave you the last\npin, what would you do?",
    "start": "2753350",
    "end": "2760460"
  },
  {
    "text": "Nothing. That's clearly different from\nwhat I would do globally here. But I claim if I can\nsolve all suffixes",
    "start": "2760460",
    "end": "2766430"
  },
  {
    "text": "I can solve my original problem,\nbecause one of the suffixes is the whole sequence.",
    "start": "2766430",
    "end": "2771454"
  },
  {
    "text": " So let's do it. ",
    "start": "2771455",
    "end": "2778430"
  },
  {
    "text": "Sort by for bowling. ",
    "start": "2778430",
    "end": "2786330"
  },
  {
    "text": "So here is our dynamic program. The sub-problems are suffixes.",
    "start": "2786330",
    "end": "2794020"
  },
  {
    "text": "So I'll write b of i is the\nmaximum score we could get",
    "start": "2794020",
    "end": "2802960"
  },
  {
    "text": "possible with our starting--",
    "start": "2802960",
    "end": "2810430"
  },
  {
    "text": "if we started a game with pins\ni, i plus 1, up to n minus 1,",
    "start": "2810430",
    "end": "2820540"
  },
  {
    "text": "which is a suffix of the pins. Very important whenever\nyou write a dynamic program to define what your\nsub-problems are.",
    "start": "2820540",
    "end": "2826540"
  },
  {
    "text": "Don't just say how\nto compute them, but first say what is the\ngoal of the sub problem. This is a common mistake\nto forget to state",
    "start": "2826540",
    "end": "2833230"
  },
  {
    "text": "what you're trying to do. So now I have defined b of i.",
    "start": "2833230",
    "end": "2838859"
  },
  {
    "text": "Now, what is the original\nthing I'm trying to solve? You also put in SRTBOT--",
    "start": "2838860",
    "end": "2844529"
  },
  {
    "text": "you could put the O earlier,\nthen it actually spells sort. So why don't I do that for fun.",
    "start": "2844530",
    "end": "2850020"
  },
  {
    "text": "The original problem we're\ntrying to solve is b of 0,",
    "start": "2850020",
    "end": "2855420"
  },
  {
    "text": "because that is all of the pins. The suffix starting\nat 0 is everything. So if we can solve\nthat, we're done.",
    "start": "2855420",
    "end": "2862720"
  },
  {
    "text": "Next is r for relate. This is the test of, did I\nget the sub-problems right,",
    "start": "2862720",
    "end": "2869340"
  },
  {
    "text": "is whether I can write\na recurrence relation. So let's try to do it.",
    "start": "2869340",
    "end": "2874410"
  },
  {
    "text": "We want to compute b of i. So we have pin i here and\nthen the remaining pins.",
    "start": "2874410",
    "end": "2884220"
  },
  {
    "text": " And the big idea here\nis to just think about--",
    "start": "2884220",
    "end": "2890789"
  },
  {
    "text": "the nice thing about\nsuffixes is if I take off something from the beginning,\nI still have a suffix.",
    "start": "2890790",
    "end": "2895973"
  },
  {
    "text": "Remember, my goal is to\ntake this sub-problem, which is suffix starting\nat i, and reduce it to a smaller sub problem,\nwhich means a smaller suffix.",
    "start": "2895973",
    "end": "2903780"
  },
  {
    "text": "So I'd like to clip off\none or two items here. And then the remaining problem\nwill be one of my sub problems.",
    "start": "2903780",
    "end": "2913770"
  },
  {
    "text": "I'll be able to recursively call\nb of something smaller than i-- or sorry, b of\nsomething larger than i",
    "start": "2913770",
    "end": "2919650"
  },
  {
    "text": "will be a smaller subsequence\nbecause we're starting later. OK, so what could I do?",
    "start": "2919650",
    "end": "2924910"
  },
  {
    "text": "Well, the idea is to\njust look at pin i and think, well, what\ncould I do to pin i?",
    "start": "2924910",
    "end": "2930000"
  },
  {
    "text": "I could not hit it\never with a ball. I could skip it. That's one option. What would be my score then?",
    "start": "2930000",
    "end": "2937720"
  },
  {
    "text": "Well, if I skip pin i, that\nleaves the remaining pins,",
    "start": "2937720",
    "end": "2942820"
  },
  {
    "text": "which is just a smaller suffix. So that is b of i plus 1.",
    "start": "2942820",
    "end": "2948829"
  },
  {
    "text": "I'm going to write\na max out here because I'd like to\nmaximize my score. And one of the options\nis, forget about pin i.",
    "start": "2948830",
    "end": "2954190"
  },
  {
    "text": "Just solve the rest. Another option is\nI throw a ball. And I exactly hit pin i.",
    "start": "2954190",
    "end": "2961539"
  },
  {
    "text": "That's one thing I could do. And it would leave exactly\nthe same remainder. So another option is\nb of i plus 1 plus vi.",
    "start": "2961540",
    "end": "2974619"
  },
  {
    "text": "Why would I prefer\nthis over this? Well, if vi is negative,\nI'd prefer this.",
    "start": "2974620",
    "end": "2979880"
  },
  {
    "text": "But if vi is positive, I'd\nactually prefer this over that. So you can figure out which\nis better, just locally.",
    "start": "2979880",
    "end": "2987723"
  },
  {
    "text": "But then there's\nanother thing I can do, which is maybe I hit this pin\nin a pair with some other pin.",
    "start": "2987723",
    "end": "2994327"
  },
  {
    "text": "Now, there's no pin to\nthe left of this one. We're assuming we\nonly have the suffix. And so the only other thing\nI can do is throw a ball",
    "start": "2994327",
    "end": "3001470"
  },
  {
    "text": "and hit i together\nwith i plus 1. And then I get the product. Now, what pins remain?",
    "start": "3001470",
    "end": "3007110"
  },
  {
    "text": "i plus 2 on. Still a suffix. So if I remove one or\ntwo items, of course,",
    "start": "3007110",
    "end": "3012119"
  },
  {
    "text": "I still get a suffix-- in this case, b of i plus 2-- and then the number of\npoints that I add on",
    "start": "3012120",
    "end": "3018300"
  },
  {
    "text": "are vi times vi plus 1. So this is a max\nof three things.",
    "start": "3018300",
    "end": "3026119"
  },
  {
    "text": "So how long does it\ntake me to compute it? I claim constant time. If I don't count\nthe time it takes",
    "start": "3026120",
    "end": "3031830"
  },
  {
    "text": "to compute these other\nsub problems, which are smaller because they\nare smaller suffixes further",
    "start": "3031830",
    "end": "3037150"
  },
  {
    "text": "to the right, then\nI'm doing a couple of additions-- product, max.",
    "start": "3037150",
    "end": "3042370"
  },
  {
    "text": "These are all nice\nnumbers and I'll assume that they live\nin the w-bit word,",
    "start": "3042370",
    "end": "3048028"
  },
  {
    "text": "because we're only doing\nconstant sized products. That's good. So this takes constant,\nconstant non-recursive work.",
    "start": "3048028",
    "end": "3056619"
  },
  {
    "text": "How many sub problems are? Well, it's suffixes, so it's a\nlinear number of sub problems. And so the time\nI'm going to end up",
    "start": "3056620",
    "end": "3063359"
  },
  {
    "text": "needing is number\nof sub problems, n, times the non-recursive work\nI do per sub problem, which",
    "start": "3063360",
    "end": "3071460"
  },
  {
    "text": "is constant. And so this is linear time. Great.",
    "start": "3071460",
    "end": "3076829"
  },
  {
    "text": "And I didn't finish\nSRTBOT, so there's another t, which is to\nmake sure that there is a topological order and\nthat is in decreasing i order.",
    "start": "3076830",
    "end": "3087450"
  },
  {
    "text": " Or I might write\nthat as a for loop--",
    "start": "3087450",
    "end": "3093869"
  },
  {
    "text": "for i equals n, n minus 1. This is the order that I\nwould compute my problems",
    "start": "3093870",
    "end": "3101610"
  },
  {
    "text": "because the suffix starting\nat n is the empty suffix. The suffix starting at 0,\nthat's the one I actually",
    "start": "3101610",
    "end": "3106950"
  },
  {
    "text": "want to compute. That's the final suffix\nI should be computing. And then we have\na b for base case,",
    "start": "3106950",
    "end": "3113830"
  },
  {
    "text": "which is that first\ncase, b of n equals 0,",
    "start": "3113830",
    "end": "3120960"
  },
  {
    "text": "because there's no pins. So I don't get any points. Sad. ",
    "start": "3120960",
    "end": "3127920"
  },
  {
    "start": "3126000",
    "end": "3437000"
  },
  {
    "text": "OK, so this is it. We just take these\ncomponents, plug them into this recursive,\nmemoized algorithm,",
    "start": "3127920",
    "end": "3134640"
  },
  {
    "text": "and we have a linear\ntime algorithm. I want to briefly\nmention a different way you could plug together those\npieces, which is called bottom",
    "start": "3134640",
    "end": "3141270"
  },
  {
    "text": "up dp, which is--",
    "start": "3141270",
    "end": "3147600"
  },
  {
    "text": "let's do it for this example. So if I have--",
    "start": "3147600",
    "end": "3152760"
  },
  {
    "text": "let's see. Let me start with the base\ncase, b of n equals 0.",
    "start": "3152760",
    "end": "3159700"
  },
  {
    "text": "But now it's an assignment. And I'm going to do for loop\nfrom the topological order for i equals n, n minus 1 to 0.",
    "start": "3159700",
    "end": "3169150"
  },
  {
    "text": "Now I'm going to do the\nrelation, b of i equals max of b of i plus 1 and\nb of i plus 1 plus bi",
    "start": "3169150",
    "end": "3182680"
  },
  {
    "text": "and b of i plus 2\nplus di vi plus 1.",
    "start": "3182680",
    "end": "3188530"
  },
  {
    "text": "Technically this only works\nif i is strictly less than n minus 1. So I should have an if i is less\nthan minus 1 for that last part",
    "start": "3188530",
    "end": "3197742"
  },
  {
    "text": "because I can only do-- I can only hit two pins if\nthere's at least two pins left. And then return b of 0.",
    "start": "3197742",
    "end": "3207640"
  },
  {
    "text": "So what I just did\nis a transformation from this SRTBOT template into\na non-recursive algorithm, a",
    "start": "3207640",
    "end": "3215950"
  },
  {
    "text": "for loop algorithm, where\nI wrote my base case first. Then I did my topological order.",
    "start": "3215950",
    "end": "3223060"
  },
  {
    "text": "Then I did my relation. Then at the end, I did my--",
    "start": "3223060",
    "end": "3228910"
  },
  {
    "text": "not base case. The original problem.  And provided you can write\nyour topological order",
    "start": "3228910",
    "end": "3236380"
  },
  {
    "text": "as some for loops. This is actually a great way\nto write down a dp as code. If I were going to\nimplement this algorithm,",
    "start": "3236380",
    "end": "3242200"
  },
  {
    "text": "I would write it this way,\nbecause this is super fast. No recursive calls. Just one for loop. In fact, this is almost\na trivial algorithm.",
    "start": "3242200",
    "end": "3248619"
  },
  {
    "text": "It's amazing that this\nsolves the bowling problem. It's in some sense considering\nevery possible strategy I could",
    "start": "3248620",
    "end": "3256809"
  },
  {
    "text": "for bowling these pins. What we're using is what we\nlike to call local brute force,",
    "start": "3256810",
    "end": "3262840"
  },
  {
    "text": "where when we think\nabout pin i, we look at all of the possible\nthings I could do to pin i,",
    "start": "3262840",
    "end": "3268119"
  },
  {
    "text": "here there's really only three\noptions of what I could do. Now, normally, if I tried\nall the options for pin i",
    "start": "3268120",
    "end": "3274720"
  },
  {
    "text": "and then all the options for i\nplus 1 and i plus 2 and so on, that would be exponential. It'd be 3 times 3 times 3.",
    "start": "3274720",
    "end": "3280690"
  },
  {
    "text": "That's bad, but because I\ncan reuse these sub problems, it turns out to\nonly be linear time.",
    "start": "3280690",
    "end": "3287530"
  },
  {
    "text": "It's almost like magic. dp-- dp is essentially an idea\nof using local brute force.",
    "start": "3287530",
    "end": "3296455"
  },
  {
    "start": "3296455",
    "end": "3302200"
  },
  {
    "text": "And by defining a small number\nof sub-problems up front-- and as long as I stay\nwithin those sub problems,",
    "start": "3302200",
    "end": "3309369"
  },
  {
    "text": "as long as I'm always recursing\ninto this polynomial space, I end up only doing\npolynomial work,",
    "start": "3309370",
    "end": "3315425"
  },
  {
    "text": "even though I'm in\nsome sense exploring exponentially many options. And it is because\nwhat I do to this pin",
    "start": "3315425",
    "end": "3322300"
  },
  {
    "text": "doesn't depend too much to\nwhat I do to a pin much later. There's a lot of intuition\ngoing on here for what--",
    "start": "3322300",
    "end": "3330520"
  },
  {
    "text": "when DP works. But we're going to see a\nlot more examples of that coming up.",
    "start": "3330520",
    "end": "3336370"
  },
  {
    "text": "And I just want to mention\nthe intuition for how to write a recurrence\nlike this is to think about-- in\nthe case of suffixes,",
    "start": "3336370",
    "end": "3342628"
  },
  {
    "text": "you always want to think\nabout the first item, or maybe the first couple of items. The case of prefixes, you always\nthink about the last item.",
    "start": "3342628",
    "end": "3349150"
  },
  {
    "text": "And for substrings, it could be\nany item-- maybe in the middle. If I remove an item from\nthe middle of a substring,",
    "start": "3349150",
    "end": "3354970"
  },
  {
    "text": "I get two substrings,\nso I can recurse. Here or in general,\nwhat we want to do",
    "start": "3354970",
    "end": "3360040"
  },
  {
    "text": "is identify some\nfeature of the solution that if we knew that\nfeature we would be done.",
    "start": "3360040",
    "end": "3366820"
  },
  {
    "text": "We would reduce to a\nsmaller sub problem. In this case, we\njust say, well, what are the possible things I\ncould do to the first pin?",
    "start": "3366820",
    "end": "3375070"
  },
  {
    "text": "There are three options. If I knew which option\nit was, I would be done. I could recurse\nand do my addition.",
    "start": "3375070",
    "end": "3381550"
  },
  {
    "text": "Now, I don't know which\nthing I want to do. So I just try them\nall and take the max. And if you're maximizing,\nyou take the max.",
    "start": "3381550",
    "end": "3388250"
  },
  {
    "text": "If you're minimizing,\nyou take the min. Sometimes you take\nan or or an and. There might be some\ncombination function.",
    "start": "3388250",
    "end": "3394359"
  },
  {
    "text": "For optimization\nproblems where you're trying to maximize or\nminimize something, like shortest paths\nyou're trying to minimize,",
    "start": "3394360",
    "end": "3399487"
  },
  {
    "text": "we put them in here. So usually it's min or max. And this is extremely powerful.",
    "start": "3399487",
    "end": "3406120"
  },
  {
    "text": "All you need to do-- the hard part is this\ninspired design part where you say, what do I\nneed to know that would",
    "start": "3406120",
    "end": "3414640"
  },
  {
    "text": "let me solve my problem? And if you can identify that\nand the number of choices for what you need to\nknow is polynomial,",
    "start": "3414640",
    "end": "3421900"
  },
  {
    "text": "then you will be able to get\na polynomial dynamic program. That's the intuition. You'll see a lot more examples\nin the next three lectures.",
    "start": "3421900",
    "end": "3430619"
  },
  {
    "start": "3430620",
    "end": "3438000"
  }
]