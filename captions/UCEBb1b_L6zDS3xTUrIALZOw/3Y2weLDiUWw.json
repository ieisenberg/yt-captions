[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high-quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at osw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: All right. Today we start a new\nsection of data structures.",
    "start": "18450",
    "end": "24740"
  },
  {
    "text": "This is going to be\ntwo lectures long, so this week succinct data\nstructures, where the goal is",
    "start": "24740",
    "end": "30310"
  },
  {
    "text": "to get really small space. ",
    "start": "30310",
    "end": "37810"
  },
  {
    "text": "And first thing to do is to\ndefine what \"small\" means.",
    "start": "37810",
    "end": "43750"
  },
  {
    "text": "Most succinct data\nstructures are also static, although there are a\nfew that are dynamic. We'll be focusing here on\nstatic data structures.",
    "start": "43750",
    "end": "53500"
  },
  {
    "text": " And so in general,\nthe name of the game",
    "start": "53500",
    "end": "59380"
  },
  {
    "text": "is taking a data\nstructure that you're familiar with-- we're going\nto talk about essentially two today.",
    "start": "59380",
    "end": "65150"
  },
  {
    "text": "One is binary tries,\nwhich has the killer application of doing binary\nsuffix trees in particular.",
    "start": "65150",
    "end": "72280"
  },
  {
    "text": "So it could be a\ncompressed try, whatever. But we'll assume hear\nthe alphabet is binary. A lot of this has\nbeen generalized",
    "start": "72280",
    "end": "77590"
  },
  {
    "text": "to larger alphabets. I'll tell you a\nlittle bit about that. But to keep it\nsimple in lecture, I'm going to stick\nto a binary alphabet.",
    "start": "77590",
    "end": "83349"
  },
  {
    "text": "And another data structure\nwe're going to look at is a bit vector,\nso n bits in a row.",
    "start": "83349",
    "end": "89610"
  },
  {
    "text": "And you want to do\ninteresting operations, like find the i-th 1\nbit in constant time.",
    "start": "89610",
    "end": "96760"
  },
  {
    "text": "These are things\nthat are easy to do in linear space, where linear\nspace means order and words.",
    "start": "96760",
    "end": "103810"
  },
  {
    "text": "Like if you want\nto implement a try, you have a pointer at\nevery node, two pointers at every node, that's easy.",
    "start": "103810",
    "end": "110049"
  },
  {
    "text": "Bit vectors you could store an\narray of where all the 1s are. And so it's easy\nto do linear space,",
    "start": "110050",
    "end": "116830"
  },
  {
    "text": "but linear space is not optimal. And there are three\nsenses of small space",
    "start": "116830",
    "end": "121869"
  },
  {
    "text": "that we'll be going for. The best version is implicit.",
    "start": "121870",
    "end": "128330"
  },
  {
    "text": "An implicit data structure means\nyou use the very optimum number of bits, plus a constant.",
    "start": "128330",
    "end": "134245"
  },
  {
    "text": " But here, we're focusing\non bits, not words.",
    "start": "134245",
    "end": "140440"
  },
  {
    "text": "And if you translate a\nlinear word data structure, and words is order\nn times w bits,",
    "start": "140440",
    "end": "148480"
  },
  {
    "text": "to store something\nlike an n-bit vector, you should really only use\norder n bits, not order nw bits.",
    "start": "148480",
    "end": "156153"
  },
  {
    "text": "Now, what would\nbe ideal is if you used n bits plus a constant. The plus a constant\nis essentially",
    "start": "156154",
    "end": "162280"
  },
  {
    "text": "because sometimes the optimum\nnumber is not an integer. And it's hard to store a\nnon-integer number of bits, so you add a constant.",
    "start": "162280",
    "end": "168950"
  },
  {
    "text": "I mean, I wouldn't mind too much\nif you added order log n bits or something. But typically, the\ngoal here is constant.",
    "start": "168950",
    "end": "176620"
  },
  {
    "text": "Sometimes you can\nreally get zero. But the next best thing would\nbe a succinct data structure,",
    "start": "176620",
    "end": "186460"
  },
  {
    "text": "where the goal is to get opt\nplus little o of opt bits.",
    "start": "186460",
    "end": "194570"
  },
  {
    "text": "So the key here is to get a\nconstant factor of 1 in front.",
    "start": "194570",
    "end": "200260"
  },
  {
    "text": "And then the worst thing in this\nregime is still pretty good.",
    "start": "200260",
    "end": "207099"
  },
  {
    "text": "It's order opt bits. ",
    "start": "207100",
    "end": "212300"
  },
  {
    "text": "So for example, if you're\nstoring an n-bit vector, if you use order n bits,\nthat's still better",
    "start": "212300",
    "end": "218740"
  },
  {
    "text": "than order nw bits. Usually, compact is a\nsavings of at least a factor",
    "start": "218740",
    "end": "224350"
  },
  {
    "text": "of w over what you'd normally\ncall a linear space data structure. So this is the big\nsavings, factor w.",
    "start": "224350",
    "end": "229874"
  },
  {
    "text": "But there's a constant here. Sometimes you like to get rid\nof that constant, make it 1. And it's not so bad\nif you have, say,",
    "start": "229874",
    "end": "236770"
  },
  {
    "text": "another square root of\nn or something little o of n bits of extra space.",
    "start": "236770",
    "end": "244204"
  },
  {
    "text": "But of course, the ideal would\nbe to have no extra space, and that's implicit. Now, it's a little confusing.",
    "start": "244205",
    "end": "249830"
  },
  {
    "text": "I usually call this area\nsuccinct data structures to mean all three. But the middle one\nis called succinct.",
    "start": "249830",
    "end": "257140"
  },
  {
    "text": "That's typically the goal\nis to go for succinct, because implicit is\nvery hard, and compact",
    "start": "257140",
    "end": "262270"
  },
  {
    "text": "is kind of like a\nwarm-up towards succinct. So this is the usual\ngoal in the middle.",
    "start": "262270",
    "end": "270100"
  },
  {
    "text": "And we're going to do\nthis for binary tries, and rank and select. So let me tell you a little\nbit about what's known.",
    "start": "270100",
    "end": "277690"
  },
  {
    "text": "Oh, sorry. One quick example. You've seen implicit\ndata structures. You may have even heard this\nterm in the context of heaps.",
    "start": "277690",
    "end": "286130"
  },
  {
    "text": "Binary heaps are an example\nof a dynamic implicit data structure. They achieve this bound.",
    "start": "286130",
    "end": "292450"
  },
  {
    "text": "They have no extra space\nin the appropriate model. And another one would\nbe a sorted array.",
    "start": "292450",
    "end": "299530"
  },
  {
    "text": "Sorted array supports\nbinary search. You can't really update it, so\nit's a static search structure. It achieves the\noptimal number of bits.",
    "start": "299530",
    "end": "306040"
  },
  {
    "text": "You're just storing the data. And usually, implicit data\nstructures just store the data, though sometimes they reorder\nthe data in interesting ways,",
    "start": "306040",
    "end": "313360"
  },
  {
    "text": "like sorting. A sorted array is one way\nto reorder your data items.",
    "start": "313360",
    "end": "320870"
  },
  {
    "text": "So here's a short survey. This is definitely\nnot exhaustive,",
    "start": "320870",
    "end": "326009"
  },
  {
    "text": "but it covers a bunch\nof the main results. ",
    "start": "326010",
    "end": "333750"
  },
  {
    "text": "So one place where this\narea really got started-- well, there are a\nfew places, actually.",
    "start": "333750",
    "end": "339660"
  },
  {
    "start": "339660",
    "end": "344910"
  },
  {
    "text": "My academic father,\none of my PhD advisors, Ian Munro is sort of one of\nthe fathers of this field.",
    "start": "344910",
    "end": "353190"
  },
  {
    "text": "And he started looking at\nspecific data structures at the very early days. And one of the\nproblems he worked on",
    "start": "353190",
    "end": "360240"
  },
  {
    "text": "was dynamic search trees. So if you want to do\nstatic search trees, you can just store the items\nin a sorted array, easy log n",
    "start": "360240",
    "end": "368160"
  },
  {
    "text": "search, no extra space. What if you want to do\ninserts and deletes also",
    "start": "368160",
    "end": "373620"
  },
  {
    "text": "in log n time per operation,\njust like a regular search tree, but you want\nto do it implicitly?",
    "start": "373620",
    "end": "380389"
  },
  {
    "text": "Now, this is tricky. And there's an old\nresult that would let you get log squared\nper update and query, which",
    "start": "380390",
    "end": "387230"
  },
  {
    "text": "essentially encoded-- you can't afford\npointers at all here. But the idea was to\nencode the pointers",
    "start": "387230",
    "end": "393449"
  },
  {
    "text": "by permuting enough items. If you take, say, log n\nitems, then the permutations",
    "start": "393450",
    "end": "399450"
  },
  {
    "text": "among them is roughly\nlog n, log log n bits. And so you can encode bits by\njust permuting pairs of items.",
    "start": "399450",
    "end": "407270"
  },
  {
    "text": "And so you could read a pointer\nin like log n operations, you end up with log squared. And then Ian Munro got\ndown to a little bit less",
    "start": "407270",
    "end": "415530"
  },
  {
    "text": "than log squared. And then there's a\nseries of improvements over the last several years.",
    "start": "415530",
    "end": "422160"
  },
  {
    "text": "And the final result is log\nn worst case insert, delete,",
    "start": "422160",
    "end": "432800"
  },
  {
    "text": "and predecessor. And this is by\nFranceschini and Grossi.",
    "start": "432800",
    "end": "439932"
  },
  {
    "text": "And furthermore,\nit's cache oblivious, so you can get log base\nb of n cache oblivious.",
    "start": "439932",
    "end": "447780"
  },
  {
    "text": "So this has been pretty\nmuch completely solved. Implicitly, you can\ndo all the good things",
    "start": "447780",
    "end": "453060"
  },
  {
    "text": "we know how to do\nwith search trees. Now, this is not trying to solve\nthe predecessor problem using",
    "start": "453060",
    "end": "458340"
  },
  {
    "text": "Van Emde Boas and such tricks. That's, I believe, open. But for a basic log n\nperformance, it's solved.",
    "start": "458340",
    "end": "467750"
  },
  {
    "text": "Before this got solved,\nanother important problem is essentially the\nequivalent of hashing.",
    "start": "467750",
    "end": "474770"
  },
  {
    "text": "So you want a\nsuccinct dictionary. You want to be able to do-- now, this is going to\nbe static, so there's",
    "start": "474770",
    "end": "481940"
  },
  {
    "text": "no insert and delete. It's just, is this\nitem in the dictionary?",
    "start": "481940",
    "end": "487770"
  },
  {
    "text": "So I have a universe of size u. I have n items in\nthe dictionary. So the first question is, what\nis the optimal number of bits?",
    "start": "487770",
    "end": "494677"
  },
  {
    "text": "And this is actually usually\nvery easy to compute. You just take, what are the\nset of possible structures",
    "start": "494677",
    "end": "499855"
  },
  {
    "text": "you're trying to\nrepresent, which is n items out of a\nuniverse of size u?",
    "start": "499855",
    "end": "505490"
  },
  {
    "text": "How many different\nways are there to have n items in a\nuniverse of size u? ",
    "start": "505490",
    "end": "515409"
  },
  {
    "text": "Come on. It's easy combinatorics. ",
    "start": "515409",
    "end": "523503"
  },
  {
    "text": "Somebody? AUDIENCE: Log u of n. ERIK DEMAINE: Log u--",
    "start": "523504",
    "end": "529454"
  },
  {
    "text": "AUDIENCE: Sorry.  That's how many\nbits you'll need. ERIK DEMAINE: Yeah.",
    "start": "529454",
    "end": "535201"
  },
  {
    "text": "Log u choose n is the\nnumber of bits you'll need. The number of different\npossibilities is u choose n. You take log base 2 of that,\nthat's how many bits you'll",
    "start": "535201",
    "end": "542490"
  },
  {
    "text": "need to represent this. Now, this is not\nnecessarily an integer, because it's got a log.",
    "start": "542490",
    "end": "547830"
  },
  {
    "text": "That's why we would\nhave plus order 1 if we were doing implicit. It's not known how\nto do implicit.",
    "start": "547830",
    "end": "553620"
  },
  {
    "text": "It's known how to\ndo succinct, so this is going to be plus\nlittle o of that thing.",
    "start": "553620",
    "end": "560880"
  },
  {
    "text": "And actually, I have\nthe explicit bound.",
    "start": "560880",
    "end": "566149"
  },
  {
    "text": "Eraser. ",
    "start": "566149",
    "end": "571644"
  },
  {
    "text": "I don't know how\nexciting this is, but you get to know\nhow little o it is.",
    "start": "571644",
    "end": "577950"
  },
  {
    "text": "Log log n squared over log n.",
    "start": "577950",
    "end": "586800"
  },
  {
    "text": "So this is slightly\nsmaller, so this is roughly something like u log n.",
    "start": "586800",
    "end": "593725"
  },
  {
    "text": "It depends. If n is small, this\nis like u log n. If n is big, this is like--",
    "start": "593725",
    "end": "601079"
  },
  {
    "text": "sorry, n log u, I should say. You can always encode a\ndictionary using n log u bits. Just for every item, you\nspecify the log u bits.",
    "start": "601080",
    "end": "608550"
  },
  {
    "text": "But when n is big,\nclose to u, then you can just use a bit\nvector and use u bits.",
    "start": "608550",
    "end": "615149"
  },
  {
    "text": "And so this is little\no of n, so it's always smaller than whatever\nyou're encoding over here.",
    "start": "615150",
    "end": "622950"
  },
  {
    "text": "It's only slightly smaller than\nn, log log n squared over log n, but it's a little o of 1. ",
    "start": "622950",
    "end": "630649"
  },
  {
    "text": "And that's I believe\nthe best known. So this is Brodnik and Munro,\nand then improved by Pagh.",
    "start": "630650",
    "end": "638639"
  },
  {
    "text": "And the point is you get\nconstant time membership query. ",
    "start": "638640",
    "end": "645551"
  },
  {
    "text": "In general, the\nname of the game is you want to do\nthe queries you're used to doing in something\nlike a dictionary, same amount",
    "start": "645552",
    "end": "650790"
  },
  {
    "text": "of time, but with less space. OK.",
    "start": "650790",
    "end": "656139"
  },
  {
    "text": "Next one is-- maybe\nI'll go over here--",
    "start": "656140",
    "end": "661320"
  },
  {
    "text": " binary try, which is what\nwe're going to work on today.",
    "start": "661320",
    "end": "672790"
  },
  {
    "text": "There's various results\non this, but sort of one of the main ones\nis by Munro and Raman.",
    "start": "672790",
    "end": "678690"
  },
  {
    "text": "Again, now this is a little\nharder of a question. How many binary tries\non n nodes are there?",
    "start": "678690",
    "end": "685720"
  },
  {
    "text": "The answer, I will tell you,\nis the nth Catalan number, which is a quantity\nwe've seen before.",
    "start": "685720",
    "end": "694990"
  },
  {
    "text": "2n choose n over n plus 1. As we mentioned last time,\nthis is roughly 4 to the n.",
    "start": "694990",
    "end": "700930"
  },
  {
    "text": " This is kind of interesting.",
    "start": "700930",
    "end": "707559"
  },
  {
    "text": "We saw the Catalan number\nin a different context, which is we were doing\nindirection and using lookup tables at the bottom on\nall rooted trees on n nodes.",
    "start": "707559",
    "end": "718940"
  },
  {
    "text": "Number of rooted trees on n\nnodes was also Catalan number. This is a different\nconcept, binary tries.",
    "start": "718940",
    "end": "724779"
  },
  {
    "text": "If you've ever taken\na combinatorics class, you see Catalan numbers\nall over the place. There's a zillion different\nthings, all of them",
    "start": "724780",
    "end": "731620"
  },
  {
    "text": "the number of them\nis Catalan number. And we will actually use that\nequivalence between binary tries and rooted trees at\nthe end of today's lecture.",
    "start": "731620",
    "end": "739760"
  },
  {
    "text": "So you'll see why\nthey're the same number. OK. So we take log of\nthat, that's 2n bits.",
    "start": "739760",
    "end": "746780"
  },
  {
    "text": "So you need 2n bits to\nrepresent a binary try.",
    "start": "746780",
    "end": "751960"
  },
  {
    "text": "And indeed, you can achieve\n2n plus little o of n bits.",
    "start": "751960",
    "end": "758630"
  },
  {
    "text": "So that's a succinct\ndata structure. And our goal will be to be\nable to do constant time",
    "start": "758630",
    "end": "765760"
  },
  {
    "text": "traversal of the tree, so left\nchild, right child, parent. ",
    "start": "765760",
    "end": "772840"
  },
  {
    "text": "And for fun, another\noperation we might want to do is compute the size of\nthe current subtree.",
    "start": "772840",
    "end": "779709"
  },
  {
    "text": "Again, think of a suffix tree. You start at the\nroot and you want",
    "start": "779710",
    "end": "784750"
  },
  {
    "text": "to be able to go\nalong the left child every time you have a 0\nbit in your query string.",
    "start": "784750",
    "end": "789940"
  },
  {
    "text": "You want to go to\nthe right child every time you have a 1 bit. Parent we don't really\nneed, but why not?",
    "start": "789940",
    "end": "795700"
  },
  {
    "text": "And then subtree\nsize would tell us, how many matches\nare there below us? You could count either the\nnumber of nodes below you",
    "start": "795700",
    "end": "800800"
  },
  {
    "text": "or the number of\nleaves below you. It's roughly the same\nfor a compact try. And so this lets you\ndo substring searches.",
    "start": "800800",
    "end": "808642"
  },
  {
    "text": "And we'll actually talk more\nabout that next lecture, how to actually do\na full suffix tree. But this is a component\nof a binary suffix",
    "start": "808642",
    "end": "815860"
  },
  {
    "text": "tree that has the\nsame performance but uses optimal\namount of space.",
    "start": "815860",
    "end": "821830"
  },
  {
    "text": "And this is a big motivator\noriginally for doing compact",
    "start": "821830",
    "end": "827590"
  },
  {
    "text": "or succinct data structures. At University of Waterloo,\nthey were doing this new OED",
    "start": "827590",
    "end": "832900"
  },
  {
    "text": "project, where Oxford\nEnglish Dictionary was trying to go online or digital. And this concept of\nhaving a CD-ROM that",
    "start": "832900",
    "end": "840100"
  },
  {
    "text": "could have an entire\ndictionary on it was crazy. And CD-ROMs were\nreally slow, so you",
    "start": "840100",
    "end": "846850"
  },
  {
    "text": "don't want to just scan the\nentire CD to do a search. You want to be able to\ndo a search for arbitrary",
    "start": "846850",
    "end": "852340"
  },
  {
    "text": "substrings. That's what suffix\ntrees let you do. But you really can't\nafford much space. And so that was the motivation\nfor developing these data",
    "start": "852340",
    "end": "859990"
  },
  {
    "text": "structures back in the day. Things are a lot easier now. Space is cheaper. But still, there's always going\nto be some giant thing that you",
    "start": "859990",
    "end": "867160"
  },
  {
    "text": "need to store that if you want\nto store a data structure, you really can't\nafford much space.",
    "start": "867160",
    "end": "874060"
  },
  {
    "text": "Cool. So that's static. There is a dynamic version.",
    "start": "874060",
    "end": "879540"
  },
  {
    "text": "It's a more recent result\nfrom just a few years ago. You can do constant time,\ninsert, and delete of a leaf.",
    "start": "879540",
    "end": "889240"
  },
  {
    "text": "And you can do a\nsubdivision of an edge. ",
    "start": "889240",
    "end": "896860"
  },
  {
    "text": "These are operations\nwe saw for dynamic LCA. ",
    "start": "896860",
    "end": "902010"
  },
  {
    "text": "So same operations\nas dynamic LCA, you can do these\nin constant time and still maintain\nthe succinct binary",
    "start": "902010",
    "end": "908740"
  },
  {
    "text": "try representation,\nwhere you can do all these traversal operations. So we won't cover that. We will cover the\nstatic version today.",
    "start": "908740",
    "end": "916360"
  },
  {
    "text": "Then that's for binary alphabet. Let me tell you what's\nknown about larger alphabet.",
    "start": "916360",
    "end": "922720"
  },
  {
    "text": "This is a problem I\nworked on a while ago, though our result is\nno longer the best.",
    "start": "922720",
    "end": "928690"
  },
  {
    "text": "So here, it's a\nlittle complicated. But the number of tries,\nnumber of k-ary tries,",
    "start": "928690",
    "end": "936720"
  },
  {
    "text": "so k is now the size\nof the alphabet, is kn plus 1 choose\nn over kn plus 1.",
    "start": "936720",
    "end": "947400"
  },
  {
    "text": " And so it's succinct,\nmeaning we can",
    "start": "947400",
    "end": "954730"
  },
  {
    "text": "achieve log of that plus\nlittle o of that bits.",
    "start": "954730",
    "end": "959790"
  },
  {
    "text": "And the queries\nwe can achieve are constant time,\nchild with label i,",
    "start": "959790",
    "end": "971670"
  },
  {
    "text": "and parent, and subtree size. ",
    "start": "971670",
    "end": "981430"
  },
  {
    "text": "So we can do all the things\nwe were able to do before. The analog of left\nchild and right child",
    "start": "981430",
    "end": "986620"
  },
  {
    "text": "now is I have a character\nin my pattern, p, and I want to know which\nchild has that label.",
    "start": "986620",
    "end": "992120"
  },
  {
    "text": "So it's not the same as finding\nthe i-th child of a node.",
    "start": "992120",
    "end": "997630"
  },
  {
    "text": "The edges are labeled by\ntheir letter in the alphabet, and you can achieve that.",
    "start": "997630",
    "end": "1003030"
  },
  {
    "text": "We had an earlier result\nthat achieved like log log or something, and then finally\nit was brought down to constant by Farzan and Muno.",
    "start": "1003030",
    "end": "1013020"
  },
  {
    "text": "So couple more.",
    "start": "1013020",
    "end": "1019070"
  },
  {
    "text": "Why don't I just\nmention what they are? It's getting a little tedious.",
    "start": "1019070",
    "end": "1024490"
  },
  {
    "text": "There's a lot of other things\nyou might want to store. You can store\nsuccinct permutations,",
    "start": "1024490",
    "end": "1031000"
  },
  {
    "text": "although there are some\nopen problems here. So you want to store\na permutation using log n factorial bits,\nplus little o of n.",
    "start": "1031000",
    "end": "1038359"
  },
  {
    "text": "If you want to achieve\nsuccincts, the best known-- oh, and the interesting\nquery is you",
    "start": "1038359",
    "end": "1043939"
  },
  {
    "text": "want to be able to do the k-th\npower of your permutation, so see where an item\ngoes after k steps.",
    "start": "1043940",
    "end": "1051620"
  },
  {
    "text": "Best query known for that\nis log n over log log n if you want succinct. If you only want\ncompact, then it's",
    "start": "1051620",
    "end": "1058400"
  },
  {
    "text": "known how to do constant time. So an interesting open\nquestion is, can you achieve succinct constant time queries?",
    "start": "1058400",
    "end": "1065210"
  },
  {
    "text": "If you relax either, then\nit's known how to do it. There's a generalization\nof this to functions,",
    "start": "1065210",
    "end": "1072289"
  },
  {
    "text": "where one of those results is\nknown, the other one isn't. You can try to do\nAbelian groups.",
    "start": "1072290",
    "end": "1079115"
  },
  {
    "start": "1079115",
    "end": "1086906"
  },
  {
    "text": "There are finite Abelian groups. There aren't too\nmany different ones, and you can represent\nan entire Abelian group",
    "start": "1086906",
    "end": "1092510"
  },
  {
    "text": "on n items using log n\nbits, which is pretty crazy, order log n bits. And you can represent an item\nin that group in log n bits",
    "start": "1092510",
    "end": "1100010"
  },
  {
    "text": "and do multiplication,\ninverse, and equality testing. There's other results on\ngraphs, which I won't get into.",
    "start": "1100010",
    "end": "1107270"
  },
  {
    "text": "Those are a little\nharder to state. And then another interesting\ncase is integers.",
    "start": "1107270",
    "end": "1114890"
  },
  {
    "text": "So you want to store\nan integer and you want to be able to increment\nand decrement the integer. And you want to do as few\nbit operations as possible.",
    "start": "1114890",
    "end": "1123470"
  },
  {
    "text": "Worst case, for\nexample, if you have lots of 1s in your bit\nstring, you do an increment,",
    "start": "1123470",
    "end": "1129320"
  },
  {
    "text": "you don't want to pay linear\ncosts, linear number of bit updates to do it.",
    "start": "1129320",
    "end": "1135020"
  },
  {
    "text": "And so you can achieve\nimplicit, so just a constant number of\nextra bits of space.",
    "start": "1135020",
    "end": "1141365"
  },
  {
    "text": " If I have an n-bit\ninteger, then I",
    "start": "1141365",
    "end": "1146750"
  },
  {
    "text": "can do an increment\nor a decrement",
    "start": "1146750",
    "end": "1152210"
  },
  {
    "text": "in order log n bit reads,\nand constant bit writes.",
    "start": "1152210",
    "end": "1161510"
  },
  {
    "text": " And this is Raman and Munro\nfrom a couple years ago.",
    "start": "1161510",
    "end": "1169642"
  },
  {
    "text": "So this is pretty good. Of course, ideal would be\nto do a constant number of-- well, a constant number\nof bit reads or writes",
    "start": "1169642",
    "end": "1175940"
  },
  {
    "text": "would be optimal, I guess. I personally would be\ninterested in getting a constant number of\nword reads and writes.",
    "start": "1175940",
    "end": "1183710"
  },
  {
    "text": "But that's an open\nproblem, I believe. So there's only\norder n bit reads.",
    "start": "1183710",
    "end": "1189614"
  },
  {
    "text": "If they were all\nconsecutive, that would be a constant\nnumber of word reads, but they're kind of spread out.",
    "start": "1189614",
    "end": "1194674"
  },
  {
    "text": "It'd be nice to get constant\nnumber of word operations.",
    "start": "1194675",
    "end": "1199850"
  },
  {
    "text": " So that's a quick\nsurvey of what's known.",
    "start": "1199850",
    "end": "1207300"
  },
  {
    "text": "Let's do some actual\ndata structures now. So we're going to be focusing\non this synced binary tries.",
    "start": "1207300",
    "end": "1216929"
  },
  {
    "text": "And we're going to do\ntwo versions of it. One of them is level order. ",
    "start": "1216930",
    "end": "1232919"
  },
  {
    "text": "And the other will use\na balanced parenthesis representation.",
    "start": "1232920",
    "end": "1238140"
  },
  {
    "text": "So let's start with\nthe level order one. This is very easy. ",
    "start": "1238140",
    "end": "1285990"
  },
  {
    "text": "So I'm going to just loop over\nthe nodes in my try in level order, so level by\nlevel, and write one bit",
    "start": "1285990",
    "end": "1292872"
  },
  {
    "text": "to say whether there's\na left child and one bit to say whether\nthere's a right child. Let's do a little example. ",
    "start": "1292872",
    "end": "1321000"
  },
  {
    "text": "So here is a binary try. ",
    "start": "1321000",
    "end": "1326110"
  },
  {
    "text": "And I'm going to write\na bit string for it. So first, I'm going to\nlook at the top level.",
    "start": "1326110",
    "end": "1333140"
  },
  {
    "text": "I have the node A. It has a left\nchild of B, right child of C, so I write 1, 1.",
    "start": "1333140",
    "end": "1340270"
  },
  {
    "text": "And this corresponds to\nB. This corresponds to C. OK.",
    "start": "1340270",
    "end": "1346340"
  },
  {
    "text": "Then next level is B.\nIt has no left child and it has a right child, which\nis D. I'm just writing down",
    "start": "1346340",
    "end": "1353899"
  },
  {
    "text": "the labels so I don't get lost. Then we have node C, which has\na left child and a right child,",
    "start": "1353900",
    "end": "1364740"
  },
  {
    "text": "E and F. Then we have node\nD, which has no left child.",
    "start": "1364740",
    "end": "1371365"
  },
  {
    "text": "It has a right\nchild, which is G.",
    "start": "1371365",
    "end": "1376481"
  },
  {
    "text": "Node E has no children. Node F has no children. Node G has no children.",
    "start": "1376481",
    "end": "1384980"
  },
  {
    "text": "OK. So there is a 2n-bit string. This is obviously\n2n bits for n nodes,",
    "start": "1384980",
    "end": "1394850"
  },
  {
    "text": "so this is one way to prove\nthere's at most four to the n tries. And well, we'll talk\nabout how useful it is.",
    "start": "1394850",
    "end": "1404052"
  },
  {
    "text": "I want to give you\nanother representation of the same thing, which\nis if we take these nodes",
    "start": "1404052",
    "end": "1410800"
  },
  {
    "text": "and add on-- wherever there's\nan absent leaf, I'm going to add what we call an\nexternal node, as you sometimes",
    "start": "1410800",
    "end": "1417580"
  },
  {
    "text": "see in data structures books. One way to represent a\nnull pointer, say, oh, there's a node there\nthat has no children.",
    "start": "1417580",
    "end": "1426170"
  },
  {
    "text": "This unifies things\na little bit, because now every\nnode either has two children or no children.",
    "start": "1426170",
    "end": "1431530"
  },
  {
    "text": "Another way to think\nabout the same thing. And it turns out if you look\nat this bit string and add a 1",
    "start": "1431530",
    "end": "1440230"
  },
  {
    "text": "in front-- so I'll put this\none in parentheses-- then what this is\nencoding is just",
    "start": "1440230",
    "end": "1447940"
  },
  {
    "text": "for every node in level\norder, are you a real node or are you an external node?",
    "start": "1447940",
    "end": "1453220"
  },
  {
    "text": "Are you an internal node\nor an external node? A here is internal.",
    "start": "1453220",
    "end": "1458770"
  },
  {
    "text": "B is internal. C is internal. This is an external node.",
    "start": "1458770",
    "end": "1464110"
  },
  {
    "text": "Then this is internal,\ninternal, internal. Then external, G, external,\nexternal, external, external,",
    "start": "1464110",
    "end": "1473610"
  },
  {
    "text": "external, external. The zeros correspond\nto external nodes because those are\nabsent children. So same thing.",
    "start": "1473610",
    "end": "1480216"
  },
  {
    "text": "So I'll write equivalently, 1\nequals an internal node and 0",
    "start": "1480216",
    "end": "1499429"
  },
  {
    "text": "equals an external node. ",
    "start": "1499430",
    "end": "1512530"
  },
  {
    "text": "Of course, to do this,\nwe need one more bit. ",
    "start": "1512530",
    "end": "1518720"
  },
  {
    "text": "And I'm going to take\nthis view primarily, because it's a little\neasier to work. It doesn't really make\nmuch of a difference,",
    "start": "1518720",
    "end": "1524383"
  },
  {
    "text": "just shifts\neverything over by 1. And I'd like to write\ndown the indices here,",
    "start": "1524383",
    "end": "1530799"
  },
  {
    "text": "so we have 1, 2, 3, 4,\n5, 6, 7 into this array.",
    "start": "1530800",
    "end": "1546340"
  },
  {
    "text": "Because now our challenge\nis all right, great. We've represented a binary try. But we want to be able\nto do constant time,",
    "start": "1546340",
    "end": "1551980"
  },
  {
    "text": "left child, right child, parent. We're not going to be\nable to do subtree size. Level order is really not\ngood for subtree size.",
    "start": "1551980",
    "end": "1558520"
  },
  {
    "text": "But left child, right\nchild, and parent we can do in constant time. ",
    "start": "1558520",
    "end": "1564410"
  },
  {
    "text": "And the reason that we\ncan do it in constant time is because there's\na nice lemma, kind of analogous to binary heaps.",
    "start": "1564410",
    "end": "1571955"
  },
  {
    "start": "1571955",
    "end": "1615799"
  },
  {
    "text": "So the claim is if we look\nat the i-th internal node, so for example C is the\nthird internal node, so",
    "start": "1615800",
    "end": "1624410"
  },
  {
    "text": "internal node number 3, then\nwe look at positions 2 times 3, and 2 times 3 plus 1, so\n6 and 7 in this array.",
    "start": "1624410",
    "end": "1632960"
  },
  {
    "text": "And we get the two children\nE and F. So that worked. 6 and 7 are E and F.",
    "start": "1632960",
    "end": "1639800"
  },
  {
    "text": "Or this one would be the\nfourth internal node. D is the fourth internal node.",
    "start": "1639800",
    "end": "1645559"
  },
  {
    "text": "And so at positions 8 and 9\nshould be this external node and G. 8 is an external node.",
    "start": "1645560",
    "end": "1651410"
  },
  {
    "text": "9 is g. So it works. This is a lemma.",
    "start": "1651410",
    "end": "1656520"
  },
  {
    "text": "You can prove it pretty\neasily by induction on i.",
    "start": "1656520",
    "end": "1662610"
  },
  {
    "text": " So the idea is,\nwell, if you look",
    "start": "1662610",
    "end": "1670259"
  },
  {
    "text": "at let's say the\ni-th internal node and the i minus first\ninternal node, this one",
    "start": "1670260",
    "end": "1678120"
  },
  {
    "text": "has two left children. Don't know whether they're\ninternal or external. Between them-- they're\non the same level",
    "start": "1678120",
    "end": "1683529"
  },
  {
    "text": "and we're in level order,\nso anything in between here is an external node. So they have no\nchildren, which means",
    "start": "1683530",
    "end": "1690840"
  },
  {
    "text": "if you look at\nthe children of i, they're going to appear\nright after the children of i minus 1, because\nwe're level order.",
    "start": "1690840",
    "end": "1700080"
  },
  {
    "text": "So we have these two guys. The next nodes at this level\nare going to be these two guys.",
    "start": "1700080",
    "end": "1706800"
  },
  {
    "text": "So this one appeared at 2i\nminus 2, and 2i minus 1.",
    "start": "1706800",
    "end": "1711860"
  },
  {
    "text": "This one will appear\nat 2i and 2i plus 1. This is if i and i minus\n1 are on the same level,",
    "start": "1711860",
    "end": "1719029"
  },
  {
    "text": "but it also works if\nthey're in different levels. ",
    "start": "1719029",
    "end": "1730759"
  },
  {
    "text": "So if I'm i minus 1 is the\nlast node on its level, again it's going to have two\nchildren here, which will be",
    "start": "1730760",
    "end": "1737170"
  },
  {
    "text": "the last nodes on this level. And then right after that\nwill come the children of i,",
    "start": "1737170",
    "end": "1743320"
  },
  {
    "text": "again at position\n2i and 2i plus 1. ",
    "start": "1743320",
    "end": "1750800"
  },
  {
    "text": "OK. So that's essentially the\nproof that this works out. There's lots of ways to\nsee why this is true,",
    "start": "1750800",
    "end": "1756520"
  },
  {
    "text": "but I think I'll\nleave it at that. OK.",
    "start": "1756520",
    "end": "1761890"
  },
  {
    "text": "So this is good news. It says if we have the\ni-th internal node, we can find the left\nand the right children.",
    "start": "1761890",
    "end": "1768540"
  },
  {
    "text": "But these are in different\nnamespaces, right? On the one hand, we're\ncounting by internal nodes. On the other hand, we're\ncounting by position",
    "start": "1768540",
    "end": "1774960"
  },
  {
    "text": "in the array, which\nis counting position by internal and external nodes.",
    "start": "1774960",
    "end": "1781120"
  },
  {
    "text": "This counts both 0's and 1's. This only counts 1's. ",
    "start": "1781120",
    "end": "1803410"
  },
  {
    "text": "So we need a mechanism for\ntranslating between those two worlds, translating between\nindices that only count",
    "start": "1803410",
    "end": "1810250"
  },
  {
    "text": "1's and indices that\ncount 0's and 1's. And this is the idea\nof rank and select.",
    "start": "1810250",
    "end": "1815515"
  },
  {
    "start": "1815515",
    "end": "1826360"
  },
  {
    "text": "So in general, if I\nhave a string of n bits, I want to be able to compute\nthe rank of a bit, which",
    "start": "1826360",
    "end": "1843650"
  },
  {
    "text": "is the number of 1's at\nor before position i. So I'm given a\nposition like 6 and I",
    "start": "1843650",
    "end": "1850317"
  },
  {
    "text": "want to know how\nmany 1's are there up to 6, which would be 5\nin the full array here.",
    "start": "1850317",
    "end": "1857360"
  },
  {
    "text": "Or I'm given a query like\n8, number of 1's is 6 up to position 8.",
    "start": "1857360",
    "end": "1864470"
  },
  {
    "text": "And then the inverse\nof rank is select,",
    "start": "1864470",
    "end": "1870409"
  },
  {
    "text": "which gives you the\nposition of the j-th 1 bit.",
    "start": "1870410",
    "end": "1875690"
  },
  {
    "text": " So this lets you translate\nbetween these two worlds",
    "start": "1875690",
    "end": "1883070"
  },
  {
    "text": "of counting just the 1's, which\nis rank, or going to the j-th 1",
    "start": "1883070",
    "end": "1889669"
  },
  {
    "text": "bit, that's select. ",
    "start": "1889670",
    "end": "1897860"
  },
  {
    "text": "So this lets you compute\nthe left child as just being at position\ntwice the rank,",
    "start": "1897860",
    "end": "1905509"
  },
  {
    "text": "because the rank tells\nyou this value i, which is which internal node are you.",
    "start": "1905510",
    "end": "1912340"
  },
  {
    "text": "That's your rank. You multiply by 2 and that was\nthe position of the left child. Right child is going\nto be that plus 1.",
    "start": "1912340",
    "end": "1922400"
  },
  {
    "text": "Parent is going to use select. So if we want the parent of i,\nthis is going to be select of i",
    "start": "1922400",
    "end": "1936410"
  },
  {
    "text": "over 2 with a floor.  So that's just the inverse\nof left and right child.",
    "start": "1936410",
    "end": "1943480"
  },
  {
    "text": "If I divide by 2 and take\nthe floor, I get rid of that plus 1, I get the rank. And then I do select, sub 1,\nand that's the inverse of rank.",
    "start": "1943480",
    "end": "1953169"
  },
  {
    "text": "So that lets me implement. If I have rank and select in\nconstant time, now I can do",
    "start": "1953170",
    "end": "1958440"
  },
  {
    "text": "left child, right child,\nparent in constant time. The remaining challenge is,\nhow do I do rank and select?",
    "start": "1958440",
    "end": "1963940"
  },
  {
    "text": "And that's what we're\ngoing to do next. Any questions about\nthat before we go on? ",
    "start": "1963940",
    "end": "1970756"
  },
  {
    "text": "All right. So now we do real\ndata structures. This is going to be some integer\ndata structures, some fun",
    "start": "1970756",
    "end": "1978820"
  },
  {
    "text": "stuff. It's going to use some\ntechniques we know,",
    "start": "1978820",
    "end": "1984210"
  },
  {
    "text": "but in a different setting,\nbecause now our goal is to really minimize space.",
    "start": "1984210",
    "end": "1990021"
  },
  {
    "text": "We're going to use\nindirection and lookup tables in a new kind of way. ",
    "start": "1990021",
    "end": "2000380"
  },
  {
    "text": "These are going to be\nword RAM data structures. I want to do both rank and\nselect in constant time.",
    "start": "2000380",
    "end": "2007159"
  },
  {
    "text": "And the amount of space\nI have is little o of n. I want succinct. And I'm going to\nstore the bit vector.",
    "start": "2007160",
    "end": "2014720"
  },
  {
    "text": "So then in addition\nto the bit vector, all I'm allowed for rank and\nselect is little o of n space. That's the cool part.",
    "start": "2014720",
    "end": "2020540"
  },
  {
    "text": " So rank is one of the first\nsuccinct data structures.",
    "start": "2020540",
    "end": "2027990"
  },
  {
    "text": "It's by Jacobson, 1989.",
    "start": "2027990",
    "end": "2036740"
  },
  {
    "text": "So a first observation is, what\ncan we do with a lookup table?",
    "start": "2036740",
    "end": "2042770"
  },
  {
    "text": "Suppose I wanted to\nstore all the answers, but I can't afford much space.",
    "start": "2042770",
    "end": "2049879"
  },
  {
    "start": "2049880",
    "end": "2063488"
  },
  {
    "text": "Well, let's do sort\nof a worksheet. If I had space x, or if I looked\nat all bit strings of length",
    "start": "2063489",
    "end": "2071230"
  },
  {
    "text": "x and then I wanted to store\nthem, that's going to cost-- or store a lookup\ntable for each of them,",
    "start": "2071230",
    "end": "2079384"
  },
  {
    "text": "it's going to\ncost-- well, there's 2 to the x different bit\nstrings of that length.",
    "start": "2079384",
    "end": "2085440"
  },
  {
    "text": "Then for each of them, I have\nto store all possible answers to rank and select queries.",
    "start": "2085440",
    "end": "2091449"
  },
  {
    "text": "So there's order x\ndifferent queries. You could query every bit.",
    "start": "2091449",
    "end": "2098024"
  },
  {
    "text": "And then for each of them, I\nhave to write down an answer. So this is going to be log x\nbits, because the answer is",
    "start": "2098024",
    "end": "2105030"
  },
  {
    "text": "a value between 0 and\nx minus 1, so it takes log x bits to write it down. So this is how much\nspace it's going",
    "start": "2105030",
    "end": "2110880"
  },
  {
    "text": "to be to store the answer for\nall bit strings of length x. So what should I set x to?",
    "start": "2110880",
    "end": "2118260"
  },
  {
    "text": "I'd like this to\nbe little o of n, so anything that's a\nlittle bit less than log n",
    "start": "2118260",
    "end": "2124140"
  },
  {
    "text": "is going to be OK. And in particular, 1/2 log\nn is a good enough choice.",
    "start": "2124140",
    "end": "2130540"
  },
  {
    "text": "If we use 1/2 log\nn bits, this is going to be root\nn, log n log log",
    "start": "2130540",
    "end": "2136960"
  },
  {
    "text": "n, which is little o of n,\nquite small as succinct data",
    "start": "2136960",
    "end": "2144227"
  },
  {
    "text": "structures go. We're going to use\nmore space than root n. The point is, if\nwe could get down to bit strings of logarithmic\nsize, we'd be done.",
    "start": "2144227",
    "end": "2151410"
  },
  {
    "text": "But we have a bit\nstring of linear size. So how do we reduce it?",
    "start": "2151410",
    "end": "2156450"
  },
  {
    "text": "Something like indirection. ",
    "start": "2156450",
    "end": "2170359"
  },
  {
    "text": "So the funny thing here is we're\ngoing to do indirection twice,",
    "start": "2170360",
    "end": "2177580"
  },
  {
    "text": "kind of recursively, but\nstopping after two levels. The first level\nof indirection is",
    "start": "2177580",
    "end": "2184119"
  },
  {
    "text": "going to reduce things\ndown to size log squared. ",
    "start": "2184120",
    "end": "2196640"
  },
  {
    "text": "So we're going to\ntake our n bit string, divide into chunks of\nsize log squared n, so there's n over\nlog squared n chunks.",
    "start": "2196640",
    "end": "2203829"
  },
  {
    "text": "They look something like\nthis, log squared n.",
    "start": "2203830",
    "end": "2211470"
  },
  {
    "start": "2211470",
    "end": "2217650"
  },
  {
    "text": "And the idea is right now\nwe're trying to just do rank, so rank number of 1's at\nor before a given position.",
    "start": "2217650",
    "end": "2225580"
  },
  {
    "text": "So what I'm going to do is that\neach of these vertical bars, I'm going to store the\ncumulative rank so far.",
    "start": "2225580",
    "end": "2231710"
  },
  {
    "start": "2231710",
    "end": "2240075"
  },
  {
    "text": "Why log squared? Basically because this\nis what I can afford. To store that cumulative\nrank is log n bits.",
    "start": "2240075",
    "end": "2250129"
  },
  {
    "text": "I mean, this rank is\ngoing to get very big. By the end, it will\nhave most of the 1 bits, so it could be\npotentially linear.",
    "start": "2250129",
    "end": "2255579"
  },
  {
    "text": "So I'm going to need log\nn bits to write that down. But how many of these\nvertical bars are there?",
    "start": "2255580",
    "end": "2261430"
  },
  {
    "text": "Well, only n over log\nsquared n of them. So I have n over log squared\nn things I need to write down.",
    "start": "2261430",
    "end": "2270670"
  },
  {
    "text": "Each of them is log n bits. ",
    "start": "2270670",
    "end": "2280218"
  },
  {
    "text": "So do some cancellation.",
    "start": "2280218",
    "end": "2286065"
  },
  {
    "text": "This cancels with that. We have n over log n\nbits overall, which",
    "start": "2286065",
    "end": "2292970"
  },
  {
    "text": "is slightly little o of n. And that's the bound\nwe're going to achieve. OK.",
    "start": "2292970",
    "end": "2298230"
  },
  {
    "text": "Of course, now we have to solve\nthe problem within a chunk. But we've at least reduced to\nsomething of size log squared.",
    "start": "2298230",
    "end": "2304400"
  },
  {
    "text": "Unfortunately, we need\nsomething of size 1/2 log n before we can use\na lookup table. So there's a bit of\na gap here, so we're",
    "start": "2304400",
    "end": "2309530"
  },
  {
    "text": "going to use indirection\na second time. ",
    "start": "2309530",
    "end": "2321320"
  },
  {
    "text": "This time, we can go all\nthe way to 1/2 log n. ",
    "start": "2321320",
    "end": "2343230"
  },
  {
    "text": "So I'll use red vertical\nbars to denote the subchunks. Each of these is 1/2 log n. ",
    "start": "2343230",
    "end": "2350900"
  },
  {
    "text": "Overall size of a chunk\nhere is log squared n. ",
    "start": "2350900",
    "end": "2355910"
  },
  {
    "text": "So every one of these\nchunks gets further divided. Now, how could this help? Why didn't I just subdivide\ninto chunks of size 1/2 log n",
    "start": "2355910",
    "end": "2363589"
  },
  {
    "text": "before? I mean, why I couldn't\ndo it is clear. If I did n over log n of them,\neach of them stores log n bits,",
    "start": "2363590",
    "end": "2369589"
  },
  {
    "text": "I'd have a linear\nnumber of bits. I can't afford a\nlinear number of bits. That would only be\ncompact, not succinct.",
    "start": "2369590",
    "end": "2376610"
  },
  {
    "text": "How does it help me to\nfirst reduce to this and then reduce to this?",
    "start": "2376610",
    "end": "2382259"
  },
  {
    "text": "Well, what I want to do at\neach of these red vertical bars",
    "start": "2382260",
    "end": "2388310"
  },
  {
    "text": "is store the cumulative\nrank, but not the overall cumulative rank. I only need the cumulative\nrank within the overall chunk,",
    "start": "2388310",
    "end": "2401900"
  },
  {
    "text": "not relative to\nthe entire array. Why does that help me? ",
    "start": "2401900",
    "end": "2411520"
  },
  {
    "text": "AUDIENCE: Need less bits. ERIK DEMAINE: Need less bits. These ranks can't get too\nbig, because the overall size",
    "start": "2411520",
    "end": "2417030"
  },
  {
    "text": "of a chunk is just log squared. Log of log squared is log log n. So I only need log log\nn bits to write down",
    "start": "2417030",
    "end": "2426960"
  },
  {
    "text": "those cumulative ranks.  And so total size\nhere is going to be",
    "start": "2426960",
    "end": "2435329"
  },
  {
    "text": "n over log n times\nlog log n bits,",
    "start": "2435330",
    "end": "2443670"
  },
  {
    "text": "because there's n over log n\nof these red vertical bars. Each one I only need to\nwrite log log n bits.",
    "start": "2443670",
    "end": "2448720"
  },
  {
    "text": "And this is slightly\nlittle o of n. It's actually a little\nbit bigger than this, but still little of of n.",
    "start": "2448720",
    "end": "2454260"
  },
  {
    "text": "So we can still afford this. And now we're done, because\nthese subchunks are of size 1/2",
    "start": "2454260",
    "end": "2461260"
  },
  {
    "text": "log n, so I can use this lookup\ntable and solve my problem. So let me step forward, just\nputting everything together.",
    "start": "2461260",
    "end": "2471585"
  },
  {
    "text": " To compute the rank of a\nquery, first thing you do",
    "start": "2471585",
    "end": "2477656"
  },
  {
    "text": "is figure out which chunk you\nfall into, which you can do by division, integer division.",
    "start": "2477656",
    "end": "2482760"
  },
  {
    "text": "These things are stored in an\narray, so you just compute, what is that cumulative rank? ",
    "start": "2482760",
    "end": "2492299"
  },
  {
    "text": "So you take the\nrank of that chunk, you add on the rank of the\nsubchunk within the chunk,",
    "start": "2492300",
    "end": "2503490"
  },
  {
    "text": "and then you add on the rank\nof the element in the subchunk.",
    "start": "2503490",
    "end": "2508530"
  },
  {
    "text": " So rank of the chunk is stored\nin the array known as 2.",
    "start": "2508530",
    "end": "2517560"
  },
  {
    "text": "The rank of the subchunk\nwithin the chunk is stored in the array,\nin the array known as 3. And then to compute the rank\nof the element in the subchunk,",
    "start": "2517560",
    "end": "2525180"
  },
  {
    "text": "you use the lookup table,\nwhich is essentially telling you for every possible\nsubchunk what the answers are.",
    "start": "2525180",
    "end": "2531990"
  },
  {
    "text": "So 3 times a constant\nis a constant. And we get rank, constant\ntime, and n log log",
    "start": "2531990",
    "end": "2539400"
  },
  {
    "text": "n over log n space. ",
    "start": "2539400",
    "end": "2545700"
  },
  {
    "text": "If you're concerned that n\ntimes log log n over log n is not very sublinear, you\ncan do a little bit better",
    "start": "2545700",
    "end": "2555800"
  },
  {
    "text": "using fancier tricks. ",
    "start": "2555800",
    "end": "2569619"
  },
  {
    "text": "Namely, you can achieve n\nover log to the kn space.",
    "start": "2569620",
    "end": "2575720"
  },
  {
    "start": "2575720",
    "end": "2586590"
  },
  {
    "text": "This is the result of\nPatrascu from 2008. I'm not going to go\ninto how it's done.",
    "start": "2586590",
    "end": "2591810"
  },
  {
    "text": "But if you're interested,\nit's a little bit less. It would be nice to do better. But my guess is there\nshould be a lower",
    "start": "2591810",
    "end": "2597510"
  },
  {
    "text": "bounds, that with constant--\nso this is for any constant k. ",
    "start": "2597510",
    "end": "2605280"
  },
  {
    "text": "It would be nice to do\nbetter, like square root of n or something. But my guess is there's\na matching lower bound.",
    "start": "2605280",
    "end": "2610530"
  },
  {
    "text": "I don't think that's known. OK. So that was rank.",
    "start": "2610530",
    "end": "2616020"
  },
  {
    "text": "Our next challenge is to\ndo select, the inverse. And select is a little\nbit harder, I would say.",
    "start": "2616020",
    "end": "2623320"
  },
  {
    "text": "Don't have a great\nintuition why. ",
    "start": "2623320",
    "end": "2628745"
  },
  {
    "text": "But it is.  And we're going to be able to\nuse the same kind of technique.",
    "start": "2628746",
    "end": "2636099"
  },
  {
    "text": "So again, we can use\na lookup table and--",
    "start": "2636100",
    "end": "2641842"
  },
  {
    "text": "I'll do that first. ",
    "start": "2641842",
    "end": "2657710"
  },
  {
    "text": "So just like before, if we have\nbit strings of length at most 1/2 log n, then we're only\ngoing to need something",
    "start": "2657710",
    "end": "2666280"
  },
  {
    "text": "like root n space. It's root n again times\nlog n log log n space, just",
    "start": "2666280",
    "end": "2672910"
  },
  {
    "text": "like rank. There are at most n possible\nqueries, actually fewer, because there may\nbe fewer 1 bits.",
    "start": "2672910",
    "end": "2677920"
  },
  {
    "text": "But at most, there\nare n 1 bits to query. An answer is now an index, which\nis within a thing of size 1/2",
    "start": "2677920",
    "end": "2683870"
  },
  {
    "text": "log n. So I just have to write\ndown an index of that size, Soit's it's log log n\nbits to write it down.",
    "start": "2683870",
    "end": "2690730"
  },
  {
    "text": "Cool. So that's the same. Now the challenge is about\ngetting down to 1/2 log n bits.",
    "start": "2690730",
    "end": "2696838"
  },
  {
    "text": "We're going to use\nthe same technique of two levels of indirection. But they work differently.",
    "start": "2696839",
    "end": "2703000"
  },
  {
    "text": "There's an extra thing we\nneed to deal with in select. ",
    "start": "2703000",
    "end": "2710650"
  },
  {
    "text": "There will be two cases,\ndepending on whether your array has lots of 1's or\nnot so many 1's.",
    "start": "2710650",
    "end": "2718030"
  },
  {
    "text": "And those two cases can\nvary throughout the string. ",
    "start": "2718030",
    "end": "2724850"
  },
  {
    "text": "So what we do,\nfirst of all, is--",
    "start": "2724850",
    "end": "2731335"
  },
  {
    "start": "2731335",
    "end": "2736356"
  },
  {
    "text": "actually, maybe\nI'll go over here.  I'll stick here.",
    "start": "2736356",
    "end": "2742160"
  },
  {
    "text": "Whatever. ",
    "start": "2742160",
    "end": "2748309"
  },
  {
    "text": "So we're back to\nan n-bit string. ",
    "start": "2748310",
    "end": "2767100"
  },
  {
    "text": "So we're looking at we want\nthe analog of this structure, this structure of chunks.",
    "start": "2767100",
    "end": "2773380"
  },
  {
    "text": "Now, we can't just say,\noh, take the bit string, divide it into\nchunks of equal size, because then given a query,\nwe want to do select of j,",
    "start": "2773380",
    "end": "2782460"
  },
  {
    "text": "we need to know which of\nthese chunks j belongs to.",
    "start": "2782460",
    "end": "2787969"
  },
  {
    "text": "So instead of making\nthem equal size, we're going to make them have\nan equal number of 1 bits. So then we can\njust take j, divide",
    "start": "2787969",
    "end": "2794309"
  },
  {
    "text": "by the size of these chunks,\nwhich is log n log log n. You could probably do\nlog squared as well,",
    "start": "2794310",
    "end": "2800520"
  },
  {
    "text": "but log n log log n is a\nslightly better choice. ",
    "start": "2800520",
    "end": "2807150"
  },
  {
    "text": "And so we just divide\nevery log n log log n 1 bit, put a vertical bar.",
    "start": "2807150",
    "end": "2813849"
  },
  {
    "text": "That way, given j, we\ndivide by this thing, take the floor, that tells\nus which chunk we belong to.",
    "start": "2813849",
    "end": "2818940"
  },
  {
    "text": "So it's different. Decomposing by 1 space\ninstead of 01 space.",
    "start": "2818940",
    "end": "2824490"
  },
  {
    "text": "And so for those guys,\nwe just store an array. If your query happens\nto have a 0 mod this,",
    "start": "2824490",
    "end": "2830700"
  },
  {
    "text": "then you have your answer. Otherwise, you still need\nto query within the chunk. In some sense, the array has\ngotten divided something like",
    "start": "2830700",
    "end": "2839490"
  },
  {
    "text": "this, so the number of 1 bits\nin here is always the same,",
    "start": "2839490",
    "end": "2845410"
  },
  {
    "text": "log n log log n 1's.",
    "start": "2845410",
    "end": "2850839"
  },
  {
    "text": "So you can now teleport\nto the appropriate chunk. And the issue is, how\ndo I solve a chunk? But now chunks have\ndifferent sizes,",
    "start": "2850840",
    "end": "2856720"
  },
  {
    "text": "which is kind of annoying. That's why we need\nthis extra step, which",
    "start": "2856720",
    "end": "2861810"
  },
  {
    "text": "is within a group of\nlog n log log n 1 bits--",
    "start": "2861810",
    "end": "2873040"
  },
  {
    "text": "I'm calling them groups\nnow, instead of chunks. So each of these groups\nhas different size.",
    "start": "2873040",
    "end": "2880830"
  },
  {
    "text": "Let's suppose it has size\nr, so say it's r bits long.",
    "start": "2880830",
    "end": "2889630"
  },
  {
    "text": " R is going to be\ndifferent for each chunk,",
    "start": "2889630",
    "end": "2895920"
  },
  {
    "text": "but we'll do this for\nevery chunk, every group.",
    "start": "2895920",
    "end": "2901040"
  },
  {
    "text": "Then there's two cases. If r is big, we're done.",
    "start": "2901040",
    "end": "2908080"
  },
  {
    "text": "How big? Well, if it's at least the\nsquare of the number of 1 bits, that means it's very sparse.",
    "start": "2908080",
    "end": "2915089"
  },
  {
    "text": "Only square root of\nthe bits are 1's. The rest are all 0's.",
    "start": "2915090",
    "end": "2920270"
  },
  {
    "text": "But then, I can afford to\njust store all the answers. ",
    "start": "2920270",
    "end": "2939575"
  },
  {
    "text": "I'm just going to store a\nlookup table of all the answers if it's very sparse,\nbecause then I",
    "start": "2939575",
    "end": "2970560"
  },
  {
    "text": "claim I only need this\nmany bits in order to store all of these answers.",
    "start": "2970560",
    "end": "2976300"
  },
  {
    "text": "So if I do this\nfor all groups that have a large number of bits,\nI store this lookup array,",
    "start": "2976300",
    "end": "2982550"
  },
  {
    "text": "how many-- if I sum up the size\nof all of these arrays, how much do I pay?",
    "start": "2982550",
    "end": "2988670"
  },
  {
    "text": "Well, the lookup array\nhas this kind of size. There are log n\nlog log n 1 bits.",
    "start": "2988670",
    "end": "2996260"
  },
  {
    "text": "And each of them I need to\nstore an index for them. Now, this could cost log n\nbits, because potentially one",
    "start": "2996260",
    "end": "3002830"
  },
  {
    "text": "of these groups is very large. It could be almost linear size. So I need log n bits to write\ndown a position in there.",
    "start": "3002830",
    "end": "3009849"
  },
  {
    "text": "There's log n log log n 1 bits\nto write down to position for. So this is the size of\none of these arrays.",
    "start": "3009850",
    "end": "3019240"
  },
  {
    "text": "Now, how many of these could\nI possibly need to store? Well, I know that this\ngroup has log n log log",
    "start": "3019240",
    "end": "3025390"
  },
  {
    "text": "n squared bits in it, so the\nmaximum number of such groups is n over that, n over\nlog n log log n squared.",
    "start": "3025390",
    "end": "3034110"
  },
  {
    "text": "And now we get to do\nsome cancellation. So this 2 cancels with\nthis log n log log n.",
    "start": "3034110",
    "end": "3042010"
  },
  {
    "text": "And then this log n\ncancels with this log n. And so we get n over\nlog log n bits, which",
    "start": "3042010",
    "end": "3053080"
  },
  {
    "text": "is slightly little of of n. OK. Again, it is possible to get\nn over log to the k space.",
    "start": "3053080",
    "end": "3061750"
  },
  {
    "text": "But we won't do that here. We'll be happy enough\nwith n over log log n.",
    "start": "3061750",
    "end": "3066890"
  },
  {
    "text": "OK. But we're not done,\nunfortunately. So we've now reduced\nin two groups,",
    "start": "3066890",
    "end": "3072340"
  },
  {
    "text": "and I've only\ngiven you one case. This is when r is large. The other cases, r\nis small, meaning",
    "start": "3072340",
    "end": "3078100"
  },
  {
    "text": "the number of bits in the group\nis at most log n log log n squared. That's a good case\nfor us, because that's",
    "start": "3078100",
    "end": "3083980"
  },
  {
    "text": "pretty similar to rank. Here we got chunks\nof size log squared. Here it's slightly\nlarger than log squared,",
    "start": "3083980",
    "end": "3089320"
  },
  {
    "text": "but only by a poly\nlog log factor. And that would correspond\nto this step 2 in rank.",
    "start": "3089320",
    "end": "3097210"
  },
  {
    "text": "You do step 2 and step 3 here. Then we get step 2 of rank. We've reduced to\npoly log size chunks",
    "start": "3097210",
    "end": "3105850"
  },
  {
    "text": "by getting rid of this case. And so we have to do it again,\nbecause we have poly log",
    "start": "3105850",
    "end": "3110880"
  },
  {
    "text": "size groups. But we need to get down to\ngroups of size log, 1/2 log.",
    "start": "3110880",
    "end": "3117160"
  },
  {
    "text": "So we need to do another\nlayer of indirection. ",
    "start": "3117160",
    "end": "3145740"
  },
  {
    "text": "So we get to do\nsteps 2 and 3 again. This is what I'll call step 4.",
    "start": "3145740",
    "end": "3150980"
  },
  {
    "start": "3150980",
    "end": "3156330"
  },
  {
    "text": "Repeat steps 2 and 3 on--",
    "start": "3156330",
    "end": "3162880"
  },
  {
    "text": "oh, sorry. I didn't say I need\nan else clause.",
    "start": "3162880",
    "end": "3168150"
  },
  {
    "text": "Else I'm going to call this bit\nvector a reduced bit vector. ",
    "start": "3168150",
    "end": "3176640"
  },
  {
    "text": "So I've reduced to order log\nn log log n squared bits.",
    "start": "3176640",
    "end": "3183345"
  },
  {
    "start": "3183345",
    "end": "3189510"
  },
  {
    "text": "And so step 4 is on\nall reduced strings,",
    "start": "3189510",
    "end": "3195200"
  },
  {
    "text": "all reduced bit strings. ",
    "start": "3195200",
    "end": "3202309"
  },
  {
    "text": "I want to do steps\n2 and 3 again. Let me do it quickly. ",
    "start": "3202310",
    "end": "3209250"
  },
  {
    "text": "My goal is to further\nreduce to poly log log n.",
    "start": "3209250",
    "end": "3225760"
  },
  {
    "text": "I took n bit strings and I\ngot down to log poly log bits. I do it again, I should get\ndown to poly log log bits.",
    "start": "3225760",
    "end": "3232240"
  },
  {
    "text": "And indeed, I can. And this is plenty small. Poly log log is way\nsmaller than 1/2 log,",
    "start": "3232240",
    "end": "3237910"
  },
  {
    "text": "so we don't even need that\nmuch of the lookup table. Fine.",
    "start": "3237910",
    "end": "3243339"
  },
  {
    "text": "So I'll call this 2 prime. ",
    "start": "3243340",
    "end": "3251109"
  },
  {
    "text": "I want to make this\nexplicit, because they are slightly different,\nbecause now everything's relative to the reduced\nstring, which is poly log.",
    "start": "3251110",
    "end": "3259825"
  },
  {
    "start": "3259825",
    "end": "3277710"
  },
  {
    "text": "This gets hard to pronounce,\nbut every log log n square-th 1 bit, we're going to write\ndown the relative index",
    "start": "3277710",
    "end": "3284710"
  },
  {
    "text": "within the reduced\nstring of size log n. So writing down\nthe relative index",
    "start": "3284710",
    "end": "3289890"
  },
  {
    "text": "only costs log log n\nbits, because we're",
    "start": "3289890",
    "end": "3295289"
  },
  {
    "text": "in something of size\nlog n, so writing down that index is short. We write it down\nfor all of these,",
    "start": "3295290",
    "end": "3301150"
  },
  {
    "text": "so we end up paying n\nover log log n squared.",
    "start": "3301150",
    "end": "3308910"
  },
  {
    "text": "That's the maximum\nnumber of these indices that we need to store. Each of them we pay log log n.",
    "start": "3308910",
    "end": "3314340"
  },
  {
    "text": "So here I'm summing over\nall the reduced bit strings. This is an overall size. It's at most n over log log n\nsquared that we need to store.",
    "start": "3314340",
    "end": "3321809"
  },
  {
    "text": "Could be fewer if there aren't\nmany reduced bit strings. But worst case, everything\nends up being reduced,",
    "start": "3321810",
    "end": "3327880"
  },
  {
    "text": "so we have this many times\nthat many times that many bits. And we get n over\nlog log n bits.",
    "start": "3327880",
    "end": "3333180"
  },
  {
    "text": " This is roughly following the\npattern of step 2 over here.",
    "start": "3333180",
    "end": "3341490"
  },
  {
    "text": "Step 2 over here didn't\njust have the log term. It also had an\nauxiliary log log term.",
    "start": "3341490",
    "end": "3347020"
  },
  {
    "text": "So if you felt like it,\nyou could make this log log n times log log log n. But it will actually give\nyou worse space bound,",
    "start": "3347020",
    "end": "3353470"
  },
  {
    "text": "so this is slightly better.  OK. Then we apply step\n3 prime, which",
    "start": "3353470",
    "end": "3360750"
  },
  {
    "text": "is we look at each of the\ngroups that we've identified. And either it's big and\nit has lots of 0 bits,",
    "start": "3360750",
    "end": "3368099"
  },
  {
    "text": "or it's not big. And in either case,\nwe're going to be happy. ",
    "start": "3368100",
    "end": "3375220"
  },
  {
    "text": "So if a group of log log n\nsquared 1 bits has r bits,",
    "start": "3375220",
    "end": "3389480"
  },
  {
    "text": "we look at each of\nthem individually. And if r is at least\nthe square of that,",
    "start": "3389480",
    "end": "3395490"
  },
  {
    "text": "so log log n to\nthe fourth power-- so we're losing constants\nin the exponents,",
    "start": "3395490",
    "end": "3401280"
  },
  {
    "text": "but it's not a big deal-- then store relative--",
    "start": "3401280",
    "end": "3412829"
  },
  {
    "text": "I mean, store all the answers,\nbut now as relative indices. ",
    "start": "3412830",
    "end": "3421530"
  },
  {
    "text": "OK. Let's go over here. ",
    "start": "3421530",
    "end": "3433770"
  },
  {
    "text": "So how much do these\nrelative indices cost? Again, it's at most order log\nlog n bits to write them down.",
    "start": "3433770",
    "end": "3447060"
  },
  {
    "text": "We don't know that a group\nis any smaller than log n, but it's at most the\noriginal size of log n.",
    "start": "3447060",
    "end": "3452140"
  },
  {
    "text": "It's only log log n bits\nto write each of them down. And now we get to\nsay, oh, well, we had to write down log\nlog n squared 1 bits.",
    "start": "3452140",
    "end": "3458700"
  },
  {
    "text": "But this can only\nhappen n over log log n to the fourth many times. So the space is n over\nlog log n to the fourth.",
    "start": "3458700",
    "end": "3469350"
  },
  {
    "text": "That's the maximum\nnumber of these I guess you call them sparse\nbit vectors, sparse groups there",
    "start": "3469350",
    "end": "3476610"
  },
  {
    "text": "could be, because each of\nthem is at least this big. The total number of them is\nat most n divided by that.",
    "start": "3476610",
    "end": "3481790"
  },
  {
    "text": "For each of them, we\nhave to write down log log n squared different\nindices for our array.",
    "start": "3481790",
    "end": "3488369"
  },
  {
    "text": "And each of those indices cost\nlog log n bits to write down. So this is log log n\nto the third power.",
    "start": "3488370",
    "end": "3495720"
  },
  {
    "text": "This is log log n\nto the fourth power. So again, this is\nn over log log n. You can tell I've tuned\nall of these numbers",
    "start": "3495720",
    "end": "3502230"
  },
  {
    "text": "to come out to n\nover log log n bits. ",
    "start": "3502230",
    "end": "3508700"
  },
  {
    "text": "OK. That was the if case. There's the else case, which\nis that you have reduced",
    "start": "3508700",
    "end": "3515280"
  },
  {
    "text": "to poly log log size, namely\nthen in the dense case, you have r is at most\nlog log n to the fourth.",
    "start": "3515280",
    "end": "3524070"
  },
  {
    "text": "So at this point, else\nyou are further reduced.",
    "start": "3524070",
    "end": "3529440"
  },
  {
    "start": "3529440",
    "end": "3535170"
  },
  {
    "text": "When you're further reduced,\nyou have at most log log n",
    "start": "3535170",
    "end": "3541329"
  },
  {
    "text": "to the fourth bits. And at most, log log n\nsquared of them are 1 bits.",
    "start": "3541330",
    "end": "3547200"
  },
  {
    "text": "But we don't really\ncare about that. Once we're down to a bit\nvector of poly log log size, we can use our lookup\ntable and we're done.",
    "start": "3547200",
    "end": "3554640"
  },
  {
    "start": "3554640",
    "end": "3561140"
  },
  {
    "text": "So that's select. If you want to do a\nselect on an index, first you figure\nout which group it's",
    "start": "3561140",
    "end": "3568420"
  },
  {
    "text": "in by dividing by log n log\nlog n, taking the floor. You teleport to the appropriate\ngroup using this array.",
    "start": "3568420",
    "end": "3576099"
  },
  {
    "text": "Then within that group,\nthere's a bit saying whether it was sparse or dense.",
    "start": "3576100",
    "end": "3582430"
  },
  {
    "text": "If it was sparse, so\nlots of 0's in it, then you have a lookup table\nthat gives you all your answers",
    "start": "3582430",
    "end": "3589690"
  },
  {
    "text": "for the remainder of your query. If it's dense, then\nyou go over here.",
    "start": "3589690",
    "end": "3596050"
  },
  {
    "text": "You know that this\nthing will be stored, and so you figure\nout which subgroup you belong to by\ndividing by log log n",
    "start": "3596050",
    "end": "3603760"
  },
  {
    "text": "squared, taking the floor. There's an array,\nthis thing, that",
    "start": "3603760",
    "end": "3609760"
  },
  {
    "text": "teleports you to that group-- sorry, to that subgroup.",
    "start": "3609760",
    "end": "3615339"
  },
  {
    "text": "And then you apply-- then there's a bit there saying\nwhether it was sparse or dense.",
    "start": "3615340",
    "end": "3620750"
  },
  {
    "text": "If it was sparse, there's\na lookup table giving you the answer. If it was dense, there's an\nindex into the number 1 lookup",
    "start": "3620750",
    "end": "3627970"
  },
  {
    "text": "table that tells\nyou what this bit string is, because there is only\nlog log n to the fourth bits.",
    "start": "3627970",
    "end": "3635300"
  },
  {
    "text": "In fact, that is the index. Just what those bits are lets\nyou look up into this table and solve your query in\nconstant time, in all cases",
    "start": "3635300",
    "end": "3642490"
  },
  {
    "text": "constant time. But here's a little\nbit more branching, depending on your situation.",
    "start": "3642490",
    "end": "3647935"
  },
  {
    "text": "As I said, select is a little\nmore complicated than rank. But in the end,\nconstant time, little of of n space, n over log\nlog n, which can again",
    "start": "3647935",
    "end": "3655690"
  },
  {
    "text": "be improved by\nPatrascu, n over log to the k for any constant k.",
    "start": "3655690",
    "end": "3661160"
  },
  {
    "text": "Question? AUDIENCE: Can you just quickly\nremind us how the 2 and 3 changed [INAUDIBLE]?",
    "start": "3661160",
    "end": "3666352"
  },
  {
    "text": "ERIK DEMAINE: OK. How did 2 and 3 change? You don't actually really\nneed to change them. The big change is that you're\nstoring only relative indices,",
    "start": "3666352",
    "end": "3672910"
  },
  {
    "text": "not indices. So before, we were storing\nan array of indices",
    "start": "3672910",
    "end": "3678820"
  },
  {
    "text": "of every log log nth 1 bit. These were global pointers.",
    "start": "3678820",
    "end": "3684130"
  },
  {
    "text": "But now after 2 and 3,\nwe've reduced to something of size log n or poly log n.",
    "start": "3684130",
    "end": "3689920"
  },
  {
    "text": "We need to exploit that\nhere, so that we were only storing log log n bits. If we didn't do that,\nthis would be order n bits",
    "start": "3689920",
    "end": "3695470"
  },
  {
    "text": "and it would be too big. That's really the only\nthing you need to change. The other thing I\nchanged was this value.",
    "start": "3695470",
    "end": "3701050"
  },
  {
    "text": "If you follow that\nplan, it would be-- ",
    "start": "3701050",
    "end": "3707690"
  },
  {
    "text": "it was also a square. So we did have to\nadd a square here. You could also add a\nlog log log n term here,",
    "start": "3707690",
    "end": "3714847"
  },
  {
    "text": "but it won't matter. Basically you do\nsomething that works. The square was necessary\nto cancel out this guy,",
    "start": "3714847",
    "end": "3721380"
  },
  {
    "text": "for example. If you didn't do the square-- well, so instead\nof this, you could have done log log n times log\nlog log n without the square.",
    "start": "3721380",
    "end": "3728610"
  },
  {
    "text": "Then here you would have\ngotten n over log log log n. So you could have\nfollowed the same pattern.",
    "start": "3728610",
    "end": "3733800"
  },
  {
    "text": "You'd just get a slightly\nworse space bound. I tuned it here. Here we needed--\nhere we could not have afforded to\ngo to log squared,",
    "start": "3733800",
    "end": "3740100"
  },
  {
    "text": "if I recall correctly,\nthough you can check that. Maybe it's a good pset question.",
    "start": "3740100",
    "end": "3747540"
  },
  {
    "text": "There's lots of\nchoices that work here. But this is the one I\nfind the cleanest that gets a decent bound, not the\nbest bound, but reasonable.",
    "start": "3747540",
    "end": "3755220"
  },
  {
    "text": "Other questions? I think that's all\nthat I changed. The sparsity definition\nwas still a squared thing,",
    "start": "3755220",
    "end": "3762780"
  },
  {
    "text": "so it was squared over here\nand it was squared over here. It's just the thing\nwe were squaring was a little different.",
    "start": "3762780",
    "end": "3768720"
  },
  {
    "text": " OK.",
    "start": "3768720",
    "end": "3774370"
  },
  {
    "text": "One more thing I\nwant to talk about. So at this point, we just finish\nthis level order representation",
    "start": "3774370",
    "end": "3784690"
  },
  {
    "text": "of binary tries,\nbecause we already saw left child, right\nchild, and parent, reduced to rank and select.",
    "start": "3784690",
    "end": "3791250"
  },
  {
    "text": "We just solved rank and\nselect in little o of n bits, so at least statically\nwe can do left child,",
    "start": "3791250",
    "end": "3799089"
  },
  {
    "text": "right child, parent\nin a binary try now in constant time per\noperation, 2n plus little",
    "start": "3799090",
    "end": "3804660"
  },
  {
    "text": "o of n bits of space. The 2n bits are to\nstore those 2n bits that we wrote down before. So that's succinct binary tries.",
    "start": "3804660",
    "end": "3813220"
  },
  {
    "text": "Done. One mention, there are\nsome dynamic versions. In particular, there are dynamic\nversions of rank and select.",
    "start": "3813220",
    "end": "3823180"
  },
  {
    "text": "But the best versions that\nare known to do dynamic rank and select achieve\nsomething like log over log",
    "start": "3823180",
    "end": "3830349"
  },
  {
    "text": "log time per operation, if\nyou're interested in dynamic.",
    "start": "3830350",
    "end": "3836050"
  },
  {
    "start": "3836050",
    "end": "3842355"
  },
  {
    "text": "So this is kind of annoying. If you want to go to dynamic,\neither you pay more time or you don't use\nrank and select.",
    "start": "3842355",
    "end": "3847570"
  },
  {
    "text": "But I'm not going to worry\ntoo much about dynamic. Stick to rank and select. But there's one more\nthing on this list,",
    "start": "3847570",
    "end": "3852726"
  },
  {
    "text": "which is a different way to\ndo succinct binary tries. And this different way is\ngoing to be more powerful, more",
    "start": "3852726",
    "end": "3859250"
  },
  {
    "text": "useful for things like\nsuffix trees, which is what we're going to do next class. So I want to tell you a\nlittle bit about this.",
    "start": "3859250",
    "end": "3868250"
  },
  {
    "text": "The level order representation\nis kind of like a warm-up. It motivates rank and select.",
    "start": "3868250",
    "end": "3873770"
  },
  {
    "text": "But it does not let\nus do subtree size. Subtree size would\nbe nice to do,",
    "start": "3873770",
    "end": "3878900"
  },
  {
    "text": "because you care about\nhow many matches you have after you do a search\ndown a suffix tree. Level order just ain't\ngoing to cut it for that,",
    "start": "3878900",
    "end": "3886400"
  },
  {
    "text": "so we're going to use\ndifferent representation. We're still going to use\nrank and select a lot.",
    "start": "3886400",
    "end": "3891410"
  },
  {
    "text": " And I'll generalize\nforms of rank and select.",
    "start": "3891410",
    "end": "3896550"
  },
  {
    "start": "3896550",
    "end": "3905586"
  },
  {
    "text": "But it's going to be a\nlittle bit more handy. Essentially I want to do more\nlike a depth-first search",
    "start": "3905586",
    "end": "3910670"
  },
  {
    "text": "of the try, less like a-- ",
    "start": "3910670",
    "end": "3919330"
  },
  {
    "text": "less level order,\nso more depth-first. OK. Here's our friend the binary\ntry, same one as before.",
    "start": "3919330",
    "end": "3933795"
  },
  {
    "text": " We had our binary\nrepresentation of it. I'm not going to draw that here.",
    "start": "3933795",
    "end": "3941320"
  },
  {
    "text": "First thing I want to\ndo is say, hey, look, this is the same thing\nas a rooted ordered tree.",
    "start": "3941320",
    "end": "3947940"
  },
  {
    "text": " I already mentioned that\nthere's the same number of them.",
    "start": "3947940",
    "end": "3954839"
  },
  {
    "text": "There's Catalan of these and\nthere's Catalan of these. So a rooted ordered\ntree has a node,",
    "start": "3954840",
    "end": "3959954"
  },
  {
    "text": "it has some number of\nchildren, then more nodes. The children are ordered, but\nthey don't have labels on them.",
    "start": "3959955",
    "end": "3966000"
  },
  {
    "text": "So it's a tree, not a try. ",
    "start": "3966000",
    "end": "3971500"
  },
  {
    "text": "So I claim these two\nthings are equivalent. And there's a nice combinatorial\nbijection between them,",
    "start": "3971500",
    "end": "3977540"
  },
  {
    "text": "which you may have seen before. It's kind of a classic. But here we're going to\nuse it for handy stuff.",
    "start": "3977540",
    "end": "3984500"
  },
  {
    "text": "Basically so binary\ntries distinguish",
    "start": "3984500",
    "end": "3990850"
  },
  {
    "text": "between left and right. Rooted order trees do not. They just have order.",
    "start": "3990850",
    "end": "3996160"
  },
  {
    "text": "So to clean that up,\nI'm going to look at the right spine of the try,\ndistinguish that, because right",
    "start": "3996160",
    "end": "4002849"
  },
  {
    "text": "and left make the difference\nhere, and then recurse. So this is the right\nspine of down here.",
    "start": "4002850",
    "end": "4008640"
  },
  {
    "text": "This is the right\nspine of this subtree. Now every node lives\nin some right spine.",
    "start": "4008640",
    "end": "4015030"
  },
  {
    "text": "And then I'm just\ngoing to rotate 45 degrees counterclockwise.",
    "start": "4015030",
    "end": "4021390"
  },
  {
    "text": "So I have A, E, G. That's\nmy first right spine. I'm going to think of them as\nchildren of a new root node.",
    "start": "4021390",
    "end": "4031710"
  },
  {
    "text": "And then they have\nchildren below that which correspond to the\nright spines that hang below.",
    "start": "4031710",
    "end": "4037109"
  },
  {
    "text": "So A, for example, has\nthis right spine, B, C, D.",
    "start": "4037110",
    "end": "4043044"
  },
  {
    "text": "So we have B, C, D here.",
    "start": "4043044",
    "end": "4048089"
  },
  {
    "text": "E has a right spine of\nF hanging off of it. G has no right spine\nhanging off of it.",
    "start": "4048090",
    "end": "4055589"
  },
  {
    "text": "So you need to prove that\nthis is a real bijection. Every binary try\ncan be so converted",
    "start": "4055590",
    "end": "4060829"
  },
  {
    "text": "into a rooted order tree. And it's unique, so if\nit's different over here, it will be different over here.",
    "start": "4060830",
    "end": "4066450"
  },
  {
    "text": "And you can convert\nbackwards as well, if you just delete\nthe super-root and turn all the children\ninto a right spine or recurse.",
    "start": "4066450",
    "end": "4072150"
  },
  {
    "text": "They're really the same thing. This is why there's\nCatalan of each of them. ",
    "start": "4072150",
    "end": "4078120"
  },
  {
    "text": "OK.  Now what I'd really like to\nget to is balanced parentheses.",
    "start": "4078120",
    "end": "4084740"
  },
  {
    "start": "4084740",
    "end": "4092260"
  },
  {
    "text": "And while it's a\nlittle unclear how to represent a binary try\nwith balanced parentheses,",
    "start": "4092260",
    "end": "4097330"
  },
  {
    "text": "these things it's really clear\nhow to represent a binary-- represent with\nbalanced parentheses. Here I just do an\nEuler tour, which",
    "start": "4097330",
    "end": "4105140"
  },
  {
    "text": "was a depth-first search\nvisiting these things. And every time I start a node,\nI'll write an open paren.",
    "start": "4105140",
    "end": "4110589"
  },
  {
    "text": "Every time I finish a node,\nI write a close paren. Similar to representation\nwe talked about before.",
    "start": "4110590",
    "end": "4116330"
  },
  {
    "text": "So this would be-- I'm going to need more space. ",
    "start": "4116330",
    "end": "4122020"
  },
  {
    "text": "This is going to be an\nopen paren for star. Why don't I make\nthat one really big?",
    "start": "4122020",
    "end": "4127420"
  },
  {
    "text": "We start here. Then we open the A chunk. Then we do B, which\nhas no children.",
    "start": "4127420",
    "end": "4134170"
  },
  {
    "text": "Then we do C, which\nhas no children. Then we do D, which\nhas no children.",
    "start": "4134170",
    "end": "4139568"
  },
  {
    "text": "And that finishes A. OK. Then we start E.\nThen we do F. Then",
    "start": "4139569",
    "end": "4150430"
  },
  {
    "text": "we finish F. We finish\nE. Then we do G.",
    "start": "4150430",
    "end": "4158290"
  },
  {
    "text": "And then we're done with star. ",
    "start": "4158290",
    "end": "4163339"
  },
  {
    "text": "So that's a very\neasy transformation. Again, there are Catalan many\nof these balanced parens. You think, oh, there's\n2 to the n of them,",
    "start": "4163340",
    "end": "4172399"
  },
  {
    "text": "because each paren\ncould be open or closed. But they have to be balanced,\nso it's a little bit more constrained than that.",
    "start": "4172399",
    "end": "4179810"
  },
  {
    "text": "And so it ends up being\nCatalan of n over 2 if there's n parens, because\nthere's 2 parens here",
    "start": "4179810",
    "end": "4187009"
  },
  {
    "text": "for every node over here. This is going to\nbe our bit string. Open parens are 0's. Close parens are 1's.",
    "start": "4187010",
    "end": "4193729"
  },
  {
    "text": "This has roughly 2n bits, 2n\nplus 2, I guess, for the star,",
    "start": "4193729",
    "end": "4199190"
  },
  {
    "text": "relative to this n. So basically, nodes\nhere correspond",
    "start": "4199190",
    "end": "4205060"
  },
  {
    "text": "to nodes here, which correspond\nto an open paren, close paren",
    "start": "4205060",
    "end": "4210380"
  },
  {
    "text": "pair over here. Now, we can't afford\nto store these labels. Those are just guidelines to\nthink about what you need.",
    "start": "4210380",
    "end": "4218402"
  },
  {
    "text": "So let's think about there\nare three things we really want here, left child,\nright child, and parent.",
    "start": "4218402",
    "end": "4224610"
  },
  {
    "start": "4224610",
    "end": "4231270"
  },
  {
    "text": "This is the thing\nthat we care about, but this is what\nwe're going to store. So I want to translate\nfrom here to here to here.",
    "start": "4231270",
    "end": "4239610"
  },
  {
    "text": "This is an exercise\nin translation. So what does a left\nchild mean here?",
    "start": "4239610",
    "end": "4244830"
  },
  {
    "text": "Left child over here\ncorresponds to-- ",
    "start": "4244830",
    "end": "4251670"
  },
  {
    "text": "well, I guess it goes-- in general, the left child\ngoes to this branch, which is like all of these\nchildren pointers from A.",
    "start": "4251670",
    "end": "4258180"
  },
  {
    "text": "But really, if you\nfollow the left child, you get to B, not any\nof the other things on the right spine. You always get to the\ntop of the right spine.",
    "start": "4258180",
    "end": "4264804"
  },
  {
    "text": "Top of the right spine is the\nleft-most node in the spine here. In other words, it is the\nfirst child of a node.",
    "start": "4264804",
    "end": "4273389"
  },
  {
    "text": "First child of a\nnode, if there is one, is going to be the\nleft child over here.",
    "start": "4273390",
    "end": "4278580"
  },
  {
    "text": "Right child is like\nfollowing the spine. That's like going this way.",
    "start": "4278580",
    "end": "4283590"
  },
  {
    "text": "So right child is what I\nwould call next sibling. ",
    "start": "4283590",
    "end": "4289920"
  },
  {
    "text": "The next sibling to the\nright, if there is one, that's going to correspond\nto the right child, because we're just\nfollowing a right spine.",
    "start": "4289920",
    "end": "4296681"
  },
  {
    "text": "OK. Parent is a little trickier. Parent is the reverse\nof these, so either you",
    "start": "4296681",
    "end": "4303810"
  },
  {
    "text": "take your previous sibling-- but if you're here and there\nis no previous sibling, then you take your\nactual parent,",
    "start": "4303810",
    "end": "4311260"
  },
  {
    "text": "because parent\nshould walk up here. This was like going\nleft, previous sibling, previous sibling. Parent of this guy, though, is\nthe actual parent over here.",
    "start": "4311260",
    "end": "4320409"
  },
  {
    "text": "So this is going to be previous\nsibling if there is one,",
    "start": "4320410",
    "end": "4325710"
  },
  {
    "text": "or if there isn't one,\nyou go to the parent. ",
    "start": "4325710",
    "end": "4334030"
  },
  {
    "text": "OK. So that's easy translation. Now we need to\nconvert these pictures into balanced parentheses\npictures, which is also",
    "start": "4334030",
    "end": "4341056"
  },
  {
    "text": "going to be easy in itself. But to jump all the way from\nbinary tries to balanced parens would be pretty\nconfusing, so that's why",
    "start": "4341056",
    "end": "4347340"
  },
  {
    "text": "we have this intermediate step. So we want first child here.",
    "start": "4347340",
    "end": "4353760"
  },
  {
    "text": "If I have a paren-- like I'm\nlooking at A. So A corresponds to this paren and this paren.",
    "start": "4353760",
    "end": "4360440"
  },
  {
    "text": "I'm going to represent the node\nlet's say by the first paren. Then the first child is just\nthe very next character.",
    "start": "4360440",
    "end": "4368489"
  },
  {
    "text": "You put the first child\nright after that open paren. So this is really\nthe next character",
    "start": "4368490",
    "end": "4374409"
  },
  {
    "text": "if we want to find\nthe first child. This is if it's an open paren.",
    "start": "4374410",
    "end": "4380945"
  },
  {
    "text": "It could be the very next--\nlike if you're doing B, the very next character\nis a close paren, that means there are no children.",
    "start": "4380945",
    "end": "4386283"
  },
  {
    "text": "But that's how you can tell\nwhether there's a child. If there's an open paren\nright after your open paren, that's your next child.",
    "start": "4386284",
    "end": "4393150"
  },
  {
    "text": "That's your first\nchild, I should say. Now what about next sibling? So let's say again\nI'm at A. And I",
    "start": "4393150",
    "end": "4402060"
  },
  {
    "text": "want to know the next sibling. Next sibling is E.\nSo that's like I go to the close paren\nfor A, and then I",
    "start": "4402060",
    "end": "4408660"
  },
  {
    "text": "go to the next character. So this would be go to the close\nparen for where you are right",
    "start": "4408660",
    "end": "4418740"
  },
  {
    "text": "now, and then go to\nthe next character. ",
    "start": "4418740",
    "end": "4424940"
  },
  {
    "text": "This is, again, if\nit's an open paren. If it's a close paren, then\nyou have no next sibling. So again, you can tell\nwhether this operation fails.",
    "start": "4424940",
    "end": "4432960"
  },
  {
    "text": "What we need is an operation\ngiven a bit string representing balanced parentheses and given a\nquery position of a left paren,",
    "start": "4432960",
    "end": "4441660"
  },
  {
    "text": "I need to know what is\nthe matching right paren. And I'll just wave\nmy hands and claim that can be done with the same\ntechniques as rank and select.",
    "start": "4441660",
    "end": "4450090"
  },
  {
    "text": "It's not easy. It's quite a bit harder. But you do enough\nof these recursions, eventually you can solve it.",
    "start": "4450090",
    "end": "4456510"
  },
  {
    "text": " OK. Last operation is\nparent over here,",
    "start": "4456510",
    "end": "4461880"
  },
  {
    "text": "which corresponds\nto previous sibling, or parent over here,\nwhich corresponds to--",
    "start": "4461880",
    "end": "4467430"
  },
  {
    "text": " there are two cases. We want to move backwards,\nso here we're always",
    "start": "4467430",
    "end": "4474240"
  },
  {
    "text": "ending with next character. So first thing we do is go\nto the previous character. ",
    "start": "4474240",
    "end": "4482840"
  },
  {
    "text": "And there are two cases. If it's a close paren-- so let's say we're here at E,\nwe go to the previous character.",
    "start": "4482840",
    "end": "4491190"
  },
  {
    "text": "If it's a close paren, then\nA is our previous sibling, and so we want to do the\nprevious sibling situation.",
    "start": "4491190",
    "end": "4497340"
  },
  {
    "text": "We again find the match. We hit percent and vi and-- what's the corresponding\nthing in Emacs? I forget.",
    "start": "4497340",
    "end": "4503580"
  },
  {
    "text": "You go to the\nmatching close paren-- sorry, open paren. And then there you go. You've got your\nprevious sibling.",
    "start": "4503580",
    "end": "4509464"
  },
  {
    "text": "So if it's a close\nparen, then you go to the corresponding\nopen paren.",
    "start": "4509464",
    "end": "4515280"
  },
  {
    "text": "If the previous character is an\nopen paren, then you're done. That's your parent.",
    "start": "4515280",
    "end": "4521160"
  },
  {
    "text": "So like here if you're at A,\nyou go to the previous character and it's open paren, then you've\njust found the parent of A.",
    "start": "4521160",
    "end": "4526950"
  },
  {
    "text": "There was no previous sibling. So in either case you end\nup with an open paren,",
    "start": "4526950",
    "end": "4531990"
  },
  {
    "text": "corresponding to either\nyour previous sibling or your parent. So that's left child,\nright child, parent.",
    "start": "4531990",
    "end": "4538620"
  },
  {
    "text": "If you have this\nmatching paren operation, you can do all of\nthese in constant time,",
    "start": "4538620",
    "end": "4544170"
  },
  {
    "text": "and little of n space\nbeyond the 2n bits to write down that bit string.",
    "start": "4544170",
    "end": "4552300"
  },
  {
    "text": "That's not so exciting,\nbecause we just reinvented the same\nresults we had before of doing left, right, and\nparent in constant time.",
    "start": "4552300",
    "end": "4561000"
  },
  {
    "text": "But what we buy out\nof this representation is we can now do subtree size.",
    "start": "4561000",
    "end": "4566010"
  },
  {
    "text": "So this is a little\nbit trickier.",
    "start": "4566010",
    "end": "4573000"
  },
  {
    "text": "Let me go to another board. ",
    "start": "4573000",
    "end": "4578407"
  },
  {
    "text": "But whereas with\nlevel representation it was impossible,\nnow it is possible. ",
    "start": "4578407",
    "end": "4592650"
  },
  {
    "text": "And we're going to use subtree\nsize I think next class, when we do compact suffix trees.",
    "start": "4592650",
    "end": "4598349"
  },
  {
    "text": " So subtree size is what\nwe want in the binary try.",
    "start": "4598350",
    "end": "4607310"
  },
  {
    "text": " In the rooted ordered\ntree it's a little tricky, because subtrees no longer\ncorrespond to subtrees.",
    "start": "4607310",
    "end": "4614420"
  },
  {
    "text": "For example, the\nsubtree of C consists of this subtree and this\nsubtree, so it's really C--",
    "start": "4614420",
    "end": "4623449"
  },
  {
    "text": "over here, it's C and all\nof its right siblings. So this is size of the node\nplus size of right siblings,",
    "start": "4623450",
    "end": "4640400"
  },
  {
    "text": "however many you have. OK. So in the rooted ordered tree,\nit's actually kind of messy.",
    "start": "4640400",
    "end": "4646730"
  },
  {
    "text": "Turns out in the\nbalanced parenthesis it's pretty clean,\nbecause all your right",
    "start": "4646730",
    "end": "4652579"
  },
  {
    "text": "siblings correspond\nto paren groups that just follow each other. And you want to know--",
    "start": "4652580",
    "end": "4658550"
  },
  {
    "text": "so these are a bunch of\nsiblings here of varying size.",
    "start": "4658550",
    "end": "4663812"
  },
  {
    "text": "And we're given,\nsay, this sibling. We want to know\nfor this sibling, up to all the ones to\nthe right-- so there's",
    "start": "4663812",
    "end": "4669190"
  },
  {
    "text": "an enclosing parenthesis\nhere for our parent in this representation.",
    "start": "4669190",
    "end": "4675320"
  },
  {
    "text": "We want to know the length\nof these, so it's just-- ",
    "start": "4675320",
    "end": "4684130"
  },
  {
    "text": "we want to take the-- here\nwe are at this left paren. We want to compute the distance\nto the enclosing close paren.",
    "start": "4684130",
    "end": "4696590"
  },
  {
    "text": "So that's here. That's our enclosing\nclose paren. So here's a new operation.",
    "start": "4696590",
    "end": "4702670"
  },
  {
    "text": "Given a paren pair, I want to\ncompute the enclosing paren pair, these guys.",
    "start": "4702670",
    "end": "4709080"
  },
  {
    "text": "That can also be done\nin constant time with rank-and-select-like techniques. And then you just measure this\ndistance and you divide by 2.",
    "start": "4709080",
    "end": "4716619"
  },
  {
    "text": "That will give you the\nnumber of nodes in here. It's half the number of paren.",
    "start": "4716620",
    "end": "4721810"
  },
  {
    "text": "That will give you subtree size. And we have a couple\nextra seconds, so another bonus\nis suppose you want",
    "start": "4721810",
    "end": "4727660"
  },
  {
    "text": "to know the number of\nleaves in a subtree. ",
    "start": "4727660",
    "end": "4733390"
  },
  {
    "text": "If I recall correctly,\nthat's something like-- instead of doing this distance\nto the enclosing paren,",
    "start": "4733390",
    "end": "4740500"
  },
  {
    "text": "you do something like rank of-- just rank of that.",
    "start": "4740500",
    "end": "4746469"
  },
  {
    "text": "Those are the number of leaves\nof the enclosing close paren--",
    "start": "4746470",
    "end": "4758920"
  },
  {
    "text": "this is getting\nnotationally confusing-- minus the rank of here.",
    "start": "4758920",
    "end": "4767700"
  },
  {
    "text": "OK. So I just want to compute how\nmany open parens, close parens are there from here to here.",
    "start": "4767700",
    "end": "4772790"
  },
  {
    "text": "And so I just take the rank\nhere, subtract by the rank here. That gives me the number\nof leaves in that range.",
    "start": "4772790",
    "end": "4778620"
  },
  {
    "text": "So this is a\ngeneralization of rank. Before we did rank\nof just a single bit. This is rank of a\ntwo-bit pattern.",
    "start": "4778621",
    "end": "4784610"
  },
  {
    "text": "But two bits is not much\nharder than one bit. You can very easily\nadapt the rank structure we saw to do any two-bit pattern\ninstead of just the one bit.",
    "start": "4784610",
    "end": "4794869"
  },
  {
    "text": "So that gives you\nthe number of leaves in the subtree,\nwhich corresponds to the number of matches. So you can do lots of\nfun things like this.",
    "start": "4794870",
    "end": "4800974"
  },
  {
    "text": "This representation\nis super powerful and we'll use it next time.",
    "start": "4800975",
    "end": "4805940"
  }
]