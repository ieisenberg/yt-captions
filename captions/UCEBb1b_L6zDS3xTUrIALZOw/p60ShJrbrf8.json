[
  {
    "text": "[SQUEAKING] [RUSTLING] [CLICKING]",
    "start": "0",
    "end": "6930"
  },
  {
    "start": "6930",
    "end": "13190"
  },
  {
    "text": "ZHENGZHONG JIN: So\nhere, so from this claim we can show this is\nin this relation r. So in fact, we also need a\nCI hash for this relation r.",
    "start": "13190",
    "end": "21154"
  },
  {
    "text": " So in this contraction, we\nneed a CI hash contraction",
    "start": "21155",
    "end": "27140"
  },
  {
    "text": "for this relation r. So this follows from the-- so for this kind of CI hash,\nit follows from the work.",
    "start": "27140",
    "end": "34630"
  },
  {
    "text": " So it almost can handle\nall of the sparse relation",
    "start": "34630",
    "end": "42769"
  },
  {
    "text": "up to some parallel repetition. So I will not go into\nthe detail of this work. So if you are interested,\nyou can read it yourself.",
    "start": "42770",
    "end": "49410"
  },
  {
    "text": "So this is the work-- so it's a CI hash for\nefficiently verifiable product",
    "start": "49410",
    "end": "55130"
  },
  {
    "text": "relation. It's a beautiful work by-- so this is the [INAUDIBLE].",
    "start": "55130",
    "end": "62680"
  },
  {
    "text": " OK. ",
    "start": "62680",
    "end": "75490"
  },
  {
    "text": "OK. So finally-- so let\nme ask a question.",
    "start": "75490",
    "end": "83660"
  },
  {
    "text": "OK. Yeah? AUDIENCE: Could you say\nagain, why we need-- like, why the CIH we saw in last\nweek's class isn't good enough?",
    "start": "83660",
    "end": "90617"
  },
  {
    "text": "ZHENGZHONG JIN: Oh, right. Good question. So last week, the CI hash you\nsaw is for searchable relation.",
    "start": "90617",
    "end": "96260"
  },
  {
    "text": "So that means the relation-- so the relation here.",
    "start": "96260",
    "end": "102460"
  },
  {
    "text": "So the CI hash relation here. ",
    "start": "102460",
    "end": "114640"
  },
  {
    "text": "Right. So the relation here need to\nsatisfy the searchable property. So it means-- so this beta--\nso for any fixed alpha,",
    "start": "114640",
    "end": "122789"
  },
  {
    "text": "there exists a unique beta\nsuch that this alpha beta is",
    "start": "122790",
    "end": "128490"
  },
  {
    "text": "in this relation r. And moreover, there is\nan efficient algorithm,",
    "start": "128490",
    "end": "133620"
  },
  {
    "text": "some efficient\nalgorithm f such that it can take this alpha and\nthe output, such as beta. So that's a efficiently\nsearchable mean.",
    "start": "133620",
    "end": "143310"
  },
  {
    "text": "So here, it's possible\nthat for a fixed alpha there might be multiple beta\nthat can satisfy this relation.",
    "start": "143310",
    "end": "152530"
  },
  {
    "text": "Because for a fixed PCP, there\nmight be multiple queries that can make the PCP be accepted.",
    "start": "152530",
    "end": "159540"
  },
  {
    "text": "Yes. Good question. Yeah. So what-- HR shows that if the\nsparse relation has an efficient",
    "start": "159540",
    "end": "169620"
  },
  {
    "text": "wildfire algorithm\nthen most of the-- then you can build\na CI hash for them",
    "start": "169620",
    "end": "175800"
  },
  {
    "text": "up to some parallel repetition. Roughly speaking, it's a-- yeah. ",
    "start": "175800",
    "end": "184790"
  },
  {
    "text": "So now, we have a\ncontraction of SNARGs,",
    "start": "184790",
    "end": "190099"
  },
  {
    "text": "but let's see what's the\nproof size for this SNARG. ",
    "start": "190100",
    "end": "195760"
  },
  {
    "text": "So the proof size consists\nof the first message",
    "start": "195760",
    "end": "202599"
  },
  {
    "text": "and the third round message. So the first round\nof message consists of l, l for hash values.",
    "start": "202600",
    "end": "208820"
  },
  {
    "text": "So you can think\nof each hash value is also [INAUDIBLE] ciphertext,\nso it's a poly lambda bits.",
    "start": "208820",
    "end": "214900"
  },
  {
    "text": "So in total the first round of\nmessage consists of poly c times",
    "start": "214900",
    "end": "223599"
  },
  {
    "text": "poly l, but it is\nindependent of k.",
    "start": "223600",
    "end": "232300"
  },
  {
    "text": "And the third round message is\nk times poly log c times poly l",
    "start": "232300",
    "end": "244530"
  },
  {
    "text": "because, for each in the Celeron\nmessage, for each instance",
    "start": "244530",
    "end": "249810"
  },
  {
    "text": "you send a q PCP answers. So the size of q is\nlambda times poly log c.",
    "start": "249810",
    "end": "259028"
  },
  {
    "text": "So in total, you\nsend a k of them. So in total, it's k times this.",
    "start": "259029",
    "end": "264530"
  },
  {
    "text": " So this is already\nnon-trivial because it's a--",
    "start": "264530",
    "end": "270270"
  },
  {
    "text": "so this number, it could be much\nsmaller than k times k times w.",
    "start": "270270",
    "end": "277440"
  },
  {
    "text": "Because the second term\nis almost order of k, and the first term is almost c.",
    "start": "277440",
    "end": "283050"
  },
  {
    "text": "So this is already non-trivial,\nbut it's still large. So the big issue is, if you\nlook at the verification time,",
    "start": "283050",
    "end": "293630"
  },
  {
    "text": "so the verification time is\nyou will see is k times poly c.",
    "start": "293630",
    "end": "305570"
  },
  {
    "text": "The reason is the verifier\nneed to verify the PCP",
    "start": "305570",
    "end": "310670"
  },
  {
    "text": "answers for each of\nthe instances for x1 to xk, so in this step.",
    "start": "310670",
    "end": "318840"
  },
  {
    "text": "So each PCP verification\nneed to take c time, and in total, it need\nto take k times poly c.",
    "start": "318840",
    "end": "328110"
  },
  {
    "text": "Yeah? AUDIENCE: Why is there a\npoly lambda at the end? ZHENGZHONG JIN: So that's\nbecause each query is a--",
    "start": "328110",
    "end": "335569"
  },
  {
    "text": "so each query, so\nif you remember-- yeah, so here. So each query size is a\nlambda times poly log c.",
    "start": "335570",
    "end": "344020"
  },
  {
    "text": " So it's-- yeah.",
    "start": "344020",
    "end": "349860"
  },
  {
    "text": "AUDIENCE: So they're not\njust querying single bits. They're querying\nlike blocks of links. ",
    "start": "349860",
    "end": "356317"
  },
  {
    "text": "ZHENGZHONG JIN: So here, we have\na lambda term because we need to do the parallel repetition. So you take PCP with\nconstant suddenness arrow,",
    "start": "356317",
    "end": "365920"
  },
  {
    "text": "and then you amplify it lambda\ntimes by parallel repetition.",
    "start": "365920",
    "end": "371392"
  },
  {
    "text": "AUDIENCE: And we\nwant to amplify it because we want complete,\nlike perfect completeness or something? ZHENGZHONG JIN:\nYeah, so you can have",
    "start": "371392",
    "end": "377770"
  },
  {
    "text": "PCP with perfect completeness. So you don't need\nto worry about when",
    "start": "377770",
    "end": "382960"
  },
  {
    "text": "you do the parallel repetition. So verification time\nis still very large.",
    "start": "382960",
    "end": "389080"
  },
  {
    "text": "So in fact you don't have any\nsavings if you do this directly, so on the verification time.",
    "start": "389080",
    "end": "396340"
  },
  {
    "text": "So let's consider for a\ngeneral SNARGs for batch",
    "start": "396340",
    "end": "403389"
  },
  {
    "text": "NP, or BARGs, so what's\nthe verification time? So remember, in a\nbark, the verifier",
    "start": "403390",
    "end": "410740"
  },
  {
    "text": "need to read at least the\nCRS and all of the statements to verify the proof.",
    "start": "410740",
    "end": "416600"
  },
  {
    "text": "So the verifier need to at\nleast read all of the instance.",
    "start": "416600",
    "end": "422430"
  },
  {
    "text": "So it seems that there is a\nlower bound on the verification time. The lower bound is just\nat least K times X.",
    "start": "422430",
    "end": "436805"
  },
  {
    "text": "So next I will show you how to\nreduce the verification time and the proof size of BARGs. ",
    "start": "436805",
    "end": "447800"
  },
  {
    "text": "So we will consider\na variant of BARG, and it don't have this lower\nbound on the verification time.",
    "start": "447800",
    "end": "453400"
  },
  {
    "text": " So I will define a\nnew notion of BARGs.",
    "start": "453400",
    "end": "461390"
  },
  {
    "text": "Let me erase this. ",
    "start": "461390",
    "end": "489820"
  },
  {
    "text": "So this notion of BARGs\nis called the index BARG,",
    "start": "489820",
    "end": "501010"
  },
  {
    "text": "or you can also call it SNARGs. ",
    "start": "501010",
    "end": "506560"
  },
  {
    "text": "for a batch index. ",
    "start": "506560",
    "end": "519820"
  },
  {
    "text": "So in the original\ndefinition of BARGs, the verifier need to\nread all of the instance, because the instance\nare non-uniform.",
    "start": "519820",
    "end": "526760"
  },
  {
    "text": "So in this notion, we will\nconsider a special case when this instance are uniform.",
    "start": "526760",
    "end": "532580"
  },
  {
    "text": "So intuitively, it means there\nexists some circuit U such",
    "start": "532580",
    "end": "539170"
  },
  {
    "text": "that the I-th instance is\ngenerated by using the circuit U and the index I.\nSo intuitively, it",
    "start": "539170",
    "end": "549490"
  },
  {
    "text": "says the instance can be\ndescribed in a uniform way by only using the index.",
    "start": "549490",
    "end": "554500"
  },
  {
    "text": "And if this is the\ncase, then what the prover will try\nto prove is X1 to XK",
    "start": "554500",
    "end": "561700"
  },
  {
    "text": "is all in this language L. So now, it is equivalent to\nsay, so for each index I,",
    "start": "561700",
    "end": "573580"
  },
  {
    "text": "there exists a witness WI\nsuch that this circuit C",
    "start": "573580",
    "end": "579280"
  },
  {
    "text": "and the UI WI equals 1.",
    "start": "579280",
    "end": "584350"
  },
  {
    "text": "So then we can define. So essentially, this you can\nview this as a new NP relation.",
    "start": "584350",
    "end": "592500"
  },
  {
    "text": "So the new NP relation\nis defined as follows. So the instance\nis just an index,",
    "start": "592500",
    "end": "600210"
  },
  {
    "text": "and it verifies there\nexists a WI such that. ",
    "start": "600210",
    "end": "616070"
  },
  {
    "text": "So this is just a\nrewriting of this, right. ",
    "start": "616070",
    "end": "624620"
  },
  {
    "text": "So, right. And you can view this as a\nnew NP verification circuit",
    "start": "624620",
    "end": "632420"
  },
  {
    "text": "that some C prime so it only\ntakes WI, and I and WI as input.",
    "start": "632420",
    "end": "638490"
  },
  {
    "text": "And it internally compute\nthis U and verify C. So this inspires us to define\na new notion called index BARG.",
    "start": "638490",
    "end": "646180"
  },
  {
    "text": "So, an index BARG definition--",
    "start": "646180",
    "end": "652810"
  },
  {
    "text": "an index BARG is a BARG\nfor this kind of relation.",
    "start": "652810",
    "end": "669200"
  },
  {
    "text": "So it is for this\nkind of language where the language is just\nsome general NP language,",
    "start": "669200",
    "end": "677420"
  },
  {
    "text": "but the instance is treated\nas an index for this language,",
    "start": "677420",
    "end": "697930"
  },
  {
    "text": "So the prover, we\nstill have a CRS.",
    "start": "697930",
    "end": "704253"
  },
  {
    "text": "And the prover tries to\nconvince the verifier",
    "start": "704253",
    "end": "709970"
  },
  {
    "text": "that all of the indices\nfrom 1, 2, et cetera, to K",
    "start": "709970",
    "end": "716569"
  },
  {
    "text": "is in this language.  So the honest prover only\nneed to read index K,",
    "start": "716570",
    "end": "725450"
  },
  {
    "text": "and it has a witness from W1\nto WK for each of the index.",
    "start": "725450",
    "end": "731790"
  },
  {
    "text": "And the verifier only\nneed to take K as input. So now the verifier,\nso this K can",
    "start": "731790",
    "end": "740690"
  },
  {
    "text": "be represented as log K bits,\nbecause it's just an index. So what's the best verification\ntime we can hope for?",
    "start": "740690",
    "end": "748690"
  },
  {
    "text": " Anyone know?",
    "start": "748690",
    "end": "754410"
  },
  {
    "start": "754410",
    "end": "760910"
  },
  {
    "text": "So all good.  So the verifier only need to\nread this index K and the proof.",
    "start": "760910",
    "end": "769690"
  },
  {
    "text": "So the verifier can be as small\nas verification time, only",
    "start": "769690",
    "end": "775000"
  },
  {
    "text": "need to be some log K, can\nbe as small as this much, so",
    "start": "775000",
    "end": "782020"
  },
  {
    "text": "only depends on log\nK and the lambda. ",
    "start": "782020",
    "end": "793420"
  },
  {
    "text": "And for this index BARG, we\nalso require the completeness and the soundness in\nthe same way as before.",
    "start": "793420",
    "end": "800170"
  },
  {
    "text": "Any questions? Yeah. AUDIENCE: How should\nI think of this U? Or should I think of it as\nbeing part of the instance",
    "start": "800170",
    "end": "805360"
  },
  {
    "text": "or something globally defined?  ZHENGZHONG JIN: So you\ncan always absorb it",
    "start": "805360",
    "end": "813640"
  },
  {
    "text": "in the relation circuit. So you can think it's\npart of the relation. AUDIENCE: Right.",
    "start": "813640",
    "end": "819040"
  },
  {
    "text": "I guess, are we going to pay for\nthe size of the description of U anywhere? Or is that a? ZHENGZHONG JIN:\nRight, right, good.",
    "start": "819040",
    "end": "824680"
  },
  {
    "text": "So the verification\ncircuit, in fact, also depends on C,\nbecause the verifier",
    "start": "824680",
    "end": "829769"
  },
  {
    "text": "needs to read the circuit. AUDIENCE: Yes. ",
    "start": "829770",
    "end": "835470"
  },
  {
    "text": "And is there like a unique\ninstance in this problem, then, like, where you're\nsaying K itself, is that OK?",
    "start": "835470",
    "end": "841830"
  },
  {
    "text": "ZHENGZHONG JIN:\nSo now, the point is now the verification time\nonly depends on linear in K.",
    "start": "841830",
    "end": "847080"
  },
  {
    "text": "So previously, you need to\nread all of the instance. And now you, the verification\ntime only grow log in K.",
    "start": "847080",
    "end": "853875"
  },
  {
    "text": "AUDIENCE: Are we supposed to\nthink of C as part of the input? ZHENGZHONG JIN: C as\npart of the input?",
    "start": "853875",
    "end": "861590"
  },
  {
    "text": "AUDIENCE: So like, or I guess\nC prime, which stores U in it.",
    "start": "861590",
    "end": "871325"
  },
  {
    "text": "ZHENGZHONG JIN: Right,\nyes, yes, right. AUDIENCE: So, that\nis part of the input. So V still has to\nread what C prime is?",
    "start": "871325",
    "end": "878649"
  },
  {
    "text": "So doesn't that\ntake a lot of value? ZHENGZHONG JIN: So it\ndepends on how you define it.",
    "start": "878650",
    "end": "884040"
  },
  {
    "text": "So you can define\nit for a fixed C, and then you have\nsuch a proof system. Or you can define a\nproof system for any C,",
    "start": "884040",
    "end": "890160"
  },
  {
    "text": "then you need the verification\ntime to grow with the circuits, size C. AUDIENCE: Is it defining it\nfor a fixed C not that helpful,",
    "start": "890160",
    "end": "899600"
  },
  {
    "text": "because you're just solving\nbatch SNARG for a fixed set of X's.",
    "start": "899600",
    "end": "905032"
  },
  {
    "text": "ZHENGZHONG JIN:\nBut you can choose C to be universal circuit,\nthen it's a-- yeah. ",
    "start": "905032",
    "end": "913250"
  },
  {
    "text": "Things in general. Good question. So in fact, I think, if\nyou take universally,",
    "start": "913250",
    "end": "920150"
  },
  {
    "text": "you need to-- if you\nuse the U, maybe. It's good to think\nof C as the input.",
    "start": "920150",
    "end": "926519"
  },
  {
    "start": "926520",
    "end": "937890"
  },
  {
    "text": "So in the remaining\ntime of this lecture, we'll prove the\nfollowing theorem.",
    "start": "937890",
    "end": "943860"
  },
  {
    "text": "So there exists an\nIndex BARG from LWE.",
    "start": "943860",
    "end": "957990"
  },
  {
    "text": "And the proof size is poly\nlog, so it will grow log",
    "start": "957990",
    "end": "968880"
  },
  {
    "text": "in K, C, and lambda. ",
    "start": "968880",
    "end": "975540"
  },
  {
    "text": "And the verification\ntime is log KC lambda.",
    "start": "975540",
    "end": "986420"
  },
  {
    "text": " So both of them\nalmost match the best",
    "start": "986420",
    "end": "995310"
  },
  {
    "text": "you can hope for, up\nto some polynomial. ",
    "start": "995310",
    "end": "1012190"
  },
  {
    "text": "So I want to emphasize here\nthat, in fact, you can,",
    "start": "1012190",
    "end": "1030670"
  },
  {
    "text": "if you know how to\nbuild this index BARG, then you can build BARGs with\nalmost the same verification",
    "start": "1030670",
    "end": "1036790"
  },
  {
    "text": "time and proof size.  So in other words, in\nfact, a batch of instance",
    "start": "1036790",
    "end": "1045280"
  },
  {
    "text": "are without loss of generality\nuniform, in some sense. So, what I will show\nyou is, in fact, if you",
    "start": "1045280",
    "end": "1057540"
  },
  {
    "text": "know how to build\nindex BARG, then you can use it in a generic\nway to build BARGs.",
    "start": "1057540",
    "end": "1064309"
  },
  {
    "text": " So the reduction\nworks as follows.",
    "start": "1064310",
    "end": "1070445"
  },
  {
    "text": " So now we want to build a\nBARG for a bunch of instance",
    "start": "1070445",
    "end": "1077309"
  },
  {
    "text": "from X1 to XK. ",
    "start": "1077310",
    "end": "1083040"
  },
  {
    "text": "So the idea is we will first\nbuild a Merkle hash of all",
    "start": "1083040",
    "end": "1088770"
  },
  {
    "text": "of the instances. ",
    "start": "1088770",
    "end": "1096679"
  },
  {
    "text": "And we have some hash root. ",
    "start": "1096679",
    "end": "1103470"
  },
  {
    "text": "So now we have the prover send\nthis hash root to the verifier. ",
    "start": "1103470",
    "end": "1110320"
  },
  {
    "text": "And then we have the prover\nto show that for any index I,",
    "start": "1110320",
    "end": "1117559"
  },
  {
    "text": "there exist a local opening,\nrow I. So the local opening,",
    "start": "1117560",
    "end": "1130590"
  },
  {
    "text": "remember, is the root to leaf\npath for each of the leaf. So there exists a\nlocal opening, row I,",
    "start": "1130590",
    "end": "1141410"
  },
  {
    "text": "for XI, such that the local\nverification will pass",
    "start": "1141410",
    "end": "1154010"
  },
  {
    "text": "for this XI local verification.",
    "start": "1154010",
    "end": "1162056"
  },
  {
    "text": " So the local\nverification algorithm",
    "start": "1162056",
    "end": "1168050"
  },
  {
    "text": "will take the hash\nroot and the index I and the XI, which is the open\nthe value, and also this local",
    "start": "1168050",
    "end": "1175780"
  },
  {
    "text": "opening, which is the\nroot-to-leaf path. And moreover, there\nalso exists a WI such",
    "start": "1175780",
    "end": "1183940"
  },
  {
    "text": "that the original\ncircuit is satisfied. ",
    "start": "1183940",
    "end": "1191690"
  },
  {
    "text": "So the idea is you just hash all\nof the instance from X1 to XK, and you send the hash\nvalue to the verifier.",
    "start": "1191690",
    "end": "1200210"
  },
  {
    "text": "Then you prove for each index\nI there exists an opening XI to this hash.",
    "start": "1200210",
    "end": "1206480"
  },
  {
    "text": "And this C of XI is satisfied. So in this way, so you\nconvert a batch of NP instance",
    "start": "1206480",
    "end": "1220870"
  },
  {
    "text": "to a batch index instance. So now, the\nstatement only grows.",
    "start": "1220870",
    "end": "1226520"
  },
  {
    "text": "So it proves something\nfor each index I, so you can view this part.",
    "start": "1226520",
    "end": "1235554"
  },
  {
    "text": " So you can view this part\nas some circuit C prime.",
    "start": "1235555",
    "end": "1242130"
  },
  {
    "text": "So C prime will take index\nI and the witness row I,",
    "start": "1242130",
    "end": "1247160"
  },
  {
    "text": "WI, and check the two things.",
    "start": "1247160",
    "end": "1253220"
  },
  {
    "text": "Then you can generate an index\nBARG for this instance for each",
    "start": "1253220",
    "end": "1259549"
  },
  {
    "text": "of the instance from\nX1, from 1 to K.",
    "start": "1259550",
    "end": "1268514"
  },
  {
    "text": "And then you generate an index\nBARG for this kind of instance. So now you send this to the\nverifier, and this is your BARG.",
    "start": "1268514",
    "end": "1277930"
  },
  {
    "start": "1277930",
    "end": "1284990"
  },
  {
    "text": "So if pi is small\nand H is small, then your total proof\nsize is also small.",
    "start": "1284990",
    "end": "1291549"
  },
  {
    "text": "So that's the idea. ",
    "start": "1291550",
    "end": "1301760"
  },
  {
    "text": "So I will come back\nto this point later.  Because the proof of soundness\nof this transformation",
    "start": "1301760",
    "end": "1308799"
  },
  {
    "text": "is not trivial, because, in\nfact, you will see this is not--",
    "start": "1308800",
    "end": "1314210"
  },
  {
    "text": "so the non-adaptive\nsoundness previously is not sufficient to\nprove the soundness, because this circuit will\ndepends on this hash,",
    "start": "1314210",
    "end": "1322270"
  },
  {
    "text": "and it's chosen adaptively\nby the adversary. So we will come\nback to this point later to show how to\nprove the soundness",
    "start": "1322270",
    "end": "1328870"
  },
  {
    "text": "of this transformation. So next, I will show you how\nto build this index BARG.",
    "start": "1328870",
    "end": "1335430"
  },
  {
    "start": "1335430",
    "end": "1344110"
  },
  {
    "text": "So our starting point\nis still this protocol.",
    "start": "1344110",
    "end": "1351220"
  },
  {
    "text": "So, as I just said earlier,\nso the first round message",
    "start": "1351220",
    "end": "1356640"
  },
  {
    "text": "is small because it\nonly depends on C, but the third round\nmessage is large. So how can we further compress\nthe third round message?",
    "start": "1356640",
    "end": "1363755"
  },
  {
    "start": "1363755",
    "end": "1394366"
  },
  {
    "text": "So in the context of index\nBARG, all of the instance are just indices. So I can replace\nthem with 1 to K.",
    "start": "1394366",
    "end": "1407210"
  },
  {
    "text": "And the idea is we're\ngoing to delegate. ",
    "start": "1407210",
    "end": "1417409"
  },
  {
    "text": "We're going to remove\nthis round of message. And so we're going to delegate\nthe verification of this message",
    "start": "1417410",
    "end": "1426830"
  },
  {
    "text": "to the prover. So the prover will\nhave this open the query, the\ncolumns in his hand,",
    "start": "1426830",
    "end": "1434160"
  },
  {
    "text": "but he is not going to\nsend them to the verifier. Instead, the prover is going\ndo the verification by itself",
    "start": "1434160",
    "end": "1441950"
  },
  {
    "text": "and prove to the verifier those\nverification is indeed correct. So the conjunction\nwork like this.",
    "start": "1441950",
    "end": "1453020"
  },
  {
    "text": "So the prover still sends\nthis H1 to HL to the verifier.",
    "start": "1453020",
    "end": "1463550"
  },
  {
    "text": "And the prover is going\nto compute this PCP",
    "start": "1463550",
    "end": "1469770"
  },
  {
    "text": "query using the CI hash. ",
    "start": "1469770",
    "end": "1474840"
  },
  {
    "text": "And then the prover\nand the verifier is going to run another\nprotocol, so another SNARG.",
    "start": "1474840",
    "end": "1486780"
  },
  {
    "text": "And this SNARG on\nthe prover side, he's going to use the\ncolumns, open the columns",
    "start": "1486780",
    "end": "1499500"
  },
  {
    "text": "as the input to this protocol. And in the end, the verifier\nis convinced the third round",
    "start": "1499500",
    "end": "1510630"
  },
  {
    "text": "message verifies. So what does this\nmean is the prover",
    "start": "1510630",
    "end": "1525980"
  },
  {
    "text": "is going to prove to this\nverifier in this protocol the following language. So there exist log columns\nQ such that two things.",
    "start": "1525980",
    "end": "1544860"
  },
  {
    "text": "So one is for each column, for\neach Q in the query, the set,",
    "start": "1544860",
    "end": "1557299"
  },
  {
    "text": "the hash is computed\ncorrectly, is consistent with\nthe first message.",
    "start": "1557300",
    "end": "1562610"
  },
  {
    "text": "So HQ is the SSV\nhash of the column.",
    "start": "1562610",
    "end": "1570360"
  },
  {
    "text": "The Q is column. So I omit the SSV key here.",
    "start": "1570360",
    "end": "1575390"
  },
  {
    "text": "And the second, for each\nPCP, for each instance,",
    "start": "1575390",
    "end": "1581640"
  },
  {
    "text": "so for any I in K,\nso here the instance",
    "start": "1581640",
    "end": "1586870"
  },
  {
    "text": "is just the index I. The I-th\ninstance XI is just the index I. So he will verify this.",
    "start": "1586870",
    "end": "1593930"
  },
  {
    "text": " So the PCP verification of\nI Q under the Q's column,",
    "start": "1593930",
    "end": "1618130"
  },
  {
    "text": "the I-th coordinate\nof the Q column. And we collect them together.",
    "start": "1618130",
    "end": "1623220"
  },
  {
    "start": "1623220",
    "end": "1630263"
  },
  {
    "text": "So this is a statement this\nprotocol wants to prove. And the prover is\ngoing to supply it",
    "start": "1630264",
    "end": "1637240"
  },
  {
    "text": "with the witness, which is this. ",
    "start": "1637240",
    "end": "1644304"
  },
  {
    "text": "So that's the high-level idea. But to achieve this, so suppose\nwe can rewrite this statement",
    "start": "1644304",
    "end": "1654240"
  },
  {
    "text": "as a batch index statement. Then I can apply the\nsame construction again",
    "start": "1654240",
    "end": "1660059"
  },
  {
    "text": "on top of this statement. So we can apply the same thing\nagain to this new statement.",
    "start": "1660060",
    "end": "1666990"
  },
  {
    "text": "And I can do the recursing. So that's the idea.",
    "start": "1666990",
    "end": "1672780"
  },
  {
    "text": "But the issue is\nhow do I represent this as a batch index language. So how do I represent this\nas a batch of index language?",
    "start": "1672780",
    "end": "1684460"
  },
  {
    "text": "So how do I represent\nit as a batch of index? ",
    "start": "1684460",
    "end": "1691110"
  },
  {
    "text": "So now you can see,\nmaybe you think, OK, so this is almost index\nbecause index language.",
    "start": "1691110",
    "end": "1698400"
  },
  {
    "text": "Because at least this part-- this is clear for any index I.\nThis is for any index I in K,",
    "start": "1698400",
    "end": "1710490"
  },
  {
    "text": "there is something. So this is similar to\nour index language, but this part is not clear.",
    "start": "1710490",
    "end": "1716250"
  },
  {
    "text": "So the reason is\nQ is very small,",
    "start": "1716250",
    "end": "1723480"
  },
  {
    "text": "but the NP witness\nis very large. So if you treat this\nQ as an instance,",
    "start": "1723480",
    "end": "1729750"
  },
  {
    "text": "then the witness size is\nK, because each column has K entries.",
    "start": "1729750",
    "end": "1736360"
  },
  {
    "text": "So each column contains\nthe PCP coordinate for each of the instance,\nso the column size is K.",
    "start": "1736360",
    "end": "1744030"
  },
  {
    "text": "But if I treat this column,\ncolumn Q, as a witness,",
    "start": "1744030",
    "end": "1751360"
  },
  {
    "text": "then when I do the\nrecursion, the proof size will grow with the size\nof K because, again, I",
    "start": "1751360",
    "end": "1760380"
  },
  {
    "text": "will have this kind of\nhash value, some L prime.",
    "start": "1760380",
    "end": "1766900"
  },
  {
    "text": "But those are H1 to L prime,\nH1 prime to L prime prime.",
    "start": "1766900",
    "end": "1773710"
  },
  {
    "text": "So they are for the new\nprotocol and the new instance. So they will grow with the\nsize of K. So that's too large.",
    "start": "1773710",
    "end": "1780820"
  },
  {
    "text": "We cannot afford that. So next, I will\nrewrite this instance",
    "start": "1780820",
    "end": "1789210"
  },
  {
    "text": "as a batch of statements. And the statement\nsize will be K,",
    "start": "1789210",
    "end": "1794590"
  },
  {
    "text": "but the NP witness\nwill be small. So how do I rewrite it?",
    "start": "1794590",
    "end": "1801420"
  },
  {
    "text": "So let's look at what this\ndo, this verification do. So for each of\nthis verification,",
    "start": "1801420",
    "end": "1810360"
  },
  {
    "text": "we have a column Q,\nand its size is K.",
    "start": "1810360",
    "end": "1819470"
  },
  {
    "text": "So it will recompute\nthis SSV hash and check if it is the same with\nsome HQ, which is the hash that",
    "start": "1819470",
    "end": "1828200"
  },
  {
    "text": "was sent in the first round.  So the idea is that\nsuppose this SSV hash,",
    "start": "1828200",
    "end": "1837680"
  },
  {
    "text": "suppose we have some more\nstructure of this SSV hash, then I can local verify it.",
    "start": "1837680",
    "end": "1844050"
  },
  {
    "text": "So that means, for\nexample, if the SSV hash",
    "start": "1844050",
    "end": "1857420"
  },
  {
    "text": "is built as a Merkle tree, then\nI can replace this verification",
    "start": "1857420",
    "end": "1862880"
  },
  {
    "text": "by verify that for\neach index I in K,",
    "start": "1862880",
    "end": "1873920"
  },
  {
    "text": "there exists a local\nopening, rho IQ,",
    "start": "1873920",
    "end": "1879490"
  },
  {
    "text": "so rho IQ is the local opening. You can think for each\nindex I, I have an entry.",
    "start": "1879490",
    "end": "1889490"
  },
  {
    "text": "The entry is column Q, the\nI-th position of column Q,",
    "start": "1889490",
    "end": "1895400"
  },
  {
    "text": "and I have a local\nopening for that, rho IQ.",
    "start": "1895400",
    "end": "1900430"
  },
  {
    "text": "So I only need to show there\nexists such a local opening for this hash.",
    "start": "1900430",
    "end": "1905559"
  },
  {
    "text": "So here, HQ is the hash value. So for HQ, I only\nneed to verify this.",
    "start": "1905560",
    "end": "1921764"
  },
  {
    "start": "1921765",
    "end": "1928180"
  },
  {
    "text": "So now I get a batch\nof NP instance. ",
    "start": "1928180",
    "end": "1943950"
  },
  {
    "text": "So let me rewrite this. ",
    "start": "1943950",
    "end": "1960870"
  },
  {
    "text": "So suppose I have a SSV\nbuilt in the Merkle tree way,",
    "start": "1960870",
    "end": "1969570"
  },
  {
    "text": "so the protocol\nwill work like this. So initially, we have H1\nto HL, and we have this Q.",
    "start": "1969570",
    "end": "1984360"
  },
  {
    "text": "So in the new\nprotocol the prover",
    "start": "1984360",
    "end": "1989460"
  },
  {
    "text": "is going to supply it with\nquery the column for this Q,",
    "start": "1989460",
    "end": "1996590"
  },
  {
    "text": "and also a bunch of\nlocal openings for each coordinates in this\nQ. So this protocol",
    "start": "1996590",
    "end": "2021180"
  },
  {
    "text": "is a new index BARG protocol.",
    "start": "2021180",
    "end": "2026940"
  },
  {
    "text": "It will prove for a new instance\nL for a new language L prime.",
    "start": "2026940",
    "end": "2032259"
  },
  {
    "text": "Let's denote it. So L prime, it contains all the\nindex I. And for each index I,",
    "start": "2032260",
    "end": "2044860"
  },
  {
    "text": "I need to show there exist a\nwitness which is column QI.",
    "start": "2044860",
    "end": "2054830"
  },
  {
    "start": "2054830",
    "end": "2063110"
  },
  {
    "text": "So this is the I-th PCP answer. And they are corresponding.",
    "start": "2063110",
    "end": "2070309"
  },
  {
    "text": "I also need this rho IQ. ",
    "start": "2070310",
    "end": "2084980"
  },
  {
    "text": "So first I need to\nverify the PCP answers. ",
    "start": "2084980",
    "end": "2112900"
  },
  {
    "text": "And second, I need to verify\nthe local opening is correct. ",
    "start": "2112900",
    "end": "2121330"
  },
  {
    "text": "So there is some local opening\nverification algorithm. The local verification\nalgorithm will",
    "start": "2121330",
    "end": "2127690"
  },
  {
    "text": "take the hash root\nfor each Q. And so I",
    "start": "2127690",
    "end": "2134470"
  },
  {
    "text": "need to verify this for every\nQ. And this local verification",
    "start": "2134470",
    "end": "2145510"
  },
  {
    "text": "algorithm of SSV\nwill verify row IQ. ",
    "start": "2145510",
    "end": "2170250"
  },
  {
    "text": "Any questions?  So this is the new\ninstance, new L prime.",
    "start": "2170250",
    "end": "2179109"
  },
  {
    "text": " So for each I--",
    "start": "2179110",
    "end": "2185590"
  },
  {
    "text": " so the prover need to\nprove 1, 2, et cetera, to K",
    "start": "2185590",
    "end": "2193860"
  },
  {
    "text": "are all in this L prime. ",
    "start": "2193860",
    "end": "2214320"
  },
  {
    "text": "Any questions? ",
    "start": "2214320",
    "end": "2229060"
  },
  {
    "text": "AUDIENCE: I just think we're\ngoing to recurse with this? And the idea is that the\nnumber K has remained the same",
    "start": "2229060",
    "end": "2235760"
  },
  {
    "text": "and the witnesses are\nnot throwing anything. ZHENGZHONG JIN: Good question. So if you do this recursion,\nit will loop forever.",
    "start": "2235760",
    "end": "2241630"
  },
  {
    "text": "Because from the beginning,\nwe have K instances. And then in the next\nlevel of the recursion,",
    "start": "2241630",
    "end": "2247310"
  },
  {
    "text": "we still have K instances. AUDIENCE: [INAUDIBLE]\nbunch it up, maybe, like, you do it [INAUDIBLE].",
    "start": "2247310",
    "end": "2252660"
  },
  {
    "text": "ZHENGZHONG JIN: Exactly. So that's what we will do next. Any questions?",
    "start": "2252660",
    "end": "2258020"
  },
  {
    "text": "AUDIENCE: So HQ is a\nhash of statements? ZHENGZHONG JIN: Sorry?",
    "start": "2258020",
    "end": "2263770"
  },
  {
    "text": "AUDIENCE: HQ. ZHENGZHONG JIN: Right. So HQ is part of the statement. AUDIENCE: Is it the hash\nof the statement X1 to XK?",
    "start": "2263770",
    "end": "2273940"
  },
  {
    "text": "ZHENGZHONG JIN: You mean,\nwhere is HQ comes from? AUDIENCE: Yes. ZHENGZHONG JIN: Good. So HQ is the same as HQ here.",
    "start": "2273940",
    "end": "2283569"
  },
  {
    "text": "So initially, we have a bunch\nof statements from 1 to K, and each of them has NP witness\nfrom omega 1 to omega K.",
    "start": "2283570",
    "end": "2292030"
  },
  {
    "text": "And we compute this PCP matrix.",
    "start": "2292030",
    "end": "2297210"
  },
  {
    "text": "And for each column,\nwe hash it to H1 to HL. ",
    "start": "2297210",
    "end": "2303210"
  },
  {
    "text": "And HQ is just the Q's\ncolumn of this H1 to HQ,",
    "start": "2303210",
    "end": "2311849"
  },
  {
    "text": "the index Q among\nthese H1 to HQ. ",
    "start": "2311850",
    "end": "2319639"
  },
  {
    "text": "AUDIENCE: Can I see the local\nopening version of the SSB is some variant of the FHE\nfitting with a Merkle tree size?",
    "start": "2319639",
    "end": "2325335"
  },
  {
    "text": "ZHENGZHONG JIN: Good, good. So that's what I'm going\nto talk about next.",
    "start": "2325335",
    "end": "2330480"
  },
  {
    "text": "So now you may ask, so how\ndo we construct such a SSV",
    "start": "2330480",
    "end": "2335940"
  },
  {
    "text": "with a Merkle\ntree-style construction,",
    "start": "2335940",
    "end": "2342210"
  },
  {
    "text": "because the construction\nI just showed you doesn't satisfy this property? So this is SSV.",
    "start": "2342210",
    "end": "2348490"
  },
  {
    "start": "2348490",
    "end": "2357560"
  },
  {
    "text": "So SSV with this local\nopening property,",
    "start": "2357560",
    "end": "2363470"
  },
  {
    "text": "so the idea is, if we build\na hash like a Merkle tree then we have this local\nopening, so for example.",
    "start": "2363470",
    "end": "2371005"
  },
  {
    "text": " The issue is how do we still\nhave somewhere-- this somewhere",
    "start": "2371005",
    "end": "2381630"
  },
  {
    "text": "so that is a binding property. So at each node of\nthe tree, we are",
    "start": "2381630",
    "end": "2387140"
  },
  {
    "text": "going to peek under the hood\nof FHE one of its children.",
    "start": "2387140",
    "end": "2393049"
  },
  {
    "text": "So you can think, initially, we\nhave some X1 to XK in the clear.",
    "start": "2393050",
    "end": "2400410"
  },
  {
    "text": " So at each level, we're\ngoing to pick either",
    "start": "2400410",
    "end": "2407380"
  },
  {
    "text": "its left child or right child\nfor each node in this level. For example, in this level, so\nsuppose this is your index I,",
    "start": "2407380",
    "end": "2416740"
  },
  {
    "text": "then what we can\ndo is for each node in this level we're going\nto pick the left child.",
    "start": "2416740",
    "end": "2422425"
  },
  {
    "text": " And at this level, we're\ngoing to pick the right child.",
    "start": "2422425",
    "end": "2428265"
  },
  {
    "text": " So at each level, we're going to\nhave some homomorphic encryption",
    "start": "2428265",
    "end": "2443170"
  },
  {
    "text": "of some bit, so some bit, B1\nand so let's say this is B2.",
    "start": "2443170",
    "end": "2450640"
  },
  {
    "text": "And each level, we're going\nto homomorphically evaluate this using this\nB1 and B2 to pick",
    "start": "2450640",
    "end": "2461220"
  },
  {
    "text": "the children under the hood of\nFHE in the same way as before. So this can give you\nSSV with local opening.",
    "start": "2461220",
    "end": "2469385"
  },
  {
    "text": " So one property we further\nrequire about this SSV",
    "start": "2469385",
    "end": "2478530"
  },
  {
    "text": "is the local\nopening correctness.",
    "start": "2478530",
    "end": "2483990"
  },
  {
    "text": "So we require this\nproperty because, remember, in the soundness proof we\nneed to ensure if the proof is",
    "start": "2483990",
    "end": "2493080"
  },
  {
    "text": "accepted in the third round,\nthen the proof contains some opening of the SSV.",
    "start": "2493080",
    "end": "2500400"
  },
  {
    "text": "And we need to show this opening\nmust be consistent with the SSV",
    "start": "2500400",
    "end": "2505559"
  },
  {
    "text": "extracted value. So originally, this is easy to\nensure because the verifier sees",
    "start": "2505560",
    "end": "2511680"
  },
  {
    "text": "the entire opening. But now it's not clear\nwhether this can still hold.",
    "start": "2511680",
    "end": "2517539"
  },
  {
    "text": "So now the verifier only sees\na local opening of the SSV.",
    "start": "2517540",
    "end": "2523010"
  },
  {
    "text": "So it does not see\nall of the X1 to XK. It only sees the\nroot-to-leaf path of some XI.",
    "start": "2523010",
    "end": "2531520"
  },
  {
    "text": "So we need a further\nlocal opening correctness. ",
    "start": "2531520",
    "end": "2548079"
  },
  {
    "text": "So the correctness\nof local opening says this SSV with local opening\nhas some local verification",
    "start": "2548080",
    "end": "2559150"
  },
  {
    "text": "algorithm. So it will take\nthe hash root of H",
    "start": "2559150",
    "end": "2565599"
  },
  {
    "text": "and some index I, and XI,\nand the root-to-leaf path",
    "start": "2565600",
    "end": "2570820"
  },
  {
    "text": "for this XI. And it can decide whether\nto accept or reject.",
    "start": "2570820",
    "end": "2576640"
  },
  {
    "text": "And the local opening property\nsays that for any index I, H, XI, and rho I, so if\nthis local verification passes,",
    "start": "2576640",
    "end": "2601680"
  },
  {
    "text": "then it must be case that the\nextracted value of the hash",
    "start": "2601680",
    "end": "2616020"
  },
  {
    "text": "equals this XI. So here, so the\nlocal verification",
    "start": "2616020",
    "end": "2629880"
  },
  {
    "text": "also need to use the\nSSV key to check this. ",
    "start": "2629880",
    "end": "2637940"
  },
  {
    "text": "So here, if this is\ntrue and the SSV key",
    "start": "2637940",
    "end": "2643550"
  },
  {
    "text": "is generated for the index I,\nif the local replication passes,",
    "start": "2643550",
    "end": "2656750"
  },
  {
    "text": "then the extracted\nvalue must be XI. So this is not\ntrivially correct. This is not trivially hold if\nyou use just this construction",
    "start": "2656750",
    "end": "2664970"
  },
  {
    "text": "because a malicious\nfile, it will",
    "start": "2664970",
    "end": "2670369"
  },
  {
    "text": "contain the root-to-leaf\npath to this XI. But it also needs to contain\nthe siblings of this.",
    "start": "2670370",
    "end": "2678060"
  },
  {
    "text": "So in this authenticated\npath, it also need to contain the siblings\nof each node in the path.",
    "start": "2678060",
    "end": "2684780"
  },
  {
    "text": "But those siblings may not be\nwell-formed FHE ciphertext. So indeed, you need to further\nadd some bootstrap mechanism",
    "start": "2684780",
    "end": "2693035"
  },
  {
    "text": "here.  So at each level of the FHE, you\nneed to use a different FHE key.",
    "start": "2693035",
    "end": "2700940"
  },
  {
    "text": "And at the next level, you\nneed to homomorphically decrypt the FHE ciphertext\nat the previous level",
    "start": "2700940",
    "end": "2707290"
  },
  {
    "text": "to ensure it's a\nwell-formed ciphertext. So I'm not going to the details,\nbut you can fix this easily",
    "start": "2707290",
    "end": "2713500"
  },
  {
    "text": "by your own. ",
    "start": "2713500",
    "end": "2718930"
  },
  {
    "text": "So now, any question\nwith this construction?",
    "start": "2718930",
    "end": "2725515"
  },
  {
    "text": "AUDIENCE: Why are we now using\nSSV in a Merkle tree style",
    "start": "2725516",
    "end": "2731650"
  },
  {
    "text": "instead of? ZHENGZHONG JIN: Good question. So if you directly use SSV\nin a Merkle tree style,",
    "start": "2731650",
    "end": "2739599"
  },
  {
    "text": "maybe there are some\nciphertext sites blow up. So each time the ciphertext size\nis lambda times larger than the.",
    "start": "2739600",
    "end": "2749125"
  },
  {
    "text": "AUDIENCE: I mean, in this\nnew version index BARG,",
    "start": "2749125",
    "end": "2754130"
  },
  {
    "text": "why now when we hash the column? We hash it in the\nMerkle tree side instead of hashing it in one?",
    "start": "2754130",
    "end": "2763640"
  },
  {
    "text": "ZHENGZHONG JIN: You mean,\nwe don't hash it entirely. We hash in the\nMerkle tree style.",
    "start": "2763640",
    "end": "2769470"
  },
  {
    "text": "AUDIENCE: Yes, yes. ZHENGZHONG JIN: Yes, yes. Yes, that's what we are doing. ",
    "start": "2769470",
    "end": "2777180"
  },
  {
    "text": "Any questions? ",
    "start": "2777180",
    "end": "2785210"
  },
  {
    "text": "So if you do this\nconstruction directly, then this construction\nwill loop forever because the recursion\nwill never end.",
    "start": "2785210",
    "end": "2792390"
  },
  {
    "text": "So initially, we\nhave K instances. And at the next level,\nit still has K instances. So next, what we will do is\nwe will use a 2-to-1 trick",
    "start": "2792390",
    "end": "2801470"
  },
  {
    "text": "to reduce the number\nof instances each time. ",
    "start": "2801470",
    "end": "2826210"
  },
  {
    "text": "So let's denote this circuit. So this part of the\ncircuit has some C prime.",
    "start": "2826210",
    "end": "2834380"
  },
  {
    "text": "So C prime will take some index\nI and the witness WI prime. So the witness WI prime\ncorresponds to this part.",
    "start": "2834380",
    "end": "2841610"
  },
  {
    "text": "So this part is the WI prime",
    "start": "2841610",
    "end": "2849290"
  },
  {
    "text": "So the 2-to-1 trick is this. ",
    "start": "2849290",
    "end": "2861280"
  },
  {
    "text": "Suppose you have K instances. ",
    "start": "2861280",
    "end": "2872010"
  },
  {
    "text": "So now you want to verify all of\nthem So you have instance from 1",
    "start": "2872010",
    "end": "2877770"
  },
  {
    "text": "to K, and their witness\nare W1 prime to WK prime.",
    "start": "2877770",
    "end": "2883390"
  },
  {
    "text": "So the prover wants to prove to\nthe verifier that all of them are correct, are in\nthis language L prime.",
    "start": "2883390",
    "end": "2890760"
  },
  {
    "text": "So what do you do is you look\nat any two adjacent indices",
    "start": "2890760",
    "end": "2899790"
  },
  {
    "text": "instances and just combine them. ",
    "start": "2899790",
    "end": "2907571"
  },
  {
    "text": "So now, the combined\ninstance is still 1,",
    "start": "2907572",
    "end": "2913470"
  },
  {
    "text": "but the witnesses are\nconcatenated together. So you have this W1\nprime and W2 prime.",
    "start": "2913470",
    "end": "2923310"
  },
  {
    "text": "And the next two\ninstances are 3 and 4.",
    "start": "2923310",
    "end": "2929890"
  },
  {
    "text": "So you have these 3\nprime and W4 prime. ",
    "start": "2929890",
    "end": "2936830"
  },
  {
    "text": "And the final one\nis the K and WK. So you combine each adjacent\none to get the second instance.",
    "start": "2936830",
    "end": "2946270"
  },
  {
    "text": " And you do this for\nany two of them.",
    "start": "2946270",
    "end": "2953760"
  },
  {
    "text": "So in the end, you\nhave K-by-2 instances. But the cost of doing this\nis the size of the witness",
    "start": "2953760",
    "end": "2962569"
  },
  {
    "text": "will blow up by a factor of 2. ",
    "start": "2962570",
    "end": "2969690"
  },
  {
    "text": "So let's say the original\nlanguage is L prime,",
    "start": "2969690",
    "end": "2975050"
  },
  {
    "text": "so it contains of I such\nthat there exists WI prime.",
    "start": "2975050",
    "end": "2980220"
  },
  {
    "start": "2980220",
    "end": "2990380"
  },
  {
    "text": "So C prime is the verification\ncircuit of L prime. Then here the new\ninstances is the following.",
    "start": "2990380",
    "end": "3000520"
  },
  {
    "text": "So it defines a new\nlanguage, L double prime.",
    "start": "3000520",
    "end": "3005700"
  },
  {
    "text": "So double prime is\nstill contains of I, but the witness are 2I minus\n1 and 2I and W2I, 2I prime.",
    "start": "3005700",
    "end": "3019890"
  },
  {
    "text": " So this concatenation\nwitness is the new NP witness",
    "start": "3019890",
    "end": "3028680"
  },
  {
    "text": "for this L double prime. And then you need to verify\nC prime of this 2I minus 1,",
    "start": "3028680",
    "end": "3036270"
  },
  {
    "text": "W2I minus 1 is 1. And also, 2I and the 2I is 1.",
    "start": "3036270",
    "end": "3045030"
  },
  {
    "text": " So by doing this, the size of\nthe number of the instances",
    "start": "3045030",
    "end": "3054790"
  },
  {
    "text": "will halve each time when\nyou do the recursion. ",
    "start": "3054790",
    "end": "3061550"
  },
  {
    "text": "So in fact, we will prove\nthis for L double prime. And we only prove\nfor 1 to K by 2.",
    "start": "3061550",
    "end": "3071150"
  },
  {
    "text": "They are all in L double\nprime in the recursion.",
    "start": "3071150",
    "end": "3078130"
  },
  {
    "text": "So that's what we will do. ",
    "start": "3078130",
    "end": "3084466"
  },
  {
    "text": "So now the question is, at\neach level of the recursion,",
    "start": "3084466",
    "end": "3095290"
  },
  {
    "text": "the number of\ninstances will halve. So at the end, there will\nonly be one instance. So what will we\ndo at that point?",
    "start": "3095290",
    "end": "3101775"
  },
  {
    "text": " Anyone know? AUDIENCE: We wrap\nit and we use that?",
    "start": "3101775",
    "end": "3107337"
  },
  {
    "text": "ZHENGZHONG JIN: ? Yes, yes. So we directly send the witness,\nand the verifier can verify it.",
    "start": "3107337",
    "end": "3112855"
  },
  {
    "start": "3112855",
    "end": "3120130"
  },
  {
    "text": "So this is the construction, and\nlet's calculate the proof size for this construction.",
    "start": "3120130",
    "end": "3125660"
  },
  {
    "start": "3125660",
    "end": "3139240"
  },
  {
    "text": "So initially, we\nsend this H1 to HL.",
    "start": "3139240",
    "end": "3146230"
  },
  {
    "text": "So the size of that\nis poly C and lambda.",
    "start": "3146230",
    "end": "3158650"
  },
  {
    "text": "And we have this Q\ncomputed by the CI hash.",
    "start": "3158650",
    "end": "3165865"
  },
  {
    "start": "3165865",
    "end": "3173869"
  },
  {
    "text": "So at the next level\nof the recursion, we will also have this first\nround message for that.",
    "start": "3173870",
    "end": "3182270"
  },
  {
    "text": "So let's denote it by HI prime.",
    "start": "3182270",
    "end": "3189020"
  },
  {
    "text": "So what's the size\nof this message? So remember, this is the\nindex BARG for L double prime.",
    "start": "3189020",
    "end": "3196550"
  },
  {
    "text": "And it has the verification\ncircuit, C double prime. ",
    "start": "3196550",
    "end": "3205250"
  },
  {
    "text": "So what is the size\nof this message? ",
    "start": "3205250",
    "end": "3213680"
  },
  {
    "text": "So this is efficiency. ",
    "start": "3213680",
    "end": "3225650"
  },
  {
    "text": "So in the next\nlevel of recursion, we will do the same\nusing the same protocol.",
    "start": "3225650",
    "end": "3232250"
  },
  {
    "text": "So originally, the NP\nverification circuit is C, so we have first\nround message this much.",
    "start": "3232250",
    "end": "3238160"
  },
  {
    "text": "So in the next level, the\nNP verification circuit is C double prime. So the size of this message\nis poly C double prime lambda.",
    "start": "3238160",
    "end": "3251980"
  },
  {
    "text": "But there is an issue if you\ndo this recursion directly. So let's examine what is\nthe size of C double prime.",
    "start": "3251980",
    "end": "3261495"
  },
  {
    "text": " So each C double prime will\ncontain two copy of C, C prime,",
    "start": "3261495",
    "end": "3270440"
  },
  {
    "text": "so C double prime. ",
    "start": "3270440",
    "end": "3285440"
  },
  {
    "text": "So this is the C double prime. So it will take index I\nand this as the witness,",
    "start": "3285440",
    "end": "3294320"
  },
  {
    "text": "and verify these two things. So the size of C double prime\nis roughly 2 times C. So",
    "start": "3294320",
    "end": "3305120"
  },
  {
    "text": "what is the size of C prime?  So C prime is here.",
    "start": "3305120",
    "end": "3312440"
  },
  {
    "text": "So the first part of C prime\nis the PCP verification. So here we will have an issue\nbecause the PCP verifier",
    "start": "3312440",
    "end": "3323150"
  },
  {
    "text": "need to know what\nis the NP relation. So the PCP verifier\nruns in C time. ",
    "start": "3323150",
    "end": "3331891"
  },
  {
    "text": "So we will have an issue here\nbecause the C prime is roughly",
    "start": "3331892",
    "end": "3340270"
  },
  {
    "text": "C, at least C. So if we do this directly, so\nyou can think, at the top level,",
    "start": "3340270",
    "end": "3349250"
  },
  {
    "text": "we have this poly C. And at the\nnext level we have this poly C",
    "start": "3349250",
    "end": "3354670"
  },
  {
    "text": "prime, which is 2C. So this is 2C. And at next level of\nrecursion, we'll have 4C.",
    "start": "3354670",
    "end": "3362920"
  },
  {
    "text": "So we'll have log K\nlevel of recursion, because each time the\nnumber of instance halves.",
    "start": "3362920",
    "end": "3369765"
  },
  {
    "text": " So the depth is log\nK. So in the end,",
    "start": "3369765",
    "end": "3375769"
  },
  {
    "text": "we have K times\nC, which is large. So the proof will grow with\nK times C, which is large.",
    "start": "3375770",
    "end": "3385630"
  },
  {
    "text": "So the final idea is\nwe are going to use PCP with some special property.",
    "start": "3385630",
    "end": "3391880"
  },
  {
    "text": "So this kind of PCP has this\nonline/offline verification property.",
    "start": "3391880",
    "end": "3396920"
  },
  {
    "text": "So this is called PCP with\nfaster online verification.",
    "start": "3396920",
    "end": "3407230"
  },
  {
    "text": " So this PCP has the property\nthat, so for any PCP prover",
    "start": "3407230",
    "end": "3419040"
  },
  {
    "text": "and verifier, so given\nany NP instance X and W, you can generate a long proof.",
    "start": "3419040",
    "end": "3426190"
  },
  {
    "text": "So this is just a normal PCP,\nbut the verification algorithm of the PCP has more structure.",
    "start": "3426190",
    "end": "3434920"
  },
  {
    "text": "So the verification algorithm,\nso originally the PCP verifier need to verify for\nX, Q, and the PCP Q.",
    "start": "3434920",
    "end": "3444599"
  },
  {
    "text": "So now the PCP verifier can\nbe decomposed to two parts.",
    "start": "3444600",
    "end": "3450250"
  },
  {
    "text": "So first, so there is an\noffline preprocessing phase. So the preprocessing\nphase only depends",
    "start": "3450250",
    "end": "3456630"
  },
  {
    "text": "on this relation circuit C. So\nthis is PCP for the language L.",
    "start": "3456630",
    "end": "3470670"
  },
  {
    "text": "So the preprocessing phase\nwill take the relation circuit as input.",
    "start": "3470670",
    "end": "3476109"
  },
  {
    "text": "And it will use the query\nto generate some state.",
    "start": "3476110",
    "end": "3481470"
  },
  {
    "text": "And this state will only grow-- the size of the state\nis polynomial in X.",
    "start": "3481470",
    "end": "3489585"
  },
  {
    "text": "So the point is, so in some case\nwhen the relation circuit is",
    "start": "3489585",
    "end": "3495119"
  },
  {
    "text": "very large, so the\npreprocessing phase will run in the size of\nthe relation circuit,",
    "start": "3495120",
    "end": "3501520"
  },
  {
    "text": "but it will output\na very short state. And the secondly,\nin the online phase,",
    "start": "3501520",
    "end": "3508450"
  },
  {
    "text": "there is an online\nverification part. So the online\nverification will only use such a short state and\nX and Q and the PCP answer",
    "start": "3508450",
    "end": "3524380"
  },
  {
    "text": "to decide whether\nto accept or reject. So the point is, it's\na polynomial time",
    "start": "3524380",
    "end": "3534640"
  },
  {
    "text": "algorithm, which means it only\ndepends on X and the size of Q.",
    "start": "3534640",
    "end": "3541480"
  },
  {
    "text": "So you can imagine if\nC is a very big circuit and the X instance\nis small, then",
    "start": "3541480",
    "end": "3548860"
  },
  {
    "text": "this means the preprocessing\nphase will take",
    "start": "3548860",
    "end": "3554410"
  },
  {
    "text": "most of the time, but the online\nverification will be very fast. It only depends on the instance\nsize and the size of the query.",
    "start": "3554410",
    "end": "3562810"
  },
  {
    "text": "So this property is\nsatisfied by most of the algebraic\nconstruction of PCP.",
    "start": "3562810",
    "end": "3567820"
  },
  {
    "text": "So any questions?",
    "start": "3567820",
    "end": "3572980"
  },
  {
    "text": "So I will not go\ninto the detail.  So in fact, this property is\nused in many practical SNARG",
    "start": "3572980",
    "end": "3581450"
  },
  {
    "text": "construction. Because in the practical\nSNARG construction, they also need to use PCP\nor some form of the PCP,",
    "start": "3581450",
    "end": "3588230"
  },
  {
    "text": "such as linear PCP. So in this\nconstruction, you also have the problem that the\nrelation circuit is very large,",
    "start": "3588230",
    "end": "3595200"
  },
  {
    "text": "but you want the\nverification to be small. So what they do is they\ncan do some preprocessing on the relation to generate\nsome short verification state.",
    "start": "3595200",
    "end": "3604530"
  },
  {
    "text": "And given the\nverification state, you can verify the\nstatement in a short time. ",
    "start": "3604530",
    "end": "3614711"
  },
  {
    "text": "So now we will use this PCP\nfurther with this property.",
    "start": "3614711",
    "end": "3623875"
  },
  {
    "start": "3623875",
    "end": "3629570"
  },
  {
    "text": "Then we can further\nmodify the construction to only do the online\nverification here in C prime.",
    "start": "3629570",
    "end": "3637010"
  },
  {
    "start": "3637010",
    "end": "3652090"
  },
  {
    "text": "So what we will do here is we\nfirst generate the CI hash, using the CI hash to\ngenerate Q. And then",
    "start": "3652090",
    "end": "3659290"
  },
  {
    "text": "we do the preprocessing to this\nQ to generate some short state. ",
    "start": "3659290",
    "end": "3666340"
  },
  {
    "text": "And this will use the\nrelation circuit C. So we can do this because\nwe use the same PCP",
    "start": "3666340",
    "end": "3673270"
  },
  {
    "text": "query for all of the PCPs. ",
    "start": "3673270",
    "end": "3679599"
  },
  {
    "text": "So for all of the PCPs, they\nare using the same PCP query, so I can do this preprocessing.",
    "start": "3679600",
    "end": "3685039"
  },
  {
    "text": " So once I have\nthis a short state,",
    "start": "3685040",
    "end": "3692050"
  },
  {
    "text": "I can hardcode it in this\nconstruction of C prime. So I will replace this with\nthe online verification.",
    "start": "3692050",
    "end": "3700560"
  },
  {
    "text": "Sorry. So this is a local verification.",
    "start": "3700560",
    "end": "3706260"
  },
  {
    "text": "So this is online\nverification of the PCP. ",
    "start": "3706260",
    "end": "3713130"
  },
  {
    "text": "So it will take the\nstate of the rest.",
    "start": "3713130",
    "end": "3719250"
  },
  {
    "text": "So now this will solve\nthis recursion issue, because now the circuit C prime\nwill not depend on C. Instead,",
    "start": "3719250",
    "end": "3729089"
  },
  {
    "text": "it will be polylog in C. So you\ncan check here because C prime,",
    "start": "3729090",
    "end": "3741390"
  },
  {
    "text": "it will only involve\nonline verification. So it's a polynomial in the\nlength of I, which is log K.",
    "start": "3741390",
    "end": "3758250"
  },
  {
    "text": "And the local verification of\nthe Merkle hash is also small. So it's also some polylog\nin K. So you can check.",
    "start": "3758250",
    "end": "3769310"
  },
  {
    "text": "So this is a polylog\nof K and lambda.",
    "start": "3769310",
    "end": "3774890"
  },
  {
    "text": "And you can take this recursion\ninside of this analysis",
    "start": "3774890",
    "end": "3780109"
  },
  {
    "text": "and see, finally, the total\nproof size is poly log in C",
    "start": "3780110",
    "end": "3796040"
  },
  {
    "text": "and poly log in K and\npolynomial in lambda. ",
    "start": "3796040",
    "end": "3803990"
  },
  {
    "text": "AUDIENCE: Plus, the length\nof one witness or-- oh, I guess it's also poly in\nC. Like the base case,",
    "start": "3803990",
    "end": "3809640"
  },
  {
    "text": "you said the witness, right? ZHENGZHONG JIN: Yes, yes. AUDIENCE: That's\nalready populated. ZHENGZHONG JIN: So in fact,\nafter you do this once,",
    "start": "3809640",
    "end": "3817770"
  },
  {
    "text": "at one level of the\nrecursion the witness is already very small,\nbecause the witness is just",
    "start": "3817770",
    "end": "3823620"
  },
  {
    "text": "the PCP opening. So it's polylog C. So finally,\nat the end the final level",
    "start": "3823620",
    "end": "3831000"
  },
  {
    "text": "witness is also very small. ",
    "start": "3831000",
    "end": "3845250"
  },
  {
    "text": "So I probably don't have time to\ncover all of the security proof, but I will show you the\nmost important part of it.",
    "start": "3845250",
    "end": "3852370"
  },
  {
    "text": " So how do we prove the\nsecurity of this construction?",
    "start": "3852370",
    "end": "3863070"
  },
  {
    "text": "So now the construction is here. ",
    "start": "3863070",
    "end": "3870990"
  },
  {
    "text": "So suppose we have some\nsecurity of this index BARG, then maybe we can\nuse it recursively to prove the security of\nthe entire construction.",
    "start": "3870990",
    "end": "3878300"
  },
  {
    "text": "But we have an issue here. So the issue is L\ndouble prime, it",
    "start": "3878300",
    "end": "3884270"
  },
  {
    "text": "will depend on\nthe first message. ",
    "start": "3884270",
    "end": "3889776"
  },
  {
    "text": "So L double prime will use\nthis L prime, so this C prime. So this C prime will use\nthe hash root, this HQ.",
    "start": "3889776",
    "end": "3898110"
  },
  {
    "text": "So this hash root comes from\nthis hash value and of the H1 to HL.",
    "start": "3898110",
    "end": "3904730"
  },
  {
    "text": "So this means the\nadversary can potentially",
    "start": "3904730",
    "end": "3911540"
  },
  {
    "text": "choose the next statement,\ndepends on the CRS because CRS is first\nsend to the adversary.",
    "start": "3911540",
    "end": "3918230"
  },
  {
    "text": "So this is not captured by the\nnon-adaptive soundness before. So we need a new\ndefinition of soundness.",
    "start": "3918230",
    "end": "3923910"
  },
  {
    "start": "3923910",
    "end": "3937900"
  },
  {
    "text": "And the issue is\nthat we don't know how to achieve fully\nadaptive soundness. So the adaptive soundness means\nthat the cheating adversary",
    "start": "3937900",
    "end": "3945279"
  },
  {
    "text": "can choose the instance,\ndepending on the CRS. So what we prove is some\nsemi-adaptive soundness.",
    "start": "3945280",
    "end": "3953359"
  },
  {
    "start": "3953360",
    "end": "3963730"
  },
  {
    "text": "So this soundness notion is not\nonly important in this security proof, but will also be\ncrucial for your next lecture.",
    "start": "3963730",
    "end": "3971090"
  },
  {
    "text": "So when you compile this\nbatch index of SNARG for P.",
    "start": "3971090",
    "end": "3979120"
  },
  {
    "text": "So it's defined as follows. So it says that it allows\nthe cheating prover to choose",
    "start": "3979120",
    "end": "3984900"
  },
  {
    "text": "the relation circuit, but\nit cannot choose which index to cheat.",
    "start": "3984900",
    "end": "3990690"
  },
  {
    "text": "So let me define it. So we say, index BARG is\nsound if there exists if.",
    "start": "3990690",
    "end": "4023390"
  },
  {
    "text": "So first, I need another\nkey generation algorithm, CRS generator.",
    "start": "4023390",
    "end": "4030350"
  },
  {
    "text": "So I'll call it generate bar. So it will take the security\nparameter as input and index I",
    "start": "4030350",
    "end": "4040520"
  },
  {
    "text": "star, and will\ngenerate some CRS star. ",
    "start": "4040520",
    "end": "4053109"
  },
  {
    "text": "And this CRS generator\nis indistinguishable",
    "start": "4053110",
    "end": "4059020"
  },
  {
    "text": "with the real CRS. ",
    "start": "4059020",
    "end": "4066579"
  },
  {
    "text": "And furthermore, for each\nnon-uniform PPT adversary",
    "start": "4066580",
    "end": "4073510"
  },
  {
    "text": "cheating prover, P star, we need\nto have the following property. ",
    "start": "4073510",
    "end": "4079930"
  },
  {
    "text": "So when P star receives the\nCRS generated by this generator",
    "start": "4079930",
    "end": "4093160"
  },
  {
    "text": "star, it can choose\nas relation circuit C",
    "start": "4093160",
    "end": "4101660"
  },
  {
    "text": "and a maliciously\nchosen relation circuit C and pi star such\nthat the probability",
    "start": "4101660",
    "end": "4114140"
  },
  {
    "text": "that the verifier,\nexcept for this K",
    "start": "4114140",
    "end": "4126290"
  },
  {
    "text": "and the I star instance is not\nin the relation circuit defined",
    "start": "4126290",
    "end": "4133278"
  },
  {
    "text": "by this C star is negligible. ",
    "start": "4133279",
    "end": "4158330"
  },
  {
    "text": "The intuition is that the SSV\nis binding for some location, for some instance.",
    "start": "4158330",
    "end": "4163460"
  },
  {
    "text": "So you just set\nthe generator bar as the generator that\noutputs that kind of SSV.",
    "start": "4163460",
    "end": "4170568"
  },
  {
    "text": "So the SSV will be binding\nfor the I star's position. Then you cannot cheat\nfor the I star instance.",
    "start": "4170569",
    "end": "4175770"
  },
  {
    "text": " So the cheating prover can\nchoose a relation circuit C,",
    "start": "4175770",
    "end": "4185799"
  },
  {
    "text": "but it cannot cheat for\nthe I-th star's position. ",
    "start": "4185800",
    "end": "4195219"
  },
  {
    "text": "That's the\nsemi-adaptive soundness. So to prove this soundness\nfor this construction,",
    "start": "4195220",
    "end": "4200560"
  },
  {
    "text": "the idea is that for any I star\nthat is not in the language,",
    "start": "4200560",
    "end": "4206530"
  },
  {
    "text": "you can see from the\ncorrelation intractability,",
    "start": "4206530",
    "end": "4211809"
  },
  {
    "text": "essentially the idea is that if\nI star is not in the language, and for any cheating\nproof, you just",
    "start": "4211810",
    "end": "4224460"
  },
  {
    "text": "switch this generator\nfor this I star.",
    "start": "4224460",
    "end": "4229830"
  },
  {
    "text": "And you can argue, if I\nstar is not in the language, then I star over 2.",
    "start": "4229830",
    "end": "4238469"
  },
  {
    "text": "Because we do the 2-to-1 trick,\nit will translate to a new instance at the next level, then\nit's also not in the L double",
    "start": "4238470",
    "end": "4253830"
  },
  {
    "text": "prime. So if the adversary doesn't\ncheat for the CR hash. So that's the idea.",
    "start": "4253830",
    "end": "4260014"
  },
  {
    "start": "4260015",
    "end": "4280160"
  },
  {
    "text": "So if the query and the hash\nvalues output by the cheating",
    "start": "4280160",
    "end": "4286040"
  },
  {
    "text": "prover does not satisfy\nthe CR hash relation R,",
    "start": "4286040",
    "end": "4292100"
  },
  {
    "text": "then you have this. Then if I star's\nposition is forced",
    "start": "4292100",
    "end": "4298610"
  },
  {
    "text": "to translate to another\nnew false statement,",
    "start": "4298610",
    "end": "4305239"
  },
  {
    "text": "you can use this claim to\ninductively argue that,",
    "start": "4305240",
    "end": "4311300"
  },
  {
    "text": "initially, if you have\nsome fixed I star, then you can track this\nfixed I star at each level",
    "start": "4311300",
    "end": "4318320"
  },
  {
    "text": "by dividing by 2\nand round up to it. And finally, you can catch it. ",
    "start": "4318320",
    "end": "4326060"
  },
  {
    "text": "So in the last level\nof the recursion, we just send all the witness.",
    "start": "4326060",
    "end": "4331320"
  },
  {
    "text": "So you must be able to catch it. So that's the idea.",
    "start": "4331320",
    "end": "4336719"
  },
  {
    "text": "So that's all about\nthe class today.",
    "start": "4336720",
    "end": "4344400"
  },
  {
    "text": "Any questions? ",
    "start": "4344400",
    "end": "4355915"
  },
  {
    "text": "AUDIENCE: This is\nthe full construction get any form of, like, the\n[INAUDIBLE] construction? AUDIENCE: Any sort of\nadaptive soundness?",
    "start": "4355915",
    "end": "4363120"
  },
  {
    "text": "Or is it like a-- ZHENGZHONG JIN: Yes, so\nit only gets this kind of adaptive soundness. AUDIENCE: I see.",
    "start": "4363120",
    "end": "4368340"
  },
  {
    "text": "Like, some notion of this for\ngeneral BARGs [INAUDIBLE]. ZHENGZHONG JIN: So\nfor the index BARG,",
    "start": "4368340",
    "end": "4374790"
  },
  {
    "text": "we can get a semi adaptive\nsoundness and for general BARGs,",
    "start": "4374790",
    "end": "4382500"
  },
  {
    "text": "I think it also has some\nsimilar notion, I think. ",
    "start": "4382500",
    "end": "4394480"
  },
  {
    "text": "AUDIENCE: Is there\nsome other construction that's adapted to sound? Or is it a very\ncommon thing to do? ZHENGZHONG JIN: That's\na good question.",
    "start": "4394480",
    "end": "4400830"
  },
  {
    "text": "So in general, given any\nnon-adaptive sound SNARG, you can always upgrade\nit to adaptive sound",
    "start": "4400830",
    "end": "4406190"
  },
  {
    "text": "by using complexity leveraging. But you will pay due to the\ninstance size in the security",
    "start": "4406190",
    "end": "4414410"
  },
  {
    "text": "proof. But in the BARGs, the total\ninstance size is K times X.",
    "start": "4414410",
    "end": "4425370"
  },
  {
    "text": "So it's very large. So I'm not sure you\ncan really do that. AUDIENCE: I see.",
    "start": "4425370",
    "end": "4431369"
  },
  {
    "text": "But is it clear priori,\nthat [INAUDIBLE] only applies to\nadaptively sound? ZHENGZHONG JIN: So right, right.",
    "start": "4431370",
    "end": "4437400"
  },
  {
    "text": "So there seems to be\na gap, but I'm not sure how large is the gap. ",
    "start": "4437400",
    "end": "4443960"
  },
  {
    "text": "Maybe you can use it on clever\ncomplexity leveraging to almost close the gap, for example.",
    "start": "4443960",
    "end": "4451780"
  },
  {
    "start": "4451780",
    "end": "4454000"
  }
]