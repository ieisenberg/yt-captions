[
  {
    "text": " The following\ncontent is provided under a Creative\nCommons license. Your support will help MIT\nOpenCourseWare continue",
    "start": "0",
    "end": "6860"
  },
  {
    "text": "to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6860",
    "end": "13330"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13330",
    "end": "23290"
  },
  {
    "text": "PROFESSOR: So today's\nlecture is on sorting. We'll be talking about specific\nsorting algorithms today.",
    "start": "23290",
    "end": "31310"
  },
  {
    "text": "I want to start\nby motivating why we're interested in sorting,\nwhich should be fairly easy.",
    "start": "31310",
    "end": "37105"
  },
  {
    "text": " Then I want to discuss\na particular sorting",
    "start": "37105",
    "end": "42489"
  },
  {
    "text": "algorithm that's\ncalled insertion sort. That's probably the\nsimplest sorting algorithm",
    "start": "42490",
    "end": "47860"
  },
  {
    "text": "you can write, it's\nfive lines of code. It's not the best\nsorting algorithm",
    "start": "47860",
    "end": "53400"
  },
  {
    "text": "that's out there and so\nwe'll try and improve it. We'll also talk about merge\nsort, which is a divide",
    "start": "53400",
    "end": "60470"
  },
  {
    "text": "and conquer algorithm\nand that's going to motivate the last thing\nthat I want to spend time on,",
    "start": "60470",
    "end": "69010"
  },
  {
    "text": "which is recurrences and\nhow you solve recurrences. Typically the\nrecurrences that we'll",
    "start": "69010",
    "end": "74230"
  },
  {
    "text": "be looking at in double o six\nare going to come from divide and conquer problems\nlike merge sort",
    "start": "74230",
    "end": "80760"
  },
  {
    "text": "but you'll see\nthis over and over. So let's talk about why\nwe're interested in sorting.",
    "start": "80760",
    "end": "86965"
  },
  {
    "text": " There's some fairly\nobvious applications",
    "start": "86965",
    "end": "94370"
  },
  {
    "text": "like if you want to\nmaintain a phone book, you've got a bunch of names\nand numbers corresponding",
    "start": "94370",
    "end": "102009"
  },
  {
    "text": "to a telephone\ndirectory and you want to keep them in\nsorted order so it's easy to search, mp3 organizers,\nspreadsheets, et cetera.",
    "start": "102010",
    "end": "111510"
  },
  {
    "text": "So there's lots of\nobvious applications. There's also some\ninteresting problems",
    "start": "111510",
    "end": "119630"
  },
  {
    "text": "that become easy once\nitems are sorted.",
    "start": "119630",
    "end": "125899"
  },
  {
    "start": "125900",
    "end": "133790"
  },
  {
    "text": "One example of that\nis finding a median. ",
    "start": "133790",
    "end": "143860"
  },
  {
    "text": "So let's say that you\nhave a bunch of items in an array a zero through\nn and a zero through n",
    "start": "143860",
    "end": "156210"
  },
  {
    "text": "contains n numbers and\nthey're not sorted. ",
    "start": "156210",
    "end": "164849"
  },
  {
    "text": "When you sort, you\nturn this into b 0 through n, where if\nit's just numbers, then",
    "start": "164850",
    "end": "172760"
  },
  {
    "text": "you may sort them in increasing\norder or decreasing order. Let's just call it\nincreasing order for now.",
    "start": "172760",
    "end": "178690"
  },
  {
    "text": "Or if they're records,\nand they're not numbers, then you have to provide\na comparison function",
    "start": "178690",
    "end": "184519"
  },
  {
    "text": "to determine which record is\nsmaller than another record. And that's another\ninput that you have to have in order\nto do the sorting.",
    "start": "184520",
    "end": "192980"
  },
  {
    "text": "So it doesn't really\nmatter what the items are as long as you have the\ncomparison function. Think of it as less\nthan or equal to.",
    "start": "192980",
    "end": "199930"
  },
  {
    "text": "And if you have that and\nit's straightforward, obviously, to check that 3\nis less than 4, et cetera.",
    "start": "199930",
    "end": "207090"
  },
  {
    "text": "But it may be a little\nmore complicated for more sophisticated\nsorting applications.",
    "start": "207090",
    "end": "212990"
  },
  {
    "text": "But the bottom line is that if\nyou have your algorithm that takes a comparison\nfunction as an input,",
    "start": "212990",
    "end": "219120"
  },
  {
    "text": "you're going to be able to,\nafter a certain amount of time, get B 0 n.",
    "start": "219120",
    "end": "225099"
  },
  {
    "text": "Now if you wanted to find the\nmedian of the set of numbers that were originally\nin the array A,",
    "start": "225100",
    "end": "231719"
  },
  {
    "text": "what would you do once you\nhave the sorted array B? AUDIENCE: Isn't there a more\nefficient algorithm for median?",
    "start": "231720",
    "end": "239124"
  },
  {
    "text": "PROFESSOR: Absolutely. But this is sort of a side\neffect of having a sorted list.",
    "start": "239124",
    "end": "248120"
  },
  {
    "text": "If you happen to\nhave a sorted list, there's many ways\nthat you could imagine",
    "start": "248120",
    "end": "255090"
  },
  {
    "text": "building up a sorted list. One way is you have something\nthat's completely unsorted and you run insertion\nsort or merge sort.",
    "start": "255090",
    "end": "262620"
  },
  {
    "text": "Another way would be to\nmaintain a sorted list as you're getting items put into the list.",
    "start": "262620",
    "end": "267660"
  },
  {
    "text": "So if you happened\nto have a sorted list and you need to have this\nsorted list for some reason, the point I'm making here\nis that finding the median",
    "start": "267660",
    "end": "275440"
  },
  {
    "text": "is easy. And it's easy because\nall you have to do is look at-- depending\non whether n is odd",
    "start": "275440",
    "end": "283805"
  },
  {
    "text": "or even-- look at B of n over 2. That would give you the\nmedian because you'd",
    "start": "283805",
    "end": "289360"
  },
  {
    "text": "have a bunch of numbers\nthat are less than that and the equal set of numbers\nthat are greater than that,",
    "start": "289360",
    "end": "296830"
  },
  {
    "text": "which is the\ndefinition of median. So this is not necessarily the\nbest way, as you pointed out,",
    "start": "296830",
    "end": "305030"
  },
  {
    "text": "of finding the median. But it's constant time if\nyou have a sorted list.",
    "start": "305030",
    "end": "311320"
  },
  {
    "text": "That's the point\nI wanted to make. There are other things\nthat you could do.",
    "start": "311320",
    "end": "316720"
  },
  {
    "text": "And this came up\nin Erik's lecture, which is the notion of\nbinary search-- finding",
    "start": "316720",
    "end": "325570"
  },
  {
    "text": "an element in an array--\na specific element. You have a list of items--\nagain a 0 through n.",
    "start": "325570",
    "end": "334090"
  },
  {
    "text": "And you're looking for a\nspecific number or item.",
    "start": "334090",
    "end": "339600"
  },
  {
    "text": " You could, obviously,\nscan the array,",
    "start": "339600",
    "end": "346639"
  },
  {
    "text": "and that would take you\nlinear time to find this item. If the array happened\nto be sorted,",
    "start": "346640",
    "end": "353100"
  },
  {
    "text": "then you can find this\nin logarithmic time",
    "start": "353100",
    "end": "358530"
  },
  {
    "text": "using what's called\nbinary search. ",
    "start": "358530",
    "end": "363600"
  },
  {
    "text": "Let's say you're looking\nfor a specific item. Let's call it k. Binary search, roughly\nspeaking, would",
    "start": "363600",
    "end": "371139"
  },
  {
    "text": "work like-- you go compare\nk to, again, B of n over 2,",
    "start": "371140",
    "end": "380200"
  },
  {
    "text": "and decide, given\nthat B is sorted, you get to look at\n1/2 of the array.",
    "start": "380200",
    "end": "388400"
  },
  {
    "text": "If B of n over 2 is not\nexactly k, then-- well, if it's exactly k you're done.",
    "start": "388400",
    "end": "394389"
  },
  {
    "text": "Otherwise, you look\nat the left half. You do your divide\nand conquer paradigm.",
    "start": "394390",
    "end": "399669"
  },
  {
    "text": "And you can do this\nin logarithmic time. So keep this in mind,\nbecause binary search",
    "start": "399670",
    "end": "405700"
  },
  {
    "text": "is going to come up\nin today's lecture and again in other lectures.",
    "start": "405700",
    "end": "410760"
  },
  {
    "text": "It's really a great\nparadigm of divide and conquer--\nprobably the simplest.",
    "start": "410760",
    "end": "416020"
  },
  {
    "text": "And it, essentially,\ntakes something that's linear--\na linear search--",
    "start": "416020",
    "end": "421040"
  },
  {
    "text": "and turns it into\nlogarithmic search. So those are a\ncouple of problems",
    "start": "421040",
    "end": "426539"
  },
  {
    "text": "that become easy if\nyou have a sorted list. And there's some not\nso obvious applications",
    "start": "426540",
    "end": "441270"
  },
  {
    "text": "of sorting-- for example,\ndata compression. If you wanted to\ncompress a file,",
    "start": "441270",
    "end": "447790"
  },
  {
    "text": "one of the things that\nyou could do is to-- and it's a set of items--\nyou could sort the items.",
    "start": "447790",
    "end": "455330"
  },
  {
    "text": "And that automatically\nfinds duplicates. And you could say, if I have 100\nitems that are all identical,",
    "start": "455330",
    "end": "462940"
  },
  {
    "text": "I'm going to compress the file\nby representing the item once and, then, having\na number associated",
    "start": "462940",
    "end": "469319"
  },
  {
    "text": "with the frequency of that\nitem-- similar to what document distance does.",
    "start": "469320",
    "end": "474440"
  },
  {
    "text": "Document distance can\nbe viewed as a way of compressing\nyour initial input.",
    "start": "474440",
    "end": "479770"
  },
  {
    "text": "Obviously, you lose the works of\nShakespeare or whatever it was. And it becomes a bunch\nof words and frequencies.",
    "start": "479770",
    "end": "486560"
  },
  {
    "text": "But it is something that\ncompresses the input",
    "start": "486560",
    "end": "492870"
  },
  {
    "text": "and gives you a\ndifferent representation. And so people use sorting as a\nsubroutine in data compression.",
    "start": "492870",
    "end": "500395"
  },
  {
    "text": " Computer graphics uses sorting.",
    "start": "500395",
    "end": "507360"
  },
  {
    "text": "Most of the time,\nwhen you render scenes in computer graphics,\nyou have many layers",
    "start": "507360",
    "end": "512870"
  },
  {
    "text": "corresponding to the scenes. It turns out that,\nin computer graphics,",
    "start": "512870",
    "end": "518550"
  },
  {
    "text": "most of the time you're\nactually rendering front to back because,\nwhen you have a big opaque",
    "start": "518550",
    "end": "524410"
  },
  {
    "text": "object in front, you want\nto render that first, so you don't have to worry\nabout everything that's",
    "start": "524410",
    "end": "530970"
  },
  {
    "text": "occluded by this\nbig opaque object. And that makes things\nmore efficient.",
    "start": "530970",
    "end": "536590"
  },
  {
    "text": "And so you keep things\nsorted front to back, most of the time, in\ncomputer graphics rendering. But some of the time, if you're\nworried about transparency,",
    "start": "536590",
    "end": "543860"
  },
  {
    "text": "you have to render\nthings back to front. So typically, you\nhave sorted lists corresponding to the different\nobjects in both orders--",
    "start": "543860",
    "end": "551550"
  },
  {
    "text": "both increasing order\nand decreasing order. And you're maintaining that. So sorting is a real\nimportant subroutine",
    "start": "551550",
    "end": "559190"
  },
  {
    "text": "in pretty much any sophisticated\napplication you look at. So it's worthwhile to look\nat the variety of sorting",
    "start": "559190",
    "end": "566780"
  },
  {
    "text": "algorithms that are out there. And we're going to do\nsome simple ones, today. But if you go and\nlook at Wikipedia",
    "start": "566780",
    "end": "571890"
  },
  {
    "text": "and do a Google search,\nthere's all sorts of sorts like cocktail\nsort, and bitonic sort,",
    "start": "571890",
    "end": "578030"
  },
  {
    "text": "and what have you. And there's reasons why each of\nthese sorting algorithms exist.",
    "start": "578030",
    "end": "585900"
  },
  {
    "text": "Because in specific\ncases, they end up winning on types of inputs\nor types of problems.",
    "start": "585900",
    "end": "593055"
  },
  {
    "text": " So let's take a look at our\nfirst sorting algorithm.",
    "start": "593055",
    "end": "599470"
  },
  {
    "text": "I'm not going to write code\nbut it will be in the notes. And it is in your document\ndistance Python files.",
    "start": "599470",
    "end": "608860"
  },
  {
    "text": "But I'll just give\nyou pseudocode here and walk through what\ninsertion sort looks like because the purpose\nof describing",
    "start": "608860",
    "end": "617460"
  },
  {
    "text": "this algorithm to you is\nto analyze its complexity. We need to do some\ncounting here, with respect to this\nalgorithm, to figure out",
    "start": "617460",
    "end": "625230"
  },
  {
    "text": "how fast it's going to run\nin and what the worst case complexity is.",
    "start": "625230",
    "end": "630279"
  },
  {
    "text": "So what is insertion sort? For i equals 1, 2, through n,\ngiven an input to be sorted,",
    "start": "630280",
    "end": "641780"
  },
  {
    "text": "what we're going to do is\nwe're going to insert A of i in the right position.",
    "start": "641780",
    "end": "648470"
  },
  {
    "text": "And we're going\nto assume that we are sort of midway through\nthe sorting process, where",
    "start": "648470",
    "end": "655220"
  },
  {
    "text": "we have sorted A 0\nthrough i minus 1.",
    "start": "655220",
    "end": "660920"
  },
  {
    "text": "And we're going to\nexpand this to this array to have i plus 1 elements.",
    "start": "660920",
    "end": "667590"
  },
  {
    "text": "And A of i is going\nto get inserted into the correct position.",
    "start": "667590",
    "end": "672830"
  },
  {
    "text": "And we're going to do\nthis by pairwise swaps",
    "start": "672830",
    "end": "683640"
  },
  {
    "text": "down to the correct position\nfor the number that is initially",
    "start": "683640",
    "end": "692730"
  },
  {
    "text": "in A of i.  So let's go through\nan example of this.",
    "start": "692730",
    "end": "702410"
  },
  {
    "text": "We're going to sort\nin increasing order. Just have six numbers. ",
    "start": "702410",
    "end": "710430"
  },
  {
    "text": "And initially, we\nhave 5, 2, 4, 6, 1, 3. And we're going to\ntake a look at this.",
    "start": "710430",
    "end": "716430"
  },
  {
    "text": "And you start with the index\n1, or the second element, because the very first\nelement-- it's a single element",
    "start": "716430",
    "end": "723620"
  },
  {
    "text": "and it's already\nsorted by definition. But you start from here. And this is what\nwe call our key.",
    "start": "723620",
    "end": "730890"
  },
  {
    "text": "And that's essentially a pointer\nto where we're at, right now. And the key keeps\nmoving to the right",
    "start": "730890",
    "end": "737020"
  },
  {
    "text": "as we go through the different\nsteps of the algorithm. And so what you do\nis you look at this and you have-- this is A of i.",
    "start": "737020",
    "end": "744830"
  },
  {
    "text": "That's your key. And you have A of\n0 to 0, which is 5.",
    "start": "744830",
    "end": "750070"
  },
  {
    "text": "And since we want to\nsort in increasing order, this is not sorted.",
    "start": "750070",
    "end": "755940"
  },
  {
    "text": "And so we do a swap. So what this would do in\nthis step is to do a swap.",
    "start": "755940",
    "end": "762399"
  },
  {
    "text": "And we would go obtain\n2, 5, 4, 6, 1, 3.",
    "start": "762400",
    "end": "771830"
  },
  {
    "text": "So all that's happened here,\nin this step-- in the very first step where the key\nis in the second position--",
    "start": "771830",
    "end": "777360"
  },
  {
    "text": "is one swap happened. Now, your key is\nhere, at item 4.",
    "start": "777360",
    "end": "783340"
  },
  {
    "text": "Again, you need to put\n4 into the right spot. And so you do pairwise swaps.",
    "start": "783340",
    "end": "788670"
  },
  {
    "text": "And in this case, you\nhave to do one swap. And you get 2, 4, 5. And you're done\nwith this iteration.",
    "start": "788670",
    "end": "795650"
  },
  {
    "text": "So what happens here is\nyou have 2, 4, 5, 6, 1, 3.",
    "start": "795650",
    "end": "807850"
  },
  {
    "text": "And now, the key\nis over here, at 6.",
    "start": "807850",
    "end": "813009"
  },
  {
    "text": "Now, at this point,\nthings are kind of easy, in the sense that you look\nat it and you say, well, I",
    "start": "813010",
    "end": "821180"
  },
  {
    "text": "know this part is\nalready started. 6 is greater than 5. So you have to do nothing.",
    "start": "821180",
    "end": "827000"
  },
  {
    "text": "So there's no swaps that\nhappen in this step. So all that happens\nhere is you're",
    "start": "827000",
    "end": "836440"
  },
  {
    "text": "going to move the key to\none step to the right.",
    "start": "836440",
    "end": "842280"
  },
  {
    "text": "So you have 2, 4, 5, 6, 1, 3. And your key is now at 1.",
    "start": "842280",
    "end": "850270"
  },
  {
    "text": "Here, you have to do more work. Now, you see one aspect of the\ncomplexity of this algorithm--",
    "start": "850270",
    "end": "856769"
  },
  {
    "text": "given that you're doing\npairwise swaps-- the way this algorithm was defined, in\npseudocode, out there, was I'm",
    "start": "856770",
    "end": "863420"
  },
  {
    "text": "going to use pairwise swaps\nto find the correct position. So what you're going\nto do is you're",
    "start": "863420",
    "end": "869640"
  },
  {
    "text": "going to have to\nswap first 1 and 6. And then you'll\nswap-- 1 is over here.",
    "start": "869640",
    "end": "876310"
  },
  {
    "text": "So you'll swap this\nposition and that position. And then you'll\nswap-- essentially,",
    "start": "876310",
    "end": "884579"
  },
  {
    "text": "do 4 swaps to get to\nthe point where you have",
    "start": "884580",
    "end": "889910"
  },
  {
    "text": "1, 2, 4, 5, 6, 3. So this is the result.",
    "start": "889910",
    "end": "896649"
  },
  {
    "text": " 1, 2, 4, 5, 6, 3.",
    "start": "896650",
    "end": "903770"
  },
  {
    "text": "And the important thing\nto understand, here, is that you've done\nfour swaps to get 1",
    "start": "903770",
    "end": "909050"
  },
  {
    "text": "to the correct position. Now, you could imagine a\ndifferent data structure where you move this over\nthere and you shift them",
    "start": "909050",
    "end": "915470"
  },
  {
    "text": "all to the right. But in fact, that shifting\nof these four elements is going to be computed\nin our model as four",
    "start": "915470",
    "end": "923630"
  },
  {
    "text": "operations, or\nfour steps, anyway. So there's no getting\naway from the fact that you have to do\nfour things here.",
    "start": "923630",
    "end": "930660"
  },
  {
    "text": "And the way the code that\nwe have for insertion sort",
    "start": "930660",
    "end": "936829"
  },
  {
    "text": "does this is by\nusing pairwise swaps. So we're almost done. Now, we have the key at 3.",
    "start": "936830",
    "end": "949490"
  },
  {
    "text": "And now, 3 needs to get put\ninto the correct position. And so you've got\nto do a few swaps.",
    "start": "949490",
    "end": "955350"
  },
  {
    "text": "This is the last step. And what happens here is 3 is\ngoing to get swapped with 6.",
    "start": "955350",
    "end": "963580"
  },
  {
    "text": "And then 3 needs to\nget swapped with 5. And then 3 needs to\nget swapped with 4.",
    "start": "963580",
    "end": "969770"
  },
  {
    "text": "And then, since 3 is\ngreater than 2, you're done. So you have 1, 2, 3, 4, 5, 6.",
    "start": "969770",
    "end": "976325"
  },
  {
    "text": " And that's it. So, analysis.",
    "start": "976325",
    "end": "982820"
  },
  {
    "text": " How many steps do I have? ",
    "start": "982820",
    "end": "990670"
  },
  {
    "text": "AUDIENCE: n squared? PROFESSOR: No, how\nmany steps do I have?",
    "start": "990670",
    "end": "996310"
  },
  {
    "text": "I guess that wasn't\na good question. If I think of a step as\nbeing a movement of the key,",
    "start": "996310",
    "end": "1003930"
  },
  {
    "text": "how many steps do I have? I have theta n steps.",
    "start": "1003930",
    "end": "1009930"
  },
  {
    "text": "And in this case, you can\nthink of it as n minus 1 steps,",
    "start": "1009930",
    "end": "1016570"
  },
  {
    "text": "since you started with 2. But let's just call\nit theta n steps,",
    "start": "1016570",
    "end": "1023900"
  },
  {
    "text": "in terms of key positions. ",
    "start": "1023900",
    "end": "1030060"
  },
  {
    "text": "And you're right. It is n square because,\nat any given step,",
    "start": "1030060",
    "end": "1035349"
  },
  {
    "text": "it's quite possible that\nI have to do theta n work. And one example is\nthis one, right here,",
    "start": "1035349",
    "end": "1042400"
  },
  {
    "text": "where I had to do four swaps. And in general, you can\nconstruct a scenario",
    "start": "1042400",
    "end": "1047599"
  },
  {
    "text": "where, towards the\nend of the algorithm, you'd have to do theta n work.",
    "start": "1047599",
    "end": "1054120"
  },
  {
    "text": "But if you had a list\nthat was reverse sorted. You would, essentially,\nhave to do, on an average n",
    "start": "1054120",
    "end": "1060960"
  },
  {
    "text": "by two swaps as you go\nthrough each of the steps. And that's theta n. So each step is theta n swaps.",
    "start": "1060960",
    "end": "1072150"
  },
  {
    "text": " And when I say\nswaps, I could also",
    "start": "1072150",
    "end": "1078740"
  },
  {
    "text": "say each step is theta\nn compares and swaps.",
    "start": "1078740",
    "end": "1086645"
  },
  {
    "text": "And this is going\nto be important because I'm going to ask\nyou an interesting question in a minute.",
    "start": "1086645",
    "end": "1091700"
  },
  {
    "text": "But let me summarize. What I have here is a\ntheta n squared algorithm. The reason this is\na theta n squared",
    "start": "1091700",
    "end": "1097970"
  },
  {
    "text": "algorithm is because\nI have theta n steps and each step is theta n.",
    "start": "1097970",
    "end": "1106860"
  },
  {
    "text": "When I'm counting,\nwhat am I counting it terms of operations? The assumption here--\nunspoken assumption--",
    "start": "1106860",
    "end": "1113510"
  },
  {
    "text": "has been that an operation\nis a compare and a swap and they're, essentially,\nequal in cost.",
    "start": "1113510",
    "end": "1119540"
  },
  {
    "text": "And in most computers,\nthat's true. You have a single\ninstruction and, say, the x86",
    "start": "1119540",
    "end": "1125210"
  },
  {
    "text": "or the MIPS architecture\nthat can do a compare, and the same thing for\nswapping registers.",
    "start": "1125210",
    "end": "1130659"
  },
  {
    "text": "So perfectly\nreasonably assumption that compares and\nswaps for numbers",
    "start": "1130660",
    "end": "1136480"
  },
  {
    "text": "have exactly the same cost. But if you had a record and\nyou were comparing records,",
    "start": "1136480",
    "end": "1141900"
  },
  {
    "text": "and the comparison function that\nyou used for the records was in itself a method\ncall or a subroutine,",
    "start": "1141900",
    "end": "1148820"
  },
  {
    "text": "it's quite possible\nthat all you're doing is swapping pointers or\nreferences to do the swap,",
    "start": "1148820",
    "end": "1155600"
  },
  {
    "text": "but the comparison could be\nsubstantially more expensive. ",
    "start": "1155600",
    "end": "1162870"
  },
  {
    "text": "Most of the time-- and\nwe'll differentiate if it becomes\nnecessary-- we're going to be counting comparisons\nin the sorting algorithms",
    "start": "1162870",
    "end": "1169560"
  },
  {
    "text": "that we'll be putting out. And we'll be assuming that\neither comparison swaps are",
    "start": "1169560",
    "end": "1176130"
  },
  {
    "text": "roughly the same or\nthat compares are-- and we'll say which one,\nof course-- that compares",
    "start": "1176130",
    "end": "1184570"
  },
  {
    "text": "are substantially more\nexpensive than swaps. So if you had either of those\ncases for insertion sort,",
    "start": "1184570",
    "end": "1192269"
  },
  {
    "text": "you have a theta n\nsquared algorithm. You have theta n\nsquared compares and theta n squared swaps.",
    "start": "1192270",
    "end": "1198200"
  },
  {
    "text": "Now, here's a question. Let's say that compares are\nmore expensive than swaps.",
    "start": "1198200",
    "end": "1211179"
  },
  {
    "text": "And so, I'm concerned\nabout the theta n squared comparison cost. ",
    "start": "1211179",
    "end": "1217270"
  },
  {
    "text": "I'm not as concerned, because of\nthe constant factors involved, with the theta n\nsquared swap cost.",
    "start": "1217270",
    "end": "1222710"
  },
  {
    "text": " This is a question question.",
    "start": "1222710",
    "end": "1228730"
  },
  {
    "text": "What's a simple fix-- change\nto this algorithm that would give me a better\ncomplexity in the case",
    "start": "1228730",
    "end": "1237260"
  },
  {
    "text": "where compares are\nmore expensive, or I'm only looking at the\ncomplexity of compares.",
    "start": "1237260",
    "end": "1243300"
  },
  {
    "text": "So the theta\nwhatever of compares. Anyone? Yeah, back there.",
    "start": "1243300",
    "end": "1248661"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] ",
    "start": "1248661",
    "end": "1256356"
  },
  {
    "text": "PROFESSOR: You could\ncompare with the middle. What did I call it? ",
    "start": "1256356",
    "end": "1261910"
  },
  {
    "text": "I called it something. What you just said, I\ncalled it something. AUDIENCE: Binary search.",
    "start": "1261910",
    "end": "1267160"
  },
  {
    "text": "PROFESSOR: Binary search. That's right. Two cushions for this one. So you pick them\nup after lecture.",
    "start": "1267160",
    "end": "1272221"
  },
  {
    "text": "So you're exactly right. You got it right. I called it binary\nsearch, up here.",
    "start": "1272221",
    "end": "1278160"
  },
  {
    "text": "And so you can\ntake insertion sort and you can sort of trivially\nturn it into a theta n log n",
    "start": "1278160",
    "end": "1284800"
  },
  {
    "text": "algorithm if we\nare talking about n being the number of compares.",
    "start": "1284800",
    "end": "1289909"
  },
  {
    "text": "And all you have to do\nto do that is to say, you know what, I'm\ngoing to replace this with binary search.",
    "start": "1289910",
    "end": "1297950"
  },
  {
    "text": "And you can do that-- and\nthat was the key observation-- because A of 0 through i\nminus 1 is already sorted.",
    "start": "1297950",
    "end": "1307990"
  },
  {
    "text": "And so you can do binary search\non that part of the array. So let me just write that down.",
    "start": "1307990",
    "end": "1313200"
  },
  {
    "text": " Do a binary search on A\nof 0 through i minus 1,",
    "start": "1313200",
    "end": "1324000"
  },
  {
    "text": "which is already sorted. ",
    "start": "1324000",
    "end": "1330539"
  },
  {
    "text": "And essentially, you can think\nof it as theta log i time,",
    "start": "1330540",
    "end": "1336780"
  },
  {
    "text": "and for each of those steps. And so then you get your\ntheta n log n theta n log",
    "start": "1336780",
    "end": "1347251"
  },
  {
    "text": "n in terms of compares. Does this help the swaps\nfor an array data structure?",
    "start": "1347251",
    "end": "1357940"
  },
  {
    "text": "No, because binary search\nwill require insertion into A of 0 though i minus 1.",
    "start": "1357940",
    "end": "1364670"
  },
  {
    "text": "So here's the problem. Why don't we have a full-fledged\ntheta n log n algorithm,",
    "start": "1364670",
    "end": "1370430"
  },
  {
    "text": "regardless of the cost\nof compares or swaps? We don't quite have that.",
    "start": "1370430",
    "end": "1375470"
  },
  {
    "text": "We don't quite have that because\nwe need to insert our A of i",
    "start": "1375470",
    "end": "1382950"
  },
  {
    "text": "into the right position into\nA of 0 through i minus 1. You do that if you have\nan array structure,",
    "start": "1382950",
    "end": "1389789"
  },
  {
    "text": "it might get into the middle. And you have to shift\nthings over to the right. And when you shift\nthings over to the right,",
    "start": "1389790",
    "end": "1395170"
  },
  {
    "text": "in the worst case, you may\nbe shifting a lot of things over to the right. And that gets back to worst\ncase complexity of theta n.",
    "start": "1395170",
    "end": "1400630"
  },
  {
    "text": " So a binary search\nin insertion sort",
    "start": "1400630",
    "end": "1407000"
  },
  {
    "text": "gives you theta n\nlog n for compares. But it's still theta\nn squared for swaps. ",
    "start": "1407000",
    "end": "1415000"
  },
  {
    "text": "So as you can see,\nthere's many varieties of sorting algorithms. We just looked at\na couple of them. And they were both\ninsertion sort.",
    "start": "1415000",
    "end": "1423010"
  },
  {
    "text": "The second one\nthat I just put up is, I guess, technically\ncalled binary insertion sort",
    "start": "1423010",
    "end": "1428900"
  },
  {
    "text": "because it does binary search. And the vanilla\ninsertion sort is the one that you have the code\nfor in the doc dis program,",
    "start": "1428900",
    "end": "1436676"
  },
  {
    "text": "or at least one of\nthe doc dis files. So let's move on and talk\nabout a different algorithm.",
    "start": "1436676",
    "end": "1444620"
  },
  {
    "text": "So what we'd like to\ndo, now-- this class is about constant improvement. We're never happy.",
    "start": "1444620",
    "end": "1451480"
  },
  {
    "text": "We always want to do\na little bit better. And eventually, once\nwe run out of room",
    "start": "1451480",
    "end": "1456864"
  },
  {
    "text": "from an asymptotic\nstandpoint, you take these other classes\nwhere you try and improve constant factors and\nget 10%, and 5%, and 1%,",
    "start": "1456864",
    "end": "1464380"
  },
  {
    "text": "and so on, and so forth. But we'll stick to improving\nasymptotic complexity.",
    "start": "1464380",
    "end": "1471200"
  },
  {
    "text": "And we're not quite happy\nwith binary insertion sort because, in the case of numbers,\nour binary insertion sort",
    "start": "1471200",
    "end": "1477049"
  },
  {
    "text": "has theta n squared complexity,\nif you look at swaps. So we'd like to go find an\nalgorithm that is theta n log",
    "start": "1477050",
    "end": "1483042"
  },
  {
    "text": "n. And I guess, eventually,\nwe'll have to stop.",
    "start": "1483042",
    "end": "1489600"
  },
  {
    "text": "But Erik will take care of that.  There's a reason to stop.",
    "start": "1489600",
    "end": "1494970"
  },
  {
    "text": "It's when you can prove that\nyou can't do any better. And so we'll get to\nthat, eventually.",
    "start": "1494970",
    "end": "1501210"
  },
  {
    "text": "So merge sort is also something\nthat you've probably seen. ",
    "start": "1501210",
    "end": "1507277"
  },
  {
    "text": "But there probably\nwill be a couple of subtleties that come out as\nI describe this algorithm that,",
    "start": "1507277",
    "end": "1512440"
  },
  {
    "text": "hopefully, will be interesting\nto those of you who already know merge sort. And for those of you who don't,\nit's a very pretty algorithm.",
    "start": "1512440",
    "end": "1521030"
  },
  {
    "text": "It's a standard recursion\nalgorithm-- recursive",
    "start": "1521030",
    "end": "1526930"
  },
  {
    "text": "algorithm-- similar\nto a binary search. What we do, here, is we have\nan array, A. We split it",
    "start": "1526930",
    "end": "1534780"
  },
  {
    "text": "into two parts, L and R.\nAnd essentially, we kind of",
    "start": "1534780",
    "end": "1542095"
  },
  {
    "text": "do no work, really. In terms of the L and R in\nthe sense that we just call,",
    "start": "1542095",
    "end": "1549814"
  },
  {
    "text": "we keep splitting,\nsplitting, splitting. And all the work is\ndone down at the bottom in this routine called\nmerge, where we are merging",
    "start": "1549814",
    "end": "1557570"
  },
  {
    "text": "a pair of elements\nat the leaves. And then, we merge two\npairs and get four elements.",
    "start": "1557570",
    "end": "1564490"
  },
  {
    "text": "And then we merge four tuples\nof elements, et cetera, and go all the way up.",
    "start": "1564490",
    "end": "1570080"
  },
  {
    "text": "So while I'm just saying L\nterms into L prime, out here,",
    "start": "1570080",
    "end": "1578990"
  },
  {
    "text": "there's no real\nexplicit code that you can see that turns\nL into L prime. It happens really later.",
    "start": "1578990",
    "end": "1585630"
  },
  {
    "text": "There's no real\nsorting code, here. It happens in the merge routine. And you'll see\nthat quite clearly",
    "start": "1585630",
    "end": "1590649"
  },
  {
    "text": "when we run through an example.  So you have L and R turn\ninto L prime and R prime.",
    "start": "1590649",
    "end": "1601500"
  },
  {
    "text": "And what we end up getting\nis a sorted array, A.",
    "start": "1601500",
    "end": "1612310"
  },
  {
    "text": "And we have what's called\na merge routine that",
    "start": "1612310",
    "end": "1618900"
  },
  {
    "text": "takes L prime and R\nprime and merges them into the sorted array. So at the top level, what\nyou see is split into two,",
    "start": "1618900",
    "end": "1629270"
  },
  {
    "text": "and do a merge, and get\nto the sorted array. The input is of size n.",
    "start": "1629270",
    "end": "1636680"
  },
  {
    "text": "You have two arrays\nof size n over 2.",
    "start": "1636680",
    "end": "1644690"
  },
  {
    "text": "These are two sorted\narrays of size n over 2.",
    "start": "1644690",
    "end": "1653210"
  },
  {
    "text": "And then, finally, you have\na sorted array of size n.",
    "start": "1653210",
    "end": "1659480"
  },
  {
    "text": " So if you want to follow\nthe recursive of execution of this in a small\nexample, then you'll",
    "start": "1659480",
    "end": "1669870"
  },
  {
    "text": "be able to see how this works. And we'll do a fairly\nstraightforward example",
    "start": "1669870",
    "end": "1676120"
  },
  {
    "text": "with 8 elements. So at the top level--\nbefore we get there, merge",
    "start": "1676120",
    "end": "1683179"
  },
  {
    "text": "is going to assume that\nyou have two sorted arrays,",
    "start": "1683180",
    "end": "1688640"
  },
  {
    "text": "and merge them together. That's the invariant in merge\nsort, or for the merge routine.",
    "start": "1688640",
    "end": "1695960"
  },
  {
    "text": "It assumes the inputs are\nsorted-- L and R. Actually I should say, L\nprime and R prime.",
    "start": "1695960",
    "end": "1702799"
  },
  {
    "text": "So let's say you have\n20, 13, 7, and 2. You have 12, 11, 9, and 1.",
    "start": "1702800",
    "end": "1711320"
  },
  {
    "text": "And this could be L prime. And this could be R prime.",
    "start": "1711320",
    "end": "1716840"
  },
  {
    "text": "What you have is what we\ncall a two finger algorithm. And so you've got two\nfingers and each of them",
    "start": "1716840",
    "end": "1722380"
  },
  {
    "text": "point to something. And in this case, one\nof them is pointing to L. My left finger\nis pointing to L prime,",
    "start": "1722380",
    "end": "1729190"
  },
  {
    "text": "or some element L prime. My right finger is pointing\nto some element in R prime. And I'm going to\ncompare the two elements",
    "start": "1729190",
    "end": "1736820"
  },
  {
    "text": "that my fingers are pointing to. And I'm going to\nchoose, in this case,",
    "start": "1736820",
    "end": "1742170"
  },
  {
    "text": "the smaller of those elements. And I'm going to put them\ninto the sorted array.",
    "start": "1742170",
    "end": "1747789"
  },
  {
    "text": "So start out here. Look at that and that. And I compared 2 and 1.",
    "start": "1747790",
    "end": "1754266"
  },
  {
    "text": "And which is smaller? 1 is smaller. So I'm going to write 1 down. This is a two finger\nalgo for merge.",
    "start": "1754266",
    "end": "1763720"
  },
  {
    "text": "And I put 1 down. When I put 1 down, I\nhad to cross out 1. So effectively, what\nhappens is-- let",
    "start": "1763720",
    "end": "1769395"
  },
  {
    "text": "me just circle that\ninstead of crossing it out. And my finger moves up to 9.",
    "start": "1769395",
    "end": "1775450"
  },
  {
    "text": "So now I'm pointing at 2 and 9. And I repeat this step. So now, in this\ncase, 2 is smaller.",
    "start": "1775450",
    "end": "1781870"
  },
  {
    "text": "So I'm going to go\nahead and write 2 down. And I can cross out 2 and\nmove my finger up to 7.",
    "start": "1781870",
    "end": "1789420"
  },
  {
    "text": "And so that's it. I won't bore you with\nthe rest of the steps. It's essentially walking up.",
    "start": "1789420",
    "end": "1796114"
  },
  {
    "text": "You have a couple of\npointers and you're walking up these two arrays. And you're writing down 1,\n2, 7, 9, 11, 12, 13, 20.",
    "start": "1796114",
    "end": "1807230"
  },
  {
    "text": "And that's your merge routine. And all of the work, really,\nis done in the merge routine",
    "start": "1807230",
    "end": "1812330"
  },
  {
    "text": "because, other than\nthat, the body is simply a recursive call. You have to, obviously,\nsplit the array.",
    "start": "1812330",
    "end": "1818420"
  },
  {
    "text": "But that's fairly\nstraightforward. If you have an array, A 0\nthrough n-- and depending on",
    "start": "1818420",
    "end": "1824600"
  },
  {
    "text": "whether n is odd\nor even-- you could imagine that you set L\nto be A 0 n by 2 minus 1,",
    "start": "1824600",
    "end": "1838530"
  },
  {
    "text": "and R similarly. And so you just split it\nhalfway in the middle.",
    "start": "1838530",
    "end": "1844086"
  },
  {
    "text": "I'll talk about that\na little bit more. There's a subtlety\nassociated with that that we'll get to\nin a few minutes.",
    "start": "1844086",
    "end": "1851200"
  },
  {
    "text": "But to finish up in terms of\nthe computation of merge sort. This is it. The merge routine is doing\nmost, if not all, of the work.",
    "start": "1851200",
    "end": "1860827"
  },
  {
    "text": "And this two finger\nalgorithm is going to be able to take\ntwo sorted arrays and put them into a\nsingle sorted array",
    "start": "1860827",
    "end": "1869550"
  },
  {
    "text": "by interspersing, or\ninterleaving, these elements. And what's the\ncomplexity of merge",
    "start": "1869550",
    "end": "1875000"
  },
  {
    "text": "if I have two arrays\nof size n over 2, here? What do I have?",
    "start": "1875000",
    "end": "1881809"
  },
  {
    "text": "AUDIENCE: n. PROFESSOR: n. We'll give you a cushion, too. ",
    "start": "1881810",
    "end": "1888049"
  },
  {
    "text": "theta n complexity. ",
    "start": "1888050",
    "end": "1895470"
  },
  {
    "text": "So far so good.  I know you know the\nanswer as to what",
    "start": "1895470",
    "end": "1901640"
  },
  {
    "text": "the complexity of merge sort is. But I'm guessing\nthat most of you won't be able to prove it to me\nbecause I'm kind of a hard guy",
    "start": "1901640",
    "end": "1907900"
  },
  {
    "text": "to prove something to. And I could always say,\nno, I don't believe you",
    "start": "1907900",
    "end": "1913040"
  },
  {
    "text": "or I don't understand.  The complexity-- and you've\nsaid this before, in class,",
    "start": "1913040",
    "end": "1920880"
  },
  {
    "text": "and I think Erik's\nmentioned it-- the overall complexity of this\nalgorithm is theta n log n",
    "start": "1920880",
    "end": "1928370"
  },
  {
    "text": "And where does that come from? How do you prove that? And so what we'll do, now,\nis take a look at merge sort.",
    "start": "1928370",
    "end": "1936840"
  },
  {
    "text": "And we'll look at\nthe recursion tree. And we'll try and--\nthere are many ways of proving that merge\nsort is theta n log n.",
    "start": "1936840",
    "end": "1943370"
  },
  {
    "text": "The way we're\ngoing to do this is what's called proof by picture.",
    "start": "1943370",
    "end": "1948640"
  },
  {
    "text": "And it's not an established\nproof technique, but it's something\nthat is very helpful",
    "start": "1948640",
    "end": "1955020"
  },
  {
    "text": "to get an intuition\nbehind the proof and why the result is true.",
    "start": "1955020",
    "end": "1960440"
  },
  {
    "text": "And you can always\ntake that and you can formalize it and\nmake this something",
    "start": "1960441",
    "end": "1967029"
  },
  {
    "text": "that everyone believes. And we'll also look at\nsubstitution, possibly",
    "start": "1967030",
    "end": "1972960"
  },
  {
    "text": "in section tomorrow,\nfor recurrence solving. So where we're right now is that\nwe have a divide and conquer",
    "start": "1972960",
    "end": "1980540"
  },
  {
    "text": "algorithm that has a merge\nstep that is theta n.",
    "start": "1980540",
    "end": "1987710"
  },
  {
    "text": "And so, if I just look at this\nstructure that I have here, I can write a recurrence\nfor merge sort",
    "start": "1987710",
    "end": "1996150"
  },
  {
    "text": "that looks like this. So when I say\ncomplexity, I can say",
    "start": "1996150",
    "end": "2002720"
  },
  {
    "text": "T of n, which is the\nwork done for n items, is going to be some\nconstant time in order",
    "start": "2002720",
    "end": "2008910"
  },
  {
    "text": "to divide the array. So this could be the\npart corresponding",
    "start": "2008910",
    "end": "2014200"
  },
  {
    "text": "to dividing the array. And there's going to be two\nproblems of size n over 2.",
    "start": "2014200",
    "end": "2020360"
  },
  {
    "text": "And so I have 2 T of n over 2. And this is the recursive part. ",
    "start": "2020360",
    "end": "2028649"
  },
  {
    "text": "And I'm going to have c times\nn, which is the merge part.",
    "start": "2028650",
    "end": "2033960"
  },
  {
    "text": "And that's some constant times\nn, which is what we have, here, with respect to\nthe theta n complexity.",
    "start": "2033960",
    "end": "2041890"
  },
  {
    "text": "So you have a recurrence like\nthis and I know some of you have seen recurrences in 6.042.",
    "start": "2041890",
    "end": "2047150"
  },
  {
    "text": "And you know how to solve this. What I'd like to do is show you\nthis recursion tree expansion",
    "start": "2047150",
    "end": "2054469"
  },
  {
    "text": "that, not only tells you how\nto solve this occurrence, but also gives you a means\nof solving recurrences where,",
    "start": "2054469",
    "end": "2063102"
  },
  {
    "text": "instead of having c of n, you\nhave something else out here. You have f of n, which\nis a different function from the linear function.",
    "start": "2063102",
    "end": "2069280"
  },
  {
    "text": "And this recursion\ntree is, in my mind, the simplest way of\narguing the theta n log n",
    "start": "2069280",
    "end": "2078649"
  },
  {
    "text": "complexity of merge sort. So what I want to do is\nexpand this recurrence out.",
    "start": "2078650",
    "end": "2084339"
  },
  {
    "text": "And let's do that over here. ",
    "start": "2084339",
    "end": "2106829"
  },
  {
    "text": "So I have c of n on top. I'm going to ignore this\nconstant factor because c of n",
    "start": "2106830",
    "end": "2115849"
  },
  {
    "text": "dominates. So I'll just start with c of n. I want to break things\nup, as I do the recursion.",
    "start": "2115850",
    "end": "2123450"
  },
  {
    "text": "So when I go c of n, at\nthe top level-- that's the work I have to do at\nthe merge, at the top level.",
    "start": "2123450",
    "end": "2129750"
  },
  {
    "text": "And then when I go down to two\nsmaller problems, each of them is size n over 2. So I do c times n\ndivided by 2 [INAUDIBLE].",
    "start": "2129750",
    "end": "2138440"
  },
  {
    "text": "So this is just a constant c. I didn't want to\nwrite thetas up here. You could.",
    "start": "2138440",
    "end": "2144440"
  },
  {
    "text": "And I'll say a little bit\nmore about that later. But think of this cn as\nrepresenting the theta n complexity.",
    "start": "2144440",
    "end": "2150260"
  },
  {
    "text": "And c is this constant. So c times n, here. c\ntimes n over 2, here.",
    "start": "2150260",
    "end": "2157960"
  },
  {
    "text": "And then when I keep going,\nI have c times n over 4, c times n over 4, et cetera,\nand so on, and so forth.",
    "start": "2157960",
    "end": "2168910"
  },
  {
    "text": "And when I come down\nall the way here, n is eventually going to become\n1-- or essentially a constant--",
    "start": "2168910",
    "end": "2176670"
  },
  {
    "text": "and I'm going to have\na bunch of c's here. So here's another question,\nthat I'd like you to answer.",
    "start": "2176670",
    "end": "2187050"
  },
  {
    "text": "Someone tell me what the number\nof levels in this tree are, precisely, and the number\nof leaves in this tree are,",
    "start": "2187050",
    "end": "2194060"
  },
  {
    "text": "precisely. AUDIENCE: The number of\nlevels is log n plus 1. PROFESSOR: Log n plus 1. Log to the base 2 plus 1.",
    "start": "2194060",
    "end": "2201169"
  },
  {
    "text": "And the number of leaves? ",
    "start": "2201169",
    "end": "2208430"
  },
  {
    "text": "You raised your hand\nback there, first. Number of leaves. AUDIENCE: I think n. PROFESSOR: Yeah, you're right.",
    "start": "2208430",
    "end": "2214130"
  },
  {
    "text": "You think right. So 1 plus log n and n leaves.",
    "start": "2214130",
    "end": "2222520"
  },
  {
    "text": "When n becomes 1, how\nmany of them do you have? You're down to a single element,\nwhich is, by definition,",
    "start": "2222520",
    "end": "2229470"
  },
  {
    "text": "sorted. And you have n leaves. So now let's add up the work.",
    "start": "2229470",
    "end": "2237020"
  },
  {
    "text": "I really like this\npicture because it's just so intuitive in terms\nof getting us the result",
    "start": "2237020",
    "end": "2243450"
  },
  {
    "text": "that we're looking for. So you add up the work in each\nof the levels of this tree.",
    "start": "2243450",
    "end": "2250080"
  },
  {
    "text": "So the top level is cn. The second level is cn because\nI added 1/2 and 1/2, cn, cn.",
    "start": "2250080",
    "end": "2259790"
  },
  {
    "text": "Wow. What symmetry. So you're doing the same\namount of work modulo",
    "start": "2259790",
    "end": "2270500"
  },
  {
    "text": "the constant factors,\nhere, with what's going on with the c1,\nwhich we've ignored,",
    "start": "2270500",
    "end": "2276280"
  },
  {
    "text": "but roughly the same amount\nof work in each of the levels. And now, you know how\nmany levels there are.",
    "start": "2276280",
    "end": "2282570"
  },
  {
    "text": "It's 1 plus log n. So if you want to write\nan equation for T of n,",
    "start": "2282570",
    "end": "2291930"
  },
  {
    "text": "it's 1 plus log n times c of\nn, which is theta of n log n.",
    "start": "2291930",
    "end": "2303030"
  },
  {
    "text": " So I've mixed in\nconstants c and thetas.",
    "start": "2303030",
    "end": "2311049"
  },
  {
    "text": "For the purposes of\nthis description, they're interchangeable. You will see recurrences that\nlook like this, in class.",
    "start": "2311049",
    "end": "2318095"
  },
  {
    "start": "2318095",
    "end": "2325210"
  },
  {
    "text": "And things like that. Don't get confused. It's just a constant\nmultiplicative factor",
    "start": "2325210",
    "end": "2331150"
  },
  {
    "text": "in front of the\nfunction that you have. And it's just a little\neasier, I think,",
    "start": "2331150",
    "end": "2336230"
  },
  {
    "text": "to write down these\nconstant factors and realize that the\namount of work done is the same in\neach of the leaves.",
    "start": "2336230",
    "end": "2342980"
  },
  {
    "text": "And once you know the\ndimensions of this tree, in terms of levels and in\nterms of the number of leaves,",
    "start": "2342980",
    "end": "2348930"
  },
  {
    "text": "you get your result. ",
    "start": "2348930",
    "end": "2354560"
  },
  {
    "text": "So we've looked at\ntwo algorithm, so far. ",
    "start": "2354560",
    "end": "2366160"
  },
  {
    "text": "And insertion sort, if\nyou talk about numbers, is theta n squared for swaps.",
    "start": "2366160",
    "end": "2371964"
  },
  {
    "text": "Merge sort is theta n log n.  Here's another\ninteresting question.",
    "start": "2371964",
    "end": "2378680"
  },
  {
    "text": "What is one advantage of\ninsertion sort over merge sort?",
    "start": "2378680",
    "end": "2384720"
  },
  {
    "start": "2384720",
    "end": "2390176"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] PROFESSOR: What does that mean? AUDIENCE: You don't have\nto move elements outside of [INAUDIBLE].",
    "start": "2390176",
    "end": "2396960"
  },
  {
    "text": "PROFESSOR: That's exactly right. That's exactly right. So the two guys who\nanswered the questions",
    "start": "2396960",
    "end": "2403270"
  },
  {
    "text": "before with the levels, and you. Come to me after class. So that's a great answer.",
    "start": "2403270",
    "end": "2409690"
  },
  {
    "text": "It's in-place\nsorting is something that has to do with\nauxiliary space.",
    "start": "2409690",
    "end": "2414819"
  },
  {
    "text": "And so what you see, here--\nand it was a bit hidden, here. But the fact of the\nmatter is that you",
    "start": "2414820",
    "end": "2421940"
  },
  {
    "text": "had L prime and R prime. And L prime and R prime are\ndifferent from L and R, which",
    "start": "2421940",
    "end": "2429910"
  },
  {
    "text": "were the initial halves of\nthe inputs to the sorting algorithm.",
    "start": "2429910",
    "end": "2434990"
  },
  {
    "text": "And what I said here is, we're\ngoing to dump this into A. That's what this picture shows.",
    "start": "2434990",
    "end": "2440440"
  },
  {
    "text": "This says sorted\narray, A. And so you had to make a copy of the\narray-- the two halves L",
    "start": "2440440",
    "end": "2448720"
  },
  {
    "text": "and R-- in order to\ndo the recursion, and then to take the\nresults and put them",
    "start": "2448720",
    "end": "2454490"
  },
  {
    "text": "into the sorted array, A. So you needed-- in\nmerge sort-- you needed theta n auxiliary space.",
    "start": "2454490",
    "end": "2464060"
  },
  {
    "text": "So merge sort, you need\ntheta n extra space.",
    "start": "2464060",
    "end": "2470370"
  },
  {
    "text": "And the definition\nof in-place sorting",
    "start": "2470370",
    "end": "2477380"
  },
  {
    "text": "implies that you have theta\n1-- constant-- auxiliary space. ",
    "start": "2477380",
    "end": "2484579"
  },
  {
    "text": "The auxiliary space\nfor insertion sort is simply that\ntemporary variable",
    "start": "2484580",
    "end": "2490450"
  },
  {
    "text": "that you need when\nyou swap two elements. So when you want to swap\na couple of registers,",
    "start": "2490450",
    "end": "2495520"
  },
  {
    "text": "you gotta store one of the\nvalues in a temporary location, override the other, et cetera. And that's the theta 1 auxiliary\nspace for insertion sort.",
    "start": "2495520",
    "end": "2503190"
  },
  {
    "text": "So there is an advantage of\nthe version of insertion sort we've talked about,\ntoday, over merge sort.",
    "start": "2503190",
    "end": "2509140"
  },
  {
    "text": "And if you have a billion\nelements, that's potentially something you don't\nwant to store in memory.",
    "start": "2509140",
    "end": "2514660"
  },
  {
    "text": "If you want to do something\nreally fast and do everything in cache or main\nmemory, and you want",
    "start": "2514660",
    "end": "2520400"
  },
  {
    "text": "to sort billions are maybe\neven trillions of items, this becomes an\nimportant consideration.",
    "start": "2520400",
    "end": "2527740"
  },
  {
    "text": "I will say that you can\nreduce the constant factor",
    "start": "2527740",
    "end": "2532930"
  },
  {
    "text": "of the theta n. So in the vanilla\nscheme, you could imagine that you have to\nhave a copy of the array.",
    "start": "2532930",
    "end": "2538690"
  },
  {
    "text": "So if you had n\nelements, you essentially have n extra items of storage.",
    "start": "2538690",
    "end": "2544490"
  },
  {
    "text": "You can make that n over 2\nwith a simple coding trick by keeping 1/2 of A.",
    "start": "2544490",
    "end": "2552710"
  },
  {
    "text": "You can throw away one of\nthe L's or one of the R's. And you can get it\ndown to n over 2. And that turns out--\nit's a reasonable thing",
    "start": "2552710",
    "end": "2559470"
  },
  {
    "text": "to do if you have\na billion elements and you want to reduce your\nstorage by a constant factor.",
    "start": "2559470",
    "end": "2565400"
  },
  {
    "text": "So that's one coding trick. Now it turns out that you\ncan actually go further. And there's a fairly\nsophisticated algorithm",
    "start": "2565400",
    "end": "2572130"
  },
  {
    "text": "that's sort of beyond\nthe scope of 6.006 that's an in-place merge sort. ",
    "start": "2572130",
    "end": "2579309"
  },
  {
    "text": "And this in-place\nmerge sort is kind of impractical in the sense\nthat it doesn't do very well",
    "start": "2579310",
    "end": "2588590"
  },
  {
    "text": "in terms of the\nconstant factors. So while it's in-place and\nit's still theta n log n.",
    "start": "2588590",
    "end": "2595119"
  },
  {
    "text": "The problem is that the running\ntime of an in-place merge sort is much worse than the\nregular merge sort that",
    "start": "2595120",
    "end": "2603210"
  },
  {
    "text": "uses theta n auxiliary space. So people don't really\nuse in-place merge sort. It's a great paper.",
    "start": "2603210",
    "end": "2609360"
  },
  {
    "text": "It's a great thing to read. Its analysis is a bit\nsophisticated for double 0 6.",
    "start": "2609360",
    "end": "2617080"
  },
  {
    "text": "So we wont go there. But it does exist. So you can take merge\nsort, and I just want to let you know that\nyou can do things in-place.",
    "start": "2617080",
    "end": "2625230"
  },
  {
    "text": "In terms of numbers, some\nexperiments we ran a few years",
    "start": "2625230",
    "end": "2630560"
  },
  {
    "text": "ago-- so these may not\nbe completely valid because I'm going to\nactually give you numbers--",
    "start": "2630560",
    "end": "2636650"
  },
  {
    "text": "but merge sort in Python, if\nyou write a little curve fit",
    "start": "2636650",
    "end": "2647380"
  },
  {
    "text": "program to do this, is 2.2n log\nn microseconds for a given n.",
    "start": "2647380",
    "end": "2657789"
  },
  {
    "text": "So this is the\nmerge sort routine.  And if you look at\ninsertion sort, in Python,",
    "start": "2657790",
    "end": "2672230"
  },
  {
    "text": "that's something like 0.2\nn square microseconds.",
    "start": "2672230",
    "end": "2679410"
  },
  {
    "text": "So you see the\nconstant factors here. If you do insertion sort in C,\nwhich is a compiled language,",
    "start": "2679410",
    "end": "2688230"
  },
  {
    "text": "then, it's much faster. It's about 20 times faster. ",
    "start": "2688230",
    "end": "2695440"
  },
  {
    "text": "It's 0.01 n squared\nmicroseconds. So a little bit of\npractice on the side.",
    "start": "2695440",
    "end": "2700960"
  },
  {
    "text": "We do ask you to write code. And this is important. The reason we're\ninterested in algorithms is because people\nwant to run them.",
    "start": "2700960",
    "end": "2706770"
  },
  {
    "text": "And what you can see is that\nyou can actually find an n-- so",
    "start": "2706770",
    "end": "2713860"
  },
  {
    "text": "regardless of whether\nyou're Python or C, this tells you that asymptotic\ncomplexity is pretty important",
    "start": "2713860",
    "end": "2720020"
  },
  {
    "text": "because, once n gets\nbeyond about 4,000, you're going to see that\nmerge sort in Python",
    "start": "2720020",
    "end": "2727260"
  },
  {
    "text": "beats insertion sort in C. So the constant\nfactors get subsumed",
    "start": "2727260",
    "end": "2735430"
  },
  {
    "text": "beyond certain values of n. So that's why asymptotic\ncomplexity is important. You do have a\nfactor of 20, here,",
    "start": "2735430",
    "end": "2741210"
  },
  {
    "text": "but that doesn't really\nhelp you in terms of keeping an n square\nalgorithm competitive.",
    "start": "2741210",
    "end": "2747440"
  },
  {
    "text": "It stays competitive\nfor a little bit longer, but then falls behind. ",
    "start": "2747440",
    "end": "2754520"
  },
  {
    "text": "That's what I wanted\nto cover for sorting. So hopefully, you\nhave a sense of what happens with these two\nsorting algorithms.",
    "start": "2754520",
    "end": "2762040"
  },
  {
    "text": "We'll look at a very different\nsorting algorithm next time, using heaps, which is a\ndifferent data structure.",
    "start": "2762040",
    "end": "2768460"
  },
  {
    "text": "The last thing I want to do in\nthe couple minutes I have left is give you a little more\nintuition as to recurrence",
    "start": "2768460",
    "end": "2774810"
  },
  {
    "text": "solving based on this diagram\nthat I wrote up there. And so we're going to use\nexactly this structure.",
    "start": "2774810",
    "end": "2781460"
  },
  {
    "text": "And we're going to look at a\ncouple of different recurrences that I won't really\nmotivate in terms of having a specific\nalgorithm, but I'll just",
    "start": "2781460",
    "end": "2789420"
  },
  {
    "text": "write out the recurrence. And we'll look at the\nrecursion tree for that.",
    "start": "2789420",
    "end": "2796339"
  },
  {
    "text": "And I'll try and tease out of\nyou the complexity associated",
    "start": "2796340",
    "end": "2801900"
  },
  {
    "text": "with these recurrences of\nthe overall complexity. ",
    "start": "2801900",
    "end": "2809480"
  },
  {
    "text": "So let's take a look at T\nof n equals 2 T of n over 2",
    "start": "2809480",
    "end": "2818000"
  },
  {
    "text": "plus c n squared.  Let me just call that c--\nno need for the brackets.",
    "start": "2818000",
    "end": "2828360"
  },
  {
    "text": "So constant c times n squared. So if you had a\ncrummy merge routine, and it was taking n square,\nand you coded it up wrong.",
    "start": "2828360",
    "end": "2838020"
  },
  {
    "text": "It's not a great motivation\nfor this recurrence, but it's a way this\nrecurrence could have come up.",
    "start": "2838020",
    "end": "2843980"
  },
  {
    "text": "So what does this\nrecursive tree look like? Well it looks kind of\nthe same, obviously.",
    "start": "2843980",
    "end": "2849580"
  },
  {
    "text": "You have c n square; you\nhave c n square divided by 4; c n square divided by\n4; c n square divided",
    "start": "2849580",
    "end": "2856619"
  },
  {
    "text": "by 16, four times. Looking a little bit\ndifferent from the other one.",
    "start": "2856620",
    "end": "2864460"
  },
  {
    "text": "The levels and the leaves\nare exactly the same. Eventually n is going\nto go down to 1.",
    "start": "2864460",
    "end": "2869720"
  },
  {
    "text": "So you will see c\nall the way here. And you're going\nto have n leaves.",
    "start": "2869720",
    "end": "2874735"
  },
  {
    "text": " And you will have, as\nbefore, 1 plus log n levels.",
    "start": "2874735",
    "end": "2883380"
  },
  {
    "text": "Everything is the same. And this is why I like this\nrecursive tree formulation so much because, now,\nall I have to do",
    "start": "2883380",
    "end": "2889370"
  },
  {
    "text": "is add up the work associated\nwith each of the levels",
    "start": "2889370",
    "end": "2894710"
  },
  {
    "text": "to get the solution\nto the recurrence. Now, take a look at\nwhat happens, here. c n square; c n square divided\nby 2; c n square divided by 4.",
    "start": "2894710",
    "end": "2905350"
  },
  {
    "text": "And this is n times c. ",
    "start": "2905350",
    "end": "2910890"
  },
  {
    "text": "So what does that add up to? AUDIENCE: [INAUDIBLE] PROFESSOR: Yeah, exactly.",
    "start": "2910890",
    "end": "2916880"
  },
  {
    "text": "Exactly right. So if you look at what\nhappens, here, this dominates. ",
    "start": "2916880",
    "end": "2924339"
  },
  {
    "text": "All of the other things are\nactually less than that. And you said bounded\nby two c n square because this part is\nbounded by c n square",
    "start": "2924340",
    "end": "2931420"
  },
  {
    "text": "and I already have c n\nsquare up at the top. So this particular algorithm\nthat corresponds to this crummy",
    "start": "2931420",
    "end": "2938100"
  },
  {
    "text": "merge sort, or wherever\nthis recurrence came from, is a theta n squared algorithm.",
    "start": "2938100",
    "end": "2946700"
  },
  {
    "text": "And in this case,\nall of the work done is at the root-- at the\ntop level of the recursion.",
    "start": "2946700",
    "end": "2955360"
  },
  {
    "text": "Here, there was a\nroughly equal amount of work done in each of\nthe different levels.",
    "start": "2955360",
    "end": "2961630"
  },
  {
    "text": "Here, all of the work\nwas done at the root. And so to close\nup shop, here, let",
    "start": "2961630",
    "end": "2969460"
  },
  {
    "text": "me just give you real\nquick a recurrence where all of the work is done at\nthe leaves, just for closure.",
    "start": "2969460",
    "end": "2980470"
  },
  {
    "text": "So if I had, magically, a merge\nroutine that actually happened",
    "start": "2980470",
    "end": "2985770"
  },
  {
    "text": "in constant time, either\nthrough buggy analysis, or because of it\nwas buggy, then what",
    "start": "2985770",
    "end": "2991890"
  },
  {
    "text": "does the tree look\nlike for that? And I can think of\nthis as being theta 1.",
    "start": "2991890",
    "end": "2998279"
  },
  {
    "text": "Or I can think of this as\nbeing just a constant c. I'll stick with that. So I have c, c, c.",
    "start": "2998280",
    "end": "3005246"
  },
  {
    "text": " Woah, I tried to move that up.",
    "start": "3005246",
    "end": "3011349"
  },
  {
    "text": "That doesn't work. So I have n leaves, as before. ",
    "start": "3011350",
    "end": "3018314"
  },
  {
    "text": "And so if I look at\nwhat I have, here, I have c at the top level. I have 2c, and so\non and so forth.",
    "start": "3018314",
    "end": "3025870"
  },
  {
    "text": "4c. And then I go all\nthe way down to nc.",
    "start": "3025870",
    "end": "3030940"
  },
  {
    "text": "And so what happens\nhere is this dominates. ",
    "start": "3030940",
    "end": "3036009"
  },
  {
    "text": "And so, in this recurrence, the\nwhole thing runs in theta n.",
    "start": "3036010",
    "end": "3041600"
  },
  {
    "text": "So the solution to\nthat is theta n. And what you have here\nis all of the work",
    "start": "3041600",
    "end": "3050970"
  },
  {
    "text": "being done at the leaves. We're not going to really cover\nthis theorem that gives you",
    "start": "3050970",
    "end": "3058440"
  },
  {
    "text": "a mechanical way of figuring\nthis out because we think the recursive tree is a\nbetter way of looking at.",
    "start": "3058440",
    "end": "3065780"
  },
  {
    "text": "But you can see that, depending\non what that function is, in terms of the work being\ndone in the merge routine,",
    "start": "3065780",
    "end": "3072130"
  },
  {
    "text": "you'd have different\nversions of recurrences. I'll stick around, and people\nwho answered questions, please pick up you cushions.",
    "start": "3072130",
    "end": "3078270"
  },
  {
    "text": "See you next time.",
    "start": "3078270",
    "end": "3080240"
  }
]