[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " PROFESSOR: All right. Today, we're going to look at\nsome kind of different data",
    "start": "18450",
    "end": "24880"
  },
  {
    "text": "structures for static trees. So we have-- at least in\nthe second two problems--",
    "start": "24880",
    "end": "30294"
  },
  {
    "text": "we have a static tree. We want to preprocess it\nto answer lots of queries. And all the queries we're\ngoing to support today",
    "start": "30294",
    "end": "37379"
  },
  {
    "text": "we'll do in constant time per\noperation, which is pretty awesome, and linear space. That's our goal.",
    "start": "37380",
    "end": "42797"
  },
  {
    "text": "It's going to be hard\nto achieve these goals. But in the end, we will\ndo it for all three of these problems. So let me tell you\nabout these problems.",
    "start": "42797",
    "end": "49480"
  },
  {
    "text": "Range minimum queries, you're\ngiven an array of numbers.",
    "start": "49480",
    "end": "57160"
  },
  {
    "start": "57160",
    "end": "67064"
  },
  {
    "text": "And the kind of query\nyou want to support--  we'll call RMQ of ij--",
    "start": "67064",
    "end": "74671"
  },
  {
    "text": " is to find the\nminimum in a range.",
    "start": "74671",
    "end": "81630"
  },
  {
    "text": "So we have Ai up to Aj and we\nwant to compute the minimum",
    "start": "81630",
    "end": "94280"
  },
  {
    "text": "in that range. So i and j form the query. I think it's pretty\nclear what this means.",
    "start": "94280",
    "end": "100670"
  },
  {
    "text": "I give you an interval\nthat I care about, ij, and I want to know,\nin this range,",
    "start": "100670",
    "end": "106730"
  },
  {
    "text": "what's the smallest value. And a little more subtle--\nthis will come up later. I don't just want to\nknow the value that's",
    "start": "106730",
    "end": "112880"
  },
  {
    "text": "there-- like say\nthis is the minimum among that shaded region. But I also want to know\nthe index K between i",
    "start": "112880",
    "end": "120820"
  },
  {
    "text": "and j of that element. Of course, if I know the index,\nI can also look up the value.",
    "start": "120820",
    "end": "126230"
  },
  {
    "text": "So it's more interesting\nto know that index. OK. This is a non-tree problem,\nbut it will be closely related",
    "start": "126230",
    "end": "133880"
  },
  {
    "text": "to tree problem, namely LCA. ",
    "start": "133880",
    "end": "142239"
  },
  {
    "text": "So LCA problem is you\nwant to preprocess a tree.",
    "start": "142240",
    "end": "148000"
  },
  {
    "text": "It's a rooted tree, and the\nquery is LCA of two nodes.",
    "start": "148000",
    "end": "162950"
  },
  {
    "text": "Which I think you know, or\nI guess I call them x and y. So it has two nodes\nx and y in the tree.",
    "start": "162950",
    "end": "170540"
  },
  {
    "text": "I want to find their lowest\ncommon ancestor, which looks something like that. ",
    "start": "170540",
    "end": "177110"
  },
  {
    "text": "At some point they\nhave shared ancestors, and we want to find\nthat lowest one. And then another problem\nwe're going to solve",
    "start": "177110",
    "end": "183799"
  },
  {
    "text": "is level ancestor,\nwhich again, preprocess a rooted tree and the query\nis a little different.",
    "start": "183800",
    "end": "194952"
  },
  {
    "text": " Given a node and an integer k--",
    "start": "194952",
    "end": "202130"
  },
  {
    "text": "positive integer--\nI want to find the kth ancestor of that node.",
    "start": "202130",
    "end": "210740"
  },
  {
    "text": "Which you might write parent to\nthe k, meaning I have a node x,",
    "start": "210740",
    "end": "217040"
  },
  {
    "text": "the first ancestor\nis its parent.  Eventually want to get\nto the kth ancestor.",
    "start": "217040",
    "end": "225720"
  },
  {
    "text": "So I want to jump\nfrom x to there. So it's like teleporting to\na target height above me.",
    "start": "225720",
    "end": "233840"
  },
  {
    "text": "Obviously, k cannot be larger\nthan the depth of the node. So these are the three problems\nwe're going to solve today,",
    "start": "233840",
    "end": "240905"
  },
  {
    "text": "RMQ, LCA, and LA.",
    "start": "240905",
    "end": "246380"
  },
  {
    "text": "Using somewhat\nsimilar techniques, we're going to use a\nnice technique called table look-up,\nwhich is generally",
    "start": "246380",
    "end": "252141"
  },
  {
    "text": "useful for a lot\nof data structures. We are working in the\nWord RAM throughout.",
    "start": "252141",
    "end": "258060"
  },
  {
    "text": "But that's not as essential as\nit has been in our past integer data structures.",
    "start": "258060",
    "end": "264620"
  },
  {
    "text": "Now the fun thing\nabout these problems is while LCA and LA\nlook quite similar--",
    "start": "264620",
    "end": "270110"
  },
  {
    "text": "I mean, they even share\ntwo letters out of three-- they're quite different. As far as I know, you need\nfairly different techniques",
    "start": "270110",
    "end": "277130"
  },
  {
    "text": "to deal with-- or as\nfar as anyone knows-- you need pretty\ndifferent techniques to deal with both of them.",
    "start": "277130",
    "end": "282409"
  },
  {
    "text": "The original paper that\nsolved level ancestors kind of lamented on this. RMQ, on the other\nhand, turns out",
    "start": "282410",
    "end": "289159"
  },
  {
    "text": "to be basically\nidentical to LCA. So that's the more\nsurprising thing,",
    "start": "289160",
    "end": "294750"
  },
  {
    "text": "and I want to start with that. Again, our goal is to get\nconstant time, linear space for all these problems.",
    "start": "294750",
    "end": "302390"
  },
  {
    "text": "Constant time is easy to\nget with polynomial space. You could just store\nall the answers. There's only n squared different\nqueries for all these problems,",
    "start": "302390",
    "end": "311210"
  },
  {
    "text": "so quadratic space is easy. Linear space is the hard part. So let me tell you\nabout a nice reduction",
    "start": "311210",
    "end": "319130"
  },
  {
    "text": "from an array to a tree. ",
    "start": "319130",
    "end": "330830"
  },
  {
    "text": "Very simple idea. It's called the Cartesian tree. It goes back to Gabow\nBentley and Tarjan in 1984.",
    "start": "330830",
    "end": "337110"
  },
  {
    "text": "It's an old idea, but it\ncomes up now and then, and in particular,\nprovides the equivalence between RMQ and LCA,\nor one direction of it.",
    "start": "337110",
    "end": "345980"
  },
  {
    "text": "I just take a minimum element-- ",
    "start": "345980",
    "end": "351169"
  },
  {
    "text": "let's call it Ai-- of the array. Let that be the root of my tree.",
    "start": "351170",
    "end": "358560"
  },
  {
    "text": "And then the left\nsub-tree of T is just going to be a\nCartesian tree on all",
    "start": "358560",
    "end": "370639"
  },
  {
    "text": "the elements to the left of i. So A less than i, and\nthen the right sub-tree",
    "start": "370640",
    "end": "379219"
  },
  {
    "text": "is going to be A greater than i. So let's do little example.",
    "start": "379220",
    "end": "385190"
  },
  {
    "start": "385190",
    "end": "392560"
  },
  {
    "text": "Suppose we have 8,\n7, 2, 8, 6, 9, 4, 5.",
    "start": "392560",
    "end": "401976"
  },
  {
    "text": " So the minimum in\nthis rate is 2.",
    "start": "401976",
    "end": "408150"
  },
  {
    "text": "So it gets promoted\nto the root, which decomposes the problem into\ntwo halves, the left half",
    "start": "408150",
    "end": "415350"
  },
  {
    "text": "and the right half. So drawing the tree, I put 2-- maybe over here is\nactually nicer--",
    "start": "415350",
    "end": "422130"
  },
  {
    "text": "2 at the root. On the left side,\n7 is the smallest. And so it's going to get\npromoted to be the root,",
    "start": "422130",
    "end": "428550"
  },
  {
    "text": "and so the left side\nwill look like this. On the right side,\nthe minimum is 4,",
    "start": "428550",
    "end": "435840"
  },
  {
    "text": "so 4 is the right root, which\ndecomposes into the left half",
    "start": "435840",
    "end": "444460"
  },
  {
    "text": "there, the right half there. So the right thing is just 5. Here the minimum is 6, and\nso we get a nice binary tree",
    "start": "444460",
    "end": "454050"
  },
  {
    "text": "on the left here.  OK. This is not a\nbinary search tree.",
    "start": "454050",
    "end": "460650"
  },
  {
    "text": "It's a min heap. ",
    "start": "460650",
    "end": "469330"
  },
  {
    "text": "Cartesian tree is a min heap. But Cartesian trees have a\nmore interesting property,",
    "start": "469330",
    "end": "476420"
  },
  {
    "text": "which I've kind of alluded\nto a couple of times already, which is that LCAs in\nthis tree correspond",
    "start": "476420",
    "end": "482140"
  },
  {
    "text": "to RMQs in this array. So let's do some examples.",
    "start": "482140",
    "end": "487400"
  },
  {
    "text": "Let's say I do LCA of 7 and 8. That's 2. Anything from the left and the\nright sub-tree, the LCA is 2.",
    "start": "487400",
    "end": "496630"
  },
  {
    "text": "And indeed, if I take anything,\nany interval that spans 2, then the RMQ is 2.",
    "start": "496630",
    "end": "502684"
  },
  {
    "text": "If I don't span 2, I'm either\nin the left or in the right. Let's say I'm on the right, say\nI do an LCA between 9 and 5.",
    "start": "502684",
    "end": "508790"
  },
  {
    "text": "I get 4 because, yeah, the\nRMQ between 9 and 5 is 4.",
    "start": "508790",
    "end": "514448"
  },
  {
    "text": "Make sense? Same problem, really, because\nit's all about which mins--",
    "start": "514449",
    "end": "521860"
  },
  {
    "text": "I mean in the sequence of mins--\nwhich mins do you contain? If you contain\nthe first min, you contain the highest\nmin you contain.",
    "start": "521860",
    "end": "528250"
  },
  {
    "text": "That is the answer and\nthat's what LCA in this tree",
    "start": "528250",
    "end": "535330"
  },
  {
    "text": "gives you. So LCA i and j in\nthis tree T equals",
    "start": "535330",
    "end": "542620"
  },
  {
    "text": "RMQ in the original array of\nthe corresponding elements.",
    "start": "542620",
    "end": "548089"
  },
  {
    "text": "So there is a bijection\nbetween these items, and so I and J here\nrepresents nodes, and here corresponding to\nthe corresponding items in A.",
    "start": "548090",
    "end": "558111"
  },
  {
    "text": "OK. So this says if you\nwanted to solve RMQ, you can reduce it\nto an LCA problem.",
    "start": "558111",
    "end": "565860"
  },
  {
    "text": "Quick note here, which is-- yeah. There's a couple of different\nversions of Cartesian trees",
    "start": "565860",
    "end": "572744"
  },
  {
    "text": "when you have ties, so\nhere I only had one 2. If there was another 2,\nthen you could either just",
    "start": "572744",
    "end": "580120"
  },
  {
    "text": "break ties arbitrarily\nand you get a binary tree, or you could make them all one\nnode, which is kind of messier,",
    "start": "580120",
    "end": "586480"
  },
  {
    "text": "and then you get\na non-binary tree. I think I'll say we\ndisambiguate arbitrarily.",
    "start": "586480",
    "end": "592210"
  },
  {
    "text": "Just pick any min, and\nthen you get a binary tree. It won't affect the answer. But I think the original paper\nmight do it a different way.",
    "start": "592210",
    "end": "599634"
  },
  {
    "text": " OK. ",
    "start": "599634",
    "end": "606250"
  },
  {
    "text": "Let's see. So then let me just\nmention a fun fact about this reduction, which\nis that you can compute it",
    "start": "606250",
    "end": "612490"
  },
  {
    "text": "in linear time. This is a fun fact we\nbasically saw last class, although in a completely\ndifferent setting,",
    "start": "612490",
    "end": "618595"
  },
  {
    "text": "so it's not at all obvious. But you may recall, we\nhad a method last time",
    "start": "618595",
    "end": "623740"
  },
  {
    "text": "for building a compressed\ntrie in linear time. Basically, same\nthing works here,",
    "start": "623740",
    "end": "629530"
  },
  {
    "text": "although it seems\nquite different. The idea is if you\nwant to build this, if you build a\nCartesian tree according",
    "start": "629530",
    "end": "634569"
  },
  {
    "text": "to this recursive\nalgorithm, you will spend n log n time or actually,\nmaybe even quadratic time, if you're computing\nmin with a linear scan.",
    "start": "634570",
    "end": "642190"
  },
  {
    "text": "So don't use that\nrecursive algorithm. Just walk through the array,\nleft to right, one at a time. So first you insert 8.",
    "start": "642190",
    "end": "648250"
  },
  {
    "text": "Then you insert\n7, and you realize 7 would have would have\nwon, so you put 7 above 8.",
    "start": "648250",
    "end": "653980"
  },
  {
    "text": "Then you insert 2. You say that's even higher than\n7, so I have to put it up here.",
    "start": "653980",
    "end": "659590"
  },
  {
    "text": "Then you insert 8 so that\nyou'll just go down from there, and you put 8 as a\nright child of 2.",
    "start": "659590",
    "end": "666250"
  },
  {
    "text": "Then you insert 6. You say whoops, 6 actually would\nhave gone in between 2 and 8.",
    "start": "666250",
    "end": "672790"
  },
  {
    "text": "And the way you'd see that is-- I mean, at that moment, your\ntree looks something like this. You've got 2, 8, and there's\nother stuff to the left,",
    "start": "672790",
    "end": "681367"
  },
  {
    "text": "but I don't actually care. I just care about\nthe right spine. I say I'm inserting 6. 6 would have been above\n8, but not above 2.",
    "start": "681367",
    "end": "688390"
  },
  {
    "text": "Therefore, it fits\nalong this edge, and so I convert this\ntree into this pattern,",
    "start": "688390",
    "end": "698110"
  },
  {
    "text": "and it will always\nlook like this.  8 becomes a child of 7--",
    "start": "698110",
    "end": "705240"
  },
  {
    "text": "sorry, 6. 6. Thanks.",
    "start": "705240",
    "end": "711006"
  },
  {
    "text": "Not 7. 7 was on the left. This is the guy I'm\ninserting next because here.",
    "start": "711006",
    "end": "718390"
  },
  {
    "text": "So I guess it's a left child\nbecause it's the first one.",
    "start": "718390",
    "end": "723450"
  },
  {
    "text": "So we insert 6 like this. So now the new\nright spine is 2, 6, and from then on,\nwe will always be",
    "start": "723450",
    "end": "728790"
  },
  {
    "text": "working to the right of that. We'll never be touching\nany of this left stuff. OK. So how long did it\ntake me to do that?",
    "start": "728790",
    "end": "735390"
  },
  {
    "text": "In general, I have a right\nspine of the tree, which are all right edges, and I might\nhave to walk up several steps",
    "start": "735390",
    "end": "742860"
  },
  {
    "text": "before I discover whoops, this\nis where the next item belongs.",
    "start": "742860",
    "end": "748620"
  },
  {
    "text": "And then I convert it\ninto this new entry, which has a left child,\nwhich is that stuff.",
    "start": "748620",
    "end": "755709"
  },
  {
    "text": "But this stuff becomes\nirrelevant from then on, because now, this\nis the new right spine. And so if this is a\nlong walk, I charge that",
    "start": "755709",
    "end": "762630"
  },
  {
    "text": "to the decrease in the\nlength of the right spine, just like that\nalgorithm last time. Slightly different\nnotion of right spine.",
    "start": "762630",
    "end": "770670"
  },
  {
    "text": "So same amortization,\nyou get linear time, and you can build\nthe Cartesian tree. This is actually where\nthat algorithm comes from.",
    "start": "770670",
    "end": "777031"
  },
  {
    "text": "This one was first, I believe.  Questions?",
    "start": "777031",
    "end": "783610"
  },
  {
    "text": "I'm not worrying too\nmuch about build time, how long it takes to build\nthese data structures, but they can all be\nbuilt in linear time.",
    "start": "783610",
    "end": "789930"
  },
  {
    "text": "And this is one of\nthe cooler algorithms, and it's a nice tie\ninto last lecture.",
    "start": "789930",
    "end": "795149"
  },
  {
    "text": "So that's a reduction\nfrom RMQ to LCA, so now all of our problems are\nabout trees, in some sense.",
    "start": "795150",
    "end": "801122"
  },
  {
    "text": "I mean, there's a\nreason I mentioned RMQ. Not just that it's a handy\nproblem to have solved, but we're actually going\nto use RMQ to solve LCA.",
    "start": "801122",
    "end": "809250"
  },
  {
    "text": "So we're going to go back and\nforth between the two a lot. ",
    "start": "809250",
    "end": "814870"
  },
  {
    "text": "Actually, we'll spend most\nof our time in the RMQ land. So let me tell you about\nthe reverse direction,",
    "start": "814870",
    "end": "820829"
  },
  {
    "text": "if you want to\nreduce LCA to RMQ. That also works.",
    "start": "820830",
    "end": "828300"
  },
  {
    "text": "And you can kind of\nsee it in this picture.",
    "start": "828300",
    "end": "833510"
  },
  {
    "text": "If I gave you this\ntree, how would you reconstruct this array? Pop quiz.",
    "start": "833510",
    "end": "839730"
  },
  {
    "text": "How do I go from here to here? ",
    "start": "839730",
    "end": "847820"
  },
  {
    "text": "In-order traversal, yep. Just doing an in-order\ntraversal, write those guys-- I mean, yeah.",
    "start": "847820",
    "end": "853801"
  },
  {
    "text": "Pretty easy. Now, not so easy because\nin the LCA problem, I don't have numbers\nin the nodes.",
    "start": "853801",
    "end": "859730"
  },
  {
    "text": "So if I do an in-order\nwalk and I write stuff, it's like, what should I\nwrite for each of the nodes.",
    "start": "859730",
    "end": "864910"
  },
  {
    "text": "Any suggestions? ",
    "start": "864910",
    "end": "885450"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] PROFESSOR: The height? Not quite the height. The depth. ",
    "start": "885450",
    "end": "896000"
  },
  {
    "text": "That will work. So let's do it,\njust so it's clear.",
    "start": "896000",
    "end": "904256"
  },
  {
    "text": "Look at the same tree\nIs that the same tree?",
    "start": "904256",
    "end": "912246"
  },
  {
    "text": "Yep. So I write the depths. 0, 1, 1, 2, 2, 2, 3, 3.",
    "start": "912246",
    "end": "920404"
  },
  {
    "text": "It's either height or depth,\nand you try them both. This is depth. So I do an in-order\nwalk I get 2, 1, 0--",
    "start": "920405",
    "end": "928625"
  },
  {
    "text": " can you read my writing-- 3, 2, 3, 1, 2.",
    "start": "928625",
    "end": "935474"
  },
  {
    "text": "It's funny doing an in-order\ntraversal on something that's not a binary search\ntree, but there it is.",
    "start": "935474",
    "end": "940590"
  },
  {
    "text": "That's the order in which\nyou visit the nodes. And you stare at it long\nenough, this sequence",
    "start": "940590",
    "end": "948630"
  },
  {
    "text": "will behave exactly the\nsame as this sequence. Of course, not in terms of\nthe actual values returned.",
    "start": "948630",
    "end": "955510"
  },
  {
    "text": "But if you do the\nargument version of RMQ, you just ask for what's the\nindex that gives me the min.",
    "start": "955510",
    "end": "961830"
  },
  {
    "text": "If you can solve RMQ\non this structure, then that RMQ will give\nexactly the same answers",
    "start": "961830",
    "end": "970050"
  },
  {
    "text": "as this structure. Just kind of nifty. Because here I had numbers, they\ncould be all over the place.",
    "start": "970050",
    "end": "977260"
  },
  {
    "text": "Here I have very clean numbers. They will go between 0 and\nthe height of the tree.",
    "start": "977260",
    "end": "984670"
  },
  {
    "text": "So in general at\nmost, 0, 2, n minus 1. So fun consequence of\nthis is you get a tool",
    "start": "984670",
    "end": "991980"
  },
  {
    "text": "for universe reduction in RMQ.",
    "start": "991980",
    "end": "998123"
  },
  {
    "text": "The tree problems\ndon't have this issue, because they don't\ninvolve numbers. They involve trees, and that's\nwhy this reduction does this.",
    "start": "998124",
    "end": "1004709"
  },
  {
    "text": "But you can start from an\narbitrary ordered universe",
    "start": "1004710",
    "end": "1014190"
  },
  {
    "text": "and have an RMQ problem on that,\nand you can convert it to LCA. And then you can convert it\nto a nice clean universe RMQ,",
    "start": "1014190",
    "end": "1030599"
  },
  {
    "text": "just by doing the Cartesian\ntree and then doing the in-order traversal\nof the depths. ",
    "start": "1030599",
    "end": "1037430"
  },
  {
    "text": "This is kind of nifty because\nif you look at these algorithms, they only assume a\ncomparison model.",
    "start": "1037430",
    "end": "1043783"
  },
  {
    "text": "So these don't\nhave to be numbers. They just have to be something\nfrom a totally ordered universe that you can compare\nin constant time.",
    "start": "1043784",
    "end": "1049220"
  },
  {
    "text": "You do this\nreduction, and now we can assume they're integers,\nnice small integers, and that will let us solve things in\nconstant time using the Word",
    "start": "1049220",
    "end": "1056510"
  },
  {
    "text": "RAM. So you don't need to assume\nthat about the original values.",
    "start": "1056510",
    "end": "1062250"
  },
  {
    "text": "Cool. So, time to actually\nsolve something. We've done reductions.",
    "start": "1062250",
    "end": "1067335"
  },
  {
    "text": "We now know RMQ and\nLCA are equivalent. Let's solve them both. ",
    "start": "1067335",
    "end": "1081500"
  },
  {
    "text": "Kind of like the last\nof the sorting we saw, there's going to\nbe a lot of steps.",
    "start": "1081500",
    "end": "1088062"
  },
  {
    "text": "They're not sequential steps. These are like different\nversions of a data structure for solving RMQ,\nand they're going",
    "start": "1088062",
    "end": "1094039"
  },
  {
    "text": "to be getting progressively\nbetter and better. So LCA which applies RMQ.",
    "start": "1094040",
    "end": "1106560"
  },
  {
    "text": " This is originally solved\nby Harel and Tarjan in 1984,",
    "start": "1106560",
    "end": "1113659"
  },
  {
    "text": "but is rather complicated. And then what I'm\ngoing to talk about is a version from 2000 by\nBender and Farach-Colton,",
    "start": "1113660",
    "end": "1121580"
  },
  {
    "text": "same authors from the\ncache-oblivious B-trees. That's a much\nsimpler presentation.",
    "start": "1121580",
    "end": "1128419"
  },
  {
    "text": "So first step is I want to do\nthis reduction again from LCA",
    "start": "1128420",
    "end": "1134630"
  },
  {
    "text": "to RMQ, but slightly\ndifferently. And we're going to get a more\nrestricted problem called",
    "start": "1134630",
    "end": "1140090"
  },
  {
    "text": "plus or minus 1 RMQ. ",
    "start": "1140090",
    "end": "1145130"
  },
  {
    "text": "What is plus or minus 1 RMQ? Just means that you get an array\nwhere all the adjacent values",
    "start": "1145130",
    "end": "1153170"
  },
  {
    "text": "differ by plus or minus 1. ",
    "start": "1153170",
    "end": "1159170"
  },
  {
    "text": "And if you look at the\nnumbers here, a lot of them differ by plus or minus 1. These all do.",
    "start": "1159170",
    "end": "1164690"
  },
  {
    "text": "But then there are\nsome big gaps-- like this has a gap of\n3, this has a gap of 2. This is plus or minus 1.",
    "start": "1164690",
    "end": "1171710"
  },
  {
    "text": "That's almost right,\nand if you just stare at this idea\nof tree walk enough,",
    "start": "1171710",
    "end": "1178549"
  },
  {
    "text": "you'll realize a\nlittle trick to make the array a little bit bigger,\nbut give you plus or minus",
    "start": "1178550",
    "end": "1184370"
  },
  {
    "text": "ones. If you've done a lot\nof tree traversal, this will come quite naturally.",
    "start": "1184370",
    "end": "1190040"
  },
  {
    "text": "This is a depth first search. This is how the depth\nfirst search order",
    "start": "1190040",
    "end": "1195460"
  },
  {
    "text": "of visiting a tree in order. This is usually called\nan Eulerian tour.",
    "start": "1195460",
    "end": "1200659"
  },
  {
    "text": "The concept we'll come\nback to in a few lectures. But Euler tour just means\nyou visit every edge twice,",
    "start": "1200660",
    "end": "1208070"
  },
  {
    "text": "in this case. If you look at the\nnode visits, I'm visiting this node here,\nhere, and here, three times.",
    "start": "1208070",
    "end": "1216590"
  },
  {
    "text": "But it's amortized constant,\nbecause every edge is just visited twice. What I'd like to do is\nfollow an Euler tour",
    "start": "1216590",
    "end": "1223790"
  },
  {
    "text": "and then write down all\nthe nodes that I visit,",
    "start": "1223790",
    "end": "1229490"
  },
  {
    "text": "but with repetition. So in that picture I\nwill get 0, 1, 2, 1.",
    "start": "1229490",
    "end": "1241010"
  },
  {
    "text": "I go 0, 1, 2, back to 1,\nback to 0, then over to the 1",
    "start": "1241010",
    "end": "1248450"
  },
  {
    "text": "on the right, then to\nthe 2, then to the 3, then back up to the 2,\nthen down to the other 3,",
    "start": "1248450",
    "end": "1255260"
  },
  {
    "text": "then back up to the\n2, back up to the 1, back down to the last\nnode on the right,",
    "start": "1255260",
    "end": "1260690"
  },
  {
    "text": "and back up and back up. OK. This is what we call Euler tour.",
    "start": "1260690",
    "end": "1266300"
  },
  {
    "text": "So multiple visits--\nfor example, here's all the places that\nthe root is visited.",
    "start": "1266300",
    "end": "1271670"
  },
  {
    "text": "Here's all the places\nthat this node is visited, then this node is\nvisited 3 times.",
    "start": "1271670",
    "end": "1280430"
  },
  {
    "text": "It's going to be visited\nonce per incident edge. I think you get the pattern.",
    "start": "1280430",
    "end": "1286840"
  },
  {
    "text": "I'm just going to store this. And what else am I going to do? Let's see. Each node in the tree\nstores, let's say,",
    "start": "1286840",
    "end": "1301610"
  },
  {
    "text": "the first visit in the array. Pretty sure this is enough.",
    "start": "1301610",
    "end": "1307086"
  },
  {
    "text": "You could maybe store\nthe last visit as well. We can only store a\nconstant number of things. And I guess each array\nitem stores a pointer",
    "start": "1307086",
    "end": "1324500"
  },
  {
    "text": "to the corresponding\nnode in the tree. ",
    "start": "1324500",
    "end": "1332340"
  },
  {
    "text": "OK. So each instance of the 0\nstores a pointer to the root, and so on.",
    "start": "1332340",
    "end": "1338470"
  },
  {
    "text": "It's kind of what these\nhorizontal bars are indicating, but those aren't\nactually stored.",
    "start": "1338470",
    "end": "1343760"
  },
  {
    "text": "OK. So I claim still RMQ and here\nis the same as LCA over there.",
    "start": "1343760",
    "end": "1352390"
  },
  {
    "text": "It's maybe a little\nmore subtle, but now if I want to compute\nthe LCA of two nodes,",
    "start": "1352390",
    "end": "1359300"
  },
  {
    "text": "I look at their\nfirst occurrences. So let's do-- I don't know-- 2 and 3.",
    "start": "1359300",
    "end": "1364909"
  },
  {
    "text": "Here, this 2 and this 3. I didn't label them, but I\nhappen to know where they are. 2 is here, and it's the first 3.",
    "start": "1364910",
    "end": "1371360"
  },
  {
    "text": " Now here, they happen to\nonly occur once in the tour,",
    "start": "1371360",
    "end": "1376669"
  },
  {
    "text": "so it's a little clearer. If I compute the RMQ,\nI get this 0, this 0, as opposed to the other 0s,\nbut this 0 points to the root,",
    "start": "1376669",
    "end": "1383090"
  },
  {
    "text": "so I get the LCA. Let's do ones that do not\nhave unique occurrences. So like, this guy and this guy,\nthe first 1 and the first 2",
    "start": "1383090",
    "end": "1391475"
  },
  {
    "text": "It'd be this 1 and this 1. In fact, I think any\nof the 2s would work.",
    "start": "1391475",
    "end": "1396560"
  },
  {
    "text": "Doesn't really matter. Just have to pick one of them. So I picked the leftmost\none for consistency. Then I take the\nRMQ, again I get 0.",
    "start": "1396560",
    "end": "1404400"
  },
  {
    "text": "You can test that\nfor all of them. I think the slightly\nmore subtle case is when one node is an\nancestor of another.",
    "start": "1404400",
    "end": "1410140"
  },
  {
    "text": "So let's do that,\n1 here and 3 there. I think here you do need to\nbe leftmost or rightmost,",
    "start": "1410140",
    "end": "1417390"
  },
  {
    "text": "consistently. So I take the 1 and\nI take the second 3.",
    "start": "1417390",
    "end": "1423330"
  },
  {
    "text": "OK. I take the RMQ of that, I get 1\nwhich is the higher of the two.",
    "start": "1423330",
    "end": "1428820"
  },
  {
    "text": "OK. So it seems to work. Actually, I think it would work\nno matter which guy you pick. I just picked the first one.",
    "start": "1428820",
    "end": "1436390"
  },
  {
    "text": "OK, no big deal. You're not going to see why\nthis is useful for a little bit until step 4 or something,\nbut we've slightly",
    "start": "1436390",
    "end": "1445080"
  },
  {
    "text": "simplified our problem to\nthis plus or minus 1 RMQ. Otherwise identical to\nthis in-order traversal.",
    "start": "1445080",
    "end": "1451299"
  },
  {
    "text": "So not a big deal, but\nwe'll need it later. ",
    "start": "1451300",
    "end": "1456690"
  },
  {
    "text": "OK. ",
    "start": "1456691",
    "end": "1474476"
  },
  {
    "text": "That was a reduction. Next, we're finally going\nto actually solve something. I'm going to do constant\ntime, n log n space, RMQ.",
    "start": "1474476",
    "end": "1487920"
  },
  {
    "text": "This data structure will not\nrequire plus or minus 1 RMQ. It works for any RMQ. It's actually a\nvery simple idea,",
    "start": "1487920",
    "end": "1494560"
  },
  {
    "text": "and it's almost what we need. But we're going to have to\nget rid of this log factor. That will be step 3.",
    "start": "1494560",
    "end": "1500050"
  },
  {
    "text": "OK, so here's the idea. You've got an array. And now someone gives\nyou an arbitrary interval",
    "start": "1500050",
    "end": "1506670"
  },
  {
    "text": "from here to here.  Ideally, I just store the mins\nfor every possible interval,",
    "start": "1506670",
    "end": "1514290"
  },
  {
    "text": "but there's n squared intervals. So instead, what I'm going\nto do is store the answer",
    "start": "1514290",
    "end": "1520830"
  },
  {
    "text": "not for all the intervals, but\nfor all intervals of length of power of 2.",
    "start": "1520830",
    "end": "1527286"
  },
  {
    "text": "It's a trick you've\nprobably seen before. ",
    "start": "1527286",
    "end": "1532500"
  },
  {
    "text": "This is the easy thing to do. And then the\ninteresting thing is how you make it actually\nget down to linear space.",
    "start": "1532500",
    "end": "1537920"
  },
  {
    "text": " Length, power of 2.",
    "start": "1537920",
    "end": "1544259"
  },
  {
    "text": " OK. There are only log n\npossible powers of 2.",
    "start": "1544260",
    "end": "1550230"
  },
  {
    "text": "There's still n different start\npoints for those intervals, so total number of\nintervals is n log n.",
    "start": "1550230",
    "end": "1555720"
  },
  {
    "text": "So this is n log n space,\nbecause I'm storing an index for each of them. ",
    "start": "1555720",
    "end": "1562519"
  },
  {
    "text": "OK. And then if I have an\narbitrary query, the point is-- let's call it length k--",
    "start": "1562520",
    "end": "1570280"
  },
  {
    "text": "then I can cover\nit by two intervals of length a power of 2.",
    "start": "1570280",
    "end": "1576790"
  },
  {
    "text": "They will be the same length. They will be length\n2 to the floor",
    "start": "1576790",
    "end": "1581980"
  },
  {
    "text": "of log k, the next smaller\npower of 2 below k. Maybe k is a power\nof 2, in which case,",
    "start": "1581980",
    "end": "1587800"
  },
  {
    "text": "it's just one interval\nor two equal intervals. But in general, you just take\nthe next smaller power of 2.",
    "start": "1587800",
    "end": "1593500"
  },
  {
    "text": "That will cover more than half\nof the thing, of the interval. And so you have one\nthat's left aligned,",
    "start": "1593500",
    "end": "1599479"
  },
  {
    "text": "one that's right aligned. Together, those will\ncover everything. And because the min operation\nhas this nifty feature",
    "start": "1599479",
    "end": "1605679"
  },
  {
    "text": "that you can take the min of\nall these, min of all these, take the min of the 2. You will get the min overall.",
    "start": "1605680",
    "end": "1611530"
  },
  {
    "text": "It doesn't hurt to\nhave duplicate entries. That's kind of an\nimportant property of min.",
    "start": "1611530",
    "end": "1618513"
  },
  {
    "text": "It holds for other\nproperties too, like max, but not everything. Then boom, we've solved RMQ.",
    "start": "1618514",
    "end": "1625018"
  },
  {
    "text": "I think it's clear. You do two queries, take\nthe min of the two-- actually, you have to\nrestore the arg mins.",
    "start": "1625019",
    "end": "1630305"
  },
  {
    "text": "So it's a little more\nwork, but constant time. Cool.",
    "start": "1630305",
    "end": "1635420"
  },
  {
    "text": "That was easy. ",
    "start": "1635420",
    "end": "1642070"
  },
  {
    "text": "Leave LCA up there. ",
    "start": "1642070",
    "end": "1650179"
  },
  {
    "text": "OK. So we're almost there, right. Just a log factor off. So what technique do we have\nfor shaving log factors?",
    "start": "1650180",
    "end": "1658230"
  },
  {
    "text": " Indirection, yeah, our\ngood friend indirection.",
    "start": "1658230",
    "end": "1664607"
  },
  {
    "text": " Indirection comes to\nour rescue yet again,",
    "start": "1664607",
    "end": "1670140"
  },
  {
    "text": "but we won't be done. The idea is, well, want\nto remove a log factor. Before we removed log\nfactors from time,",
    "start": "1670140",
    "end": "1676849"
  },
  {
    "text": "but there's no real\ntime here, right. Everything's constant time. But we can use indirection to\nshave a log factor in space,",
    "start": "1676849",
    "end": "1682770"
  },
  {
    "text": "too. Let's just divide. So this is again for RMQ.",
    "start": "1682770",
    "end": "1691980"
  },
  {
    "text": "So I have an array, I'm going\nto divide the array into groups",
    "start": "1691980",
    "end": "1698010"
  },
  {
    "text": "of size, I believe\n1/2 log n would",
    "start": "1698010",
    "end": "1703130"
  },
  {
    "text": "be the right magic number. It's going to be theta log n,\nbut I need a specific constant for step 4.",
    "start": "1703130",
    "end": "1708390"
  },
  {
    "text": " So what does that mean?",
    "start": "1708390",
    "end": "1713610"
  },
  {
    "text": "I have the first 1/2 log\nn entries in the array. Then I have the next\n1/2 log entries,",
    "start": "1713610",
    "end": "1721529"
  },
  {
    "text": "and then I have the\nlast 1/2 log n entries.",
    "start": "1721530",
    "end": "1727200"
  },
  {
    "text": "OK, that's easy enough. But now I'd like to tie all\nthese structures together.",
    "start": "1727200",
    "end": "1733210"
  },
  {
    "text": "A natural way to do that is with\na big structure on top of size,",
    "start": "1733210",
    "end": "1738419"
  },
  {
    "text": "n over log n, I guess\nwith a factor 2 out here.",
    "start": "1738420",
    "end": "1743670"
  },
  {
    "text": "n over 1/2 log n. How do I do that? Well, this is an RMQ problem,\nso the natural thing to do",
    "start": "1743670",
    "end": "1750840"
  },
  {
    "text": "is just take the min\nof everything here. So the red here is going\nto denote taking the min,",
    "start": "1750840",
    "end": "1756480"
  },
  {
    "text": "and take that-- the one\nitem that results by taking the min in that group, and\npromoting it to the next level.",
    "start": "1756480",
    "end": "1762520"
  },
  {
    "text": "This is a static thing\nwe do ahead of time. Now if I'm given\na query, like say,",
    "start": "1762520",
    "end": "1768120"
  },
  {
    "text": "this interval, what\nI need to do is first compute the min in this range\nwithin a bottom structure.",
    "start": "1768120",
    "end": "1777300"
  },
  {
    "text": "Maybe also compute the\nmin within this range, the last bottom structure,\nand then these guys are all taken in entirety.",
    "start": "1777300",
    "end": "1782820"
  },
  {
    "text": "So I can just take the\ncorresponding interval up here and that will give me\nsimultaneously the mins",
    "start": "1782820",
    "end": "1788370"
  },
  {
    "text": "of everything below. So now a query is going to be\nthe min of two bottoms and one",
    "start": "1788370",
    "end": "1801840"
  },
  {
    "text": "top. In other words, I do one\ntop RMQ query for everything between, strictly\nbetween the two ends.",
    "start": "1801840",
    "end": "1809760"
  },
  {
    "text": "Then I do a bottom query for\nthe one end, a bottom query for the other end. Take the min of all those\nvalues and really, it's",
    "start": "1809760",
    "end": "1815730"
  },
  {
    "text": "the arg min, but. Clear? So it would be\nconstant time if I can do bottom in\nconstant time, if I",
    "start": "1815730",
    "end": "1822030"
  },
  {
    "text": "can do top in constant time. But the big win is that\nthis top structure only has to store n over log n items.",
    "start": "1822030",
    "end": "1829050"
  },
  {
    "text": "So I can afford an n log\nn space data structure, because the logs cancel.",
    "start": "1829050",
    "end": "1834929"
  },
  {
    "text": "So I'm going to use\nstructure 2 for the top. That will give me constant\ntime up here, linear space.",
    "start": "1834930",
    "end": "1842440"
  },
  {
    "text": "So all that's left is to solve\nthe bottoms individually. Again, similar kind of\nstructure to [INAUDIBLE]..",
    "start": "1842440",
    "end": "1848309"
  },
  {
    "text": "We have a summary structure and\nwe have the details down below. But the parameters\nare way out of whack. It's no longer root n, root n.",
    "start": "1848310",
    "end": "1854506"
  },
  {
    "text": "Now these guys are super\ntiny because we only needed this to be a\nlittle bit smaller than n, and then this would work\nout to linear space.",
    "start": "1854506",
    "end": "1863010"
  },
  {
    "text": "OK. So step 4 is going to be how do\nwe solve the bottom structures.",
    "start": "1863010",
    "end": "1868175"
  },
  {
    "start": "1868176",
    "end": "1880326"
  },
  {
    "text": "So step 4. This is where we're going to\nuse technique of lookup tables",
    "start": "1880326",
    "end": "1893830"
  },
  {
    "text": "for bottom groups.  This is going to be\nslightly weird to phrase,",
    "start": "1893830",
    "end": "1899840"
  },
  {
    "text": "because on the one hand,\nI want to be thinking about an individual group,\nbut my solution is actually going to solve all\ngroups simultaneously,",
    "start": "1899840",
    "end": "1906260"
  },
  {
    "text": "and it's kind of important. But for now, let's just\nthink of one group.",
    "start": "1906260",
    "end": "1911990"
  },
  {
    "text": "So it has size n prime\nand n prime is 1/2 log n.",
    "start": "1911990",
    "end": "1918065"
  },
  {
    "text": "I need to remember\nhow it relates to the original value of n so\nI know how to pay for things. The idea is there's really\nnot many different problems",
    "start": "1918065",
    "end": "1926630"
  },
  {
    "text": "of size 1/2 log n. And here's where we're going\nto use the fact that we're in plus or minus 1 land.",
    "start": "1926630",
    "end": "1934110"
  },
  {
    "text": "We have this giant\nstring of integers. Well, now we're looking\nat log n of them",
    "start": "1934110",
    "end": "1939720"
  },
  {
    "text": "to say OK, this here, this\nis a sequence 0, 1, 2, 3.",
    "start": "1939720",
    "end": "1945590"
  },
  {
    "text": "Over here a 0, 1, 2, 1. There's all these\ndifferent things. Then there's other\nthings like 2, 3, 2, 3.",
    "start": "1945590",
    "end": "1951815"
  },
  {
    "text": " So there's a couple\nannoying things.",
    "start": "1951815",
    "end": "1957000"
  },
  {
    "text": "One is it matters what\nvalue you start at, a b, and then it matters what the\nsequence of plus and minus 1s",
    "start": "1957000",
    "end": "1963260"
  },
  {
    "text": "are after that. OK. I claim it doesn't really\nmatter what value you start at,",
    "start": "1963260",
    "end": "1969710"
  },
  {
    "text": "because RMQ, this query,\nis invariant under adding",
    "start": "1969710",
    "end": "1984110"
  },
  {
    "text": "some value x to all entries,\nall values, in the array.",
    "start": "1984110",
    "end": "1990720"
  },
  {
    "text": "Or if I add 100 to every\nvalue, then the minimums stay the same in position. So again, here I'm thinking\nof RMQ as an arg min.",
    "start": "1990720",
    "end": "1998220"
  },
  {
    "text": "So it's giving just the\nindex of where it lives. So in particular, I'm going\nto add minus the first value",
    "start": "1998220",
    "end": "2007030"
  },
  {
    "text": "of the array to all values. ",
    "start": "2007030",
    "end": "2013210"
  },
  {
    "text": "I should probably call this-- well, yeah. Here I'm just thinking about\na single group for now.",
    "start": "2013210",
    "end": "2019580"
  },
  {
    "text": "So in a single group, saying\nwell, it starts at some value. I'm just going to\ndecrease all these things",
    "start": "2019580",
    "end": "2024759"
  },
  {
    "text": "by whatever that value is. Now some of them\nmight become negative, but at least now\nwe start with a 0.",
    "start": "2024760",
    "end": "2030730"
  },
  {
    "text": "So what we start\nwith is irrelevant. What remains, the remaining\nnumbers here are completely",
    "start": "2030730",
    "end": "2038020"
  },
  {
    "text": "defined by the gaps\nbetween or the difs between consecutive\nitems, and the difs",
    "start": "2038020",
    "end": "2044320"
  },
  {
    "text": "are all plus or minus 1. So now the number of possible\narrays in a group, so",
    "start": "2044320",
    "end": "2059469"
  },
  {
    "text": "in a single group, is\nequal to the number of plus or minus 1 strings\nof length n prime, which is",
    "start": "2059469",
    "end": "2072070"
  },
  {
    "text": "1/2 log n. ",
    "start": "2072070",
    "end": "2077120"
  },
  {
    "text": "And the number of plus or\nminus 1 strings of length n prime is 2 to the n prime.",
    "start": "2077120",
    "end": "2082669"
  },
  {
    "text": "So we get 2 to the 1/2 log n,\nalso known as square root of n.",
    "start": "2082670",
    "end": "2088149"
  },
  {
    "text": "Square root of n is small. We're aiming for linear space. This means that for every--",
    "start": "2088150",
    "end": "2093730"
  },
  {
    "text": "not only for every group,\nthere is n over log n groups-- but actually many of the\ngroups have to be the same.",
    "start": "2093730",
    "end": "2099140"
  },
  {
    "text": "There's n over log n groups,\nbut there's only root n different types of groups.",
    "start": "2099140",
    "end": "2104450"
  },
  {
    "text": "So on average, like root n\nover log n occurrences of each. So we can kind of compress\nthings down and say hey,",
    "start": "2104450",
    "end": "2112494"
  },
  {
    "text": "I would like to just\nlike store a lookup table for each one of these, but\nthat would be quadratic space. But there's really only square\nroot of n different types.",
    "start": "2112494",
    "end": "2119360"
  },
  {
    "text": "So if I use a layer of\nindirection, I guess-- different sort of\nindirection-- if I just have, for each of\nthese groups, I just",
    "start": "2119360",
    "end": "2126010"
  },
  {
    "text": "store a pointer to the\ntype of group, which is what the plus or\nminus 1 string is,",
    "start": "2126010",
    "end": "2131980"
  },
  {
    "text": "and then for that type,\nI store a lookup table of all possibilities. That will be efficient. Let me show that to you.",
    "start": "2131980",
    "end": "2141200"
  },
  {
    "text": "This is a very handy idea. In general, if you have a lot\nof things of size roughly log n,",
    "start": "2141200",
    "end": "2147960"
  },
  {
    "text": "lookup tables are a good idea. ",
    "start": "2147960",
    "end": "2154520"
  },
  {
    "text": "And this naturally arises\nwhen you're using indirection, because usually you just\nneed to shave a log or two.",
    "start": "2154520",
    "end": "2160340"
  },
  {
    "text": "So here we have these\ndifferent types. So what we're going to do\nis store a lookup table that",
    "start": "2160340",
    "end": "2173510"
  },
  {
    "text": "says for each group\ntype, I'll just say a lookup table\nof all answers,",
    "start": "2173510",
    "end": "2184130"
  },
  {
    "text": "do that for each group type. ",
    "start": "2184130",
    "end": "2191012"
  },
  {
    "text": "Group type, meaning the\nplus or minus 1 string. It's really what\nis in that group after you do this shifting.",
    "start": "2191012",
    "end": "2196830"
  },
  {
    "text": "OK. Now there's square\nroot of n group types.  What does it take to\nstore the answers?",
    "start": "2196831",
    "end": "2203390"
  },
  {
    "text": "Well, there is, I guess, 1/2\nlog n squared different queries,",
    "start": "2203390",
    "end": "2210680"
  },
  {
    "text": "because n prime is\n1/2 log n, and a query is defined by the two endpoints. So there's at most\nthis many queries.",
    "start": "2210680",
    "end": "2216650"
  },
  {
    "text": "Each query, to store the answer,\nis going to take order log log n bits-- this is\nif you're fancy--",
    "start": "2216650",
    "end": "2223910"
  },
  {
    "text": "because the answer is an index\ninto that array of size 1/2 log n, so you need log log n\nbits to write down that.",
    "start": "2223910",
    "end": "2230839"
  },
  {
    "text": "So the total size\nof this lookup table is the product of these things.",
    "start": "2230840",
    "end": "2236720"
  },
  {
    "text": "We have to write root\nn look up tables. Each stores log squared\nn different values,",
    "start": "2236720",
    "end": "2244790"
  },
  {
    "text": "and the values require\nlog log n bits. So total number of\nbits is this thing,",
    "start": "2244790",
    "end": "2251240"
  },
  {
    "text": "and this thing is little o of n. So smaller than linear,\nso it's irrelevant.",
    "start": "2251240",
    "end": "2257480"
  },
  {
    "text": "Can store for free. Now if we have a bottom group,\nthe one thing we need to do",
    "start": "2257480",
    "end": "2262700"
  },
  {
    "text": "is store a pointer\nfrom that bottom group to the corresponding section of\nthe lookup table for that group",
    "start": "2262700",
    "end": "2270380"
  },
  {
    "text": "type. So each group stores a\npointer into lookup table.",
    "start": "2270380",
    "end": "2285140"
  },
  {
    "text": " I'm of two minds whether I\nthink of this as a single lookup",
    "start": "2285140",
    "end": "2291050"
  },
  {
    "text": "table that's parameterized\nfirst by group type, and then by the query. So it's like a two-dimensional\ntable or three-dimensional,",
    "start": "2291050",
    "end": "2297860"
  },
  {
    "text": "depending how you count. Or you can think of there being\nseveral lookup tables, one for each group type,\nand then you're pointing to a\nsingle lookup table.",
    "start": "2297860",
    "end": "2303810"
  },
  {
    "text": "However, you want to think\nabout it, same thing. Same difference, as they say.",
    "start": "2303810",
    "end": "2309260"
  },
  {
    "text": "This gives us linear space. These pointers\ntake linear space. The top structure takes\nlinear space linear number",
    "start": "2309260",
    "end": "2314733"
  },
  {
    "text": "of words, and\nconstant query time, because lookup\ntables are very fast.",
    "start": "2314733",
    "end": "2320750"
  },
  {
    "text": "Just look into them. They give you the answer. So you can do a lookup table\nhere, lookup table here.",
    "start": "2320750",
    "end": "2326820"
  },
  {
    "text": "And then over here,\nyou do the covering by 2, powers of 2 intervals.",
    "start": "2326820",
    "end": "2332990"
  },
  {
    "text": "Again, we have a lookup\ntable for those intervals, so it's like we're\nlooking into four tables, take the min of them all, done.",
    "start": "2332990",
    "end": "2340609"
  },
  {
    "text": "That is RMQ, and also LCA. Actually it was really LCA that\nwe solved, because we solved",
    "start": "2340610",
    "end": "2347690"
  },
  {
    "text": "plus or minus 1\nRMQ, which solved LCA, but by the\nCartesian tree reduction,",
    "start": "2347690",
    "end": "2355910"
  },
  {
    "text": "that also solves RMQ.  Now we solved 2 out\nof 3 of our problems.",
    "start": "2355910",
    "end": "2362870"
  },
  {
    "text": "Any questions?  Level ancestors are going to\nbe harder, little bit harder.",
    "start": "2362870",
    "end": "2371490"
  },
  {
    "text": "Similar number of steps. I'd say they're a\nlittle more clever. This I feel is pretty easy.",
    "start": "2371490",
    "end": "2376830"
  },
  {
    "text": "Very simple style of\nindirection, very simple style of enumeration here. It's going to be a little more\nsophisticated and a little bit",
    "start": "2376830",
    "end": "2383520"
  },
  {
    "text": "more representative of\nthe general case for level ancestors.",
    "start": "2383520",
    "end": "2388760"
  },
  {
    "text": " Definitely fancier. ",
    "start": "2388760",
    "end": "2396619"
  },
  {
    "text": "Level ancestors is a similar\nstory we solved a while ago, but it was kind of a\ncomplicated solution.",
    "start": "2396620",
    "end": "2403170"
  },
  {
    "text": "And then Bender\nand Farach-Colton found it and said hey,\nwe can simplify this.",
    "start": "2403170",
    "end": "2408770"
  },
  {
    "text": "And I'm going to give you\nthe simplified version. So this is level ancestors.",
    "start": "2408770",
    "end": "2415640"
  },
  {
    "text": "Says originally solved\nby Berkman and Vishkin in 1994, OK, not so long ago.",
    "start": "2415640",
    "end": "2421010"
  },
  {
    "text": "And then the new\nversion is from 2004. Ready?",
    "start": "2421010",
    "end": "2426800"
  },
  {
    "text": "Level ancestors. What was the problem again? Here it is. I gave you a rooted\ntree, give you a node,",
    "start": "2426800",
    "end": "2434150"
  },
  {
    "text": "and a level that I want to go\nup, and then I level up by k,",
    "start": "2434150",
    "end": "2439619"
  },
  {
    "text": "so I go to the kth ancestor,\nor parent to the k.",
    "start": "2439620",
    "end": "2445470"
  },
  {
    "text": "This may seem\nsuperficially like LCA, but it's very different,\nbecause as you can see, RMQ was very specific to LCA.",
    "start": "2445470",
    "end": "2452540"
  },
  {
    "text": "It's not going to let you solve\nlevel ancestors in any sense. I don't think. Maybe you could try to do\nthe Cartesian tree reduction,",
    "start": "2452540",
    "end": "2459340"
  },
  {
    "text": "but solution we'll see\nis completely different, although similar in spirit.",
    "start": "2459340",
    "end": "2465860"
  },
  {
    "text": "So step 1. This one's going to\nbe a little bit less",
    "start": "2465860",
    "end": "2471230"
  },
  {
    "text": "obvious that we will succeed. Here we started with\nn log n space which is shaving a log, no big deal.",
    "start": "2471230",
    "end": "2477217"
  },
  {
    "text": "Here, I'm going to give\nyou a couple of strategies that aren't even constant time,\nthey're log time or worse.",
    "start": "2477217",
    "end": "2482690"
  },
  {
    "text": "And yet you combine them\nand you get constant time. It's crazy. ",
    "start": "2482690",
    "end": "2491490"
  },
  {
    "text": "Again, each of the\npieces is going to be pretty intuitive,\nnot super surprising,",
    "start": "2491490",
    "end": "2502274"
  },
  {
    "text": "but it's one of\nthese things where you take all these ingredients\nthat are all kind of obvious, you stare at them for a while\nlike, oh, I put them together",
    "start": "2502274",
    "end": "2509209"
  },
  {
    "text": "and it works. It's like magic. All right, so first goal is\ngoing to be n log n space,",
    "start": "2509209",
    "end": "2514820"
  },
  {
    "text": "log n query. So here's a way to do it with a\ntechnique called jump pointers. ",
    "start": "2514820",
    "end": "2527510"
  },
  {
    "text": "In this case, nodes are going to\nhave log n different pointers, and they're going\nto point to the 2",
    "start": "2527510",
    "end": "2532790"
  },
  {
    "text": "to the ith ancestor for all i. ",
    "start": "2532790",
    "end": "2540281"
  },
  {
    "text": "I guess maximum possible\ni would be log n. You can never go up more than n.",
    "start": "2540281",
    "end": "2546230"
  },
  {
    "text": "So I mean, ideally you'd have\na pointer to all your ancestors in array, boom. In the quadratic space,\nyou solve your problem",
    "start": "2546230",
    "end": "2552500"
  },
  {
    "text": "in constant time. But it's a little\nmore interesting. Now every node only has pointers\nto log n different places",
    "start": "2552500",
    "end": "2559430"
  },
  {
    "text": "so it's looking like this. This is the ancestor path.",
    "start": "2559430",
    "end": "2567950"
  },
  {
    "text": "So n log n space, and\nI claim with this, you can roughly do a binary\nsearch, if you wanted to.",
    "start": "2567950",
    "end": "2574410"
  },
  {
    "text": "Now we're not actually going\nto use this query algorithm for anything, but I'll\nwrite it down just",
    "start": "2574410",
    "end": "2579930"
  },
  {
    "text": "so it feels like we've\naccomplished something, mainly log n query time. So what do I do?",
    "start": "2579930",
    "end": "2587390"
  },
  {
    "text": "I set x to be the 2 to the\nfloor log kth ancestor of x.",
    "start": "2587390",
    "end": "2595099"
  },
  {
    "text": " OK, remember we're given\na node x and a value",
    "start": "2595100",
    "end": "2604760"
  },
  {
    "text": "k that we want to rise by. So I take the power\nof 2 just below k-- that's 2 the floor log k.",
    "start": "2604760",
    "end": "2611150"
  },
  {
    "text": "I go up that much,\nand that's my new x, and then I set k to\nbe k minus that value.",
    "start": "2611150",
    "end": "2618560"
  },
  {
    "text": "That's how much I\nhave left to go. OK. This thing will be\nless than k over 2.",
    "start": "2618560",
    "end": "2625430"
  },
  {
    "text": "Because the next previous\npower of 2 is at least, is bigger than\nhalf of the thing.",
    "start": "2625430",
    "end": "2630710"
  },
  {
    "text": "So we got more\nthan halfway there, and so after log n iterations,\nwe'll actually get there.",
    "start": "2630710",
    "end": "2635950"
  },
  {
    "text": "That's pretty easy. That's jump pointers to two\nlogs that we need to get rid of,",
    "start": "2635950",
    "end": "2644120"
  },
  {
    "text": "and yes, we will use\nindirection, but not yet. ",
    "start": "2644120",
    "end": "2654590"
  },
  {
    "text": "First, we need some\nmore ingredients. ",
    "start": "2654590",
    "end": "2661270"
  },
  {
    "text": "This next ingredient\nis kind of funny, because it will seem useless. But in fact, it is useful as\na step towards ingredient 3.",
    "start": "2661270",
    "end": "2670000"
  },
  {
    "text": "So the next trick is called\nlong path decomposition. ",
    "start": "2670000",
    "end": "2680170"
  },
  {
    "text": "In general, this class covers\na lot of different treaty compositions. We did preferred path\ndecomposition for tango trees.",
    "start": "2680170",
    "end": "2689160"
  },
  {
    "text": "We're going to do long path now. We'll do another one\ncalled heavy path later. There's a lot of them out there.",
    "start": "2689160",
    "end": "2694270"
  },
  {
    "text": "This one won't seem\nvery useful at first, because while it will\nachieve linear space,",
    "start": "2694270",
    "end": "2700420"
  },
  {
    "text": "it will achieve the amazing\nsquare root of n query, which I guess is new.",
    "start": "2700420",
    "end": "2706270"
  },
  {
    "text": "I mean, we don't know how to\ndo that yet with linear space. Not so obvious\nhow to get root n.",
    "start": "2706270",
    "end": "2712240"
  },
  {
    "text": "But anyway, don't worry\nabout the query time. It's more the concept of\nlong path that's interesting.",
    "start": "2712240",
    "end": "2718960"
  },
  {
    "text": "It's a step in the\nright direction. So here's what here's how we're\ngoing to decompose a tree. First thing we do is find the\nlongest route to leaf path",
    "start": "2718960",
    "end": "2730570"
  },
  {
    "text": "in the tree, because\nif you look at a tree,",
    "start": "2730570",
    "end": "2736940"
  },
  {
    "text": "it has some wavy bottom. Take the deepest node. Take the path the unique path\nfrom the root to that node.",
    "start": "2736940",
    "end": "2744869"
  },
  {
    "text": "OK. When I do that, I could\nimagine deleting those nodes. I mean, there's\nthat path, and then",
    "start": "2744870",
    "end": "2751180"
  },
  {
    "text": "there's everything\nelse, which means there's all these triangles\nhanging off of that path, some",
    "start": "2751180",
    "end": "2756730"
  },
  {
    "text": "on the left, some on the right. Actually, I haven't\ntalked about this,",
    "start": "2756730",
    "end": "2764440"
  },
  {
    "text": "but both LCA and level ancestors\nwork not just for binary trees.",
    "start": "2764440",
    "end": "2770619"
  },
  {
    "text": "They work for arbitrary trees. And somewhere along here--",
    "start": "2770620",
    "end": "2775660"
  },
  {
    "text": "yeah, here. This reduction of\nusing the Euler tour works for non-binary trees, too.",
    "start": "2775660",
    "end": "2782464"
  },
  {
    "text": "That's actually\nanother reason why this reduction is better than\nin-order traversal by itself. In-order traversal works\nonly for binary trees.",
    "start": "2782464",
    "end": "2790630"
  },
  {
    "text": "This thing works for any tree. In that case, in\nan arbitrary tree, you visit the node many,\nmany times potentially.",
    "start": "2790630",
    "end": "2796299"
  },
  {
    "text": "OK, but it will\nstill be linear space and everything will still work. Here also, I want to\nhandle non-binary trees.",
    "start": "2796300",
    "end": "2802210"
  },
  {
    "text": "So I'm going to draw\nthings hanging off, but in fact, there might be\nseveral things hanging off here, each their\nown little tree.",
    "start": "2802210",
    "end": "2809200"
  },
  {
    "text": "OK, but the point is-- where's my red. ",
    "start": "2809200",
    "end": "2814690"
  },
  {
    "text": "Here. There was this one path in the\nbeginning, the longest path,",
    "start": "2814690",
    "end": "2819850"
  },
  {
    "text": "and then there's stuff\nhanging off of it. So just recurse on all the\nthings hanging off of it.",
    "start": "2819850",
    "end": "2825760"
  },
  {
    "text": "Recursively decompose\nthose sub-trees. ",
    "start": "2825760",
    "end": "2848032"
  },
  {
    "text": "OK. Not clear what this\nis going to give you. In fact, it's not\ngoing to be so awesome, but it will be a starting point.",
    "start": "2848032",
    "end": "2855140"
  },
  {
    "text": "Now you can answer a query\nwith this, as follows.",
    "start": "2855140",
    "end": "2860440"
  },
  {
    "text": "Query-- oh, sorry. I should say how we're\nactually storing these paths.",
    "start": "2860440",
    "end": "2866339"
  },
  {
    "text": "Here's the cool idea\nwith this path thing. I have this path.",
    "start": "2866340",
    "end": "2872130"
  },
  {
    "text": "I'd like to be able to\njump around at least-- suppose your tree was a path. Suppose your tree were a path.",
    "start": "2872130",
    "end": "2878160"
  },
  {
    "text": "Then what would you want to do? Store the nodes in an\narray ordered by depth,",
    "start": "2878160",
    "end": "2883482"
  },
  {
    "text": "because then if\nyou're a position i and you need to go to\nposition i minus k, boom. That's just a look\nup into your array.",
    "start": "2883482",
    "end": "2889990"
  },
  {
    "text": "So I'm going to store\neach path as an array,",
    "start": "2889990",
    "end": "2897610"
  },
  {
    "text": "as an array of nodes or\nnode pointers, I guess,",
    "start": "2897610",
    "end": "2907770"
  },
  {
    "text": "ordered by depth. So if it happens, so if my query\nvalue x is somewhere on this",
    "start": "2907770",
    "end": "2915420"
  },
  {
    "text": "path, and if this path\nencompasses where I need",
    "start": "2915420",
    "end": "2920430"
  },
  {
    "text": "to go-- so if I need to go\nk up and I end up here-- then that's instantaneous.",
    "start": "2920430",
    "end": "2925890"
  },
  {
    "text": "The trouble would be\nis if I have a query, let's say, over here. And so there's going to be\na path that guy lives on,",
    "start": "2925890",
    "end": "2935190"
  },
  {
    "text": "but maybe the kth ancestor\nis not on that path. It could be on a higher up path. It could be on the\nred path, and I can't",
    "start": "2935190",
    "end": "2941460"
  },
  {
    "text": "jump there instantaneously. Nonetheless, there is a\ndecent query algorithm here.",
    "start": "2941460",
    "end": "2947170"
  },
  {
    "text": "All right.  So Here's what\nwe're going to do.",
    "start": "2947170",
    "end": "2957900"
  },
  {
    "text": "If k is less than or equal\nto the index i of node",
    "start": "2957900",
    "end": "2969970"
  },
  {
    "text": "x on its path. ",
    "start": "2969970",
    "end": "2977580"
  },
  {
    "text": "So every node belongs\nto exactly one path. This is a path decomposition. It's a partition of\nthe tree into paths.",
    "start": "2977580",
    "end": "2984954"
  },
  {
    "text": "Not all the edges\nare represented, but all the nodes are there. All the nodes\nbelong to some path,",
    "start": "2984954",
    "end": "2993020"
  },
  {
    "text": "and we're going to store,\nfor every node, store what its index is and where\nit lives in its array.",
    "start": "2993020",
    "end": "2999780"
  },
  {
    "text": "So look at that\nindex in the array. If k is less than or\nequal to that index,",
    "start": "2999780",
    "end": "3005330"
  },
  {
    "text": "then we can solve\nour problem instantly by looking at the path\narray at position i minus k.",
    "start": "3005330",
    "end": "3015590"
  },
  {
    "text": "That's what I said before. If our kth ancestor\nis within the path, then that's where it\nwill be, and that's",
    "start": "3015590",
    "end": "3022190"
  },
  {
    "text": "going to work as long\nas that is non-negative. If I get to negative, that\nmeans it's another path.",
    "start": "3022190",
    "end": "3028380"
  },
  {
    "text": "So that's the good case. The other case is\nwe're just going to do",
    "start": "3028380",
    "end": "3034970"
  },
  {
    "text": "some recursion, essentially. ",
    "start": "3034970",
    "end": "3041100"
  },
  {
    "text": "So we're going to go as high\nas we can with this path. We're going to look at\npath array at position 0.",
    "start": "3041100",
    "end": "3047420"
  },
  {
    "text": "Go to the parent of that. Let's suppose every node\nhas a parent pointer. That's easy, regular tree, and\nthen decrease k by 1 plus i.",
    "start": "3047420",
    "end": "3059940"
  },
  {
    "text": "So the array let us\njump up i steps-- that's this part--\nand then the parent",
    "start": "3059940",
    "end": "3066130"
  },
  {
    "text": "stepped us up one more step. That's just to get to\nthe next path above us. OK, so how much did\nthis decrease k by?",
    "start": "3066130",
    "end": "3073299"
  },
  {
    "text": "I'd like to say a factor of\n2 and get log n, but in fact, no, it's not very good.",
    "start": "3073300",
    "end": "3078842"
  },
  {
    "text": "It doesn't decrease\nk by very much. It does decrease k,\nguaranteed by at least 1, so it's definitely linear time.",
    "start": "3078842",
    "end": "3085700"
  },
  {
    "text": "And there's a bad\ntree, which is this. ",
    "start": "3085700",
    "end": "3095100"
  },
  {
    "text": "It's like a grid. Whoa. Sorry. ",
    "start": "3095100",
    "end": "3101104"
  },
  {
    "text": "OK, here's a tree. It's a binary tree. And if you set it up right,\nthis is the longest path.",
    "start": "3101104",
    "end": "3107091"
  },
  {
    "text": "And then when you decompose,\nthis is the longest path, and this is the longest path,\nthis is the longest path. If you query here,\nyou'll walk up to here,",
    "start": "3107091",
    "end": "3113544"
  },
  {
    "text": "and then walk up to here,\nand walk up to here, and walk up to here. So this is a square root of n\nlower bound for this algorithm.",
    "start": "3113544",
    "end": "3120510"
  },
  {
    "text": "So not a good algorithm\nyet, but the makings of a good algorithm. ",
    "start": "3120510",
    "end": "3139569"
  },
  {
    "text": "Makings of step 3, which is\ncalled ladder decomposition.",
    "start": "3139570",
    "end": "3145826"
  },
  {
    "start": "3145826",
    "end": "3152587"
  },
  {
    "text": "Ladder decomposition is\nsomething I haven't really seen anywhere else. I think it comes from\nthe parallel algorithms",
    "start": "3152587",
    "end": "3158390"
  },
  {
    "text": "world in general. ",
    "start": "3158390",
    "end": "3163830"
  },
  {
    "text": "And now we're going to achieve\nlinear space log n query.",
    "start": "3163830",
    "end": "3173760"
  },
  {
    "text": "Now this is an improvement. So we have, at the\nmoment, n log n space, log n query or n\nspace root n query.",
    "start": "3173760",
    "end": "3182105"
  },
  {
    "text": "We're basically taking\nthe min of the two. And so we're getting\nlinear space log n query.",
    "start": "3182105",
    "end": "3188990"
  },
  {
    "text": "Still not perfect. We want constant query. That's when we'll use\nindirection, I think.",
    "start": "3188990",
    "end": "3195140"
  },
  {
    "text": "Yeah, basically, a new type\nof indirection, but OK. So linear space log n query.",
    "start": "3195140",
    "end": "3202950"
  },
  {
    "text": "Well, the idea is just\nto fix long paths,",
    "start": "3202950",
    "end": "3208040"
  },
  {
    "text": "and it's a crazy idea, OK. Let me tell you the\nidea and then it's like, why would that be useful.",
    "start": "3208040",
    "end": "3214310"
  },
  {
    "text": "But it's obvious that\nit doesn't hurt you, OK. When we have these paths,\nsometimes they're long.",
    "start": "3214310",
    "end": "3220970"
  },
  {
    "text": "Sometimes they're\nnot long enough. Just take each of\nthese paths and extend them upwards by a factor of 2.",
    "start": "3220970",
    "end": "3228900"
  },
  {
    "text": "That's the idea. So take number 2, extend\neach path upward 2 x.",
    "start": "3228900",
    "end": "3240430"
  },
  {
    "text": "So that gives us call a ladder. ",
    "start": "3240430",
    "end": "3246270"
  },
  {
    "text": "OK, what happens? Well, paths are\ngoing to overlap. Fine.",
    "start": "3246270",
    "end": "3253000"
  },
  {
    "text": "Ladders overlap. The original paths\ndon't overlap. Ladders overlap. I don't really care\nif they overlap.",
    "start": "3253000",
    "end": "3258580"
  },
  {
    "text": "How much space is there? It's still linear space, because\nI'm just doubling everything. So I've most doubled space\nrelative to long path",
    "start": "3258580",
    "end": "3267027"
  },
  {
    "text": "decomposition. I didn't mention it explicitly,\nbut long path decomposition is linear space. We're just partitioning up\nthe tree into little pieces.",
    "start": "3267027",
    "end": "3274630"
  },
  {
    "text": "Doesn't take much. We have to store those\narrays, but every node appears in exactly\none cell here.",
    "start": "3274630",
    "end": "3280990"
  },
  {
    "text": "Now every node will\nappear in, on average, two cells in some weird way. Like what happens over here?",
    "start": "3280990",
    "end": "3286570"
  },
  {
    "text": "I have no idea. So this guy's length 1. It's going to grow to length 2.",
    "start": "3286570",
    "end": "3292060"
  },
  {
    "text": "This one's length 2, so\nnow it'll grow to length 4. This one's length 3-- and it depends on how you count.",
    "start": "3292060",
    "end": "3297958"
  },
  {
    "text": "I'm counting nodes here. That's going to go here,\nall the way the top.",
    "start": "3297958",
    "end": "3303010"
  },
  {
    "text": "Interesting. All the others\nwill go to the top. So if I'm here, I walk here.",
    "start": "3303010",
    "end": "3308945"
  },
  {
    "text": "Then I can jump all\nthe way to the top. Then I can jump all\nthe way to the root. Not totally obvious, but it\nactually will be log n steps.",
    "start": "3308945",
    "end": "3317000"
  },
  {
    "text": "Let's prove that. This is again something\nwe don't really need to know for\nthe final solution, but kind of nice, kind of\ncomforting to know that we've",
    "start": "3317000",
    "end": "3325060"
  },
  {
    "text": "gotten down a log n query. So it's at most\ndouble the space. This is still linear.",
    "start": "3325060",
    "end": "3330590"
  },
  {
    "text": " Now-- oh, there's one catch.",
    "start": "3330590",
    "end": "3337165"
  },
  {
    "text": " Over in this world,\nwe said each--",
    "start": "3337165",
    "end": "3345660"
  },
  {
    "text": "I didn't say it. I mentioned it out loud. Every node stores what\narray it lives in.",
    "start": "3345660",
    "end": "3352330"
  },
  {
    "text": "Now a node lives in\nmultiple arrays, OK. So which one do I\nstore a pointer to?",
    "start": "3352330",
    "end": "3358359"
  },
  {
    "text": "Well, there's one obvious\none to store a pointer to. Whatever node you take\nlives in one path.",
    "start": "3358360",
    "end": "3365380"
  },
  {
    "text": "In that long path decomposition,\nit still lives in one path. Store a pointer\ninto that ladder.",
    "start": "3365380",
    "end": "3371660"
  },
  {
    "text": "So node stores a pointer you\ncould say to the ladder that",
    "start": "3371660",
    "end": "3380559"
  },
  {
    "text": "contains it in the lower half. ",
    "start": "3380560",
    "end": "3387550"
  },
  {
    "text": "That corresponds to the one\nwhere it was an actual path. And only one ladder will contain\na node in its lower half.",
    "start": "3387550",
    "end": "3395260"
  },
  {
    "text": "The upper half\nwas the extension. I guess it's like those\nfolding ladders you extend.",
    "start": "3395260",
    "end": "3400560"
  },
  {
    "text": "OK. Cool. So that's what we're\ngoing to do and also store its index in the array.",
    "start": "3400560",
    "end": "3407210"
  },
  {
    "text": "Now we can do exactly this\nquery algorithm again, except now instead of\npath, it says ladder.",
    "start": "3407210",
    "end": "3412570"
  },
  {
    "text": "So you look at the index\nof the node in its ladder. If that index is\nlarger than k, then",
    "start": "3412570",
    "end": "3418900"
  },
  {
    "text": "boom, that ladder array will\ntell you exactly where to go. Otherwise you go to\nthe top of the ladder",
    "start": "3418900",
    "end": "3424480"
  },
  {
    "text": "and then you take\nthe parent pointer, and you decrease by this. But now I claim that\ndecrease will be substantial.",
    "start": "3424480",
    "end": "3431116"
  },
  {
    "text": "Why? ",
    "start": "3431116",
    "end": "3440470"
  },
  {
    "text": "If I have a node of height h-- ",
    "start": "3440470",
    "end": "3445569"
  },
  {
    "text": "remember, height of a node\nis the length of the longest path from there downward-- ",
    "start": "3445570",
    "end": "3452300"
  },
  {
    "text": "it will be on a ladder\nof height at least 2h.",
    "start": "3452300",
    "end": "3464301"
  },
  {
    "text": "Why? Because if you look at\na node of height h-- like say, I don't\nknow, this node-- ",
    "start": "3464301",
    "end": "3471220"
  },
  {
    "text": "the longest path from\nthere is substantial. I mean, if it's height h, then\nthe longest path from there",
    "start": "3471220",
    "end": "3476380"
  },
  {
    "text": "is length at least h. So every node of height h will\nbe on a path of length at least h, and from there down.",
    "start": "3476380",
    "end": "3484010"
  },
  {
    "text": "And so you look at the ladder. Well, that's going\nto be double that. So the ladder will be\nheight at least 2h,",
    "start": "3484010",
    "end": "3489670"
  },
  {
    "text": "which means if your\nquery starts at height h, after you do one step\nof this ladder search,",
    "start": "3489670",
    "end": "3496480"
  },
  {
    "text": "you will get to height at least\n2h, and then 4h, and then 8h. You're increasing your height by\na power of 2, by a factor of 2",
    "start": "3496480",
    "end": "3503020"
  },
  {
    "text": "every time. So in log n steps, you will\nget to wherever you need to go.",
    "start": "3503020",
    "end": "3509000"
  },
  {
    "text": "OK You don't have to\nworry about overshooting, because that's the case\nwhen the array tells you exactly where to go.",
    "start": "3509000",
    "end": "3515800"
  },
  {
    "text": "OK.  Time for the climax.",
    "start": "3515800",
    "end": "3522079"
  },
  {
    "text": "It won't be the end,\nbut it's the climax in the middle of the story. So we have on the one\nhand, jump pointers.",
    "start": "3522080",
    "end": "3527900"
  },
  {
    "text": "Remember those? Jump pointers made small\nsteps initially and got--",
    "start": "3527900",
    "end": "3535170"
  },
  {
    "text": "actually, no. This is what it looks like\nfor the data structure. But if you look\nat the algorithm,",
    "start": "3535170",
    "end": "3540440"
  },
  {
    "text": "actually it makes a big\nstep in the beginning. Right? It gets more than halfway there. Then it makes smaller\nand smaller steps,",
    "start": "3540440",
    "end": "3546410"
  },
  {
    "text": "exponentially decreasing steps. Finally, it arrives\nat the intended node.",
    "start": "3546410",
    "end": "3552990"
  },
  {
    "text": "Ladder decomposition\nis doing the reverse. If you start at\nlow height, you're going to make very small\nsteps in the beginning.",
    "start": "3552990",
    "end": "3559490"
  },
  {
    "text": "As your height\ngets bigger, you're going to be making\nbigger and bigger steps. And then when you jump over your\nnode, you found it instantly.",
    "start": "3559490",
    "end": "3565880"
  },
  {
    "text": "So it's kind of the\nopposite of jump pointers. So what we're going to\ndo is take jump pointers",
    "start": "3565880",
    "end": "3572630"
  },
  {
    "text": "and add them to\nladder decomposition. ",
    "start": "3572630",
    "end": "3592096"
  },
  {
    "text": "Huh. This is, I guess, version 4. Combine jump pointers from\none and ladders from three.",
    "start": "3592096",
    "end": "3608700"
  },
  {
    "text": "Forget about two. Two is just a warm up for three. Long paths, defined ladders.",
    "start": "3608700",
    "end": "3615210"
  },
  {
    "text": "So we've got one way\nto do log n query. We've got another way\nto do log n query.",
    "start": "3615210",
    "end": "3620250"
  },
  {
    "text": "I combine them, and\nI get constant query.",
    "start": "3620250",
    "end": "3625610"
  },
  {
    "text": "Because log n plus\nlog n equals 1. I don't know. ",
    "start": "3625610",
    "end": "3632820"
  },
  {
    "text": "OK, here's the idea. On the one hand, jump pointers\nmake a big step and then",
    "start": "3632820",
    "end": "3638030"
  },
  {
    "text": "smaller steps, right. Yeah, like that. And on the other hand,\nladders make small steps.",
    "start": "3638030",
    "end": "3646339"
  },
  {
    "text": "It's hard to draw. ",
    "start": "3646340",
    "end": "3651400"
  },
  {
    "text": "What I'd like to do is take\nthis step and this step.",
    "start": "3651400",
    "end": "3659380"
  },
  {
    "text": "That would be good,\nbecause only two of them. So query is going to do\none jump, plus 1 ladder,",
    "start": "3659380",
    "end": "3673180"
  },
  {
    "text": "in that order. See, the thing about\nladders is it's really slow in the beginning,\nbecause your height is small.",
    "start": "3673180",
    "end": "3680110"
  },
  {
    "text": "I really want to\nget large height. Jump pointers give\nyou large height. The very first step, you get\nhalf the height you need.",
    "start": "3680110",
    "end": "3688720"
  },
  {
    "text": "That's it. So when we do a jump, we do\none step of the jump algorithm.",
    "start": "3688720",
    "end": "3698770"
  },
  {
    "text": "What do we do? We reach height at\nleast k over 2 above x.",
    "start": "3698770",
    "end": "3709040"
  },
  {
    "text": "All right, we get halfway there. So our height-- it's a little-- let's say x has height h.",
    "start": "3709040",
    "end": "3716360"
  },
  {
    "text": "OK, so then we get to\nheight-- this is saying we get to height h plus k over 2.",
    "start": "3716360",
    "end": "3723369"
  },
  {
    "text": "OK, that's good. This is a big height. Halfway there, I mean, halfway\nof the remainder after h.",
    "start": "3723370",
    "end": "3731410"
  },
  {
    "text": "Now ladders double your\nheight in every step. So ladder step-- so\nthis is the jump step.",
    "start": "3731410",
    "end": "3740540"
  },
  {
    "text": "If you do one ladder step, you\nwill reach height double that. So it's at least\n2 h plus k, which",
    "start": "3740540",
    "end": "3748724"
  },
  {
    "text": "is bigger than what we need. We need h plus k. That's where we're trying to go. And so we're done.",
    "start": "3748725",
    "end": "3754963"
  },
  {
    "text": "Isn't that cool? ",
    "start": "3754964",
    "end": "3760960"
  },
  {
    "text": "So the annoying part is\nthere's this extra part here. This is the h part and\nwe start at some level.",
    "start": "3760960",
    "end": "3768110"
  },
  {
    "text": "We don't know where. This is x. The worst case is maybe\nwhen it's very small, but whatever it is, we do this\nstep and this is our target up",
    "start": "3768110",
    "end": "3776260"
  },
  {
    "text": "here. This is height h plus k. In one step, we get\nmore than halfway",
    "start": "3776260",
    "end": "3782210"
  },
  {
    "text": "there with the jump pointer. And then the ladder will\ncarry us the rest of the way.",
    "start": "3782210",
    "end": "3787529"
  },
  {
    "text": "Because this is the ladder. We basically go horizontally\nto fall on this ladder,",
    "start": "3787530",
    "end": "3793310"
  },
  {
    "text": "and it will cover\nus beyond where we need to go, beyond\nour wildest imaginations. So this is k over 2.",
    "start": "3793310",
    "end": "3799669"
  },
  {
    "text": "Because not only\nwill it double this, which is what we\nneed to double, it will also double whatever\nis down here, this h part.",
    "start": "3799669",
    "end": "3805820"
  },
  {
    "text": "So it gets us way beyond\nwhere we need to go. I mean, could be h 0. Then it gets us to exactly\nwhere we need to go.",
    "start": "3805820",
    "end": "3811208"
  },
  {
    "text": " But then the ladder\ntells us where to go. So two steps constant time.",
    "start": "3811208",
    "end": "3817931"
  },
  {
    "text": " Now one annoying thing is\nwe're not done with space.",
    "start": "3817931",
    "end": "3825440"
  },
  {
    "text": "So this is the anticlimax part. It's still going to\nbe pretty interesting. We've got to shave off\na log factor in space,",
    "start": "3825440",
    "end": "3831456"
  },
  {
    "text": "but hey, we're experienced. We already did that once today. Question? Yeah. Why is it OK to go\npast your target?",
    "start": "3831456",
    "end": "3837145"
  },
  {
    "text": " The question was why is it\nOK to go past our target?",
    "start": "3837145",
    "end": "3843830"
  },
  {
    "text": "Jump pointers aren't\nallowed, because they only know how to go up. They can't overshoot. That's why they went less than\nhalfway, or more than halfway,",
    "start": "3843830",
    "end": "3850640"
  },
  {
    "text": "but less than the full way. Ladder decomposition can go\nbeyond, because as soon as--",
    "start": "3850640",
    "end": "3856580"
  },
  {
    "text": "the point is, as soon as--\nhere's you, x, and here's your kth ancestor.",
    "start": "3856580",
    "end": "3861770"
  },
  {
    "text": "This is the answer. As soon as you're in\na common ladder, then the array tells you where to go. So even though the top\nof the ladder overshot,",
    "start": "3861770",
    "end": "3870099"
  },
  {
    "text": "there will be a\nladder connecting you to that top of the ladder. So as long as it's somewhere\nin between, it's free.",
    "start": "3870099",
    "end": "3876020"
  },
  {
    "text": "Yeah, so that's why it's OK\nthis goes potentially too high. So it's good for ladders,\nnot good for jumps,",
    "start": "3876020",
    "end": "3881630"
  },
  {
    "text": "but that's exactly where\nwe have it Other questions? Yeah.",
    "start": "3881630",
    "end": "3886823"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]\njump pointers, wouldn't you be high\nup enough in the tree",
    "start": "3886823",
    "end": "3892458"
  },
  {
    "text": "so that just the\nlong path would work? PROFESSOR: Oh,\ninteresting question. So would it be enough to do\njump pointers plus long path?",
    "start": "3892458",
    "end": "3899450"
  },
  {
    "text": "My guess is no. Jump pointers get you up to-- so think of the\ncase where h is 0.",
    "start": "3899450",
    "end": "3905750"
  },
  {
    "text": "Initially you're at height 0. I think that's going\nto be a problem. You jump up to height k\nover 2 with a jump pointer.",
    "start": "3905750",
    "end": "3915470"
  },
  {
    "text": "Now long path\ndecomposition, you know that the path will have a\nlength at least k over 2,",
    "start": "3915470",
    "end": "3921170"
  },
  {
    "text": "but you need to get up to k. And so you may get stuck\nin this kind of situation where maybe you're\ntrying to get to the root",
    "start": "3921170",
    "end": "3927540"
  },
  {
    "text": "and you jumped to here,\nbut then you have to walk. So I think the long\npath's not enough.",
    "start": "3927540",
    "end": "3933140"
  },
  {
    "text": "You need that factor of 2,\nwhich the ladders give you. You can see where ladders\ncome from now, right? I mean we got up\nto height k over 2.",
    "start": "3933140",
    "end": "3940390"
  },
  {
    "text": "Now we just need to double it. Hey, we can afford\nto double every path, but I think we need to. Are there questions?",
    "start": "3940391",
    "end": "3948690"
  },
  {
    "text": "OK. So last thing to do is to shave\noff this log factor of space.",
    "start": "3948690",
    "end": "3956000"
  },
  {
    "text": "Now, we're going to do that\nwith indirection, of course, constant time and log n space.",
    "start": "3956000",
    "end": "3961040"
  },
  {
    "text": "But it's not our usual\ntype of indirection. ",
    "start": "3961040",
    "end": "3968750"
  },
  {
    "text": "Use this board. Indirections. So last time we did indirection,\nit was with an array.",
    "start": "3968750",
    "end": "3977080"
  },
  {
    "text": "And actually pretty much\nevery indirection we've done, it's been with an\narray-like thing. We could decompose into\ngroups of size log n,",
    "start": "3977080",
    "end": "3984039"
  },
  {
    "text": "the top thing was n over log n. So it was kind of clean. This structure is not so\nclean, because it's a tree.",
    "start": "3984040",
    "end": "3992200"
  },
  {
    "text": "How do you decompose a\ntree into little things at the bottom of size\nlog n and a top thing of size n over log n?",
    "start": "3992200",
    "end": "3998680"
  },
  {
    "text": "Suppose, for example,\nyour tree is a path. ",
    "start": "3998680",
    "end": "4006840"
  },
  {
    "text": "Bad news. If my tree were a path,\nwell, I could trim off",
    "start": "4006840",
    "end": "4015960"
  },
  {
    "text": "bottom thing of size log n. But now the rest is of size\nn minus log n, not n divided",
    "start": "4015960",
    "end": "4021750"
  },
  {
    "text": "by log n. That's bad. I need to shave a factor of\nlog n, not an additive log n. ",
    "start": "4021750",
    "end": "4029590"
  },
  {
    "text": "Can you tell me a good\nthing about a path?  I mean, obviously, when\nwe can put in an array.",
    "start": "4029591",
    "end": "4037150"
  },
  {
    "text": "But can you quantify\nthe goodness, or the pathlikedness of a tree? ",
    "start": "4037150",
    "end": "4044984"
  },
  {
    "text": "I erase this board. ",
    "start": "4044984",
    "end": "4053169"
  },
  {
    "text": "Kind of a vague question. ",
    "start": "4053169",
    "end": "4061730"
  },
  {
    "text": "Good thing about\na path is that it doesn't have very many leaves. That's one way to\nquantify pathedness.",
    "start": "4061730",
    "end": "4068220"
  },
  {
    "text": "Small number of leaves, I\nclaim life's not so bad.",
    "start": "4068220",
    "end": "4074290"
  },
  {
    "text": "I actually need to do that\nbefore we get to indirection.",
    "start": "4074290",
    "end": "4079388"
  },
  {
    "start": "4079388",
    "end": "4096009"
  },
  {
    "text": "Step 5 is let's tune\njump pointers a bit. ",
    "start": "4096010",
    "end": "4104479"
  },
  {
    "text": "I want to make them--  so they're the problem, right? That's where we\nget n log n space.",
    "start": "4104479",
    "end": "4111330"
  },
  {
    "text": "They're the only source\nof our n log n space. So what I'd like to do is\nin this situation where",
    "start": "4111330",
    "end": "4119170"
  },
  {
    "text": "the number of leaves is small-- we'll see what small\nis in a moment-- I would like jump pointers\nto be linear size.",
    "start": "4119170",
    "end": "4126809"
  },
  {
    "text": " OK, here's the idea. ",
    "start": "4126809",
    "end": "4136250"
  },
  {
    "text": "First idea is let's just store\njump pointers from leaves. ",
    "start": "4136250",
    "end": "4149290"
  },
  {
    "text": "OK. So that would imply\nl log n space,",
    "start": "4149290",
    "end": "4156528"
  },
  {
    "text": "I guess, plus linear overall. ",
    "start": "4156529",
    "end": "4162948"
  },
  {
    "text": "Instead of n log n, now we\njust pay for the leaves, except we kind of\nmessed up our query. First thing query did was at the\nnode, follow the jump pointer.",
    "start": "4162948",
    "end": "4171024"
  },
  {
    "text": "But it's not so bad. Here we are at x. There's some leaves\ndown here, and we want",
    "start": "4171024",
    "end": "4179119"
  },
  {
    "text": "to jump up from here, from x. How do I jump from x? Well, if I could somehow\ngo from x to really,",
    "start": "4179120",
    "end": "4185990"
  },
  {
    "text": "any leaf, the ancestors\nof x that I care about are also ancestors of\nany leaf descendant of x.",
    "start": "4185990",
    "end": "4193009"
  },
  {
    "text": "So all I need to do\nis store for each node any leaf descendant,\nsingle pointer--",
    "start": "4193010",
    "end": "4201929"
  },
  {
    "text": "this'll be linear--\nfrom every node.",
    "start": "4201930",
    "end": "4209260"
  },
  {
    "text": " OK so I start at x.",
    "start": "4209260",
    "end": "4215510"
  },
  {
    "text": "I jump down to an arbitrary\nleaf, say this one. And now I have to do a query.",
    "start": "4215510",
    "end": "4222949"
  },
  {
    "text": " Jump down, and let's\nsay I jumped down by d.",
    "start": "4222950",
    "end": "4233540"
  },
  {
    "text": "Then my k becomes\nk plus d, right.",
    "start": "4233540",
    "end": "4240770"
  },
  {
    "text": "If I went down by d,\nand I want to go up by k from my original point,\nnow I have to go up by k plus d.",
    "start": "4240770",
    "end": "4246440"
  },
  {
    "text": "But hey, we know how to\ngo up from any node that has jump pointers. So now we have a\nnew node, a leaf.",
    "start": "4246440",
    "end": "4255800"
  },
  {
    "text": "So it has a jump pointer,\nhas jump pointers, upward.",
    "start": "4255800",
    "end": "4261020"
  },
  {
    "text": "So we follow that one jump\npointer to get us halfway there from our new starting point.",
    "start": "4261020",
    "end": "4266660"
  },
  {
    "text": "We follow one\nladder thing, and we can get to the level ancestor\nk plus d from the leaf,",
    "start": "4266660",
    "end": "4273530"
  },
  {
    "text": "and that's the level\nancestor k from x. OK, this is like a reduction\nto the leaf situation.",
    "start": "4273530",
    "end": "4279069"
  },
  {
    "text": "We really don't have to support\nqueries from arbitrary nodes. Just go down to a leaf\nand then solve the problem from the leaf.",
    "start": "4279069",
    "end": "4285840"
  },
  {
    "text": "OK.  OK, so now, if the\nnumber leaves is small,",
    "start": "4285840",
    "end": "4291840"
  },
  {
    "text": "my space will get small. How small does l have to be? n divided by log n. Interesting.",
    "start": "4291840",
    "end": "4299180"
  },
  {
    "text": "If I could get the top structure\nto not have n over log n nodes, that's not possible.",
    "start": "4299180",
    "end": "4304250"
  },
  {
    "text": "I can, at best, get to\nn minus log n nodes. But if I could get it down\nto n over log n leaves, that",
    "start": "4304250",
    "end": "4310699"
  },
  {
    "text": "would be enough to\nmake this linear space, and indeed, I can. This is a technique called tree\ntrimming, or I call it that.",
    "start": "4310700",
    "end": "4319340"
  },
  {
    "text": "I don't know if\nanyone else does. But I think I've called\nit that in enough papers",
    "start": "4319340",
    "end": "4324542"
  },
  {
    "text": "that we're allowed\nto call it that. ",
    "start": "4324542",
    "end": "4333420"
  },
  {
    "text": "Originally invented by\n[? Al ?] [? Strip ?] and others for a particular data structure.",
    "start": "4333420",
    "end": "4338620"
  },
  {
    "text": "There's many versions of it. We will see other versions\nin future lectures, but here's the version\nyou need for this problem.",
    "start": "4338620",
    "end": "4349340"
  },
  {
    "start": "4349340",
    "end": "4367920"
  },
  {
    "text": "OK, here's the plan. I have a tree and\nI want to identify",
    "start": "4367920",
    "end": "4379820"
  },
  {
    "text": "all the maximally deep nodes\nthat have at least log n",
    "start": "4379820",
    "end": "4384889"
  },
  {
    "text": "nodes below them. This will seem weird,\nbecause we really care about leaves, and so on. So there's stuff hanging\noff here, whatever.",
    "start": "4384890",
    "end": "4395239"
  },
  {
    "text": "I guess I'm thinking of\nthat as one big tree. No, actually I'm not.",
    "start": "4395240",
    "end": "4401180"
  },
  {
    "text": "I do need to separate these out.  But one of these nodes could\nhave arbitrarily many children.",
    "start": "4401180",
    "end": "4408230"
  },
  {
    "text": "We have no idea. It's a arbitrary tree. ",
    "start": "4408230",
    "end": "4414740"
  },
  {
    "text": "OK, and what I know is that\neach of these triangles has size less than 1/4 log n.",
    "start": "4414740",
    "end": "4422750"
  },
  {
    "text": "Because otherwise, this\nnode was not maximally deep. So if this had size greater\nor equal than 1/4 log n,",
    "start": "4422750",
    "end": "4433919"
  },
  {
    "text": "then that would have been the\nnode where I cut, not this one. So I'm circling the\nnodes that I cut below,",
    "start": "4433919",
    "end": "4438920"
  },
  {
    "text": "so meaning I cut these edges.  OK, so these things have\nsize less than 1/4 log n,",
    "start": "4438920",
    "end": "4445829"
  },
  {
    "text": "but these nodes have at least\n1/4 log n nodes below them.",
    "start": "4445830",
    "end": "4451880"
  },
  {
    "text": "So how many of these\ncircle nodes are there? Well, at most, 4 n over\nlog n such nodes, right,",
    "start": "4451880",
    "end": "4470119"
  },
  {
    "text": "because I can charge\nthis node to at least 1/4 log n nodes that disappear\nin the top structure.",
    "start": "4470120",
    "end": "4476750"
  },
  {
    "text": " But these things become\nthe leaves, right.",
    "start": "4476750",
    "end": "4483650"
  },
  {
    "text": "If I cut all the edges\ngoing down from there, that makes it a leaf. And they're the only leaves.",
    "start": "4483650",
    "end": "4490719"
  },
  {
    "text": "Are they the only leaves? Yeah. If you look at a leaf, then it\nhas size less than 1/4 log n.",
    "start": "4490720",
    "end": "4497000"
  },
  {
    "text": "So you will cut\nabove it somewhere. So every old leaf\nwill be down here, and the only new leaves\nwill be the cut nodes.",
    "start": "4497000",
    "end": "4505270"
  },
  {
    "text": "OK. So we have order n\nover log n leaves.",
    "start": "4505270",
    "end": "4512329"
  },
  {
    "text": "Yes, good. So it's funny. We're cutting according\nto counting nodes, descendants, not leaves.",
    "start": "4512330",
    "end": "4518659"
  },
  {
    "text": "Won't work if you\ncut with leaves-- cut with nodes. But then the thing that we care\nabout is the number of leaves",
    "start": "4518660",
    "end": "4524171"
  },
  {
    "text": "went down. That will be enough. Great.",
    "start": "4524171",
    "end": "4529880"
  },
  {
    "text": "So up here, we can afford to\nuse 5, the tuned jump pointer,",
    "start": "4529880",
    "end": "4538100"
  },
  {
    "text": "combined with ladder structure. Because this only costs l log n.",
    "start": "4538100",
    "end": "4545310"
  },
  {
    "text": "l is now n over log n,\nso the log n's cancel. So linear space to\nstore the jump pointers",
    "start": "4545310",
    "end": "4551720"
  },
  {
    "text": "from these circled nodes. So if our query is\nanywhere up here, then we go to a descendant\nleaf in the top structure.",
    "start": "4551720",
    "end": "4558840"
  },
  {
    "text": "And we can go wherever\nwe need to go.  If our query is in one\nof the little trees",
    "start": "4558840",
    "end": "4565506"
  },
  {
    "text": "at the bottom, which are small,\nthey're only 1/4 quarter log n, so we're going to\nuse a lookup table.",
    "start": "4565506",
    "end": "4570770"
  },
  {
    "text": "Either answer is\ninside the triangle, in which case, we really\nneed to query that structure. Or it's up here.",
    "start": "4570770",
    "end": "4578300"
  },
  {
    "text": "If it's up here, we just\nneed to know, basically, if every node down here stores\na pointer to the dot above it.",
    "start": "4578300",
    "end": "4585660"
  },
  {
    "text": "Then we can first go there\nand see, is that too high? If it's too high, then\nour answer is in here. If it's not too\nhigh, then we just",
    "start": "4585660",
    "end": "4591680"
  },
  {
    "text": "do the corresponding\nquery in structure 5. OK, so the last\nremaining thing is to solve a query that stays\nentirely within a triangle, so",
    "start": "4591680",
    "end": "4600239"
  },
  {
    "text": "a bottom structure, and that's\nwhere we use lookup tables.",
    "start": "4600240",
    "end": "4605555"
  },
  {
    "start": "4605555",
    "end": "4616740"
  },
  {
    "text": "Again, things are going\nto be similar to last time except for now, to step 7. ",
    "start": "4616740",
    "end": "4624780"
  },
  {
    "text": "But it's a little bit messier\nbecause instead of arrays, we have trees. And here it's like we graduate\nfrom baby [INAUDIBLE] which is",
    "start": "4624780",
    "end": "4633869"
  },
  {
    "text": "how many plus or minus\n1 strings there are-- power of 2-- to how\nmany trees are there.",
    "start": "4633870",
    "end": "4640050"
  },
  {
    "text": "Anyone know how many trees\non n nodes there are? One word answer. ",
    "start": "4640050",
    "end": "4648220"
  },
  {
    "text": "No. Nice. That is a correct\none word answer. Very good.",
    "start": "4648220",
    "end": "4654150"
  },
  {
    "text": "Not the one I had in\nmind, but anyone else? ",
    "start": "4654150",
    "end": "4674630"
  },
  {
    "text": "Nope. You're thinking end to the end. That would be bad. We could not afford that,\nbecause log n to log n",
    "start": "4674630",
    "end": "4680199"
  },
  {
    "text": "is super polynomial. Fortunately it's not that big. Hmm? AUDIENCE: PROFESSOR: It's\nroughly 4 to the n.",
    "start": "4680200",
    "end": "4686050"
  },
  {
    "text": "The correct answer-- I\nmean the exact answer-- is called the Catalan number,\nwhich didn't tell you much.",
    "start": "4686050",
    "end": "4691636"
  },
  {
    "text": "I didn't write it\ndown, but I'm pretty sure it is 2 n prime choose\nn prime 1 over n prime plus 1",
    "start": "4691637",
    "end": "4701770"
  },
  {
    "text": "ish? Don't quote me on that. It's roughly that.",
    "start": "4701770",
    "end": "4707380"
  },
  {
    "text": "Might be exactly that. Someone with internet can check. But it is at most\n4 to the n prime.",
    "start": "4707380",
    "end": "4713460"
  },
  {
    "text": "The computer science\nanswer is 4 to the n. Indeed. It's just some asymptotics here.",
    "start": "4713460",
    "end": "4719260"
  },
  {
    "text": "Why is it 4 to the n? 4 to the n you could also\nwrite as 2 to the 2 n prime, which is--",
    "start": "4719260",
    "end": "4724754"
  },
  {
    "text": "first, let's check this\nis good, and then I'll explain why this is true\nin a computer science way.",
    "start": "4724754",
    "end": "4730060"
  },
  {
    "text": "So we got 1/4 log n up here. So the one 2 cancels\nwith one 2 up here.",
    "start": "4730060",
    "end": "4735910"
  },
  {
    "text": "So we have 2 to the 1/2 log n. This is our good friend root n. Root n is just something\nthat's n to the something,",
    "start": "4735910",
    "end": "4742750"
  },
  {
    "text": "but is n to the\nsomething less than 1. So we can afford\nsome log factors. ",
    "start": "4742750",
    "end": "4750369"
  },
  {
    "text": "Why are there only 2\nto the 2 n prime trees? One way to see that is you can\nencode a tree using 2n bits.",
    "start": "4750370",
    "end": "4757630"
  },
  {
    "text": "If I have an n node tree, I\ncan encode it with 2n bits. How? Do an Euler tour.",
    "start": "4757630",
    "end": "4763719"
  },
  {
    "text": "And all you really need\nto know from an Euler tour to reconstruct the\ntree is at each step,",
    "start": "4763720",
    "end": "4768970"
  },
  {
    "text": "did I go down or did I go up? Those are the only\nthings you can do. If you went down,\nit's to a new child. If you went up,\nit's to an old node.",
    "start": "4768970",
    "end": "4775849"
  },
  {
    "text": "So if I told you\na sequence of bits for every step in the\nEuler tour, did I go down or did I go up, you can\nreconstruct the tree.",
    "start": "4775850",
    "end": "4783950"
  },
  {
    "text": "Now how many bits\ndo I have to do? Well, twice the number\nof edges in the tree, because the length\nof an Euler tour",
    "start": "4783950",
    "end": "4789610"
  },
  {
    "text": "is twice the number\nof edges in the tree. So 2 n bits are enough\nto encode any tree. That's the computer\nscience information",
    "start": "4789610",
    "end": "4795790"
  },
  {
    "text": "theoretic way to prove it. You could also do it\nfrom this formula, but then you'd have to know\nwhy the formula's correct,",
    "start": "4795790",
    "end": "4801440"
  },
  {
    "text": "and that's messier. Cool. So we're almost done.",
    "start": "4801440",
    "end": "4807890"
  },
  {
    "text": "We have root n possible\ndifferent structures down here. We've got n over\nlog n of them or--",
    "start": "4807890",
    "end": "4814610"
  },
  {
    "text": "maybe. It's a little harder to know\nexactly how many of them there are, but I don't care. There's only root\nn different types,",
    "start": "4814610",
    "end": "4821310"
  },
  {
    "text": "and so I only need to store\na lookup table for each type. The number of queries is\norder log squared n again,",
    "start": "4821310",
    "end": "4832250"
  },
  {
    "text": "because our structures\nare of size order log n, and the answer to\na query is again,",
    "start": "4832250",
    "end": "4839469"
  },
  {
    "text": "order log log n bits,\nbecause there's only log",
    "start": "4839470",
    "end": "4844620"
  },
  {
    "text": "n different nodes to point to. And so the total space is\norder root n log n squared,",
    "start": "4844620",
    "end": "4858260"
  },
  {
    "text": "log log n for the lookup table. And then each of these\ntriangles stores a pointer,",
    "start": "4858260",
    "end": "4865800"
  },
  {
    "text": "or I guess, every node\nin here stores a pointer to what tree we're in, or\nwhat type of tree we have,",
    "start": "4865800",
    "end": "4874489"
  },
  {
    "text": "and also what node in\nthat tree we are in. So every guy in here-- because that's not\npart of the query--",
    "start": "4874490",
    "end": "4880940"
  },
  {
    "text": "has to store, not only a little\nbit more specific pointer into this table. It actually tells you\nwhat the query part is,",
    "start": "4880940",
    "end": "4887869"
  },
  {
    "text": "or the first part of\nthe query, the node x. Then the table also\nis parameterized by k,",
    "start": "4887870",
    "end": "4893780"
  },
  {
    "text": "so one of these logs is\nwhich node you're querying. The other log is\nnow the value k,",
    "start": "4893780",
    "end": "4899300"
  },
  {
    "text": "but again, you never go\nup higher than log n. If you went up\nhigher than log n, then you'd be in\nthe 5 structure,",
    "start": "4899300",
    "end": "4904592"
  },
  {
    "text": "so if you just do\na query up there, you don't need a\nquery in the bottom. OK. So there's only\nthat many queries,",
    "start": "4904592",
    "end": "4910760"
  },
  {
    "text": "and so space for this lookup\ntable is little o of n again. And so we're dominated by\nspace for these pointers",
    "start": "4910760",
    "end": "4918489"
  },
  {
    "text": "and for the space up\nhere, which is linear. So linear space, constant query.",
    "start": "4918490",
    "end": "4924020"
  },
  {
    "text": "Boom. Any questions? ",
    "start": "4924020",
    "end": "4933150"
  },
  {
    "text": "I have an open question, maybe. I think it's open. So what if you want to do\ndynamic, 30 seconds of dynamic?",
    "start": "4933150",
    "end": "4942900"
  },
  {
    "text": "For LCA, it's known\nhow to do dynamic LCA constant operations.",
    "start": "4942900",
    "end": "4948570"
  },
  {
    "text": "The operations are add a leaf-- we can add another leaf-- given an edge.",
    "start": "4948570",
    "end": "4954329"
  },
  {
    "text": "Subdivide that edge into\nthat, and also the reverse. So I can erase a guy, put\nthe edge back, delete a leaf,",
    "start": "4954330",
    "end": "4962850"
  },
  {
    "text": "those sorts of things. Those operations can all be\ndone in constant time for LCA. What about level ancestor?",
    "start": "4962850",
    "end": "4969510"
  },
  {
    "text": "I have no idea. Maye we'll work on it today. That's it. ",
    "start": "4969510",
    "end": "4974944"
  }
]