[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6340"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6340",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13320",
    "end": "20410"
  },
  {
    "text": "ERIK DEMAINE: All right. Welcome back to 6046. Today we continue our\ntheme of data structures",
    "start": "20410",
    "end": "28030"
  },
  {
    "text": "but this time, instead of doing\na fancy cool data structure, we're going to look\nat fancy cool analysis",
    "start": "28030",
    "end": "33370"
  },
  {
    "text": "techniques for data structures. And these are useful for tons\nof different data structures, especially in the context when\nyou're using a data structure",
    "start": "33370",
    "end": "41800"
  },
  {
    "text": "to implement an algorithm. For example, in Dijkstra, when\nyou learn Dijkstra's algorithm,",
    "start": "41800",
    "end": "48950"
  },
  {
    "text": "you had lots of\ndifferent heap structures you could use for the\npriority queue in Dijkstra,",
    "start": "48950",
    "end": "54850"
  },
  {
    "text": "and they gave different\nrunning times with Dijkstra. But the key thing\nin that context",
    "start": "54850",
    "end": "60230"
  },
  {
    "text": "is that you cared about\nthe total running time of the algorithm,\nless than you cared",
    "start": "60230",
    "end": "65390"
  },
  {
    "text": "about the individual running\ntime of each operation. That's what\namortization is about.",
    "start": "65390",
    "end": "70910"
  },
  {
    "text": "It's, I guess, a technique\nfrom financial analysis, but we've appropriated\nit in computer science",
    "start": "70910",
    "end": "76910"
  },
  {
    "text": "as an analysis technique\nto say, well, let's not worry about every single\noperation worst case cost,",
    "start": "76910",
    "end": "82360"
  },
  {
    "text": "let's just worry about the\ntotal operation, the sum of all the operations cost.",
    "start": "82360",
    "end": "87640"
  },
  {
    "text": "That's the whole\nidea of amortization, but there's a lot of\ndifferent ways to do it. We're going to cover four\ndifferent methods for doing it,",
    "start": "87640",
    "end": "93910"
  },
  {
    "text": "and three-ish examples\nof doing it today. You've seen some essentially\nin recitation last time,",
    "start": "93910",
    "end": "102180"
  },
  {
    "text": "and you've seen a\nlittle bit in 6006, so let me first remind you of\nthe example of table doubling",
    "start": "102180",
    "end": "110040"
  },
  {
    "text": "from 6006.",
    "start": "110040",
    "end": "116330"
  },
  {
    "text": "This came up in the\ncontext of hash tables. As you may recall,\nif you store n items",
    "start": "116330",
    "end": "124909"
  },
  {
    "text": "in a hash table of size m--\nthere are m slots in the table,",
    "start": "124910",
    "end": "132280"
  },
  {
    "text": "let's say, using chaining--\nhashing with chaining-- then we got an expected\ncost constant plus",
    "start": "132280",
    "end": "147269"
  },
  {
    "text": "the load factor, size\nof the table divided by the number of items. So we wanted to get\nconstant expected,",
    "start": "147270",
    "end": "154030"
  },
  {
    "text": "and so we wanted this to\nalways be, at most, a constant. I guess we could handle\na larger table size,",
    "start": "154030",
    "end": "160250"
  },
  {
    "text": "although then we are\nunhappy about our space, but we definitely want m to be\nat least around n so that this",
    "start": "160250",
    "end": "166350"
  },
  {
    "text": "works out to order one. And the solution for doing\nthat was table doubling. Whenever the table is\ntoo big, double it--",
    "start": "166350",
    "end": "173275"
  },
  {
    "text": "or sorry-- whenever\nthe table is too small and we have too many items,\ndouble the size of the table. ",
    "start": "173275",
    "end": "181260"
  },
  {
    "text": "If n-- n is the thing\nthat we can't control.",
    "start": "181260",
    "end": "188521"
  },
  {
    "text": "That's the number\nof items somebody is inserting into the table. If n grows to the value\nto match m, then double m.",
    "start": "188522",
    "end": "198650"
  },
  {
    "text": " So m prime equals 2m, and\nto double the table size,",
    "start": "198650",
    "end": "209935"
  },
  {
    "text": "you have to allocate a new\narray of double the size and copy over all the items,\nand that involves hashing.",
    "start": "209935",
    "end": "215750"
  },
  {
    "text": "But overall this will take\norder, size of the table, work.",
    "start": "215750",
    "end": "222320"
  },
  {
    "text": "Doesn't matter whether I'm\nusing m or m prime here, because they're within a\nconstant factor of each other,",
    "start": "222320",
    "end": "227760"
  },
  {
    "text": "and that's bad. Linear time to do an\ninsertion is clearly bad. This is all during one\ninsertion operation",
    "start": "227760",
    "end": "233070"
  },
  {
    "text": "that this would happen,\nbut overall it's not going to be bad, because\nyou only double log n times.",
    "start": "233070",
    "end": "238549"
  },
  {
    "text": "And if you look at\nthe total cost--",
    "start": "238550",
    "end": "246130"
  },
  {
    "text": "so maybe you think, oh,\nis it log n per operation, but it's not so bad because\ntotal cost for n insertions",
    "start": "246130",
    "end": "254070"
  },
  {
    "text": "starting from an empty structure\nis something like 2 to the 0--",
    "start": "254070",
    "end": "261351"
  },
  {
    "text": "this is a big theta outside--\n2 to the 1, 2 to the 2. If we're only doing\ninsertions, this is great.",
    "start": "261352",
    "end": "268920"
  },
  {
    "text": "2 to the log n. This is a geometric series\nand so this is order n.",
    "start": "268920",
    "end": "276067"
  },
  {
    "text": " Theta head I guess.",
    "start": "276067",
    "end": "282180"
  },
  {
    "text": "So to do n insertions,\ncost theta n, so we'd like to say the\namortized cost per operation",
    "start": "282180",
    "end": "296520"
  },
  {
    "text": "is constant, because\nwe did n operations.",
    "start": "296520",
    "end": "309770"
  },
  {
    "text": "Total cost was n, so sort\nof on average per operation, that was the only constant. So this is the sense in which\nhash tables are constant,",
    "start": "309770",
    "end": "317100"
  },
  {
    "text": "expected, amortized. And we'll get back to\nhashing in a future lecture,",
    "start": "317100",
    "end": "323000"
  },
  {
    "text": "probably I think lecture\n8, but for now we're just going to think about\nthis as a general thing",
    "start": "323000",
    "end": "328430"
  },
  {
    "text": "where you need table doubling,\nthen this gives you a fast way",
    "start": "328430",
    "end": "333580"
  },
  {
    "text": "to insert into a table. Later we'll think about\ndeleting from a table and keeping the\nspace not too big,",
    "start": "333580",
    "end": "338880"
  },
  {
    "text": "but that's a starting point. This is an example of a\ngeneral technique called the aggregate method, which\nis probably the weakest",
    "start": "338880",
    "end": "348600"
  },
  {
    "text": "method for doing\namortization but",
    "start": "348600",
    "end": "353812"
  },
  {
    "text": "maybe the most intuitive one. ",
    "start": "353812",
    "end": "361160"
  },
  {
    "text": "So the aggregate\nmethod says, well, we do some sequence of operations.",
    "start": "361160",
    "end": "367620"
  },
  {
    "text": "Let's say, in general,\nthere are k operations. Measure the total cost\nof those operations,",
    "start": "367620",
    "end": "378100"
  },
  {
    "text": "divide by k, that's the\namortized cost per operation. ",
    "start": "378100",
    "end": "395190"
  },
  {
    "text": "You can think of\nthis as a definition, but it's not actually\ngoing to be our definition of amortized cost. We're going to use a\nmore flexible definition,",
    "start": "395190",
    "end": "401600"
  },
  {
    "text": "but for simple examples like\nthis, it's a fine definition, and it gives you what you want.",
    "start": "401600",
    "end": "406960"
  },
  {
    "text": "When your sequence of\noperations is very clear, like here, there's\nonly one thing you",
    "start": "406960",
    "end": "412349"
  },
  {
    "text": "can do at each step,\nwhich is insert-- that's my definition of the\nproblem-- then great, we get a very simple sum.",
    "start": "412350",
    "end": "418100"
  },
  {
    "text": "As soon as you mix\ninserts and deletes, the sum is not so clear. But in some situations,\nthe sum is really clean,",
    "start": "418100",
    "end": "425502"
  },
  {
    "text": "so you just compute\nthe sum, divide by a number of operations,\nyou get a cost, and that could be\nthe amortized cost.",
    "start": "425502",
    "end": "431820"
  },
  {
    "text": "And that's the aggregate method,\nworks great for simple sums. Here's another example\nwhere it-- no, sorry.",
    "start": "431820",
    "end": "439480"
  },
  {
    "text": "Let me now give you\nthe general definition of amortized bounds,\nwhich becomes important",
    "start": "439480",
    "end": "451560"
  },
  {
    "text": "once you're dealing with\ndifferent types of operations. I want to say an insert\ncosts one bound amortized",
    "start": "451560",
    "end": "457070"
  },
  {
    "text": "and maybe a delete\ncosts some other bound. So what you get to do is assign\na cost for each operation.",
    "start": "457070",
    "end": "468250"
  },
  {
    "text": "I should call it\nan amortized cost,",
    "start": "468250",
    "end": "484490"
  },
  {
    "text": "such that you preserve\nthe sum of those costs.",
    "start": "484490",
    "end": "493810"
  },
  {
    "text": "So what I mean is that if I look\nat the sum over all operations",
    "start": "493810",
    "end": "499910"
  },
  {
    "text": "of the amortized cost\nof that operation,",
    "start": "499910",
    "end": "505570"
  },
  {
    "text": "and I compare that with the\nsum of all the actual costs",
    "start": "505570",
    "end": "513120"
  },
  {
    "text": "of the operations, the\namortize should always",
    "start": "513120",
    "end": "518240"
  },
  {
    "text": "be bigger, because I\nalways want an upper bound on my actual cost. So if I can prove that the\namortized costs are, at most,",
    "start": "518240",
    "end": "525830"
  },
  {
    "text": "say, constant per\noperation, then I get that the sum\nof the actual cost is, at most, constant\nper operation.",
    "start": "525830",
    "end": "531600"
  },
  {
    "text": "I don't learn anything\nabout the individual costs, but I learn about\nthe total cost. And in the context of an\nalgorithm like Dijkstra's",
    "start": "531600",
    "end": "537773"
  },
  {
    "text": "algorithm, you only care\nabout the total cost, because you don't care about\nthe shortest paths at time t,",
    "start": "537773",
    "end": "542810"
  },
  {
    "text": "you only care about the shortest\npaths when the algorithm is completely finished. So in a lot of situations,\nmaybe not a real-time system,",
    "start": "542810",
    "end": "551281"
  },
  {
    "text": "but almost everything\nelse, you just care about the sum of the costs. As long as that's\nsmall, you can afford the occasional\nexpensive operation.",
    "start": "551281",
    "end": "559930"
  },
  {
    "text": "So this is a more\nflexible definition. One option would be to\nassign the average cost",
    "start": "559930",
    "end": "565139"
  },
  {
    "text": "to each operation, but we have\na whole bunch more operations. We could say inserts cost\nmore than deletes or things",
    "start": "565140",
    "end": "570570"
  },
  {
    "text": "like that. In fact, let me do\nsuch an example. A couple weeks ago, you\nlearned about 2-3 trees.",
    "start": "570570",
    "end": "578132"
  },
  {
    "text": "This would work for\nany structure though. ",
    "start": "578132",
    "end": "589690"
  },
  {
    "text": "So I claim I'm going to look at\nthree operations on 2-3 trees. One is create an\nempty tree, so I",
    "start": "589690",
    "end": "597679"
  },
  {
    "text": "need to think about\nhow we're getting started in amortization. ",
    "start": "597679",
    "end": "606410"
  },
  {
    "text": "Let's say you always\nstart with an empty tree. It takes constant\ntime to make one.",
    "start": "606410",
    "end": "611519"
  },
  {
    "text": "I pay log n time-- I'm going\nto tweak that a little bit--",
    "start": "611519",
    "end": "617250"
  },
  {
    "text": "for an insertion, and\nI pay 0 time per delete",
    "start": "617250",
    "end": "633490"
  },
  {
    "text": "in an amortized sense. ",
    "start": "633490",
    "end": "641090"
  },
  {
    "text": "You can write big\nO of 0 if you like. Same thing. So deletion you can think\nof as a free operation.",
    "start": "641090",
    "end": "649360"
  },
  {
    "text": "Why? ",
    "start": "649361",
    "end": "656576"
  },
  {
    "text": "This is a bit counter-intuitive\nbecause, of course, in reality the actual cost of a deletion\nis going to be log n.",
    "start": "656577",
    "end": "662151"
  },
  {
    "text": "Yeah. AUDIENCE: You can never\ndelete more elements than you've already inserted. ERIK DEMAINE: You can\nnever delete more elements than you've already inserted.",
    "start": "662151",
    "end": "668210"
  },
  {
    "text": "Good. AUDIENCE: Can you cap\nthe cost of [INAUDIBLE] ERIK DEMAINE: Yeah. So I can bound the deletion\ncost by the insertion cost,",
    "start": "668210",
    "end": "676519"
  },
  {
    "text": "and in the context of\njust the aggregate method, you could look at the total\ncost of all the operations.",
    "start": "676520",
    "end": "683019"
  },
  {
    "text": "I guess we're not\nexactly dividing here, but if we look at\nthe total cost,",
    "start": "683020",
    "end": "691940"
  },
  {
    "text": "let's say that we do c\ncreations, i insertions",
    "start": "691940",
    "end": "697300"
  },
  {
    "text": "and d deletions, then the total\ncost becomes c plus i times",
    "start": "697300",
    "end": "704330"
  },
  {
    "text": "log n plus d times the log n. ",
    "start": "704330",
    "end": "711540"
  },
  {
    "text": "And the point is d is\nless than or equal to i,",
    "start": "711540",
    "end": "716571"
  },
  {
    "text": "because you can never\ndelete an item that wasn't already inserted\nif you're starting from an empty structure.",
    "start": "716572",
    "end": "721760"
  },
  {
    "text": "And so this is i plus d\ntimes log n, but that's just,",
    "start": "721760",
    "end": "727370"
  },
  {
    "text": "at most, twice i times log\nn, so we get c plus i log n.",
    "start": "727370",
    "end": "733660"
  },
  {
    "text": " And so we can think of that\nas having a d times 0, 0",
    "start": "733660",
    "end": "742220"
  },
  {
    "text": "cost per deletion. So this is the sum of the\nactual costs over here. This is the sum of the\namortized costs, where",
    "start": "742220",
    "end": "749220"
  },
  {
    "text": "we say 0 for the\ndeletion, and we just showed that this is an upper\nbound on that, so we're happy.",
    "start": "749220",
    "end": "756980"
  },
  {
    "text": "Now, there's a\nslight catch here, and that's why I wrote\nstar on every n, which is not every operation\nhas the same cost, right?",
    "start": "756980",
    "end": "764190"
  },
  {
    "text": "When you start from\nan empty structure, insertion cost constant\ntime, because n is 0.",
    "start": "764190",
    "end": "770480"
  },
  {
    "text": "When n is a constant,\ninsertion is constant time. When n grows to n,\nit costs log n time.",
    "start": "770480",
    "end": "778310"
  },
  {
    "text": "At different times, n\nis a different value, and n I'm going to use\nto mean the current size",
    "start": "778310",
    "end": "783450"
  },
  {
    "text": "of the structure. For this argument to\nwork at the moment, I need that n is not the\ncurrent value, because this",
    "start": "783450",
    "end": "791249"
  },
  {
    "text": "is kind of charging work. Some insertions are\nfor large structures, some are for small structures,\nsome deletions are for small,",
    "start": "791249",
    "end": "796700"
  },
  {
    "text": "some are for large. Gets confusing to think about. We will fix that in a\nmoment but, for now, I'm just going to\ndefine n star to be",
    "start": "796700",
    "end": "803930"
  },
  {
    "text": "the maximum size over all time. ",
    "start": "803930",
    "end": "809370"
  },
  {
    "text": "OK, if we just define it\nthat way, then this is true. That will let me pay\nfor any deletion,",
    "start": "809370",
    "end": "818000"
  },
  {
    "text": "but we'll remove that\nstar later on once we get better analysis\nmethods, but so far so good.",
    "start": "818000",
    "end": "824260"
  },
  {
    "text": "Two very simple\nexamples-- table doubling, 2-3 trees with free deletion.",
    "start": "824260",
    "end": "830167"
  },
  {
    "text": "Of course, that would\nwork for any structure with logarithmic\ninsertion and deletion, but we're going to be using\n2-3 trees in a more-- analyzing",
    "start": "830167",
    "end": "837759"
  },
  {
    "text": "them in a more\ninteresting way later on.",
    "start": "837760",
    "end": "842870"
  },
  {
    "text": "So let's go to the next method,\nwhich is the accounting method. ",
    "start": "842870",
    "end": "852220"
  },
  {
    "text": "It's like the bank teller's\nanalysis, if you will. ",
    "start": "852220",
    "end": "859699"
  },
  {
    "text": "These are all just different\nways to compute these sums or to think about the sums,\nand usually one method",
    "start": "859700",
    "end": "866660"
  },
  {
    "text": "is a lot easier, either for you\npersonally or for each problem, more typically.",
    "start": "866660",
    "end": "872250"
  },
  {
    "text": "Each problem usually one\nor more of these methods is going to be more\nintuitive than the others. They're all kind of\nequivalent, but it's",
    "start": "872250",
    "end": "878550"
  },
  {
    "text": "good to have them\nall in your mind so you can just think about\nthe problem in different ways. So with the accounting\nmethod, what we're going to do",
    "start": "878550",
    "end": "886230"
  },
  {
    "text": "is define a bank account and\nan operation can store credit",
    "start": "886230",
    "end": "897070"
  },
  {
    "text": "in that bank account. ",
    "start": "897070",
    "end": "911546"
  },
  {
    "text": "Credits maybe not the best\nword, because you're not allowed for the bank\naccount to go negative.",
    "start": "911546",
    "end": "916649"
  },
  {
    "text": "The bank account must always\nbe non-negative balance,",
    "start": "916650",
    "end": "922570"
  },
  {
    "text": "because otherwise your\nsummations won't work out. So when you store credit in the\nbank account, you pay for it.",
    "start": "922570",
    "end": "929050"
  },
  {
    "text": "It's as if you're\nconsuming time now in order to pay for it in the future.",
    "start": "929050",
    "end": "934090"
  },
  {
    "text": "And think of operations\ncosting money, so whenever I do a deletion, I\nspend actual time, log n time,",
    "start": "934090",
    "end": "943530"
  },
  {
    "text": "but if I had log n\ndollars in the bank, and I could pull\nthose out of the bank, I can use those dollars\nto pay for the work,",
    "start": "943530",
    "end": "951230"
  },
  {
    "text": "and then the deletion\nitself becomes free in an amortized sense. So this is, on the\none hand, operation--",
    "start": "951230",
    "end": "960030"
  },
  {
    "text": "and when I do an insertion,\nI'm going to physically take some coins out of myself.",
    "start": "960030",
    "end": "965960"
  },
  {
    "text": "That will cost\nsomething in the sense that the amortized\ncost of insertion",
    "start": "965960",
    "end": "971029"
  },
  {
    "text": "goes up in order to put\nthose coins in the bank, but then I'll be able to\nuse them for deletion.",
    "start": "971030",
    "end": "976329"
  },
  {
    "text": "So this is what\ninsertion is going to do. I can store credit\nin the bank, and then separately we allow an operation\nto take coins out of the bank,",
    "start": "976330",
    "end": "989540"
  },
  {
    "text": "and you can pay for time\nusing the credit that's",
    "start": "989540",
    "end": "997070"
  },
  {
    "text": "been stored in the bank. ",
    "start": "997070",
    "end": "1003410"
  },
  {
    "text": "As long as the bank\nbalance remains non-negative at all\ntimes, this will be good.",
    "start": "1003410",
    "end": "1012680"
  },
  {
    "text": "The bank balance is a\nsort of unused time. We're paying for it to\nstore things in there.",
    "start": "1012680",
    "end": "1017930"
  },
  {
    "text": "If we don't use\nit, well, we just have an upper bound on time. As long as we go\nnon-negative, then",
    "start": "1017930",
    "end": "1025189"
  },
  {
    "text": "the summation will always\nbe in the right direction. This inequality will hold. Let's do an example.",
    "start": "1025190",
    "end": "1031900"
  },
  {
    "start": "1031900",
    "end": "1047839"
  },
  {
    "text": "Well, maybe this\nis a first example. So when I do an\ninsertion, I can put,",
    "start": "1047839",
    "end": "1055050"
  },
  {
    "text": "let's say, one coin of value\nlog n star into the bank, and so",
    "start": "1055050",
    "end": "1061170"
  },
  {
    "text": "the total cost of\nthat insertion, I pay log n star real cost\nin order to do the insertion,",
    "start": "1061170",
    "end": "1066310"
  },
  {
    "text": "then I also pay log n\nstar for those coins to put them in the bank. When I do a deletion, the\nreal cost is log n star,",
    "start": "1066310",
    "end": "1073520"
  },
  {
    "text": "but I'm going to extract\nout of it log n star coins, and so the total\ncost is actually",
    "start": "1073520",
    "end": "1078730"
  },
  {
    "text": "free-- the total\namortized cost is free--",
    "start": "1078730",
    "end": "1087320"
  },
  {
    "text": "and the reason that works, the\nreason the balance is always non-negative, is because\nfor every deletion there was an\ninsertion before it.",
    "start": "1087320",
    "end": "1093700"
  },
  {
    "text": "So that's maybe a\nless intuitive way to think about this\nproblem, but you could think about it that way.",
    "start": "1093700",
    "end": "1099085"
  },
  {
    "start": "1099085",
    "end": "1105080"
  },
  {
    "text": "More generally-- so\nwhat we'd like to say is that we only put\nlog n without the star,",
    "start": "1105080",
    "end": "1112970"
  },
  {
    "text": "the current value\nof n per insert",
    "start": "1112970",
    "end": "1118230"
  },
  {
    "text": "and a 0 per delete amortized.",
    "start": "1118230",
    "end": "1126815"
  },
  {
    "start": "1126815",
    "end": "1133570"
  },
  {
    "text": "So we'd like to\nsay, OK, let me put",
    "start": "1133570",
    "end": "1139389"
  },
  {
    "text": "one coin worth log n for each\ninsertion, and when I delete,",
    "start": "1139390",
    "end": "1160710"
  },
  {
    "text": "I consume the coin. ",
    "start": "1160710",
    "end": "1167600"
  },
  {
    "text": "And, in general,\nthe formula here is that the amortized\ncost of an operation",
    "start": "1167600",
    "end": "1178660"
  },
  {
    "text": "is the actual cost plus the\ndeposits minus the withdrawals.",
    "start": "1178660",
    "end": "1195960"
  },
  {
    "start": "1195960",
    "end": "1203341"
  },
  {
    "text": "OK. So insertion, we\njust double the cost, because we pay log\nn to the real thing, we pay log n to store the coin.",
    "start": "1203341",
    "end": "1211270"
  },
  {
    "text": "That's the plus deposit\npart, so insertion remains log n, and then deletion, we\npay log n to do the deletion,",
    "start": "1211270",
    "end": "1218360"
  },
  {
    "text": "but then we subtract off\nthe coin of value log n,",
    "start": "1218360",
    "end": "1223470"
  },
  {
    "text": "so that hopefully\nworks out to zero 0. But, again, we have this\nissue that coins actually",
    "start": "1223470",
    "end": "1228970"
  },
  {
    "text": "have different amounts,\ndepending on what the current value of n was.",
    "start": "1228970",
    "end": "1234669"
  },
  {
    "text": "You can actually get\nthis to work if you say, well, there are coins\nof varying values here,",
    "start": "1234670",
    "end": "1242690"
  },
  {
    "text": "and I think the\ninvariant is if you have a current\nstructure of size n, you will have one coin of size\nlog 1, log 2, log 3, log 4,",
    "start": "1242690",
    "end": "1250470"
  },
  {
    "text": "up to log n. Each coin corresponds to the\nitem that made n that value.",
    "start": "1250470",
    "end": "1256870"
  },
  {
    "text": "And so when you delete\nan item at size n, you'll be removing the log nth\ncoin, the coin of value log n.",
    "start": "1256870",
    "end": "1264450"
  },
  {
    "text": "So you can actually get this\nto work if you're careful. ",
    "start": "1264450",
    "end": "1270019"
  },
  {
    "text": "I guess the invariant is one\ncoin of value log i for i",
    "start": "1270020",
    "end": "1284430"
  },
  {
    "text": "equals 1 to n, and you can\ncheck that invariant holds.",
    "start": "1284430",
    "end": "1291140"
  },
  {
    "text": "When I do a new insertion,\nI increase n by 1 and I make a new coin\nof log that value. When I do a deletion,\nI'm going to remove",
    "start": "1291140",
    "end": "1298460"
  },
  {
    "text": "that last coin of log n. So this does work out.",
    "start": "1298460",
    "end": "1303470"
  },
  {
    "text": "So we got rid of the end star. OK, let's use this same method\nto analyze table doubling.",
    "start": "1303470",
    "end": "1312058"
  },
  {
    "text": "We already know why\ntable doubling works, but good to think of it\nfrom different perspectives.",
    "start": "1312058",
    "end": "1317179"
  },
  {
    "start": "1317180",
    "end": "1326530"
  },
  {
    "text": "And it's particularly\nfun to think of the coins as being physical objects\nin the data structure. I always thought it would fun\nto put this in a programming",
    "start": "1326530",
    "end": "1333855"
  },
  {
    "text": "language, but I\ndon't think there is a programming language that\nhas coins in it in this sense",
    "start": "1333855",
    "end": "1340290"
  },
  {
    "text": "yet. Maybe you can fix that. So let's go back\nto table doubling. ",
    "start": "1340290",
    "end": "1365630"
  },
  {
    "text": "Let's say when we insert\nan item into a table, and here I'm just\ngoing to do insertions.",
    "start": "1365630",
    "end": "1373420"
  },
  {
    "text": "We'll worry about\ndeletions in a moment. ",
    "start": "1373420",
    "end": "1378630"
  },
  {
    "text": "Whenever I do an\ninsertion, I'm going to put a coin on that item,\nand the value of the coin",
    "start": "1378630",
    "end": "1387440"
  },
  {
    "text": "is going to be a constant. I going to give the constant a\nname so we can be a little more precise in a moment-- c.",
    "start": "1387440",
    "end": "1395910"
  },
  {
    "text": "So here's kind of the typical--\nwell, here's an array.",
    "start": "1395910",
    "end": "1403240"
  },
  {
    "text": "We start with an\narray of size 1, and we insert a single item\nhere, and we put a coin on it.",
    "start": "1403240",
    "end": "1410692"
  },
  {
    "text": "Maybe I'll draw the coin in\na color, which I've lost.",
    "start": "1410692",
    "end": "1416196"
  },
  {
    "text": "Here.  So I insert some item x, and\nI put a coin on that item.",
    "start": "1416196",
    "end": "1425540"
  },
  {
    "text": " When I do the next\ninsertion, let's say I have to double\nthe table to size 2.",
    "start": "1425540",
    "end": "1433100"
  },
  {
    "text": "I'm going to use\nup that coin, so erase it, put a new coin on\nthe item that I just put down.",
    "start": "1433100",
    "end": "1440120"
  },
  {
    "text": "Call it y. In general-- so the next time\nI double, which is immediately,",
    "start": "1440120",
    "end": "1447520"
  },
  {
    "text": "I'm going to go to size 4. I erase this coin,\nthen I put a coin here.",
    "start": "1447520",
    "end": "1455550"
  },
  {
    "text": "When I insert item, of\ncourse, letter after z is w. Then I put another coin\nwhen I have to double again,",
    "start": "1455550",
    "end": "1463670"
  },
  {
    "text": "so here I'm going to use\nthese coins to charge",
    "start": "1463670",
    "end": "1469490"
  },
  {
    "text": "for the doubling, and\nthen in the next round, I'm going to be\ninserting here, here,",
    "start": "1469490",
    "end": "1474900"
  },
  {
    "text": "and here, and I'll be\nputting a coin here, here, here, and here.",
    "start": "1474900",
    "end": "1480110"
  },
  {
    "text": "In general, you start\nto see the pattern-- so I used up these\nguys-- that by the time",
    "start": "1480110",
    "end": "1485640"
  },
  {
    "text": "I have to double again, half\nof the items have coins, the other half don't,\nbecause I already used them.",
    "start": "1485640",
    "end": "1492081"
  },
  {
    "text": "You have to be careful not to\nuse a coin twice, because you only get to use it once. You can't divide money\ninto double money",
    "start": "1492082",
    "end": "1499690"
  },
  {
    "text": "unless you're doing\nstocks, I guess.  As soon as I get to a place\nwhere the array is completely",
    "start": "1499690",
    "end": "1507060"
  },
  {
    "text": "full when n equals m, the\nlast half of the items will have coins. I'm going to use them in\norder to pay for the doubling,",
    "start": "1507060",
    "end": "1514100"
  },
  {
    "text": "so the number of coins\nhere will be n over 2.",
    "start": "1514100",
    "end": "1519929"
  },
  {
    "text": "So this is why I wanted\nto make this constant a little explicit, because\nit has to be bigger than 2",
    "start": "1519930",
    "end": "1526140"
  },
  {
    "text": "in some sense. However much work-- let's say\nit takes a times n work in order",
    "start": "1526140",
    "end": "1531300"
  },
  {
    "text": "to do doubling,\nthen this constant should be something\nlike two times a, because I need to do\nthe work to double,",
    "start": "1531300",
    "end": "1538200"
  },
  {
    "text": "but I only have n over\n2 coins to pay for it. I don't get coins over here.",
    "start": "1538200",
    "end": "1544640"
  },
  {
    "text": "So when we double, the last\nn over 2 items have coins,",
    "start": "1544640",
    "end": "1561710"
  },
  {
    "text": "and so the amortized cost\nof the doubling operation",
    "start": "1561710",
    "end": "1575770"
  },
  {
    "text": "is going to be the\nreal cost, which is sum theta n minus the\nnumber of coins I can remove",
    "start": "1575770",
    "end": "1583130"
  },
  {
    "text": "and their value. So it's going to be\nminus c times n over 2",
    "start": "1583130",
    "end": "1589070"
  },
  {
    "text": "and, the point is, this\nis 0 if we set c large.",
    "start": "1589070",
    "end": "1595110"
  },
  {
    "text": "It only has to be a constant. It needs to be bigger than\n2 times that constant.",
    "start": "1595110",
    "end": "1601150"
  },
  {
    "text": "And usually when you're\nworking with coins, you want to make the\nconstants explicit just to make sure there's no circular\ndependence on constants,",
    "start": "1601150",
    "end": "1607640"
  },
  {
    "text": "make sure there is a valid\nchoice of c that annihilates",
    "start": "1607640",
    "end": "1613000"
  },
  {
    "text": "whatever cost you\nwant to get rid of. So this is the accounting\nmethod view of table doubling.",
    "start": "1613000",
    "end": "1622710"
  },
  {
    "text": "Any questions so far?  So far so good.",
    "start": "1622710",
    "end": "1627870"
  },
  {
    "text": "Pretty simple example. Let's get to more\ninteresting examples.",
    "start": "1627870",
    "end": "1633780"
  },
  {
    "text": "You also think about the\namortized cost of an insert. It costs constant real time. Actual cost is constant.",
    "start": "1633780",
    "end": "1639570"
  },
  {
    "text": "You have to also\ndeposit one coin, which costs constant time so the\namortized cost of the insert is still constant.",
    "start": "1639570",
    "end": "1645850"
  },
  {
    "text": "So that's good. Still we don't know how\nto deal with deletions,",
    "start": "1645850",
    "end": "1652170"
  },
  {
    "text": "but let me give you a kind\nof reverse perspective on the accounting method.",
    "start": "1652170",
    "end": "1659751"
  },
  {
    "text": " It's, again, equivalent\nin a certain sense,",
    "start": "1659751",
    "end": "1665620"
  },
  {
    "text": "but in another sense\nmay be more intuitive some of the time\nfor some people.",
    "start": "1665620",
    "end": "1671110"
  },
  {
    "text": "It's actually not\nin the textbook, but it's the one I\nuse the most so I figure it's worth teaching.",
    "start": "1671110",
    "end": "1678350"
  },
  {
    "text": "It's called the charging method.  It's also a little bit more\ntime travel-y, if you will,",
    "start": "1678350",
    "end": "1686510"
  },
  {
    "text": "so if you like time travel,\nthis method is for you,",
    "start": "1686510",
    "end": "1691710"
  },
  {
    "text": "or maybe a more\npessimistic view is blaming the past for your mistakes.",
    "start": "1691710",
    "end": "1697560"
  },
  {
    "text": "So what we're going\nto do is allow--",
    "start": "1697560",
    "end": "1703060"
  },
  {
    "text": "there's no bank balance anymore,\nalthough it's essentially there. We're going to allow operations\nto charge some of their cost",
    "start": "1703060",
    "end": "1715090"
  },
  {
    "text": "retroactively to the\npast, not the future.",
    "start": "1715090",
    "end": "1728616"
  },
  {
    "text": "I actually have a\ndata structures paper which proves that while\ntime travel to the past is plausible, time travel to the\nfuture is not computationally.",
    "start": "1728616",
    "end": "1735670"
  },
  {
    "text": "So you're not allowed to\ntime travel to the future, only allowed to go to the\npast, and say, hey, give me $5.",
    "start": "1735670",
    "end": "1742627"
  },
  {
    "text": " But you've got to be a little\nbit conservative in how",
    "start": "1742628",
    "end": "1748710"
  },
  {
    "text": "you do it. You can't just keep charging the\nsame operation a million times, because then the cost of\nthat operation is going up.",
    "start": "1748710",
    "end": "1755450"
  },
  {
    "text": "At the end of the\nday, every operation had to have paid for\nits total charge. So there's the actual\ncost, which it starts with,",
    "start": "1755450",
    "end": "1762740"
  },
  {
    "text": "and then there's whatever it's\nbeing charged by the future. So from an analysis\nperspective, you're thinking about the future.",
    "start": "1762740",
    "end": "1767933"
  },
  {
    "text": "What could\npotentially charge me? Again, you can define the\namortized cost of an operation",
    "start": "1767933",
    "end": "1778830"
  },
  {
    "text": "is going to be the actual\ncost minus the total charge",
    "start": "1778830",
    "end": "1788330"
  },
  {
    "text": "to the past.  So when we charge\nto the past, we",
    "start": "1788330",
    "end": "1794320"
  },
  {
    "text": "get free dollars in\nthe present, but we have to pay for whatever\nthe future is going to do.",
    "start": "1794320",
    "end": "1800623"
  },
  {
    "text": " So we have to imagine\nhow many times could I",
    "start": "1800624",
    "end": "1806730"
  },
  {
    "text": "get charged in the future? I'm going to have to pay for\nthat now in a consistent time line.",
    "start": "1806730",
    "end": "1812150"
  },
  {
    "text": "You will have to have paid for\nthings that come in the future. ",
    "start": "1812150",
    "end": "1817690"
  },
  {
    "text": "So let's do an example. Actually it sounds\ncrazy and weird, but I actually find this\na lot more intuitive",
    "start": "1817690",
    "end": "1823560"
  },
  {
    "text": "to think about even\nthese very examples. ",
    "start": "1823560",
    "end": "1829560"
  },
  {
    "text": "Let's start with table doubling. ",
    "start": "1829560",
    "end": "1858610"
  },
  {
    "text": "So we have this kind\nof picture already. It's going to be\npretty much the same.",
    "start": "1858610",
    "end": "1865200"
  },
  {
    "text": "After I've doubled the\ntable, my array is half full",
    "start": "1865200",
    "end": "1870519"
  },
  {
    "text": "and, again, insertion only,\nalthough we'll insertion and deletion in the moment.",
    "start": "1870520",
    "end": "1876080"
  },
  {
    "text": "In order to get from half\nfull to completely full, I have to do n\nover 2 insertions.",
    "start": "1876080",
    "end": "1883074"
  },
  {
    "text": "It's looking very similar,\nbut what I'm going to say is that when I double\nthe array next time,",
    "start": "1883074",
    "end": "1891440"
  },
  {
    "text": "I'm going to charge that\ndoubling to those operations. ",
    "start": "1891440",
    "end": "1899340"
  },
  {
    "text": "In general, you can actually say\nthis quite concisely-- whenever I do a doubling\noperation, I'm going",
    "start": "1899340",
    "end": "1905920"
  },
  {
    "text": "to charge it to\nall the insertions",
    "start": "1905920",
    "end": "1913740"
  },
  {
    "text": "since the last doubling. ",
    "start": "1913740",
    "end": "1921560"
  },
  {
    "text": "That's a very\nclear set of items. Doublings happen, and then they\ndon't happen for a while, just",
    "start": "1921560",
    "end": "1926909"
  },
  {
    "text": "all those insertions\nthat happened since the last doubling\ncharged to them. And how many are there?",
    "start": "1926910",
    "end": "1933009"
  },
  {
    "text": "Well, as we've argued,\nthere are n over 2 of them, and the cost of-- in order\nto make this doubling free,",
    "start": "1933010",
    "end": "1942460"
  },
  {
    "text": "I need to charge theta n. So this doubling cost\ntheta n, but there's",
    "start": "1942460",
    "end": "1949660"
  },
  {
    "text": "n over things to charge to. I'm going to uniformly\ndistribute my charge to them, which\nmeans I'm charging",
    "start": "1949660",
    "end": "1957510"
  },
  {
    "text": "a constant amount to each. And the key fact here is that\nI only charge an insert once.",
    "start": "1957510",
    "end": "1969420"
  },
  {
    "text": "Because of this\nsince clause, I never will charge an\nitem twice as long",
    "start": "1969420",
    "end": "1974620"
  },
  {
    "text": "as I'm only inserting for now. ",
    "start": "1974620",
    "end": "1982140"
  },
  {
    "text": "If you look over all\ntime, you will only charge an insert once. ",
    "start": "1982140",
    "end": "1988200"
  },
  {
    "text": "That's good, because\nthe inserts have to pay for their total\ncharge in the future. There's only one charge, and\nit's only a constant amount,",
    "start": "1988200",
    "end": "1995110"
  },
  {
    "text": "then amortized cost\nof insert is still constant, amortized\ncost of doubling is 0, because we charged the\nentire cost to the past.",
    "start": "1995110",
    "end": "2003970"
  },
  {
    "text": "So same example, but slightly\ndifferent perspective. Let's do a more interesting\nexample-- inserts and deletes",
    "start": "2003970",
    "end": "2015770"
  },
  {
    "text": "in a table. ",
    "start": "2015770",
    "end": "2049638"
  },
  {
    "text": "Let' say I want to maintain\nthat the size of the table is always within a constant\nfactor of the number of items",
    "start": "2049638",
    "end": "2057690"
  },
  {
    "text": "currently in the table. If I just want an upper bound,\nthen I only need to double,",
    "start": "2057690",
    "end": "2062780"
  },
  {
    "text": "but if I want also\na lower bound-- if I don't want the\ntable to be too empty, then I need to\nadd table halving.",
    "start": "2062780",
    "end": "2071419"
  },
  {
    "text": "So what I'm going to do is\nwhen the table is 100% full, I double its size, when\nthe table is 50% full,",
    "start": "2071420",
    "end": "2082539"
  },
  {
    "text": "should I halve it in size? Would that work? ",
    "start": "2082540",
    "end": "2087579"
  },
  {
    "text": "No, because-- AUDIENCE: [INAUDIBLE]\nhave to have it inserted",
    "start": "2087580",
    "end": "2093610"
  },
  {
    "text": "in place of linear [INAUDIBLE]. ERIK DEMAINE: Right. I can basically do insert,\ndelete, insert, delete, insert,",
    "start": "2093610",
    "end": "2100620"
  },
  {
    "text": "delete, and every\nsingle operation costs linear time, because maybe\nI'm a little bit less than half full-- sorry, yeah, if\nI'm a little bit less than half",
    "start": "2100620",
    "end": "2110530"
  },
  {
    "text": "full, then I'm going to\nshrink the array into half. Get rid of this part, then\nif I immediately insert,",
    "start": "2110530",
    "end": "2118190"
  },
  {
    "text": "it becomes 100% full again. I have to double in size,\nand then if I delete, it becomes less than half full,\nand I have to halve in size.",
    "start": "2118190",
    "end": "2124970"
  },
  {
    "text": "Every operation would\ncost linear time, so amortized cost\nis linear time. That's not good.",
    "start": "2124970",
    "end": "2130700"
  },
  {
    "text": "So what I'll do is just separate\nthose constants a little bit.",
    "start": "2130700",
    "end": "2137020"
  },
  {
    "text": "When I'm 100% full,\nI will double. That seems pretty\nclear, but let's say when I'm a quarter\nfull, then I will halve.",
    "start": "2137020",
    "end": "2144910"
  },
  {
    "text": "Any value less than 50 would\nwork here, but-- just halve,",
    "start": "2144910",
    "end": "2152735"
  },
  {
    "text": "like that. This will actually work. This will be constant\namortized per operation,",
    "start": "2152736",
    "end": "2158780"
  },
  {
    "text": "but it's-- especially the\ninitial analysis we did of table doubling isn't\ngoing to work here,",
    "start": "2158780",
    "end": "2163790"
  },
  {
    "text": "because it's complicated. The thing's going to\nshrink and grow over time.",
    "start": "2163790",
    "end": "2169589"
  },
  {
    "text": "Just summing that is not easy. It depends on the\nsequence of operations, but with charging\nand also with coins,",
    "start": "2169590",
    "end": "2176250"
  },
  {
    "text": "we could do it in\na pretty clean way. I'm going to do\nit with charging. ",
    "start": "2176250",
    "end": "2183740"
  },
  {
    "text": "So this particular\nchoice of constants is nice, because when I double\na full array, it's half full,",
    "start": "2183740",
    "end": "2193172"
  },
  {
    "text": "and also when I\nhave an array that's a quarter full, like this,\nand then I divide it--",
    "start": "2193172",
    "end": "2204080"
  },
  {
    "text": "and then I shrink it--\nI get rid of this part, it's also half full.",
    "start": "2204080",
    "end": "2210410"
  },
  {
    "text": "So whenever I do a\ndouble or a halve, the new array is half full, 50%.",
    "start": "2210410",
    "end": "2217240"
  },
  {
    "text": "That's nice. ",
    "start": "2217240",
    "end": "2224150"
  },
  {
    "text": "That's nice, because 50% is far\naway from both 25% and 100%. ",
    "start": "2224150",
    "end": "2235510"
  },
  {
    "text": "So our nice state is right\nafter a doubling or a halve, then we know that\nour structure is 50%.",
    "start": "2235510",
    "end": "2242740"
  },
  {
    "text": "In order to get to an\nunder-flowing state where we have to halve, I have\nto delete at least a quarter",
    "start": "2242740",
    "end": "2248490"
  },
  {
    "text": "of the items, a quarter of m. In order to get to overflowing\nwhere I have to double,",
    "start": "2248490",
    "end": "2257430"
  },
  {
    "text": "I have to insert at\nleast m over 2 items. Either way, a constant\nfraction times m, that's",
    "start": "2257430",
    "end": "2263329"
  },
  {
    "text": "what I'm going to charge to. Now, to be clear,\nwhen I'm 50% full,",
    "start": "2263330",
    "end": "2268650"
  },
  {
    "text": "I might insert, delete, insert,\ndelete, many different inserts and deletes. At some point, one\nof these two things",
    "start": "2268650",
    "end": "2274180"
  },
  {
    "text": "is going to happen though. In order to get here, I have to\ndo at least m over 4 deletions.",
    "start": "2274180",
    "end": "2280000"
  },
  {
    "text": "I might also do more\ninsertions and deletions, but I have to do\nat least that many, and those are the ones\nI'm going to charge to.",
    "start": "2280000",
    "end": "2285790"
  },
  {
    "text": "So I'm going to charge\na halving operation",
    "start": "2285790",
    "end": "2296740"
  },
  {
    "text": "to the at least m\nover 4 deletions",
    "start": "2296740",
    "end": "2304660"
  },
  {
    "text": "since the last resize of either\ntype, doubling or halving.",
    "start": "2304660",
    "end": "2312869"
  },
  {
    "text": "And I'm going to\ncharge the doubling",
    "start": "2312870",
    "end": "2317930"
  },
  {
    "text": "to the at least m\nover 2 insertions",
    "start": "2317930",
    "end": "2324960"
  },
  {
    "text": "since the last resize. ",
    "start": "2324960",
    "end": "2333950"
  },
  {
    "text": "OK, and that's it. Because the halving costs\ntheta m time, doubling costs",
    "start": "2333950",
    "end": "2339680"
  },
  {
    "text": "theta m time, I have theta\nm operations to charge to, so I'm only charging constant\nfor each of the operations.",
    "start": "2339680",
    "end": "2347730"
  },
  {
    "text": "And because of this\nsince last resize clause, it's clear that you're never\ncharging an operation more",
    "start": "2347730",
    "end": "2353950"
  },
  {
    "text": "than once, because\nyou can divide time by when the resizes happen,\ngrows or shrinks, halves",
    "start": "2353950",
    "end": "2361540"
  },
  {
    "text": "or doubles. And each resize is only charging\nto the past a window of time.",
    "start": "2361540",
    "end": "2368030"
  },
  {
    "text": "So it's like you have epics\nof time, you separate them, you only charge\nwithin your epic.",
    "start": "2368030",
    "end": "2373570"
  },
  {
    "text": "OK, so that's cool. So you only get\na constant number of charges per item\nof a constant amount,",
    "start": "2373570",
    "end": "2380974"
  },
  {
    "text": "therefore insertions\nand deletions are constant amortized. Halving and doubling\nis free amortized.",
    "start": "2380974",
    "end": "2387660"
  },
  {
    "text": "Clear? This is where amortization\nstarts to get interesting. ",
    "start": "2387660",
    "end": "2395710"
  },
  {
    "text": "You can also think of this\nexample in terms of coins, but with putting\ncoins on the items,",
    "start": "2395710",
    "end": "2402820"
  },
  {
    "text": "but then you have to think\nabout the invariance of where the coins are, which I\nfind to be more work.",
    "start": "2402820",
    "end": "2408070"
  },
  {
    "text": "We actually had\nto do it up here. I was claiming the last\nhalf of the items had coins. You have to prove that really.",
    "start": "2408070",
    "end": "2414220"
  },
  {
    "text": "With this method, you don't. I mean, what you have to prove\nis that there are enough things",
    "start": "2414220",
    "end": "2419680"
  },
  {
    "text": "to charge to. We had to prove here that\nthere were n over 2 items to charge to. Kind of the same thing,\nbut it was very clear",
    "start": "2419680",
    "end": "2425260"
  },
  {
    "text": "that you weren't charging to\nthe same thing more than once. You were never trying to\nuse a coin that wasn't there",
    "start": "2425260",
    "end": "2430840"
  },
  {
    "text": "because of the since clause. To each their own.",
    "start": "2430840",
    "end": "2436000"
  },
  {
    "text": "I think either way would work. ",
    "start": "2436000",
    "end": "2445790"
  },
  {
    "text": "I think I will\nskip this example, but I'll just mention it. So for 2-3 trees, we\nsaid deletions were free,",
    "start": "2445790",
    "end": "2454270"
  },
  {
    "text": "and we did that with\nthe coin invariant, that there was one coin\nof size log i for each i.",
    "start": "2454270",
    "end": "2459880"
  },
  {
    "text": "You could instead say,\nwhen I delete an item, I'm going to charge\nit to the insert that made n this current value,\nbecause that insert paid",
    "start": "2459880",
    "end": "2470900"
  },
  {
    "text": "log n the actual\ncost, so it can afford to pay another log n\nto pay for the deletion of some other item, the one\nwe're currently deleting.",
    "start": "2470900",
    "end": "2479319"
  },
  {
    "text": "And that works, that you don't\ndouble charge to an insert, because you're\ndecreasing n right now.",
    "start": "2479320",
    "end": "2485950"
  },
  {
    "text": "So for n to get up\nto that value again, you would have had\nto do another insert. So same thing, slightly\ndifferent perspective.",
    "start": "2485950",
    "end": "2493569"
  },
  {
    "text": "Let's go to something\neven more interesting and in some sense more powerful,\nthe last method on the list,",
    "start": "2493570",
    "end": "2499849"
  },
  {
    "text": "which is potential method. ",
    "start": "2499850",
    "end": "2525310"
  },
  {
    "text": "This is a good exercise in how\nmany ways can you skin a cat? ",
    "start": "2525310",
    "end": "2531940"
  },
  {
    "text": "So potential method, I like\nto call it defining karma",
    "start": "2531940",
    "end": "2538030"
  },
  {
    "text": "in a formal way, is more\nlike the counting strategy.",
    "start": "2538030",
    "end": "2544080"
  },
  {
    "text": "We're going to think\nabout there being a bank account with some\nbalance, but we're going to define that balance\nas a function of the data",
    "start": "2544080",
    "end": "2551560"
  },
  {
    "text": "structure state. So that's called the\npotential function,",
    "start": "2551560",
    "end": "2566329"
  },
  {
    "text": "but you can think of\nit as a bank balance. You can think of it as\nkinetic potential, I guess.",
    "start": "2566330",
    "end": "2572243"
  },
  {
    "text": " Potential energy. ",
    "start": "2572243",
    "end": "2597030"
  },
  {
    "text": "Just like the bank account, we\nwant this function to always be non-negative.",
    "start": "2597030",
    "end": "2602760"
  },
  {
    "text": "We'll also make it an integer.  That would be convenient.",
    "start": "2602760",
    "end": "2607815"
  },
  {
    "start": "2607815",
    "end": "2613002"
  },
  {
    "text": "The potential\nfunction is basically trying to measure how bad is\nthe data structure right now?",
    "start": "2613002",
    "end": "2619240"
  },
  {
    "text": "It's, again, like saving\nup for a rainy day. We want that whenever we have\nto do an expensive operation, like a double or halve, that\nthis potential has grown",
    "start": "2619240",
    "end": "2628970"
  },
  {
    "text": "large enough that we\ncan charge that cost to a decrease in the potential.",
    "start": "2628970",
    "end": "2634340"
  },
  {
    "text": "So it's like this is\nstoring up energy, and whenever we\nhave some free time,",
    "start": "2634340",
    "end": "2639420"
  },
  {
    "text": "we'll give some of that time\nto the potential function. It's just like the accounting\nmethod, in a certain sense,",
    "start": "2639420",
    "end": "2645720"
  },
  {
    "text": "but we're defining\nthings differently. Over here, we explicitly\nsaid, hey look, I'm going to store some\ncredit right now.",
    "start": "2645720",
    "end": "2652330"
  },
  {
    "text": "So we were basically\nspecifying the delta, and here we're saying I'm going\nto consume some credit right",
    "start": "2652330",
    "end": "2657480"
  },
  {
    "text": "now. Over here, we're going to\ndefine this magical function of the current state.",
    "start": "2657480",
    "end": "2662560"
  },
  {
    "text": "From that you can compute the\ndeltas, but also from here you can integrate and compute\nthe potential function.",
    "start": "2662560",
    "end": "2667760"
  },
  {
    "text": "So they're interchangeable,\nbut usually it's easier to think about one\nperspective or the other. Really often, you can\njust look at what's",
    "start": "2667760",
    "end": "2674352"
  },
  {
    "text": "going on with the data\nstructure and say, hey, you know, this aspect\nof the data structure",
    "start": "2674352",
    "end": "2680590"
  },
  {
    "text": "makes it bad, makes\ncostly operations, and you can just define\nthe potential function,",
    "start": "2680590",
    "end": "2685760"
  },
  {
    "text": "then just check that it works. But it's a little\nbit of black magic to come up with these\nfunctions, so you depends how",
    "start": "2685760",
    "end": "2692584"
  },
  {
    "text": "you like to think about things.  So, as before, we can\ndefine an amortized cost.",
    "start": "2692584",
    "end": "2701040"
  },
  {
    "text": " It's going to be the\nactual cost plus the change",
    "start": "2701040",
    "end": "2710377"
  },
  {
    "text": "in the potential. ",
    "start": "2710377",
    "end": "2716330"
  },
  {
    "text": "So change of potential\nis just the potential",
    "start": "2716330",
    "end": "2721540"
  },
  {
    "text": "after the operation minus the\npotential before the operation.",
    "start": "2721540",
    "end": "2729160"
  },
  {
    "start": "2729160",
    "end": "2741869"
  },
  {
    "text": "I highlight that, and it's\nkind of obvious from the way",
    "start": "2741870",
    "end": "2748100"
  },
  {
    "text": "we set things up, but\nwhat I care about is the sum of the amortized costs.",
    "start": "2748100",
    "end": "2754734"
  },
  {
    "text": "I care about that,\nbecause it's supposed to be an upper bound on the\nsum of the actual costs.",
    "start": "2754734",
    "end": "2760630"
  },
  {
    "text": "And if you just look\nat what that sum is, on the right-hand\nside I have amortized cost plus the fee after\nthe operation minus the fee",
    "start": "2760630",
    "end": "2768640"
  },
  {
    "text": "before the operation. If I add all those up,\nthis part telescopes",
    "start": "2768640",
    "end": "2775100"
  },
  {
    "text": "or you get cancellation\nfrom each term with the previous term. The sum of the\namortized costs is",
    "start": "2775100",
    "end": "2788079"
  },
  {
    "text": "equal to the sum of the\nactual costs plus phi",
    "start": "2788080",
    "end": "2801970"
  },
  {
    "text": "at the end minus phi\nat the beginning.",
    "start": "2801970",
    "end": "2807640"
  },
  {
    "text": " So a slight catch with\nthe potential method.",
    "start": "2807640",
    "end": "2814400"
  },
  {
    "text": "When you define things\nthis way, you also have to pay for phi\nat the beginning,",
    "start": "2814400",
    "end": "2821930"
  },
  {
    "text": "because we want the actual cost\nto be, at most, amortized cost. So we need to take this\napart and put it over here",
    "start": "2821930",
    "end": "2828880"
  },
  {
    "text": "so it's, at most,\nsome of amortized cost plus phi of the beginning. ",
    "start": "2828880",
    "end": "2835549"
  },
  {
    "text": "This part becomes negative,\nso we usually just ignore it. It can only help us.",
    "start": "2835550",
    "end": "2842250"
  },
  {
    "text": "So when you define a\npotential function, you'd really like it to\nbe 0 at the beginning. ",
    "start": "2842250",
    "end": "2854150"
  },
  {
    "text": "It's funny, but you pay\nphi of the beginning state at the beginning of time, and\nwhen you've done 0 operations,",
    "start": "2854150",
    "end": "2861460"
  },
  {
    "text": "you really like\nthe cost to be 0, and you don't want to\nhave to have stored stuff",
    "start": "2861460",
    "end": "2866770"
  },
  {
    "text": "in the bank, so this should\nbe a-- constant would probably",
    "start": "2866770",
    "end": "2872560"
  },
  {
    "text": "be OK, or whatever the cost\nof your first operation is but should be constant or 0.",
    "start": "2872560",
    "end": "2878650"
  },
  {
    "text": "Usually we do this\nby saying, look, let's start with an empty\nstructure and work from there. Usually phi of an\nempty structure is 0,",
    "start": "2878650",
    "end": "2885550"
  },
  {
    "text": "and all is well. So when you're defining things\nwith potential function, you have to be careful\nabout your initial state.",
    "start": "2885550",
    "end": "2892039"
  },
  {
    "text": "You have to make sure\nit's non-negative just like you did\nover here, but you didn't have to worry about\nthis part over there.",
    "start": "2892040",
    "end": "2899460"
  },
  {
    "text": "All this infrastructure,\nwhat's it good for? Let's do some examples.",
    "start": "2899460",
    "end": "2904700"
  },
  {
    "text": "These are going to be the\nmost interesting examples. ",
    "start": "2904700",
    "end": "2933369"
  },
  {
    "text": "A kind of classic\nexample of amortization is incrementing\na binary counter.",
    "start": "2933370",
    "end": "2938780"
  },
  {
    "text": "So when you have some\nbinary value like this one",
    "start": "2938780",
    "end": "2944650"
  },
  {
    "text": "and you increment\nit, many bits change,",
    "start": "2944650",
    "end": "2954181"
  },
  {
    "text": "but only a constant\nnumber are going to change in an amortized sense. If I start with a 0\nvector, 0 bit vector,",
    "start": "2954181",
    "end": "2960710"
  },
  {
    "text": "and I increment-- well, the\nvery first increment costs 1, the next increment costs 2,\nthe next increment costs 1,",
    "start": "2960710",
    "end": "2967200"
  },
  {
    "text": "next increment costs 3, then\n1, then 2, then 1, then 4, then it's a fractal.",
    "start": "2967200",
    "end": "2974160"
  },
  {
    "text": "But instead of thinking\nabout that fractal and working hard to\nprove that summation",
    "start": "2974160",
    "end": "2979330"
  },
  {
    "text": "is linear for an operation,\nlet's use the potential method.",
    "start": "2979330",
    "end": "2985650"
  },
  {
    "text": "And the intuition here\nis actually pretty easy, because an increment\nhas a very clear cost.",
    "start": "2985650",
    "end": "2996170"
  },
  {
    "text": "It's just the number\nof trailing 1s plus 1. ",
    "start": "2996170",
    "end": "3011390"
  },
  {
    "text": "That's what it is\nin actual cost. We'd like that to be\nconstant so, intuitively,",
    "start": "3011390",
    "end": "3018030"
  },
  {
    "text": "what is making an increment bad? If you had to name one thing? ",
    "start": "3018030",
    "end": "3027970"
  },
  {
    "text": "If I just look at a\nconfiguration, is this bad? Is this bad?",
    "start": "3027970",
    "end": "3033480"
  },
  {
    "text": "How bad is the configuration? Yeah. AUDIENCE: The more\ntrailing ones you have, the worse the state is? ERIK DEMAINE: The more trailing\nones, the worse the state is.",
    "start": "3033480",
    "end": "3040801"
  },
  {
    "text": "So that's one\nnatural definition. Turns out, it won't work. Let's see why. ",
    "start": "3040801",
    "end": "3047320"
  },
  {
    "text": "I think here's an example.  So near the end of\nour increment stage,",
    "start": "3047320",
    "end": "3053880"
  },
  {
    "text": "we have a whole bunch of\n1s but no trailing 1s, number of trailing 1s is 0. If I do a single increment, now\nthe number of trailing 1s is n,",
    "start": "3053880",
    "end": "3063670"
  },
  {
    "text": "so if you look at\nthe amortized cost, it's the actual cost\nplus the change in phi",
    "start": "3063670",
    "end": "3069700"
  },
  {
    "text": "and so I actually pay\nn for that operation in the amortized sense,\nand that's no good. We only want to pay constant,\nbut it's on the right track.",
    "start": "3069700",
    "end": "3077430"
  },
  {
    "text": "So number of trailing 1, it\nis the natural thing to try, but it doesn't quite work\nfor our definition of phi.",
    "start": "3077430",
    "end": "3086250"
  },
  {
    "text": "Other ideas? Yeah. AUDIENCE: The total\nnumber of [INAUDIBLE]",
    "start": "3086250",
    "end": "3091818"
  },
  {
    "text": "ERIK DEMAINE: The\ntotal number of 1s. Yeah. Let's define phi, could\nbe the number of 1 bits.",
    "start": "3091819",
    "end": "3100130"
  },
  {
    "text": "That will work, but\nyou both get a Frisbee.",
    "start": "3100130",
    "end": "3105500"
  },
  {
    "text": " AUDIENCE: Oh, [INAUDIBLE]. ERIK DEMAINE: Sorry.",
    "start": "3105500",
    "end": "3111325"
  },
  {
    "text": "Good thing I missed.  Number 1 bits. Intuitively, 1s are bad, and\nthis is a good definition,",
    "start": "3111325",
    "end": "3122150"
  },
  {
    "text": "because when I increment\nI only create one 1, so I'm not going to have this\nissue that delta phi goes up",
    "start": "3122150",
    "end": "3129559"
  },
  {
    "text": "by a lot-- sorry, that\nphi goes up by a lot, that delta phi is really large. Because even in this\nscenario, if I increment,",
    "start": "3129560",
    "end": "3136400"
  },
  {
    "text": "I only add one 1. In this scenario, I destroy\nthree 1s and add one.",
    "start": "3136400",
    "end": "3143370"
  },
  {
    "text": "In general, if there are,\nlet's say, t trailing bits,",
    "start": "3143370",
    "end": "3151070"
  },
  {
    "text": "then an increment destroys t 1\nbits, and it creates one 1 bit.",
    "start": "3151070",
    "end": "3166660"
  },
  {
    "text": " That's always what happens.",
    "start": "3166660",
    "end": "3172860"
  },
  {
    "text": "T could be 0, and then I\nhave a net positive of 1, but most of the time actually\nI destroy 1 bits-- well,",
    "start": "3172860",
    "end": "3180180"
  },
  {
    "text": "more than half the\ntime I destroy 1 bits, and I just create a\nsingle 1 bit, in terms of the total number of 1s.",
    "start": "3180180",
    "end": "3186560"
  },
  {
    "text": "So the amortized cost\nis the actual cost,",
    "start": "3186560",
    "end": "3198280"
  },
  {
    "text": "which is this 1 plus t. ",
    "start": "3198280",
    "end": "3203920"
  },
  {
    "text": "I'm actually going to\nremove the-- well, yeah. I'd like to remove\nthe big O if I could.",
    "start": "3203920",
    "end": "3211786"
  },
  {
    "text": "I'm going to\ncount-- I want to be a little bit precise\nabout my counting, because I have to do\na minus sign here.",
    "start": "3211786",
    "end": "3218340"
  },
  {
    "text": "If I just wrote minus\nt, that doesn't quite work out, because\nthere's a constant here that I have to annihilate.",
    "start": "3218340",
    "end": "3224790"
  },
  {
    "text": "If I count the number\nof bits that change, then that's exactly 1\nplus t in an increment.",
    "start": "3224790",
    "end": "3231089"
  },
  {
    "text": "And now the change of potential\nis that I decrease by t, I increase by 1, I get 0.",
    "start": "3231090",
    "end": "3241440"
  },
  {
    "text": "That seems a little bit too\nsmall, 0 time per operation. AUDIENCE: You're\nadding a 1, you're",
    "start": "3241440",
    "end": "3247410"
  },
  {
    "text": "not subtracting [INAUDIBLE]. Sorry, you're not\nsubtracting [INAUDIBLE]. Just subtracting something else. ERIK DEMAINE: Oh, right, sorry.",
    "start": "3247410",
    "end": "3253390"
  },
  {
    "text": "That's 2. Thank you. I just can't do the arithmetic. I wrote everything correct, but\nthis is a plus 1 and a plus 1.",
    "start": "3253390",
    "end": "3261960"
  },
  {
    "text": "T minus t is the key\npart that cancels. Now, if you were measuring\nrunning time instead",
    "start": "3261960",
    "end": "3267970"
  },
  {
    "text": "of the number of\nchanged bits, you'd have to have a big O\nhere, and in that case you'd have to define phi to be\nsome constant times the number",
    "start": "3267970",
    "end": "3275760"
  },
  {
    "text": "of 1 bits. So you could still set\nthat constant large enough so that this part,\nwhich is multiplied by c,",
    "start": "3275760",
    "end": "3281856"
  },
  {
    "text": "would annihilate\nthis part, which would have a big O. I guess\nI'll write it in just for kicks",
    "start": "3281856",
    "end": "3287230"
  },
  {
    "text": "so you've seen both versions. This would be minus c see\ntimes t plus 1 times c.",
    "start": "3287230",
    "end": "3292482"
  },
  {
    "text": "So that would still work out. If you set c to the right\nvalue, you will still get 2. ",
    "start": "3292482",
    "end": "3298760"
  },
  {
    "text": "So binary counters,\nconstant amortize operation. So I think this is\nvery clean, much easier than analyzing the\nfractal of the costs.",
    "start": "3298760",
    "end": "3305697"
  },
  {
    "text": "Now, binary counter with\nincrement and decrements, that doesn't work. There are other data\nstructures to do it,",
    "start": "3305697",
    "end": "3311100"
  },
  {
    "text": "but that's for another class. ",
    "start": "3311100",
    "end": "3316530"
  },
  {
    "text": "Let's go back to 2-3 trees,\nbecause I have more interesting things to say about them. ",
    "start": "3316530",
    "end": "3323528"
  },
  {
    "text": "Any questions about\nbinary counters?  As you saw, it wasn't\ntotally easy to define",
    "start": "3323528",
    "end": "3330619"
  },
  {
    "text": "a potential function,\nbut we're going to see-- if see\nenough examples, you get some intuition for\nthem, but it is probably",
    "start": "3330620",
    "end": "3338930"
  },
  {
    "text": "the hardest method to use but\nalso kind of the most powerful. I would say all\nhard amortizations",
    "start": "3338930",
    "end": "3344740"
  },
  {
    "text": "use a potential function. That's just life. Finding them is tough.",
    "start": "3344740",
    "end": "3351170"
  },
  {
    "text": "That's reality. ",
    "start": "3351170",
    "end": "3360790"
  },
  {
    "text": "I want to analyze insertions\nonly in 2-3 trees, then we'll do insertions\nand deletions,",
    "start": "3360790",
    "end": "3366430"
  },
  {
    "text": "and I want to count how\nmany splits in a 2-3 tree",
    "start": "3366430",
    "end": "3375710"
  },
  {
    "text": "when I do an insertion. ",
    "start": "3375710",
    "end": "3382560"
  },
  {
    "text": "So remember, when you\ninsert into a 2-3 tree, so you started a leaf,\nyou insert a key there.",
    "start": "3382560",
    "end": "3389310"
  },
  {
    "text": "If it's too big,\nyou split that node into two parts, which\ncauses an insert of a key into the parent.",
    "start": "3389310",
    "end": "3395470"
  },
  {
    "text": "Then that might be too big,\nand you split, and so on. So total number of\nsplits per insert? ",
    "start": "3395470",
    "end": "3402530"
  },
  {
    "text": "Upper bounds? AUDIENCE: Log n. ERIK DEMAINE: Log n. OK. Definitely log n\nin the worst case. That's sort of the actual cost\nbut, as you may be guessing,",
    "start": "3402530",
    "end": "3414830"
  },
  {
    "text": "I claim the amortized number\nof splits is only constant,",
    "start": "3414830",
    "end": "3424110"
  },
  {
    "text": "and first will prove\nthis with insertion only. With insertion and\ndeletion in a 2-3 tree, it's actually not true, but for\ninsertion only this is true.",
    "start": "3424110",
    "end": "3432740"
  },
  {
    "text": "So let's prove it. A 2-3 tree, we have two types\nof nodes, 2 nodes and 3 nodes.",
    "start": "3432740",
    "end": "3443090"
  },
  {
    "text": "I'm counting the\nnumber of children, not the number of\nkeys, is one smaller than the number of children.",
    "start": "3443090",
    "end": "3448770"
  },
  {
    "text": "Sorry, no vertical line there. This is just sum key\nx, sum key and y.",
    "start": "3448770",
    "end": "3455880"
  },
  {
    "text": " So when I insert\na key into a node,",
    "start": "3455880",
    "end": "3466849"
  },
  {
    "text": "it momentarily becomes\na 4 node, you might say,",
    "start": "3466850",
    "end": "3472590"
  },
  {
    "text": "with has three\nkeys, x, y, and z. So 4 node, it has four\nchildren, hence the 4,",
    "start": "3472590",
    "end": "3481680"
  },
  {
    "text": "and we split it into x and z.",
    "start": "3481680",
    "end": "3490790"
  },
  {
    "text": "There's the four\nchildren, same number, but now they're distributed\nbetween x and z. And then y gets promoted\nto the next level up,",
    "start": "3490790",
    "end": "3500120"
  },
  {
    "text": "which allows us to have\ntwo pointers to x and z. And that's how 2-3 trees work. That's how split works.",
    "start": "3500120",
    "end": "3506110"
  },
  {
    "text": "Now, I want to say\nthat splitting-- I want to charge the splitting\nto something, intuitively.",
    "start": "3506110",
    "end": "3513035"
  },
  {
    "start": "3513035",
    "end": "3518069"
  },
  {
    "text": "Let's say y was the\nkey that was inserted, so we started with x\nz, which was a 3 node.",
    "start": "3518070",
    "end": "3526650"
  },
  {
    "text": "When we did an insert,\nit became a 4 node, and then we did a\nsplit, which left us",
    "start": "3526650",
    "end": "3535529"
  },
  {
    "text": "with two 2 nodes and something. ",
    "start": "3535530",
    "end": "3543510"
  },
  {
    "text": "So what can you say\noverall about this process?  What's making this example bad?",
    "start": "3543510",
    "end": "3549940"
  },
  {
    "text": "What's making the split\nhappen, in some sense? I mean, the insert is\none thing, but there's",
    "start": "3549940",
    "end": "3555519"
  },
  {
    "text": "another thing we can charge to.  Insert's not enough, because\nwe're going to do log n splits,",
    "start": "3555519",
    "end": "3561580"
  },
  {
    "text": "and we can only\ncharge to the insert once if we want constant\namortized bound. ",
    "start": "3561580",
    "end": "3576150"
  },
  {
    "text": "Yeah? AUDIENCE: Number of 3 nodes? ERIK DEMAINE: Number\nof 3 nodes, exactly. That's a good\npotential function,",
    "start": "3576150",
    "end": "3586760"
  },
  {
    "text": "because on the left side of\nthis picture, we had one 3 node. On the right side of the\npicture, we had two 2 nodes.",
    "start": "3586760",
    "end": "3592330"
  },
  {
    "text": "Now, what's happening\nto the parent? We'll have to worry\nabout that in a moment, but you've got the intuition. ",
    "start": "3592330",
    "end": "3599970"
  },
  {
    "text": "Number of 3 nodes. ",
    "start": "3599970",
    "end": "3617869"
  },
  {
    "text": "I looked at just a\nsingle operation here, but if you look more generally\nabout an expensive insert,",
    "start": "3617870",
    "end": "3623099"
  },
  {
    "text": "in that it does many splits,\nthe only way that can happen is if you had a chain of 3 nodes\nall connected to each other",
    "start": "3623100",
    "end": "3636950"
  },
  {
    "text": "and you do an insert down here. This one splits, then this one\nsplits, then this one splits. So there are all these 3\nnodes just hanging around,",
    "start": "3636950",
    "end": "3645440"
  },
  {
    "text": "and after you do the split,\nthe parent of the very last node that splits,\nthat might become a 3 node.",
    "start": "3645440",
    "end": "3653770"
  },
  {
    "text": "So that will be\nup here somewhere. You might have made\none new 3 node, but then this one is\na couple of 2 nodes,",
    "start": "3653770",
    "end": "3661010"
  },
  {
    "text": "this becomes a\ncouple of 2 nodes, and this becomes a\ncouple of 2 nodes. So if you had k 3 nodes before,\nafterwards you have one.",
    "start": "3661010",
    "end": "3670790"
  },
  {
    "text": " Sound familiar?",
    "start": "3670790",
    "end": "3676540"
  },
  {
    "text": "This is actually\nexactly what's going on with the binary counter, so this\nmay seem like a toy example,",
    "start": "3676540",
    "end": "3681820"
  },
  {
    "text": "but over here we created,\nat most, one 1 bit. Down here we create,\nat most, one 3 node,",
    "start": "3681820",
    "end": "3692890"
  },
  {
    "text": "which is when the split stops. When the split stops,\nthat's the only time we actually insert a key into\na node and it doesn't split,",
    "start": "3692890",
    "end": "3699910"
  },
  {
    "text": "because otherwise you split. When you split, you're\nalways making two nodes, and that's good.",
    "start": "3699910",
    "end": "3705544"
  },
  {
    "text": "At the very end when\nyou stop splitting, you might have made one 3 node. So in an insert, let's say\nthe number of splits equals k,",
    "start": "3705544",
    "end": "3722240"
  },
  {
    "text": "then the change of\npotential for that operation is minus k plus 1,\nbecause for every split",
    "start": "3722240",
    "end": "3735599"
  },
  {
    "text": "there was a 3 node to charge\nto-- or for every split there was a 3 node that\nbecame two nodes, two 2 nodes.",
    "start": "3735600",
    "end": "3743624"
  },
  {
    "text": "So the potential\nwent down by one, because you used to have\none 3 node, then you had 0. At the very end, you\nmight create one 3 node.",
    "start": "3743624",
    "end": "3749290"
  },
  {
    "text": "That's the plus 1. So the amortized cost is just\nthe sum of these two things,",
    "start": "3749290",
    "end": "3755390"
  },
  {
    "text": "and we get 1. ",
    "start": "3755390",
    "end": "3761920"
  },
  {
    "text": "That's k minus k\nplus 1 which is 1. ",
    "start": "3761920",
    "end": "3768930"
  },
  {
    "text": "Cool, huh? This is where a potential method\nbecomes powerful, I would say.",
    "start": "3768930",
    "end": "3774070"
  },
  {
    "text": "You can view this as a\nkind of charging argument, but it gets very confusing.",
    "start": "3774070",
    "end": "3780069"
  },
  {
    "text": "Maybe with coins is\nthe most plausible use. Essentially, the\ninvariance you'd want is that you have a\ncoin on every 3 node.",
    "start": "3780070",
    "end": "3786320"
  },
  {
    "text": "Same thing, of course,\nbut it's I think easier to think about it this way. Say, well, 3 nodes seem\nto be the bad thing.",
    "start": "3786320",
    "end": "3792390"
  },
  {
    "text": "Let's just count them,\nlet's just see what happens. It's more like you\nsay I want to have this invariant that there's\na coin on every 3 node.",
    "start": "3792390",
    "end": "3798925"
  },
  {
    "text": "How can I achieve that? And it just works magically,\nbecause A, it helps it was true",
    "start": "3798925",
    "end": "3806061"
  },
  {
    "text": "and, B, we had to come up with\nthe right potential function. And those are tricky and, in\ngeneral with amortization, unless you're told on a p\nset prove order t amortize,",
    "start": "3806061",
    "end": "3814642"
  },
  {
    "text": "you don't always know what\nthe right running time is, and you just have to experiment. ",
    "start": "3814642",
    "end": "3822190"
  },
  {
    "text": "Our final example,\nmost impressive. Let's go over here.",
    "start": "3822190",
    "end": "3828501"
  },
  {
    "text": " It's a surprise, I guess. It's not even on the list.",
    "start": "3828501",
    "end": "3834721"
  },
  {
    "text": " I want to do-- this\nis great for inserts,",
    "start": "3834721",
    "end": "3848320"
  },
  {
    "text": "but what about deletes? I want to do\ninserts and deletes. ",
    "start": "3848320",
    "end": "3861810"
  },
  {
    "text": "I'd like to do 2-3 trees,\nbut 2-3 trees don't work.",
    "start": "3861810",
    "end": "3867860"
  },
  {
    "text": "If I want to get a constant\namortized bound for inserts and deletes, I've got to\nconstant advertised here for inserts-- I should be clear.",
    "start": "3867860",
    "end": "3875589"
  },
  {
    "text": "I'm ignoring the\ncost of searching. Let's just say searching\nis cheap for some reason. Maybe you already know\nwhere your key is,",
    "start": "3875590",
    "end": "3881300"
  },
  {
    "text": "and you just want\nto insert there. Then insert only costs constant\namortize in a 2-3 tree.",
    "start": "3881300",
    "end": "3887420"
  },
  {
    "text": "Insert and delete\nis not that good. It can be log n\nfor every operation",
    "start": "3887420",
    "end": "3893470"
  },
  {
    "text": "if I do inserts and deletes,\nessentially for the same reason that a binary counter can\nbe n for every operation",
    "start": "3893470",
    "end": "3901940"
  },
  {
    "text": "if I do increments\nand decrements. I could be here,\nincrement a couple times,",
    "start": "3901940",
    "end": "3908119"
  },
  {
    "text": "and then I change a\nhuge number of bits. If I immediately decrement,\nthen all the bits go back. In increment, all\nthe bits go back.",
    "start": "3908120",
    "end": "3914310"
  },
  {
    "text": "Decrement, all the bits go back. So I'm changing end\nbits in every operation. In the same way, if you just\nthink of one path of your tree,",
    "start": "3914310",
    "end": "3922630"
  },
  {
    "text": "and you think of the\n0 bits as 2 nodes and the 1 bits as 3\nnodes, when I increment",
    "start": "3922630",
    "end": "3929710"
  },
  {
    "text": "by inserting at the\nbottom, all those 3s turn to 1, except\nthe top I make a 3. That's just like\na binary counter.",
    "start": "3929710",
    "end": "3935400"
  },
  {
    "text": "It went from all\n1s to 1 0 0 0 0 0, and then if I\ndecrement, if I delete",
    "start": "3935400",
    "end": "3942140"
  },
  {
    "text": "from that very\nsame leaf, then I'm going to have to do\nmerges all the way back up and turn those all back\ninto 3 nodes again.",
    "start": "3942140",
    "end": "3948720"
  },
  {
    "text": "And so every operation\nis going to pay log n. Log n's, not so bad, but\nI really want constant.",
    "start": "3948720",
    "end": "3954810"
  },
  {
    "text": "So I'm going to introduce\nsomething new called 2-5 trees,",
    "start": "3954810",
    "end": "3963440"
  },
  {
    "text": "and it's going to be exactly\nlike b trees that you learned, except now the number of\nchildren of every node",
    "start": "3963440",
    "end": "3972140"
  },
  {
    "text": "should be between 2 and 5. ",
    "start": "3972140",
    "end": "3977950"
  },
  {
    "text": "All the operations\nare defined the same. We've already\ntalked about insert. Now insert-- when you\nhave six children,",
    "start": "3977950",
    "end": "3985440"
  },
  {
    "text": "then you're\noverflowing, and then you're going to split\nin half and so on. So actually I should\ndraw that picture,",
    "start": "3985440",
    "end": "3990544"
  },
  {
    "text": "because we're going to need it. So if I started with a 5 node,\nwhich means it has four keys,",
    "start": "3990544",
    "end": "3999339"
  },
  {
    "text": "and then I insert into\nit, I get a 6 node. ",
    "start": "3999340",
    "end": "4007460"
  },
  {
    "text": "That's too many.  Six children.",
    "start": "4007460",
    "end": "4012572"
  },
  {
    "text": " OK, that's too\nmuch, so I'm going to split it in\nhalf, which is going",
    "start": "4012572",
    "end": "4019380"
  },
  {
    "text": "to leave a 3 node\nand a single item,",
    "start": "4019380",
    "end": "4026519"
  },
  {
    "text": "which gets promoted to the\nparent, and another 3 node.",
    "start": "4026520",
    "end": "4034860"
  },
  {
    "text": "OK, so we started with a 5 node,\nand the result was two 3 nodes. OK, that split, and\nwe also contaminate",
    "start": "4034860",
    "end": "4043730"
  },
  {
    "text": "the parent a little\nbit, but that may lead to another split,\nwhich will look like this again. So if we're just\ndoing insertions,",
    "start": "4043730",
    "end": "4049010"
  },
  {
    "text": "fine, we just count the number\nof 5 nodes, no different, right? But I want to do simultaneously\ninsert and delete.",
    "start": "4049010",
    "end": "4056250"
  },
  {
    "text": "So let's remember what\nhappens with a delete.",
    "start": "4056250",
    "end": "4062470"
  },
  {
    "text": "So if you just delete\na key and a leaf, the issue is it may\nbecome too empty.",
    "start": "4062470",
    "end": "4069160"
  },
  {
    "text": "So what's too empty? Well, the minimum\nnumber of children",
    "start": "4069160",
    "end": "4075530"
  },
  {
    "text": "we're allowed to have\nis two, so too empty would be that I have one child. So maybe initially\nI have two children,",
    "start": "4075530",
    "end": "4083660"
  },
  {
    "text": "and I have a single key\nx, then maybe I delete x, and so now I have 0 keys.",
    "start": "4083660",
    "end": "4091090"
  },
  {
    "text": "This is a 1 node. It has a single child. OK.",
    "start": "4091090",
    "end": "4096520"
  },
  {
    "text": "Weird. In that case, there are\nsort of two situations.",
    "start": "4096520",
    "end": "4103750"
  },
  {
    "text": "Maybe your sibling\nhas enough keys that you can just steal one,\nthen that was really cheap.",
    "start": "4103750",
    "end": "4111210"
  },
  {
    "text": "But the other case\nis that you-- yeah.",
    "start": "4111210",
    "end": "4117509"
  },
  {
    "text": "I'm also going to have\nto involve my parent, so maybe I'm going\nto take a key from x",
    "start": "4117510",
    "end": "4124439"
  },
  {
    "text": "and merge all these\nthings together. So that's y, then\nwhat I get is an x y.",
    "start": "4124439",
    "end": "4133479"
  },
  {
    "text": "I had two children here,\nthree children here. OK.",
    "start": "4133479",
    "end": "4138960"
  },
  {
    "text": "Also messed up my\nparent a little bit, but that's going to\nbe the recursive case. This is a sort of\nmerge operation.",
    "start": "4138960",
    "end": "4145028"
  },
  {
    "text": "In general, I merge\nwith my sibling and then potentially\nsplit again, or you can think of it as\nstealing from your sibling,",
    "start": "4145029",
    "end": "4151410"
  },
  {
    "text": "as you may be\nexperienced with doing. I don't have siblings, so\nI didn't get to do that, but I stole from my\nparents, so whatever.",
    "start": "4151410",
    "end": "4157649"
  },
  {
    "text": "However you want\nto think about it, that is merging in a b tree.",
    "start": "4157649",
    "end": "4162689"
  },
  {
    "text": "We started with a 2 node here. We ended up with a 3 node.",
    "start": "4162689",
    "end": "4168259"
  },
  {
    "text": "Hmm, that's good. It's different at least. So the bad case\nhere is a 5 node,",
    "start": "4168260",
    "end": "4176310"
  },
  {
    "text": "bad case here is a 2 node. What should I use a\npotential function? ",
    "start": "4176310",
    "end": "4202160"
  },
  {
    "text": "Yeah. AUDIENCE: Number of\nnodes with two children and number of nodes\nwith five children? ERIK DEMAINE: Number\nof nodes with two",
    "start": "4202160",
    "end": "4208410"
  },
  {
    "text": "or five children, yeah. So that's it. Just combine with the sum. That's going to be the number\nof nodes with two children",
    "start": "4208410",
    "end": "4224870"
  },
  {
    "text": "plus the number of nodes\nwith five children.",
    "start": "4224870",
    "end": "4231870"
  },
  {
    "text": " This is measuring karma.",
    "start": "4231870",
    "end": "4237020"
  },
  {
    "text": "This is how bad is\nmy tree going to be, because if I have 2 nodes, I'm\nreally close to under flowing",
    "start": "4237020",
    "end": "4243370"
  },
  {
    "text": "and that's potentially bad. If I happen to delete there,\nbad things are going to happen.",
    "start": "4243370",
    "end": "4249140"
  },
  {
    "text": "If I have a bunch of 5 nodes,\nsplits could happen there, and I don't know whether\nit's going to be an insert or delete next,\nso I'm just going",
    "start": "4249140",
    "end": "4254520"
  },
  {
    "text": "to keep track of both of them. And luckily neither of\nthem output 5s or 2s.",
    "start": "4254520",
    "end": "4259690"
  },
  {
    "text": "If they did, like\nif we did 2-3 trees, this is a total\nnightmare, because you can't count the number of 2\nnodes plus the number 3 nodes.",
    "start": "4259690",
    "end": "4265990"
  },
  {
    "text": "That's all the nodes. Potential only changes\nby 1 in each step. That would never help you.",
    "start": "4265990",
    "end": "4272090"
  },
  {
    "text": "OK? But here we have enough\nof a gap between the lower bound and the upper bound and,\nin general, any constants here",
    "start": "4272090",
    "end": "4279070"
  },
  {
    "text": "will work. These are usually\ncalled a-b trees, generalization of\nb trees, where you",
    "start": "4279070",
    "end": "4284080"
  },
  {
    "text": "get to specify the lower\nbound and the upper bound, as long as a-- what's\nthe way-- as long as a",
    "start": "4284080",
    "end": "4291210"
  },
  {
    "text": "is strictly less than b over 2,\nthen this argument will work. As long as there's at least\none gap between a and b over 2,",
    "start": "4291210",
    "end": "4301090"
  },
  {
    "text": "then this argument will work,\nbecause in the small case,",
    "start": "4301090",
    "end": "4306750"
  },
  {
    "text": "you start with the\nminimum number of children you can have. You'll get one more in the end,\nand in the other situation,",
    "start": "4306750",
    "end": "4315830"
  },
  {
    "text": "you have too many\nthings, you divide by 2, and you don't want\ndividing by 2 to end up",
    "start": "4315830",
    "end": "4320960"
  },
  {
    "text": "with the bad case over here. That's what happened\neven with 2-4 trees-- 2-3-4 trees-- but with 2-5\ntrees, there's enough of a gap",
    "start": "4320960",
    "end": "4329300"
  },
  {
    "text": "that when we split 5 in\nhalf, we get 3s only, no 2s, and when we merge\n2s, we get 3s, no 5s.",
    "start": "4329300",
    "end": "4339449"
  },
  {
    "text": "So in either case,\nif we do the split--",
    "start": "4339450",
    "end": "4344550"
  },
  {
    "text": "if we do an insert with k\nsplits, the change in potential",
    "start": "4344550",
    "end": "4356710"
  },
  {
    "text": "is minus k plus 1. Again, we might make a single\nfive-child node at the top when",
    "start": "4356710",
    "end": "4364929"
  },
  {
    "text": "we stop splitting, but\nevery time we split,",
    "start": "4364930",
    "end": "4370140"
  },
  {
    "text": "we've taken a 5 node\nand destroyed it, left it with two 3 nodes,\nso that decreases by k,",
    "start": "4370140",
    "end": "4375850"
  },
  {
    "text": "and so this k cost gets\ncancelled out by this negative k and change potential, so the\namortized cost is 1 just like",
    "start": "4375850",
    "end": "4382200"
  },
  {
    "text": "before. But now, also with delete,\nwith k merge operations",
    "start": "4382200",
    "end": "4392860"
  },
  {
    "text": "where I'm treating all\nof this as one operation, again, the change of\npotential is minus k plus 1.",
    "start": "4392860",
    "end": "4402320"
  },
  {
    "text": "Potentially when\nwe stop merging, because we stole one\nkey from our parent,",
    "start": "4402320",
    "end": "4408400"
  },
  {
    "text": "it may now be a 2 node,\nwhereas before it wasn't. If it was already a 2 node,\nthen it would be another merge,",
    "start": "4408400",
    "end": "4414495"
  },
  {
    "text": "and that's actually\na good case for us, but when the merges\nstop, they stop because we hit a node\nthat's at least a 3 node,",
    "start": "4414495",
    "end": "4421292"
  },
  {
    "text": "then we delete a key from it,\nso potentially it's a 2 node. So potentially the\npotential goes up by 1.",
    "start": "4421292",
    "end": "4426530"
  },
  {
    "text": "We make one new bad\nnode, but every time we do a merge, we\ndestroy bad nodes,",
    "start": "4426530",
    "end": "4432590"
  },
  {
    "text": "because we started\nwith a 2 node, we turned it into a 3 node. So, again, the amortized\ncost is the actual cost,",
    "start": "4432590",
    "end": "4439230"
  },
  {
    "text": "which is k, plus the\nchange in potential, which is minus k plus 1, and so\nthe amortized cost is just 1.",
    "start": "4439230",
    "end": "4446370"
  },
  {
    "text": "Constant number of splits or\nmerges per insert or delete. ",
    "start": "4446370",
    "end": "4465740"
  },
  {
    "text": "So this is actually\nreally nice if you're in a model where changing\nyour data structure",
    "start": "4465740",
    "end": "4471750"
  },
  {
    "text": "is more expensive than\nsearching your data structure. For example, you have a lot of\nthreads in parallel accessing",
    "start": "4471750",
    "end": "4478651"
  },
  {
    "text": "your thing. You're on a multi-core\nmachine or something. You have a shared\ndata structure,",
    "start": "4478651",
    "end": "4484170"
  },
  {
    "text": "you really don't want to be\nchanging things very often, because you have to take a\nlock and then that slows down",
    "start": "4484170",
    "end": "4490380"
  },
  {
    "text": "all the other threads. If searches are\nreally fast but splits and merges are\nexpensive, then this",
    "start": "4490380",
    "end": "4495900"
  },
  {
    "text": "is a reason why you should use\n2-5 trees instead of 2-3 trees, because 2-3 trees,\nthey'll be splitting",
    "start": "4495900",
    "end": "4501130"
  },
  {
    "text": "emerging all the time, log n. It's not a huge\ndifference, log n versus constant, but\nwith data structures",
    "start": "4501130",
    "end": "4506728"
  },
  {
    "text": "that's usually the gap. Last class we were super\nexcited, because we went from log to log log. Here we're excited we\ngo from log to constant.",
    "start": "4506728",
    "end": "4513980"
  },
  {
    "text": "It's a little better, but\nthey're all small numbers, but still we like to go\nfast, as fast as possible.",
    "start": "4513980",
    "end": "4521570"
  },
  {
    "text": "In a real system, actually\nit's even more important, because splitting the root\nis probably the worst,",
    "start": "4521570",
    "end": "4526679"
  },
  {
    "text": "because everyone is\nalways touching the root. In a 2-5 tree, you\nalmost never touch the root, almost always\nsplitting and merging",
    "start": "4526680",
    "end": "4533409"
  },
  {
    "text": "at the leaves,\nwhereas in a 2-3 tree, you could be going all the way\nto the root every single time.",
    "start": "4533410",
    "end": "4539120"
  },
  {
    "text": "So that's my examples. Any questions?",
    "start": "4539120",
    "end": "4544176"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] ERIK DEMAINE: For free minutes.",
    "start": "4544176",
    "end": "4549641"
  },
  {
    "text": "Cool. That's amortization. ",
    "start": "4549641",
    "end": "4552689"
  }
]