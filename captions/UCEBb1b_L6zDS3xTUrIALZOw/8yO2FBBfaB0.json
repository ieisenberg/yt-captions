[
  {
    "start": "0",
    "end": "159000"
  },
  {
    "text": "Here's how our virtual memory system will\nwork.",
    "start": "870",
    "end": "3980"
  },
  {
    "text": "The memory addresses generated by the CPU\nare called virtual addresses to distinguish",
    "start": "3980",
    "end": "8680"
  },
  {
    "text": "them from the physical addresses used by main\nmemory.",
    "start": "8680",
    "end": "12300"
  },
  {
    "text": "In between the CPU and main memory there's\na new piece of hardware called the memory",
    "start": "12300",
    "end": "16490"
  },
  {
    "text": "management unit (MMU).",
    "start": "16490",
    "end": "20060"
  },
  {
    "text": "The MMU's job is to translate virtual addresses\nto physical addresses.",
    "start": "20060",
    "end": "24980"
  },
  {
    "text": "\"But wait!\" you say.",
    "start": "24980",
    "end": "26980"
  },
  {
    "text": "\"Doesn't the cache go between the CPU and\nmain memory?\"",
    "start": "26980",
    "end": "31070"
  },
  {
    "text": "You're right and at the end of this lecture\nwe'll talk about how to use both an MMU and",
    "start": "31070",
    "end": "35821"
  },
  {
    "text": "a cache.",
    "start": "35821",
    "end": "36980"
  },
  {
    "text": "But for now, let's assume there's only an\nMMU and no cache.",
    "start": "36980",
    "end": "42359"
  },
  {
    "text": "The MMU hardware translates virtual addresses\nto physical addresses using a simple table",
    "start": "42359",
    "end": "47600"
  },
  {
    "text": "lookup.",
    "start": "47600",
    "end": "48890"
  },
  {
    "text": "This table is called the page map or page\ntable.",
    "start": "48890",
    "end": "51989"
  },
  {
    "text": "Conceptually, the MMU uses the virtual address\nas index to select an entry in the table,",
    "start": "51989",
    "end": "57480"
  },
  {
    "text": "which tells us the corresponding physical\naddress.",
    "start": "57480",
    "end": "61239"
  },
  {
    "text": "The table allows a particular virtual address\nto be found anywhere in main memory.",
    "start": "61239",
    "end": "66690"
  },
  {
    "text": "In normal operation we'd want to ensure that\ntwo virtual addresses don't map to the same",
    "start": "66690",
    "end": "70940"
  },
  {
    "text": "physical address.",
    "start": "70940",
    "end": "73540"
  },
  {
    "text": "But it would be okay if some of the virtual\naddresses did not have a translation to a",
    "start": "73540",
    "end": "77920"
  },
  {
    "text": "physical address.",
    "start": "77920",
    "end": "79810"
  },
  {
    "text": "This would indicate that the contents of the\nrequested virtual address haven't yet been",
    "start": "79810",
    "end": "83790"
  },
  {
    "text": "loaded into main memory, so the MMU would\nsignal a memory-management exception to the",
    "start": "83790",
    "end": "89020"
  },
  {
    "text": "CPU,\nwhich could assign a location in physical",
    "start": "89020",
    "end": "92020"
  },
  {
    "text": "memory and perform the required I/O operation\nto initialize that location from secondary",
    "start": "92020",
    "end": "97520"
  },
  {
    "text": "storage.",
    "start": "97520",
    "end": "100140"
  },
  {
    "text": "The MMU table gives the system a lot of control\nover how physical memory is accessed by the",
    "start": "100140",
    "end": "105409"
  },
  {
    "text": "program running on the CPU.",
    "start": "105410",
    "end": "107790"
  },
  {
    "text": "For example, we could arrange to run multiple\nprograms in quick succession (a technique",
    "start": "107790",
    "end": "113090"
  },
  {
    "text": "called time sharing) by changing the page\nmap when we change programs.",
    "start": "113090",
    "end": "119189"
  },
  {
    "text": "Main memory locations accessible to one program\ncould be made inaccessible to another program",
    "start": "119190",
    "end": "124020"
  },
  {
    "text": "by proper management of their respective page\nmaps.",
    "start": "124020",
    "end": "127259"
  },
  {
    "text": "And we could use memory-management exceptions\nto load program contents into main memory",
    "start": "127260",
    "end": "132200"
  },
  {
    "text": "on demand instead of having to load the entire\nprogram before execution starts.",
    "start": "132200",
    "end": "137769"
  },
  {
    "text": "In fact, we only need to ensure the current\nworking set of a program is actually resident",
    "start": "137769",
    "end": "143499"
  },
  {
    "text": "in main memory.",
    "start": "143499",
    "end": "145480"
  },
  {
    "text": "Locations not currently being used could live\nin secondary storage until needed.",
    "start": "145480",
    "end": "150260"
  },
  {
    "text": "In this lecture and next, we'll see how the\nMMU plays a central role in the design of",
    "start": "150260",
    "end": "155379"
  },
  {
    "text": "a modern timesharing computer system.",
    "start": "155379",
    "end": "159549"
  },
  {
    "start": "159000",
    "end": "159000"
  },
  {
    "text": "Of course, we'd need an impossibly large table\nto separately map each virtual address to",
    "start": "159549",
    "end": "164720"
  },
  {
    "text": "a physical address.",
    "start": "164720",
    "end": "166450"
  },
  {
    "text": "So instead we divide both the virtual and\nphysical address spaces into fixed-sized blocks,",
    "start": "166450",
    "end": "171690"
  },
  {
    "text": "called pages.",
    "start": "171690",
    "end": "173840"
  },
  {
    "text": "Page sizes are always a power-of-2 bytes,\nsay 2^p bytes, so p is the number address",
    "start": "173840",
    "end": "180180"
  },
  {
    "text": "bits needed to select a particular location\non the page.",
    "start": "180180",
    "end": "183519"
  },
  {
    "text": "We'll the use low-order p bits of the virtual\nor physical address as the page offset.",
    "start": "183519",
    "end": "189680"
  },
  {
    "text": "The remaining address bits tell us which page\nis being accessed and are called the page",
    "start": "189680",
    "end": "194310"
  },
  {
    "text": "number.",
    "start": "194310",
    "end": "195310"
  },
  {
    "text": "A typical page size is 4KB to 16KB, which\ncorrespond to p=12 and p=14 respectively.",
    "start": "195310",
    "end": "205159"
  },
  {
    "text": "Suppose p=12.",
    "start": "205159",
    "end": "206700"
  },
  {
    "text": "If the CPU produces a 32-bit virtual address,\nthe low-order 12 bits of the virtual address",
    "start": "206700",
    "end": "213280"
  },
  {
    "text": "are the page offset and the high-order 20\nbits are the virtual page number.",
    "start": "213280",
    "end": "218840"
  },
  {
    "text": "Similarly, the low-order p bits of the physical\naddress are the page offset and the remaining",
    "start": "218840",
    "end": "224739"
  },
  {
    "text": "physical address bits are the physical page\nnumber.",
    "start": "224739",
    "end": "228189"
  },
  {
    "text": "The key idea is that the MMU will manage pages,\nnot individual locations.",
    "start": "228189",
    "end": "234090"
  },
  {
    "text": "We'll move entire pages from secondary storage\ninto main memory.",
    "start": "234090",
    "end": "238168"
  },
  {
    "text": "By the principal of locality, if a program\naccess one location on a page, we expect it",
    "start": "238169",
    "end": "244450"
  },
  {
    "text": "will soon access other nearby locations.",
    "start": "244450",
    "end": "248379"
  },
  {
    "text": "By choosing the page offset from the low-order\naddress bits, we'll ensure that nearby locations",
    "start": "248379",
    "end": "253799"
  },
  {
    "text": "live on the same page (unless of course we're\nnear one end of the page or the other).",
    "start": "253799",
    "end": "259190"
  },
  {
    "text": "So pages naturally capture the notion of locality.",
    "start": "259190",
    "end": "262900"
  },
  {
    "text": "And since pages are large, by dealing with\npages when accessing secondary storage,",
    "start": "262900",
    "end": "267770"
  },
  {
    "text": "we'll take advantage that reading or writing\nmany locations is only slightly more time",
    "start": "267770",
    "end": "272780"
  },
  {
    "text": "consuming than accessing the first location.",
    "start": "272780",
    "end": "276759"
  },
  {
    "text": "The MMU will map virtual page numbers to physical\npage numbers.",
    "start": "276759",
    "end": "281360"
  },
  {
    "text": "It does this by using the virtual page number\n(VPN) as an index into the page table.",
    "start": "281360",
    "end": "287918"
  },
  {
    "text": "Each entry in the page table indicates if\nthe page is resident in main memory and, if",
    "start": "287919",
    "end": "292561"
  },
  {
    "text": "it is, provides the appropriate physical page\nnumber (PPN).",
    "start": "292561",
    "end": "296919"
  },
  {
    "text": "The PPN is combined with the page offset to\nform the physical address for main memory.",
    "start": "296919",
    "end": "303970"
  },
  {
    "text": "If the requested virtual page is NOT resident\nin main memory, the MMU signals a memory-management",
    "start": "303970",
    "end": "310550"
  },
  {
    "text": "exception, called a page fault, to the CPU\nso it can load the appropriate page from secondary",
    "start": "310550",
    "end": "315948"
  },
  {
    "text": "storage and set up the appropriate mapping\nin the MMU.",
    "start": "315949",
    "end": "320699"
  },
  {
    "text": "Our plan to use main memory as page cache\nis called \"paging\" or sometimes \"demand paging\"",
    "start": "320699",
    "end": "326349"
  },
  {
    "text": "since movements of pages to and from secondary\nstorage is determined by the demands of the",
    "start": "326349",
    "end": "331580"
  },
  {
    "text": "program.",
    "start": "331580",
    "end": "333030"
  },
  {
    "start": "333000",
    "end": "333000"
  },
  {
    "text": "So here's the plan.",
    "start": "333030",
    "end": "335190"
  },
  {
    "text": "Initially all the virtual pages for a program\nreside in secondary storage and the MMU is",
    "start": "335190",
    "end": "340819"
  },
  {
    "text": "empty, i.e., there are no pages resident in\nphysical memory.",
    "start": "340819",
    "end": "345360"
  },
  {
    "text": "The CPU starts running the program and each\nvirtual address it generates, either for an",
    "start": "345360",
    "end": "349860"
  },
  {
    "text": "instruction fetch or data access, is passed\nto the MMU to be mapped to a physical address",
    "start": "349860",
    "end": "355319"
  },
  {
    "text": "in main memory.",
    "start": "355319",
    "end": "357400"
  },
  {
    "text": "If the virtual address is resident in physical\nmemory, the main memory hardware can complete",
    "start": "357400",
    "end": "361919"
  },
  {
    "text": "the access.",
    "start": "361919",
    "end": "364310"
  },
  {
    "text": "If the virtual address in NOT resident in\nphysical memory, the MMU signals a page fault",
    "start": "364310",
    "end": "369990"
  },
  {
    "text": "exception, forcing the CPU to switch execution\nto special code called the page fault handler.",
    "start": "369990",
    "end": "376479"
  },
  {
    "text": "The handler allocates a physical page to hold\nthe requested virtual page and loads the virtual",
    "start": "376479",
    "end": "382129"
  },
  {
    "text": "page from secondary storage into main memory.",
    "start": "382129",
    "end": "386630"
  },
  {
    "text": "It then adjusts the page map entry for the\nrequested virtual page to show that it is",
    "start": "386630",
    "end": "390930"
  },
  {
    "text": "now resident and to indicate the physical\npage number for the newly allocated and initialized",
    "start": "390930",
    "end": "396789"
  },
  {
    "text": "physical page.",
    "start": "396789",
    "end": "399540"
  },
  {
    "text": "When trying to allocate a physical page, the\nhandler may discover that all physical pages",
    "start": "399540",
    "end": "404080"
  },
  {
    "text": "are currently in use.",
    "start": "404080",
    "end": "405800"
  },
  {
    "text": "In this case it chooses an existing page to\nreplace, e.g., a resident virtual page that",
    "start": "405800",
    "end": "412340"
  },
  {
    "text": "hasn't been recently accessed.",
    "start": "412340",
    "end": "415130"
  },
  {
    "text": "It swaps the contents of the chosen virtual\npage out to secondary storage and updates",
    "start": "415130",
    "end": "420409"
  },
  {
    "text": "the page map entry for the replaced virtual\npage to indicate it is no longer resident.",
    "start": "420409",
    "end": "425690"
  },
  {
    "text": "Now there's a free physical page to re-use\nto hold the contents of the virtual page that",
    "start": "425690",
    "end": "430419"
  },
  {
    "text": "was missing.",
    "start": "430419",
    "end": "433229"
  },
  {
    "text": "The working set of the program, i.e., the\nset of pages the program is currently accessing,",
    "start": "433229",
    "end": "438500"
  },
  {
    "text": "is loaded into main memory through a series\nof page faults.",
    "start": "438500",
    "end": "443370"
  },
  {
    "text": "After a flurry of page faults when the program\nstarts running, the working set changes slowly,",
    "start": "443370",
    "end": "449050"
  },
  {
    "text": "so the frequency of page faults drops dramatically,\nperhaps close to zero if the program is small",
    "start": "449050",
    "end": "454909"
  },
  {
    "text": "and well-behaved.",
    "start": "454909",
    "end": "457280"
  },
  {
    "text": "It is possible to write programs that consistently\ngenerate page faults, a phenomenon called",
    "start": "457280",
    "end": "462099"
  },
  {
    "text": "thrashing.",
    "start": "462099",
    "end": "463919"
  },
  {
    "text": "Given the long access times of secondary storage,\na program that's thrashing runs *very* slowly,",
    "start": "463919",
    "end": "470170"
  },
  {
    "text": "usually so slowly that users give up and rewrite\nthe program to behave more sensibly.",
    "start": "470170",
    "end": "477449"
  },
  {
    "start": "477000",
    "end": "477000"
  },
  {
    "text": "The design of the page map is straightforward.",
    "start": "477449",
    "end": "480330"
  },
  {
    "text": "There's one entry in the page map for each\nvirtual page.",
    "start": "480330",
    "end": "483879"
  },
  {
    "text": "For example, if the CPU generates a 32-bit\nvirtual address and the page size is 2^12",
    "start": "483879",
    "end": "489620"
  },
  {
    "text": "bytes, the virtual page number has 32-12 = 20\nbits and the page table will have 2^20 entries.",
    "start": "489620",
    "end": "499349"
  },
  {
    "text": "Each entry in the page table contains a \"resident\nbit\" (R) which is set to 1 when the virtual",
    "start": "499349",
    "end": "505210"
  },
  {
    "text": "page is resident in physical memory.",
    "start": "505210",
    "end": "507689"
  },
  {
    "text": "If R is 0, an access to that virtual page\nwill cause a page fault.",
    "start": "507689",
    "end": "513750"
  },
  {
    "text": "If R is 1, the entry also contains the PPN,\nindicating where to find the virtual page",
    "start": "513750",
    "end": "520029"
  },
  {
    "text": "in main memory.",
    "start": "520029",
    "end": "523360"
  },
  {
    "text": "There's one additional state bit called the\n\"dirty bit\" (D).",
    "start": "523360",
    "end": "527320"
  },
  {
    "text": "When a page has just been loaded from secondary\nstorage, it's \"clean\", i.e, the contents of",
    "start": "527320",
    "end": "533300"
  },
  {
    "text": "physical memory match the contents of the\npage in secondary storage.",
    "start": "533300",
    "end": "538279"
  },
  {
    "text": "So the D bit is set to 0.",
    "start": "538279",
    "end": "541089"
  },
  {
    "text": "If subsequently the CPU stores into a location\non the page, the D bit for the page is set",
    "start": "541089",
    "end": "546660"
  },
  {
    "text": "to 1, indicating the page is \"dirty\", i.e.,\nthe contents of memory now differ from the",
    "start": "546660",
    "end": "552879"
  },
  {
    "text": "contents of secondary storage.",
    "start": "552880",
    "end": "555810"
  },
  {
    "text": "If a dirty page is ever chosen for replacement,\nits contents must be written to secondary",
    "start": "555810",
    "end": "560820"
  },
  {
    "text": "storage in order to save the changes before\nthe page gets reused.",
    "start": "560820",
    "end": "566720"
  },
  {
    "text": "Some MMUs have additional state bits in each\npage table entry.",
    "start": "566720",
    "end": "570389"
  },
  {
    "text": "For example, there could be a \"read-only\"\nbit which, when set, would generate an exception",
    "start": "570389",
    "end": "575350"
  },
  {
    "text": "if the program attempts to store into the\npage.",
    "start": "575350",
    "end": "578100"
  },
  {
    "text": "This would be useful for protecting code pages\nfrom accidentally being corrupted by errant",
    "start": "578100",
    "end": "583310"
  },
  {
    "text": "data accesses, a very handy debugging feature.",
    "start": "583310",
    "end": "587779"
  },
  {
    "text": "Here's an example of the MMU in action.",
    "start": "587779",
    "end": "590220"
  },
  {
    "start": "588000",
    "end": "588000"
  },
  {
    "text": "To make things simple, assume that the virtual\naddress is 12 bits, consisting of an 8-bit",
    "start": "590220",
    "end": "596230"
  },
  {
    "text": "page offset and a 4-bit virtual page number.",
    "start": "596230",
    "end": "599680"
  },
  {
    "text": "So there are 2^4 = 16 virtual pages.",
    "start": "599680",
    "end": "603839"
  },
  {
    "text": "The physical address is 11 bits, divided into\nthe same 8-bit page offset and a 3-bit physical",
    "start": "603840",
    "end": "610420"
  },
  {
    "text": "page number.",
    "start": "610420",
    "end": "611740"
  },
  {
    "text": "So there are 2^3 = 8 physical pages.",
    "start": "611740",
    "end": "616190"
  },
  {
    "text": "On the left we see a diagram showing the contents\nof the 16-entry page map, i.e., an entry for",
    "start": "616190",
    "end": "621649"
  },
  {
    "text": "each virtual page.",
    "start": "621649",
    "end": "624200"
  },
  {
    "text": "Each page table entry includes a dirty bit\n(D), a resident bit (R) and a 3-bit physical",
    "start": "624200",
    "end": "630300"
  },
  {
    "text": "page number, for a total of 5 bits.",
    "start": "630300",
    "end": "633760"
  },
  {
    "text": "So the page map has 16 entries, each with\n5-bits, for a total of 16*5 = 80 bits.",
    "start": "633760",
    "end": "641340"
  },
  {
    "text": "The first entry in the table is for virtual\npage 0, the second entry for virtual page",
    "start": "641340",
    "end": "645941"
  },
  {
    "text": "1, and so on.",
    "start": "645941",
    "end": "649320"
  },
  {
    "text": "In the middle of the slide there's a diagram\nof physical memory showing the 8 physical",
    "start": "649320",
    "end": "653670"
  },
  {
    "text": "pages.",
    "start": "653670",
    "end": "654980"
  },
  {
    "text": "The annotation for each physical page shows\nthe virtual page number of its contents.",
    "start": "654980",
    "end": "661010"
  },
  {
    "text": "Note that there's no particular order to how\nvirtual pages are stored in physical memory",
    "start": "661010",
    "end": "665129"
  },
  {
    "text": "-\nwhich page holds what is determined by which",
    "start": "665129",
    "end": "668300"
  },
  {
    "text": "pages are free at the time of a page fault.",
    "start": "668300",
    "end": "671630"
  },
  {
    "text": "In general, after the program has run for\na while, we'd expected to find the sort of",
    "start": "671630",
    "end": "676540"
  },
  {
    "text": "jumbled ordering we see here.",
    "start": "676540",
    "end": "680060"
  },
  {
    "text": "Let's follow along as the MMU handles the\nrequest for virtual address 0x2C8, generated",
    "start": "680060",
    "end": "686050"
  },
  {
    "text": "by the execution of the LD instruction shown\nhere.",
    "start": "686050",
    "end": "690260"
  },
  {
    "text": "Splitting the virtual address into page number\nand offset, we see that the VPN is 2 and the",
    "start": "690260",
    "end": "696850"
  },
  {
    "text": "offset is 0xC8.",
    "start": "696850",
    "end": "700089"
  },
  {
    "text": "Looking at the page map entry with index 2,\nwe see that the R bit is 1, indicating that",
    "start": "700090",
    "end": "706170"
  },
  {
    "text": "virtual page 2 is resident in physical memory.",
    "start": "706170",
    "end": "710290"
  },
  {
    "text": "The PPN field of entry tells us that virtual\npage 2 can be found in physical page 4.",
    "start": "710290",
    "end": "718149"
  },
  {
    "text": "Combining the PPN with the 8-bit offset, we\nfind that the contents of virtual address",
    "start": "718149",
    "end": "724269"
  },
  {
    "text": "0x2C8 can be found in main memory location\n0x4C8.",
    "start": "724270",
    "end": "729920"
  },
  {
    "text": "Note that the offset is unchanged by the translation\nprocess -",
    "start": "729920",
    "end": "733380"
  },
  {
    "text": "the offset into the physical page is always\nthe same as the offset into the virtual page.",
    "start": "733380",
    "end": "738620"
  }
]