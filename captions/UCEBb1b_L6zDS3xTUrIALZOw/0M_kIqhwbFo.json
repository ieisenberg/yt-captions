[
  {
    "start": "0",
    "end": "22000"
  },
  {
    "text": " The following\ncontent is provided under a Creative\nCommons license. Your support will help MIT\nOpenCourseWare continue",
    "start": "0",
    "end": "6860"
  },
  {
    "text": "to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6860",
    "end": "13330"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13330",
    "end": "21835"
  },
  {
    "text": "PROFESSOR: All right. Let's get started. Today we start a brand\nnew section of 006,",
    "start": "21835",
    "end": "27730"
  },
  {
    "start": "22000",
    "end": "300000"
  },
  {
    "text": "which is hashing. Hashing is cool. It is probably the most used\nand common and important",
    "start": "27730",
    "end": "34230"
  },
  {
    "text": "data structure and all\nof computer science. It's in, basically, every system\nyou've ever used, I think.",
    "start": "34230",
    "end": "41860"
  },
  {
    "text": "And in particular,\nit's in Python as part of what makes\nPython fun to program in. And basically, every modern\nprogramming language has it.",
    "start": "41860",
    "end": "49740"
  },
  {
    "text": "So today is about how to\nmake it actually happen. So what is it? ",
    "start": "49740",
    "end": "57230"
  },
  {
    "text": "It is usually\ncalled a dictionary.  So this is an\nabstract data if you",
    "start": "57230",
    "end": "64280"
  },
  {
    "text": "remember that term from\na couple lectures ago. ",
    "start": "64280",
    "end": "73080"
  },
  {
    "text": "It's kind of an old term,\nnot so common anymore, but it's useful to think about.",
    "start": "73080",
    "end": "78340"
  },
  {
    "text": "So a dictionary is\na data structure, or it's a thing,\nthat can store items,",
    "start": "78340",
    "end": "86900"
  },
  {
    "text": "and it can insert items, delete\nitems and search for items. ",
    "start": "86900",
    "end": "95179"
  },
  {
    "text": "So in general, it's going\nto be a set of items,",
    "start": "95180",
    "end": "100230"
  },
  {
    "text": "each item has a key. ",
    "start": "100230",
    "end": "107720"
  },
  {
    "text": "And you can insert an item,\nyou can delete an item",
    "start": "107720",
    "end": "116080"
  },
  {
    "text": "from the set, and you can\nsearch for a key, not an item.",
    "start": "116080",
    "end": "126720"
  },
  {
    "text": "And the interesting\npart is the search. I think you know what\ninsert and delete do. ",
    "start": "126720",
    "end": "140360"
  },
  {
    "text": "So there are two outcomes\nto this kind of search. This is what I call\nan exact search. Either you find an item with a\ngiven key, or there isn't one,",
    "start": "140360",
    "end": "149440"
  },
  {
    "text": "and then you just say\nkey error in Python. ",
    "start": "149440",
    "end": "161950"
  },
  {
    "text": "OK. This is a little\ndifferent from what we could do with\nbinary search trees. Binary search trees, if\nwe didn't find a key,",
    "start": "161950",
    "end": "167690"
  },
  {
    "text": "we could find the next\nlarger and the next smaller successor and predecessor. With dictionaries you're\nnot allowed to do that,",
    "start": "167690",
    "end": "174659"
  },
  {
    "text": "or you're not able to do that. And you're just\ninterested in the question does the key exist? And if so, give me the\nitem with that key.",
    "start": "174660",
    "end": "182090"
  },
  {
    "text": "So we're assuming here that\nthe items have unique keys, no two items have the same key.",
    "start": "182090",
    "end": "187362"
  },
  {
    "text": "And one way to\nenforce that is when you insert an item\nwith an existing key, it overwrites whatever\nkey was there.",
    "start": "187362",
    "end": "193140"
  },
  {
    "text": "That's the Python behavior. So we'll assume that.",
    "start": "193140",
    "end": "198550"
  },
  {
    "text": "Overwrite any existing key.",
    "start": "198550",
    "end": "205650"
  },
  {
    "start": "205650",
    "end": "211730"
  },
  {
    "text": "And so, it's well\ndefined what search does. Either there's one\nitem with that key, or there's no item\nwith that key,",
    "start": "211730",
    "end": "217489"
  },
  {
    "text": "and it tells you what\nthe situation is. OK. So one way to solve\ndictionaries is",
    "start": "217490",
    "end": "227709"
  },
  {
    "text": "to use a balanced binary\nsearch tree like AVL trees. And so you can do all of these\noperations on log n time.",
    "start": "227710",
    "end": "234709"
  },
  {
    "start": "234710",
    "end": "241720"
  },
  {
    "text": "I mean, you can ignore the\nfact that AVL trees give you more information\nwhen you do a search, and still does exact search.",
    "start": "241720",
    "end": "248540"
  },
  {
    "text": "So that's one solution, but it\nturns out you can do better. And while last class was about,\nwell, in the comparison model",
    "start": "248540",
    "end": "256109"
  },
  {
    "text": "the best way to sort is n log\nn and the best way to search is log n.",
    "start": "256110",
    "end": "261570"
  },
  {
    "text": "Then we saw in the\nRAM model, where if you assume your items are\nintegers we can sort faster,",
    "start": "261570",
    "end": "267600"
  },
  {
    "text": "sometimes we can\nsort in linear time. Today's lecture is about how to\nsearch faster than log n time.",
    "start": "267600",
    "end": "273710"
  },
  {
    "text": "And we're going to get\ndown to constant time. No-- basically, no\nassumptions except, maybe,",
    "start": "273710",
    "end": "281020"
  },
  {
    "text": "that your keys are integers. We'll be able to get\ndown to constant time with high probability.",
    "start": "281020",
    "end": "286365"
  },
  {
    "text": " It's going to be a\nrandomized data structure. It's one of the few instances\nof randomization in 006,",
    "start": "286365",
    "end": "293490"
  },
  {
    "text": "but it'll be pretty simple\nto analyze, so don't worry. But we're going to use\nsome probability today.",
    "start": "293490",
    "end": "299332"
  },
  {
    "text": "Make it a little exciting.  I think you know how\ndictionaries work in Python.",
    "start": "299332",
    "end": "305470"
  },
  {
    "start": "300000",
    "end": "780000"
  },
  {
    "text": "In Python it's the\ndict data type.",
    "start": "305470",
    "end": "311810"
  },
  {
    "text": "We've used it all\nover the place. The key things you can\ndo are lookup a key",
    "start": "311810",
    "end": "317760"
  },
  {
    "text": "and-- so this is the\nanalog of search--",
    "start": "317760",
    "end": "324100"
  },
  {
    "text": "you can set a key to a value. This is the analog of an insert.",
    "start": "324100",
    "end": "330960"
  },
  {
    "text": "It overwrites\nwhatever was there. And what else? Delete. So you can delete\na particular key.",
    "start": "330960",
    "end": "338129"
  },
  {
    "text": " OK. We'll usually use this\nnotation because it's",
    "start": "338130",
    "end": "344593"
  },
  {
    "text": "more familiar and intuitive. But the big topic today\nis how do you actually implement these operations\nfor a dictionary, D?",
    "start": "344593",
    "end": "353070"
  },
  {
    "text": "The one specific thing\nabout Python dictionaries is that an item is\nbasically a pair",
    "start": "353070",
    "end": "361465"
  },
  {
    "text": "of two things, a\nkey and a value. And so, in particular,\nwhen you call d.items",
    "start": "361465",
    "end": "367410"
  },
  {
    "text": "you get a whole bunch of ordered\npairs, a key and a value. And so the key is always--\nthe key of an item",
    "start": "367410",
    "end": "373220"
  },
  {
    "text": "is always this first part. So it's well defined. ",
    "start": "373220",
    "end": "380035"
  },
  {
    "text": "OK.  So that's Python dictionaries.",
    "start": "380035",
    "end": "388120"
  },
  {
    "text": "So one obvious motivation\nfor building dictionaries is you need them in Python.",
    "start": "388120",
    "end": "394980"
  },
  {
    "text": "And in fact, people\nuse them all the time. We used them in docdist. All of the fastest versions of\nthe document distance problem",
    "start": "394980",
    "end": "403889"
  },
  {
    "text": "used dictionaries for counting\nwords, how many times each word occurs in a document, and\nfor computing inner products,",
    "start": "403890",
    "end": "411470"
  },
  {
    "text": "for finding common words\nbetween two documents. And it's just it's the\nbest way to do things,",
    "start": "411470",
    "end": "417035"
  },
  {
    "text": "it's the easiest way to do\nthings , and the fastest. As a result, dictionaries are\nbuilt into basically every",
    "start": "417035",
    "end": "422800"
  },
  {
    "text": "modern programming language,\nPython, Perl, Ruby, JavaScript, Java, C++, C#.",
    "start": "422800",
    "end": "428110"
  },
  {
    "text": "In modern versions, all have\nsome version of dictionaries. And they all run in,\nbasically, constant time",
    "start": "428110",
    "end": "433790"
  },
  {
    "text": "using the stuff that's in\nthis lecture and the next two lectures. ",
    "start": "433790",
    "end": "440130"
  },
  {
    "text": "Let's see. It's also, in, basically,\nevery database. ",
    "start": "440130",
    "end": "446893"
  },
  {
    "text": "There are essentially two kinds\nof databases in the world, there are those\nthat use hashing, and there are those\nthat use search trees.",
    "start": "446894",
    "end": "452800"
  },
  {
    "text": "Sometimes you need one. Sometimes you need the other. There are a lot of situations\nin databases where you just need hashing.",
    "start": "452800",
    "end": "459082"
  },
  {
    "text": "So if you've ever\nused Berkeley DB, there's a hash\ntype of a database.",
    "start": "459082",
    "end": "464450"
  },
  {
    "text": "So if things like, when\nyou go to Merriam-Webster, and you look up a\nword, how do you",
    "start": "464450",
    "end": "471199"
  },
  {
    "text": "find the definition\nof that word? You use a hash table, you use\na dictionary, I should say.",
    "start": "471200",
    "end": "478090"
  },
  {
    "text": "How do you-- when you\nspell check your document, how do you tell whether a\nword is correctly spelled?",
    "start": "478090",
    "end": "484360"
  },
  {
    "text": "You look it up in a dictionary. If it's not correctly\nspelled, how do you find the closest\nrelated, correct spelling?",
    "start": "484360",
    "end": "491520"
  },
  {
    "text": "You try tweaking\none the letters, and look it up in a dictionary\nand see if it's there. You do that for all possible\nletters, or maybe two letters.",
    "start": "491520",
    "end": "497600"
  },
  {
    "text": "That is a state of the art\nway to do spelling correction. Just keep looking\nup in a dictionary.",
    "start": "497600",
    "end": "503439"
  },
  {
    "text": "Because dictionaries\nare so fast you can afford to do things like\ntrial perturbations of letters. ",
    "start": "503440",
    "end": "510820"
  },
  {
    "text": "What else. In the old days, which\nmeans pre-Google, every search engine\non the web would",
    "start": "510820",
    "end": "518030"
  },
  {
    "text": "have a dictionary that\nsays, for given word, give me all of the documents\ncontaining that word.",
    "start": "518030",
    "end": "524120"
  },
  {
    "text": "Google doesn't do it that\nway, but that's another story. It's less fancy, actually.",
    "start": "524120",
    "end": "530870"
  },
  {
    "text": "Or when you log\ninto a system, you type your username and password. You look in a dictionary\nthat stores a username",
    "start": "530870",
    "end": "537762"
  },
  {
    "text": "and, associated\nwith that username, all the information\nof that user. Every time you log into a\nweb system, or whatever,",
    "start": "537762",
    "end": "543040"
  },
  {
    "text": "it is going through\na dictionary. So they're all over the place. One of the original\napplications is",
    "start": "543040",
    "end": "549330"
  },
  {
    "text": "in writing\nprogramming languages. Some of the first\ncomputer programs were programming languages,\nso you could actually",
    "start": "549330",
    "end": "555076"
  },
  {
    "text": "program them in\na reasonable way. ",
    "start": "555076",
    "end": "561860"
  },
  {
    "text": "Whenever you type a variable\nname the computer doesn't really think about\nthat variable name,",
    "start": "561860",
    "end": "567080"
  },
  {
    "text": "it wants to think about\nan address in memory. And so you've got to\ntranslate that variable name into a real, physical address\nin the machine, or a position",
    "start": "567080",
    "end": "576340"
  },
  {
    "text": "on the stack, or whatever\nit is in real life. In the old days\nof Python, I guess",
    "start": "576340",
    "end": "581950"
  },
  {
    "text": "this is pre-Python\n2 or so, 2.1, I don't remember the\nexact transition it was.",
    "start": "581950",
    "end": "588390"
  },
  {
    "text": "In the interpreter,\nthere was the dictionary of all your global\nvariables, there's a dictionary of all\nyour local variables.",
    "start": "588390",
    "end": "594420"
  },
  {
    "text": "And that was-- it\nwas right there. I mean you could\nmodify the dictionary,",
    "start": "594420",
    "end": "600310"
  },
  {
    "text": "you could do crazy things. And all the\nvariables were there. And so they'd match the\nkey to the actual value",
    "start": "600310",
    "end": "606050"
  },
  {
    "text": "stored in the variable. They don't do that anymore\nbecause it's a little slow, but-- and you could\ndo better in practice.",
    "start": "606050",
    "end": "612019"
  },
  {
    "text": "But at the very least, when\nyou're compiling the thing, you need a dictionary. And then, later on, you can\ndo more efficient lookups.",
    "start": "612019",
    "end": "620120"
  },
  {
    "text": "Let's see.  On the internet there\nare hash tables all over,",
    "start": "620120",
    "end": "626490"
  },
  {
    "text": "like in your router. Router needs to know\nall the machines that are connected to it. Each machine has an IP address,\nso when you get a packet in,",
    "start": "626490",
    "end": "633875"
  },
  {
    "text": "and it says, deliver to\nthis IP address, you see, oh, is it in my dictionary\nof all the machines that are directly\nconnected to me?",
    "start": "633875",
    "end": "639476"
  },
  {
    "text": "If so, send it there. If it's not then it has\nto find the right subnet. That's not quite a\ndictionary problem,",
    "start": "639476",
    "end": "644573"
  },
  {
    "text": "a little more complicated. But for looking up local\nmachines, it's a dictionary. Routers use dictionaries because\nthey need to go really fast.",
    "start": "644573",
    "end": "651930"
  },
  {
    "text": "They're getting a billion\npackets every second. Also, in the network\nstack of a machine,",
    "start": "651930",
    "end": "659190"
  },
  {
    "text": "when you come in you\nget it packet delivered to a particular port, you need\nto say, oh, which application,",
    "start": "659190",
    "end": "664980"
  },
  {
    "text": "or which socket is\nconnected to this port? All of these things\nare dictionaries. The point is they're\nin, basically,",
    "start": "664980",
    "end": "670088"
  },
  {
    "text": "everything you've ever\nused, virtual memory, I mean, they're\nall over the place. There are also some more\nsubtle applications,",
    "start": "670088",
    "end": "676935"
  },
  {
    "text": "where it is not obvious\nthat's it a dictionary, but still, we use\nthis idea of hashing we're going to talk about today.",
    "start": "676935",
    "end": "682230"
  },
  {
    "text": "Like searching in a string. ",
    "start": "682230",
    "end": "690350"
  },
  {
    "text": "So when you hit-- I don't\nknow-- in your favorite editor, you do Control-F, or\nControl-S, or slash,",
    "start": "690350",
    "end": "696850"
  },
  {
    "text": "or whatever your way of\nsearching for something is, and you type start typing. If your editor is\nclever, it will",
    "start": "696850",
    "end": "703930"
  },
  {
    "text": "use hashing in order to\nsearch for that string. It's a faster way to do it.",
    "start": "703930",
    "end": "709770"
  },
  {
    "text": "If you use grep, for example, in\nUnix it does it in a fancy way. Every time you do\na Google search",
    "start": "709770",
    "end": "716240"
  },
  {
    "text": "it's essentially using this. It's solving this problem. I don't know what algorithm,\nbut we could guess.",
    "start": "716240",
    "end": "721330"
  },
  {
    "text": "Using the algorithms we'll\ncover in next lecture. It wouldn't surprise me.",
    "start": "721330",
    "end": "726650"
  },
  {
    "text": "Also, if you have\na couple strings and you want to know what they\nhave in common, how similar",
    "start": "726650",
    "end": "734540"
  },
  {
    "text": "they are? Example, you have\ntwo DNA strings. You want to see how similar\nthey are, you use hashing.",
    "start": "734540",
    "end": "740480"
  },
  {
    "text": "And you're going to do that\nin the next problem set, PS4, which goes out on Thursday.",
    "start": "740480",
    "end": "747000"
  },
  {
    "text": "Also, for things like file\nand directory synchronization. ",
    "start": "747000",
    "end": "758870"
  },
  {
    "text": "So on Unix, if you rsync\nor unison, or, I guess, modern day-- these\ndays, Dropbox, MIT",
    "start": "758870",
    "end": "766740"
  },
  {
    "text": "startup-- Whenever you're\nsynchronizing files between two locations, you use\nhashing to tell whether a file has changed,\nor whether a directory has",
    "start": "766740",
    "end": "773260"
  },
  {
    "text": "changed. That's a big idea. Fairly modern idea.",
    "start": "773260",
    "end": "779940"
  },
  {
    "text": "And also in\ncryptography-- this will be a topic of next\nTuesday's lecture.",
    "start": "779940",
    "end": "787480"
  },
  {
    "start": "780000",
    "end": "1185000"
  },
  {
    "text": "If you're transferring\na file and you want to check that you\nactually transferred that file, and there wasn't some person in\nthe middle corrupting your file",
    "start": "787480",
    "end": "795672"
  },
  {
    "text": "and making it look like it\nwas what you wanted it to be, you use something called\ncryptographic hash functions,",
    "start": "795672",
    "end": "801420"
  },
  {
    "text": "which [INAUDIBLE] will\ntalk about on Tuesday. So tons of motivation\nfor dictionaries.",
    "start": "801420",
    "end": "807230"
  },
  {
    "text": "Let's actually do it,\nsee how they are done.",
    "start": "807230",
    "end": "812839"
  },
  {
    "text": " We're going to start with sort\nof a very simple straw man,",
    "start": "812840",
    "end": "820990"
  },
  {
    "text": "and then we're going to improve\nit until, by the end of today, we have a really good way\nto solve the dictionary",
    "start": "820990",
    "end": "826130"
  },
  {
    "text": "problem in constant\ntime for operation. ",
    "start": "826130",
    "end": "834190"
  },
  {
    "text": "So the really simple approach\nis called a direct access table. ",
    "start": "834190",
    "end": "840230"
  },
  {
    "text": "So it's just a big\ntable, an array.",
    "start": "840230",
    "end": "845449"
  },
  {
    "text": "You have-- the index into\nthe array is the key.",
    "start": "845450",
    "end": "854340"
  },
  {
    "text": "So, store items in an\narray, indexed by key.",
    "start": "854340",
    "end": "867530"
  },
  {
    "text": " And in fact, Python kind\nmakes you think about this",
    "start": "867530",
    "end": "874200"
  },
  {
    "text": "because the Python notation\nfor accessing dictionaries is identical to the notation\nfor accessing arrays.",
    "start": "874200",
    "end": "880120"
  },
  {
    "text": "But with arrays, the\nkeys are restricted to be non-negative integers,\n0 through n minus 1.",
    "start": "880120",
    "end": "885157"
  },
  {
    "text": "So why not just\nimplement it that way? If your keys happen\nto be integers I could just store all my\nitems in a giant array.",
    "start": "885157",
    "end": "892410"
  },
  {
    "text": "So if I just want to store\nan item here with key 2, call that, maybe, item\n2, I just put that there.",
    "start": "892410",
    "end": "900130"
  },
  {
    "text": "If I want to store\nsomething with key 4 I'll just put it there. Everything else is going to\nbe null, or none, or whatever.",
    "start": "900130",
    "end": "907950"
  },
  {
    "text": "So lots of blank entries. Whatever keys I don't use I'll\njust put a null value there.",
    "start": "907950",
    "end": "913380"
  },
  {
    "text": "Every key that I want to\nput into the dictionary I'll just store it at the\ncorresponding position.",
    "start": "913380",
    "end": "919620"
  },
  {
    "text": "What's bad about this? ",
    "start": "919620",
    "end": "925060"
  },
  {
    "text": "Yeah. AUDIENCE: It's hard to associate\nsomething with just an integer. PROFESSOR: Hard to associate\nsomething with an integer.",
    "start": "925060",
    "end": "930670"
  },
  {
    "text": "Good. That's one problem. There's actually two big\nproblems with this structure.",
    "start": "930670",
    "end": "936100"
  },
  {
    "text": "I want both of them. So bad-- badness number one\nis keys may not be integers.",
    "start": "936100",
    "end": "948040"
  },
  {
    "start": "948040",
    "end": "960021"
  },
  {
    "text": "Good.  Another problem. Yeah.",
    "start": "960021",
    "end": "965254"
  },
  {
    "text": "AUDIENCE: Possibility\nof collision. PROFESSOR: Possibility\nof collision. So here there's no collisions. We'll get to\ncollisions in a moment,",
    "start": "965254",
    "end": "971040"
  },
  {
    "text": "but a collision\nis when two items go to the same\nslot in this table.",
    "start": "971040",
    "end": "976330"
  },
  {
    "text": "And we defined the problem\nso there weren't collisions. We said whenever we insert\nitem with the same key you",
    "start": "976330",
    "end": "981390"
  },
  {
    "text": "overwrite whatever is there. So collisions are OK. They will be a problem in a\nmoment, so save your answer. Yeah?",
    "start": "981390",
    "end": "986540"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE]  PROFESSOR: Running time? AUDIENCE: [INAUDIBLE]",
    "start": "986540",
    "end": "992070"
  },
  {
    "text": "PROFESSOR: For deletion? Actually, running time\nis going to be great. If I want to insert-- I\nmean, I do these operations",
    "start": "992070",
    "end": "997860"
  },
  {
    "text": "but on array instead\nof a dictionary. So if I want insert I\njust put something there. If I want to delete I\njust set it to null.",
    "start": "997860",
    "end": "1004480"
  },
  {
    "text": "If I want to search I just\ngo there and see is it null? Yeah? AUDIENCE: It's a\ngigantic memory hog PROFESSOR: It's\ngigantic memory hog.",
    "start": "1004480",
    "end": "1010600"
  },
  {
    "text": "I like that phrasing. ",
    "start": "1010600",
    "end": "1017750"
  },
  {
    "text": "Not always of course. If it happens that your keys\nare-- the set of possible keys",
    "start": "1017750",
    "end": "1023100"
  },
  {
    "text": "is not too giant\nthen life is good. Let's see If I cannot\nkill somebody today.",
    "start": "1023100",
    "end": "1028593"
  },
  {
    "text": "Oh yes. Very good. But if you have a\nlot of keys, you need one slot in\nyour array per key.",
    "start": "1028593",
    "end": "1037849"
  },
  {
    "text": "That could be a lot. Maybe your keys are\n64-bit integers.",
    "start": "1037849",
    "end": "1043920"
  },
  {
    "text": "Then you need 264 slots just\nto store one measly dictionary. That's huge.",
    "start": "1043920",
    "end": "1050210"
  },
  {
    "text": "I guess there's also the\nrunning time of initialize that. But at the very least,\nyou have huge space hog.",
    "start": "1050210",
    "end": "1055530"
  },
  {
    "text": "This is bad. So we're going to fix both of\nthese problems one at a time.",
    "start": "1055530",
    "end": "1060820"
  },
  {
    "text": "First problem we're\ngoing to talk about is what if your keys\naren't integers?",
    "start": "1060820",
    "end": "1065991"
  },
  {
    "text": "Because if your\nkeys aren't integers you can't use this at all. So lets at least get\nsomething that works. ",
    "start": "1065991",
    "end": "1078620"
  },
  {
    "text": "And this is a notion\ncalled prehashing.  I guess different people\ncall it different things.",
    "start": "1078620",
    "end": "1085240"
  },
  {
    "text": "Unfortunately Python\ncalls it hash. It's not hashing,\nit's prehashing.",
    "start": "1085240",
    "end": "1091710"
  },
  {
    "text": "Emphasized the \"pre\" here. So prehash function\nmaps whatever keys",
    "start": "1091710",
    "end": "1099250"
  },
  {
    "text": "you have to\nnon-negative integers. ",
    "start": "1099250",
    "end": "1108314"
  },
  {
    "text": "At this point we're not\nworrying about how big those integers are. They could be giant. We're not going to fix the\nsecond problem til later.",
    "start": "1108314",
    "end": "1114920"
  },
  {
    "text": "First problem is if I have\nsome key, maybe it's a string, it's whatever, it's an object,\nhow do I map it to some integer",
    "start": "1114920",
    "end": "1122682"
  },
  {
    "text": "so I could, at least\nin principle, put it in a direct access table.",
    "start": "1122682",
    "end": "1128052"
  },
  {
    "text": "There's a theoretical\nanswer to how to do this, and then there's the practical\nanswer. how to do this. I'll start with\nthe mathematical.",
    "start": "1128052",
    "end": "1135710"
  },
  {
    "text": "In theory, I like this, keys\nare finite and discrete.",
    "start": "1135710",
    "end": "1144725"
  },
  {
    "text": " OK. We know that anything\non the computer",
    "start": "1144725",
    "end": "1150580"
  },
  {
    "text": "could, ultimately, be written\ndown as a string of bits. So a string of bits\nrepresents an integer.",
    "start": "1150580",
    "end": "1156404"
  },
  {
    "text": "So we're done. ",
    "start": "1156405",
    "end": "1164160"
  },
  {
    "text": "So in theory, this is easy. And we're going to\nassume in this class,",
    "start": "1164160",
    "end": "1170211"
  },
  {
    "text": "because it's sort\nof a theory class, that this is what's happening. At least for\nanalysis, we're always going to analyze things as\nif this is what's happening.",
    "start": "1170211",
    "end": "1177040"
  },
  {
    "text": "Now in reality, people\ndon't always do this. In particular-- I'll\ngo somewhere else.",
    "start": "1177040",
    "end": "1184059"
  },
  {
    "text": "In Python it's not\nquite so simple,",
    "start": "1184060",
    "end": "1205817"
  },
  {
    "start": "1185000",
    "end": "1355000"
  },
  {
    "text": "but at least you get\nto see what's going on. There's a function called hash,\nwhich should be called prehash,",
    "start": "1205817",
    "end": "1210940"
  },
  {
    "text": "and it, given an\nobject, it produces a non-- I'm not sure,\nactually, if it's non-negative.",
    "start": "1210940",
    "end": "1216580"
  },
  {
    "text": "It's not a big deal if it has\na minus sign because then you could just use this and\nget rid of the sign.",
    "start": "1216580",
    "end": "1221770"
  },
  {
    "text": "But it maps every\nobject to an integer, or every hashable\nobject, technically.",
    "start": "1221770",
    "end": "1227216"
  },
  {
    "text": "But pretty much\nanything can be mapped to an integer, one\nway or another. And so for example, if\nyou given it an integer",
    "start": "1227217",
    "end": "1233350"
  },
  {
    "text": "it just returns the integer. So that's pretty easy. If you give it a string\nit does something.",
    "start": "1233350",
    "end": "1239299"
  },
  {
    "text": "I don't know exactly\nwhat it does, but there are some issues. For example, hash of\nthis string, backslash 0B",
    "start": "1239300",
    "end": "1251668"
  },
  {
    "text": "is equal to the hash of\nbackslash 0 backslash 0C 64.",
    "start": "1251668",
    "end": "1262617"
  },
  {
    "text": "It's a little tricky\nto find these examples, but they're out there. And I guess, this is\nprobably the lowest one",
    "start": "1262617",
    "end": "1268390"
  },
  {
    "text": "in a certain measure. So it's a concern. In practice you have to be\ncareful about these things",
    "start": "1268390",
    "end": "1274670"
  },
  {
    "text": "because what you'd\nlike-- in an ideal world, and in the theoretical world--\nthis prehash function of x,",
    "start": "1274670",
    "end": "1285980"
  },
  {
    "text": "if it equals the\nprehash function of y, this should only\nhappen when x=y,",
    "start": "1285980",
    "end": "1291380"
  },
  {
    "text": "when they're the same thing.  And equals equal sense, I guess,\nwould be the technical version.",
    "start": "1291380",
    "end": "1300100"
  },
  {
    "text": "Sadly, in Python this\nis not quite true. But mostly true. ",
    "start": "1300100",
    "end": "1308029"
  },
  {
    "text": "Let's see. If you define a custom\nobject, you may know this,",
    "start": "1308030",
    "end": "1313460"
  },
  {
    "text": "there is an __hash__\nmethod you can implement, which tells Python what\nto do when you call hash",
    "start": "1313460",
    "end": "1321740"
  },
  {
    "text": "of your object. If you don't, it\nuses the default of id, which is the\nphysical location",
    "start": "1321740",
    "end": "1328060"
  },
  {
    "text": "of your object in memory. So as long as your object\nisn't moving around in memory this is a pretty\ngood hash function",
    "start": "1328060",
    "end": "1333130"
  },
  {
    "text": "because no two items occupy\nthe same space in memory. So that's just implementation\nside of things.",
    "start": "1333130",
    "end": "1341429"
  },
  {
    "text": "Other implementation side\nof things is in Python,",
    "start": "1341430",
    "end": "1348010"
  },
  {
    "text": "well, there's this distinction\nbetween objects and keys, I guess you would say. You really don't want\nthis prehash function",
    "start": "1348010",
    "end": "1353980"
  },
  {
    "text": "to change value. In, say, a direct access\ntable, if you store-- you take an item, you\ncompute the prehash function",
    "start": "1353980",
    "end": "1361260"
  },
  {
    "text": "of the key in there, and you\nthrow it in, and it says, oh, prehash value is four.",
    "start": "1361260",
    "end": "1367615"
  },
  {
    "text": "Then you put it\nin position four. If that value change, then when\nyou go to search for that key, and you call prehash of that\nthing, and if it give you five,",
    "start": "1367615",
    "end": "1374780"
  },
  {
    "text": "you look in position five, and\nyou say, oh, it's not there. So prehash really\nshould not change.",
    "start": "1374780",
    "end": "1380070"
  },
  {
    "text": "If you ever implement this\nfunction don't mess with it. I mean, make sure it's\ndefined in such a way",
    "start": "1380070",
    "end": "1385260"
  },
  {
    "text": "that it doesn't\nchange over time. Otherwise, you won't be able to\nfind your items in the table.",
    "start": "1385260",
    "end": "1390622"
  },
  {
    "text": "Python can't protect\nyou from that.  This is why, for example,\nif you have a list,",
    "start": "1390622",
    "end": "1397799"
  },
  {
    "text": "which is a mutable object, you\ncannot put it into a hash table as a key value because it\nwould change over time.",
    "start": "1397800",
    "end": "1405370"
  },
  {
    "text": "Potentially, you'd append\nto the list, or whatever. All right.",
    "start": "1405370",
    "end": "1411679"
  },
  {
    "text": "So hopefully you're\nreasonably happy with this. You could also\nthink of it is we're going to assume keys are\nnon-negative integers.",
    "start": "1411680",
    "end": "1416948"
  },
  {
    "text": "But in practice,\nanything you have you can map to an integer,\none way or another.",
    "start": "1416948",
    "end": "1422770"
  },
  {
    "text": "The bigger problem\nin a certain sense, or the more interesting\nproblem is reducing space.",
    "start": "1422770",
    "end": "1428780"
  },
  {
    "text": "So how do we do that? ",
    "start": "1428780",
    "end": "1438420"
  },
  {
    "text": "This would be hashing. ",
    "start": "1438420",
    "end": "1443880"
  },
  {
    "text": "This is sort of the magic\npart of today's lecture. In case you're\nwondering, hashing",
    "start": "1443880",
    "end": "1449200"
  },
  {
    "text": "has nothing to do with hashish. Hashish is a Arabic root word\nunrelated to the Germanic,",
    "start": "1449200",
    "end": "1457610"
  },
  {
    "text": "which is hachet, I believe. Yeah. Or hacheh-- I guess,\nsomething like that.",
    "start": "1457610",
    "end": "1463340"
  },
  {
    "text": "I'm not very good at German. Which means hatchet. OK It's like you take your\nkey, and you cut it up",
    "start": "1463340",
    "end": "1468400"
  },
  {
    "text": "into little pieces, and you mix\nthem around and cut and dice, and it's like cooking. OK.",
    "start": "1468400",
    "end": "1473511"
  },
  {
    "text": "What? AUDIENCE: Hash browns. PROFESSOR: Hash\nbrowns, for example. Yeah, same root. OK.",
    "start": "1473511",
    "end": "1478780"
  },
  {
    "text": "It's like the only two English\nwords with that kind of hash. OK. In our case, it's\na verb, to hash.",
    "start": "1478780",
    "end": "1485130"
  },
  {
    "text": "It means to cut into\npieces and mix around. OK. That won't really be clear\nuntil towards the end of today's",
    "start": "1485130",
    "end": "1491130"
  },
  {
    "text": "lecture, but we\nwill eventually get to the etymology of hashing. Or, we've got the etymology,\nbut why it's, actually,",
    "start": "1491130",
    "end": "1498060"
  },
  {
    "text": "why we use that term. All right. So the big idea is we\ntake all possible keys",
    "start": "1498060",
    "end": "1510860"
  },
  {
    "text": "and we want to reduce them\ndown to some small, small set of integers. ",
    "start": "1510860",
    "end": "1543700"
  },
  {
    "text": "Let me draw a picture of that. ",
    "start": "1543700",
    "end": "1555640"
  },
  {
    "text": "So we have this giant\nspace of all possible keys.",
    "start": "1555640",
    "end": "1561765"
  },
  {
    "text": "We'll call this key space.  It's like outer\nspace, basically.",
    "start": "1561765",
    "end": "1568230"
  },
  {
    "text": "It's giant. And if we stored a\ndirect access table, this would also be giant.",
    "start": "1568230",
    "end": "1573730"
  },
  {
    "text": "And we don't want to do that. We'd like to somehow map\nusing a hash function h down",
    "start": "1573730",
    "end": "1581500"
  },
  {
    "text": "to some smaller set. How do I want to draw this? Like an array. ",
    "start": "1581500",
    "end": "1590820"
  },
  {
    "text": "So we're going to have possible\nvalues 0 up to m minus 1.",
    "start": "1590820",
    "end": "1596960"
  },
  {
    "text": "m is a new thing. It's going to be the\nsize of our hash table. Let's call the hash table. ",
    "start": "1596960",
    "end": "1605107"
  },
  {
    "text": "I think we'll call it t also. And we'd somehow like to map--",
    "start": "1605107",
    "end": "1611230"
  },
  {
    "text": "All right. So there's a giant space\nof all possible keys, but then there's a subset\nof keys that are actually",
    "start": "1611230",
    "end": "1617900"
  },
  {
    "text": "stored in this set,\nin this dictionary.",
    "start": "1617900",
    "end": "1623310"
  },
  {
    "text": "At any moment in\ntime there's some set of keys that are present. That set changes,\nbut at any moment",
    "start": "1623310",
    "end": "1630290"
  },
  {
    "text": "there's some keys that\nare actually there. k1, k2, k3, k4.",
    "start": "1630290",
    "end": "1637180"
  },
  {
    "text": "I'd like to map them to\npositions in this table. So maybe I store k2-- or\nactually, item 2 would go here.",
    "start": "1637180",
    "end": "1646590"
  },
  {
    "text": "In particular, this is when\nh of k2, if it equals zero,",
    "start": "1646590",
    "end": "1654000"
  },
  {
    "text": "then you'd put item 2 there. Item 3, let's say,\nit's at position-- wow,",
    "start": "1654000",
    "end": "1659780"
  },
  {
    "text": "3 would be a bit of a\ncoincidence, but what the hell. Maybe h or k3 equals 3.",
    "start": "1659780",
    "end": "1666630"
  },
  {
    "text": "Then you'd put item 3 here.  OK. You get the idea.",
    "start": "1666630",
    "end": "1671750"
  },
  {
    "text": "So these four items each\nhave a special position in their table. And the idea is we would\nlike to be, m to be around n.",
    "start": "1671750",
    "end": "1682880"
  },
  {
    "text": " n is the number of keys In\nthe dictionary right now.",
    "start": "1682880",
    "end": "1699280"
  },
  {
    "text": "So if we could achieve\nthat, the size of the table was proportional to the\nnumber of keys being stored in the dictionary, that would\nbe good news because then",
    "start": "1699280",
    "end": "1706970"
  },
  {
    "text": "the space is not\ngigantic and hoggish. It would just be linear,\nwhich is optimal.",
    "start": "1706970",
    "end": "1713657"
  },
  {
    "text": "So if we want to store\nm things, maybe we'll use 2m space, a 3m\nspace, but not much more. ",
    "start": "1713657",
    "end": "1721740"
  },
  {
    "text": "How the heck are we going\nto define such a function h? Well, that's the\nrest of the lecture.",
    "start": "1721740",
    "end": "1727560"
  },
  {
    "text": "But even before we\ndefine a function h, do you see any\nproblems with this? ",
    "start": "1727560",
    "end": "1735580"
  },
  {
    "text": "Yeah. AUDIENCE: [INAUDIBLE]. ",
    "start": "1735580",
    "end": "1742764"
  },
  {
    "text": "PROFESSOR: Yeah. This space over here, this\nis pigeonhole principle. The number of slots for\nyour pigeons over here is way smaller than the\nnumber of possible pigeons.",
    "start": "1742764",
    "end": "1750240"
  },
  {
    "text": "So there are going\nto be two keys that map to the same slot\nin the hash table.",
    "start": "1750240",
    "end": "1756990"
  },
  {
    "text": "This is what we\ncall a collision.  Let's call this, I\ndon't know, ki, kj.",
    "start": "1756990",
    "end": "1764500"
  },
  {
    "text": " h of ki equals h of kj,\nbut the keys are different.",
    "start": "1764500",
    "end": "1775500"
  },
  {
    "text": "So ki does not equal kj,\nyet their hash functions",
    "start": "1775500",
    "end": "1780920"
  },
  {
    "text": "are the same, hash\nvalues are the same. We call that a collision. And that's guaranteed to\nhappen a lot, yet somehow,",
    "start": "1780920",
    "end": "1788990"
  },
  {
    "text": "we can still make this work. That's the magic. ",
    "start": "1788990",
    "end": "1797640"
  },
  {
    "text": "And that is going\nto be chaining. We've done these guys. Next up is a technique for\ndealing with collisions.",
    "start": "1797640",
    "end": "1805263"
  },
  {
    "text": "There are two techniques\nfor dealing with collisions we're going to\ntalk about in 006. One is called chaining,\nand next Tuesday, we'll",
    "start": "1805264",
    "end": "1811720"
  },
  {
    "text": "see another method\ncalled open addressing. But let's start with chaining.",
    "start": "1811720",
    "end": "1817169"
  },
  {
    "start": "1815000",
    "end": "2040000"
  },
  {
    "text": " The idea with chaining a simple.",
    "start": "1817170",
    "end": "1824730"
  },
  {
    "text": "If you have multiple items\nhere all with the same-- that hash to the same position,\njust store them as a list.",
    "start": "1824730",
    "end": "1832860"
  },
  {
    "text": "I'm going to draw\nit as a linked list. ",
    "start": "1832860",
    "end": "1862850"
  },
  {
    "text": "I think I need a\nbig picture here. ",
    "start": "1862850",
    "end": "1887710"
  },
  {
    "text": "So we have our nice universe,\nvarious keys that we actually",
    "start": "1887710",
    "end": "1895270"
  },
  {
    "text": "have present. So these are the keys\nin the dictionary,",
    "start": "1895270",
    "end": "1902740"
  },
  {
    "text": "and this is all of key space. ",
    "start": "1902740",
    "end": "1913170"
  },
  {
    "text": "These guys map to\nslots in the table. Some of them might\nmap to the same value.",
    "start": "1913170",
    "end": "1918490"
  },
  {
    "text": "So let's say k1 and k2,\nsuppose they collide.",
    "start": "1918490",
    "end": "1924975"
  },
  {
    "text": "So they both go this slot. What we're going to store\nhere is a linked list",
    "start": "1924975",
    "end": "1931230"
  },
  {
    "text": "that stores item 1,\nand stores a pointer",
    "start": "1931230",
    "end": "1936750"
  },
  {
    "text": "to the next item,\nwhich is item 2. And that's the end of the list.",
    "start": "1936750",
    "end": "1943380"
  },
  {
    "text": "Or you could-- however\nyou want to draw a null. So however many items\nthere are, we're",
    "start": "1943380",
    "end": "1950320"
  },
  {
    "text": "going to have a linked list\nof that length in that slot. So in particular, if there's\njust one item, like say,",
    "start": "1950320",
    "end": "1957440"
  },
  {
    "text": "this k3 here, maybe it\njust maps to this slot. And maybe that's all\nthat maps to that slot.",
    "start": "1957440",
    "end": "1964350"
  },
  {
    "text": "In that case, we just\nsay, follow this item 3, and there's no other items.",
    "start": "1964350",
    "end": "1970370"
  },
  {
    "text": "Some slots are going\nto be completely empty. There nothing there so you\njust store a null pointer.",
    "start": "1970370",
    "end": "1976440"
  },
  {
    "text": "That is hashing with chaining. It's pretty simple,\nvery simple really.",
    "start": "1976440",
    "end": "1982350"
  },
  {
    "text": "The only question is why would\nyou expect it to be any good? Because, in the worst case,\nif you fix your hash function",
    "start": "1982350",
    "end": "1988960"
  },
  {
    "text": "here, h, there's going to\nbe a whole bunch of keys that all map to the same slot. And so in the worst case, those\nare the keys that you insert,",
    "start": "1988960",
    "end": "1996330"
  },
  {
    "text": "and they all go here. And then you have this\nfancy data structure. And in the end, all you have is\na linked list of all n items.",
    "start": "1996330",
    "end": "2003100"
  },
  {
    "text": "So the worst case is theta n.",
    "start": "2003100",
    "end": "2010950"
  },
  {
    "text": "And this is going to be true for\nany hashing scheme, actually. In the worst case,\nhashing sucks.",
    "start": "2010950",
    "end": "2016710"
  },
  {
    "text": "Yet in practice, it works\nreally, really well. And the reason is\nrandomization, essentially,",
    "start": "2016710",
    "end": "2021960"
  },
  {
    "text": "that this hash function,\nunless you're really unlucky, the hash function will\nnicely distribute your items,",
    "start": "2021960",
    "end": "2028270"
  },
  {
    "text": "and most of these lists\nwill have constant length. We're going to prove\nthat under an assumption.",
    "start": "2028270",
    "end": "2040720"
  },
  {
    "start": "2040000",
    "end": "2250000"
  },
  {
    "text": "Well have to warm\nup a little bit. ",
    "start": "2040720",
    "end": "2047000"
  },
  {
    "text": "But I'm also going to cop\nout a little m as you'll see. ",
    "start": "2047000",
    "end": "2062960"
  },
  {
    "text": "So in 006 we're going to make\nan assumption called Simple Uniform Hashing.",
    "start": "2062960",
    "end": "2069080"
  },
  {
    "text": "OK. And this is an assumption,\nit's an unrealistic assumption.",
    "start": "2069080",
    "end": "2075849"
  },
  {
    "text": "I would go so far as to say\nit's false, a false assumption. But it's really\nconvenient for analysis,",
    "start": "2075850",
    "end": "2082236"
  },
  {
    "text": "and it's going to\nmake it obvious why chaining is a good idea. Sadly, the assumption\nisn't quite true,",
    "start": "2082236",
    "end": "2088138"
  },
  {
    "text": "but it gives you a flavor. If you want to see why\nhashing is actually good, I'm going to hint at it\nat the end of lecture",
    "start": "2088139",
    "end": "2093955"
  },
  {
    "text": "but really should\ntake 6.046 Yeah. AUDIENCE: [INAUDIBLE] question. Is the hashing\nfunction [INAUDIBLE]?",
    "start": "2093955",
    "end": "2099182"
  },
  {
    "text": "Like, how do we know the\narray is still [INAUDIBLE]? PROFESSOR: OK. The hashing function-- I guess\nI didn't specify up here.",
    "start": "2099182",
    "end": "2107619"
  },
  {
    "text": "The hashing function maps\nyour universe to 0, 1,",
    "start": "2107620",
    "end": "2114160"
  },
  {
    "text": "up to m minus 1,\nThat's the definition. So it's guaranteed to reduce the\nspace of keys to just m slots.",
    "start": "2114160",
    "end": "2123090"
  },
  {
    "text": "So your hashing function\nneeds to know what m is. In reality there's not going\nto be one hashing function, there's going to be 1 for each\nm, or at least one for each m.",
    "start": "2123090",
    "end": "2130669"
  },
  {
    "text": "And so, depending on\nhow big your table is, you use the corresponding\nhash function. Yeah, good question. So the hash function\nis what does",
    "start": "2130669",
    "end": "2136545"
  },
  {
    "text": "the work of reducing\nyour key space down to small set of slots. So that's what's going\nto give us low space.",
    "start": "2136545",
    "end": "2144180"
  },
  {
    "text": "OK. But now, how do we get low time? Let me just state this\nassumption and get to business.",
    "start": "2144180",
    "end": "2149255"
  },
  {
    "start": "2149255",
    "end": "2193299"
  },
  {
    "text": "Simply, uniform hashing\nis, essentially, two probabilistic assumptions. The first one is uniformity.",
    "start": "2193300",
    "end": "2201360"
  },
  {
    "text": "If you take some\nkey in your space that you want to store\nthe hash function maps it to a uniform\nrandom choice.",
    "start": "2201360",
    "end": "2209230"
  },
  {
    "text": "This is, of course, is\nwhat you want to happen. Each of these slots here is\nequally likely to be hashed to.",
    "start": "2209230",
    "end": "2218271"
  },
  {
    "text": "OK. That's a good start. But to do proper analysis,\nnot only do we uniformity,",
    "start": "2218271",
    "end": "2223550"
  },
  {
    "text": "we also need independence. So not only is this true\nfor each key individually, but it's true for all\nthe keys together.",
    "start": "2223550",
    "end": "2230210"
  },
  {
    "text": "So if key one maps to\na uniform random place, no matter where it\ngoes, key two also",
    "start": "2230210",
    "end": "2236840"
  },
  {
    "text": "matches to a uniform\nrandom place. And no matter\nwhere those two go, key three maps to a\nuniform random place.",
    "start": "2236840",
    "end": "2242040"
  },
  {
    "text": "This really can't be true. But if it's true, we can prove\nthat this takes constant time.",
    "start": "2242040",
    "end": "2247829"
  },
  {
    "text": "So let me do that. ",
    "start": "2247830",
    "end": "2261180"
  },
  {
    "start": "2250000",
    "end": "2530000"
  },
  {
    "text": "So under this assumption,\nwe can analyze hashing-- hashing with chaining\nis what this method is called.",
    "start": "2261180",
    "end": "2271400"
  },
  {
    "text": "So let's do it I want to know-- I\ngot to cheat, sorry.",
    "start": "2271400",
    "end": "2279318"
  },
  {
    "text": "I got to remember the notation.  I don't have any\ngood notation here.",
    "start": "2279319",
    "end": "2285460"
  },
  {
    "text": "All right. What I'd like to know is the\nexpected length of a chain.",
    "start": "2285460",
    "end": "2292965"
  },
  {
    "start": "2292965",
    "end": "2298460"
  },
  {
    "text": "OK. Now this is if I have n keys\nthat are stored in the table,",
    "start": "2298460",
    "end": "2305160"
  },
  {
    "text": "and m slots in the\ntable, then what is the expected\nlength of a chain?",
    "start": "2305160",
    "end": "2312030"
  },
  {
    "text": "Any suggestions. Yeah. AUDIENCE: 1 over m to the n. PROFESSOR: 1 over m to the n?",
    "start": "2312030",
    "end": "2317480"
  },
  {
    "text": "That's going to be a\nprobability of something. Not quite. AUDIENCE: [INAUDIBLE]",
    "start": "2317480",
    "end": "2323369"
  },
  {
    "text": "PROFESSOR: That's\nbetween 0 and 1. It's probably at least\none, or something. Yeah. AUDIENCE: m over n.",
    "start": "2323370",
    "end": "2329190"
  },
  {
    "text": "PROFESSOR: n over m, yeah. ",
    "start": "2329190",
    "end": "2334630"
  },
  {
    "text": "It's really easy. The chance of a key going to\na particular slot is 1 over m.",
    "start": "2334630",
    "end": "2340010"
  },
  {
    "text": "They're all independent, so\nit's 1 over m, plus 1 over m, plus 1 over m, n times.",
    "start": "2340010",
    "end": "2345160"
  },
  {
    "text": "So it's n over m. This is really easy when\nyou have independence.",
    "start": "2345160",
    "end": "2350730"
  },
  {
    "text": "Sadly, in the real world,\nyou don't have independence. We're going to call\nthis thing alpha,",
    "start": "2350730",
    "end": "2355806"
  },
  {
    "text": "and it's also known as the\nload factor of the table.",
    "start": "2355806",
    "end": "2361559"
  },
  {
    "text": "So if it's one, n equals m. And so the length\nof a chain is one.",
    "start": "2361560",
    "end": "2367650"
  },
  {
    "text": "If it's 10, then you have\n10 times as many elements as you have slots. But still, the expected\nlength of a chain is 10.",
    "start": "2367650",
    "end": "2374559"
  },
  {
    "text": "That's a constant. It's OK. If it's a 12, that's OK. It means that you have a bigger\ntable than you have items.",
    "start": "2374560",
    "end": "2381080"
  },
  {
    "text": "As long as it's a constant,\nas long as we have-- I erased it by now-- as\nlong as m is theta n,",
    "start": "2381080",
    "end": "2389817"
  },
  {
    "text": "this is going to be constant. ",
    "start": "2389817",
    "end": "2395730"
  },
  {
    "text": "And so we need to\nmaintain this property. But as long as you set your\ntable size to the right value, to be roughly n, this\nwill be constant.",
    "start": "2395730",
    "end": "2404730"
  },
  {
    "text": "And so the running time of\nan operation, insert, delete,",
    "start": "2404730",
    "end": "2412900"
  },
  {
    "text": "and search-- Well,\nsearch is really the hardest because when you\nwant to search for a key,",
    "start": "2412900",
    "end": "2420430"
  },
  {
    "text": "you map it into your table,\nthen you walk the linked list and look for the key that\nyou're searching for.",
    "start": "2420430",
    "end": "2426692"
  },
  {
    "text": "Now is this the key\nyou're searching for? No, it's not the key\nyou're searching for. Is this the key\nyou're searching for?",
    "start": "2426692",
    "end": "2431957"
  },
  {
    "text": "Those are not the keys\nyou're searching for. You keep going. Either you find your\nkey or you don't. But in the worst case, you\nhave to walk the entire list.",
    "start": "2431957",
    "end": "2440266"
  },
  {
    "text": "Sorry for the bad Star\nTrek reference-- Star Wars. God. I'm not awake.",
    "start": "2440267",
    "end": "2445930"
  },
  {
    "text": "All right. In general, the running\ntime, in the worst case, is 1 plus the length\nof your chain.",
    "start": "2445930",
    "end": "2453785"
  },
  {
    "text": " OK. So it's going to\nbe 1 plus alpha.",
    "start": "2453785",
    "end": "2459340"
  },
  {
    "text": "Why do I write one? Well, because alpha can be much\nsmaller than 1, in general.",
    "start": "2459340",
    "end": "2464930"
  },
  {
    "text": "And you always have\nto pay the cost of computing the hash function. We're going to assume\nthat takes constant time.",
    "start": "2464930",
    "end": "2470770"
  },
  {
    "text": "And then you have to\nfollow the first pointer. So you always pay constant time,\nbut then you also pay alpha.",
    "start": "2470770",
    "end": "2477589"
  },
  {
    "text": "That's your expected life. OK. That's the analysis. It's super simple.",
    "start": "2477590",
    "end": "2483079"
  },
  {
    "text": "If you assume Simple\nUniform Hashing, it's clear, as long as your load\nfactor is constant, m theta n,",
    "start": "2483080",
    "end": "2490550"
  },
  {
    "text": "you get constant running\ntime for all your operations. Life is good. This is the intuition\nof why hashing works.",
    "start": "2490550",
    "end": "2497010"
  },
  {
    "text": "It's not really\nwhy hashing works. But it's about as far as\nwe're going to get in 006.",
    "start": "2497010",
    "end": "2503175"
  },
  {
    "text": "I'm going to tell\nyou a little bit more about why hashing is actually\ngood to practice and in theory.",
    "start": "2503176",
    "end": "2509380"
  },
  {
    "start": "2509380",
    "end": "2526819"
  },
  {
    "text": "What are we up to? Last topic is hash functions.",
    "start": "2526820",
    "end": "2532740"
  },
  {
    "start": "2530000",
    "end": "2880000"
  },
  {
    "text": "The one remaining thing\nis how do I construct h? How do I actually map from\nthis giant universe of keys",
    "start": "2532740",
    "end": "2539799"
  },
  {
    "text": "to this small set of slots in\nthe table, there's m of them?",
    "start": "2539800",
    "end": "2544961"
  },
  {
    "text": " I'm going to give you three hash\nfunctions, two of which are,",
    "start": "2544961",
    "end": "2554140"
  },
  {
    "text": "let's say, common practice, and\nthe third of which is actually theoretically good. So the first two are\nnot good theoretically.",
    "start": "2554140",
    "end": "2560930"
  },
  {
    "text": "You can prove that they're\nbad, but at least they give you some\nflavor, and they're still common in practice because\na lot of the time they're OK,",
    "start": "2560930",
    "end": "2571979"
  },
  {
    "text": "but you can't really\nprove much about them.  OK.",
    "start": "2571979",
    "end": "2576990"
  },
  {
    "text": "So first method, sort\nof the obvious one,",
    "start": "2576990",
    "end": "2583000"
  },
  {
    "text": "called the division method. And if you have\na key, this could be a giant key, huge\nuniverse of keys,",
    "start": "2583000",
    "end": "2589950"
  },
  {
    "text": "you just take that\nkey, modulo m, that gives you a number\nbetween zero and m minus 1.",
    "start": "2589950",
    "end": "2596190"
  },
  {
    "text": "Done. It's so easy. I'm not going to\ntell you in detail why this is a bad method.",
    "start": "2596190",
    "end": "2602660"
  },
  {
    "text": "Maybe you can think about it. It's especially bad if m has\nsome common factors with k.",
    "start": "2602660",
    "end": "2609890"
  },
  {
    "text": "Like, let's say\nk is even always, and m is even also\nbecause you say,",
    "start": "2609890",
    "end": "2614974"
  },
  {
    "text": "oh, I'd like a table the\nsize of power of two. That seems natural. Then that will be really\nbad because you'll use only half the table.",
    "start": "2614974",
    "end": "2621650"
  },
  {
    "text": "There are lots of situations\nwhere this is bad. In practice, it's pretty good. If m is prime, you always\nchoose a prime table size,",
    "start": "2621650",
    "end": "2629435"
  },
  {
    "text": "so you don't have\nthose common factors. And it's not very close to\na power of 2 or power of 10",
    "start": "2629436",
    "end": "2634610"
  },
  {
    "text": "because real world powers\nof 2's and 10's are common. But it's very hackish, OK?",
    "start": "2634610",
    "end": "2639740"
  },
  {
    "text": "It works a lot of the\ntime but not always. A cooler method-- I think\nit's cooler-- still,",
    "start": "2639740",
    "end": "2647570"
  },
  {
    "text": "you can't prove much\nabout it-- Division didn't",
    "start": "2647570",
    "end": "2654290"
  },
  {
    "text": "seem to work so great, so\nhow about multiplication? What does that mean? Multiply by m, that\nwouldn't be very good.",
    "start": "2654290",
    "end": "2660420"
  },
  {
    "text": "Now, it's a bit different. We're going to take the key,\nmultiply it by an integer, a,",
    "start": "2660420",
    "end": "2670780"
  },
  {
    "text": "and then we're going to do\nthis crazy, crazy stuff. Take it mod 2 to the w and\nthen shift it right, w minus r.",
    "start": "2670780",
    "end": "2681920"
  },
  {
    "text": "OK. What is w? We're assuming that\nwe're in a w-bit machine.",
    "start": "2681920",
    "end": "2688380"
  },
  {
    "text": "Remember way back in\nmodels of computation? Your machine has a\nword size, it's w bits.",
    "start": "2688380",
    "end": "2694720"
  },
  {
    "text": "So let's suppose it's w bits. So we have our key, k. Here it is.",
    "start": "2694720",
    "end": "2700050"
  },
  {
    "text": "It's w bits long.  We take some number,\na-- think of a as being",
    "start": "2700050",
    "end": "2707339"
  },
  {
    "text": "a random integer among all\npossible w bit integers. So it's got some zeros,\nit's got some ones.",
    "start": "2707340",
    "end": "2717140"
  },
  {
    "text": "And I multiply these. What does multiplication\nmean in binary? Well, I take one of these copies\nof k for each one that's here.",
    "start": "2717140",
    "end": "2725559"
  },
  {
    "text": "So I'm going to\ntake one copy here because there's a one there. I'm going to take one copy here\nbecause there's a one there.",
    "start": "2725560",
    "end": "2732560"
  },
  {
    "text": "And I'm going to\ntake one copy here because there's a one there.",
    "start": "2732560",
    "end": "2737860"
  },
  {
    "text": "And on average, half\nof them will be ones. So I have various copies of k,\nand then I just add them up.",
    "start": "2737860",
    "end": "2746150"
  },
  {
    "text": "And you know, stuff happens. I get some gobbledygook here. OK. How big is it?",
    "start": "2746150",
    "end": "2751270"
  },
  {
    "text": "In general, it's two words long. When I multiply two\nwords I get two words.",
    "start": "2751270",
    "end": "2757089"
  },
  {
    "text": "It could be twice\nas long, in general. And what this business is doing\nis saying take the right word,",
    "start": "2757090",
    "end": "2763480"
  },
  {
    "text": "this right half here-- let\nthe right word in, I guess,",
    "start": "2763480",
    "end": "2768590"
  },
  {
    "text": "if you see vampire\nmovies-- and then shift right-- this is a shift right\noperation-- by w minus r.",
    "start": "2768590",
    "end": "2776704"
  },
  {
    "text": "I didn't even say what r is. But basically, what\nI want is these bits. I want r bits here--\nthis is w bits.",
    "start": "2776704",
    "end": "2784779"
  },
  {
    "text": "I want the leftmost r bits\nof the rightmost w bits because I shift right here\nand get rid of all these guys.",
    "start": "2784780",
    "end": "2792510"
  },
  {
    "text": "r-- I should say,\nm, is two to the r. So I'm going to\nassume here I have",
    "start": "2792510",
    "end": "2798060"
  },
  {
    "text": "a table of size a power of\n2, and then this number will be a number between\n0 and m minus 1.",
    "start": "2798060",
    "end": "2807440"
  },
  {
    "text": "OK. Why does this work? It's intuitive. In practice it works quite\nwell because what you're",
    "start": "2807440",
    "end": "2814390"
  },
  {
    "text": "doing is taking a whole\nbunch of sort of randomly shifted copies of k, adding\nthem up-- you get carries,",
    "start": "2814390",
    "end": "2820200"
  },
  {
    "text": "things get mixed\nup-- This is hashing. This is-- you're taking\nk, sort of cutting it up while you're shifting it around,\nadding things and they collide,",
    "start": "2820200",
    "end": "2828040"
  },
  {
    "text": "and weird stuff happens. You sort of randomize stuff. Out here, you don't\nget much randomization",
    "start": "2828040",
    "end": "2833440"
  },
  {
    "text": "because most-- like\nthe last bit could just be this one bit of k. But in the middle, everybody's\nkind of colliding together.",
    "start": "2833440",
    "end": "2839730"
  },
  {
    "text": "And so intuitively,\nyou're mixing lots of things in the center. You take those r bits,\nroughly, in the center.",
    "start": "2839730",
    "end": "2845309"
  },
  {
    "text": "That will be nicely mixed up. And most of the time\nthis works well. In practice it works well-- I\nhave some things written here.",
    "start": "2845310",
    "end": "2853950"
  },
  {
    "text": "a better be odd, otherwise\nyou're throwing away stuff. And it should not be very\nclose to a power of 2.",
    "start": "2853950",
    "end": "2859980"
  },
  {
    "text": "But it should be in between 2\nto the r minus 1 and 2 to the r. Cool.",
    "start": "2859980",
    "end": "2867080"
  },
  {
    "text": "One more. ",
    "start": "2867080",
    "end": "2872750"
  },
  {
    "text": "Again, theoretically,\nthis can be bad. And I leave it as an exercise\nto find situations, find",
    "start": "2872750",
    "end": "2877930"
  },
  {
    "text": "key values where this\ndoes not do a good job. ",
    "start": "2877930",
    "end": "2883790"
  },
  {
    "start": "2880000",
    "end": "3075000"
  },
  {
    "text": "The cool method is\ncalled universal hashing. ",
    "start": "2883790",
    "end": "2891120"
  },
  {
    "text": "This is something that's a\nbit beyond the scope of 006. If you want to understand it\nbetter you should take 046.",
    "start": "2891120",
    "end": "2897440"
  },
  {
    "text": "But I'll give you the flavor and\nthe method, one of the methods. There's actually\nmany ways to do this.",
    "start": "2897440",
    "end": "2903020"
  },
  {
    "start": "2903020",
    "end": "2913690"
  },
  {
    "text": "We see a mod m on the outside. That's just division method just\nto make the number between 0 and a minus 1.",
    "start": "2913690",
    "end": "2919760"
  },
  {
    "text": "Here's our key. And then there's\nthese numbers a and b. These are going to be\nrandom numbers between 0",
    "start": "2919760",
    "end": "2929220"
  },
  {
    "text": "and p minus 1. What's p? Prime number bigger than\nthe size of the universe.",
    "start": "2929220",
    "end": "2938660"
  },
  {
    "text": "So it's a big prime number. I think we know how\nto find prime numbers.",
    "start": "2938660",
    "end": "2943869"
  },
  {
    "text": "We don't know in this\nclass, but people know how to find\nthe prime numbers. So there's a subroutine\nhere, find a big prime number",
    "start": "2943870",
    "end": "2949977"
  },
  {
    "text": "bigger than your universe. It's not too hard to do that. We can do it in polynomial time.",
    "start": "2949977",
    "end": "2955369"
  },
  {
    "text": "That's just set up. You do that once for\na given size table. And then you choose two\nrandom numbers, a and b.",
    "start": "2955369",
    "end": "2963916"
  },
  {
    "text": "And then this is the\nhash function, a times k plus b, mod p mod m.",
    "start": "2963916",
    "end": "2968980"
  },
  {
    "text": "OK. What does this do? It turns out-- here's\nthe interesting part.",
    "start": "2968980",
    "end": "2975810"
  },
  {
    "text": "For worst case keys, k1\nand k2, that are distinct,",
    "start": "2975810",
    "end": "2985260"
  },
  {
    "text": "the probability of h of k1\nequaling h of k2 is 1 over n.",
    "start": "2985260",
    "end": "2996650"
  },
  {
    "text": "So probability of two keys\nthat are different colliding is 1 over m, for\nthe worst case keys.",
    "start": "2996650",
    "end": "3003072"
  },
  {
    "text": "What the heck does that mean? What's the probability over? Any suggestions?",
    "start": "3003072",
    "end": "3008390"
  },
  {
    "text": "What's random here? AUDIENCE: a and b. PROFESSOR: a and b. This is the probability\nover a and b.",
    "start": "3008390",
    "end": "3015250"
  },
  {
    "text": "This is the probability over the\nchoice of your hash function. So it's the worst case\ninputs, worst case insertions,",
    "start": "3015250",
    "end": "3022030"
  },
  {
    "text": "but random hash function. As long as you choose\nyour random hash function, the probability of\ncollision is 1 over m.",
    "start": "3022030",
    "end": "3028550"
  },
  {
    "text": "This is the ideal situation And so you can prove, just\nlike we analyzed here--",
    "start": "3028550",
    "end": "3034140"
  },
  {
    "text": "It's a little more work. It's in the notes. You use linearity\nof expectation. And you can prove, still,\nthat the expected length",
    "start": "3034140",
    "end": "3039700"
  },
  {
    "text": "of a chain-- the expected number\nof collisions that a key has with another key is the load\nfactor, in the worst case,",
    "start": "3039700",
    "end": "3048720"
  },
  {
    "text": "but in expectation for\na given hash function. So still, the expected\nlength of a chain, and therefore, the\nexpected running time",
    "start": "3048720",
    "end": "3055400"
  },
  {
    "text": "of hashing with chaining,\nusing this hash function, or this collection of hash\nfunctions, or a randomly chosen",
    "start": "3055400",
    "end": "3060750"
  },
  {
    "text": "one, is constant for\nconstant load factor. And that's why hashing\nreally works in theory. We're not going to go into\ndetails of this again.",
    "start": "3060750",
    "end": "3067730"
  },
  {
    "text": "Take 6.046 if you want to know. But this should make you\nfeel more comfortable. And we'll see other ways\ndo hashing next class.",
    "start": "3067730",
    "end": "3075490"
  }
]