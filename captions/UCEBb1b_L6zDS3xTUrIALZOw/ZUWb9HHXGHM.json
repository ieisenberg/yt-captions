[
  {
    "start": "0",
    "end": "0"
  },
  {
    "text": "One of the most useful abstractions provided\nby high-level languages is the notion of a",
    "start": "229",
    "end": "5140"
  },
  {
    "text": "procedure or subroutine, which is a sequence\nof instructions that perform a specific task.",
    "start": "5140",
    "end": "10169"
  },
  {
    "text": "A procedure has a single named entry point,\nwhich can be used to refer to the procedure",
    "start": "10169",
    "end": "15209"
  },
  {
    "text": "in other parts of the program.",
    "start": "15210",
    "end": "17190"
  },
  {
    "text": "In the example here, this code is defining\nthe GCD procedure, which is declared to return",
    "start": "17190",
    "end": "22650"
  },
  {
    "text": "an integer value.",
    "start": "22650",
    "end": "25810"
  },
  {
    "text": "Procedures have zero or more formal parameters,\nwhich are the names the code inside the procedure",
    "start": "25810",
    "end": "30689"
  },
  {
    "text": "will use to refer the values supplied when\nthe procedure is invoked by a \"procedure call\".",
    "start": "30689",
    "end": "34772"
  },
  {
    "text": "A procedure call is an expression that has\nthe name of the procedure followed by parenthesized",
    "start": "34772",
    "end": "41000"
  },
  {
    "text": "list of values called \"arguments\" that will\nbe matched up with the formal parameters.",
    "start": "41000",
    "end": "46809"
  },
  {
    "text": "For example, the value of the first argument\nwill become the value of the first formal",
    "start": "46809",
    "end": "50989"
  },
  {
    "text": "parameter while the procedure is executing.",
    "start": "50990",
    "end": "53519"
  },
  {
    "text": "The body of the procedure may define additional\nvariables, called \"local variables\", since",
    "start": "53519",
    "end": "57840"
  },
  {
    "text": "they can only be accessed by statements in\nthe procedure body.",
    "start": "57840",
    "end": "62019"
  },
  {
    "text": "Conceptually, the storage for local variables\nonly exists while the procedure is executing.",
    "start": "62019",
    "end": "67790"
  },
  {
    "text": "They are allocated when the procedure is invoked\nand deallocated when the procedure returns.",
    "start": "67790",
    "end": "72890"
  },
  {
    "text": "The procedure may return a value that's the\nresult of the procedure's computation.",
    "start": "72890",
    "end": "77750"
  },
  {
    "text": "It's legal to have procedures that do not\nreturn a value, in which case the procedures",
    "start": "77750",
    "end": "82220"
  },
  {
    "text": "would only be executed for their \"side effects\",\ne.g., changes they make to shared data.",
    "start": "82220",
    "end": "87500"
  },
  {
    "text": "Here we see another procedure, COPRIMES, that\ninvokes the GCD procedure to compute the greatest",
    "start": "87500",
    "end": "92860"
  },
  {
    "text": "common divisor of two numbers.",
    "start": "92860",
    "end": "96130"
  },
  {
    "text": "To use GCD, the programmer of COPRIMES only\nneeded to know the input/output behavior of",
    "start": "96130",
    "end": "103060"
  },
  {
    "text": "GCD, i.e., the number and types of the arguments\nand what type of value is returned as a result.",
    "start": "103060",
    "end": "108280"
  },
  {
    "text": "The procedural abstraction has hidden the\nimplementation of GCD, while still making",
    "start": "108280",
    "end": "112640"
  },
  {
    "text": "its functionality available as a \"black box\".",
    "start": "112640",
    "end": "116590"
  },
  {
    "text": "This is a very powerful idea: encapsulating\na complex computation so that it can be used",
    "start": "116590",
    "end": "122320"
  },
  {
    "text": "by others.",
    "start": "122320",
    "end": "124110"
  },
  {
    "text": "Every high-level language comes with a collection\nof pre-built procedures, called \"libraries\",",
    "start": "124110",
    "end": "129410"
  },
  {
    "text": "which can be used to perform arithmetic functions\n(e.g., square root or cosine),",
    "start": "129410",
    "end": "134319"
  },
  {
    "text": "manipulate collections of data (e.g., lists\nor dictionaries), read data from files, and",
    "start": "134319",
    "end": "141500"
  },
  {
    "text": "so on - the list is nearly endless!",
    "start": "141500",
    "end": "144590"
  },
  {
    "text": "Much of the expressive power and ease-of-use\nprovided by high-level languages comes from",
    "start": "144590",
    "end": "149019"
  },
  {
    "text": "their libraries of \"black boxes\".",
    "start": "149019",
    "end": "152609"
  },
  {
    "text": "The procedural abstraction is at the heart\nof object-oriented languages, which encapsulate",
    "start": "152609",
    "end": "157540"
  },
  {
    "text": "data and procedures as black boxes called\nobjects that support specific operations on",
    "start": "157540",
    "end": "162999"
  },
  {
    "text": "their internal data.",
    "start": "162999",
    "end": "164920"
  },
  {
    "text": "For example, a LIST object has procedures\n(called \"methods\" in this context) for indexing",
    "start": "164920",
    "end": "170909"
  },
  {
    "text": "into the list to read or change a value, adding\nnew elements to the list, inquiring about",
    "start": "170909",
    "end": "176340"
  },
  {
    "text": "the length of the list, and so on.",
    "start": "176340",
    "end": "178909"
  },
  {
    "text": "The internal representation of the data and\nthe algorithms used to implement the methods",
    "start": "178909",
    "end": "183569"
  },
  {
    "text": "are hidden by the object abstraction.",
    "start": "183569",
    "end": "186500"
  },
  {
    "text": "Indeed, there may be several different LIST\nimplementations to choose from depending on",
    "start": "186500",
    "end": "190959"
  },
  {
    "text": "which operations you need to be particularly\nefficient.",
    "start": "190959",
    "end": "194349"
  },
  {
    "text": "Okay, enough about the virtues of the procedural\nabstraction!",
    "start": "194349",
    "end": "198909"
  },
  {
    "text": "Let's turn our attention to how to implement\nprocedures using the Beta ISA.",
    "start": "198909",
    "end": "203959"
  },
  {
    "text": "A possible implementation is to \"inline\" the\nprocedure, where we replace the procedure",
    "start": "203959",
    "end": "209049"
  },
  {
    "start": "204000",
    "end": "204000"
  },
  {
    "text": "call with a copy of the statements in the\nprocedure's body, substituting argument values",
    "start": "209049",
    "end": "214049"
  },
  {
    "text": "for references to the formal parameters.",
    "start": "214049",
    "end": "216819"
  },
  {
    "text": "In this approach we're treating procedures\nvery much like UASM macros, i.e., a simple",
    "start": "216819",
    "end": "222379"
  },
  {
    "text": "notational shorthand for making a copy of\nthe procedure's body.",
    "start": "222379",
    "end": "226579"
  },
  {
    "text": "Are there any problems with this approach?",
    "start": "226579",
    "end": "229860"
  },
  {
    "text": "One obvious issue is the potential increase\nin the code size.",
    "start": "229860",
    "end": "233819"
  },
  {
    "text": "For example, if we had a lengthy procedure\nthat was called many times, the final expanded",
    "start": "233819",
    "end": "239349"
  },
  {
    "text": "code would be huge!",
    "start": "239349",
    "end": "241609"
  },
  {
    "text": "Enough so that inlining isn't a practical\nsolution except in the case of short procedures",
    "start": "241609",
    "end": "246769"
  },
  {
    "text": "where optimizing compilers do sometimes decide\nto inline the code.",
    "start": "246769",
    "end": "251540"
  },
  {
    "text": "A bigger difficulty is apparent when we consider\na recursive procedure where there's a nested",
    "start": "251540",
    "end": "258090"
  },
  {
    "text": "call to the procedure itself.",
    "start": "258090",
    "end": "260690"
  },
  {
    "text": "During execution the recursion will terminate\nfor some values of the arguments and the recursive",
    "start": "260690",
    "end": "265530"
  },
  {
    "text": "procedure will eventually return answer.",
    "start": "265530",
    "end": "268170"
  },
  {
    "text": "But at compile time, the inlining process\nwould not terminate and so the inlining scheme",
    "start": "268170",
    "end": "274670"
  },
  {
    "text": "fails if the language allows recursion.",
    "start": "274670",
    "end": "278510"
  },
  {
    "text": "The second option is to \"link\" to the procedure.",
    "start": "278510",
    "end": "281380"
  },
  {
    "text": "In this approach there is a single copy of\nthe procedure code which we arrange to be",
    "start": "281380",
    "end": "285230"
  },
  {
    "text": "run for each procedure call - all the procedure\ncalls are said to link to the procedure code.",
    "start": "285230",
    "end": "292530"
  },
  {
    "text": "Here the body of the procedure is translated\nonce into Beta instructions and the first",
    "start": "292530",
    "end": "296920"
  },
  {
    "text": "instruction is identified as the procedure's\nentry point.",
    "start": "296920",
    "end": "300410"
  },
  {
    "text": "The procedure call is compiled into a set\nof instructions that evaluate the argument",
    "start": "300410",
    "end": "304190"
  },
  {
    "text": "expressions and save the values in an agreed-upon\nlocation.",
    "start": "304190",
    "end": "308720"
  },
  {
    "text": "Then we'll use a BR instruction to transfer\ncontrol to the entry point of the procedure.",
    "start": "308720",
    "end": "314220"
  },
  {
    "text": "Recall that the BR instruction not only changes\nthe PC but saves the address of the instruction",
    "start": "314220",
    "end": "320160"
  },
  {
    "text": "following the branch in a specified register.",
    "start": "320160",
    "end": "323690"
  },
  {
    "text": "This saved address is the \"return address\"\nwhere we want execution to resume when procedure",
    "start": "323690",
    "end": "328760"
  },
  {
    "text": "execution is complete.",
    "start": "328760",
    "end": "331680"
  },
  {
    "text": "After branching to the entry point, the procedure\ncode runs, stores the result in an agreed-upon",
    "start": "331680",
    "end": "336490"
  },
  {
    "text": "location and then resumes execution of the\ncalling program by jumping to the supplied",
    "start": "336490",
    "end": "341389"
  },
  {
    "text": "return address.",
    "start": "341390",
    "end": "344000"
  },
  {
    "start": "344000",
    "end": "344000"
  },
  {
    "text": "To complete this implementation plan we need\na \"calling convention\" that specifies where",
    "start": "344000",
    "end": "348830"
  },
  {
    "text": "to store the argument values during procedure\ncalls and where the procedure should store",
    "start": "348830",
    "end": "352900"
  },
  {
    "text": "the return value.",
    "start": "352900",
    "end": "354300"
  },
  {
    "text": "It's tempting to simply allocate specific\nmemory locations for the job.",
    "start": "354300",
    "end": "359220"
  },
  {
    "text": "How about using registers?",
    "start": "359220",
    "end": "361360"
  },
  {
    "text": "We could pass the argument value in registers\nstarting, say, with R1.",
    "start": "361360",
    "end": "366210"
  },
  {
    "text": "The return address could be stored in another\nregister, say R28.",
    "start": "366210",
    "end": "370460"
  },
  {
    "text": "As we can see, with this convention the BR\nand JMP instructions are just what we need",
    "start": "370460",
    "end": "374900"
  },
  {
    "text": "to implement procedure call and return.",
    "start": "374900",
    "end": "377490"
  },
  {
    "text": "It's usual to call the register holding the\nreturn address the \"linkage pointer\".",
    "start": "377490",
    "end": "382060"
  },
  {
    "text": "And finally the procedure can use, say, R0\nto hold the return value.",
    "start": "382060",
    "end": "387180"
  },
  {
    "text": "Let's see how this would work when executing\nthe procedure call fact(3).",
    "start": "387180",
    "end": "390550"
  },
  {
    "text": "As shown on the right, fact(3) requires a\nrecursive call to compute fact(2), and so",
    "start": "390550",
    "end": "396810"
  },
  {
    "text": "on.",
    "start": "396810",
    "end": "397810"
  },
  {
    "text": "Our goal is to have a uniform calling convention\nwhere all procedure calls and procedure bodies",
    "start": "397810",
    "end": "403440"
  },
  {
    "text": "use the same convention for storing arguments,\nreturn addresses and return values.",
    "start": "403440",
    "end": "408100"
  },
  {
    "text": "In particular, we'll use the same convention\nwhen compiling the recursive call fact(n-1)",
    "start": "408100",
    "end": "414740"
  },
  {
    "text": "as we did for the initial call to fact(3).",
    "start": "414740",
    "end": "417780"
  },
  {
    "text": "Okay.",
    "start": "417780",
    "end": "419220"
  },
  {
    "text": "In the code shown on the right we've used\nour proposed convention when compiling the",
    "start": "419220",
    "end": "423240"
  },
  {
    "text": "Beta code for fact().",
    "start": "423240",
    "end": "425210"
  },
  {
    "text": "Let's take a quick tour.",
    "start": "425210",
    "end": "427580"
  },
  {
    "text": "To compile the initial call fact(3) the compiler\ngenerated a CMOVE instruction to put the argument",
    "start": "427580",
    "end": "433409"
  },
  {
    "text": "value in R1 and then a BR instruction to transfer\ncontrol to fact's entry point while remembering",
    "start": "433410",
    "end": "439470"
  },
  {
    "text": "the return address in R28.",
    "start": "439470",
    "end": "442890"
  },
  {
    "text": "The first statement in the body of fact tests\nthe value of the argument using CMPLEC and",
    "start": "442890",
    "end": "449461"
  },
  {
    "text": "BT instructions.",
    "start": "449461",
    "end": "452290"
  },
  {
    "text": "When n is greater than 0, the code performs\na recursive call to fact, saving the value",
    "start": "452290",
    "end": "457550"
  },
  {
    "text": "of the recursive argument n-1 in R1 as our\nconvention requires.",
    "start": "457550",
    "end": "463960"
  },
  {
    "text": "Note that we had to first save the value of\nthe original argument n because we'll need",
    "start": "463960",
    "end": "467680"
  },
  {
    "text": "it for the multiplication after the recursive\ncall returns its value in R0.",
    "start": "467680",
    "end": "474220"
  },
  {
    "text": "If n is not greater than 0, the value 1 is\nplaced in R0.",
    "start": "474220",
    "end": "479720"
  },
  {
    "text": "Then the two possible execution paths merge,\neach having generated the appropriate return",
    "start": "479720",
    "end": "485030"
  },
  {
    "text": "value in R0, and finally there's a JMP to\nreturn control to the caller.",
    "start": "485030",
    "end": "490770"
  },
  {
    "text": "The JMP instruction knows to find the return\naddress in R28, just where the BR put it as",
    "start": "490770",
    "end": "495990"
  },
  {
    "text": "part of the original procedure call.",
    "start": "495990",
    "end": "500460"
  },
  {
    "text": "Some of you may have noticed that there are\nsome difficulties with this particular implementation.",
    "start": "500460",
    "end": "505830"
  },
  {
    "text": "The code is correct in the sense that it faithfully\nimplements procedure call and return using",
    "start": "505830",
    "end": "510419"
  },
  {
    "text": "our proposed convention.",
    "start": "510420",
    "end": "512969"
  },
  {
    "text": "The problem is that during recursive calls\nwe'll be overwriting register values we need",
    "start": "512969",
    "end": "517860"
  },
  {
    "text": "later.",
    "start": "517860",
    "end": "519860"
  },
  {
    "text": "For example, note that following our calling\nconvention, the recursive call also uses R28",
    "start": "519860",
    "end": "526230"
  },
  {
    "text": "to store the return address.",
    "start": "526230",
    "end": "527959"
  },
  {
    "text": "When executed, the code for the original call\nstored the address of the HALT instruction",
    "start": "527959",
    "end": "532670"
  },
  {
    "text": "in R28.",
    "start": "532670",
    "end": "534730"
  },
  {
    "text": "Inside the procedure, the recursive call will\nstore the address of the MUL instruction in",
    "start": "534730",
    "end": "539730"
  },
  {
    "text": "R28.",
    "start": "539730",
    "end": "541060"
  },
  {
    "text": "Unfortunately that overwrites the original\nreturn address.",
    "start": "541060",
    "end": "545110"
  },
  {
    "text": "Even the attempt to save the value of the\nargument N in R2 is doomed to fail since during",
    "start": "545110",
    "end": "550610"
  },
  {
    "text": "the execution of the recursive call R2 will\nbe overwritten.",
    "start": "550610",
    "end": "555910"
  },
  {
    "text": "The crux of the problem is that each recursive\ncall needs to remember the value of its argument",
    "start": "555910",
    "end": "560878"
  },
  {
    "text": "and return address, i.e., we need two storage\nlocations for each active call to fact().",
    "start": "560879",
    "end": "567810"
  },
  {
    "text": "And while executing fact(3), when we finally\nget to calling fact(0) there are four nested",
    "start": "567810",
    "end": "573939"
  },
  {
    "text": "active calls, so we'll need 4*2 = 8 storage\nlocations.",
    "start": "573939",
    "end": "578649"
  },
  {
    "text": "In fact, the amount of storage needed varies\nwith the depth of the recursion.",
    "start": "578649",
    "end": "584860"
  },
  {
    "text": "Obviously we can't use just two registers\n(R2 and R28) to hold all the values we need",
    "start": "584860",
    "end": "589889"
  },
  {
    "text": "to save.",
    "start": "589889",
    "end": "591949"
  },
  {
    "text": "One fix is to disallow recursion!",
    "start": "591949",
    "end": "594259"
  },
  {
    "text": "And, in fact, some of the early programming\nlanguages such as FORTRAN did just that.",
    "start": "594259",
    "end": "600050"
  },
  {
    "text": "But let's see if we can solve the problem\nanother way.",
    "start": "600050",
    "end": "602429"
  }
]