[
  {
    "start": "0",
    "end": "80000"
  },
  {
    "text": " The following content is\nprovided under a Creative Commons license.",
    "start": "0",
    "end": "5310"
  },
  {
    "text": "Your support will help\nMIT OpenCourseWare continue to offer high-quality\neducational resources for free.",
    "start": "5310",
    "end": "11610"
  },
  {
    "text": "To make a donation or to\nview additional materials from hundreds of MIT courses,\nvisit MIT OpenCourseWare",
    "start": "11610",
    "end": "18140"
  },
  {
    "text": "at ocw.mit.edu.  JULIAN SHUN: Good\nafternoon, everyone.",
    "start": "18140",
    "end": "23890"
  },
  {
    "text": "Let's get started.  So welcome to the\n11th lecture of 6.172.",
    "start": "23890",
    "end": "31951"
  },
  {
    "text": "It seems that there\nare many fewer people here today than on Tuesday. [LAUGHTER]",
    "start": "31951",
    "end": "40160"
  },
  {
    "text": "All right. So today we're going to talk\nabout storage allocation. And it turns out that\nstorage allocation",
    "start": "40160",
    "end": "47170"
  },
  {
    "text": "is about both allocating\nmemory and also freeing it. But in the literature, it's\njust called storage allocation,",
    "start": "47170",
    "end": "53980"
  },
  {
    "text": "so that's the term\nwe're going to use. And whenever you do\na malloc or a free, then you're doing\nstorage allocation.",
    "start": "53980",
    "end": "59860"
  },
  {
    "text": "So how many of you have\nused malloc or free before? ",
    "start": "59860",
    "end": "65500"
  },
  {
    "text": "So hopefully all of\nyou, since you needed it",
    "start": "65500",
    "end": "70510"
  },
  {
    "text": "for the projects and homeworks. So the simplest form\nof storage is a stack.",
    "start": "70510",
    "end": "76990"
  },
  {
    "text": " And in a stack, you just\nhave an array and a pointer.",
    "start": "76990",
    "end": "84000"
  },
  {
    "start": "80000",
    "end": "80000"
  },
  {
    "text": "So here we have an\narray, which we call A, and then there's some\nportion of this array that's",
    "start": "84000",
    "end": "89910"
  },
  {
    "text": "used for memory, and the rest\nof it is free-- it's not used. And then there's a\npointer, sp, that",
    "start": "89910",
    "end": "96659"
  },
  {
    "text": "points to the end of the\nused region in this stack.",
    "start": "96660",
    "end": "102170"
  },
  {
    "text": "And if you want to allocate x\nbytes on the stack, all you do",
    "start": "102170",
    "end": "107330"
  },
  {
    "text": "is, you just increment\nthis sp pointer by x. And then, of course, you\nshould also check for overflow",
    "start": "107330",
    "end": "116450"
  },
  {
    "text": "to make sure that\nyou don't actually go off the end of this\narray, because if you do that then you'll get\na segmentation fault.",
    "start": "116450",
    "end": "123380"
  },
  {
    "text": "But actually,\nnowadays, compilers don't really check\nfor stack overflow because your stack is\nusually big enough for most",
    "start": "123380",
    "end": "131860"
  },
  {
    "text": "of your program, and when\nyou do get a stack overflow, you'll just get a segfault and\nthen you go debug your program.",
    "start": "131860",
    "end": "137390"
  },
  {
    "text": "So for efficiency reasons,\nthe stack overflow isn't actually checked.",
    "start": "137390",
    "end": "142620"
  },
  {
    "text": "OK? And then it returns a pointer\nto the beginning of the memory that you just allocated, so\nthat's just as sp minus x.",
    "start": "142620",
    "end": "151970"
  },
  {
    "text": "So that's pretty simple. And in fact, this is how\nthe C call stack works.",
    "start": "151970",
    "end": "157579"
  },
  {
    "text": "It also uses a stack discipline. So when you call a function,\nyou save local variables",
    "start": "157580",
    "end": "164960"
  },
  {
    "text": "and registers on the\nstack, and you also save the return address\nof the function that's",
    "start": "164960",
    "end": "171110"
  },
  {
    "text": "calling another function. And then, when you return,\nyou pop things off the stack.",
    "start": "171110",
    "end": "176510"
  },
  {
    "text": "So you can also free\nthings from the stack. So what you do is,\nyou just decrement sp",
    "start": "176510",
    "end": "184070"
  },
  {
    "start": "177000",
    "end": "177000"
  },
  {
    "text": "by x if you want\nto free x bytes. So here we just decremented\nsp by x, and everything",
    "start": "184070",
    "end": "192800"
  },
  {
    "text": "after sp is now\nconsidered to be free. And again, if\nyou're careful, you",
    "start": "192800",
    "end": "198110"
  },
  {
    "text": "would check for a\nstack underflow. But again, the compiler\nusually doesn't do this",
    "start": "198110",
    "end": "203690"
  },
  {
    "text": "because if you do\nhave a stack overflow, there's a bug in your program,\nand you'll get a segfault,",
    "start": "203690",
    "end": "208720"
  },
  {
    "text": "and you should go fix it.  So allocating and\nfreeing in a stack",
    "start": "208720",
    "end": "216340"
  },
  {
    "text": "takes constant time\nbecause all you have to do is manipulate the stack pointer,\nso it's pretty efficient.",
    "start": "216340",
    "end": "225170"
  },
  {
    "text": "However, you have\nto free consistently with the stack discipline. So the stack has\nlimited applicability.",
    "start": "225170",
    "end": "233709"
  },
  {
    "text": "Does anybody see why\nyou can't do everything with just a stack? So what's one\nlimitation of the stack?",
    "start": "233710",
    "end": "240640"
  },
  {
    "start": "240640",
    "end": "245920"
  },
  {
    "text": "Yes? AUDIENCE: [INAUDIBLE] JULIAN SHUN: So it turns\nout that you can actually",
    "start": "245920",
    "end": "252849"
  },
  {
    "text": "pass a compile time constant\nto make the stack bigger if you wanted to. There's actually a more\nfundamental limitation",
    "start": "252850",
    "end": "258730"
  },
  {
    "text": "of the stack. Yes. AUDIENCE: You can\nonly read things in the reverse order in\nwhich you allocate them.",
    "start": "258730",
    "end": "265192"
  },
  {
    "text": "JULIAN SHUN: Yeah, so the\nanswer is that you can only free the last thing\nthat you allocated, so there's no way\nto free anything",
    "start": "265192",
    "end": "271870"
  },
  {
    "text": "in the middle of this\nused region here. You have to free\nthe last thing here because the stack doesn't\nkeep track of the objects",
    "start": "271870",
    "end": "279070"
  },
  {
    "start": "273000",
    "end": "273000"
  },
  {
    "text": "in the middle of\nthis used region. So there's limited\napplicability,",
    "start": "279070",
    "end": "284110"
  },
  {
    "text": "but it's great when it works\nbecause it's very efficient, and all of this code can\nessentially be inline.",
    "start": "284110",
    "end": "289660"
  },
  {
    "text": "You don't have to have\nany function calls, so it's very fast. And it also turns\nout that you can",
    "start": "289660",
    "end": "296110"
  },
  {
    "text": "allocate on the call stack using\nthis function called alloca. It's actually not a function.",
    "start": "296110",
    "end": "302080"
  },
  {
    "text": "It's just a keyword that\nthe compiler recognizes, and it will transform\nit to instructions",
    "start": "302080",
    "end": "307600"
  },
  {
    "text": "that manipulate the stack. However, this function\nis now deprecated",
    "start": "307600",
    "end": "313707"
  },
  {
    "text": "because it turns out that\nthe compiler is actually more efficient\nwhen you're dealing with these fixed-size\nframes if you just allocate",
    "start": "313707",
    "end": "319930"
  },
  {
    "text": "a pointer on the stack that\npoints to some piece of memory on the heap. But nevertheless, if you want\nto allocate on the call stack,",
    "start": "319930",
    "end": "328143"
  },
  {
    "text": "you can call this\nalloca function, but you should check that\nis doing the right thing since it's now deprecated and\nthe implementation is compiler",
    "start": "328143",
    "end": "335230"
  },
  {
    "text": "dependent. So what's another type of\nstorage besides the stack?",
    "start": "335230",
    "end": "342060"
  },
  {
    "text": "So you can't do\neverything with a stack. So what else can we use? ",
    "start": "342060",
    "end": "354050"
  },
  {
    "text": "Yes? AUDIENCE: Heap. JULIAN SHUN: Yes. So we also have the heap, which\nis more general than the stack.",
    "start": "354050",
    "end": "361180"
  },
  {
    "start": "361000",
    "end": "361000"
  },
  {
    "text": "So a stack looks\nvery nice and tidy, and it's very efficient\nto use the stack,",
    "start": "361180",
    "end": "366742"
  },
  {
    "text": "but it doesn't work\nfor everything. So that's why we have the heap. And a heap is much more\ngeneral, but it's very messy.",
    "start": "366742",
    "end": "373639"
  },
  {
    "text": "It's very hard to organize this\nand work with it efficiently. And for the rest\nof this lecture,",
    "start": "373640",
    "end": "379290"
  },
  {
    "text": "I am going to be\ntalking about how to manage memory in the heap. And I found these pictures\non Stack Overflow,",
    "start": "379290",
    "end": "386320"
  },
  {
    "text": "so maybe they're\nbiased towards stacks. [CHUCKLES] OK, so how do\nwe do heap allocation?",
    "start": "386320",
    "end": "394540"
  },
  {
    "text": "So let's first start with\nfixed-size heap allocation, where we assume that all of the\nobjects that we're dealing with",
    "start": "394540",
    "end": "400060"
  },
  {
    "text": "are of the same size. In general this isn't\ntrue, but let's just start with this\nsimpler case first.",
    "start": "400060",
    "end": "405550"
  },
  {
    "text": " OK, so as I said earlier, if\nyou use malloc and free in C,",
    "start": "405550",
    "end": "413949"
  },
  {
    "start": "409000",
    "end": "409000"
  },
  {
    "text": "then you're doing\nheap allocation. C++ has the new and\ndelete operators,",
    "start": "413950",
    "end": "419449"
  },
  {
    "text": "which work similarly\nto malloc and free. They also call the object\nconstructor and destructor,",
    "start": "419450",
    "end": "426670"
  },
  {
    "text": "and the C functions\ndon't do that. And unlike Java and Python, C\nand C++ don't provide a garbage",
    "start": "426670",
    "end": "435310"
  },
  {
    "text": "collector, so the programmer\nhas to manage memory him or herself, and this is one of\nthe reasons for the efficiency",
    "start": "435310",
    "end": "441850"
  },
  {
    "text": "of C and C++, because there's\nno garbage collector running in the background.",
    "start": "441850",
    "end": "447250"
  },
  {
    "text": "However, this makes\nit much harder to write correct\nprograms in C because you",
    "start": "447250",
    "end": "452290"
  },
  {
    "text": "have to be careful of memory\nleaks, dangling pointers, and double freeing.",
    "start": "452290",
    "end": "457660"
  },
  {
    "text": "So a memory leak is if\nyou allocate something and you forget to free\nit and your program keeps",
    "start": "457660",
    "end": "463620"
  },
  {
    "text": "running and allocating\nmore and more stuff but without freeing it. Eventually, you're going\nto run out of memory, and your program\nis going to crash.",
    "start": "463620",
    "end": "471040"
  },
  {
    "text": "So you need to be\ncareful of memory leaks. Dangling pointers are\npointers to pieces of memory",
    "start": "471040",
    "end": "477790"
  },
  {
    "text": "that you have already\nfreed, and if you try to dereference\na dangling pointer, the behavior is going\nto be undefined.",
    "start": "477790",
    "end": "484550"
  },
  {
    "text": "So maybe you'll get\na segmentation fault. Maybe you won't see anything\nuntil later on in your program because that memory might have\nbeen reallocated for something",
    "start": "484550",
    "end": "491980"
  },
  {
    "text": "else, and it's actually legal\nto dereference that memory. So dangling pointers\nare very annoying when",
    "start": "491980",
    "end": "498580"
  },
  {
    "text": "you're using C. If you're lucky,\nyou'll get a segfault right away, and you can\ngo fix your bug, but sometimes these\nare very hard to find.",
    "start": "498580",
    "end": "507100"
  },
  {
    "text": "There's also double freeing. So this is when you free\nsomething more than once. And again, this will lead\nto undefined behavior.",
    "start": "507100",
    "end": "514240"
  },
  {
    "text": "Maybe you'll get a segfault,\nor maybe that piece of memory was allocated for\nsomething else,",
    "start": "514240",
    "end": "520178"
  },
  {
    "text": "and then when you free it\nagain, it's actually legal. But your program is\ngoing to be incorrect,",
    "start": "520179",
    "end": "525850"
  },
  {
    "text": "so you need to be careful\nthat you don't free something more than once. ",
    "start": "525850",
    "end": "531650"
  },
  {
    "text": "And this is why\nsome people prefer to use a language\nlike Java and Python",
    "start": "531650",
    "end": "536769"
  },
  {
    "text": "that provide these built-in\ngarbage collectors. However, these languages\nare less efficient",
    "start": "536770",
    "end": "542680"
  },
  {
    "text": "because they have a\ngeneral-purpose garbage collector running\nin the background. So in this class,\nwe're going to use C",
    "start": "542680",
    "end": "550210"
  },
  {
    "text": "because we want to be able to\nwrite the fastest programs as possible, so we need to\nstudy how to manage memory.",
    "start": "550210",
    "end": "558370"
  },
  {
    "text": "And there are some\ntools you can use to reduce the number of memory\nbugs you have in your program.",
    "start": "558370",
    "end": "563950"
  },
  {
    "text": "So there's memory checkers like\nAddressSanitizer and Valgrind, which can assist you in\nfinding these pernicious bugs.",
    "start": "563950",
    "end": "571270"
  },
  {
    "text": "So AddressSanitizer is a\ncompiler instrumentation tool. When you compile your\nprogram, you pass a flag,",
    "start": "571270",
    "end": "579160"
  },
  {
    "text": "and then, when you\nrun your program, it's going to report\npossible memory",
    "start": "579160",
    "end": "585580"
  },
  {
    "text": "bugs you have in your program. And then Valgrind-- it works\ndirectly off the binaries. You don't need to do anything\nspecial when you compile it.",
    "start": "585580",
    "end": "594279"
  },
  {
    "text": "You can just pass your\nbinary to Valgrind, and if there is a memory\nbug, it might find it.",
    "start": "594280",
    "end": "601120"
  },
  {
    "text": "But Valgrind tends to be\nslower than AddressSanitizer, and it tends to catch\nfewer bugs because it",
    "start": "601120",
    "end": "607870"
  },
  {
    "text": "knows less about the program\nthan AddressSanitizer. And AddressSanitizer sees the\nsource code of the program",
    "start": "607870",
    "end": "613839"
  },
  {
    "text": "and has more information,\nwhereas Valgrind just works directly off the binary. ",
    "start": "613840",
    "end": "621560"
  },
  {
    "text": "Also, don't confuse the heap\nwith the heap data structure that you might have seen before\nin your algorithms or data",
    "start": "621560",
    "end": "629750"
  },
  {
    "text": "structures courses. So these are two\ndifferent concepts. The heap data structure\nin your algorithms course",
    "start": "629750",
    "end": "637910"
  },
  {
    "text": "was a data structure used to\nrepresent a priority queue, where you can efficiently\nextract the highest priority",
    "start": "637910",
    "end": "643880"
  },
  {
    "text": "element, and you can also\nupdate the priorities of elements in the set. And this could be\nused for algorithms",
    "start": "643880",
    "end": "649610"
  },
  {
    "text": "like sorting or graph search. But today we're\ngoing to be talking about another heap,\nwhich is the heap that's",
    "start": "649610",
    "end": "656900"
  },
  {
    "text": "used for storage allocation. So don't get confused. ",
    "start": "656900",
    "end": "662430"
  },
  {
    "text": "So any questions so far?  OK.",
    "start": "662430",
    "end": "668940"
  },
  {
    "text": "All right. So we're going to first start\nwith fixed-size allocations, since that's the easier case.",
    "start": "668940",
    "end": "674653"
  },
  {
    "start": "669000",
    "end": "669000"
  },
  {
    "text": "So we're going to assume\nthat every piece of storage has the same size. Some of these blocks are used,\nand some of them are unused.",
    "start": "674653",
    "end": "683960"
  },
  {
    "text": "And among the\nunused blocks, we're going to keep a list that\nwe call the free list,",
    "start": "683960",
    "end": "689540"
  },
  {
    "text": "and each block in this\nfree list has a pointer to the next block\nin the free list. And since this\nmemory is unused, we",
    "start": "689540",
    "end": "695990"
  },
  {
    "text": "can actually use\nthe memory to store a pointer as part of our storage\nallocator implementation.",
    "start": "695990",
    "end": "702028"
  },
  {
    "text": " There's actually another way\nto do fixed-size allocations.",
    "start": "702028",
    "end": "708670"
  },
  {
    "text": "Instead of using\na free list, you could actually a place a\nbit for each block saying",
    "start": "708670",
    "end": "714339"
  },
  {
    "text": "whether or not it's free, and\nthen when you do allocation, you can use bit tricks. But today I'm going to\ntalk about the free list",
    "start": "714340",
    "end": "721870"
  },
  {
    "text": "implementation.  So to allocate one object\nfrom the free list,",
    "start": "721870",
    "end": "730959"
  },
  {
    "text": "you set the pointer\nx to be free. So free is pointing to the\nfirst object in this free list.",
    "start": "730960",
    "end": "738070"
  },
  {
    "text": "Then you set the\nfree pointer to point to the next thing\nin the free list, so this is doing free equal\nto the next pointer of free.",
    "start": "738070",
    "end": "747250"
  },
  {
    "text": "And then, finally,\nyou return x, which is a pointer to the first\nobject in the free list.",
    "start": "747250",
    "end": "755139"
  },
  {
    "text": "So here's an animation. So x is going to point\nto what free points to.",
    "start": "755140",
    "end": "760630"
  },
  {
    "text": "You also need to check\nif free is equal to null, because if free\nis equal to null, that means there are no more\nfree blocks in the free list,",
    "start": "760630",
    "end": "768670"
  },
  {
    "text": "and the programmer\nshould know this. You should return\na special value. ",
    "start": "768670",
    "end": "774699"
  },
  {
    "text": "Otherwise, we're going\nto set the free pointer to point to the next\nthing in the free list,",
    "start": "774700",
    "end": "780490"
  },
  {
    "text": "and then, finally, we\nreturn x to the program, and now the program has a\nblock of memory that I can use.",
    "start": "780490",
    "end": "786640"
  },
  {
    "text": " There is still a garbage\npointer in this block",
    "start": "786640",
    "end": "792940"
  },
  {
    "text": "that we pass back to the program\nbecause we didn't clear it. So the implementation\nof the storage allocator",
    "start": "792940",
    "end": "798910"
  },
  {
    "text": "could decide to zero\nthis out, or it can just pass it back to the\nprogram and leave it up to the programmer to do\nwhatever it wants with it.",
    "start": "798910",
    "end": "805643"
  },
  {
    "text": "So in the latter\ncase, the programmer should be careful not to try\nto dereference this pointer.",
    "start": "805643",
    "end": "811269"
  },
  {
    "start": "811270",
    "end": "816510"
  },
  {
    "text": "OK, so how about deallocation? So let's say we want\nto free some object x.",
    "start": "816510",
    "end": "823860"
  },
  {
    "text": "What we do is, we just\nset the next pointer of x to be equal\nto free, so it's",
    "start": "823860",
    "end": "831420"
  },
  {
    "text": "going to point to the first\nthing in the free list. And then we set free equal to x.",
    "start": "831420",
    "end": "838380"
  },
  {
    "text": "So right. So now free is pointing\nto x, and this x object",
    "start": "838380",
    "end": "845389"
  },
  {
    "text": "that we wanted to free now is\na pointer to the first object in the original free list.",
    "start": "845390",
    "end": "850459"
  },
  {
    "text": " So pretty simple. Any questions on this?",
    "start": "850460",
    "end": "856040"
  },
  {
    "start": "856040",
    "end": "865350"
  },
  {
    "text": "So this sort of\nacts like a stack in that the last thing\nthat you've freed",
    "start": "865350",
    "end": "870630"
  },
  {
    "text": "is going to be the first\nthing that you allocate, so you get temporal\nlocality in that way.",
    "start": "870630",
    "end": "876960"
  },
  {
    "text": "But unlike a stack,\nyou can actually free any of the blocks and\nnot just the last block that you allocated.",
    "start": "876960",
    "end": "883590"
  },
  {
    "text": " So with a free list,\nallocating and freeing",
    "start": "883590",
    "end": "889589"
  },
  {
    "text": "take constant time\nbecause you're just adjusting some pointers.",
    "start": "889590",
    "end": "894630"
  },
  {
    "text": "It has good temporal\nlocality, because as I said, the things that you\nfreed most recently",
    "start": "894630",
    "end": "900060"
  },
  {
    "text": "are going to be the things\nthat are going to be allocated. It has poor spatial locality\ndue to external fragmentation,",
    "start": "900060",
    "end": "910050"
  },
  {
    "text": "and external fragmentation means\nthat your box of used memory are spread out\nall over the place",
    "start": "910050",
    "end": "916680"
  },
  {
    "text": "in the space of all memory. And this can be\nbad for performance",
    "start": "916680",
    "end": "922139"
  },
  {
    "text": "because it can increase\nthe size of the page table, and it can also\ncause disk thrashing.",
    "start": "922140",
    "end": "928300"
  },
  {
    "text": "So if you recall,\nwhenever you access a page in virtual memory, it\nhas to do address translation",
    "start": "928300",
    "end": "937110"
  },
  {
    "text": "to the physical memory address. And if your memory is\nspread out across many pages",
    "start": "937110",
    "end": "942990"
  },
  {
    "text": "in virtual memory, then you're\ngoing to have a lot of entries in the page table, because\nthe page table is storing",
    "start": "942990",
    "end": "949350"
  },
  {
    "text": "this mapping between the virtual\nmemory address of the page and the physical memory\naddress of the page.",
    "start": "949350",
    "end": "955649"
  },
  {
    "text": "So this can complicate\nthe page table, make it less efficient\nto do lookups in it.",
    "start": "955650",
    "end": "961019"
  },
  {
    "text": "And then if you have\nmore pages than you can fit in your main\nmemory, then this",
    "start": "961020",
    "end": "966089"
  },
  {
    "text": "can cause disk thrashing\nbecause you have to move pages in and out of disk. ",
    "start": "966090",
    "end": "973170"
  },
  {
    "text": "The Translation Lookaside Buffer\nor TLB can also be a problem. Does anybody know what a TLB is?",
    "start": "973170",
    "end": "979319"
  },
  {
    "start": "979320",
    "end": "988530"
  },
  {
    "text": "Yes? AUDIENCE: A cache of the\nresult of translating from virtual memory\nto physical memory. JULIAN SHUN: Yeah, so\nthe TLB is essentially",
    "start": "988530",
    "end": "995380"
  },
  {
    "text": "a cache for the\npage table, so it will cache the results\nof the translation",
    "start": "995380",
    "end": "1001050"
  },
  {
    "text": "from virtual memory\naddresses to physical memory addresses for the most\nrecent translations.",
    "start": "1001050",
    "end": "1006750"
  },
  {
    "text": "And looking up a\ntranslation in the TLB is much more efficient than\ngoing through the page table.",
    "start": "1006750",
    "end": "1013770"
  },
  {
    "text": "And if you have a lot of\nexternal fragmentation, then you have a lot of\npages that you might access,",
    "start": "1013770",
    "end": "1019829"
  },
  {
    "text": "and this means that\nwhen you go to the TLB, it's more likely\nyou'll get a TLB miss, and you have to go\nto the page table",
    "start": "1019830",
    "end": "1025380"
  },
  {
    "text": "to look up the\nappropriate address. So that's why external\nfragmentation is bad. ",
    "start": "1025380",
    "end": "1032790"
  },
  {
    "text": "So let's look at\nsome ways to mitigate external fragmentation.",
    "start": "1032790",
    "end": "1038619"
  },
  {
    "start": "1035000",
    "end": "1035000"
  },
  {
    "text": "So one way to do this is to\nkeep a free list or a bitmap",
    "start": "1038619",
    "end": "1043890"
  },
  {
    "text": "per disk page, and then when\nyou want to allocate something, you allocate from the free\nlist of the fullest page.",
    "start": "1043890",
    "end": "1050730"
  },
  {
    "text": "So you sort of skew\nthe memory that's being used to as few\npages as possible.",
    "start": "1050730",
    "end": "1057419"
  },
  {
    "text": "And when you free\na block of storage, you just return it to the page\non which that block resides.",
    "start": "1057420",
    "end": "1065490"
  },
  {
    "text": "And if a page becomes\ncompletely empty-- there are no more items\nthat are used on that page--",
    "start": "1065490",
    "end": "1070860"
  },
  {
    "text": "then the virtual memory\nsystem can page it out without affecting the program\nperformance because you're not going to access\nthat page anyways.",
    "start": "1070860",
    "end": "1078750"
  },
  {
    "text": "So this might seem\ncounterintuitive. Why do we want to skew the items\nto as few pages as possible?",
    "start": "1078750",
    "end": "1084030"
  },
  {
    "text": "So let's look at\na simple example to convince ourselves why this\nis actually good for dealing",
    "start": "1084030",
    "end": "1089220"
  },
  {
    "text": "with external fragmentation. So here I have two cases. In the first case, I have\n90% of my blocks on one page",
    "start": "1089220",
    "end": "1096929"
  },
  {
    "text": "and 10% of the blocks\non the other page. In the second case, I have\nhalf of my blocks on one page",
    "start": "1096930",
    "end": "1103049"
  },
  {
    "text": "and half on the other page. So now let's look\nat the probability that two random accesses\nwill hit the same page.",
    "start": "1103050",
    "end": "1109980"
  },
  {
    "text": "So let's assume that all\nof the random accesses are going to go to\none of the two pages. So in the first\ncase, the probability",
    "start": "1109980",
    "end": "1116730"
  },
  {
    "text": "that both of the accesses\nhit the first page is going to be 0.9 times 0.9, and then\nthe probability that they",
    "start": "1116730",
    "end": "1123779"
  },
  {
    "text": "both hit the second\npage is 0.1 times 0.1, and if you sum this\nup, you get 0.82.",
    "start": "1123780",
    "end": "1129429"
  },
  {
    "text": "That's the probability that\nboth of the random accesses are going to hit the same page.",
    "start": "1129430",
    "end": "1135230"
  },
  {
    "text": "In the other case,\nthe probability that both of the accesses\nhit the first page",
    "start": "1135230",
    "end": "1140820"
  },
  {
    "text": "is going to be 0.5 times 0.5. The second page is also\ngoing to be 0.5 times 0.5,",
    "start": "1140820",
    "end": "1146190"
  },
  {
    "text": "so that sums to\n0.5, and that means that there's only a 50% chance\nthat two random accesses are",
    "start": "1146190",
    "end": "1151835"
  },
  {
    "text": "going to hit the same page. So in the first\ncase, you actually have a higher chance that\nthe two random accesses hit",
    "start": "1151835",
    "end": "1157590"
  },
  {
    "text": "the same page, and that's why we\nwant to skew the items as much as possible so\nthat we can reduce",
    "start": "1157590",
    "end": "1163800"
  },
  {
    "text": "the external fragmentation. Any questions? ",
    "start": "1163800",
    "end": "1173799"
  },
  {
    "text": "OK, so that was fixed-size\nheap allocation,",
    "start": "1173800",
    "end": "1179870"
  },
  {
    "text": "and obviously you can't\nuse that for many programs if you're allocating\nmemory of different sizes.",
    "start": "1179870",
    "end": "1186590"
  },
  {
    "text": "So now let's look at\nvariable-size heap allocation. ",
    "start": "1186590",
    "end": "1192360"
  },
  {
    "start": "1192000",
    "end": "1192000"
  },
  {
    "text": "So we're going to look at\none allocation scheme called binned free lists. And the idea is to leverage\nthe efficiency of free list",
    "start": "1192360",
    "end": "1203410"
  },
  {
    "text": "and also accept\nthe bounded amount of internal fragmentation. So internal fragmentation is\nwasted space within a block,",
    "start": "1203410",
    "end": "1210500"
  },
  {
    "text": "so that means when\nyou allocate possibly more space than\nyou're using, then there's some wasted\nspace in there.",
    "start": "1210500",
    "end": "1216530"
  },
  {
    "text": "So in binned free lists,\nwhat we're going to do is, we're going to have a\nwhole bunch of bins, and each bin is going to store\nblocks of a particular size.",
    "start": "1216530",
    "end": "1225260"
  },
  {
    "text": " So here I'm going to\nsay that bin k holds",
    "start": "1225260",
    "end": "1233720"
  },
  {
    "text": "memory blocks of\nsize 2 to the k, so I'm going to store\nblocks of sizes powers of 2.",
    "start": "1233720",
    "end": "1240440"
  },
  {
    "text": " So why don't I just store a\nbin for every possible size?",
    "start": "1240440",
    "end": "1246050"
  },
  {
    "text": "Does anybody know why?  Why am I rounding up\nto powers of 2 here?",
    "start": "1246050",
    "end": "1256490"
  },
  {
    "text": "AUDIENCE: You'd\nhave too many bins. JULIAN SHUN: Yes, if I wanted\na bin for every possible size, I would have way too many\nbins, and just the pointers",
    "start": "1256490",
    "end": "1266240"
  },
  {
    "text": "to these bins are not\ngoing to fit in memory. So that's why I'm only\nusing bins that store",
    "start": "1266240",
    "end": "1272300"
  },
  {
    "text": "blocks of size 2 to the k.  And now let's look\nat how I'm going",
    "start": "1272300",
    "end": "1281090"
  },
  {
    "start": "1278000",
    "end": "1278000"
  },
  {
    "text": "to allocate x bytes\nfrom a binned free list. So what I'm going\nto do is, I'm going to look up the bin for which\nI should take a block from,",
    "start": "1281090",
    "end": "1289370"
  },
  {
    "text": "and to get that, I'm going to\ntake the ceiling of log base x.",
    "start": "1289370",
    "end": "1295670"
  },
  {
    "text": "This is log base 2, so\nrecall that lg is log base 2. If that bin is nonempty,\nthen I can just",
    "start": "1295670",
    "end": "1302600"
  },
  {
    "text": "return a block from that bin. However, if that\nbin is empty, then I need to go to the next\nhighest bin that's nonempty,",
    "start": "1302600",
    "end": "1312590"
  },
  {
    "text": "and then I'm going to\ntake a block from that bin and then split it up\ninto smaller chunks and place them\ninto smaller bins.",
    "start": "1312590",
    "end": "1319580"
  },
  {
    "text": "And then I'll also get a chunk\nthat is of the right size. So for this example, let's say\nI wanted to allocate 3 bytes.",
    "start": "1319580",
    "end": "1327920"
  },
  {
    "text": "The ceiling of log base 2\nof x is 2, so I go to bin 2. But bin 2 is empty, so I need\nto look for the next bin that's",
    "start": "1327920",
    "end": "1335330"
  },
  {
    "text": "not empty. And that's going to be bin 4. And I'm going to split up this\nblock into smaller powers of 2.",
    "start": "1335330",
    "end": "1344230"
  },
  {
    "text": "So in particular,\nI'm going to find a nonempty bin k\nprime greater than k",
    "start": "1344230",
    "end": "1349250"
  },
  {
    "text": "and split up a block into sizes\nof 2 to the k prime minus 1, 2 to the k prime minus 2, all\nthe way down to 2 to the k.",
    "start": "1349250",
    "end": "1357530"
  },
  {
    "text": "So I'm going to split it into\nsizes of all the powers of 2 less than 2 to the k prime\nand greater than or equal to 2",
    "start": "1357530",
    "end": "1366260"
  },
  {
    "text": "to the k. And I'm going to actually have\ntwo blocks of size 2 to the k, and one of those will be\nreturned to the program.",
    "start": "1366260",
    "end": "1374090"
  },
  {
    "text": "So here I'm going to\nsplit up this block. I'm going to place one of the\nsmaller blocks in bin 3, one",
    "start": "1374090",
    "end": "1381140"
  },
  {
    "text": "of them into bin 2, and then\nI also have another block here that I'm just going to\nreturn to the program.",
    "start": "1381140",
    "end": "1387245"
  },
  {
    "text": " So any questions on\nhow this scheme works? ",
    "start": "1387245",
    "end": "1397779"
  },
  {
    "text": "OK, and if there are no\nlarger blocks that exist-- so that means all\nof the bins higher",
    "start": "1397780",
    "end": "1403309"
  },
  {
    "text": "than the bin I'm\nlooking at are empty-- then I need to go to the OS\nto request for more memory.",
    "start": "1403310",
    "end": "1410250"
  },
  {
    "text": "And then after I\nget that memory, I'll split it up so I can\nsatisfy my allocation request. ",
    "start": "1410250",
    "end": "1419260"
  },
  {
    "text": "In practice, this exact\nscheme isn't used, so there are many\nvariants of this scheme.",
    "start": "1419260",
    "end": "1425380"
  },
  {
    "text": "So it turns out\nthat efficiency is very important for\nsmall allocations because there's not\nthat much work performed",
    "start": "1425380",
    "end": "1432460"
  },
  {
    "text": "on these small pieces of\nmemory, and the overheads of the storage allocation\nscheme could cause a performance",
    "start": "1432460",
    "end": "1439629"
  },
  {
    "text": "bottleneck. So in practice, you usually\ndon't go all the way down to blocks of size 1.",
    "start": "1439630",
    "end": "1444760"
  },
  {
    "text": "You might stop at blocks\nof size 8 bytes so that you don't have\nthat much overhead,",
    "start": "1444760",
    "end": "1450460"
  },
  {
    "text": "but this does increase\nthe internal fragmentation by a little bit, because now\nyou have some wasted space.",
    "start": "1450460",
    "end": "1459460"
  },
  {
    "text": "And then-- one\nsecond-- and then you can also group\nblocks into pages, as I said before, so that all\nof the blocks in the same page",
    "start": "1459460",
    "end": "1466787"
  },
  {
    "text": "have the same size,\nand then you don't have to store the information\nof the size of the blocks.",
    "start": "1466787",
    "end": "1473800"
  },
  {
    "text": "Yes. AUDIENCE: How do you--",
    "start": "1473800",
    "end": "1479080"
  },
  {
    "text": "JULIAN SHUN: Yeah, so there\nare two commands you can use. One is called mmap and the\nother one is called sbrk.",
    "start": "1479080",
    "end": "1485149"
  },
  {
    "text": "So those are system calls. You just call that, and then the\nOS will give you more memory,",
    "start": "1485150",
    "end": "1491160"
  },
  {
    "text": "and then your storage\nallocator can use it. ",
    "start": "1491160",
    "end": "1498720"
  },
  {
    "text": "Yes? AUDIENCE: They don't have to\nuse something like this in order",
    "start": "1498720",
    "end": "1504762"
  },
  {
    "text": "to implement those? JULIAN SHUN: No, the standard\nimplementation of malloc--",
    "start": "1504762",
    "end": "1510390"
  },
  {
    "text": "internally, it uses these\ncommands, mmap and sbrk, to get memory from the OS,\nso the OS just gives you",
    "start": "1510390",
    "end": "1517919"
  },
  {
    "text": "a huge chunk of memory. It doesn't split it up into\nsmaller blocks or anything. That's up to the\nstorage allocator to do.",
    "start": "1517920",
    "end": "1523649"
  },
  {
    "text": "It just gives you a\nbig chunk of memory, and then the storage\nallocator will break it up",
    "start": "1523650",
    "end": "1528840"
  },
  {
    "text": "into smaller blocks. There are similar\ncommands where you",
    "start": "1528840",
    "end": "1534300"
  },
  {
    "text": "can free memory\nback to the OS when you're not using them anymore. AUDIENCE: Can you explain\nthe paging thing [INAUDIBLE]??",
    "start": "1534300",
    "end": "1541464"
  },
  {
    "text": " JULIAN SHUN: Yeah,\nso what I said was that you can actually\nkeep blocks of different sizes",
    "start": "1541464",
    "end": "1548330"
  },
  {
    "text": "on different pages, so\nthen you don't actually have to store the\nsize of each block.",
    "start": "1548330",
    "end": "1553919"
  },
  {
    "text": "You can just look up what page\nthat block resides in when you get the memory address. And then for each page,\nyou have one field",
    "start": "1553920",
    "end": "1561020"
  },
  {
    "text": "that stores the size of\nthose blocks on that page. So this saves you the\noverhead of having to store information per\nblock to figure out its size.",
    "start": "1561020",
    "end": "1569820"
  },
  {
    "text": "Yeah. AUDIENCE: --changing\nthe size of the blocks. JULIAN SHUN: Yeah,\nso I mean, if you do change the size\nof the blocks,",
    "start": "1569820",
    "end": "1576790"
  },
  {
    "text": "then you can't actually\nuse this scheme, so this is actually a\nvariant where you don't change the size of the blocks.",
    "start": "1576790",
    "end": "1582962"
  },
  {
    "text": "If you do change\nthe size, then you have to change it\nfor the entire page. ",
    "start": "1582962",
    "end": "1588470"
  },
  {
    "text": "Yeah, so there are many variants\nof memory allocators out there. This is just the simplest\none that I described.",
    "start": "1588470",
    "end": "1595470"
  },
  {
    "text": "But it turns out that this exact\nscheme isn't the one that's",
    "start": "1595470",
    "end": "1600510"
  },
  {
    "text": "used in practice. There are many variants. Like some allocators,\ninstead of using powers of 2,",
    "start": "1600510",
    "end": "1605880"
  },
  {
    "text": "they use Fibonacci numbers to\ndetermine the different bins. ",
    "start": "1605880",
    "end": "1612648"
  },
  {
    "text": "Yeah. Any other questions? So you'll actually get\na chance to play around",
    "start": "1612648",
    "end": "1618929"
  },
  {
    "text": "with implementing some\nallocators in project 3 and homework 6. ",
    "start": "1618930",
    "end": "1631679"
  },
  {
    "start": "1630000",
    "end": "1630000"
  },
  {
    "text": "So let's briefly look at the\nstorage layout of a program. So this is how our\nvirtual memory address",
    "start": "1631680",
    "end": "1640040"
  },
  {
    "text": "space is laid out. So we have the stack\nall the way at the top,",
    "start": "1640040",
    "end": "1645940"
  },
  {
    "text": "and the stack grows downwards,\nso we have the high addresses up top and the low\naddresses below.",
    "start": "1645940",
    "end": "1651930"
  },
  {
    "text": "Then we have the heap,\nwhich grows upward, and the heap and\nthe stack basically grow towards each other, and\nthis space is dynamically",
    "start": "1651930",
    "end": "1659490"
  },
  {
    "text": "allocated as the program runs. Then there's the bss\nsegment, the data segment,",
    "start": "1659490",
    "end": "1666330"
  },
  {
    "text": "and the text segment, which\nall reside below the heap.",
    "start": "1666330",
    "end": "1671440"
  },
  {
    "text": "So the code segment just stores\nthe code for your program. So when you load\nup your program,",
    "start": "1671440",
    "end": "1677789"
  },
  {
    "text": "this code is going to put your\nprogram into this text segment. Then there's this\ndata segment, which",
    "start": "1677790",
    "end": "1685770"
  },
  {
    "text": "stores all of the global\nvariables and static variables, these constants that you\ndefined in your program.",
    "start": "1685770",
    "end": "1692460"
  },
  {
    "text": "These are all stored\nin the data segment, and when you load\nyour program you also have to read this data\nfrom disk and store it",
    "start": "1692460",
    "end": "1700230"
  },
  {
    "text": "into the data segment. Then there's the bss\nsegment this segment is",
    "start": "1700230",
    "end": "1705810"
  },
  {
    "text": "used to store all the\non initialize variables in your program,\nand this is just",
    "start": "1705810",
    "end": "1711390"
  },
  {
    "text": "initialized to 0 at the\nstart of your program, since your program\nhasn't initialized it, so it doesn't matter\nwhat we set it to.",
    "start": "1711390",
    "end": "1719790"
  },
  {
    "text": "And then the heap--\nthis is the memory that we're using when we're\ncalling malloc and free.",
    "start": "1719790",
    "end": "1727110"
  },
  {
    "text": "And then we have the stack,\nwhich we talked about. ",
    "start": "1727110",
    "end": "1735610"
  },
  {
    "text": "So in practice, the\nstack and the heap are never actually going to\nhit each other because we're working with 64-bit addresses.",
    "start": "1735610",
    "end": "1742647"
  },
  {
    "text": "So even though they're\ngrowing towards each other, you don't have to worry\nabout them actually hitting each other. ",
    "start": "1742647",
    "end": "1750040"
  },
  {
    "text": "And another point to\nnote is that if you're doing a lot of precomputation\nin your program,",
    "start": "1750040",
    "end": "1757080"
  },
  {
    "text": "for example generating these\nhuge tables of constants, those all have to be\nread from disk when",
    "start": "1757080",
    "end": "1763560"
  },
  {
    "text": "you start your program and\nstored in this data segment. So if you have a lot\nof these constants, it's actually going to\nmake your program loading",
    "start": "1763560",
    "end": "1770670"
  },
  {
    "text": "time much higher. However, it's usually OK to do\na little bit of precomputation,",
    "start": "1770670",
    "end": "1776460"
  },
  {
    "text": "especially if you can save a\nlot of computation at runtime, but in some cases\nit might actually",
    "start": "1776460",
    "end": "1781529"
  },
  {
    "text": "be faster overall to just\ncompute the things in memory when you start your\nprogram, because then you",
    "start": "1781530",
    "end": "1787060"
  },
  {
    "text": "have to read stuff from disk. ",
    "start": "1787060",
    "end": "1794725"
  },
  {
    "text": "So here's a question. So since a 64-bit address\nspace takes over a century to write at a rate of 4\nbillion bytes per second,",
    "start": "1794725",
    "end": "1803580"
  },
  {
    "text": "we're never effectively going\nto run out of virtual memory. So why don't we just allocate\nout of virtual memory and never",
    "start": "1803580",
    "end": "1810840"
  },
  {
    "text": "free anything? ",
    "start": "1810840",
    "end": "1820730"
  },
  {
    "text": "Yes? AUDIENCE: If you\nallocate a bunch of small things\nin random places,",
    "start": "1820730",
    "end": "1827992"
  },
  {
    "text": "then it's harder to update\nthan a large segment? JULIAN SHUN: Yeah,\nso one thing is",
    "start": "1827992",
    "end": "1833200"
  },
  {
    "text": "that you have this\nissue of fragmentation. The blocks of memory\nthat you're using",
    "start": "1833200",
    "end": "1838660"
  },
  {
    "text": "are not going to be\ncontiguous in memory, and then it makes it harder\nfor you to find large blocks. ",
    "start": "1838660",
    "end": "1845560"
  },
  {
    "start": "1845000",
    "end": "1845000"
  },
  {
    "text": "So this is called\nexternal fragmentation, which I mentioned earlier. So if you do this,\nexternal fragmentation",
    "start": "1845560",
    "end": "1852040"
  },
  {
    "text": "is going to be very bad. The performance\nof the page table is going to degrade tremendously\nbecause the memory that you're",
    "start": "1852040",
    "end": "1859180"
  },
  {
    "text": "using is going to be spread\nall over virtual memory, and you're going\nto use many pages, and this leads to\ndisk thrashing.",
    "start": "1859180",
    "end": "1866230"
  },
  {
    "text": "So you have to do a lot of swaps\nof pages in and out of disk. Your TLB hit rate is\ngoing to be very low.",
    "start": "1866230",
    "end": "1874120"
  },
  {
    "text": " And another reason\nis that you're also",
    "start": "1874120",
    "end": "1881272"
  },
  {
    "text": "going to run out\nof physical memory if you never free anything. So one of the goals\nof storage allocation",
    "start": "1881272",
    "end": "1888160"
  },
  {
    "text": "is to try to use as little\nvirtual memory as possible and to try to keep the\nused portions of the memory",
    "start": "1888160",
    "end": "1893860"
  },
  {
    "text": "relatively compact.  Any questions so far?",
    "start": "1893860",
    "end": "1899620"
  },
  {
    "start": "1899620",
    "end": "1908530"
  },
  {
    "text": "OK, so let's do an analysis of\nthe binned free list storage allocation scheme.",
    "start": "1908530",
    "end": "1914790"
  },
  {
    "start": "1909000",
    "end": "1909000"
  },
  {
    "text": "So here's a theorem. Suppose that the maximum\namount of heap memory in use at any time by a program is\nM. If the heap is managed",
    "start": "1914790",
    "end": "1923400"
  },
  {
    "text": "by a binned free list\nallocator, then the amount of virtual memory consumed\nby the heap storage",
    "start": "1923400",
    "end": "1929010"
  },
  {
    "text": "is upper bounded by\nM log M. Does anybody have an intuition about why\nthis theorem could be true?",
    "start": "1929010",
    "end": "1937020"
  },
  {
    "text": "So how many bins do\nwe have, at most? ",
    "start": "1937020",
    "end": "1943166"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] JULIAN SHUN: Right. So the number of bins we have\nis upper bounded by log M,",
    "start": "1943166",
    "end": "1950419"
  },
  {
    "text": "and each bin is going\nto use order M memory. So let's look at\nthis more formally. So an allocation request\nfor a block of size x",
    "start": "1950420",
    "end": "1958490"
  },
  {
    "text": "is going to consume 2 to\nthe ceiling of log base 2 of x storage, which is\nupper bounded by 2x,",
    "start": "1958490",
    "end": "1965690"
  },
  {
    "text": "so we're only wasting a\nfactor of 2 storage here.",
    "start": "1965690",
    "end": "1971269"
  },
  {
    "text": "So therefore, the\namount of virtual memory devoted to blocks of size\n2 to the k is at most 2M.",
    "start": "1971270",
    "end": "1979370"
  },
  {
    "text": "And since there are at most\nlog base 2 of M free lists, the theorem holds just by\nmultiplying the two terms.",
    "start": "1979370",
    "end": "1987350"
  },
  {
    "text": "So you can only have log\nbase 2 of M free lists because that's the maximum\namount of memory you're using,",
    "start": "1987350",
    "end": "1994100"
  },
  {
    "text": "and therefore your\nlargest bin is only going to hold blocks of\nsize M. And it turns out",
    "start": "1994100",
    "end": "2002150"
  },
  {
    "text": "that the bin free list\nallocation scheme is theta of 1 competitive with\nthe optimal allocator,",
    "start": "2002150",
    "end": "2009310"
  },
  {
    "text": "and here an optimal locator\nknows all of the memory requests in the future.",
    "start": "2009310",
    "end": "2014790"
  },
  {
    "text": "So it can basically do\na lot of clever things to optimize the memory\nallocation process.",
    "start": "2014790",
    "end": "2021140"
  },
  {
    "text": "But it turns out that the\nbinned free list is only going to be a\nconstant factor worse than the optimal allocator.",
    "start": "2021140",
    "end": "2027530"
  },
  {
    "text": "This is assuming that we don't\ncoalesce blocks together, which I'll talk about\non the next slide.",
    "start": "2027530",
    "end": "2033510"
  },
  {
    "text": "It turns out that\nthis constant is 6, so Charles Leiserson has a\npaper describing this result.",
    "start": "2033510",
    "end": "2040549"
  },
  {
    "text": "And there's also a lower\nbound of 6, so this is tight. ",
    "start": "2040550",
    "end": "2047950"
  },
  {
    "text": "So coalescing. So coalescing is when you\nsplice together smaller blocks",
    "start": "2047950",
    "end": "2054638"
  },
  {
    "start": "2048000",
    "end": "2048000"
  },
  {
    "text": "into a larger block. So you can do this if you\nhave two free blocks that are contiguous in memory. This will allow you to put them\ntogether into a larger block.",
    "start": "2054639",
    "end": "2064419"
  },
  {
    "text": "So binned free\nlists can sometimes be heuristically improved\nby doing coalescing,",
    "start": "2064420",
    "end": "2069699"
  },
  {
    "text": "and there are many\nclever schemes for trying to find adjacent\nblocks efficiently. So there's something\ncalled the buddy",
    "start": "2069699",
    "end": "2075158"
  },
  {
    "text": "system, where each\nblock has a buddy that's contiguous and memory. However, it turns out that this\nscheme especially, the buddy",
    "start": "2075159",
    "end": "2083620"
  },
  {
    "text": "system scheme, has\npretty high overhead. So it's usually\ngoing to be slower than just the standard\nbinned free list algorithm.",
    "start": "2083620",
    "end": "2093699"
  },
  {
    "text": "There are no good\ntheoretical bounds that exist that prove the\neffectiveness of coalescing,",
    "start": "2093699",
    "end": "2099430"
  },
  {
    "text": "but it does seem to work\npretty well in practice at reducing fragmentation\nbecause heap storage tends",
    "start": "2099430",
    "end": "2106269"
  },
  {
    "text": "to be deallocated as\na stack or in batches. So what I mean by this is\nthat the objects that you free",
    "start": "2106270",
    "end": "2116140"
  },
  {
    "text": "tend to be pretty close\ntogether in memory. So if you deallocate as\na stack, then all of them",
    "start": "2116140",
    "end": "2121180"
  },
  {
    "text": "are going to be near\nthe top of the stack. And when you\ndeallocate in batches-- this is when you do allocate\na whole bunch of things",
    "start": "2121180",
    "end": "2128950"
  },
  {
    "text": "that you allocated\ntogether in your program. For example, if you have\na graph data structure and you allocated data for the\nvertices all at the same time,",
    "start": "2128950",
    "end": "2139270"
  },
  {
    "text": "then when you deallocate\nthem all together, this is going to give you a\nchunk of contiguous memory",
    "start": "2139270",
    "end": "2144550"
  },
  {
    "text": "that you can splice together. OK, so now let's look\nat garbage collection.",
    "start": "2144550",
    "end": "2151634"
  },
  {
    "text": "This is going to be slightly\ndifferent from storage allocation. So the idea of\ngarbage collection",
    "start": "2151635",
    "end": "2158320"
  },
  {
    "start": "2156000",
    "end": "2156000"
  },
  {
    "text": "is to free the programmer\nfrom having to free objects. So languages like\nJava and Python,",
    "start": "2158320",
    "end": "2164109"
  },
  {
    "text": "they have built-in\ngarbage collectors, so the programmer doesn't\nhave to free stuff themselves,",
    "start": "2164110",
    "end": "2169210"
  },
  {
    "text": "and this makes it\neasier to write programs because you don't have\nto worry about double freeing and dangling\npointers and so forth.",
    "start": "2169210",
    "end": "2176270"
  },
  {
    "text": " So a garbage collector is\ngoing to identify and recycle",
    "start": "2176270",
    "end": "2182099"
  },
  {
    "text": "the objects that the\nprogrammer can no longer access so that these memory objects can\nbe used for future allocations.",
    "start": "2182100",
    "end": "2189490"
  },
  {
    "text": "And in addition to having a\nbuilt-in garbage collector, you can also create your\nown garbage collector",
    "start": "2189490",
    "end": "2195880"
  },
  {
    "text": "in C, which doesn't have\na garbage collector. So if you have an\napplication, you can actually create a\nspecial-purpose garbage",
    "start": "2195880",
    "end": "2201220"
  },
  {
    "text": "collector that might\nbe more efficient than a general garbage collector. Yes? AUDIENCE: This is the previous\ntopic, but why [? INAUDIBLE ?]",
    "start": "2201220",
    "end": "2210330"
  },
  {
    "text": "order of M memory? JULIAN SHUN: Why\nis it not order M?",
    "start": "2210330",
    "end": "2215560"
  },
  {
    "text": "AUDIENCE: Yeah. JULIAN SHUN: Because\nfor each of the bins, you could use up\nto order M memory.",
    "start": "2215560",
    "end": "2222770"
  },
  {
    "text": "So if you don't do\ncoalescing, basically, I",
    "start": "2222770",
    "end": "2228010"
  },
  {
    "text": "could have a bunch\nof small allocations, and then I chop up\nall of my blocks,",
    "start": "2228010",
    "end": "2233079"
  },
  {
    "text": "and then they all go\ninto smaller bins. And then I want to\nallocate something larger. I can't just splice\nthose together.",
    "start": "2233080",
    "end": "2238310"
  },
  {
    "text": "I have to make another\nmemory allocation. So if you order your memory\nrequests in a certain way,",
    "start": "2238310",
    "end": "2243430"
  },
  {
    "text": "you can make it so that each\nof the bins has order M memory. ",
    "start": "2243430",
    "end": "2255770"
  },
  {
    "text": "OK, so for garbage collection,\nlet's go over some terminology. So there are three types\nof memory objects, roots,",
    "start": "2255770",
    "end": "2264280"
  },
  {
    "start": "2257000",
    "end": "2257000"
  },
  {
    "text": "live objects, and dead objects. Roots are objects\nthat are directly accessible by the program, so\nthese are global variables,",
    "start": "2264280",
    "end": "2271400"
  },
  {
    "text": "things on the stack, and so on. Then there are\nlive objects, which are reachable by following\nthe roots via pointers,",
    "start": "2271400",
    "end": "2280120"
  },
  {
    "text": "and then finally,\nthere are dead objects, and these objects are\ninaccessible via sequences of pointers.",
    "start": "2280120",
    "end": "2285580"
  },
  {
    "text": "And these can be recycled\nbecause the programmer can no longer reach\nthese dead objects. ",
    "start": "2285580",
    "end": "2294380"
  },
  {
    "text": "So in order for garbage\ncollection to work in general, you need to be able to have\nthe garbage collector identify",
    "start": "2294380",
    "end": "2302800"
  },
  {
    "text": "pointers, and this\nrequires strong typing. So languages like Python\nand Java have strong typing,",
    "start": "2302800",
    "end": "2310690"
  },
  {
    "text": "but in C, it doesn't\nhave strong typing. This means that when\nyou have a pointer",
    "start": "2310690",
    "end": "2316232"
  },
  {
    "text": "you don't actually know\nwhether it's a pointer. Because a pointer just\nlooks like an integer. It could be either a\npoint or an integer.",
    "start": "2316232",
    "end": "2323060"
  },
  {
    "text": "You can cast things\nin C. You can also do pointer arithmetic\nin C. So in contrast,",
    "start": "2323060",
    "end": "2330220"
  },
  {
    "text": "in other languages, once\nyou declare something to be a pointer, it's always\ngoing to be a pointer. And for those languages\nthat have strong typing,",
    "start": "2330220",
    "end": "2337630"
  },
  {
    "text": "this makes it much easier\nto do garbage collection. You also need to prohibit\ndoing pointer arithmetic",
    "start": "2337630",
    "end": "2343900"
  },
  {
    "text": "on these pointers. Because if you do\npointer arithmetic and you change the\nlocation of the pointer,",
    "start": "2343900",
    "end": "2352210"
  },
  {
    "text": "then the garbage\ncollector no longer knows where the memory\nregion starts anymore.",
    "start": "2352210",
    "end": "2357310"
  },
  {
    "text": "In C, sometimes you do\ndo pointer arithmetic, and that's why\nyou can't actually",
    "start": "2357310",
    "end": "2363099"
  },
  {
    "text": "have a general-purpose garbage\ncollector in C that works well. ",
    "start": "2363100",
    "end": "2369940"
  },
  {
    "text": "So let's look at one simple\nform of garbage collection.",
    "start": "2369940",
    "end": "2376380"
  },
  {
    "text": "And this is called\nreference counting. The idea is that,\nfor each object,",
    "start": "2376380",
    "end": "2381390"
  },
  {
    "text": "I'm going to keep a count of the\nnumber of pointers referencing that object. And if the count ever\ngoes to 0, then that",
    "start": "2381390",
    "end": "2388670"
  },
  {
    "text": "means I can free that\nobject because there are no more pointers that\ncan reach that object.",
    "start": "2388670",
    "end": "2394420"
  },
  {
    "text": "So here, I have\na bunch of roots. So these are directly\naccessible by my program.",
    "start": "2394420",
    "end": "2400200"
  },
  {
    "text": "And then I have a\nbunch of objects that can be reached\nvia following pointers",
    "start": "2400200",
    "end": "2405750"
  },
  {
    "text": "starting from the root. And then each of them\nhave a reference count that indicates how many\nincoming pointers they have.",
    "start": "2405750",
    "end": "2412290"
  },
  {
    "text": " So let's say now I change\none of these pointers.",
    "start": "2412290",
    "end": "2419119"
  },
  {
    "text": "So initially, I had a\npointer going to here, but now I changed it so\nthat it goes down here.",
    "start": "2419120",
    "end": "2424549"
  },
  {
    "text": "So what happens now is I have\nto adjust a reference counts of both of these objects.",
    "start": "2424550",
    "end": "2429780"
  },
  {
    "text": "So this object\nhere, now it doesn't have any incoming pointers, so I\nhave to decrement its reference",
    "start": "2429780",
    "end": "2435260"
  },
  {
    "text": "count. So that goes to 0. And then for this one, I have to\nincrement its reference count,",
    "start": "2435260",
    "end": "2440400"
  },
  {
    "text": "so now it's 3. And now I have an object that\nhas a reference count of 0,",
    "start": "2440400",
    "end": "2445790"
  },
  {
    "text": "and with this reference\ncounting algorithm, I can free this object. So let's go ahead\nand free this object.",
    "start": "2445790",
    "end": "2452450"
  },
  {
    "text": "But when I free this\nobject, it actually has pointers to other\nobjects, so I also have to decrement the reference\ncounts of these other objects",
    "start": "2452450",
    "end": "2460520"
  },
  {
    "text": "when I free this object. So I'm going to\ndecrement the counts. And now it turns out\nthat this object also",
    "start": "2460520",
    "end": "2467630"
  },
  {
    "text": "has a reference count of 0,\nso I can free that, as well. And in general, I just\nkeep doing this process",
    "start": "2467630",
    "end": "2473300"
  },
  {
    "text": "until the reference\ncounts of the objects don't change anymore, and\nwhenever I encounter an object",
    "start": "2473300",
    "end": "2478340"
  },
  {
    "text": "with a reference count of 0,\nI can free it immediately. And the memory that I\nfreed can be recycled.",
    "start": "2478340",
    "end": "2486260"
  },
  {
    "text": "It can be used for future\nmemory allocations. So questions on how\nthe reference counting",
    "start": "2486260",
    "end": "2492273"
  },
  {
    "text": "procedure works? ",
    "start": "2492273",
    "end": "2500760"
  },
  {
    "text": "So there's one issue\nwith reference counting. Does anybody see\nwhat the issue is?",
    "start": "2500760",
    "end": "2507150"
  },
  {
    "text": "Yes? AUDIENCE: What if it has\na reference to itself? JULIAN SHUN: Yes. So what if it has a\nreference to itself?",
    "start": "2507150",
    "end": "2515970"
  },
  {
    "text": "More generally, what\nif it has a cycle? You can't ever collect\ngarbage collect a cycle when",
    "start": "2515970",
    "end": "2523200"
  },
  {
    "start": "2521000",
    "end": "2521000"
  },
  {
    "text": "you're using reference counts. So here we have a\ncycle of length 3.",
    "start": "2523200",
    "end": "2530099"
  },
  {
    "text": "They all have a\nreference count of 1, but you can never reach the\ncycle by following pointers",
    "start": "2530100",
    "end": "2536100"
  },
  {
    "text": "from the root,\nand therefore, you can never delete any\nobject in the cycle,",
    "start": "2536100",
    "end": "2541214"
  },
  {
    "text": "and the reference counts are\nalways going to be non-zero. ",
    "start": "2541215",
    "end": "2547410"
  },
  {
    "text": "So let's just\nillustrate the cycle. And furthermore, any object\nthat's pointed to by objects",
    "start": "2547410",
    "end": "2557200"
  },
  {
    "text": "in the cycle cannot be\ngarbage collected, as well,",
    "start": "2557200",
    "end": "2562450"
  },
  {
    "text": "because you can't garbage\ncollect the cycle, so all the pointer is going out\nof the objects in the cycle are",
    "start": "2562450",
    "end": "2568600"
  },
  {
    "text": "always going to be there. So there could be a lot\nof objects downstream from this object here that\ncan't be garbage collected,",
    "start": "2568600",
    "end": "2575800"
  },
  {
    "text": "so this makes it very bad.  And as we all know,\nuncollected garbage stinks,",
    "start": "2575800",
    "end": "2583220"
  },
  {
    "text": "so we don't want that. So let's see if we can come up\nwith another garbage collection",
    "start": "2583220",
    "end": "2589530"
  },
  {
    "text": "scheme.  So it turns out that\nreference counting is actually",
    "start": "2589530",
    "end": "2595320"
  },
  {
    "text": "pretty good when it\ndoes work because it's very efficient and\nsimple to implement.",
    "start": "2595320",
    "end": "2600420"
  },
  {
    "text": "So if you know that\nyour program doesn't have these cycles in\nthem among pointers,",
    "start": "2600420",
    "end": "2605760"
  },
  {
    "text": "then you can use a\nreference counting scheme. There are some languages,\nlike Objective-C,",
    "start": "2605760",
    "end": "2612000"
  },
  {
    "text": "that have two different types\nof pointers, strong pointers and weak pointers.",
    "start": "2612000",
    "end": "2617040"
  },
  {
    "text": "And if you're doing\nreference counting with a language with these\ntwo types of pointers,",
    "start": "2617040",
    "end": "2622260"
  },
  {
    "text": "the reference count\nonly stores the number of incoming strong pointers.",
    "start": "2622260",
    "end": "2628050"
  },
  {
    "text": "And therefore, if you define\nthese pointers inside a cycle to be weak pointers,\nthey're not going",
    "start": "2628050",
    "end": "2633510"
  },
  {
    "text": "to contribute to\nthe reference count, and therefore you can\nstill garbage collect. However, programming with\nstrong or weak pointers",
    "start": "2633510",
    "end": "2641520"
  },
  {
    "text": "can be kind of\ntricky because you need to make sure that you're\nnot dereferencing something",
    "start": "2641520",
    "end": "2646710"
  },
  {
    "text": "that a weak pointer points\nto because that thing might have been garbage\ncollected already, so you need to be careful.",
    "start": "2646710",
    "end": "2652380"
  },
  {
    "text": "And C doesn't have these\ntwo types of pointers, so we need to use another\nmethod of garbage collection",
    "start": "2652380",
    "end": "2659520"
  },
  {
    "text": "to make sure we can garbage\ncollect these cycles. So we're going to look at\ntwo more garbage collection",
    "start": "2659520",
    "end": "2665230"
  },
  {
    "text": "schemes. The first one is\ncalled mark-and-sweep, and the second one is\ncalled stop-and-copy.",
    "start": "2665230",
    "end": "2672510"
  },
  {
    "text": "So first we need to define\na graph abstraction.",
    "start": "2672510",
    "end": "2677520"
  },
  {
    "start": "2673000",
    "end": "2673000"
  },
  {
    "text": "So let's say we have a graph\nwith vertices V and edges E.",
    "start": "2677520",
    "end": "2682620"
  },
  {
    "text": "And the vertex at V\ncontains all of the memory objects in memory,\nand the edges E are",
    "start": "2682620",
    "end": "2688860"
  },
  {
    "text": "directed edges between objects. So there's a directed\nedge from object A",
    "start": "2688860",
    "end": "2695640"
  },
  {
    "text": "to object B if object A\nhas a pointer to object B.",
    "start": "2695640",
    "end": "2702190"
  },
  {
    "text": "And then, as we said earlier,\nthe live objects are the ones that are reachable\nfrom the roots,",
    "start": "2702190",
    "end": "2707750"
  },
  {
    "text": "so we can use a\nbreadth-first-search-like procedure to find all\nof the live objects. So we just start our\nbreadth-first search",
    "start": "2707750",
    "end": "2713630"
  },
  {
    "text": "from the roots,\nand we'll mark all of the objects that can be\nreachable from the roots.",
    "start": "2713630",
    "end": "2718850"
  },
  {
    "text": "And then everything\nelse that isn't reached, those are available\nto be reclaimed.",
    "start": "2718850",
    "end": "2727430"
  },
  {
    "text": "So we're going to\nhave a FIFO queue, First-In, First-Out queue,\nfor our breadth-first search.",
    "start": "2727430",
    "end": "2733549"
  },
  {
    "text": "This is represented as an array. And we have two pointers,\none to the head of the queue",
    "start": "2733550",
    "end": "2738740"
  },
  {
    "text": "and one to the\ntail of the queue. And here let's look at this\ncode, which essentially",
    "start": "2738740",
    "end": "2744650"
  },
  {
    "text": "is like a breadth-first search. So we're first going to go over\nall the vertices in our graph,",
    "start": "2744650",
    "end": "2751030"
  },
  {
    "text": "and we're going to check\nif each vertex v is a root. If it is a root, we're going\nto set its mark to be 1,",
    "start": "2751030",
    "end": "2758150"
  },
  {
    "text": "and we're going to place\nthe vertex onto the queue. And otherwise, we're going\nto set the mark of v to be 0.",
    "start": "2758150",
    "end": "2766490"
  },
  {
    "text": "And then while the\nqueue is not empty, we're going to dequeue the\nfirst thing from the queue. Let that be u.",
    "start": "2766490",
    "end": "2772350"
  },
  {
    "text": "Then we're going to look at all\nthe outgoing neighbors of u. So these are vertices\nv such that there",
    "start": "2772350",
    "end": "2777730"
  },
  {
    "text": "is a directed edge from u\nto v. We're going to check if v's mark is equal to 0.",
    "start": "2777730",
    "end": "2784550"
  },
  {
    "text": "If it is, that means we\nhaven't explored it yet, so we'll set its mark to be 1,\nand we place it onto the queue.",
    "start": "2784550",
    "end": "2790520"
  },
  {
    "text": "And if the neighbor has\nalready been explored, then we don't have\nto do anything. ",
    "start": "2790520",
    "end": "2796560"
  },
  {
    "text": "So let's illustrate how\nthis algorithm works on this simple graph here.",
    "start": "2796560",
    "end": "2801600"
  },
  {
    "text": "And for this example,\nI'm just going to assume that I have\none root, vertex r. In general, I can\nhave multiple routes,",
    "start": "2801600",
    "end": "2807359"
  },
  {
    "text": "and I just place all\nof them onto the queue at the beginning,\nbut for this example, I'm just going to\nhave a single root.",
    "start": "2807360",
    "end": "2813810"
  },
  {
    "text": "So I'm going to place it onto\nthe queue, and the location that I place it is going to be\nwhere the tail pointer points",
    "start": "2813810",
    "end": "2820890"
  },
  {
    "text": "to. And after I placed\nit on the queue, I increment the tail pointer. Now I'm going to take\nthe first thing off",
    "start": "2820890",
    "end": "2827730"
  },
  {
    "text": "of my queue, which is r, and\nI'll explore my neighbors. So the neighbors\nare b and c here.",
    "start": "2827730",
    "end": "2834360"
  },
  {
    "text": "Both of them haven't been marked\nyet, so I'm going to mark them, and I'm going to indicate\nthe marked vertices",
    "start": "2834360",
    "end": "2839940"
  },
  {
    "text": "with shaded blue. And I'll place them\nonto the queue.",
    "start": "2839940",
    "end": "2846839"
  },
  {
    "text": "Now I'm going to take\nthe next thing, b. I'm going to check\nits neighbors. It only has a neighbor to c,\nbut c is already on the queue.",
    "start": "2846840",
    "end": "2854190"
  },
  {
    "text": "It's already marked, so I\ndon't have to do anything. Now I dequeue c, and c\nhas neighbors d and e,",
    "start": "2854190",
    "end": "2861450"
  },
  {
    "text": "so I place them onto the queue. d doesn't have any\noutgoing neighbors, so I don't to do anything.",
    "start": "2861450",
    "end": "2868560"
  },
  {
    "text": "Now when I dequeue e,\nit has neighbors f. When I dequeue f,\nit has a neighbor g,",
    "start": "2868560",
    "end": "2874103"
  },
  {
    "text": "and when I dequeue g, it\ndoesn't have any neighbors. So now my queue is empty, and my\nbreadth-first search procedure",
    "start": "2874103",
    "end": "2879115"
  },
  {
    "text": "finishes.  So at this point,\nI've marked all",
    "start": "2879115",
    "end": "2884870"
  },
  {
    "text": "of the objects that are\naccessible from the root, and all of the unmarked\nobjects can now",
    "start": "2884870",
    "end": "2892043"
  },
  {
    "text": "be garbage collected\nbecause there is no way I can access them in the program. So the mark-and-sweep\nprocedure has two stages.",
    "start": "2892043",
    "end": "2900892"
  },
  {
    "start": "2897000",
    "end": "2897000"
  },
  {
    "text": "The first stage is\ncalled the mark stage, where I use a\nbreadth-first search to mark all of the live objects.",
    "start": "2900892",
    "end": "2907670"
  },
  {
    "text": "And the sweep stage\nwill scan over memory to free the unmarked objects.",
    "start": "2907670",
    "end": "2913700"
  },
  {
    "text": "So this a pretty simple scheme. There is one issue\nwith this scheme.",
    "start": "2913700",
    "end": "2919730"
  },
  {
    "text": "Does anybody see what\nthe possible issue is? ",
    "start": "2919730",
    "end": "2927130"
  },
  {
    "text": "Yes? AUDIENCE: You have to scan\nover all the [INAUDIBLE].. JULIAN SHUN: Yeah, so that's\none issue, where you have to scan over all of memory.",
    "start": "2927130",
    "end": "2934640"
  },
  {
    "text": "There are some variants\nof mark-and-sweep where it keeps track of\njust the allocated objects,",
    "start": "2934640",
    "end": "2940650"
  },
  {
    "text": "so you only have to\nscan over those instead of the entire memory space. Besides that, are there\nany other possible issues",
    "start": "2940650",
    "end": "2948010"
  },
  {
    "text": "with this? Yes? AUDIENCE: This also requires\nthat you [INAUDIBLE]",
    "start": "2948010",
    "end": "2956190"
  },
  {
    "text": "strong typing. JULIAN SHUN: Right,\nso let's assume that we do have strong typing.",
    "start": "2956190",
    "end": "2961900"
  },
  {
    "text": "Any other possible limitations? Anybody else?",
    "start": "2961900",
    "end": "2967210"
  },
  {
    "text": "Think I called on-- yeah. AUDIENCE: [INAUDIBLE]\nreference counting, you can see the object\nthat has a reference to it,",
    "start": "2967210",
    "end": "2974190"
  },
  {
    "text": "whereas for here you can find\neverything that would not be garbage collected [INAUDIBLE]. ",
    "start": "2974190",
    "end": "2982780"
  },
  {
    "text": "JULIAN SHUN: Yeah, so for\nthe scheme that I described, you have to look over\nall of the things that",
    "start": "2982780",
    "end": "2989210"
  },
  {
    "text": "don't have references to it. So that is another overhead.",
    "start": "2989210",
    "end": "2995040"
  },
  {
    "text": "So those are all issues. Good. The issue I want\nto get at is that",
    "start": "2995040",
    "end": "3000069"
  },
  {
    "text": "the mark-and-sweep algorithm\nthat I presented here doesn't deal with fragmentation. So it doesn't compact\nthe live objects",
    "start": "3000070",
    "end": "3007210"
  },
  {
    "text": "to be contiguous in memory. It just frees the ones\nthat are unreachable, but it doesn't do anything with\nthe ones that are reachable.",
    "start": "3007210",
    "end": "3016000"
  },
  {
    "text": "So let's look at\nanother procedure that does deal with fragmentation.",
    "start": "3016000",
    "end": "3023020"
  },
  {
    "text": "This is called the stop-and-copy\ngarbage collection procedure. ",
    "start": "3023020",
    "end": "3030730"
  },
  {
    "start": "3030000",
    "end": "3030000"
  },
  {
    "text": "At a high level, it's\npretty similar to the mark-and-sweep algorithm.",
    "start": "3030730",
    "end": "3036632"
  },
  {
    "text": "We're still going to use\na breadth-first search to identify all of\nthe live objects. ",
    "start": "3036632",
    "end": "3043690"
  },
  {
    "text": "But if you look at how this\nbreadth-first search is implemented, is\nthere any information you can use here to try to\nget the live objects to be",
    "start": "3043690",
    "end": "3051580"
  },
  {
    "text": "contiguous in memory? Does anybody see anything\nhere that we can use",
    "start": "3051580",
    "end": "3057740"
  },
  {
    "text": "to try to reduce fragmentation? Yes? AUDIENCE: [INAUDIBLE] JULIAN SHUN: Yes,\nso the answer is",
    "start": "3057740",
    "end": "3063630"
  },
  {
    "text": "that the objects that we visited\nare contiguous on the queue. So in the mark-and-sweep\nalgorithm,",
    "start": "3063630",
    "end": "3071820"
  },
  {
    "text": "I just place the IDs of\nthe vertices on the queue, but if I just place the actual\nobjects onto the queue instead,",
    "start": "3071820",
    "end": "3077880"
  },
  {
    "text": "then I can just use my\nqueue as my new memory. And then all of the objects\nthat are unreachable",
    "start": "3077880",
    "end": "3085200"
  },
  {
    "text": "will be implicitly deleted. So this procedure here will deal\nwith external fragmentation.",
    "start": "3085200",
    "end": "3091450"
  },
  {
    "text": "So let's see how this works. So we're going to have\ntwo separate memory",
    "start": "3091450",
    "end": "3096509"
  },
  {
    "text": "spaces, the FROM space\nand the TO space. So in the FROM space, I'm\njust going to do allocation",
    "start": "3096510",
    "end": "3104550"
  },
  {
    "text": "and freeing on it\nuntil it becomes full. So when I allocate\nsomething I place it at the end of this space.",
    "start": "3104550",
    "end": "3110339"
  },
  {
    "text": "When I free something,\nI just market as free, but I don't compact it out yet.",
    "start": "3110340",
    "end": "3115740"
  },
  {
    "text": "And when this FROM\nspace becomes full, then I'm going to run my\ngarbage collection algorithm,",
    "start": "3115740",
    "end": "3123960"
  },
  {
    "text": "and I'm going to use\nthe TO space as my queue when I do my\nbreadth-first search. ",
    "start": "3123960",
    "end": "3130930"
  },
  {
    "text": "So after I run my breadth-first\nsearch, all of the live objects are going to appear in the\nTO space in contiguous memory",
    "start": "3130930",
    "end": "3139900"
  },
  {
    "text": "since I used the TO\nspace as my queue. ",
    "start": "3139900",
    "end": "3146060"
  },
  {
    "start": "3145000",
    "end": "3145000"
  },
  {
    "text": "Right, and then I just\nkeep allocating stuff from the TO space and\nalso marking things",
    "start": "3146060",
    "end": "3151600"
  },
  {
    "text": "as deleted when I free\nthem until the TO space becomes full. Then I do the same thing,\nbut I swap the roles",
    "start": "3151600",
    "end": "3157300"
  },
  {
    "text": "of the TO and the FROM spaces. So this is called the\nstop-and-copy algorithm.",
    "start": "3157300",
    "end": "3163420"
  },
  {
    "text": "There is one problem\nwith this algorithm which we haven't addressed yet. Does anybody see what\nthe potential problem is?",
    "start": "3163420",
    "end": "3171515"
  },
  {
    "text": "Yes? AUDIENCE: If nothing\nis dead, then you're copying over your entire\nstorage every single time.",
    "start": "3171515",
    "end": "3176727"
  },
  {
    "text": "JULIAN SHUN: Yeah, so\nthat's one good observation. If nothing is dead, then\nyou're wasting a lot of work",
    "start": "3176727",
    "end": "3181780"
  },
  {
    "text": "because you have to copy this. Although with the\nmark-and-sweep algorithm, you still have to\ndo some copying,",
    "start": "3181780",
    "end": "3188049"
  },
  {
    "text": "although you're not\ncopying the entire objects. You're just copying the IDs. There's actually a\ncorrectness issue here.",
    "start": "3188050",
    "end": "3195460"
  },
  {
    "text": "So does anybody see what\nthe correct this issue is? ",
    "start": "3195460",
    "end": "3208450"
  },
  {
    "text": "Yes? AUDIENCE: So maybe the\npointers in the TO space have to be changed in order to\npoint to the new [INAUDIBLE]..",
    "start": "3208450",
    "end": "3216340"
  },
  {
    "text": "JULIAN SHUN: Yeah,\nso the answer is that if you had pointers that\npointed to objects in the FROM",
    "start": "3216340",
    "end": "3223480"
  },
  {
    "text": "space, if you move your\nobjects to the TO space, those pointers aren't going\nto be correct anymore.",
    "start": "3223480",
    "end": "3229280"
  },
  {
    "text": "So if I had a pointer\nto a live object before and I moved my live object to\na different memory address,",
    "start": "3229280",
    "end": "3235030"
  },
  {
    "text": "I need to also\nupdate that pointer. So let's see how we\ncan deal with this.",
    "start": "3235030",
    "end": "3242220"
  },
  {
    "start": "3240000",
    "end": "3240000"
  },
  {
    "text": "So the idea is that,\nwhen an object is copied to the TO space, we're\ngoing to store a forwarding",
    "start": "3242220",
    "end": "3247859"
  },
  {
    "text": "pointer in the\ncorresponding object in the from space, and\nthis implicitly marks",
    "start": "3247860",
    "end": "3254880"
  },
  {
    "text": "that object as moved. And then when I remove\nan object from the FIFO queue in my breadth-first\nsearch, in the TO space",
    "start": "3254880",
    "end": "3263430"
  },
  {
    "text": "I'm going to update\nall of the pointers by following these\nforwarding pointers. So let's look at an\nexample of how this works.",
    "start": "3263430",
    "end": "3272640"
  },
  {
    "start": "3270000",
    "end": "3270000"
  },
  {
    "text": "So let's say I'm executing\nthe breadth-first search, and this is my current\nqueue right now.",
    "start": "3272640",
    "end": "3279069"
  },
  {
    "text": " What I'm going to do is,\nwhen I dequeue an element",
    "start": "3279070",
    "end": "3285180"
  },
  {
    "text": "from my queue, first I'm\ngoing to place the neighboring",
    "start": "3285180",
    "end": "3291000"
  },
  {
    "text": "objects that haven't been\nexplored yet onto the queue. So here it actually\nhas two neighbors, but the first one has already\nbeen placed the queue,",
    "start": "3291000",
    "end": "3297877"
  },
  {
    "text": "so I can ignore it. And the second one hasn't\nbeen placed on the queue yet, so I place it onto the queue.",
    "start": "3297877",
    "end": "3302960"
  },
  {
    "text": " And then I'm also going to--",
    "start": "3302960",
    "end": "3309240"
  },
  {
    "text": "oh, so this object\nalso has a pointer to something in the FROM\nspace, which I'm not",
    "start": "3309240",
    "end": "3314570"
  },
  {
    "text": "going to change at this time. But I am going to store\na forwarding pointer from the object that I\nmoved from the FROM space",
    "start": "3314570",
    "end": "3321980"
  },
  {
    "text": "to the TO space, so\nnow it has a pointer that tells me the new address.",
    "start": "3321980",
    "end": "3328079"
  },
  {
    "text": "And then, for the object\nthat I just dequeued, I'm going to follow\nthe forwarding",
    "start": "3328080",
    "end": "3333740"
  },
  {
    "text": "pointers of its neighbors,\nand that will give me the correct addresses now.",
    "start": "3333740",
    "end": "3339970"
  },
  {
    "text": "So I'm going to update the\npointers by just following the forwarding pointer. So the first pointer\npointed to this object,",
    "start": "3339970",
    "end": "3347359"
  },
  {
    "text": "which has a forwarding pointer\nto this, so I just make a point to this object in the TO space.",
    "start": "3347360",
    "end": "3353830"
  },
  {
    "text": "And then similarly\nfor the other pointer, I'm going to make it\npoint to this object. ",
    "start": "3353830",
    "end": "3362500"
  },
  {
    "text": "So that's the\nthat's the idea how of how to adjust the pointers.",
    "start": "3362500",
    "end": "3368530"
  },
  {
    "text": "One question is, why can't\nwe just adjust the pointer is when we enqueue the object? So why do I have to\nadjust the pointers",
    "start": "3368530",
    "end": "3375010"
  },
  {
    "text": "when I dequeue an object?  Yes?",
    "start": "3375010",
    "end": "3380580"
  },
  {
    "text": "AUDIENCE: Because we haven't\nprocessed its neighbors yet. JULIAN SHUN: Yeah,\nso the answer is that, when you enqueue\nobject, you don't actually",
    "start": "3380581",
    "end": "3388752"
  },
  {
    "text": "know where your\nneighbors are going to reside in the TO space. And you only know that when\nyou dequeue the object,",
    "start": "3388752",
    "end": "3395380"
  },
  {
    "text": "because when you\ndequeue the object, you must have explored\nyour neighbors, and therefore you can generate\nthese forward pointers.",
    "start": "3395380",
    "end": "3402070"
  },
  {
    "text": " So any questions on this scheme? ",
    "start": "3402070",
    "end": "3414690"
  },
  {
    "text": "So how much time does it take to\ndo the stop-and-copy procedure? So let's say n is\nthe number of objects",
    "start": "3414690",
    "end": "3423960"
  },
  {
    "text": "and the number of\npointers I have, so it's the sum of the number of\nobjects and number of pointers.",
    "start": "3423960",
    "end": "3429599"
  },
  {
    "text": "How much time would it\ntake to run this algorithm? ",
    "start": "3429600",
    "end": "3440143"
  },
  {
    "text": "AUDIENCE: [INAUDIBLE] JULIAN SHUN: Yeah,\nso it's just going to be linear time because we're\nrunning a breadth-first search,",
    "start": "3440143",
    "end": "3446995"
  },
  {
    "text": "and that takes linear time. ",
    "start": "3446995",
    "end": "3452400"
  },
  {
    "text": "You also have to\ndo work in order to copy these objects\nto the TO space,",
    "start": "3452400",
    "end": "3458730"
  },
  {
    "text": "so you also have to\ndo work proportional to the number of bytes\nthat you're copying over.",
    "start": "3458730",
    "end": "3464200"
  },
  {
    "text": "So it's linear in the\nnumber of objects, the number of pointers, and\nthe total amount of space",
    "start": "3464200",
    "end": "3470220"
  },
  {
    "text": "or copying over. And the advantage\nof this scheme is",
    "start": "3470220",
    "end": "3476900"
  },
  {
    "text": "that you don't actually need\nto go over the objects that aren't reachable because those\nare going to be implicitly",
    "start": "3476900",
    "end": "3483230"
  },
  {
    "text": "deleted because they're not\ncopied over to the TO space, whereas in the\nmark-and-sweep procedure,",
    "start": "3483230",
    "end": "3488420"
  },
  {
    "text": "you had to actually go\nthrough your entire memory and then free all the objects\nthat aren't reachable.",
    "start": "3488420",
    "end": "3494840"
  },
  {
    "text": "So this makes the stop-and-copy\nprocedure more efficient,",
    "start": "3494840",
    "end": "3500000"
  },
  {
    "text": "and it also deals with the\nexternal fragmentation issue. ",
    "start": "3500000",
    "end": "3508630"
  },
  {
    "start": "3508000",
    "end": "3508000"
  },
  {
    "text": "So what happens when the\nFROM space becomes full?",
    "start": "3508630",
    "end": "3514400"
  },
  {
    "text": "So what you do is, you're\ngoing to request a new heap space equal to the used\nspace, so you're just",
    "start": "3514400",
    "end": "3520660"
  },
  {
    "text": "going to double the\nsize of your FROM space.  And then you're going to\nconsider the FROM space to be",
    "start": "3520660",
    "end": "3527230"
  },
  {
    "text": "full when the newly\nallocated space becomes full, so essentially what\nyou're going to do is, you're going to\ndouble the space,",
    "start": "3527230",
    "end": "3533260"
  },
  {
    "text": "and when that becomes\nfull, you're going to double it again, and so on. And with this method,\nyou can amortize",
    "start": "3533260",
    "end": "3538750"
  },
  {
    "text": "the cost of garbage collection\nto the size of the new heap space, so it's going to be\namortized constant overhead",
    "start": "3538750",
    "end": "3545770"
  },
  {
    "text": "per byte of memory. And this is assuming\nthat the user program is going to touch all\nof the memory that it allocates.",
    "start": "3545770",
    "end": "3553630"
  },
  {
    "text": " And furthermore, the\nvirtual memory space",
    "start": "3553630",
    "end": "3559340"
  },
  {
    "text": "required by this scheme\nis just a constant times the optimal if you locate\nthe FROM and the TO spaces",
    "start": "3559340",
    "end": "3565910"
  },
  {
    "text": "in different regions\nof virtual memory so that they can't\ninterfere with each other. And the reason why it's a\nconstant times the optimal",
    "start": "3565910",
    "end": "3572819"
  },
  {
    "text": "is because you only\nlose a factor of 2 because you're maintaining\ntwo separate spaces.",
    "start": "3572820",
    "end": "3579080"
  },
  {
    "text": "And then another factor\nof 2 comes from the fact that you're doubling the size of\nyour array when it becomes full",
    "start": "3579080",
    "end": "3586370"
  },
  {
    "text": "and up to half of\nit will be unused. But it's constant times\noptimal since we're just",
    "start": "3586370",
    "end": "3592579"
  },
  {
    "text": "multiplying constants together. And similarly, when\nyou're FROM space",
    "start": "3592580",
    "end": "3597980"
  },
  {
    "text": "becomes relatively empty-- for example, if it's\nless than half full-- you can also release\nmemory back to the OS,",
    "start": "3597980",
    "end": "3605990"
  },
  {
    "text": "and then the analysis of the\namortized constant overhead is similar. ",
    "start": "3605990",
    "end": "3615970"
  },
  {
    "text": "OK, any other questions? ",
    "start": "3615970",
    "end": "3625840"
  },
  {
    "text": "OK, so there's a lot more\nthat's known and also unknown about dynamic\nstorage allocation,",
    "start": "3625840",
    "end": "3631940"
  },
  {
    "text": "so I've only scratched the\nsurface of dynamic storage allocation today. There are many other topics.",
    "start": "3631940",
    "end": "3637190"
  },
  {
    "text": "For example, there's the buddy\nsystem for doing coalescing.",
    "start": "3637190",
    "end": "3642960"
  },
  {
    "text": "There are many variants of\nthe mark-and-sweep procedure. So there are optimizations to\nimprove the performance of it.",
    "start": "3642960",
    "end": "3651560"
  },
  {
    "text": "There's generational\ngarbage collection, and this is based on the\nidea that many objects are short-lived, so a\nlot of the objects",
    "start": "3651560",
    "end": "3659600"
  },
  {
    "text": "are going to be freed\npretty close to the time when you allocate it. And for the ones that\naren't going to be freed,",
    "start": "3659600",
    "end": "3665060"
  },
  {
    "text": "they tend to be\npretty long-lived. And the idea of generational\ngarbage collection is, instead of scanning your\nwhole memory every time,",
    "start": "3665060",
    "end": "3672500"
  },
  {
    "text": "you just do work on the younger\nobjects most of the time. And then once in\na while, you try",
    "start": "3672500",
    "end": "3677660"
  },
  {
    "text": "to collect the garbage\nfrom the older objects because those tend to\nnot change that often.",
    "start": "3677660",
    "end": "3682880"
  },
  {
    "text": " There's also real-time\ngarbage collection. So the methods I\ntalked about today",
    "start": "3682880",
    "end": "3690450"
  },
  {
    "text": "assume that the program isn't\nrunning when the garbage collection procedure is\nrunning, but in practice, you",
    "start": "3690450",
    "end": "3697710"
  },
  {
    "text": "might want to actually have\nyour garbage collector running in the background when\nyour program is running,",
    "start": "3697710",
    "end": "3703260"
  },
  {
    "text": "but this can lead to\ncorrectness issues because the static\nalgorithms I just described",
    "start": "3703260",
    "end": "3708660"
  },
  {
    "text": "assume that the graph of\nthe objects and pointers isn't changing, and when\nthe objects and pointers are",
    "start": "3708660",
    "end": "3715413"
  },
  {
    "text": "changing, you need to\nmake sure that you still get a correct answer. Real-time garbage collection\ntends to be conservative,",
    "start": "3715413",
    "end": "3723619"
  },
  {
    "text": "so it doesn't always free\neverything that's garbage. But for the things that\nit does decide to free,",
    "start": "3723620",
    "end": "3730740"
  },
  {
    "text": "those can be actually reclaimed. And there are various techniques\nto make real-time garbage",
    "start": "3730740",
    "end": "3736500"
  },
  {
    "text": "collection efficient. One possible way is, instead\nof just having one FROM",
    "start": "3736500",
    "end": "3741540"
  },
  {
    "text": "and TO space, you can have\nmultiple FROM and TO spaces, and then you just work on\none of the spaces at a time",
    "start": "3741540",
    "end": "3747660"
  },
  {
    "text": "so that it doesn't\nactually take that long to do garbage collection. You can do it incrementally\nthroughout your program.",
    "start": "3747660",
    "end": "3755130"
  },
  {
    "text": "There's also multithreaded\nstorage allocation and parallel garbage collection. So this is when you have\nmultiple threads running,",
    "start": "3755130",
    "end": "3762059"
  },
  {
    "text": "how do you allocate memory, and\nalso how do you collect garbage",
    "start": "3762060",
    "end": "3767100"
  },
  {
    "text": "in the background. So the algorithms become\nmuch trickier because there",
    "start": "3767100",
    "end": "3772940"
  },
  {
    "text": "are multiple threads\nrunning, and you have to deal with races\nand correctness issues and so forth.",
    "start": "3772940",
    "end": "3778380"
  },
  {
    "text": "And that's actually a\ntopic of the next lecture. ",
    "start": "3778380",
    "end": "3784860"
  },
  {
    "text": "So in summary,\nthese are the things that we talked about today. So we have the most basic form\nof storage, which is a stack.",
    "start": "3784860",
    "end": "3792860"
  },
  {
    "text": "The limitation of a stack is\nthat you can only free things at the top of the stack.",
    "start": "3792860",
    "end": "3797960"
  },
  {
    "text": "You can't free arbitrary\nthings in the stack, but it's very efficient when\nit works because the code is",
    "start": "3797960",
    "end": "3804140"
  },
  {
    "text": "very simple. And it can be inlined,\nand in fact this is what the C calling\nprocedure uses.",
    "start": "3804140",
    "end": "3810530"
  },
  {
    "text": "It places local variables\nin the return address of the function on the stack. The heap is the more\ngeneral form of storage,",
    "start": "3810530",
    "end": "3817789"
  },
  {
    "text": "but it's much more\ncomplicated to manage. And we talked about various\nways to do allocation",
    "start": "3817790",
    "end": "3823850"
  },
  {
    "text": "and deallocation for the heap. We have fixed-size\nallocation using free lists, variable-size\nallocation using",
    "start": "3823850",
    "end": "3830330"
  },
  {
    "text": "binned free lists, and then\nmany variants of these ideas are used in practice.",
    "start": "3830330",
    "end": "3837170"
  },
  {
    "text": "For garbage collection,\nthis is where you want to free the programmer\nfrom having to free objects.",
    "start": "3837170",
    "end": "3844070"
  },
  {
    "text": "And garbage\ncollection algorithms are supported in languages\nlike Java and Python.",
    "start": "3844070",
    "end": "3850099"
  },
  {
    "text": "We talked about various ways\nto do this reference counting, which suffers from\nthe limitation that it can't free cycles.",
    "start": "3850100",
    "end": "3856580"
  },
  {
    "text": "Mark-and-sweep and\nstop-and-copy-- these can free cycles. The mark-and-sweep\nprocedure doesn't",
    "start": "3856580",
    "end": "3861620"
  },
  {
    "text": "deal with external\nfragmentation, but the stop-and-copy\nprocedure does.",
    "start": "3861620",
    "end": "3866840"
  },
  {
    "text": "We also talked about internal\nand external fragmentation. So external fragmentation is\nwhen your memory blocks are all",
    "start": "3866840",
    "end": "3873950"
  },
  {
    "text": "over the place in\nvirtual memory. This can cause performance\nissues like disk thrashing and TLB misses.",
    "start": "3873950",
    "end": "3880040"
  },
  {
    "text": "Then there's internal\nfragmentation, where you're actually\nnot using all of the space in the\nblock that you allocate.",
    "start": "3880040",
    "end": "3887059"
  },
  {
    "text": "So for example, in the\nbinned free list algorithm, you do have a little bit\nof internal fragmentation because you're always rounding\nup to the nearest power of 2",
    "start": "3887060",
    "end": "3895063"
  },
  {
    "text": "greater than the size you\nwant, so you're wasting up to a factor of 2 in space. And in project 3,\nyou're going to look",
    "start": "3895063",
    "end": "3901310"
  },
  {
    "text": "much more at these storage\nallocation schemes, and then you'll also get to try\nsome of these in homework 6.",
    "start": "3901310",
    "end": "3909770"
  },
  {
    "text": "So any other questions? So that's all I have\nfor today's lecture.",
    "start": "3909770",
    "end": "3916060"
  },
  {
    "start": "3916060",
    "end": "3925355"
  }
]