[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6330"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6330",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at osw.mit.edu.",
    "start": "13320",
    "end": "19790"
  },
  {
    "text": "ERIK DEMAINE: All right. Today's lecture's full of\ntries and trays, and trees. Oh, my.",
    "start": "19790",
    "end": "25170"
  },
  {
    "text": "Lots of different synonyms\nall coming from trees. In particular,\nwe're going to cover",
    "start": "25170",
    "end": "31619"
  },
  {
    "text": "suffix trees today and various\nrepresentations of them, and how to build\nthem in linear time. Now, they are good things.",
    "start": "31620",
    "end": "37470"
  },
  {
    "text": "Some of you may have\nseen suffix trees before, but hopefully, haven't actually\nseen most of the things",
    "start": "37470",
    "end": "43260"
  },
  {
    "text": "we're going to cover,\nexcept for the very basics. So the general problem we're\ninterested in solving today",
    "start": "43260",
    "end": "50580"
  },
  {
    "text": "is string matching. ",
    "start": "50580",
    "end": "57660"
  },
  {
    "text": "And in string matching\nwe are given two strings. One of them we call the\ntext T and the other one",
    "start": "57660",
    "end": "67290"
  },
  {
    "text": "we call a pattern P.\nThese are both strings",
    "start": "67290",
    "end": "78630"
  },
  {
    "text": "over some alphabet. And the alphabet we're going\nto always call capital Sigma.",
    "start": "78630",
    "end": "85950"
  },
  {
    "text": "Think of that. It could be binary-- 0 and 1. Could be ASCII, so there's\n256 characters in there.",
    "start": "85950",
    "end": "91950"
  },
  {
    "text": "Could be Unicode-- pick\nyour favorite alphabet. Then it could be ACGT for DNA.",
    "start": "91950",
    "end": "100409"
  },
  {
    "text": "And their goal is to\nfind the occurrences of the pattern in the text. ",
    "start": "100410",
    "end": "112960"
  },
  {
    "text": "Could be we want to find\nsome of those occurrences or all of them, or count them. ",
    "start": "112960",
    "end": "129869"
  },
  {
    "text": "And in this lecture, we're\nonly interested in substring searches.",
    "start": "129870",
    "end": "134930"
  },
  {
    "text": "So the pattern is just a string. You want to know all the\nplaces where P occurs.",
    "start": "134930",
    "end": "145000"
  },
  {
    "text": "P might appear multiple times,\neven overlapping itself-- in those two\npositions, whatever.",
    "start": "145000",
    "end": "151740"
  },
  {
    "text": "You want to find all the shifts\nof P where it's identical to T. Now, there are\nlots of variations on this problem\nwhich we won't look",
    "start": "151740",
    "end": "157278"
  },
  {
    "text": "at in this lecture, such as\nwhen the pattern has wildcards in it, or you could imagine\nit being a regular expression,",
    "start": "157278",
    "end": "164152"
  },
  {
    "text": "or you don't want\nto match exactly, you want to match approximately,\nyou could have some mismatches, or it could require\nsome edits to match",
    "start": "164152",
    "end": "172170"
  },
  {
    "text": "T. We're not going to\nlook at those problems.  This is both an algorithmic\nproblem and a data structures",
    "start": "172170",
    "end": "179459"
  },
  {
    "text": "problem. If I give you this\ntext in the pattern, I just want to know the answer. You can do that in\nlinear time-- it's",
    "start": "179460",
    "end": "185879"
  },
  {
    "text": "famous Knuth-Morris-Pratt, or\nBoyer-Moore, or Rabin-Karp.",
    "start": "185880",
    "end": "192694"
  },
  {
    "text": "Lots of linear time\nalgorithms for doing that. We're interested in\nthe data structure version of the problem,\nstatic data structure.",
    "start": "192694",
    "end": "201070"
  },
  {
    "text": "So we're given\nthe text up front, given T. We want\nto preprocess T.",
    "start": "201070",
    "end": "207660"
  },
  {
    "text": "And then the query\nconsists of the pattern.",
    "start": "207660",
    "end": "214110"
  },
  {
    "text": "Imagine T being very\nbig, P being not so big. And we'd like to spend\nsomething like order",
    "start": "214110",
    "end": "225400"
  },
  {
    "text": "P time to do a query. ",
    "start": "225400",
    "end": "231222"
  },
  {
    "text": "That would be ideal because\nyou have to at least look at the query and\nyou don't really want to spend time\nlooking at the text.",
    "start": "231222",
    "end": "237240"
  },
  {
    "text": "You'd also like something\nlike order T space.",
    "start": "237240",
    "end": "243405"
  },
  {
    "text": "We don't want the space\nof the data structure to be much bigger than\nthe original text. So these are goals which we will\nmore or less achieve, depending",
    "start": "243405",
    "end": "250726"
  },
  {
    "text": "on exactly the problem you want. Sometimes we'll\nachieve this, sometimes we'll achieve almost this.",
    "start": "250727",
    "end": "256019"
  },
  {
    "text": "But these are really nice\nrunning times and space.",
    "start": "256019",
    "end": "261492"
  },
  {
    "text": "It's all optimal.  Before we get to\nthat problem, I want",
    "start": "261492",
    "end": "266660"
  },
  {
    "text": "to solve a simpler problem which\nis necessary to solve this one.",
    "start": "266660",
    "end": "272400"
  },
  {
    "text": "We'll call it a warm up.  And that's a good friend--\nthe predecessor problem,",
    "start": "272400",
    "end": "281860"
  },
  {
    "text": "but now among strings. ",
    "start": "281860",
    "end": "288060"
  },
  {
    "text": "Let's say we have k strings-- k texts-- T1 to T k.",
    "start": "288060",
    "end": "294410"
  },
  {
    "text": "And now the query is\nyou're given some pattern P and you want to\nknow where P fits among these strings\nin lexical order.",
    "start": "294410",
    "end": "302070"
  },
  {
    "text": "So a regular predecessor,\nbut now comparison is string comparison. Of course, you could try to\nsolve that using our existing",
    "start": "302070",
    "end": "308964"
  },
  {
    "text": "predecessor data structures. But they won't do very well. Even a binary search\ntree is not going to do well here because\ncomparing two strings",
    "start": "308964",
    "end": "315350"
  },
  {
    "text": "could take a very long time\nif those strings are long. So we don't want to do that. Instead, we're going\nto build a trie.",
    "start": "315350",
    "end": "324470"
  },
  {
    "text": "Now, tries we've\nseen in fast sorting lecture, when w is at least\nlogs at two plus epsilon event.",
    "start": "324470",
    "end": "331540"
  },
  {
    "text": " We used tries in a\nparticular setting there.",
    "start": "331540",
    "end": "336740"
  },
  {
    "text": "We're going to use them in\ntheir more native setting today a lot.",
    "start": "336740",
    "end": "341810"
  },
  {
    "text": " In this setting-- again,\na trie is a rooted tree.",
    "start": "341810",
    "end": "351710"
  },
  {
    "text": "The children\nbranches are labeled. ",
    "start": "351710",
    "end": "360000"
  },
  {
    "text": "And in this case,\nthey're labeled with letters in the alphabet-- Sigma.",
    "start": "360000",
    "end": "366030"
  },
  {
    "text": "So you have a node. And let's say, we have the\nEnglish alphabet-- a, b,",
    "start": "366030",
    "end": "373020"
  },
  {
    "text": "up to z. Those are your 26\npossible children. Some of them may not exist,\nthey are null pointers.",
    "start": "373020",
    "end": "379200"
  },
  {
    "text": "Others may point\nto actual nodes. That is a trie in\nits native setting,",
    "start": "379200",
    "end": "385560"
  },
  {
    "text": "which is when the alphabet\nis something you care about. Now, when we used tries\nbefore, our alphabet",
    "start": "385560",
    "end": "391260"
  },
  {
    "text": "just represented some\ndigit in some kind of arbitrary representation. The digit was made up of\nlog to the epsilon bits.",
    "start": "391260",
    "end": "398160"
  },
  {
    "text": "We were just using it as a tool. But this is where\ntries actually come from-- they come from trying\nto retrieve strings out",
    "start": "398160",
    "end": "405660"
  },
  {
    "text": "of some database, in this case. We're doing predecessor--\nthis is a practical problem.",
    "start": "405660",
    "end": "412320"
  },
  {
    "text": "Like a lot of library\nsearch engines, you type in the beginning\nof the title of a book and you want to know what is the\npreceding and succeeding book",
    "start": "412320",
    "end": "421080"
  },
  {
    "text": "title of what you query for. So this is something\npeople care about.",
    "start": "421080",
    "end": "426202"
  },
  {
    "text": "Although really they\nwant us-- typically, we want to solve this\nproblem because it's harder. ",
    "start": "426202",
    "end": "433020"
  },
  {
    "text": "So that's a trie. Now, to make this actually\nwork, what we'd like to do",
    "start": "433020",
    "end": "443070"
  },
  {
    "text": "is represent our strings. So how do we use this structure\nto represent strings T1 to T k?",
    "start": "443070",
    "end": "449510"
  },
  {
    "text": " We're going to\nrepresent those strings",
    "start": "449510",
    "end": "455960"
  },
  {
    "text": "in the obvious way, which\nwe've done many times in the past when we were doing\ninteger data structures--",
    "start": "455960",
    "end": "461970"
  },
  {
    "text": "as root to leaf paths. ",
    "start": "461970",
    "end": "468789"
  },
  {
    "text": "Because any root to leaf path\nis just a sequence of letters, and that's a string. So we just throw them in there.",
    "start": "468790",
    "end": "474520"
  },
  {
    "text": "Now, to do that, we need to\nchange things a little bit. We're going to add a new letter,\nwhich we usually present as $",
    "start": "474520",
    "end": "487389"
  },
  {
    "text": "sign, to the end\nof every string. ",
    "start": "487390",
    "end": "501550"
  },
  {
    "text": "I have an example. We're going to do four strings--",
    "start": "501550",
    "end": "513039"
  },
  {
    "text": " various spellings\nof Anna and Ann.",
    "start": "513039",
    "end": "521590"
  },
  {
    "text": "And say, we'd like to\nthrow these into a trie.",
    "start": "521590",
    "end": "527170"
  },
  {
    "text": "They all start with a. So at the root, there's going to\nbe four branches corresponding",
    "start": "527170",
    "end": "532600"
  },
  {
    "text": "to $ sign, a, e, and n. I'm supposing my\nalphabet is just a,",
    "start": "532600",
    "end": "537850"
  },
  {
    "text": "e, n because that's\nall that appears here. But everything will\nbe on the a branch.",
    "start": "537850",
    "end": "544570"
  },
  {
    "text": "And then from there\nwe're going to have-- let's see-- they\nall go to n next.",
    "start": "544570",
    "end": "552709"
  },
  {
    "text": "So they all follow this branch. Then one of them goes to a.",
    "start": "552710",
    "end": "560950"
  },
  {
    "text": "These all go to n afterwards. So we've got $ sign,\na we use, e, n we use.",
    "start": "560950",
    "end": "571240"
  },
  {
    "text": "And on the a\nbranch, we are done. This corresponds to and a, n, e.",
    "start": "571240",
    "end": "578680"
  },
  {
    "text": "We're finished. And we imagine there being $\nsign at the end of this string. So we follow the $ sign child.",
    "start": "578680",
    "end": "588940"
  },
  {
    "text": "The others are blank. And this leaf here\ncorresponds to a, n, a.",
    "start": "588940",
    "end": "595870"
  },
  {
    "text": "On the other hand, if\nwe could do a, n, n, there's three options.",
    "start": "595870",
    "end": "601630"
  },
  {
    "text": "We could be done. Or there could be an\na or an e to follow. So if we're done, that would\ncorrespond to the $ sign",
    "start": "601630",
    "end": "609310"
  },
  {
    "text": "pointer. That's going to be a leaf\ncorresponding to this string",
    "start": "609310",
    "end": "614529"
  },
  {
    "text": "here. Or it could be an a\nand then we're done.",
    "start": "614530",
    "end": "622465"
  },
  {
    "text": " And then we have a\nleaf corresponding",
    "start": "622465",
    "end": "628920"
  },
  {
    "text": "to Anna, a, n, n, a. Or could be we have an e\nnext and then we're done.",
    "start": "628920",
    "end": "639230"
  },
  {
    "text": " OK.",
    "start": "639230",
    "end": "644970"
  },
  {
    "text": "Not very exciting\nbut that is the tri representation of a, n, a; a,\nn, n; a, n, n, a; a, n, n, e.",
    "start": "644970",
    "end": "652260"
  },
  {
    "text": "And you can see there is exactly\none leaf per word down here.",
    "start": "652260",
    "end": "657930"
  },
  {
    "text": "And furthermore, if you\ntake in order traversal of those leaves, you get\nthese strings in order.",
    "start": "657930",
    "end": "663934"
  },
  {
    "text": "And typically, if you're\ngoing to store a data structure like this, you would\nstore these actual pointers. So once you get to a leaf,\nyou know which word matched.",
    "start": "663934",
    "end": "670670"
  },
  {
    "text": " So that's a trie. Seems pretty trivial.",
    "start": "670670",
    "end": "678884"
  },
  {
    "text": "Trievial?  But it turns out there's\nsomething already",
    "start": "678885",
    "end": "686050"
  },
  {
    "text": "pretty interesting about\nthis data structure. How do you do a\npredecessor search?",
    "start": "686050",
    "end": "692820"
  },
  {
    "text": "If I'm searching for something\nlike, I don't know, a, n, e-- because I made a typo--",
    "start": "692820",
    "end": "699850"
  },
  {
    "text": "then I follow a, n, and then\nI follow this e branch here and discover-- whoops--",
    "start": "699850",
    "end": "705490"
  },
  {
    "text": "there's nothing here. But right at that node I see,\nOK, well, my predecessor is going to be the max\nin this subtree, which",
    "start": "705490",
    "end": "711610"
  },
  {
    "text": "happens to be a, n, a. My successor is going to be\nthe min in this subtree, which happens to be a, n, n.",
    "start": "711610",
    "end": "717790"
  },
  {
    "text": "And so I find what I want. How long does it\ntake me to do that? Well, if I store\nsubtree mins and maxs,",
    "start": "717790",
    "end": "723970"
  },
  {
    "text": "then I just have to\nwalk down the tree. That will take order\nP time to walk down.",
    "start": "723970",
    "end": "729034"
  },
  {
    "text": "And then, once I'm\nat a node, I've got to do a predecessor\nor successor in the node.",
    "start": "729034",
    "end": "734740"
  },
  {
    "text": "So there are two issues. One is, given a node, how do\nyou know which way to walk down? And then, when you're\ndone, how do you",
    "start": "734740",
    "end": "741130"
  },
  {
    "text": "do predecessor in a node? It's the fundamental question. Now, this is something\nwe spent a lot of time doing in, say, fusion trees.",
    "start": "741130",
    "end": "746950"
  },
  {
    "text": "That was the big challenge. So this is not\nreally so trivial-- how do I represent a node?",
    "start": "746950",
    "end": "752560"
  },
  {
    "text": "One way to make it trivial is\nto assume that the alphabet is constant size, like two. Then, of course,\nthere's nothing to do.",
    "start": "752560",
    "end": "758770"
  },
  {
    "text": "It's a binary trie. You look at 0, you look at 1. You can figure out\nanything you need to do",
    "start": "758770",
    "end": "764560"
  },
  {
    "text": "if the alphabet is constant. But things get interesting\nif you imagine, well, the alphabet\nis some parameter, we don't know how big it is.",
    "start": "764560",
    "end": "770600"
  },
  {
    "text": "It might be substantial. So let's think about\nhow you might represent a trie or the node of a trie.",
    "start": "770600",
    "end": "778390"
  },
  {
    "start": "778390",
    "end": "783790"
  },
  {
    "text": "Let's call this trie\nnode representation. ",
    "start": "783790",
    "end": "791620"
  },
  {
    "text": "Any suggestions? What are the obvious ways to\nrepresent the node of a trie? Nothing fancy.",
    "start": "791620",
    "end": "798156"
  },
  {
    "text": "I have three obvious\nanswers, at least. AUDIENCE: Array. ERIK DEMAINE: Array. Good. That was my number one. ",
    "start": "798156",
    "end": "805090"
  },
  {
    "text": "Any more? That's I think the most obvious. AUDIENCE: Tree. ERIK DEMAINE: Tree. Good.",
    "start": "805090",
    "end": "810415"
  },
  {
    "text": "Do a binary search tree. Or? AUDIENCE: Hash table. ERIK DEMAINE: Hash table. Good. ",
    "start": "810415",
    "end": "819550"
  },
  {
    "text": "So for each of them we\nhave query time and space.",
    "start": "819550",
    "end": "824950"
  },
  {
    "text": " If I use an array,\nmeaning I have--",
    "start": "824950",
    "end": "831420"
  },
  {
    "text": "let's say, for a through z-- I have a pointer that either\nis null or points to the child.",
    "start": "831420",
    "end": "839710"
  },
  {
    "text": "This is going to be really\nfast because they're at a node. If I want to know, I just\nlook at that i-th letter",
    "start": "839710",
    "end": "845350"
  },
  {
    "text": "in my pattern P. I\nsay, oh, it's a j. So I look at the j\nposition and I follow it.",
    "start": "845350",
    "end": "851577"
  },
  {
    "text": "You might wonder, how do I\ndo predecessor and successor? Well, this is a\nstatic data structure. So for every cell,\nif it's null, I",
    "start": "851577",
    "end": "857470"
  },
  {
    "text": "can store the predecessor\nand successor in the node. With no more space.",
    "start": "857470",
    "end": "863910"
  },
  {
    "text": "This is Sigma space per node. So the amount of space is T\nSigma, which is not so great.",
    "start": "863910",
    "end": "874570"
  },
  {
    "text": "But the query is fast,\nquery is order P time. ",
    "start": "874570",
    "end": "880230"
  },
  {
    "text": "BST. The idea of the BST\nis instead of having a node that has some pointers,\nsome of which may be absent,",
    "start": "880230",
    "end": "887269"
  },
  {
    "text": "let's expand it out into\nsomething like this.",
    "start": "887270",
    "end": "894050"
  },
  {
    "text": "Actually, I'll use colors. This will make life a little\nbit cleaner in a moment. Because we are going to\nmodify this approach.",
    "start": "894050",
    "end": "901830"
  },
  {
    "text": "So let's say that the pointers\nyou care about are red. Those are the actual letter\npointers you want to do.",
    "start": "901830",
    "end": "908670"
  },
  {
    "text": "So the idea is to expand\nout this high degree node into binary nodes. You put appropriate keys in here\nso you can do a binary search.",
    "start": "908670",
    "end": "916150"
  },
  {
    "text": "And then, eventually, you get\ndown to where you need to go. This structure has\nhigh log Sigma.",
    "start": "916150",
    "end": "923960"
  },
  {
    "text": "So the query time is\ngoing to be P log Sigma. So that goes up a\nlittle bit, not perfect.",
    "start": "923960",
    "end": "931310"
  },
  {
    "text": "But the space now\nbecomes linear, so that's an improvement. Ideally, we'd like the\nbest of both of these--",
    "start": "931310",
    "end": "938630"
  },
  {
    "text": "optimal query time, optimal\nspace, linear space. And hash tables achieve that.",
    "start": "938630",
    "end": "945050"
  },
  {
    "text": "They give you order P\nquery and order T space.",
    "start": "945050",
    "end": "951529"
  },
  {
    "text": "Again, the issue is some of\nthese cells are absent so don't use an array. That's like a direct\nmapped hash table.",
    "start": "951530",
    "end": "956839"
  },
  {
    "text": "Use a hash table, use hashing. That way you can use linear\nspace per node, however many",
    "start": "956840",
    "end": "961880"
  },
  {
    "text": "occupied children there are. What is T here, by the way? T is the sum of the\nlengths of the T i's--",
    "start": "961880",
    "end": "971120"
  },
  {
    "text": "because here we're\nstoring multiple T i's. Or it's the number of\nnodes in the tree, which,",
    "start": "971120",
    "end": "979699"
  },
  {
    "text": "if your strings happen to\nhave a lot of common prefixes, the number of nodes in\nthe trie could be smaller than that, but not in general.",
    "start": "979700",
    "end": "988980"
  },
  {
    "text": "What's the problem\nwith the hash table? Question. AUDIENCE: [INAUDIBLE]",
    "start": "988980",
    "end": "998330"
  },
  {
    "text": "ERIK DEMAINE: Yes. For the BST, we need to\nstore some keys in this node. That lets you do\na binary search. For example, every\nnode could store",
    "start": "998330",
    "end": "1004450"
  },
  {
    "text": "the max in the left subtree-- just within this\nlittle tree, though. AUDIENCE: [INAUDIBLE]",
    "start": "1004450",
    "end": "1013090"
  },
  {
    "text": "ERIK DEMAINE: It\nis order T. Sorry, I see-- why is it\nnot O T Sigma space? You're only storing\none letter here,",
    "start": "1013090",
    "end": "1018579"
  },
  {
    "text": "so that fits in a single\nword, and two pointers. So every node only\ntakes constant space.",
    "start": "1018580",
    "end": "1024099"
  },
  {
    "text": "It's only T space, not T Sigma. Other questions?",
    "start": "1024099",
    "end": "1030939"
  },
  {
    "text": "Or answers? There's a problem with hashing-- doesn't actually solve the\nproblem we want to solve.",
    "start": "1030940",
    "end": "1038260"
  },
  {
    "text": "It doesn't solve predecessor. Because hashing mixes up\nthe order of the nodes. This is the problem\nwe had with--",
    "start": "1038260",
    "end": "1045009"
  },
  {
    "text": "what's it called-- signature\nsort, which hashed, it messed up, it permuted\nall the things in the nodes",
    "start": "1045010",
    "end": "1052789"
  },
  {
    "text": "and so you didn't know-- I mean, in a hash table,\nyou can't solve predecessor. That's what the\npredecessor problem is for.",
    "start": "1052790",
    "end": "1060289"
  },
  {
    "text": "I guess you could try to\nthrow a predecessor data structure in here. Actually, I hadn't\nthought of that before.",
    "start": "1060289",
    "end": "1066960"
  },
  {
    "text": "So we could use y-fast\ntries or something. And we would get\norder T space and--",
    "start": "1066960",
    "end": "1075650"
  },
  {
    "text": "I guess, with high\nprobability, this is also with high probability--",
    "start": "1075650",
    "end": "1080990"
  },
  {
    "text": "we get order P log\nlog Sigma, I guess.",
    "start": "1080990",
    "end": "1086179"
  },
  {
    "text": "Because I use Van Emde Boas. I'm going to have to call\nit 3.5, Van Emde Boas.",
    "start": "1086180",
    "end": "1095840"
  },
  {
    "text": "So that would be\nanother approach. So hashing will not\ndo a predecessor.",
    "start": "1095840",
    "end": "1102409"
  },
  {
    "text": "We'll do exact search, which is\nstill an interesting problem. Might give you some\nstrings I want to know-- is this string in your set?",
    "start": "1102409",
    "end": "1109640"
  },
  {
    "text": "But it won't solve the\npredecessor problem. So this is an interesting\nsolution-- hashing--",
    "start": "1109640",
    "end": "1114650"
  },
  {
    "text": "but not quite what we want. And Van Emde Boas doesn't\nquite do what we want either. It improves over\nthe BST approach",
    "start": "1114650",
    "end": "1120620"
  },
  {
    "text": "but we get another log in there. But it's still not order\nP. I kind of like order P.",
    "start": "1120620",
    "end": "1126080"
  },
  {
    "text": "Or at least, instead of\norder P times log log Sigma, I kind of like order\nP plus log Sigma.",
    "start": "1126080",
    "end": "1134030"
  },
  {
    "text": "And order P plus\nlog Sigma is known. So that's what I want\nto tell you about.",
    "start": "1134030",
    "end": "1141010"
  },
  {
    "text": "And this is normally\ndone with a structure called trays, which is\na portamento, I guess,",
    "start": "1141010",
    "end": "1149740"
  },
  {
    "text": "of tree and array. Somewhere in there there's\na tree and an array,",
    "start": "1149740",
    "end": "1155140"
  },
  {
    "text": "so it's a bit of\nan awkward word. But Those are developed by\nKoplowitz and Lewenstein,",
    "start": "1155140",
    "end": "1163690"
  },
  {
    "text": "in 2006, a fairly\nrecent innovation. I'll have this number 6--",
    "start": "1163690",
    "end": "1171240"
  },
  {
    "text": "trays, achieve order P plus\nlog Sigma and order T space.",
    "start": "1171240",
    "end": "1181900"
  },
  {
    "text": "So this is pretty good. And they will do predecessor\nand successor-- definitely an improvement over the BST.",
    "start": "1181900",
    "end": "1187037"
  },
  {
    "text": " It's open whether you could\ndo order P plus log log Sigma.",
    "start": "1187037",
    "end": "1195460"
  },
  {
    "text": "This is as far as I can tell,\nno one has worked on this. Maybe we will work on it today.",
    "start": "1195460",
    "end": "1203920"
  },
  {
    "text": "So something to think about-- whether you could\nget the best of all of these worlds for predecessor.",
    "start": "1203920",
    "end": "1209174"
  },
  {
    "text": "There's a lower bound-- you\nneed to spend at least log log Sigma time. Because even if you\ntry as a single node,",
    "start": "1209174",
    "end": "1214319"
  },
  {
    "text": "you have the\npredecessor lower bound. And we know log log universe\nsize is the best you can do in this regime.",
    "start": "1214319",
    "end": "1219860"
  },
  {
    "text": " So that's where we're going.",
    "start": "1219860",
    "end": "1226559"
  },
  {
    "text": "Instead of describing\ntrays, though, I'm going to describe\na new way to do it, which has never\nbeen seen before",
    "start": "1226560",
    "end": "1232200"
  },
  {
    "text": "in any class or anywhere. Because it's brand new. It's developed by Martin\nFarach-Colton, who",
    "start": "1232200",
    "end": "1237720"
  },
  {
    "text": "did the LCA and the\nlevel ancestor structures that we saw in last class.",
    "start": "1237720",
    "end": "1243480"
  },
  {
    "text": "And he just told it to\nme and it's really cool so we're going to cover it. ",
    "start": "1243480",
    "end": "1251640"
  },
  {
    "text": "A simpler way to get\nthis same bound of trays. ",
    "start": "1251640",
    "end": "1258990"
  },
  {
    "text": "And the first thing\nwe're going to do is use a weight balanced BST. ",
    "start": "1258990",
    "end": "1267040"
  },
  {
    "text": "This will achieve P plus log\nk query and linear space.",
    "start": "1267040",
    "end": "1276670"
  },
  {
    "text": " k, remember, is the\nnumber of strings",
    "start": "1276670",
    "end": "1283210"
  },
  {
    "text": "that we're storing, so it's the\nnumber of leaves in the trie. So it's not quite as\ngood as P plus log Sigma",
    "start": "1283210",
    "end": "1288789"
  },
  {
    "text": "but it's going to be a warm up. We're going to to do this and\nthen we're going to improve it. ",
    "start": "1288789",
    "end": "1294549"
  },
  {
    "text": "Remember weight balanced trees,\nwe talked about them way back in lecture 3, I believe.",
    "start": "1294550",
    "end": "1301549"
  },
  {
    "text": "There is an issue of\nwhat is the weight. And typically, you say,\nthe weight of a subtree",
    "start": "1301550",
    "end": "1306850"
  },
  {
    "text": "is the number of\nnodes in the subtree. I'm going to change\nthat slightly and say, the weight of a subtree is\nthe number of descendant",
    "start": "1306850",
    "end": "1313360"
  },
  {
    "text": "leaves in the subtree,\nnot the number of nodes,",
    "start": "1313360",
    "end": "1319299"
  },
  {
    "text": "because it's log k. We really care about the\nnumber of leaves down there.",
    "start": "1319300",
    "end": "1324460"
  },
  {
    "text": "There could be long\npaths here which we are not so excited about. We really care about how\nmany leaves are down there.",
    "start": "1324460",
    "end": "1331149"
  },
  {
    "text": "Like the weight of this\nnode here is three-- there's three leaves below it. ",
    "start": "1331150",
    "end": "1341410"
  },
  {
    "text": "You may recall\nweight balanced BSTs trying to make the weight\nof the left subtree within a constant factor of the\nweight of the right subtree.",
    "start": "1341410",
    "end": "1348860"
  },
  {
    "text": "Because we're static,\nwe can be even simpler and say, find the\noptimal partition. ",
    "start": "1348860",
    "end": "1357190"
  },
  {
    "text": "So we're thinking\nabout this approach-- idea of expanding a large degree\nnode into some binary tree.",
    "start": "1357190",
    "end": "1364570"
  },
  {
    "text": "We have a choice of\nwhat binary tree to use. With three nodes it may\nbe not many choices-- that could be this or it could\nbe a straight this way",
    "start": "1364570",
    "end": "1370693"
  },
  {
    "text": "or a straight line that way. Those are different. And if one of these\nguys is really heavy, one of these children\nis really heavy,",
    "start": "1370693",
    "end": "1376750"
  },
  {
    "text": "you want to put it\ncloser to the root. So that's what\nwe're going to do. ",
    "start": "1376750",
    "end": "1384060"
  },
  {
    "text": "Let me draw it this way. That's kind of an array.",
    "start": "1384060",
    "end": "1389270"
  },
  {
    "text": "But what this array\nrepresents is for a node-- so here's my node, it\nhas lots of children.",
    "start": "1389270",
    "end": "1396040"
  },
  {
    "text": "Some of these are\nheavy, some of them are light, lighter than others.",
    "start": "1396040",
    "end": "1401567"
  },
  {
    "text": "We don't know how\nthey're distributed. But they're ordered, we\nhave to preserve the order.",
    "start": "1401567",
    "end": "1407374"
  },
  {
    "text": "What this is\nsupposed to represent is the total number of\nleaves in this subtree. So the total number\nof leaves here.",
    "start": "1407374",
    "end": "1416050"
  },
  {
    "text": "And then I'm going to partition\nthis rectangle into groups corresponding to these sizes.",
    "start": "1416050",
    "end": "1423429"
  },
  {
    "text": "So these are small, medium,\nsmall, little less than medium, big, and then small.",
    "start": "1423430",
    "end": "1431290"
  },
  {
    "text": "Something like that. So these horizontal\nlengths correspond to the number of\nleaves in these things,",
    "start": "1431290",
    "end": "1437260"
  },
  {
    "text": "correspond to the\nweight of my children. So I look at that\nand I say, well, what I'd really like\nto do is split this",
    "start": "1437260",
    "end": "1444160"
  },
  {
    "text": "in the middle, which\nis, maybe, here. I say, OK, well,\nthen I'll split here. That's pretty close\nto the middle.",
    "start": "1444160",
    "end": "1451090"
  },
  {
    "text": "So my left subtree will\nconsist of these guys, my right subtree will\nconsist of these guys. And then I recurse--",
    "start": "1451090",
    "end": "1456760"
  },
  {
    "text": "over here I've\nsplit at the middle, I find the thing that's\nclosest to the middle. Over here I've\nsplit at the middle,",
    "start": "1456760",
    "end": "1462898"
  },
  {
    "text": "I find the thing that's\nclosest to the middle. It's pretty much determined. So my root node\ncorresponds to this one.",
    "start": "1462898",
    "end": "1470642"
  },
  {
    "text": "It's going to partition here. So over on the right,\nthere's going to be-- ",
    "start": "1470642",
    "end": "1477250"
  },
  {
    "text": "here's going to be the\nbig tree and then here is the small tree. So this small tree\ncorresponds to this one. This big tree corresponds\nto this interval.",
    "start": "1477250",
    "end": "1484270"
  },
  {
    "text": "Then on the left we've got\nfour things we need to store. So these are the red\npointers that we had before.",
    "start": "1484270",
    "end": "1491970"
  },
  {
    "text": "Then over on the left, we're\ngoing to have a partition. And then there's going\nto be two guys here.",
    "start": "1491970",
    "end": "1497250"
  },
  {
    "text": "It doesn't really matter\nhow we store them. It's something like this.",
    "start": "1497250",
    "end": "1503050"
  },
  {
    "text": "There is medium and small.",
    "start": "1503050",
    "end": "1510214"
  },
  {
    "text": "And then over on the left,\nwe also have two guys. So it's going to be,\nagain, something like this.",
    "start": "1510214",
    "end": "1515740"
  },
  {
    "text": " You got medium and small.",
    "start": "1515740",
    "end": "1523370"
  },
  {
    "text": "So you see how that worked. Our main goal was to make this\nbig guy as close to the root",
    "start": "1523370",
    "end": "1529270"
  },
  {
    "text": "as possible. It was the biggest and that's\nbasically what happened. This one is really big. And we couldn't quite put\nit as a child of the root",
    "start": "1529270",
    "end": "1536330"
  },
  {
    "text": "because it appeared\nin the middle, but we could put it as a\ngrandchild at the root.",
    "start": "1536330",
    "end": "1541480"
  },
  {
    "text": "In general, if you have\na super heavy child, it will always become a child\nor grandchild of the root.",
    "start": "1541480",
    "end": "1547150"
  },
  {
    "text": "So in constant number of\ntraversals you'll get there. Now again, you fill in\nthese nodes with some keys",
    "start": "1547150",
    "end": "1552190"
  },
  {
    "text": "so you can do a binary search. But now the binary\nsearch might go faster",
    "start": "1552190",
    "end": "1557950"
  },
  {
    "text": "than log Sigma, which\nis what we had before. And indeed, you can prove\nthat this really works well.",
    "start": "1557950",
    "end": "1564340"
  },
  {
    "start": "1564340",
    "end": "1572409"
  },
  {
    "text": "So what's the claim?  Claim is every two\nedges you follow either",
    "start": "1572410",
    "end": "1592950"
  },
  {
    "text": "advance one letter in P-- ",
    "start": "1592950",
    "end": "1598440"
  },
  {
    "text": "these are the red edges\nthat we want to follow. So if we follow a\nred edge, then we've made progress to the next node.",
    "start": "1598440",
    "end": "1605020"
  },
  {
    "text": "So this would be\nfollowing a red edge. Or we reduce the number of\ncandidate to T i's by 2/3",
    "start": "1605020",
    "end": "1624270"
  },
  {
    "text": "or, I guess, to 2/3\nof its original value. So we lose a third\nof the strings.",
    "start": "1624270",
    "end": "1630210"
  },
  {
    "text": "That's what I'd like to claim. And it's not too\nhard to see this. You have to imagine all of\nthese possible partitions.",
    "start": "1630210",
    "end": "1637684"
  },
  {
    "text": "It's a little bit awkward. The idea is the following. If you take one\nof these arrays--",
    "start": "1637685",
    "end": "1643170"
  },
  {
    "text": "this view of all the leaves\njust laid out on the line-- you say, well, I'd like\nto split in half and half.",
    "start": "1643170",
    "end": "1650800"
  },
  {
    "text": "But that will never happen\nunless I'm really lucky. So let's think about\nthis one third splitting.",
    "start": "1650800",
    "end": "1657540"
  },
  {
    "text": "If I were able to cut anywhere\nin here, then in one step, actually, I would achieve\nthis 2/3 reduction.",
    "start": "1657540",
    "end": "1665429"
  },
  {
    "text": "I'd lose a third of the nodes. ",
    "start": "1665430",
    "end": "1670529"
  },
  {
    "text": "If I end up cutting here,\nfor example, then either I",
    "start": "1670530",
    "end": "1676170"
  },
  {
    "text": "go to the left and I lost\nalmost 2/3 of the nodes, or I go to the\nright and I at least lost this one third of the notes\nor one third of the leaves,",
    "start": "1676170",
    "end": "1682410"
  },
  {
    "text": "I should say. So that would be\na good situation if I got some cut in here.",
    "start": "1682410",
    "end": "1687610"
  },
  {
    "text": "But it might be there is no\npossible cut I can make in here because there's a giant child\nin here that has more than one",
    "start": "1687610",
    "end": "1696878"
  },
  {
    "text": "third of the nodes. It would have to span\nall the way across here. So I can't make any\ncuts, I can only",
    "start": "1696879",
    "end": "1702630"
  },
  {
    "text": "cut between child boundaries. In that situation,\nyou make this--",
    "start": "1702630",
    "end": "1709880"
  },
  {
    "text": "well, this is when I need to\nfollow two edges, not one. When there's a super big\nchild like that, as we said,",
    "start": "1709880",
    "end": "1716550"
  },
  {
    "text": "it will become a\ngrandchild of the root. So it will be-- there's the root and then\nhere is the giant tree.",
    "start": "1716550",
    "end": "1725070"
  },
  {
    "text": "And then there's going to be\nthe other stuff here and here.",
    "start": "1725070",
    "end": "1730269"
  },
  {
    "text": "So after I go down to either\none step or two steps, I will either get here--",
    "start": "1730270",
    "end": "1737390"
  },
  {
    "text": "sorry, more red chalk,\nthis was a red point.",
    "start": "1737390",
    "end": "1743020"
  },
  {
    "text": "Now, this is going to a child. So if I went there,\nI'm happy in two steps. I advance one letter in P.\nOr in two steps, I went here",
    "start": "1743020",
    "end": "1752260"
  },
  {
    "text": "or I went here. And this was a huge\namount of the nodes, this is at least a\nthird of the nodes. Again, if I end up\nhere or end up here,",
    "start": "1752260",
    "end": "1758220"
  },
  {
    "text": "I lost 2/3 of the\ncandidate leaves. I mean, I lost one third\nof the candidate leaves,",
    "start": "1758220",
    "end": "1763740"
  },
  {
    "text": "leaving 2/3 of them. ",
    "start": "1763740",
    "end": "1768840"
  },
  {
    "text": "If this happens, I charged\nto this order P term. And if the other\nsituation happens,",
    "start": "1768840",
    "end": "1774809"
  },
  {
    "text": "I charge the log k term--\nbecause I can only reduce k by a factor of 2/3--",
    "start": "1774810",
    "end": "1781260"
  },
  {
    "text": "order log k times. This implies order\np plus log k search.",
    "start": "1781260",
    "end": "1790720"
  },
  {
    "text": "So a very simple idea. Just change the way we do BSTs. And we get, in some\ncases, a better bound.",
    "start": "1790720",
    "end": "1797210"
  },
  {
    "text": "But not in all\ncases because maybe P plus log k might be bigger\nthan P times log Sigma.",
    "start": "1797210",
    "end": "1803240"
  },
  {
    "text": "And k and Sigma are kind of\nincomparable, so we don't know. That's where method\n5 comes in, which",
    "start": "1803240",
    "end": "1813350"
  },
  {
    "text": "is our good friend\nfrom last class-- leaf trimming and indirection.",
    "start": "1813350",
    "end": "1818752"
  },
  {
    "text": " So we're going to use\nthis idea of finding--",
    "start": "1818752",
    "end": "1826639"
  },
  {
    "text": "we're going to cut below\nmaximally deep nodes",
    "start": "1826640",
    "end": "1833750"
  },
  {
    "text": "with the right number\nof descendants in them. ",
    "start": "1833750",
    "end": "1843820"
  },
  {
    "text": "So we need at least\nSigma descendants.",
    "start": "1843820",
    "end": "1848909"
  },
  {
    "text": " It could just be descendants\nor descendant leaves,",
    "start": "1848910",
    "end": "1856090"
  },
  {
    "text": "doesn't actually matter. ",
    "start": "1856090",
    "end": "1862890"
  },
  {
    "text": "Let me draw a picture, maybe. This is pretty much\nwhat we did before,",
    "start": "1862890",
    "end": "1868040"
  },
  {
    "text": "except before this magic number\nwas log n that we needed or 1/2 log n or something.",
    "start": "1868040",
    "end": "1873820"
  },
  {
    "text": "Now it's going to be\nSigma that we need. So it is we find these\nmaximally deep nodes-- these dots-- that\nhave at least--",
    "start": "1873820",
    "end": "1882879"
  },
  {
    "text": "I guess, there is really\nmultiple things hanging off here. In general, it could be\nseveral things hanging off.",
    "start": "1882880",
    "end": "1889990"
  },
  {
    "text": "But the total number\nof descendants of each of these nodes\nis at least Sigma.",
    "start": "1889990",
    "end": "1895970"
  },
  {
    "text": "So what that implies\nis that the number of these dots, the number of\nthe leaves in the top tree--",
    "start": "1895970",
    "end": "1903420"
  },
  {
    "text": "so up here-- number of leaves\nis at most T over Sigma.",
    "start": "1903420",
    "end": "1911890"
  },
  {
    "text": "Because we can charge each\nof these nodes to Sigma descendants in each of them.",
    "start": "1911890",
    "end": "1918490"
  },
  {
    "text": "So that's good because it\nsays we can use method 1-- the simple array method--\nwhich is fast but spacious.",
    "start": "1918490",
    "end": "1926830"
  },
  {
    "text": "But if our new size of the trie\ngets divided by a Sigma factor,",
    "start": "1926830",
    "end": "1931870"
  },
  {
    "text": "then this turns\nout to be linear. So up here we use method 1. ",
    "start": "1931870",
    "end": "1938980"
  },
  {
    "text": "Now, you got to be a little\ncareful because we can't use method 1 on all the nodes. We can definitely\nuse it on the leaves",
    "start": "1938980",
    "end": "1944710"
  },
  {
    "text": "because there aren't\ntoo many leaves. That means we can also use it on\nthe number of branching nodes.",
    "start": "1944710",
    "end": "1952910"
  },
  {
    "text": "Number of branching\nnodes is also going to be, at\nmost, T over Sigma",
    "start": "1952910",
    "end": "1957940"
  },
  {
    "text": "because it's actually\none fewer branching node than there are leaves.",
    "start": "1957940",
    "end": "1963310"
  },
  {
    "text": "So great, I can use\narrays on the leaves,",
    "start": "1963310",
    "end": "1969340"
  },
  {
    "text": "I can use arrays on\nthe branching nodes. I can't use it on the\nnon-branching nodes.",
    "start": "1969340",
    "end": "1974950"
  },
  {
    "text": "Non-branching nodes are nodes\nwith a single descendant and everything else is null.",
    "start": "1974950",
    "end": "1980650"
  },
  {
    "text": "What do I do for those nodes? Very difficult. I just store\nthat one pointer in a storage",
    "start": "1980650",
    "end": "1986470"
  },
  {
    "text": "label. I guess you could think\nof that as method 2 in a very trivial case. You see-- is this\nthe right label?",
    "start": "1986470",
    "end": "1993670"
  },
  {
    "text": "Yes or no. So this is the\nnon-branching nodes. ",
    "start": "1993670",
    "end": "2002730"
  },
  {
    "text": "Non-branching top nodes-- I will use method 2.",
    "start": "2002730",
    "end": "2008430"
  },
  {
    "text": "So I guess this is really-- well, for these\nguys I use method 1, for these guys I use method 1.",
    "start": "2008430",
    "end": "2015930"
  },
  {
    "text": "So I can afford all this. This will take order T space. ",
    "start": "2015930",
    "end": "2023070"
  },
  {
    "text": "And it will be fast because\neither I'm using arrays or I really don't\nhave any work to do,",
    "start": "2023070",
    "end": "2028230"
  },
  {
    "text": "and so it doesn't\nreally matter what I do. But except I can't use\narrays because they would be too spacious.",
    "start": "2028230",
    "end": "2033990"
  },
  {
    "text": "So that handles the top. Now, the issue is, what about\nthese bottom structures? The bottom structures--\nwhat do we know?",
    "start": "2033990",
    "end": "2039540"
  },
  {
    "text": "They have to have\nless than Sigma nodes, less than Sigma descendants.",
    "start": "2039540",
    "end": "2045659"
  },
  {
    "text": "Also less than Sigma leaves. So in other words,\nin these trees",
    "start": "2045660",
    "end": "2055888"
  },
  {
    "text": "we have k less than Sigma. Well, then we can\nafford to use method 4.",
    "start": "2055889",
    "end": "2061888"
  },
  {
    "text": "Because our whole goal is to get\nk down to Sigma in this bound. So in the bottom\ntrees, we use method 4.",
    "start": "2061889",
    "end": "2069105"
  },
  {
    "text": " Method 4 was always\nlinear space. And the issue was we\npaid P plus log k.",
    "start": "2069105",
    "end": "2076260"
  },
  {
    "text": "But now in here, k is less\nthan Sigma in these trees.",
    "start": "2076260",
    "end": "2084239"
  },
  {
    "text": "So that means we get order\nP plus log Sigma query time.",
    "start": "2084239",
    "end": "2090690"
  },
  {
    "text": " And that's the best we know how\nto do if you want predecessor",
    "start": "2090690",
    "end": "2096550"
  },
  {
    "text": "at the nodes. So it matches this tray\nbound in pretty easy way.",
    "start": "2096550",
    "end": "2101830"
  },
  {
    "text": "Just to apply weight balanced,\nclean things up a little bit. But only do that at the\nleaves and everywhere up",
    "start": "2101830",
    "end": "2107800"
  },
  {
    "text": "here, basically. Except the non-branching\nnodes use arrays. So for the most part arrays\nand then, at the bottom,",
    "start": "2107800",
    "end": "2113280"
  },
  {
    "text": "you use weight balance. This is how you ought\nto represent a trie.",
    "start": "2113280",
    "end": "2119339"
  },
  {
    "text": "If you want to preserve\nthe order of the children, this is the best\nwe know how to do. If you don't want to preserve\norder, just use a hash table.",
    "start": "2119340",
    "end": "2126329"
  },
  {
    "text": "So it depends on\nthe application. ",
    "start": "2126330",
    "end": "2132110"
  },
  {
    "text": "One fun application of\nthis is string sorting. ",
    "start": "2132110",
    "end": "2139370"
  },
  {
    "text": "It's not a data\nstructures problem so I don't want to spend\ntoo much time on it. But you use this trie data\nstructure to sort strings.",
    "start": "2139370",
    "end": "2145339"
  },
  {
    "text": "You just throw in a string\nand then throw in a string. We didn't talk about dynamic\ntries but it can be done.",
    "start": "2145340",
    "end": "2152670"
  },
  {
    "text": "And if you throw it,\nyou just sort of find where you fall off and\nthen add the thing. Now, you have to maintain\nall this funky stuff",
    "start": "2152670",
    "end": "2159770"
  },
  {
    "text": "but weight balanced trees can\nbe made dynamic and indirection can be made dynamic.",
    "start": "2159770",
    "end": "2165030"
  },
  {
    "text": "So you end up with this sort\nof simple incremental scheme. You end up with T\nplus k log Sigma",
    "start": "2165030",
    "end": "2174410"
  },
  {
    "text": "to sort k strings of total size\nT with alphabet size Sigma.",
    "start": "2174410",
    "end": "2181789"
  },
  {
    "text": "This is good. If I used, for example,\nmerge sort to sort strings, it's going to be very bad.",
    "start": "2181790",
    "end": "2187160"
  },
  {
    "text": "It's going to be something like\nT times k times log something.",
    "start": "2187160",
    "end": "2192650"
  },
  {
    "text": "We didn't really\ncare about the log. T times k is bad. That's because comparing strings\ncould potentially take T time.",
    "start": "2192650",
    "end": "2199400"
  },
  {
    "text": "And then there's k of them. But this is linear. This is the sum of the\nlengths of the strings.",
    "start": "2199400",
    "end": "2204870"
  },
  {
    "text": "There's this extra little term. But most of the time that's\ngoing to be dominated by the length of the strings.",
    "start": "2204870",
    "end": "2211599"
  },
  {
    "text": "So that's a good way to\nsort strings using tries. Tries by themselves, I mean this\nis about all there is to say.",
    "start": "2211600",
    "end": "2217800"
  },
  {
    "text": "So let's move on to suffix\ntrees and compressed tries.",
    "start": "2217800",
    "end": "2222870"
  },
  {
    "text": "Now, we actually did compressed\ntries in the signature sort lecture. ",
    "start": "2222870",
    "end": "2234492"
  },
  {
    "text": "Actually, why don't\nI go over here? ",
    "start": "2234492",
    "end": "2245210"
  },
  {
    "text": "So tries-- branches were\nlabeled with letters. That's still going to be\ntrue for a compressed trie.",
    "start": "2245210",
    "end": "2252160"
  },
  {
    "text": "But as we saw in that\nlecture, in compressed trie we're going to get rid of\nthe non-branching nodes.",
    "start": "2252160",
    "end": "2257819"
  },
  {
    "text": " So idea with the compressed\ntrie is very simple--",
    "start": "2257820",
    "end": "2264010"
  },
  {
    "text": "just contract non-branching\npaths into a single edge.",
    "start": "2264010",
    "end": "2269500"
  },
  {
    "start": "2269500",
    "end": "2283580"
  },
  {
    "text": "This is our example of a trie. We're just going to modify\nit to make a compressed trie. ",
    "start": "2283580",
    "end": "2294890"
  },
  {
    "text": "Here we have a\nnon-branching path. We have to follow an a, and\nthen we have to follow an n.",
    "start": "2294890",
    "end": "2300770"
  },
  {
    "text": "There's no point in\nhaving this node. You might as well just\nhave a single edge that says a-n on it.",
    "start": "2300770",
    "end": "2306560"
  },
  {
    "text": "So we go from here,\nfrom the root. We're going to have\nan edge that says a-n.",
    "start": "2306560",
    "end": "2313369"
  },
  {
    "text": " And in some sense, the\nkey of this child is a.",
    "start": "2313370",
    "end": "2320560"
  },
  {
    "text": "If you're starting up\nhere and you want to know which way should I go, you\nshould only go this way",
    "start": "2320560",
    "end": "2325820"
  },
  {
    "text": "if your first letter is a. After that, your next\nletter better be n, otherwise you fell off the tree.",
    "start": "2325820",
    "end": "2331420"
  },
  {
    "text": "So that's the\ncompression we're doing. Now, here we have-- this\nis a branching node, so that node we keep intact.",
    "start": "2331420",
    "end": "2336700"
  },
  {
    "text": " This is an n, this is an a here.",
    "start": "2336700",
    "end": "2343840"
  },
  {
    "text": "But here it's non-branching. Let me draw this a\nlittle bit longer. In reality, it's\njust a single edge.",
    "start": "2343840",
    "end": "2350350"
  },
  {
    "text": "And again, the key is a, and\nthen you must have a $ sign on afterwards. Then you reach a\nleaf, the first leaf.",
    "start": "2350350",
    "end": "2356730"
  },
  {
    "text": "If we follow the n branch-- this is branching, so\nthat node is preserved.",
    "start": "2356730",
    "end": "2362277"
  },
  {
    "text": " If I go this way, it's a\n$ sign and I reach a leaf.",
    "start": "2362278",
    "end": "2368730"
  },
  {
    "text": "If I go this way it's an a that\nmust be followed by a $ sign, so that's a leaf.",
    "start": "2368730",
    "end": "2374020"
  },
  {
    "text": "And if I go this way, it must\nbe an e, followed by a $ sign, which is a leaf.",
    "start": "2374020",
    "end": "2379780"
  },
  {
    "text": "Again, these four leaves\ncan point to these places. That's a compressed trie. Pretty obvious.",
    "start": "2379780",
    "end": "2385966"
  },
  {
    "text": "The nice thing about the\ncompressed trie is the number-- here we knew the number\nof non-branching nodes, it was at most the\nnumber of leaves.",
    "start": "2385967",
    "end": "2391780"
  },
  {
    "text": "Over here, the number\nof internal nodes is at most the number of leaves. So this structure has\norder k nodes in total",
    "start": "2391780",
    "end": "2399540"
  },
  {
    "text": "because we got rid of all\nthe non-branching nodes. I guess except the root, the\nroot might not be branching.",
    "start": "2399540",
    "end": "2404851"
  },
  {
    "text": " We've got a big O\nthere to cover us. ",
    "start": "2404852",
    "end": "2412000"
  },
  {
    "text": "And all the things we said\nabout representing tries here, you can do the same thing\nwith a compressed trie.",
    "start": "2412000",
    "end": "2418300"
  },
  {
    "text": "I need to write\ndown that 3.5 here. ",
    "start": "2418300",
    "end": "2433980"
  },
  {
    "text": "And in fact, these\nresults get better because before order T meant the\nnumber of nodes in the trie.",
    "start": "2433980",
    "end": "2440880"
  },
  {
    "text": "Now order T will be\nthe number of nodes in the compressed trie,\nwhich is actually order k. So life gets really\ngood in this world.",
    "start": "2440880",
    "end": "2450902"
  },
  {
    "text": "I did it in the trie\nsetting because it's just simpler to think about. But really, you would always\nstore a compressed trie.",
    "start": "2450902",
    "end": "2455968"
  },
  {
    "text": "There's no point\nin storing a trie. You can still do the\nsame kinds of searches. ",
    "start": "2455968",
    "end": "2464010"
  },
  {
    "text": "But really, compressed tries\nare warm up for suffix trees.",
    "start": "2464010",
    "end": "2469150"
  },
  {
    "text": "So let's talk\nabout suffix trees. ",
    "start": "2469150",
    "end": "2474720"
  },
  {
    "text": "Suffix trees are\na compressed trie. So really they should\nbe called suffix tries.",
    "start": "2474720",
    "end": "2482789"
  },
  {
    "text": "And occasionally, people\nwill call them suffix tries. But most people call\nthem suffix trees,",
    "start": "2482790",
    "end": "2488745"
  },
  {
    "text": "so for consistency I'll\ncall them trees as well. But they are tries. ",
    "start": "2488745",
    "end": "2502542"
  },
  {
    "text": "I'm going to introduce\nsome notation here. ",
    "start": "2502542",
    "end": "2513457"
  },
  {
    "text": "With tries, we are\nthinking about lots of different strings. In this case, we're going back\nto our string matching problem.",
    "start": "2513457",
    "end": "2519590"
  },
  {
    "text": "We have a single text and we\nwant to preprocess that text. But we're going to turn\nit into multiple strings",
    "start": "2519590",
    "end": "2524940"
  },
  {
    "text": "by looking at all\nsuffixes of the string. This is Python\nnotation for everything from letter i onwards.",
    "start": "2524940",
    "end": "2532590"
  },
  {
    "text": "And we do that for all i,\nso that's a lot of strings. And we build the\ncompressed trie over them.",
    "start": "2532590",
    "end": "2538824"
  },
  {
    "text": "That's the idea. And to make it work out--\nbecause you remember, with tries we had to append\n$ sign to every string.",
    "start": "2538824",
    "end": "2545790"
  },
  {
    "text": "In this case, we'd just\nhave to append $ sign to T, and then all suffixes\nwill end with a $ sign.",
    "start": "2545790",
    "end": "2551220"
  },
  {
    "text": "So that covers\nus. $ sign, again, is a character not\nappearing in the alphabet.",
    "start": "2551220",
    "end": "2556510"
  },
  {
    "text": "And that's it. So that's a definition. Let's do an example. ",
    "start": "2556510",
    "end": "2569240"
  },
  {
    "text": "At this point, we going for\nthis goal of order P query, order T space. Suffix trees will be a\nway to achieve that goal.",
    "start": "2569240",
    "end": "2577130"
  },
  {
    "start": "2577130",
    "end": "2583819"
  },
  {
    "text": "Let's do my favorite\nexample which is banana.",
    "start": "2583820",
    "end": "2590375"
  },
  {
    "text": " I had a friend who said, I\nknow how to spell banana,",
    "start": "2590375",
    "end": "2597650"
  },
  {
    "text": "I just don't know when to stop. There's nice pattern to it\nand a lot of repeated letters",
    "start": "2597650",
    "end": "2602990"
  },
  {
    "text": "and so on. I've got to number\nthe characters. He said that when he was like\nsix, not when he was older.",
    "start": "2602990",
    "end": "2608880"
  },
  {
    "text": " It's a little harder when\nyou're writing it on the board but we all know how to\nspell banana, I hope.",
    "start": "2608880",
    "end": "2616580"
  },
  {
    "text": "I'd got it right, right? It should be 7 letters,\nincluding the $ sign. ",
    "start": "2616580",
    "end": "2623395"
  },
  {
    "text": "There they are. So there's a suffix which\nis the whole string. There's a suffix which\nis a, n, a, n, a, $ sign.",
    "start": "2623395",
    "end": "2628670"
  },
  {
    "text": "There is a suffix which\nis n, a, n, a, $ sign. There's a suffix which\nis a, n, a, $ sign. Suffix n, a, $ sign. a, $ sign.",
    "start": "2628670",
    "end": "2633890"
  },
  {
    "text": "And $ sign. And empty, I suppose, but we're\nnot going to store that one. You don't need to.",
    "start": "2633890",
    "end": "2641210"
  },
  {
    "text": "Cool. I'm going to cheat a little\nbit and look at my figure because it is a little\nbit of thinking.",
    "start": "2641210",
    "end": "2647349"
  },
  {
    "text": "One The final challenge\nof this lecture will be construct this\ndiagram in linear time.",
    "start": "2647350",
    "end": "2654559"
  },
  {
    "text": "But I'm, just for\nnow, going to cheat",
    "start": "2654560",
    "end": "2678115"
  },
  {
    "text": "because it's a little\ntricky to do it and get all the nodes in sorted order. ",
    "start": "2678115",
    "end": "2697980"
  },
  {
    "text": "So that should give it to us. And then the suffixes. Here is another color.",
    "start": "2697980",
    "end": "2704630"
  },
  {
    "text": "6, 5, 3, 1, 0, 4, 2.",
    "start": "2704630",
    "end": "2714809"
  },
  {
    "text": "Cool. This I claim is a\nsuffix tree of banana. You see the banana substring.",
    "start": "2714810",
    "end": "2720530"
  },
  {
    "text": "Than the next one is\na, n, a, n, a, $ sign. Then the next one is\nn, a, n, a, $ sign.",
    "start": "2720530",
    "end": "2727700"
  },
  {
    "text": "Then the next one\nis a, n, a, $ sign. Next one is n, a, $ sign.",
    "start": "2727700",
    "end": "2734380"
  },
  {
    "text": "Next one is a, $ sign. And then $ sign. So that's a nice,\nclean representation",
    "start": "2734380",
    "end": "2739917"
  },
  {
    "text": "of all the suffixes. And you can see that if\nyou wanted to search from the middle of this string--\nsuppose I want to search",
    "start": "2739917",
    "end": "2745250"
  },
  {
    "text": "for a nan-- then it's right there. Just do n, a, n, then I'm done.",
    "start": "2745250",
    "end": "2751700"
  },
  {
    "text": "This virtual node\nin the middle here along the one third of\nthe way down the edge,",
    "start": "2751700",
    "end": "2756980"
  },
  {
    "text": "that represents n-a-n. And indeed, if you look\nat the descendant leaf,",
    "start": "2756980",
    "end": "2762170"
  },
  {
    "text": "that corresponds to an\noccurrence of n-a-n. If I was going to\nlook for a-n, I",
    "start": "2762170",
    "end": "2768830"
  },
  {
    "text": "would do a, n, so\nhalfway down this edge. And then this subtree represents\nall the occurrences of a-n.",
    "start": "2768830",
    "end": "2777920"
  },
  {
    "text": "Think about it. There's two of them-- One that starts at position 3,\none that starts at position 1.",
    "start": "2777920",
    "end": "2785450"
  },
  {
    "text": "Here's one occurrence\nof a-n, here's another occurrence of a-n. This works even when\nthey're overlapping. If I search for a-n-a,\nI would get here.",
    "start": "2785450",
    "end": "2792716"
  },
  {
    "text": "And then these are the two\noccurrences of a-n-a and they actually overlap each other-- this one and this one.",
    "start": "2792717",
    "end": "2798764"
  },
  {
    "text": "So this is a great\ndata structure, it solves what we need.",
    "start": "2798764",
    "end": "2803940"
  },
  {
    "text": "It's all substrings searching. ",
    "start": "2803940",
    "end": "2821460"
  },
  {
    "text": "Applications of suffix trees. ",
    "start": "2821460",
    "end": "2838570"
  },
  {
    "text": "Just do a search in the trie\nfor a particular pattern. We get subtree representing all\nof the occurrences of P and T.",
    "start": "2838570",
    "end": "2862800"
  },
  {
    "text": "So this is great. In order P time, walking\ndown this structure, I can figure out\nall the occurrences.",
    "start": "2862800",
    "end": "2869819"
  },
  {
    "text": "And then, if I want to\nknow how many there were, I could just store\nsubtree sizes-- number of leaves\nbelow every node.",
    "start": "2869820",
    "end": "2875940"
  },
  {
    "text": "If I wanted to list\nthem, I could just do an in-order traversal. And I'll even get them in order.",
    "start": "2875940",
    "end": "2883230"
  },
  {
    "text": "So in particular, if I wanted to\nlist the first 10 occurrences,",
    "start": "2883230",
    "end": "2888900"
  },
  {
    "text": "I could store the left-most leaf\nfrom every node, teleport down to the first occurrence\nin constant time.",
    "start": "2888900",
    "end": "2894870"
  },
  {
    "text": "And then I could just have a\nlinked list of all the leaves. So once I find the\nfirst one, I can just follow until I find, oh,\nthat's not an occurrence of P.",
    "start": "2894870",
    "end": "2902880"
  },
  {
    "text": "So I can list the first\nk of them in order k time once I've done the\nsearch of order P time.",
    "start": "2902880",
    "end": "2908160"
  },
  {
    "text": "So this is really\ngood searching. And It's the ideal situation. You can list any information\nyou want about all",
    "start": "2908160",
    "end": "2914520"
  },
  {
    "text": "of the answers in the optimal\ntime and size of the output. ",
    "start": "2914520",
    "end": "2920670"
  },
  {
    "text": "How big is this data structure? Well, there are T suffixes,\nso k is the size of T.",
    "start": "2920670",
    "end": "2931007"
  },
  {
    "text": "And when we look at our\ntrie representations, our general goal was to get-- here, capital T was\nthe sum of the lengths.",
    "start": "2931008",
    "end": "2939817"
  },
  {
    "text": "Well, sum of the\nlengths is not good-- that would be quadratic-- sum of the lengths\nof the suffixes. But we also said, or the\nnumber of nodes in the trie.",
    "start": "2939817",
    "end": "2948420"
  },
  {
    "text": "And we know the number\nof leaves in this trie is exactly the size of T. And so\nbecause it's a compressed trie,",
    "start": "2948420",
    "end": "2955054"
  },
  {
    "text": "the number of\ninternal [INAUDIBLE] is also less than the size of\nT. So the total number of nodes here is order T And\nso if we use any",
    "start": "2955054",
    "end": "2964890"
  },
  {
    "text": "of the reasonable\nrepresentations, we get order T space. ",
    "start": "2964890",
    "end": "2973020"
  },
  {
    "text": "Now, there's one issue which\nis, how long does a search for P cost? And it depends on\nour representation,",
    "start": "2973020",
    "end": "2978630"
  },
  {
    "text": "it depends how quickly\nwe can traverse a node. If we use hashing-- method 3-- use hashing,\nthen we get order P time.",
    "start": "2978630",
    "end": "2991740"
  },
  {
    "text": " But the trouble with\nhashing is it permutes",
    "start": "2991740",
    "end": "2998100"
  },
  {
    "text": "the children of every node. So in that situation,\nthe leaves will not be ordered in the same way that\nthey're ordered in the string.",
    "start": "2998100",
    "end": "3005799"
  },
  {
    "text": "So if you really want to be\nable to find the first five occurrences of the pattern\nP, you can't use hashing.",
    "start": "3005799",
    "end": "3011060"
  },
  {
    "text": "You can find some\nfive occurrences but you will find the\nfirst in the usual ordering of the string.",
    "start": "3011060",
    "end": "3016770"
  },
  {
    "text": "So if you really\nwant the first five and you want them in order,\nthen you should use trays--",
    "start": "3016770",
    "end": "3023750"
  },
  {
    "text": "this method 6 that we used. 6? 5. If we use trays, then it will\nbe order P times log Sigma--",
    "start": "3023750",
    "end": "3035230"
  },
  {
    "text": " sorry, order P plus log Sigma.",
    "start": "3035230",
    "end": "3040640"
  },
  {
    "text": "That was our query time. Here, P plus log Sigma.",
    "start": "3040640",
    "end": "3047030"
  },
  {
    "text": "Small penalty to pay but the\nnice thing is then your answers are represented in order.",
    "start": "3047030",
    "end": "3052310"
  },
  {
    "text": "No permutation, no\nhashing, no randomization. This is the reason suffix\ntrees were invented--",
    "start": "3052310",
    "end": "3058940"
  },
  {
    "text": "they let you do searches fast. But actually, they let you\ndo a ton of things fast. And I want to quickly\ngive you an overview",
    "start": "3058940",
    "end": "3065930"
  },
  {
    "text": "of the zillions of things you\ncan do with the suffix tree. And then I want to get\nto how to build them in linear time, which has some\ninteresting algorithms/data",
    "start": "3065930",
    "end": "3076205"
  },
  {
    "text": "structures. I already talked\nabout if you want to find the first\nk occurrences, you",
    "start": "3076205",
    "end": "3081980"
  },
  {
    "text": "can do that in order k time. If you want to find the\nnumber of occurrences, you can do that\nin constant time, just by augmenting\nthe subtree sizes.",
    "start": "3081980",
    "end": "3089174"
  },
  {
    "text": "Here's another\nthing you could do. Suppose you have a\nvery long string. I mean think of T as\nan entire document.",
    "start": "3089174",
    "end": "3095160"
  },
  {
    "text": "You know, it could be the\nMerriam-Webster dictionary or it could be the web.",
    "start": "3095160",
    "end": "3101320"
  },
  {
    "text": "We're imagining T to be\nthe huge data structure. And then we're able to search\nfor substrings within that data",
    "start": "3101320",
    "end": "3106610"
  },
  {
    "text": "structure very fast. So that's cool.",
    "start": "3106610",
    "end": "3112430"
  },
  {
    "text": "Here's an interesting puzzle. What is the longest substring--\nwhat is the longest string that",
    "start": "3112430",
    "end": "3117790"
  },
  {
    "text": "appears twice on the web? This is called the longest\nrepeated substring. Could be overlapping, maybe not.",
    "start": "3117790",
    "end": "3124610"
  },
  {
    "text": "Well, you take the web, you\nthrow it in the suffix tree-- not sure anyone could\nactually do that-- but small part of the web.",
    "start": "3124610",
    "end": "3131762"
  },
  {
    "text": "Dictionary-- this\nwould be no problem. ",
    "start": "3131762",
    "end": "3137260"
  },
  {
    "text": "Wikipedia would be feasible. You take Wikipedia, you\nthrow it in the suffix tree. And what I'm interested\nin is, basically,",
    "start": "3137260",
    "end": "3144820"
  },
  {
    "text": "a node that has two, at\nleast two descendant leaves. And if I'm counting the number\nof leaves at every node,",
    "start": "3144820",
    "end": "3151749"
  },
  {
    "text": "I could just do one pass\nover this data structure and find what are all\nthe nodes that have at least two descendant leaves.",
    "start": "3151749",
    "end": "3156820"
  },
  {
    "text": "That's all the internal nodes. And then among them I'd also\nlike to know how deep is it.",
    "start": "3156820",
    "end": "3162280"
  },
  {
    "text": "Because the depth corresponds\nto how long the string is. This one is a-n-a\nso this one has,",
    "start": "3162280",
    "end": "3168280"
  },
  {
    "text": "I call it, a letter depth of 3. This one has a\nletter depth of 1. This one has a\nletter depth of 2.",
    "start": "3168280",
    "end": "3173785"
  },
  {
    "text": "So I just want to find\nthe deepest node that has at least two descendant leaves. In linear time, I could find\nthe longest repeated substring.",
    "start": "3173785",
    "end": "3180151"
  },
  {
    "text": "Or I could find the\nlongest substring that appears five times or whatever. I just do one pass\nover this thing,",
    "start": "3180151",
    "end": "3185530"
  },
  {
    "text": "find the deepest node that\nhas my threshold of leaves. So that's kind of a\nneat thing you can do in linear time on a string.",
    "start": "3185530",
    "end": "3191440"
  },
  {
    "text": " Here's another fun one.",
    "start": "3191440",
    "end": "3196580"
  },
  {
    "text": "Suppose I have\nthis giant string. And I just want to compare\ntwo substrings in it.",
    "start": "3196580",
    "end": "3201930"
  },
  {
    "text": "So here's my giant string. And suppose I want to measure\nhow long is the repeated",
    "start": "3201930",
    "end": "3209359"
  },
  {
    "text": "substring. So I say, well,\nI've got position i, I've got position j. Let's say I already know that\nthey match for a little bit.",
    "start": "3209360",
    "end": "3215360"
  },
  {
    "text": "I want to know, how\nlong do they match? How far can I go to the right\nand have them still match?",
    "start": "3215360",
    "end": "3220790"
  },
  {
    "text": " How could I do that? Well, I could look at\nthe suffix starting at i.",
    "start": "3220790",
    "end": "3226580"
  },
  {
    "text": "That corresponds to\na leaf over here. And I could look at the\nsuffix starting at j. That corresponds\nto some other leaf.",
    "start": "3226580",
    "end": "3235099"
  },
  {
    "text": "And what is the length of\nthe longest common prefix of those two suffixes\nin the suffix tree?",
    "start": "3235100",
    "end": "3242560"
  },
  {
    "text": " Three letters-- LCA.",
    "start": "3242560",
    "end": "3252150"
  },
  {
    "text": "If I take the LCA of those\ntwo leaves-- for example, I take these two leaves--",
    "start": "3252150",
    "end": "3259270"
  },
  {
    "text": "the LCA gives me the\nlongest common prefix. Then they branch. So longest common prefix\nof these two suffixes",
    "start": "3259270",
    "end": "3265780"
  },
  {
    "text": "is the letter a, so\nit's just length 1. And again, if I label every\nnode with the letter depth,",
    "start": "3265780",
    "end": "3271030"
  },
  {
    "text": "I can figure out exactly\nhow long these guys match, even if they overlap. So in constant time--\nbecause we already",
    "start": "3271030",
    "end": "3277150"
  },
  {
    "text": "have a constant time LCA query. Linear space,\nconstant time query. Given any two\npositions i and j, I",
    "start": "3277150",
    "end": "3283031"
  },
  {
    "text": "can tell you how long they\nmatch for in constant time. Boom-- instantaneously. It's kind of crazy.",
    "start": "3283031",
    "end": "3288340"
  },
  {
    "text": "So you can do tons of\nthese queries instantly. That's one reason why\npeople care about LCAs,",
    "start": "3288340",
    "end": "3293770"
  },
  {
    "text": "there are other reasons. But mostly LCAs were\ndeveloped for suffix trees to answer queries like that.",
    "start": "3293770",
    "end": "3299799"
  },
  {
    "text": " Got some more. ",
    "start": "3299800",
    "end": "3308940"
  },
  {
    "text": "Why don't I just write-- LCP of one suffix\nand another suffix",
    "start": "3308940",
    "end": "3319620"
  },
  {
    "text": "is equivalent to an LCA query. And so we can do\nthat in constant time",
    "start": "3319620",
    "end": "3325050"
  },
  {
    "text": "after pre-processing. ",
    "start": "3325050",
    "end": "3338599"
  },
  {
    "text": "Here's another one. Suppose I want to find all\noccurrences of T i to j.",
    "start": "3338600",
    "end": "3352180"
  },
  {
    "text": " So I give you a\nsubstring and I want",
    "start": "3352180",
    "end": "3357670"
  },
  {
    "text": "to know where does that occur. The substring is restricted\nto come from the text.",
    "start": "3357670",
    "end": "3363800"
  },
  {
    "text": "Now, this is a little subtle. Of course, I could solve it\nin j minus i plus 1 time.",
    "start": "3363800",
    "end": "3368860"
  },
  {
    "text": "I just do the search. But what if I want to\ndo it in constant time?",
    "start": "3368860",
    "end": "3374470"
  },
  {
    "text": "Maybe this is a\nreally big substring. But I still know it\nappears multiple times. I want to know how many\ntimes does it appear.",
    "start": "3374470",
    "end": "3381119"
  },
  {
    "text": "I claim I can do this\nin constant time. How?",
    "start": "3381120",
    "end": "3386320"
  },
  {
    "text": "This is a level ancestor query. Why is it a level\nancestor query?",
    "start": "3386320",
    "end": "3392050"
  },
  {
    "text": "If I look at the\nsuffix starting at i, and then I just want to\ntrim off, I want to stop.",
    "start": "3392050",
    "end": "3398470"
  },
  {
    "text": "Or I don't care about\nthe entire suffix, I just want to do that j. It's like saying, well,\nsuppose I'm looking",
    "start": "3398470",
    "end": "3405580"
  },
  {
    "text": "for occurrences of a-n-a. So I go and I start at the\nfirst occurrence of a-n-a,",
    "start": "3405580",
    "end": "3411520"
  },
  {
    "text": "which is a-n-a-n-a-$, so this\nis the leaf corresponding to a-n-a. And then if I want to find\nall occurrences of a-n-a,",
    "start": "3411520",
    "end": "3418140"
  },
  {
    "text": "I just need to go up to the\nancestor that represents a-n-a.",
    "start": "3418140",
    "end": "3423910"
  },
  {
    "text": "This is what I call a\nweighted level ancestor.",
    "start": "3423910",
    "end": "3429786"
  },
  {
    "text": "That's not quite the\nproblem we solved in the last lecture, lecture\n15, because now it's weighted.",
    "start": "3429787",
    "end": "3438490"
  },
  {
    "text": "So it's level ancestor j minus\ni of the T i suffix leaf.",
    "start": "3438490",
    "end": "3448577"
  },
  {
    "text": "So I find this leaf,\nwhich I just have an array of all the leaves. Given a suffix, tell me what\nleaf it is in the suffix tree.",
    "start": "3448577",
    "end": "3454737"
  },
  {
    "text": "And then I want to find\nthe j minus i-th ancestor, except the edges don't\njust have unit length.",
    "start": "3454737",
    "end": "3459820"
  },
  {
    "text": "So here I want to find\nthe third ancestor, except it's really the ancestor\nin the compressed trie.",
    "start": "3459820",
    "end": "3465190"
  },
  {
    "text": "I want to do the j\nminus i-th ancestor in the suffix in\nthe trie, but what I have is a compressed tree.",
    "start": "3465190",
    "end": "3471849"
  },
  {
    "text": "And so these edges are labeled\nwith how many characters are on them and I got\nto deal with that.",
    "start": "3471850",
    "end": "3478000"
  },
  {
    "text": "Fortunately, the data structure\nwe gave for a level ancestor-- which was constant time\nquery, linear space--",
    "start": "3478000",
    "end": "3483040"
  },
  {
    "text": "can be fairly easily\nadapted to weights. ",
    "start": "3483040",
    "end": "3488170"
  },
  {
    "text": "Not quite in\nconstant time though. It can be solved\nin log log n time.",
    "start": "3488170",
    "end": "3494859"
  },
  {
    "text": "And I think that's optimal. Because if your thing is\na single path with maybe",
    "start": "3494860",
    "end": "3503710"
  },
  {
    "text": "the occasional branch, then\nfinding your i-th ancestor here",
    "start": "3503710",
    "end": "3508720"
  },
  {
    "text": "is like solving a\npredecessor problem. Because you say, well,\nfrom the i-th position up,",
    "start": "3508720",
    "end": "3516190"
  },
  {
    "text": "I want to know what\nis the previous-- I want to round\nup or round down.",
    "start": "3516190",
    "end": "3521887"
  },
  {
    "text": "So I want to do a\npredecessor or a successor on this straight line. And so for a\npredecessor you need",
    "start": "3521887",
    "end": "3527200"
  },
  {
    "text": "log log time for\nthe right parameters and this can be achieved.",
    "start": "3527200",
    "end": "3533206"
  },
  {
    "text": "And the basic idea is you\nuse ladder decomposition, just like before. But now a ladder can't be\nrepresented by an array",
    "start": "3533206",
    "end": "3538839"
  },
  {
    "text": "because there are lots of\nabsent places in the array. Now instead, use a predecessor,\nuse a Van Emde Boas",
    "start": "3538840",
    "end": "3544540"
  },
  {
    "text": "to represent a ladder. So that's basically all you do. Van Emde Boas\nrepresents a ladder.",
    "start": "3544540",
    "end": "3553630"
  },
  {
    "text": "That's what you do\nin the top structure. Remember, we had\nindirection, leaf trimming, top was this thing,\nladder decomposition.",
    "start": "3553630",
    "end": "3559058"
  },
  {
    "text": "You Bottom was look up tables. The other problem is you can't\nuse lookup tables anymore because in one of\nthese tiny trees",
    "start": "3559058",
    "end": "3566529"
  },
  {
    "text": "you could have a\nsuper long path. It's non-branching,\nthey got compressed. And you can't\nafford to enumerate all possible situations.",
    "start": "3566530",
    "end": "3573410"
  },
  {
    "text": "It's kind of annoying. So instead of using lookup\ntables-- this was actually an idea from some students\nin this class last time",
    "start": "3573410",
    "end": "3580960"
  },
  {
    "text": "I taught this material--\nthey said, oh, well, instead of using a lookup table, you\ncan use ladder decomposition.",
    "start": "3580960",
    "end": "3587180"
  },
  {
    "text": "So down here, in\nthe compressed tree, we have log n different nodes.",
    "start": "3587180",
    "end": "3592240"
  },
  {
    "text": "If you use ladder decomposition\non that thing-- but not the hybrid structure. Remember, we used jump\npointers plus ladders.",
    "start": "3592240",
    "end": "3598360"
  },
  {
    "text": "Jump pointers still\nwork here, just you have to round them\nto a different place. Down here, I'm not\ngoing to try to do",
    "start": "3598360",
    "end": "3604750"
  },
  {
    "text": "jump pointers plus ladders. I'll just do ladders. And remember, just ladders\ngave us a log n query time.",
    "start": "3604750",
    "end": "3610119"
  },
  {
    "text": "But now n is log T. And so\nwe get log log T query time.",
    "start": "3610120",
    "end": "3618300"
  },
  {
    "text": "And that's, basically,\nall you have to do.  So you're always jumping\nto the top of a ladder.",
    "start": "3618300",
    "end": "3624960"
  },
  {
    "text": "You'll only have to\ntraverse log log T ladders. The very last ladder\nyou might have to do a predecessor query that\nwill cost you log log log T.",
    "start": "3624960",
    "end": "3632500"
  },
  {
    "text": "But overall, it will\nbe log log T time just by this kind of tweak to our\nlevel ancestor data structure.",
    "start": "3632500",
    "end": "3639730"
  },
  {
    "text": "So I thought that was\nkind of a fun connection. This is the reason, essentially,\nlevel ancestors were developed.",
    "start": "3639730",
    "end": "3646450"
  },
  {
    "text": "And people use them\nbecause you can do these kinds of things\nin nearly constant time,",
    "start": "3646450",
    "end": "3651800"
  },
  {
    "text": "even if the substring is huge. So maybe I know ahead\nof time all the queries",
    "start": "3651800",
    "end": "3657760"
  },
  {
    "text": "I might want to do. I just throw them into the\ntext, just add them in there.",
    "start": "3657760",
    "end": "3663310"
  },
  {
    "text": "Then I've cut these\nsubstrings, they're now represented in the suffix tree. Now any substring I want\nto query in log log n time,",
    "start": "3663310",
    "end": "3670480"
  },
  {
    "text": "I can find all the\noccurrences of that string, even if the substring is huge.",
    "start": "3670480",
    "end": "3676670"
  },
  {
    "text": "So if you know what\nqueries you want, you can preprocess\nthem and solve them even faster than order P time.",
    "start": "3676670",
    "end": "3684430"
  },
  {
    "text": "Cool. Another thing you can do is\nrepresent multiple documents.",
    "start": "3684430",
    "end": "3692480"
  },
  {
    "text": "And that's what I was\nsort of getting at there. If you have multiple\ndocuments-- say, you're storing the\nentire web or Wikipedia.",
    "start": "3692480",
    "end": "3699670"
  },
  {
    "text": "Like there's multiple pages. You want to separate them. All you need to do is say,\nOK, I'll take my first string",
    "start": "3699670",
    "end": "3707859"
  },
  {
    "text": "and then put a special\n$ sign after it. Then take my second string,\nput a special $ sign after it.",
    "start": "3707860",
    "end": "3712980"
  },
  {
    "text": "And take my k-th string and\nput a special $ sign after it. Just concatenate them with\ndifferent $ signs in between",
    "start": "3712980",
    "end": "3719710"
  },
  {
    "text": "them. Then build the suffix tree on\nthis thing which I'll call T So you can use the same\nsuffix tree data structure,",
    "start": "3719710",
    "end": "3726010"
  },
  {
    "text": "but now, in some sense,\nyou're representing all of these documents and\nall the ways they interweave.",
    "start": "3726010",
    "end": "3731963"
  },
  {
    "text": "Because there are\nsome shared substrings here that are shared by\nthis, and this, and whatever. And those will be represented\nin the same structure.",
    "start": "3731964",
    "end": "3738069"
  },
  {
    "text": "Or I can do a search and\nthen I've effectively found all the documents\nthat contain it.",
    "start": "3738070",
    "end": "3743500"
  },
  {
    "text": "One issue, though. Suppose, I want to find all\nthe documents containing the word MIT or something.",
    "start": "3743500",
    "end": "3751390"
  },
  {
    "text": "Maybe all k of them match,\nmaybe one document matches, maybe two documents match. Suppose, two documents match.",
    "start": "3751390",
    "end": "3757930"
  },
  {
    "text": "The first document mentions\nMIT a billion times. The second document\nhas MIT in it once.",
    "start": "3757930",
    "end": "3766330"
  },
  {
    "text": "Then suffix trees\nare kind of annoying because they will find that\nbillion and one matches as a subtree.",
    "start": "3766330",
    "end": "3771907"
  },
  {
    "text": "But if I just want to know the\nanswer, oh, these two documents match, I'd like to do\nthat in order 2 time,",
    "start": "3771907",
    "end": "3777070"
  },
  {
    "text": "not order billion time,\nto use technical terms.",
    "start": "3777070",
    "end": "3782230"
  },
  {
    "text": "And that is called the document\nretrieval problem or a document",
    "start": "3782230",
    "end": "3788080"
  },
  {
    "text": "retrieval data structure. This is a problem considered\nby M. Krishnan in 2002.",
    "start": "3788080",
    "end": "3794320"
  },
  {
    "text": "Document retrieval you can\ndo an order P plus number",
    "start": "3794320",
    "end": "3802510"
  },
  {
    "text": "of documents matching. So if I want to list all\nthe documents that match,",
    "start": "3802510",
    "end": "3810449"
  },
  {
    "text": "I could do an order the number\nof documents that match, not the order of a number of\noccurrences of the string.",
    "start": "3810449",
    "end": "3817270"
  },
  {
    "text": "So I still got to do the\nP search in the beginning, and then this is better. And the funny thing is the\nsolution to this data structure",
    "start": "3817270",
    "end": "3825339"
  },
  {
    "text": "uses RMQ, range minimum\nqueries, from last lecture. So let me tell you how it works.",
    "start": "3825340",
    "end": "3831050"
  },
  {
    "text": "It's actually very simple. ",
    "start": "3831050",
    "end": "3836730"
  },
  {
    "text": "And then I think we'll move on\nto how to build a suffix tree. So document retrieval.",
    "start": "3836730",
    "end": "3843500"
  },
  {
    "text": " Here's what we're going to do.",
    "start": "3843500",
    "end": "3849470"
  },
  {
    "start": "3849470",
    "end": "3865040"
  },
  {
    "text": "Remember, these different $\nsigns i represent different documents.",
    "start": "3865040",
    "end": "3870230"
  },
  {
    "text": "I want to remember\nwhich suffixes came from the same document. So at every $ sign i, I\nwant to store the number",
    "start": "3870230",
    "end": "3880790"
  },
  {
    "text": "of the previous $ sign i. Let's suppose, the suffixes,\nwhen they get to one of the $",
    "start": "3880790",
    "end": "3888260"
  },
  {
    "text": "signs, I can just stop, I\ndon't have to store the rest, I'm going to throw away. Whenever I hit a $ sign, I\nwill stop the suffix tree.",
    "start": "3888260",
    "end": "3895490"
  },
  {
    "text": "That way, the $ signs\nreally are leaves, all of them now become leaves. So I don't really care\nabout a suffix that",
    "start": "3895490",
    "end": "3901490"
  },
  {
    "text": "goes all the way through here. I just want the\nsuffix to the $ sign, as it represents the\nindividual documents.",
    "start": "3901490",
    "end": "3906960"
  },
  {
    "text": "So $ sign i's are leaves. And I want each of them just\nto store a pointer, basically, to the previous one of the\nsame type, the same $ sign i.",
    "start": "3906960",
    "end": "3914930"
  },
  {
    "text": "It came from the same document. ",
    "start": "3914930",
    "end": "3922860"
  },
  {
    "text": "Now, here's the idea. I did a search, I\ngot down to a node,",
    "start": "3922860",
    "end": "3930470"
  },
  {
    "text": "and now there's this\nbig subtree here. And this subtree has a\nbunch of leaves in it,",
    "start": "3930470",
    "end": "3936400"
  },
  {
    "text": "those represent all the\noccurrences of the pattern P. And let's suppose that\nthose leaves are numbered.",
    "start": "3936400",
    "end": "3943119"
  },
  {
    "text": "I'm numbering the leaves\nfrom 1 to n, I guess.",
    "start": "3943120",
    "end": "3948620"
  },
  {
    "text": "Then in here, the leaves\nwill be an interval-- interval l, comma, n.",
    "start": "3948620",
    "end": "3954710"
  },
  {
    "text": "And the trouble is a lot of\nthese have the same label $ sign i. And I just want to\nfind the unique ones.",
    "start": "3954710",
    "end": "3961369"
  },
  {
    "text": "How do I do that? ",
    "start": "3961370",
    "end": "3967760"
  },
  {
    "text": "What we do is find the first\noccurrence of $ sign i for each",
    "start": "3967760",
    "end": "3975560"
  },
  {
    "text": "i. I could just find the first\noccurrence of $ sign i for each i. I'd then only have to pay order\nnumber of distinct documents,",
    "start": "3975560",
    "end": "3984370"
  },
  {
    "text": "then we'll have to pay for\nevery match within the document. Now, one way to define\nthe first $ sign i is--",
    "start": "3984370",
    "end": "3990859"
  },
  {
    "text": "that's a $ sign i\nwhose stored value-- we said we store the leaf number\nof the previous $ sign i--",
    "start": "3990860",
    "end": "3998619"
  },
  {
    "text": "whose stored value\nis less than l.",
    "start": "3998620",
    "end": "4005301"
  },
  {
    "text": "So we find some position here. If the previous\nguy is less than l, that means it was the\nfirst of that type.",
    "start": "4005301",
    "end": "4011950"
  },
  {
    "text": "If we store this, that's\ndefinition of being first. So in this interval, I want to\nfind $ sign i's that have very",
    "start": "4011950",
    "end": "4021610"
  },
  {
    "text": "small stored values. How would I find\nthe very best one? Range minimum query.",
    "start": "4021610",
    "end": "4027430"
  },
  {
    "text": "So we do a range minimum\nquery on l, comma, n.",
    "start": "4027430",
    "end": "4032559"
  },
  {
    "text": "If there's any firsts in\nthere, this will find it. ",
    "start": "4032560",
    "end": "4038579"
  },
  {
    "text": "Find, let's say, a position\nm with the smallest",
    "start": "4038580",
    "end": "4044470"
  },
  {
    "text": "possible stored value. ",
    "start": "4044470",
    "end": "4057430"
  },
  {
    "text": "If the stored number\nis less than l,",
    "start": "4057430",
    "end": "4063079"
  },
  {
    "text": "then output that answer. ",
    "start": "4063080",
    "end": "4068480"
  },
  {
    "text": "And then recurse on the\nremaining intervals.",
    "start": "4068480",
    "end": "4073890"
  },
  {
    "text": "So there's going to be from l\nto m minus 1 and m plus 1 to n.",
    "start": "4073890",
    "end": "4081859"
  },
  {
    "text": "So we find the best\ncandidate, the minimum. That's minimum sorted value. If anything is going to be\nless than l, that would be it.",
    "start": "4081860",
    "end": "4089210"
  },
  {
    "text": "If it is less than l, we output\nit, then we recurse over here and we recurse over here. At some point this will\nstop finding things.",
    "start": "4089210",
    "end": "4095750"
  },
  {
    "text": "We're going to do\nanother RMQ over here. Might not find anything, then\nwe just stop that recursion.",
    "start": "4095750",
    "end": "4101189"
  },
  {
    "text": "But the number of\nrecursions we have to do is going to be equal to\nthe number of documents that match, maybe plus 1.",
    "start": "4101189",
    "end": "4107810"
  },
  {
    "text": "So we achieved this bound\nusing RMQ because RMQ we can do in constant time with\nappropriate pre-processing.",
    "start": "4107810",
    "end": "4113689"
  },
  {
    "text": "Now, the RMQ is over an array. It's over this array of stored\nvalues indexed by leaves.",
    "start": "4113689",
    "end": "4120589"
  },
  {
    "text": "And this idea of\ntaking the leaves and writing them down in order\nis actually something we need.",
    "start": "4120590",
    "end": "4126290"
  },
  {
    "text": "It's called a suffix array. ",
    "start": "4126290",
    "end": "4136970"
  },
  {
    "text": "We're going to use this\nalternate representation of suffix trees in\norder to compute them.",
    "start": "4136970",
    "end": "4142639"
  },
  {
    "text": "Suffix arrays in some sense\nare easier to think about. ",
    "start": "4142640",
    "end": "4156410"
  },
  {
    "text": "The idea with the\nsuffix array is to write down all the\nsuffixes, sort them.",
    "start": "4156410",
    "end": "4161540"
  },
  {
    "text": " This is conceptual.",
    "start": "4161540",
    "end": "4167089"
  },
  {
    "text": "Imagine you take\nall these suffixes. Their total size\nis quadratic in T so you'd never actually\nwant to do this.",
    "start": "4167090",
    "end": "4172142"
  },
  {
    "text": "But just imagine\nwriting them down, sorting them lexically using\nour string sorting algorithms.",
    "start": "4172142",
    "end": "4177560"
  },
  {
    "text": "And then we can't\nrepresent them explicitly because it would be too big. Just write down their index,\njust store the indices.",
    "start": "4177560",
    "end": "4188254"
  },
  {
    "text": " Let's do this for banana. ",
    "start": "4188254",
    "end": "4195350"
  },
  {
    "text": "Banana's over here. It'll make my life\na little harder. ",
    "start": "4195350",
    "end": "4217090"
  },
  {
    "text": "Actually, they're already\nhere in sorted order. If dollar sign, I'm supposing,\nis first, first suffix is $,",
    "start": "4217090",
    "end": "4223720"
  },
  {
    "text": "then a-$, then a-n-a-$, then\na-n-a-n-a-$, then banana, then n-a-$, then n-a-n-a-$.",
    "start": "4223720",
    "end": "4231880"
  },
  {
    "text": "I'll just write\nthat down over here. $, a-$, a-n-a-$, a-n-a-n-a-$,\nthen banana, then n-a-$,",
    "start": "4231880",
    "end": "4256580"
  },
  {
    "text": "then n-a-n-a-$. If you look at these, they're\nindeed in sorted order-- $,",
    "start": "4256580",
    "end": "4262219"
  },
  {
    "text": "a's, b's, n's. Everything is sorted\nhere lexically. Now, I can't store this\nbecause it's quadratic size.",
    "start": "4262220",
    "end": "4269160"
  },
  {
    "text": "Instead, I just write down the\nnumbers that are down there. This was the sixth suffix, it\nwas starting at position 6.",
    "start": "4269160",
    "end": "4274620"
  },
  {
    "text": "Then 5, then 3, then 1, then 0--",
    "start": "4274620",
    "end": "4281370"
  },
  {
    "text": "that's everything--\nthen 4, then 2.",
    "start": "4281370",
    "end": "4287010"
  },
  {
    "text": "This thing is the suffix array. It also has linear size.",
    "start": "4287010",
    "end": "4293550"
  },
  {
    "text": "It's just a permutation on the\nsuffix labels, suffix indices. ",
    "start": "4293550",
    "end": "4306114"
  },
  {
    "text": "I still want to\ntell you about it. There's some other\ninformation that's helpful to write down\nabout the suffix array.",
    "start": "4306115",
    "end": "4315630"
  },
  {
    "text": "It's called longest common\nprefix information, LCP. The idea is to look at adjacent\nelements in the suffix array.",
    "start": "4315630",
    "end": "4323580"
  },
  {
    "text": "In some sense, this represents\nthe same information, right? Our whole goal is to\nsort the suffixes. If we could do this,\nthen, as we'll see,",
    "start": "4323580",
    "end": "4332199"
  },
  {
    "text": "we can also build this. And this is sort of\nwhat we really want. The suffix array by\nitself is pretty good if you add in LCP information.",
    "start": "4332200",
    "end": "4339130"
  },
  {
    "text": "LCP is-- what is the longest\ncommon prefix of these two suffixes? In this case, 0. In this case, one letter.",
    "start": "4339130",
    "end": "4346090"
  },
  {
    "text": "In this case, three\nletters match. So here the value is 3.",
    "start": "4346090",
    "end": "4353440"
  },
  {
    "text": "And the next one,\nzero letters match. Next one, zero letters match.",
    "start": "4353440",
    "end": "4359659"
  },
  {
    "text": "Next one, two letters match.",
    "start": "4359660",
    "end": "4365380"
  },
  {
    "text": "So this is another array\nyou could store here-- 0, 1, 3, 0, 0, 2. AUDIENCE: Longest common prefix?",
    "start": "4365380",
    "end": "4371980"
  },
  {
    "text": "ERIK DEMAINE: Longest common\nprefix of the suffixes. Because each of these\nis a suffix but here",
    "start": "4371980",
    "end": "4378200"
  },
  {
    "text": "we're interested in how\nlong they match for. I claim if you have this suffix\narray and this LCP information,",
    "start": "4378200",
    "end": "4385360"
  },
  {
    "text": "you can build this structure. Anyone wants to tell me how\nto build this using this?",
    "start": "4385360",
    "end": "4392679"
  },
  {
    "text": "It's a one word or two word\nanswer that we saw, I think,",
    "start": "4392680",
    "end": "4397930"
  },
  {
    "text": "last class. But we saw a lot of things\nlast class, so it's maybe not obvious. ",
    "start": "4397930",
    "end": "4410530"
  },
  {
    "text": "Magic words are Cartesian tree. ",
    "start": "4410530",
    "end": "4415570"
  },
  {
    "text": "Cartesian tree was how we\nconverted RMQ into LCA,",
    "start": "4415570",
    "end": "4421969"
  },
  {
    "text": "I think. Yeah? Which was you take the\nminimum value in the array, make that the root, and then\nrecurse on the two sides.",
    "start": "4421970",
    "end": "4430480"
  },
  {
    "text": "So a Cartesian tree\nof the LCP array, basically, gives you\nthis transformation.",
    "start": "4430480",
    "end": "4437800"
  },
  {
    "text": "The minimum values\nhere are the 0's. Now, before we just broke\nties, we picked an arbitrary 0,",
    "start": "4437800",
    "end": "4442990"
  },
  {
    "text": "put it at the root. Now I want to take all the\n0's, put them at the root. If I do that, I get\nthree 0's at the root",
    "start": "4442990",
    "end": "4453130"
  },
  {
    "text": "and then I have\neverything in between. So there's nothing\nleft of the first 0.",
    "start": "4453130",
    "end": "4459429"
  },
  {
    "text": "Then next one,\nthere's these guys and the mins are going\nto be 1 and then 3. So here I'm going to get a\n1 when I recurse and then 3.",
    "start": "4459430",
    "end": "4467800"
  },
  {
    "start": "4467800",
    "end": "4474909"
  },
  {
    "text": "There's nothing in\nbetween these 0's. And after the last\n0, there's a 2. So this would be the Cartesian\ntree, a slightly different",
    "start": "4474910",
    "end": "4481840"
  },
  {
    "text": "version where we\ndon't break ties, we take all the\nmins simultaneously, put them at the root.",
    "start": "4481840",
    "end": "4487670"
  },
  {
    "text": "Now, does that look\nlike this thing? Yeah. Everything except the leaves. [INAUDIBLE] are\nmissing at the leaves.",
    "start": "4487670",
    "end": "4493960"
  },
  {
    "text": "The leaves are represented\nby these values. Just visit them in order\nhere, do an inner traversal",
    "start": "4493960",
    "end": "4500410"
  },
  {
    "text": "of the missing pointers here. We're going to get 6, and\nthen 5, and then 3 and then 1,",
    "start": "4500410",
    "end": "4512260"
  },
  {
    "text": "and then 0, and\nthen 4, and then 2.",
    "start": "4512260",
    "end": "4519609"
  },
  {
    "text": "Now, the meaning of these\nvalues is slightly different. Maybe I should\ncircle them in red.",
    "start": "4519609",
    "end": "4524739"
  },
  {
    "text": "These leaves are just\nlike these leaves. They're exactly the labels we\nwrote down in the same order.",
    "start": "4524740",
    "end": "4530388"
  },
  {
    "text": "These numbers are\nslightly different. What they represent\nare letter depths. The letter depth of this node\nis 0, letter depth of this node",
    "start": "4530389",
    "end": "4536110"
  },
  {
    "text": "is 1, letter depth\nof this node is 3. That's what I wrote here-- 1, 3, 2. This one says, 2.",
    "start": "4536110",
    "end": "4542240"
  },
  {
    "text": "These LCPs are exactly\nthe letter depth. That's how far down\nthe tree you are. Once you have this structure\nand the letter depth,",
    "start": "4542240",
    "end": "4548050"
  },
  {
    "text": "you can very easily\nput in these labels. I won't say how to do that. But in linear time,\nif I could build",
    "start": "4548050",
    "end": "4553210"
  },
  {
    "text": "the suffix array plus the LCPs,\nI could build suffix tree.",
    "start": "4553210",
    "end": "4559030"
  },
  {
    "text": "So our real goal is to build\nthis information, these two arrays. If we could do it\nin linear time,",
    "start": "4559030",
    "end": "4564300"
  },
  {
    "text": "we'd get a suffix\ntree in linear time. So that is what\nremains to be done.",
    "start": "4564300",
    "end": "4570100"
  },
  {
    "start": "4570100",
    "end": "4577379"
  },
  {
    "text": "We're going to do-- ",
    "start": "4577379",
    "end": "4584565"
  },
  {
    "text": "not quite linear time. If you want a\nnicely sorted suffix",
    "start": "4584565",
    "end": "4590620"
  },
  {
    "text": "tree where all the\nchildren are labeled here-- so in particular, if I\njust had a single node,",
    "start": "4590620",
    "end": "4596020"
  },
  {
    "text": "I have to be able to sort\nthe letters in the alphabet. However long that takes.",
    "start": "4596020",
    "end": "4601090"
  },
  {
    "text": "Maybe it's a small\nalphabet and you can do linear time sorting\nby radix sort or whatever. However long that\ntakes, we do it once.",
    "start": "4601090",
    "end": "4607260"
  },
  {
    "text": "Then the rest will\nbe order T time. Here's how we do it. First step-- sort the alphabet.",
    "start": "4607260",
    "end": "4614217"
  },
  {
    "text": "This will turn out to be\nmore interesting than you might think. I'll come back to it. Second step--\nreplace each letter",
    "start": "4614217",
    "end": "4621250"
  },
  {
    "text": "by its index in\nthe sorted order. This sounds boring but it\nwill be useful for later.",
    "start": "4621250",
    "end": "4627130"
  },
  {
    "start": "4627130",
    "end": "4635710"
  },
  {
    "text": "Third step-- the big idea. This is an algorithm by\nKarkkainen and Sanders,",
    "start": "4635710",
    "end": "4643179"
  },
  {
    "text": "from 2003. The problem was first\nsolved in this running time by Martin Farach-Colton,\nour good friend.",
    "start": "4643180",
    "end": "4651640"
  },
  {
    "text": "But then it got simplified. So I'll tell you a little\nbit about that in a moment. ",
    "start": "4651640",
    "end": "4658750"
  },
  {
    "text": "And there going to be\na lot of writing here. ",
    "start": "4658750",
    "end": "4672880"
  },
  {
    "text": "The idea here is we're going\nto take the 3i-th letter, 3i plus first, 3i\nplus second letter, concatenate them into a\nsingle triple letter--",
    "start": "4672880",
    "end": "4680020"
  },
  {
    "text": "think of it as a single letter. And then just do that for all i. So it's like I take\nthese guys, make them",
    "start": "4680020",
    "end": "4685110"
  },
  {
    "text": "one letter, these guys,\nmake them one letter. Now, I could start at 0,\nor I could start at 1, or I could start at 2.",
    "start": "4685110",
    "end": "4692230"
  },
  {
    "text": "Do them all. So this is going to be 3i\nplus 1, 3i plus 2, 3i plus 3.",
    "start": "4692230",
    "end": "4702909"
  },
  {
    "text": "And this one is going to be 3i\nplus 2, 3i plus 3, 3i plus 4.",
    "start": "4702910",
    "end": "4712390"
  },
  {
    "text": "We're going to do\nthis to recurse. But the point is, if\nI want to represent all the suffixes\nof T, suffix could",
    "start": "4712390",
    "end": "4718750"
  },
  {
    "text": "start at a position 0 mod\n3, or position 1 mod 3, or position 2 mod 3.",
    "start": "4718750",
    "end": "4723800"
  },
  {
    "text": "So if I could sort all the\nsuffixes of these guys, I would effectively sort all\nthe suffixes of the original T.",
    "start": "4723800",
    "end": "4729120"
  },
  {
    "text": "This tripling up doesn't\nreally change things, up to like plus 1 or 2. ",
    "start": "4729120",
    "end": "4743500"
  },
  {
    "text": "Next, I believe, is recursion. ",
    "start": "4743500",
    "end": "4753726"
  },
  {
    "text": "I'm going to take T0 and\nT1 and concatenate them. This thing has size 2/3 n.",
    "start": "4753726",
    "end": "4761320"
  },
  {
    "text": "It has number of characters\n2/3 n because each of them has a third of the\nnumber of characters.",
    "start": "4761320",
    "end": "4766420"
  },
  {
    "text": "Of course, all the\ninformation is still there, which is kind of weird. But if we treat this as\na single character, which",
    "start": "4766420",
    "end": "4771680"
  },
  {
    "text": "then has a 1/3 n, we can't\nafford to recurse on all three. We can only afford to recurse\non two out of the three",
    "start": "4771680",
    "end": "4777850"
  },
  {
    "text": "because then we're going to get\na recurrence of the form T of n is T of 2/3 n plus order n.",
    "start": "4777850",
    "end": "4786370"
  },
  {
    "text": "And this is geometric,\nso it's order n. That's how we're going\nto get linear time after the first sort.",
    "start": "4786370",
    "end": "4793630"
  },
  {
    "text": "If this was 3/3 n, then\nthis would be n log n. We don't want to do that. So that's what I can afford.",
    "start": "4793630",
    "end": "4799832"
  },
  {
    "text": "Now I've got to deal with it. What this tells me is,\nthe sorted order of all the suffixes of T0 and\nT1, all the suffixes",
    "start": "4799832",
    "end": "4805420"
  },
  {
    "text": "starting at positions\nthat are 0 or 1 mod 3. ",
    "start": "4805420",
    "end": "4812139"
  },
  {
    "text": "Next thing we'd like to do\nis sort the suffixes of T2.",
    "start": "4812140",
    "end": "4817840"
  },
  {
    "text": "We can do that, I\nclaim, by radix sort. ",
    "start": "4817840",
    "end": "4826159"
  },
  {
    "text": "How do we do that? Well, if you look\nat a suffix T 2i, this is the same thing as\nT from 3i plus 2 onwards.",
    "start": "4826160",
    "end": "4837320"
  },
  {
    "text": "Which we can think of as\nthat first character, comma,",
    "start": "4837320",
    "end": "4843139"
  },
  {
    "text": "the next character onwards. ",
    "start": "4843140",
    "end": "4848840"
  },
  {
    "text": "Sorry, that's the angle bracket. And this thing is, basically,\nT0 of i plus 1 onwards.",
    "start": "4848840",
    "end": "4856679"
  },
  {
    "text": "So if I strip off\nthe first letter, then I get a suffix\nthat I know about. I know the sorted order\nof all the T0 suffixes.",
    "start": "4856680",
    "end": "4862830"
  },
  {
    "text": "So this is really just\na-- you can think of this as a two character value. There's a single\ncharacter from Sigma",
    "start": "4862830",
    "end": "4868220"
  },
  {
    "text": "here, which we've\nalready reduced down to-- this is an integer between\n0 and Sigma minus 1.",
    "start": "4868220",
    "end": "4878210"
  },
  {
    "text": "This thing you can do the same\nthing with these recursive values. So you've just got two values.",
    "start": "4878210",
    "end": "4884210"
  },
  {
    "text": "Small. You can radix sort\nthem in linear time. And then we will have sorted\nT2 suffixes because we already",
    "start": "4884210",
    "end": "4890990"
  },
  {
    "text": "knew the order of these guys.  One more thing, which we have\nto merge suffixes of T0 and T1",
    "start": "4890990",
    "end": "4905780"
  },
  {
    "text": "with suffixes of T2.",
    "start": "4905780",
    "end": "4912469"
  },
  {
    "text": "And this is where\nwe use the fact that there are three of these\nthings and not two of them.",
    "start": "4912470",
    "end": "4918130"
  },
  {
    "text": "This is a weird case where three\nway divide and conquer works. Two way divide and\nconquer is what Farach-Colton did originally.",
    "start": "4918130",
    "end": "4924160"
  },
  {
    "text": "It's much more complicated\nbecause of this merge step. Merge gets painful. I claim this merging\nis easy because merging",
    "start": "4924160",
    "end": "4933489"
  },
  {
    "text": "is linear time, provided your\ncomparison is constant time. So if I need to compare a\nT0 suffix with a T2 suffix,",
    "start": "4933490",
    "end": "4941610"
  },
  {
    "text": "if I want to do\nthat comparison, I strip off the first\nletter from this one. It turns into a T1 suffix,\nthe first character",
    "start": "4941610",
    "end": "4949329"
  },
  {
    "text": "plus a T1 suffix. If I strip out the first\ncharacter of this one, it turns into the first\ncharacter and then a T0 suffix.",
    "start": "4949330",
    "end": "4955809"
  },
  {
    "text": "And these things I know how\nto compare because I already sorted T0, comma, T1.",
    "start": "4955810",
    "end": "4960969"
  },
  {
    "text": "If I need to compare T1\nsuffix with the T2 suffix,",
    "start": "4960970",
    "end": "4967900"
  },
  {
    "text": "how do I do it? I strip off the first\ntwo letters of this one, I get a T0 suffix. I strip off the first\ntwo letters of this one,",
    "start": "4967900",
    "end": "4975340"
  },
  {
    "text": "I get a T1 suffix. I can't strip off one letter\nbecause this would turn it into a T2 and I don't\nknow how to compare T2",
    "start": "4975340",
    "end": "4980953"
  },
  {
    "text": "to other things,\nthat's the whole point. I guess, it's a T2\nversus a T0, if I did that, which is this case.",
    "start": "4980953",
    "end": "4987330"
  },
  {
    "text": "But here, I strip\noff two letters, I get something I\nknow how to compare. This technique does not work\nif you only have two things.",
    "start": "4987330",
    "end": "4993290"
  },
  {
    "text": "It only works if you have\nthree things because they're sort of these situations. So constant time.",
    "start": "4993290",
    "end": "4998950"
  },
  {
    "text": "By comparing these little\ntuples, the first character or two plus the remaining\nsuffix, I can do the comparator",
    "start": "4998950",
    "end": "5006000"
  },
  {
    "text": "and merge. And then if I can do that,\neverything is linear time.",
    "start": "5006000",
    "end": "5011010"
  },
  {
    "text": "The only interesting thing\nis how do I sort the alphabet when I recurse? And for that, you\nuse radix sort.",
    "start": "5011010",
    "end": "5018690"
  },
  {
    "text": "So the first time,\nyou pay sort of Sigma.",
    "start": "5018690",
    "end": "5024500"
  },
  {
    "text": "We don't know how long\nthat takes, depends on your alphabet. But every following\nrecursion it's a radix sort because you have a triple\nof values, each of which",
    "start": "5024500",
    "end": "5031650"
  },
  {
    "text": "is small. And so you can do\nit in linear time. Because there's only\nthree digits to the thing",
    "start": "5031650",
    "end": "5037860"
  },
  {
    "text": "you're sorting. So overall, this is a\nrecursive algorithm. It gives you linear\ntime because you're",
    "start": "5037860",
    "end": "5045000"
  },
  {
    "text": "making one recursive\ncall of 2/3 the size. Pretty clever and simple.",
    "start": "5045000",
    "end": "5051840"
  },
  {
    "text": "And that's suffix trees\nand how you build them. Versus you get suffix arrays,\nyou can do the same thing",
    "start": "5051840",
    "end": "5057270"
  },
  {
    "text": "and get LCP information\nat the same time, it's written in the nodes. Then you get suffix trees.",
    "start": "5057270",
    "end": "5063330"
  },
  {
    "text": "And then you're done.",
    "start": "5063330",
    "end": "5065480"
  }
]