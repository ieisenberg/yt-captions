[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality,\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13330"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13330",
    "end": "26600"
  },
  {
    "text": "NANCY LYNCH: OK so today, you're\ngoing to see something new. In fact all this\nweek, you're going to see something that's quite\ndifferent from what you've",
    "start": "26600",
    "end": "33510"
  },
  {
    "text": "been studying in this course. These are algorithms. But they're for a completely\ndifferent sort of model.",
    "start": "33510",
    "end": "42380"
  },
  {
    "text": "Distributed algorithms,\nOK, so what are they? So now instead of\nhaving algorithms",
    "start": "42380",
    "end": "48190"
  },
  {
    "text": "that run on a typical\ncomputer, you're going to have algorithms that\nrun on a network of processors.",
    "start": "48190",
    "end": "55400"
  },
  {
    "text": "Or it could be on\none machine that has multiple processors,\nmulti processors that memory.",
    "start": "55400",
    "end": "61329"
  },
  {
    "text": " Much of computing is\ndistributed algorithms now.",
    "start": "61330",
    "end": "69370"
  },
  {
    "text": "They solve problems\nlike communication on the internet, data\nmanagement over a network,",
    "start": "69370",
    "end": "78560"
  },
  {
    "text": "allocating resources\nin a network setting, synchronizing,\nreaching agreement among different agents\nat remote locations.",
    "start": "78560",
    "end": "88990"
  },
  {
    "text": "So these are all distributed\nproblems, not things that you just solve\non one computer.",
    "start": "88990",
    "end": "94610"
  },
  {
    "text": "The kinds of algorithms you\ndesign for these settings have to work under extremely\ndifficult platforms",
    "start": "94610",
    "end": "105420"
  },
  {
    "text": "because what you have is\nconcurrent activity that's going on at many locations,\nmany processors doing things",
    "start": "105420",
    "end": "111840"
  },
  {
    "text": "at the same time. And you don't know exactly\nwhen everybody's going to perform their activities.",
    "start": "111840",
    "end": "117970"
  },
  {
    "text": "You can have different\nsorts of timing uncertainty. The order of events isn't clear.",
    "start": "117970",
    "end": "125009"
  },
  {
    "text": "There could be inputs that\narrive at different locations. And then you also have to\ndeal with failure and recovery",
    "start": "125010",
    "end": "132150"
  },
  {
    "text": "of some of the processors or\nsome of the channels involved in the computation. You don't think of\nany of this when",
    "start": "132150",
    "end": "137980"
  },
  {
    "text": "you're just trying to run an\nalgorithm on one computer.  So distributed algorithms\ncan be pretty complicated.",
    "start": "137980",
    "end": "145990"
  },
  {
    "text": "It's not easy to design them. And after you design\nthem, you still have to make sure\nthey're correct.",
    "start": "145990",
    "end": "152070"
  },
  {
    "text": "So there are issues involved\nin proving them correct and analyzing them. A little bit of\nhistory, the field",
    "start": "152070",
    "end": "157980"
  },
  {
    "text": "pretty much started\naround the late '60s. Edsger Dijkstra was one of the\nearliest leaders in the field.",
    "start": "157980",
    "end": "166330"
  },
  {
    "text": "He won of the first\nTuring Awards. Leslie Lamport won the\nTuring Award last year.",
    "start": "166330",
    "end": "172780"
  },
  {
    "text": "Although he actually\nstarted as a very young guy, way back in the early\ndays of the field.",
    "start": "172780",
    "end": "179470"
  },
  {
    "text": "If you want to look at some\nsources, I have a book. There's another textbook\nby Attiya and Welch. There's a new series of\nmonographs that basically",
    "start": "179470",
    "end": "186710"
  },
  {
    "text": "try to summarize many of the\nimportant research topics in distributed computing theory.",
    "start": "186710",
    "end": "192250"
  },
  {
    "text": "And the last two lines have a\ncouple of the main conferences in the field.",
    "start": "192250",
    "end": "198620"
  },
  {
    "text": "OK so I can't do that\nmuch in one week. What I'll do is just\nintroduce the area,",
    "start": "198620",
    "end": "204610"
  },
  {
    "text": "by showing you two common\nmodels for distributed networks. And just introduce a very\nfew fundamental algorithms,",
    "start": "204610",
    "end": "212686"
  },
  {
    "text": "and you'll see along the way\nsome techniques for modeling and analyzing them. OK the two models here are\nsynchronous distributed",
    "start": "212686",
    "end": "219740"
  },
  {
    "text": "networks, and asynchronous\ndistributed networks.",
    "start": "219740",
    "end": "224820"
  },
  {
    "text": "The problems I'll look at\nin the synchronous setting are a simple problem of leader\nelection, which is a symmetry",
    "start": "224820",
    "end": "230860"
  },
  {
    "text": "breaking problem, basically. Maximal independence set\nproblem, and then a couple",
    "start": "230860",
    "end": "238226"
  },
  {
    "text": "of problems that should\nlook familiar to you from the settings of this\nclass, establishing structures",
    "start": "238227",
    "end": "244530"
  },
  {
    "text": "like breadth-first spanning\ntrees and shortest paths trees. In the asynchronous case\nI'll revisit these last two",
    "start": "244530",
    "end": "250800"
  },
  {
    "text": "problems, setting up\nbreadth-first and shortest path trees. OK so I mentioned\nsomething about modeling",
    "start": "250800",
    "end": "257620"
  },
  {
    "text": "in proofs and analysis. Turns out, getting the\nformal models right",
    "start": "257620",
    "end": "263030"
  },
  {
    "text": "and getting real\nproofs tends to be pretty important for\ndistributed algorithms because with all the stuff\ngoing on, they're complicated.",
    "start": "263030",
    "end": "271180"
  },
  {
    "text": "And it's easy to make mistakes. The kinds of models that we use\nare interacting state machines,",
    "start": "271180",
    "end": "278110"
  },
  {
    "text": "inputs and outputs. They send each other messages. But the kinds of\nproofs you do typically",
    "start": "278110",
    "end": "284050"
  },
  {
    "text": "use invariants, a\ntechnique that you're very familiar with from this class. You can still use them\nin a distributed setting.",
    "start": "284050",
    "end": "290669"
  },
  {
    "text": "And you still prove them\nthe same way, by induction. Something else that comes up a\nlot in the distributed setting",
    "start": "290670",
    "end": "296640"
  },
  {
    "text": "is modeling and proofs\nusing levels of abstraction. You might want to give\nan abstract description",
    "start": "296640",
    "end": "302810"
  },
  {
    "text": "of an algorithm and\nprove that that works. And then you have a very\ndetailed, complicated, lower level description that you\ncan prove implements the higher",
    "start": "302810",
    "end": "311480"
  },
  {
    "text": "level description. That's another\npopular technique. You use different kinds\nof complexity measures.",
    "start": "311480",
    "end": "317669"
  },
  {
    "text": "For time complexity,\nyou would measure rounds if it's the synchronous\nmodel, or some approximation",
    "start": "317670",
    "end": "325610"
  },
  {
    "text": "to real time, if it's\nthe asynchronous model. You also count communication,\neither the number",
    "start": "325610",
    "end": "331410"
  },
  {
    "text": "of messages you send, or\nthe total number of bits that you send in an algorithm. ",
    "start": "331410",
    "end": "338000"
  },
  {
    "text": "So throughout\nthese two lectures, we'll be looking at\ndistributed networks.",
    "start": "338000",
    "end": "344300"
  },
  {
    "text": "So you start with a graph. Let's just look at\nundirected graphs this week.",
    "start": "344300",
    "end": "349830"
  },
  {
    "text": "We use n in this\nfield for what you're calling v, the total number\nof nodes in the network",
    "start": "349830",
    "end": "356490"
  },
  {
    "text": "or vertices in the graph.",
    "start": "356490",
    "end": "361780"
  },
  {
    "text": "We use the notation gamma of\nu to mean the neighbors of u in the graph.",
    "start": "361780",
    "end": "366910"
  },
  {
    "text": "So every vertex of the graph has\na set of immediate neighboring vertices. That's gamma of u.",
    "start": "366910",
    "end": "373730"
  },
  {
    "text": "And the degree of u is the size\nof the neighborhood, the number",
    "start": "373730",
    "end": "379310"
  },
  {
    "text": "of neighbors of the vertex. OK so we start with the graph. But now we're\ngoing to plunk down",
    "start": "379310",
    "end": "385740"
  },
  {
    "text": "a process, some kind\nof active entity at each vertex of the graph.",
    "start": "385740",
    "end": "391900"
  },
  {
    "text": "So this is some\nkind of automaton. If you've taken automata\ntheory, it's not really finite state machines, it's more\nlike infinite state automata",
    "start": "391900",
    "end": "399960"
  },
  {
    "text": "that can interact\nwith each other. So we usually talk about\nvertices in a graph, processes",
    "start": "399960",
    "end": "407820"
  },
  {
    "text": "at the vertices of a graph. But sometimes we get\nsloppy and just say nodes. And we could mean either the\nvertex or the active thing",
    "start": "407820",
    "end": "414979"
  },
  {
    "text": "running at the vertex. Can't keep them\nstraight all the time. OK and then with the\nedges of the graph,",
    "start": "414980",
    "end": "422120"
  },
  {
    "text": "we would put\ncommunication channels, one in each direction,\nso that the processes",
    "start": "422120",
    "end": "428690"
  },
  {
    "text": "can communicate over the edges. This week I'm not going\nto talk about what",
    "start": "428690",
    "end": "433840"
  },
  {
    "text": "happens when you introduce\nfailures because we just don't have time. A lot of distributed computing\ntheory deals with what",
    "start": "433840",
    "end": "440800"
  },
  {
    "text": "happens when some of the\ncomponents in your system fail. How do you cope with that?",
    "start": "440800",
    "end": "447330"
  },
  {
    "text": "So we'll start right in\nwith synchronous distributed algorithms. ",
    "start": "447330",
    "end": "452956"
  },
  {
    "text": "A source for that,\nif you're interested is the first technical\nchapter in my book.",
    "start": "452956",
    "end": "458180"
  },
  {
    "text": "OK so you have processes\nat the nodes of a graph, like I just said. They communicate using messages.",
    "start": "458180",
    "end": "465830"
  },
  {
    "text": "So think of each process as not\nknowing who his neighbors are, not knowing anything\nabout the graph.",
    "start": "465830",
    "end": "471930"
  },
  {
    "text": "So what do they have? They have ports. You could say they have output\nports, on which they could send",
    "start": "471930",
    "end": "477410"
  },
  {
    "text": "a message, and then some\ninput ports on which messages can come in.",
    "start": "477410",
    "end": "482900"
  },
  {
    "text": "So in general, the\nprocess doesn't know who the ports are connected to.",
    "start": "482900",
    "end": "488660"
  },
  {
    "text": "It just has local\nnames for the ports, like one, two, three,\nup to the degree.",
    "start": "488660",
    "end": "493800"
  },
  {
    "text": "If you have any questions\njust stop me and ask, if something's not clear.",
    "start": "493800",
    "end": "499189"
  },
  {
    "text": "Otherwise I'll go pretty fast. And I know that none\nof this is familiar. ",
    "start": "499190",
    "end": "505620"
  },
  {
    "text": "So in general, the\nprocesses don't have to be distinguishable at all.",
    "start": "505620",
    "end": "511070"
  },
  {
    "text": "So they don't have to have\nspecial unique identifiers so you could tell\nthe processes apart.",
    "start": "511070",
    "end": "516710"
  },
  {
    "text": "They could be\ncompletely identical. Well if they have\ndifferent numbers of ports, they're not exactly identical.",
    "start": "516710",
    "end": "523370"
  },
  {
    "text": "They certainly\nknow how many ports they have, and release the\nlocal names for the ports. ",
    "start": "523370",
    "end": "531320"
  },
  {
    "text": "Good so these are\nprocesses sitting at the nodes of the graph. What do they do? So they execute.",
    "start": "531320",
    "end": "536490"
  },
  {
    "text": "And we talk about an\nexecution of this network. It goes in synchronous\nrounds, and every round,",
    "start": "536490",
    "end": "544310"
  },
  {
    "text": "every process\nlooks at its state, and decides what\nmessages it's going to send on all of the ports.",
    "start": "544310",
    "end": "552460"
  },
  {
    "text": "So it could send different\nmessages on different ports. ",
    "start": "552460",
    "end": "558110"
  },
  {
    "text": "So then what happens\nis all the messages that the processes decide to\nsend get put onto the channels",
    "start": "558110",
    "end": "563540"
  },
  {
    "text": "and they get delivered to\nthe process at the other end. So the process of the\nother end is in some state.",
    "start": "563540",
    "end": "570520"
  },
  {
    "text": "All these messages come in. It updates its state, based\non the arriving messages. So it changes state in\nresponse to whatever comes in.",
    "start": "570520",
    "end": "577750"
  },
  {
    "start": "577750",
    "end": "582880"
  },
  {
    "text": "And this is completely different\nfrom this semester so far. We're going to completely\nignore the costs",
    "start": "582880",
    "end": "588880"
  },
  {
    "text": "of the local computation. So each node can compute\nsome complicated algorithm",
    "start": "588880",
    "end": "594641"
  },
  {
    "text": "of the sort you've been\nstudying in this class, and we usually don't\nconsider that cost. We're more worried about\nthe communication costs.",
    "start": "594642",
    "end": "603610"
  },
  {
    "text": "And so we'll be focusing on the\nnumber of rounds that it takes, in the synchronous case, and\nthe number of communication",
    "start": "603610",
    "end": "611170"
  },
  {
    "text": "messages or bits. OK so far? ",
    "start": "611170",
    "end": "618650"
  },
  {
    "text": "So let's start on\nthe first problem. Here's a graph. The nodes start out\npossibly identical,",
    "start": "618650",
    "end": "624460"
  },
  {
    "text": "but you want to somehow\ndistinguish one of them to be a leader.",
    "start": "624460",
    "end": "630200"
  },
  {
    "text": "So you have this arbitrary,\nconnected, undirected graph. And exactly one\nprocess is supposed",
    "start": "630200",
    "end": "636280"
  },
  {
    "text": "to elect itself the leader. That means it outputs a\nspecial leader signal. ",
    "start": "636280",
    "end": "643360"
  },
  {
    "text": "so exactly one should do that. So why do you want a leader? Well in practice, leaders\ncan coordinate things.",
    "start": "643360",
    "end": "652079"
  },
  {
    "text": "They can take charge\nof communication, and inform other\nnodes when they're allowed to send messages.",
    "start": "652080",
    "end": "657380"
  },
  {
    "text": "They can coordinate\nthe processing of data. Basically it allows\nyou to centralize some of the computation.",
    "start": "657380",
    "end": "663190"
  },
  {
    "text": "It can schedule the\nother processes. It can allocate the resources. It could help to reach\nagreement among the processes,",
    "start": "663190",
    "end": "670020"
  },
  {
    "text": "if they start out with\ndifferent opinions about what is supposed to happen. ",
    "start": "670020",
    "end": "675782"
  },
  {
    "text": "All right so let's start\nout with a very simple case. You have a clique. Here's a four clique, where\nall the vertices are directly",
    "start": "675782",
    "end": "682500"
  },
  {
    "text": "connected to all\nthe other vertices, with two directional channels.",
    "start": "682500",
    "end": "687932"
  },
  {
    "text": "And the processes are identical.  So I should have\nasked you, instead",
    "start": "687932",
    "end": "693420"
  },
  {
    "text": "of just giving the\nanswer here, but are they able to elect a leader?",
    "start": "693420",
    "end": "699550"
  },
  {
    "text": "So this theorem says that in\ngeneral, that's impossible. Or it's not possible, in\nthe most general case.",
    "start": "699550",
    "end": "706880"
  },
  {
    "text": "If you have, no\nmatter what n is, let's just say we have an\nn vertex clique for some n.",
    "start": "706880",
    "end": "713100"
  },
  {
    "text": "It's not possible to have\nany algorithm that you can have all the processes\nrun, if it's deterministic",
    "start": "713100",
    "end": "721759"
  },
  {
    "text": "and the processes start\nout all indistinguishable. There's no way\nthat they can elect",
    "start": "721760",
    "end": "727940"
  },
  {
    "text": "a single node as a leader. So do you have an intuition\nfor why that might be the case? ",
    "start": "727940",
    "end": "734982"
  },
  {
    "text": "Yeah. AUDIENCE: They're\nall connected, and the cross-problem\ncommunication in one round",
    "start": "734982",
    "end": "741378"
  },
  {
    "text": "is equal, then to\nbe equal likely to select each one of them. It would be-- NANCY LYNCH: It's deterministic\nthere's no likelihood here.",
    "start": "741378",
    "end": "750290"
  },
  {
    "text": "And nobody is doing\nany selecting. You're talking as if there's\nsomebody who's choosing",
    "start": "750290",
    "end": "756639"
  },
  {
    "text": "a process to do something. There isn't anyone in charge. So this is a really\ndifferent way of thinking.",
    "start": "756640",
    "end": "763700"
  },
  {
    "text": "AUDIENCE: So every node is\nessentially the exact same. So if it says, OK, let's\nassume I'm going to be leader,",
    "start": "763700",
    "end": "769370"
  },
  {
    "text": "everyone is going to assume\nthey're going to be leader. NANCY LYNCH: That's exactly\nthe right intuition.",
    "start": "769370",
    "end": "775420"
  },
  {
    "text": "They can't\ndistinguish themselves because they're always\ngoing to do the same thing. Let's look at a\nvery simple case.",
    "start": "775420",
    "end": "781340"
  },
  {
    "text": "Suppose we have just two nodes,\ntwo node clique, two nodes connected by channels.",
    "start": "781340",
    "end": "787970"
  },
  {
    "text": "These are identical. They're deterministic. What can they do? Well you could try to design\nalgorithms for one of them",
    "start": "787970",
    "end": "794530"
  },
  {
    "text": "to elect itself as the leader. But you can show,\nby using induction, that the processes\nare actually going",
    "start": "794530",
    "end": "800530"
  },
  {
    "text": "to remain in the same state\nas each other forever, however many rounds you execute.",
    "start": "800530",
    "end": "808260"
  },
  {
    "text": "So let's slow down. We can work by contradiction. Suppose you have an algorithm\nthat solves this problem.",
    "start": "808260",
    "end": "816460"
  },
  {
    "text": "Both of the processes,\nthey're identical. They start in the\nsame start state. Let's say there's a\nunique start state.",
    "start": "816460",
    "end": "822300"
  },
  {
    "text": " So we could prove by induction\non the number of rounds",
    "start": "822300",
    "end": "829750"
  },
  {
    "text": "that after any number\nof rounds, say r rounds, the processes are still\nin identical states.",
    "start": "829750",
    "end": "837770"
  },
  {
    "text": "So the inductive step\nis, all right, they're in identical states after\nsome number of rounds. Let's look at the next round.",
    "start": "837770",
    "end": "843677"
  },
  {
    "text": "They're in the same state. So they generate\nthe same messages. So they each other\nthe same messages.",
    "start": "843677",
    "end": "849900"
  },
  {
    "text": "They receive the same message. And then they make\nthe same state change.",
    "start": "849900",
    "end": "855140"
  },
  {
    "text": "So they stay in the same state.  And you can tweak\nthis, and say how this",
    "start": "855140",
    "end": "862260"
  },
  {
    "text": "works for-- yeah, question? AUDIENCE: So in what ways is\nthe proof a contradiction?",
    "start": "862260",
    "end": "868010"
  },
  {
    "text": "NANCY LYNCH: I'm not finished. You're exactly right. We have to finish by using the\nrequirements of the problem.",
    "start": "868010",
    "end": "873850"
  },
  {
    "text": "Since the algorithm has to solve\nthe leader election problem, the requirements say that\neventually, one of them",
    "start": "873850",
    "end": "881170"
  },
  {
    "text": "has to output leader. And what happens when he does?",
    "start": "881170",
    "end": "886820"
  },
  {
    "text": " Anyone? Yeah. AUDIENCE: You have node also\noutputting the leader signal.",
    "start": "886820",
    "end": "894240"
  },
  {
    "text": "NANCY LYNCH: Yeah the other one\nwould also do the same thing. We're saying round by round,\nthey stay in the same state.",
    "start": "894240",
    "end": "899820"
  },
  {
    "text": "So as someone said before,\nwhen one guy outputs leader, at the same round the other\nguy will output leader as well.",
    "start": "899820",
    "end": "908209"
  },
  {
    "text": "So that's a contradiction\nto the problem requirements. Notice we didn't\nassume anything at all about exactly how\nthe algorithm works.",
    "start": "908210",
    "end": "915040"
  },
  {
    "text": "We're just saying, however it\nworks, it can't solve this, under the assumptions\nthat the nodes",
    "start": "915040",
    "end": "920110"
  },
  {
    "text": "are indistinguishable\nand deterministic.  So as you can see,\nthis will extend if you",
    "start": "920110",
    "end": "926710"
  },
  {
    "text": "have larger cliques of size n. So now the process has\nnot just one output port,",
    "start": "926710",
    "end": "933710"
  },
  {
    "text": "it has n minus 1 output ports to\nconnect to all the other nodes. Let's say they're numbered\n1 through n minus 1.",
    "start": "933710",
    "end": "941370"
  },
  {
    "text": "And one of the possibilities,\nand one I'll use in this proof is that the ports happen to\nbe numbered consistently.",
    "start": "941370",
    "end": "947980"
  },
  {
    "text": "So that if you have output\nport number k at one node, it's connected to input port\nnumber k at the other end.",
    "start": "947980",
    "end": "957319"
  },
  {
    "text": "So that's one way\nthings can match up. All right if that's\nthe case, we could do the same proof we just did.",
    "start": "957320",
    "end": "963230"
  },
  {
    "text": "Show by induction that all\nthe processes in the clique remain in the same\nstate forever.",
    "start": "963230",
    "end": "969580"
  },
  {
    "text": "So same proof. Suppose you have an\nalgorithm that's solves it. They all began in\nthe same state.",
    "start": "969580",
    "end": "974620"
  },
  {
    "text": "You show by induction that\nthey all remain the same state. ",
    "start": "974620",
    "end": "979690"
  },
  {
    "text": "Well so now we slow\ndown a little bit. Each process sends a possibly\ndifferent message on each port.",
    "start": "979690",
    "end": "985920"
  },
  {
    "text": "But everybody sends the\nsame message on port k because they're all\nindistinguishable.",
    "start": "985920",
    "end": "990980"
  },
  {
    "text": "And then because the\nway the ports match up, everybody receives the\nsame message on port k.",
    "start": "990980",
    "end": "996370"
  },
  {
    "text": "And then they make the\nsame state changes.  AUDIENCE: Does this\nproof imply that there's",
    "start": "996370",
    "end": "1003456"
  },
  {
    "text": "a kernel for simplifying the\ngraph when you find a clique? ",
    "start": "1003456",
    "end": "1010240"
  },
  {
    "text": "NANCY LYNCH: No because\nif you have a graph that consists of a clique\nand then let's say, some other stuff,\nmaybe the leader",
    "start": "1010240",
    "end": "1017330"
  },
  {
    "text": "could be somebody\noutside the clique. So you can't just\nsay because there's a clique that you can't elect\na leader because you could",
    "start": "1017330",
    "end": "1024619"
  },
  {
    "text": "break the symmetry of the graph\nwith other stuff in the graph. Yeah? AUDIENCE: What assumptions do\nwe make to know that for each k,",
    "start": "1024619",
    "end": "1031947"
  },
  {
    "text": "they receive the same message? NANCY LYNCH:\nBecause everybody is going to send the same message\non the same numbered port,",
    "start": "1031947",
    "end": "1038109"
  },
  {
    "text": "because they're identical.  And one way the ports\ncan be hooked up,",
    "start": "1038109",
    "end": "1043933"
  },
  {
    "text": "and we have to tolerate all\nways they could be hooked up-- say an adversary\nhooks them up-- is that port k,\nsomebody's output port,",
    "start": "1043933",
    "end": "1052430"
  },
  {
    "text": "is the other end's\ninput port numbered k. So then they all\nreceive the same message",
    "start": "1052430",
    "end": "1058710"
  },
  {
    "text": "on their port number k. Yeah? AUDIENCE: Is it actually\npossible to always hook up the boards that way.",
    "start": "1058710",
    "end": "1064150"
  },
  {
    "text": "I mean, it's like wrapped\nwith three vertices. NANCY LYNCH: Well I'm\njust doing it for cliques.",
    "start": "1064150",
    "end": "1071309"
  },
  {
    "text": "Yeah it is. Yeah you could do it. I mean you could have port\none always going clockwise,",
    "start": "1071310",
    "end": "1077470"
  },
  {
    "text": "and port two going\ncounterclockwise, I mean, there's always a\nway to do that in a clique.",
    "start": "1077470",
    "end": "1083560"
  },
  {
    "text": "I checked that. So what you've just seen is\none of the very basic problems",
    "start": "1083560",
    "end": "1089240"
  },
  {
    "text": "for distributed algorithms,\nwhich is breaking symmetry among identical processes. And you see that deterministic,\nindistinguishable processes",
    "start": "1089240",
    "end": "1097850"
  },
  {
    "text": "just can't do it. So we have to have\nsomething more. So what do you\nthink we could add",
    "start": "1097850",
    "end": "1103100"
  },
  {
    "text": "to make this problem solvable?  AUDIENCE: [INAUDIBLE] processes.",
    "start": "1103100",
    "end": "1108680"
  },
  {
    "text": "NANCY LYNCH: I can't hear. AUDIENCE: Probability. Probability, OK, anything else? ",
    "start": "1108680",
    "end": "1116210"
  },
  {
    "text": "So we could have the processes\nactually distinguishable. The common way in this area is\nto say that each process has",
    "start": "1116210",
    "end": "1122710"
  },
  {
    "text": "an identifier. Like, you buy a chip and it's\ngot some identifier burned in. OK so you have some kind\nof unique identifiers.",
    "start": "1122710",
    "end": "1130159"
  },
  {
    "text": "Or you can use randomness. OK for unique\nidentifiers, you assume",
    "start": "1130160",
    "end": "1137230"
  },
  {
    "text": "everybody has some\nnumber or some identifier that it knows what it is. It's built into its state, let's\nsay, a special state variable.",
    "start": "1137230",
    "end": "1147050"
  },
  {
    "text": "They're totally\nordered, generally. They could be integers, or\nfrom some totally ordered set.",
    "start": "1147050",
    "end": "1155170"
  },
  {
    "text": "When you say unique\nidentifiers, is it means that different\nidentifiers could",
    "start": "1155170",
    "end": "1160810"
  },
  {
    "text": "appear any place in the graph. But each identifier can\nappear at most once.",
    "start": "1160810",
    "end": "1167429"
  },
  {
    "text": "You can have a huge identifier\nspace in a small graph. But you're Just selecting\nsome identifiers",
    "start": "1167430",
    "end": "1172700"
  },
  {
    "text": "to put in the\nprocesses in the graph. So that's one set up.",
    "start": "1172700",
    "end": "1177720"
  },
  {
    "text": "And the other one, of\ncourse, is using randomness. So let's look at the\nunique identifiers first.",
    "start": "1177720",
    "end": "1184930"
  },
  {
    "text": "Now the problem becomes easy. Let's look at the clique again. Suppose there's an\nalgorithm-- well, let's",
    "start": "1184930",
    "end": "1191970"
  },
  {
    "text": "construct an algorithm\nthat consists of deterministic processes\nwith unique identifiers.",
    "start": "1191970",
    "end": "1198760"
  },
  {
    "text": "And we're going to guarantee\nto elect a leader in the graph. And moreover, it's\njust going to take",
    "start": "1198760",
    "end": "1203990"
  },
  {
    "text": "one round of communication. And it's only going to\nuse n squared messages.",
    "start": "1203990",
    "end": "1210210"
  },
  {
    "text": "How could that work? ",
    "start": "1210210",
    "end": "1217159"
  },
  {
    "text": "Everybody in this click\nhas a unique identifier. What would they do?",
    "start": "1217160",
    "end": "1222539"
  },
  {
    "text": "Send it out, right? So you can just send\nit on all your ports. Everybody would send its\nunique identifier on all",
    "start": "1222540",
    "end": "1228250"
  },
  {
    "text": "its output ports. And then they collect the unique\nidentifiers from everyone else.",
    "start": "1228250",
    "end": "1233540"
  },
  {
    "text": "So everybody sees the\nsame set of identifiers. And so the process with the\nmaximum unique identifier",
    "start": "1233540",
    "end": "1240870"
  },
  {
    "text": "knows that it's the only\none with that identifier. And it's the biggest one. So it can elect\nitself the leader.",
    "start": "1240870",
    "end": "1246120"
  },
  {
    "text": " So all you is unique\nidentifiers and the ability",
    "start": "1246120",
    "end": "1251790"
  },
  {
    "text": "to exchange them reliably. And you can elect\nsomebody easily. ",
    "start": "1251790",
    "end": "1258810"
  },
  {
    "text": "Randomness, well,\nvarious ways to do it. But one idea is the processes\ncould just choose identifiers",
    "start": "1258810",
    "end": "1267270"
  },
  {
    "text": "randomly. You take a sufficiently large\nset of possible identifiers,",
    "start": "1267270",
    "end": "1273419"
  },
  {
    "text": "and so if they just choose\nuniformly at random, they're likely to choose\nall different identifiers.",
    "start": "1273420",
    "end": "1279640"
  },
  {
    "text": "Once you have these\nrandomly chosen identifiers you could use them like the\nreally unique identifiers.",
    "start": "1279640",
    "end": "1286770"
  },
  {
    "text": "The only thing is you might,\nthere's a small chance that you'll have a duplicate. In which case, you want to be\nable to detect that and repeat",
    "start": "1286770",
    "end": "1294520"
  },
  {
    "text": "this. So first of all, how big\nthe a set do you need?",
    "start": "1294520",
    "end": "1300112"
  },
  {
    "text": "Well here's an example.  Suppose that you have\nthe n processes choosing",
    "start": "1300112",
    "end": "1306409"
  },
  {
    "text": "at random, independently\nfrom a space of size r. Identifiers are the\nnumbers one through r.",
    "start": "1306410",
    "end": "1317030"
  },
  {
    "text": "OK and r is going\nto depend on n. It's going to be like n\nsquared, but it's also",
    "start": "1317030",
    "end": "1323230"
  },
  {
    "text": "going to depend on epsilon,\nwhich is the error probability that you're interested in.",
    "start": "1323230",
    "end": "1328270"
  },
  {
    "text": "Turns out that n squared over\n2 epsilon is good enough. OK so you have your IDs\nspace at least that large.",
    "start": "1328270",
    "end": "1335299"
  },
  {
    "text": "And then you can guarantee that\nwith probability at least 1 minus epsilon, all the\nnumbers that everybody chooses",
    "start": "1335300",
    "end": "1342130"
  },
  {
    "text": "are different. It's a very easy proof. The probability-- just look\nat two particular processes--",
    "start": "1342130",
    "end": "1347980"
  },
  {
    "text": "what's the probability that\nthey choose the same number? It's just 1 over r, right. Because they're both\nchoosing at random.",
    "start": "1347980",
    "end": "1354260"
  },
  {
    "text": "The first one chooses something. The probability\nthat the second one chooses the same thing\nis just 1 over r.",
    "start": "1354260",
    "end": "1361080"
  },
  {
    "text": "But now you can\ntake a union bound, just add up the probabilities\nof any pair having a duplicate.",
    "start": "1361080",
    "end": "1369020"
  },
  {
    "text": "And so you have n square\naround n squared over 2 pairs. And so multiplying 1 over\nr by n squared over 2",
    "start": "1369020",
    "end": "1377500"
  },
  {
    "text": "still keeps your probability\nless than or equal to epsilon, your error probability.",
    "start": "1377500",
    "end": "1382820"
  },
  {
    "text": "So you can choose\nidentifiers using randomness.",
    "start": "1382820",
    "end": "1388740"
  },
  {
    "text": "With large enough space,\nwith very high probability, you can get them to\nbe all different.",
    "start": "1388740",
    "end": "1395910"
  },
  {
    "text": "And now here's how\nthe algorithm works.  So you get an algorithm that\nwould finish in only one round,",
    "start": "1395910",
    "end": "1404630"
  },
  {
    "text": "with probability\n1 minus epsilon. But it will be correct. And it will have\nrepeated rounds,",
    "start": "1404630",
    "end": "1410640"
  },
  {
    "text": "in case the first\nround doesn't work. But the expected\ntime is just 1 over 1",
    "start": "1410640",
    "end": "1415900"
  },
  {
    "text": "minus epsilon, not very big. What's the algorithm? Well processes just choose the\nrandom IDs from the big space,",
    "start": "1415900",
    "end": "1423880"
  },
  {
    "text": "like we just said. They exchange their Ids. And now, everybody\ncan see everyone's ID,",
    "start": "1423880",
    "end": "1430030"
  },
  {
    "text": "but they also can tell\nif there's a duplicate. if the maximum is not unique. So if the maximum is unique,\nfind the maximum wins.",
    "start": "1430030",
    "end": "1437680"
  },
  {
    "text": "And everyone knows that. Otherwise you have a problem. And you have to repeat. And you just keep doing\nthat until you succeed.",
    "start": "1437680",
    "end": "1446200"
  },
  {
    "text": "So this can just\ncontinue, but it's likely to finish very fast,\nif you have a high likelihood",
    "start": "1446200",
    "end": "1451860"
  },
  {
    "text": "of having no duplicates. ",
    "start": "1451860",
    "end": "1457310"
  },
  {
    "text": "Questions about the\nleader election? So the story was, it's\nimpossible without something",
    "start": "1457310",
    "end": "1463909"
  },
  {
    "text": "to help you distinguish\nsome processes. You can do it with\nunique identifiers.",
    "start": "1463910",
    "end": "1469286"
  },
  {
    "text": "You can do with randomness. ",
    "start": "1469286",
    "end": "1476680"
  },
  {
    "text": "Second problem is called\nmaximal independent set.",
    "start": "1476680",
    "end": "1482240"
  },
  {
    "text": "So you have a picture of\na maximal independent set in a graph here. Let's try this.",
    "start": "1482240",
    "end": "1489790"
  },
  {
    "text": "Yeah cursor. So the maximal independent\nset in the graph is here. But this is something I'll\ncome back to a minute.",
    "start": "1489790",
    "end": "1497300"
  },
  {
    "text": "This is actually a use of\nthe maximal independent set to model what happens\nin a certain kind",
    "start": "1497300",
    "end": "1502600"
  },
  {
    "text": "of biological system. What's a maximal\nindependence set?",
    "start": "1502600",
    "end": "1507660"
  },
  {
    "text": "So you start with a general,\nundirected graph network.",
    "start": "1507660",
    "end": "1513750"
  },
  {
    "text": "And the problem is to choose\na subset of the nodes so that they form what we call\na maximal independent .",
    "start": "1513750",
    "end": "1521000"
  },
  {
    "text": "Set let's break that down. What does this mean? Independent means you don't\nhave any two neighbors that",
    "start": "1521000",
    "end": "1526810"
  },
  {
    "text": "are both in the set. So you don't want to get\ntwo neighbors in the set.",
    "start": "1526810",
    "end": "1532960"
  },
  {
    "text": "Maximal means that\nwhatever set you choose, you can't add any more nodes\nwithout violating independence.",
    "start": "1532960",
    "end": "1542480"
  },
  {
    "text": "So now this should\nlook something like a couple of\nhomework problems that you had from the\nbeginning and recently.",
    "start": "1542480",
    "end": "1548799"
  },
  {
    "text": "But I'm not saying that it's\nmaximum independent set. I'm not saying you have to\nhave the global, largest",
    "start": "1548800",
    "end": "1554420"
  },
  {
    "text": "number of nodes. I'm just saying it has\nto be a local optimum, in the sense that you can't\nadd any more nodes to your set",
    "start": "1554420",
    "end": "1561850"
  },
  {
    "text": "without violating the\nindependence property. Make sense? There's two examples,\nthe same graph,",
    "start": "1561850",
    "end": "1569559"
  },
  {
    "text": "two different maximal\nindependent sets. The green nodes, here\nwe have four green nodes",
    "start": "1569560",
    "end": "1578350"
  },
  {
    "text": "that are independent, not\nneighbors of each other. And they're maximal,\nin that I couldn't",
    "start": "1578350",
    "end": "1583760"
  },
  {
    "text": "add any of the red\nnodes into a set without violating the\nindependence property.",
    "start": "1583760",
    "end": "1591150"
  },
  {
    "text": "But then over here, we have a\nsecond maximal independent set for the same graph. Now we just have two nodes.",
    "start": "1591150",
    "end": "1599160"
  },
  {
    "text": "And you can't add\nany of the red nodes without violating the\nindependence property.",
    "start": "1599160",
    "end": "1604960"
  },
  {
    "text": "In other words, every\nnode is either in the MIS, or has a neighbor in the MIS.",
    "start": "1604960",
    "end": "1611810"
  },
  {
    "text": "There's nothing else you can\ndo to add notes to the MIS So the notion of maximal\nindependence, that make sense?",
    "start": "1611810",
    "end": "1620175"
  },
  {
    "text": " All right, so to make this\na distributed problem,",
    "start": "1620175",
    "end": "1628430"
  },
  {
    "text": "let's start out assuming we\nhave no unique identifier. Actually, for this\nwhole problem, we're not going to have\nunique identifiers.",
    "start": "1628430",
    "end": "1634660"
  },
  {
    "text": "They're all going\nto be identical. The processes do need\none piece of information,",
    "start": "1634660",
    "end": "1639990"
  },
  {
    "text": "which is some approximation\nto n, the size of the network, the total number of vertices.",
    "start": "1639990",
    "end": "1647160"
  },
  {
    "text": "So we would like to\nhave these nodes somehow cooperate to compute an MIS\nof the entire network graph.",
    "start": "1647160",
    "end": "1655860"
  },
  {
    "text": "What that means is every process\nshould find out whether it is in the MIS or not.",
    "start": "1655860",
    "end": "1661380"
  },
  {
    "text": "If it is, it should output n. And if it's not,\nit'll just output out. ",
    "start": "1661380",
    "end": "1669110"
  },
  {
    "text": "So you don't have to\nactually compute this, like you're used\nto solving problems like this, where somebody\nhas to gather all",
    "start": "1669110",
    "end": "1675950"
  },
  {
    "text": "the information in one place. Nobody gathers anything. Everybody just has to\nknow whether or not",
    "start": "1675950",
    "end": "1681360"
  },
  {
    "text": "they're in the MIS.  So as you can\nimagine, this is going",
    "start": "1681360",
    "end": "1687760"
  },
  {
    "text": "to be unsolvable\nin certain graphs by deterministic algorithms,\nby the same kind of symmetry",
    "start": "1687760",
    "end": "1694870"
  },
  {
    "text": "breaking problems that you\nsaw for leader election. So we're going to move right\nto randomized algorithms",
    "start": "1694870",
    "end": "1702320"
  },
  {
    "text": "for this problem. Some applications\nof distributed MIS,",
    "start": "1702320",
    "end": "1708180"
  },
  {
    "text": "well they come up in\ncommunication networks, where you want to choose--\nlet's say you have a very dense network of processes.",
    "start": "1708180",
    "end": "1715040"
  },
  {
    "text": "You want to choose just\na few nodes, which would be like an overlay network. You would choose some\nnodes who could take charge",
    "start": "1715040",
    "end": "1721850"
  },
  {
    "text": "of communication that you can\ncommunicate on this overlay network, and then in\nthe end, each node",
    "start": "1721850",
    "end": "1726909"
  },
  {
    "text": "can take care of communicating\nwith its many neighbors. So that's a common\nsort of application.",
    "start": "1726910",
    "end": "1734250"
  },
  {
    "text": "But it also comes\nup in other places. A great example is in\ndevelopmental biology, where",
    "start": "1734250",
    "end": "1739300"
  },
  {
    "text": "a couple of years ago, there\nwas a paper in Science by Afek, Alon-- there's like\neight authors on that.",
    "start": "1739300",
    "end": "1745980"
  },
  {
    "text": "But Ziv Bar-Joseph was the\nlead author of this paper.",
    "start": "1745980",
    "end": "1751380"
  },
  {
    "text": "So the idea is you have a\nbunch of cells in a fruit fly. And during development,\nsome of those cells",
    "start": "1751380",
    "end": "1758830"
  },
  {
    "text": "are supposed to\ndistinguish themselves as being what's called\nsensory organ precursor cells.",
    "start": "1758830",
    "end": "1764730"
  },
  {
    "text": "The properties that you\nwant it that actually, you would like a maximal independent\nset of the cells to become",
    "start": "1764730",
    "end": "1771940"
  },
  {
    "text": "distinguished in this way. So they wrote a paper about\nit, got published in Science. They basically designed a\nnew distributed algorithm",
    "start": "1771940",
    "end": "1779790"
  },
  {
    "text": "that closely mirrored what\nhappened in the fruit fly during development. ",
    "start": "1779790",
    "end": "1788420"
  },
  {
    "text": "So what I'm going to show you\nis a very well-known algorithm, a classical algorithm for MIS.",
    "start": "1788420",
    "end": "1795780"
  },
  {
    "text": "This is by Michael Luby. Very simple algorithm,\nit executes in phases.",
    "start": "1795780",
    "end": "1802070"
  },
  {
    "text": "Each phase has two realms. So you start out with all\nthe nodes being active.",
    "start": "1802070",
    "end": "1807690"
  },
  {
    "text": "They're all involved. They don't know what they're\ngoing to end up with. And at each phase, some\nof the active nodes",
    "start": "1807690",
    "end": "1815410"
  },
  {
    "text": "are going to decide\nthey're in the MIS. Some others will decide\nthey're out of the MIS.",
    "start": "1815410",
    "end": "1821970"
  },
  {
    "text": "And some others won't know yet. So then you just continue\nto the next phase,",
    "start": "1821970",
    "end": "1827230"
  },
  {
    "text": "with all the remaining nodes\nand the edges between them. So you're basically\ngoing to settle",
    "start": "1827230",
    "end": "1832670"
  },
  {
    "text": "what happens with some\nsubset of the nodes, and then reduce the\ngraph and continue. ",
    "start": "1832670",
    "end": "1839870"
  },
  {
    "text": "So that's the algorithm. So what do you do in each phase? Here's what an active\nnode does at a phase.",
    "start": "1839870",
    "end": "1846115"
  },
  {
    "text": "Two rounds. The first round, it\npicks a random value in a large space, the same\nkind of idea as before.",
    "start": "1846115",
    "end": "1854640"
  },
  {
    "text": "This time it's 1 up\n2 n to the fifth. It sends that random value\nto all its neighbors,",
    "start": "1854640",
    "end": "1861790"
  },
  {
    "text": "receives the values from all\nits still active neighbors, and then it just looks to see\nif its value is greater than all",
    "start": "1861790",
    "end": "1871309"
  },
  {
    "text": "the values it received. So then it's a local maximum. It has chosen a value\nthat's strictly greater",
    "start": "1871310",
    "end": "1876830"
  },
  {
    "text": "than the values chosen\nby all its neighbors. So then it decides to join\nthe MIS and it outputs in.",
    "start": "1876830",
    "end": "1884040"
  },
  {
    "text": "But now you want to make\nsure none of its neighbors-- you know that none\nof its neighbors are going to join\nthe MIS at round one.",
    "start": "1884040",
    "end": "1891200"
  },
  {
    "text": "Because you know this\nguy's chosen value is larger, strictly larger,\nthan all its neighbors.",
    "start": "1891200",
    "end": "1896930"
  },
  {
    "text": "But now you want to tell them\nthat they should not join. They should be out. So if you join the\nMIS you're going",
    "start": "1896930",
    "end": "1909080"
  },
  {
    "text": "to announce that by sending\nmessages to all your neighbors.",
    "start": "1909080",
    "end": "1914740"
  },
  {
    "text": "And then anybody who\nreceives an announcement can",
    "start": "1914740",
    "end": "1922510"
  },
  {
    "text": "decide it's not going to be\nin the MIS and it outputs out. Because it knows it has a\nneighbor that's in the MIS.",
    "start": "1922510",
    "end": "1930260"
  },
  {
    "text": "So if you decided in or out\nat this phase, you're done. You become inactive.",
    "start": "1930260",
    "end": "1936420"
  },
  {
    "text": "And only the\nremaining active guys continue to the next phase. Make sense? ",
    "start": "1936420",
    "end": "1944240"
  },
  {
    "text": "any questions about how\nthe algorithm works? ",
    "start": "1944240",
    "end": "1952480"
  },
  {
    "text": "And animation. All right so all the\nnodes start out identical.",
    "start": "1952480",
    "end": "1957770"
  },
  {
    "text": "They all pick IDs. So here's some numbers\nthat they pick. So which nodes are going\nto now join the MIS?",
    "start": "1957770",
    "end": "1965410"
  },
  {
    "text": "16, and the one that chose 13.",
    "start": "1965410",
    "end": "1970480"
  },
  {
    "text": "Good, so they're in the MIS. And then at the same phase,\nall of their neighbors, those for red nodes, are going\nto decide to be out of the MIS",
    "start": "1970480",
    "end": "1982750"
  },
  {
    "text": "And now you're left with\nthe remaining four nodes. We don't keep going\nwith the same IDs. we start over.",
    "start": "1982750",
    "end": "1988140"
  },
  {
    "text": "We want the rounds\nto be independent. So if they choose\nagain, they get new IDs.",
    "start": "1988140",
    "end": "1994610"
  },
  {
    "text": "And now the guy with the\n12 and the guy with the 18 going to join the\nMIS at this phase.",
    "start": "1994610",
    "end": "2002179"
  },
  {
    "text": "And their neighbors will\ndecide not to be in the MIS.",
    "start": "2002180",
    "end": "2007280"
  },
  {
    "text": "That leaves us with just one\nmode, the guy who had four. Next phase, he\nchooses another ID.",
    "start": "2007280",
    "end": "2013240"
  },
  {
    "text": "But he has no neighbors\nso by default, he's bigger than\nall the neighbors. So he just joins the MIS.",
    "start": "2013240",
    "end": "2019340"
  },
  {
    "text": " So that's how this works. Very simple algorithm,\nand it actually",
    "start": "2019340",
    "end": "2025600"
  },
  {
    "text": "works to find an\nMIS very quickly. ",
    "start": "2025600",
    "end": "2033380"
  },
  {
    "text": "Why does this give\nyou independence? How do we know that if\nthis ever terminates,",
    "start": "2033380",
    "end": "2040310"
  },
  {
    "text": "if everybody decides, how do\nwe know that we don't ever have two neighbors that\ndecided to be in the MIS?",
    "start": "2040310",
    "end": "2048440"
  },
  {
    "text": "Yeah. AUDIENCE: Because once\na node joins the MIS, it broadcasts to\nits neighbors that--",
    "start": "2048440",
    "end": "2054550"
  },
  {
    "text": "NANCY LYNCH: Right. The only way you join\nthe MIS is if you have the unique maximum\nvalue in your neighborhood.",
    "start": "2054550",
    "end": "2061750"
  },
  {
    "text": "And when you do, all your\nneighbors become inactive. So you're certainly going\nto have independence.",
    "start": "2061750",
    "end": "2069020"
  },
  {
    "text": "Maximality, if it\nterminates, the final set is not going to allow you\nto add any more nodes.",
    "start": "2069020",
    "end": "2077158"
  },
  {
    "text": "Why? Because a node is only\ngoing to become inactive if it joins the MIS, or\na neighbor joins the MIS.",
    "start": "2077159",
    "end": "2085460"
  },
  {
    "text": "And we just continue\nthis algorithm until all the nodes\nbecome inactive.",
    "start": "2085460",
    "end": "2091079"
  },
  {
    "text": "So either the node is in the\nMIS or a neighbor is in the MIS. So you can't possibly\nadd any more.",
    "start": "2091080",
    "end": "2098170"
  },
  {
    "text": "Yes? So this has the\nbasic correctness properties, but what\nyou're probably wondering,",
    "start": "2098170",
    "end": "2104590"
  },
  {
    "text": "is why is this efficient enough? Why is it efficient?",
    "start": "2104590",
    "end": "2110119"
  },
  {
    "text": "Well we could say that with high\nprobability, of probability 1, it will eventually terminate. ",
    "start": "2110120",
    "end": "2117589"
  },
  {
    "text": "More quantitative, we can\nstate this theorem that says,",
    "start": "2117590",
    "end": "2125020"
  },
  {
    "text": "with probability at\nleast 1 minus 1 over n, all the nodes decide\nwithin four log n phases.",
    "start": "2125020",
    "end": "2133490"
  },
  {
    "text": "Since n is the\nnumber of nodes, this doesn't tell us that you get\nprobability 1 of eventually",
    "start": "2133490",
    "end": "2138670"
  },
  {
    "text": "terminating. But we can repeat this\nand get the same sort of bound repeatedly\nfor successive phases.",
    "start": "2138670",
    "end": "2147520"
  },
  {
    "text": "But let's just focus on getting\nprobability at least 1 minus 1 over n that all nodes decide\nwithin about four log n phases.",
    "start": "2147520",
    "end": "2157245"
  },
  {
    "text": " So let's see what\nthis is saying. You have this big\ncomplicated graph.",
    "start": "2157245",
    "end": "2164579"
  },
  {
    "text": "And in one round, for this to\nbe like log n behavior, what has to happen at each phase?",
    "start": "2164580",
    "end": "2170885"
  },
  {
    "text": " You have to reduce it by\nsome constant fraction.",
    "start": "2170885",
    "end": "2176119"
  },
  {
    "text": "The number of nodes,\nsay, should go down. So it's sort of how\nthe proof will go.",
    "start": "2176120",
    "end": "2183220"
  },
  {
    "text": "So we start out\nwith a Lemma saying, you're choosing\nthese IDs at random. You want a high probability\nthat they're all different.",
    "start": "2183220",
    "end": "2190584"
  },
  {
    "text": "So we have a lemma like\nthe one we had before. It says, the probability\nat least, we use 1 minus 1",
    "start": "2190584",
    "end": "2195920"
  },
  {
    "text": "over n squared, in each phase. All these phases\nup to four log n,",
    "start": "2195920",
    "end": "2201310"
  },
  {
    "text": "everybody's choosing a\ndifferent random value. All the nodes choose different\nvalues at each phase.",
    "start": "2201310",
    "end": "2208880"
  },
  {
    "text": "So this lets us\nignore the possibility that you have repeats.",
    "start": "2208880",
    "end": "2214000"
  },
  {
    "text": "So we'll come back\nto that at the end.  All right, so we're going to\npretend that in each phase,",
    "start": "2214000",
    "end": "2220480"
  },
  {
    "text": "all the random\nnumbers are different.  So the key idea of this is\nto show that the graph has",
    "start": "2220480",
    "end": "2229070"
  },
  {
    "text": "to shrink enough at each phase. So the way we're\ngoing to say that is",
    "start": "2229070",
    "end": "2234560"
  },
  {
    "text": "not in terms of the\nnodes, but in terms of the number of edges. We're going to say at\neach phase, the expected",
    "start": "2234560",
    "end": "2242670"
  },
  {
    "text": "number of edges that are\nlive-- why is that shaking? ",
    "start": "2242670",
    "end": "2251680"
  },
  {
    "text": "OK. The expected number\nof edges that are live at the end of the\nphase is at most half the number",
    "start": "2251680",
    "end": "2258300"
  },
  {
    "text": "that were live at the\nbeginning of the phase. So an edge is live, if its\nendpoints are still live.",
    "start": "2258300",
    "end": "2265410"
  },
  {
    "text": "So instead of talking about\nreducing the number of nodes by a constant\nfraction, I'm going to reduce the number\nof remaining edges",
    "start": "2265410",
    "end": "2272549"
  },
  {
    "text": "by constant fraction\nof each phase. So this is what\nI'm going to prove.",
    "start": "2272550",
    "end": "2278859"
  },
  {
    "text": "So now I've got only three\nslides, but the only three slides today that have\ncalculations on them.",
    "start": "2278860",
    "end": "2284690"
  },
  {
    "text": "So probably have\nto pay attention, if you want to follow\nthe calculations online. So let's see why.",
    "start": "2284690",
    "end": "2291390"
  },
  {
    "text": "But the goal is clear? We have to reduce\nthe number of edges that remain by a factor of two.",
    "start": "2291390",
    "end": "2296750"
  },
  {
    "text": " So this is actually a new\nproof of this algorithm's",
    "start": "2296750",
    "end": "2303470"
  },
  {
    "text": "performance. The proof in the original\npapers is pretty complicated. This is a very\nintuitive, neat proof.",
    "start": "2303470",
    "end": "2312770"
  },
  {
    "text": "So the first line\nof the proof says if you have a node that\nhas a neighbor that",
    "start": "2312770",
    "end": "2318820"
  },
  {
    "text": "chooses a value that's bigger\nthan all of its own neighbors-- so u has a neighbor w.",
    "start": "2318820",
    "end": "2325005"
  },
  {
    "text": "W chooses a value that's\nbigger than all w's neighbors. But let's say more. Let's say it's also bigger than\nall of u's other neighbors,",
    "start": "2325006",
    "end": "2333220"
  },
  {
    "text": "besides w. So w is really big, bigger\nthan all w's neighbors,",
    "start": "2333220",
    "end": "2339270"
  },
  {
    "text": "bigger than all of\nu's other neighbors. If that happens, then\nwhat happens to u?",
    "start": "2339270",
    "end": "2348240"
  },
  {
    "text": "Well we know that w is going\nto decide to join the MIS. And u is going to\ndefinitely die,",
    "start": "2348240",
    "end": "2356260"
  },
  {
    "text": "is not going to join the MIS. Right? OK? I don't want to lose\npeople in the first line.",
    "start": "2356260",
    "end": "2363920"
  },
  {
    "text": "Question? Here's a picture. Here's u. ",
    "start": "2363920",
    "end": "2371869"
  },
  {
    "text": "And it has a neighbor w. And let's say that w's chosen\nvalue is greater than all",
    "start": "2371870",
    "end": "2380780"
  },
  {
    "text": "of w's neighbors, but\nalso greater than all of u's other neighbors. ",
    "start": "2380780",
    "end": "2387510"
  },
  {
    "text": "Yes? If w has that, w is\ngoing to join the MIS,",
    "start": "2387510",
    "end": "2393160"
  },
  {
    "text": "and u is going to\ndefinitely not join the MIS. It's going to decide\nout in this phase.",
    "start": "2393160",
    "end": "2400470"
  },
  {
    "text": "OK so far? AUDIENCE: Why does you need\nw to have value greater",
    "start": "2400470",
    "end": "2405829"
  },
  {
    "text": "than u's neighbors? Because if w is greater than\nall of its neighbors then it's-- NANCY LYNCH: --be in the MIS\nand u will not be in the MIS.",
    "start": "2405830",
    "end": "2413630"
  },
  {
    "text": "And that seems like\nit ought to be enough. But look at the next line.",
    "start": "2413630",
    "end": "2419240"
  },
  {
    "text": "Well the line after this one. What's the probability that\nw chooses a value like that?",
    "start": "2419240",
    "end": "2424960"
  },
  {
    "text": " So if it's going to be bigger\nthan all u's neighbors, and all",
    "start": "2424960",
    "end": "2431570"
  },
  {
    "text": "of w's neighbors,\nand keeping in mind that they are each\nother's neighbors, turns out that\nthere is degree u,",
    "start": "2431570",
    "end": "2437920"
  },
  {
    "text": "at most degree u plus degree\nw nodes involved here.",
    "start": "2437920",
    "end": "2443410"
  },
  {
    "text": "W has to have the\nbiggest of all of those, so it's going to\nhave the probability",
    "start": "2443410",
    "end": "2448810"
  },
  {
    "text": "1 over the number of nodes\nof being the biggest one. So it's just 1 over\nthe degree of u",
    "start": "2448810",
    "end": "2455540"
  },
  {
    "text": "plus the degree of\nw, the probability that w will choose\na big enough value.",
    "start": "2455540",
    "end": "2461319"
  },
  {
    "start": "2461320",
    "end": "2466580"
  },
  {
    "text": "But you ask, this\nis pessimistic. Why don't I just say that w\nis bigger than its own values?",
    "start": "2466580",
    "end": "2473950"
  },
  {
    "text": "Because I want to\ndo this next step. I want to say the probability\nthat node u gets killed",
    "start": "2473950",
    "end": "2479180"
  },
  {
    "text": "by one of its neighbors, any one\nof its neighbors in this phase.",
    "start": "2479180",
    "end": "2484730"
  },
  {
    "text": "I can calculate that as the sum.  The probability that node\nu is killed by a neighbor",
    "start": "2484730",
    "end": "2492220"
  },
  {
    "text": "is at least the sum over\nall of its neighbors. You look at all the vertices\nin the neighbor set,",
    "start": "2492220",
    "end": "2500240"
  },
  {
    "text": "and you add up this fraction. So why did I need to make that\nadditional assumption before?",
    "start": "2500240",
    "end": "2509090"
  },
  {
    "text": "That w is greater than\nall of u's neighbors, as well as all of\nits own neighbors.",
    "start": "2509090",
    "end": "2514390"
  },
  {
    "text": "Yeah? AUDIENCE: So you can\nadd a problem to-- NANCY LYNCH: Yeah\nbecause otherwise these would be overlapping events.",
    "start": "2514390",
    "end": "2520839"
  },
  {
    "text": "But this way I know they're\ndefinitely disjoint events. We can't have-- if we\nhave w and w prime,",
    "start": "2520840",
    "end": "2526991"
  },
  {
    "text": "you can't have both\nof those holding because the requirement for\nw is saying that its ID is",
    "start": "2526991",
    "end": "2532590"
  },
  {
    "text": "bigger than w prime's ID. Because you have\nthese disjoint events,",
    "start": "2532590",
    "end": "2538790"
  },
  {
    "text": "you can just add\nthe probabilities. And you know that\nthe probability that u gets killed\nby some neighbor",
    "start": "2538790",
    "end": "2545460"
  },
  {
    "text": "is at least this summation. OK so far? So now I'm going to calculate.",
    "start": "2545460",
    "end": "2550740"
  },
  {
    "text": " But I wanted to\nfocus on the edges. So let's see, this tells us a\nway that a node can get killed.",
    "start": "2550740",
    "end": "2558560"
  },
  {
    "text": "But let's look at what happens\nfor an edge getting killed. This is the probability\nthat a node is killed.",
    "start": "2558560",
    "end": "2568230"
  },
  {
    "text": "So the probability that\nan edge dies at this phase is at least the maximum\nof the probability",
    "start": "2568230",
    "end": "2576180"
  },
  {
    "text": "that either of its\ntwo endpoints die.",
    "start": "2576180",
    "end": "2582765"
  },
  {
    "text": "And let's just write\nit as the average. The probability\nthat an edge dies is at least the average\nof the probability",
    "start": "2582766",
    "end": "2589050"
  },
  {
    "text": "that it's two endpoints\nare killed, in this way. ",
    "start": "2589050",
    "end": "2595200"
  },
  {
    "text": "So for an edge, an edge is\ndefinitely going to die, if one of its endpoints dies.",
    "start": "2595200",
    "end": "2600380"
  },
  {
    "text": "And then the edge dies if it\ndies in this particular way. ",
    "start": "2600380",
    "end": "2606109"
  },
  {
    "text": "So the probability an edge dies\nis at least the probability that one of the-- half the\nsum of the probabilities",
    "start": "2606110",
    "end": "2612390"
  },
  {
    "text": "that the two end points die. It's the average probability.",
    "start": "2612390",
    "end": "2618490"
  },
  {
    "text": "Makes sense? You might have to\nread this later. So now we can go from that to\nthe expected number of edges",
    "start": "2618490",
    "end": "2625770"
  },
  {
    "text": "that die. What is that? You just add up, over all,\nthe edges, the probability",
    "start": "2625770",
    "end": "2631110"
  },
  {
    "text": "that the edge dies. The expected number\nof edges that die is at least the sum over all\nof the edges of the probability",
    "start": "2631110",
    "end": "2640910"
  },
  {
    "text": "that the two endpoints die. ",
    "start": "2640910",
    "end": "2649040"
  },
  {
    "text": "So you have the sum,\nover all of the edges. You add up for all the edges. The probability that\none endpoint is killed,",
    "start": "2649040",
    "end": "2656300"
  },
  {
    "text": "and the probability the\nother endpoint is killed. So what we have is this\ngreat big summation",
    "start": "2656300",
    "end": "2662240"
  },
  {
    "text": "involving now the kill\nprobabilities for vertices. So we have the kill\nprobability for each vertex.",
    "start": "2662240",
    "end": "2669050"
  },
  {
    "text": "How many times does that occur? If you have a vertex, u, it\nappears once for every edge",
    "start": "2669050",
    "end": "2678100"
  },
  {
    "text": "that u is an endpoint of. ",
    "start": "2678100",
    "end": "2683200"
  },
  {
    "text": "So you have the kill probability\nfor each node occurring exactly it's degree number of times.",
    "start": "2683200",
    "end": "2690500"
  },
  {
    "text": "So that lets me rewrite\nthis in terms of vertices. This sum is just 1/2 the\nsum over all the nodes",
    "start": "2690500",
    "end": "2698420"
  },
  {
    "text": "of the probability that the node\ngets killed times its degree. ",
    "start": "2698420",
    "end": "2705200"
  },
  {
    "text": "So I'm calculating by\nreplacing the description in terms of edges,\nby description",
    "start": "2705200",
    "end": "2711100"
  },
  {
    "text": "in terms of vertices. More or less OK so far?",
    "start": "2711100",
    "end": "2716779"
  },
  {
    "text": "So now what do I do? Well, I know the probability\nthat u is killed. I have a bound for that\nup on the first line.",
    "start": "2716780",
    "end": "2723900"
  },
  {
    "text": "So I'm just going\nto plug that in. So I get 1/2 the sum\nover all the nodes,",
    "start": "2723900",
    "end": "2729460"
  },
  {
    "text": "the degree of the node times\nthis summation that gives me",
    "start": "2729460",
    "end": "2736320"
  },
  {
    "text": "the kill probability\nfor that node. And now I play\naround with the sum. I can move the degree\ninside the second summation,",
    "start": "2736320",
    "end": "2745170"
  },
  {
    "text": "and I get this. So now let's stare\nat this again. I have the sum over all\nnodes of the sum over all",
    "start": "2745170",
    "end": "2754760"
  },
  {
    "text": "of its neighbors\nof some expression. But if I'm considering a\nnode, every note and every one",
    "start": "2754760",
    "end": "2761702"
  },
  {
    "text": "of its neighbors,\nthat's like considering all the directed edges. I look at every u, and I\nlook at every edge that",
    "start": "2761702",
    "end": "2768760"
  },
  {
    "text": "connects u to something else. So I can write it as the sum\nover all the directed edges",
    "start": "2768760",
    "end": "2774890"
  },
  {
    "text": "of this expression. So I get half of\nthe sum over all the",
    "start": "2774890",
    "end": "2780160"
  },
  {
    "text": "directed edges of\nthis expression. But we were talking\nabout undirected edges.",
    "start": "2780160",
    "end": "2785245"
  },
  {
    "text": " And the undirected edges\nare being twice here, once",
    "start": "2785245",
    "end": "2792229"
  },
  {
    "text": "for each direction.  I can change this sum to a\nsum over undirected edges.",
    "start": "2792229",
    "end": "2799690"
  },
  {
    "text": "But now I have the two\nendpoints to deal with. So I get the degree of u and\nthe degree of v in the numerator",
    "start": "2799690",
    "end": "2808390"
  },
  {
    "text": "because I'm looking at\nit from the point of view both of the endpoints\nof each edge.",
    "start": "2808390",
    "end": "2813809"
  },
  {
    "text": "Well something\ndrops out, so I have 1/2 the sum over all the\nundirected edges of 1.",
    "start": "2813810",
    "end": "2820860"
  },
  {
    "text": "So that's 1/2 of the\nnumber of undirected edges. ",
    "start": "2820860",
    "end": "2826550"
  },
  {
    "text": "So I don't expect you to\nget every step of this, but it's on three\nslides, so you can stare at this when you go home\nand make sure the steps work.",
    "start": "2826550",
    "end": "2834250"
  },
  {
    "text": "But remember the\npoint of this is to show that you reduce\nthe number of edges by a factor of two, and it's\ndone and sort of a clever way",
    "start": "2834250",
    "end": "2841640"
  },
  {
    "text": "by counting the kill\nprobabilities of vertices. ",
    "start": "2841640",
    "end": "2850700"
  },
  {
    "text": "So we get this, reducing\nthe number of edges. And now we can just\nplug that back in",
    "start": "2850700",
    "end": "2855910"
  },
  {
    "text": "to get our complexity bound\nfor the entire algorithm.",
    "start": "2855910",
    "end": "2861072"
  },
  {
    "text": "Remember the original theorem\nyou're we were to prove is a probability bound for\ndeciding within log n phases.",
    "start": "2861072",
    "end": "2867740"
  },
  {
    "text": "Well you should have\na pretty good idea of why that works\nbecause if at each phase, you're going to reduce\nthe number of edges",
    "start": "2867740",
    "end": "2873120"
  },
  {
    "text": "by around a factor\nof two, then it's going to take something\nlike log n phases to finish.",
    "start": "2873120",
    "end": "2880530"
  },
  {
    "text": "And I just put a proof sketch.  The number of edges that are\nstill alive after four log n",
    "start": "2880530",
    "end": "2887710"
  },
  {
    "text": "phases, well you divide\nby 2 four log n times, so you get down to\npractically nothing.",
    "start": "2887710",
    "end": "2893310"
  },
  {
    "text": "The probability any edges are\nalive at the end is very small.",
    "start": "2893310",
    "end": "2899690"
  },
  {
    "text": "So you get a small probability\nthe algorithm doesn't terminate within four log n phases.",
    "start": "2899690",
    "end": "2906700"
  },
  {
    "text": "There's an extra little\nterm I threw in here. You might have forgotten. There was a term that I needed\nfor the small probability,",
    "start": "2906700",
    "end": "2913030"
  },
  {
    "text": "that somebody chose\nduplicate IDs. So I'm bringing them\nback in at the end, in a little union bound.",
    "start": "2913030",
    "end": "2920430"
  },
  {
    "text": "And we get our 1 over\nn probability this way. But the key idea is you\nreduce the number of edges",
    "start": "2920430",
    "end": "2925940"
  },
  {
    "text": "by half at each stage. Enough for you to look at later,\nI guess to figure this out",
    "start": "2925940",
    "end": "2932789"
  },
  {
    "text": "or you have any\nquestions about this? So that's the last\nequations and calculation.",
    "start": "2932790",
    "end": "2940190"
  },
  {
    "text": "I'm going to go onto a new\nidea, more conceptual stuff.",
    "start": "2940190",
    "end": "2946470"
  },
  {
    "text": "Familiar problem,\nbreadth-first spanning trees, setting up breadth-first\npaths to every node,",
    "start": "2946470",
    "end": "2954070"
  },
  {
    "text": "but we're going to study\nit in our new setting.",
    "start": "2954070",
    "end": "2959130"
  },
  {
    "text": "We have a connected graph. This time, let's suppose that\nit has a distinguished vertex,",
    "start": "2959130",
    "end": "2964390"
  },
  {
    "text": "like it already has a leader. So it has a distinguished\nvertex in the graph that's going to become\nthe root of the BFS tree.",
    "start": "2964390",
    "end": "2971930"
  },
  {
    "text": " And the processes don't\nneed any knowledge",
    "start": "2971930",
    "end": "2977619"
  },
  {
    "text": "about the graph for this one. ",
    "start": "2977620",
    "end": "2984930"
  },
  {
    "text": "For the rest of the\ntime today and Thursday, we'll assume the processes\nhave unique identifiers,",
    "start": "2984930",
    "end": "2991250"
  },
  {
    "text": "and I don't think we're\nusing any probabilities. So this is just going to be\nusing the unique identifiers",
    "start": "2991250",
    "end": "2996970"
  },
  {
    "text": "to solve our problems. So everybody knows its\nown unique identifier.",
    "start": "2996970",
    "end": "3002700"
  },
  {
    "text": "The root has a distinguished,\ngenerally known, unique identifier say i0.",
    "start": "3002700",
    "end": "3008720"
  },
  {
    "text": "And the process that\nhas i0 knows hey, I'm at the root of the graph. So the set up make sense?",
    "start": "3008720",
    "end": "3014380"
  },
  {
    "text": " We might as well\nassume that everybody knows the unique identifiers\nof their neighbors",
    "start": "3014380",
    "end": "3021710"
  },
  {
    "text": "because they could easily\nexchange information now, and match up who's\nconnected on which port",
    "start": "3021710",
    "end": "3027200"
  },
  {
    "text": "by a unique identifier.  We'll just do deterministic.",
    "start": "3027200",
    "end": "3033499"
  },
  {
    "text": "There'll be a little bit\nof non-determinism here. I'll say more about that. But I'm not going to worry\nabout probabilities for this.",
    "start": "3033499",
    "end": "3042470"
  },
  {
    "text": "Well that told you\nabout the general setup. What are the processes\nsupposed to do?",
    "start": "3042470",
    "end": "3047880"
  },
  {
    "text": "Well they're supposed to compute\na breadth-first spanning tree, rooted at vertex v0.",
    "start": "3047880",
    "end": "3053210"
  },
  {
    "text": "The branches are\ngoing to be directed paths in this undirected\ngraph, coming from v0.",
    "start": "3053210",
    "end": "3060039"
  },
  {
    "text": "Spanning means they should\nreach all the vertices. And breadth-first means that\nif a vertex is at a distance",
    "start": "3060040",
    "end": "3066370"
  },
  {
    "text": "d from v0, it will appear at\ndepth d in this spanning tree.",
    "start": "3066370",
    "end": "3072600"
  },
  {
    "text": "So everybody should get a\nshortest path from the root.",
    "start": "3072600",
    "end": "3077910"
  },
  {
    "text": "Now how are we going to compute\nthis in a distributed setting? Well now the output\nof a process is just",
    "start": "3077910",
    "end": "3083400"
  },
  {
    "text": "going to be its\nparent in the tree. So we're not actually going\nto compute this tree anywhere",
    "start": "3083400",
    "end": "3089590"
  },
  {
    "text": "as a whole. Everybody's just going to\nknow its parent in the tree. ",
    "start": "3089590",
    "end": "3097809"
  },
  {
    "text": "Questions? Problem make sense? ",
    "start": "3097810",
    "end": "3103920"
  },
  {
    "text": "So this is just an example\nof a spanning tree, breadth-first spanning tree. This gives you shortest\npaths to all of the nodes, ,",
    "start": "3103920",
    "end": "3113000"
  },
  {
    "text": "shortest in terms of\nthe number of hops. ",
    "start": "3113000",
    "end": "3118599"
  },
  {
    "text": "So we can have a very,\nvery simple algorithm. We're going to let the processes\nmark themselves as they",
    "start": "3118600",
    "end": "3126270"
  },
  {
    "text": "get included in the tree. Starts out only the first\nprocess, i0, is marked.",
    "start": "3126270",
    "end": "3132970"
  },
  {
    "text": "So do you want to give an idea,\nmaybe, of how this might work? Sketch out-- yeah?",
    "start": "3132970",
    "end": "3139421"
  },
  {
    "text": "AUDIENCE: The root will\nsend out to its neighbors. And they will then\nmark themselves as the parent of\nwhoever they heard from.",
    "start": "3139421",
    "end": "3145408"
  },
  {
    "text": "Then they will-- NANCY LYNCH: This\nis all synchronous. So that's great. They'll be doing this\nin synchronous rounds.",
    "start": "3145408",
    "end": "3151720"
  },
  {
    "text": "So everybody will, at\nthe certain distance, is going to get the message\nat the right number of rounds",
    "start": "3151720",
    "end": "3157790"
  },
  {
    "text": "to mark their distance. OK so in round one,\nprocess i0 will",
    "start": "3157790",
    "end": "3165000"
  },
  {
    "text": "send a special\nmessage, say search, to all of its neighbors.",
    "start": "3165000",
    "end": "3170660"
  },
  {
    "text": "And anybody who receives\na message in round one will mark itself,\ndecide i0 is its parent,",
    "start": "3170660",
    "end": "3177320"
  },
  {
    "text": "could output that i0 is\nmy parent, parent i0. And then it can get\nready for the next round,",
    "start": "3177320",
    "end": "3183970"
  },
  {
    "text": "when it's supposed to\nsend to continue this.",
    "start": "3183970",
    "end": "3189210"
  },
  {
    "text": "So at later rounds, if you\ndecided you're going to send, if you know you're supposed to\nsend from the previous round,",
    "start": "3189210",
    "end": "3196070"
  },
  {
    "text": "then you send a search message\nto all of your neighbors. Now the process is\nsitting there and it",
    "start": "3196070",
    "end": "3202530"
  },
  {
    "text": "receives a search message. If he's already marked, then he\nshould just ignore the message.",
    "start": "3202530",
    "end": "3210340"
  },
  {
    "text": "Once you're included\nin the tree, you don't care if you\nget other messages, search messages on other paths.",
    "start": "3210340",
    "end": "3217839"
  },
  {
    "text": "So you only do anything\nif you're not yet marked and you receive a message.",
    "start": "3217840",
    "end": "3223119"
  },
  {
    "text": "And in that case, then\nyou mark yourself.  Then you mark\nyourself, and then you",
    "start": "3223120",
    "end": "3229970"
  },
  {
    "text": "choose one of your neighbors\nas to be your parent. Now because this\nis synchronous, you",
    "start": "3229970",
    "end": "3235920"
  },
  {
    "text": "have several nodes that could\nbe sending at the same time. So one node could be\nreceiving search messages",
    "start": "3235920",
    "end": "3242280"
  },
  {
    "text": "from several different\nneighbors at once. Well, it wants to choose\none of them as its parent,",
    "start": "3242280",
    "end": "3247660"
  },
  {
    "text": "doesn't matter which\none it chooses. So it can just choose\nnondeterminstically just",
    "start": "3247660",
    "end": "3253000"
  },
  {
    "text": "arbitrarily. And then it decides that it\nwill send the next round.",
    "start": "3253000",
    "end": "3259932"
  },
  {
    "text": "Is the algorithm clear? ",
    "start": "3259932",
    "end": "3266770"
  },
  {
    "text": "So there's, I mentioned, a\nlittle bit of nondeterministic here, only in that a process\ncan choose arbitrarily",
    "start": "3266770",
    "end": "3271970"
  },
  {
    "text": "among several possible parents.  And then we could\nput in a default,",
    "start": "3271970",
    "end": "3278490"
  },
  {
    "text": "saying that it chooses the\none with the smallest ID, if we really want to\nmake it deterministic. But it's also OK to leave\ndistributed algorithms",
    "start": "3278490",
    "end": "3285542"
  },
  {
    "text": "nondeterministic.  And here I should\nmake a remark that",
    "start": "3285542",
    "end": "3291530"
  },
  {
    "text": "shows how differently\nnondeterminism is regarded in the\ndistributed setting,",
    "start": "3291530",
    "end": "3296910"
  },
  {
    "text": "from the way it is for\nsequential algorithms. For distributed algorithms,\nthere can be many options.",
    "start": "3296910",
    "end": "3303410"
  },
  {
    "text": "And maybe they're all OK. But the algorithm is\nsupposed to work correctly, no matter how you resolve\nthe nondeterministic choices.",
    "start": "3303410",
    "end": "3312960"
  },
  {
    "text": "So think about like\nnp, and the other ways that you've seen\nnondeterminism so far.",
    "start": "3312960",
    "end": "3318160"
  },
  {
    "text": "There you say you're lucky if\nthere is a path to a choice. Here when you make a\nnondeterministic choice,",
    "start": "3318160",
    "end": "3324200"
  },
  {
    "text": "or when the algorithm\nbehaves nondeterministically, all the choices are\nsupposed to work. It's like all the paths have to\ncome up with correct answers.",
    "start": "3324200",
    "end": "3330890"
  },
  {
    "text": "Do you have a question? AUDIENCE: Yes, whenever\nthere's a sub- [INAUDIBLE], whenever there's\na race condition,",
    "start": "3330890",
    "end": "3336740"
  },
  {
    "text": "we locally assume that\nthere wasn't a difference in local computation time. But if there is, even\nin the slightest,",
    "start": "3336740",
    "end": "3342829"
  },
  {
    "text": "then they would get a parent\n[INAUDIBLE] before another one, it would still be a valid-- NANCY LYNCH: So the\nsynchronous model",
    "start": "3342830",
    "end": "3348670"
  },
  {
    "text": "is more abstract than that. You don't model the\nlocal computation time. You're moving more toward\nan asynchronous model,",
    "start": "3348670",
    "end": "3354660"
  },
  {
    "text": "where the steps can take\ndiffering amounts of time. Here we just assume you have\nan abstract model, where",
    "start": "3354660",
    "end": "3361250"
  },
  {
    "text": "everybody does stuff\nat once, in each round. But you still have\nnondeterminism because they can all arrive\nat the same round somewhere.",
    "start": "3361250",
    "end": "3371559"
  },
  {
    "text": "But it's OK. You can pick any one\nand it still works. ",
    "start": "3371560",
    "end": "3377560"
  },
  {
    "text": "So it should be not hard to\nsee that this does give you a BFS tree because you're\ncreating all the branches",
    "start": "3377560",
    "end": "3383830"
  },
  {
    "text": "synchronously. And you're growing\none hop at each round. It reaches all the\nnodes eventually",
    "start": "3383830",
    "end": "3390690"
  },
  {
    "text": "because the graph is connected. And everybody sends messages\nonce a node get marked.",
    "start": "3390690",
    "end": "3396400"
  },
  {
    "text": "It sends messages\nto its neighbors. So eventually, the\nmarkings are going to reach all the neighbors,\nall the nodes in the graph.",
    "start": "3396400",
    "end": "3406640"
  },
  {
    "text": "So here's how you get the\nexample I showed before, simple breadth-first search.",
    "start": "3406640",
    "end": "3413460"
  },
  {
    "text": "That's a search message\nsent by this guy. I put it to the\nright of the edge",
    "start": "3413460",
    "end": "3419360"
  },
  {
    "text": "to indicate-- it's kind\nof hard to distinguish. But I put them on\nthe right of the edge",
    "start": "3419360",
    "end": "3424880"
  },
  {
    "text": "from the point of\nview of the sender. So he sends a search message. it gets there.",
    "start": "3424880",
    "end": "3430650"
  },
  {
    "text": "This arrow just indicates\nthat it reached the other end. And this guy has\nchosen the sender,",
    "start": "3430650",
    "end": "3436160"
  },
  {
    "text": "which is the other direction\non the arrow, as its parent. Now the recipient is going\nto send some search messages.",
    "start": "3436160",
    "end": "3445540"
  },
  {
    "text": "So he sends four of them. They all get to the other end. And OK, so all these\nguys now get marked.",
    "start": "3445540",
    "end": "3452770"
  },
  {
    "text": "They're included\nin the BFS tree. And now the next round,\nthey all send some messages.",
    "start": "3452770",
    "end": "3460000"
  },
  {
    "text": "I'm not putting in the messages\nwhere somebody would send back to a guy who sent to him.",
    "start": "3460000",
    "end": "3465970"
  },
  {
    "text": "But I put in all the others. Some of them are\ngoing to be ignored.",
    "start": "3465970",
    "end": "3471350"
  },
  {
    "text": "But you do get to a\nfew new nodes this way. That's round three. Round four, everybody sends.",
    "start": "3471350",
    "end": "3477900"
  },
  {
    "text": "And now you have all\nthe nodes included. ",
    "start": "3477900",
    "end": "3483250"
  },
  {
    "text": "So this gives you\nthe spanning tree that I showed at the\nbeginning of this topic. ",
    "start": "3483250",
    "end": "3492450"
  },
  {
    "text": "This is not a very\ncomplicated algorithm. But I think you can see\nthat things can get worse.",
    "start": "3492450",
    "end": "3497829"
  },
  {
    "text": "And you want to argue about why\nthe algorithms work correctly. So as I said before,\na popular method",
    "start": "3497830",
    "end": "3505970"
  },
  {
    "text": "of reasoning about\nthe algorithms is to state invariance. So here, suppose\nI want to describe",
    "start": "3505970",
    "end": "3512010"
  },
  {
    "text": "the state of the entire\nnetwork, after some number, r, of rounds.",
    "start": "3512010",
    "end": "3517921"
  },
  {
    "text": "what could you say about that? What's the case after r\nrounds of this algorithm? ",
    "start": "3517921",
    "end": "3529010"
  },
  {
    "text": "Yeah. AUDIENCE: All nodes at\ndistance r from the root have been marked.",
    "start": "3529010",
    "end": "3535260"
  },
  {
    "text": "NANCY LYNCH: All the nodes\nat distance r from the root have been marked. In fact, only those by\nround r, only the ones",
    "start": "3535260",
    "end": "3543000"
  },
  {
    "text": "with distances up through\nr have been marked. So to state the invariance, if\nyou want to state invariance,",
    "start": "3543000",
    "end": "3549350"
  },
  {
    "text": "I have to say what's in\nthe state of the processes. So all right, what can we say?",
    "start": "3549350",
    "end": "3554770"
  },
  {
    "text": "So the process has a Boolean\nthat says whether or not it's marked. It has a place to\nrecord a parent.",
    "start": "3554770",
    "end": "3563570"
  },
  {
    "text": "And it has someplace\nwhere it puts information",
    "start": "3563570",
    "end": "3569150"
  },
  {
    "text": "about whether it's\nsupposed to send a message at the next round. And we also should\nknow its UID, so I'll",
    "start": "3569150",
    "end": "3576180"
  },
  {
    "text": "put that in another\nstate variable. So here is something I\ncan say in invariance.",
    "start": "3576180",
    "end": "3583570"
  },
  {
    "text": "At the end of r rounds, as you\nsaid, at the end of r rounds",
    "start": "3583570",
    "end": "3588920"
  },
  {
    "text": "exactly the processes\nat distance at most r from the source node, the\nroot node, are marked.",
    "start": "3588920",
    "end": "3597511"
  },
  {
    "text": "I can say a little more. I can say a process has its\nparents defined if and only",
    "start": "3597511",
    "end": "3602750"
  },
  {
    "text": "if it's marked. So it doesn't just get market. It also computes a\nparent, and the parent",
    "start": "3602750",
    "end": "3608049"
  },
  {
    "text": "gets computed at the point\nwhere it gets marked. Then I should say that\nthe parent is correct.",
    "start": "3608050",
    "end": "3615950"
  },
  {
    "text": "So for any process that's at\ndistance d from the source,",
    "start": "3615950",
    "end": "3621400"
  },
  {
    "text": "if the parent is\ndefined, then it's in fact the UID of a process\nat distance d minus 1",
    "start": "3621400",
    "end": "3626410"
  },
  {
    "text": "from the source. So that says it's\nactually getting a correct breadth-first tree.",
    "start": "3626410",
    "end": "3633590"
  },
  {
    "text": "It's getting the parent\non a shortest path. Yeah? AUDIENCE: Do these invariants\n[INAUDIBLE] for i0?",
    "start": "3633590",
    "end": "3639945"
  },
  {
    "text": " NANCY LYNCH:\nDistance 0 is marked. ",
    "start": "3639946",
    "end": "3647089"
  },
  {
    "text": "i0 doesn't ever-- I\nsee what you're saying.",
    "start": "3647090",
    "end": "3652200"
  },
  {
    "text": "i0 doesn't have a parent. So I guess that we\nshould say for i not equal to i0 in this case.",
    "start": "3652200",
    "end": "3661200"
  },
  {
    "text": "So this would be a\nprocess other than i0. It would have its\nparent defined, if and only if it's marked. Well as I think\nyou just noticed,",
    "start": "3661200",
    "end": "3669180"
  },
  {
    "text": "the root node is marked but\nit doesn't have a parent. So it's an exception.",
    "start": "3669180",
    "end": "3675240"
  },
  {
    "text": "But this should be,\nthis doesn't involve i0. So the second one, I\ncan fix that a bit.",
    "start": "3675240",
    "end": "3682777"
  },
  {
    "text": "Other comments, questions? ",
    "start": "3682777",
    "end": "3687890"
  },
  {
    "text": "So if somebody wanted to\ndo a formal correctness proof of an algorithm\nlike this one,",
    "start": "3687890",
    "end": "3693040"
  },
  {
    "text": "you would use these invariants. You prove it by induction. In fact there's\nquite a few people who use interactive theorem\nprovers to do proofs",
    "start": "3693040",
    "end": "3703030"
  },
  {
    "text": "like this because the algorithms\ncan get pretty complicated, with a lot of variables.",
    "start": "3703030",
    "end": "3708520"
  },
  {
    "text": "So you have to do\nsome bookkeeping. You keep track of\nall these invariants, and then you want to prove that\nthey're all true by induction.",
    "start": "3708520",
    "end": "3715880"
  },
  {
    "text": "They all hold through\nan inductive step. So you can use an\ninteractive theorem prover to help you do the bookkeeping.",
    "start": "3715880",
    "end": "3723540"
  },
  {
    "text": "But even a manual proof\nin a research paper would use invariance\nin this style.",
    "start": "3723540",
    "end": "3728789"
  },
  {
    "text": " OK complexity.",
    "start": "3728790",
    "end": "3734940"
  },
  {
    "text": "So the number of rounds until\neverybody outputs their parent would be the maximum\ndistance of any node from v0.",
    "start": "3734940",
    "end": "3743440"
  },
  {
    "text": "So we can say that's at most\nthe diameter of the graph. It could be less. It's just is the\nmaximum distance from this particular node.",
    "start": "3743440",
    "end": "3751440"
  },
  {
    "text": "Message complexity? Well how many messages are\nsent in this algorithm?",
    "start": "3751440",
    "end": "3758140"
  },
  {
    "text": "So everybody is going\nto send messages only once on all of its edges.",
    "start": "3758140",
    "end": "3763880"
  },
  {
    "text": "So that means all the\nedges get a message sent in each direction just once. So it's order of\nthe number of edges.",
    "start": "3763880",
    "end": "3770255"
  },
  {
    "start": "3770255",
    "end": "3775359"
  },
  {
    "text": "All right, so we can\nplay around with this. So this algorithm just tells\neverybody who his parent is.",
    "start": "3775360",
    "end": "3781560"
  },
  {
    "text": "But maybe when you're\nfinished, you'd like to who your\nchildren are as well. ",
    "start": "3781560",
    "end": "3788400"
  },
  {
    "text": "For many uses of\nthese trees, you'd like to have a parent be\nable to talk to its children",
    "start": "3788400",
    "end": "3794039"
  },
  {
    "text": "in the tree. So how to do that? Well you can add a child\npointer because anybody",
    "start": "3794040",
    "end": "3800079"
  },
  {
    "text": "who gets a search message\nand selects its parents could send back a message\nto that parents saying, hey, I'm your child.",
    "start": "3800080",
    "end": "3806330"
  },
  {
    "text": "And if you get a search message,\nand you decide that that's not your parent, you can\nhelp that guy out",
    "start": "3806330",
    "end": "3811760"
  },
  {
    "text": "by sending a message saying\nyou're not my parent. In the synchronous\ncase, he would just know that, if he didn't\nget a parent message.",
    "start": "3811760",
    "end": "3817864"
  },
  {
    "text": "But things are going to\nget more complicated. So we'll send parents\nor non parent responses",
    "start": "3817864",
    "end": "3823517"
  },
  {
    "text": "to the search messages. ",
    "start": "3823517",
    "end": "3829770"
  },
  {
    "text": "Suppose we want to compute\nthe distances from v0, not just to the parents are. Well that's easy.",
    "start": "3829770",
    "end": "3835309"
  },
  {
    "text": "Everybody can just record\nits distances, as well as its parent and the mark.",
    "start": "3835310",
    "end": "3841670"
  },
  {
    "text": "And then you just include\nyour own distance value in your search message. And when somebody\nreceives a search message,",
    "start": "3841670",
    "end": "3849339"
  },
  {
    "text": "it sets its own distance to\nthe received distance plus 1. So we can just keep track\nand add one to the distance.",
    "start": "3849340",
    "end": "3857750"
  },
  {
    "text": "It's easy to augment\nthis algorithm to get this extra information. ",
    "start": "3857750",
    "end": "3864630"
  },
  {
    "text": "All right, now how\ndo the processes know when this is all finished? ",
    "start": "3864630",
    "end": "3870140"
  },
  {
    "text": "So everybody was able\nto output parent. I know who my parent is. But how does anybody\nknow when the entire tree",
    "start": "3870140",
    "end": "3876870"
  },
  {
    "text": "has been produced? Not so obvious.",
    "start": "3876870",
    "end": "3882820"
  },
  {
    "text": "So in some settings, you\nmight know an upper bound on the depth of the tree.",
    "start": "3882820",
    "end": "3888350"
  },
  {
    "text": "And then you could just wait\nfor that number of rounds. But what if you don't know that? You don't know anything\nabout the graph.",
    "start": "3888350",
    "end": "3894476"
  },
  {
    "text": "Nobody knows. So let's come up\nwith an algorithm for process i0, the root,\nto know definitively",
    "start": "3894476",
    "end": "3904660"
  },
  {
    "text": "that the tree has been\ncompletely constructed. Ideas? ",
    "start": "3904660",
    "end": "3914099"
  },
  {
    "text": "You're creating this\nby search messages. How is i0 going to\nknow when its done? ",
    "start": "3914100",
    "end": "3925871"
  },
  {
    "text": "Yeah. AUDIENCE: Every time\nyou mark a node, the node can send a\nmessage back to its parent, saying hi, I've been marked. Then you can probably get\nall the way back to the root.",
    "start": "3925872",
    "end": "3933154"
  },
  {
    "text": "And then the root can count\nthe number of-- actually, no if the root doesn't-- NANCY LYNCH: Root doesn't\nknow the number of nodes.",
    "start": "3933154",
    "end": "3939985"
  },
  {
    "text": "So that's a good idea. AUDIENCE: If you\ndon't have a child, you can tell your parent\nthat you don't have a child.",
    "start": "3939985",
    "end": "3945507"
  },
  {
    "text": " NANCY LYNCH: That's\na good start. Was there another?",
    "start": "3945507",
    "end": "3951230"
  },
  {
    "text": "Yeah. AUDIENCE: More\ngenerally, you just send a signal when you\nknow your sub-tree is done. NANCY LYNCH: When you know\nyou're sub-tree is done,",
    "start": "3951230",
    "end": "3958010"
  },
  {
    "text": "so that means you're going\nto be communicating something up the tree. Right, so that's the idea\nthat you're working toward.",
    "start": "3958010",
    "end": "3965640"
  },
  {
    "text": "So a termination\nalgorithm to inform i0 when the tree is\ncompletely constructed.",
    "start": "3965640",
    "end": "3971550"
  },
  {
    "text": "So let's say that the search\nmessages get their responses. So everybody knows\nwhich nodes are their,",
    "start": "3971550",
    "end": "3977700"
  },
  {
    "text": "which neighbors are its\nchildren, and which are not. So suppose a node\nhas gotten responses",
    "start": "3977700",
    "end": "3984810"
  },
  {
    "text": "to all of its search messages,\nknows who all its children are.",
    "start": "3984810",
    "end": "3990830"
  },
  {
    "text": "Now the leaves in\nthis tree are going to know that they're leaves. How do they know that?",
    "start": "3990830",
    "end": "3997880"
  },
  {
    "text": "Propagating all these search\nmessages, and I'm a leaf. How do I know I'm a leaf?",
    "start": "3997880",
    "end": "4003524"
  },
  {
    "text": "AUDIENCE: You can't\nhave children. NANCY LYNCH: Yeah, you send\nall these search messages, and everybody says, sorry\nyou're not my parent.",
    "start": "4003524",
    "end": "4011809"
  },
  {
    "text": "So you know you have no\nchildren because of the kind of responses you get.",
    "start": "4011810",
    "end": "4017140"
  },
  {
    "text": "So now we're going\nto use what we call a convergecast strategy. Broadcast is sending things out.",
    "start": "4017140",
    "end": "4023160"
  },
  {
    "text": "Convergecast is fanning\nin information back to the top of the tree.",
    "start": "4023160",
    "end": "4029560"
  },
  {
    "text": "So the convergecast\nwould say, all right, so the leaves would send\na message to their parents",
    "start": "4029560",
    "end": "4035200"
  },
  {
    "text": "saying they're done. Now if I'm some node in\nthe middle of the tree,",
    "start": "4035200",
    "end": "4043600"
  },
  {
    "text": "how do I know I'm done? Well it's what you said. You know that you\ncan figure out when",
    "start": "4043600",
    "end": "4051750"
  },
  {
    "text": "your entire sub-tree is done. Well first of all, you have\nto know your children are.",
    "start": "4051750",
    "end": "4057750"
  },
  {
    "text": "It's kind of a\ntwo stage process. You have to know who\nyour children are, by having received responses\nto all your search messages.",
    "start": "4057750",
    "end": "4066530"
  },
  {
    "text": "And you wait to receive\ndone messages from all of your actual children. So if I'm sitting in\nthe middle of the tree,",
    "start": "4066530",
    "end": "4073080"
  },
  {
    "text": "and I've got done messages\nfrom all my children, I know my whole\nsub-tree is done. Then I can send the done\nmessage to my parent.",
    "start": "4073080",
    "end": "4082140"
  },
  {
    "text": "Got that? That's how convergecast works. And when it reaches\nthe top, if i0",
    "start": "4082140",
    "end": "4089690"
  },
  {
    "text": "knows who its children are,\nand it receives done messages from all its children, it\nknows the whole tree is done.",
    "start": "4089690",
    "end": "4095540"
  },
  {
    "text": "So it can output that the\ntree construction is complete. And it could tell\nthe others by sending",
    "start": "4095540",
    "end": "4102420"
  },
  {
    "text": "a message down the tree,\nso they all know as well. Questions? AUDIENCE: Wouldn't i0\nbe the last one to know?",
    "start": "4102420",
    "end": "4112673"
  },
  {
    "text": "NANCY LYNCH: He'd\nbe the last one. No, he'd be the first one to\nknow that the whole tree is complete.",
    "start": "4112674",
    "end": "4118670"
  },
  {
    "text": "Everybody else knows when\ntheir sub-tree is complete. So i0 still has to now send\nanother message down the tree",
    "start": "4118670",
    "end": "4125410"
  },
  {
    "text": "to tell everyone else the\nentire tree is complete. Is there another question? ",
    "start": "4125410",
    "end": "4132289"
  },
  {
    "text": "All right so this\nisn't showing that. This is just showing done\nmessages, which are actually going in the opposite\ndirection from these edges,",
    "start": "4132289",
    "end": "4138559"
  },
  {
    "text": "going up the tree. But you can just see\nhow they propagate up until the roots says done.",
    "start": "4138560",
    "end": "4144670"
  },
  {
    "text": "No big deal.  Complexity for termination.",
    "start": "4144670",
    "end": "4150818"
  },
  {
    "text": "Well it just takes at most\ndiameter rounds and n messages for this done information\nto come up to the top,",
    "start": "4150819",
    "end": "4156880"
  },
  {
    "text": "once the tree\nactually is finished. Because now you're\njust sending messages on the paths in this\ntree, which are only,",
    "start": "4156880",
    "end": "4165130"
  },
  {
    "text": "at most, diameter in length. And this is just the process\ni0 can tell everybody else.",
    "start": "4165130",
    "end": "4172920"
  },
  {
    "text": "It doesn't take\nvery long either.  Applications, well suppose you\nconstruct a tree like this.",
    "start": "4172920",
    "end": "4181149"
  },
  {
    "text": "And process i0 now wants\nto use it to communicate. It wants to send a\nwhole batch of messages",
    "start": "4181149",
    "end": "4186450"
  },
  {
    "text": "to all the other nodes. It can just send\nthem now on the tree. It's an easy way to\nmake sure messages reach",
    "start": "4186450",
    "end": "4192790"
  },
  {
    "text": "everybody else in the network. Just send them on the edges\nof the breadth-first spanning tree.",
    "start": "4192790",
    "end": "4199580"
  },
  {
    "text": "So now the messages,\neach individual message takes at most n\nmessage instances",
    "start": "4199580",
    "end": "4207369"
  },
  {
    "text": "along the edges of the\ntree, because you only have to traverse the tree edges. No more dependence on the total\nnumber of edges in the network.",
    "start": "4207370",
    "end": "4215920"
  },
  {
    "text": "And in fact, you can\nsave time by pipelining a series of messages. So you can send them one\nround after the other.",
    "start": "4215920",
    "end": "4223409"
  },
  {
    "text": " The other way, suppose you want\nto compute something globally.",
    "start": "4223410",
    "end": "4231740"
  },
  {
    "text": "Suppose everybody starts\nwith some initial value. And process i0 is going\nto try to determine",
    "start": "4231740",
    "end": "4238590"
  },
  {
    "text": "the value of some function\nof everybody's initial value, like the minimum or maximum\nor the sum or anything.",
    "start": "4238590",
    "end": "4246530"
  },
  {
    "text": "Well you can do this\nwhile convergecasting on an already built BFS tree.",
    "start": "4246530",
    "end": "4252910"
  },
  {
    "text": "So everybody can just send\ntheir information up the tree, and i0 can collect it all.",
    "start": "4252910",
    "end": "4258290"
  },
  {
    "text": "In general, you\ncan accumulate, you can do data aggregation as you\ngo up the paths of the tree.",
    "start": "4258290",
    "end": "4264610"
  },
  {
    "text": "So the message size\ndoesn't blow up.",
    "start": "4264610",
    "end": "4269909"
  },
  {
    "text": "So if you want, for example,\nthe sum of everybody's values, everybody just sends their\nvalues up in a convergecast.",
    "start": "4269910",
    "end": "4276260"
  },
  {
    "text": "And each node computes\nthe sum of all the values in its sub-tree.",
    "start": "4276260",
    "end": "4281550"
  },
  {
    "text": "So this is pretty efficient. Make sense?",
    "start": "4281550",
    "end": "4286722"
  },
  {
    "text": "I'm going to skip this. But you could do leader\nelection in a general graph, If you don't have\na leader, already,",
    "start": "4286722",
    "end": "4292469"
  },
  {
    "text": "i0 by having everybody\nrun a breadth-first search in parallel. But we'll skip that. Because I just wanted to\nhave a couple of minutes",
    "start": "4292470",
    "end": "4299400"
  },
  {
    "text": "to start the last topic, and\nwe'll pick it up next time. So it's the obvious extension.",
    "start": "4299400",
    "end": "4307060"
  },
  {
    "text": "Instead of just\nbreadth-first search trees, let's put weights\non the edges and try to compute shortest paths trees\nin terms of the total weight",
    "start": "4307060",
    "end": "4317170"
  },
  {
    "text": "of the path.  So we're going to add weights.",
    "start": "4317170",
    "end": "4324350"
  },
  {
    "text": "It's an undirected graph. So it's just a weight\nfor each undirected edge. ",
    "start": "4324350",
    "end": "4331290"
  },
  {
    "text": "I'll still have a starting\nnode, vertex v0 with process i0.",
    "start": "4331290",
    "end": "4339160"
  },
  {
    "text": "Still have unique identifiers. And I'll assume the processes\nknow who their neighbors are.",
    "start": "4339160",
    "end": "4344670"
  },
  {
    "text": "And they know the\nweights of the incident edges, their adjacent edges. But otherwise they\ndon't need to know",
    "start": "4344670",
    "end": "4351200"
  },
  {
    "text": "anything else about the graph. So again, this is\na familiar problem.",
    "start": "4351200",
    "end": "4356889"
  },
  {
    "text": "But we're looking at it\nin a very different way, by distributing it. ",
    "start": "4356890",
    "end": "4363360"
  },
  {
    "text": "so the processes are supposed to\ncompute a shortest paths tree, in the sense that\neverybody should",
    "start": "4363360",
    "end": "4369960"
  },
  {
    "text": "output its parent in the tree. And let's say they output\nthe distance as well,",
    "start": "4369960",
    "end": "4375440"
  },
  {
    "text": "the weighted distance\nfrom the root node. ",
    "start": "4375440",
    "end": "4383540"
  },
  {
    "text": "So this is called\nBellman-Ford's algorithm. Again it's got the same name\nin the distributed setting.",
    "start": "4383540",
    "end": "4391969"
  },
  {
    "text": "The Bellman-Ford\nshortest paths algorithm. ",
    "start": "4391970",
    "end": "4397230"
  },
  {
    "text": "So everybody is keeping\ntrack of their current best distance that they\nknow, and their parent.",
    "start": "4397230",
    "end": "4403630"
  },
  {
    "text": "And they know their\nunique identifier. And here's how the\nalgorithm works.",
    "start": "4403630",
    "end": "4409040"
  },
  {
    "text": "This will look\nfamiliar from when you had Bellman-Ford earlier.",
    "start": "4409040",
    "end": "4414130"
  },
  {
    "text": "At every round,\neverybody is going to send its distance\nto its neighbors.",
    "start": "4414130",
    "end": "4420752"
  },
  {
    "text": "Instead of just sending\na search message, now it will send its actual\ndistance information.",
    "start": "4420752",
    "end": "4426450"
  },
  {
    "text": "And you receive the messages\nfrom your neighbors. And now you do a relaxation\nstep, as you've seen before.",
    "start": "4426450",
    "end": "4435240"
  },
  {
    "text": "You look at the current\ndistance you have. And you see if you've\ngotten a new distance from a neighbor, such that if\nyou add the new distance you",
    "start": "4435240",
    "end": "4443650"
  },
  {
    "text": "receive to the weight of\nthe edge between yourself and that neighbor, you\nget something better",
    "start": "4443650",
    "end": "4448690"
  },
  {
    "text": "than what you had before. If you get that, then you're\ngoing to improve your distance.",
    "start": "4448690",
    "end": "4454220"
  },
  {
    "text": "And if you improve\nyour distance, then you're going\nto reset your parent to the sender of this new,\nbetter distance information.",
    "start": "4454220",
    "end": "4464719"
  },
  {
    "text": "So does this\nalgorithm make sense? It's like what you saw before. But there's no running\nthrough all the nodes.",
    "start": "4464720",
    "end": "4472470"
  },
  {
    "text": "Each node is doing\nits own thing. It's waiting to get better\ndistance information and re-computing.",
    "start": "4472470",
    "end": "4479100"
  },
  {
    "text": "And then it's going to\nbe sending out its better information at the next round. ",
    "start": "4479100",
    "end": "4486100"
  },
  {
    "text": "Question? So this is kind of a jump\nin the way of thinking. ",
    "start": "4486100",
    "end": "4494060"
  },
  {
    "text": "All right, so now I'm just\ngoing to end basically with an animation that'll\nshow you the kinds of things",
    "start": "4494060",
    "end": "4499560"
  },
  {
    "text": "that happen here. All right so you start\nout with the initial node.",
    "start": "4499560",
    "end": "4507100"
  },
  {
    "text": "And what's recorded in the\ncircle is the best distances. The rest of these, the best\ndistance they know is infinity.",
    "start": "4507100",
    "end": "4514522"
  },
  {
    "text": "So I didn't write that. So this guy knows 0 After one\nround, he sent two messages.",
    "start": "4514522",
    "end": "4523470"
  },
  {
    "text": "The best distance each\nof these guys knows is just the weight of the\nedge between v0 and itself.",
    "start": "4523470",
    "end": "4530360"
  },
  {
    "text": "So this guy's now estimating\nit's distance at 16 and this guy at 1.",
    "start": "4530360",
    "end": "4536080"
  },
  {
    "text": "16 is not very good because it's\nactually very roundabout routes that can get there. But it's going to take us some\ntime to make that adjustment.",
    "start": "4536080",
    "end": "4545310"
  },
  {
    "text": "After two rounds, everybody\nis sending their distance information.",
    "start": "4545310",
    "end": "4550880"
  },
  {
    "text": "But now we get a\ncorrection here. This used to say 16.",
    "start": "4550880",
    "end": "4557110"
  },
  {
    "text": "But now we have a\ntwo hop path that gives you a better distance.",
    "start": "4557110",
    "end": "4562170"
  },
  {
    "text": "So you get the 1 plus the 14. So he's going to here,\nabout the distance of 15",
    "start": "4562170",
    "end": "4568850"
  },
  {
    "text": "as a result of what 1 sends. And some new guys get their\ndistance is calculated",
    "start": "4568850",
    "end": "4576740"
  },
  {
    "text": "And then after three rounds, it\ngets a little bit complicated. So maybe I'm just going to\nflip through it quickly and let",
    "start": "4576740",
    "end": "4584910"
  },
  {
    "text": "you study later. But you see that you keep\ngetting improvements, as you perform relaxation steps.",
    "start": "4584910",
    "end": "4592389"
  },
  {
    "text": "As information gets to\nsomebody by better paths that happen to have\nmore hops, they're",
    "start": "4592390",
    "end": "4598680"
  },
  {
    "text": "going to be reducing\ntheir estimates. I'm going to flip, and you\nsee that this guy's estimate",
    "start": "4598680",
    "end": "4604640"
  },
  {
    "text": "is going down. And in the end, after\neight rounds of this,",
    "start": "4604640",
    "end": "4609920"
  },
  {
    "text": "you end up with a\nvery roundabout path that actually gives this\nguy a much better estimate.",
    "start": "4609920",
    "end": "4616430"
  },
  {
    "text": "So you can see how that works.  So the claim is that\neventually, every process",
    "start": "4616430",
    "end": "4623660"
  },
  {
    "text": "will have its distance being\na correct minimum weight of the path, and its\nparent will be correct.",
    "start": "4623660",
    "end": "4632710"
  },
  {
    "text": "I think maybe this is\na good place to stop. We'll pick up with this\nalgorithm and its analysis.",
    "start": "4632710",
    "end": "4637810"
  },
  {
    "text": "Most of next time\nis going to be spent on asynchronous\nalgorithms, which is a whole other\nlevel of complication.",
    "start": "4637810",
    "end": "4645560"
  },
  {
    "text": "So I'll see you on Thursday. ",
    "start": "4645560",
    "end": "4653278"
  }
]