[
  {
    "start": "0",
    "end": "40000"
  },
  {
    "text": "[SQUEAKING]\n[RUSTLING] [CLICKING]",
    "start": "0",
    "end": "12580"
  },
  {
    "text": "ERIK DEMAINE: All right, welcome\nback to 006 Data Structures. Today, we're going to\ncover a different kind",
    "start": "12580",
    "end": "19330"
  },
  {
    "text": "of tree-like data structure\ncalled a heap-- a binary heap. It's going to let us solve\nsorting problem in a new way.",
    "start": "19330",
    "end": "26710"
  },
  {
    "text": "Let me first remind\nyou of a portion-- the problem we're going\nto be solving today",
    "start": "26710",
    "end": "32020"
  },
  {
    "text": "is called priority queue. This is the interface. We'll see several\ndata structures, but one main data\nstructure for today.",
    "start": "32020",
    "end": "40070"
  },
  {
    "start": "40000",
    "end": "178000"
  },
  {
    "text": "And this is a subset\nof the set interface. ",
    "start": "40070",
    "end": "47230"
  },
  {
    "text": "And subsets are interesting\nbecause, potentially, we can solve them better,\nfaster, simpler, something.",
    "start": "47230",
    "end": "53750"
  },
  {
    "text": "And so you'll recognize--\nyou should recognize all of these operations,\nexcept we didn't normally",
    "start": "53750",
    "end": "60670"
  },
  {
    "text": "highlight the max operation. So here, we're interested\nin storing a bunch of items.",
    "start": "60670",
    "end": "66190"
  },
  {
    "text": "They have keys which we\nthink of as priorities. And we want to be able to\nidentify the maximum priority",
    "start": "66190",
    "end": "73840"
  },
  {
    "text": "item in our set and remove it. And so there's lots of\nmotivations for this.",
    "start": "73840",
    "end": "79250"
  },
  {
    "text": "Maybe you have a router,\npackets going into the router. They have different\npriorities assigned to them. You want to route the\nhighest priority first.",
    "start": "79250",
    "end": "85090"
  },
  {
    "text": "Or you have processes\non your computer trying to run on your single\nthreaded-- single core,",
    "start": "85090",
    "end": "92620"
  },
  {
    "text": "and you've got to choose\nwhich one to run next. And you usually run higher\npriority processes first.",
    "start": "92620",
    "end": "97840"
  },
  {
    "text": "Or you're trying to simulate\na system where events happen at different times,\nand you want to process",
    "start": "97840",
    "end": "104800"
  },
  {
    "text": "the next event ordered by time. All of these are examples of\nthe priority queue interface.",
    "start": "104800",
    "end": "110470"
  },
  {
    "text": "We'll even see applications\nwithin this class when we get to graph algorithms. But the main two things we\nwant to be able to support",
    "start": "110470",
    "end": "116740"
  },
  {
    "text": "are inserting an item,\nwhich includes a key, and leading the maximum\nitem, and also returning it",
    "start": "116740",
    "end": "121930"
  },
  {
    "text": "at the same time. We'll also talk some about being\nable to build the structure",
    "start": "121930",
    "end": "127600"
  },
  {
    "text": "faster than just inserting it. But of course, we\ncould implement build by starting empty\nand repeatedly inserting.",
    "start": "127600",
    "end": "134260"
  },
  {
    "text": "And also the complexity\nof just finding the max without deleting it, this you\ncould simulate with these two",
    "start": "134260",
    "end": "140410"
  },
  {
    "text": "operations by deleting the\nmax and then reinserting it, which works.",
    "start": "140410",
    "end": "145930"
  },
  {
    "text": "But often, we can do faster. But the two key, main operations\nare insert and delete max.",
    "start": "145930",
    "end": "152470"
  },
  {
    "text": "And we're going to see a few\ndata structures to do this. Any suggestions among\nthe data structures",
    "start": "152470",
    "end": "159717"
  },
  {
    "text": "we've seen in this class? What should we use to solve\npriority queue interface?",
    "start": "159718",
    "end": "165603"
  },
  {
    "start": "165604",
    "end": "173840"
  },
  {
    "text": "Many possible answers.  AUDIENCE: Sequence AVL? ERIK DEMAINE: Sequence AVL?",
    "start": "173840",
    "end": "179965"
  },
  {
    "start": "178000",
    "end": "295000"
  },
  {
    "text": "Ooh, that's interesting! Sequence AVL is a good answer,\nbut maybe the fancier version.",
    "start": "179965",
    "end": "187030"
  },
  {
    "text": "Yeah? AUDIENCE: Set AVL? ERIK DEMAINE: Set\nAVL sounds good. Set AVL supports these\noperations and many more.",
    "start": "187030",
    "end": "194090"
  },
  {
    "text": "All in log n time except for\nbuild, which takes n log n time because you have to sort first.",
    "start": "194090",
    "end": "200980"
  },
  {
    "text": "So set AVL a good\nway to do this. We'll come back to your\nsequence AVL idea later.",
    "start": "200980",
    "end": "207580"
  },
  {
    "text": "This gets log n for operation. Great. I mean, this is--",
    "start": "207580",
    "end": "213310"
  },
  {
    "text": "set AVL is our most\npowerful data structure. It does all the operations we\ncare about on the set side.",
    "start": "213310",
    "end": "218407"
  },
  {
    "text": "And the sequence AVL\ndoes all the operations on the sequence side. But note that this is\na set, not a sequence. We care about keys.",
    "start": "218407",
    "end": "224349"
  },
  {
    "text": "There are hacks to get around\nthat with sequence AVLs, but let's do that later.",
    "start": "224350",
    "end": "230420"
  },
  {
    "text": "So great, if we wanted\nto, for example, speed up find_max in a set AVL.",
    "start": "230420",
    "end": "235840"
  },
  {
    "text": "We could add augmentation. We could-- remember subtree\nproperty augmentations?",
    "start": "235840",
    "end": "245410"
  },
  {
    "text": "We can use that to get\nconstant time find_max",
    "start": "245410",
    "end": "250600"
  },
  {
    "text": "by storing in every node\nthe maximum key item within the subtree. And that's a subtree property.",
    "start": "250600",
    "end": "256850"
  },
  {
    "text": "It's one we\nmentioned last class. So we could even improve\nthat to cut some time. Great.",
    "start": "256850",
    "end": "262690"
  },
  {
    "text": "So we're done. End of lecture. [CHUCKLES] In some\nsense, that's true. But what we're\ngoing to see today",
    "start": "262690",
    "end": "268540"
  },
  {
    "text": "is another data structure\ncalled a binary heap, which is, in some sense, a\nsimplification of set AVL.",
    "start": "268540",
    "end": "274780"
  },
  {
    "text": "It achieves basically\nthe same time bounds. Build will be faster\nby a log factor.",
    "start": "274780",
    "end": "281240"
  },
  {
    "text": "But that's not the main\nreason we care about them. The main advantage is\nthat they're simpler",
    "start": "281240",
    "end": "286960"
  },
  {
    "text": "and they give us an\nin-place sorting algorithm. ",
    "start": "286960",
    "end": "294220"
  },
  {
    "text": "So I have up here\nthree of the operations I've been talking about--\nbuild, insert, and delete_max.",
    "start": "294220",
    "end": "301120"
  },
  {
    "start": "295000",
    "end": "345000"
  },
  {
    "text": "So we have set AVL trees there--\nn log n build, log n insert, log n delete.",
    "start": "301120",
    "end": "307180"
  },
  {
    "text": "So along the way to our heap, I\nwant to mention two other data",
    "start": "307180",
    "end": "312310"
  },
  {
    "text": "structures. One is a dynamic\nbut unsorted array.",
    "start": "312310",
    "end": "318010"
  },
  {
    "text": "And the other is a\ndynamic sorted array. ",
    "start": "318010",
    "end": "325850"
  },
  {
    "text": "These are simpler\ndata structures we've talked about\nmany times before. And they're useful kind\nof motivations for getting",
    "start": "325850",
    "end": "332000"
  },
  {
    "text": "started, because a heap is going\nto be built on top of arrays instead of--",
    "start": "332000",
    "end": "338060"
  },
  {
    "text": "well, it's sort of a fusion\nbetween arrays and trees. So if I have an unsorted\narray, this is very easy",
    "start": "338060",
    "end": "347400"
  },
  {
    "text": "to insert into, right? I just append to the end. This is what we\ncalled insert last.",
    "start": "347400",
    "end": "353650"
  },
  {
    "text": "So insert is fast,\nconstant amortized.",
    "start": "353650",
    "end": "358750"
  },
  {
    "text": "We might have to\nresize the array, but so that's the\namortized part. But delete max is slow. In an unsorted array, I don't\nknow where the maximum is.",
    "start": "358750",
    "end": "365910"
  },
  {
    "text": "So I have to scan\nthrough the whole array. ",
    "start": "365910",
    "end": "371240"
  },
  {
    "text": "So I scan through\nthe array, identify that the max is somewhere\nin the middle, and then, if I want to delete it--",
    "start": "371240",
    "end": "376990"
  },
  {
    "start": "376990",
    "end": "382780"
  },
  {
    "text": "I want to delete that\nmaximum element, well, in a dynamic array,\nall I can really do is delete the last\nelement efficiently.",
    "start": "382780",
    "end": "388940"
  },
  {
    "text": "So I could, for example, swap\nit with the last element. So I take this element\nand put it here, and then",
    "start": "388940",
    "end": "396940"
  },
  {
    "text": "delete the last element in that\narray, which is pop in Python or delete_last in our world.",
    "start": "396940",
    "end": "403639"
  },
  {
    "text": "So overall, this is\nlinear time, which is bad.",
    "start": "403640",
    "end": "410160"
  },
  {
    "text": "But I wanted to highlight\nexactly how it's done for a reason we'll\nget to in a moment. A sorted array is\nsort of the reverse.",
    "start": "410160",
    "end": "416200"
  },
  {
    "text": "It's very easy to find the max. Where is it? At the end.",
    "start": "416200",
    "end": "422580"
  },
  {
    "text": "delete_max, the maximum element\nis always the last element in a increasing sorted array.",
    "start": "422580",
    "end": "427919"
  },
  {
    "text": " I guess that's constant\namortized, because then I",
    "start": "427920",
    "end": "434040"
  },
  {
    "text": "have to delete it, which\nmay incur resizing. Insert, though, is\ngoing to be linear,",
    "start": "434040",
    "end": "441630"
  },
  {
    "text": "because maybe I can\nbinary search to find where the added item belongs.",
    "start": "441630",
    "end": "448199"
  },
  {
    "text": "Let's say I just\nadded this item here.",
    "start": "448200",
    "end": "455445"
  },
  {
    "text": "I could binary\nsearch to find it, but then I'm going to\nhave to do a big shift. So I might as well\njust swap repeatedly",
    "start": "455445",
    "end": "461590"
  },
  {
    "text": "until I find the position\nwhere the added item x belongs.",
    "start": "461590",
    "end": "467560"
  },
  {
    "text": "And now I've restored\nsorted order. That takes linear\ntime, which is bad. And what we want is somehow\nthe best of these two worlds.",
    "start": "467560",
    "end": "476110"
  },
  {
    "text": "Insert is fast for array. Delete is fast for\na sorted array.",
    "start": "476110",
    "end": "481750"
  },
  {
    "text": "We can't get constant\ntime for both. But we can get log\nn time for both. We already know how\nwith set AVL trees.",
    "start": "481750",
    "end": "487870"
  },
  {
    "text": "But we're going to see a\ndifferent way to do it today. And the main motivation for\na different way to do this",
    "start": "487870",
    "end": "496780"
  },
  {
    "text": "is sorting. So I want to define a\npriority queue sort. ",
    "start": "496780",
    "end": "509280"
  },
  {
    "text": "So given any data structure\nthat implements a priority queue interface, in particular\ninsert and delete_max,",
    "start": "509280",
    "end": "516419"
  },
  {
    "text": "I can make a sorting algorithm. What do I do? Insert all the items,\ndelete all the items.",
    "start": "516419",
    "end": "522270"
  },
  {
    "text": "But because when I delete them\nthey come out largest first, I get them in\nreverse sorted order.",
    "start": "522270",
    "end": "527610"
  },
  {
    "text": "Then I could reverse in linear\ntime and I've sorted my items. So we can insert (x) for\nx in A, or (build(A)),",
    "start": "527610",
    "end": "544740"
  },
  {
    "text": "and then repeatedly delete_max.",
    "start": "544740",
    "end": "550209"
  },
  {
    "start": "550210",
    "end": "557170"
  },
  {
    "text": "How much time does\nthis algorithm take? I'm going to introduce\nsome notation here. It takes however long it\ntakes to build n items,",
    "start": "557170",
    "end": "565080"
  },
  {
    "text": "call that T sub build (n) plus-- ",
    "start": "565080",
    "end": "572280"
  },
  {
    "text": "sorry-- plus n times the\ntime to do a delete_max.",
    "start": "572280",
    "end": "582655"
  },
  {
    "text": " Or we can write\nthis as n times time",
    "start": "582655",
    "end": "589710"
  },
  {
    "text": "to do an insert, plus\ntime to do a delete_max. ",
    "start": "589710",
    "end": "598350"
  },
  {
    "text": "So I'm using these T functions\nto just abstract what are the running times provided\nby my data structure that",
    "start": "598350",
    "end": "604770"
  },
  {
    "text": "implements this interface. Interface says\nwhat's correct is, and these T functions give\nme my performance bounds.",
    "start": "604770",
    "end": "610990"
  },
  {
    "text": "So if I plug in each of\nthese data structures, I get a sorting algorithm.",
    "start": "610990",
    "end": "616560"
  },
  {
    "text": "I get AVL sort,\nI get array sort, I get assorted array sort. What do those look like? It turns out many of\nthese are familiar.",
    "start": "616560",
    "end": "623145"
  },
  {
    "text": " So set AVLs take\nlog n per operation.",
    "start": "623145",
    "end": "629529"
  },
  {
    "text": "So we get an n log n sorting\nalgorithm out of them, which is insert all of the\nitems into the AVL tree.",
    "start": "629530",
    "end": "636580"
  },
  {
    "text": "I don't want to use AVL build\nbecause that uses sort, and not allowed to sort in\norder to implement sort.",
    "start": "636580",
    "end": "642220"
  },
  {
    "text": "But we saw how to\ninsert into an AVL tree and keep the thing balanced. So that takes log n each.",
    "start": "642220",
    "end": "647350"
  },
  {
    "text": "And then we can find the\nmax, delete it, rebalance, and so on. Total time will be n log n.",
    "start": "647350",
    "end": "652779"
  },
  {
    "text": "This is an algorithm\nwe call AVL sort. It's a bit complicated, because\nAVL trees are complicated.",
    "start": "652780",
    "end": "658630"
  },
  {
    "text": "But it gives us optimal\ncomparison bound and log n.",
    "start": "658630",
    "end": "664150"
  },
  {
    "text": "Now, what about array sort? So suppose I use\nan unsorted array.",
    "start": "664150",
    "end": "673310"
  },
  {
    "text": "I insert the item. So if I insert the items-- so I'm doing all the insertions\nhere before all the deletions.",
    "start": "673310",
    "end": "678540"
  },
  {
    "text": "So what's going to happen\nis I just insert the items in the original array order. In other words, I\njust take the array.",
    "start": "678540",
    "end": "683720"
  },
  {
    "text": "And then what I do is repeatedly\nextract the maximum item",
    "start": "683720",
    "end": "690459"
  },
  {
    "text": "by searching for it, moving\nit to the end of the array, and then repeating that process.",
    "start": "690460",
    "end": "696190"
  },
  {
    "text": "That sound familiar? That's selection sort\nfrom lecture three.",
    "start": "696190",
    "end": "703960"
  },
  {
    "text": "So this-- arrays give\nus selection sort. ",
    "start": "703960",
    "end": "713260"
  },
  {
    "text": "This is a new way\nto think about what we were doing way back then. With a sorted array,\nwhat are we doing?",
    "start": "713260",
    "end": "721360"
  },
  {
    "text": "We insert all the items. That's actually where all\nthe work happens, because we maintain the sorted array.",
    "start": "721360",
    "end": "726490"
  },
  {
    "text": "So we start with an empty array. It's sorted. We add an item. OK, it's still sorted. We add a second\nitem, and we swap",
    "start": "726490",
    "end": "731710"
  },
  {
    "text": "if we need to in order to sort. In general, when we add an\nitem, we swap it to the left until it's sorted again.",
    "start": "731710",
    "end": "737529"
  },
  {
    "text": "That is insertion sort. ",
    "start": "737530",
    "end": "746080"
  },
  {
    "text": "Kind of cool, this is a unifying\nframework for three sorting algorithms that we saw before.",
    "start": "746080",
    "end": "752290"
  },
  {
    "text": "We didn't actually talk\nabout AVL sort last time, but it was in the notes. And so that is the right\npart of this table.",
    "start": "752290",
    "end": "759110"
  },
  {
    "text": "So of course, these array data\nstructures are not efficient. They take linear time for\nsome of the operations.",
    "start": "759110",
    "end": "764710"
  },
  {
    "start": "760000",
    "end": "870000"
  },
  {
    "text": "So the sorting algorithms\nare not efficient. But they're ones\nwe've seen before, so it's neat to see\nhow they fit in here.",
    "start": "764710",
    "end": "769938"
  },
  {
    "text": "They had the-- selection\nsort and insertion sort had the advantage\nthat they were in place. You just needed a constant\nnumber of pointers or indices",
    "start": "769938",
    "end": "777490"
  },
  {
    "text": "beyond the array itself. So they're very space efficient. So that was a plus for them. But they take n squared\ntime, so you should never",
    "start": "777490",
    "end": "784390"
  },
  {
    "text": "use them, except for n,\nat most, 100 or something. AVL tree sort is great and then\nit gets n log n time, probably",
    "start": "784390",
    "end": "794393"
  },
  {
    "text": "more complicated than\nmerge sort and you could stick to merge sort. But neither merge sort nor set\nAVL tree sort are in place.",
    "start": "794393",
    "end": "801949"
  },
  {
    "text": "And so the goal\nof today is to get the best of all those\nworlds in sorting to get n log n\ncomparisons, which",
    "start": "801950",
    "end": "808390"
  },
  {
    "text": "is optimal in the\ncomparison model, but get it to be in place. And that's what we're going\nto get with binary heaps.",
    "start": "808390",
    "end": "815575"
  },
  {
    "text": " We're going to design\na data structure that",
    "start": "815575",
    "end": "820970"
  },
  {
    "text": "happens to build a little\nbit faster-- as I mentioned, linear time building. So it's not representing a\nsorted order in the same way",
    "start": "820970",
    "end": "828110"
  },
  {
    "text": "that AVL trees are. But it will be\nkind of tree-based. It will also be array-based.",
    "start": "828110",
    "end": "833686"
  },
  {
    "text": "We're going to get logarithmic\ntime for insert and delete_max. It happens to be amortized,\nbecause we use arrays.",
    "start": "833687",
    "end": "840230"
  },
  {
    "text": "But the key thing is that it's\nan in-place data structure. It only consists of\nan array of the items.",
    "start": "840230",
    "end": "847970"
  },
  {
    "text": "And so, when we plug it\ninto our sorting algorithm-- priority queue sort or\ngeneric sorting algorithm--",
    "start": "847970",
    "end": "853460"
  },
  {
    "text": "not only do we get\nn log n performance, but we also get an\nin-place sorting algorithm.",
    "start": "853460",
    "end": "858530"
  },
  {
    "text": "This will be our first\nand only-- to this class-- n log n in-place\nsorting algorithm.",
    "start": "858530",
    "end": "864570"
  },
  {
    "text": "Cool. That's the goal.",
    "start": "864570",
    "end": "869890"
  },
  {
    "text": "Let's do it. So what we're going to do,\nbecause we're in place,",
    "start": "869890",
    "end": "876420"
  },
  {
    "start": "870000",
    "end": "920000"
  },
  {
    "text": "basically we have to have an\narray storing our end items. That's sort of the\ndefinition of in-place,",
    "start": "876420",
    "end": "881580"
  },
  {
    "text": "just using n slots\nof memory exactly the size of the number of\nitems in our structure.",
    "start": "881580",
    "end": "887918"
  },
  {
    "text": "But we're obviously not going\nto use a regular unsorted array or a regular sorted array.",
    "start": "887918",
    "end": "892998"
  },
  {
    "text": "We're going to use\narray just as sort of the underlying technology\nfor how things are stored.",
    "start": "892998",
    "end": "898050"
  },
  {
    "text": "But we'd really like\nlogarithmic performance, which should make you think tree. Only way to get a log is the\nbinary tree, more or less.",
    "start": "898050",
    "end": "906509"
  },
  {
    "text": "So somehow, we want to\nembed a tree into an array.",
    "start": "906510",
    "end": "914740"
  },
  {
    "text": "Let me grab an example. ",
    "start": "914740",
    "end": "923959"
  },
  {
    "start": "920000",
    "end": "1010000"
  },
  {
    "text": "Let me draw a tree. ",
    "start": "923960",
    "end": "944680"
  },
  {
    "text": "If I got to choose\nany old tree I want, I would choose a tree that's\nbasically perfectly balanced.",
    "start": "944680",
    "end": "951550"
  },
  {
    "text": "Perfectly balanced would\nbe like this, where-- what's the property? That I have all\nof these levels--",
    "start": "951550",
    "end": "958899"
  },
  {
    "text": "all of these depths are\ncompletely filled with nodes. This is depth 0. ",
    "start": "958900",
    "end": "965800"
  },
  {
    "text": "Remember, this is depth 1, this\nis depth 2, this is depth 3.",
    "start": "965800",
    "end": "971339"
  },
  {
    "text": "So what I'd really like\nis to have 2 to the i nodes at depth i.",
    "start": "971340",
    "end": "980860"
  },
  {
    "text": "That would be a\nperfect binary tree. But that only works when n is 1\nless than a power of 2, right?",
    "start": "980860",
    "end": "989050"
  },
  {
    "text": "I can't always achieve\nthat for any n. And so the next best\nthing I could hope for",
    "start": "989050",
    "end": "994090"
  },
  {
    "text": "is 2 to the i at\nnodes at depth i until the very last\ni-- the largest depth.",
    "start": "994090",
    "end": "1000339"
  },
  {
    "text": "And in that level, I'm still\ngoing to restrict things. I'm going to force\nall of the nodes",
    "start": "1000340",
    "end": "1005410"
  },
  {
    "text": "to be as far left as possible. So I want to say, except at\nmax depth where nodes are--",
    "start": "1005410",
    "end": "1023550"
  },
  {
    "start": "1010000",
    "end": "1220000"
  },
  {
    "text": "I'll call them left justified. ",
    "start": "1023550",
    "end": "1030660"
  },
  {
    "text": "And these two\nproperties together is what I call a\ncomplete binary tree. ",
    "start": "1030660",
    "end": "1047839"
  },
  {
    "text": "Why is this interesting? Because I claim I can represent\na tree like this as an array.",
    "start": "1047839",
    "end": "1055399"
  },
  {
    "text": "I've narrowed things down enough\nthat I can draw an array down here.",
    "start": "1055400",
    "end": "1061440"
  },
  {
    "text": "And what I'm going to\ndo is write these nodes in depth order. So I write A first,\nbecause that's step 0.",
    "start": "1061440",
    "end": "1067910"
  },
  {
    "text": "Then B, C, that's step 1. Then, well, they're\nalphabetical.",
    "start": "1067910",
    "end": "1073140"
  },
  {
    "text": "I made it that way. D, E, F, G is depth 2.",
    "start": "1073140",
    "end": "1078680"
  },
  {
    "text": "And then H, I, J is step 3. This is very different from\ntraversal order of a tree.",
    "start": "1078680",
    "end": "1086210"
  },
  {
    "text": "Traversal order would have\nbeen H, D, I, B, J, E, A, F, C, G, OK?",
    "start": "1086210",
    "end": "1091790"
  },
  {
    "text": "But this is what we\nmight call depth order, do the lowest\ndepth nodes first--",
    "start": "1091790",
    "end": "1097669"
  },
  {
    "text": "very different way to lay things\nout or to linearize our data.",
    "start": "1097670",
    "end": "1104440"
  },
  {
    "text": "And this is what a heap\nis going to look like. So the cool thing is,\nbetween complete binary",
    "start": "1104440",
    "end": "1113310"
  },
  {
    "text": "trees and arrays is a bijection. For every array, there's a\nunique complete binary tree.",
    "start": "1113310",
    "end": "1119760"
  },
  {
    "text": "And for every complete binary\ntree, there's a unique array. Why? Because the complete\nconstraint forces",
    "start": "1119760",
    "end": "1126700"
  },
  {
    "text": "everything-- forces my hand. There's only-- if I\ngive you a number n, there is one tree\nshape of size n, right?",
    "start": "1126700",
    "end": "1133809"
  },
  {
    "text": "You just fill in the\nnodes top down until you get to the last level. And then you have to fill\nthem in left to right.",
    "start": "1133810",
    "end": "1139960"
  },
  {
    "text": "It's what you might call reading\norder for writing down nodes. And the array is telling\nyou which keys go where.",
    "start": "1139960",
    "end": "1147070"
  },
  {
    "text": "This is the first node you\nwrite down at the root, this is the next\nnode you write down at the left child of\nthe root, and so on.",
    "start": "1147070",
    "end": "1153670"
  },
  {
    "text": "So here we have a binary\ntree represented as an array, or array representing\na binary tree.",
    "start": "1153670",
    "end": "1159279"
  },
  {
    "text": "The very specific\nbinary tree, it has a clear advantage, which\nis it is guaranteed balance.",
    "start": "1159280",
    "end": "1165580"
  },
  {
    "text": "No rotations necessary in heaps,\nbecause complete binary trees are always balanced. In fact, they have the best\nheight they possibly could,",
    "start": "1165580",
    "end": "1173770"
  },
  {
    "text": "which is ceiling of log n. ",
    "start": "1173770",
    "end": "1179560"
  },
  {
    "text": "Balanced, remember, just\nmeant you were big O of log n. This is 1 times log n. So it's the best level of\nbalance you could hope for.",
    "start": "1179560",
    "end": "1187899"
  },
  {
    "text": "So somehow, I claim, we can\nmaintain a complete binary tree",
    "start": "1187900",
    "end": "1192910"
  },
  {
    "text": "for solving priority queues. This would not be\npossible if you were trying to solve\nthe whole set interface. And that's kind of the\ncool thing about heaps,",
    "start": "1192910",
    "end": "1199660"
  },
  {
    "text": "is that by just focusing on the\nsubset of the set interface, we can do more.",
    "start": "1199660",
    "end": "1205030"
  },
  {
    "text": "We can maintain this\nvery strong property. And because we have this\nvery strong property, we don't even need\nto store this tree.",
    "start": "1205030",
    "end": "1210993"
  },
  {
    "text": "We're not going to store left\nand right pointers and parent pointers, we're just\ngoing to store the array.",
    "start": "1210993",
    "end": "1216620"
  },
  {
    "text": "This is what we call an\nimplicit data structure, which",
    "start": "1216620",
    "end": "1228960"
  },
  {
    "start": "1220000",
    "end": "1500000"
  },
  {
    "text": "basically means no pointers,\njust an array of the n items.",
    "start": "1228960",
    "end": "1238529"
  },
  {
    "start": "1238530",
    "end": "1244080"
  },
  {
    "text": "How are we going to get away\nwithout storing pointers? I'd still like to\ntreat it like a tree. I'd still like to know\nthe left child of B is D",
    "start": "1244080",
    "end": "1252150"
  },
  {
    "text": "and the right child B is E.\nWe'll see why in a moment. Well, we can do this\nwith index arithmetic.",
    "start": "1252150",
    "end": "1261990"
  },
  {
    "text": "So maybe I should add some\nlabels before I get there. ",
    "start": "1261990",
    "end": "1271419"
  },
  {
    "text": "So this array\nnaturally has indices. This is index 0.",
    "start": "1271420",
    "end": "1276630"
  },
  {
    "text": "This is index 1, index 2, index\n3, index 4, index 5, index 6, 7, 8, 9, because there\nare 10 items, 0 through 9.",
    "start": "1276630",
    "end": "1287610"
  },
  {
    "text": "And I can apply those\nlabels up here, too. These are the same\nnodes, so 0, 1, 2. This is just a depth order.",
    "start": "1287610",
    "end": "1294299"
  },
  {
    "text": " But once I have\nthis labeling, it's going to be a lot easier\nto figure things out.",
    "start": "1294300",
    "end": "1300130"
  },
  {
    "text": "So if I wanted to know\nthe left child of B is D, somehow, given the number 1, I\nwant to compute the number 3.",
    "start": "1300130",
    "end": "1308596"
  },
  {
    "text": "Add 2, there are all\nsorts-- multiply by 3, there are all\nsorts of operations",
    "start": "1308596",
    "end": "1314030"
  },
  {
    "text": "that take 1 and turn it into 3. But there's only one that's\ngoing to work in all cases. And the intuition here\nis, well, I have to 2",
    "start": "1314030",
    "end": "1320840"
  },
  {
    "text": "the i nodes at level i. If I want to go to\nthe child level, there's 2 to the i plus\n1 nodes down there--",
    "start": "1320840",
    "end": "1326990"
  },
  {
    "text": "exactly double. So it's the very last one,\nbut that won't really matter. If there is a left child,\nit will behave the same.",
    "start": "1326990",
    "end": "1333350"
  },
  {
    "text": "And so, intuitively, I have\nthis space of size 2 to the i. I have to expand it to a space\nof size 2 to the i plus 1,",
    "start": "1333350",
    "end": "1339350"
  },
  {
    "text": "So I should multiply by 2. And that's almost right, but\nthen there's some constants.",
    "start": "1339350",
    "end": "1347110"
  },
  {
    "text": "So I'd like to say 2 times i. But if we look at the\nexamples here, 1 times 2",
    "start": "1347110",
    "end": "1352899"
  },
  {
    "text": "is 2, which is 1 less than 3. 2 times 2 is 4, which\nis 1 less than 5.",
    "start": "1352900",
    "end": "1358420"
  },
  {
    "text": "Hey, we almost got it right. It's just off by 1. Off by 1 is--",
    "start": "1358420",
    "end": "1365680"
  },
  {
    "text": "index errors are the most common\nthings in computer science.",
    "start": "1365680",
    "end": "1370840"
  },
  {
    "text": "What about the right child? If the left child is a 2i plus\n1, where is the right child?",
    "start": "1370840",
    "end": "1376540"
  },
  {
    "text": " I hear lots of mumbles. 2i plus 2-- one more.",
    "start": "1376540",
    "end": "1383930"
  },
  {
    "text": "Because we're writing things\nleft to right in depth order, the right child is the right\nsibling of the left child.",
    "start": "1383930",
    "end": "1389830"
  },
  {
    "text": "So it's just one larger, OK? Given those rules, we\ncan also compute parent.",
    "start": "1389830",
    "end": "1395990"
  },
  {
    "text": "It's just whatever\nis the inverse of both of these\nfunctions, which I want",
    "start": "1395990",
    "end": "1402500"
  },
  {
    "text": "to divide by 2 at some point. I want to get back to i given\n2i plus 1 or given 2i plus 2.",
    "start": "1402500",
    "end": "1409400"
  },
  {
    "text": "And so if I subtract 1\nfrom i, then I either",
    "start": "1409400",
    "end": "1416530"
  },
  {
    "text": "get 2i or 2i plus 1. And then, if I take an integer\ndivision by 2, I get i--",
    "start": "1416530",
    "end": "1422680"
  },
  {
    "text": "the original i. Sorry, maybe I'll call\nthis j to be clearer. So j is the left or right child.",
    "start": "1422680",
    "end": "1429580"
  },
  {
    "text": "Then I can reconstruct\ni, which was the parent. So this is constant number\narithmetic operations.",
    "start": "1429580",
    "end": "1436159"
  },
  {
    "text": "So I don't have to store\nleft and right pointers. I can just compute them\nwhenever I need them. Whenever I'm at\nsome node like E,",
    "start": "1436160",
    "end": "1443140"
  },
  {
    "text": "and I want to know\nwhat's its left child-- sorry, given the\nnode index 4, which",
    "start": "1443140",
    "end": "1448630"
  },
  {
    "text": "happens to contain\nthe item E, and I want to know what's its left\nchild, I just multiply by 2 and add 1.",
    "start": "1448630",
    "end": "1453960"
  },
  {
    "text": "I get 9. And then, I can index into\nthis array at position 9. Because I don't-- this is\njust in my head, remember.",
    "start": "1453960",
    "end": "1460630"
  },
  {
    "text": "We're just thinking that\nthere's a tree here. But in reality, on the computer,\nthere's just the array.",
    "start": "1460630",
    "end": "1466340"
  },
  {
    "text": "So if we want to go from E\nto J, we can, from 4 to 9. If we go try to go to the\nright child, we multiply by 2.",
    "start": "1466340",
    "end": "1473620"
  },
  {
    "text": "8 add 2-- 10. And we see, oh, 10 is\nbeyond the end of the array. But our array stores its\nsize, so we realize, oh, E",
    "start": "1473620",
    "end": "1480279"
  },
  {
    "text": "does not have a right child. This is something you can only\ndo in a complete binary tree. In a general binary\ntree you don't",
    "start": "1480280",
    "end": "1486490"
  },
  {
    "text": "have these nice properties. Cool, so this is\nbasically a heap.",
    "start": "1486490",
    "end": "1493970"
  },
  {
    "text": "I just need to add\none more property, naturally called\nthe heap property.",
    "start": "1493970",
    "end": "1499830"
  },
  {
    "start": "1499830",
    "end": "1504880"
  },
  {
    "start": "1500000",
    "end": "1860000"
  },
  {
    "text": "So there are multiple\ntypes of heaps. This type of heap is\ncalled a binary heap.",
    "start": "1504880",
    "end": "1511890"
  },
  {
    "text": "We will talk about others\nin future lectures. I'm going to call it\nQ. Explicit thing--",
    "start": "1511890",
    "end": "1528690"
  },
  {
    "text": "this is an array representing\na complete binary tree,",
    "start": "1528690",
    "end": "1547913"
  },
  {
    "text": "called the array Q. And we\nwant every node to satisfy",
    "start": "1547913",
    "end": "1562270"
  },
  {
    "text": "the so-called max-heap property,\nwhich says Q[i] is greater than",
    "start": "1562270",
    "end": "1580770"
  },
  {
    "text": "or equal to Q[j] for both\nchildren left of i and right",
    "start": "1580770",
    "end": "1589360"
  },
  {
    "text": "of i. ",
    "start": "1589360",
    "end": "1597160"
  },
  {
    "text": "So we have a node i. And it has two children--",
    "start": "1597160",
    "end": "1604750"
  },
  {
    "text": "2i plus 1 and 2i plus 2. These are two values of j.",
    "start": "1604750",
    "end": "1610360"
  },
  {
    "text": " What we want is a\ngreater than or equal to",
    "start": "1610360",
    "end": "1617140"
  },
  {
    "text": "relation here and here. So this node should be\nbigger than both this one and this one.",
    "start": "1617140",
    "end": "1622519"
  },
  {
    "text": "Which of these is larger? We don't know, and\nwe don't care-- very different from\nbinary search trees",
    "start": "1622520",
    "end": "1628360"
  },
  {
    "text": "or set binary trees, where we\nsaid these guys were less than or equal to this one,\nthis one was less than",
    "start": "1628360",
    "end": "1633613"
  },
  {
    "text": "or equal to all the nodes\nin the subtree here. We're just locally\nsaying, this node is greater than or equal\nto this node and this node.",
    "start": "1633613",
    "end": "1640000"
  },
  {
    "text": "So the biggest is at the top. ",
    "start": "1640000",
    "end": "1646270"
  },
  {
    "text": "So one nice lemma about\nthese heaps-- this is weird.",
    "start": "1646270",
    "end": "1654010"
  },
  {
    "text": "Let me give you\nsome more intuition. If you are a binary heap, if you\nsatisfy this max-heap property",
    "start": "1654010",
    "end": "1659679"
  },
  {
    "text": "everywhere, then\nin fact, you learn that every node i is greater\nthan or equal to all nodes",
    "start": "1659680",
    "end": "1667510"
  },
  {
    "text": "in its subtree. These are what we call\ndescendants in subtree of i.",
    "start": "1667510",
    "end": "1675759"
  },
  {
    "text": " Let me look at this example.",
    "start": "1675760",
    "end": "1683390"
  },
  {
    "text": "So I haven't written\nany numbers here. You can imagine. So A here is greater than\nor equal to both B and C,",
    "start": "1683390",
    "end": "1690880"
  },
  {
    "text": "and B is greater than\nor equal to D and E, and C is greater than\nor equal to F and G, D is greater than\nor equal to H and I,",
    "start": "1690880",
    "end": "1696340"
  },
  {
    "text": "and E is greater\nthan or equal to J. That would make this\nstructure a heap, not just a complete binary tree.",
    "start": "1696340",
    "end": "1703640"
  },
  {
    "text": "So what does that imply? It implies that A\nmust be the maximum. So you look at any\nnode here, like J, A",
    "start": "1703640",
    "end": "1709802"
  },
  {
    "text": "is greater than or equal to B\nis greater than or equal to E is greater than or equal to\nJ. And in general, what we're",
    "start": "1709802",
    "end": "1715400"
  },
  {
    "text": "saying is that A is greater\nthan or equal to all nodes in the tree. B is greater than or equal\nto all nodes in its subtree",
    "start": "1715400",
    "end": "1721190"
  },
  {
    "text": "down here. C is greater than or equal\nto all nodes in its subtree. That's what this\nlemma is saying.",
    "start": "1721190",
    "end": "1727220"
  },
  {
    "text": "You can prove this\nlemma by induction. But it's really simple.",
    "start": "1727220",
    "end": "1735280"
  },
  {
    "text": "If you have two nodes, i\nand j, and j is somewhere in the subtree,\nthat means there's some downward path from i to j.",
    "start": "1735280",
    "end": "1743769"
  },
  {
    "text": "And you know that,\nfor every edge we traverse on a\ndownward path, our key is going down non-strictly.",
    "start": "1743770",
    "end": "1750280"
  },
  {
    "text": "So every child is less than\nor equal to its parent. i is greater than\nor equal to this, is greater than\nor equal to this, is greater than\nor equal to this,",
    "start": "1750280",
    "end": "1756335"
  },
  {
    "text": "is greater than\nor equal to j, OK? So by transitivity of\nless than or equal to,",
    "start": "1756335",
    "end": "1761470"
  },
  {
    "text": "you know that i is, in fact,\ngreater than or equal to j. Or sorry, the key\nin i is greater than",
    "start": "1761470",
    "end": "1767080"
  },
  {
    "text": "or equal to the key in j. This is what we're\ncalling i, the index. This is what we\nwould call Q of i.",
    "start": "1767080",
    "end": "1774169"
  },
  {
    "text": "This is Index j Q of j. ",
    "start": "1774170",
    "end": "1780010"
  },
  {
    "text": "Very different way to\norganize keys in a tree,",
    "start": "1780010",
    "end": "1786660"
  },
  {
    "text": "but as you might\nimagine, this is going to be good for priority queues. Because priority\nqueues just need",
    "start": "1786660",
    "end": "1792060"
  },
  {
    "text": "to find the maximum elements. Then they need to delete it. That's going to be harder,\nbecause leading the root",
    "start": "1792060",
    "end": "1797785"
  },
  {
    "text": "is, like-- that's the hardest\nnode to delete, intuitively. I'd really prefer\nto delete leaves.",
    "start": "1797785",
    "end": "1802950"
  },
  {
    "text": "But leading leaves and\nkeeping a complete binary tree is actually kind of hard.",
    "start": "1802950",
    "end": "1808470"
  },
  {
    "text": "If I want to delete\nH, that doesn't look like a binary\ntree, or it doesn't look like a complete\nbinary tree anymore.",
    "start": "1808470",
    "end": "1814468"
  },
  {
    "text": "It's not left justified. Similarly, if I want to\ndelete F, that's bad. Because now, I don't\nhave four nodes here.",
    "start": "1814468",
    "end": "1820800"
  },
  {
    "text": "The one node that's easy\nto delete is J, right? If I remove that node, I\nstill have a complete tree.",
    "start": "1820800",
    "end": "1827380"
  },
  {
    "text": "The last leaf, the last\nposition in my array, is the one that's\neasy to delete.",
    "start": "1827380",
    "end": "1833200"
  },
  {
    "text": "That's good, because arrays are\ngood at leading the last item. But what I've set up here is\nit's easy to find the max.",
    "start": "1833200",
    "end": "1839770"
  },
  {
    "text": "It's going to be up\nhere at the root. Deleting it is annoying. I'd like to somehow take that\nkey and put it at position--",
    "start": "1839770",
    "end": "1848200"
  },
  {
    "text": "at the last position\nat the last leaf, because that's the one\nthat's easy to delete.",
    "start": "1848200",
    "end": "1853683"
  },
  {
    "text": "And that's indeed\nwhat we're going to do in a delete algorithm. Let me first do insert.",
    "start": "1853683",
    "end": "1859600"
  },
  {
    "text": "I guess that's a little\nsimpler, kind of symmetric",
    "start": "1859600",
    "end": "1869450"
  },
  {
    "text": "to what we just said. So if I want to insert a key or\nan item x which has some key,",
    "start": "1869450",
    "end": "1877130"
  },
  {
    "text": "again, the only thing I\nreally can do in an array-- if I want to add a new item,\nit has to go at the end.",
    "start": "1877130",
    "end": "1883532"
  },
  {
    "text": "The only thing we\nknow how to do is insert at the end of an array. This is what we\ncalled insert_last.",
    "start": "1883532",
    "end": "1888742"
  },
  {
    "start": "1888742",
    "end": "1893820"
  },
  {
    "text": "this? Corresponds to adding\na node containing x--",
    "start": "1893820",
    "end": "1899269"
  },
  {
    "text": "the item x-- in the very last\nlevel of the complete binary",
    "start": "1899270",
    "end": "1904380"
  },
  {
    "text": "tree. Either it goes to the right\nof all the existing nodes, or starts a new level. But it's always going\nto be the last leaf.",
    "start": "1904380",
    "end": "1910238"
  },
  {
    "text": "After we do the\ninsertion, it will be at position size of Q minus 1. ",
    "start": "1910238",
    "end": "1917805"
  },
  {
    "text": "This is probably\nnot enough, though. We just inserted an\narbitrary item in a leaf. And now, it may not satisfy\nthe max-heap property anymore.",
    "start": "1917805",
    "end": "1924890"
  },
  {
    "text": "So let's just check if it does,\nand if it doesn't, fix it. That's what we know how to do.",
    "start": "1924890",
    "end": "1930490"
  },
  {
    "text": "But this time,\nwe're not even going to need rotations,\nwhich is cool.",
    "start": "1930490",
    "end": "1943960"
  },
  {
    "text": "So I'm going to define\nan operation called max_heapify_up.",
    "start": "1943960",
    "end": "1949190"
  },
  {
    "text": "This will make things\nmore like a max-heap. We're going to start at size\nof Q minus 1 for our value i.",
    "start": "1949190",
    "end": "1959810"
  },
  {
    "text": "But it's going to be recursive,\nso what we're going to do is look at a node i,\nin particular the one",
    "start": "1959810",
    "end": "1969290"
  },
  {
    "text": "that just got inserted. And where could\nit violate things? Well, with its parent, because\nwe have no idea what key",
    "start": "1969290",
    "end": "1978790"
  },
  {
    "text": "we just put here. Maybe it's less than our parent. Then we're happy. But if it's greater than\nour parent, we're in trouble",
    "start": "1978790",
    "end": "1985179"
  },
  {
    "text": "and we should fix it. So if the item in the parent's\nkey is less than i's key--",
    "start": "1985180",
    "end": "2003090"
  },
  {
    "text": " ah, I see I forgot to write\nkey and all these spots.",
    "start": "2003090",
    "end": "2008705"
  },
  {
    "text": "This should be dot\nkey and dot key, because Q[i] is an\nitem that gets its key.",
    "start": "2008705",
    "end": "2017190"
  },
  {
    "text": "So this is the bad case. This is if the parent is\nsmaller than the child. We wanted the parent\nto always be greater",
    "start": "2017190",
    "end": "2023400"
  },
  {
    "text": "than or equal to its children. So in that case,\nwhat could we do?",
    "start": "2023400",
    "end": "2029309"
  },
  {
    "text": "Swap them.  Let's swap Q parent of i--",
    "start": "2029310",
    "end": "2038639"
  },
  {
    "text": "excellent, more\nchalk-- with Q[i].",
    "start": "2038640",
    "end": "2043970"
  },
  {
    "text": "Now they're in the right order. Now, we need to think about\nwhat about the other child of that node?",
    "start": "2043970",
    "end": "2050449"
  },
  {
    "text": "And what about its parent? So I have some numbers here.",
    "start": "2050449",
    "end": "2055888"
  },
  {
    "text": "Let's say this was\n5 and this was 10.",
    "start": "2055889",
    "end": "2062119"
  },
  {
    "text": "What do I know about\nthis picture before? Well, I know that 10 is\nthis newly inserted item.",
    "start": "2062120",
    "end": "2069589"
  },
  {
    "text": "It's the only one that\ncould have caused violations when I first inserted it. So I know that before this--\nbefore I moved 10 around,",
    "start": "2069590",
    "end": "2077419"
  },
  {
    "text": "I knew all the things\nin this left subtree are less than or equal to\n5, and everything up here",
    "start": "2077420",
    "end": "2084199"
  },
  {
    "text": "are created equal to 5. I also know that the nodes in\nhere, in fact, were less than",
    "start": "2084199",
    "end": "2090590"
  },
  {
    "text": "or equal to 5. Other than this node 10\nthat we just inserted, this was a correct heap.",
    "start": "2090590",
    "end": "2097138"
  },
  {
    "text": "So 5 was a separator between-- things above it on\nthe ancestor chain are greater than or equal to\n5, and things in its subtree",
    "start": "2097139",
    "end": "2104180"
  },
  {
    "text": "are less than or equal to it. So after I do this swap,\nwhich I'm just going to do--",
    "start": "2104180",
    "end": "2111920"
  },
  {
    "text": " after I swap the items 5 and\n10, 10 is up here, 5 is here.",
    "start": "2111920",
    "end": "2121310"
  },
  {
    "text": "And now, I realize,\nOK, great, this edge is happy, because now 10 is\ngreater than or equal to 5. But also this edge is happy,\nbecause it used to be happy,",
    "start": "2121310",
    "end": "2128690"
  },
  {
    "text": "and we only made\nits parent larger. Now this edge maybe is bad.",
    "start": "2128690",
    "end": "2134540"
  },
  {
    "text": "And so we need to recurse--  recurse on the parent.",
    "start": "2134540",
    "end": "2141809"
  },
  {
    "text": " But that's it. So we fixed this one edge.",
    "start": "2141810",
    "end": "2147845"
  },
  {
    "text": "Initially, this happens\nway down at the leaf. But in general,\nwe're taking our item that we inserted, which is x,\nand it starts at the last leaf,",
    "start": "2147845",
    "end": "2156349"
  },
  {
    "text": "and it may be bubbles\nup for a while. And maybe it gets all\nthe way to the root if we inserted a\nnew maximum item.",
    "start": "2156350",
    "end": "2161660"
  },
  {
    "text": "But in each step,\nit goes up one. And so the running\ntime of all this stuff",
    "start": "2161660",
    "end": "2166730"
  },
  {
    "text": "is the height of the\ntree, which is log n.",
    "start": "2166730",
    "end": "2172228"
  },
  {
    "text": "And because there's only this\none item that could potentially be wrong, if it\never stops moving, we've just checked\nthat it satisfies",
    "start": "2172228",
    "end": "2178190"
  },
  {
    "text": "the max-heap property. If it gets to the\nroot, you can also check it satisfies\nthe max-heap property.",
    "start": "2178190",
    "end": "2183368"
  },
  {
    "text": "So there's a base case\nI didn't write here, which is if i equals 0, we're\nat the root, we're done.",
    "start": "2183368",
    "end": "2190760"
  },
  {
    "text": "And then you can prove\nthis correct by induction. There's just one item that's\nin the wrong spot, initially.",
    "start": "2190760",
    "end": "2196830"
  },
  {
    "text": "And we put it into a right spot. There are many places it could\ngo, but we will move it to the,",
    "start": "2196830",
    "end": "2202770"
  },
  {
    "text": "I guess, unique ancestor\nposition that is correct-- that satisfies\nmax-heap property, OK?",
    "start": "2202770",
    "end": "2208500"
  },
  {
    "text": "So that's insert. Delete is going to be almost\nthe same, delete_min, that is--",
    "start": "2208500",
    "end": "2223000"
  },
  {
    "start": "2220000",
    "end": "2730000"
  },
  {
    "start": "2223000",
    "end": "2234010"
  },
  {
    "text": "sorry, delete_max, thank you. You can of course define\nall of these things",
    "start": "2234010",
    "end": "2239140"
  },
  {
    "text": "for min instead of max. Everything works the same. I just have a hard\ntime remembering which one we're doing.",
    "start": "2239140",
    "end": "2245319"
  },
  {
    "text": "Just don't switch you can't use\na max-heap to do delete_min. You can't use a min-heap\nto do delete_max, but you can use a\nmin-heap to do delete_min.",
    "start": "2245320",
    "end": "2252790"
  },
  {
    "text": "That's fine. So like I said, the only node\nwe really know how to delete",
    "start": "2252790",
    "end": "2260680"
  },
  {
    "text": "is the last leaf\non the last level, which is the end of the array. Because that's what arrays\ncan delete efficiently.",
    "start": "2260680",
    "end": "2267549"
  },
  {
    "text": "And what we need to\ndelete is the root item, because that's always\nthe maximum one, which is at the first\nposition in the array.",
    "start": "2267550",
    "end": "2274490"
  },
  {
    "text": "So what do we do? Swap them, our usual trick.",
    "start": "2274490",
    "end": "2280323"
  },
  {
    "text": "I think the cool\nthing about heaps is we never have\nto do rotations. We're only going to do\nswaps, which is something",
    "start": "2280323",
    "end": "2285370"
  },
  {
    "text": "we had to do with trees also-- binary trees. ",
    "start": "2285370",
    "end": "2291087"
  },
  {
    "text": "Q[0] with Q of the last item--",
    "start": "2291087",
    "end": "2298780"
  },
  {
    "text": "great, done. Now we have the last item is\nthe one we want to delete. So we do delete_last, or pop in\nPython, and boom, we've got--",
    "start": "2298780",
    "end": "2310420"
  },
  {
    "text": "we've now deleted\nthe maximum item. Of course, we may have also\nmessed up the max-heap property",
    "start": "2310420",
    "end": "2316210"
  },
  {
    "text": "just like we did with insert. So with insert, we were\nadding a last leaf.",
    "start": "2316210",
    "end": "2323410"
  },
  {
    "text": "Now, what we're doing is\nswapping the last leaf with the-- I'm pointing at\nthe wrong picture. Let me go back to this tree.",
    "start": "2323410",
    "end": "2330610"
  },
  {
    "text": "What we did is swap item J\nwith A. So the problem is now-- and then we deleted this node.",
    "start": "2330610",
    "end": "2337450"
  },
  {
    "text": "The problem is now\nthat that root node has maybe a very small key. Because the key that's here\nnow is whatever was down here,",
    "start": "2337450",
    "end": "2344900"
  },
  {
    "text": "which is very low in the tree. So intuitively,\nthat's a small value. This is supposed to\nbe the maximum value,",
    "start": "2344900",
    "end": "2350630"
  },
  {
    "text": "and we just put a small\nvalue in the root. So what do we do? Heapify down.",
    "start": "2350630",
    "end": "2356540"
  },
  {
    "text": "We're going to take that\nitem and somehow push it down to the tree until the-- down in the tree until\nmax-heap property is satisfied.",
    "start": "2356540",
    "end": "2364760"
  },
  {
    "text": "So this is going to\nbe max_heapify_down.",
    "start": "2364760",
    "end": "2370960"
  },
  {
    "text": "And we will start at position\n0, which is the root. ",
    "start": "2370960",
    "end": "2378120"
  },
  {
    "text": "And max_heapify_down is going\nto be a recursive algorithm.",
    "start": "2378120",
    "end": "2385840"
  },
  {
    "text": "So we'll start at\nsome position i. And initially, that's the root. And what we're going to do is\nlook at position i and its two",
    "start": "2385840",
    "end": "2393954"
  },
  {
    "text": "children.  So let's say we put a very\nsmall value up here, like 0.",
    "start": "2393955",
    "end": "2401090"
  },
  {
    "text": "And let's say we have\nour children, 5 and 10. We don't know-- maybe\nI'll swap their order just",
    "start": "2401090",
    "end": "2406220"
  },
  {
    "text": "to be more generic, because\nthat looks like not quite a binary search\ntree, but we don't",
    "start": "2406220",
    "end": "2412700"
  },
  {
    "text": "know their relative order. But one of them is greater\nthan or equal to the other in some order.",
    "start": "2412700",
    "end": "2418920"
  },
  {
    "text": "And so what would I like to\ndo to fix this local picture? ",
    "start": "2418920",
    "end": "2425369"
  },
  {
    "text": "Yeah, I want to swap. And I could swap-- 0 is clearly in the wrong spot. It needs to go\nlower in the tree.",
    "start": "2425370",
    "end": "2431400"
  },
  {
    "text": "I can swap 0 with\n5 or 0 with 10. Which one? 10. ",
    "start": "2431400",
    "end": "2439010"
  },
  {
    "text": "I could draw the picture with\n5, but it will not be happy. ",
    "start": "2439010",
    "end": "2446180"
  },
  {
    "text": "Why 10? We want to do it\nwith the larger one, because then this\nedge will be happy, and also this edge\nwill be happy.",
    "start": "2446180",
    "end": "2452660"
  },
  {
    "text": "If I swapped 5 up there instead,\nthe 5/10 edge would be unhappy. It wouldn't satisfy\nthe max-heap property.",
    "start": "2452660",
    "end": "2458460"
  },
  {
    "text": "So I can do one swap and\nfix max-heap property. Except that, again, 0 may be\nunhappy with its children.",
    "start": "2458460",
    "end": "2465680"
  },
  {
    "text": "0 was this one item that\nwas in the wrong spot. And so it made it have\nto go farther down. But 5 will be--",
    "start": "2465680",
    "end": "2471560"
  },
  {
    "text": "5 didn't even move. So it's happy. Everything in this\nsubtree is good.",
    "start": "2471560",
    "end": "2476960"
  },
  {
    "text": "What about the parent? Well, if you think about\nit, because everything was a correct heap\nbefore we added 0,",
    "start": "2476960",
    "end": "2483890"
  },
  {
    "text": "or before we put 0 too\nhigh, all of these nodes will be greater than or equal\nto 10 on the ancestor path.",
    "start": "2483890",
    "end": "2493820"
  },
  {
    "text": "And all of these nodes were\nless than or equal to 10 before, unless\nyou're equal to 5. So that's still true.",
    "start": "2493820",
    "end": "2501509"
  },
  {
    "text": "But you see, this tree is happy. This tree still may be unhappy. 0 still might need\nto push down farther.",
    "start": "2501510",
    "end": "2507450"
  },
  {
    "text": "That's going to\nbe the recursion. So we check down here.",
    "start": "2507450",
    "end": "2516650"
  },
  {
    "start": "2516650",
    "end": "2526470"
  },
  {
    "text": "There's a base case, which is\nif i is a leaf, we're done. Because there's\nnothing below them. ",
    "start": "2526470",
    "end": "2533900"
  },
  {
    "text": "So we satisfy the\nmax-heap property at i because there's no children. Otherwise, let's look at\nthe leaf among the left--",
    "start": "2533900",
    "end": "2544400"
  },
  {
    "text": "sorry, left not leaf-- among the two children\nleft and right of i.",
    "start": "2544400",
    "end": "2549640"
  },
  {
    "text": "Right if i might not exist. Then ignore it. But among the two\nchildren that exist,",
    "start": "2549640",
    "end": "2556000"
  },
  {
    "text": "find the one that has\nmaximum key value, Q[j].key.",
    "start": "2556000",
    "end": "2562327"
  },
  {
    "text": " That was 10 in our example.",
    "start": "2562327",
    "end": "2569090"
  },
  {
    "text": "And then, if these\nitems are out of order, if we do not satisfy--",
    "start": "2569090",
    "end": "2574460"
  },
  {
    "text": "so greater than\nwould be satisfy. Less than Q[j] would be the\nopposite of the max-heap",
    "start": "2574460",
    "end": "2580550"
  },
  {
    "text": "property here. If max-heap property\nis violated,",
    "start": "2580550",
    "end": "2586560"
  },
  {
    "text": "then we fix it by\nswapping Q[i] with Q[j],",
    "start": "2586560",
    "end": "2595160"
  },
  {
    "text": "and then we recurse on j-- ",
    "start": "2595160",
    "end": "2601700"
  },
  {
    "text": "call max_heapify_down of j. That's it. So pretty symmetric. Insert was a little bit\nsimpler, because we only",
    "start": "2601700",
    "end": "2608460"
  },
  {
    "text": "have one parent. Delete_min, because\nwe're pushing down, we have two children. We have to pick one.",
    "start": "2608460",
    "end": "2614140"
  },
  {
    "text": "But there's a clear\nchoice-- the bigger one. And again, this algorithm--\nthis whole thing-- will take order h time,\nthe height of the tree,",
    "start": "2614140",
    "end": "2620980"
  },
  {
    "text": "which is log n, because our\nnode just sort of bubbles down. At some point, it stops. When it stops, we know\nthe max-heap property",
    "start": "2620980",
    "end": "2627480"
  },
  {
    "text": "was satisfied there. And if you check along\nthe way, by induction, all the other\nmax-heap properties",
    "start": "2627480",
    "end": "2633000"
  },
  {
    "text": "will be satisfied,\nbecause they were before. So almost forced what\nwe could do here.",
    "start": "2633000",
    "end": "2639670"
  },
  {
    "text": "The amazing thing is\nthat you can actually maintain a complete\nbinary tree that satisfies the max-heap property.",
    "start": "2639670",
    "end": "2645800"
  },
  {
    "text": "But once you're told that, the\nalgorithm kind of falls out. Because we have an array. The only thing we can\ndo is insert and delete",
    "start": "2645800",
    "end": "2651680"
  },
  {
    "text": "the last item. And so we've got to swap\nthings to there in order-- or out of there in\norder to make that work.",
    "start": "2651680",
    "end": "2658170"
  },
  {
    "text": "And then, the rest is\njust checking locally that you can fix the property. ",
    "start": "2658170",
    "end": "2664930"
  },
  {
    "text": "Cool. So that's almost it, not\nquite what we wanted.",
    "start": "2664930",
    "end": "2672300"
  },
  {
    "text": "So we now have log n amortize\ninsert and delete_max in our heap.",
    "start": "2672300",
    "end": "2679330"
  },
  {
    "text": "We did not yet\ncover linear build. Right now, it's n log n\nif you insert n times.",
    "start": "2679330",
    "end": "2685070"
  },
  {
    "text": "And we did not yet cover how to\nmake this an in-place sorting algorithm. So let me sketch each of those.",
    "start": "2685070",
    "end": "2692660"
  },
  {
    "text": "I think first is in-place. So how do we make this\nalgorithm in-place?",
    "start": "2692660",
    "end": "2701530"
  },
  {
    "text": "I guess I want that,\nbut I don't need this. ",
    "start": "2701530",
    "end": "2706720"
  },
  {
    "text": "So we want to follow\npriority queue sort. Maybe I do want that. ",
    "start": "2706720",
    "end": "2716570"
  },
  {
    "text": "But I don't want to have to\ngrow and shrink my array.",
    "start": "2716570",
    "end": "2722060"
  },
  {
    "text": "I would just like to start\nwith the array itself. ",
    "start": "2722060",
    "end": "2736500"
  },
  {
    "text": "So this is in place. ",
    "start": "2736500",
    "end": "2741977"
  },
  {
    "text": "So what we're going to\ndo is say, OK, here's my array that I want to sort.",
    "start": "2741977",
    "end": "2747548"
  },
  {
    "text": "That's given to me. That's the input to\npriority queue sort. ",
    "start": "2747548",
    "end": "2753650"
  },
  {
    "text": "And what I'd like is to build\na priority queue out of it. Initially, it's empty. And then I want to insert the\nitems one at a time, let's say.",
    "start": "2753650",
    "end": "2762600"
  },
  {
    "text": "So in general, what\nI'm going to do is maintain that Q\nis some prefix of A.",
    "start": "2762600",
    "end": "2769018"
  },
  {
    "text": "That's going to be\nmy priority queue. It's going to live in this\nsub array-- this prefix.",
    "start": "2769018",
    "end": "2775110"
  },
  {
    "text": "So how do I insert a new item? Well, I just increment.",
    "start": "2775110",
    "end": "2780510"
  },
  {
    "text": "So to do an insert, the first\nstep is increment size of Q.",
    "start": "2780510",
    "end": "2789090"
  },
  {
    "text": "Then I will have taken\nthe next item from A and injected into this Q. And conveniently, if we look at\nour insert code, which is here,",
    "start": "2789090",
    "end": "2797430"
  },
  {
    "text": "the first thing we wanted\nto do was add an item at the end of the array. So we just did it without\nany actual work, just",
    "start": "2797430",
    "end": "2803940"
  },
  {
    "text": "conceptual work. We just said, oh,\nour Q is one bigger. Boom! Now this is at the\nend of the array.",
    "start": "2803940",
    "end": "2809430"
  },
  {
    "text": "no more amortization, in\nfact, because we're not ever resizing our array,\nwe're just saying, oh, now Q is a little bit\nbigger of a prefix.",
    "start": "2809430",
    "end": "2817050"
  },
  {
    "text": "It just absorb the\nnext item of A. Similarly, delete_max\nis going to,",
    "start": "2817050",
    "end": "2826329"
  },
  {
    "text": "at the end, decrement the\nsize of Q. Why is that OK?",
    "start": "2826330",
    "end": "2832260"
  },
  {
    "text": "Because at the end of our\ndelete_max operation-- not quite at the end,\nbut almost the end--",
    "start": "2832260",
    "end": "2839520"
  },
  {
    "text": "we deleted the last\nitem from our array. So we just replaced that\ndelete last with a decrement,",
    "start": "2839520",
    "end": "2845309"
  },
  {
    "text": "and that's going to\nshrink the Q by 1. It has the exact same impact\nas leading the last item.",
    "start": "2845310",
    "end": "2851430"
  },
  {
    "text": "But now, it's constant time,\nworst case not amortized. And the result is we never\nactually build a dynamic array.",
    "start": "2851430",
    "end": "2857790"
  },
  {
    "text": "We just use a portion\nof A to do it. So what's going\nto happen is we're going to absorb all the items\ninto the priority queue,",
    "start": "2857790",
    "end": "2863895"
  },
  {
    "text": "and then start kicking them out. As we kick them out, we kick\nout the largest key item first,",
    "start": "2863895",
    "end": "2869790"
  },
  {
    "text": "and we put it here, then\nthe next largest, then the next largest, and so on. The minimum item is\ngoing to be here.",
    "start": "2869790",
    "end": "2875010"
  },
  {
    "text": "And, boom, it's sorted. This is the whole reason I did\nmax-heaps instead of min-heaps,",
    "start": "2875010",
    "end": "2880079"
  },
  {
    "text": "is that in the end, this\nwill be a upward sorted array with the max at the end.",
    "start": "2880080",
    "end": "2885300"
  },
  {
    "text": "Because we always kick\nout items at the end. We delete the max first. So that is what's\nnormally called heapsort.",
    "start": "2885300",
    "end": "2895180"
  },
  {
    "text": "You can apply this same trick\nto insertion sort and selection sort, and you actually get the\ninsertion sort and selection",
    "start": "2895180",
    "end": "2901360"
  },
  {
    "text": "sort algorithms that\nwe've seen which operate in prefixes of the array.",
    "start": "2901360",
    "end": "2906920"
  },
  {
    "text": "Cool, so now we have-- we've achieved the\ny up there, which is n log n sorting\nalgorithm that is in-place.",
    "start": "2906920",
    "end": "2914390"
  },
  {
    "text": "So that was our main goal-- heapsort. Let me very quickly mention you\ncan build a heap in linear time",
    "start": "2914390",
    "end": "2926150"
  },
  {
    "text": "with a clever trick. So if you insert the\nitems one at a time, that would correspond to\ninserting down the array.",
    "start": "2926150",
    "end": "2933230"
  },
  {
    "text": "And every time I insert an item,\nI have to walk up the tree. So this would be the sum\nof the depth of each node.",
    "start": "2933230",
    "end": "2944170"
  },
  {
    "text": "If you do that, you get n log n. This is the sum over i of log i.",
    "start": "2944170",
    "end": "2952150"
  },
  {
    "text": "That turns out to be n log n. It's a log of n factorial.",
    "start": "2952150",
    "end": "2957310"
  },
  {
    "text": "The cool trick is\nto, instead, imagine adding all the items\nat once and not heapifying anything, and\nthen heapify up-- sorry,",
    "start": "2957310",
    "end": "2964805"
  },
  {
    "text": "heapify down from the bottom up. So here we're heapifying up.",
    "start": "2964805",
    "end": "2971530"
  },
  {
    "text": "Now, we're going\nto heapify down. And surprisingly, that's better.",
    "start": "2971530",
    "end": "2977079"
  },
  {
    "text": "Because this is the sum of\nthe heights of the nodes.",
    "start": "2977080",
    "end": "2982150"
  },
  {
    "text": "And that turns out to be linear. It's not obvious. But intuitively, for a depth,\nthis is 0, this is log n,",
    "start": "2982150",
    "end": "2989740"
  },
  {
    "text": "and we've got a\nwhole ton of leaves. So right at the leaf level, you\ncan see, we're paying n log n, right? Because there are n of them,\nand each one costs log n.",
    "start": "2989740",
    "end": "2997540"
  },
  {
    "text": "Down here, at the leaf\nlevel, we're paying constant. Because the height\nof the leaves are 1.",
    "start": "2997540",
    "end": "3003480"
  },
  {
    "text": "Here, the height of\nthe root is log n. And this is better. Now we're paying a small\namount for the thing",
    "start": "3003480",
    "end": "3009530"
  },
  {
    "text": "of which there are many. It's not quite a\ngeometric series, but it turns out this is linear.",
    "start": "3009530",
    "end": "3015090"
  },
  {
    "text": "So that's how you can\ndo linear building heap. To come back to your question\nabout sequence AVL trees,",
    "start": "3015090",
    "end": "3023450"
  },
  {
    "text": "turns out you can get\nall of the same bounds as heaps, except for\nthe in-place part, by taking a sequence\nAVL tree, storing",
    "start": "3023450",
    "end": "3030330"
  },
  {
    "text": "the items in an arbitrary\norder, and augmenting by max, which is a crazy idea.",
    "start": "3030330",
    "end": "3036210"
  },
  {
    "text": "But it also gives you\na linear build time. And yeah, there's other\nfun stuff in your notes. But I'll stop there.",
    "start": "3036210",
    "end": "3042980"
  },
  {
    "start": "3042980",
    "end": "3051077"
  }
]