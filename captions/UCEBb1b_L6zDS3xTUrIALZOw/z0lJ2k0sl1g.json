[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13339"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. ",
    "start": "13340",
    "end": "22419"
  },
  {
    "text": "ERIK DEMAINE: All right,\nlet's get started. Today we're going to continue\nthe theme of randomization",
    "start": "22420",
    "end": "29060"
  },
  {
    "text": "and data structures. Last time we saw skip lists. Skip lists solve the\npredecessor-successor problem.",
    "start": "29060",
    "end": "36010"
  },
  {
    "text": "You can search for an item\nand if it's not there, you get the closest item\non either side in log n",
    "start": "36010",
    "end": "41660"
  },
  {
    "text": "with high probability. But we already knew how to\ndo that deterministically. Today we're going to solve a\nslightly different problem,",
    "start": "41660",
    "end": "49400"
  },
  {
    "text": "the dictionary problem\nwith hash tables. Something you already\nthink you know.",
    "start": "49400",
    "end": "54610"
  },
  {
    "text": "But we're going to show you\nhow much you didn't know. But after today you will know.",
    "start": "54610",
    "end": "60080"
  },
  {
    "text": "And we're going to get\nconstant time and not with high probability. That's hard.",
    "start": "60080",
    "end": "66110"
  },
  {
    "text": "But we'll do constant\nexpected time. So that's in some sense better.",
    "start": "66110",
    "end": "71709"
  },
  {
    "text": "It's going to solve\na weaker problem. But we're going to get\ntighter bound constant instead of logarithmic.",
    "start": "71709",
    "end": "77940"
  },
  {
    "text": "So for starters let me remind\nyou what problem we're solving and the basics of hashing\nwhich you learned in 6006.",
    "start": "77940",
    "end": "90770"
  },
  {
    "text": "I'm going to give this problem\na name because it's important and we often forget\nto distinguish",
    "start": "90770",
    "end": "97880"
  },
  {
    "text": "between two types of things. ",
    "start": "97880",
    "end": "104070"
  },
  {
    "text": "This is kind of an old\nterm, but I would call this an abstract data type.",
    "start": "104070",
    "end": "111400"
  },
  {
    "text": "This is just the\nproblem specification of what you're trying to do.",
    "start": "111400",
    "end": "116580"
  },
  {
    "text": "You might call this an\ninterface or something. This is the problem statement\nversus the data structure is how you actually solve it.",
    "start": "116580",
    "end": "122219"
  },
  {
    "text": "The hash tables are\nthe data structure. The dictionary is the problem\nor the abstract data type.",
    "start": "122220",
    "end": "128300"
  },
  {
    "text": "So what we're\ntrying to do today, as in most data\nstructures, is maintain",
    "start": "128300",
    "end": "133530"
  },
  {
    "text": "a dynamic set of items.  And here I'm going to\ndistinguish between the items",
    "start": "133530",
    "end": "140920"
  },
  {
    "text": "and their keys.  Each item has a key. And normally you'd\nthink of there also",
    "start": "140920",
    "end": "147439"
  },
  {
    "text": "being a value like in Python. But we're just\nworrying about the keys and moving the items around.",
    "start": "147440",
    "end": "153760"
  },
  {
    "text": "And we want to support\nthree operations. ",
    "start": "153760",
    "end": "159770"
  },
  {
    "text": "We want to be able to insert\nan item, delete an item,",
    "start": "159770",
    "end": "173170"
  },
  {
    "text": "and search for an item. ",
    "start": "173170",
    "end": "178920"
  },
  {
    "text": "But search is going to\nbe different from what we know from AVL trees\nor skip lists or even",
    "start": "178920",
    "end": "184769"
  },
  {
    "text": "Venom [INAUDIBLE] That was a\npredecessor-successor search. Here we just want\nto know-- sorry,",
    "start": "184770",
    "end": "190779"
  },
  {
    "text": "your not searching for an item. Usually you're searching\nfor just a key-- here",
    "start": "190779",
    "end": "197760"
  },
  {
    "text": "you just want to know is\nthere any item with that key, and return it. ",
    "start": "197760",
    "end": "208880"
  },
  {
    "text": "This is often called\nan exact search because if the key\nis not in there, you learn absolutely nothing.",
    "start": "208880",
    "end": "216310"
  },
  {
    "text": "You can't find the nearest key. And for whatever reason this\nis called a dictionary problem",
    "start": "216310",
    "end": "221480"
  },
  {
    "text": "though it's unlike\na real dictionary. Usually when you search for a\nword you do find its neighbors. Here we're just going to\neither-- if the key's there",
    "start": "221480",
    "end": "228510"
  },
  {
    "text": "we find that, otherwise not. And this is exactly what a\nPython dictionary implements.",
    "start": "228510",
    "end": "235930"
  },
  {
    "text": "So I guess that's why Python\ndictionaries are called dicts.",
    "start": "235930",
    "end": "240980"
  },
  {
    "text": "So today I'm going to assume\nall items have distinct keys.",
    "start": "240980",
    "end": "247540"
  },
  {
    "text": "So in the insertion I will\nassume key is not already",
    "start": "247540",
    "end": "253480"
  },
  {
    "text": "in the table.  With a little bit\nof work, you can",
    "start": "253480",
    "end": "261769"
  },
  {
    "text": "allow inserting an item\nwith an existing key, and you just overwrite\nthat existing item.",
    "start": "261769",
    "end": "267240"
  },
  {
    "text": "But I don't want to\nworry about that here.  So we could, of course,\nsolve this using an AVL tree",
    "start": "267240",
    "end": "274300"
  },
  {
    "text": "in log n time. But our goal is to do better\nbecause it's an easier problem.",
    "start": "274300",
    "end": "280720"
  },
  {
    "text": "And I'm going to remind you\nof the simplest way you learn to do this which was hashing\nwith chaining in 006.",
    "start": "280720",
    "end": "290950"
  },
  {
    "text": "And the catch is you didn't\nreally analyze this in 006.",
    "start": "290950",
    "end": "297930"
  },
  {
    "text": "So we're going make a\nconstant time per operation. ",
    "start": "297930",
    "end": "306950"
  },
  {
    "text": "It's going to be expected or\nsomething and linear space.",
    "start": "306950",
    "end": "314570"
  },
  {
    "text": " And remember the\nvariables we care",
    "start": "314570",
    "end": "322340"
  },
  {
    "text": "about, there's u, n, and m. So u is the size\nof the universe.",
    "start": "322340",
    "end": "328860"
  },
  {
    "text": "This is the all possible keys. The space of all possible keys. ",
    "start": "328860",
    "end": "338900"
  },
  {
    "text": "n is the size of the set\nyour currently storing. So that's the number\nof items or keys",
    "start": "338900",
    "end": "347130"
  },
  {
    "text": "currently in the data structure. ",
    "start": "347130",
    "end": "354510"
  },
  {
    "text": "And then m is the\nsize of your table. So say it's the number\nof slots in the table.",
    "start": "354510",
    "end": "361390"
  },
  {
    "text": " So you remember the picture. You have a table of slots.",
    "start": "361390",
    "end": "370630"
  },
  {
    "text": "Let's say 0 to m minus 1. Each of them is a\npointer to a linked list. ",
    "start": "370630",
    "end": "378610"
  },
  {
    "text": "And if you have,\nlet's say over here is your universe of\nall possible keys,",
    "start": "378610",
    "end": "384660"
  },
  {
    "text": "then we have a hash function\nwhich maps each universe item into one of these slots.",
    "start": "384660",
    "end": "392950"
  },
  {
    "text": "And then the linked\nlist here is storing all of the items that\nhash to that slot.",
    "start": "392950",
    "end": "398720"
  },
  {
    "text": "So we have a hash function\nwhich maps the universe.",
    "start": "398720",
    "end": "409810"
  },
  {
    "text": "I'm going to assume the\nuniverse has already been mapped into integers 0 to u minus 1. And it maps to slots.",
    "start": "409810",
    "end": "416389"
  },
  {
    "start": "416390",
    "end": "422660"
  },
  {
    "text": "And when we do\nhashing with chaining, I think I mentioned this\nlast week, the bounds",
    "start": "422660",
    "end": "429780"
  },
  {
    "text": "you get, we achieve\na bound of 1 plus",
    "start": "429780",
    "end": "443950"
  },
  {
    "text": "alpha where alpha is\nthe load factor n/m.",
    "start": "443950",
    "end": "449450"
  },
  {
    "text": "The average number of items\nyou'd expect to hash to a slot is the number of items divided\nby the number of slots.",
    "start": "449450",
    "end": "456710"
  },
  {
    "text": "OK. And you proved this\nin 6006 but you",
    "start": "456710",
    "end": "461770"
  },
  {
    "text": "assumed something called\nsimple uniform hashing.",
    "start": "461770",
    "end": "467199"
  },
  {
    "start": "467200",
    "end": "485590"
  },
  {
    "text": "Simple uniform hashing\nis an assumption, I think invented for CLRS.",
    "start": "485590",
    "end": "490750"
  },
  {
    "text": "It makes the\nanalysis very simple, but it's also\nbasically cheating. So today our goal\nis to not cheat.",
    "start": "490750",
    "end": "497820"
  },
  {
    "text": "It's nice as a warm up. But we don't like cheating. So you may recall the assumption\nis about the hash function.",
    "start": "497820",
    "end": "514270"
  },
  {
    "text": "You want a good hash function. And good means this.",
    "start": "514270",
    "end": "523080"
  },
  {
    "text": "I want the probability\nof two distinct keys mapping to the same slot to\nbe 1/m if there are m slots.",
    "start": "523080",
    "end": "531519"
  },
  {
    "text": "If everything was\ncompletely random, if h was basically choosing a\nrandom number for every key,",
    "start": "531520",
    "end": "537290"
  },
  {
    "text": "then that's what we\nwould expect to happen. So this is like the\nidealized scenario.",
    "start": "537290",
    "end": "542550"
  },
  {
    "text": "Now, we can't have\na hash function could choosing a random\nnumber for every key because it has to choose the\nsame value if you give it",
    "start": "542550",
    "end": "549250"
  },
  {
    "text": "the same key. So it has to be some kind\nof deterministic strategy or at least repeatable\nstrategy where",
    "start": "549250",
    "end": "555570"
  },
  {
    "text": "if you plug in the same\nkey you get the same thing. So really what this\nassumption is saying is that the key's that you\ngive are in some sense random.",
    "start": "555570",
    "end": "568750"
  },
  {
    "text": "If I give you random keys\nand I have not-too-crazy hash function then this will be true.",
    "start": "568750",
    "end": "576459"
  },
  {
    "text": "But I don't like assuming\nanything about the keys maybe. I want my keys to\nbe worst case maybe.",
    "start": "576460",
    "end": "584190"
  },
  {
    "text": "There are lots of examples in\nthe real world where you apply some hash function\nand it turns out",
    "start": "584190",
    "end": "589330"
  },
  {
    "text": "your data has some very\nparticular structure. And if you choose a\nbad hash function, then your hash table\ngets really, really slow.",
    "start": "589330",
    "end": "596350"
  },
  {
    "text": "Maybe everything hashes\nto the same slot. Or say you take--\nwell yeah, there",
    "start": "596350",
    "end": "602920"
  },
  {
    "text": "are lots of examples of that. We want to avoid that. After today you will know how to\nachieve constant expected time",
    "start": "602920",
    "end": "610649"
  },
  {
    "text": "no matter what your keys\nare, for worst case keys. But it's going to take\nsome work to do that.",
    "start": "610650",
    "end": "618140"
  },
  {
    "text": "So this assumption\nrequires assuming",
    "start": "618140",
    "end": "626080"
  },
  {
    "text": "that the keys are random. ",
    "start": "626080",
    "end": "632447"
  },
  {
    "text": "And this is what we would\ncall an average case analysis. ",
    "start": "632447",
    "end": "641296"
  },
  {
    "text": "You might think that\naverage case analysis is necessary for\nrandomized algorithms, but that's not true.",
    "start": "641296",
    "end": "647800"
  },
  {
    "text": "And we saw that last\nweek with quicksort. Quicksort, if you say I\nwill always choose a of 1",
    "start": "647800",
    "end": "654660"
  },
  {
    "text": "to be my partition\nelement, that's what the textbook calls\nbasic quicksort, then",
    "start": "654660",
    "end": "660770"
  },
  {
    "text": "for an average input\nthat will do really well. If you have a uniform\nrandom permutation of items",
    "start": "660770",
    "end": "667610"
  },
  {
    "text": "and you sort with the method of\nalways choosing the first item as your partition, then that\nwill be n log n on average",
    "start": "667610",
    "end": "676090"
  },
  {
    "text": "if your data is average. But we saw we could\navoid that assumption",
    "start": "676090",
    "end": "681269"
  },
  {
    "text": "by choosing a random pivot. If you choose a\nrandom pivot, then you don't need to assume\nanything about the input.",
    "start": "681270",
    "end": "687836"
  },
  {
    "text": "You just need to assume\nthat the pivots are random. So it's a big difference between\nassuming your inputs are random versus assuming your\ncoin flips are random.",
    "start": "687836",
    "end": "695230"
  },
  {
    "text": "It's pretty reasonable to\nassume you can flip coins. If you've got enough\ndexterity in your thumb then",
    "start": "695230",
    "end": "701610"
  },
  {
    "text": "you can do it. But it's not so\nreasonable to assume that your input is random. So we'd like to avoid average\ncase analysis whenever we can,",
    "start": "701610",
    "end": "710011"
  },
  {
    "text": "and that's the goal of today. So what you saw in 006 was\nessentially assuming the inputs are random.",
    "start": "710012",
    "end": "715089"
  },
  {
    "text": "We're going to get rid of that\nunreasonable assumption today. ",
    "start": "715089",
    "end": "723860"
  },
  {
    "text": "So that's, in some\nsense, review from 006. I'm going to take a\nbrief pause and tell you",
    "start": "723860",
    "end": "730430"
  },
  {
    "text": "about the etymology of the word\nhash in case you're curious. Hash is an English word since\nthe 1650's, so it's pretty old.",
    "start": "730430",
    "end": "745019"
  },
  {
    "text": "It means literally\ncut into small pieces. It's usually used\nin a culinary sense,",
    "start": "745020",
    "end": "751520"
  },
  {
    "text": "like these days you have\ncorned beef hash or something. I'll put the\ndefinition over here.",
    "start": "751520",
    "end": "757828"
  },
  {
    "start": "757828",
    "end": "765480"
  },
  {
    "text": "It comes from French, hacher,\nwhich means to chop up.",
    "start": "765480",
    "end": "781130"
  },
  {
    "text": " You know it in English\nfrom the word hatchet.",
    "start": "781130",
    "end": "788660"
  },
  {
    "text": "So it's the same derivation.  And it comes from old French--\nI don't actually know whether",
    "start": "788660",
    "end": "800519"
  },
  {
    "text": "that's \"hash-ay\" or \"hash\"\nbut-- which means axe.",
    "start": "800520",
    "end": "810916"
  },
  {
    "text": "So you can see the derivation. ",
    "start": "810916",
    "end": "815940"
  },
  {
    "text": "If you look this\nup in OED or pick your favorite dictionary or even\nGoogle, that's what you find.",
    "start": "815940",
    "end": "821760"
  },
  {
    "text": "But in fact there's a\nnew prevailing theory that in fact hash comes\nfrom another language which",
    "start": "821760",
    "end": "833570"
  },
  {
    "text": "is Vulcan, la'ash, I mean you\ncan see the derivation right?",
    "start": "833570",
    "end": "841140"
  },
  {
    "text": "Actually means axe. So maybe French got it\nfrom Vulcan or vice versa",
    "start": "841140",
    "end": "846800"
  },
  {
    "text": "but I think that's pretty clear. Live long and prosper,\nand farewell to Spock.",
    "start": "846800",
    "end": "853959"
  },
  {
    "text": " Sad news of last week. ",
    "start": "853960",
    "end": "860880"
  },
  {
    "text": "So enough about hashing. We'll come back to\nthat in a little bit. But hash functions\nessentially take up",
    "start": "860880",
    "end": "867050"
  },
  {
    "text": "this idea of taking your\nkey, chopping up into pieces, and mixing it like\nin a good dish.",
    "start": "867050",
    "end": "875910"
  },
  {
    "text": "All right, so we're going\nto cover two ways to get strong constant time bounds.",
    "start": "875910",
    "end": "883186"
  },
  {
    "text": "Probably the most useful one\nis called universal hashing. We'll spend most of\nour time on that. But the theoretically cooler\none is called perfect hashing.",
    "start": "883186",
    "end": "890379"
  },
  {
    "text": "Universal hashing,\nwe're going to guarantee there are very few\nconflicts in expectation. Perfect hashing , we're going\nto guarantee there are zero",
    "start": "890379",
    "end": "896990"
  },
  {
    "text": "conflicts. The catch is, at least\nin its obvious form, it only works for static sets.",
    "start": "896990",
    "end": "904290"
  },
  {
    "text": "If you forbid, insert,\nand delete and just want to do search, then perfect\nhashing is a good method.",
    "start": "904290",
    "end": "910894"
  },
  {
    "text": "So like if you're\nactually storing a dictionary, like\nthe OED, English doesn't change that quickly.",
    "start": "910894",
    "end": "916630"
  },
  {
    "text": "So you can afford to recompute\nyour data structure whenever you release a new edition.",
    "start": "916630",
    "end": "922285"
  },
  {
    "text": "But let's start with\nuniversal hashing. This is a nice\npowerful technique.",
    "start": "922285",
    "end": "927600"
  },
  {
    "text": "It works for dynamic data. Insert, delete, and\nsearch will be constant expected time with no\nassumptions about the input.",
    "start": "927600",
    "end": "936339"
  },
  {
    "text": "So it will not be average case. It's in some sense worse\ncase but randomized. ",
    "start": "936340",
    "end": "943000"
  },
  {
    "text": "So the idea is we need\nto do something random. If you just say, well, I\nchoose one hash function",
    "start": "943000",
    "end": "948900"
  },
  {
    "text": "once and for all, and I\nuse that for my table, OK maybe my table\ndoubles in size and I change the hash function.",
    "start": "948900",
    "end": "954070"
  },
  {
    "text": "But there's no randomness there. We need to introduce\nrandomness somehow",
    "start": "954070",
    "end": "959740"
  },
  {
    "text": "into this data structure. And the way we're\ngoing to do that is in how we choose\nthe hash function.",
    "start": "959740",
    "end": "967160"
  },
  {
    "text": "We're going to choose our\nhash function randomly",
    "start": "967160",
    "end": "977579"
  },
  {
    "text": "from some set of hash functions. Call it h. This is going to be a\nuniversal hash family.",
    "start": "977580",
    "end": "985845"
  },
  {
    "text": "We're going to imagine\nthere are many possible hash functions we could choose. If we choose one of them\nuniformly at random,",
    "start": "985845",
    "end": "991780"
  },
  {
    "text": "that's a random choice. And that randomness\nis going to be enough that we no longer need to\nassume anything about the keys.",
    "start": "991780",
    "end": "999750"
  },
  {
    "text": "So for that to work, we need\nsome assumption about h.",
    "start": "999750",
    "end": "1006800"
  },
  {
    "text": "Maybe it's just a set\nof one hash function. That wouldn't add\nmuch randomness. Two also would not\nadd much randomness.",
    "start": "1006800",
    "end": "1012540"
  },
  {
    "text": "We need a lot of them. And so we're going to require\nH to have this property. ",
    "start": "1012540",
    "end": "1019070"
  },
  {
    "text": "And we're going to call it\nthe property universality. ",
    "start": "1019070",
    "end": "1024770"
  },
  {
    "text": "Generally you would call\nit a universal hash family. ",
    "start": "1024770",
    "end": "1031589"
  },
  {
    "text": "Just a set of hash functions. What we want is that-- so we're\nchoosing our hash function",
    "start": "1031589",
    "end": "1041390"
  },
  {
    "text": "h from H. And\namong those choices we want the probability that\ntwo keys hash to the same value",
    "start": "1041390",
    "end": "1051179"
  },
  {
    "text": "to be small. ",
    "start": "1051180",
    "end": "1062520"
  },
  {
    "text": "I'll say-- and this\nis very similar",
    "start": "1062520",
    "end": "1071610"
  },
  {
    "text": "looking to simple\nuniform hashing. Looks almost the same here\nexcept I switched from k1",
    "start": "1071610",
    "end": "1079130"
  },
  {
    "text": "and k2 to k and\nk', but same thing. But what we're taking\nthe probability over,",
    "start": "1079130",
    "end": "1085770"
  },
  {
    "text": "what we're assuming is\nrandom is different. Here we're assuming k1 and\nk2 a are because h was fixed.",
    "start": "1085770",
    "end": "1092519"
  },
  {
    "text": "This was an assumption\nabout the inputs. Over here we're thinking\nof k and k' as being fixed.",
    "start": "1092520",
    "end": "1099970"
  },
  {
    "text": "This has to work for every\npair of distinct keys. And the probability\nwe're considering",
    "start": "1099970",
    "end": "1105400"
  },
  {
    "text": "is the distribution of h. So we're trying all the\ndifferent h's Or we're trying",
    "start": "1105400",
    "end": "1111470"
  },
  {
    "text": "little h uniformly at random. We want the probability that a\nrandom h makes k and k' collide",
    "start": "1111470",
    "end": "1117730"
  },
  {
    "text": "to be at most 1/m. The other difference is we\nswitch from equals to at most.",
    "start": "1117730",
    "end": "1124030"
  },
  {
    "text": "I mean less would be better. And there are ways to make\nit less for a couple pairs but it doesn't really matter.",
    "start": "1124030",
    "end": "1130310"
  },
  {
    "text": "But of course anything\nless than or equal to 1/m will be just as good. So this is an\nassumption about H.",
    "start": "1130310",
    "end": "1137960"
  },
  {
    "text": "We'll see how to achieve this\nassumption in a little bit. Let me first prove to\nyou that this is enough.",
    "start": "1137960",
    "end": "1144510"
  },
  {
    "text": "It's going to be basically\nthe same as the 006 analysis. But it's worth repeating just\nso we are sure everything's OK.",
    "start": "1144510",
    "end": "1153870"
  },
  {
    "start": "1153870",
    "end": "1160230"
  },
  {
    "text": "And so I can be more precise\nabout what we're assuming. ",
    "start": "1160230",
    "end": "1179240"
  },
  {
    "text": "The key difference between this\ntheorem and the 006 theorem is we get to make no\nassumptions about the keys.",
    "start": "1179240",
    "end": "1184740"
  },
  {
    "text": "They are arbitrary. You get to choose\nthem however you want. But then I choose a\nrandom hash function.",
    "start": "1184740",
    "end": "1191680"
  },
  {
    "text": "The hash function cannot\ndepend on these keys. But it's going to be random. And I choose the hash function\nafter you choose the keys.",
    "start": "1191680",
    "end": "1199860"
  },
  {
    "text": "That's important. ",
    "start": "1199860",
    "end": "1207570"
  },
  {
    "text": "So we're going to\nchoose a random h and H. And we're assuming\nH is universal.",
    "start": "1207570",
    "end": "1214110"
  },
  {
    "text": " Then the expected number of keys\nin a slot among those n keys",
    "start": "1214110",
    "end": "1235680"
  },
  {
    "text": "is at most 1 plus alpha. Alpha is n/m.",
    "start": "1235680",
    "end": "1241260"
  },
  {
    "text": "So this is exactly\nwhat we had over here. Here we're talking\nabout time bound.",
    "start": "1241260",
    "end": "1247559"
  },
  {
    "text": "But the time bound\nfollowed because the length of each chain was expected\nto be 1 plus alpha.",
    "start": "1247560",
    "end": "1253630"
  },
  {
    "text": "And here the expectation\nis over the choice of h. Not assuming anything\nabout the keys.",
    "start": "1253630",
    "end": "1261910"
  },
  {
    "text": "So let's prove this theorem. ",
    "start": "1261910",
    "end": "1268920"
  },
  {
    "text": "It's pretty easy. But I'm going to introduce\nsome analysis techniques that we will use for\nmore interesting things.",
    "start": "1268920",
    "end": "1276880"
  },
  {
    "text": "So let's give the keys a name. I'll just call\nthem-- I'll be lazy.",
    "start": "1276880",
    "end": "1288380"
  },
  {
    "text": "Use k1 up to kn. ",
    "start": "1288380",
    "end": "1295679"
  },
  {
    "text": "And I just want to\ncompute that expectation.",
    "start": "1295680",
    "end": "1301100"
  },
  {
    "start": "1301100",
    "end": "1313620"
  },
  {
    "text": "So I want to compute let's say\nthe number of keys colliding",
    "start": "1313620",
    "end": "1321820"
  },
  {
    "text": "with one of those\nkeys, let's say ki. ",
    "start": "1321820",
    "end": "1332840"
  },
  {
    "text": "So this is of course the size of\nthe slot that ki happens to go. This is going to work for all i.",
    "start": "1332840",
    "end": "1338220"
  },
  {
    "text": "And so if I can say that this\nis at most 1/alpha for each i, then I have my theorem.",
    "start": "1338220",
    "end": "1343919"
  },
  {
    "text": "Just another way\nto talk about it. Now the number of keys\ncolliding with ki, here's",
    "start": "1343920",
    "end": "1349100"
  },
  {
    "text": "a general trick, whenever\nyou want to count something in expectation, a\nvery helpful tool",
    "start": "1349100",
    "end": "1354820"
  },
  {
    "text": "is indicator random variables. Let's name all of the different\nevents that we want to count.",
    "start": "1354820",
    "end": "1362530"
  },
  {
    "text": "And then we're basically\nsumming those variables. So I'm going to say-- I'm going\nto use I ij to be an indicator",
    "start": "1362530",
    "end": "1373514"
  },
  {
    "text": "random variable. It's going to be 1 or 0. 1 if hash function of ki\nequals the hash function of kj.",
    "start": "1373514",
    "end": "1386664"
  },
  {
    "text": "So there's a collision\nbetween ki and kj j and 0 if they hash to different slots.",
    "start": "1386665",
    "end": "1392280"
  },
  {
    "text": " Now this is, it's a random\nvariable because it depends",
    "start": "1392280",
    "end": "1397659"
  },
  {
    "text": "on h and h is a random thing. ki and kj are not random. They're given to you.",
    "start": "1397660",
    "end": "1404290"
  },
  {
    "text": "And then I want to know\nwhen does h back those two keys to the same slot.",
    "start": "1404290",
    "end": "1410660"
  },
  {
    "text": "And so this number is really\njust the sum of Iij over all j.",
    "start": "1410660",
    "end": "1419070"
  },
  {
    "text": "This is the same thing. The number in here is the sum\nfor j not equal to i of Iij.",
    "start": "1419070",
    "end": "1430620"
  },
  {
    "text": "Because we get a 1 every time\nthey collide, zero otherwise. So that counts how many collide.",
    "start": "1430620",
    "end": "1437169"
  },
  {
    "text": "Once we have it\nin this notation, we can use all the great\ndilemmas and theorems",
    "start": "1437170",
    "end": "1442600"
  },
  {
    "text": "about in this case,\nE, expectation. What should I use here? ",
    "start": "1442600",
    "end": "1450442"
  },
  {
    "text": "STUDENT: What? ERIK DEMAINE: What's\na good-- how can I simplify this formula? STUDENT: The linearity\nof expectation.",
    "start": "1450442",
    "end": "1456625"
  },
  {
    "text": "ERIK DEMAINE: The\nlinearity of expectation. Thank you.  If you don't know\nall these things,",
    "start": "1456625",
    "end": "1461640"
  },
  {
    "text": "read the probability\nappendix in the textbook. So we want to talk\nabout expectation",
    "start": "1461640",
    "end": "1469279"
  },
  {
    "text": "of the simplest thing possible. So linearity let's us\nput the E inside the sum",
    "start": "1469280",
    "end": "1475909"
  },
  {
    "text": "without losing anything. Now the expectation of an\nindicator random variable",
    "start": "1475910",
    "end": "1481600"
  },
  {
    "text": "is pretty simple\nbecause the zeros don't contribute to the expectation. The 1's contribute 1.",
    "start": "1481600",
    "end": "1487310"
  },
  {
    "text": "So this is the same thing\nas just the probability of this being 1. So we get sum of j9 equal\nto I of the probability",
    "start": "1487310",
    "end": "1499700"
  },
  {
    "text": "that Iij equals 1.",
    "start": "1499700",
    "end": "1504980"
  },
  {
    "text": "And the probability\nthat Iij equals 1, well, that's the probability\nthat this happens.",
    "start": "1504980",
    "end": "1511570"
  },
  {
    "text": "And what's the probability\nthat that happens? At most 1/m our universality.",
    "start": "1511570",
    "end": "1518520"
  },
  {
    "text": "So I'm going to--\nI'll write it out. This is sum j not\nequal to I. Probability",
    "start": "1518520",
    "end": "1526450"
  },
  {
    "text": "that h maps ki and\nkj to the same slot. ",
    "start": "1526450",
    "end": "1534870"
  },
  {
    "text": "So that's the definition of Iij. And this is at most\nsum j not equal to i",
    "start": "1534870",
    "end": "1541950"
  },
  {
    "text": "of 1/m by universality. So here's where we're using it. ",
    "start": "1541950",
    "end": "1550450"
  },
  {
    "text": "And sum of j not equal to\nI, well that's basically n.",
    "start": "1550450",
    "end": "1556029"
  },
  {
    "start": "1556030",
    "end": "1564920"
  },
  {
    "text": "But I made a mistake here. Slightly off. From here-- yeah.",
    "start": "1564920",
    "end": "1571409"
  },
  {
    "text": "So this line is wrong. Sorry. Let me fix it. Because this\nassumption only works",
    "start": "1571410",
    "end": "1578430"
  },
  {
    "text": "when the keys are distinct. So in fact-- how did I get\nj-- yeah. , Yeah, sorry.",
    "start": "1578430",
    "end": "1592070"
  },
  {
    "text": "This should have been\nthis-- actually everything I said is true, but if you want\nto count the number of keys--",
    "start": "1592070",
    "end": "1597960"
  },
  {
    "text": "I really wanted to count the\ntotal number of keys that hash to the same place as ki.",
    "start": "1597960",
    "end": "1603630"
  },
  {
    "text": "So there's one more\nwhich is ki itself. Always hashes to\nwherever ki hashes.",
    "start": "1603630",
    "end": "1608920"
  },
  {
    "text": "So I did a summation\nj not equal i but I should also have\na plus Iii-- captain.",
    "start": "1608920",
    "end": "1617670"
  },
  {
    "text": "So there's the case when I\nhashing to the same place which",
    "start": "1617670",
    "end": "1623650"
  },
  {
    "text": "of course is always going to\nhappen so you get basically plus 1 everywhere. ",
    "start": "1623650",
    "end": "1631389"
  },
  {
    "text": "So that makes me\nhappier because then I actually get with the theorem\nsaid which is 1 plus alpha. There is always going to be\nthe one guy hashing there",
    "start": "1631390",
    "end": "1638539"
  },
  {
    "text": "when I assume that ki\nhashed to wherever it does. ",
    "start": "1638540",
    "end": "1644650"
  },
  {
    "text": "So this tells you that if we\ncould find a universal hash family, then we're guaranteed\ninsert, delete, and search",
    "start": "1644650",
    "end": "1652799"
  },
  {
    "text": "cost order 1 plus\nalpha in expectation. And the expectation is\nonly over the choice of h,",
    "start": "1652800",
    "end": "1658520"
  },
  {
    "text": "not over the inputs. I think I've stressed\nthat enough times. But the remaining question\nis can we actually",
    "start": "1658520",
    "end": "1664340"
  },
  {
    "text": "design a universal hash family? Are there any universal\nhash families? ",
    "start": "1664340",
    "end": "1673960"
  },
  {
    "text": "Yes, as you might\nexpect there are. Otherwise this wouldn't\nbe very interesting. ",
    "start": "1673960",
    "end": "1687140"
  },
  {
    "text": "Let me give you an example of\na bad universal hash family.",
    "start": "1687140",
    "end": "1692990"
  },
  {
    "text": "Sort of an oxymoron\nbut it's possible. ",
    "start": "1692990",
    "end": "1704190"
  },
  {
    "text": "Bad. Here's a hash family\nthat's universal. h is the set of\nall hash functions.",
    "start": "1704190",
    "end": "1712360"
  },
  {
    "text": "h from 0,1 to u minus 1. ",
    "start": "1712360",
    "end": "1724010"
  },
  {
    "text": "This is what's normally\ncalled uniform hashing. It makes analysis\nreally easy because you",
    "start": "1724010",
    "end": "1730350"
  },
  {
    "text": "get to assume-- I\nmean this says ahead of time for every\nuniverse item, I'm",
    "start": "1730350",
    "end": "1735500"
  },
  {
    "text": "going to choose a\nrandom slot to put it. And then I'll just\nremember that.",
    "start": "1735500",
    "end": "1741510"
  },
  {
    "text": "And so whenever you give me\nthe key, I'll just map it by h. And I get a consistent slot\nand definitely it's universal.",
    "start": "1741510",
    "end": "1750420"
  },
  {
    "text": "What's bad about\nthis hash function? Many things but-- ",
    "start": "1750420",
    "end": "1757427"
  },
  {
    "text": "STUDENT: [INAUDIBLE] That's\njust as hard as the problem I'm",
    "start": "1757427",
    "end": "1762520"
  },
  {
    "text": "solving. ERIK DEMAINE: Sort of. I'm begging the\nquestion that it's just as hard as the\nproblem I'm solving. And what, algorithmically,\nwhat goes wrong here?",
    "start": "1762520",
    "end": "1771022"
  },
  {
    "text": "There are two things I guess. ",
    "start": "1771022",
    "end": "1778304"
  },
  {
    "text": "Yeah? STUDENT: It's not deterministic? ERIK DEMAINE: It's\nnot deterministic. That's OK because we're\nallowing randomization",
    "start": "1778304",
    "end": "1785275"
  },
  {
    "text": "in this algorithm. So I mean how I\nwould compute this is I would do a four loop\nover all universe items.",
    "start": "1785275",
    "end": "1792610"
  },
  {
    "text": "And I assume I have a way\nto generate a random number between 0 and m minus 1. That's legitimate.",
    "start": "1792610",
    "end": "1798570"
  },
  {
    "text": "But there's something\nbad about that algorithm. STUDENT: It's not consistent. ERIK DEMAINE: Not consistent?",
    "start": "1798570",
    "end": "1803758"
  },
  {
    "text": "It is consistent if I precompute\nfor every universe item where to map it. That's good. So all these things\nare actually OK.",
    "start": "1803758",
    "end": "1810669"
  },
  {
    "text": "STUDENT: It takes too\nmuch time and space. ERIK DEMAINE: It takes\ntoo much time and space. Yeah.",
    "start": "1810670",
    "end": "1816460"
  },
  {
    "text": "That's the bad thing. It's hard to isolate in a bad\nthing what is so bad about it.",
    "start": "1816460",
    "end": "1822640"
  },
  {
    "text": "But we need u time to compute\nall those random numbers.",
    "start": "1822640",
    "end": "1829710"
  },
  {
    "text": "And we need u space to\nstore that hash function. In order to get to the\nconsistency we have to-- Oops.",
    "start": "1829710",
    "end": "1837270"
  },
  {
    "text": "Good catch. In order to get\nconsistency, we need to keep track of all those\nhash function values.",
    "start": "1837270",
    "end": "1843840"
  },
  {
    "text": "And that's not good. You could try to not\nstore them all, you know,",
    "start": "1843840",
    "end": "1849440"
  },
  {
    "text": "use a hash table. But you can't use a hash table\nto store a hash function. That would be-- that would\nbe infinite recursion.",
    "start": "1849440",
    "end": "1858180"
  },
  {
    "text": "So but at least\nthey're out there. So the challenge is to find\nan efficient hash family that",
    "start": "1858180",
    "end": "1863510"
  },
  {
    "text": "doesn't take much space\nto store and doesn't take much time to compute. OK, we're allowing randomness.",
    "start": "1863510",
    "end": "1869786"
  },
  {
    "start": "1869786",
    "end": "1879720"
  },
  {
    "text": "But we don't want\nto much randomness. We can't afford u units\nof time of randomness. I mean u could be huge.",
    "start": "1879720",
    "end": "1885630"
  },
  {
    "text": "We're only doing n operations\nprobably on this hash table. u could be way bigger than n.",
    "start": "1885630",
    "end": "1891030"
  },
  {
    "text": "We don't want to have to\nprecompute this giant table and then use it for\nlike five steps. It would be really, really\nslow even amortized.",
    "start": "1891030",
    "end": "1898220"
  },
  {
    "text": "So here's one that\nI will analyze. And there's another one in the\ntextbook which I'll mention.",
    "start": "1898220",
    "end": "1905000"
  },
  {
    "text": " This one's a little\nbit simpler to analyze.",
    "start": "1905000",
    "end": "1913359"
  },
  {
    "text": "We're going to need a little\nbit of number theory, just prime numbers. And you've probably heard of\nthe idea of your hash table size",
    "start": "1913359",
    "end": "1922240"
  },
  {
    "text": "being prime. Here you'll see\nwhy that's useful, at least for this family. You don't always need\nprimality, but it's",
    "start": "1922240",
    "end": "1928860"
  },
  {
    "text": "going to make this family work. So I'm going to assume that\nmy table size is prime.",
    "start": "1928860",
    "end": "1934429"
  },
  {
    "text": "Now really my table\nsize is doubling, so that's a little awkward. But luckily there are\nalgorithms given a number",
    "start": "1934430",
    "end": "1941549"
  },
  {
    "text": "to find a nearby prime number. We're not going to\ncover that here, but that's an algorithmic\nnumber theory thing.",
    "start": "1941550",
    "end": "1947500"
  },
  {
    "text": "And in polylogarithmic\ntime, I guess you can find a\nnearby prime number.",
    "start": "1947500",
    "end": "1953340"
  },
  {
    "text": "So you want it to\nbe a power of 2. And you'll just look around\nfor nearby prime numbers.",
    "start": "1953340",
    "end": "1958390"
  },
  {
    "text": "And then we have a prime that's\nabout the same size so that will work just as well from\na table doubling perspective.",
    "start": "1958390",
    "end": "1965549"
  },
  {
    "text": "Then furthermore,\nfor convenience, I'm going to assume that u\nis an integer power of m.",
    "start": "1965550",
    "end": "1973740"
  },
  {
    "start": "1973740",
    "end": "1981403"
  },
  {
    "text": "I want my universe to be\na power of that prime.",
    "start": "1981404",
    "end": "1986489"
  },
  {
    "text": "I mean, if it isn't, just\nmake u a little bigger. It's OK if u gets\nbigger as long as it covers all of the same items.",
    "start": "1986489",
    "end": "1993450"
  },
  {
    "text": "Now once I view my universe\nas a power of the table size,",
    "start": "1993450",
    "end": "1999340"
  },
  {
    "text": "a natural thing to do is\ntake my universe items, to take my input integers,\nand think of them in base m.",
    "start": "1999340",
    "end": "2007530"
  },
  {
    "text": "So that's what I'm going to do. I'm going to view\na key k in base m.",
    "start": "2007530",
    "end": "2017880"
  },
  {
    "text": "Whenever I have a\nkey, I can think of it as a vector of subkeys,\nk1 up to kr minus 1.",
    "start": "2017880",
    "end": "2031850"
  },
  {
    "text": "There are digits in base m\nbecause of this relation.",
    "start": "2031850",
    "end": "2037023"
  },
  {
    "text": "And I don't even care which\nis the least significant and which is the\nmost significant. That won't matter so\nwhatever, whichever order",
    "start": "2037024",
    "end": "2042630"
  },
  {
    "text": "you want to think of it. And each of the\nki's here I guess",
    "start": "2042630",
    "end": "2048830"
  },
  {
    "text": "is between 0 and m minus 1. ",
    "start": "2048830",
    "end": "2057480"
  },
  {
    "text": "So far so good. ",
    "start": "2057480",
    "end": "2077760"
  },
  {
    "text": "So with this perspective,\nthe base m perspective, I can define a dot product\nhash function as follows.",
    "start": "2077760",
    "end": "2085469"
  },
  {
    "text": "It's going to be\nparametrized by another key, I'll call it a, which we can\nthink of again as a vector.",
    "start": "2085469",
    "end": "2092865"
  },
  {
    "text": " I want to define h sub a of k.",
    "start": "2092865",
    "end": "2103039"
  },
  {
    "text": "So this is parametrized\nby a, but it's a function of a given\nkey k as the dot product",
    "start": "2103040",
    "end": "2110910"
  },
  {
    "text": "of those two vectors mod m. ",
    "start": "2110910",
    "end": "2116390"
  },
  {
    "text": "So remember dot products\nare just the sum from i equals 0 to r minus\n1 of a1 times ki.",
    "start": "2116390",
    "end": "2126800"
  },
  {
    "text": "I want to do all\nof that modulo m. We'll worry about\nhow long this takes",
    "start": "2126800",
    "end": "2133992"
  },
  {
    "text": "to compute in a moment I guess. Maybe very soon.",
    "start": "2133992",
    "end": "2140680"
  },
  {
    "text": "But the hash family h is\njust all of these ha's",
    "start": "2140680",
    "end": "2145690"
  },
  {
    "text": "for all possible choices of a. ",
    "start": "2145690",
    "end": "2152276"
  },
  {
    "text": "a was a key so it comes\nfrom the universe u. ",
    "start": "2152276",
    "end": "2161770"
  },
  {
    "text": "And so what that means is\nto do universal hashing, I want to choose one of these\nha's uniformly at random.",
    "start": "2161770",
    "end": "2167650"
  },
  {
    "text": "How do I do that? I just choose a\nuniformly at random. Pretty easy. It's one random value\nfrom one random key.",
    "start": "2167650",
    "end": "2176230"
  },
  {
    "text": "So that should take constant\ntime and constant space to store one number.",
    "start": "2176230",
    "end": "2182660"
  },
  {
    "text": "In general we're in a world\ncalled the Word RAM model.",
    "start": "2182660",
    "end": "2188099"
  },
  {
    "text": "This is actually-- I\nguess m stands for model so I shouldn't write model.",
    "start": "2188100",
    "end": "2193610"
  },
  {
    "text": "Random access machine\nwhich you may have heard. The word RAM assumes\nthat in general we're",
    "start": "2193610",
    "end": "2202980"
  },
  {
    "text": "manipulating integers. And the integers fit in a word.",
    "start": "2202980",
    "end": "2209550"
  },
  {
    "text": "And the computational\nassumption is that manipulating a\nconstant number of words",
    "start": "2209550",
    "end": "2215176"
  },
  {
    "text": "and doing essentially\nany operation you want on constant number of\nwords takes constant time.",
    "start": "2215176",
    "end": "2221060"
  },
  {
    "start": "2221060",
    "end": "2226530"
  },
  {
    "text": "And the other part\nof the word RAM model is to assume that the things\nyou care about fit in a word.",
    "start": "2226530",
    "end": "2231770"
  },
  {
    "start": "2231770",
    "end": "2236950"
  },
  {
    "text": "Say individual data values,\nhere we're talking about keys,",
    "start": "2236950",
    "end": "2244950"
  },
  {
    "text": "fit in a word. This is what you need\nto assume in [INAUDIBLE]",
    "start": "2244950",
    "end": "2250589"
  },
  {
    "text": "that you can compute high\nof x in constant time or low of x in constant time. Here I'm going to use it to\nassume that we can compute",
    "start": "2250590",
    "end": "2258250"
  },
  {
    "text": "h sub a of k in constant time. In practice this would\nbe done by implementing",
    "start": "2258250",
    "end": "2264010"
  },
  {
    "text": "this computation, this\ndot product computation, in hardware. And the reason a 64-bit\nedition on a modern processor",
    "start": "2264010",
    "end": "2273420"
  },
  {
    "text": "or a 32-bit on most\nphones takes constant time is because there's\nhardware that's designed to do that really fast.",
    "start": "2273420",
    "end": "2280049"
  },
  {
    "text": "And in general we're assuming\nthat the things we care about fit in a single word.",
    "start": "2280050",
    "end": "2286137"
  },
  {
    "text": "And we're assuming random access\nand that we can have a raise. That's what we need in\norder to store a table. And same thing in [INAUDIBLE],\nwe needed to assume we",
    "start": "2286137",
    "end": "2292930"
  },
  {
    "text": "had a raise.  And I think this\noperation is actually",
    "start": "2292930",
    "end": "2298400"
  },
  {
    "text": "pretty-- exists in Intel\narchitectures in some form. But it's certainly not\na normal operation.",
    "start": "2298400",
    "end": "2305117"
  },
  {
    "text": "If you're going to\ndo this explicitly, adding up and\nmultiplying things this would be r is the log base m of\nu, so it's kind of logish time.",
    "start": "2305117",
    "end": "2314900"
  },
  {
    "text": "Maybe I'll mention\nanother hash family that's",
    "start": "2314900",
    "end": "2319970"
  },
  {
    "text": "more obviously computable. ",
    "start": "2319970",
    "end": "2325499"
  },
  {
    "text": "But I won't analyze here. It's analyzed in the textbook. So if you're curious you\ncan check it out there.",
    "start": "2325499",
    "end": "2332450"
  },
  {
    "text": "Let's call this just another. ",
    "start": "2332450",
    "end": "2355620"
  },
  {
    "text": "It's a bit weird\nbecause it has two mods. You take mod p and then mod m. But the main computation\nis very simple.",
    "start": "2355620",
    "end": "2362010"
  },
  {
    "text": "You choose a uniformly\nrandom value a. You multiply it by your key\nin usual binary multiplication",
    "start": "2362010",
    "end": "2369640"
  },
  {
    "text": "instead of dot product. And then you add another\nuniformly random key. This is also universal.",
    "start": "2369640",
    "end": "2376360"
  },
  {
    "text": "So H is hab for all a\nand b that are keys.",
    "start": "2376360",
    "end": "2384660"
  },
  {
    "text": " So if you're not happy\nwith this assumption",
    "start": "2384660",
    "end": "2390420"
  },
  {
    "text": "that you can compute\nthis in constant time, you should be happy\nwith this assumption. If you believe in addition and\nmultiplication and division",
    "start": "2390420",
    "end": "2396396"
  },
  {
    "text": "being constant time, then\nthis will be constant time. ",
    "start": "2396396",
    "end": "2401859"
  },
  {
    "text": "So both of these\nfamilies are universal. I'm going to prove that this\none is universal because it's a little bit easier. Yeah?",
    "start": "2401860",
    "end": "2407290"
  },
  {
    "text": "STUDENT: Is this p a\nchoice that you made? ERIK DEMAINE: OK, right. What is p? P just has to be bigger than\nm, and it should be prime.",
    "start": "2407290",
    "end": "2419030"
  },
  {
    "text": "It's not random. You can just choose one prime\nthat's bigger than your table",
    "start": "2419030",
    "end": "2424550"
  },
  {
    "text": "size, and this will work. STUDENT: [INAUDIBLE] ",
    "start": "2424550",
    "end": "2432390"
  },
  {
    "text": "ERIK DEMAINE: I\nforget whether you have to assume that m is prime. I'd have to check.",
    "start": "2432390",
    "end": "2437630"
  },
  {
    "text": "I'm guessing not, but\ndon't quote me on that.",
    "start": "2437630",
    "end": "2443250"
  },
  {
    "text": "Check the section\nin the textbook. So good. Easy to compute.",
    "start": "2443250",
    "end": "2450111"
  },
  {
    "text": "The analysis is simpler, but\nit's a little bit easier here. Essentially this is\nvery much like products",
    "start": "2450112",
    "end": "2456070"
  },
  {
    "text": "but there's no\ncarries here from one. When we do the dot product\ninstead of just multiplying",
    "start": "2456070",
    "end": "2462140"
  },
  {
    "text": "in base m we multiply\nthem based on that would give the same thing\nas multiplying in base 2,",
    "start": "2462140",
    "end": "2467150"
  },
  {
    "text": "but we get carries from one\nm-sized digit to the next one. And that's just more\nannoying to think about.",
    "start": "2467150",
    "end": "2472280"
  },
  {
    "text": "So here we're essentially\ngetting rid of carries. So it's in some sense\neven easier to compute. And in both cases,\nit's universal.",
    "start": "2472280",
    "end": "2480305"
  },
  {
    "text": " So we want to prove\nthis property.",
    "start": "2480305",
    "end": "2494140"
  },
  {
    "text": "That if we choose a random\na then the probability",
    "start": "2494140",
    "end": "2499200"
  },
  {
    "text": "of two keys, k and k'\nwhich are distinct mapping via h to the same value is at\nmost 1/m So let's prove that.",
    "start": "2499200",
    "end": "2509450"
  },
  {
    "start": "2509450",
    "end": "2526450"
  },
  {
    "text": "So we're given two keys.",
    "start": "2526450",
    "end": "2532422"
  },
  {
    "text": "We have no control\nover them because this has to work for all\nkeys that are distinct. ",
    "start": "2532422",
    "end": "2542430"
  },
  {
    "text": "The only thing we know\nis that they're distinct. Now if two keys are\ndistinct, then their vectors must be distinct.",
    "start": "2542430",
    "end": "2547975"
  },
  {
    "text": "If two vectors\nare distinct, that means at least one\nitem must be different. Should sound familiar.",
    "start": "2547975",
    "end": "2553185"
  },
  {
    "start": "2553185",
    "end": "2559870"
  },
  {
    "text": "So this was like in the matrix\nmultiplication verification algorithm that\n[INAUDIBLE] taught.",
    "start": "2559870",
    "end": "2566420"
  },
  {
    "text": "So k and k' differ\nin some digit.",
    "start": "2566420",
    "end": "2574855"
  },
  {
    "text": " Let's call that digit d. ",
    "start": "2574855",
    "end": "2582901"
  },
  {
    "text": "So k sub d is different\nfrom k sub d'. ",
    "start": "2582902",
    "end": "2589370"
  },
  {
    "text": "And I want to compute\nthis probability.",
    "start": "2589370",
    "end": "2594590"
  },
  {
    "text": "We'll rewrite it. ",
    "start": "2594590",
    "end": "2613970"
  },
  {
    "text": "The probability is over a. I'm choosing a\nuniformly at random. I want another\nprobability that that",
    "start": "2613970",
    "end": "2619900"
  },
  {
    "text": "maps k and k' to the same slot. So let me just write\nout the definition.",
    "start": "2619900",
    "end": "2627210"
  },
  {
    "text": "It's probability over a that\nthe dot product of a and k",
    "start": "2627210",
    "end": "2638750"
  },
  {
    "text": "is the same thing as when I do\nthe dot product with k' mod m.",
    "start": "2638750",
    "end": "2652180"
  },
  {
    "text": "These two, that sum should\ncome out the same, mod m. ",
    "start": "2652180",
    "end": "2659570"
  },
  {
    "text": "So let me move this part over to\nthis side because in both cases",
    "start": "2659570",
    "end": "2665210"
  },
  {
    "text": "we have the same ai. So I can group\nterms and say this is the probability--\nprobability sum over i",
    "start": "2665210",
    "end": "2685640"
  },
  {
    "text": "equals 0 to r minus 1\nof ai times ki minus",
    "start": "2685640",
    "end": "2690900"
  },
  {
    "text": "ki prime equals 0. ",
    "start": "2690900",
    "end": "2697660"
  },
  {
    "text": "Mod m. ",
    "start": "2697660",
    "end": "2712380"
  },
  {
    "text": "OK, no pun intended. Now we care about this digit d.",
    "start": "2712380",
    "end": "2719430"
  },
  {
    "text": "d is a place where we know\nthat this is non-zero. So let me separate out the terms\nfor d and everything but d.",
    "start": "2719430",
    "end": "2728270"
  },
  {
    "text": "So this is the same as ability\nof, let's do the d term first,",
    "start": "2728270",
    "end": "2734630"
  },
  {
    "text": "so we have ad times\nkd minus kd prime.",
    "start": "2734630",
    "end": "2741920"
  },
  {
    "text": "That's one term. I'm going to write\nthe summation of i not equal to d of ai\nki minus ki prime.",
    "start": "2741920",
    "end": "2756485"
  },
  {
    "text": "These ones, some of\nthem might be zero. Some are not. We're not going\nto worry about it. It's enough to just isolate\none term that is non-zero.",
    "start": "2756485",
    "end": "2763105"
  },
  {
    "start": "2763105",
    "end": "2768550"
  },
  {
    "text": "So this thing we know\ndoes not equal zero. ",
    "start": "2768550",
    "end": "2774370"
  },
  {
    "text": "Cool. Here's where I'm going to use\na little bit of number theory. I haven't yet used\nthat m is prime.",
    "start": "2774370",
    "end": "2780360"
  },
  {
    "text": "I required m is prime because\nwhen you're working modulo m,",
    "start": "2780360",
    "end": "2787120"
  },
  {
    "text": "you have multiplicative\ninverses. Because this is\nnot zero, there is",
    "start": "2787120",
    "end": "2792430"
  },
  {
    "text": "something I can\nmultiply on both sides and get this to cancel\nout and become one.",
    "start": "2792430",
    "end": "2800800"
  },
  {
    "text": "For every value x\nthere is a value y. So x times y equals 1 modulo m.",
    "start": "2800800",
    "end": "2806170"
  },
  {
    "text": "And you can even compute\nit in constant time in a reasonable model. So then I can say I want the\nprobability that ad is minus",
    "start": "2806170",
    "end": "2828289"
  },
  {
    "text": "kd minus kd prime inverse. This is the multiplicative\ninverse I was talking about.",
    "start": "2828290",
    "end": "2834520"
  },
  {
    "text": "And then the sum i not equal\nto d whatever, I don't actually",
    "start": "2834520",
    "end": "2840680"
  },
  {
    "text": "care what this is too much, I've\nalready done the equals part.",
    "start": "2840680",
    "end": "2847264"
  },
  {
    "text": "I still need to write mod m.  The point is this\nis all about ad.",
    "start": "2847264",
    "end": "2856520"
  },
  {
    "text": "Remember we're choosing\na uniformly at random. That's the same\nthing as choosing each of the ai's independently\nuniformly at random.",
    "start": "2856520",
    "end": "2865896"
  },
  {
    "text": "Yeah? STUDENT: Is the second line over\nthere isolating d [INAUDIBLE]?",
    "start": "2865896",
    "end": "2873276"
  },
  {
    "text": "Second from the top. ERIK DEMAINE: Which? This one? STUDENT: No up. ERIK DEMAINE: This? STUDENT: Down.",
    "start": "2873276",
    "end": "2878398"
  },
  {
    "text": "That one. No. The one below that. ERIK DEMAINE: Yes. STUDENT: Is that line\nisolating d or is that--",
    "start": "2878398",
    "end": "2883730"
  },
  {
    "text": "ERIK DEMAINE: No. I haven't isolated d yet. This is all the terms. And then going from\nthis line to this one,",
    "start": "2883730",
    "end": "2888970"
  },
  {
    "text": "I'm just pulling out\nthe i equals d term. That's this term. And then separating out\nthe i not equal to d.",
    "start": "2888970",
    "end": "2896324"
  },
  {
    "text": "STUDENT: I get it. ERIK DEMAINE: Right? This sum is just the\nsame as that sum. But I've done the\nd term explicitly. STUDENT: Sure. I get it.",
    "start": "2896324",
    "end": "2901780"
  },
  {
    "text": " ERIK DEMAINE: So I've\ndone all this rewriting",
    "start": "2901780",
    "end": "2907150"
  },
  {
    "text": "because I know that ad is\nchosen uniformly at random. Here we have this\nthing, this monstrosity,",
    "start": "2907150",
    "end": "2914340"
  },
  {
    "text": "but it does not depend on ad. In fact it is independent of ad. I'm going to write this\nas a function of k and k'",
    "start": "2914340",
    "end": "2924570"
  },
  {
    "text": "because those are\ngiven to us and fixed. And then it's also a\nfunction of a0 and a1.",
    "start": "2924570",
    "end": "2930310"
  },
  {
    "text": "Everything except d. So ad minus 1, ad plus 1,\nand so on up to ar minus 1.",
    "start": "2930310",
    "end": "2941920"
  },
  {
    "text": "This is awkward to write. But everything except\nad appears here because we have\ni not equal to d.",
    "start": "2941920",
    "end": "2949230"
  },
  {
    "text": "And these ai's are\nrandom variables. But we're assuming that they're\nall chosen independently",
    "start": "2949230",
    "end": "2956460"
  },
  {
    "text": "from each other. So I don't really care what's\ngoing on in this function.",
    "start": "2956460",
    "end": "2961720"
  },
  {
    "text": "It's something. And if I rewrite\nthis probability, it's the probability\nover the choice of a.",
    "start": "2961720",
    "end": "2967636"
  },
  {
    "text": "I can separate out the\nchoice of all these things from the choice of ad.",
    "start": "2967636",
    "end": "2975320"
  },
  {
    "text": "And this is just\na useful formula. I'm going to write\na not equal to d.",
    "start": "2975320",
    "end": "2983500"
  },
  {
    "text": "All the other-- maybe I'll\nwrite a sub i not equal to d. All the choices of\nthose guys separately",
    "start": "2983500",
    "end": "2991079"
  },
  {
    "text": "from the probability\nof choosing ad of ad",
    "start": "2991080",
    "end": "2999700"
  },
  {
    "text": "equal to this function. ",
    "start": "2999700",
    "end": "3005090"
  },
  {
    "text": "If you just think about the\ndefinition of expectation, this is doing the same thing. We're thinking of first\nchoosing the ai's where",
    "start": "3005090",
    "end": "3012780"
  },
  {
    "text": "i is not equal to d. And then we choose ad. And this computational will\ncome out the same as that.",
    "start": "3012780",
    "end": "3019470"
  },
  {
    "start": "3019470",
    "end": "3025109"
  },
  {
    "text": "But this is the probability\nof a uniformly random number equaling something.",
    "start": "3025110",
    "end": "3031680"
  },
  {
    "text": "So we just need to\nthink about-- sorry. Important.",
    "start": "3031680",
    "end": "3037470"
  },
  {
    "text": "That would be pretty\nunlikely that would be 1/u, but this is all\nworking modulo m.",
    "start": "3037470",
    "end": "3042970"
  },
  {
    "text": "So if I just take a\nuniformly random integer and the chance of it hitting any\nparticular value mod m is 1/m.",
    "start": "3042970",
    "end": "3049530"
  },
  {
    "text": " And that's universality. ",
    "start": "3049530",
    "end": "3057430"
  },
  {
    "text": "So in this case, you get exactly\n1/m, no less than or equal to.",
    "start": "3057430",
    "end": "3062500"
  },
  {
    "text": "Sorry, I should have written\nit's the expectation of 1/m, but that's 1/m because 1/m\nhas no random parts in it.",
    "start": "3062500",
    "end": "3072540"
  },
  {
    "text": "Yeah? STUDENT: How do\nwe know that the, that this expression doesn't\nhave any biases in the sense",
    "start": "3072540",
    "end": "3079734"
  },
  {
    "text": "that it doesn't give more,\nmore, like if you give it the uniform\ndistribution of numbers,",
    "start": "3079735",
    "end": "3086718"
  },
  {
    "text": "it doesn't spit out\nmore numbers than others and that could potentially-- ERIK DEMAINE: Oh,\nso you're asking",
    "start": "3086718",
    "end": "3091930"
  },
  {
    "text": "how do we know that\nthis hash family doesn't prefer some slots\nover others, I guess.",
    "start": "3091930",
    "end": "3098085"
  },
  {
    "text": "STUDENT: Of course like\nafter the equals sign, like in this middle\nline in the middle.",
    "start": "3098085",
    "end": "3106219"
  },
  {
    "text": "Middle board. ERIK DEMAINE: This one? Oh, this one. STUDENT: Middle board. ERIK DEMAINE: Middle board.",
    "start": "3106219",
    "end": "3111531"
  },
  {
    "text": "Here. STUDENT: Yes. So how do we know\nthat if you give it-- ERIK DEMAINE: This function. STUDENT: --random variables,\nit won't prefer certain numbers",
    "start": "3111531",
    "end": "3119760"
  },
  {
    "text": "over others? ERIK DEMAINE: So this function\nmay prefer some numbers over others.",
    "start": "3119760",
    "end": "3124940"
  },
  {
    "text": "But it doesn't matter. All we need is\nthat this function is independent of\nour choice of ad.",
    "start": "3124940",
    "end": "3130285"
  },
  {
    "text": "So you can think\nof this function, you choose all of these\nrandom-- actually k and k' are not random-- but you choose\nall these random numbers.",
    "start": "3130285",
    "end": "3138179"
  },
  {
    "text": "Then you evaluate your f. Maybe it always comes out to 5. Who knows. It could be super biased. But then you choose ad\nuniformly at random.",
    "start": "3138179",
    "end": "3146430"
  },
  {
    "text": "So the chance of ad\nequalling 5 is the same as the chance of ad equaling 3.",
    "start": "3146430",
    "end": "3151730"
  },
  {
    "text": "So in all cases, you get\nthe probability is 1/m. What we need is independence. We need that the ad is chosen\nindependently from the other",
    "start": "3151730",
    "end": "3159220"
  },
  {
    "text": "ai's. But we don't need to know\nanything about f other than it doesn't depend on ad.",
    "start": "3159220",
    "end": "3164640"
  },
  {
    "text": "So and we made it not depend\non ad because I isolated ad by pulling it out\nof that summation.",
    "start": "3164640",
    "end": "3170599"
  },
  {
    "text": "So we know there's\nno ad's over here. Good question.",
    "start": "3170600",
    "end": "3176110"
  },
  {
    "text": "You get a bonus Frisbee\nfor your question. ",
    "start": "3176110",
    "end": "3181500"
  },
  {
    "text": "All right. That ends universal hashing.",
    "start": "3181500",
    "end": "3186519"
  },
  {
    "text": "Any more questions? So at this point we\nhave at least one universal hash family.",
    "start": "3186520",
    "end": "3192349"
  },
  {
    "text": "So we're just choosing, in this\ncase, a uniformly at random. In the other method, we choose\na and b uniformly at random.",
    "start": "3192350",
    "end": "3199400"
  },
  {
    "text": "And then we build\nour hash table. And the hash function\ndepends on m.",
    "start": "3199400",
    "end": "3205667"
  },
  {
    "text": "So also every time we\ndouble our table size, we're going to have to\nchoose a new hash function for the new value of m.",
    "start": "3205667",
    "end": "3212340"
  },
  {
    "text": "And that's about it. So this will give us constant\nexpected time-- or in general 1",
    "start": "3212340",
    "end": "3218869"
  },
  {
    "text": "plus alpha if you're not doing\ntable doubling-- for insert, delete, and exact search.",
    "start": "3218870",
    "end": "3225230"
  },
  {
    "text": "Just building on the\nhashing with chaining. And so this is a good method.",
    "start": "3225230",
    "end": "3230760"
  },
  {
    "text": "Question? STUDENT: Why do you say expected\nvalue of the probability? Isn't it sufficient to just say\nthe probability of [INAUDIBLE]?",
    "start": "3230760",
    "end": "3238430"
  },
  {
    "text": "ERIK DEMAINE: Uh, yeah,\nI wanted to isolate-- it is the overall probability\nof this happening.",
    "start": "3238430",
    "end": "3245400"
  },
  {
    "text": "I rewrote it this\nway because I wanted to think about first choosing\nthe ai's where i does not equal d and then choosing ad.",
    "start": "3245400",
    "end": "3252224"
  },
  {
    "text": "So this probability\nwas supposed to be only over the choice of ad. And you have to do something\nwith the other ai's",
    "start": "3252225",
    "end": "3257700"
  },
  {
    "text": "because they're random. You can't just say,\nwhat's the probability ad equaling a random variable? That's a little sketchy.",
    "start": "3257700",
    "end": "3263300"
  },
  {
    "text": "I wanted to have no\nrandom variables over all. So I have to kind of bind\nthose variables with something.",
    "start": "3263300",
    "end": "3268460"
  },
  {
    "text": "And I just want to see what\nthe-- This doesn't really affect very much, but to\nmake this algebraically",
    "start": "3268460",
    "end": "3275859"
  },
  {
    "text": "correct I need to say\nwhat the ai's, i not equal to d are doing.",
    "start": "3275860",
    "end": "3281490"
  },
  {
    "text": "Other questions? Yeah. STUDENT: Um, I'm a bit\nconfused about your definition of the collision in\nthe lower left board.",
    "start": "3281490",
    "end": "3290546"
  },
  {
    "text": "Why are you adding\ni's [INAUDIBLE]? ERIK DEMAINE: Yeah, sorry. This is a funny\nnotion of colliding.",
    "start": "3290546",
    "end": "3296319"
  },
  {
    "text": "I just mean I want to count\nthe number of keys that hash to the same slot as ki. STUDENT: So it's not necessarily\nlike a collision [INAUDIBLE].",
    "start": "3296320",
    "end": "3304106"
  },
  {
    "text": "ERIK DEMAINE: You\nmay not call it a collision when it\ncollides with itself, yeah. Whatever you want to call it.",
    "start": "3304106",
    "end": "3311050"
  },
  {
    "text": "But I just mean hashing\nto the same slot is ki. Yeah. Just because I want to count\nthe total length of the chain.",
    "start": "3311050",
    "end": "3317960"
  },
  {
    "text": "I don't want to count the number\nof collisions in the chain. Sorry. Probably a poor choice of word.",
    "start": "3317960",
    "end": "3323220"
  },
  {
    "text": " We're hashing because\nwe're taking our key,",
    "start": "3323220",
    "end": "3331179"
  },
  {
    "text": "we're cutting it up\ninto little bits, and then we're mixing them up\njust like a good corned beef hash or something.",
    "start": "3331179",
    "end": "3338550"
  },
  {
    "text": "All right let's move\non to perfect hashing. This is more\nexciting I would say.",
    "start": "3338550",
    "end": "3344950"
  },
  {
    "text": "Even cooler-- this was cool\nfrom a probability perspective, depending on your\nnotion of cool.",
    "start": "3344950",
    "end": "3350589"
  },
  {
    "text": "This method will be cool from\na data structures perspective and a probability perspective. ",
    "start": "3350590",
    "end": "3357630"
  },
  {
    "text": "But so far data structures\nare what we know from 006. Now we're going to go\nup a level, literally.",
    "start": "3357630",
    "end": "3366080"
  },
  {
    "text": "We're going to have two levels. So here we're solving-- you\ncan actually make this data",
    "start": "3366080",
    "end": "3372410"
  },
  {
    "text": "structure dynamic. But we're going to solve\nthe static dictionary problem which is when you\nhave no inserts and deletes.",
    "start": "3372410",
    "end": "3384530"
  },
  {
    "text": "You're given the keys up front. ",
    "start": "3384530",
    "end": "3389760"
  },
  {
    "text": "You're given n keys. You want to build a table\nthat supports search. ",
    "start": "3389760",
    "end": "3398424"
  },
  {
    "text": "And that's it. You want search to\nbe constant time and perfect hashing,\nalso known as FKS hashing",
    "start": "3398424",
    "end": "3411820"
  },
  {
    "text": "because it was invented by\nFredman, Komlos, and Szemeredi in 1984.",
    "start": "3411820",
    "end": "3419269"
  },
  {
    "text": "What we will achieve is constant\ntime worst case for search.",
    "start": "3419270",
    "end": "3429520"
  },
  {
    "start": "3429520",
    "end": "3436670"
  },
  {
    "text": "So that's a little\nbetter because here we're just doing constant\nexpected time for search.",
    "start": "3436670",
    "end": "3442000"
  },
  {
    "text": "But it's worse in that we have\nto know the keys up in advance. We're going to take the linear\nspace in the worst case.",
    "start": "3442000",
    "end": "3450620"
  },
  {
    "start": "3450620",
    "end": "3460250"
  },
  {
    "text": "And then the\nremaining question is how long does it take you to\nbuild this data structure? And for now I'll just\nsay it's polynomial time.",
    "start": "3460250",
    "end": "3467570"
  },
  {
    "text": "It's actually going\nto be nearly linear. ",
    "start": "3467570",
    "end": "3476750"
  },
  {
    "text": "And this is also\nan expected bounds. Actually with high probability\ncould be a little more strong",
    "start": "3476750",
    "end": "3485110"
  },
  {
    "text": "here.  So it's going to take\nus a little bit of time to build this structure,\nbut once you have it,",
    "start": "3485111",
    "end": "3491536"
  },
  {
    "text": "you have the perfect scenario. There's going to\nbe in some sense no collisions in our hash\ntable so it would be constant",
    "start": "3491536",
    "end": "3496591"
  },
  {
    "text": "times first search\nand linear space. So that part's great. The only catch is it's static.",
    "start": "3496591",
    "end": "3504710"
  },
  {
    "text": "But beggars can't\nbe choosers I guess.",
    "start": "3504710",
    "end": "3510500"
  },
  {
    "text": "All right.  I'm not sure who's begging\nin that analogy but.",
    "start": "3510500",
    "end": "3516060"
  },
  {
    "text": " The keys who want to be stored.",
    "start": "3516060",
    "end": "3521900"
  },
  {
    "text": "I don't know. All right, so the big\nidea for perfect hashing",
    "start": "3521900",
    "end": "3528170"
  },
  {
    "text": "is to use two levels. ",
    "start": "3528170",
    "end": "3535710"
  },
  {
    "text": "So let me draw a picture. We have our universe, and we're\nmapping that via hash function",
    "start": "3535710",
    "end": "3544240"
  },
  {
    "text": "h1 into a table. Look familiar? Exactly the diagram\nI drew before.",
    "start": "3544240",
    "end": "3551539"
  },
  {
    "text": "It's going to have\nsome table size m. And we're going to set m to be\nwithin a constant factor of n.",
    "start": "3551540",
    "end": "3562090"
  },
  {
    "text": "So right now it looks\nexactly like regular-- and it's going to\nbe a universal,",
    "start": "3562090",
    "end": "3567380"
  },
  {
    "text": "h1 is chosen from a\nuniversal hash family, so universal hashing applies.",
    "start": "3567380",
    "end": "3574079"
  },
  {
    "text": "The trouble is we're going\nto get some lists here. And we don't want to store\nthe set of colliding elements,",
    "start": "3574080",
    "end": "3584755"
  },
  {
    "text": "the set of elements that hash to\nthat place, with a linked list because linked lists are slow.",
    "start": "3584755",
    "end": "3590549"
  },
  {
    "text": "Instead we're going to store\nthem using a hash table. It sounds crazy.",
    "start": "3590550",
    "end": "3596000"
  },
  {
    "text": "But we're going to have--\nso this is position 1.",
    "start": "3596000",
    "end": "3601340"
  },
  {
    "text": "This is going to be h2,1. There's going to be another hash\nfunction h2,0 that maps to some",
    "start": "3601340",
    "end": "3610500"
  },
  {
    "text": "other hash table. These hash tables are going\nto be of varying sizes. Some of them will be of size 0\nbecause nothing hashes there.",
    "start": "3610500",
    "end": "3619300"
  },
  {
    "text": "But in general\neach of these slots is going to map instead of to\na linked list to a hash table.",
    "start": "3619300",
    "end": "3625569"
  },
  {
    "text": "So this would be h2, m minus 1.",
    "start": "3625570",
    "end": "3631260"
  },
  {
    "text": "I'm going to guarantee in\nthe second level of hashing there are zero collisions. ",
    "start": "3631260",
    "end": "3650589"
  },
  {
    "text": "Let that sink in a little bit. Let me write down a little\nmore carefully what I'm doing.",
    "start": "3650590",
    "end": "3656099"
  },
  {
    "start": "3656100",
    "end": "3669050"
  },
  {
    "text": "So h1 is picked from a\nuniversal hash family. ",
    "start": "3669050",
    "end": "3680220"
  },
  {
    "text": "Where m is theta n.",
    "start": "3680220",
    "end": "3685420"
  },
  {
    "text": "I want to put a theta-- I\nmean I could m equals n, but sometimes we\nrequire m to be a prime. So I'm going to give you some\nslop in how you choose m.",
    "start": "3685420",
    "end": "3692164"
  },
  {
    "text": "So it can be prime\nor whatever you want.  And then at the\nfirst level we're",
    "start": "3692164",
    "end": "3697880"
  },
  {
    "text": "basically doing\nhashing with chaining. And now I want to look at\neach slot in that hash table.",
    "start": "3697880",
    "end": "3710580"
  },
  {
    "text": "So between 0 and m-1.  I'm going to let lj be the\nnumber of keys that hash,",
    "start": "3710580",
    "end": "3722150"
  },
  {
    "text": "it's the length of the\nlist that would go there. It's going to be\nthe number of keys, among just the n keys, Number\nof, keys hashing to slot j.",
    "start": "3722150",
    "end": "3743730"
  },
  {
    "text": " So now the big question\nis, if I have lj keys here,",
    "start": "3743730",
    "end": "3750200"
  },
  {
    "text": "how big do I make that table? You might say, well\nI make a theta lj. That's what I always do. But that's not what\nI'm going to do.",
    "start": "3750200",
    "end": "3756640"
  },
  {
    "text": "That wouldn't help. We get exactly, I\nthink, the same number of collisions if we did that,\nmore or less, in expectation.",
    "start": "3756640",
    "end": "3764450"
  },
  {
    "text": "So we're going do\nsomething else. We're going to pick a hash\nfunction from a universal",
    "start": "3764450",
    "end": "3774150"
  },
  {
    "text": "family, h2,j.  It again maps the same universe.",
    "start": "3774150",
    "end": "3780170"
  },
  {
    "start": "3780170",
    "end": "3785510"
  },
  {
    "text": "The key thing is the\nsize of the hash table I'm going to choose\nwhich is lj squared.",
    "start": "3785510",
    "end": "3793227"
  },
  {
    "start": "3793227",
    "end": "3812510"
  },
  {
    "text": "So if there are 3 elements that\nhappen to hash to this slot,",
    "start": "3812510",
    "end": "3817890"
  },
  {
    "text": "this table will have size 9. So it's mostly empty.",
    "start": "3817890",
    "end": "3823920"
  },
  {
    "text": "Only square root fraction--\nif that's a word, if that's a phrase-- will be full.",
    "start": "3823920",
    "end": "3828930"
  },
  {
    "text": "Most of it's empty. Why squared?  Any ideas?",
    "start": "3828930",
    "end": "3835820"
  },
  {
    "text": "I claim this will guarantee zero\ncollisions with decent chance. Yeah. STUDENT: With 1/2\nprobability you're",
    "start": "3835820",
    "end": "3841859"
  },
  {
    "text": "going to end up\nwith no collisions. ERIK DEMAINE: With\n1/2 probability I'm going to end up\nwith no collisions. Why? What's it called?",
    "start": "3841860",
    "end": "3846998"
  },
  {
    "text": " STUDENT: Markov [INAUDIBLE] ERIK DEMAINE: Markov's\ninequality would prove it.",
    "start": "3846998",
    "end": "3853260"
  },
  {
    "text": "But it's more commonly\nknown as the, whoa, as the birthday paradox.",
    "start": "3853260",
    "end": "3861020"
  },
  {
    "text": "So the whole name of the game\nhere is the birthday paradox. If I have, how's\nit go, if I have n",
    "start": "3861020",
    "end": "3869315"
  },
  {
    "text": "squared people with n\npossible birthdays then-- is that the right way?",
    "start": "3869315",
    "end": "3875430"
  },
  {
    "text": "No, less. If I have n people and n\nsquared possible birthdays, the probability of getting a\ncollision, a shared birthday,",
    "start": "3875430",
    "end": "3882700"
  },
  {
    "text": "is 1/2. Normally we think of\nthat as a funny thing. You know, if I choose a\nfair number of people,",
    "start": "3882700",
    "end": "3888860"
  },
  {
    "text": "then I get immediately\na collision. I'm going to do it\nthe opposite way. I'm going to guarantee that\nthere's so many birthdays",
    "start": "3888860",
    "end": "3896130"
  },
  {
    "text": "that no 2 of them will collide\nwith probability of 1/2 No, 1/2 is not great. We're going to fix that.",
    "start": "3896130",
    "end": "3901430"
  },
  {
    "start": "3901430",
    "end": "3908230"
  },
  {
    "text": "So actually I haven't given\nyou the whole algorithm yet. There are two steps, 1 and 2.",
    "start": "3908230",
    "end": "3914049"
  },
  {
    "text": "But there are also two\nother steps 1.5 and 2.5.",
    "start": "3914050",
    "end": "3919920"
  },
  {
    "text": "But this is the right\nidea and this will make things work in expectation. But I'm going to\ntweak it a little bit.",
    "start": "3919920",
    "end": "3926020"
  },
  {
    "text": " So first let me\ntell you step 1.5. It fits in between the two.",
    "start": "3926020",
    "end": "3933170"
  },
  {
    "text": "I want that the space of this\ndata structure is linear. So I need to make sure it is.",
    "start": "3933170",
    "end": "3940050"
  },
  {
    "text": "If the sum j equals 0 to\nm minus 1 of lj squared",
    "start": "3940050",
    "end": "3948840"
  },
  {
    "text": "is bigger than\nsome constant times n-- we'll figure out what the\nconstant is later-- then redo",
    "start": "3948840",
    "end": "3955250"
  },
  {
    "text": "step 1. So after I do step 1, I know\nhow big all these tables",
    "start": "3955250",
    "end": "3961360"
  },
  {
    "text": "are going to be. If the sum of those squares is\nbigger than linear, start over.",
    "start": "3961360",
    "end": "3967140"
  },
  {
    "text": "I need to prove\nthat this will only have to take-- this\nwill happen an expected",
    "start": "3967140",
    "end": "3972180"
  },
  {
    "text": "constant number of times. log n times with\nhigh probability. In fact why don't we-- yeah,\nlet's worry about that later.",
    "start": "3972180",
    "end": "3981290"
  },
  {
    "text": " Let me first tell\nyou step 2.5 which",
    "start": "3981290",
    "end": "3987690"
  },
  {
    "text": "is I want there to be\nzero collisions in each of these tables. It's only going to happen\nwith probability of 1/2",
    "start": "3987690",
    "end": "3994170"
  },
  {
    "text": "So if it doesn't\nhappen, just try again. So 2.5 is while there's some\nhash function h2,j that maps 2",
    "start": "3994170",
    "end": "4010160"
  },
  {
    "text": "keys that we're given to the\nsame slot at the second level,",
    "start": "4010160",
    "end": "4022309"
  },
  {
    "text": "this is for some j and let's\nsay ki different from ki prime.",
    "start": "4022310",
    "end": "4037290"
  },
  {
    "text": "But they map to the same place\nby the first hash function. ",
    "start": "4037290",
    "end": "4046350"
  },
  {
    "text": "So if two keys map to\nthe same secondary table and there's a\nconflict, then I'm just",
    "start": "4046350",
    "end": "4052099"
  },
  {
    "text": "going to redo that construction. So I'm going to repick h2,j.",
    "start": "4052100",
    "end": "4060420"
  },
  {
    "text": "h2,j was a random choice. So if I get a bad choice,\nI'll just try another one.",
    "start": "4060420",
    "end": "4067230"
  },
  {
    "text": "Just keep randomly\nchoosing the a or randomly choosing\nthis hash function until there are zero collisions\nin that secondary table.",
    "start": "4067230",
    "end": "4075780"
  },
  {
    "text": "And I'm going to do\nthis for each table. So we worry about how\nlong these will take, but I claim expected\nconstant number of trials.",
    "start": "4075780",
    "end": "4082745"
  },
  {
    "text": " So let's do the\nsecond one first. ",
    "start": "4082745",
    "end": "4093040"
  },
  {
    "text": "After we do this y loop\nthere are no collisions with the proper notion of\nthe word collisions, which",
    "start": "4093040",
    "end": "4099049"
  },
  {
    "text": "is two different keys\nmapping to the same value. ",
    "start": "4099050",
    "end": "4115970"
  },
  {
    "text": "So at this point\nwe have guaranteed",
    "start": "4115970",
    "end": "4121470"
  },
  {
    "text": "that searches are\nconstant time worst case after we do all these\n4 steps because we apply h1,",
    "start": "4121470",
    "end": "4128740"
  },
  {
    "text": "we figure out which\nslot we fit in. Say it's slot j,\nthen we apply h2j",
    "start": "4128740",
    "end": "4133929"
  },
  {
    "text": "and if your item's\nin the overall table, it should be in that\nsecondary table. Because there are no\ncollisions you can see,",
    "start": "4133930",
    "end": "4140243"
  },
  {
    "text": "is that one item the\none I'm looking for? If so, return it. If not, it's not anywhere. If there are no\ncollisions then I",
    "start": "4140243",
    "end": "4147829"
  },
  {
    "text": "don't need chains coming out\nof here because it is just a single item. ",
    "start": "4147829",
    "end": "4153750"
  },
  {
    "text": "The big question-- so\nconstant worst case space because 1.5 guarantees that.",
    "start": "4153750",
    "end": "4159130"
  },
  {
    "text": "Constant worst case\ntime first search. The big question is, how\nlong does it take to build? How many times do\nwe have to redo",
    "start": "4159130",
    "end": "4165330"
  },
  {
    "text": "steps 1 and 2 before we\nget a decent-- before we get a perfect hash table. ",
    "start": "4165330",
    "end": "4172979"
  },
  {
    "text": "So let me remind\nyou of the birthday paradox, why it works here. ",
    "start": "4172979",
    "end": "4194530"
  },
  {
    "text": "As mentioned earlier this is\ngoing to be a union bounds.",
    "start": "4194530",
    "end": "4199846"
  },
  {
    "text": "We want to know the\nprobability of collision at that second level. Well that's at most the sum\nof all possible collisions,",
    "start": "4199847",
    "end": "4206754"
  },
  {
    "text": "probabilities of collisions. So I'm going to say\nthe sum over all i not equal to ij of\nthe probability.",
    "start": "4206754",
    "end": "4214340"
  },
  {
    "text": "Now this is over our choice\nof the hash function h2,j. ",
    "start": "4214340",
    "end": "4219847"
  },
  {
    "text": "Of h2,j of ki equaling\nh2,j of ki prime.",
    "start": "4219848",
    "end": "4229120"
  },
  {
    "text": "So union bounds says, of course. The probability of any\nof them happening-- we don't know about\ninterdependence or whatnot--",
    "start": "4229120",
    "end": "4235380"
  },
  {
    "text": "but certainly almost the sum of\neach of these possible events. There are a lot of\npossible events.",
    "start": "4235380",
    "end": "4242150"
  },
  {
    "text": "If there 's li\nthings, that there are going to be li choose\n2 possible collisions",
    "start": "4242150",
    "end": "4247462"
  },
  {
    "text": "we have to worry about. We know i is not\nequal to i prime. ",
    "start": "4247462",
    "end": "4253360"
  },
  {
    "text": "So the number of terms\nhere is li choose 2. ",
    "start": "4253360",
    "end": "4260890"
  },
  {
    "text": "And what's this probability? ",
    "start": "4260890",
    "end": "4266120"
  },
  {
    "text": "STUDENT: [INAUDIBLE] ERIK DEMAINE: 1/li at most\nbecause we're assuming h2,j is",
    "start": "4266120",
    "end": "4274420"
  },
  {
    "text": "a universal hash function so\nthe probability of choosing-- sorry? li squared.",
    "start": "4274420",
    "end": "4279530"
  },
  {
    "text": "Thank you. The size of the table. 1/m but m in this case, the\nsize of our table is li squared.",
    "start": "4279530",
    "end": "4287230"
  },
  {
    "text": "So the probability that we\nchoose a good hash function and that these\nparticular keys don't hit",
    "start": "4287230",
    "end": "4292790"
  },
  {
    "text": "is at most 1/li squared. This is basically li squared/ 2. And so this is at most 1/2.",
    "start": "4292790",
    "end": "4300690"
  },
  {
    "text": "It's a slightly less\nthan li squared/2. So this is at most 1/2. And this is basically\na birthday paradox",
    "start": "4300690",
    "end": "4306940"
  },
  {
    "text": "in this particular case. That means there\nis a probability of at least a half that there\nis zero collisions in one",
    "start": "4306940",
    "end": "4313610"
  },
  {
    "text": "of these tables. So that means I'm basically\nflipping a fair coin. If I ever get a heads I'm happy.",
    "start": "4313610",
    "end": "4318922"
  },
  {
    "text": "Each time I get a\ntails I have to reflip. This should sound\nfamiliar from last time. So this is 2 expected trials\nor log n with high probability.",
    "start": "4318922",
    "end": "4334045"
  },
  {
    "start": "4334045",
    "end": "4340710"
  },
  {
    "text": "We've proved log n\nwith high probability. That's the same as saying the\nnumber of levels in a skip list",
    "start": "4340710",
    "end": "4346360"
  },
  {
    "text": "is log n with high probability. How many times do I have to flip\na coin before I get a heads? Definitely at most log n.",
    "start": "4346360",
    "end": "4352000"
  },
  {
    "text": " Now we have to do this\nfor each secondary table.",
    "start": "4352000",
    "end": "4358530"
  },
  {
    "text": "There are m equal theta\nand secondary tables. ",
    "start": "4358530",
    "end": "4370110"
  },
  {
    "text": "There's a slight question of how\nbig are the secondary tables. If one of these tables\nis like linear size,",
    "start": "4370110",
    "end": "4376770"
  },
  {
    "text": "then I have to spend\nlinear time for a trial. And then I multiply that\nby the number of trials",
    "start": "4376770",
    "end": "4382450"
  },
  {
    "text": "and also the number of different\nthings that would be like n squared log n n. But you know a secondary table\nbetter not have linear sides.",
    "start": "4382450",
    "end": "4391460"
  },
  {
    "text": "I mean a linear\nnumber of li equal n. That would be bad because\nthen li squared is n squared",
    "start": "4391460",
    "end": "4396850"
  },
  {
    "text": "and we guaranteed that\nwe had linear space. So in fact you can prove\nwith another Chernoff bound.",
    "start": "4396850",
    "end": "4405790"
  },
  {
    "text": "Let me put this over here. ",
    "start": "4405790",
    "end": "4414330"
  },
  {
    "text": "That all the li's\nare pretty small. Not constant but logarithmic.",
    "start": "4414330",
    "end": "4422730"
  },
  {
    "text": "So li is order log n with\nhigh probability for each i",
    "start": "4422730",
    "end": "4430400"
  },
  {
    "text": "and therefore for all i. So I can just change the alpha\nmy minus 1 n to the alpha",
    "start": "4430400",
    "end": "4436550"
  },
  {
    "text": "and get that for\nall i this happens. In fact, the right answer\nis log over log log,",
    "start": "4436550",
    "end": "4442570"
  },
  {
    "text": "if you want to do some\nreally messy analysis. But we just, logarithmic\nis fine for us.",
    "start": "4442570",
    "end": "4448430"
  },
  {
    "text": "So what this means\nis we're doing n different things\nfor each of them",
    "start": "4448430",
    "end": "4454010"
  },
  {
    "text": "with high probability\nli is of size log n. And then maybe we'll have\nto do like log n trials",
    "start": "4454010",
    "end": "4460469"
  },
  {
    "text": "repeating until we get a\ngood hash function there. And so the total build\ntime for steps 1 and 2.5",
    "start": "4460470",
    "end": "4469320"
  },
  {
    "text": "is going to be at most\nn times log squared n. You can prove a tighter\nbound but it's polynomial.",
    "start": "4469320",
    "end": "4477420"
  },
  {
    "text": "That's all I wanted to go\nfor and it's almost linear. So I'm left with one thing\nto analyze which is step 1.5.",
    "start": "4477420",
    "end": "4486855"
  },
  {
    "text": "This to me is maybe the\nmost surprising thing that it works out. I mean here we designed--\nwe did this li to li",
    "start": "4486855",
    "end": "4493490"
  },
  {
    "text": "squared so the birthday\nparadox would happen. This is not surprising. I mean it's a cool idea,\nbut once you have the idea,",
    "start": "4493490",
    "end": "4499020"
  },
  {
    "text": "it's not surprising\nthat it works. What's a little more\nsurprising is that squaring is OK from a space perspective.",
    "start": "4499020",
    "end": "4505670"
  },
  {
    "text": "1.5 says we're going\nto have to rebuild that first table until the\nsum of these squared lengths is at most linear.",
    "start": "4505670",
    "end": "4511469"
  },
  {
    "text": "I can guarantee\nthat each of these is logarithmic so the sum of the\nsquares is at most like n log",
    "start": "4511470",
    "end": "4516840"
  },
  {
    "text": "squared n. But I claim I can get linear. ",
    "start": "4516840",
    "end": "4522360"
  },
  {
    "text": "Let's do that. So for step 1.5\nwe're looking at what",
    "start": "4522360",
    "end": "4529880"
  },
  {
    "text": "is the expectation of the\nsum of the lj squareds being",
    "start": "4529880",
    "end": "4535409"
  },
  {
    "text": "more than linear. Sorry. Expectation. Let's first compute\nthe expectation",
    "start": "4535410",
    "end": "4541310"
  },
  {
    "text": "and then we'll talk\nabout a tail bound which is the probability\nthat we're much bigger than the expectation.",
    "start": "4541310",
    "end": "4546980"
  },
  {
    "text": "First thing is I claim\nthe expectation is linear. So again whenever we're\ncounting something--",
    "start": "4546980",
    "end": "4556000"
  },
  {
    "text": "I mean this is basically\nthe total number of pairs of items that collide\nat the first level",
    "start": "4556000",
    "end": "4562580"
  },
  {
    "text": "with double counting. So I mean if you think of lj\nand then I make a complete graph",
    "start": "4562580",
    "end": "4568940"
  },
  {
    "text": "on those lj items,\nthat's going to have like the squared\nnumber of edges, so,",
    "start": "4568940",
    "end": "4574400"
  },
  {
    "text": "if I also multiply by 2. So this is the same\nthing as counting how many pairs of items map to\nthe same spot, the same slot.",
    "start": "4574400",
    "end": "4585180"
  },
  {
    "text": "So this is going to-- and that\nI can write as an indicator random variable which\nlets me use linearity",
    "start": "4585180",
    "end": "4590820"
  },
  {
    "text": "of expectation\nwhich makes me happy because then everything simple.",
    "start": "4590820",
    "end": "4596940"
  },
  {
    "text": "So I'm going to write Ii,j.  This is going to be 1 if each 1\nof ki, I guess, equals h1 if kj",
    "start": "4596940",
    "end": "4614070"
  },
  {
    "text": "and it's going to be\n0 if h1 otherwise. ",
    "start": "4614070",
    "end": "4625080"
  },
  {
    "text": "This is the total number\nof pairwise colliding items including i versus i.",
    "start": "4625080",
    "end": "4630520"
  },
  {
    "text": "And so like if li equals\n1, li squared is also 1. There's 1 item\ncolliding with itself.",
    "start": "4630520",
    "end": "4635820"
  },
  {
    "text": "So this actually works exactly. All right, with the wrong\ndefinition of colliding.",
    "start": "4635820",
    "end": "4641840"
  },
  {
    "text": "If you bear with me. So now we can use\nlinear of expectation and put the E in here.",
    "start": "4641840",
    "end": "4648889"
  },
  {
    "text": "So this is sum i equals 1\nto n sum j equals 1 to n",
    "start": "4648890",
    "end": "4655400"
  },
  {
    "text": "of the expectation of Ii,j. But we know the expectation\nof the Ii,j is the probability",
    "start": "4655400",
    "end": "4662982"
  },
  {
    "text": "of it equaling 1 because it's\nan indicator random variable. The probability of this\nhappening over our choice of h1",
    "start": "4662982",
    "end": "4668582"
  },
  {
    "text": "is at most 1/m by universality. Here it actually is m because\nwe're at the first level. So this is at most\n1/m which is theta n.",
    "start": "4668582",
    "end": "4679520"
  },
  {
    "text": " So when i does not equal j,\nso it's a little bit annoying.",
    "start": "4679520",
    "end": "4690929"
  },
  {
    "text": "I do have to separate out the Ii\nterms from the i and different",
    "start": "4690930",
    "end": "4696570"
  },
  {
    "text": "i not equal to j terms. But there's only-- I\nmean it's basically the diagonal of this matrix. There's n things that will\nalways collide with themselves.",
    "start": "4696570",
    "end": "4704510"
  },
  {
    "text": "So we're going to get like\nn plus the number of i",
    "start": "4704510",
    "end": "4710690"
  },
  {
    "text": "not equal to pairs\ndouble counted. So it's like 2 times n choose 2. But we get to divide by m.",
    "start": "4710690",
    "end": "4718180"
  },
  {
    "text": "So this is like n squared /n. So we get order n.",
    "start": "4718180",
    "end": "4726070"
  },
  {
    "text": "So that's not--\nwell, that's cool. Expected space is linear.",
    "start": "4726070",
    "end": "4731073"
  },
  {
    "text": "This is what makes\neverything work. ",
    "start": "4731073",
    "end": "4739409"
  },
  {
    "text": "Last class was about getting\nwith high probability bounds when we're working with logs. ",
    "start": "4739410",
    "end": "4745610"
  },
  {
    "text": "When you want to\nget that something is log with high\nprobability, you have to use, with\nrespect to n, you",
    "start": "4745610",
    "end": "4751690"
  },
  {
    "text": "have to use a turn off bound. But this is about-- now I\nwant to show that the space is",
    "start": "4751690",
    "end": "4757290"
  },
  {
    "text": "linear with high probability. Linear is actually really easy. You can use a much weaker\nbound called Markov inequality.",
    "start": "4757290",
    "end": "4764560"
  },
  {
    "text": "So I want to claim that the\nprobability of h1 of this thing",
    "start": "4764560",
    "end": "4776200"
  },
  {
    "text": "lj squareds being bigger\nthan some constant times n is at most the expectation\nof that thing divided by cn.",
    "start": "4776200",
    "end": "4789624"
  },
  {
    "text": "This is Markov's inequality. It holds for anything here. So I'm just repeating\nit over here. ",
    "start": "4789624",
    "end": "4798550"
  },
  {
    "text": "So this is nice because we\nknow that this expectation is",
    "start": "4798550",
    "end": "4805170"
  },
  {
    "text": "linear. So we're getting like a\nlinear function divided by cn.",
    "start": "4805170",
    "end": "4812000"
  },
  {
    "text": "Remember we get to choose c. The step said if it's bigger\nthan some constant times n then we're redoing the thing.",
    "start": "4812000",
    "end": "4818050"
  },
  {
    "text": "So I can choose c\nto be 100, whatever. I'm going to choose it to\nbe twice this constant.",
    "start": "4818050",
    "end": "4823870"
  },
  {
    "text": "And then this is at most half. So the probability of\nmy space being too big",
    "start": "4823870",
    "end": "4829600"
  },
  {
    "text": "is at most a half. We're back to coin flipping. Every time I flip\na coin, if I get heads I have the right amount\nof space at less than c times n",
    "start": "4829600",
    "end": "4840550"
  },
  {
    "text": "space. If I get a tails I try again. So the expected number\nof trials is 2 at most",
    "start": "4840550",
    "end": "4850000"
  },
  {
    "text": "not trails, trials. And it's also log n trials\nwith high probability.",
    "start": "4850000",
    "end": "4857605"
  },
  {
    "text": " How much time do I\nspend for each trial?",
    "start": "4857605",
    "end": "4863480"
  },
  {
    "text": "Linear time. I choose one hash function. I hash all the items. I count the number of collision\nsquared or the sum of lj",
    "start": "4863480",
    "end": "4870120"
  },
  {
    "text": "squared. That takes linear time to do. And so the total work I'm doing\nfor these steps is n log n.",
    "start": "4870120",
    "end": "4876150"
  },
  {
    "text": " So n log n to do\nstep 1 and 1 prime",
    "start": "4876150",
    "end": "4883710"
  },
  {
    "text": "and log squared n to\ndo steps 2 and 2 prime. Overall n Polylog\nor polynomial time.",
    "start": "4883710",
    "end": "4890940"
  },
  {
    "text": "And we get guaranteed no\ncollisions for static data. Constant worst case search\nand linear worst case space.",
    "start": "4890940",
    "end": "4899714"
  },
  {
    "text": "This is kind of surprising\nthat this works out but everything's nice. ",
    "start": "4899714",
    "end": "4907780"
  },
  {
    "text": "Now you know hashing. ",
    "start": "4907780",
    "end": "4910740"
  }
]