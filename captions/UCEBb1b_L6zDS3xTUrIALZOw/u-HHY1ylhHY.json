[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: All right. Today is all about the\npredecessor problem, which",
    "start": "18450",
    "end": "24904"
  },
  {
    "text": "is a problem we've certainly\ntalked about implicitly with, say, binary search trees. You want to be able to\ninsert and delete into a set,",
    "start": "24904",
    "end": "30940"
  },
  {
    "text": "and compute the predecessor\nand successor of any given key. So maybe define that formally.",
    "start": "30940",
    "end": "39114"
  },
  {
    "start": "39115",
    "end": "48160"
  },
  {
    "text": "And this is not\nreally our first, but it is an example of\nan integer data structure.",
    "start": "48160",
    "end": "54370"
  },
  {
    "text": "And for whatever\nreason, I don't brand hashing as an integer\ndata structure, just because it's its own beast.",
    "start": "54370",
    "end": "61384"
  },
  {
    "text": "But in particular, today,\nI need to be a little more formal about the models of\ncomputation we're allowing-- or I want to be.",
    "start": "61384",
    "end": "67600"
  },
  {
    "text": "In particular, because, in the\npredecessor problem, which is,",
    "start": "67600",
    "end": "72880"
  },
  {
    "text": "insert, delete,\npredecessor, successor,",
    "start": "72880",
    "end": "79409"
  },
  {
    "text": "there are actually lower bounds\nthat say you cannot do better than such and such. With hashing, there aren't\nreally any lower bounds,",
    "start": "79410",
    "end": "86170"
  },
  {
    "text": "because you can do\neverything in constant time with high probability. So I mean, there are\nmaybe some lower bounds on deterministic hashing.",
    "start": "86170",
    "end": "91990"
  },
  {
    "text": "That's harder. But if you allow randomization,\nthere's no real lower bounds, whereas predecessor, there is.",
    "start": "91990",
    "end": "97710"
  },
  {
    "text": " And in general,\npredecessor problem--",
    "start": "97710",
    "end": "106566"
  },
  {
    "text": "the key thing I\nwant to highlight is that we're maintaining\nhere a set of--",
    "start": "106566",
    "end": "113500"
  },
  {
    "text": "the set is called s\nof n elements, which",
    "start": "113500",
    "end": "124270"
  },
  {
    "text": "live in some universe, U-- just like last time. When you insert, you can\ninsert an arbitrary element",
    "start": "124270",
    "end": "130179"
  },
  {
    "text": "of the universe. That probably shouldn't be an\ns, or it will get thrown away. But the key thing is that\npredecessor and successor",
    "start": "130180",
    "end": "137020"
  },
  {
    "text": "operate not just on\nthe [INAUDIBLE] in s, but you can give it any key. It doesn't have to be in there.",
    "start": "137020",
    "end": "142390"
  },
  {
    "text": "And it will find the\nprevious key that is in s, or the next key that is in s. So predecessor is\nthe largest key",
    "start": "142390",
    "end": "149280"
  },
  {
    "text": "that is less than or equal\nto x that's in your set. ",
    "start": "149280",
    "end": "157550"
  },
  {
    "text": "And successor is the\nsmallest that is larger--",
    "start": "157550",
    "end": "163406"
  },
  {
    "text": "of course, if there is one. ",
    "start": "163406",
    "end": "168675"
  },
  {
    "text": "So those are the kinds of\noperations we want to do. Now, we know how to do all of\nthis n log n time, no problem,",
    "start": "168675",
    "end": "174040"
  },
  {
    "text": "with binary search trees,\nin the comparison model. But I want to introduce two\nmore, say, realistic models",
    "start": "174040",
    "end": "181330"
  },
  {
    "text": "of computers, that ignore\nthe memory hierarchy, but think about\nregular RAM machines--",
    "start": "181330",
    "end": "188620"
  },
  {
    "text": "random access machines--\nand what they can really do. And it's a model we're going\nto be working on for the next,",
    "start": "188620",
    "end": "195670"
  },
  {
    "text": "I think, five lectures. So, important to\nset the stage right. ",
    "start": "195670",
    "end": "202150"
  },
  {
    "text": "So these are models for\ninteger data structures. ",
    "start": "202150",
    "end": "209470"
  },
  {
    "text": "In general, we have\na unifying concept,",
    "start": "209470",
    "end": "214960"
  },
  {
    "text": "which is a word of\ninformation, a word of data,",
    "start": "214960",
    "end": "220045"
  },
  {
    "text": "a word of memory. It's used all over the\nplace-- a word of input. A word is the machine\ntheoretic sense,",
    "start": "220045",
    "end": "228640"
  },
  {
    "text": "not like the linguistic sense. It's going to be\na w-bit integer.",
    "start": "228640",
    "end": "234299"
  },
  {
    "text": "And so this defines the\nuniverse, which is-- I'm going to assume they're\nall unsigned integers.",
    "start": "234300",
    "end": "240909"
  },
  {
    "text": "So this is 2 to the w minus one. Those are all the\nunsigned integers",
    "start": "240910",
    "end": "247000"
  },
  {
    "text": "you can represent with w-bits. We'll also call this number,\n2 to the w, little u. That is the size of the\nuniverse, which is capital U.",
    "start": "247000",
    "end": "256060"
  },
  {
    "text": "So this matches\nnotation from last time. But I'm really highlighting how\nmany bits we have, which is w.",
    "start": "256060",
    "end": "263349"
  },
  {
    "text": "Now, here's where\nthings get interesting. I'm going to get to\na model called a word",
    "start": "263350",
    "end": "268930"
  },
  {
    "text": "RAM, which is what you\nmight expect, more or less. But before I get there I\nwant to define something",
    "start": "268930",
    "end": "274509"
  },
  {
    "text": "called transdichotomous RAM-- tough word to spell.",
    "start": "274510",
    "end": "280280"
  },
  {
    "text": "It just means bridging\na dichotomy-- bridging two worlds, if you will.",
    "start": "280280",
    "end": "286509"
  },
  {
    "text": "RAM is a random access machine. I've certainly mentioned\nthe word RAM before.",
    "start": "286510",
    "end": "294294"
  },
  {
    "text": "But now we're going to get a\nlittle more precise about it. So in general, in the\nRAM, memory is an array.",
    "start": "294294",
    "end": "300360"
  },
  {
    "text": "And you can do random\naccess into the array. But now, we're going to say,\nthe cells of the memory--",
    "start": "300360",
    "end": "306580"
  },
  {
    "text": "each slot in that array-- is a word. Everything is\ngoing to be a word. Every input-- all these\nx's are going to be words.",
    "start": "306580",
    "end": "314887"
  },
  {
    "text": "Everything will be a word. And in particular, the things\nin your memory are words. ",
    "start": "314887",
    "end": "321069"
  },
  {
    "text": "Let's say you have s of them. That's your space bound. In general, in\ntransdichotomous RAM,",
    "start": "321070",
    "end": "327430"
  },
  {
    "text": "you can do any operation\nthat reads and writes",
    "start": "327430",
    "end": "334180"
  },
  {
    "text": "a constant number\nof words in memory.",
    "start": "334180",
    "end": "340600"
  },
  {
    "text": "And in particular, you can do\nrandom access to that memory.",
    "start": "340600",
    "end": "345860"
  },
  {
    "text": "But in particular, we use\nwords to serve as pointers.",
    "start": "345860",
    "end": "352224"
  },
  {
    "start": "352225",
    "end": "357460"
  },
  {
    "text": "Here's my memory of words. ",
    "start": "357460",
    "end": "362590"
  },
  {
    "text": "Each of them is w bits-- so s of them, from, I\nguess, 0 to s minus one.",
    "start": "362590",
    "end": "372039"
  },
  {
    "text": "And if you have, like,\nthe number 3 here,",
    "start": "372040",
    "end": "377170"
  },
  {
    "text": "that can be used as a pointer\nto the third slot of memory. One, two, three.",
    "start": "377170",
    "end": "384909"
  },
  {
    "text": "You can use numbers as\nindexes into memory. So that's what I mean by,\nwords serve as pointers. So particularly, you can\nimplement a pointer machine,",
    "start": "384910",
    "end": "392110"
  },
  {
    "text": "which-- no surprise-- but for this to work, we\nneed a lower bound on w.",
    "start": "392110",
    "end": "399760"
  },
  {
    "text": "This implies w has to be at\nleast log of the space bound. Otherwise, you just can't\nindex your whole memory.",
    "start": "399760",
    "end": "407560"
  },
  {
    "text": "And if you've got s minus 1\nthings, this 2 to the w minus 1 better be at least s minus 1.",
    "start": "407560",
    "end": "413880"
  },
  {
    "text": "So we get this lower bound. So in particular, presumably, s\nis at least your problem size,",
    "start": "413880",
    "end": "423621"
  },
  {
    "text": "n. If you're trying to\nmaintain n items, you've got to store them.",
    "start": "423621",
    "end": "428670"
  },
  {
    "text": "So w is at least log n. Now, this relation is\nessentially a statement",
    "start": "428670",
    "end": "437760"
  },
  {
    "text": "bridging two worlds. Namely, you have,\non the one hand, your model of computation, which\nhas a particular word size.",
    "start": "437760",
    "end": "444044"
  },
  {
    "text": "And in reality, we think of that\nas being 32 or 64 or maybe 128. Some fancy operations\non Intel machines,",
    "start": "444045",
    "end": "451230"
  },
  {
    "text": "you can do 128-bit or so. And then there's\nyour problem size, which we think of as an input.",
    "start": "451230",
    "end": "457830"
  },
  {
    "text": "Now, this is relating the two. It's a little weird. I guess you could say it's just\na limitation for a given CPU.",
    "start": "457830",
    "end": "463469"
  },
  {
    "text": "There's only certain\nproblems you can solve. But theoretically, it\nmakes a lot of sense",
    "start": "463470",
    "end": "469687"
  },
  {
    "text": "to relate these two. Because if you're\nin a RAM, and you've got to be able to\nindex your data,",
    "start": "469687",
    "end": "474888"
  },
  {
    "text": "you need at least\nthat many bits just to be able to talk\nabout all those things. And so the claim is,\nbasically, machines",
    "start": "474889",
    "end": "481680"
  },
  {
    "text": "will grow to\naccommodate memory size. As memory size grows,\nyou'll need more bits.",
    "start": "481680",
    "end": "486700"
  },
  {
    "text": "Now, in reality, there's\nonly about 2 to 256--",
    "start": "486700",
    "end": "491894"
  },
  {
    "text": "what do you call\nthem-- particles in the known universe. So word size probably\nwon't get that much bigger.",
    "start": "491894",
    "end": "498520"
  },
  {
    "text": "Beyond 256 should be OK. But theoretically,\nthis is a nice way",
    "start": "498520",
    "end": "503610"
  },
  {
    "text": "to formalize this claim\nthat word sizes don't need to get too big unless\nmemories get gigantic.",
    "start": "503610",
    "end": "509370"
  },
  {
    "text": "So it may seem weird at\nfirst, but it's very natural. And all real world machines\nhave big enough words",
    "start": "509370",
    "end": "515549"
  },
  {
    "text": "to accommodate that. Word size could be bigger,\nand that will give you, essentially, more parallelism. But it should be\nat least that big.",
    "start": "515549",
    "end": "522789"
  },
  {
    "text": "All right. Enough proselytizing. ",
    "start": "522789",
    "end": "530410"
  },
  {
    "text": "That's the transdichotomous RAM. The end. And the word RAM is\na specific version",
    "start": "530410",
    "end": "536220"
  },
  {
    "text": "of the transdichotomous\nRAM, where",
    "start": "536220",
    "end": "544230"
  },
  {
    "text": "you restrict the operations\nto c-like operations. ",
    "start": "544230",
    "end": "551610"
  },
  {
    "text": "These are sort of the standard-- they're instructions\non, basically, all computers, except a few\nrisk architectures don't have",
    "start": "551610",
    "end": "558850"
  },
  {
    "text": "multiplication and division. But everything else\nis on everything.",
    "start": "558850",
    "end": "566191"
  },
  {
    "text": " So these are the operators,\nunless I missed one, in c.",
    "start": "566191",
    "end": "575199"
  },
  {
    "text": "They're all in Python,\nand pick your-- most languages. You've got integer\narithmetic, including mod.",
    "start": "575200",
    "end": "582696"
  },
  {
    "text": "You've got bitwise and,\nbitwise or, bitwise x or, bitwise negation, and\nshift left, and shift right.",
    "start": "582696",
    "end": "590730"
  },
  {
    "text": "These we all view as\ntaking constant time. They take one or two integer\ninputs-- words as inputs.",
    "start": "590730",
    "end": "599700"
  },
  {
    "text": "They can compute an answer. They write out another word. Of course, there's also random\naccess-- array dereference,",
    "start": "599700",
    "end": "605771"
  },
  {
    "text": "I guess. ",
    "start": "605771",
    "end": "610980"
  },
  {
    "text": "So that's the word RAM. You restrict to\nthese operations. Whereas transdichotomous\nRAM, you can do weird things, as\nlong as they only involve",
    "start": "610980",
    "end": "616501"
  },
  {
    "text": "a constant number of words. Word RAM-- it's\nthe regular thing. So this is basically\nthe standard model",
    "start": "616501",
    "end": "622800"
  },
  {
    "text": "that all integer data\nstructures use, pretty much. If they don't use this\nmodel, they have to say so.",
    "start": "622800",
    "end": "628199"
  },
  {
    "text": "Otherwise this model has become\naccepted as the normal one. It took several years\nbefore people realized",
    "start": "628200",
    "end": "633930"
  },
  {
    "text": "that's a good model--\ngood enough to capture pretty much everything we want.",
    "start": "633930",
    "end": "639300"
  },
  {
    "text": "The cool thing\nabout word RAM is, it lets you do things\non w-bits in parallel. You can take the and of\nw-bits, pairwise, all at once.",
    "start": "639300",
    "end": "647920"
  },
  {
    "text": "So you get some speed up. But it's a natural\ngeneralization of something like the comparison model. Comparison model-- I guess\nI didn't write those.",
    "start": "647920",
    "end": "655214"
  },
  {
    "text": "It's more operations-- less\nthan, greater than, and so on. You can compare two\nnumbers in constant time,",
    "start": "655215",
    "end": "661290"
  },
  {
    "text": "get a Boolean output\nvia, say, subtraction, and computing the sine. ",
    "start": "661290",
    "end": "669000"
  },
  {
    "text": "And you think of comparisons\nas taking constant time, so why not all of these things?",
    "start": "669000",
    "end": "674850"
  },
  {
    "text": "Cool. One more model-- this\nis kind of a weird one.",
    "start": "674850",
    "end": "681710"
  },
  {
    "text": "It's called cell\nprobe model, which is, we just count\nthe number of memory",
    "start": "681710",
    "end": "691440"
  },
  {
    "text": "reads and writes that we\nneed to do to solve a data",
    "start": "691440",
    "end": "702206"
  },
  {
    "text": "structure or a query. Like, you you're\nlooking at predecessor, and you just want to know,\nhow much of the data structure",
    "start": "702206",
    "end": "707280"
  },
  {
    "text": "do I have to read in order to be\nable to answer the predecessor problem? How much do I have\nto write out to do",
    "start": "707280",
    "end": "712311"
  },
  {
    "text": "an insertion, or whatever? And so in this model,\ncomputation is free.",
    "start": "712311",
    "end": "720480"
  },
  {
    "text": "And this is kind of like\nthe external memory model, and the cache oblivious models.",
    "start": "720480",
    "end": "726180"
  },
  {
    "text": "There, we were\nmeasuring how many block reads and writes there are. Here, our blocks are\nactually our words. So there is a bit of a relation,\nexcept there's no real--",
    "start": "726180",
    "end": "734397"
  },
  {
    "text": "you can either think\nof there being no cache here, because\nyou're just reading in a constant number of words,\ndoing something, spitting",
    "start": "734397",
    "end": "739463"
  },
  {
    "text": "stuff out. Or in the cell probe\nmodel, you could imagine there being an infinite\ncache for this operation,",
    "start": "739463",
    "end": "744630"
  },
  {
    "text": "but no cache from\noperation to operation. It's just, how much do I have\nto [INAUDIBLE] information, theoretically, to solve a\nparticular predecessor problem?",
    "start": "744630",
    "end": "751190"
  },
  {
    "text": "We'll deal with this\na lot in a couple of lectures-- not quite yet. This model is just\nused for lower bounds.",
    "start": "751190",
    "end": "758199"
  },
  {
    "text": "It's not a realistic\nmodel, because you have to pay for computation\nin the real world.",
    "start": "758200",
    "end": "763794"
  },
  {
    "text": "But if you can\nprove that you need to read at least a certain\nnumber of words, then, of course, you have to do at\nleast that many operations.",
    "start": "763794",
    "end": "770920"
  },
  {
    "text": "So it's nice for lower bounds. In general, we have this\nsort of hierarchy of models,",
    "start": "770920",
    "end": "778020"
  },
  {
    "text": "where this is the most\npowerful, strongest,",
    "start": "778020",
    "end": "783390"
  },
  {
    "text": "and below cell probe, we\nhave transdichotomous RAM,",
    "start": "783390",
    "end": "793920"
  },
  {
    "text": "then word RAM, then--\njust to fit it in context,",
    "start": "793920",
    "end": "800100"
  },
  {
    "text": "what we've been doing-- below that is pointer\nmachine, and below that",
    "start": "800100",
    "end": "805620"
  },
  {
    "text": "would be binary search tree. I've mentioned before,\npointer machines are more powerful than\nbinary search tree. And of course, we can\nimplement a pointer machine",
    "start": "805620",
    "end": "812281"
  },
  {
    "text": "on a word RAM. So we have these relations. There are, of\ncourse, other models. But this is a quick picture\nof models we've seen so far.",
    "start": "812281",
    "end": "819450"
  },
  {
    "start": "819450",
    "end": "827140"
  },
  {
    "text": "So now, we have this\nnotion of a word. In the predecessor problem,\nthese elements are words.",
    "start": "827140",
    "end": "834475"
  },
  {
    "text": " They're w-bit integers,\nuniverse-defined.",
    "start": "834475",
    "end": "840311"
  },
  {
    "text": "And we want to be able to\ninsert, delete, predecessor, and successor over words. So that's our challenge.",
    "start": "840311",
    "end": "847558"
  },
  {
    "start": "847558",
    "end": "852910"
  },
  {
    "text": "In the binary search\ntree model, we know the answer to this\nproblem is theta log n. In general, any\ncomparison-based data structure,",
    "start": "852910",
    "end": "859690"
  },
  {
    "text": "you need theta log\nn, in the worst case. It's an easy lower bound.",
    "start": "859690",
    "end": "864710"
  },
  {
    "text": "But we're going to do better on\nthese other models in the word RAM.",
    "start": "864710",
    "end": "870040"
  },
  {
    "text": "So here are some results. ",
    "start": "870040",
    "end": "878440"
  },
  {
    "text": "First data structure is\ncalled Van Emde Boas. You might guess it\nis by van Emde Boas-- Peter.",
    "start": "878440",
    "end": "885160"
  },
  {
    "text": "It actually has a\ncouple other authors in some versions of\nthe papers, which makes a little bit confusing. But for whatever reason,\nthe data structure",
    "start": "885160",
    "end": "891361"
  },
  {
    "text": "is just named Van Emde Boas. And it achieves log\nw per operation.",
    "start": "891361",
    "end": "903770"
  },
  {
    "text": "I think I'll rewrite this. This is log log u per operation.",
    "start": "903770",
    "end": "909490"
  },
  {
    "text": "But it requires u space. So think of u space as\nbeing, like, for every item",
    "start": "909490",
    "end": "916330"
  },
  {
    "text": "in the universe I store,\nyes or no, is it in the set? So that's a lot of space, unless\nn and u are not too different.",
    "start": "916330",
    "end": "924700"
  },
  {
    "text": "But we can do better. But the cool thing\nis the running time. This is really fast--",
    "start": "924700",
    "end": "930970"
  },
  {
    "text": "log log u. If you think about,\nfor example-- I don't know-- the universe\nbeing polynomial in n,",
    "start": "930970",
    "end": "940660"
  },
  {
    "text": "or even if the universe\nis something like-- polynomial in n is\nthe same as this-- 2 to the c log n.",
    "start": "940660",
    "end": "946960"
  },
  {
    "text": "You can go crazy and\nsay log to the c power-- so, like, 2 to the log\nto the fifth power.",
    "start": "946960",
    "end": "952100"
  },
  {
    "text": "All those things,\nyou take log twice. Then log log u becomes\ntheta log log n.",
    "start": "952100",
    "end": "962589"
  },
  {
    "text": "So as long as your word\nsize is not insanely large,",
    "start": "962590",
    "end": "971545"
  },
  {
    "text": "you're getting log\nlog n performance. So in general, when, let's\nsay, w is is polylog n,",
    "start": "971545",
    "end": "983700"
  },
  {
    "text": "then we're getting this\nkind of performance. And I think on most computers,\nw is polylogarithmic. We said it has to\nbe at least log.",
    "start": "983700",
    "end": "990490"
  },
  {
    "text": "It's also, generally, not\nso much bigger than log. So log squared is probably\nfine most of the time,",
    "start": "990490",
    "end": "995589"
  },
  {
    "text": "unless you have a\nreally small problem. OK, so cool.",
    "start": "995590",
    "end": "1000680"
  },
  {
    "text": "But the space is giant. So how do we do\nbetter than that? Well, there's a\ncouple of answers.",
    "start": "1000680",
    "end": "1006699"
  },
  {
    "text": "One is that you can achieve\nlog w with high probability,",
    "start": "1006700",
    "end": "1014640"
  },
  {
    "text": "and order n space. With a slight tweak, basically,\nyou combine Van Emde Boas",
    "start": "1014640",
    "end": "1021930"
  },
  {
    "text": "plus hashing, and you get that. I don't actually know what the\nreference is for this result.",
    "start": "1021930",
    "end": "1028799"
  },
  {
    "text": "It's been an exercise in\nvarious courses, and so on.",
    "start": "1028800",
    "end": "1034349"
  },
  {
    "text": "I can talk more\nabout that later. Then alternatively, there's\nanother data structure, which, in many ways, is simpler.",
    "start": "1034349",
    "end": "1040740"
  },
  {
    "text": "It really embraces hashing. It's called y-fast trees. It achieves the same\nbounds-- so log w",
    "start": "1040740",
    "end": "1046903"
  },
  {
    "text": "with high probability\nand linear space. It's basically just a hash\ntable with some cleverness.",
    "start": "1046904",
    "end": "1053429"
  },
  {
    "text": "So we'll get there. Even though it's\nsimpler, we're going to start with this structure. Historically, this is\nthe way it happened--",
    "start": "1053430",
    "end": "1060210"
  },
  {
    "text": "Van Emde Boas, then y-fast\ntrees, which are by Willard. And it'll be kind\nof a nice finale.",
    "start": "1060210",
    "end": "1065670"
  },
  {
    "text": " There's another data structure\nI want to talk about,",
    "start": "1065670",
    "end": "1073480"
  },
  {
    "text": "which is designed for the\ncase when w is very large--",
    "start": "1073480",
    "end": "1078780"
  },
  {
    "text": "much bigger than polylog n. In that case, there's\nsomething called fusion trees.",
    "start": "1078780",
    "end": "1084360"
  },
  {
    "text": "And you can achieve\nlog base w of n-- and, I guess, with high\nprobability and linear space.",
    "start": "1084360",
    "end": "1093840"
  },
  {
    "text": " The original fusion\ntrees are static. And you could just do log base\nw of n deterministic queries.",
    "start": "1093840",
    "end": "1101879"
  },
  {
    "text": "But there's a later\nversion that dynamic, achieves this using hashing\nfor updates, insertions,",
    "start": "1101880",
    "end": "1110160"
  },
  {
    "text": "and deletions. Cool. So this is an\nalmost upside-down-- it's obviously\nalways an improvement",
    "start": "1110160",
    "end": "1116490"
  },
  {
    "text": "over just log base 2 of n.",
    "start": "1116490",
    "end": "1121890"
  },
  {
    "text": "But it's sometimes better and\nsometimes worse than log w. In fact, it kind of makes\nsense to take the min of them.",
    "start": "1121890",
    "end": "1128490"
  },
  {
    "text": "When w is small, you\nwant to use log w. When w is big, you want\nto use log base w of n.",
    "start": "1128490",
    "end": "1133950"
  },
  {
    "text": "They're going to balance out\nwhen w is 2 to the root log n--",
    "start": "1133950",
    "end": "1144889"
  },
  {
    "text": "something like that. The easy thing is,\nwhen these balance out is when they're equal.",
    "start": "1144890",
    "end": "1151150"
  },
  {
    "text": "And that will be when this\nis log n divided by log w.",
    "start": "1151150",
    "end": "1156850"
  },
  {
    "text": "So when log w equals\nlog n divided by log w-- let do that over here.",
    "start": "1156850",
    "end": "1162250"
  },
  {
    "text": "log w is log n over log w.",
    "start": "1162250",
    "end": "1167870"
  },
  {
    "text": "Then this is like saying\nlog squared w equals log n, or log w is root log n.",
    "start": "1167870",
    "end": "1176641"
  },
  {
    "text": "So I was right. w is\n2 to the root log in, which is a weird quantity. But the easy thing to\nthink about is this one--",
    "start": "1176641",
    "end": "1182310"
  },
  {
    "text": "log w is root log n. And in that case, the running\ntime you get is root log n.",
    "start": "1182310",
    "end": "1187610"
  },
  {
    "text": " So it's always, at most, this.",
    "start": "1187610",
    "end": "1192880"
  },
  {
    "text": "And the worst case is when\nthese things are balanced, or these two are the same, and\nthey both achieve root log n.",
    "start": "1192880",
    "end": "1200289"
  },
  {
    "text": "But if w is smaller or\nlarger than this threshold, these structures will be\neven better than root log n. But in particular,\nit's a nice way",
    "start": "1200290",
    "end": "1206446"
  },
  {
    "text": "to think about, oh, we're\ndoing sort of a square factor better than binary search trees.",
    "start": "1206446",
    "end": "1212930"
  },
  {
    "text": "And we can do this high\nprobability in linear space. ",
    "start": "1212930",
    "end": "1220120"
  },
  {
    "text": "So that's cool. ",
    "start": "1220120",
    "end": "1227530"
  },
  {
    "text": "Turns out it's also\npretty much optimal. And that's not at all\nobvious, and wasn't",
    "start": "1227530",
    "end": "1238540"
  },
  {
    "text": "known for many years. ",
    "start": "1238540",
    "end": "1246650"
  },
  {
    "text": "So there's a cell\nprobe lower bound. So these are all in\nthe word RAM model--",
    "start": "1246650",
    "end": "1257580"
  },
  {
    "text": "all these results. The first one actually kind of\nworks in the pointer machine. I'll talk about that later. ",
    "start": "1257580",
    "end": "1270570"
  },
  {
    "text": "This lower bound's a\nlittle bit messy to state. The bound is slightly\nmore complicated",
    "start": "1270570",
    "end": "1278100"
  },
  {
    "text": "than what we've seen. But I'm going to restrict to\na special situation, which is, if you have n polylog n space.",
    "start": "1278100",
    "end": "1284660"
  },
  {
    "text": "So this is a lower bound\non static predecessor. All you need to do is solve\npredecessor and successor,",
    "start": "1284660",
    "end": "1290200"
  },
  {
    "text": "or even just predecessor. There's no inserts and deletes. In that case, if you use lots of\nspace, like u space, of course,",
    "start": "1290200",
    "end": "1297250"
  },
  {
    "text": "you can do constant\ntime for everything. You just store all the answers. But if you want space that's\nnot much bigger than n--",
    "start": "1297250",
    "end": "1305632"
  },
  {
    "text": "in particular, if you wanted\nto be able to do updates in polylog, this\nis the most space you could ever hope to achieve.",
    "start": "1305632",
    "end": "1311830"
  },
  {
    "text": "So assuming that, which\nis pretty reasonable, there's a bound of the\nmin of two things--",
    "start": "1311830",
    "end": "1320049"
  },
  {
    "text": "log base w of n,\nwhich is fusion trees, and, roughly, log w,\nwhich is Van Emde Boas.",
    "start": "1320050",
    "end": "1325930"
  },
  {
    "text": "But it's slightly\nsmaller than that. ",
    "start": "1325930",
    "end": "1336169"
  },
  {
    "text": "Yeah, pretty weird. Let me tell you\nthe consequences-- a little easier to think about. Van Emde Boas is going to be\noptimal for the kind of cases",
    "start": "1336170",
    "end": "1346270"
  },
  {
    "text": "we care about, which\nis when w is polylog n. ",
    "start": "1346270",
    "end": "1355270"
  },
  {
    "text": "And fusion trees are\noptimal when w is big. ",
    "start": "1355270",
    "end": "1369910"
  },
  {
    "text": "Square root log n log log n.",
    "start": "1369910",
    "end": "1375450"
  },
  {
    "text": "OK-- a little messy. So there's this divided by\nlog of log w over log n.",
    "start": "1375450",
    "end": "1383890"
  },
  {
    "text": "If w is polylog n, then this\nis just order log log n. And so this cancels.",
    "start": "1383890",
    "end": "1389340"
  },
  {
    "text": "This becomes constant. So in these situations, which\nare the ones I mentioned over here, w is polylog\nn, which is when",
    "start": "1389340",
    "end": "1395440"
  },
  {
    "text": "we get log log n performance. And that's kind of the\ncase we care about. Van Emde Boas is the\nbest thing to do.",
    "start": "1395440",
    "end": "1401320"
  },
  {
    "text": "Turns out, this is\nactually the right answer. You can do slightly better.",
    "start": "1401320",
    "end": "1406670"
  },
  {
    "text": "It's almost an exercise. You can tweak Van Emde Boas and\nget this slight improvement. But most word sizes, it\nreally doesn't matter.",
    "start": "1406670",
    "end": "1413600"
  },
  {
    "text": "You're not saving much. Cool. So other than that\nlittle factor,",
    "start": "1413600",
    "end": "1419050"
  },
  {
    "text": "these are the right answers. You have to know\nabout Van Emde Boas. You have to know\nabout fusion trees. And so this lecture is\nabout Van Emde Boas.",
    "start": "1419050",
    "end": "1425380"
  },
  {
    "text": "Next lecture is\nabout fusion trees. This result is from 2006\nand 2007, so pretty recent.",
    "start": "1425380",
    "end": "1445040"
  },
  {
    "text": "So let's start a Van Emde Boas. ",
    "start": "1445040",
    "end": "1479539"
  },
  {
    "text": "Yeah. Let's dive into it. I'll talk about\nhistory a little later. The central idea,\nI guess, if you",
    "start": "1479540",
    "end": "1485800"
  },
  {
    "text": "wanted to sum up Van Emde\nBoas in an equation, which is something we very rarely\nget to do in algorithms,",
    "start": "1485800",
    "end": "1492980"
  },
  {
    "text": "is to think about\nthis recurrence-- T of u is T of square\nroot of u plus order 1.",
    "start": "1492980",
    "end": "1500429"
  },
  {
    "text": "What does this solve to? log log u.",
    "start": "1500430",
    "end": "1505470"
  },
  {
    "text": "All right, just\nthink of taking logs. This is the same as\nT of w equals T of w",
    "start": "1505470",
    "end": "1513470"
  },
  {
    "text": "over 2 plus order 1. w is the word size. And so this is log w.",
    "start": "1513470",
    "end": "1519470"
  },
  {
    "text": "It's the same thing. If we could achieve\nthis recurrence, then--",
    "start": "1519470",
    "end": "1525410"
  },
  {
    "text": "boom-- we get our\nbound of log w. ",
    "start": "1525410",
    "end": "1530809"
  },
  {
    "text": "So how do we do it. We split the universe\ninto root u clusters,",
    "start": "1530810",
    "end": "1545480"
  },
  {
    "text": "each of size root u. ",
    "start": "1545480",
    "end": "1551980"
  },
  {
    "text": "OK, so, if here is our\nuniverse, then I just",
    "start": "1551980",
    "end": "1559940"
  },
  {
    "text": "split every square\nroot of u items. So each of these is root u long.",
    "start": "1559940",
    "end": "1566870"
  },
  {
    "text": "The number of them\nis square root of u. And then somehow,\nI want to recurse on each of these clusters.",
    "start": "1566870",
    "end": "1574460"
  },
  {
    "text": "And I only get to\nrecurse on one of them-- so a pretty simple idea. ",
    "start": "1574460",
    "end": "1594550"
  },
  {
    "text": "Yeah. So I'll talk about\nhow to actually do that recursion in a moment. Before I get there,\nI want to define a sort of hierarchical\ncoordinate system.",
    "start": "1594550",
    "end": "1603789"
  },
  {
    "text": "This is a new way of\nphrasing it for me. So I hope you like it. If we have a word x, I\nwant to write it as two",
    "start": "1603790",
    "end": "1612510"
  },
  {
    "text": "coordinates-- c and i. I'm going to use\nangle brackets, so it doesn't get too confusing. c\nis which cluster you're in.",
    "start": "1612510",
    "end": "1620700"
  },
  {
    "text": "So this is cluster 0, cluster\n1, cluster 2, cluster three. i is your index\nwithin the cluster.",
    "start": "1620700",
    "end": "1625820"
  },
  {
    "text": "So this is 0, 1, 2, 3, 4,\n5-- up to root u minus 1 within this cluster. Then 0, 1, 2, 3, 4, 5\nup to root u minus 1",
    "start": "1625820",
    "end": "1632670"
  },
  {
    "text": "with in this\ncluster-- so the i is your index within the\ncluster, like this,",
    "start": "1632670",
    "end": "1639720"
  },
  {
    "text": "and c is which\ncluster you are in. OK. Pretty simple.",
    "start": "1639720",
    "end": "1645540"
  },
  {
    "text": "And there's easy\narithmetic to do this. c is x integer divide root u.",
    "start": "1645540",
    "end": "1653430"
  },
  {
    "text": "And i is x integer mod root u. I used Python notation here.",
    "start": "1653430",
    "end": "1661559"
  },
  {
    "text": "So fine, I think\nyou all know this-- pretty simple. And if I gave you\nc and i, you could",
    "start": "1661560",
    "end": "1667230"
  },
  {
    "text": "reconstruct x by just\nsaying, oh, well, that's c times root u plus i.",
    "start": "1667230",
    "end": "1672600"
  },
  {
    "text": "So in constant time, you\ncan decompose a number into its two coordinates. That's the point.",
    "start": "1672600",
    "end": "1679580"
  },
  {
    "text": "In fact, it's much\neasier than this. You don't even\nhave to do division if you think of\neverything in binary,",
    "start": "1679581",
    "end": "1684909"
  },
  {
    "text": "which computers tend to do. So the binary perspective\nis that x is a word.",
    "start": "1684910",
    "end": "1696559"
  },
  {
    "text": "So it's a bunch of bits. 0, 1, 1, 0, 1, 0,\n0, 1-- whatever.",
    "start": "1696560",
    "end": "1705000"
  },
  {
    "text": "Divide that bit sequence\nin half, and then this part is c, this part is i.",
    "start": "1705000",
    "end": "1712919"
  },
  {
    "text": "And if you assume that\nw is a power of 2, these two are identical. If they're not a\npower of 2, you've",
    "start": "1712920",
    "end": "1718470"
  },
  {
    "text": "got to round a little bit here. It doesn't matter. But you can use this definition\ninstead of this one either way.",
    "start": "1718470",
    "end": "1726190"
  },
  {
    "text": "So in this case, c is-- ooh, boy-- x shifted\nright, w over 2, basically.",
    "start": "1726190",
    "end": "1734100"
  },
  {
    "text": "So this w over 2-- w over 2.",
    "start": "1734100",
    "end": "1740220"
  },
  {
    "text": "The whole thing is w bits. So if I shift right, I get\nrid of the low order bits,",
    "start": "1740220",
    "end": "1747150"
  },
  {
    "text": "if I want. i is slightly more annoying. But I can't do it\nas an and with one",
    "start": "1747150",
    "end": "1758070"
  },
  {
    "text": "shifted left w over 2 minus 1.",
    "start": "1758070",
    "end": "1764690"
  },
  {
    "text": "That's probably\nhow you do it in c. I don't know if\nyou're used to this. But if I take it a 1 bit,\nI shift it over to here, and I subtract 1.",
    "start": "1764690",
    "end": "1770309"
  },
  {
    "text": "Then I get a whole\nbunch of 1 bits. And then you mask\nwith that bit pattern. So I'm masking with 1, 1, 1, 1.",
    "start": "1770310",
    "end": "1776850"
  },
  {
    "text": "Then I'll just get\nthe low order bits. Computers do the\nsuper fast-- way faster than integer division.",
    "start": "1776850",
    "end": "1782610"
  },
  {
    "text": "Because this is just\nlike routing bits around. So this is easy to\ndo on a typical CPU.",
    "start": "1782610",
    "end": "1787769"
  },
  {
    "text": "And this will be much\nfaster than this code, even though looks like\nmore operations, typically.",
    "start": "1787770",
    "end": "1793440"
  },
  {
    "text": "All right. So fine. The point is, I can\ndecompos x into c and i. Of course, I can\nalso do the reverse.",
    "start": "1793440",
    "end": "1801409"
  },
  {
    "text": "This would be c shifted\nleft w over 2, ord with i. ",
    "start": "1801410",
    "end": "1810160"
  },
  {
    "text": "It's a slight diversion. Now, I can tell you\nthe actual recursion,",
    "start": "1810160",
    "end": "1815400"
  },
  {
    "text": "and then talk about\nhow to maintain it. So we're going to define\na recursive Van Emde Boas",
    "start": "1815400",
    "end": "1824580"
  },
  {
    "text": "structure of size\nu and word size w.",
    "start": "1824580",
    "end": "1832279"
  },
  {
    "start": "1832280",
    "end": "1837660"
  },
  {
    "text": "And what it's going\nto look like is, we have a bunch of clusters,\neach of size square root of u.",
    "start": "1837660",
    "end": "1848830"
  },
  {
    "start": "1848830",
    "end": "1854820"
  },
  {
    "text": "So this represents the\nfirst root u items. This represents the\nnext root u items. This represents the last\nroot u items, and so on.",
    "start": "1854820",
    "end": "1861100"
  },
  {
    "text": "So that's the obvious\nrecursion from this. So this is going to\nbe a Van Emde Boas structure of size root u.",
    "start": "1861100",
    "end": "1867850"
  },
  {
    "text": "And then we also\nhave a structure up top, which is called\nthe summary structure.",
    "start": "1867850",
    "end": "1874929"
  },
  {
    "text": "And the idea is, it represents,\nfor each of these clusters, is the cluster empty or not?",
    "start": "1874930",
    "end": "1881620"
  },
  {
    "text": "Does this cluster\nhave any items in it? Yes or no. If yes, then the\nname of this cluster",
    "start": "1881620",
    "end": "1888940"
  },
  {
    "text": "is in the summary structure. So notice, by this\nhierarchical decomposition,",
    "start": "1888940",
    "end": "1893950"
  },
  {
    "text": "the cluster number\nand the index are valid names of items\nwithin these substructures.",
    "start": "1893950",
    "end": "1900020"
  },
  {
    "text": "And basically we're going to use\nthe i part to talk about things within the clusters. And we're going to use the\nc part to talk about things",
    "start": "1900020",
    "end": "1906640"
  },
  {
    "text": "within the summary structure. They're both numbers between\n0 and root u minus 1. And so we get this perspective.",
    "start": "1906640",
    "end": "1914170"
  },
  {
    "text": "All right. So formally, or some\nnotation, cluster i--",
    "start": "1914170",
    "end": "1921730"
  },
  {
    "text": "so we're going to have\nan array of clusters. It is Van Emde Boas thing\nof size square root u,",
    "start": "1921730",
    "end": "1930470"
  },
  {
    "text": "and word size w over 2.",
    "start": "1930470",
    "end": "1935620"
  },
  {
    "text": "This is slightly weird,\nbecause the machine, of course, its word size remains w.",
    "start": "1935620",
    "end": "1940630"
  },
  {
    "text": "It doesn't get smaller\nas you recurse. We're not going to try\nto spread the parallelism around or whatever.",
    "start": "1940630",
    "end": "1946950"
  },
  {
    "text": "But this is just a\nnotational convenience. I want to say the\nword size conceptually goes down to w over 2, so\nthat this definition still",
    "start": "1946950",
    "end": "1954039"
  },
  {
    "text": "makes sense. Because as I look at a\nsmaller part of the word, in order to divide it in\nhalf, I have to shift right",
    "start": "1954040",
    "end": "1961690"
  },
  {
    "text": "by a smaller amount. So that's the w that I'm\npassing into the structure.",
    "start": "1961690",
    "end": "1967330"
  },
  {
    "text": "OK, and then v dot\nsummary is same thing.",
    "start": "1967330",
    "end": "1972710"
  },
  {
    "text": "It's also Van Emde Boa's\nthing of size root u.",
    "start": "1972710",
    "end": "1978110"
  },
  {
    "text": "Then the one other clever idea,\nwhich makes all of this work, is that we store the minimum\nelement in v dot min.",
    "start": "1978110",
    "end": "1985040"
  },
  {
    "start": "1985040",
    "end": "1990490"
  },
  {
    "text": "And we do not store\nit recursively. ",
    "start": "1990490",
    "end": "2000070"
  },
  {
    "text": "So there's also one item here,\nsize 1, which is the min.",
    "start": "2000070",
    "end": "2007080"
  },
  {
    "text": "It's just stored\noff to the side. It doesn't live in\nthese structures. Every other item\nlives down here.",
    "start": "2007080",
    "end": "2013204"
  },
  {
    "text": "And furthermore, if one\nof these is not empty, there's also a\ncorresponding item up here.",
    "start": "2013204",
    "end": "2018750"
  },
  {
    "text": "This turns out to be crucial\nto make a Van Emde Boas work.",
    "start": "2018750",
    "end": "2023880"
  },
  {
    "text": "And then v dot\nmax, we also need-- but it can be\nstored recursively. So just think of it\nas a copy of whatever",
    "start": "2023880",
    "end": "2030090"
  },
  {
    "text": "the maximum element is. OK, so in constant time,\nwe can compute the min and compute the max.",
    "start": "2030090",
    "end": "2035520"
  },
  {
    "text": "That's good. But then I claim also in log\nw time-- log log u time-- we can do insert, delete,\npredecessor, successor.",
    "start": "2035520",
    "end": "2042492"
  },
  {
    "start": "2042492",
    "end": "2048888"
  },
  {
    "text": "So let's do that. ",
    "start": "2048889",
    "end": "2062379"
  },
  {
    "text": "This data structure--\nthe solution is both simple and\na little bit subtle. And so this will be\none of the few times",
    "start": "2062380",
    "end": "2068030"
  },
  {
    "text": "I'm going to write\nexplicit pseudocode-- say exactly how to maintain\nthis data structure.",
    "start": "2068030",
    "end": "2073399"
  },
  {
    "text": "It's short code, which is good. Each algorithm is\nonly a few lines.",
    "start": "2073400",
    "end": "2078739"
  },
  {
    "text": "But every line matters. So I want to write them down\nso I can talk about them. ",
    "start": "2078739",
    "end": "2086040"
  },
  {
    "text": "And with this new\nhierarchical notation, I think it's even easier\nto write these down.",
    "start": "2086040",
    "end": "2092460"
  },
  {
    "text": "Let's see how I do. ",
    "start": "2092460",
    "end": "2168510"
  },
  {
    "text": "OK, so we'll start with\nthe successor code. Predecessor is,\nof course, metric. ",
    "start": "2168510",
    "end": "2188000"
  },
  {
    "text": "And it basically has two cases. There's a special case\nin the beginning, which",
    "start": "2188000",
    "end": "2193540"
  },
  {
    "text": "is, if the thing you're\nquerying happens to be less than the minimum of the\nwhole thing, then of course,",
    "start": "2193540",
    "end": "2198670"
  },
  {
    "text": "the minimum is the successor. This has to be done specially,\nbecause the min is not stored recursively.",
    "start": "2198670",
    "end": "2203987"
  },
  {
    "text": "And so you've got\nto check for the min every single level\nof the recursion. But that's just constant time.",
    "start": "2203987",
    "end": "2209500"
  },
  {
    "text": "No big deal. Then the interesting\nthings is, we have recursions in both sides-- in both cases-- but only one.",
    "start": "2209500",
    "end": "2218150"
  },
  {
    "text": "The key is, we want\nthis recurrence-- T of u is 1 times T of\nroot u plus order 1.",
    "start": "2218150",
    "end": "2225819"
  },
  {
    "text": "That gives us log log u. If there was a 2 here, we would\nget log u, which is no good.",
    "start": "2225820",
    "end": "2232760"
  },
  {
    "text": "We want the one. So in one case, we call\nsuccessor on a cluster. In the other case,\nwe call successor",
    "start": "2232760",
    "end": "2238630"
  },
  {
    "text": "on the summary structure. But we don't want to do both.",
    "start": "2238630",
    "end": "2244840"
  },
  {
    "text": "So let's just think about,\nintuitively, what's going on. We've got this-- I guess I can do it\nin the same picture.",
    "start": "2244840",
    "end": "2251200"
  },
  {
    "text": "We've got this summary\nand a bunch of clusters. And let's say you want\nto compute, what's",
    "start": "2251200",
    "end": "2256869"
  },
  {
    "text": "the successor of this item? So via this\ntransformation, we compute which cluster it lives in and\nwhere it is within the cluster.",
    "start": "2256870",
    "end": "2264100"
  },
  {
    "text": "That's i. So it's some item here. Now, it could be the successor\nis inside the same cluster.",
    "start": "2264100",
    "end": "2269650"
  },
  {
    "text": "Maybe there's an\nitem right there. Then want to recurse in here. Or it could be, it's\nin some future cluster.",
    "start": "2269650",
    "end": "2277090"
  },
  {
    "text": " Let's do the first case.",
    "start": "2277090",
    "end": "2282910"
  },
  {
    "text": "If, basically, we are less than\nthe max of our own cluster,",
    "start": "2282910",
    "end": "2288190"
  },
  {
    "text": "that means that the\nanswer is in there. Figure out what the max\nis in this structure--",
    "start": "2288190",
    "end": "2293980"
  },
  {
    "text": "the rightmost item in s\nthat's inside this cluster c. This is c.",
    "start": "2293980",
    "end": "2301300"
  },
  {
    "text": "If our index is less than the\nmax's index, then if we recurse in here, we will find an answer.",
    "start": "2301300",
    "end": "2308219"
  },
  {
    "text": "If we're bigger than\nthe max, then we won't find an answer down here. We have to recurse\nsomewhere else. So that's what we do.",
    "start": "2308219",
    "end": "2314890"
  },
  {
    "text": "If we're less than\nthe max, then we just recursively find the successor\nof our index within cluster c.",
    "start": "2314890",
    "end": "2322090"
  },
  {
    "text": "And we have to add\non the c in front. Because successor\nwithin this cluster",
    "start": "2322090",
    "end": "2327460"
  },
  {
    "text": "will only give an index\nwithin the cluster. And we have to prepend this\nc part to give a global name.",
    "start": "2327460",
    "end": "2334620"
  },
  {
    "text": "OK, so that's case 1. Very easy. The other case is where we're\nslightly clever, in some sense.",
    "start": "2334620",
    "end": "2341590"
  },
  {
    "text": "We say, OK, well, if there's no\nsuccessor within the cluster,",
    "start": "2341590",
    "end": "2346630"
  },
  {
    "text": "maybe it's in the next cluster. Of course, that one might\nbe empty, in which case, it's in the next cluster. But that one might be empty,\nso look at the next cluster.",
    "start": "2346630",
    "end": "2353050"
  },
  {
    "text": "We need to find, what is\nthe next non-empty cluster? For that, we use the\nsummary structure.",
    "start": "2353050",
    "end": "2359019"
  },
  {
    "text": "So we go up to position c here. We say, OK, what is the next\nnon-empty structure after c?",
    "start": "2359020",
    "end": "2365400"
  },
  {
    "text": "Because we know that's\ngoing to be where our answer lives for successor. So that's going to\ngive us, basically,",
    "start": "2365400",
    "end": "2371770"
  },
  {
    "text": "a pointer to one of these\nstructures-- c prime, which-- all these guys are empty.",
    "start": "2371770",
    "end": "2378249"
  },
  {
    "text": "And so there's no\nsuccessor in there. The successor is then the\nmin in this structure. So that's all we do.",
    "start": "2378249",
    "end": "2384160"
  },
  {
    "text": "Compute the successor of c\nin the summary structure. And then, in that\ncluster, c prime,",
    "start": "2384160",
    "end": "2391900"
  },
  {
    "text": "find the min, which\ntakes constant time, and then prepend c prime to\nthat to get a global name.",
    "start": "2391900",
    "end": "2399060"
  },
  {
    "text": "And that's our successor. Yeah, question. AUDIENCE: Could you repeat\nwhy min is not recursive?",
    "start": "2399060",
    "end": "2405864"
  },
  {
    "text": "Because looking\nat this, it looks like all these smaller\n[INAUDIBLE] trees have [INAUDIBLE]",
    "start": "2405864",
    "end": "2412714"
  },
  {
    "text": "ERIK DEMAINE: Ah, OK. Sorry. The question is, why is\nthe minimum not recursive? The answer to that\nquestion is not yet clear.",
    "start": "2412715",
    "end": "2418380"
  },
  {
    "text": "It will have to\ndo with insertion. But I think what\nexactly this means, I maybe didn't state\ncarefully enough.",
    "start": "2418380",
    "end": "2425440"
  },
  {
    "text": "Every Van Emde Boas\nstructure has a min-- stores a min. In that sense, this is done--",
    "start": "2425440",
    "end": "2432080"
  },
  {
    "text": "that's funny-- not\nso recursively. But every one stores it. The point is that\nthis item doesn't",
    "start": "2432080",
    "end": "2438849"
  },
  {
    "text": "get put into one\nof these clusters recursively-- just the item. But each of these\nhas its own min,",
    "start": "2438850",
    "end": "2444309"
  },
  {
    "text": "which is then not stored\nat the next level down. And each of those has\nits own min, which is not stored at the next level down.",
    "start": "2444310",
    "end": "2450190"
  },
  {
    "text": "Think of this as kind\nof like a little buffer. The first time I insert\nit into the structure, I just stick it into the min.",
    "start": "2450190",
    "end": "2455568"
  },
  {
    "text": "I don't touch anything else. You'll see when we get to\nthe insertion algorithm. But it sort of slows\nthings down from trickling.",
    "start": "2455568",
    "end": "2462430"
  },
  {
    "text": "AUDIENCE: So putting that min,\nis that what prevents from-- ERIK DEMAINE: That will\nprevent the insertion",
    "start": "2462430",
    "end": "2469000"
  },
  {
    "text": "from doing two recursions\ninstead of one. So we'll see that in a moment. At this point, just\nsuccessor is very clear.",
    "start": "2469000",
    "end": "2475379"
  },
  {
    "text": "This would work whether the min\nis stored recursively or not. But we need to know what the\nmin is of every structure,",
    "start": "2475379",
    "end": "2480440"
  },
  {
    "text": "and we need to know the\nmax of every structure. At this point, you could just\nsay that min and max could be",
    "start": "2480440",
    "end": "2485840"
  },
  {
    "text": "copies-- no big deal-- and we'd be happy. And of course, predecessor\ndoes the same thing.",
    "start": "2485840",
    "end": "2491294"
  },
  {
    "text": "So the slight cleverness here\nis that we use the min here. This could have been a successor\noperation with minus infinity",
    "start": "2491294",
    "end": "2496640"
  },
  {
    "text": "as the query. But that would be\ntwo recursions. We can only afford one. Fortunately, it's the\nmin item that we need.",
    "start": "2496640",
    "end": "2502970"
  },
  {
    "text": "So we're done with successor. That was the easy case-- or the easy one. Insert is slightly harder.",
    "start": "2502970",
    "end": "2510710"
  },
  {
    "text": "Delete is just slightly messier. It's basically the\nsame as insert. ",
    "start": "2510710",
    "end": "2519610"
  },
  {
    "text": "So insert-- let me\nwrite the code again. ",
    "start": "2519610",
    "end": "2597170"
  },
  {
    "text": "Insertion also has\ntwo main cases. There's this case,\nand the other case.",
    "start": "2597170",
    "end": "2602620"
  },
  {
    "text": "But there's no else here. This happens in both cases. And then there's some just\nannoying little details",
    "start": "2602620",
    "end": "2607900"
  },
  {
    "text": "at the beginning. Just like over here, we had to\ncheck for the min specially, here, we've got to\nupdate the min and max.",
    "start": "2607900",
    "end": "2614170"
  },
  {
    "text": "And there's a special case,\nwhich I haven't mentioned yet. v dot min-- special case is,\nit will be this value, none,",
    "start": "2614170",
    "end": "2624700"
  },
  {
    "text": "if the whole structure is empty. So this is the obvious way to\ntell whether a structure is",
    "start": "2624700",
    "end": "2632740"
  },
  {
    "text": "empty and has no min. Because if there's\nany items in there, there's going to be\none in the min slot.",
    "start": "2632740",
    "end": "2637810"
  },
  {
    "text": "So first thing we do is\ncheck, is our structure empty? If it's empty, the min and the\nmax become the inserted item.",
    "start": "2637810",
    "end": "2644710"
  },
  {
    "text": "We're done. So that's the easy case. We do not store it\nrecursively in here.",
    "start": "2644710",
    "end": "2651819"
  },
  {
    "text": "That's what this means. This element does not get\nstored in any of the clusters.",
    "start": "2651820",
    "end": "2657894"
  },
  {
    "text": "If it's not the very first\nitem, or it's not the min item, then we're going to recursively\ninsert it into a cluster.",
    "start": "2657894",
    "end": "2664520"
  },
  {
    "text": "So if we have x in\ncluster c, we always insert index i into cluster\nc, except if it's the min.",
    "start": "2664520",
    "end": "2676839"
  },
  {
    "text": "Now, it could be where a\nstructure is non-empty. There is a min item there. But we are less than the min. In that case, we're the new\nmin, and we just swap those.",
    "start": "2676840",
    "end": "2683650"
  },
  {
    "text": "And now, we have to\nrecursively insert the old min into the rest of the structure. So that's a simple case.",
    "start": "2683650",
    "end": "2689290"
  },
  {
    "text": "Then we also have\nto update v dot max, just in the obvious way. This is the easy way to\nmaintain v dot max in variant,",
    "start": "2689290",
    "end": "2695869"
  },
  {
    "text": "that is the maximum item. OK, now we have the two cases. I mean, this is really\nthe obvious thing",
    "start": "2695869",
    "end": "2702100"
  },
  {
    "text": "to get to do insertion. We have to update the\nsummary structure, meaning, if the cluster that we are\ninserting into-- cluster c--",
    "start": "2702100",
    "end": "2710020"
  },
  {
    "text": "is empty, that means it was not\nyet in the summary structure. We need to put it in there. So we just insert c\ninto v dot summary--",
    "start": "2710020",
    "end": "2717190"
  },
  {
    "text": "pretty obvious. And in all cases, we insert\nour item into cluster c.",
    "start": "2717190",
    "end": "2724044"
  },
  {
    "text": "This looks bad,\nhowever, because there's two recursions in some cases. If this if doesn't hold,\nit's one recursion.",
    "start": "2724044",
    "end": "2729880"
  },
  {
    "text": "Everything's fine. So if the cluster was\nalready in use, great. This is one recursion.",
    "start": "2729880",
    "end": "2735770"
  },
  {
    "text": "This is constant work. We're done. The worry is, if the\ncluster was empty",
    "start": "2735770",
    "end": "2740800"
  },
  {
    "text": "before, then this insertion\nis a whole recursion. That's scary, because we can't\nafford a second recursion.",
    "start": "2740800",
    "end": "2748010"
  },
  {
    "text": "But it's all OK. Because if we do\nthis recursion, that",
    "start": "2748010",
    "end": "2753160"
  },
  {
    "text": "means that this cluster\nwas empty, which means, in this recursion, we fall\ninto this very first case.",
    "start": "2753160",
    "end": "2759910"
  },
  {
    "text": "That structure,\nit's min is none. That's what we just checked for. If it's none, we do\nconstant work and stop.",
    "start": "2759910",
    "end": "2766572"
  },
  {
    "text": "So everything's OK. If we recursed in the\nsummary structure,",
    "start": "2766572",
    "end": "2773170"
  },
  {
    "text": "this recursion will be\na shallow recursion. It just does one thing. You could actually put this\ncode into this if case,",
    "start": "2773170",
    "end": "2783340"
  },
  {
    "text": "and make this an else case. That's another way\nto write the code. But this will be a\nvery short recursion.",
    "start": "2783340",
    "end": "2788480"
  },
  {
    "text": "So either you just\ndo this recursion, which could be\nexpensive, or you just do this one, in which case,\nwe know this one was cheap.",
    "start": "2788480",
    "end": "2794470"
  },
  {
    "text": "If this happens, we know\nthis will take constant time. So in both cases, we\nget this recursion--",
    "start": "2794470",
    "end": "2799660"
  },
  {
    "text": "square root of u plus constant. And so we get log\nlog u insertion.",
    "start": "2799660",
    "end": "2805086"
  },
  {
    "text": " Do you want to see delete? I mean, it's basically\nthe same thing.",
    "start": "2805086",
    "end": "2811410"
  },
  {
    "text": "It's in the notes. I mean, you do the\nobvious thing, which is, you delete in the cluster.",
    "start": "2811410",
    "end": "2817919"
  },
  {
    "text": "And then if it became\nempty, you also have to delete in the\nsummary structure. So there's, again, a chance\nthat you do two recursions.",
    "start": "2817919",
    "end": "2825510"
  },
  {
    "text": "But-- OK, I'm talking about it. Maybe I'll write a\nlittle bit of the code.",
    "start": "2825510",
    "end": "2830920"
  },
  {
    "start": "2830920",
    "end": "2837672"
  },
  {
    "text": "I think I won't\nwrite all the code, though-- just the main stuff. ",
    "start": "2837672",
    "end": "2844599"
  },
  {
    "text": "So if we want to\ndelete, then basically,",
    "start": "2844600",
    "end": "2851130"
  },
  {
    "text": "we delete in cluster c, index i.",
    "start": "2851130",
    "end": "2856799"
  },
  {
    "text": " And then if the cluster\nhas become empty",
    "start": "2856800",
    "end": "2864510"
  },
  {
    "text": "as a result of\nthat, then we have",
    "start": "2864510",
    "end": "2869970"
  },
  {
    "text": "to delete cluster c from\nthe summary structure, so that our predecessor and\nsuccessor queries actually",
    "start": "2869970",
    "end": "2876240"
  },
  {
    "text": "still work. ",
    "start": "2876240",
    "end": "2884131"
  },
  {
    "text": "OK, so that's the\nbulk of the code. I mean, that's where\nthe action happens. And the worry would be,\nin this if case, we're",
    "start": "2884132",
    "end": "2889190"
  },
  {
    "text": "doing two recursive deletes. The claim is, if we\ndo this second delete,",
    "start": "2889190",
    "end": "2896299"
  },
  {
    "text": "which is potentially expensive--\nthis one was really cheap-- the claim is that emptying\na Van Emde Boas structure",
    "start": "2896300",
    "end": "2903429"
  },
  {
    "text": "takes constant time--\nlike, if you're deleting the last element. Why? Because when you're\ndeleting the last element,",
    "start": "2903429",
    "end": "2909760"
  },
  {
    "text": "it's in the min right here. Everything below it-- all\nthe recursive structures--",
    "start": "2909760",
    "end": "2915020"
  },
  {
    "text": "will be empty if\nthere's only one item, because it will be right here. And you can check that\nfrom the insertion. If it was empty, all we did was\nchange v dot min and v dot max.",
    "start": "2915020",
    "end": "2923390"
  },
  {
    "text": "So the inverse, which\nI want right here, is just to clear out v\ndot min and v dot max. So if this ends up happening,\nthis only took constant time.",
    "start": "2923390",
    "end": "2932630"
  },
  {
    "text": "You don't have to recurse when\nyou're deleting the last item. So in either case, you're really\nonly doing one deep recursion.",
    "start": "2932630",
    "end": "2939000"
  },
  {
    "text": "So you get the same recurrence,\nand you get log log u. So for the details,\ncheck out the notes.",
    "start": "2939000",
    "end": "2944390"
  },
  {
    "text": "I want to go to other\nperspectives of Van Emde Boas. This is one way\nto think about it.",
    "start": "2944390",
    "end": "2951110"
  },
  {
    "text": "And amusingly, and this is\nprobably the most taut way to do Van Emde Boas.",
    "start": "2951110",
    "end": "2956540"
  },
  {
    "text": "It's, in CLRS,\ndescribed this way, because in 2001, when\nI first came here,",
    "start": "2956540",
    "end": "2961967"
  },
  {
    "text": "I presented Van Emde Boas like\nthis in an undergrad algorithms class with more details. You guys are grads, so I did\nit like three times faster",
    "start": "2961967",
    "end": "2969500"
  },
  {
    "text": "than I would in 6046. So now, it's in\ntextbooks and whatnot.",
    "start": "2969500",
    "end": "2976080"
  },
  {
    "text": "But this is not\nhow Van Emde Boas presented this data\nstructure-- just out of historical interest. This is a way that I believe\nwas invented by Michael Bender",
    "start": "2976080",
    "end": "2984401"
  },
  {
    "text": "and Martin Farach-Colton,\nwho are the co-authors on \"Cache-oblivious B-trees.\" And around 2001,\nthey were looking",
    "start": "2984401",
    "end": "2989730"
  },
  {
    "text": "at lots of old data structures\nand simplifying them. And I think this is a\nvery clean, simple way",
    "start": "2989730",
    "end": "2994800"
  },
  {
    "text": "to think about Van Emde Boas. But I want to tell you\nthe other way, which is the way it originally\nappeared in their papers.",
    "start": "2994800",
    "end": "3002599"
  },
  {
    "text": "There's actually three\npapers by van Emde Boas about this structure.",
    "start": "3002600",
    "end": "3009260"
  },
  {
    "text": "Many papers appear twice-- once in a conference,\nonce in a journal-- this one, there's\nthree relevant papers.",
    "start": "3009260",
    "end": "3015350"
  },
  {
    "text": "There's conference\nversion, journal version. The only weird thing there is\nthat the conference version",
    "start": "3015350",
    "end": "3020480"
  },
  {
    "text": "has one author-- van Emde Boas. The journal version\nhas three authors-- van Emde Boas,\nKaas, and Zijlstra.",
    "start": "3020480",
    "end": "3028134"
  },
  {
    "text": "And they're acknowledged\nin the conference version, so I guess they\nhelped even more. In particular, they, I think,\nimplemented this data structure",
    "start": "3028135",
    "end": "3035540"
  },
  {
    "text": "for the first time. It's a really easy\ndata structure to implement, and very fast. ",
    "start": "3035540",
    "end": "3041370"
  },
  {
    "text": "Then there's a third\npaper by van Emde Boas only in a journal which\nimproves the space a little bit.",
    "start": "3041370",
    "end": "3047010"
  },
  {
    "text": "So we'll see a little\nbit what that's about. But what I like about\nboth of these papers",
    "start": "3047010",
    "end": "3052610"
  },
  {
    "text": "is they offer a simpler way\nto get log log u, successor,",
    "start": "3052610",
    "end": "3060140"
  },
  {
    "text": "predecessor. Let's not worry about insertions\nand deletions for a little bit, and take what I'll call\nthe simple tree view.",
    "start": "3060140",
    "end": "3068990"
  },
  {
    "start": "3068990",
    "end": "3074660"
  },
  {
    "text": "So I'm going to draw a picture-- 0, 1, 0, 0, 0, 0, 0--",
    "start": "3074660",
    "end": "3081760"
  },
  {
    "start": "3081760",
    "end": "3087780"
  },
  {
    "text": "OK. This is what we call a bit\nvector, meaning, here's",
    "start": "3087780",
    "end": "3096200"
  },
  {
    "text": "item zero, item one, item two. And here is u minus 1.",
    "start": "3096200",
    "end": "3102195"
  },
  {
    "text": "And I'll put a 1 if that\nelement is in my set, and a 0 otherwise.",
    "start": "3102195",
    "end": "3107280"
  },
  {
    "text": "OK, so one is in the set, nine-- I think-- is in the set,\n10, and 15 are in the set.",
    "start": "3107280",
    "end": "3115190"
  },
  {
    "text": " I kind of want to maintain this. This is, of course,\neasy to maintain",
    "start": "3115190",
    "end": "3120980"
  },
  {
    "text": "by insertions and deletions. I just flip a bit on or off. But I want to be able\nto do successor queries. And if I want the\nsuccessor of, say, this 0,",
    "start": "3120980",
    "end": "3127850"
  },
  {
    "text": "finding the next 1-- I don't want to\nhave to walk down. That would take order\nu time-- very bad.",
    "start": "3127850",
    "end": "3132890"
  },
  {
    "text": "So obvious thing to do is\nbuild a tree on this thing. ",
    "start": "3132890",
    "end": "3140990"
  },
  {
    "text": "And I'm going to put in here\nthe or of the two children. Every node will store\nthe or of its children.",
    "start": "3140990",
    "end": "3147140"
  },
  {
    "text": " And then keep building the tree.",
    "start": "3147140",
    "end": "3152990"
  },
  {
    "start": "3152990",
    "end": "3164630"
  },
  {
    "text": "Now we have a binary tree,\nwith bits on the vertices. And I claim, if\nI want to compute",
    "start": "3164630",
    "end": "3171500"
  },
  {
    "text": "the successor of this\nitem, I can do it in a pretty natural way\nin the log log u time.",
    "start": "3171500",
    "end": "3178290"
  },
  {
    "text": "So keep in mind, this\nheight here is w--",
    "start": "3178290",
    "end": "3183850"
  },
  {
    "text": "log u.  So I need to achieve log w.",
    "start": "3183850",
    "end": "3189270"
  },
  {
    "text": "So of course, you could try\njust walking down this tree, or walking up and\nthen back down.",
    "start": "3189270",
    "end": "3194660"
  },
  {
    "text": "That would take order w time. That's the obvious BST approach. I want to do log w.",
    "start": "3194660",
    "end": "3201600"
  },
  {
    "text": "So how do I do it? I'm going to binary\nsearch on the height.",
    "start": "3201600",
    "end": "3207626"
  },
  {
    "text": "How could I binary\nsearch on the height? Well, what I'd really like\nto do, in some sense--",
    "start": "3207626",
    "end": "3213339"
  },
  {
    "text": "if I look at the path of\nthis node to the route-- where is my red chalk?",
    "start": "3213340",
    "end": "3220940"
  },
  {
    "text": "So here's the path to the root. ",
    "start": "3220940",
    "end": "3226839"
  },
  {
    "text": "These bits are saying, is\nthere anybody down here? That's what the or gives you.",
    "start": "3226840",
    "end": "3232870"
  },
  {
    "text": "So it's like the\nsummary structure. If I want to search for this\nguy-- well, if I walked up,",
    "start": "3232870",
    "end": "3239590"
  },
  {
    "text": "eventually, I find a 1. And that's when I find\nthe first nearby element. Now, in this case it's\nnot the successor I find.",
    "start": "3239590",
    "end": "3246220"
  },
  {
    "text": "It's really the\npredecessor I found. When you get to the first one--\nthe transition from 0 to 1--",
    "start": "3246220",
    "end": "3251320"
  },
  {
    "text": "you look at your sibling-- the other child of that one. And down in this subtree, there\nwill be either the predecessor",
    "start": "3251320",
    "end": "3259210"
  },
  {
    "text": "or the successor. In this case, we've\ngot the predecessor, because it was to the left. We take the max\nelement in there,",
    "start": "3259210",
    "end": "3265140"
  },
  {
    "text": "and that's the\npredecessor of this item. If instead, we had found\nthis was our first one, then we look over\nhere, take the min--",
    "start": "3265140",
    "end": "3270856"
  },
  {
    "text": "there's, of course,\nnothing here. But in that situation,\nthe min over there would be our successor.",
    "start": "3270856",
    "end": "3276670"
  },
  {
    "text": "So we can't guarantee\nwhich one we find. But we will find either the\npredecessor or the successor",
    "start": "3276670",
    "end": "3282130"
  },
  {
    "text": "if we could find the first\ntransition from 0 to 1. And we can do that\nvia binary search,",
    "start": "3282130",
    "end": "3287470"
  },
  {
    "text": "because this string is monotone. It's a whole bunch\nof zeros for awhile, and then once you\nget a 1, it's going",
    "start": "3287470",
    "end": "3292761"
  },
  {
    "text": "to continue to be 1,\nbecause those are or. That one will propagate up. ",
    "start": "3292761",
    "end": "3318089"
  },
  {
    "text": "So this is the new idea to\nget log log u, predecessor, successor is to--",
    "start": "3318090",
    "end": "3325376"
  },
  {
    "text": "let's say-- any root-to-leaf\npath is monotone.",
    "start": "3325376",
    "end": "3334555"
  },
  {
    "text": "It's 0 for awhile, and\nthen it becomes 1 forever. ",
    "start": "3334555",
    "end": "3340550"
  },
  {
    "text": "So we should be able to\nbinary search for the 0 to 1 transition.",
    "start": "3340550",
    "end": "3346235"
  },
  {
    "text": " And it either looks like\nthis, or it looks like this.",
    "start": "3346236",
    "end": "3357470"
  },
  {
    "text": "So our query was somewhere\ndown here in the 0 part.",
    "start": "3357470",
    "end": "3364744"
  },
  {
    "text": "I'm assuming that\nour query is not a 1. Otherwise, it's an\nimmediate 0 to 1 transition. And that's a special case.",
    "start": "3364745",
    "end": "3370410"
  },
  {
    "text": "It's easy to deal with. And then there's\nthe other tree--",
    "start": "3370410",
    "end": "3377190"
  },
  {
    "text": "the sibling of x-- the other child of the 1.",
    "start": "3377190",
    "end": "3382810"
  },
  {
    "text": "And in this case, we\nwant to take the min. And that will give us\nour successor of x.",
    "start": "3382810",
    "end": "3388240"
  },
  {
    "text": " And in this case, we want\nto take the max over here,",
    "start": "3388240",
    "end": "3394219"
  },
  {
    "text": "and that will give us\nthe predecessor of x. ",
    "start": "3394219",
    "end": "3401110"
  },
  {
    "text": "So as long as we have\nminimax of subtrees, this is constant time. We find either the\npredecessor or the successor.",
    "start": "3401110",
    "end": "3407480"
  },
  {
    "text": "Now, how do we\nget the other one? Pretty easy. Just store a linked list\nof all the items, in order.",
    "start": "3407480",
    "end": "3414140"
  },
  {
    "text": "So I'm going to store a pointer\nfrom this one to this one, and vice versa--",
    "start": "3414140",
    "end": "3419390"
  },
  {
    "text": "and this one or this one. This is actually really\neasy to maintain. Because when you insert,\nif you can compute",
    "start": "3419390",
    "end": "3427394"
  },
  {
    "text": "the predecessor\nand the successor, you can just stick it\nin the linked list. That's really easy. We know how to do\nthat in constant time.",
    "start": "3427394",
    "end": "3433260"
  },
  {
    "text": "So once you do this, it's\nenough to find one of them, as long as you know\nwhich one it is. Because then you just\nfollow a pointer--",
    "start": "3433260",
    "end": "3438830"
  },
  {
    "text": "either a forward or\na backward pointer-- and you get the other one. So whichever one you wanted-- you find both the\npredecessor and successor",
    "start": "3438830",
    "end": "3444350"
  },
  {
    "text": "at the cost of\nfinding either one. So that's a cute little trick.",
    "start": "3444350",
    "end": "3450170"
  },
  {
    "text": "This is hard to maintain,\ndynamically, at the moment. But this is, I think,\nwhere the Van Emde Boas",
    "start": "3450170",
    "end": "3457670"
  },
  {
    "text": "structure came from. It's nice to think about\nit in the tree view.",
    "start": "3457670",
    "end": "3462830"
  },
  {
    "text": "So we get log log you u,\npredecessor, and successor.",
    "start": "3462830",
    "end": "3471320"
  },
  {
    "text": " I should say what this relies on\nis the ability to binary search",
    "start": "3471320",
    "end": "3478040"
  },
  {
    "text": "on any route-to-node path. Now, there aren't enough\npointers to do that.",
    "start": "3478040",
    "end": "3483740"
  },
  {
    "text": "So you have a choice. Either you realize,\noh, this is a bunch of bits in a\ncomplete binary tree,",
    "start": "3483740",
    "end": "3489990"
  },
  {
    "text": "so I can store them\nsequentially in array. And given a particular node\nposition in that array,",
    "start": "3489990",
    "end": "3498050"
  },
  {
    "text": "I can compute, what is\nthe second ancestor, or the fourth ancestor or\nwhatever, in constant time.",
    "start": "3498050",
    "end": "3503970"
  },
  {
    "text": "I just do some arithmetic\nand I can compute from here where to go to there. It's like the regular old\nheaps, but a little bit",
    "start": "3503970",
    "end": "3509630"
  },
  {
    "text": "embellished, because\nyou have to divide by a larger power of two,\nnot just one of them. So that's one way to do it.",
    "start": "3509630",
    "end": "3516000"
  },
  {
    "text": "So in a RAM, that\nall works fine. When van Emde Boas wrote this\npaper, though, the RAM didn't--",
    "start": "3516000",
    "end": "3522145"
  },
  {
    "text": "it kind of existed. It just wasn't as\nwell-developed then. And the hot thing at the\ntime was the pointer machine,",
    "start": "3522145",
    "end": "3529520"
  },
  {
    "text": "or I guess at that point, they\ncalled it the Pascal machine, more or less. Pascal does have arrays.",
    "start": "3529520",
    "end": "3535280"
  },
  {
    "text": "And the funny thing is, Van\nEmde Boas does use arrays, but mostly it's pointers.",
    "start": "3535280",
    "end": "3541220"
  },
  {
    "text": "And you can get rid of the\narrays from their structure. And essentially, in\nthe end, Van Emde Boas,",
    "start": "3541220",
    "end": "3547040"
  },
  {
    "text": "as presented like this,\nis in a pointer machine. Let me tell you a\nlittle bit about that.",
    "start": "3547040",
    "end": "3552410"
  },
  {
    "text": " So original Van Emde Boas, which\nI'll call stratified trees--",
    "start": "3552410",
    "end": "3568040"
  },
  {
    "text": "that's what he called it-- is basically this tree structure\nwith a lot more pointers.",
    "start": "3568040",
    "end": "3575520"
  },
  {
    "text": "So in particular, each leaf-- or every node,\nactually, let's say--",
    "start": "3575520",
    "end": "3582000"
  },
  {
    "text": "stores a pointer to 2\nto the ith ancestor,",
    "start": "3582000",
    "end": "3594080"
  },
  {
    "text": "where i is 0, 1, up to log w.",
    "start": "3594080",
    "end": "3602123"
  },
  {
    "text": "Because it was the\n2 to the-- here. So once you get the\nancestor immediately",
    "start": "3602123",
    "end": "3608047"
  },
  {
    "text": "above me, two steps above\nme, four steps above me, eight steps above me,\nthat's what I really need to do this binary search.",
    "start": "3608047",
    "end": "3613700"
  },
  {
    "text": "The first thing I\nneed is halfway up. And then if I have\nto go down, I'm going to need a\nquarter of the way up.",
    "start": "3613700",
    "end": "3619310"
  },
  {
    "text": "And if I have to go down, I\nwant an eighth of the way up. Whenever I go up, from-- if\nI decide, oh, this is a 0.",
    "start": "3619310",
    "end": "3625110"
  },
  {
    "text": "I've got to go above here. Then I do the same\nthing from here. I want to go halfway\nup from here-- from this node.",
    "start": "3625110",
    "end": "3630830"
  },
  {
    "text": "So as long as every node knows\nhow to go up by any power of 2,",
    "start": "3630830",
    "end": "3636140"
  },
  {
    "text": "we're golden. We can do a binary search. The trouble with this\nis, it increases space.",
    "start": "3636140",
    "end": "3641270"
  },
  {
    "text": "This is u log w space, which\nis a little bit bigger than u.",
    "start": "3641270",
    "end": "3647560"
  },
  {
    "text": "And the original van Emde Boas\npaper, conference and journal version, achieves this bound-- not u.",
    "start": "3647560",
    "end": "3653210"
  },
  {
    "text": "Little historical fun fact-- not terribly well known.",
    "start": "3653210",
    "end": "3658250"
  },
  {
    "text": "Cool. So that's stratified trees. ",
    "start": "3658250",
    "end": "3665620"
  },
  {
    "text": "Anything else? All right. Stratified tree. Right.",
    "start": "3665620",
    "end": "3670730"
  },
  {
    "text": "At this point, we have fast\nsearch, but slow update let. Me tell you about\nupdates in a second. Yeah, question.",
    "start": "3670730",
    "end": "3676079"
  },
  {
    "text": "AUDIENCE: So once you do binary\nsearch to find the first 1, how do you walk\nback down the tree--",
    "start": "3676080",
    "end": "3682910"
  },
  {
    "text": "ERIK DEMAINE: Oh,\nI didn't mention, but also, every node\nstores min and max. ",
    "start": "3682910",
    "end": "3693500"
  },
  {
    "text": "So that lets me do the\nteleportation back down. Every node knows the min\nand the max of its subtree.",
    "start": "3693500",
    "end": "3699570"
  },
  {
    "text": "Right. One more thing I was\nforgetting here-- when I say, this a lot\nof pointers to store.",
    "start": "3699570",
    "end": "3704750"
  },
  {
    "text": "You can't store them\nall in one node. And in the van Emde Boas\npaper, it's stored in an array.",
    "start": "3704750",
    "end": "3710220"
  },
  {
    "text": "But it doesn't really\nneed that its an array. It could just as well\nbe a linked list. And that's how you\nget pointer machine.",
    "start": "3710220",
    "end": "3716600"
  },
  {
    "text": "So this could be linked list. And then this whole thing\nworks in pointer machine,",
    "start": "3716600",
    "end": "3721610"
  },
  {
    "text": "which is kind of neat. And it's a little weird,\nbecause if you used a comparison",
    "start": "3721610",
    "end": "3727479"
  },
  {
    "text": "pointer machine, where all\nyou can do is compare items, there's a lower bound of\nlog n, because you only have branching factor constant.",
    "start": "3727479",
    "end": "3734780"
  },
  {
    "text": "But here, the formulation of\nthe problem is, when I say, give me the successor\nof this, I actually",
    "start": "3734780",
    "end": "3740480"
  },
  {
    "text": "give you a pointer to this item. And then from there, you can\ndo all this jumping around,",
    "start": "3740480",
    "end": "3746300"
  },
  {
    "text": "and find your\npredecessor or successor. So in this world, you\nneed at least u space, even to be able to\nspecify the input.",
    "start": "3746300",
    "end": "3752555"
  },
  {
    "text": " So that's kind of a limitation\nof the pointer machine.",
    "start": "3752555",
    "end": "3757750"
  },
  {
    "text": "And you can actually show\nin the pointer machine log, log u is optimal for any\npredecessor data structure",
    "start": "3757750",
    "end": "3766070"
  },
  {
    "text": "in the pointer machine. So there's a matching lower\nbound log log u in this model.",
    "start": "3766070",
    "end": "3773567"
  },
  {
    "text": "And you need to use space. So it's not very exciting. What we like is the word RAM. There, we can reduce space to n.",
    "start": "3773567",
    "end": "3780070"
  },
  {
    "text": "And that's what I want\nto do next, I believe-- almost next. One more mention--\nactual stratified trees--",
    "start": "3780070",
    "end": "3788380"
  },
  {
    "text": "here, we got query\nfast, update slow. Stratified trees actually\ndo update fast, as well.",
    "start": "3788380",
    "end": "3793990"
  },
  {
    "text": "Essentially, it's this idea,\nplus you don't recursively store the min, which,\nof course, makes",
    "start": "3793990",
    "end": "3800290"
  },
  {
    "text": "all these bits no\nlonger accurate, as it gets much messier. But in the end, it's doing\nexactly the same thing",
    "start": "3800290",
    "end": "3806800"
  },
  {
    "text": "as this recursion. In fact, you can\ndraw the picture. It is this part up here--",
    "start": "3806800",
    "end": "3815870"
  },
  {
    "text": "the top half of the tree-- this is summary. ",
    "start": "3815870",
    "end": "3821109"
  },
  {
    "text": "And each of these bottom\nhalves is a cluster.",
    "start": "3821110",
    "end": "3826408"
  },
  {
    "text": "And there's root u\nclusters down here.",
    "start": "3826408",
    "end": "3831820"
  },
  {
    "text": "So those are smaller structures. And there's one root u sized\nVan Emde Boas structure, which",
    "start": "3831820",
    "end": "3837610"
  },
  {
    "text": "is a summary structure. These bits here is the\nbit vector representation",
    "start": "3837610",
    "end": "3842617"
  },
  {
    "text": "of the summary structures. It's, is there anyone\nin this cluster? Is there anyone in this\ncluster, and so on?",
    "start": "3842617",
    "end": "3848597"
  },
  {
    "text": "This, of course, also looks\na lot like the Van Emde Boas layout. Take a binary tree, cut\nit in half, do the top,",
    "start": "3848597",
    "end": "3854137"
  },
  {
    "text": "recursively do the bottom. So that's why it was called\nthe Van Emde Boas layout, is this picture. But if you take\nthis tree structure,",
    "start": "3854137",
    "end": "3860290"
  },
  {
    "text": "and then you don't\nrecursively store mins, and then the bits are not\nquite accurate, it's messy. And so stratified\ntrees-- you should",
    "start": "3860290",
    "end": "3866768"
  },
  {
    "text": "try to read the original paper. It's a mess. Whereas this code--\npretty clean. And so once you\nsay, oh, I'm just",
    "start": "3866769",
    "end": "3873279"
  },
  {
    "text": "going to store all these\nclusters as an array and not worry about\nkeeping track of the tree, it actually gets a lot easier.",
    "start": "3873280",
    "end": "3879620"
  },
  {
    "text": "And that was the\nBender/Farach-Colton cleaning up, which never\nappeared in print.",
    "start": "3879620",
    "end": "3884920"
  },
  {
    "text": "But it's appeared in the lecture\nnotes all over the place-- and now CLRS.",
    "start": "3884920",
    "end": "3890700"
  },
  {
    "text": "Cool. I want to tell you\nabout two more things. It's actually\ngoing to get easier the more time we spend\nwith this data structure.",
    "start": "3890700",
    "end": "3897989"
  },
  {
    "start": "3897989",
    "end": "3921970"
  },
  {
    "text": "All right. Let me draw a box.",
    "start": "3921970",
    "end": "3927970"
  },
  {
    "text": "At this point, we've seen a\nclean way to get Van Emde Boas. And we've seen a\ncute way in a tree",
    "start": "3927970",
    "end": "3934569"
  },
  {
    "text": "to get search fast,\nbut update slow. I want to talk a\nlittle more about that. Let's suppose I have\nthis data structure.",
    "start": "3934570",
    "end": "3941200"
  },
  {
    "text": "It's achieves log w\nquery, which is fast, but it only achieves w\nupdate, which is slow.",
    "start": "3941200",
    "end": "3950590"
  },
  {
    "text": "How do you update the structure? You update one\nbit at the bottom, and then you've got to update\nall the bits up the path.",
    "start": "3950590",
    "end": "3956980"
  },
  {
    "text": "So you spend w time to\ndo an update over here. ",
    "start": "3956980",
    "end": "3962410"
  },
  {
    "text": "If updates are slow, I just\nwant to do less updates. We have a trick for\ndoing this, which",
    "start": "3962410",
    "end": "3967569"
  },
  {
    "text": "is, you put little things\ndown here of size theta w. ",
    "start": "3967570",
    "end": "3976809"
  },
  {
    "text": "And then only one item\nfrom here gets promoted into the top structure. We only end up having n over\nw items up here, and about 1",
    "start": "3976810",
    "end": "3986860"
  },
  {
    "text": "over w as many updates. If I want to do an\ninsertion, I do a search here",
    "start": "3986860",
    "end": "3991930"
  },
  {
    "text": "to figure out which\nof these little-- I'll call these \"chunks--\" which\nlittle chunk it belongs in.",
    "start": "3991930",
    "end": "3999369"
  },
  {
    "text": "I do an insert there. If that structure\ngets too big-- it's bigger than, say, 2\ntimes w, or 4 times w,",
    "start": "3999370",
    "end": "4005730"
  },
  {
    "text": "whatever-- then I'll split it. And if I delete from something,\nand it gets too small,",
    "start": "4005730",
    "end": "4010765"
  },
  {
    "text": "I'll merge with the\nneighbor, or maybe re-split-- just like B-trees. We've done this\nmany times, by now.",
    "start": "4010765",
    "end": "4018820"
  },
  {
    "text": "But only when it\nsplits, or I do a merge, do I have to do\nan update up here. Only when the set\nof chunks changes do",
    "start": "4018820",
    "end": "4025540"
  },
  {
    "text": "I need to do a single\ninsertion or deletion up here-- or a constant number. So this update time goes\ndown by a factor of w.",
    "start": "4025540",
    "end": "4035860"
  },
  {
    "text": "But I have to pay whatever\nthe update cost is here. So what I do with\nthis data structure? I don't want use Van\nEmde Boas, because this",
    "start": "4035860",
    "end": "4041529"
  },
  {
    "text": "could be a very big universe. Who knows what? I use the binary search tree. Here, I can afford a\nbinary search tree,",
    "start": "4041530",
    "end": "4048250"
  },
  {
    "text": "because then it's only log w. log w is the bound\nwe're trying to get. So you can do these\nbinary search trees.",
    "start": "4048250",
    "end": "4054580"
  },
  {
    "text": "It's trivial. Just do insert, delete, search. Everything will be log w.",
    "start": "4054580",
    "end": "4059994"
  },
  {
    "text": "So if I want to do a search,\nI search through here, which, conveniently, is\nalready fast-- log w-- and then I do a search through\nhere, which is also log w.",
    "start": "4059994",
    "end": "4066850"
  },
  {
    "text": "So it's nice and balanced. Everything's log w.  If I want to do an insertion,\nI do an insertion here.",
    "start": "4066850",
    "end": "4073840"
  },
  {
    "text": "If it splits, I do\nan insertion here. But that order w update\ncost, I charge to the order",
    "start": "4073840",
    "end": "4080470"
  },
  {
    "text": "w updates I would have\nhad to do in this chunk before it got split. So this our good friend\nindirection, a technique we",
    "start": "4080470",
    "end": "4088060"
  },
  {
    "text": "will use over and\nover in this class. It's very helpful when you're\nalmost at the right bound.",
    "start": "4088060",
    "end": "4094450"
  },
  {
    "text": "And that's actually in the\nfollow-up van Emde Boas paper. A similar indirection\ntrick is in there.",
    "start": "4094450",
    "end": "4100520"
  },
  {
    "text": "So we can charge the\norder w update in top to--",
    "start": "4100520",
    "end": "4111370"
  },
  {
    "text": "that's the cost of the update-- to the order w updates\nthat have actually",
    "start": "4111370",
    "end": "4118180"
  },
  {
    "text": "been performed in the bottom. Because when\nsomebody gets split,",
    "start": "4118180",
    "end": "4124600"
  },
  {
    "text": "it's nice in its average\nstate-- or when it gets merged, it's going to be close\nto its average state. You have to do a lot of\ninsertions or deletions",
    "start": "4124600",
    "end": "4130598"
  },
  {
    "text": "to get it out of whack, and\ncause a split or a merge. So-- boom.",
    "start": "4130598",
    "end": "4136000"
  },
  {
    "text": "This means the\nupdates become log w.",
    "start": "4136000",
    "end": "4141700"
  },
  {
    "text": "Searches are also log w. So we've got Van Emde\nBoas again, in a new way.",
    "start": "4141700",
    "end": "4147549"
  },
  {
    "text": "Bonus points-- if you\ntake this structure-- ",
    "start": "4147550",
    "end": "4154330"
  },
  {
    "text": "even this structure, if we\ndid it in the array form-- great. It was order u space. If we did it with\nall these pointers,",
    "start": "4154330",
    "end": "4160750"
  },
  {
    "text": "and we wanted a pointer\nmachine data structure, we needed u log w space. But this indirection trick, you\ncan also get rid of the log w",
    "start": "4160750",
    "end": "4168130"
  },
  {
    "text": "in space factor. It's a little less obvious. But you take this-- here, we reduced n\nby a factor of w.",
    "start": "4168130",
    "end": "4174859"
  },
  {
    "text": "You can also reduce\nu by a factor of w. I'll just wave my hands. That's possible. So u gets a little bit smaller.",
    "start": "4174859",
    "end": "4181509"
  },
  {
    "text": "And so when we\npay u log w space, if you got smaller\nby a factor of w, this basically disappears.",
    "start": "4181510",
    "end": "4188689"
  },
  {
    "text": "So you get, at\nmost, order u space.  But order u is not order n.",
    "start": "4188689",
    "end": "4194390"
  },
  {
    "text": "I want order n space, darn it. So let's reduce space.",
    "start": "4194390",
    "end": "4201400"
  },
  {
    "text": "As I said, this is going\nto get easier and easier. By the end, we will have very\nlittle of a data structure. But still, we'll have log log u.",
    "start": "4201400",
    "end": "4210150"
  },
  {
    "text": "And you thought this was\neasy, but wait, there's more. ",
    "start": "4210150",
    "end": "4216679"
  },
  {
    "text": "Right now, we have two\nways to get log log u-- query and order u space.",
    "start": "4216680",
    "end": "4222950"
  },
  {
    "text": "There's the one I'm\nerasing, and there's this-- take this tree structure\nwith the very simple pointers.",
    "start": "4222950",
    "end": "4228410"
  },
  {
    "text": "Add indirection. So admittedly, it's more\ncomplicated to implement. But conceptually,\nit's super simple.",
    "start": "4228410",
    "end": "4233526"
  },
  {
    "text": "It's like, do this\nobvious tree binary search on the level thing. And then add indirection,\nand it fixes all your bounds,",
    "start": "4233526",
    "end": "4240080"
  },
  {
    "text": "magically. So conceptually, very simple-- practically, you definitely\nwant to do this-- much simpler.",
    "start": "4240080",
    "end": "4247850"
  },
  {
    "text": "Now, what about saving space? ",
    "start": "4247850",
    "end": "4254420"
  },
  {
    "text": "Very simple idea--\nwhich, I think, again, comes from Michael\nBender and Martin Farach-Colton.",
    "start": "4254420",
    "end": "4261560"
  },
  {
    "text": "Don't store empty structures. So in this picture, we had\nan array of all the clusters.",
    "start": "4261560",
    "end": "4269620"
  },
  {
    "text": "But a cluster could be\nentirely empty, like this one-- this entirely empty cluster.",
    "start": "4269620",
    "end": "4275470"
  },
  {
    "text": "Don't store it. It's a waste. If you store them all, you're\ngoing to spend order u space.",
    "start": "4275470",
    "end": "4280710"
  },
  {
    "text": "If you don't store them all-- just don't store\nthe empty ones-- I claim your order n space. Done.",
    "start": "4280710",
    "end": "4287910"
  },
  {
    "text": "So I'm going back to\nthe structure I erased. Ignore the tree\nperspective for awhile.",
    "start": "4287910",
    "end": "4293110"
  },
  {
    "text": "Don't store empty clusters.",
    "start": "4293110",
    "end": "4299440"
  },
  {
    "text": "OK, now, this sounds easy. But in reality, it's a\nlittle bit more annoying. Because we wanted to have\nan array of clusters.",
    "start": "4299440",
    "end": "4307639"
  },
  {
    "text": "So we could quickly\nfind the cluster. If you store an\narray, you're going",
    "start": "4307640",
    "end": "4312809"
  },
  {
    "text": "to spend at least\nsquare rot of u space. Because at the very\nbeginning, you say, here are my root u clusters.",
    "start": "4312810",
    "end": "4318040"
  },
  {
    "text": "Now, some of them\nmight be null pointers. But I can't afford to store\nthat entire array of clusters.",
    "start": "4318040",
    "end": "4323980"
  },
  {
    "text": "So don't use an array. Use a perfect hash table. ",
    "start": "4323980",
    "end": "4330730"
  },
  {
    "text": "So v dot cluster, instead\nof being an array, is now, let's say, a\ndynamic perfect hashing.",
    "start": "4330730",
    "end": "4338650"
  },
  {
    "text": "And I'm going to use the\nversion which I did not present. The version I presented,\nwhich used universal hashing,",
    "start": "4338650",
    "end": "4343750"
  },
  {
    "text": "was order 1 expected. But I said that it can be\nconstant with high probability",
    "start": "4343750",
    "end": "4350410"
  },
  {
    "text": "per operation. It's a little bit stronger. So now, everything's fine.",
    "start": "4350410",
    "end": "4355540"
  },
  {
    "text": "If I do an index\nv dot cluster c, that's still constant time,\nwith high probability now.",
    "start": "4355540",
    "end": "4361120"
  },
  {
    "text": "And I claim this structure\nis now order n's space. Why is it order n's space?",
    "start": "4361120",
    "end": "4367540"
  },
  {
    "text": "By simple amortization--\ncharge each table entry in that",
    "start": "4367540",
    "end": "4376510"
  },
  {
    "text": "hash table to the\nmin of the cluster. ",
    "start": "4376510",
    "end": "4386924"
  },
  {
    "text": "We're only storing\nnon-empty ones. So if one of these guys\nexists in the hash table, we had to store a\npointer to it, then",
    "start": "4386924",
    "end": "4393670"
  },
  {
    "text": "that means the summary\nstructure is non-zero. It means this guy is not empty. So it has an item in its min.",
    "start": "4393670",
    "end": "4399810"
  },
  {
    "text": "Charge the space up here to\nstore the pointer to that min guy. Then each item-- each min item--",
    "start": "4399810",
    "end": "4407200"
  },
  {
    "text": "only gets charged once. Because it only has one parent\nthat has a pointer to it.",
    "start": "4407200",
    "end": "4412380"
  },
  {
    "text": "So you only charge once. And therefore-- charge\nand table entry--",
    "start": "4412380",
    "end": "4418290"
  },
  {
    "text": " only charge each element once.",
    "start": "4418290",
    "end": "4425050"
  },
  {
    "text": " And that's all your space.",
    "start": "4425050",
    "end": "4430909"
  },
  {
    "text": "So it's order n space. Done.",
    "start": "4430910",
    "end": "4436250"
  },
  {
    "text": "Kind of crazy. I guess, if you want, there's\nalso the pointer to the summary structure. You could charge\nthat to your own min.",
    "start": "4436250",
    "end": "4442290"
  },
  {
    "text": "And then you're charging twice. But it's constant per item. So this is kind of funny.",
    "start": "4442290",
    "end": "4448517"
  },
  {
    "text": "Again, it doesn't appear in\nprint anywhere, except maybe as an exercise in CLRS now. But you get linear\norder n space,",
    "start": "4448517",
    "end": "4456760"
  },
  {
    "text": "just by adding hashing\nin the obvious way. Now, for whatever reason,\nWillard didn't see this,",
    "start": "4456760",
    "end": "4463180"
  },
  {
    "text": "or wanted to do his\nown thing, and so he found another way to do\norder n space log log u query",
    "start": "4463180",
    "end": "4470409"
  },
  {
    "text": "with hashing.  Well, I guess, also,\nyou had to think",
    "start": "4470409",
    "end": "4475570"
  },
  {
    "text": "of it in this simple form. It's harder to do\nthis in the tree. It can be done, I think. But this is a simpler view\nthan the tree, I think.",
    "start": "4475570",
    "end": "4482530"
  },
  {
    "text": "And then boom-- order n space. But it turns out there's\nanother way to do it.",
    "start": "4482530",
    "end": "4488139"
  },
  {
    "text": "This is a completely\ndifferent way to do Van Emde Boas-- actually,\nnot that completely different. It's another way to\ndo this with hashing.",
    "start": "4488140",
    "end": "4498613"
  },
  {
    "text": " And we're going to start with\nwhat's called x-fast trees,",
    "start": "4498613",
    "end": "4506140"
  },
  {
    "text": "and then we will modify\nit to get y-fast trees. That's Willard's terminology.",
    "start": "4506140",
    "end": "4511882"
  },
  {
    "text": "OK, so x-fast trees\nis, store this tree, but don't store the zeros.",
    "start": "4511882",
    "end": "4518060"
  },
  {
    "text": "So don't store zeros. Only store the ones in the-- we\ncall this the simple tree view.",
    "start": "4518060",
    "end": "4527530"
  },
  {
    "text": "This is why I, in\nparticular, wanted to tell you about\nthe simple tree view, because it is really\nwhat x fast trees do.",
    "start": "4527530",
    "end": "4533320"
  },
  {
    "text": "So what do I mean by\nonly store the ones? Well, each of these\nones has sort of a name.",
    "start": "4533320",
    "end": "4541280"
  },
  {
    "text": "What is the name of this item? Its name is one-- or in other words, 0, 0, 0, 1. Each of these nodes,\nyou can think of,",
    "start": "4541280",
    "end": "4547810"
  },
  {
    "text": "what is the path to get here? Like, the path to get\nto this one is 1, 0, 0. 1 means right.",
    "start": "4547810",
    "end": "4553450"
  },
  {
    "text": "0 means left. Those names give you\nthe binary indicator of where that node is in\nthe tree, in some sense.",
    "start": "4553450",
    "end": "4560860"
  },
  {
    "text": "So store the ones as binary\nstrings in a hash table--",
    "start": "4560860",
    "end": "4573316"
  },
  {
    "text": " again, a dynamic\nperfect hash table.",
    "start": "4573316",
    "end": "4579269"
  },
  {
    "text": "Let's say I can get constant\nwith high probability. OK. And if you're a\nlittle concerned--",
    "start": "4579270",
    "end": "4586280"
  },
  {
    "text": "so what this means--\nthe ones are exactly the prefixes of the paths\nto each of the items.",
    "start": "4586280",
    "end": "4592050"
  },
  {
    "text": "This was item one. And so I want to store this\none, which is empty string,",
    "start": "4592050",
    "end": "4597420"
  },
  {
    "text": "this one, which is 0, this\none, which is 00, this one, which is 000, this\none, which is 0001.",
    "start": "4597420",
    "end": "4604060"
  },
  {
    "text": "So I take 0001, which is\nthe item I want to store.",
    "start": "4604060",
    "end": "4609600"
  },
  {
    "text": "And there's all\nthese prefixes, which are the items I want to store. And for this really\nto make sense,",
    "start": "4609600",
    "end": "4616290"
  },
  {
    "text": "you also need the\nlength of the string. Strings of different lengths\nshould be in different worlds.",
    "start": "4616290",
    "end": "4621810"
  },
  {
    "text": "So the way, actually,\nx-fast trees originally did it in the paper is,\nhave a different hash table for strings of\ndifferent lengths.",
    "start": "4621810",
    "end": "4627124"
  },
  {
    "text": "So that's probably an easier\nway to think about it. You store all the items\nthemselves in a hash table. You store all the\nprefixes of all",
    "start": "4627124",
    "end": "4633330"
  },
  {
    "text": "but the last bit in a\nseparate hash table, all but the last two bits in a\nseparate hash table, and so on.",
    "start": "4633330",
    "end": "4640120"
  },
  {
    "text": "Now, what does this let you do? It lets you do this-- binary search for the\n0 to 1 transition.",
    "start": "4640120",
    "end": "4648162"
  },
  {
    "text": " What we did here was-- I look at the bit, is it 0 or 1?",
    "start": "4648162",
    "end": "4655469"
  },
  {
    "text": "Instead of doing that, you do\na query into the hash table, and say, is it in\nthe hash table? It's in the hash table\nif and only if it is one.",
    "start": "4655470",
    "end": "4662900"
  },
  {
    "text": "So looking at a bit in\nthis conceptual tree is the same thing as\nchecking for containment in this hash table.",
    "start": "4662900",
    "end": "4668760"
  },
  {
    "text": "But now, we don't have to\nstore the zeros, which is cool. ",
    "start": "4668760",
    "end": "4675929"
  },
  {
    "text": "We can now do search,\npredecessor or successor, fast,",
    "start": "4675930",
    "end": "4684600"
  },
  {
    "text": "in log w time, via\nthis old thing.",
    "start": "4684600",
    "end": "4691650"
  },
  {
    "text": "Again, you have to have min\nand max pointers, as well. So in this hash table,\nyou store the min",
    "start": "4691650",
    "end": "4697039"
  },
  {
    "text": "and the max of your subtree.  Or actually, from\na 1, you actually",
    "start": "4697039",
    "end": "4702960"
  },
  {
    "text": "need the max of\nthe left subtree, and you need the min\nof the right subtree. But it's a constant amount\nof information per thing.",
    "start": "4702960",
    "end": "4710190"
  },
  {
    "text": "This is not perfect, however,\nin that it uses nw space.",
    "start": "4710190",
    "end": "4716190"
  },
  {
    "text": " And also, updates are slow. It's order w updates.",
    "start": "4716190",
    "end": "4722775"
  },
  {
    "start": "4722775",
    "end": "4741540"
  },
  {
    "text": "But we're almost there. Because we have fast\nqueries, slow updates, not optimal space.",
    "start": "4741540",
    "end": "4747990"
  },
  {
    "text": "Take this. Add indirection-- done. And that's y-fast trees. ",
    "start": "4747990",
    "end": "4757950"
  },
  {
    "text": "y-fast trees-- you\ntake x-fast trees, you add this\nindirection right here,",
    "start": "4757950",
    "end": "4765470"
  },
  {
    "text": "and you get log w per\noperation order and space.",
    "start": "4765470",
    "end": "4773266"
  },
  {
    "text": "Of course, this is\na high probability because we're using hashing. Because we have a\nfactor w bad here,",
    "start": "4773266",
    "end": "4780290"
  },
  {
    "text": "we have factor w bad here. You divide by w. You're done. Up here, you have n over w\nspace. n over w times w is n.",
    "start": "4780290",
    "end": "4788360"
  },
  {
    "text": "Queries, just like\nbefore, remain log w. But now-- boom-- updates, we pay log w\nbecause of the binary search",
    "start": "4788360",
    "end": "4796160"
  },
  {
    "text": "trees at the bottom,\nbut pretty cool. Isn't that neat? I've never seen this before.",
    "start": "4796160",
    "end": "4802190"
  },
  {
    "text": "OK, I've seen x-fast\ntrees and y-fast trees. But it's really just the same-- we're taking Van Emde Boas,\nlooking at it in the tree view.",
    "start": "4802190",
    "end": "4809989"
  },
  {
    "text": "You can see where\nWillard got this stuff. It's like, oh, man I really\nwant to store all these bits, but hey, it's way too big.",
    "start": "4809990",
    "end": "4815300"
  },
  {
    "text": "Just don't store the zeros. That means we should\nuse a hash table. Ah , hash table just gives you\nwhether the bit is in or out.",
    "start": "4815300",
    "end": "4822769"
  },
  {
    "text": "Great. Now use indirection. And indirection was\nalready floating around as a concept at the time--",
    "start": "4822770",
    "end": "4829220"
  },
  {
    "text": "slightly different parameters. Van Emde Boas had\nhis own indirection to reduce the space\nfrom u times log w to u.",
    "start": "4829220",
    "end": "4838187"
  },
  {
    "text": "But Willard did it,\nand-- boom-- it got down to n space in this way. But as you saw, you can also do\nit directly to Van Emde Boas.",
    "start": "4838187",
    "end": "4845700"
  },
  {
    "text": "All these ideas can\nbe interchanged. You can combine\nany data structure you want with any\nspace saving trick you want, with\nindirection, if you",
    "start": "4845700",
    "end": "4851810"
  },
  {
    "text": "need to, to speed things up\nand reduce space a little bit. So there's many,\nmany ways to do this.",
    "start": "4851810",
    "end": "4857190"
  },
  {
    "text": "But in the end, you get\nlog w per operation, and order n space. And that sort of result one. And it's probably the most\nuseful predecessor data",
    "start": "4857190",
    "end": "4864530"
  },
  {
    "text": "structure, in general. But next time, we'll\nsee fusion trees, which are good for when w is huge.",
    "start": "4864530",
    "end": "4870730"
  },
  {
    "start": "4870730",
    "end": "4874192"
  }
]