[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high-quality\neducational resources for free. To make a donation, or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT\ncourses, visit MIT OpenCourseWare at ocw.mit.edu,",
    "start": "13320",
    "end": "21280"
  },
  {
    "text": "ERIK DEMAINE: Today we continue\nour theme of dynamic graphs. This is the second\nof three lectures.",
    "start": "21280",
    "end": "26410"
  },
  {
    "text": "And this will be the main\nlecture about upper bounds for general graphs.",
    "start": "26410",
    "end": "32890"
  },
  {
    "text": "Last class was about\nlink cut trees. And we saw, essentially,\nhow to solve a problem called dynamic\nconnectivity, which",
    "start": "32890",
    "end": "40655"
  },
  {
    "text": "is where you can\ninsert into lead edges and you want to know\nwhat's connected to what. For trees, we solved it.",
    "start": "40655",
    "end": "46990"
  },
  {
    "text": "We're going to solve it again\nfor trees in an easier way. Because we need a slightly\nsimpler data structure we can augment in different\nways, called Euler-tour trees.",
    "start": "46990",
    "end": "56260"
  },
  {
    "text": "And then we'll solve\ntrees, yet again, in a setting where you\ncan only delete edges.",
    "start": "56260",
    "end": "61899"
  },
  {
    "text": "Then we can get from log\nn time to constant time. So we'll still talk about\ntrees for quite awhile.",
    "start": "61900",
    "end": "68560"
  },
  {
    "text": "But then we'll finally\nget to general graphs. And we'll do a log squared n\nsolution for general graphs.",
    "start": "68560",
    "end": "74570"
  },
  {
    "text": "So just another log\nfactor more, you can generalize from trees\nto undirected graphs.",
    "start": "74570",
    "end": "81484"
  },
  {
    "text": "And then I'll give you a\nflavor of what's out there. Dynamic graphs is a big world. It has lots of results.",
    "start": "81484",
    "end": "87299"
  },
  {
    "text": "And I'll give you some idea\nof what other problems have been studied in dynamic graphs,\nboth undirected and directed.",
    "start": "87299",
    "end": "92770"
  },
  {
    "text": "Though for directed graphs,\nthings get pretty slow.  Yeah, next class will be\nabout lower bounds, which",
    "start": "92770",
    "end": "99640"
  },
  {
    "text": "will prove that this log\nstuff is actually necessary,",
    "start": "99640",
    "end": "104830"
  },
  {
    "text": "in case you were wondering. Because a lot of\nthe time, we've been able to get better\nthan log in this class. And dynamic graphs, you can't.",
    "start": "104830",
    "end": "111040"
  },
  {
    "text": "They're log lower bounds. So let's start out with a\ndefinition of the problem.",
    "start": "111040",
    "end": "117280"
  },
  {
    "text": "We'll be focusing, today, mostly\non this dynamic connectivity problem. ",
    "start": "117280",
    "end": "128139"
  },
  {
    "text": "Maintain an undirected\ngraph subject to [INAUDIBLE]",
    "start": "128139",
    "end": "139012"
  },
  {
    "text": "insertion and deletion. ",
    "start": "139012",
    "end": "147090"
  },
  {
    "text": "And you can also insert and\ndelete degree-0 vertices. ",
    "start": "147090",
    "end": "153170"
  },
  {
    "text": "But we're not really going\nto worry about vertices. It's easy to add vertices\nthat have no edges to them. Also easy to delete them.",
    "start": "153170",
    "end": "159525"
  },
  {
    "text": "It'll be more about adding\nand removing edges incident to those vertices.",
    "start": "159525",
    "end": "165020"
  },
  {
    "text": "And then the query connectivity\nquery is given two vertices.",
    "start": "165020",
    "end": "173195"
  },
  {
    "text": " Is there a v to w path?",
    "start": "173195",
    "end": "179420"
  },
  {
    "text": " So this is asking are\ntwo vertices, v and w, in the same connected component?",
    "start": "179420",
    "end": "187310"
  },
  {
    "text": "That's a strong query. In some sense, a weaker query\nis just to know globally,",
    "start": "187310",
    "end": "192800"
  },
  {
    "text": "is the graph connected? That's another interpretation\nof dynamic connectivity.",
    "start": "192800",
    "end": "198260"
  },
  {
    "text": "It turns out, both\nof these problems are interesting and useful\nfor solving problems.",
    "start": "198260",
    "end": "205059"
  },
  {
    "text": "But they also turn out to\nbe, more or less, equivalent. All the upper bounds\nwe know for one apply to the other\nand vice versa.",
    "start": "205059",
    "end": "210510"
  },
  {
    "text": "So it doesn't seem to make much\ndifference which kind of query you want. So might as well take both.",
    "start": "210510",
    "end": "215790"
  },
  {
    "text": "We'll focus on the v, w query. OK.",
    "start": "215790",
    "end": "221690"
  },
  {
    "text": "So that's the\nproblem, in general. And I want to introduce\nsome terminology,",
    "start": "221690",
    "end": "229489"
  },
  {
    "text": "like when we had partially\nand full persistence, there's also a partial\nand full dynamicness.",
    "start": "229490",
    "end": "237530"
  },
  {
    "text": "A fully dynamic\ndata structure is one where you can do inserts\nand deletes of edges.",
    "start": "237530",
    "end": "245190"
  },
  {
    "text": " And a partially\ndynamic data structure",
    "start": "245190",
    "end": "255472"
  },
  {
    "text": "is one where you can\ndo inserts or deletes.  So you can only do\ninserts, or you can only",
    "start": "255473",
    "end": "265650"
  },
  {
    "text": "do deletes throughout the\nlifetime of the data structure. And these have specific names.",
    "start": "265650",
    "end": "271350"
  },
  {
    "text": "Because usually you use\ndifferent data structures for just insertions\nor just deletions. Just insertions is\ncalled incremental.",
    "start": "271350",
    "end": "276972"
  },
  {
    "start": "276972",
    "end": "283539"
  },
  {
    "text": "And just deletions is\ncalled decremental. ",
    "start": "283540",
    "end": "289957"
  },
  {
    "text": "The idea of\nincremental algorithms is definitely not a new one. But in dynamic graphs,\nit always makes sense.",
    "start": "289957",
    "end": "297009"
  },
  {
    "text": "So in general, a\ndynamic graph problem is defined usually by insertion\nand deletion of edges,",
    "start": "297010",
    "end": "302320"
  },
  {
    "text": "and either fully dynamic\nor partially dynamic. And then the query\nis what can vary. We're going to focus on\nconnectivity queries.",
    "start": "302320",
    "end": "309020"
  },
  {
    "text": "But you could do others. So this explains, for\ndecremental, we're going to solve trees\nin constant time.",
    "start": "309020",
    "end": "315370"
  },
  {
    "text": "For fully dynamic, we're\ngoing to solve general graphs in log squared n time. ",
    "start": "315370",
    "end": "326220"
  },
  {
    "text": "I guess these three are sort\nof the meat of the lecture. But before I go\ninto that, I want",
    "start": "326220",
    "end": "331470"
  },
  {
    "text": "to tell you where this dynamic\nconnectivity results fit into the literature in general\non dynamic connectivity.",
    "start": "331470",
    "end": "339158"
  },
  {
    "start": "339158",
    "end": "345509"
  },
  {
    "text": "This is part of our survey, but\njust on dynamic connectivity. ",
    "start": "345510",
    "end": "359780"
  },
  {
    "text": "Well, for trees, this\nis the best we know. This is the best,\npossible really.",
    "start": "359780",
    "end": "365680"
  },
  {
    "text": "You can do log n in general,\nand then decremental. ",
    "start": "365680",
    "end": "374990"
  },
  {
    "text": "You can do constant. We actually already know how to\ndo trees with lint cut trees.",
    "start": "374990",
    "end": "380199"
  },
  {
    "text": "It's not totally obvious,\nbut you can use links to simulate edge insertions.",
    "start": "380200",
    "end": "387010"
  },
  {
    "text": "And you can use cuts to\nsimulate edge deletions. It's not totally obvious\nbecause the link operation",
    "start": "387010",
    "end": "393675"
  },
  {
    "text": "requires that one\nof the vertices is the root of its tree. So that's not so trivial.",
    "start": "393675",
    "end": "400030"
  },
  {
    "text": "But we'll see an easy way to\ndo that in Euler-tour trees later on.",
    "start": "400030",
    "end": "405610"
  },
  {
    "text": "So this we kind of\nalready know how to do. But we're going to see\nanother simpler way. The constant time\namortized decremental",
    "start": "405610",
    "end": "412930"
  },
  {
    "text": "we're going to do today. So we're also going\nto do this today.",
    "start": "412930",
    "end": "419590"
  },
  {
    "text": "Incremental, I don't think it's\nknown, how to do constant time.",
    "start": "419590",
    "end": "424725"
  },
  {
    "text": "But I'll tell you\nanother result. You can get almost\nconstant time. ",
    "start": "424726",
    "end": "430310"
  },
  {
    "text": "Another special type of\ngraph you could consider is a plane graph. This is a graph with\nplanar embedding.",
    "start": "430310",
    "end": "435670"
  },
  {
    "text": "So as you're inserting edges\nor adding vertices and whatnot, you say which face they live in. And so you have a\nfixed planar embedding.",
    "start": "435670",
    "end": "442120"
  },
  {
    "text": "It's being constructed\nas you go along. These are easy to maintain. You can get order log n.",
    "start": "442120",
    "end": "448082"
  },
  {
    "text": "I guess, in some sense,\nthat generalizes trees. Because they also have pretty\nobvious planar embedding.",
    "start": "448082",
    "end": "453820"
  },
  {
    "text": "So that's something\nyou can do, in log n.",
    "start": "453820",
    "end": "460750"
  },
  {
    "text": "But the big question\nis, for general graphs,",
    "start": "460750",
    "end": "467920"
  },
  {
    "text": "can you do log n per operation? That's an open problem, probably\nthe central open problem",
    "start": "467920",
    "end": "475099"
  },
  {
    "text": "in dynamic connectivity. ",
    "start": "475100",
    "end": "486300"
  },
  {
    "text": "But we're not so\nfar away from that. As I said, you can\nget log squared. Let me say what the\nlog squared result is.",
    "start": "486300",
    "end": "493110"
  },
  {
    "text": "It's a little bit better\nthan just log squared. You get log squared\nupdate, but query",
    "start": "493110",
    "end": "498150"
  },
  {
    "text": "is actually sub logarithmic.  You got a log n over\nlog log n query.",
    "start": "498150",
    "end": "506400"
  },
  {
    "start": "506400",
    "end": "512650"
  },
  {
    "text": "And another result is\nyou can do a little bit better than log squared.",
    "start": "512650",
    "end": "518049"
  },
  {
    "text": "You can do log times\nlog log n cube update.",
    "start": "518049",
    "end": "525750"
  },
  {
    "text": "So roughly log n update, but\nthere's some poly log log term. And query slows\ndown very slightly.",
    "start": "525750",
    "end": "534279"
  },
  {
    "text": "It becomes log n\nover a log log log n.",
    "start": "534280",
    "end": "539310"
  },
  {
    "start": "539310",
    "end": "544700"
  },
  {
    "text": "Well, it'll sort of makes\nsense why in a moment. So the lowest update time known\nis this one, log times log",
    "start": "544700",
    "end": "552580"
  },
  {
    "text": "log cubed. Big open question is whether\nyou can get log for update,",
    "start": "552580",
    "end": "561160"
  },
  {
    "text": "and any kind of\nreasonable query time. But ideally, log for both.",
    "start": "561160",
    "end": "566649"
  },
  {
    "text": "So that's for a fully dynamic. If I don't say any\notherwise, fully dynamic is always the default.\nResult, that's",
    "start": "566650",
    "end": "574839"
  },
  {
    "text": "the case you usually care about.  Cool.",
    "start": "574840",
    "end": "580240"
  },
  {
    "text": "But if you want\nto do incremental,",
    "start": "580240",
    "end": "586990"
  },
  {
    "text": "you can achieve an alpha bound.",
    "start": "586990",
    "end": "592870"
  },
  {
    "text": "Because incremental dynamic\nconnectivity is really the union find problem.",
    "start": "592870",
    "end": "598580"
  },
  {
    "text": "Union find, you have a\nbunch of sets of elements. You can take two of them\nand union them together.",
    "start": "598580",
    "end": "603850"
  },
  {
    "text": "Once they're unioned, they\ncan never be split apart. And find is tell\nme what set I'm in. So if I do find\non two vertices, I",
    "start": "603850",
    "end": "610390"
  },
  {
    "text": "can find which connected\ncomponents there and check whether\nthey're the same. That will give me\nconnectivity query.",
    "start": "610390",
    "end": "617200"
  },
  {
    "text": "Insertion corresponds to\nmerging two connected components unless they were\nalready together. And it's known you can get\nan alpha amortized bound.",
    "start": "617200",
    "end": "623960"
  },
  {
    "text": "And that's optimal\nfor that problem. So I guess that's\nactually a theta. ",
    "start": "623960",
    "end": "631670"
  },
  {
    "text": "So that's sort of\nwell-known stuff. It's a complicated analysis,\nbut already been done.",
    "start": "631670",
    "end": "639250"
  },
  {
    "text": "So in particular, that's,\nI believe, the best way we know how to solve incremental\nconnectivity in trees.",
    "start": "639250",
    "end": "646120"
  },
  {
    "text": "Though I'm curious whether you\ncan do constant incremental. ",
    "start": "646120",
    "end": "654790"
  },
  {
    "text": "Decremental, there's\nessentially a log n solution. Not quite, but for dense graphs,\nthere's a log n solution.",
    "start": "654790",
    "end": "664120"
  },
  {
    "start": "664120",
    "end": "671830"
  },
  {
    "text": "So I'm stating, instead\nof a bound per operation, this is a total bound.",
    "start": "671830",
    "end": "677230"
  },
  {
    "text": "Let's say you start\nwith an m-edge graph and you delete all the edges. Then you pay log\nn for each edge.",
    "start": "677230",
    "end": "684180"
  },
  {
    "text": "But you also have to pay\nthis n poly log n cost. So if m is a bit bigger\nthan n, then this dominates.",
    "start": "684180",
    "end": "691870"
  },
  {
    "text": "And so it's log n per operation. But if you have a\nsparse graph, it's still poly log per operation.",
    "start": "691870",
    "end": "697540"
  },
  {
    "text": "So decremental, we can kind\nof get log for general graphs.",
    "start": "697540",
    "end": "703652"
  },
  {
    "text": "Another goal you might\nhave is what if I wanted to get worse-case bounds? Everything I've said\nso far is amortized.",
    "start": "703652",
    "end": "709630"
  },
  {
    "text": "If you want to get worse\ncase, not much is known. Big open question is, can I\nget a poly log updating query.",
    "start": "709630",
    "end": "719290"
  },
  {
    "start": "719290",
    "end": "725500"
  },
  {
    "text": "So it was actually a pretty big\nbreakthrough to get poly log whatsoever. This first result\nis from 2001 or so,",
    "start": "725500",
    "end": "733509"
  },
  {
    "text": "after people have worked on\ndynamic graphs for probably a decade. So it took quite a while to\nfind this any kind of poly log.",
    "start": "733510",
    "end": "739860"
  },
  {
    "text": "That still hasn't\nbeen made worse case. So the best results\nare state of the art",
    "start": "739860",
    "end": "746350"
  },
  {
    "text": "at the time, before\nthe poly log came out, which is square root of\nn update, constant query.",
    "start": "746350",
    "end": "752800"
  },
  {
    "start": "752800",
    "end": "760806"
  },
  {
    "text": "There's one other result\nfor worse case, which is if you want to do an\nincremental solution, so you're just inserting edges.",
    "start": "760806",
    "end": "767260"
  },
  {
    "text": "Then there's a bound. It's actually a whole trade off\nbetween updates and queries.",
    "start": "767260",
    "end": "773950"
  },
  {
    "text": "If you have updates\nto take order x time, then you get queries that\ntake log n over log x time.",
    "start": "773950",
    "end": "781779"
  },
  {
    "start": "781780",
    "end": "791150"
  },
  {
    "text": "So log base x of n. And that's optimal. These are theta. There's matching lower bounds.",
    "start": "791150",
    "end": "798080"
  },
  {
    "text": "So this is again,\nreally union find. And so union find has\nbeen well studied,",
    "start": "798080",
    "end": "804420"
  },
  {
    "text": "even in the worse-case setting. Can't do as well as\nalpha, basically.",
    "start": "804420",
    "end": "811570"
  },
  {
    "text": "OK. And then finally, I want\nto talk about lower bounds. ",
    "start": "811570",
    "end": "823259"
  },
  {
    "text": "So there are two\ncomplementary results. But maybe first I'll\nsummarize by saying you need",
    "start": "823260",
    "end": "830270"
  },
  {
    "text": "omega log n update or query. One of them has to\nbe at least log n",
    "start": "830270",
    "end": "838320"
  },
  {
    "text": "to do dynamic connectivity. ",
    "start": "838320",
    "end": "843690"
  },
  {
    "text": "As you see, queries\ncan be sublogarithmic. We don't know how to make\nupdates sublogarithmic and get any\nreasonable query time.",
    "start": "843690",
    "end": "851610"
  },
  {
    "text": "But one of them has\nto be at least log. And here's the specific\ntheorems that imply that.",
    "start": "851610",
    "end": "857580"
  },
  {
    "start": "857580",
    "end": "873310"
  },
  {
    "text": "That's actually similar to this\nresult, but not quite the same.",
    "start": "873310",
    "end": "878467"
  },
  {
    "text": "Because there's a log\non the left-hand side. ",
    "start": "878467",
    "end": "886870"
  },
  {
    "text": "And these results hold\nfor amortized solutions. Whoops.",
    "start": "886870",
    "end": "892750"
  },
  {
    "text": "Key word's missing here. This is an update bound. And this is a query bound. ",
    "start": "892750",
    "end": "902340"
  },
  {
    "text": "So these are basically\nsymmetric results. Says if you have super\nlogarithmic update,",
    "start": "902340",
    "end": "907980"
  },
  {
    "text": "so you have some x bigger\nthan 1 times log n update, then you get log n\nover log x query.",
    "start": "907980",
    "end": "914940"
  },
  {
    "text": "That's a lower bound. If you have a super\nlogarithmic query, so let's say it's x\ntimes larger than log n,",
    "start": "914940",
    "end": "920790"
  },
  {
    "text": "then you need at least a log\nn over log x update time. ",
    "start": "920790",
    "end": "928080"
  },
  {
    "text": "So this result is\nthe one of relevance. Because we don't know any\nsublogarithmic updates.",
    "start": "928080",
    "end": "935630"
  },
  {
    "text": "But we do know\nsublogarithmic queries. So this is the\nregime that we have, essentially, matching\nupper bounds.",
    "start": "935630",
    "end": "942509"
  },
  {
    "text": "Let me show you. This result, this\nresult, and this result,",
    "start": "942510",
    "end": "950670"
  },
  {
    "text": "even, are, in some sense,\ntight against this trade-off, this update query trade-off.",
    "start": "950670",
    "end": "956850"
  },
  {
    "text": "So this update is\nlog n times log n. So x is log n. And over here we get\nlog n over log log n.",
    "start": "956850",
    "end": "965550"
  },
  {
    "text": "So that's tight against that. Here, also, we have here\nx is log log n cubed.",
    "start": "965550",
    "end": "971570"
  },
  {
    "text": "So you take a log of log log n\ncubed, you get log log log n. So that's why there's a\nlog log log n down here.",
    "start": "971570",
    "end": "977949"
  },
  {
    "text": "That's the best\nyou could hope for, given that update time,\nthat's the best query time you can get.",
    "start": "977950",
    "end": "983160"
  },
  {
    "text": "Same over here. Given an update time of root\nn, well, of course, the best",
    "start": "983160",
    "end": "988302"
  },
  {
    "text": "you can hope for\nis constant query. But indeed, it works out. As you're taking log n\ndivided it by 1/2 log n,",
    "start": "988302",
    "end": "993330"
  },
  {
    "text": "you get constant. So these results, they\nmay sound suboptimal.",
    "start": "993330",
    "end": "1000260"
  },
  {
    "text": "But a certain sense,\nthey're optimal. Of course, these are just single\npoints on the trade-off curve. We still really care\nabout the situation of--",
    "start": "1000260",
    "end": "1008535"
  },
  {
    "text": "where's the open\nproblem here-- log n update and query, that\nwould still be ideal.",
    "start": "1008535",
    "end": "1014630"
  },
  {
    "text": "But these are not as bad\nas they look, is the point. Of course, it'd be better\nif this wasn't a 3, it was only a 1.",
    "start": "1014630",
    "end": "1020740"
  },
  {
    "text": "But they're still,\nin a certain sense, tight against this, the\nquery bound that you get.",
    "start": "1020740",
    "end": "1027540"
  },
  {
    "text": "Another open problem\nhere is whether this, the reverse situation,\nis ever relevant.",
    "start": "1027540",
    "end": "1033230"
  },
  {
    "text": "Can you have a\nsublogarithmic update time and get any poly log query time?",
    "start": "1033230",
    "end": "1040715"
  },
  {
    "text": "So this is another open problem. ",
    "start": "1040716",
    "end": "1046549"
  },
  {
    "text": "Little o of log n query. Sorry, little o of log n update,\nand let's say poly log query.",
    "start": "1046550",
    "end": "1054290"
  },
  {
    "text": " The lower bound kind of predicts\nthat something like this",
    "start": "1054290",
    "end": "1060900"
  },
  {
    "text": "ought to exist. But it may be it's\njust impossible. And there's a different lower\nbound that makes it impossible.",
    "start": "1060900",
    "end": "1066977"
  },
  {
    "start": "1066978",
    "end": "1072680"
  },
  {
    "text": "Some theta I wanted to add here. ",
    "start": "1072680",
    "end": "1082600"
  },
  {
    "text": "OK. Another fun thing\nabout this lower bound, is that it holds even if\nyour graphs are paths.",
    "start": "1082600",
    "end": "1088670"
  },
  {
    "text": " So in particular, that tells us\nthat this dynamic tree result",
    "start": "1088670",
    "end": "1096840"
  },
  {
    "text": "that we covered last\nclass, say, you need log n. If you're going to do\nboth operations and log n,",
    "start": "1096840",
    "end": "1103759"
  },
  {
    "text": "that's optimal. Even if your trees\nare paths, which",
    "start": "1103760",
    "end": "1108790"
  },
  {
    "text": "is like the really easy case. And we're going to prove\nthis theorem next class. So if you want, that'll\nbe our last class,",
    "start": "1108790",
    "end": "1115970"
  },
  {
    "text": "our last lower bound. That's next time. Tune in next time. But today we're going to\nfocus on upper bounds, namely",
    "start": "1115970",
    "end": "1123410"
  },
  {
    "text": "these two and this one. ",
    "start": "1123410",
    "end": "1132980"
  },
  {
    "text": "So let's do them. The first one is\nEuler-tour trees,",
    "start": "1132980",
    "end": "1138975"
  },
  {
    "text": "which is another way\nto do the log n bound. It's something we need.",
    "start": "1138975",
    "end": "1145430"
  },
  {
    "text": "We'll need it for doing\nthe log squared solution, for a reason we'll\nsee in a moment.",
    "start": "1145430",
    "end": "1150470"
  },
  {
    "start": "1150470",
    "end": "1163730"
  },
  {
    "text": "So Euler-tour tress go back\nto 1995, Henzinger and King. They're simpler dynamic\ntrees, simpler than link cut,",
    "start": "1163730",
    "end": "1171530"
  },
  {
    "text": "even though they're newer. And the key difference\ncompared to link cut trees",
    "start": "1171530",
    "end": "1179630"
  },
  {
    "text": "is that they let you\ndo stuff with subtrees of the tree instead\nof paths of the tree.",
    "start": "1179630",
    "end": "1185519"
  },
  {
    "text": "Link cut trees are great. We could compute\nthe min or the max or the sum of a bunch\nof weights on any path",
    "start": "1185519",
    "end": "1190910"
  },
  {
    "text": "that we cared about. But for various reasons, we\nwant to do the same thing on subtrees.",
    "start": "1190910",
    "end": "1196410"
  },
  {
    "text": "And this turns out to be easier. So what do we do with\nEuler-tour trees?",
    "start": "1196410",
    "end": "1202640"
  },
  {
    "text": "We take an Euler-tour. Remember Euler-tour from-- I\ncan never remember-- lecture 15.",
    "start": "1202640",
    "end": "1207845"
  },
  {
    "text": "[LAUGHS] I don't quite remember\nwhat that lecture was.",
    "start": "1207845",
    "end": "1213170"
  },
  {
    "text": "When did we do Euler-tours?  Well, doesn't matter.",
    "start": "1213170",
    "end": "1219179"
  },
  {
    "text": "You remember the idea\nof an Euler-tour. It was just walk around the\ntree, do a depth for search, and keep track of every\ntime you visit a node.",
    "start": "1219180",
    "end": "1227550"
  },
  {
    "text": "So you visit some\nnodes multiple times. In general, the\ndegree of the node is the number of\ntimes you visit it.",
    "start": "1227551",
    "end": "1234190"
  },
  {
    "text": "Every edge gets\nvisited exactly twice. So it's the linear\nnumber of visits total.",
    "start": "1234190",
    "end": "1239530"
  },
  {
    "text": " I just want to take that\nlinear order of visits,",
    "start": "1239530",
    "end": "1248360"
  },
  {
    "text": "pull it out straight, store\nthat in a balanced binary search tree. That's Euler-tour trees.",
    "start": "1248360",
    "end": "1253590"
  },
  {
    "text": "They're very simple. ",
    "start": "1253590",
    "end": "1259760"
  },
  {
    "text": "Store the node visits\nby the Euler-tour,",
    "start": "1259760",
    "end": "1270915"
  },
  {
    "text": "and a balanced\nbinary search tree. ",
    "start": "1270915",
    "end": "1277940"
  },
  {
    "text": "What's the order? We're storing them\nin order by the order that the Euler-tour\nvisits, the visits.",
    "start": "1277940",
    "end": "1285799"
  },
  {
    "text": "So this will be the left-most,\nthe min in the tree. This will be the\nnext and then next. So if you do an in-order\ntraversal of the tree,",
    "start": "1285800",
    "end": "1291708"
  },
  {
    "text": "you should get the\nvisits in this order. This is, of course, a way to\nbalance a tree, in some sense.",
    "start": "1291708",
    "end": "1297400"
  },
  {
    "text": "I drew a balanced\ntree as the thing we're trying to represent. But again, it could be a\ntotally unbalanced thing.",
    "start": "1297400",
    "end": "1302799"
  },
  {
    "text": "But when you do an Euler-tour,\nyou get order n visits. And you throw them into\na balanced binary search",
    "start": "1302800",
    "end": "1308530"
  },
  {
    "text": "tree, it's balanced, of course. It's a bit of a weird thing,\nbecause you're not really preserving the structure\nin an obvious way.",
    "start": "1308530",
    "end": "1316530"
  },
  {
    "text": "But there's one\nmore thing we store, which will let us do,\nessentially, whatever we want.",
    "start": "1316530",
    "end": "1322960"
  },
  {
    "text": "Each node stores two\npointers into this structure",
    "start": "1322960",
    "end": "1332730"
  },
  {
    "text": "to the first and last visit. ",
    "start": "1332730",
    "end": "1341230"
  },
  {
    "text": "So like this node has a\npointer to its first visit and its last visit\nalong this structure.",
    "start": "1341230",
    "end": "1347980"
  },
  {
    "text": "It doesn't keep track\nof any middle visits. Because there could\nbe a lot of those. And we just want to have a\nconstant number of pointers.",
    "start": "1347980",
    "end": "1353410"
  },
  {
    "text": "This is going to be a pointer\nmachine data structure just like link cut trees. ",
    "start": "1353410",
    "end": "1359680"
  },
  {
    "text": "Let's see. How do we solve our operations,\ninserting and deleting of edges and connectivity?",
    "start": "1359680",
    "end": "1365770"
  },
  {
    "text": "Actually, I'll start\nwith just phrasing it like link cut trees. We can do most of the\nlink cut tree operations.",
    "start": "1365770",
    "end": "1371380"
  },
  {
    "text": "Remember, there was a\nfind root, link and cut were our main operations. Than there was aggregation. But that will have to change.",
    "start": "1371380",
    "end": "1377784"
  },
  {
    "text": "But if we want to do find root--  so we're given one of these\nbalanced binary search trees.",
    "start": "1377785",
    "end": "1385909"
  },
  {
    "text": "In it is the node v.\nWell, actually, it's a little weirder here.",
    "start": "1385910",
    "end": "1393560"
  },
  {
    "text": "But we have some\nnode v in our tree. And really, we have\nour pointers into this.",
    "start": "1393560",
    "end": "1399980"
  },
  {
    "text": "This is a balanced\nbinary search tree here. We have pointers to the\nfirst and last visit in here.",
    "start": "1399980",
    "end": "1405430"
  },
  {
    "text": "I don't care. Just take any visit,\nanything in here, just say the first visit of\nv. Then walk up the tree.",
    "start": "1405430",
    "end": "1412150"
  },
  {
    "text": "Then walk down the\ntree on the left spine. That is the min.",
    "start": "1412150",
    "end": "1418600"
  },
  {
    "text": "And that's going to be the\nfirst visit of the root node. And so this has a pointer,\nin turn, to the root node.",
    "start": "1418600",
    "end": "1427570"
  },
  {
    "text": "Boom, you found the\nroot of your tree. Again, we're maintaining\nforest of trees.",
    "start": "1427570",
    "end": "1433070"
  },
  {
    "text": "And so we just need to\nfind which tree v is in, walk up, walk down,\nthat's order log n, because this\nthing is balanced,",
    "start": "1433070",
    "end": "1439450"
  },
  {
    "text": "and we found the root. So that's easy. Turns out, the other\noperations are not too easy",
    "start": "1439450",
    "end": "1446380"
  },
  {
    "text": "if you can split and\nconcatenate your tree. So let's start with cut.",
    "start": "1446380",
    "end": "1451480"
  },
  {
    "text": " We need a bigger diagram.",
    "start": "1451480",
    "end": "1457419"
  },
  {
    "start": "1457420",
    "end": "1469540"
  },
  {
    "text": "So here's v. Here's the\nparent of v. I'll call it w. Here's the edge.",
    "start": "1469540",
    "end": "1474840"
  },
  {
    "text": "And our goal, and\nthe cut operation is to delete that edge, separate\nthis tree from that tree.",
    "start": "1474840",
    "end": "1485890"
  },
  {
    "text": "So what I need to do is\nisolate this subtree of v. But conveniently, if you\nthink of the Euler-tour,",
    "start": "1485890",
    "end": "1493330"
  },
  {
    "text": "the Euler-tour, it\ndoes some stuff here. Eventually it follows this edge. Visits v for the\nfirst time here.",
    "start": "1493330",
    "end": "1500700"
  },
  {
    "text": "Then it visits all\nthe stuff down here. Then it visits v\nfor the last time. Then it follows this edge\nand then does other stuff.",
    "start": "1500700",
    "end": "1507990"
  },
  {
    "text": "So the v subtree is a contiguous\ninterval of the Euler-tour.",
    "start": "1507990",
    "end": "1513059"
  },
  {
    "text": "So we just cut it\nopen, cut it apart. So we split the BST at\nthe first and last visits",
    "start": "1513060",
    "end": "1522450"
  },
  {
    "text": "to v, which is\nexactly what we know.",
    "start": "1522450",
    "end": "1529110"
  },
  {
    "text": "We have a pointer from v to\nits first and last visits in the Euler-tour.",
    "start": "1529110",
    "end": "1534450"
  },
  {
    "text": "So split the tree there. Split the tree there. You know split in a\nbinary search tree. You're given a particular\nkey value, let's say, x.",
    "start": "1534450",
    "end": "1543420"
  },
  {
    "text": "And you split into\neverything less than x, and everything great than\nor equal to x, or something",
    "start": "1543420",
    "end": "1549810"
  },
  {
    "text": "like that. That's a split operation. It can be done in\nlog n time, and pick your favorite balanced\nbinary search tree.",
    "start": "1549810",
    "end": "1556350"
  },
  {
    "text": "Red-black trees, AVL\ntrees, they can all do this and maintain\nbalance in these two things. Even though they might\nbe very different sizes,",
    "start": "1556350",
    "end": "1562350"
  },
  {
    "text": "they'll both be log height\nrelative to their own size.",
    "start": "1562350",
    "end": "1567612"
  },
  {
    "text": "This is obviously\nnot quite enough. Because what we've\ndone is basically cut here and cut here.",
    "start": "1567612",
    "end": "1572760"
  },
  {
    "text": "Now we have three trees. We have the one we want\nfor v, v is subtree.",
    "start": "1572760",
    "end": "1578250"
  },
  {
    "text": "That will correspond\nto the Euler-tour of exactly that thing. So this is the represented\ntree I'm talking about.",
    "start": "1578250",
    "end": "1584730"
  },
  {
    "text": "And this is the balanced\nbinary search tree. But the rest of the\ntree is in two parts.",
    "start": "1584730",
    "end": "1591400"
  },
  {
    "text": "There's the part\nto the left of v, before we visited v, the\npart after we visited v. Those we just have\nto stick back together,",
    "start": "1591400",
    "end": "1597570"
  },
  {
    "text": "so we concatenate them. ",
    "start": "1597570",
    "end": "1603451"
  },
  {
    "text": "Yeah. ",
    "start": "1603451",
    "end": "1610419"
  },
  {
    "text": "So I'll call them the before-v\ntree and the after-v tree. There is actually a tiny\nthing that has to happen here,",
    "start": "1610420",
    "end": "1616930"
  },
  {
    "text": "which I just remembered. Which is we need, somewhere,\nto delete one occurrence of w,",
    "start": "1616930",
    "end": "1624950"
  },
  {
    "text": "of the parent of v. Because it used to be we\nvisit w, then we visit v,",
    "start": "1624950",
    "end": "1630142"
  },
  {
    "text": "blah, blah, blah. Then we visit w again. If we cut out this\npart, we're going to have two visits\nto w in a row.",
    "start": "1630142",
    "end": "1635620"
  },
  {
    "text": "We really just want one visit. So this is a minor thing, but\nwe need to do a delete in there.",
    "start": "1635620",
    "end": "1640980"
  },
  {
    "text": "So each of these is log n time. So the overall time is log n. Easy. This is a cut-and-paste kind\nof argument, all pretty cheap.",
    "start": "1640980",
    "end": "1651060"
  },
  {
    "text": "OK, now let's do link. ",
    "start": "1651060",
    "end": "1658080"
  },
  {
    "text": "Concatenate is the reverse\nof split, by the way. You have two trees. All the things in\nthe left are smaller",
    "start": "1658080",
    "end": "1663650"
  },
  {
    "text": "than all things in the right. You just want to\njoin them together like a very restrictive\nkind of merge.",
    "start": "1663650",
    "end": "1671060"
  },
  {
    "text": "So join, recall, is you have a\nnode v. And you want to make it",
    "start": "1671060",
    "end": "1680450"
  },
  {
    "text": "a new child of w. w might have other children. It lives in some bigger tree.",
    "start": "1680450",
    "end": "1689059"
  },
  {
    "text": "We want to add v\nas a child of w. So we're assuming here\nv is a root, for now. ",
    "start": "1689060",
    "end": "1695880"
  },
  {
    "text": "So what do we do?  Sort of the same thing.",
    "start": "1695880",
    "end": "1701750"
  },
  {
    "text": "We sort of know we want to\nput v in here somewhere. It actually doesn't really\nmatter where we put it.",
    "start": "1701750",
    "end": "1707690"
  },
  {
    "text": "We're not keeping track of\nthe order of nodes in here. So I'm going to simplify\nmy life and say,",
    "start": "1707690",
    "end": "1713060"
  },
  {
    "text": "let's put v at the end. I want to make v the last\nchild of w, like this.",
    "start": "1713060",
    "end": "1721370"
  },
  {
    "text": "So we can find the last\nchild, in some sense. After we visit the last\nchild, we come back",
    "start": "1721370",
    "end": "1726800"
  },
  {
    "text": "and do the last visit to w. So I'm going to look\nat the last visit of w, cut the tree open there,\nand stick this part in.",
    "start": "1726800",
    "end": "1734400"
  },
  {
    "text": "Cut the Euler-tour\nin half there. So split. ",
    "start": "1734400",
    "end": "1741270"
  },
  {
    "text": "w is tree at w's last visit.",
    "start": "1741270",
    "end": "1747550"
  },
  {
    "start": "1747550",
    "end": "1752640"
  },
  {
    "text": "Right? And then we do\nomega concatenate.",
    "start": "1752640",
    "end": "1757780"
  },
  {
    "text": "We're going to\nconcatenate, basically,",
    "start": "1757780",
    "end": "1763020"
  },
  {
    "text": "before w's last visit. ",
    "start": "1763020",
    "end": "1771370"
  },
  {
    "text": "We're going to concatenate\na single occurrence of w. Because there's a new\noccurrence of w now.",
    "start": "1771370",
    "end": "1777120"
  },
  {
    "text": "We do it before and after v. So we add another w. Then we add v's\nEuler-tour, v's BST,",
    "start": "1777120",
    "end": "1786660"
  },
  {
    "text": "and then we do after\nwhatever used to be there after w's last visit.",
    "start": "1786660",
    "end": "1794159"
  },
  {
    "text": "Let's say, after and\nincluding that w visit.",
    "start": "1794160",
    "end": "1802930"
  },
  {
    "text": " So just the symmetric\nof this, here we had to delete\none occurrence of w.",
    "start": "1802930",
    "end": "1809620"
  },
  {
    "text": "Here we have to add one back in. But you just cut, paste\nin the thing you need, and rejoin everything.",
    "start": "1809620",
    "end": "1814970"
  },
  {
    "text": "So again, very easy. It's a constant number\nof log n time operations, if you can do split and\nconcatenate in log n time.",
    "start": "1814970",
    "end": "1822830"
  },
  {
    "text": "So you see this, it's like wow,\nwhy do we spend so much time with link cut trees? This is really easy.",
    "start": "1822830",
    "end": "1829158"
  },
  {
    "text": "But they have their\ndifferent applications. If you want to compute\naggregates on paths you need to use link cut tress. It's the best we know.",
    "start": "1829159",
    "end": "1835270"
  },
  {
    "text": "This structure will not\ndo aggregates on paths. But it will do\naggregates on subtrees. Because subtrees are\nrepresented by these intervals",
    "start": "1835270",
    "end": "1842680"
  },
  {
    "text": "in the Euler-tour tree. So if you have a weight\non all the nodes in here, say, you can easily\nfind this interval",
    "start": "1842680",
    "end": "1849926"
  },
  {
    "text": "and do a range query there. So you take the min\nof all those things. If you have subtree\nmins, you can",
    "start": "1849926",
    "end": "1855490"
  },
  {
    "text": "take the min of log n\nthings and in log n time, compute the min in an\ninterval, or min over",
    "start": "1855490",
    "end": "1862840"
  },
  {
    "text": "a subtree rooted at a node,\nor max or sum, or whatever. So here you can do subtree\naggregation in log n time.",
    "start": "1862840",
    "end": "1869820"
  },
  {
    "text": "And we're going to need that\nfor the log squared solution. ",
    "start": "1869820",
    "end": "1877120"
  },
  {
    "text": "One other thing I\nwanted to maybe mention, here we did join. And join assumed that v\nwas the root of its tree.",
    "start": "1877120",
    "end": "1886300"
  },
  {
    "text": "What if v is not\nthe root of its tree and we still want\nto insert an edge? Because insert, when\nwe're maintaining",
    "start": "1886300",
    "end": "1892149"
  },
  {
    "text": "an undirected graph,\nthere is no rootedness. That rootedness is just a tool.",
    "start": "1892150",
    "end": "1897377"
  },
  {
    "text": "You could say at the first\nstep here, just root the tree somewhere so that we can\nhave a well-defined beginning",
    "start": "1897377",
    "end": "1903520"
  },
  {
    "text": "and end to the Euler-tour. Of course, Euler-tour in\nit's the most natural form, is actually a cycle.",
    "start": "1903520",
    "end": "1908679"
  },
  {
    "text": "And it would only\nhave one visit here.  So you can think of it that way.",
    "start": "1908680",
    "end": "1914800"
  },
  {
    "text": "I'd still like to have the\ntwo visits conceptually, because that makes even the\nsubtree rooted at the root",
    "start": "1914800",
    "end": "1922240"
  },
  {
    "text": "an interval between the\nbeginning and the end. But the nice thing\nof the cycle view",
    "start": "1922240",
    "end": "1927940"
  },
  {
    "text": "is if I wanted to\nchange who the root is, say I want this node to\nbe the root, that's just",
    "start": "1927940",
    "end": "1934480"
  },
  {
    "text": "a cyclic shift of everything. It just means I want to start\nthe cycle here and end it here. So I'd basically duplicate this\ncopy of the vertex, singlify",
    "start": "1934480",
    "end": "1944390"
  },
  {
    "text": "this one. There's only one copy. That's the constant number\nof inserts and deletes. And now rotate.",
    "start": "1944390",
    "end": "1949660"
  },
  {
    "text": "[LAUGHS] What does it rotate mean? Well, before it was\na sequential order,",
    "start": "1949660",
    "end": "1954680"
  },
  {
    "text": "starting here, ending here. Now, I want it to be a\nsequential order, say, starting here, continuing this\nway, and then ending back here.",
    "start": "1954680",
    "end": "1964200"
  },
  {
    "text": "So if you look at what\nthat requires, maybe use another color,\nI want this part.",
    "start": "1964200",
    "end": "1970059"
  },
  {
    "start": "1970060",
    "end": "1975120"
  },
  {
    "text": "That's an interval of the old\ntree, of the old sequence. And then I want this part.",
    "start": "1975120",
    "end": "1981970"
  },
  {
    "text": "So there's two pieces\nof the old tree. And I just want to\nchange their order. It's a cyclic shift.",
    "start": "1981970",
    "end": "1987450"
  },
  {
    "text": "Cyclic shift is just a cut and\nthen a rejoin the other way. So I can reroute a tree\nin log n time as well.",
    "start": "1987450",
    "end": "1995050"
  },
  {
    "text": "So this is why, in this world,\njoin is equivalent to insert. If I want to do\na general insert,",
    "start": "1995050",
    "end": "2000890"
  },
  {
    "text": "first I reroute v's tree. I do a cyclic shift with\none split one concatenate, like this.",
    "start": "2000890",
    "end": "2006650"
  },
  {
    "text": "And I get v to be the root. Then I can do the join. So again, constant number\nof splits and concatenates.",
    "start": "2006650",
    "end": "2013710"
  },
  {
    "text": " So it's another operation\nwe can do, in log in.",
    "start": "2013710",
    "end": "2022280"
  },
  {
    "text": "Everything here is log n. ",
    "start": "2022280",
    "end": "2028070"
  },
  {
    "text": "Cool. Any questions about\nEuler-tour trees. That's all I'll say about them.",
    "start": "2028070",
    "end": "2034179"
  },
  {
    "text": "We will next move\non to next result.",
    "start": "2034180",
    "end": "2041596"
  },
  {
    "text": "AUDIENCE: Can link cut\ntrees also do a reroute? ERIK DEMAINE: Can link cut\ntress also do a reroute? I haven't thought about that.",
    "start": "2041596",
    "end": "2047270"
  },
  {
    "text": " I would guess so.",
    "start": "2047270",
    "end": "2052684"
  },
  {
    "text": "[LAUGHS] But it's going to require\nsome more thought. So let's see, link cut tree,\nwe can do a little aside here.",
    "start": "2052684",
    "end": "2061069"
  },
  {
    "text": "Link cut tree, we\ndo an axis on v. So now we get that v is\nup here, right at the root",
    "start": "2061070",
    "end": "2067129"
  },
  {
    "text": "of the tree of oxx trees. Now we've got other trees of\n[INAUDIBLE] trees hanging off here.",
    "start": "2067130",
    "end": "2073158"
  },
  {
    "text": "But in particular, this\nthing represents a path. ",
    "start": "2073159",
    "end": "2078560"
  },
  {
    "text": "It represents the\nroute to v path. It actually has no right child. So it's a little bit\nemptier, like that.",
    "start": "2078560",
    "end": "2088460"
  },
  {
    "text": "So now we want to flip things\naround and say v is the root. We basically want\nto reverse the order of all the nodes in this tree.",
    "start": "2088460",
    "end": "2095090"
  },
  {
    "text": "So reversing the order of\nnodes in a binary search tree, you can't regularly do. But if you augment your\ndata structure to say,",
    "start": "2095090",
    "end": "2103160"
  },
  {
    "text": "I could basically mark\nthese nodes as all inverted, treat left as right\nand right as left. It's basically the\ndyslexic approach.",
    "start": "2103160",
    "end": "2110180"
  },
  {
    "text": "You have a bit\nsaying from here down to here, mark\neverything as dyslexic.",
    "start": "2110180",
    "end": "2116540"
  },
  {
    "text": "And so you invert\nleft and right. So I think, with this\nappropriate augmentation, you can reroute the\ntree in log n time.",
    "start": "2116540",
    "end": "2125200"
  },
  {
    "text": "But of course, there's\nsome details to check. It might even be that's in the\noriginal link cut tree paper.",
    "start": "2125200",
    "end": "2130700"
  },
  {
    "text": "But I don't remember offhand. So I'm pretty sure it\nworks, and therefore, gives you dynamic connectivity.",
    "start": "2130700",
    "end": "2135740"
  },
  {
    "text": "But if it doesn't,\nEuler-tour trees do it too. So we're covered either way.",
    "start": "2135740",
    "end": "2141170"
  },
  {
    "text": "So that's Euler-tour trees. Next on our list is decremental\nconnectivity in trees. So we're going to solve\na weaker problem, which",
    "start": "2141170",
    "end": "2147740"
  },
  {
    "text": "is just deletions only instead\nof inserts and deletes. We're going to solve it faster. ",
    "start": "2147740",
    "end": "2155300"
  },
  {
    "text": "Constant time per operation. This is just a\nfun little result.",
    "start": "2155300",
    "end": "2176650"
  },
  {
    "text": "It's fun because it uses\nsome techniques we know. So bound is constant amortized,\nassuming all edges get deleted.",
    "start": "2176650",
    "end": "2187300"
  },
  {
    "start": "2187300",
    "end": "2195280"
  },
  {
    "text": "We need to assume\nthis, essentially, because we're amortizing\nagainst the future. So we need to get all\nthe way to the end.",
    "start": "2195280",
    "end": "2203710"
  },
  {
    "text": "Overall, over n operations it's\ngoing to take order n time. ",
    "start": "2203710",
    "end": "2209049"
  },
  {
    "text": "This is, again, a\nseries of refinements, or a bunch of pieces of\nthe solution that get combined together, not\na sequential algorithm.",
    "start": "2209050",
    "end": "2217540"
  },
  {
    "text": "So the first observation is, of\ncourse, we can do order log n. We know, now, maybe\ntwo ways to do it.",
    "start": "2217540",
    "end": "2224349"
  },
  {
    "text": "But you can use Euler-tour trees\nand only do cuts, life is easy. Link cut trees, you\ncould also just do cuts.",
    "start": "2224350",
    "end": "2230170"
  },
  {
    "text": "You don't even need rerouting. Rerouting was only for joins. So that may seem obvious.",
    "start": "2230170",
    "end": "2236060"
  },
  {
    "text": "But how do we reduce\nthe log n to a constant?",
    "start": "2236060",
    "end": "2241140"
  },
  {
    "text": "In general, in this class? AUDIENCE: Make up tables. ERIK DEMAINE: Indirection,\nand maybe look up tables.",
    "start": "2241140",
    "end": "2247650"
  },
  {
    "text": "Yep. How do we do\nindirection in a tree? AUDIENCE: Leaf pruning?",
    "start": "2247650",
    "end": "2253183"
  },
  {
    "text": "ERIK DEMAINE: Leaf\npruning, leaf trimming, whatever you want to call it. Should call it the Edward\nScissorhands approach,",
    "start": "2253184",
    "end": "2261730"
  },
  {
    "text": "or something. So leaf trimming,\nwhat I want to do is cut below\nmaximally deep nodes",
    "start": "2261730",
    "end": "2271540"
  },
  {
    "text": "that are [INAUDIBLE] log n. ",
    "start": "2271540",
    "end": "2280510"
  },
  {
    "text": "Say with greater than\nlog n descendants. ",
    "start": "2280510",
    "end": "2289400"
  },
  {
    "text": "So we have our top tree. And then hanging\noff some nodes here, we're going to have\nsome bottom trees.",
    "start": "2289400",
    "end": "2295840"
  },
  {
    "start": "2295840",
    "end": "2303150"
  },
  {
    "text": "These each have, at\nmost, log n nodes. These have bigger than\nlog n nodes below them.",
    "start": "2303150",
    "end": "2310227"
  },
  {
    "text": "So we can charge every\nleaf in the structure to the log n nodes below it. And so up here we have at most,\nsorry, n over log n leaves.",
    "start": "2310227",
    "end": "2322320"
  },
  {
    "text": "Not nodes. Nodes could still be linear\nif the graph is a path. But at most, n\nover log n leaves.",
    "start": "2322320",
    "end": "2329850"
  },
  {
    "text": "So we have, at most, n over\nlog n branching nodes up here. So what we need is a\nstructure for dealing",
    "start": "2329850",
    "end": "2336300"
  },
  {
    "text": "with long paths in\nthe top, a structure for dealing with log n\nsize things down here,",
    "start": "2336300",
    "end": "2342180"
  },
  {
    "text": "and a structure for\ncombining the paths together. And that's the easy part.",
    "start": "2342180",
    "end": "2349619"
  },
  {
    "text": "If we treat each long\npath as a single edge, basically, we look at\nthe compressed top tree,",
    "start": "2349620",
    "end": "2355056"
  },
  {
    "text": "in the sense of\ncompressed tries. But it's now a tree\ninstead of a try. I guess it's a try. Whatever We look at the\ncompressed tree up here.",
    "start": "2355056",
    "end": "2361650"
  },
  {
    "text": "That will have\nsize, n over log n. And then we can afford\nto use structure one.",
    "start": "2361650",
    "end": "2367300"
  },
  {
    "text": "Why? Because in some\nsense, there only be n over log n\noperations performed.",
    "start": "2367300",
    "end": "2372762"
  },
  {
    "text": "So it's not a space issue\nthere we're trying to save. It's a time issue. So a little different\nfrom the past. ",
    "start": "2372762",
    "end": "2379920"
  },
  {
    "text": "There are only n\nover log n times that you can destroy\na path up here. Because there's only\nn over log n paths.",
    "start": "2379920",
    "end": "2385667"
  },
  {
    "text": "Each time you destroy a path,\nI do an operation up here, I pay log n. But if the total number of\noperations n over log n,",
    "start": "2385667",
    "end": "2391950"
  },
  {
    "text": "total cost is linear. So constant amortized\nagainst the future. So I'm going to use structure\none on the compressed top tree.",
    "start": "2391950",
    "end": "2403040"
  },
  {
    "start": "2403040",
    "end": "2408640"
  },
  {
    "text": "And what remains is what\nI do in the bottom trees? What I do on the paths? And then how do I combine\nall those results together?",
    "start": "2408640",
    "end": "2415297"
  },
  {
    "text": "Let's first talk about how\nto combine the results. There are a couple\nof different cases. It So we're doing\na query on v, w,",
    "start": "2415297",
    "end": "2423220"
  },
  {
    "text": "and we want to do\nconnectivity query.  So it could be that v and w\nare in the same bottom tree.",
    "start": "2423220",
    "end": "2432940"
  },
  {
    "text": "In that case, we just need to\ndo a query within a bottom tree. So as long as we can solve\nthe bottom tree case quickly,",
    "start": "2432940",
    "end": "2442540"
  },
  {
    "text": "we're happy. Constant time, I guess. That will turn out\nto be pretty easy.",
    "start": "2442540",
    "end": "2449700"
  },
  {
    "text": "That's the easy case. Otherwise they could be\nin different bottom trees.",
    "start": "2449700",
    "end": "2455260"
  },
  {
    "text": "So it could be v's down here and\nw's in some other bottom tree.",
    "start": "2455260",
    "end": "2462430"
  },
  {
    "text": "So then we have three\nqueries we need to do. One is like this. One is like this.",
    "start": "2462430",
    "end": "2468700"
  },
  {
    "text": "We need to test the single\nedge, but that's trivial. And then we need to\ndo a query in the top.",
    "start": "2468700",
    "end": "2474660"
  },
  {
    "text": "Can you get from here to here? Now, these nodes are\na little bit special, because they are leaves. They will be at\nthe ends of paths.",
    "start": "2474660",
    "end": "2482710"
  },
  {
    "text": "So this is really just a query\nwe can do using structure one. Because we take either an\nentire path or no path at all.",
    "start": "2482710",
    "end": "2492610"
  },
  {
    "text": "So we can look at\nthe compressed tree and that's enough,\nbecause the leaves exist on the compressed tree.",
    "start": "2492610",
    "end": "2498180"
  },
  {
    "text": "That's not always the case. A different situation is this. We might have, for example,\nv up here, w up here,",
    "start": "2498180",
    "end": "2505859"
  },
  {
    "text": "and v and w are not down here. So these are irrelevant. We just want to know, in the\ntop tree, can I get from v to w?",
    "start": "2505860",
    "end": "2513304"
  },
  {
    "text": "Now, this is a\nlittle more awkward because v is going\nto live on some path.",
    "start": "2513304",
    "end": "2518380"
  },
  {
    "text": "w is going to live on some path. But it might be in\nthe middle of a path. And so there's now three\nqueries we need to do.",
    "start": "2518380",
    "end": "2524330"
  },
  {
    "text": "One is can I get to\nthe top of my path? And then can I get from\none path to the other?",
    "start": "2524330",
    "end": "2531289"
  },
  {
    "text": "So these are\nbranching nodes here. And can I get from\nthis branching node to that branching node? It might not always be going up.",
    "start": "2531290",
    "end": "2536500"
  },
  {
    "text": "Sometimes you have to go down. But point is, a constant number\nof queries to path structures,",
    "start": "2536500",
    "end": "2541590"
  },
  {
    "text": "to compressed structures. This is, again,\nthe one structure. And a constant number of\ncalls to a bottom structure",
    "start": "2541590",
    "end": "2548596"
  },
  {
    "text": "will suffice to\nanswer the query. There's a few more cases\nthat I haven't drawn. If you could be half of\nthis and half of this.",
    "start": "2548596",
    "end": "2555406"
  },
  {
    "text": "But it can all be\ndone, as long as we can solve bottom and paths. So let's solve paths\nfirst, I think.",
    "start": "2555406",
    "end": "2562540"
  },
  {
    "text": "Oh no, bottom trees, fine. So part 3 of the solution\nis solve a bottom tree.",
    "start": "2562540",
    "end": "2569260"
  },
  {
    "text": " Here we can do it in\nconstant worse case. ",
    "start": "2569260",
    "end": "2578530"
  },
  {
    "text": "So this is essentially\nthe lookup table thing, although it's a pretty\nsimple lookup table.",
    "start": "2578530",
    "end": "2583810"
  },
  {
    "text": "What we do, bottom tree\nhas only log n nodes.",
    "start": "2583810",
    "end": "2588860"
  },
  {
    "text": "So we can represent 1 bit\nper node in a single word. And what we'll do, store\nbit vector of which",
    "start": "2588860",
    "end": "2598930"
  },
  {
    "text": "edges have been deleted. ",
    "start": "2598930",
    "end": "2607750"
  },
  {
    "text": "In what order? I don't really care. Just pick some fixed order\non the edges down here,",
    "start": "2607750",
    "end": "2613810"
  },
  {
    "text": "and store the bits\nin that order. And say every edge\nknows its sequence. So you could do a depth first\nsearch at the beginning,",
    "start": "2613810",
    "end": "2620760"
  },
  {
    "text": "to label the edges in\nsome canonical order. And then every edge knows\nwhat its bit position",
    "start": "2620760",
    "end": "2626440"
  },
  {
    "text": "is in the vector. So when I go to\ndelete an edge, I just set that one bit\nusing an or operation.",
    "start": "2626440",
    "end": "2633740"
  },
  {
    "text": "Cool. So I can delete edges. I can actually even insert edges\ndown here that used to exist.",
    "start": "2633740",
    "end": "2639190"
  },
  {
    "text": "I could undelete an edge. But that only works in\nthe bottom structure. So not generally useful.",
    "start": "2639190",
    "end": "2644850"
  },
  {
    "text": "OK, so it's clear how to do\nan update, how to do a delete. I just mark a bit. How do I do a query?",
    "start": "2644850",
    "end": "2650212"
  },
  {
    "text": "I want to know, given two\nnodes, v and w, one of them could be the root of the tree. I want to know can\nI get from v to w?",
    "start": "2650212",
    "end": "2656560"
  },
  {
    "text": "Or there's only a single\npath that might exist. So it's a matter of has any edge\nalong this path been deleted?",
    "start": "2656560",
    "end": "2664460"
  },
  {
    "text": "So a general way to\nwrite that is I have w.",
    "start": "2664460",
    "end": "2672580"
  },
  {
    "text": "I look at v's path to the root. I look at w's path to the root. At some point,\nwe've reach the LCA.",
    "start": "2672580",
    "end": "2679450"
  },
  {
    "text": "What I want to know is, have\nany of these edges been deleted? If yes, I can't get there. If none of them have been\ndeleted, I can get there.",
    "start": "2679450",
    "end": "2685780"
  },
  {
    "text": "It's an if and only if. I don't care about these\nedges up here above the LCA. Because I only need to go\nto the LCA and back down.",
    "start": "2685780",
    "end": "2693170"
  },
  {
    "text": "So what do I do? Each vertex stores a bit\nvector of its ancestors,",
    "start": "2693170",
    "end": "2707916"
  },
  {
    "text": "of the ancestor edges. ",
    "start": "2707916",
    "end": "2717740"
  },
  {
    "text": "Well, ancestor edges\nis kind of weird. It stores a bit vector\nrepresenting its path",
    "start": "2717740",
    "end": "2726790"
  },
  {
    "text": "to the root.  That's this red stuff.",
    "start": "2726790",
    "end": "2732700"
  },
  {
    "text": "I want to know,\nfor vertex v, what are the edges along the path to\nthe root of this bottom tree?",
    "start": "2732700",
    "end": "2738760"
  },
  {
    "text": "Just preprocessed. You can build this thing as\nyou do the depth first search and store it. Again, it's one word per vertex.",
    "start": "2738760",
    "end": "2745220"
  },
  {
    "text": "So I can fit it\nwith constant space. It's constant space overhead.",
    "start": "2745220",
    "end": "2750880"
  },
  {
    "text": "And now, if I have\ntwo vertices, I take the XOR of those two paths.",
    "start": "2750880",
    "end": "2755950"
  },
  {
    "text": "That will give me this part. And then I use that as a mask\ninto the bit vector, say,",
    "start": "2755950",
    "end": "2763250"
  },
  {
    "text": "are any of these 1? How do I do that? I just mask. And if the result is the 0 word,\nthen I know none of them are 1.",
    "start": "2763250",
    "end": "2769780"
  },
  {
    "text": "Otherwise, I know some edge\nwas deleted and I'm screwed. So I take XOR of v's\npath and w's path.",
    "start": "2769780",
    "end": "2781660"
  },
  {
    "text": " And then I mask this thing,\nwhich stores which edges",
    "start": "2781660",
    "end": "2790089"
  },
  {
    "text": "were deleted. And then I check whether\nthat word equals 0.",
    "start": "2790090",
    "end": "2795270"
  },
  {
    "text": "If it equals 0, yes,\nI can get there. If it doesn't equal\n0, I can't get there because some edge was deleted.",
    "start": "2795270",
    "end": "2801230"
  },
  {
    "text": "So very easy, because we can\nfit log n bits in a word.",
    "start": "2801230",
    "end": "2806600"
  },
  {
    "text": " OK, that's the bottom\ntree structure.",
    "start": "2806600",
    "end": "2811770"
  },
  {
    "text": "Next we need a path structure. ",
    "start": "2811770",
    "end": "2843180"
  },
  {
    "text": "Here we can use due constant\namortized with a similar trick. ",
    "start": "2843180",
    "end": "2850650"
  },
  {
    "text": "So here's our path. We're going to use,\nessentially, indirection again.",
    "start": "2850650",
    "end": "2857610"
  },
  {
    "text": "Again, we know how to\nsolve this in log n. When we have a sequential thing,\nour usual way of indirection",
    "start": "2857610",
    "end": "2862890"
  },
  {
    "text": "is to split into chunks.  Each chunk here, I need\nto be about log n in size.",
    "start": "2862890",
    "end": "2871410"
  },
  {
    "text": "So I'll just make it\nexactly log n in size. So there's n over log n chunks.",
    "start": "2871410",
    "end": "2876570"
  },
  {
    "text": "So if I store a\nsummary vector, we can think of these\nas being 0, 1, 0, 1,",
    "start": "2876570",
    "end": "2881880"
  },
  {
    "text": "whatever, where the 1's mean\nthis edge has been deleted. 0 means it hasn't been deleted. All right, let me write n over\nlog n chunks, each log n edges.",
    "start": "2881880",
    "end": "2894630"
  },
  {
    "text": " And I'm going to store\neach chunk as a bit vector.",
    "start": "2894630",
    "end": "2901720"
  },
  {
    "start": "2901720",
    "end": "2908180"
  },
  {
    "text": "Bit vector has log n bits. w's at least log n. So I can do the same sort\nof things I could do before.",
    "start": "2908180",
    "end": "2914690"
  },
  {
    "text": "If I delete an edge, I just set\na 1 bit in the chunk vector. ",
    "start": "2914690",
    "end": "2922990"
  },
  {
    "text": "Now, that's good\nfor local queries. If I want to do a\nlong-distance query, I need to basically summarize,\nare any of these edges deleted?",
    "start": "2922990",
    "end": "2931690"
  },
  {
    "text": "If so, I'll put a 1 up here. Any of these edges deleted? If not, put a 0.",
    "start": "2931690",
    "end": "2937000"
  },
  {
    "text": "And now, I want to\nstructure over-- this, you might call the summary\nvector, like in [INAUDIBLE]..",
    "start": "2937000",
    "end": "2942490"
  },
  {
    "text": "Done that before with\nindirection as well. Now, this summary vector\nhas size n over log n.",
    "start": "2942490",
    "end": "2948280"
  },
  {
    "text": "So I can afford to use our log\nn solution that we started with.",
    "start": "2948280",
    "end": "2953360"
  },
  {
    "text": "So use 1 on summary\nvector of chunks.",
    "start": "2953360",
    "end": "2966730"
  },
  {
    "text": "Because again, the first time\nI set one of the bits in here, I have to do an update up here.",
    "start": "2966730",
    "end": "2972700"
  },
  {
    "text": "But only then. Once it's been done once, I\ndon't have to update again. So there will only be\nn over log n updates.",
    "start": "2972700",
    "end": "2978200"
  },
  {
    "text": "So I can afford\nlog n per update. It'll still be linear time\ntotal, constant per operation",
    "start": "2978200",
    "end": "2983410"
  },
  {
    "text": "amortized. So this is my solution. If I have a query, let's say\nI want to know between here",
    "start": "2983410",
    "end": "2992440"
  },
  {
    "text": "and here, I first check, can\nI get to the right endpoint locally?",
    "start": "2992440",
    "end": "2998200"
  },
  {
    "text": "Which is a query\nwithin the chunk. Which is again, I just\nmask out these bits. I say and now do I\nhave the 0 vector?",
    "start": "2998200",
    "end": "3004494"
  },
  {
    "text": "In which case, nothing I\ncare about has been deleted and I can get there? Or if I don't have the 0\nvector, I can't get there.",
    "start": "3004494",
    "end": "3011160"
  },
  {
    "text": "I want to know, can I get\nto the left from here? Again it's a mask and\na check against 0. And then I want to\nknow, can I go over",
    "start": "3011160",
    "end": "3017910"
  },
  {
    "text": "this interval of chunks? And that, I can use\nthe summary vector for.",
    "start": "3017910",
    "end": "3023970"
  },
  {
    "text": "And again, that is a\nmask of a subinterval, and then checking\nwhether it has 0.",
    "start": "3023970",
    "end": "3029490"
  },
  {
    "text": "So I take the and of these\nthree results, and I'm done. That gives me a\nquery over a path.",
    "start": "3029490",
    "end": "3036137"
  },
  {
    "text": "So it's kind of fun. We use two levels\nof indirection. One to reduce the\nnumber of leaves.",
    "start": "3036137",
    "end": "3043040"
  },
  {
    "text": "And then these were\nsort of trivial. And then within the structure,\nwe could only afford things",
    "start": "3043040",
    "end": "3048900"
  },
  {
    "text": "on the non-branching\npart, so we had to deal with paths separately. And there we use another\nlevel of indirection.",
    "start": "3048900",
    "end": "3054270"
  },
  {
    "text": "But in the end, we get\nrid of all of our logs. And it's constant amortized\nfor deletions in a tree.",
    "start": "3054270",
    "end": "3062270"
  },
  {
    "text": "Questions about that? That was our second\nresult. We have one more.",
    "start": "3062270",
    "end": "3069250"
  },
  {
    "start": "3069250",
    "end": "3094929"
  },
  {
    "text": "Last result we're\ngoing to talk about is log squared n\nupdate, log over log log query, for general graphs.",
    "start": "3094929",
    "end": "3101980"
  },
  {
    "text": "Finally, we graduate from\ntrees to general graphs. ",
    "start": "3101980",
    "end": "3144099"
  },
  {
    "text": "This is a result by Holm,\nde Lichtenberg, and Thorup, 2001 is the journal version.",
    "start": "3144100",
    "end": "3152740"
  },
  {
    "text": "So we want to solve\ndynamic connectivity. We want to understand,\nin general, when two vertices are in\nthe same connected component",
    "start": "3152740",
    "end": "3159580"
  },
  {
    "text": "or not. That sounds tricky. We're going to do that\nin a pretty simple way",
    "start": "3159580",
    "end": "3165970"
  },
  {
    "text": "at a high level. High level is, we want to\nstore a spanning forest.",
    "start": "3165970",
    "end": "3172286"
  },
  {
    "text": "You know what a\nspanning tree is. Spanning forest, well, your\ngraph might be disconnected. That's the whole point\nof the data structure.",
    "start": "3172286",
    "end": "3178660"
  },
  {
    "text": "If it's not disconnected,\nyou answer yes all the time. When it's disconnected\nyou say, OK, I'll have a spanning tree for\nthis connected component,",
    "start": "3178660",
    "end": "3184640"
  },
  {
    "text": "spanning tree for every\nconnected component. Together we call that\na spanning forest. That's the maximal connectivity\nyou can get, but represented",
    "start": "3184640",
    "end": "3192010"
  },
  {
    "text": "as a tree. Now, we have a great\nway to represent trees, Euler-tour trees.",
    "start": "3192010",
    "end": "3197710"
  },
  {
    "text": "And if you somehow connected\ntogether two components, that is an insertion of an edge\nin an Euler-tour structure.",
    "start": "3197710",
    "end": "3204460"
  },
  {
    "text": "Great. So we can maintain all\nthese connected components and merge them if we\nhave to, using an insert",
    "start": "3204460",
    "end": "3211750"
  },
  {
    "text": "in Euler-tour structure. And to do a connectivity query-- I don't think I mentioned this--\nyou do find root on v and w,",
    "start": "3211750",
    "end": "3218200"
  },
  {
    "text": "see whether they're\nthe same root. Because root is a canonical name\nfor the connected component.",
    "start": "3218200",
    "end": "3223510"
  },
  {
    "text": "You can solve connectivity using\nfind root in constant time. Well, constant extra time,\nlog for the find root.",
    "start": "3223510",
    "end": "3231270"
  },
  {
    "text": "OK, so everything looks great. I can connectivity. I can do insertion. What about deletion?",
    "start": "3231270",
    "end": "3237730"
  },
  {
    "text": "If I delete an edge that is\nnot in my spanning forest, I'm happy.",
    "start": "3237730",
    "end": "3242852"
  },
  {
    "text": "I have exactly the same\nconnectivity as before, as proved by the\nspanning forest. The trouble is when I\ndelete an edge that's",
    "start": "3242852",
    "end": "3249040"
  },
  {
    "text": "in the spanning forest. Then it's like, uh, maybe.",
    "start": "3249040",
    "end": "3254080"
  },
  {
    "text": "So here's spanning\ntree, whatever. ",
    "start": "3254080",
    "end": "3262690"
  },
  {
    "text": "And now let's say I\ndelete this edge here. Then there's a\ncouple possibilities.",
    "start": "3262690",
    "end": "3269440"
  },
  {
    "text": " It was a graph, it's not a tree.",
    "start": "3269440",
    "end": "3274480"
  },
  {
    "text": "So there could be\nsome other edge that connects those two trees. Then I have to find it. Oh, I'm going to find it.",
    "start": "3274480",
    "end": "3279550"
  },
  {
    "text": "That's going to be annoying. Or it could be\nthere's no such edge. Then I'm fine. Then it's just a cut.",
    "start": "3279550",
    "end": "3285609"
  },
  {
    "text": "But distinguishing\nthose two cases is going to be our challenge. And that's where we're going\nto lose another log factor,",
    "start": "3285610",
    "end": "3290950"
  },
  {
    "text": "but only another log factor. To only lose another log\nfactor, what we're going to do is not just store\none spanning forest.",
    "start": "3290950",
    "end": "3299560"
  },
  {
    "text": "We will store the\nspanning forest, but then we're going to\nhierarchically decompose it and say, well, yeah,\nthere's this big tree.",
    "start": "3299560",
    "end": "3308109"
  },
  {
    "text": "But some of the edges I'm going\nto put in the next level down.",
    "start": "3308110",
    "end": "3313600"
  },
  {
    "text": "Some I won't. So some subset of this forest\nwill be at the next level down. And there's going\nto be log n levels.",
    "start": "3313600",
    "end": "3319660"
  },
  {
    "text": "That's where we\nlose our log factor. And the weird thing is,\nthere's no real reason",
    "start": "3319660",
    "end": "3325060"
  },
  {
    "text": "to put things down, except we'll\nuse it as a charging scheme. We'll prove that an edge can\nonly go down log n levels.",
    "start": "3325060",
    "end": "3332740"
  },
  {
    "text": "And then it has to get deleted\nbefore it becomes relevant again. So it will let us charge\nonly log n times per edge.",
    "start": "3332740",
    "end": "3342960"
  },
  {
    "text": "OK, that's about as\ngood as I can give you a high-level overview. Now we have to see the details.",
    "start": "3342960",
    "end": "3348040"
  },
  {
    "text": "It's kind of amazing that\nthis works, but it does.",
    "start": "3348040",
    "end": "3353740"
  },
  {
    "text": "So we're going to talk\nabout the level of an edge. This is not a\ndefinition, per se.",
    "start": "3353740",
    "end": "3361970"
  },
  {
    "text": "But it's a change in\nquantity over time. As you do edge\ndeletions, some edges are going to decrease in level.",
    "start": "3361970",
    "end": "3368590"
  },
  {
    "text": "They all start at log n. Log n is going to\nbe the top level.",
    "start": "3368590",
    "end": "3374576"
  },
  {
    "text": "That's the whole\nspanning forest.  They will only decrease,\nso it's monotone.",
    "start": "3374576",
    "end": "3383319"
  },
  {
    "text": "And they can never get below 0. So we start at log n. They could go down.",
    "start": "3383320",
    "end": "3388960"
  },
  {
    "text": "And the lowest value is 0. Now, Gi is my graph.",
    "start": "3388960",
    "end": "3395349"
  },
  {
    "text": "And G is going to be the\nsubgraph of lower-level edges. ",
    "start": "3395350",
    "end": "3407785"
  },
  {
    "text": "It's going to say, level\nless than or equal to i. So in particular, G log\nn is the whole graph.",
    "start": "3407785",
    "end": "3414730"
  },
  {
    "text": " So we always include\nlower-level edges.",
    "start": "3414730",
    "end": "3420530"
  },
  {
    "text": "So level 0 is going to\nappear in all the Gi's. But if we look at G 0,\nit's only level 0 edges.",
    "start": "3420530",
    "end": "3428369"
  },
  {
    "text": "G1 is level 0 and 1. And so this is sort of a\nhierarchical decomposition of the graph. We have fewer edges\nat the bottom levels.",
    "start": "3428370",
    "end": "3434498"
  },
  {
    "text": " And there's going to\nbe two key invariants we have over these structures.",
    "start": "3434498",
    "end": "3442530"
  },
  {
    "text": "In variant one it's is going\nto be every connected component",
    "start": "3442530",
    "end": "3447740"
  },
  {
    "text": "of Gi is small. ",
    "start": "3447740",
    "end": "3463711"
  },
  {
    "text": "It's going to be size,\nat most, 2 to the i. ",
    "start": "3463711",
    "end": "3471140"
  },
  {
    "text": "This is really\nwhat's going to let us charge against something. Whenever you go down\na level, the max size",
    "start": "3471140",
    "end": "3476680"
  },
  {
    "text": "of a connected component\ngoes down by a factor of 2. So at level 0, all\ncomponents have size 1.",
    "start": "3476680",
    "end": "3483380"
  },
  {
    "text": "There are no edges at level 0. So I kind of lied. I guess the lowest level is 1.",
    "start": "3483380",
    "end": "3489320"
  },
  {
    "text": "At level 1, you can\nhave two vertices. So there can be\nisolated edges in Gi.",
    "start": "3489320",
    "end": "3495000"
  },
  {
    "text": "But that's it. You can't have a path of length\n2 in G1, and so on up the tree.",
    "start": "3495000",
    "end": "3500500"
  },
  {
    "text": "At G log n, you can\nhave the whole graph. Whole thing could be connected. But this will let us\ncharge to something",
    "start": "3500500",
    "end": "3507100"
  },
  {
    "text": "as we go down in the tree.  As we go down in\nlevels, I should say.",
    "start": "3507100",
    "end": "3513790"
  },
  {
    "start": "3513790",
    "end": "3527890"
  },
  {
    "text": "So next thing we need is a\nspanning forest for each Gi.",
    "start": "3527890",
    "end": "3532900"
  },
  {
    "text": "Fi is going to be\nspanning forest of Gi. ",
    "start": "3532900",
    "end": "3538690"
  },
  {
    "text": "So it's going to maintain the\nconnected components of Gi. And we're going to store that\nusing an Euler-tour tree.",
    "start": "3538690",
    "end": "3546300"
  },
  {
    "start": "3546300",
    "end": "3553355"
  },
  {
    "text": "There's this issue\nof pluralization. I'll say trees. Because Fi is disconnected.",
    "start": "3553355",
    "end": "3558710"
  },
  {
    "text": "Each connected\ncomponent you use, you store using an\nEuler-tour tree. Together, it's an Euler-tour\nforest, I suppose.",
    "start": "3558710",
    "end": "3567200"
  },
  {
    "text": "So that way we can do a query. And so given two\nnodes, we can know whether they're in the same\nconnected component in Fi,",
    "start": "3567200",
    "end": "3574040"
  },
  {
    "text": "just by saying whether they\nlive under the same root. ",
    "start": "3574040",
    "end": "3581089"
  },
  {
    "text": "Well, in particular,\nthat means that f log n, which is a\nspanning forest of G log n, which is everything, that\nwill let me solve queries.",
    "start": "3581090",
    "end": "3590940"
  },
  {
    "text": "This is the desired\nspanning forest that will let me ask\nconnectivity queries.",
    "start": "3590940",
    "end": "3598677"
  },
  {
    "text": "So all this\ninfrastructure is in order to support deletes efficiently. But queries are easy. We just look at the top forest.",
    "start": "3598677",
    "end": "3604730"
  },
  {
    "text": "That's the one we want. OK, now second\ninvariant, this is",
    "start": "3604730",
    "end": "3610400"
  },
  {
    "text": "where things get interesting. ",
    "start": "3610400",
    "end": "3615938"
  },
  {
    "text": "Variant 2.  The forests have to nest.",
    "start": "3615938",
    "end": "3621630"
  },
  {
    "start": "3621630",
    "end": "3627319"
  },
  {
    "text": "So F log n, of course,\nhas the most edges. F0 is going to have\nthe fewest edges.",
    "start": "3627320",
    "end": "3632420"
  },
  {
    "text": "But I want them to be contained\nin this nested structure. All this is saying is\nthat there's really only",
    "start": "3632420",
    "end": "3638000"
  },
  {
    "text": "one spanning forest, F log n. Fi is just F log n, but\nrestricted to the edges of Gi.",
    "start": "3638000",
    "end": "3650030"
  },
  {
    "text": "So really we're trying\nto represent this forest. But then, as we look\nat lower levels,",
    "start": "3650030",
    "end": "3655130"
  },
  {
    "text": "we just forget about\nthe higher-level edges. Restrict to the lower edges of\nlevel less than or equal to i,",
    "start": "3655130",
    "end": "3660200"
  },
  {
    "text": "that's our smaller force. This is, in some sense, the\nhierarchical decomposition of the forest.",
    "start": "3660200",
    "end": "3665275"
  },
  {
    "text": "Because there's really\nonly one forest. That would make our\nlives way easier.",
    "start": "3665275",
    "end": "3670640"
  },
  {
    "text": "Fun fact, is that that\nforest, then, is actually not just any spanning forest.",
    "start": "3670640",
    "end": "3676849"
  },
  {
    "text": "It's a minimum spanning\nforest, with respect to level. ",
    "start": "3676850",
    "end": "3684762"
  },
  {
    "text": "You've probably heard of\nminimum spanning tree. Minimum spanning forest\nis just the analog for disconnected graphs.",
    "start": "3684762",
    "end": "3691059"
  },
  {
    "text": " So we're defining the weight\nof an edge to be it's level.",
    "start": "3691060",
    "end": "3699000"
  },
  {
    "text": "And so F log n can't just\nbe any spanning forest. It has to prefer\nlower-level edges.",
    "start": "3699000",
    "end": "3704750"
  },
  {
    "text": "Otherwise, this nesting\nstructure won't be true. Now, that doesn't uniquely\ndefine the forest or anything.",
    "start": "3704750",
    "end": "3712005"
  },
  {
    "text": "Because maybe all\nthe levels are log n. And then every spanning forest\nis a minimum spanning forest. But it's a constraint\non spanning forest.",
    "start": "3712005",
    "end": "3720890"
  },
  {
    "text": "Cool Let's go over here. ",
    "start": "3720890",
    "end": "3748120"
  },
  {
    "text": "Let me quickly say how to do an\ninsert and how to do a query. These are really easy.",
    "start": "3748120",
    "end": "3753340"
  },
  {
    "text": "Delete is really\nwhere the action is, but just to make sure\nwe're on the same page,",
    "start": "3753340",
    "end": "3760340"
  },
  {
    "text": "and to introduce a\nlittle bit of notation, and say a little bit\nabout what we do.",
    "start": "3760340",
    "end": "3765640"
  },
  {
    "text": "We are going to store\nincidence lists, which is for every vertex, we\nhave a list of the incident",
    "start": "3765640",
    "end": "3773260"
  },
  {
    "text": "edges in a linked list. ",
    "start": "3773260",
    "end": "3779050"
  },
  {
    "text": "So in constant time, we\ncan add our edge to v and w's incidence lists. That's not maintaining any\norder or anything special.",
    "start": "3779050",
    "end": "3786250"
  },
  {
    "text": "Then we also set the level\nof the edge to the log n.",
    "start": "3786250",
    "end": "3793540"
  },
  {
    "text": "That's what I said, every\nedge starts at level log n. And then there's one\nmore thing, which is if v and w are\ndisconnected, and F log n,",
    "start": "3793540",
    "end": "3811720"
  },
  {
    "text": "we can tell that because we\ncan do a connectivity query on F log n. We have that as an\nEuler-tour tree.",
    "start": "3811720",
    "end": "3817690"
  },
  {
    "text": "So we can see whether v and w\nare in different components. If they are, we\nhave to merge them. So we merge them.",
    "start": "3817690",
    "end": "3823750"
  },
  {
    "text": "We This is what you\ncall an edge insertion. ",
    "start": "3823750",
    "end": "3832340"
  },
  {
    "text": "So this is an Euler-tour\ntree insertion, that we know how to do in log n. We reroute and we do a join.",
    "start": "3832340",
    "end": "3840507"
  },
  {
    "text": "So that's cheap. And that's it. So insertion is easy to do\nin log n time, actually.",
    "start": "3840508",
    "end": "3847930"
  },
  {
    "text": "Its deletion that's\ngoing to be painful. Actually, we're going to\ncharge through the inserts. So it'll be end up being\nlog squared amortized.",
    "start": "3847930",
    "end": "3854648"
  },
  {
    "text": "But worst case, it's log n. Great. I want to say a little\nbit about connectivity.",
    "start": "3854648",
    "end": "3861160"
  },
  {
    "text": "Now we know how to solve\nconnectivity already. We do find root on v\nand w and in log n time,",
    "start": "3861160",
    "end": "3868870"
  },
  {
    "text": "we determine whether they're\nin the same component. But I actually claimed--\nit's maybe erased by now.",
    "start": "3868870",
    "end": "3876560"
  },
  {
    "text": "Yeah. But I claim not to log n query. I claimed a log\nover log log query. Turns out, that's\nreally easy to do.",
    "start": "3876560",
    "end": "3883400"
  },
  {
    "text": "You just change the top\nlevel minimum spanning forest slightly.",
    "start": "3883400",
    "end": "3889720"
  },
  {
    "text": "So I want to make F log\nn equal to a B-tree.",
    "start": "3889720",
    "end": "3897940"
  },
  {
    "text": "Or actually, it's\na bunch of B-trees, one per connected component,\nof branching factor log n.",
    "start": "3897940",
    "end": "3905289"
  },
  {
    "text": " I guess it's a B-tree, so\nI have to have some slop.",
    "start": "3905290",
    "end": "3910600"
  },
  {
    "text": "Theta log n, let's say. Usually we said with\nEuler-tour trees,",
    "start": "3910600",
    "end": "3916720"
  },
  {
    "text": "it was a balanced\nbinary search tree. I'm going to make this\nparticular forest use a log n",
    "start": "3916720",
    "end": "3922780"
  },
  {
    "text": "way, B-tree. This is going to\nslow down updates. But it actually\nspeeds up queries.",
    "start": "3922780",
    "end": "3929710"
  },
  {
    "text": "So to do a find root is\nnow a little bit easier.",
    "start": "3929710",
    "end": "3936280"
  },
  {
    "text": "Find root should just\nbe log base log n of n,",
    "start": "3936280",
    "end": "3942790"
  },
  {
    "text": "which is log n over log log n. Because find root, you just\nneed to go to your parent,",
    "start": "3942790",
    "end": "3948250"
  },
  {
    "text": "to your parent, to your parent. Go to the top. And then you have to go\nto the leftmost place. But it's easy, in a\nB-tree, to always go",
    "start": "3948250",
    "end": "3954924"
  },
  {
    "text": "to the leftmost place. If I had to do a\nsearch within the node, that would be annoying. But going to the\nleftmost, that's easy.",
    "start": "3954924",
    "end": "3960160"
  },
  {
    "text": "So I only pay log over\nlog log for query, so I got my desired query time.",
    "start": "3960160",
    "end": "3966410"
  },
  {
    "text": "And I claim the\nupdate is kind of OK. Because it's slowed down, but\nwe're already going to pay",
    "start": "3966410",
    "end": "3971530"
  },
  {
    "text": "log square eventually. And here we were doing log. So we don't need\nto be that fast.",
    "start": "3971530",
    "end": "3980080"
  },
  {
    "text": "Update is now going to be-- let's see-- the\nheight of the tree",
    "start": "3980080",
    "end": "3989289"
  },
  {
    "text": "times the branching factor.  If we touch nodes in\na root-to-leaf path,",
    "start": "3989290",
    "end": "3997869"
  },
  {
    "text": "there's log over\nlog log of them. For each one, we have to\nrewrite the whole node. So we pay log. But this is less\nthan log squared.",
    "start": "3997870",
    "end": "4004660"
  },
  {
    "start": "4004660",
    "end": "4009970"
  },
  {
    "text": "So this won't end up hurting us. Because we only do this\nat the top forest level. We don't do it at\nall the levels.",
    "start": "4009970",
    "end": "4015580"
  },
  {
    "text": "If we did it at\nall the levels, we would lose another log factor,\nlog over log log factor. But here, we do this\nonce at the top,",
    "start": "4015580",
    "end": "4022960"
  },
  {
    "text": "pay log squared over log log. Then we have to update log n\nother levels, each paying log. So we're already paying log\nsquared for the lower level.",
    "start": "4022960",
    "end": "4029450"
  },
  {
    "text": "So if we increase the top\nlevel a bit, not a big deal. So that's how you improve\nconnectivity queries slightly.",
    "start": "4029450",
    "end": "4038230"
  },
  {
    "text": "And now, finally,\nwe get to deletes. This is the moment\nyou've been waiting for.",
    "start": "4038230",
    "end": "4044188"
  },
  {
    "text": "How do we do a delete\nin this structure? What are all these\nlevels good for?",
    "start": "4044188",
    "end": "4049270"
  },
  {
    "start": "4049270",
    "end": "4062860"
  },
  {
    "text": "So we're deleting an edge e. Its endpoints are v and w.",
    "start": "4062860",
    "end": "4068260"
  },
  {
    "text": "First thing we do is remove\ne from the incidence list. ",
    "start": "4068260",
    "end": "4079676"
  },
  {
    "text": "If every edge stores\na pointer to where it lives in the\nincidence list, you can do that deletion\nin constant time.",
    "start": "4079676",
    "end": "4085578"
  },
  {
    "text": "Great. So as I said, if e is\nnot in this forest--",
    "start": "4085578",
    "end": "4094530"
  },
  {
    "start": "4094530",
    "end": "4101670"
  },
  {
    "text": "what if it's in a\nlower level of forest? ",
    "start": "4101670",
    "end": "4107220"
  },
  {
    "text": "Oh, I see, right. I forgot. In variant two, variant two\nsays the forests are nested.",
    "start": "4107220",
    "end": "4112930"
  },
  {
    "text": "So if it's in any forest, it's\ngoing to be in the last one. So if it's not in\nthe last one, that means it's not in\nany of the forests.",
    "start": "4112930",
    "end": "4119160"
  },
  {
    "text": "That means we're done. We do nothing. That's the easy case. We didn't destroy\nany connectivity,",
    "start": "4119160",
    "end": "4124950"
  },
  {
    "text": "because the forests represent\nmaximal connectivity. They're spanning. But if it's in the forest,\nthen something changed.",
    "start": "4124950",
    "end": "4132120"
  },
  {
    "text": "Then we need to determine,\nlike in this picture, is there a replacement edge? Or is there no replacement edge?",
    "start": "4132120",
    "end": "4138880"
  },
  {
    "text": "In which case, when there's\nno replacement edge, we basically don't do anything. We have to do a bunch of\ndeletes in the forests.",
    "start": "4138880",
    "end": "4146859"
  },
  {
    "text": "But yeah, is that what\nI want to say next? Yes, we always do that.",
    "start": "4146859",
    "end": "4153430"
  },
  {
    "text": "We're going to delete e. We have to delete e. So we're going to recursively\ndelete it from f sub e dot",
    "start": "4153430",
    "end": "4164489"
  },
  {
    "text": "level up to F log n. e\ndot level is the earliest",
    "start": "4164490",
    "end": "4171814"
  },
  {
    "text": "forest it appears in. And we have to delete\nit from all those. Each of those is an Euler-tour\ntree deletion, or cut.",
    "start": "4171814",
    "end": "4177770"
  },
  {
    "text": "And so each of them pays log\nn total cost log squared n. So this is where the log\nsquared's coming from.",
    "start": "4177770",
    "end": "4182790"
  },
  {
    "text": "That's great. Now we've successfully\ndeleted the edge. But now we need to know,\nis there a replacement?",
    "start": "4182790",
    "end": "4188609"
  },
  {
    "text": "And at what level is\nthere a replacement? Now, we know by invariant\n2, that there could be",
    "start": "4188609",
    "end": "4196380"
  },
  {
    "text": "no replacement of lower level. The point is, this is a\nminimum spanning tree.",
    "start": "4196380",
    "end": "4203300"
  },
  {
    "text": "So e was the lowest\nlevel edge that could connect the two sides,\nthese two connected components",
    "start": "4203300",
    "end": "4208710"
  },
  {
    "text": "of the forest. So if there's any replacements\nat e's level or higher,",
    "start": "4208710",
    "end": "4215160"
  },
  {
    "text": "there might not be a\nreplacement at e dot level. But there might be a\nreplacement at a higher level. We want to find the smallest\nlevel for which there",
    "start": "4215160",
    "end": "4221023"
  },
  {
    "text": "is a replacement. That will preserve\ninvariant 2, that we have a minimum spanning forest.",
    "start": "4221023",
    "end": "4226889"
  },
  {
    "text": "So that's what we're going\nto do, loop over the levels to try to find a\nreplacement edge.",
    "start": "4226890",
    "end": "4232500"
  },
  {
    "text": "So we're going to start\nat e dot level, loop potentially up to log\nn, call it a level i.",
    "start": "4232500",
    "end": "4241739"
  },
  {
    "text": "Then I want to identify,\nat level i, the two sides of the edge.",
    "start": "4241740",
    "end": "4247320"
  },
  {
    "text": "Let Tv and Tw be the trees\nof Fi, containing v and w,",
    "start": "4247320",
    "end": "4258810"
  },
  {
    "text": "respectively. We just deleted the edge\nconnecting those two sides. So we know that they're in two\ndifferent trees, Tv and Tw.",
    "start": "4258810",
    "end": "4267310"
  },
  {
    "text": "And one of them is\nsmaller than the other. I'd like to relabel v and\nw so that the size of Tv",
    "start": "4267310",
    "end": "4275100"
  },
  {
    "text": "is less than or equal\nto the size of Tw, size, in terms of number of vertices\nfrom there in the tree.",
    "start": "4275100",
    "end": "4284240"
  },
  {
    "text": "So swapped v and w if necessary. Here's the fun thing. If we apply invariant\n1, then we learn",
    "start": "4284240",
    "end": "4298520"
  },
  {
    "text": "these sizes are not so big. Claim, at most, 2 to the i. As you realize it's\nalmost 2 to the i,",
    "start": "4298520",
    "end": "4305130"
  },
  {
    "text": "you have to imagine the moment\nbefore this deletion happened, before we deleted the edge. Because at that point, Tv and\nTw were actually one tree.",
    "start": "4305130",
    "end": "4313240"
  },
  {
    "text": "They were connected by edge e. We've just deleted them. But the moment before we\ndeleted them, invariant 1 held.",
    "start": "4313240",
    "end": "4319090"
  },
  {
    "text": "And so that was a\nconnected component. It should have size,\nat most, 2 to the i. Now, we split it. But that's all we've done.",
    "start": "4319090",
    "end": "4324820"
  },
  {
    "text": "So the sum of those sizes\nhas to be at most 2 to the i. Because that used to be\na connected component.",
    "start": "4324820",
    "end": "4330760"
  },
  {
    "text": "Cool So that means that size of Tv\nis 1/2 that, at most 2 to i",
    "start": "4330760",
    "end": "4339190"
  },
  {
    "text": "minus 1. Because Tv is less\nthan or equal to Tw. So it's, at most,\n1/2 of the total.",
    "start": "4339190",
    "end": "4346980"
  },
  {
    "text": "So Tv is even smaller. In particular, what\nthat tells us-- now we have Tv and Tw as\nkind of separate components",
    "start": "4346980",
    "end": "4353740"
  },
  {
    "text": "temporarily-- we don't really know that\nthey're separate at level i. But we know at level i\nminus 1 they are separate.",
    "start": "4353740",
    "end": "4361159"
  },
  {
    "text": "At level i minus 1, there\nis no replacement edge, by the minimum spanning\nforest property. So what we could\ndo, at this point,",
    "start": "4361159",
    "end": "4369469"
  },
  {
    "text": "is take Tv, take all of\nthe edges internal to Tv, and push them down\nto level i minus 1.",
    "start": "4369470",
    "end": "4375860"
  },
  {
    "text": "We could afford that. What do I mean by we\ncould afford that? We wouldn't destroy invariant 1.",
    "start": "4375860",
    "end": "4381165"
  },
  {
    "text": "Because we're taking\n2 to the i minus 1 vertices, pushing\nall those edges down. We don't have to\npush all of them.",
    "start": "4381166",
    "end": "4387170"
  },
  {
    "text": "We could push some\nsubset of the edges down. Whatever connectivity\ncomponent we make at that level will be of size at\nmost 2 to d, i minus 1,",
    "start": "4387170",
    "end": "4394325"
  },
  {
    "text": "and so invariant 1\nwill be preserved.  So great.",
    "start": "4394325",
    "end": "4399950"
  },
  {
    "text": "We can afford in\nthis certain sense of",
    "start": "4399950",
    "end": "4405220"
  },
  {
    "text": "\"afford,\" to push all of Tv's\nedges to level i minus 1.",
    "start": "4405220",
    "end": "4420702"
  },
  {
    "text": " Great",
    "start": "4420702",
    "end": "4428080"
  },
  {
    "text": "We don't actually\nneed to do this. But what we're going to do\nis use it to pay for stuff.",
    "start": "4428080",
    "end": "4434469"
  },
  {
    "start": "4434470",
    "end": "4442150"
  },
  {
    "text": "We have this scary\ngoal, which is we want to find is there\na replacement edge? I don't know a good way to\nfind a replacement edge,",
    "start": "4442150",
    "end": "4448810"
  },
  {
    "text": "except to do, basically,\na depth first search and look at all the edges. That's going to\ntake a lot of time.",
    "start": "4448810",
    "end": "4455090"
  },
  {
    "text": "But the good news\nis, if we search from Tv, every edge\nthat's useless,",
    "start": "4455090",
    "end": "4461020"
  },
  {
    "text": "we can just decrease its level. And whenever we decrease\nthe level of an edge, we basically get a\nfree coin to continue.",
    "start": "4461020",
    "end": "4468260"
  },
  {
    "text": "So you get a free\nlife every time you push an edge down by one level. Because overall,\nnumber of pushes",
    "start": "4468260",
    "end": "4474280"
  },
  {
    "text": "can be number\ninsertions times log n.",
    "start": "4474280",
    "end": "4480550"
  },
  {
    "text": "Because every edge can only\nbe pushed long n times. So whenever we push down an\nedge, we get a free bonus life,",
    "start": "4480550",
    "end": "4488080"
  },
  {
    "text": "so we can keep doing our search. So here's how the search works. I'm going to say, for each--",
    "start": "4488080",
    "end": "4497335"
  },
  {
    "text": "this is a little bit\ntricky to implement. I'm going to first tell\nyou what we want to do",
    "start": "4497335",
    "end": "4502900"
  },
  {
    "text": "and why that's OK. And then we'll see\nhow we actually do it. ",
    "start": "4502900",
    "end": "4510730"
  },
  {
    "text": "So I want to search\nfrom every vertex in Fv. I want to look at all the\noutgoing edges from there",
    "start": "4510730",
    "end": "4517469"
  },
  {
    "text": "of level i. Never mind how to\nfind those edges. Just pretend you could find\nit in constant time per edge.",
    "start": "4517470",
    "end": "4525610"
  },
  {
    "text": "It's going to be\nlog n time per edge. But that's OK. It's two cases.",
    "start": "4525610",
    "end": "4532060"
  },
  {
    "text": "Either y is in Tw. Otherwise, y is\ngoing to be in Tv.",
    "start": "4532060",
    "end": "4539320"
  },
  {
    "text": " Because we have Tv here.",
    "start": "4539320",
    "end": "4544850"
  },
  {
    "text": "We have Tw. We just deleted this edge, e.",
    "start": "4544850",
    "end": "4550240"
  },
  {
    "text": "Sadly, we want to find\na replacement edge. So if we look at all the edges\ncoming out of a vertex in Tv,",
    "start": "4550240",
    "end": "4556210"
  },
  {
    "text": "this is, I guess, x. It could be it's an edge\nthat stays within Tv. Or could be it's an\nedge that goes to Tw.",
    "start": "4556210",
    "end": "4562750"
  },
  {
    "text": "There are no other options,\nbecause of our invariants. If it's in Tv, oh,\nthat's kind of annoying.",
    "start": "4562750",
    "end": "4569469"
  },
  {
    "text": "Doesn't help us. But then we can just set\nthe level of that edge,",
    "start": "4569470",
    "end": "4574960"
  },
  {
    "text": "e-prime, to be i minus 1.",
    "start": "4574960",
    "end": "4580072"
  },
  {
    "text": "Because we can afford\nto push all of these edges down by one level. So that pays for this\nround of the loop.",
    "start": "4580072",
    "end": "4586480"
  },
  {
    "text": " What about the other case?",
    "start": "4586480",
    "end": "4591670"
  },
  {
    "text": "The other cases\nis the good case. That means we've found a\nreplacement edge for e. If we have an edge\nfrom Tv to Tw.",
    "start": "4591670",
    "end": "4598260"
  },
  {
    "text": "And at level i, we did\nthese levels in order. Did I say that? Yeah, we're doing\nlevels in order.",
    "start": "4598260",
    "end": "4604930"
  },
  {
    "text": "So if we can find this is the\nlowest level replacement edge, so we do it.",
    "start": "4604930",
    "end": "4609960"
  },
  {
    "text": "We insert that edge into\nFi using an Euler-tour tree",
    "start": "4609960",
    "end": "4618370"
  },
  {
    "text": "insertion. And then we're done. So we stop the algorithm.",
    "start": "4618370",
    "end": "4625260"
  },
  {
    "text": "The moment we find a\ndesired edge we're happy. Now, maybe there\nare lots of edges. So we've got to stop when\nwe find the first one.",
    "start": "4625260",
    "end": "4630910"
  },
  {
    "text": "Then we've restored our minimum\nspanning forest property. We have maximal connectivity,\nall these great things.",
    "start": "4630910",
    "end": "4637650"
  },
  {
    "text": "As long as we\ndon't find an edge, we can push things down a\nlevel and pay for this round. So it's constant time or log\nn time to do the last step.",
    "start": "4637650",
    "end": "4645237"
  },
  {
    "text": "But all the other steps are paid\nfor by the decrease in level. ",
    "start": "4645237",
    "end": "4651869"
  },
  {
    "text": "So the claim is overall,\nwe pay log squared n. Because we had to do log\nsquared n for these deletions.",
    "start": "4651870",
    "end": "4658860"
  },
  {
    "text": "Plus log n times the\nnumber of level decreases.",
    "start": "4658860",
    "end": "4668739"
  },
  {
    "text": " That's for this step. I claim that each round\nof this loop cost log n.",
    "start": "4668740",
    "end": "4676971"
  },
  {
    "text": "So that's why we've\nget log n times number of level decreases. But number of level\ndecreases is, at most,",
    "start": "4676972",
    "end": "4682150"
  },
  {
    "text": "number of edge\ninsertions times log n. Because each edge can\nonly decrease in level",
    "start": "4682150",
    "end": "4687250"
  },
  {
    "text": "log n times, by\ndefinition of levels. And so we can charge to\nthe insert operations",
    "start": "4687250",
    "end": "4692320"
  },
  {
    "text": "at a factor of log n. So there's two log n's here. So inserts now cost log\nsquared amortized as well.",
    "start": "4692320",
    "end": "4700500"
  },
  {
    "text": "To deletes costs log\nsquared amortized. And we get log squared overall. One last issue though, which\nis how do we do this step?",
    "start": "4700500",
    "end": "4708760"
  },
  {
    "text": "Actually, there's another\nstep that's not so trivial, this one. We need to know the size\nof Tv and the size of Tw.",
    "start": "4708760",
    "end": "4715540"
  },
  {
    "text": "Well, that's easy. I just store subtree\nsizes at every node. So then I look at\nthe root of the BST,",
    "start": "4715540",
    "end": "4721720"
  },
  {
    "text": "and it tells me how\nbig that tree is. And so I can see which is\nbigger and switch accordingly.",
    "start": "4721720",
    "end": "4727420"
  },
  {
    "text": "But that's trivial. This one requires a\ndifferent augmentation for Euler-tour trees.",
    "start": "4727420",
    "end": "4734840"
  },
  {
    "text": "And again, in both\nof these situations, we're using the fact that we\ncan augment on subtrees, not on paths. That's why we need Euler-tour\ntrees, not link cut trees.",
    "start": "4734840",
    "end": "4742910"
  },
  {
    "text": "So what we store in F-- why did I write Fv?",
    "start": "4742910",
    "end": "4748690"
  },
  {
    "text": "I mean Tv here. ",
    "start": "4748690",
    "end": "4755000"
  },
  {
    "text": "So in Fi-- this is for each i,\nbut at the forest at level i-- what I'm going to store is at\nevery node in the Euler-tour",
    "start": "4755000",
    "end": "4762970"
  },
  {
    "text": "tree, I want to know in the\nsubtree rooted in that node--",
    "start": "4762970",
    "end": "4768830"
  },
  {
    "text": "so here's Euler-tour tree. Here's a node, v.\nThis is a tree in Fi.",
    "start": "4768830",
    "end": "4775405"
  },
  {
    "text": "I want to know, in\nthis subtree, in here, is there any node that has a\nlevel i edge incident to it?",
    "start": "4775405",
    "end": "4786180"
  },
  {
    "text": "So I want to know, are\nthere any level i edges? ",
    "start": "4786180",
    "end": "4793366"
  },
  {
    "text": "If there aren't any\nlevel i edges, then for the purposes\nof this search, I should just skip that subtree.",
    "start": "4793366",
    "end": "4798929"
  },
  {
    "text": "It's as if the\nsubtree was erased. So I have some tree. It has height log n overall.",
    "start": "4798930",
    "end": "4804619"
  },
  {
    "text": "I erase some of the\nsubtrees according to this bit, which is an\neasy thing to keep track of. It's an augmentation,\nconstant factor overhead.",
    "start": "4804620",
    "end": "4813670"
  },
  {
    "text": "Then I basically want to\ndo an in-order traversal of this tree, but\nskipping the stuff below.",
    "start": "4813670",
    "end": "4820460"
  },
  {
    "text": "So I mean, one way to think of\nit is you just repeatedly call successor, like successor\nin a binary search tree.",
    "start": "4820460",
    "end": "4826047"
  },
  {
    "text": "But whenever I see that there's\nno level edges below me, I just skip. So in log n time you can\nbasically find the next place",
    "start": "4826047",
    "end": "4833719"
  },
  {
    "text": "where there's an outgoing edge. I guess also, the\nincidence lists have to be stored\nseparately for each level.",
    "start": "4833720",
    "end": "4840090"
  },
  {
    "text": "So you can say, what are\nyour outgoing level i edges from a vertex? This lets you find\nthe vertex quickly, but then you have to\nfind the edges quickly.",
    "start": "4840090",
    "end": "4847040"
  },
  {
    "text": "So the instance lists are not\njust stored as one single link lists, one link list per level.",
    "start": "4847040",
    "end": "4852510"
  },
  {
    "text": "But that's easy to do. So then from this, vertex we\ncan find all the outgoing level i edges.",
    "start": "4852510",
    "end": "4857870"
  },
  {
    "text": "And we can do this\n4 loop efficiently. And whenever it's\nlow, we get to charge.",
    "start": "4857870",
    "end": "4865705"
  },
  {
    "text": "In the remaining\nnegative two minutes, let me tell you briefly\nabout other problems that",
    "start": "4865705",
    "end": "4871142"
  },
  {
    "text": "have been solved. So this finishes log squared\nn fully dynamic connectivity. I wasn't planning to spend\nmuch time on this anyway.",
    "start": "4871142",
    "end": "4877550"
  },
  {
    "text": "There are notes. If you're interested in\nthe specific problems, I'll just tell you\nwhat the problems are. Generalization of connectivity\nis k connectivity.",
    "start": "4877550",
    "end": "4883820"
  },
  {
    "text": "I don't just want to know, is\nthere one path from v to w? I want to know are there k\ndisjoint paths from v to w?",
    "start": "4883820",
    "end": "4890450"
  },
  {
    "text": "So they could be edge-disjoint\nor vertex-disjoint paths, might be your goal.",
    "start": "4890450",
    "end": "4896600"
  },
  {
    "text": "In that case, poly\nlog solutions are known for 2 connectivity\nedge or vertex.",
    "start": "4896600",
    "end": "4903752"
  },
  {
    "text": "This is the result, actually,\nI used in my very first graph algorithms papers, where I first\nlearned about dynamic graphs.",
    "start": "4903752",
    "end": "4909380"
  },
  {
    "text": "In log to the fourth n time,\nyou can maintain 2 edge connectivity.",
    "start": "4909380",
    "end": "4914480"
  },
  {
    "text": "It's open for k equals\n3, even, whether you",
    "start": "4914480",
    "end": "4920570"
  },
  {
    "text": "can achieve that bound. So kind of lame. Another problem is\nminimum spanning forest.",
    "start": "4920570",
    "end": "4926847"
  },
  {
    "text": "So you don't just want to\nmaintain some spanning forest. Maybe you actually have\nweights on the edges and you want the\nminimum spanning for us.",
    "start": "4926847",
    "end": "4932517"
  },
  {
    "text": "That it turns out, you can\nsolve with a couple extra log factors. So in log to the fourth\nn time, with an extra log",
    "start": "4932517",
    "end": "4939996"
  },
  {
    "text": "squared factor, you can\nreduce to the problem of dynamic connectivity. And so log to the\nforth overall, you can maintain minimum\nspanning forest.",
    "start": "4939996",
    "end": "4947408"
  },
  {
    "text": "Another problem is\nplanarity testing. You want to insert or delete\nedges and, at all points, know whether your\ngraph is planar.",
    "start": "4947409",
    "end": "4954980"
  },
  {
    "text": "And that, there's no great\nresults known for that. It's like n to the 2/3.",
    "start": "4954980",
    "end": "4960810"
  },
  {
    "text": "Directed graphs,\nthings get really hard. There are two problems\nI've surveyed here.",
    "start": "4960810",
    "end": "4966844"
  },
  {
    "text": "There's probably more. But the most\nfundamental questions are the analog of\nconnectivity is",
    "start": "4966844",
    "end": "4972260"
  },
  {
    "text": "what I call dynamic\ntransitive closure, which means given two vertices,\nv and w, I want to know,",
    "start": "4972260",
    "end": "4978680"
  },
  {
    "text": "is there a directed path from\nv to w instead of undirected? At the moment, a\nbunch of results",
    "start": "4978680",
    "end": "4985520"
  },
  {
    "text": "match a trade-off curve\nwhich should be update times",
    "start": "4985520",
    "end": "4990890"
  },
  {
    "text": "query is roughly m times n, a\nnumber of edges times number of vertices.",
    "start": "4990890",
    "end": "4996830"
  },
  {
    "text": "This is big. But there are a bunch of results\nthat achieve this trade-off.",
    "start": "4996830",
    "end": "5003550"
  },
  {
    "text": "I don't think I'm\nmatching lower bound. But it's also open, whether\nthis entire trade-off",
    "start": "5003550",
    "end": "5008920"
  },
  {
    "text": "curve could be achieved. There's various points on\nthe curve where you pay square root of n for an update.",
    "start": "5008920",
    "end": "5014050"
  },
  {
    "text": "Then you pay like,\nm times square root of n for the query or vice\nversa, stuff like that.",
    "start": "5014050",
    "end": "5020330"
  },
  {
    "text": "And then a harder\nversion of this is you have weights\non the edges. And now the query is\nnot just find a path, find the shortest path.",
    "start": "5020330",
    "end": "5027460"
  },
  {
    "text": "This is what I call dynamic\nall pairs shortest paths. This is even harder. There are some results where you\ncan do like, roughly, n squared",
    "start": "5027460",
    "end": "5036040"
  },
  {
    "text": "time updates constant query. So it's maybe similar\ntype of trade-off curves, not really known.",
    "start": "5036040",
    "end": "5043630"
  },
  {
    "text": "When all the weights\nof the edges are 1, you just want to find the\nshortest path in terms of the number of edges, you can\ndo not really that much better.",
    "start": "5043630",
    "end": "5051910"
  },
  {
    "text": "Still, this is the product. But at least more of the\ntrade curve has been solved.",
    "start": "5051910",
    "end": "5057160"
  },
  {
    "text": "So that's a quick overview of\ndynamic graphs, more generally. Dynamic graphs come up all\nover the place, obviously.",
    "start": "5057160",
    "end": "5063720"
  },
  {
    "text": "You have network where the\nlinks are changing, or Facebook, you want to maintain\nconnections but people friend",
    "start": "5063720",
    "end": "5069385"
  },
  {
    "text": "and de-friend all the time. So you want to maintain whatever\nstructure you care about.",
    "start": "5069385",
    "end": "5075000"
  },
  {
    "text": "Anyway, that's dynamic\ngraphs upper bounds. Next class will be\nlower bounds, the log n.",
    "start": "5075000",
    "end": "5081500"
  }
]