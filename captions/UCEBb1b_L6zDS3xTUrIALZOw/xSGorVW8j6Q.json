[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: Today,\nwe continue our theme on integer data structures.",
    "start": "18450",
    "end": "24217"
  },
  {
    "text": "And we're going to cover\none data structure called fusion trees, which introduces\na bunch of cool concepts using,",
    "start": "24217",
    "end": "31070"
  },
  {
    "text": "you might call bit tricks,\nusing the word level parallelism to do lots of great things.",
    "start": "31070",
    "end": "37329"
  },
  {
    "text": "To do those great things we\nneed to do something called sketching, which is essentially\ntaking w-bit integers",
    "start": "37329",
    "end": "43040"
  },
  {
    "text": "and making them\nless than w-bits, but still having enough\nstuff that we care about. And then we can actually\ncompute those sketches",
    "start": "43040",
    "end": "50660"
  },
  {
    "text": "using integer multiplication\nin a very clever way. And given a bunch of\nthese slightly less than w",
    "start": "50660",
    "end": "58520"
  },
  {
    "text": "bit numbers we can\ncompare several for the price of one operation\nas a parallel comparison.",
    "start": "58520",
    "end": "65700"
  },
  {
    "text": "And then a particularly\nnifty thing, which is new this time I\nhaven't covered it before,",
    "start": "65700",
    "end": "71120"
  },
  {
    "text": "is how to compute\nthe leftmost 1 bit in a w-bit integer in\nconstant time, all very cool.",
    "start": "71120",
    "end": "79790"
  },
  {
    "text": "And so we're going to\ncombine all these techniques and get fusion trees. What do fusion trees\ngive us in the end?",
    "start": "79790",
    "end": "85040"
  },
  {
    "start": "85040",
    "end": "90950"
  },
  {
    "text": "Basically, the goal is to get\nlog base w of n, predecessor",
    "start": "90950",
    "end": "96619"
  },
  {
    "text": "and successor. So we're again talking about\nthe predecessor problem.",
    "start": "96620",
    "end": "103040"
  },
  {
    "text": "We did log of w last time with\nvan Emde Boas and y-fast tries.",
    "start": "103040",
    "end": "109430"
  },
  {
    "text": "So then with the two\nof them together, we get log w and log base w of n.",
    "start": "109430",
    "end": "116750"
  },
  {
    "text": "The min of those\ntwo things is always at most root log n, but\nsometimes much better",
    "start": "116750",
    "end": "123470"
  },
  {
    "text": "than that. So fusion trees are\ngreat when w is big, van Emde Boas was good\nwhen w was smallish.",
    "start": "123470",
    "end": "130250"
  },
  {
    "text": "Like poly log n, van\nEmde Boas is optimal. Here, we're thinking\nabout w being closer to n,",
    "start": "130250",
    "end": "140120"
  },
  {
    "text": "or maybe n to the\nepsilon or something. Then we get constant time,\nif it's n to the epsilon.",
    "start": "140120",
    "end": "145950"
  },
  {
    "text": "Anyway, the version we're\ngoing to cover is static. ",
    "start": "145950",
    "end": "153140"
  },
  {
    "text": "And it's linear space, and\nit runs on the good old word",
    "start": "153140",
    "end": "160850"
  },
  {
    "text": "RAM, which you may\nrecall is regular C operations on w-bit words.\nw is at least log n,",
    "start": "160850",
    "end": "168504"
  },
  {
    "text": "so you can do random access.  And anything else?",
    "start": "168504",
    "end": "175069"
  },
  {
    "text": "I think that's the\nversion we will cover. And that is the original\nversion of Fredman and Willard,",
    "start": "175070",
    "end": "180230"
  },
  {
    "text": "and it was invented\nin 1990, which was one year after the\ncold fusion debacle.",
    "start": "180230",
    "end": "186060"
  },
  {
    "text": "So this may be where\nthis name came from. There's other reasons it might\nbe called fusion trees, which",
    "start": "186060",
    "end": "191329"
  },
  {
    "text": "we'll get to.  Cool. So now, there's other\nversions of fusion trees",
    "start": "191330",
    "end": "196940"
  },
  {
    "text": "which I will not cover, but\njust so you know about them. And in some sense we\nwill pseudo cover them.",
    "start": "196940",
    "end": "203510"
  },
  {
    "text": " There's a version\nfor an AC0 RAM.",
    "start": "203510",
    "end": "210526"
  },
  {
    "text": "This is a model we\nhaven't talked about. It's another version of\na trans-dichotomous RAM,",
    "start": "210526",
    "end": "216799"
  },
  {
    "text": "somewhere off to the\nside next to word RAM. AC0 is a circuit model. And it's basically any constant\ndepth circuit of unbounded fan",
    "start": "216800",
    "end": "230090"
  },
  {
    "text": "in and fan out. ",
    "start": "230090",
    "end": "237950"
  },
  {
    "text": "And so in particular\nwhat AC0 forbids are operations like\nmultiplication.",
    "start": "237950",
    "end": "243805"
  },
  {
    "text": " I think this used to be a\nbigger deal than it is today.",
    "start": "243805",
    "end": "251769"
  },
  {
    "text": "I think multiplication used\nto be in order of magnitude slower than integer addition. I checked on current\nIntel architecture.",
    "start": "251769",
    "end": "258394"
  },
  {
    "text": "It's about 3 times\nslower than an addition, because of pipelining a\nlot of things get cheaper.",
    "start": "258395",
    "end": "263660"
  },
  {
    "text": "But in some theoretical\nsense, multiplication is worse than a lot\nof other operations,",
    "start": "263660",
    "end": "268879"
  },
  {
    "text": "because you need to have\na log and depth circuit. So you can't quite get\nas much parallelism",
    "start": "268880",
    "end": "274476"
  },
  {
    "text": "as you can with\ninteger addition. If you don't know\nabout circuit models, don't worry about it too much. But AC0 means no multiplication,\nsort of simpler operations.",
    "start": "274476",
    "end": "282259"
  },
  {
    "text": "The weird thing\nabout the AC0 RAM is it lets you do weird things,\nwhich are AC0, but are not",
    "start": "282260",
    "end": "289009"
  },
  {
    "text": "in C. So you could look\nat the intersection of AC0 RAM and word RAM, and that\nwould basically be word RAM",
    "start": "289010",
    "end": "294830"
  },
  {
    "text": "without multiplication. But AC0 RAM allows\nother operations as long as there's some\ncircuit that can compute them.",
    "start": "294830",
    "end": "301876"
  },
  {
    "text": "Sometimes they're\nreasonable operations like most significant set\nbit is an AC0 operation. So, you don't have to do any\nwork to get this operation.",
    "start": "301876",
    "end": "310639"
  },
  {
    "text": "So, in some sense this\nmakes your life easier. In other ways it makes\nyour life harder, because there is\nno multiplication and we're going to\nuse multiplication",
    "start": "310640",
    "end": "317449"
  },
  {
    "text": "to compute sketches\nand other things. So it's both better and worse.",
    "start": "317450",
    "end": "323390"
  },
  {
    "text": "This is by Anderson\nand others a few years after the original fusion trees.",
    "start": "323390",
    "end": "329780"
  },
  {
    "text": "More interesting\nis that there are-- so this is a version\nof fusion trees.",
    "start": "329780",
    "end": "335690"
  },
  {
    "text": "More interesting are the dynamic\nversions of fusion trees. ",
    "start": "335690",
    "end": "341990"
  },
  {
    "text": "So there's one that\nthe first version--",
    "start": "341990",
    "end": "347914"
  },
  {
    "text": "it's actually published later. ",
    "start": "347915",
    "end": "360330"
  },
  {
    "text": "There's a general trick\nfor dynamizing static data structures. We actually saw one. You may recall weight balanced\nsearch trees was a way",
    "start": "360330",
    "end": "367169"
  },
  {
    "text": "to dynamize a static\ndata structure. It turns out it doesn't work\nso great on fusion trees.",
    "start": "367170",
    "end": "373260"
  },
  {
    "text": "Because the time to build a\nfusion tree is polynomial. It's not linear.",
    "start": "373260",
    "end": "379364"
  },
  {
    "text": "And so that's kind of annoying. You need polynomial time\nto build this thing. So weight balance is not enough\nto slow down the rebuilds.",
    "start": "379364",
    "end": "386830"
  },
  {
    "text": "There's another structure,\nwhich we won't cover, called exponential search trees. It has this log log n overhead.",
    "start": "386830",
    "end": "393129"
  },
  {
    "text": "But other than that, it gives\nyou a nice time dynamization. So these are updates.",
    "start": "393130",
    "end": "398540"
  },
  {
    "text": " There's another version\nwhich uses hashing,",
    "start": "398540",
    "end": "406370"
  },
  {
    "text": "and achieves log base w\nexpected time for updates.",
    "start": "406370",
    "end": "414210"
  },
  {
    "text": "This is by Raman. And so this gives you matching\nthe fusion tree query bound,",
    "start": "414210",
    "end": "424350"
  },
  {
    "text": "you can do inserts and deletes,\nthe same amount of time if you allow expected. And essentially the idea is to\ndo sketches more like hashing.",
    "start": "424350",
    "end": "433110"
  },
  {
    "text": "I mean, think of sketching\nas just hashing down to a smaller universe. And in expectation\nthat will work well,",
    "start": "433110",
    "end": "438990"
  },
  {
    "text": "although it's open,\nactually, whether you can achieve this bound\nwith high probability.",
    "start": "438990",
    "end": "444870"
  },
  {
    "text": " So it's an interesting\nopen question.",
    "start": "444870",
    "end": "451800"
  },
  {
    "text": " So that's the various\nversions of fusion trees.",
    "start": "451800",
    "end": "457269"
  },
  {
    "text": "But we're going to just\ncover the static ones, because they're\ninteresting enough. Dynamic ones are not that\nmuch harder than the regular.",
    "start": "457269",
    "end": "465879"
  },
  {
    "text": "So how do we achieve\nlog base w of n? Well we've already seen B-trees\nwhich achieve log base b of n.",
    "start": "465880",
    "end": "472080"
  },
  {
    "text": "So presumably it's\nthe same idea, and indeed that's what we'll do.",
    "start": "472080",
    "end": "479340"
  },
  {
    "text": "What we want is a B-tree with\nbranching factor ideally w.",
    "start": "479340",
    "end": "487520"
  },
  {
    "text": "We can't quite achieve w though. So it's going to be w to\nsome small constant power.",
    "start": "487520",
    "end": "493780"
  },
  {
    "text": "And 1/5 is the one that\nI'll use in this lecture. You can improve it or\nmake it worse, up to you.",
    "start": "493780",
    "end": "501150"
  },
  {
    "text": "But any constant\nup here will do. Because then log\nbase w to the 1/5 is going to be five\ntimes log base w of n.",
    "start": "501150",
    "end": "510590"
  },
  {
    "text": "So we have a node. So it has branching\nfactor w to the 1/5.",
    "start": "510590",
    "end": "516539"
  },
  {
    "text": " Then the height of\nthe tree, of course,",
    "start": "516539",
    "end": "522150"
  },
  {
    "text": "is theta log base w of n. So that's all good. But now what we need to\ndo is, doing a predecessor",
    "start": "522150",
    "end": "529230"
  },
  {
    "text": "search given a node, we need to\ndecide in constant time which branch has our answer.",
    "start": "529230",
    "end": "535680"
  },
  {
    "text": "So normally in a B-tree you\nwould read in all these keys, and then compare your\nitem to all of them,",
    "start": "535680",
    "end": "542310"
  },
  {
    "text": "and then decide which way to go. Because in a B-tree we can\nread all of these items in one operation.",
    "start": "542310",
    "end": "548400"
  },
  {
    "text": "Now here, is that possible? Think about it. You've got each of these\nkeys is w bits long.",
    "start": "548400",
    "end": "554640"
  },
  {
    "text": "There's w to the 1/5 of them. So the total number\nof bits in the node",
    "start": "554640",
    "end": "562890"
  },
  {
    "text": "to store all those keys is w to\nthe 1 plus 1/5, which is a lot.",
    "start": "562890",
    "end": "569460"
  },
  {
    "text": "There's no way you can read all\nthose bits in constant time. You can only read order\nw bits in constant time.",
    "start": "569460",
    "end": "574852"
  },
  {
    "text": "So we can't look at them all. Somehow, we still have to figure\nout which way to go correctly in constant time.",
    "start": "574852",
    "end": "580450"
  },
  {
    "text": "So this is the idea\nof a fusion node. ",
    "start": "580450",
    "end": "594310"
  },
  {
    "text": "We need to be able to store k,\nwhich is order w to the 1/5.",
    "start": "594310",
    "end": "603200"
  },
  {
    "text": "Keys, I'm going to\ngive them some names, x0 up to xk minus 1.",
    "start": "603200",
    "end": "611580"
  },
  {
    "text": "Assume that they've\nbeen presorted. We can preprocess and\ndo all those things. I'm going to go constant time,\npredecessor and successor,",
    "start": "611580",
    "end": "620490"
  },
  {
    "text": "and it's going to\nbe linear space, and it's going to require\npolynomial preprocessing.",
    "start": "620490",
    "end": "627800"
  },
  {
    "text": " And this is the annoying part. If this was just\nk preprocessing,",
    "start": "627800",
    "end": "633405"
  },
  {
    "text": "it would be easy to make\nfusion trees dynamic. But it's k to squared,\nor k cubed or something,",
    "start": "633405",
    "end": "638610"
  },
  {
    "text": "depending on how fancy you are. It's not known how to\ndo it in linear time. ",
    "start": "638610",
    "end": "645880"
  },
  {
    "text": "So that's really our goal. If we can implement\nfusion tree nodes and do constant time predecessor\non this small value of n",
    "start": "645880",
    "end": "653540"
  },
  {
    "text": "basically, when n is\nonly w to the 1/5. If we can do constant\ntime for that, then by plugging in B-trees\nwe get the log base w of n",
    "start": "653540",
    "end": "662360"
  },
  {
    "text": "for arbitrary values of n. So it's really all\nabout a single mode",
    "start": "662360",
    "end": "668339"
  },
  {
    "text": "and doing that fast. ",
    "start": "668340",
    "end": "674060"
  },
  {
    "text": "So, the rest of the\nlecture will be about that. So, I want to introduce\nthis idea of sketching.",
    "start": "674060",
    "end": "681310"
  },
  {
    "text": "And to do that\nI'm going to think about what it takes\nto distinguish",
    "start": "681310",
    "end": "689740"
  },
  {
    "text": "this small number of keys. ",
    "start": "689740",
    "end": "697570"
  },
  {
    "text": "High level ideas, well\nwe've got w to the 1/5 keys. Each of them is w bits.",
    "start": "697570",
    "end": "703750"
  },
  {
    "text": "Do you really need all\nw bits for each of them? It seems a little excessive. If there's only w to the 1/5,\nyou should only need about w",
    "start": "703750",
    "end": "711880"
  },
  {
    "text": "to the 1/5 bits of each\nto distinguish them all. So that's the intuition. And indeed, you can\nformalize that intuition",
    "start": "711880",
    "end": "720160"
  },
  {
    "text": "by viewing each of the keys\nas a path in a binary tree. ",
    "start": "720160",
    "end": "729770"
  },
  {
    "text": "So this represents the\nbit string 01011101.",
    "start": "729770",
    "end": "737160"
  },
  {
    "text": "0 means left. 1 means right. This is a transformation\nwe'll use a lot.",
    "start": "737160",
    "end": "742510"
  },
  {
    "text": "So maybe that's in your set. Maybe this other bit\nstring is in your set.",
    "start": "742510",
    "end": "750259"
  },
  {
    "text": "Maybe this bit string-- oh, I've got to make these\nthe same height which",
    "start": "750260",
    "end": "756437"
  },
  {
    "text": "is a little challenging. ",
    "start": "756437",
    "end": "763780"
  },
  {
    "text": "So maybe those are the three. Suppose you just have these\nthree bit strings, w bit strings in your set.",
    "start": "763780",
    "end": "769300"
  },
  {
    "text": "So this is a tree of height w. Because each of the keys\nhas w bits, so maybe k is 3.",
    "start": "769300",
    "end": "778250"
  },
  {
    "text": "And those are your three keys. OK. The idea is, look at\nthe branching nodes.",
    "start": "778250",
    "end": "783730"
  },
  {
    "text": "Where's a color? So, you've got a branching node\nhere and a branching node here.",
    "start": "783730",
    "end": "791860"
  },
  {
    "text": "Because there's\nthree leaves, there's only going to be\ntwo branching nodes. So the idea is, well I really\nonly care about these two bits.",
    "start": "791860",
    "end": "801279"
  },
  {
    "text": "Or it would be enough to\nthink about these two bits.  OK.",
    "start": "801280",
    "end": "806560"
  },
  {
    "text": "Well, we'll look at this\nmore formally in a moment. But by storing this bit,\nI know whether the key",
    "start": "806560",
    "end": "812800"
  },
  {
    "text": "is over here on the left\nor over here on the right. And then by storing\nthis bit, I don't really care about it for this word.",
    "start": "812800",
    "end": "818440"
  },
  {
    "text": "But it will distinguish\nthese two words. So if you just look at the bits\nthat contain branching nodes",
    "start": "818440",
    "end": "824380"
  },
  {
    "text": "in this tri-view, then it's\nenough to distinguish all",
    "start": "824380",
    "end": "831370"
  },
  {
    "text": "of the xi's. So this is x0, x1, x2.",
    "start": "831370",
    "end": "837670"
  },
  {
    "text": " OK. Let me formalize\nthat a little bit.",
    "start": "837670",
    "end": "844430"
  },
  {
    "text": "So we have k minus 1 branching\nnodes in this height w",
    "start": "844430",
    "end": "856279"
  },
  {
    "text": "tree of the k keys.",
    "start": "856280",
    "end": "867135"
  },
  {
    "text": "Because there's\nk leaves, there's going to be k minus 1 branching\nnodes, because the k leaves are",
    "start": "867135",
    "end": "872600"
  },
  {
    "text": "distinct. So this means there are at most,\nk minus 1 levels containing",
    "start": "872600",
    "end": "881882"
  },
  {
    "text": "a branching node. It might be fewer. ",
    "start": "881882",
    "end": "893410"
  },
  {
    "text": "Maybe it's nice to add\nin another key over here on the left. I mean if I was lucky, there'd\nbe another key over here,",
    "start": "893410",
    "end": "899800"
  },
  {
    "text": "and then I'd be using\nthis bit and getting two for the price of one. If I'm less lucky, it\nwill be more like this.",
    "start": "899800",
    "end": "906730"
  },
  {
    "text": "So here's another x value. And in this case, I care\nabout this branching node.",
    "start": "906731",
    "end": "913720"
  },
  {
    "text": "So I care about\nanother bit here. OK. But if I have four keys, it\nwill be at most three bits",
    "start": "913720",
    "end": "922390"
  },
  {
    "text": "corresponding to these levels. So call these-- these\nlevels correspond to bits.",
    "start": "922390",
    "end": "927640"
  },
  {
    "text": "This is the first bit, second\nbit, third bit, and so on. This is the most\nsignificant bit, next,",
    "start": "927640",
    "end": "933180"
  },
  {
    "text": "and then the least\nsignificant is at the bottom. So these levels correspond\nto important bits.",
    "start": "933180",
    "end": "946720"
  },
  {
    "text": "That's the definition.  And we're going to give\nthese bits a name, b0, b1,",
    "start": "946720",
    "end": "955500"
  },
  {
    "text": "up to br minus 1. Those are bit indices saying\nwhich bits we care about.",
    "start": "955500",
    "end": "962320"
  },
  {
    "text": "And we know that r is less than\nk, and k is order w to the 1/5.",
    "start": "962320",
    "end": "969040"
  },
  {
    "text": "So there are only w to\nthe 1/5 important bits overall among these k keys.",
    "start": "969040",
    "end": "977050"
  },
  {
    "text": "So the idea is don't store\nall w bits for all the keys. I mean you have to store them. But don't look at them.",
    "start": "977050",
    "end": "982780"
  },
  {
    "text": "Just look at these\nimportant bits for the keys. And then life is good.",
    "start": "982780",
    "end": "988180"
  },
  {
    "text": "Because there's only w\nto the 1/5 bits per key. There's only w to the 1/5 keys.",
    "start": "988180",
    "end": "994250"
  },
  {
    "text": "And so the total number of\nimportant bits among all k keys",
    "start": "994250",
    "end": "1005280"
  },
  {
    "text": "is small. It's only w to the 2/5,\nwhich is less than w. So it fits in a single\nword, and we can",
    "start": "1005280",
    "end": "1011520"
  },
  {
    "text": "look at this in constant time.  So that seems like a good thing.",
    "start": "1011520",
    "end": "1017100"
  },
  {
    "text": " Let me tell you what\nproperties this has.",
    "start": "1017100",
    "end": "1025049"
  },
  {
    "text": "Let me also define the notion\nof a perfect sketch of a word.",
    "start": "1025050",
    "end": "1034910"
  },
  {
    "text": "x is going to be what\nyou get when you extract",
    "start": "1034910",
    "end": "1042750"
  },
  {
    "text": "bits b0 to br minus 1 from x.",
    "start": "1042750",
    "end": "1050130"
  },
  {
    "text": "So in other words, this is a bit\nstring, an r-bit string who's",
    "start": "1050130",
    "end": "1060760"
  },
  {
    "text": "i-th bit equals bit bi of x.",
    "start": "1060760",
    "end": "1069810"
  },
  {
    "text": "So you've got a bit\nstring which is x. You say, oh, the important\nones are this one, this one,",
    "start": "1069810",
    "end": "1075909"
  },
  {
    "text": "this one, and this one. Inside here is\neither a 0 or a 1. And there's other bits\nwhich we don't care about,",
    "start": "1075910",
    "end": "1082811"
  },
  {
    "text": "because they're not important.  And we just compress\nthis to a 4-bit string.",
    "start": "1082811",
    "end": "1090750"
  },
  {
    "text": " 0110.",
    "start": "1090750",
    "end": "1096280"
  },
  {
    "text": "OK. This is sketch of x. ",
    "start": "1096280",
    "end": "1101790"
  },
  {
    "text": "And to be a little bit\nmore explicit about how I'm labeling things, this is b0.",
    "start": "1101790",
    "end": "1106920"
  },
  {
    "text": "This is b1, b2, and b3. ",
    "start": "1106920",
    "end": "1114240"
  },
  {
    "text": "Because you number bits-- I think this is right,\nwe'll see later-- we're going to number bits\nfrom the right-hand side.",
    "start": "1114240",
    "end": "1121020"
  },
  {
    "text": "This is 0-th bit, first\nbit, second, third, fourth; which is the opposite of this\npicture, unfortunately, sorry.",
    "start": "1121020",
    "end": "1128450"
  },
  {
    "text": "This is a bit 0, bit 1, anyway. This will be convenient. ",
    "start": "1128450",
    "end": "1140490"
  },
  {
    "text": "So, that's perfect sketch. For now, I'm going\nto assume that we can compute this in constant time.",
    "start": "1140490",
    "end": "1147149"
  },
  {
    "text": "This one answer is\nit's an AC0 operation.",
    "start": "1147150",
    "end": "1152715"
  },
  {
    "text": "That's not so obvious,\nbut it's true. So on an AC0 RAM, you can just\nsay, oh, this is an operation.",
    "start": "1152715",
    "end": "1157861"
  },
  {
    "text": "Right? It's given one word. And, well OK. It's given these\ndescription of bit numbers,",
    "start": "1157861",
    "end": "1163809"
  },
  {
    "text": "but those will also\nfit in one word. And then does this\nbit extraction.",
    "start": "1163810",
    "end": "1169256"
  },
  {
    "text": "We're going to see a\nreasonable way to do it. But for now, take that as an\nunreasonable way to do this. ",
    "start": "1169256",
    "end": "1176010"
  },
  {
    "text": "So perfect sketch is\ngood, because it implies",
    "start": "1176010",
    "end": "1187365"
  },
  {
    "text": "the following nice property. If you look at the\nsketch of x0 that's",
    "start": "1187365",
    "end": "1192380"
  },
  {
    "text": "going to be less than the\nsketch of x1, and so on,",
    "start": "1192380",
    "end": "1198320"
  },
  {
    "text": "which is going to be less\nthan the sketch of xk minus 1.",
    "start": "1198320",
    "end": "1207438"
  },
  {
    "text": "Sketch preserves order. We assume that--\nwhere do we have it?",
    "start": "1207438",
    "end": "1212630"
  },
  {
    "text": "Over here, x0 is less than\nx1, is less than xk minus 1.",
    "start": "1212630",
    "end": "1218150"
  },
  {
    "text": "And because we're\nkeeping all the bits where are these xi's\nget distinguished,",
    "start": "1218150",
    "end": "1224660"
  },
  {
    "text": "this one it doesn't matter\nwhether we kept here, it doesn't matter whether\nwe kept these guys. But in particular,\nwe keep the bits that",
    "start": "1224660",
    "end": "1230000"
  },
  {
    "text": "have all the branching nodes. That will preserve\nthe order of the xi's. So we know that the\norder of the xi's is",
    "start": "1230000",
    "end": "1236270"
  },
  {
    "text": "preserved under sketching. The trouble is the following. Suppose you want to do a\nsearch, a predecessor search.",
    "start": "1236270",
    "end": "1247240"
  },
  {
    "text": "So, you're given some query q,\nand you want to know where does",
    "start": "1247240",
    "end": "1253550"
  },
  {
    "text": "q fit among the xi's. Because that will tell you\nwhich child to visit from here.",
    "start": "1253550",
    "end": "1259880"
  },
  {
    "text": "So, OK. You compute a sketch\nof q, seems reasonable,",
    "start": "1259880",
    "end": "1266540"
  },
  {
    "text": "and move into sketch world. And now you try to\nfind where sketch of q",
    "start": "1266540",
    "end": "1272030"
  },
  {
    "text": "fits among these guys. So you can do that. And I claim you can do\nthat in constant time. It's again, an AC0 operation.",
    "start": "1272030",
    "end": "1278690"
  },
  {
    "text": "But the nice thing is the\nsketches all fit in one word. Also this single sketch fits\nin one word, no big surprise",
    "start": "1278690",
    "end": "1285890"
  },
  {
    "text": "there. So let's say you can\nfind where sketch of q fits among these items\nin constant time.",
    "start": "1285890",
    "end": "1292100"
  },
  {
    "text": "The trouble is were the sketch\nof q fits is not necessarily the same as where q\nfits among the xi's.",
    "start": "1292100",
    "end": "1300860"
  },
  {
    "text": "Because q was not involved\nin the definition of sketch. q is an arbitrary query. They come online, I mean\nany word could be a query,",
    "start": "1300860",
    "end": "1309950"
  },
  {
    "text": "not just the xi's. So you've set everything up\nto distinguish all the xi's. But q is going to fall off\nthis tree at some point.",
    "start": "1309950",
    "end": "1318920"
  },
  {
    "text": "And that kind of messes you up. Because if q fell off here,\nyou don't have that bit.",
    "start": "1318920",
    "end": "1324139"
  },
  {
    "text": "You won't notice\nthe q fit there. So we have to do some work.",
    "start": "1324140",
    "end": "1330050"
  },
  {
    "text": "And this is what I\ncall de-sketchifying. ",
    "start": "1330050",
    "end": "1339020"
  },
  {
    "text": "And I like a big board. ",
    "start": "1339020",
    "end": "1365541"
  },
  {
    "text": "OK, let mean draw a some more\nmethodical and smaller example.",
    "start": "1365541",
    "end": "1371245"
  },
  {
    "text": " I need to make it the\nright number of levels.",
    "start": "1371245",
    "end": "1377660"
  },
  {
    "start": "1377660",
    "end": "1403789"
  },
  {
    "text": "A little bigger than my usual\ntree, and I'll get my red,",
    "start": "1403789",
    "end": "1414110"
  },
  {
    "text": "actually maybe use two colors. ",
    "start": "1414110",
    "end": "1439370"
  },
  {
    "text": "So here's a real example. Now it has four keys.",
    "start": "1439370",
    "end": "1445210"
  },
  {
    "text": "And here I'm in the lucky case,\nwhere this is an important bit. ",
    "start": "1445210",
    "end": "1451600"
  },
  {
    "text": "And I get two for\nthe price of one. I cared about this\nbranching node, I cared about this\nbranching node,",
    "start": "1451600",
    "end": "1458770"
  },
  {
    "text": "and so I only have to\ndoor two bits in my sketch for these four nodes.",
    "start": "1458770",
    "end": "1464049"
  },
  {
    "text": "In general, it\nmight be three bits. But this will just\nmake the point. So it's actually,\nlife is in some ways",
    "start": "1464050",
    "end": "1469659"
  },
  {
    "text": "harder in this situation. OK. So what are my bit strings here? Over here I've got 0000, which\ncorresponds to always going",
    "start": "1469660",
    "end": "1478461"
  },
  {
    "text": "left. And I've got 0010.",
    "start": "1478461",
    "end": "1484360"
  },
  {
    "text": "Over here I've\ngot 1100 and 1111.",
    "start": "1484360",
    "end": "1492530"
  },
  {
    "text": "We drew these pictures\nfor van Emde Boas, right? The idea is we're\ngoing to use some",
    "start": "1492530",
    "end": "1497679"
  },
  {
    "text": "of the similar\nperspectives at least. OK, but the important bits were\nthe very first, the leftmost",
    "start": "1497680",
    "end": "1503770"
  },
  {
    "text": "bit I should say. And then two bits after\nthat, so these guys.",
    "start": "1503770",
    "end": "1512810"
  },
  {
    "start": "1512810",
    "end": "1518280"
  },
  {
    "text": "And so the sketch here\nis 11, 10, 01, and 00.",
    "start": "1518280",
    "end": "1525197"
  },
  {
    "text": "And you can see this is\nthe minimal number of bits I need to keep them in order. But it does. It works.",
    "start": "1525197",
    "end": "1530717"
  },
  {
    "text": "You can check. This works in general. OK. Now comes the query.",
    "start": "1530717",
    "end": "1536250"
  },
  {
    "text": "I have a problematic\nquery I'd like to draw. And it is 0101, so 0-1-0-1.",
    "start": "1536250",
    "end": "1545760"
  },
  {
    "text": "So here's my query queue. Let me draw these as white. ",
    "start": "1545760",
    "end": "1555350"
  },
  {
    "text": "Query is 0101. 1 If we take the\nsketch, we get 00.",
    "start": "1555350",
    "end": "1564350"
  },
  {
    "text": "Those are the important bits. So if I search for\nthe query of 00,",
    "start": "1564350",
    "end": "1571040"
  },
  {
    "text": "I will find that it\nhappens to match this key, or it matches the\nsketch of this key.",
    "start": "1571040",
    "end": "1576220"
  },
  {
    "text": "But that key is neither the\npredecessor, nor the successor of that query. So this is bad news.",
    "start": "1576220",
    "end": "1582140"
  },
  {
    "text": "I find the predecessor in sketch\nworld, which is the red stuff, I get the wrong answer. In general, they could be\nvery far away from each other.",
    "start": "1582140",
    "end": "1589910"
  },
  {
    "text": "Here, I've got it 1\naway, but that's as big an example as I can draw. ",
    "start": "1589910",
    "end": "1597162"
  },
  {
    "text": "So, how do we deal with this? ",
    "start": "1597162",
    "end": "1612380"
  },
  {
    "text": "This is the de-sketchification. So when I do this query, I\nend up finding this guy, x0.",
    "start": "1612380",
    "end": "1621179"
  },
  {
    "text": "I claim that I can still use\nthat for something interesting.",
    "start": "1621180",
    "end": "1627080"
  },
  {
    "text": "OK, let's say we\nhave a sketch of xi",
    "start": "1627080",
    "end": "1635510"
  },
  {
    "text": "as the predecessor\nof the sketch of q.",
    "start": "1635510",
    "end": "1641240"
  },
  {
    "text": "And so sketch of q is\nsandwiched between a sketch of xi and sketch of xi plus 1.",
    "start": "1641240",
    "end": "1646952"
  },
  {
    "text": "First of all, we're\nassuming that I can compute this\nin constant time, I can find where sketch of\nq fits among these guys.",
    "start": "1646952",
    "end": "1652160"
  },
  {
    "text": "Because it just fits into words. And for now, let's just\nassume all operations on a constant number of\nwords are at constant time.",
    "start": "1652160",
    "end": "1657710"
  },
  {
    "text": "We will see how to do this. This is parallel comparison. So you figure out\nsketch of q fits here.",
    "start": "1657710",
    "end": "1664700"
  },
  {
    "text": "I want to learn something about\nwhere q fits among the xi's. It's obviously, these\nmay be the wrong answer.",
    "start": "1664700",
    "end": "1671130"
  },
  {
    "text": "But I claim I can do\nsomething useful by looking at the longest common\nprefix of those words.",
    "start": "1671130",
    "end": "1680030"
  },
  {
    "start": "1680030",
    "end": "1688130"
  },
  {
    "text": "So I want to compare q, not\nsketch of q but the real value q, and either xi or xi plus 1.",
    "start": "1688130",
    "end": "1703340"
  },
  {
    "text": "And what I want is the longest. So I look at the longest\ncommon prefix of q and xi.",
    "start": "1703340",
    "end": "1708889"
  },
  {
    "text": "I look at longest common\nprefix of q and xi plus 1. Whichever of those\nis the longest that's",
    "start": "1708890",
    "end": "1714950"
  },
  {
    "text": "my longest common prefix. In the tree, it's the\nlongest common ancestor, or lowest common ancestor.",
    "start": "1714950",
    "end": "1721090"
  },
  {
    "text": " OK. So let's do it.",
    "start": "1721090",
    "end": "1726680"
  },
  {
    "text": "We found that sketch of\nq fit between, I guess, these two guys, the\nway I've written it with the inequalities.",
    "start": "1726680",
    "end": "1732559"
  },
  {
    "text": "It's between x0 here and x1. So in this case, the\nlowest common ancestor",
    "start": "1732560",
    "end": "1740750"
  },
  {
    "text": "of this node and q\nis going to be here. Also this node and q\nhappens to also be here.",
    "start": "1740750",
    "end": "1746420"
  },
  {
    "text": "So this is the lowest we can go. And what this means\nis that these guys,",
    "start": "1746420",
    "end": "1754810"
  },
  {
    "text": "they share the bit\nstring up to here. We were on the blue\nsubstructure up till here.",
    "start": "1754810",
    "end": "1760130"
  },
  {
    "text": "This was the node\nwhere q diverged. We followed a pointer here\nalong a non-blue edge.",
    "start": "1760130",
    "end": "1766880"
  },
  {
    "text": "That's where we made a mistake. So this lets us\nfind, in some sense, the first mistake, where\nwe fell off the tree.",
    "start": "1766880",
    "end": "1773360"
  },
  {
    "text": "So that's where we\nfell off the blue tree. That's useful information. Because now we know, well,\nwe went to the right,",
    "start": "1773360",
    "end": "1781640"
  },
  {
    "text": "whereas all the actual data is\nover here in the left subtree. There is no blue\nstuff in the right.",
    "start": "1781640",
    "end": "1787730"
  },
  {
    "text": "So that tells us a lot. If we want to now find\nthe predecessor of q, it's going to be whatever\nis the max in this subtree.",
    "start": "1787730",
    "end": "1795630"
  },
  {
    "text": "So, I just need to be able\nto find the max over here. So this is the idea. Now there's two cases, depending\non whether we were in the right",
    "start": "1795630",
    "end": "1803300"
  },
  {
    "text": "or in the left from that node. ",
    "start": "1803300",
    "end": "1810650"
  },
  {
    "text": "So let me write\nthis, find the node y",
    "start": "1810650",
    "end": "1818090"
  },
  {
    "text": "where q fell off the blue tree.",
    "start": "1818090",
    "end": "1825679"
  },
  {
    "text": "So this node y, we can\nthink of as a bit number. Here the leftmost\nbit was still on,",
    "start": "1825680",
    "end": "1831820"
  },
  {
    "text": "but then the next bit was off. And so we look at-- I'll call that bit y plus 1,\nor maybe size of y plus 1.",
    "start": "1831820",
    "end": "1842180"
  },
  {
    "text": "If that bit equals 1,\nthat's the picture we have.",
    "start": "1842180",
    "end": "1849760"
  },
  {
    "text": "Then what I'm going to do\nis set a new quantity e,",
    "start": "1849760",
    "end": "1856190"
  },
  {
    "text": "which is going to be-- this is a new word. It's going to be the bit\nstring y, followed by a 0,",
    "start": "1856190",
    "end": "1862280"
  },
  {
    "text": "followed by lots of 1's.  Whereas our bit string q had a\n1 here, and fell off the tree.",
    "start": "1862280",
    "end": "1874696"
  },
  {
    "text": "What we're instead\ngoing to do is identify this node, the\nrightmost node in this subtree.",
    "start": "1874696",
    "end": "1882190"
  },
  {
    "text": "That's not necessarily an xi. But it's a thing. And then we're\ngoing to do, again,",
    "start": "1882190",
    "end": "1888460"
  },
  {
    "text": "this search and sketch space,\nbut now using e instead of q.",
    "start": "1888460",
    "end": "1895630"
  },
  {
    "text": "If we do that,\nwhat is this node? Let's label it, 0011.",
    "start": "1895630",
    "end": "1902440"
  },
  {
    "text": "If you look at the sketch\nbits, this has a sketch of 01. So if I did a search\nhere, I would actually",
    "start": "1902440",
    "end": "1908860"
  },
  {
    "text": "find that this is\nthe answer, and that actually is a predecessor of q.",
    "start": "1908860",
    "end": "1913900"
  },
  {
    "text": "In general, this is\ngoing to work well. Because essentially\nsome of these bits",
    "start": "1913900",
    "end": "1920684"
  },
  {
    "text": "are going to be sketch bits. This one was not, and\nwe made a mistake there. We went right.",
    "start": "1920684",
    "end": "1925940"
  },
  {
    "text": "We should have got left. These ones, some of them\nare going to be sketch bits. Some of them are not. But whichever ones\nget underlined,",
    "start": "1925940",
    "end": "1932260"
  },
  {
    "text": "it's going to be a\n1, which means we're going to do the right thing. We want the very rightmost\nitem in this tree.",
    "start": "1932260",
    "end": "1940370"
  },
  {
    "text": "So if we always go right\nwhenever there's a sketch bit, and then do a search\nin sketch space,",
    "start": "1940370",
    "end": "1946570"
  },
  {
    "text": "we will find the rightmost\nitem in this tree. So if we then do a\nsearch on e, we're",
    "start": "1946570",
    "end": "1952480"
  },
  {
    "text": "always going to get\nthe right answer. So in the end, we're going do\ntwo searches in sketch space,",
    "start": "1952480",
    "end": "1958090"
  },
  {
    "text": "once with q to find this\nplace where we fell off, then once with e where we\nactually find the right answer.",
    "start": "1958090",
    "end": "1967720"
  },
  {
    "text": " And there's a symmetric case,\nwhich is if we went left and we",
    "start": "1967720",
    "end": "1974559"
  },
  {
    "text": "should have gone right,\nthen we go right, and then we put a lot of 0's. Because then we want to\nfind the min in that tree.",
    "start": "1974560",
    "end": "1980419"
  },
  {
    "start": "1980420",
    "end": "1990070"
  },
  {
    "text": "So, back to search, we\ncompute sketch of q. We find it among the\nsketch of the xi's.",
    "start": "1990070",
    "end": "1999785"
  },
  {
    "text": " This gives us this y.",
    "start": "1999785",
    "end": "2007120"
  },
  {
    "text": "So we find the\nlongest common prefix, y equals longest common prefix\nof q and xi or xi plus 1.",
    "start": "2007120",
    "end": "2021240"
  },
  {
    "text": "Then we compute e, and then we\nfind sketch of e among sketch",
    "start": "2021240",
    "end": "2035346"
  },
  {
    "text": "of xi's.  And the claim is that the\npredecessor and successor",
    "start": "2035346",
    "end": "2045700"
  },
  {
    "text": "of sketch of e among sketch\nof xi's equals the predecessor",
    "start": "2045700",
    "end": "2053250"
  },
  {
    "text": "and successor of q, our\nactual query, among the xi's.",
    "start": "2053250",
    "end": "2066010"
  },
  {
    "start": "2066010",
    "end": "2078669"
  },
  {
    "text": "So this is a claim. It needs proof. But it's what I've been\narguing that e gives us",
    "start": "2078669",
    "end": "2083790"
  },
  {
    "text": "the right structure. It fixes all the sketch bits\nthat are potentially wrong. We found the first sketch\nbit that was wrong.",
    "start": "2083790",
    "end": "2090480"
  },
  {
    "text": "We fixed that one. And then the remainder, as\nlong as we go all the way to the right, we'll find the\nmax, or in the other case",
    "start": "2090480",
    "end": "2098070"
  },
  {
    "text": "we want to go all\nthe way to the left because we want to find the min. So that's this claim.",
    "start": "2098070",
    "end": "2104060"
  },
  {
    "text": "We find the predecessor\nof sketch of e. Run the sketch of the xi's,\nwhich is just this thing again.",
    "start": "2104060",
    "end": "2110530"
  },
  {
    "text": "So again, we can do\nit in constant time. Then we find-- I mean I have to be a little\nbit more precise here.",
    "start": "2110530",
    "end": "2116939"
  },
  {
    "text": "Of course, we find the\npredecessor and successor, we get a sketch of the xi. We have to undo that\nsketch operation.",
    "start": "2116939",
    "end": "2122160"
  },
  {
    "text": "Really the way to think of it\nis predecessor and successor are really returning a rank.",
    "start": "2122160",
    "end": "2127530"
  },
  {
    "text": "I want to know the\ni that matters. So if it fits between sketch\nof xi and sketch of xi plus 1,",
    "start": "2127530",
    "end": "2136155"
  },
  {
    "text": "if sketch of e\nfits between those, then I know that q will fit\nbetween xi and xi plus 1,",
    "start": "2136155",
    "end": "2143730"
  },
  {
    "text": "in terms of that rank, i,\nthe index in the array. ",
    "start": "2143730",
    "end": "2151134"
  },
  {
    "text": "So, that makes sense. This is the end of the--",
    "start": "2151134",
    "end": "2159970"
  },
  {
    "text": "what's the right way to put it? This is the big picture\nof fusion trees. At this point you should\nbelieve that everything works.",
    "start": "2159970",
    "end": "2169070"
  },
  {
    "text": "And overall, what are we doing? We're building a\nw to the 1/5 tree. It's not yet clear\nwhy w to the 1/5.",
    "start": "2169070",
    "end": "2176587"
  },
  {
    "text": "And so we have to\nimplement these nodes that only have w to the 1/5 keys. So we're looking\nat a single node. And say, hey look,\nthere's a bunch of keys.",
    "start": "2176587",
    "end": "2183610"
  },
  {
    "text": "Let's just look at\nthe important bits. That defines the\nsketch operation. Now if we want to do a search,\nwe do this double search.",
    "start": "2183610",
    "end": "2191170"
  },
  {
    "text": "We compute the sketch, find\nthe sketch among the sketches, find our mistake,\ncompute our proper query,",
    "start": "2191170",
    "end": "2199270"
  },
  {
    "text": "compute the sketch of that, find\nthat sketch among the sketches, and then that index in the array\nof sketches will be the correct",
    "start": "2199270",
    "end": "2206619"
  },
  {
    "text": "index of our actual\nquery q among the xi's.",
    "start": "2206620",
    "end": "2211910"
  },
  {
    "text": "Now, there are\nseveral things left to be done in a reasonable way. One is how do we\ncompute sketches.",
    "start": "2211910",
    "end": "2218530"
  },
  {
    "text": "How do we do this\nkind of operation of taking the bits we care\nabout and bringing them all next to each other?",
    "start": "2218530",
    "end": "2226220"
  },
  {
    "text": "Second thing is, how\ndo we do this find? This parallel comparison. So it's basically all\nthe bullets up here.",
    "start": "2226220",
    "end": "2232990"
  },
  {
    "text": "We have how do we\ndo a sketch, how do we do parallel comparison\nto find where one sketch fits",
    "start": "2232990",
    "end": "2239020"
  },
  {
    "text": "among many sketches, and there's\nalso a most significant set bit. Where did we do that?",
    "start": "2239020",
    "end": "2244900"
  },
  {
    "text": "In computing the\nlongest common prefix. So if you have two\nbit strings and you want to know where\ndid they first differ,",
    "start": "2244900",
    "end": "2252779"
  },
  {
    "text": "the natural way to\ndo that is compute the XOR, which gives you\nall the differing bits. And then find the first\none bit from the left.",
    "start": "2252779",
    "end": "2260230"
  },
  {
    "text": "So this is really most\nsignificant set bit. ",
    "start": "2260230",
    "end": "2268630"
  },
  {
    "text": "So, we need that operation. ",
    "start": "2268630",
    "end": "2274760"
  },
  {
    "text": "So, we have our\nwork cut out for us. But the overall\npicture of fusion trees should now be clear.",
    "start": "2274760",
    "end": "2280740"
  },
  {
    "text": "It just remains to do\nthese three things. And this is where the\nengineering comes in,",
    "start": "2280740",
    "end": "2286090"
  },
  {
    "text": "I would say. Any questions about\nthe big picture?",
    "start": "2286090",
    "end": "2291620"
  },
  {
    "start": "2291620",
    "end": "2310980"
  },
  {
    "text": "So, the first thing I'm\ngoing to do is sketch. And as I've hinted at\nin the outline here,",
    "start": "2310980",
    "end": "2317115"
  },
  {
    "text": "we're not going to\ndo a perfect sketch. We're going to do an\napproximate sketch. ",
    "start": "2317115",
    "end": "2323810"
  },
  {
    "text": "This will probably\nbe the most work among any of these operations. Parallel comparison is\nactually quite easy.",
    "start": "2323810",
    "end": "2328850"
  },
  {
    "text": " Sketching is, I think,\nthe biggest insight",
    "start": "2328850",
    "end": "2334099"
  },
  {
    "text": "in Fusion trees. So, perfect sketch\ntakes just the bits",
    "start": "2334100",
    "end": "2341450"
  },
  {
    "text": "you care about that we need. We only want to look at\nthe bits we care about. But it's easy to look at\nthe bits we care about.",
    "start": "2341450",
    "end": "2347049"
  },
  {
    "text": "We can apply a mask, and just\nAND out the bits we care about. Everything else we can zero out. So that's easy.",
    "start": "2347049",
    "end": "2352670"
  },
  {
    "text": "The hard part is compression,\ntaking these four bits and making them four\nconsecutive bits.",
    "start": "2352670",
    "end": "2358950"
  },
  {
    "text": "But they don't really\nneed to be consecutive. If I added in some 0's here\nin a consistent pattern",
    "start": "2358950",
    "end": "2368810"
  },
  {
    "text": "that would still work. I'd still preserve the\norder among the sketches. And that's all I care about. And this is where I'm going\nto use the slop I have.",
    "start": "2368810",
    "end": "2375350"
  },
  {
    "text": "Because right now I\nhave w to the 1/5 keys. If I did perfect sketch,\nthe total number of bits",
    "start": "2375350",
    "end": "2381410"
  },
  {
    "text": "would only be w to the 2/5. But I can go up to w. So what I'm going\nto do is basically",
    "start": "2381410",
    "end": "2391010"
  },
  {
    "text": "spread out the bits,\nthe important bits,",
    "start": "2391010",
    "end": "2402170"
  },
  {
    "text": "in a predictable pattern\nof length w to the 4/5.",
    "start": "2402170",
    "end": "2415480"
  },
  {
    "text": " Predictable just means it\ndoesn't depend on what x is.",
    "start": "2415480",
    "end": "2422450"
  },
  {
    "text": "So when there are extra 0's\nhere, you know that's fine.",
    "start": "2422450",
    "end": "2428119"
  },
  {
    "text": "But there's always going to\nbe two 0's here, one 0 here, three 0's here, no\nmatter what x was.",
    "start": "2428120",
    "end": "2434300"
  },
  {
    "text": "As long as it's predictable,\nI'm going to preserve order. And as long as it's\nlength order w to the 4/5,",
    "start": "2434300",
    "end": "2439960"
  },
  {
    "text": "if I take w to the\n1/5 of them, that will still fit in a\nconstant number of words. Because it will be\norder w bits total.",
    "start": "2439960",
    "end": "2447390"
  },
  {
    "text": "So that's what I can afford. And now I'm going to do it.",
    "start": "2447390",
    "end": "2452480"
  },
  {
    "text": "So here's how. First thing, as I\nsaid, is we're going to mask the important bits.",
    "start": "2452480",
    "end": "2459680"
  },
  {
    "text": " I just want the important bits.",
    "start": "2459680",
    "end": "2465800"
  },
  {
    "text": "I should throw away\nall the others. And so this is going to be x\nprime equals x bit-wise AND.",
    "start": "2465800",
    "end": "2476075"
  },
  {
    "start": "2476075",
    "end": "2485171"
  },
  {
    "text": "And here's where I'm going to\nuse the notation that the bits count from the right. I want the bi-th bit to\ncorrespond to the value 2",
    "start": "2485171",
    "end": "2492920"
  },
  {
    "text": "to the bi. This thing is just a bit string. It has 1's wherever\nthe important bits are.",
    "start": "2492920",
    "end": "2501920"
  },
  {
    "text": "So if this is the\nb0, b1, b2, and b3;",
    "start": "2501920",
    "end": "2509180"
  },
  {
    "text": "I just want this bit string. I mean, you can think of this\nas 1 shifted left bi times.",
    "start": "2509180",
    "end": "2515360"
  },
  {
    "text": "So I get 1's in exactly\nthe positions I care about. And if I bit-wise AND\nthat with x it zeros out all the other bits.",
    "start": "2515360",
    "end": "2521130"
  },
  {
    "text": "This is what we call masking.  So that's the\nobvious thing to do.",
    "start": "2521130",
    "end": "2528480"
  },
  {
    "text": "And then the second\nidea is multiplication.",
    "start": "2528480",
    "end": "2534100"
  },
  {
    "text": "And it's just like, well, maybe\nwe could do it with a multiply, and then we'll just work it out. And the answer is yes, you\ncan do it with a multiply.",
    "start": "2534100",
    "end": "2541290"
  },
  {
    "text": "So that I imagine\nwas the big insight was to see that multiplication\nis a very powerful operation.",
    "start": "2541290",
    "end": "2549520"
  },
  {
    "text": "So we're just going to do x\nprime times some number m. And we're going to prove\nthat there exists a number",
    "start": "2549520",
    "end": "2555100"
  },
  {
    "text": "m that does what we need. So I'm going to write this out\na little bit algebraically.",
    "start": "2555100",
    "end": "2561200"
  },
  {
    "text": "So we can think about\nwhat m might be. Now x prime only has\nthe important bits.",
    "start": "2561200",
    "end": "2568279"
  },
  {
    "text": "So we can write that as a sum i\nequals 0 to r minus 1 of xbi 2",
    "start": "2568280",
    "end": "2580620"
  },
  {
    "text": "to the bi. So I am introducing\nsome notation here. xbi, is that important bit bi 1 or 0?",
    "start": "2580620",
    "end": "2588840"
  },
  {
    "text": "This is just a de-reference of\nthe bit vector or a bit string.",
    "start": "2588840",
    "end": "2595090"
  },
  {
    "text": "And so you multiply\nthat by that position. I mean this the definition\nof binary notation, right?",
    "start": "2595090",
    "end": "2600691"
  },
  {
    "text": "But we only care about\nthe important bits. Because only those are set. So that's x prime. And then we're\nmultiplying that by m.",
    "start": "2600691",
    "end": "2608440"
  },
  {
    "text": "Now m could have any bit set. So I'm going to--",
    "start": "2608440",
    "end": "2613765"
  },
  {
    "text": "but I'm going to\nwrite it like this. ",
    "start": "2613765",
    "end": "2634160"
  },
  {
    "text": "I'm going to assume that\nm only has r bits set, same as the number\nof important bits,",
    "start": "2634160",
    "end": "2641950"
  },
  {
    "text": "r is a number of important bits. ",
    "start": "2641950",
    "end": "2650407"
  },
  {
    "text": "But I don't know where they are. So I'm just going to suppose\nthey're at positions m0, m1, up to mr minus 1.",
    "start": "2650407",
    "end": "2656440"
  },
  {
    "text": "I've got to find what these\nmi's should be, or mj's. And now just taking\nthis product,",
    "start": "2656440",
    "end": "2662830"
  },
  {
    "text": "so we can expand out the\nproduct algebraically and see what we get. ",
    "start": "2662830",
    "end": "2686960"
  },
  {
    "text": "So, what's this product? Sum i equals 0 to\nr minus 1 sum j",
    "start": "2686960",
    "end": "2696200"
  },
  {
    "text": "equals 0 to r minus 1 of xbi-- ",
    "start": "2696200",
    "end": "2704452"
  },
  {
    "text": "I mean just the\nproduct of these. So 2 to the bi plus mj.",
    "start": "2704452",
    "end": "2710320"
  },
  {
    "text": "That's the algebraic\nproduct of those two things. That's why I wrote\nit out this way. So I can see what's going on. The point is when you\ndo multiplication,",
    "start": "2710320",
    "end": "2717070"
  },
  {
    "text": "you're doing these\npairwise products. Now the guys that\nare going to survive",
    "start": "2717070",
    "end": "2722769"
  },
  {
    "text": "are the ones where the\nxbi's are 1, of course. But they survive\nin multiple places.",
    "start": "2722770",
    "end": "2728589"
  },
  {
    "text": "Essentially the mj's\nshift all of those bits by various amounts.",
    "start": "2728590",
    "end": "2735610"
  },
  {
    "text": "So it used to be at this\nposition, 2 to the bi. But now we're shifting\nit by mj for all j.",
    "start": "2735610",
    "end": "2743140"
  },
  {
    "text": "So some of those bits\nmight hit each other. Then they add up. That's really messy.",
    "start": "2743140",
    "end": "2748150"
  },
  {
    "text": "We're going to avoid\nthat, and design the mj's so that all of\nthese values are unique.",
    "start": "2748150",
    "end": "2753750"
  },
  {
    "text": "Therefore, bits\nnever hit each other. That's step one. And then furthermore, what we\ncare about or what we're trying",
    "start": "2753750",
    "end": "2762130"
  },
  {
    "text": "to do is to get the xbi's to\nappear in a nice little window,",
    "start": "2762130",
    "end": "2768160"
  },
  {
    "text": "consecutive interval\nof w to the 4/5 bits,",
    "start": "2768160",
    "end": "2774280"
  },
  {
    "text": "somehow by setting the mj's. So let me tell you\nthe claim, which we will prove by induction.",
    "start": "2774280",
    "end": "2780944"
  },
  {
    "text": " So we're given these bi's\nthat we can't control.",
    "start": "2780944",
    "end": "2788042"
  },
  {
    "text": "Those are the important bits.  And the claim is we can\nchoose the mi's such",
    "start": "2788042",
    "end": "2804790"
  },
  {
    "text": "that three properties hold. First one is that bi plus mj\nare distinct for all i and j.",
    "start": "2804790",
    "end": "2819790"
  },
  {
    "text": "So that was that these bits\ndon't collide with each other. So there's no actual\nsummation here. These sums could\nthen be replaced",
    "start": "2819790",
    "end": "2825730"
  },
  {
    "text": "by ORs, which makes\nit very easy to keep track of where the\nbits are going, if we can achieve this property.",
    "start": "2825730",
    "end": "2832540"
  },
  {
    "text": "Property b is that it\nturns out that the bits",
    "start": "2832540",
    "end": "2850670"
  },
  {
    "text": "I'm going to end up\ncaring about our b0 plus m0, b1 plus m1,\nand general bi plus mi.",
    "start": "2850670",
    "end": "2857360"
  },
  {
    "text": "In general, we have bi plus\nmj for different values of i and j. I claim the ones I care\nabout are the ones where",
    "start": "2857360",
    "end": "2863540"
  },
  {
    "text": "i and j are equal. So I'm going to\nlook at these bits, and in particular I want\nthem to appear in order",
    "start": "2863540",
    "end": "2870860"
  },
  {
    "text": "in the bit string.  And then third property--",
    "start": "2870860",
    "end": "2877376"
  },
  {
    "text": "I need some more space--  is that if I look at\nthe span of those bits,",
    "start": "2877376",
    "end": "2885110"
  },
  {
    "text": "so I look at br minus\n1 plus mr minus 1",
    "start": "2885110",
    "end": "2890150"
  },
  {
    "text": "minus b0 plus m0 that is the\ninterval that these bits span.",
    "start": "2890150",
    "end": "2897680"
  },
  {
    "text": "I want that to be order\nr to the fourth power.",
    "start": "2897680",
    "end": "2903380"
  },
  {
    "text": "Because r was w to the 1/5. So this would be\norder w to the 4/5.",
    "start": "2903380",
    "end": "2909710"
  },
  {
    "text": "That's what I need for\neverything to fit in. ",
    "start": "2909710",
    "end": "2915200"
  },
  {
    "text": "So this is guaranteeing\nthat these bits are the sketch that I need.",
    "start": "2915200",
    "end": "2921510"
  },
  {
    "text": "They appear in\norder, and they don't span a very large interval,\njust w to the 4/5.",
    "start": "2921510",
    "end": "2928092"
  },
  {
    "text": "This is what I need to prove. If I can prove this, I\nhave approximate sketching.",
    "start": "2928092",
    "end": "2933695"
  },
  {
    "text": "So let's prove it. ",
    "start": "2933695",
    "end": "2959600"
  },
  {
    "text": "Proof happens in two steps. First thing I'm\ngoing to worry about is just getting\nthese guys distinct.",
    "start": "2959600",
    "end": "2965890"
  },
  {
    "text": "Then I'll worry about\nthe order property. So here's how we\nget them distinct.",
    "start": "2965890",
    "end": "2971890"
  },
  {
    "text": "And these are going\nto be the mi primes,",
    "start": "2971890",
    "end": "2977529"
  },
  {
    "text": "not quite the mi's that we want.  They're all going to be integers\nless than r cubed, greater than",
    "start": "2977530",
    "end": "2987210"
  },
  {
    "text": "or equal to 0, and they're\ngoing to have the property that the bi's plus mj primes\nare distinct mod r cubed.",
    "start": "2987210",
    "end": "3006030"
  },
  {
    "text": "So this is a stronger\nversion of a. We really just need\nthem to be distinct. But to make it easier\nfor the other steps,",
    "start": "3006030",
    "end": "3012060"
  },
  {
    "text": "we're going to force them\nto be distinct mod r cubed. ",
    "start": "3012060",
    "end": "3018390"
  },
  {
    "text": "How do we do this? By induction. So let's suppose that we've\npicked m0 up to mt minus 1.",
    "start": "3018390",
    "end": "3031716"
  },
  {
    "text": "So suppose by induction\nthat we've done that. And now our goal is\nto pick mt prime.",
    "start": "3031716",
    "end": "3038640"
  },
  {
    "text": " So how do we choose mt prime?",
    "start": "3038640",
    "end": "3046330"
  },
  {
    "text": "Well, what can't it be? mt prime has to avoid\nbasically mi prime,",
    "start": "3046330",
    "end": "3058070"
  },
  {
    "text": "and believe minus bj plus b--",
    "start": "3058070",
    "end": "3063611"
  },
  {
    "text": "we're going to call it k? I guess so. ",
    "start": "3063611",
    "end": "3068990"
  },
  {
    "text": "If it avoids all\nexpressions like this, then mt prime plus bj\nwill be different from mi",
    "start": "3068990",
    "end": "3079600"
  },
  {
    "text": "prime plus bk. In other words, all of these\nthings will be distinct. So it has to avoid\nthis modulo r cubed.",
    "start": "3079600",
    "end": "3089560"
  },
  {
    "text": "If I can avoid all\nof these things-- so this is for all ijk-- ",
    "start": "3089560",
    "end": "3098010"
  },
  {
    "text": "if I can choose mt prime\nto avoid all those, then I'm happy.",
    "start": "3098010",
    "end": "3103260"
  },
  {
    "text": "Because then these things\nwill continue to be distinct, and then I apply induction. Well, how many choices\nare there for i, j, and k?",
    "start": "3103260",
    "end": "3110320"
  },
  {
    "text": "For i, there's I\nguess t choices. Because mi can be any\nof the previous values.",
    "start": "3110320",
    "end": "3118950"
  },
  {
    "text": "For j, let's call it r choices\nfor k, there's r choices.",
    "start": "3118950",
    "end": "3126970"
  },
  {
    "text": "That's how many\nimportant bits there are. So total number of\nchoices is tr squared. ",
    "start": "3126970",
    "end": "3134410"
  },
  {
    "text": "But t here is\nalways less than r. So this is going to\nbe less than r cubed.",
    "start": "3134410",
    "end": "3140372"
  },
  {
    "text": "So that means there is\nless than r cubed things we have to avoid. But I have r cubed\nallowable choices",
    "start": "3140372",
    "end": "3145740"
  },
  {
    "text": "on working modulo r cubed. So I just pick any one\nthat avoids the collision. This is basically deterministic\nhashing, in a certain sense.",
    "start": "3145740",
    "end": "3153340"
  },
  {
    "text": "We are choosing these\nvalues deterministically to avoid collisions in\nthis simple hash function.",
    "start": "3153340",
    "end": "3159231"
  },
  {
    "text": "OK. It takes time. It's going to take polynomial\ntime to compute this thing. And you can imagine if\nyou just plug in hashing,",
    "start": "3159231",
    "end": "3165328"
  },
  {
    "text": "this will work with\nsome probability, and blah, blah, blah. But I want to make it always\nwork deterministically.",
    "start": "3165329",
    "end": "3170590"
  },
  {
    "text": "Because we know what\nthe xi's are here. All right. So we've avoided collisions.",
    "start": "3170590",
    "end": "3176930"
  },
  {
    "text": "There's enough space. That's all. That was step one. Step two, and this\nwill solve property a,",
    "start": "3176930",
    "end": "3184540"
  },
  {
    "text": "even modulo r cubed. Now we have a\nlittle bit of space. We're allowed to go\nup to r to the fourth. And now we just need to\nspread out these bits.",
    "start": "3184540",
    "end": "3192560"
  },
  {
    "text": "So that's step two. Basically we're going to set\nmi to be these values that we",
    "start": "3192560",
    "end": "3201520"
  },
  {
    "text": "chose plus this weird thing,\nw minus bi plus ir cubed",
    "start": "3201520",
    "end": "3212680"
  },
  {
    "text": "rounded down to a\nmultiple of r cubed.",
    "start": "3212680",
    "end": "3222809"
  },
  {
    "text": " So I guess you could put this\nin parentheses if you want.",
    "start": "3222810",
    "end": "3230360"
  },
  {
    "text": "Rough idea is, we want to\ntake mi prime plus ir cubed.",
    "start": "3230360",
    "end": "3235400"
  },
  {
    "text": "Because these mi primes,\nthey're all values between 0, and r cubed minus 1. We got everything\nworking modulo r cubed.",
    "start": "3235400",
    "end": "3243230"
  },
  {
    "text": "If we could just add ir\ncubed to each of these values that we'll spread them out.",
    "start": "3243230",
    "end": "3248770"
  },
  {
    "text": "Because each of these\nvalues used to fall just in this tiny range ir cubed. So we can move the next\none to the next position,",
    "start": "3248770",
    "end": "3255940"
  },
  {
    "text": "move the next one to the\nnext position, and so on. Spread them out to\nthe left by adding",
    "start": "3255940",
    "end": "3261279"
  },
  {
    "text": "on multiples of r cubed, then\nthat will achieve property b. ",
    "start": "3261280",
    "end": "3268800"
  },
  {
    "text": "The annoying issue here is\nwe don't want to mess things up modulo r cubed. So we need to round\nthings down to be",
    "start": "3268800",
    "end": "3275050"
  },
  {
    "text": "a multiple of r cubed so that\nthis is congruent to mi prime.",
    "start": "3275050",
    "end": "3284617"
  },
  {
    "text": "That's what we want. We want it to stay\ncongruent to mod r cubed. ",
    "start": "3284617",
    "end": "3289971"
  },
  {
    "text": "Well, why do we need to round\ndown to a multiple of r cubed? We were adding on ir cubed. Well, it's not quite\nmi that we care about.",
    "start": "3289971",
    "end": "3296849"
  },
  {
    "text": "It's mi plus bi. Those are the bits that we\nwant to be nicely ordered.",
    "start": "3296850",
    "end": "3302260"
  },
  {
    "text": "And so we kind of\nneed a minus bi here, so that when we take mi\nplus bi, those cancel.",
    "start": "3302260",
    "end": "3310030"
  },
  {
    "text": "But then bi is not a\nmultiple of r cubed. So you've got to do this\nrounding down to r cubed.",
    "start": "3310030",
    "end": "3315150"
  },
  {
    "text": "Also negative bi is\na negative number. And we can't really deal\nwith negative numbers. Because you can't go left of 0.",
    "start": "3315150",
    "end": "3321809"
  },
  {
    "text": "So we have to add on this w\njust to make things work out. So it's a little\nmessy, and I don't",
    "start": "3321810",
    "end": "3327720"
  },
  {
    "text": "want to spend too much time\non why this formula works. But I think you have the\nessence of what's working.",
    "start": "3327720",
    "end": "3333750"
  },
  {
    "text": "This is just to avoid\nnegative numbers. This negative bi is so that when\nyou add it to mi that cancels.",
    "start": "3333750",
    "end": "3343200"
  },
  {
    "text": "And so you get these\nr cubes separations. In the end, let me draw\na picture, perhaps.",
    "start": "3343200",
    "end": "3348920"
  },
  {
    "start": "3348920",
    "end": "3369859"
  },
  {
    "text": "In the end, if you look at the\nbit space, so this is w bits.",
    "start": "3369860",
    "end": "3377520"
  },
  {
    "text": "And you divide it up into\nmultiples of r cubed. ",
    "start": "3377520",
    "end": "3384710"
  },
  {
    "text": "All of the mi primes\nare over here.",
    "start": "3384710",
    "end": "3390359"
  },
  {
    "text": "So these are mi primes. You don't know in what\norder or anything. They're just kind of randomly\nin there, and chosen pretty much",
    "start": "3390360",
    "end": "3396003"
  },
  {
    "text": "arbitrarily on the low\nend of the spectrum, from 0 to r cubed minus 1.",
    "start": "3396003",
    "end": "3401550"
  },
  {
    "text": "And then what we want\nis for x0 plus m0 to fall somewhere in this\nrange, and then x1 plus m1",
    "start": "3401550",
    "end": "3410540"
  },
  {
    "text": "to fall somewhere in this\nrange, and x2 plus m2 to fall somewhere in this range.",
    "start": "3410540",
    "end": "3417349"
  },
  {
    "text": "If I do that, and it's\nweird because the bits are numbered from\n0 to the left here.",
    "start": "3417350",
    "end": "3423140"
  },
  {
    "text": "Then I will have this property. I claim this\nassignment does that.",
    "start": "3423140",
    "end": "3430069"
  },
  {
    "text": "It's an exercise you can check\nthat indeed xi plus mi will",
    "start": "3430070",
    "end": "3435140"
  },
  {
    "text": "fall in this range. ",
    "start": "3435140",
    "end": "3441410"
  },
  {
    "text": "So this gives us property b. It also gives us property c.",
    "start": "3441410",
    "end": "3446680"
  },
  {
    "text": "Because we've been\nfairly tight here. There's r of these guys, and\nr of these intervals of size r",
    "start": "3446680",
    "end": "3457520"
  },
  {
    "text": "cubed. And so the total\nrange of these bits is going to be r to the fourth.",
    "start": "3457520",
    "end": "3463040"
  },
  {
    "text": "We started at x0 plus m0. We end at xr minus\n1, plus, mr minus 1.",
    "start": "3463040",
    "end": "3469790"
  },
  {
    "text": "That's going to\nbe somewhere here. But if you look at just\nthat interval of bits--",
    "start": "3469790",
    "end": "3475050"
  },
  {
    "text": "so there are more bits actually\nover here, in particular,",
    "start": "3475050",
    "end": "3481560"
  },
  {
    "text": "because of this w bit part. This whole picture\nbasically starts at bit w.",
    "start": "3481560",
    "end": "3488650"
  },
  {
    "text": "Then there's all\nthis stuff to 0. So this is a more\naccurate picture. You're doing this\nmultiplication.",
    "start": "3488650",
    "end": "3494370"
  },
  {
    "text": "Garbage happens here. We have no idea. Garbage happens here. We have no idea. Actually, garbage\nhappens all over here.",
    "start": "3494370",
    "end": "3501390"
  },
  {
    "text": "But what we know\nis that these bits are the bits we care about.",
    "start": "3501390",
    "end": "3507350"
  },
  {
    "text": "These are the xi plus mi bits. If you look at xi plus\nmi, they give you xbi.",
    "start": "3507350",
    "end": "3515930"
  },
  {
    "text": "They exist in other places. But these bits will\nhave the important bits.",
    "start": "3515930",
    "end": "3521410"
  },
  {
    "text": "Now the bits are also\nall over everywhere else. But none of the\nbits hit each other. So these bits remain\ncorrect, because nothing else",
    "start": "3521410",
    "end": "3529490"
  },
  {
    "text": "collides with it. And so if I just mask\nout those bits, again,",
    "start": "3529490",
    "end": "3535270"
  },
  {
    "text": "so I have to do another mask. I did one mask here. I did a multiplication, and\nthen I have to do another mask.",
    "start": "3535270",
    "end": "3543100"
  },
  {
    "text": " So why don't I\nwrite it over here?",
    "start": "3543100",
    "end": "3548330"
  },
  {
    "text": "So we AND with sum i\nequal 0 to r minus 1 of 2",
    "start": "3548330",
    "end": "3565570"
  },
  {
    "text": "to the bi plus mi. Those are the circled bits.",
    "start": "3565570",
    "end": "3572330"
  },
  {
    "text": "So if we grab those things,\nand then we shift right by--",
    "start": "3572330",
    "end": "3579385"
  },
  {
    "text": " why am I writing x?",
    "start": "3579385",
    "end": "3585080"
  },
  {
    "text": "Sorry. These are all b's.  Too many letters.",
    "start": "3585081",
    "end": "3593180"
  },
  {
    "text": "We shift right by b0 plus m0. Because we don't care about\nall those leading bits.",
    "start": "3593180",
    "end": "3599650"
  },
  {
    "text": "So we shift this\nover to the left. We did the mask, then we will\njust have the important bits",
    "start": "3599650",
    "end": "3605040"
  },
  {
    "text": "and they will occupy over here\nan interval of size at most-- I'll say order r to the fourth.",
    "start": "3605040",
    "end": "3612329"
  },
  {
    "text": " Clear?",
    "start": "3612330",
    "end": "3618329"
  },
  {
    "text": "So this is\napproximate sketching. This is definitely a bit\ncomplicated, but it works.",
    "start": "3618330",
    "end": "3626630"
  },
  {
    "text": "Let me review briefly. So, our algorithm was simple.",
    "start": "3626630",
    "end": "3631890"
  },
  {
    "text": "We have a bit string, x. We just want to get\nthe important bits and compress them to a thing\nof size r to the fourth.",
    "start": "3631890",
    "end": "3638950"
  },
  {
    "text": "So first of all, we threw away\nall the non-important bits with this mask. That was easy. Then we just did an\narbitrary multiplication,",
    "start": "3638950",
    "end": "3646240"
  },
  {
    "text": "and we proved that there\nwas a multiplication that avoided collision. So the sums basically\nturned into ORs or XORs.",
    "start": "3646240",
    "end": "3654760"
  },
  {
    "text": "I mean you never get two\n1 bits hitting each other, so you don't have\nto worry about that. And we did that with the\nsimple inductive argument.",
    "start": "3654760",
    "end": "3662359"
  },
  {
    "text": "And then we also wanted\nthe bi's plus mi's to be linearly ordered. Because we need to preserve the\norder of the important bits.",
    "start": "3662360",
    "end": "3668950"
  },
  {
    "text": "We can't just permute them. And we needed them to\noccupy a small range.",
    "start": "3668950",
    "end": "3674410"
  },
  {
    "text": "And we did that\nbasically by adding ir cubed to each of them. But it was a little messy\nand we had to add w, and blah-blah-blah.",
    "start": "3674410",
    "end": "3682060"
  },
  {
    "text": "But in the end, we\ngot our important bits to be nicely spaced out\nhere by pretty much putting",
    "start": "3682060",
    "end": "3688480"
  },
  {
    "text": "an r cubed in between each one. So those were our\nbi plus mi bits.",
    "start": "3688480",
    "end": "3693670"
  },
  {
    "text": "They occupied this range\nof r to the fourth. We'll mask out all the\nrest of the garbage. Because this multiplication\nmade a quadratic number of bits.",
    "start": "3693670",
    "end": "3699890"
  },
  {
    "text": "We only want these r bits,\nthe r squared 1 bits in here. We'll mask away all the others.",
    "start": "3699890",
    "end": "3705280"
  },
  {
    "text": "Take these bits,\nshift them over. Now they occupy a nice interval\nat the beginning size order r",
    "start": "3705280",
    "end": "3711450"
  },
  {
    "text": "to the fourth. And that's our\napproximate sketch. So sketch should only take\nr, but we're being sloppy.",
    "start": "3711450",
    "end": "3720230"
  },
  {
    "text": "With this multiplication\ntrick, the best we know is to get down to\nr to the fourth. And that's good enough.",
    "start": "3720230",
    "end": "3727440"
  },
  {
    "text": "And that's why I set everything\nto w to the one fifth. Because this is w to the 4/5.",
    "start": "3727440",
    "end": "3732640"
  },
  {
    "text": "We're going to have\nw to the 1/5 of them. And so if you take\nthese sketches and you concatenate them, fuse\nthem together if you will,",
    "start": "3732640",
    "end": "3740940"
  },
  {
    "text": "and that's fusion trees. Then the sketches of all of\nthe keys x0 up to xk minus 1",
    "start": "3740940",
    "end": "3748690"
  },
  {
    "text": "will occupy order 1 words. Because it's order w bits, w\nto the 4/5 times w to the 1/5.",
    "start": "3748690",
    "end": "3756180"
  },
  {
    "text": " Which brings us to\nparallel comparison.",
    "start": "3756180",
    "end": "3765250"
  },
  {
    "text": "I have all of these\napproximate sketches. So you could start forgetting\napproximate sketching.",
    "start": "3765250",
    "end": "3770620"
  },
  {
    "text": "Somehow, we get these\nw to the 4/5 bits. We want to concatenate them\ntogether, and then in parallel",
    "start": "3770620",
    "end": "3776049"
  },
  {
    "text": "compare all of them\nto the sketch of q. The sketch of the xi's\nwe can preprocess.",
    "start": "3776050",
    "end": "3782619"
  },
  {
    "text": "We can actually\nspend a lot of time finding the sketch function. But then we have to fix\nthe sketch function.",
    "start": "3782620",
    "end": "3787890"
  },
  {
    "text": "We have to be able to compute\na sketch of q in constant time. That's what we just did. Sketch of q is one AND one\nmultiplication and another AND.",
    "start": "3787890",
    "end": "3795130"
  },
  {
    "text": "So computing sketches is fast. That's the steps of\ncomputing sketch of q. Now, next step is find it\namong the sketch of the xi's.",
    "start": "3795130",
    "end": "3803080"
  },
  {
    "text": "So this is the next thing\nwe want to make fast. ",
    "start": "3803080",
    "end": "3822049"
  },
  {
    "text": "It's actually pretty easy. You probably know you\ncan compare two integers by subtracting one\nfrom the other.",
    "start": "3822050",
    "end": "3827400"
  },
  {
    "text": "So we're just going to do\nthat, but in a clever way, so we can do k subtractions\nfor the price of one.",
    "start": "3827400",
    "end": "3833390"
  },
  {
    "start": "3833390",
    "end": "3843975"
  },
  {
    "text": "I'm going to define the sketch\nof a node to be 1 bit followed by the sketch of x0 dot, dot,\ndot, 1 sketch of xk minus one.",
    "start": "3843976",
    "end": "3859985"
  },
  {
    "text": "And I'm going to define a\nsketch of q to the k-th power,",
    "start": "3859985",
    "end": "3866850"
  },
  {
    "text": "so to speak, to be a 0 bit\nfollowed by sketch of q, dot,",
    "start": "3866850",
    "end": "3872385"
  },
  {
    "text": "dot dot, zero bit sketch of q. ",
    "start": "3872385",
    "end": "3879860"
  },
  {
    "text": "This is aligning\nthings, so that if I did this subtraction\nand this one,",
    "start": "3879860",
    "end": "3884990"
  },
  {
    "text": "I would basically be comparing\nq with all the xi's at once. ",
    "start": "3884990",
    "end": "3892490"
  },
  {
    "text": "The point is these sketches--\nthis is the thing that fits in order 1 words. These sketches are\nw to the 4/5 bits,",
    "start": "3892490",
    "end": "3900650"
  },
  {
    "text": "and there's w to\nthe 1/5 of them. So this whole thing\nis order w bits. So it fits in one word.",
    "start": "3900650",
    "end": "3906350"
  },
  {
    "text": "This thing also. It happens to be the same\nbits repeated many times but also it fits in one word.",
    "start": "3906350",
    "end": "3913310"
  },
  {
    "text": "How do I compute this thing? I can do it with multiplication.",
    "start": "3913310",
    "end": "3919329"
  },
  {
    "text": "It's sketch of q times\n0000001, 000000001.",
    "start": "3919330",
    "end": "3933600"
  },
  {
    "text": "So, ahead of time, I'll just\npre-compute this bit string that has 1's at the rightmost\nslot for each of these k",
    "start": "3933600",
    "end": "3943010"
  },
  {
    "text": "fields. If I just take that and\nmultiply it by sketch of q, then I get this.",
    "start": "3943010",
    "end": "3948330"
  },
  {
    "text": "So this is easy to do\nin one multiplication. Now, I take this thing\nminus this thing.",
    "start": "3948330",
    "end": "3955530"
  },
  {
    "text": " I take the difference.",
    "start": "3955530",
    "end": "3961800"
  },
  {
    "text": " And the key thing is because\nI put these 1 bits here, I'm",
    "start": "3961800",
    "end": "3968340"
  },
  {
    "text": "taking this minus this. The point is either this 1 bit\nwill get borrowed when I do binary subtraction, or it won't.",
    "start": "3968340",
    "end": "3974730"
  },
  {
    "text": "It gets borrowed when\nthis is bigger than this, otherwise it doesn't\nget borrowed. So I'm going to\nget either a 0 or 1",
    "start": "3974730",
    "end": "3982740"
  },
  {
    "text": "here, and then\nsome garbage which I don't care about, and a 0 or\na 1 here, and then some garbage.",
    "start": "3982740",
    "end": "3990430"
  },
  {
    "text": "And I'll just mask that out. I'm ANDing with 10000, 100000.",
    "start": "3990430",
    "end": "4004760"
  },
  {
    "text": "And so I end up just with\n01 bits and the rest 0's. ",
    "start": "4004760",
    "end": "4017289"
  },
  {
    "text": "And these bits,\nif I get it right, it's 1 if the sketch\nof q is less than",
    "start": "4017290",
    "end": "4032410"
  },
  {
    "text": "or equal to the sketch of xi. ",
    "start": "4032410",
    "end": "4037870"
  },
  {
    "text": "And it's 0 if the sketch of q is\ngreater than the sketch of xi.",
    "start": "4037870",
    "end": "4046560"
  },
  {
    "text": "Because when it's greater\nthat's when the borrow happens. And then the 1 turns into a 0. So 1's indicate the query is\ntoo small or they're just right.",
    "start": "4046560",
    "end": "4057130"
  },
  {
    "text": "And 0's indicate\nthat they're greater. Now the xi's were in order.",
    "start": "4057130",
    "end": "4063220"
  },
  {
    "text": "So probably x0 is too small. And so this bit will\nend up being a 0.",
    "start": "4063220",
    "end": "4068530"
  },
  {
    "text": "Probably xk this\nplus 1 is too big. So this bit will be a 1. In general, it's going to be\na monotone sequence of bits.",
    "start": "4068530",
    "end": "4074680"
  },
  {
    "text": "If you look at these\nbits, these 01 bits, they are going to be monotone.",
    "start": "4074680",
    "end": "4081940"
  },
  {
    "text": "They'll be 0 for a while,\nand then at some point",
    "start": "4081940",
    "end": "4087750"
  },
  {
    "text": "they'll switch to being 1's. And that transition from 0 to\n1 that's what we want to find.",
    "start": "4087750",
    "end": "4094740"
  },
  {
    "text": "These keys are too small. These keys are too big. This key is just right.",
    "start": "4094740",
    "end": "4101220"
  },
  {
    "text": "So we fit between-- this would be position\ni and position i plus 1.",
    "start": "4101220",
    "end": "4106889"
  },
  {
    "text": "And we fit between\nxi and xi plus 1. Well, not actually\nxi and xi plus 1. We fit between sketch of\nxi and sketch of xi plus 1.",
    "start": "4106890",
    "end": "4115014"
  },
  {
    "text": "That's what we need to find. Now that is again the\nproblem of finding the most significant 1 bit.",
    "start": "4115014",
    "end": "4120810"
  },
  {
    "text": "But in this case, I don't\nneed that operation. I can do it in a simpler way.",
    "start": "4120810",
    "end": "4126089"
  },
  {
    "text": " But we're almost done, right?",
    "start": "4126090",
    "end": "4131899"
  },
  {
    "text": "We've done all of this\nparallel comparison. We just need to find that\ntransition between 0's and 1's.",
    "start": "4131899",
    "end": "4137989"
  },
  {
    "text": "Turns out there's a\ncool way to do it. ",
    "start": "4137990",
    "end": "4150462"
  },
  {
    "text": "The cool way is multiply that\nword times our good friend,",
    "start": "4150462",
    "end": "4161600"
  },
  {
    "text": "this thing, 000001, 000001.",
    "start": "4161600",
    "end": "4169611"
  },
  {
    "text": "This is a little\nharder to think about. But take this bit string\nand multiply it by this.",
    "start": "4169612",
    "end": "4175399"
  },
  {
    "text": "What that does is it\ntakes this string. It includes it. Because there's a 1 right there. It shifts it over by one field,\nand includes it, shifts it over",
    "start": "4175399",
    "end": "4184399"
  },
  {
    "text": "by another field, includes it. So this repeats this thing. And now collision happens,\nbecause they're perfectly",
    "start": "4184399",
    "end": "4190759"
  },
  {
    "text": "aligned. If these 1 bits ever hit each\nother, they'll be summing. Now, some of them are\n0, some of them are 1.",
    "start": "4190760",
    "end": "4198440"
  },
  {
    "text": "Instead of computing\nthe position of the 0 to 1 transition, we could\nequivalently just count how many 1's are there.",
    "start": "4198440",
    "end": "4205337"
  },
  {
    "text": "I mean that's counting\nfrom the right, whereas this is counting of from\nthe left, whatever, same thing.",
    "start": "4205337",
    "end": "4210870"
  },
  {
    "text": "So if I could count how\nmany 1's I'd be all set. And in this case, if\nyou look at right here,",
    "start": "4210870",
    "end": "4221460"
  },
  {
    "text": "this will be the\nnumber of 1's I claim. Because if this one was\nthere, it will stay there.",
    "start": "4221460",
    "end": "4229070"
  },
  {
    "text": "And then all the other bits\nget shifted over and fall right here on top of this bit.",
    "start": "4229070",
    "end": "4234380"
  },
  {
    "text": "So as they get added up,\nyou'll get some carries and things will move over. But this is not very big.",
    "start": "4234380",
    "end": "4239930"
  },
  {
    "text": "Because we're\ntalking about k bits. So this is only going\nto be with log k.",
    "start": "4239930",
    "end": "4245400"
  },
  {
    "text": " I mean there's tons\nof room here before we get to the next shift.",
    "start": "4245400",
    "end": "4251622"
  },
  {
    "text": "So I just look at these bits. I mask them out. I shift them over. And that gives me\nthe number of 1's.",
    "start": "4251622",
    "end": "4257340"
  },
  {
    "text": "This is a cute way to count the\nnumber of ones in a bit string when the bits are\nspread out nicely.",
    "start": "4257340",
    "end": "4263330"
  },
  {
    "text": "They have to be at least\nlog k away from each other. Otherwise you get collision. It doesn't work for an\narbitrary bit string.",
    "start": "4263330",
    "end": "4268640"
  },
  {
    "text": "But for a bit string\nlike this, we're all set. We can count how\nmany 1's there are. Then we figure out where\nthis transition is.",
    "start": "4268640",
    "end": "4276500"
  },
  {
    "text": "That is parallel comparison. One more thing to do, which\nis most significant set bit.",
    "start": "4276500",
    "end": "4287422"
  },
  {
    "start": "4287422",
    "end": "4293800"
  },
  {
    "text": "The place we needed this, was\nwe were taking the XOR of q with xi.",
    "start": "4293800",
    "end": "4299824"
  },
  {
    "text": "And then we wanted\nto find the first bit where they were differing. So after you take\nthe XOR, you've got some bit string\nthat looks like this.",
    "start": "4299824",
    "end": "4307440"
  },
  {
    "text": "And you want to find\nthis bit, because that's the place you diverged. Then we would turn that to 0\nand change the rest to 1's.",
    "start": "4307440",
    "end": "4313730"
  },
  {
    "text": "That's easy to do if we\nknow where this bit is. And this is a generally\nuseful operation. It's used all over computer\nscience, I would say.",
    "start": "4313730",
    "end": "4323720"
  },
  {
    "text": "So much so that most CPUs\nhave it as an instruction, so on Intel it's called CLZ.",
    "start": "4323720",
    "end": "4330130"
  },
  {
    "text": "And it has many names. They're in the notes. Most compilers\nprovide this to you",
    "start": "4330130",
    "end": "4335390"
  },
  {
    "text": "as an operation on\narchitectures that have it, otherwise they simulate it. They probably don't\nsimulate it as well",
    "start": "4335390",
    "end": "4341660"
  },
  {
    "text": "as I'm going to tell you. Because we're going to\ndo this in constant time on a regular word RAM,\njust C operations,",
    "start": "4341660",
    "end": "4347920"
  },
  {
    "text": "which does not seem to have\nmade it into popular culture. It's slightly\ncomplicated, which is why.",
    "start": "4347920",
    "end": "4356600"
  },
  {
    "text": "But what's cool is\nwe're going to use-- I'm going to do this\nrelatively quickly. Because I don't\nhave a ton of time.",
    "start": "4356600",
    "end": "4362000"
  },
  {
    "text": "We're going to use all the\nthings that we just did again, quickly.",
    "start": "4362000",
    "end": "4367020"
  },
  {
    "text": "Most of them just\nas black boxes. All right. So, here's what\nwe're going to do.",
    "start": "4367020",
    "end": "4373699"
  },
  {
    "text": "Maybe I should go somewhere new. ",
    "start": "4373700",
    "end": "4381430"
  },
  {
    "text": "So, I'm going to use sketches,\nnot approximate sketches, but I'm going to sketches. I'm going to use multiplication. I'm going to use\nparallel comparison.",
    "start": "4381430",
    "end": "4388430"
  },
  {
    "text": "And in some sense I'm going to\nuse most significant set bit. All of these things\nI'm going to use to solve the most\nsignificant set bit problem.",
    "start": "4388430",
    "end": "4395438"
  },
  {
    "start": "4395438",
    "end": "4405410"
  },
  {
    "text": "So here's what we do. We split the word into root\nw clusters of root w bits.",
    "start": "4405410",
    "end": "4421270"
  },
  {
    "text": "Sound familiar? This is exactly what we\ndid in van Emde Boas. So van Emde Boas did\nthis recursively. We're going to do it once.",
    "start": "4421270",
    "end": "4427360"
  },
  {
    "text": "We can only afford\nconstant time. So here's an example. x is 0101, 0000, 1000, 1101.",
    "start": "4427360",
    "end": "4443590"
  },
  {
    "text": "So each of these is root w bits. There's root w of them. It's approximate. It doesn't it to be exactly.",
    "start": "4443590",
    "end": "4449710"
  },
  {
    "text": "But we'll assume x is\na nice power of two, so that works cleanly. ",
    "start": "4449710",
    "end": "4458140"
  },
  {
    "text": "So the first thing, so what\nthe high level idea is I need to find the first\nnon-empty cluster. Here it happens to\nbe the first cluster.",
    "start": "4458140",
    "end": "4465099"
  },
  {
    "text": "And then I need to find the\nfirst 1 bit within the cluster. Hard part is finding the\nfirst non-empty cluster.",
    "start": "4465100",
    "end": "4472480"
  },
  {
    "text": "Actually, the hard\npart or the messy part is finding which\nclusters are empty and which clusters are not.",
    "start": "4472480",
    "end": "4477580"
  },
  {
    "text": "This cluster is not empty. This cluster is empty. These are non-empty. So I want the summary\nvector which is 1011.",
    "start": "4477580",
    "end": "4485739"
  },
  {
    "text": "I claim if I can do that,\neverything else is easy. So let's spend some time on\nidentifying non-empty clusters.",
    "start": "4485740",
    "end": "4496660"
  },
  {
    "start": "4496660",
    "end": "4503380"
  },
  {
    "text": "First thing I do is I take x,\nANDed with this thing, which",
    "start": "4503380",
    "end": "4511000"
  },
  {
    "text": "I'm going to call F, 1000,\n1000, 1000, 1000; F for first.",
    "start": "4511000",
    "end": "4525400"
  },
  {
    "text": "So I'm just seeing which\nof these first bits in each cluster are set.",
    "start": "4525400",
    "end": "4531280"
  },
  {
    "text": "So the result is I get\n0000, 0000, 1000, and 1000.",
    "start": "4531280",
    "end": "4542889"
  },
  {
    "text": "So in particular that tells me\nthis cluster and this cluster are non-empty, because they\nhave the first bit set.",
    "start": "4542890",
    "end": "4549837"
  },
  {
    "text": "What about all those other bits? Well, the other bits I'm going\nto do in a different way. Just the first bits, I\nneed a little bit of room.",
    "start": "4549837",
    "end": "4555670"
  },
  {
    "start": "4555670",
    "end": "4561310"
  },
  {
    "text": "I need this bit of room. I want to put these 1's in. So I've got to get rid of some\nbits to make room for that.",
    "start": "4561310",
    "end": "4569290"
  },
  {
    "text": "So this deals with\nthe first bits. Now I'm going to\nclear those out. So I'm going to take x XOR this.",
    "start": "4569290",
    "end": "4579670"
  },
  {
    "text": "And that will give me everything\nwith the first bits cleared. So I've got 0101,\n0000, 0000, and 0101.",
    "start": "4579670",
    "end": "4594250"
  },
  {
    "text": "These are the rest of the\nbits I've got to figure out. This one is non-empty\nand this one's non-empty.",
    "start": "4594250",
    "end": "4599260"
  },
  {
    "text": "How do you do it? With subtraction. ",
    "start": "4599260",
    "end": "4618920"
  },
  {
    "text": "I take F minus that thing. ",
    "start": "4618920",
    "end": "4626340"
  },
  {
    "text": "This F has 1's, and they're\ngoing to get borrowed. When I take F minus this,\nthis 1 will get borrowed",
    "start": "4626340",
    "end": "4632010"
  },
  {
    "text": "because there's something here. This one will not get\nborrowed because this is 0. This one will not get\nborrowed because this is 0.",
    "start": "4632010",
    "end": "4637623"
  },
  {
    "text": "This one will get borrowed\nbecause there's something here. That's it. We're comparing\nwith 0 everything.",
    "start": "4637623",
    "end": "4644520"
  },
  {
    "text": "So we're going to get, in\nthis case, 0 and some garbage, 1 and 0's, 1, and 0\nwith some garbage.",
    "start": "4644520",
    "end": "4657210"
  },
  {
    "text": "I just care about these bits. These are the bits that tell\nme which ones were empty. The 0's are empty.",
    "start": "4657210",
    "end": "4662340"
  },
  {
    "text": "The 1's are non-empty. So I do a mask. I get 0, and some 0's, 1 and\nsome 0's, 1 and some 0's 0",
    "start": "4662340",
    "end": "4671415"
  },
  {
    "text": "and some 0's. OK. Then I do an XOR with F. Because\nI really want 1 for these guys,",
    "start": "4671415",
    "end": "4681120"
  },
  {
    "text": "and 0 for these guys. 1 means it's not empty. 0 means it's empty.",
    "start": "4681120",
    "end": "4686460"
  },
  {
    "text": " I got that right.",
    "start": "4686460",
    "end": "4691650"
  },
  {
    "text": "So I'm just inverting the 0\nbits to 1 bits, and vice versa. So 1 means this one's not empty.",
    "start": "4691650",
    "end": "4697112"
  },
  {
    "text": "1 means this one's not empty. Those are the non-empty guys. I take this and I OR\nit with this thing.",
    "start": "4697112",
    "end": "4706760"
  },
  {
    "text": " This was the thing\nthat told me which ones had that first bit set.",
    "start": "4706760",
    "end": "4713850"
  },
  {
    "text": "So if I take the OR of those\ntwo I learn, or any bit set. Because this was dealing\nwith all of the other bits.",
    "start": "4713850",
    "end": "4720075"
  },
  {
    "start": "4720075",
    "end": "4728150"
  },
  {
    "text": "I threw away this bit,\nbut I had to remember that it was non-empty. OK. So I take that OR.",
    "start": "4728150",
    "end": "4733160"
  },
  {
    "text": "Now, this tells me those\nthree blocks were not empty. This one was empty. So now here I have the\nbits that I care about.",
    "start": "4733160",
    "end": "4741440"
  },
  {
    "text": "Sadly they're spread out. I'd really like them compressed. So I do that with sketch. ",
    "start": "4741440",
    "end": "4749130"
  },
  {
    "text": "I want to compress them to 1011. It would fit in one\nlittle thing here.",
    "start": "4749130",
    "end": "4755150"
  },
  {
    "text": "Because this is root w. There's root w of them. Sadly, I can't use\napproximate sketch. Because I don't\nhave enough space.",
    "start": "4755150",
    "end": "4762170"
  },
  {
    "text": "This is w to the 1/2. If I used approximate\nsketch I get w--",
    "start": "4762170",
    "end": "4767420"
  },
  {
    "text": "I'd lose this factor of\n4 and be bigger than w. I really need it to\nbe perfectly sketched.",
    "start": "4767420",
    "end": "4774490"
  },
  {
    "text": "Conveniently, you can do\nperfect sketch in this regime. Before the bi's were\narbitrary things.",
    "start": "4774490",
    "end": "4780004"
  },
  {
    "text": "We had no idea how\nthey were spread out. Here bi is root w minus\n1-- that's the first one--",
    "start": "4780004",
    "end": "4787699"
  },
  {
    "text": "plus i times root w. They're nicely uniformly\nspaced by i root w.",
    "start": "4787700",
    "end": "4794750"
  },
  {
    "text": "In this case--  I'm running out of time--",
    "start": "4794750",
    "end": "4800270"
  },
  {
    "text": "I claim you can use mj equal to\nw minus root w minus 1 minus j",
    "start": "4800270",
    "end": "4809792"
  },
  {
    "text": "root w plus j. And I won't go to the proof. There's a sketch in the notes.",
    "start": "4809792",
    "end": "4815929"
  },
  {
    "text": "If you do this, this is\na nice setting of mj. It turns out you will get bi--",
    "start": "4815930",
    "end": "4822490"
  },
  {
    "text": "if we look at bi plus mi,\nthis cancels, this cancels,",
    "start": "4822490",
    "end": "4827900"
  },
  {
    "text": "because i equals j. You're left with w plus j. So in other words, if\nyou look at bi plus mi,",
    "start": "4827900",
    "end": "4835890"
  },
  {
    "text": "you get from bit w to bit\nw plus root w minus 1.",
    "start": "4835890",
    "end": "4842350"
  },
  {
    "text": "These bits will be exactly\nthe bits you care about. So you take those. You mask out the others. You shift it over to\nthe right, and you have",
    "start": "4842350",
    "end": "4849150"
  },
  {
    "text": "exactly your perfect sketch. The thing you need to prove\nhere is that bi plus mj are all distinct.",
    "start": "4849150",
    "end": "4854310"
  },
  {
    "text": "So there's no collisions. But in this case it's\neasy to avoid collisions. You've got all your bits\nnice and consecutive.",
    "start": "4854310",
    "end": "4860070"
  },
  {
    "text": "Now you've got it\ndown to this thing. OK, not quite done though.",
    "start": "4860070",
    "end": "4866226"
  },
  {
    "text": "Only one more minute. Let's say-- well,\nthat was step one.",
    "start": "4866226",
    "end": "4871770"
  },
  {
    "text": "Identify non-empty clusters. Step two was sketch.",
    "start": "4871770",
    "end": "4877770"
  },
  {
    "text": "Step three is find the\nfirst non-empty cluster.",
    "start": "4877770",
    "end": "4884490"
  },
  {
    "text": " I claim this is easy.",
    "start": "4884490",
    "end": "4891710"
  },
  {
    "text": "So I take this sketch vector. It only has root w bits.",
    "start": "4891710",
    "end": "4897040"
  },
  {
    "text": "So I use parallel comparison. ",
    "start": "4897040",
    "end": "4904980"
  },
  {
    "text": "What do I compare to? I'm going to compare many copies\nof this thing to 0001, 0010,",
    "start": "4904980",
    "end": "4914110"
  },
  {
    "text": "0100, 1000; the powers of 2. So I take this.",
    "start": "4914110",
    "end": "4920160"
  },
  {
    "text": "I put them in a vector\nlike the sketch of a node. And I take the k, or I guess\nroot w copies of the sketch",
    "start": "4920160",
    "end": "4929760"
  },
  {
    "text": "of the summary vector. That's this 1011. So I compare four copies\nof this to each of these,",
    "start": "4929760",
    "end": "4936210"
  },
  {
    "text": "and I learn which power\nof 2 it is greater than. In other words, what is the\nmost significant set bit.",
    "start": "4936210",
    "end": "4942600"
  },
  {
    "text": "That's why when I told you\nhow to do over here, when I told you how to do\nparallel comparison,",
    "start": "4942600",
    "end": "4948960"
  },
  {
    "text": "I didn't want to use\nmost significant bit as a subroutine. Because this is a subroutine\nto most significant bit.",
    "start": "4948960",
    "end": "4955110"
  },
  {
    "text": "Over here, we could just do\nthis multiplication and boom, we found what the\nmost significant set bit was as long as\nthere was room to fit",
    "start": "4955110",
    "end": "4961680"
  },
  {
    "text": "all this stuff in a word. And because I've reduced\neverything to size root w, and then only there's\nw of these things",
    "start": "4961680",
    "end": "4968314"
  },
  {
    "text": "to compare to, because\nthat's the width of one of these fields. This all fits in a word. I can do this\nparallel comparison.",
    "start": "4968314",
    "end": "4973950"
  },
  {
    "text": "Boom, I find the first 1 bit\nin this bit string, which happens to be the first bit.",
    "start": "4973950",
    "end": "4979710"
  },
  {
    "text": "That tells me that this cluster\nis a cluster I care about.",
    "start": "4979710",
    "end": "4984820"
  },
  {
    "text": "So I take those bits out. I mask them out,\nshift them over, and I find the first\n1 bit in that cluster.",
    "start": "4984820",
    "end": "4995030"
  },
  {
    "text": "How do I do it? In exactly the same way,\nclusters again, root w bits. I can use parallel\ncomparison to compare it",
    "start": "4995030",
    "end": "5001310"
  },
  {
    "text": "to all these things\nin constant time. I find where the\nfirst 1 bit is there. And then I take this cluster\nC, I take this bit D,",
    "start": "5001310",
    "end": "5013700"
  },
  {
    "text": "and my answer is\nC root w plus D.",
    "start": "5013700",
    "end": "5020150"
  },
  {
    "text": "That is the final index of\nthe most significant 1 bit in constant time, using all\nthose fusion tricks once again.",
    "start": "5020150",
    "end": "5027851"
  },
  {
    "text": "And that in the end\ngives you fusion trees on a word RAM static. ",
    "start": "5027851",
    "end": "5034030"
  },
  {
    "text": "It's complicated, probably\nimpractical, but pretty cool.",
    "start": "5034030",
    "end": "5040070"
  },
  {
    "text": "And we're going to use\nthese bit tricks again. ",
    "start": "5040070",
    "end": "5048040"
  }
]