[
  {
    "text": " The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare",
    "start": "0",
    "end": "6360"
  },
  {
    "text": "continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials",
    "start": "6360",
    "end": "13320"
  },
  {
    "text": "from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu.",
    "start": "13320",
    "end": "18450"
  },
  {
    "text": " ERIK DEMAINE: All right,\ntoday we continue our theme",
    "start": "18450",
    "end": "23530"
  },
  {
    "text": "of integer data structures. And today we're going to look\nat priority queues instead of the predecessor problem, so\nsomething a little different.",
    "start": "23530",
    "end": "30849"
  },
  {
    "text": "Insert, delete, and find min. It turns out priority queues\nare equivalent to sorting",
    "start": "30850",
    "end": "38140"
  },
  {
    "text": "in the sense that if you have,\nnormally they say f of n,",
    "start": "38140",
    "end": "54022"
  },
  {
    "text": "but here we're going to\ndepend on both n and the word size, priority queue.",
    "start": "54022",
    "end": "59170"
  },
  {
    "text": " Well then, of course you\nget a sorting algorithm.",
    "start": "59170",
    "end": "65530"
  },
  {
    "text": "Just insert everything\ninto the priority queue and then find min delete,\nfind min delete, and so on.",
    "start": "65530",
    "end": "71560"
  },
  {
    "text": " So that's the trivial\ndirection of the equivalence.",
    "start": "71560",
    "end": "80080"
  },
  {
    "text": "But it turns out, both\nof these are true. If you have a sorting\nalgorithm with n times f time,",
    "start": "80080",
    "end": "88060"
  },
  {
    "text": "then you can convert it\ninto a priority queue that in the worst case every\noperation takes only f of n, w.",
    "start": "88060",
    "end": "97280"
  },
  {
    "text": "So that's the equivalence\nas the result of Thorpe from a few years ago, 2007.",
    "start": "97280",
    "end": "104890"
  },
  {
    "text": "Kind of a cool breakthrough. There were earlier versions\nthat weren't quite as efficient but this gives you perfect\nefficiency, turning any sorting",
    "start": "104890",
    "end": "111700"
  },
  {
    "text": "algorithm into priority queue. Rough sketch of\nthe data structure is you have a bunch of sorting\nalgorithms which you run now",
    "start": "111700",
    "end": "117790"
  },
  {
    "text": "and then to get little\nparts of the input in order to build an\noverall priority queue.",
    "start": "117790",
    "end": "122810"
  },
  {
    "text": "But it's very complicated. There was an entire\nclass project on assimilating it\nand understanding it.",
    "start": "122810",
    "end": "129699"
  },
  {
    "text": "It's a bit beyond what we\ncan cover in the class. So I'm going to\ntake this as given",
    "start": "129699",
    "end": "134769"
  },
  {
    "text": "and tell you instead\nabout sorting algorithms because there's a major open\nproblem here which is, can you sort n integers, n w bit\nintegers in a word ram's,",
    "start": "134770",
    "end": "143470"
  },
  {
    "text": "word size w in linear time. We still don't know but we\nhave a bunch of results.",
    "start": "143470",
    "end": "149524"
  },
  {
    "text": "In particular,\nwe're going to talk about a couple\ninteresting cases where we can get linear time sorting.",
    "start": "149524",
    "end": "156070"
  },
  {
    "text": "If you've seen radix sort you\nknow another interesting case where linear time\nsorting is possible. ",
    "start": "156070",
    "end": "164409"
  },
  {
    "text": "Interesting open problem here. Can you get constant\ntime decrease key?",
    "start": "164410",
    "end": "173620"
  },
  {
    "text": "And ideally, also insertion? But decrease key would be\nhandy because then this would be useful.",
    "start": "173620",
    "end": "179260"
  },
  {
    "text": " In this reduction if you\nhave a sorting algorithm,",
    "start": "179260",
    "end": "184630"
  },
  {
    "text": "like to get a priority queue\nwith constant time decrease key, that would\nhave applications to Dijkstra's algorithm. Of course, if you can\nsort in linear time",
    "start": "184630",
    "end": "190960"
  },
  {
    "text": "then everything can be\ndone in constant time. So this is not the most\ninteresting open problem but it would be a step\nin that direction.",
    "start": "190960",
    "end": "199400"
  },
  {
    "text": "Cool. So let me tell you some\nbounds about sorting.",
    "start": "199400",
    "end": "206364"
  },
  {
    "start": "206365",
    "end": "212482"
  },
  {
    "text": "So we have n w bit integers.",
    "start": "212482",
    "end": "218556"
  },
  {
    "text": "And you take any of\nthese bounds divide by n you get the priority queue\nbound, the best that we know.",
    "start": "218556",
    "end": "226250"
  },
  {
    "text": "So of course, there's comparison\nsorting, which takes n log n.",
    "start": "226250",
    "end": "232690"
  },
  {
    "text": "So that's an upper bound. Trying to beat that. Trying to get rid of the log. There's a counting sort from\nundergraduate algorithms.",
    "start": "232690",
    "end": "241300"
  },
  {
    "text": "That takes n plus u\ntime because you need to build a table of size u. You've got to zero out\nall the initial counts",
    "start": "241300",
    "end": "248215"
  },
  {
    "text": "so that requires order u time. This is interesting when\nthe word size equals log n.",
    "start": "248215",
    "end": "260470"
  },
  {
    "text": "So that's a case of\npotential interest, because then 2 to\nthe w is just n. So this is linear time.",
    "start": "260470",
    "end": "266759"
  },
  {
    "text": "But even if w is 2 log n,\nradix or 1.1 times log n, then this is bigger n log n.",
    "start": "266760",
    "end": "273250"
  },
  {
    "text": "So, not very good. But we have radix sort,\nwhich is a bit better.",
    "start": "273250",
    "end": "281110"
  },
  {
    "text": "And this is n times\nw divided by log n.",
    "start": "281110",
    "end": "289310"
  },
  {
    "text": "If you do it right you\nhave some word size w, you're using counting sort\nfor each digit in the radix.",
    "start": "289310",
    "end": "297190"
  },
  {
    "text": "So you can afford that the word\nsize of doing counting sort to be exactly log n.",
    "start": "297190",
    "end": "303010"
  },
  {
    "text": "Which means you have your\noverall word you're dividing into chunks of size log n. Each of them you can\ndo in linear time.",
    "start": "303010",
    "end": "309139"
  },
  {
    "text": "So the number of chunks you have\nto do is w divided by log n. And this is linear if\nw equals order log n.",
    "start": "309140",
    "end": "318039"
  },
  {
    "text": " Right, but only then.",
    "start": "318040",
    "end": "324009"
  },
  {
    "text": "So this buys you a little\nbit, but still not great. OK, there's some other\nsorting algorithms",
    "start": "324010",
    "end": "330590"
  },
  {
    "text": "we've implicitly seen because\nwe've seen Van Emde Boas. I mean, any predecessor\ndata structure",
    "start": "330590",
    "end": "336009"
  },
  {
    "text": "gives you a priority\nqueue data structure. Priority queues-- I didn't\nwrite it, but I mentioned--",
    "start": "336010",
    "end": "342530"
  },
  {
    "text": "insert, delete, find min. Find min is a weaker operation\nthan predecessor or successor.",
    "start": "342530",
    "end": "350600"
  },
  {
    "text": "So we can take Van Emde Boas's\npredecessor data structure",
    "start": "350600",
    "end": "357350"
  },
  {
    "text": "and convert it into a\nsorting algorithm and we get order n times log w.",
    "start": "357350",
    "end": "367160"
  },
  {
    "text": "Now this is a little\nbit tricky to compare. Of course, log w\nsounds better than w.",
    "start": "367160",
    "end": "372560"
  },
  {
    "text": "But there's just divided\nby log n, which makes it a little hard to compare.",
    "start": "372560",
    "end": "378620"
  },
  {
    "text": "It turns out there's\nanother version.",
    "start": "378620",
    "end": "385160"
  },
  {
    "text": "You can take this\nsorting algorithm and achieve a bound\nof m log w over log n.",
    "start": "385160",
    "end": "393520"
  },
  {
    "text": " OK, so this is a slight\nimprovement in here.",
    "start": "393520",
    "end": "399500"
  },
  {
    "text": "It's similar to your\nproblem set this week. This specific\nproblem was a problem set in 2005 of this class.",
    "start": "399500",
    "end": "407370"
  },
  {
    "text": "So you can check\nit out if you want to see how to do this\nslight improvement. But now this is clearly\nbetter than this",
    "start": "407370",
    "end": "412814"
  },
  {
    "text": "because here we\nhave w over log n. Here I've got a log in front. So this is a win\nover radex sort.",
    "start": "412814",
    "end": "418540"
  },
  {
    "text": "So Van Emde Boas, here's another\nway in which is interesting. It gives us a strict\nimprovement over radex sort.",
    "start": "418540",
    "end": "425830"
  },
  {
    "text": "And in particular,\nactually both of these",
    "start": "425830",
    "end": "434020"
  },
  {
    "text": "are order n log log n if w\nis not too big, poly log n.",
    "start": "434020",
    "end": "442310"
  },
  {
    "text": " This doesn't actually\nmatter but it's",
    "start": "442310",
    "end": "448130"
  },
  {
    "text": "clearly better than this one. Again, if w is order log n\nyou get this to be linear.",
    "start": "448130",
    "end": "454490"
  },
  {
    "text": "But in particular, it says\noverall you get n log log n up to w being poly log.",
    "start": "454490",
    "end": "461300"
  },
  {
    "text": "OK, why do we care? Because there's this\nother nice algorithm,",
    "start": "461300",
    "end": "466670"
  },
  {
    "text": "signature sort, which\ncovers all large word sizes. And this is an algorithm\nwe will cover today.",
    "start": "466670",
    "end": "473570"
  },
  {
    "text": " It only works when w is\nlarge, and large means",
    "start": "473570",
    "end": "481520"
  },
  {
    "text": "log to the 2 plus epsilon. And this is no matter\nwhat epsilon is.",
    "start": "481520",
    "end": "487740"
  },
  {
    "text": "In reality, it's probably\nlog squared times log log n squared. But be a little\nsloppy and just say,",
    "start": "487740",
    "end": "494750"
  },
  {
    "text": "a little bit bigger\nthan log squared. And then it runs in linear time.",
    "start": "494750",
    "end": "500640"
  },
  {
    "text": "OK, so if you were graphing this\nin your mind you've got time and there's a nice bound\nhere which is order n.",
    "start": "500640",
    "end": "508430"
  },
  {
    "text": "Then we have everything's\nabove n log n. Maybe here we have--",
    "start": "508430",
    "end": "515200"
  },
  {
    "text": "is hard to draw-- n log log n. This is asymptotic space,\nwhich doesn't really exist,",
    "start": "515200",
    "end": "522630"
  },
  {
    "text": "but you know what I mean. And then this is the\nword size versus log n.",
    "start": "522630",
    "end": "529475"
  },
  {
    "text": "Wow, this is hard to-- this is a really weird picture. I've never drawn this before. So you know, initially in\na radex sort, OK log n.",
    "start": "529475",
    "end": "538080"
  },
  {
    "text": "We could get linear time\nor order log n, great.",
    "start": "538080",
    "end": "544125"
  },
  {
    "text": "What this is saying\nis once you get out to log the 2 plus epsilon\nn you can also do linear.",
    "start": "544125",
    "end": "550520"
  },
  {
    "text": "And from here over\nwe have linear time. And here over we\nhave linear time.",
    "start": "550520",
    "end": "555839"
  },
  {
    "text": "So the question is what about\nthis middle range between log n and log to the 2 plus epsilon?",
    "start": "555840",
    "end": "562190"
  },
  {
    "text": "Well, one thing we could do\nis use Van Emde Boas sort,",
    "start": "562190",
    "end": "567530"
  },
  {
    "text": "get an n log log n bound. And so that's one way to fill\nin this range in the middle. And that means overall you can\nalways sort n integers in n log",
    "start": "567530",
    "end": "575570"
  },
  {
    "text": "log n time. If w is big you\nuse signature sort, if w small use Van\nEmde Boas sort.",
    "start": "575570",
    "end": "582170"
  },
  {
    "text": "So this implies n\nlog log n for all w.",
    "start": "582170",
    "end": "589430"
  },
  {
    "text": "So that's something. It's not the best known. Let's see, first result in this\ndirection was by Han in 2001.",
    "start": "589430",
    "end": "600680"
  },
  {
    "text": "And it achieved this bound,\ndeterministic and in the ac 0",
    "start": "600680",
    "end": "610370"
  },
  {
    "text": "ram, so without\nusing multiplication. Which, I guess Van Emde\nBoas doesn't either,",
    "start": "610370",
    "end": "617310"
  },
  {
    "text": "unless I'm missing something. But it got rid of\nthe randomisation which is necessary to get\nlinear space in Van Emde Boas.",
    "start": "617310",
    "end": "625800"
  },
  {
    "text": "The current best\nresult on sorting is by Han and Thorpe in\n2002, so a while ago.",
    "start": "625800",
    "end": "634330"
  },
  {
    "text": "They achieved n square\nroot log w over log n,",
    "start": "634330",
    "end": "642150"
  },
  {
    "text": "which is similar\nto this bound, just has an extra square root here.",
    "start": "642150",
    "end": "650200"
  },
  {
    "text": "So it's a little bit better\nthan Van Emde Boas sort. It uses some clever tricks. It is randomized. ",
    "start": "650200",
    "end": "658779"
  },
  {
    "text": "So still the best deterministic\nbound is n log log n,",
    "start": "658780",
    "end": "663840"
  },
  {
    "text": "And let's see, we can plug\nthat in for this range here.",
    "start": "663840",
    "end": "669790"
  },
  {
    "text": "And it will imply that\nyou get n square root log",
    "start": "669790",
    "end": "676050"
  },
  {
    "text": "log n for all w. Because in particular,\nif w is poly log n,",
    "start": "676050",
    "end": "686340"
  },
  {
    "text": "then this is just log log n. So you get this bound.",
    "start": "686340",
    "end": "691779"
  },
  {
    "text": "Of course, for all w because\nlarge w are already covered. So this sorting algorithm is a\nlittle bit messy, and possibly",
    "start": "691780",
    "end": "699175"
  },
  {
    "text": "not the right answer. I would conjecture you\ncan sort n integers in linear time for all w.",
    "start": "699176",
    "end": "705449"
  },
  {
    "text": "But that is a big open problem. ",
    "start": "705450",
    "end": "712590"
  },
  {
    "text": "This is the current\nstate of the art. So this open question is\nreally about for small w",
    "start": "712590",
    "end": "719300"
  },
  {
    "text": "when w is poly\nlog n, or actually when it's between\nlog and poly log. So to give you a piece\nof the complete picture",
    "start": "719300",
    "end": "726329"
  },
  {
    "text": "I want to tell you\nabout signature sort. Because I think you have\nto use different techniques when w is small versus large.",
    "start": "726330",
    "end": "732389"
  },
  {
    "text": "We know that from fusion\ntrees and Van Emde Boas. So I'll tell you about the\nslightly large case when",
    "start": "732390",
    "end": "738480"
  },
  {
    "text": "w is at least log to\nthe 2 plus epsilon, how to get linear time. And this is fun.",
    "start": "738480",
    "end": "743709"
  },
  {
    "text": "It uses bit tricks, it\nuses a lot of cool ideas, uses hashing, lots of things. It also uses another sorting\nalgorithm called packed sort.",
    "start": "743710",
    "end": "752819"
  },
  {
    "text": "This doesn't fit in\nthe regular table because it's for a situation\nwhen more than one input",
    "start": "752820",
    "end": "758700"
  },
  {
    "text": "number fits in a word. So we're going to let b\ndenote the number of bits in the inputs.",
    "start": "758700",
    "end": "764339"
  },
  {
    "text": "So we have b bit integers. Then when w is at least\nb times log n log log n,",
    "start": "764340",
    "end": "770460"
  },
  {
    "text": "so you can fit log n log log\nn integers in a single word, then you can sort\nthem in linear time.",
    "start": "770460",
    "end": "776982"
  },
  {
    "text": "So it's like your machine\nis just a little bit bigger than what you'd need to\nrepresent the integers, then all sorting can be\ndone in a linear time.",
    "start": "776982",
    "end": "784889"
  },
  {
    "text": "And as you might imagine,\nthis log to the 2 plus epsilon buys you a little bit of\nroom with some tricks,",
    "start": "784890",
    "end": "792660"
  },
  {
    "text": "namely hashing. Right, that's where we're going.",
    "start": "792660",
    "end": "799139"
  },
  {
    "text": "And we'll use yet another\nsorting algorithm, bitonic sort, which\nyou may have seen. It's a sorting network.",
    "start": "799140",
    "end": "805840"
  },
  {
    "text": "It's in CLRS up\nto second edition, but it got removed\nfrom third edition. I guess they thought people\ndidn't use sorting networks,",
    "start": "805840",
    "end": "811950"
  },
  {
    "text": "but we use sorting\nnetworks here.  Because it gives us parallel\nsorting and the word ram",
    "start": "811950",
    "end": "819690"
  },
  {
    "text": "is all about using the\nparallelism in your word. So, we'll get to those.",
    "start": "819690",
    "end": "828420"
  },
  {
    "text": "I'm going to start at the top\nlevel, which is signature sort. And we're going to\nleave things to be done",
    "start": "828420",
    "end": "835050"
  },
  {
    "text": "and then pack sorting\nwill be one of them. And bitonic sorting will\nbe used in pack sorting. So it's a chain like this.",
    "start": "835050",
    "end": "843829"
  },
  {
    "text": "Cool. So I'm going to\nassume my signature",
    "start": "843830",
    "end": "850770"
  },
  {
    "text": "sort that w is at least\nlog to 2 pulse epsilon n",
    "start": "850770",
    "end": "855990"
  },
  {
    "text": "times log log n. This is really just a change\nin what epsilon means.",
    "start": "855990",
    "end": "863407"
  },
  {
    "text": "If you're given some\nparticular epsilon make it a little smaller,\nthen you can afford to add that log log factor.",
    "start": "863407",
    "end": "868560"
  },
  {
    "text": "This is just for convenience. Now here's the idea.",
    "start": "868560",
    "end": "877927"
  },
  {
    "text": "It's a pretty cool\nidea I have to say. It's by Anderson\nand others in 1998.",
    "start": "877927",
    "end": "899250"
  },
  {
    "text": "OK, word size is big,\nwhich is both good and bad. It means the numbers we\nhave to sort are big. They have a lot of bits in\nthem, way more than log n bits.",
    "start": "899250",
    "end": "907600"
  },
  {
    "text": "But also, we have\nthis powerful machine that can handle words\nof very large size",
    "start": "907600",
    "end": "913794"
  },
  {
    "text": "and do things and\nconstant time on them. ",
    "start": "913794",
    "end": "919090"
  },
  {
    "text": "I'd like to make some slop. I want my words to be\nbigger than my items, so first few steps\nare about doing that.",
    "start": "919090",
    "end": "926410"
  },
  {
    "text": "The first idea is, well,\nyou've got this giant word log to the 2 plus epsilon.",
    "start": "926410",
    "end": "932020"
  },
  {
    "text": "So let's split it into chunks. And the number of chunks\nis log to the epsilon.",
    "start": "932020",
    "end": "940180"
  },
  {
    "text": "So that means each chunk is-- well, it could be even bigger.",
    "start": "940180",
    "end": "945710"
  },
  {
    "text": "So it's at least log squared n. But it could be bigger\nthan that because w",
    "start": "945710",
    "end": "951510"
  },
  {
    "text": "is at least log to\nthe 2 plus epsilon. So we don't know. These things are of size w\ndivided by log to the epsilon",
    "start": "951510",
    "end": "957330"
  },
  {
    "text": "n. So it's at least log squared. OK, here's the crazy idea.",
    "start": "957330",
    "end": "964970"
  },
  {
    "text": "We're thinking of our\nnumber being divided into these chunks, you\nknow, it's being represented",
    "start": "964970",
    "end": "970180"
  },
  {
    "text": "in some base, 2 to the w\ndivided by log to the epsilon n. It's a bit of a mouthful.",
    "start": "970180",
    "end": "977510"
  },
  {
    "text": "But think about these digits. I claim if you look at a digit,\nmost values don't appear.",
    "start": "977510",
    "end": "987040"
  },
  {
    "text": "Because how many values\nare there for a digit? Well, it's at least 2\nto the log squared n.",
    "start": "987040",
    "end": "993310"
  },
  {
    "text": "That's a big number. That's way bigger\nthan polynomial and n. But how many different\ndigits are there?",
    "start": "993310",
    "end": "999790"
  },
  {
    "text": "Well, there's n\nnumbers, each of them has log to the epsilon n\ndigits in it appearing.",
    "start": "999790",
    "end": "1007350"
  },
  {
    "text": "And so there's roughly a linear\nnumber of digit values total.",
    "start": "1007350",
    "end": "1012870"
  },
  {
    "text": "But the number of\npossible digit values is 2 to the log log\nsquared n, which is huge, super polynomial.",
    "start": "1012870",
    "end": "1020580"
  },
  {
    "text": "So most digit values don't\nappear in our numbers. So what we're going to\ndo is hash the digit",
    "start": "1020580",
    "end": "1027359"
  },
  {
    "text": "values to reduce their space. Because they're currently living\nin a universe of 2 to the log squared n, but there's\nonly n times log",
    "start": "1027359",
    "end": "1034444"
  },
  {
    "text": "to the epsilon n of them. So we should be able to reduce\nto have a much smaller universe",
    "start": "1034444",
    "end": "1043199"
  },
  {
    "text": "using hashing. Maybe perfect hashing even.",
    "start": "1043200",
    "end": "1050669"
  },
  {
    "text": "I mean, we don't have to\nbe too intelligent here. Tell you what we get. ",
    "start": "1050669",
    "end": "1061980"
  },
  {
    "text": "What I'd like is to reduce\nto a polynomial universe. And another way to say that is\nthat the hash values are order",
    "start": "1061980",
    "end": "1073380"
  },
  {
    "text": "log n bits. So this lets us go to n\nto the 10, or whatever, which is plenty of room. We take any universal\nhash function,",
    "start": "1073380",
    "end": "1083049"
  },
  {
    "text": "as soon as you get to\nroughly n squared size, I mean the square of\nthe number of things,",
    "start": "1083050",
    "end": "1088380"
  },
  {
    "text": "by a birthday paradox, constant\nprobability none of them will hit each other. That was the second\nlevel of perfect hashing.",
    "start": "1088380",
    "end": "1094320"
  },
  {
    "text": "We don't need two levels\nhere, just say OK, user order log n bits. You can set this\nto 100, whatever.",
    "start": "1094320",
    "end": "1100320"
  },
  {
    "text": "Then with high probability\nyou will not get collisions, so none of the chunks\nwill hit each other. So I'm omitting a step\nhere which is how to--",
    "start": "1100320",
    "end": "1107880"
  },
  {
    "text": "OK, I'm omitting a\ncouple of things here. One of them is I want to\ndo this in linear time.",
    "start": "1107880",
    "end": "1116130"
  },
  {
    "text": "Everything has to\nbe in linear time. So one front part\nis I have to compute the hash value of\nall of these digits",
    "start": "1116130",
    "end": "1123210"
  },
  {
    "text": "in a single word\nin constant time. So a brief aside, how would\nI compute a universal hash",
    "start": "1123210",
    "end": "1131549"
  },
  {
    "text": "function of these digits\nindividually in constant time? Well, my personal favorite\nuniversal hashing scheme",
    "start": "1131550",
    "end": "1142230"
  },
  {
    "text": "is the multiplication method. You just need to multiply\nby a single value m",
    "start": "1142230",
    "end": "1148240"
  },
  {
    "text": "and then take it\nmodular something. So if I do\nmultiplication, I mean",
    "start": "1148240",
    "end": "1160690"
  },
  {
    "text": "if you think of there\nbeing something here, something here, something here,\nsomething here, something here, m does multiply each\nof these individually.",
    "start": "1160690",
    "end": "1170481"
  },
  {
    "text": " Wow, that's a rough sketch.",
    "start": "1170481",
    "end": "1176200"
  },
  {
    "text": "I want to hash each of\nthese guys multiply, them by the\nmultiplication method. This would work fine,\nexcept you get overflows,",
    "start": "1176200",
    "end": "1182799"
  },
  {
    "text": "which is a bit messy. So in fact, I'm going to have\nto do it for the odd guys first, multiply them out, mask\nout the bits I care about,",
    "start": "1182800",
    "end": "1190390"
  },
  {
    "text": "then do it for the\neven guys separately. So it's a bit messy. But hand-wavy proof you can\ncompute the hash function",
    "start": "1190390",
    "end": "1198700"
  },
  {
    "text": "of each of these\nguys individually, but in constant time. So that lets me do this. You have to then\ncheck for collisions,",
    "start": "1198700",
    "end": "1204640"
  },
  {
    "text": "which is kind of annoying. Let's not worry about that. Set this really high,\nvery high probability, there will be no collisions.",
    "start": "1204640",
    "end": "1211900"
  },
  {
    "text": "Cool. So at this point we have\nmucked up all the digits.",
    "start": "1211900",
    "end": "1217319"
  },
  {
    "text": "The annoying thing\nabout this hashing is we do not preserve order. ",
    "start": "1217319",
    "end": "1224860"
  },
  {
    "text": "It's a little weird for\na sorting algorithm not preserve order. The whole point is to\nput things in order.",
    "start": "1224860",
    "end": "1231850"
  },
  {
    "text": "But it's going to be\nuseful nonetheless. And so each digit\nhas been mangled. Each digit is out of order.",
    "start": "1231850",
    "end": "1238570"
  },
  {
    "text": "But of course, the\nsequence of digits has been preserved,\nin some sense",
    "start": "1238570",
    "end": "1245800"
  },
  {
    "text": "So, what? Well, at this point\nwe can use packed sorting to sort what remains.",
    "start": "1245800",
    "end": "1252640"
  },
  {
    "start": "1252640",
    "end": "1265836"
  },
  {
    "text": "In general packed\nsorting can sort n b bit integers provided\nb is small, so w",
    "start": "1265836",
    "end": "1273680"
  },
  {
    "text": "is at least b log n log log n. That's the theorem\nof packed sorting.",
    "start": "1273680",
    "end": "1281900"
  },
  {
    "text": "We're going to delay the\ncoverage of this result until later. And I claim that that applies\nhere because each chunk is now",
    "start": "1281900",
    "end": "1296830"
  },
  {
    "text": "order log n bits. And there's log to\nthe epsilon n bits.",
    "start": "1296830",
    "end": "1303200"
  },
  {
    "text": "So b is theta log to\nthe 1 plus epsilon n.",
    "start": "1303200",
    "end": "1311320"
  },
  {
    "text": "And w is at least log to the 2\nplus epsilon times log log n.",
    "start": "1311320",
    "end": "1321889"
  },
  {
    "text": "OK, so the ratio between\nthese is as needed. It's at least log\nn times log log n. ",
    "start": "1321890",
    "end": "1329450"
  },
  {
    "text": "OK, so that's why this is good. There were these things\nwere huge before. We've compressed them a lot.",
    "start": "1329450",
    "end": "1335330"
  },
  {
    "text": "They're at least log square,\nnow they're only log. And so now we can\napply packed sorting.",
    "start": "1335330",
    "end": "1341265"
  },
  {
    "text": " You can fit log times log\nlog items into one word.",
    "start": "1341265",
    "end": "1348460"
  },
  {
    "text": "And that's going to make\nsorting easy, somehow. That's to be done. But now the question is,\nsuppose we had packed sorting,",
    "start": "1348460",
    "end": "1356800"
  },
  {
    "text": "how does this help you? Because this does not sort\nthe original integers. It sorts these\nintegers that have",
    "start": "1356800",
    "end": "1362289"
  },
  {
    "text": "all of their digits\npermuted in some random way. We have no idea how the hash\nfunction re-orders things.",
    "start": "1362290",
    "end": "1369070"
  },
  {
    "text": "So we're not done\nwith signature sort. It's called signature sort, of\ncourse, because of the hashing.",
    "start": "1369070",
    "end": "1374560"
  },
  {
    "text": "You're taking signatures\nof each of these digits. Another word for hashes.",
    "start": "1374560",
    "end": "1379690"
  },
  {
    "text": "All right, next step is to\nbuild a compressed trie.",
    "start": "1379690",
    "end": "1385955"
  },
  {
    "text": " This is a term we\nhaven't used yet.",
    "start": "1385955",
    "end": "1391060"
  },
  {
    "start": "1391060",
    "end": "1397005"
  },
  {
    "text": "So I'm going to\ncall these things that we sorted signatures. And how many people know\nwhat a compressed trie is?",
    "start": "1397005",
    "end": "1406960"
  },
  {
    "text": "OK, no one. Wow, just a few. So you haven't seen\nsuffix trees yet. We're going to cover where\ncompressed tries come",
    "start": "1406960",
    "end": "1412930"
  },
  {
    "text": "from in a couple\nof lectures but we get to see them a little early\nbecause they're cool and needed",
    "start": "1412930",
    "end": "1418480"
  },
  {
    "text": "in this algorithm. So first notion is\nthe notion of a trie.",
    "start": "1418480",
    "end": "1424230"
  },
  {
    "text": "The word trie comes\nfrom retrieval,",
    "start": "1424230",
    "end": "1429340"
  },
  {
    "text": "from old days when\ninformation retrieval was what's now called web\nsearching, or whatever.",
    "start": "1429340",
    "end": "1436640"
  },
  {
    "text": "So it's now pronounced trie. It's just another word\nfor tree, but where",
    "start": "1436640",
    "end": "1442630"
  },
  {
    "text": "the children of the tree\ncome from a fixed universe. ",
    "start": "1442630",
    "end": "1450780"
  },
  {
    "text": "We've been working\nwith tries all the time in pretty much every lecture\nfor the last n lectures,",
    "start": "1450780",
    "end": "1456990"
  },
  {
    "text": "last w lectures, I don't\nknow, a lot of them. We said oh, OK, well\nlet's just consider the space of all possible keys.",
    "start": "1456990",
    "end": "1464261"
  },
  {
    "text": "You know, I've drawn this\npicture zillion times. Even when we weren't doing\nVan Emde Boas, which actually stores all of these\nthings, we were",
    "start": "1464261",
    "end": "1470970"
  },
  {
    "text": "thinking about fusion\ntrees like, oh yeah, so we're storing\nthis value, and we're storing this value,\nand maybe this value.",
    "start": "1470970",
    "end": "1477659"
  },
  {
    "text": "And we understand this\ncorresponds to a 0-bit. These are 0 and 1 bits. This is a 1, 0, 1, whatever.",
    "start": "1477660",
    "end": "1483560"
  },
  {
    "text": "So we understand how to convert\na bit string into this picture. This is what we\ncall a binary trie.",
    "start": "1483560",
    "end": "1489750"
  },
  {
    "text": "I want to do the\nsame thing over here, except it's not a binary trie. Now each digit is giant\nso we're going to have",
    "start": "1489750",
    "end": "1496320"
  },
  {
    "text": "some huge branching factor. So it's going to be\nmore like a b-tree. The first node has a\nwhole bunch of children.",
    "start": "1496320",
    "end": "1503280"
  },
  {
    "text": "I'm not going to even-- I mean, it's 2 to the w divided\nby log to the epsilon n.",
    "start": "1503280",
    "end": "1511060"
  },
  {
    "text": "That's the branching factor. OK, it's big. That's the number of possible\nvalues in the first digit.",
    "start": "1511060",
    "end": "1519570"
  },
  {
    "text": "OK. So then maybe this child\nhas some node there.",
    "start": "1519570",
    "end": "1527190"
  },
  {
    "text": "And maybe this one. ",
    "start": "1527190",
    "end": "1534130"
  },
  {
    "text": "Actually, sorry, I didn't\nwant to draw it that way. I have a specific trie\nin mind, or part of it.",
    "start": "1534130",
    "end": "1540450"
  },
  {
    "start": "1540450",
    "end": "1549200"
  },
  {
    "text": "OK, I mean, trie is going\nto look something like this. It's harder to draw, but\nit's the larger than binary",
    "start": "1549200",
    "end": "1555780"
  },
  {
    "text": "equivalent of this picture. This would be a trie.",
    "start": "1555780",
    "end": "1561370"
  },
  {
    "text": "So let's think about a\nparticular situation. Which is, suppose we just have\ntwo items in this structure.",
    "start": "1561370",
    "end": "1568780"
  },
  {
    "text": "Then it's easier to draw. So let's suppose there's\nsome item over here, x1.",
    "start": "1568780",
    "end": "1574350"
  },
  {
    "text": "There's some item over here, x2. Now, generic picture is they\nshare some common prefix.",
    "start": "1574350",
    "end": "1579402"
  },
  {
    "text": "This is the common prefix.  It's just to understand some\nparticular picture here.",
    "start": "1579402",
    "end": "1586424"
  },
  {
    "text": "Then they diverge, and you know,\nthen they have their own digit values. In some sense, this is the\ndigit value we care about",
    "start": "1586425",
    "end": "1592200"
  },
  {
    "text": "because it distinguishes them. So there's this idea of a\ncompressed trie, which cleans",
    "start": "1592200",
    "end": "1599850"
  },
  {
    "text": "up this picture a little bit.  The idea with the compress\ntrie is very simple.",
    "start": "1599850",
    "end": "1606730"
  },
  {
    "text": "You draw this trie. So here, imagine I'm erasing all\nthe things that do not appear.",
    "start": "1606730",
    "end": "1613350"
  },
  {
    "text": "Maybe all this is gone. So I'm just keeping this\npart of the structure. Let's do it for the\nbinary case first.",
    "start": "1613350",
    "end": "1620140"
  },
  {
    "text": "The idea in a compress\ntrie is very simple. I'm going to contract\nevery non-branching node",
    "start": "1620140",
    "end": "1630619"
  },
  {
    "text": "into its parent. ",
    "start": "1630619",
    "end": "1641930"
  },
  {
    "text": "So what that means. So here I'm storing three\nvalues: 0, 0, 1, 1; 0, 1,",
    "start": "1641930",
    "end": "1648950"
  },
  {
    "text": "0, 0; and 0, 1, 1, 1.",
    "start": "1648950",
    "end": "1654370"
  },
  {
    "text": "So some nodes are\nnon-branching, that's this node, this\nnode, and this node.",
    "start": "1654370",
    "end": "1659605"
  },
  {
    "text": "And the point is well,\nwhy store those nodes? I mean, there was nothing being\ndistinguished at that node, so contract it.",
    "start": "1659605",
    "end": "1665380"
  },
  {
    "text": "So the new picture if I\nredrew this would be 0, 0, 1--",
    "start": "1665380",
    "end": "1672510"
  },
  {
    "text": "sorry, also this\nis non-branching. So in fact, I'm going\nto contract this",
    "start": "1672510",
    "end": "1678537"
  },
  {
    "text": "into its parent,\nthis into its parent. So this whole path,\nthis non-branching path will be left with a single edge\nwhich I will label 0, 1, 1.",
    "start": "1678537",
    "end": "1686139"
  },
  {
    "text": "But it's a single edge\nin this structure. Over here we have an edge 1,\nand now we have 0, 0 here,",
    "start": "1686140",
    "end": "1694090"
  },
  {
    "text": "and 1, 1 here. That is the compressed\ntrie representation of these three values.",
    "start": "1694090",
    "end": "1700660"
  },
  {
    "text": "The nice thing\nabout this structure is every node is branching\nexcept the leaves, which means the number\nof nodes here is",
    "start": "1700660",
    "end": "1707049"
  },
  {
    "text": "linear in the number of leaves. That's like twice the number\nof leaves minus 1, roughly.",
    "start": "1707050",
    "end": "1712960"
  },
  {
    "text": "I guess the root might\nnot be branching. It has no parent\nto contract into. Whatever.",
    "start": "1712960",
    "end": "1718660"
  },
  {
    "text": "But more and more\nnodes, most 2n nodes. That's the binary case. Now over here what we do is in\nthe corresponding contracted",
    "start": "1718660",
    "end": "1727009"
  },
  {
    "text": "try a picture of this thing. Let's see, it's a second edge. I'm going to put just a label\nof 2 on this edge to say, well,",
    "start": "1727010",
    "end": "1733990"
  },
  {
    "text": "I'm skipping this node. This guy is non-branching. So I want to get rid of it and\ncontract it into the parent.",
    "start": "1733990",
    "end": "1739840"
  },
  {
    "text": "So now this corresponds\nto two edges here. There are two digits, which\nI could write the digits if I knew what they were.",
    "start": "1739840",
    "end": "1745690"
  },
  {
    "text": "But particularly I want\nto keep track of the fact that there exactly two of them.",
    "start": "1745690",
    "end": "1751100"
  },
  {
    "text": "And then there's\na branching node. That one stays. But then I actually we'll go\nstraight to the leaves here.",
    "start": "1751100",
    "end": "1757039"
  },
  {
    "text": "This will be x1 and x2.",
    "start": "1757040",
    "end": "1762360"
  },
  {
    "text": "And this will have\na lot of digits.  OK, so some large\nnumber written here.",
    "start": "1762360",
    "end": "1769000"
  },
  {
    "text": "So that's the idea\nwith a compress trie. Now the nice thing\nabout a compress trie",
    "start": "1769000",
    "end": "1774030"
  },
  {
    "text": "is they have linear size,\nnumber of edges and vertices",
    "start": "1774030",
    "end": "1780000"
  },
  {
    "text": "is linear in the\nnumber of leaves, which is the number of\nvalues we have here.",
    "start": "1780000",
    "end": "1785760"
  },
  {
    "text": "Another nice thing\nabout compress tries is they preserve order. So if you look at the\norder of the leaves",
    "start": "1785760",
    "end": "1790830"
  },
  {
    "text": "down here it's the same as the\norder of the leaves over here. We're not really\nchanging order, we're",
    "start": "1790830",
    "end": "1795870"
  },
  {
    "text": "just making things a little\nshorter to write down. Same thing over here. I mean, x1 appears\nthe left of x2.",
    "start": "1795870",
    "end": "1802500"
  },
  {
    "start": "1802500",
    "end": "1818130"
  },
  {
    "text": "Say the order of the\nleaves is preserved. The other cool thing\nabout compress tries is you can compute\nthem in linear time.",
    "start": "1818130",
    "end": "1825120"
  },
  {
    "text": "But let me tell you why\nwe're drawing this picture. We've messed up all these\nchunks, all these digits.",
    "start": "1825120",
    "end": "1832320"
  },
  {
    "text": "What does that correspond\nto in this picture? We've permuted all of the\nchildren in this node.",
    "start": "1832320",
    "end": "1837661"
  },
  {
    "text": "We've permuted all the\nchildren in this node, permuted all the children in this node. But otherwise, the structure\nof the tree is correct.",
    "start": "1837661",
    "end": "1844019"
  },
  {
    "text": "What we wanted to\ndo was compute-- if we could compute the\ncompress trie representation of the original values just\nhaving broken the integers",
    "start": "1844020",
    "end": "1853020"
  },
  {
    "text": "into these pieces, then if we\nhad that trie we could just do an in order traversal,\nfind the order of the leaves,",
    "start": "1853020",
    "end": "1858210"
  },
  {
    "text": "then we'd have the sorted\norder of the integers. Instead what we've computed\nis we didn't compute",
    "start": "1858210",
    "end": "1865590"
  },
  {
    "text": "the correct compress trie. But we computed a\ndifferent compress trie where every node has\nits children permuted.",
    "start": "1865590",
    "end": "1872220"
  },
  {
    "text": "So all we need to do is put\nthe children within each node in the correct\norder, then we would",
    "start": "1872220",
    "end": "1877860"
  },
  {
    "text": "have the correct compress trie. OK, that's why we're doing this. But first, how do we compute a\ncompress trie in linear time?",
    "start": "1877860",
    "end": "1887400"
  },
  {
    "text": " This is a simple\namortization argument.",
    "start": "1887400",
    "end": "1893950"
  },
  {
    "start": "1893950",
    "end": "1908887"
  },
  {
    "text": "Remember what we're given.  At this point we are given\nthe leaves in sorted order.",
    "start": "1908887",
    "end": "1917070"
  },
  {
    "text": "We've just sorted our things\nso all I'm trying to do is compute the trie of the\nstuff above the things.",
    "start": "1917070",
    "end": "1922970"
  },
  {
    "text": "OK, we're given the leaves of\nthe trie in the correct order. I just need to build\nthe compress trie.",
    "start": "1922970",
    "end": "1928030"
  },
  {
    "text": "The reason I'm building\na compress trie is so I can do it\nin linear time. Constructing the uncompressed\ntrie would take too long.",
    "start": "1928030",
    "end": "1935780"
  },
  {
    "text": "OK, so how do we do this? ",
    "start": "1935780",
    "end": "1946149"
  },
  {
    "text": "We have our items xn in order. ",
    "start": "1946150",
    "end": "1954340"
  },
  {
    "text": "I want to just insert it\ninto the compress trie.",
    "start": "1954340",
    "end": "1961570"
  },
  {
    "text": "So I start with an\nempty compress trie. First thing I do is add x1,\nso it's just a single leaf.",
    "start": "1961570",
    "end": "1967840"
  },
  {
    "text": "Then I add x2 to the\ntrie, x3 to the trie. In general, I'll have computed--",
    "start": "1967840",
    "end": "1973029"
  },
  {
    "text": "I'm going to draw a picture. How to draw a partial\ntrie, something like this.",
    "start": "1973030",
    "end": "1978060"
  },
  {
    "text": "I've computed the left\npart of trie already. All these x1's have been done.",
    "start": "1978060",
    "end": "1983080"
  },
  {
    "text": "And now I need to\nadd on the next, say xi over here somewhere.",
    "start": "1983080",
    "end": "1989930"
  },
  {
    "text": "So think of how that\nwould look in the trie. It has to come off\nof the right side,",
    "start": "1989930",
    "end": "1995715"
  },
  {
    "text": "I guess what would\nyou call this? The right spine of the tree. Some right most node over here.",
    "start": "1995715",
    "end": "2002310"
  },
  {
    "text": "We want xi to be a new\nto the right child. So one possible\npicture is there was",
    "start": "2002310",
    "end": "2010890"
  },
  {
    "text": "some node which had\nsome other children, maybe this one had xi minus 1.",
    "start": "2010890",
    "end": "2017100"
  },
  {
    "text": "Maybe xi belongs over here. Maybe this leads to xi\nin the uncompressed trie.",
    "start": "2017100",
    "end": "2023700"
  },
  {
    "text": "This could be a\npotential picture. In the compress trie\nthis node either exists",
    "start": "2023700",
    "end": "2029309"
  },
  {
    "text": "or got contracted. If it exists maybe there\nwas a previous xi minus 2",
    "start": "2029310",
    "end": "2035250"
  },
  {
    "text": "belongs over here. So we already had this node\nbecause it distinguished these two xj's.",
    "start": "2035250",
    "end": "2041410"
  },
  {
    "text": "To add the xi is really easy. I just add a node here and then\nwhich points to a leaf of xi.",
    "start": "2041410",
    "end": "2047820"
  },
  {
    "text": "So that could be one situation. The other situation is only\nslightly more complicated.",
    "start": "2047820",
    "end": "2053480"
  },
  {
    "start": "2053480",
    "end": "2061980"
  },
  {
    "text": "So the other\npossibility is this node didn't exist in the compressed\ntrie, which means we jumped",
    "start": "2061980",
    "end": "2068730"
  },
  {
    "text": "over it in the compress trie. Some number bigger\nthan 1 here, maybe you",
    "start": "2068730",
    "end": "2075210"
  },
  {
    "text": "skipped three nodes, who knows. So now this node matters.",
    "start": "2075210",
    "end": "2080450"
  },
  {
    "text": "It didn't matter before. Before it was non-branching, but\nnow we add xi, it's branching. All we do is update,\nadd this new guy,",
    "start": "2080451",
    "end": "2088908"
  },
  {
    "text": "add the new pointer to xi. OK, so constant work.",
    "start": "2088909",
    "end": "2094949"
  },
  {
    "text": "Great, constant work per xi\ninserted, linear time overall. Not really.",
    "start": "2094949",
    "end": "2100920"
  },
  {
    "text": "I've cheated a little\nbit here, which is how do we know what we're\ngoing to do this operation. So the changes we make\nis constant, that's fine.",
    "start": "2100920",
    "end": "2108930"
  },
  {
    "text": "But how did I find that\nthis was the edge where I need to put xi in? You can't do it\nin constant time,",
    "start": "2108930",
    "end": "2114990"
  },
  {
    "text": "but we can do it in\nconstant amortized time. So what we're going to do\nis start at the right most--",
    "start": "2114990",
    "end": "2122700"
  },
  {
    "text": "that is not very red. Not a red chalk.",
    "start": "2122700",
    "end": "2129964"
  },
  {
    "text": "Red chalk. We start at this leaf, the\nrightmost leaf which you go",
    "start": "2129965",
    "end": "2135630"
  },
  {
    "text": "going right most as possible. We're going to walk up the tree\nuntil we find the right point.",
    "start": "2135630",
    "end": "2142089"
  },
  {
    "text": "We're going to spend\nlinear time this path walk. OK, how could this\npossibly be OK?",
    "start": "2142090",
    "end": "2147532"
  },
  {
    "text": "I think you believe that I can\ndo it in linear time, right. Each point I see-- what is my common prefix?",
    "start": "2147532",
    "end": "2153660"
  },
  {
    "text": "Actually an easy way\nis right up front. This thing right\nhere is xi minus 1.",
    "start": "2153660",
    "end": "2159510"
  },
  {
    "text": "These are single integers. So I can just compute\ntheir x or, find the most significant one bit,\nwhich we did with the fusion",
    "start": "2159510",
    "end": "2166560"
  },
  {
    "text": "tree lecture. And boom, I know where they\ndiffer in bit position.",
    "start": "2166560",
    "end": "2172890"
  },
  {
    "text": "By some rounding\nI can figure out which chunk they differ\nin, just by dividing,",
    "start": "2172890",
    "end": "2179069"
  },
  {
    "text": "taking the ceiling.  So I know the correct depth.",
    "start": "2179070",
    "end": "2186180"
  },
  {
    "text": "And then these numbers tell\nme how much depth I'm losing. As I walk up at some\npoint I'll discover,",
    "start": "2186180",
    "end": "2192480"
  },
  {
    "text": "oops, I just jumped\nover the depth I care about where they differ. And so at that point I\nknow to do that operation.",
    "start": "2192480",
    "end": "2198480"
  },
  {
    "text": "So if there are k edges\nhere on the compress trie, I can do this in order k\ntime, k plus 1, let's say.",
    "start": "2198480",
    "end": "2208390"
  },
  {
    "text": "Why is that OK? Because my potential\nfunction, amortization",
    "start": "2208390",
    "end": "2215190"
  },
  {
    "text": "is going to be the length\nof the rightmost path.",
    "start": "2215190",
    "end": "2223045"
  },
  {
    "text": " OK, before my rightmost\npath was this thing.",
    "start": "2223045",
    "end": "2230020"
  },
  {
    "text": "Afterwards, my rightmost path\nis going to be this thing. So it got roughly k\nshorter, k minus 1 shorter.",
    "start": "2230020",
    "end": "2237270"
  },
  {
    "text": "OK, so I charged\nthis k plus 1 cost to a potential\ndecrease of k minus 1.",
    "start": "2237270",
    "end": "2244849"
  },
  {
    "text": "And so the amortize\ncost is only constant. Easy amortization. Another way to see\nthis is, overall",
    "start": "2244850",
    "end": "2251619"
  },
  {
    "text": "we're basically doing it in\norder traversal of the tree. So whenever we walk up we'll\nnever visit these nodes again,",
    "start": "2251620",
    "end": "2257080"
  },
  {
    "text": "because then we go down\nat a different place. OK, yeah, this guy we're\ngoing to walk up again because in an in order\ntraversal we would have gone",
    "start": "2257080",
    "end": "2263195"
  },
  {
    "text": "left and then come back\nto it and then gone down. So overall we're\ndoing an in order traversal of the compress trie,\nso it's linear time total.",
    "start": "2263195",
    "end": "2271140"
  },
  {
    "start": "2271140",
    "end": "2276271"
  },
  {
    "text": "OK.  Still not done though.",
    "start": "2276271",
    "end": "2282084"
  },
  {
    "text": "What we have so far--\nwhat have we done? We've taken our numbers,\nwe've split them into digits. We randomly permuted the\ndigits via hash function.",
    "start": "2282084",
    "end": "2289869"
  },
  {
    "text": "That magically let us\nsort them in linear time. Now we've built a compress\ntrie of that representation.",
    "start": "2289870",
    "end": "2295900"
  },
  {
    "text": "The last thing to do is to\nfix the order of the children from each node. The tree is correct\nexcept for the order",
    "start": "2295900",
    "end": "2303130"
  },
  {
    "text": "of the children in each node. So we've kind of sorted a little\nbit, but haven't fully sorted.",
    "start": "2303130",
    "end": "2310059"
  },
  {
    "text": "So that's the last step. And we're going to do\nthat with recursion.",
    "start": "2310060",
    "end": "2319320"
  },
  {
    "text": " We're only going to recurse\na constant number of times.",
    "start": "2319320",
    "end": "2325724"
  },
  {
    "text": " Recursively sort. ",
    "start": "2325725",
    "end": "2360970"
  },
  {
    "text": "OK, I'm going to walk\nthrough this compress try trie we've built. And I\nguess it looks more like this.",
    "start": "2360970",
    "end": "2369450"
  },
  {
    "text": "And for each edge I'm going\nto write down this key. First thing you're\ngoing to write down",
    "start": "2369450",
    "end": "2375460"
  },
  {
    "text": "is the ID of the node. Let's say the ID is the in order\ntraversal index of the node.",
    "start": "2375460",
    "end": "2382260"
  },
  {
    "text": "OK, so boom. As we traverse the tree we can\njust increment this counter.",
    "start": "2382260",
    "end": "2387910"
  },
  {
    "text": "Then we also want-- what I'm going to put in here\nis the actual chunk value",
    "start": "2387910",
    "end": "2397960"
  },
  {
    "text": "that's at the top of the node. So something like this,\nor I guess this one. This one consists\nof two chunk values.",
    "start": "2397960",
    "end": "2405400"
  },
  {
    "text": "So it's called c1, for\nchunk values, c1 and c2. It's the first chunk\nvalue and the second chunk",
    "start": "2405400",
    "end": "2411310"
  },
  {
    "text": "value, first digit\nand the second digit. Just write down the first one. ",
    "start": "2411310",
    "end": "2418062"
  },
  {
    "text": "That's really the only\none we care about. The second one wasn't\nbranching so it's no big deal. ",
    "start": "2418062",
    "end": "2424440"
  },
  {
    "text": "OK, so there's some chunk value. Now, I don't want to write\ndown the signature chunk value.",
    "start": "2424440",
    "end": "2430380"
  },
  {
    "text": "I don't want to write\ndown the hash value. I want the actual chunk,\noriginal chunk not the hash.",
    "start": "2430380",
    "end": "2437040"
  },
  {
    "text": "That's why I write\nactual over here and then also, I'm\ngoing to write down the index of the edge.",
    "start": "2437040",
    "end": "2442780"
  },
  {
    "text": "So this is the second\nedge, for example. OK, now this is in some\nsense the wrong index.",
    "start": "2442780",
    "end": "2449560"
  },
  {
    "text": "And what I want to compute\nis where it's supposed to be. The edges have been permuted. So if I sort this\nthing, I claim that I'll",
    "start": "2449560",
    "end": "2456090"
  },
  {
    "text": "find that all the\ndesired permutations. OK, why?",
    "start": "2456090",
    "end": "2462059"
  },
  {
    "text": "Because if I sort by\nthis triple, first thing",
    "start": "2462060",
    "end": "2467280"
  },
  {
    "text": "I sort by is by node ID, then\nI'm sorting by actual chunk value, then edge index. I don't care that I'm\nsorting by it, that's",
    "start": "2467280",
    "end": "2473910"
  },
  {
    "text": "just coming along for the ride. So what this tells\nme is for each node",
    "start": "2473910",
    "end": "2480270"
  },
  {
    "text": "it gives me the sorted value\nof the actual chunks, not the hash chunks. And then it tells me the\norder they used to be in.",
    "start": "2480270",
    "end": "2488160"
  },
  {
    "text": "So this is a way to figure\nout the sorted permutation",
    "start": "2488160",
    "end": "2493200"
  },
  {
    "text": "of these things. This gives you the old index. And so once you've\nsorted them you know that new correct\norder is in order by chunk.",
    "start": "2493200",
    "end": "2501510"
  },
  {
    "text": "And so this gives\nyou the inverse of the permutation over here,\nof where each edge should be.",
    "start": "2501510",
    "end": "2507420"
  },
  {
    "text": "So once I've done\nthis the last step is",
    "start": "2507420",
    "end": "2512670"
  },
  {
    "text": "for each node permute\nthe edges as given",
    "start": "2512670",
    "end": "2524339"
  },
  {
    "text": "by this inverse permutation. Questions? AUDIENCE: Can you\nexplain again that?",
    "start": "2524340",
    "end": "2529659"
  },
  {
    "text": "You were basically\nsorting three times. ERIK DEMAINE: No, I'm sorting\nthese single key values.",
    "start": "2529659",
    "end": "2534756"
  },
  {
    "text": "The key value, the most\nsignificant part of the key is this. The next most significant\npart of the key is this. And the least significant\npart of the key is this.",
    "start": "2534756",
    "end": "2541360"
  },
  {
    "text": "So imagine concatenating\nthese things together into a single key value. Yeah, good question.",
    "start": "2541360",
    "end": "2546539"
  },
  {
    "text": "What I'll talk about in a\nmoment, how big this key is. But if I sort by the\nconcatenation of those keys",
    "start": "2546540",
    "end": "2552390"
  },
  {
    "text": "then what happens is\nI'm sorting by this and then sorting by this. But really, I'm doing\none sort operation. This is one recursion.",
    "start": "2552390",
    "end": "2559620"
  },
  {
    "text": "Other questions? OK. Do you see why this\ngives us what we need?",
    "start": "2559620",
    "end": "2566520"
  },
  {
    "text": "For every node we want\nto sort all those chunks. And so this information\nis just so we",
    "start": "2566520",
    "end": "2571806"
  },
  {
    "text": "can keep track of\nthe permutation when we're just sorting\nby value and not keeping the permutation. This let's us keep track of it.",
    "start": "2571806",
    "end": "2578650"
  },
  {
    "text": "But our real goal is to\nsort all the chunk values. And we add in the node\nID so that we just",
    "start": "2578650",
    "end": "2584430"
  },
  {
    "text": "learn for every node what\nwe're supposed to do instead of globally what we need to do. Maybe you don't have to\ndo this but it's easier",
    "start": "2584430",
    "end": "2590670"
  },
  {
    "text": "to keep the node ID in there. OK, how many bits\nare in this key?",
    "start": "2590670",
    "end": "2597004"
  },
  {
    "text": "So our whole point was\nto make chunks small so that the keys were small. But I claim this will be a\nlittle bit smaller than what",
    "start": "2597004",
    "end": "2602460"
  },
  {
    "text": "we started with. So the node ID, well,\nthere's only n nodes, so this is log n bits.",
    "start": "2602460",
    "end": "2609510"
  },
  {
    "text": "Chunk value is, I\nguess, w divided by log",
    "start": "2609510",
    "end": "2615090"
  },
  {
    "text": "to the epsilon n bits. Because there are a log\nto the epsilon n chunks,",
    "start": "2615090",
    "end": "2622069"
  },
  {
    "text": "so it's w divided by\nlog to the epsilon bits. The edge index, how many\ndifferent things were there?",
    "start": "2622070",
    "end": "2630390"
  },
  {
    "text": " Is it also w divided\nby log to the epsilon?",
    "start": "2630390",
    "end": "2637090"
  },
  {
    "text": "I guess so. Depends how you count. ",
    "start": "2637090",
    "end": "2644390"
  },
  {
    "text": "Let me think for a second\nhow these edge indices should be stored. ",
    "start": "2644390",
    "end": "2652140"
  },
  {
    "text": "I think I'd like to\nstore the edge indices-- I don't want to store\nthe absent down pointers.",
    "start": "2652140",
    "end": "2660150"
  },
  {
    "text": "The way that I built this\ntree, this compress trie, I was always adding\nthings to the right.",
    "start": "2660150",
    "end": "2665920"
  },
  {
    "text": "So it's like OK,\nI'm storing here. Here's the first child,\nhere's the next child, here's the next child,\nhere's the next child.",
    "start": "2665920",
    "end": "2672344"
  },
  {
    "text": "I just keep appending on. It's like an array that you\ncan grow to the right, which you should know how to\ndo in constant time,",
    "start": "2672344",
    "end": "2677460"
  },
  {
    "text": "even though linked\nlist is probably fine.  If there are a\nbunch of values here",
    "start": "2677460",
    "end": "2682800"
  },
  {
    "text": "that are just null\npointers I don't want to store those\nitems in the array. So in fact, the maximum number\nof children of a node is n.",
    "start": "2682800",
    "end": "2690359"
  },
  {
    "text": "I mean, at the worst case you\nhave branching everywhere. So this is only log n bits to\nstore the index in that array.",
    "start": "2690360",
    "end": "2703050"
  },
  {
    "text": "So it's an extra\nlevel of compression. I guess I didn't mention\ndon't store null pointers,",
    "start": "2703050",
    "end": "2713150"
  },
  {
    "text": "just skip them. And that's easy to do because\nyou're always just appending.",
    "start": "2713150",
    "end": "2719510"
  },
  {
    "text": "And in the end what\ndo I need to do here? Step seven is in order\ntraversal of the compress trie.",
    "start": "2719510",
    "end": "2733010"
  },
  {
    "text": " And I output all the\nleaves I get in order.",
    "start": "2733010",
    "end": "2743654"
  },
  {
    "text": "And the point is we computed\nthe compress trie which has the rough correct\ntopological structure.",
    "start": "2743654",
    "end": "2748910"
  },
  {
    "text": "Then we fix the order\nwithin each node, now we have the correctly\nsorted compress trie. And so you're just doing\nin order traversal, output",
    "start": "2748910",
    "end": "2755980"
  },
  {
    "text": "the leave you get in order. Boom, we've sorted\nall the items. A little crazy.",
    "start": "2755980",
    "end": "2761315"
  },
  {
    "text": " So if all we need to do in\nthe end is in order traversal then it's fine we don't need\nto store the null pointers.",
    "start": "2761315",
    "end": "2768553"
  },
  {
    "text": "So we don't need to be able\nto search in this trie, so this is enough. ",
    "start": "2768553",
    "end": "2774589"
  },
  {
    "text": "Clear? OK, the remaining\nquestion is how expensive is this recursion?",
    "start": "2774590",
    "end": "2779970"
  },
  {
    "text": "So I computed the number\nof bits basically w divided by log to the\nepsilon n, plus order log n.",
    "start": "2779970",
    "end": "2787020"
  },
  {
    "text": "That order log n won't hurt us. Now, we started with\nintegers of size w,",
    "start": "2787020",
    "end": "2792660"
  },
  {
    "text": "the total size here was w. Now we have integers that\ntheir size is w divided",
    "start": "2792660",
    "end": "2799850"
  },
  {
    "text": "by log to the epsilon n. So we've made progress. ",
    "start": "2799850",
    "end": "2805010"
  },
  {
    "text": "Cool. How much progress? ",
    "start": "2805010",
    "end": "2813380"
  },
  {
    "text": "Over here maybe. ",
    "start": "2813380",
    "end": "2821710"
  },
  {
    "text": "After, let's say, 1\nover epsilon plus 1 recursions we will\nhave reached b will",
    "start": "2821710",
    "end": "2837230"
  },
  {
    "text": "have decreased to order log n.",
    "start": "2837230",
    "end": "2847109"
  },
  {
    "text": "I guess, like 1 over epsilon\nlog n plus w over log",
    "start": "2847110",
    "end": "2856350"
  },
  {
    "text": "to the 1 plus epsilon n. ",
    "start": "2856350",
    "end": "2867480"
  },
  {
    "text": "OK. Right, if we take\nw and every time we divide by log to the epsilon n,\nthen after 1 over epsilon times",
    "start": "2867480",
    "end": "2874630"
  },
  {
    "text": "we have divided by log\nn, get rid of epsilon. Do it one more time,\nwe get w divided",
    "start": "2874630",
    "end": "2879910"
  },
  {
    "text": "by log to the 1 plus epsilon n. And at this point\nwe're in good shape.",
    "start": "2879910",
    "end": "2885720"
  },
  {
    "text": " If we get the size\nof our integers",
    "start": "2885720",
    "end": "2891700"
  },
  {
    "text": "to be only w divided by log\nto the 1 plus epsilon n, then we can use packed sorting.",
    "start": "2891700",
    "end": "2898450"
  },
  {
    "text": "Because packed sorting,\nconveniently it's the black box at the\nmoment, says well, as long as w divided by b is\na little bigger than log n.",
    "start": "2898450",
    "end": "2905710"
  },
  {
    "text": "So here we've made it quite\na bit bigger than log n. I mean, log to the 1\nplus epsilon n bigger,",
    "start": "2905710",
    "end": "2911560"
  },
  {
    "text": "then we can use packed sorting. ",
    "start": "2911560",
    "end": "2917680"
  },
  {
    "text": "Reach base case, and\nthen use packed sorting.",
    "start": "2917680",
    "end": "2924550"
  },
  {
    "start": "2924550",
    "end": "2930740"
  },
  {
    "text": "OK, the only thing is\nthere's this log n. Now, epsilon is a constant here,\nso 1 over epsilon is constant.",
    "start": "2930740",
    "end": "2936890"
  },
  {
    "text": "So this is just order log n. Order log n doesn't hurt you. I mean, if this happened\nto dominate this",
    "start": "2936890",
    "end": "2943030"
  },
  {
    "text": "then you're saying your values\nare order log n bits long, and so you use radex sort.",
    "start": "2943030",
    "end": "2948740"
  },
  {
    "text": "So that's not going to dominate. In fact, you can\nprove in this case it's not going to dominate. w\nis at least log to the 2 plus",
    "start": "2948740",
    "end": "2954528"
  },
  {
    "text": "epsilon. So you take w\ndivided by log to 1 plus epsilon, that's\nstill at least log n.",
    "start": "2954528",
    "end": "2960010"
  },
  {
    "text": "So this will always dominate. ",
    "start": "2960010",
    "end": "2967360"
  },
  {
    "text": "OK, so we did all\nthis work and all we did was reduce our word size\nby a log to the epsilon factor.",
    "start": "2967360",
    "end": "2975142"
  },
  {
    "text": "But that's enough,\nbecause after we do that 1 over\nepsilon plus 1 times",
    "start": "2975142",
    "end": "2980310"
  },
  {
    "text": "the words are small enough,\nor the items we're sorting are small enough, that we\ncan use packed sorting.",
    "start": "2980310",
    "end": "2985750"
  },
  {
    "text": "And boom, we're done. OK, that is the beauty\nof signature sort.",
    "start": "2985750",
    "end": "2992140"
  },
  {
    "text": "Any questions about that? Definitely not easy. ",
    "start": "2992140",
    "end": "2999020"
  },
  {
    "text": "But, it works. The crazy idea is, well,\ndecompose into these digits.",
    "start": "2999020",
    "end": "3004594"
  },
  {
    "text": "And when we decompose into\nlog to the epsilon digits because that would be enough. If we can get things down\nto a single digit life",
    "start": "3004594",
    "end": "3010270"
  },
  {
    "text": "would be easy. Which I guess is kind of\nlike Van Emde Boas, right.",
    "start": "3010270",
    "end": "3016550"
  },
  {
    "text": "It's like our lower\nbounds from last time. I don't know. If we can make it to only\none digit mattered then",
    "start": "3016550",
    "end": "3022960"
  },
  {
    "text": "we could afford to do it because\neach digit is quite a bit smaller. It's smaller by a factor\nof log to the epsilon n.",
    "start": "3022960",
    "end": "3030790"
  },
  {
    "text": "So we did that\nsplitting and then there was this observation that\nmost digit values aren't used.",
    "start": "3030790",
    "end": "3036200"
  },
  {
    "text": "So if we hash then\nthings got a lot smaller. Then we can afford to pack sort.",
    "start": "3036200",
    "end": "3041260"
  },
  {
    "text": "Except that hash didn't\npreserve the order. How didn't it\npreserve the order? Well, when you look\nat the compress trie",
    "start": "3041260",
    "end": "3046660"
  },
  {
    "text": "you see how it got messed up. Each node got messed\nup individually, but overall the structure\nof the trie was correct.",
    "start": "3046660",
    "end": "3052535"
  },
  {
    "text": "So we did all this work to\nget the structure of the trie. Then we had to fix\nthe node order. But that's really just\nsorting a single digit.",
    "start": "3052535",
    "end": "3059079"
  },
  {
    "text": "And yeah, we have to do it for\nall nodes but you add them up. It's still only n items\nthat we need to sort.",
    "start": "3059080",
    "end": "3065200"
  },
  {
    "text": "So I wrote that b went down. n stays the same.",
    "start": "3065200",
    "end": "3070515"
  },
  {
    "text": "The number of things\nwe have to sort of stays the same, which is fine. We're not trying\nto reduce n, we're",
    "start": "3070515",
    "end": "3077190"
  },
  {
    "text": "just trying to reduce\nthe size of our items to be a little\nbit smaller than w so then we can use\npacked sorting.",
    "start": "3077190",
    "end": "3082770"
  },
  {
    "text": "OK, I think I've gone over\nthis algorithm enough times. The next step is packed sorting.",
    "start": "3082770",
    "end": "3089320"
  },
  {
    "text": " If we have integers that are\nmuch smaller than our word,",
    "start": "3089320",
    "end": "3096940"
  },
  {
    "text": "how do we sort in linear time? And this is going to be\nessentially a fancy merge sort.",
    "start": "3096940",
    "end": "3103140"
  },
  {
    "start": "3103140",
    "end": "3129284"
  },
  {
    "text": "This is done in the same paper. ",
    "start": "3129284",
    "end": "3146560"
  },
  {
    "text": "Before we said omega, I'm\ngoing to essentially make omega a little bit bigger than 2.",
    "start": "3146560",
    "end": "3152057"
  },
  {
    "text": "So I want to assume\nthat w is at least twice b plus 1 log n log log n. That's just to make\nthis convenient,",
    "start": "3152057",
    "end": "3158859"
  },
  {
    "text": "but of course it doesn't really\nmatter what the constants are. This will make everything\nfit in one word though, instead of a\nconstant number of words.",
    "start": "3158860",
    "end": "3166410"
  },
  {
    "text": "OK, step zero of this\nalgorithm is the packing part.",
    "start": "3166410",
    "end": "3183000"
  },
  {
    "text": " We can fit more than one\nelement into each word.",
    "start": "3183000",
    "end": "3189780"
  },
  {
    "text": "So put them in. Now, we have linear\ntime overall. This is easy to do.",
    "start": "3189780",
    "end": "3196550"
  },
  {
    "text": "You have some word already.  Take those items, shift them\nleft or in the next item,",
    "start": "3196550",
    "end": "3203940"
  },
  {
    "text": "shift them left or\nin the next item, shift them left or\nin the next item. OK, linear time.",
    "start": "3203940",
    "end": "3210460"
  },
  {
    "text": "So in the end what it's\ngoing to look like-- oh, I also want to leave a 0\nbit in between each of them.",
    "start": "3210460",
    "end": "3216810"
  },
  {
    "text": "So we're going to have b. This is going to\nbe x1 here, x2, xn.",
    "start": "3216810",
    "end": "3233150"
  },
  {
    "text": "Each of these is b bits long. And then we have one more bit. ",
    "start": "3233150",
    "end": "3238940"
  },
  {
    "text": "And in fact, the way\nwe set things up this is only half the word. So there's another\nhalf over here, which is going to be all 0 for now.",
    "start": "3238940",
    "end": "3246470"
  },
  {
    "text": "So we have one word contains-- sorry, this is not n items. This is going to\nbe log n log log n.",
    "start": "3246470",
    "end": "3254929"
  },
  {
    "text": "Can't fit them all in one word. That would make\nlife really easy. You can fit log n log log\nn items in the first word.",
    "start": "3254929",
    "end": "3260360"
  },
  {
    "text": "Then the next word\nis the next log n log log n items and so on. Linear time to do that.",
    "start": "3260360",
    "end": "3266480"
  },
  {
    "text": " Next step, this is an algorithm.",
    "start": "3266480",
    "end": "3273472"
  },
  {
    "text": "It's not really a step. I should say these are\nthings that we're able to do, and we're going to combine\nthem in different ways.",
    "start": "3273472",
    "end": "3281144"
  },
  {
    "text": "So the next thing\nto observe, this is sort of a bottom\nup perspective. So first thing we can do\nis pack things into word.",
    "start": "3281144",
    "end": "3288320"
  },
  {
    "text": "Next thing we can do is\nmerge two sorted words. Let's say they each have k items\nand k is at most log n log log",
    "start": "3288320",
    "end": "3295670"
  },
  {
    "text": "n. ",
    "start": "3295670",
    "end": "3304480"
  },
  {
    "text": "And I want to merge them into\none sorted word with two k",
    "start": "3304480",
    "end": "3315575"
  },
  {
    "text": "elements.  So I have two of these\nthings and I'll merge them",
    "start": "3315575",
    "end": "3322060"
  },
  {
    "text": "in sorted order. And when I did this\npacking, nothing's sorted.",
    "start": "3322060",
    "end": "3327160"
  },
  {
    "text": "But don't worry about\nthat at the moment. Just if I had two\nthese words and suppose they were already\nsorted, then I want",
    "start": "3327160",
    "end": "3334990"
  },
  {
    "text": "to merge them and make\nthem still sorted. OK, I want x1 to be\nless than x2 and so on.",
    "start": "3334990",
    "end": "3341860"
  },
  {
    "text": " How much time? It'd be cool if you could\ndo this in constant time",
    "start": "3341860",
    "end": "3348340"
  },
  {
    "text": "on a transdichotomous rem. You could do anything\non a constant number of words in constant time. We're not going to\nachieve constant time,",
    "start": "3348340",
    "end": "3354240"
  },
  {
    "text": "but we don't need to. We're going to do\norder log k time. ",
    "start": "3354240",
    "end": "3361234"
  },
  {
    "text": "ERIK DEMAINE: This is the\nhardest step of packed sorting, and I'm not going to tell\nyou how to do it until later.",
    "start": "3361235",
    "end": "3366790"
  },
  {
    "text": "I will tell you, don't worry. But this is going to\nrequire bitonic sorting.",
    "start": "3366790",
    "end": "3373210"
  },
  {
    "text": "So I have to delay\nit a little bit. Suppose you had that for now. Let me tell you how\nthe rest is easy.",
    "start": "3373210",
    "end": "3379030"
  },
  {
    "start": "3379030",
    "end": "3385900"
  },
  {
    "text": "So many black boxes, but they're\nall filled in in this lecture. ",
    "start": "3385900",
    "end": "3391660"
  },
  {
    "text": "OK, next thing you\nmight ask is, well,",
    "start": "3391660",
    "end": "3397059"
  },
  {
    "text": "how do I get a sorted word? I see how to get a single word\nthat has log n log log n items.",
    "start": "3397060",
    "end": "3402190"
  },
  {
    "text": "But how would I\nsort those items? Use merge sort. Here's a merger.",
    "start": "3402190",
    "end": "3407410"
  },
  {
    "text": "You have a way to\nmerge two sorted lists, so use merge sort,\nthat will give you a way to sort the whole thing.",
    "start": "3407410",
    "end": "3413269"
  },
  {
    "text": "So I'm going to merge sort\nk equals log n log log n items into one sorted word.",
    "start": "3413270",
    "end": "3426300"
  },
  {
    "start": "3426300",
    "end": "3433050"
  },
  {
    "text": "So I start out with a\nword that's unsorted. I do merge sort. And I sort them.",
    "start": "3433050",
    "end": "3439884"
  },
  {
    "text": "So this is not the\nwhole sorting problem but it's the one\nword sorting problem.",
    "start": "3439884",
    "end": "3445300"
  },
  {
    "text": "So how long does this take? Well, it's usual\nmerge sort recurrence, but then it's plus how long\nit takes me to split the word.",
    "start": "3445300",
    "end": "3454095"
  },
  {
    "text": "Well, splitting\nthe word is easy, you just mask out the\nlow end or the high end and then maybe shift over.",
    "start": "3454095",
    "end": "3460140"
  },
  {
    "text": "So in constant time I\ncan get the left half and the right half of the\narray, which is the word.",
    "start": "3460140",
    "end": "3466230"
  },
  {
    "text": "Then the hard part\nis merging them. And merging them is 1,\nand that takes log k.",
    "start": "3466230",
    "end": "3474468"
  },
  {
    "text": "So this is step one. That's our merger. And so what does this solve to?",
    "start": "3474468",
    "end": "3480560"
  },
  {
    "text": "Well, probably easiest to\ndraw the recursion tree. So at the root we pay log k. Then we have 2 times log\nk over 2, log k over 2.",
    "start": "3480560",
    "end": "3493890"
  },
  {
    "text": " So at this level\nwe're paying log k.",
    "start": "3493890",
    "end": "3500160"
  },
  {
    "text": "At this level we're paying\n2 log k minus 1, I guess.",
    "start": "3500160",
    "end": "3506280"
  },
  {
    "text": " I'm just going to\ncall this maybe-- yeah, I do need to do that.",
    "start": "3506280",
    "end": "3513480"
  },
  {
    "text": "I mean everything is constant\nsize so you pay a constant. How many leaves are there\nat the bottom level?",
    "start": "3513480",
    "end": "3519200"
  },
  {
    "text": "k of them. OK, so at the root\nwe're paying log k, at the leaves we're paying k.",
    "start": "3519200",
    "end": "3525750"
  },
  {
    "text": "This is roughly geometric. There's this minus 1,\nbut it's geometric enough and when you add up all these\nlevels it's dominated by k.",
    "start": "3525750",
    "end": "3534210"
  },
  {
    "text": "So this ends up\nbeing order k time. ",
    "start": "3534210",
    "end": "3539450"
  },
  {
    "text": "The minus 1 here turns\nout not to matter much. Cool.",
    "start": "3539450",
    "end": "3544710"
  },
  {
    "text": "So this linear time sorting\non log n log log n items. Everything it fits in a word.",
    "start": "3544710",
    "end": "3550050"
  },
  {
    "text": "Cool, but we're not done yet. We need another level.",
    "start": "3550050",
    "end": "3556320"
  },
  {
    "text": "The rest is pretty easy. It's just scaling up. ",
    "start": "3556320",
    "end": "3594660"
  },
  {
    "text": "OK, let's see. At this point we're going to\nassume that all of our words",
    "start": "3594660",
    "end": "3600530"
  },
  {
    "text": "are completely full. So this merging and stuff\nwas in order to fill up words and to make those words sorted.",
    "start": "3600530",
    "end": "3607310"
  },
  {
    "text": "But once we've done that\nfor each cluster of log n log log n items, now\nwe can assume each word",
    "start": "3607310",
    "end": "3613130"
  },
  {
    "text": "is sorted and completely full. It has exactly k elements in it.",
    "start": "3613130",
    "end": "3618150"
  },
  {
    "text": "So each of these r sorted\nwords has k elements.",
    "start": "3618150",
    "end": "3625539"
  },
  {
    "text": "OK, so now the issue is\nthings don't fit in a word. And so now suppose they\nfit in r sorted words. So supposed we've already made\na sorted list of r times k items",
    "start": "3625540",
    "end": "3635119"
  },
  {
    "text": "which fit in r words,\neach with k items in it. Then I want to take\ntwo of these lists",
    "start": "3635120",
    "end": "3640760"
  },
  {
    "text": "and merge them\ntogether and get one sorted list of sorted words. So it's 2 rk items that are\ndistributed into 2r words,",
    "start": "3640760",
    "end": "3650570"
  },
  {
    "text": "each of size k. How do I do that\nmerge in linear time?",
    "start": "3650570",
    "end": "3657750"
  },
  {
    "text": "And I only need to do it\nin r log k time, only.",
    "start": "3657750",
    "end": "3663700"
  },
  {
    "text": "Yeah, question? AUDIENCE: I'm assuming k is\nthe number of items per word?",
    "start": "3663700",
    "end": "3668860"
  },
  {
    "text": "ERIK DEMAINE: Yeah, k\nis this from now on. And there are exactly\nk elements per word.",
    "start": "3668860",
    "end": "3676129"
  },
  {
    "text": "We've already filled up\nthe word so at this point we can assume that. AUDIENCE: But it's exactly\nequal, not less than.",
    "start": "3676129",
    "end": "3681427"
  },
  {
    "text": "ERIK DEMAINE: Right. AUDIENCE: Because in one-- ERIK DEMAINE: Yeah, over here\nit's less than or equal to. I know it's a little confusing. I use k for different--\ncall this k prime.",
    "start": "3681427",
    "end": "3689280"
  },
  {
    "text": "OK, and at this point we've\nfilled up to this value of k. Now everything has exactly\nlog n log log n items.",
    "start": "3689280",
    "end": "3695570"
  },
  {
    "text": "Thanks. OK, let's see. ",
    "start": "3695570",
    "end": "3702650"
  },
  {
    "text": "A regular merging algorithm\nwould take r times k time because they're r times k items.",
    "start": "3702650",
    "end": "3707970"
  },
  {
    "text": "But we have this merger\nover here, which will merge two words in log k time.",
    "start": "3707970",
    "end": "3715040"
  },
  {
    "text": "So that's why it's\ngoing to be r log k. What's the picture? Well, let me draw it.",
    "start": "3715040",
    "end": "3720450"
  },
  {
    "start": "3720450",
    "end": "3736900"
  },
  {
    "text": "We have a list of words. A list of words.",
    "start": "3736900",
    "end": "3744040"
  },
  {
    "text": "How do we merge? Well, we take the first\ntwo words, merge them. When we merge them and we know\nhow to do this n log k time,",
    "start": "3744040",
    "end": "3750619"
  },
  {
    "text": "that's step 1. When we merge them\nwe get two words, they just are now sorted.",
    "start": "3750620",
    "end": "3755995"
  },
  {
    "text": " So we've got these\ntwo guys sorted",
    "start": "3755995",
    "end": "3761470"
  },
  {
    "text": "and then there's the rest. I'd like to say output\nthese and repeat, but that wouldn't\nbe quite correct.",
    "start": "3761470",
    "end": "3768640"
  },
  {
    "text": "Well, these guys I can output\nbecause I've got k items here,",
    "start": "3768640",
    "end": "3774979"
  },
  {
    "text": "k items here. These are the k smallest\namong all of them. Those must be the\noverall smallest k items.",
    "start": "3774979",
    "end": "3780340"
  },
  {
    "text": "Because I compared k with k. These higher k\nitems, I don't know. They might be good or bad.",
    "start": "3780340",
    "end": "3786559"
  },
  {
    "text": "So I have to put this high part\nback into one of these lists.",
    "start": "3786560",
    "end": "3791971"
  },
  {
    "text": "You have to think a\nlittle bit about which list to put it into. Turns out if you\nlook at the max item, say where did this come\nfrom, list one or list two?",
    "start": "3791971",
    "end": "3799357"
  },
  {
    "text": "You put it into that list. Let's say this\ncame from list two. And you put it back into\nlist two and then repeat.",
    "start": "3799357",
    "end": "3805970"
  },
  {
    "text": "OK, so in log k time here\nwe have output k items.",
    "start": "3805970",
    "end": "3812710"
  },
  {
    "text": "And so we end up with an r\nlog k running time overall. OK, so it's like\nregular merge algorithm,",
    "start": "3812710",
    "end": "3819490"
  },
  {
    "text": "except we use step\none to merge words, and then there's a\nlittle bit of work.",
    "start": "3819490",
    "end": "3825690"
  },
  {
    "text": "This is like old merging\nalgorithm, right? You take the min and\nyou put the max back in.",
    "start": "3825690",
    "end": "3830770"
  },
  {
    "text": "Except now the max\nis a whole word. OK that's how we merge.",
    "start": "3830770",
    "end": "3838030"
  },
  {
    "text": "Now, why did we do a merger? Because next thing\nwe do is merge sort. ",
    "start": "3838030",
    "end": "3860250"
  },
  {
    "text": "And this is the\noverall algorithm. It's one merge sort. We're going to use\nthis is the merger and we're going to use\nthis as the base case.",
    "start": "3860250",
    "end": "3866650"
  },
  {
    "text": "So it's actually two recursive\nlevels of merge sort. Merge sort is recursive\nwithin step four for a while,",
    "start": "3866650",
    "end": "3873390"
  },
  {
    "text": "until we get down to the\nlevel of a single word. Then we use this thing to deal\nwith things in a single word. ",
    "start": "3873390",
    "end": "3882580"
  },
  {
    "text": "So we end up with t of n\nis 2 times t of n over 2",
    "start": "3882580",
    "end": "3889230"
  },
  {
    "text": "plus n over k log k.",
    "start": "3889230",
    "end": "3895890"
  },
  {
    "text": "And base case of\nt of k is order k. ",
    "start": "3895890",
    "end": "3907350"
  },
  {
    "text": "Why is it all this? This thing is r. ",
    "start": "3907350",
    "end": "3915450"
  },
  {
    "text": "So we have r log k to do a\nmerge. r here is n over k. Why is it n over k?",
    "start": "3915450",
    "end": "3921470"
  },
  {
    "text": " Because n is the\ntotal number of items. We had r times k\nitems, so n equals rk.",
    "start": "3921470",
    "end": "3929190"
  },
  {
    "text": "So r equals n over k. That's that. So this is our merge cost. This is the cost of 3,\nthis is the cost of 2.",
    "start": "3929190",
    "end": "3938160"
  },
  {
    "text": "If we have only log\nn log log n items, so k items, then we can\nsort in linear time.",
    "start": "3938160",
    "end": "3948150"
  },
  {
    "text": "So we just need to\nsolve this recurrence.  Well, how's it going to work?",
    "start": "3948150",
    "end": "3956820"
  },
  {
    "text": "It's going to be kind of like\nmerge sort, but not quite. Question? ",
    "start": "3956820",
    "end": "3963920"
  },
  {
    "text": "AUDIENCE: When you say-- so\nyou have-- it's definitely merging two lists\nof sorted words into one sorted\nlist of two words.",
    "start": "3963920",
    "end": "3971070"
  },
  {
    "text": "[INAUDIBLE]? ",
    "start": "3971070",
    "end": "3976950"
  },
  {
    "text": "You may have to do that, right?  ERIK DEMAINE: Say that again.",
    "start": "3976950",
    "end": "3982440"
  },
  {
    "text": "AUDIENCE: So you\nhave two sorted-- two sorted lists\nof R sorted words. ERIK DEMAINE: The\nwords are going",
    "start": "3982440",
    "end": "3988800"
  },
  {
    "text": "to change, which elements are\nin which words are changing. But that's thanks to\nstep one, for example.",
    "start": "3988800",
    "end": "3996300"
  },
  {
    "text": "I mean, step one can\nmerge any two sorted words and make one sorted word. Or actually, one sorted word.",
    "start": "3996300",
    "end": "4005180"
  },
  {
    "text": "In our case, we're going\nto get two sorted words. That was the picture over here. I merge the two guys.",
    "start": "4005180",
    "end": "4011510"
  },
  {
    "text": "I could represent it as one\nword that's kind of double full, and then I can split\nthat into two words.",
    "start": "4011510",
    "end": "4017420"
  },
  {
    "text": "So we again need\nthe split operation, but split is just a mask\nthese guys out and you",
    "start": "4017420",
    "end": "4024619"
  },
  {
    "text": "get the high part. This is all 0. Then you shift it\nover to the left, now you've got the high\nword over the single word.",
    "start": "4024620",
    "end": "4034130"
  },
  {
    "text": "So they're shuffling\nwithin those two words, or within one word,\nessentially, via this procedure,",
    "start": "4034130",
    "end": "4040980"
  },
  {
    "text": "which we haven't covered. So everything is\ngoing to mix around. But then there's the low\nitems and the high items.",
    "start": "4040980",
    "end": "4047064"
  },
  {
    "text": "And so all the items in\nhere are less than all of the items in here.",
    "start": "4047064",
    "end": "4052080"
  },
  {
    "text": "Other questions? Cool. So I need to solve\nthis recurrence.",
    "start": "4052080",
    "end": "4057150"
  },
  {
    "text": "So let's draw another\nrecursion tree. That's the east way\nto solve recurrences.",
    "start": "4057150",
    "end": "4062250"
  },
  {
    "text": "Root is n over k log k. Next level down, see\nn got divided by 2.",
    "start": "4062250",
    "end": "4068750"
  },
  {
    "text": "So it's going to be 1/2 n over\nk log k, 1/2 n over k log k,",
    "start": "4068750",
    "end": "4077690"
  },
  {
    "text": "because the n gets divided by 2. So if I add up\neverything on this level, I get n over k log k.",
    "start": "4077690",
    "end": "4084079"
  },
  {
    "text": "And in general as I\ngo down, all levels are going to sum to this\nsame value, n over k log k.",
    "start": "4084080",
    "end": "4090080"
  },
  {
    "text": "So up here we are going\nto have a cost of n over k log k times\nthe number of levels.",
    "start": "4090080",
    "end": "4098120"
  },
  {
    "text": "Now, this is where\nit's a little tricky. It's not log n levels\nlike regular merge sort. We stop at level k.",
    "start": "4098120",
    "end": "4105009"
  },
  {
    "text": "So it's going to\nbe log of n over k. ",
    "start": "4105010",
    "end": "4113049"
  },
  {
    "text": "That's the number\nof levels we get to. Now at the leaf level finally\nwe have things of size order k,",
    "start": "4113050",
    "end": "4120939"
  },
  {
    "text": "and we only pay order k. Great.",
    "start": "4120939",
    "end": "4126470"
  },
  {
    "text": "And then how many\nleaves are there? There's n over k leaves. ",
    "start": "4126470",
    "end": "4136230"
  },
  {
    "text": "OK. So, that's an order n cost. This is order k, that's\nn over k, order n.",
    "start": "4136230",
    "end": "4145639"
  },
  {
    "text": "What's this thing? Well, what's k? k was log n log log n.",
    "start": "4145640",
    "end": "4152839"
  },
  {
    "text": "So this is n divided\nby log n log log n. This, therefore, is\napproximately log log n.",
    "start": "4152840",
    "end": "4160130"
  },
  {
    "text": "So that log log n\ncancels this one. This is approximately log n,\nso that cancels with this one.",
    "start": "4160130",
    "end": "4166065"
  },
  {
    "text": "So this is order n. That's why we\nchose these values.",
    "start": "4166065",
    "end": "4172104"
  },
  {
    "text": "So this n over k was not\nactually that significant. We could have called that n. What is important is that this\nrecursion doesn't work when",
    "start": "4172104",
    "end": "4180140"
  },
  {
    "text": "you get down to a single word. Can't do the same strategy. You need to use a different\nmerger for single words",
    "start": "4180140",
    "end": "4187699"
  },
  {
    "text": "because here we have\nto do bit tricks. For this merge\nstrategy we didn't have to do big tricks\nbecause everything was bigger",
    "start": "4187700",
    "end": "4193305"
  },
  {
    "text": "than a word. The reason why we\nhave these two levels is not to make the\ntime fast, it's just",
    "start": "4193305",
    "end": "4201050"
  },
  {
    "text": "to make the algorithm work. I mean, to define the algorithm\nthere's within a word merging and over many words merging.",
    "start": "4201050",
    "end": "4208880"
  },
  {
    "text": "The hard part is this one,\nwithin a word merging. So that's our next goal.",
    "start": "4208880",
    "end": "4214650"
  },
  {
    "text": "But if we could do that we\nget linear time sorting for packed sorting when you can fit\nlog log log n things in a word.",
    "start": "4214650",
    "end": "4222530"
  },
  {
    "text": "Any questions about\npacked sorting?  Good.",
    "start": "4222530",
    "end": "4228160"
  },
  {
    "text": "So, last thing is how do\nwe merge two sorted words",
    "start": "4228160",
    "end": "4233800"
  },
  {
    "text": "into one sorted word.  And this is where we're\ngoing to use bitonic sorting.",
    "start": "4233800",
    "end": "4239770"
  },
  {
    "text": "See, it says right here, bitonic\nsort for merging sorted words. Here we know what to do.",
    "start": "4239770",
    "end": "4245500"
  },
  {
    "text": "Much easier in hindsight. ",
    "start": "4245500",
    "end": "4251659"
  },
  {
    "text": "So I'm going to take a\nlittle diversion tell you about bitonic sorting, briefly. ",
    "start": "4251660",
    "end": "4261239"
  },
  {
    "text": "Because it's NCLRS I don't want\nto spend too much time on it, but it is something we need.",
    "start": "4261240",
    "end": "4267739"
  },
  {
    "text": "So you need to\nknow how it works. ",
    "start": "4267740",
    "end": "4274310"
  },
  {
    "text": "So first thing is the idea\nof a bitonic sequence. This is going to be a cyclic\nshift of a uni-modal sequence.",
    "start": "4274310",
    "end": "4286150"
  },
  {
    "text": "So a non-decreasing plus\na non-increasing sequence.",
    "start": "4286150",
    "end": "4292900"
  },
  {
    "text": " So I want non-decreasing\nand then non-increasing.",
    "start": "4292900",
    "end": "4299650"
  },
  {
    "text": "So this is a bitonic sequence. I think you know\nwhat this means. Or it could be a\ncyclic shift thereof.",
    "start": "4299650",
    "end": "4306920"
  },
  {
    "text": "So I could, for example,\ntake this part here and shift it over to this side. So then I'd end up with\nthis, this, and this.",
    "start": "4306920",
    "end": "4315220"
  },
  {
    "text": "This is also bitonic. or I could shift\nthis whole thing and put it over there\nso I end up with that.",
    "start": "4315220",
    "end": "4321710"
  },
  {
    "text": "That's also bitonic. So it basically has one\nmax, one min if you're",
    "start": "4321710",
    "end": "4326890"
  },
  {
    "text": "reading it cyclically. One local max, one local min. Except, it's non-decreasing\nso it's a little messier,",
    "start": "4326890",
    "end": "4333090"
  },
  {
    "text": "but same thing. OK, let's go over here.",
    "start": "4333090",
    "end": "4340860"
  },
  {
    "start": "4340860",
    "end": "4357900"
  },
  {
    "text": "So if you have a\nbitonic sequence there's something called a\nbitonic sorting network, which",
    "start": "4357900",
    "end": "4363780"
  },
  {
    "text": "you can think of as a\nparallel sorting algorithm, to sort such a thing. So it's almost\nsorted, but not quite.",
    "start": "4363780",
    "end": "4370700"
  },
  {
    "text": "And there's this\nway of sorting them. So I'm going to draw a picture\nto make it easier for me.",
    "start": "4370700",
    "end": "4377900"
  },
  {
    "text": " It's a little more\nannoying to write down the general algorithm.",
    "start": "4377900",
    "end": "4383449"
  },
  {
    "text": "But so what I want to do,\nsuppose the number of elements is a power of 2. Here's what I'm going to do. First I compare the first\nand the midway element.",
    "start": "4383450",
    "end": "4392059"
  },
  {
    "text": "And then the next one with\nthe next one, and then the next one with the next one,\nthe next one with the next one. For each of these\ncomparisons I put those items",
    "start": "4392059",
    "end": "4398758"
  },
  {
    "text": "in the correct order. So if I do that 3 versus\n6, 3 is less than 6, so 3 stays here, 6 stays there.",
    "start": "4398758",
    "end": "4404800"
  },
  {
    "text": "5 is bigger than 4 though,\nso 4 comes over here, 5 goes over here. Next is 7 versus 2, so 2 comes\nover here, 7 comes over here.",
    "start": "4404800",
    "end": "4415430"
  },
  {
    "text": "Nine versus 0, so 0 is\nover here, 9 is over there. OK, that's an easy\nset comparisons to do.",
    "start": "4415430",
    "end": "4422480"
  },
  {
    "text": "The nice thing is you can\ndo all those in parallel. OK, just to check here. This was a monotone\nincreasing sub-sequence",
    "start": "4422480",
    "end": "4430460"
  },
  {
    "text": "and then a monotone decreasing. Now, we have increasing\nthen decreasing.",
    "start": "4430460",
    "end": "4437270"
  },
  {
    "text": "And then we have\ndecreasing then increasing. But if you look at the left\nhalf or the right half,",
    "start": "4437270",
    "end": "4445310"
  },
  {
    "text": "they are still bitonic. And that's an invariant. Bitonic will be preserved here.",
    "start": "4445310",
    "end": "4450560"
  },
  {
    "text": "Also notice, all the\nelements in the left are smaller than all the\nelements in the right. That's not true for\nan arbitrary sequence,",
    "start": "4450560",
    "end": "4456620"
  },
  {
    "text": "but it will be true\nfor bitonic sequence. Essentially the max\nis somewhere here",
    "start": "4456620",
    "end": "4462260"
  },
  {
    "text": "and so it's going to\nbe spanned by some of these intervals, that max. And by spanning those intervals,\nand in particular comparing",
    "start": "4462260",
    "end": "4469760"
  },
  {
    "text": "that guy with\nsomebody on the right, the max will get\nover to the right and then the rest of the\nincreasing and decreasing",
    "start": "4469760",
    "end": "4476870"
  },
  {
    "text": "sub-sequences will follow. That's a very\nhand-wavy argument. You can see CLRS for a\nway to prove that OK, just",
    "start": "4476870",
    "end": "4485000"
  },
  {
    "text": "take it for granted now. Now, we recurse\non the two sides. So I compare 3 with 2, 4\nwith 0, I compare 6 with 7,",
    "start": "4485000",
    "end": "4492320"
  },
  {
    "text": "and 6 with 9. So what do I get? 2 is less than 3. 0 is less than 4.",
    "start": "4492320",
    "end": "4498570"
  },
  {
    "text": "Then I compare 6 with\n7, so 6 less than 7. 5 is less than 9.",
    "start": "4498570",
    "end": "4505910"
  },
  {
    "text": "So now I've got four chunks,\nthis one, this one, this one,",
    "start": "4505910",
    "end": "4511010"
  },
  {
    "text": "and this one. I recurse on each of them. So 0 is less than 2, 3 is\nless than 4, 5 is less than 6,",
    "start": "4511010",
    "end": "4518110"
  },
  {
    "text": "7 is less than 9. Now I have all my items in\nsorted order, magically.",
    "start": "4518110",
    "end": "4523929"
  },
  {
    "text": "OK, but if you\nbelieve that invariant that the smallest\nn over two items get to the left and the\nlarger n over two items",
    "start": "4523929",
    "end": "4530900"
  },
  {
    "text": "get to the right, then by\ninduction this will sort them. Kind of like quick\nsort in that sense.",
    "start": "4530900",
    "end": "4537431"
  },
  {
    "text": "OK. The cool thing is I can\ndo all these in parallel, all these in parallel,\nall these in parallel. So the total time is log k,\nif I'm a parallel sorting",
    "start": "4537431",
    "end": "4546140"
  },
  {
    "text": "algorithm or a sorting network. And log k is exactly\nwhat I can afford.",
    "start": "4546140",
    "end": "4551270"
  },
  {
    "text": "So the last thing to do is to\nimplement an operation like this, or like this-- this is\nkind of the generic picture",
    "start": "4551270",
    "end": "4557600"
  },
  {
    "text": "here-- in constant time on a word ram. ",
    "start": "4557600",
    "end": "4573380"
  },
  {
    "text": "One other thing,\nbecause I don't want to sort a bitonic sequence. That wasn't my goal. My goal was to merge\ntwo sorted sequences.",
    "start": "4573380",
    "end": "4580910"
  },
  {
    "text": "I have two sorted sequences,\nI want to merge them. How do I make that bitonic? ",
    "start": "4580910",
    "end": "4588460"
  },
  {
    "text": "I just flip, like that. I take this sequence\nand I reverse it.",
    "start": "4588460",
    "end": "4594642"
  },
  {
    "text": "If I take a sorted sequence\nand reverse it then it looks like this. And so then the\nresult is bitonic. Then I can use bitonic\nsorting to sort it.",
    "start": "4594642",
    "end": "4601850"
  },
  {
    "text": "So this is the merge\nproblem and I've just reduced it to bitonic sorting.",
    "start": "4601850",
    "end": "4607220"
  },
  {
    "text": "Cool. Except, how do I\nreverse a sequence",
    "start": "4607220",
    "end": "4612610"
  },
  {
    "text": "in log k time on a word ram? Cute trick. ",
    "start": "4612610",
    "end": "4620735"
  },
  {
    "text": "If I have a word and it\nhas many items in it-- that's our picture,\nthat's our set up here--",
    "start": "4620735",
    "end": "4627042"
  },
  {
    "text": "and I want to reverse it\nover all, what I'll do is cut it in half, take all\nthese guys put them over here,",
    "start": "4627042",
    "end": "4632990"
  },
  {
    "text": "take all these guys\nput them over here. So I've got the right side--",
    "start": "4632990",
    "end": "4638315"
  },
  {
    "text": "sorry, it's only four-- cells over here. I've got the left\nside over here.",
    "start": "4638315",
    "end": "4644930"
  },
  {
    "text": "Then I recursively\nreverse the sequence",
    "start": "4644930",
    "end": "4650420"
  },
  {
    "text": "and recursively\nreverse this sequence. And then I have the\nreverse sequence.",
    "start": "4650420",
    "end": "4657219"
  },
  {
    "text": "Right, this is a standard. One way to reverse items\nis to do the big part and then recursively reverse.",
    "start": "4657220",
    "end": "4663830"
  },
  {
    "text": "Then I will get, I mean\nthis is like ab reverse is equal to b reverse a reverse.",
    "start": "4663830",
    "end": "4671180"
  },
  {
    "text": "Just a fun fact. So we're implementing that. Now how do I do this?",
    "start": "4671180",
    "end": "4676810"
  },
  {
    "text": "Well, this is the thing I've\nbeen talking about over here. You want to take the high part\nyou just mask that part out,",
    "start": "4676810",
    "end": "4682763"
  },
  {
    "text": "shift it to the right. You want to take the low\npart, just mask that part out. And so I can take\neach of these parts",
    "start": "4682764",
    "end": "4688440"
  },
  {
    "text": "individually, shift\nthis one to the left, shift this one to the\nright, order them together, and I've reversed.",
    "start": "4688440",
    "end": "4693690"
  },
  {
    "text": "So this takes constant time. This is recursion but\nthe total number of steps will be order log k, which\nis exactly what I can afford.",
    "start": "4693690",
    "end": "4703770"
  },
  {
    "text": "So that's how I do\nthe reverse part. So if I want to merge, now\nI have a bitonic sequence.",
    "start": "4703770",
    "end": "4709619"
  },
  {
    "text": "Last thing to do is, how do\nI do this bitonic comparison",
    "start": "4709620",
    "end": "4715080"
  },
  {
    "text": "in constant time. ",
    "start": "4715080",
    "end": "4725969"
  },
  {
    "text": "So, that's next page. ",
    "start": "4725970",
    "end": "4732734"
  },
  {
    "text": "Here's a quick sketch. ",
    "start": "4732734",
    "end": "4741739"
  },
  {
    "text": "I'm going to try to draw\nthe generic picture. So the generic picture is\nI have this thing which I call a, this thing\nwhich I call b,",
    "start": "4741740",
    "end": "4748659"
  },
  {
    "text": "and we basically want to compare\ncorresponding items in a and b. Though in fact, there's\nanother a over here and another",
    "start": "4748660",
    "end": "4754330"
  },
  {
    "text": "b over here. In general, there are many\na's, many b's, but they appear in this nice periodic pattern.",
    "start": "4754330",
    "end": "4759580"
  },
  {
    "text": "And so I'm just going\nto look at one ab pair, but it's going to simultaneously\nwork for all of them with the same operations.",
    "start": "4759580",
    "end": "4766186"
  },
  {
    "text": "So that's the dot,\ndot, dot here. There's another a\nand then another b, and another a and another b. So what do I do?",
    "start": "4766186",
    "end": "4772810"
  },
  {
    "text": "First thing I do is\nmake 1aa, 1aa, 1aa.",
    "start": "4772810",
    "end": "4780760"
  },
  {
    "text": "In other words, I\nadd in these 1 bits. Remember, we had zeros\nthere hanging out.",
    "start": "4780760",
    "end": "4786554"
  },
  {
    "text": "That was when we were\ngoing to use them. So I set them all to\nones in the a list. I take the b list, I just\nshift it over and leave them",
    "start": "4786555",
    "end": "4794094"
  },
  {
    "text": "as zeros. ",
    "start": "4794095",
    "end": "4800300"
  },
  {
    "text": "Time for bit tricks. Then I take this number, I\nsubtract it from this number. What do I get?",
    "start": "4800300",
    "end": "4806610"
  },
  {
    "text": "I get zeros or ones for\nwhether this bit got borrowed, which tells\nme whether little a is",
    "start": "4806610",
    "end": "4812030"
  },
  {
    "text": "bigger than little b. Then I get some junk. And then I get 0, 1. Junk. So on.",
    "start": "4812030",
    "end": "4817310"
  },
  {
    "text": "0, 1, junk. So 0 corresponds\nto a being smaller",
    "start": "4817310",
    "end": "4823880"
  },
  {
    "text": "than b, and 1 corresponds\nto the reverse. OK, whatever. Then I do my usual masking,\njust the 0, 1 bits,",
    "start": "4823880",
    "end": "4831820"
  },
  {
    "text": "then there's some zeros.  OK, here's a new trick\nwhich we haven't seen yet.",
    "start": "4831820",
    "end": "4838760"
  },
  {
    "text": "I'm going to shift this to the\nright by two, or in general by the size of those items.",
    "start": "4838760",
    "end": "4844470"
  },
  {
    "text": "So now I have 0, 1 here,\n0, 1 here, 0, 1 here. Each of these bits\nmight be different.",
    "start": "4844470",
    "end": "4850880"
  },
  {
    "text": "So I take this,\nshift to the right. Now I subtract. What this gives me--",
    "start": "4850880",
    "end": "4857400"
  },
  {
    "text": "so I'm taking 1,\n0, 0, 0, minus 1. What I get is 0, 1, 1, 1.",
    "start": "4857400",
    "end": "4863750"
  },
  {
    "text": "OK, in this case,\nthere's just two bits. Except it's not 1, 1. It's either 0, 0 or 1, 1.",
    "start": "4863750",
    "end": "4874760"
  },
  {
    "text": "And then we have here 0, and\nthen 0, 0 or 1, 1, and so on.",
    "start": "4874760",
    "end": "4882119"
  },
  {
    "text": "So now these are masks. The zeros correspond to\nwhen the a's were smaller,",
    "start": "4882120",
    "end": "4888409"
  },
  {
    "text": "the ones correspond to\nwhen the b's are smaller. So if I take this [? added ?]\nwith this, I get the large b's.",
    "start": "4888410",
    "end": "4898430"
  },
  {
    "text": "If I take this [? added ?]\nwith this, I get the small a's. Or one of some of\nthose combinations.",
    "start": "4898430",
    "end": "4905630"
  },
  {
    "text": "The point is I take-- I think here I\nget the small a's.",
    "start": "4905630",
    "end": "4911895"
  },
  {
    "text": " And then if I take this thing\nand negate it and then mask it",
    "start": "4911895",
    "end": "4925265"
  },
  {
    "text": "with this I get the small b's. ",
    "start": "4925265",
    "end": "4931750"
  },
  {
    "text": "And then I take this thing-- I ran out of room. So I've got small\na's, small b's.",
    "start": "4931750",
    "end": "4939210"
  },
  {
    "text": " I take this thing I shift it\nover so I have small b's here.",
    "start": "4939210",
    "end": "4945450"
  },
  {
    "text": " And then I OR these together,\nI get all the smalls.",
    "start": "4945450",
    "end": "4953620"
  },
  {
    "text": "OK, these are designed to\nnever conflict because I took the inversion here. So I get the smaller of the\na's, smaller of the b's.",
    "start": "4953620",
    "end": "4960770"
  },
  {
    "text": "So now I put the smaller\nthings in the right order. I do exactly the same procedure\nnegated, and get the larges.",
    "start": "4960770",
    "end": "4968170"
  },
  {
    "text": " And then I OR these\ntogether and I get sorted.",
    "start": "4968170",
    "end": "4974530"
  },
  {
    "text": " Well, not sorted. I get whatever bitonic\nsort would have done.",
    "start": "4974530",
    "end": "4981600"
  },
  {
    "text": "It's doing these pairwise\ncomparisons by doing this shift and it's putting things\nin the right order.",
    "start": "4981600",
    "end": "4986970"
  },
  {
    "text": "The small ones always\nend up on the left, the large ones always\nend up on the right. That's the definition of\nthe operation we want to do.",
    "start": "4986970",
    "end": "4993790"
  },
  {
    "text": "Bitonic operated. And because we are just doing\nshifts, and subtractions,",
    "start": "4993790",
    "end": "4999060"
  },
  {
    "text": "and all these things, it works\neven though there's not just one ab pair, but there's\na whole bunch of ab pairs. They will all be shifted, and\ncomputed, and sorted together.",
    "start": "4999060",
    "end": "5008460"
  },
  {
    "text": "It's a little hard\nto visualize but this will do one bitonic operation\nand a constant number",
    "start": "5008460",
    "end": "5014090"
  },
  {
    "text": "of word ram operations. And so you pop out\nall these stacks this gives us a merger, that\ngives us packed sorting,",
    "start": "5014090",
    "end": "5021110"
  },
  {
    "text": "and with packed sorting\nwe get signature sorting. Easy, right?",
    "start": "5021110",
    "end": "5027351"
  },
  {
    "text": "All right, that's probably\none of the most complicated algorithms we'll\nsee in this class. But from that you get\na priority queue that",
    "start": "5027351",
    "end": "5033230"
  },
  {
    "text": "runs in constant time provided\nw is a little bigger than log squared n. Boom.",
    "start": "5033230",
    "end": "5038559"
  }
]