[
  {
    "start": "0",
    "end": "22000"
  },
  {
    "text": " The following content is\nprovided under a Creative Commons license.",
    "start": "0",
    "end": "5310"
  },
  {
    "text": "Your support will help\nMIT Open CourseWare continue to offer high quality\neducational resources for free.",
    "start": "5310",
    "end": "11610"
  },
  {
    "text": "To make a donation or to\nview additional materials from hundreds of MIT courses,\nvisit MIT Open CourseWare",
    "start": "11610",
    "end": "18140"
  },
  {
    "text": "at ocw.mit.edu.  CHARLES E. LEISERSON:\nHey, everybody.",
    "start": "18140",
    "end": "23280"
  },
  {
    "start": "22000",
    "end": "83000"
  },
  {
    "text": "Let's get going.  Who here has heard of the FFT?",
    "start": "23280",
    "end": "29270"
  },
  {
    "text": " That's most of you.",
    "start": "29270",
    "end": "36020"
  },
  {
    "text": "So I first met\nSteve Johnson when he worked with one of\nmy graduate students,",
    "start": "36020",
    "end": "41570"
  },
  {
    "text": "now former graduate\nstudent, Matteo Frigo. And they came up with a\nreally spectacular piece",
    "start": "41570",
    "end": "48380"
  },
  {
    "text": "of performance\nengineering for the FFT, a system they call FFTW\nfor the Fastest Fourier",
    "start": "48380",
    "end": "56570"
  },
  {
    "text": "Transform in the West. And it has, for\nover years and years been a staple of anybody\ndoing signal processing will",
    "start": "56570",
    "end": "65750"
  },
  {
    "text": "know FFTW. So anyway, it's a great pleasure\nto welcome Steve Johnson, who",
    "start": "65750",
    "end": "72070"
  },
  {
    "text": "is going to talk\nabout some of the work that he's been doing\non dynamic languages,",
    "start": "72070",
    "end": "77930"
  },
  {
    "text": "such as Julia and Python. STEVEN JOHNSON: Yeah. Thanks. CHARLES E. LEISERSON:\nIs that pretty actuate?",
    "start": "77930",
    "end": "83330"
  },
  {
    "start": "83000",
    "end": "174000"
  },
  {
    "text": "STEVEN JOHNSON: Yeah. Yeah, so I'm going to talk, as\nI said, about high level dynamic languages and how you\nget performance in these.",
    "start": "83330",
    "end": "89300"
  },
  {
    "text": "And so most of you have probably\nused Python, or R, and Matlab.",
    "start": "89300",
    "end": "94520"
  },
  {
    "text": "And so these are really\npopular for people doing in technical computing,\nstatistics, and anything",
    "start": "94520",
    "end": "99649"
  },
  {
    "text": "where you want kind of\ninteractive exploration. You'd like to have a\ndynamically typed language where you can just type x equals 3.",
    "start": "99650",
    "end": "106310"
  },
  {
    "text": "And then three lines later,\nyou said, oh, x is an array. Because you're doing\nthings interactively. You don't have to be stuck\nwith a particular set of types.",
    "start": "106310",
    "end": "113560"
  },
  {
    "text": "And there's a lot of\nchoices for these. But they usually\nhit a wall when it",
    "start": "113560",
    "end": "118640"
  },
  {
    "text": "comes to writing\nperformance critical code in these languages. And so traditionally, people\ndoing some serious computing",
    "start": "118640",
    "end": "125720"
  },
  {
    "text": "in these languages have\na two-language solution. So they do high\nlevel exploration,",
    "start": "125720",
    "end": "131210"
  },
  {
    "text": "and productivity and so\nforth in Python or whatever. But when they need to write\nperformance critical code,",
    "start": "131210",
    "end": "137270"
  },
  {
    "text": "then you drop down to a lower\nlevel language, Fortran, or C, or Cython, or\none of these things.",
    "start": "137270",
    "end": "142459"
  },
  {
    "text": "And you use Python as the glue\nfor these low level kernels. And the problem--\nand this is workable.",
    "start": "142460",
    "end": "150010"
  },
  {
    "text": "I've done this myself. Many of you have\nprobably done this. But when you drop down from\nPython to C, or even to Cython,",
    "start": "150010",
    "end": "156420"
  },
  {
    "text": "there there's a huge\ndiscontinuous jump in the complexity of the coding.",
    "start": "156420",
    "end": "161760"
  },
  {
    "text": "And there's usually\na lot of generality. When you write code in C\nor something like that, it's specific to a very\nsmall set of types,",
    "start": "161760",
    "end": "168648"
  },
  {
    "text": "whereas the nice thing\nabout high level languages is you can write\ngeneric code that works for a lot of different types.",
    "start": "168648",
    "end": "175590"
  },
  {
    "start": "174000",
    "end": "222000"
  },
  {
    "text": "So at this point, there's often\nsomeone who pops up and says, oh, well, I did performance\nprogramming in Python.",
    "start": "175590",
    "end": "181550"
  },
  {
    "text": "And everyone knows you just need\nto vectorize your code, right? So basically, what\nthey mean is you",
    "start": "181550",
    "end": "187700"
  },
  {
    "text": "rely on mature\nexternal libraries that you pass on a\nbig block of data. It does a huge amount of\ncomputation and comes back.",
    "start": "187700",
    "end": "195239"
  },
  {
    "text": "And so you never\nwrite your own loops. And this is great. If there's someone who's already\nwritten the code that you need,",
    "start": "195240",
    "end": "203069"
  },
  {
    "text": "you should try and leverage\nthat as much as possible. But somebody has to write those.",
    "start": "203070",
    "end": "208580"
  },
  {
    "text": "And eventually, that\nperson will be you. And because eventually if\nyou do scientific computing,",
    "start": "208580",
    "end": "214800"
  },
  {
    "text": "you run into a problem\ninevitably that you just can't express in terms of\nexisting libraries very",
    "start": "214800",
    "end": "220460"
  },
  {
    "text": "easily or at all. So this was the state of\naffairs for a long time.",
    "start": "220460",
    "end": "227110"
  },
  {
    "start": "222000",
    "end": "319000"
  },
  {
    "text": "And a few years ago, starting\nin Alan Edelman's group at MIT, there was a proposal for\na new language called",
    "start": "227110",
    "end": "234950"
  },
  {
    "text": "Julia, which tries to be as\nhigh level and interactive",
    "start": "234950",
    "end": "240560"
  },
  {
    "text": "as-- it's a dynamically typed\nlanguage, you know, as Matlab, or Python, and so forth.",
    "start": "240560",
    "end": "246319"
  },
  {
    "text": "But general purpose\nlanguage like Python, very productive\nfor technical work, so really oriented towards\nscientific numerical computing.",
    "start": "246320",
    "end": "255020"
  },
  {
    "text": "But you can write\na loop, and you write low level code\nin that that's as fast as C. So that was the goal.",
    "start": "255020",
    "end": "260778"
  },
  {
    "text": "The first release was in 2013. So it's a pretty young language. The 1.0 release was in\nAugust of this year.",
    "start": "260779",
    "end": "267949"
  },
  {
    "text": "So before that point\nevery year there was a new release,\n0.1, 0.2, Point3.",
    "start": "267950",
    "end": "273530"
  },
  {
    "text": "And every year, it would\nbreak all your old code, and you'd have to update\neverything to keep it working.",
    "start": "273530",
    "end": "278720"
  },
  {
    "text": "So now they said,\nOK, it's stable. We'll add new features. We'll make it faster. But from this point\nonwards, for least",
    "start": "278720",
    "end": "285710"
  },
  {
    "text": "until 2.0, many\nyears in the future it will be backwards compatible.",
    "start": "285710",
    "end": "291920"
  },
  {
    "text": "So there's lots of-- in my experience, this\npretty much holds up. I haven't found\nany problem where",
    "start": "291920",
    "end": "298580"
  },
  {
    "text": "there was a nice highly\noptimized C or Fortran code where I couldn't\nwrite equivalent",
    "start": "298580",
    "end": "305539"
  },
  {
    "text": "code or equivalent performance,\nequivalently performing code in Julia given\nenough time, right?",
    "start": "305540",
    "end": "312110"
  },
  {
    "text": "Obviously, if something is-- there's a library with\n100,000 lines of code. It takes quite a\nlong time to rewrite",
    "start": "312110",
    "end": "317810"
  },
  {
    "text": "that in any other language. So there are lots of benchmarks\nthat illustrate this. The goal of Julia is usually to\nstay within a factor of 2 of C.",
    "start": "317810",
    "end": "325280"
  },
  {
    "start": "319000",
    "end": "431000"
  },
  {
    "text": "In my experience, it's\nusually within a factor of a few percent if you\nknow what you're doing.",
    "start": "325280",
    "end": "330840"
  },
  {
    "text": "So there's a very simple\nexample that I like to use, which is generating\na Vandermonde matrix.",
    "start": "330840",
    "end": "338850"
  },
  {
    "text": "So giving a vector a value as\nalpha 1 alpha 2 to alpha n. And you want to make an n by m\nmatrix whose columns are just",
    "start": "338850",
    "end": "346040"
  },
  {
    "text": "those entries to 0 with power,\nfirst power squared, cubed,",
    "start": "346040",
    "end": "351050"
  },
  {
    "text": "and so forth element-wise. All right, so this\nkind of matrix shows up in a lot of problems. So most matrix and\nvector libraries",
    "start": "351050",
    "end": "358580"
  },
  {
    "text": "have a built in function\nto do this and Python. In NumPy, there is a function\ncalled numpy.vander to do this.",
    "start": "358580",
    "end": "366150"
  },
  {
    "text": "And if you look at-- it's generating a big matrix. It could be\nperformance critical. So they can implement\nit in Python.",
    "start": "366150",
    "end": "372988"
  },
  {
    "text": "So if you look at the\nNumPy implementation, it's a little Python shim\nthat calls immediately to C.",
    "start": "372988",
    "end": "379190"
  },
  {
    "text": "And then if you\nlook at the C code-- I won't scroll\nthrough it-- but it's several hundred lines of code. It's quite long and complicated.",
    "start": "379190",
    "end": "385480"
  },
  {
    "text": "And all that several\nhundred lines of code is doing is just figuring\nout what types to work with,",
    "start": "385480",
    "end": "392620"
  },
  {
    "text": "like what kernels\nto dispatch to. And at the end of that,\nit dispatches to a kernel that does the actual work.",
    "start": "392620",
    "end": "397790"
  },
  {
    "text": "And that kernel is also\nC code, but that C code was generated by a special\npurpose code generation.",
    "start": "397790",
    "end": "402800"
  },
  {
    "text": "So it's quite involved\nto get good performance",
    "start": "402800",
    "end": "407930"
  },
  {
    "text": "for this while still being\nsomewhat type generic. So their goal is\nto have something that works for basically any\nNumPy array and any NumPy type,",
    "start": "407930",
    "end": "416300"
  },
  {
    "text": "which there's a\nhandful, like maybe a dozen scalar types that it\nshould work with, all right?",
    "start": "416300",
    "end": "421530"
  },
  {
    "text": "So if you're\nimplementing this in C, it's really trivial to write 20\nlines of code that implements",
    "start": "421530",
    "end": "426920"
  },
  {
    "text": "this but only for double\nprecision, a point or two double position\narray, all right?",
    "start": "426920",
    "end": "432120"
  },
  {
    "start": "431000",
    "end": "608000"
  },
  {
    "text": "So the difficulty is\ngetting type generic in C. So in Julia.",
    "start": "432120",
    "end": "438320"
  },
  {
    "text": "Here is the\nimplementation in Julia. It looks at first glance\nmuch like what roughly",
    "start": "438320",
    "end": "445885"
  },
  {
    "text": "what a C or Fourier\nimplementation would look like. It's just implemented\nthe most simple way.",
    "start": "445885",
    "end": "451850"
  },
  {
    "text": "It's just two nested loops. So just basically,\nyou loop across.",
    "start": "451850",
    "end": "456949"
  },
  {
    "text": "And as you go across,\nyou accumulate powers by multiplying repeatedly by x.",
    "start": "456950",
    "end": "463105"
  },
  {
    "text": "That's all it is. And it just fills in the array. The performance\nof that graph here",
    "start": "463105",
    "end": "468169"
  },
  {
    "text": "is the time for the NumPy\nimplementation divided by the time for the\nJulie implementation as a function of n\nfor an n by n matrix.",
    "start": "468170",
    "end": "474420"
  },
  {
    "text": "The first data point,\nI think there's something funny going on\nthat's not 10,000 times slower. But for a 10 by\n10, 20 by 20 array,",
    "start": "474420",
    "end": "482660"
  },
  {
    "text": "the NumPy version is\nactually 10 times slower because it's basically the\noverhead that's imposed by all",
    "start": "482660",
    "end": "487729"
  },
  {
    "text": "going through all those layers. Once you get to\n100 by 100 matrix, the overhead doesn't matter. And then it's all this optimized\nC code, generation and so forth",
    "start": "487730",
    "end": "498340"
  },
  {
    "text": "is pretty much the same\nspeed as the Julia code. Except the Julia code\nthere, as I said, it looks much like C code\nwould, except there's no types.",
    "start": "498340",
    "end": "507350"
  },
  {
    "text": "It's Vander x. There's no type declaration.\nx can be anything. And, in fact, this works\nwith any container type",
    "start": "507350",
    "end": "513950"
  },
  {
    "text": "as long as it has an\nindexing operation. And any numeric type--\nit could be real numbers. It could be complex numbers.",
    "start": "513950",
    "end": "519586"
  },
  {
    "text": "It could be quarternians,\nanything that supports the times operation. And there's also a call to 1.",
    "start": "519586",
    "end": "526370"
  },
  {
    "text": "So 1 returns the multiplicative\nidentity for whatever, so whatever group you're in\nyou need to have a 1, right?",
    "start": "526370",
    "end": "532230"
  },
  {
    "text": "That's the first column. That might be a different type\nof 1 for a different object, right? It might be an array of\nmatrices, for example.",
    "start": "532230",
    "end": "539310"
  },
  {
    "text": "And then the 1 is\nthe identity matrix. So, in fact.",
    "start": "539310",
    "end": "544430"
  },
  {
    "text": "There are even cases\nwhere you can do. Get significantly faster than\noptimize C and Fortran codes.",
    "start": "544430",
    "end": "551180"
  },
  {
    "text": "So I found this when I was\nimplementing special functions, so things like the error\nfunction, or polygamma",
    "start": "551180",
    "end": "556460"
  },
  {
    "text": "function, or the inverse\nof the error function. I've consistently found\nthat I can get often",
    "start": "556460",
    "end": "562040"
  },
  {
    "text": "two to three times faster\nthan optimized C and Fortran libraries out there, partly\nbecause I'm smarter than people",
    "start": "562040",
    "end": "569506"
  },
  {
    "text": "who wrote those libraries,\nbut-- no-- mainly because in Julia,\nI'm using basically",
    "start": "569507",
    "end": "575090"
  },
  {
    "text": "the same expansions, the same\nseries, rational functions that everyone else is using. The difference is\nthen in Julia, it",
    "start": "575090",
    "end": "581083"
  },
  {
    "text": "has built-in\ntechniques for what's called metaprogramming\nor co-generation. So usually, the\nspecial functions",
    "start": "581083",
    "end": "587900"
  },
  {
    "text": "involved lots of\npolynomial evaluations. That's what they boil down to. And you can basically\nwrite co-generation",
    "start": "587900",
    "end": "593900"
  },
  {
    "text": "that generates very\noptimized inline evaluation of the specific polynomials\nfor these functions that",
    "start": "593900",
    "end": "600320"
  },
  {
    "text": "would be really awkward\nto write in Fortran. You'd either have to\nwrite it all by hand or write a separate routine,\na separate program that",
    "start": "600320",
    "end": "607310"
  },
  {
    "text": "wrote Fortran code for you. So you can do this. It's a high level languages\nallow you to do tricks",
    "start": "607310",
    "end": "612920"
  },
  {
    "text": "for performance that it would be\nreally hard to do in low level languages. So mainly what I\nwanted to talk about is give some idea of\nwhy Julia can be fast.",
    "start": "612920",
    "end": "623839"
  },
  {
    "text": "And to understand\nthis, you also need to understand why\nis Python slow.",
    "start": "623840",
    "end": "629000"
  },
  {
    "text": "And in general, what's going on\nin determining the performance in a language like this?",
    "start": "629000",
    "end": "634050"
  },
  {
    "text": "What do you need in the language\nto enable you to compile it to fast code while still,\nstill being completely",
    "start": "634050",
    "end": "640920"
  },
  {
    "text": "generic like this\nVander function, which works on any type.",
    "start": "640920",
    "end": "646430"
  },
  {
    "text": "Even user-defined, numeric type,\nuser-defined container type will be just as fast. There's no privileged-- in\nfact, if you look at Julia,",
    "start": "646430",
    "end": "654210"
  },
  {
    "text": "almost all of Julia is\nimplemented in Julia. Integer operations and things\nlike that, the really basic",
    "start": "654210",
    "end": "660060"
  },
  {
    "text": "types, most of that is\nimplemented in Julia, right? Obviously, if you're\nmultiplying two 32-bit integers.",
    "start": "660060",
    "end": "665370"
  },
  {
    "text": "At some point, it's calling an\nassembly language instruction. But even that, calling\nout to the assembly",
    "start": "665370",
    "end": "671399"
  },
  {
    "text": "is actually in Julia. So at this point, I\nwant to switch over",
    "start": "671400",
    "end": "679110"
  },
  {
    "start": "673000",
    "end": "1098000"
  },
  {
    "text": "to sort of a live calculation.",
    "start": "679110",
    "end": "684410"
  },
  {
    "text": " So this is from a\nnotebook that I developed",
    "start": "684410",
    "end": "690569"
  },
  {
    "text": "as part of a short course\nwith Alan Edelman, who's sitting over there, [INAUDIBLE]\non performance optimization",
    "start": "690570",
    "end": "696850"
  },
  {
    "text": "high level languages. And so I want to go through\njust a very simple calculation.",
    "start": "696850",
    "end": "703450"
  },
  {
    "text": "Of course, you would never-- in any language, usually you\nwould have a built-- often have a built-in\nfunction for this.",
    "start": "703450",
    "end": "709120"
  },
  {
    "text": "But it's just a sum function\njust written up there. So we need to have a list,\nan array, of n numbers.",
    "start": "709120",
    "end": "715077"
  },
  {
    "text": "We're just going to add them up. And if we can't make this fast,\nthen we have real problems.",
    "start": "715077",
    "end": "721571"
  },
  {
    "text": "And we're not going to be able\nto do anything in this list. So this is the\nsimple sort of thing",
    "start": "721572",
    "end": "726640"
  },
  {
    "text": "where if someone doesn't\nprovide this for you, you're going to have to\nwrite a loop to do this.",
    "start": "726640",
    "end": "732970"
  },
  {
    "text": "So I'm going to look at it\nnot just in Julia but also in Python, in C, and Python\nwith NumPy and so forth.",
    "start": "732970",
    "end": "743510"
  },
  {
    "text": "So this document that\nI'm showing you here is a Jupyter Notebook.",
    "start": "743510",
    "end": "749134"
  },
  {
    "text": "Some of you may have\nseen this kind of thing. So Jupyter is this really nice-- they provide this really\nnice browser-based front end",
    "start": "749135",
    "end": "754820"
  },
  {
    "text": "when I can put in equations,\nand text, and code, and results,",
    "start": "754820",
    "end": "759940"
  },
  {
    "text": "and graphs all in one\nMathematical notebook document. And you can plug in\ndifferent languages. So initially, it was for Python.",
    "start": "759940",
    "end": "766450"
  },
  {
    "text": "But we plugged in Julia. And now there's R, and\nthere's 30 different-- like 100 different\nlanguages that you can plug in to the same front end.",
    "start": "766450",
    "end": "772750"
  },
  {
    "text": "OK, so I'll start with the\nC implementation of this. So this is a Julia\nnotebook, but I can easily",
    "start": "772750",
    "end": "778720"
  },
  {
    "text": "compile and call\nout to C. So I just made a string that\nhas just-- you know there's 10 lines\nC implementation.",
    "start": "778720",
    "end": "784192"
  },
  {
    "text": "It's just the most\nobvious function that just takes in a pointer\nto an array of doubles",
    "start": "784192",
    "end": "789250"
  },
  {
    "text": "and it's length. And it just loops over\nthem and sums them up,",
    "start": "789250",
    "end": "794500"
  },
  {
    "text": "just what you would do. And then I'll compile it\nwith GCC dash 03 and link it",
    "start": "794500",
    "end": "801760"
  },
  {
    "text": "to a shared library, and load\nthat shared library in Julia and just call it. So there's a function\ncalled C call in Julia where",
    "start": "801760",
    "end": "809260"
  },
  {
    "text": "I can just call out to a C\nlibrary with a 0 overhead, basically.",
    "start": "809260",
    "end": "814823"
  },
  {
    "text": "So it's nice because you have\nlots of existing C libraries out there. You don't want to lose them. So I just say C call, and\nwe call this c_sum function",
    "start": "814823",
    "end": "821920"
  },
  {
    "text": "in my library. It returns a flow 64. It takes two parameters,\na size t and a flow 64.",
    "start": "821920",
    "end": "829555"
  },
  {
    "text": "And I'm going to pass\nthe length of my array. And the array-- and\nit'll automatically-- a Julia array, of course,\nis just a bunch of numbers.",
    "start": "829555",
    "end": "838240"
  },
  {
    "text": "And it'll pass a pointer\nto that under the hood. So do that. And I wrote a little\nfunction to call",
    "start": "838240",
    "end": "846040"
  },
  {
    "text": "relerr that computes\nthe relative error between the fractional\ndifference between x and y.",
    "start": "846040",
    "end": "851112"
  },
  {
    "text": "And I'll just check it. I'll just generate 10 to\nthe 7 random numbers in 01 and compare that to the Julia\nbecause Julia has a built-in",
    "start": "851112",
    "end": "857800"
  },
  {
    "text": "function called sum,\nthat sums and array. And it's giving the same answer\nto 13 decimal places, so not",
    "start": "857800",
    "end": "864785"
  },
  {
    "text": "quite machine precision, but\nthere's 10 to the 7 numbers. So the error is\nkind of accumulative when you add it across. OK so, as I'm calling it,\nit's giving the right answer.",
    "start": "864785",
    "end": "872320"
  },
  {
    "text": "And now I want to just\nbenchmark the C implementation, use that as kind of\na baseline for this.",
    "start": "872320",
    "end": "877540"
  },
  {
    "text": "This should be pretty fast\nfor an array of floating point values.",
    "start": "877540",
    "end": "882770"
  },
  {
    "text": "So there's a Julia package\ncalled benchmark tools. As you probably know\nfrom this class, benchmarking is a\nlittle bit tricky.",
    "start": "882770",
    "end": "888940"
  },
  {
    "text": "So this will take something,\nrun it lots of times, collect some statistics,\nreturn the minimum time,",
    "start": "888940",
    "end": "894050"
  },
  {
    "text": "or you can also get the\nvariance and other things. So I'm going to get that number.",
    "start": "894050",
    "end": "901247"
  },
  {
    "text": "B time is something\ncalled a macro in Julia. So it takes an\nexpression, rewrites it into something that basically\nhas a loop, and times it,",
    "start": "901247",
    "end": "908950"
  },
  {
    "text": "and does all that stuff. OK, so it takes 11 milliseconds\nto sum 10 to the 7 numbers",
    "start": "908950",
    "end": "915250"
  },
  {
    "text": "with a straight C, C loop\ncompiled with jcc-03, no special tricks, OK?",
    "start": "915250",
    "end": "923709"
  },
  {
    "text": "And so that's 1\ngigaflop, basically, billion operations per second.",
    "start": "923710",
    "end": "929210"
  },
  {
    "text": "So it's not hitting the\npeak rate of the CPU. But, of course, there's\nadditional calculations.",
    "start": "929210",
    "end": "937730"
  },
  {
    "text": "This array doesn't fit\nin cache, and so forth. OK. So now let's-- before\nI do anything in Julia,",
    "start": "937730",
    "end": "944620"
  },
  {
    "text": "let's do some Python. But I'll do a trick. I can call Python from\nJulia, so that way",
    "start": "944620",
    "end": "950230"
  },
  {
    "text": "I can just do everything from\none notebook using a package I wrote called PyCall. And PyCall just calls\ndirectly out to lib Python.",
    "start": "950230",
    "end": "958300"
  },
  {
    "text": "So with no virtually\nno overhead, so it's just like calling\nPython from within Python.",
    "start": "958300",
    "end": "964029"
  },
  {
    "text": "I'm calling directly out to\nlib Python functions to call. And I can pass any type I\nwant, and call any function,",
    "start": "964030",
    "end": "969820"
  },
  {
    "text": "and do conversions\nback and forth. OK, so I'm going\nto take that array.",
    "start": "969820",
    "end": "975710"
  },
  {
    "text": "I'll convert it to a\nPython list object. So I don't want to time\nthe overhead of converting",
    "start": "975710",
    "end": "981310"
  },
  {
    "text": "my array to a Python array. So I'll just convert\nahead of time. And just start with a built--",
    "start": "981310",
    "end": "987570"
  },
  {
    "text": "Python has a built-in\nfunction called sum. So I'll use the\nbuilt-in sum function.",
    "start": "987570",
    "end": "993430"
  },
  {
    "text": "And I'll get this\nPy object for it. I'll call it PySum\non this list and make",
    "start": "993430",
    "end": "999235"
  },
  {
    "text": "sure it's giving the right\nanswer OK is the difference is 10 to the minus 13 again. And now let's benchmark it.",
    "start": "999235",
    "end": "1007810"
  },
  {
    "text": "Oops. There we go. So it takes a few\nseconds because it",
    "start": "1007810",
    "end": "1013160"
  },
  {
    "text": "has to run it a few times\nand catch up with statistics. OK, so it takes 40 milliseconds.",
    "start": "1013160",
    "end": "1020365"
  },
  {
    "text": "That's not bad. It's actually it's four or\nfive times slower than C, but it's pretty good, OK?",
    "start": "1020365",
    "end": "1026849"
  },
  {
    "text": "So and why is it five\ntimes slower than C? Is it is it because--",
    "start": "1026849",
    "end": "1031937"
  },
  {
    "text": "the glib answer is, oh,\nwell, Python is slow because it's interpreted. But the sum function\nis actually written",
    "start": "1031937",
    "end": "1038119"
  },
  {
    "text": "in C. Here's the C\nimplementation of the sum function that I'm calling.",
    "start": "1038119",
    "end": "1043240"
  },
  {
    "text": "And I'm just linking\nto the GitHub code. There's a whole\nbunch of boilerplate",
    "start": "1043240",
    "end": "1048280"
  },
  {
    "text": "that just checks with\nthe type of the object, and then has some\nloops and so forth.",
    "start": "1048280",
    "end": "1054900"
  },
  {
    "text": "And so if you look\ncarefully, it turns out it's actually doing really well. And the reason it does really\nwell is it has a fast path.",
    "start": "1054900",
    "end": "1062780"
  },
  {
    "text": "If you have a list where\neverything is a number type, so then it has an optimized\nimplementation for that case.",
    "start": "1062780",
    "end": "1071490"
  },
  {
    "text": "But it's still five\ntimes slower than C. And they've spent a\nlot of work on it. It used to be 10 times slower\nthan C a couple of years ago.",
    "start": "1071490",
    "end": "1078920"
  },
  {
    "text": "So they do a lot of\nwork on optimizing this. And so why aren't they\nable to get C speed?",
    "start": "1078920",
    "end": "1085160"
  },
  {
    "text": "Since they have a C\nimplementation of a sum, are they just dumb, you know?",
    "start": "1085160",
    "end": "1090440"
  },
  {
    "text": "No. It's because the\nsemantics of the data type prevent them from getting\nanything faster than that.",
    "start": "1090440",
    "end": "1098549"
  },
  {
    "text": "And this is one\nof the things you learn when you do high level\nperformance in high level",
    "start": "1098550",
    "end": "1103950"
  },
  {
    "text": "languages. You have to think\nabout data types, and you have to think about\nwhat the semantics are. And that that greatly constrains\nwhat any conceivable compiler",
    "start": "1103950",
    "end": "1111110"
  },
  {
    "text": "can do. And if the language\ndoesn't provide you with the ability to\nexpress the semantics",
    "start": "1111110",
    "end": "1118190"
  },
  {
    "text": "you want, then you're dead. And that's one of the basic\nthings that Julia does. So what does a Python list?",
    "start": "1118190",
    "end": "1123350"
  },
  {
    "text": " Right, so you have-- you\ncan have three, four, right?",
    "start": "1123350",
    "end": "1136760"
  },
  {
    "text": "A Python list is a bunch\nof objects, Python objects. But the Python numbers\ncan be anything. They can be any type.",
    "start": "1136760",
    "end": "1143039"
  },
  {
    "text": "So it's completely\nheterogeneous types. ",
    "start": "1143040",
    "end": "1150627"
  },
  {
    "text": "So, of course, a particular\nlist like in this case can be homogeneous. But the data structure\nhas to be heterogeneous",
    "start": "1150627",
    "end": "1156813"
  },
  {
    "text": "because, in fact, I can\ntake that homogeneous thing. At any point, I can assign\nthe third element to a string, right?",
    "start": "1156813",
    "end": "1161990"
  },
  {
    "text": "And it has to support that. So think about what that\nmeans for how it has to be implemented in memory.",
    "start": "1161990",
    "end": "1169270"
  },
  {
    "text": "So what this has to do--\nso this is a list of--",
    "start": "1169270",
    "end": "1174406"
  },
  {
    "text": "in this case, three items. But what are those items?",
    "start": "1174406",
    "end": "1180220"
  },
  {
    "text": "So if they can be\nan item of any type, they could be things that-- they\ncould be another array, right?",
    "start": "1180220",
    "end": "1185800"
  },
  {
    "text": "It could be of different\nsizes and so forth. You don't want to have an\narray where everything is",
    "start": "1185800",
    "end": "1190960"
  },
  {
    "text": "a different size, first of all. So it has to be this\nan array of pointers",
    "start": "1190960",
    "end": "1197500"
  },
  {
    "text": "where the first pointer\nis 3, turned out to be 3. The next one is four.",
    "start": "1197500",
    "end": "1202990"
  },
  {
    "text": "The next one is 2, all right? But it can't just be that.",
    "start": "1202990",
    "end": "1208960"
  },
  {
    "text": "It can't just be pointer to-- if this is a you\n64-bit number, it's can't just be pointer to\none 64-bit value in memory,",
    "start": "1208960",
    "end": "1217150"
  },
  {
    "text": "because it has to know. It has to somehow store\nwhat type the subject is. So there has to be a type tag\nthis says this is an integer.",
    "start": "1217150",
    "end": "1225190"
  },
  {
    "start": "1225190",
    "end": "1230570"
  },
  {
    "text": "And this one has to have a type\ntag that says it's a string. So this is sometimes\ncalled the box.",
    "start": "1230570",
    "end": "1237620"
  },
  {
    "text": "So you have a value, you\nhave a type tag plus a value.",
    "start": "1237620",
    "end": "1244290"
  },
  {
    "text": " And so imagine what even the\nmost optimized C imitation",
    "start": "1244290",
    "end": "1251160"
  },
  {
    "text": "has to do given this\nkind of data structure. OK, here's the first element. It has to chase the pointer and\nthen ask what type of object",
    "start": "1251160",
    "end": "1258420"
  },
  {
    "text": "is it, OK? Then depending on\nwhat type of object is it, so I initialize\nmy sum to that.",
    "start": "1258420",
    "end": "1264390"
  },
  {
    "text": "Then I read the next object. I have to chase the second\npointer, read the type tag, figure out the type.",
    "start": "1264390",
    "end": "1270110"
  },
  {
    "text": "This is all done\nat run time, right? And then, oh, this\nis another integer that tells me I want to use the\nplus function for two integers,",
    "start": "1270110",
    "end": "1278040"
  },
  {
    "text": "OK? And then I read the next\nvalue, which maybe-- which plus function\nit's using depends",
    "start": "1278040",
    "end": "1284252"
  },
  {
    "text": "upon the type of the object. It's an to\nobject-oriented language. I can define my own type. If it has its own plus function,\nit should work with sum.",
    "start": "1284253",
    "end": "1290490"
  },
  {
    "text": "So it's looking up the types\nof the objects at runtime. It's looking at the plus\nfunction at runtime.",
    "start": "1290490",
    "end": "1295760"
  },
  {
    "text": "And not only that, but each\ntime it does a loop iteration it has to add two things\nand allocate a result.",
    "start": "1295760",
    "end": "1301680"
  },
  {
    "text": "That result in general\nmight be another-- it has to be a box because\nthe type might change as you're summing through. If you start with integers, and\nthen you get a floating point",
    "start": "1301680",
    "end": "1309172"
  },
  {
    "text": "value, and then you get an\narray, the type will change. So each time you do\na loop iteration,",
    "start": "1309172",
    "end": "1314700"
  },
  {
    "text": "it allocates another box. So what happens is the C\nimplementation is a fast path. If they're all\ninteger types, I think",
    "start": "1314700",
    "end": "1322320"
  },
  {
    "text": "it doesn't reallocate\nthat box for the sum it's accumulating all the time. And it caches the value of\nthe plus function it's using.",
    "start": "1322320",
    "end": "1330240"
  },
  {
    "text": "So it's a little bit faster. But still, it has to\ninspect every type tag and chase all these pointers\nfor every element of the array,",
    "start": "1330240",
    "end": "1337260"
  },
  {
    "text": "whereas the C\nimplementation of sum, if you imagine what this\nis this compiles down to,",
    "start": "1337260",
    "end": "1345440"
  },
  {
    "text": "for each loop iteration,\nwhat does it do? It increments a pointer\nto the next element.",
    "start": "1345440",
    "end": "1351428"
  },
  {
    "text": "At compile time, the\ntypes are all flow 64. So it flushes flow 64\nvalue into a register.",
    "start": "1351428",
    "end": "1356940"
  },
  {
    "text": "And then it has a running\nsum in another register, calls one machine instruction\nto add that running sum,",
    "start": "1356940",
    "end": "1363120"
  },
  {
    "text": "and then it checks\nto see if we're done, an if statement there, and\nthen goes on, all right?",
    "start": "1363120",
    "end": "1368700"
  },
  {
    "text": "So just a few instructions\nand in a very tight loop here, whereas each loop\niteration here has",
    "start": "1368700",
    "end": "1374712"
  },
  {
    "text": "to be lots and lots\nof instructions to chase all these pointers\nto get the type tag-- and that's in the fast case\nwhere they're all the same type",
    "start": "1374712",
    "end": "1381000"
  },
  {
    "text": "and it's optimized for that. So where was I?",
    "start": "1381000",
    "end": "1387230"
  },
  {
    "start": "1383000",
    "end": "1553000"
  },
  {
    "text": "So wrong thing. So that's the\nPython sum function.",
    "start": "1387230",
    "end": "1393059"
  },
  {
    "text": "Now most many of\nyou, you've used Python know that there\nis another type of array",
    "start": "1393060",
    "end": "1398279"
  },
  {
    "text": "and there's a whole\nlibrary called NumPy for working with numerics. So what problem is\nthat addressing?",
    "start": "1398280",
    "end": "1405299"
  },
  {
    "text": "So the basic problem\nis this data structure. This data structure, as soon\nas you have a list of items--",
    "start": "1405300",
    "end": "1411360"
  },
  {
    "text": "it can be any type-- you're dead, right? There's no way to make\nthis as fast as a C",
    "start": "1411360",
    "end": "1416880"
  },
  {
    "text": "loop over a double pointer. So to make it\nfast, what you need",
    "start": "1416880",
    "end": "1422250"
  },
  {
    "text": "to have is a way to say, oh,\nevery element of this array is the same type. So I don't need to store\ntype tags for every element.",
    "start": "1422250",
    "end": "1429270"
  },
  {
    "text": "I can store a type tag\nonce for the whole array. ",
    "start": "1429270",
    "end": "1437019"
  },
  {
    "text": "So there, there is a tag.  There is a type, which\nis, say, float 64, OK?",
    "start": "1437020",
    "end": "1448030"
  },
  {
    "text": "There is maybe a\nlength of the array. And then there's just a bunch\nof values one after the other.",
    "start": "1448030",
    "end": "1455020"
  },
  {
    "text": "So this is just 1.0, 3.7, 8.9.",
    "start": "1455020",
    "end": "1461050"
  },
  {
    "text": "And each of these are just 8\nbytes, an 8-byte double in C notation, right?",
    "start": "1461050",
    "end": "1468340"
  },
  {
    "text": "So it's just one\nafter the other. So it reads this once,\nreads the length, and then it dispatches\nto code that says,",
    "start": "1468340",
    "end": "1475240"
  },
  {
    "text": "OK, now-- basically dispatches\nto the equivalent of my C code, all right? So now once it knows the\ntype and the length, then OK,",
    "start": "1475240",
    "end": "1481830"
  },
  {
    "text": "it says it runs this, OK? And that can be quite fast. And the only problem\nis you cannot write,",
    "start": "1481830",
    "end": "1488530"
  },
  {
    "text": "implement this in Python. So Python doesn't\nprovide you a way to have that semantics\nto have a list of objects",
    "start": "1488530",
    "end": "1497090"
  },
  {
    "text": "where you say they all\nhave to be the same type. There is no way to\nenforce that, or to inform",
    "start": "1497090",
    "end": "1503230"
  },
  {
    "text": "the language of that in Python. And then to tell\nit-- oh, for this, since these are\nall the same type,",
    "start": "1503230",
    "end": "1509830"
  },
  {
    "text": "you can throw away the boxes. Every Python object\nlooks like this. So there's no way\nto tell Python.",
    "start": "1509830",
    "end": "1514870"
  },
  {
    "text": "Oh, well, these are\nall the same types. You don't need to\nstore the type tags. You don't need to have pointers.",
    "start": "1514870",
    "end": "1520300"
  },
  {
    "text": "You don't need to have\nreference counting. You can just slam the\nvalues into memory one after the other.",
    "start": "1520300",
    "end": "1526060"
  },
  {
    "text": "It doesn't provide you\nwith that facility, and so there's no way to-- you can make a fast Python\ncompiler that will do this.",
    "start": "1526060",
    "end": "1532360"
  },
  {
    "text": "So NumPy is implemented\nin C. Even with-- some of you are\nfamiliar with PyPy,",
    "start": "1532360",
    "end": "1537650"
  },
  {
    "text": "which is an attempt to make\na fast-- like a tracing jit for Python. So when they poured\ninto NumPy to PyPy,",
    "start": "1537650",
    "end": "1544840"
  },
  {
    "text": "or they attempted to, even then\nthey could implement more of it in Python.",
    "start": "1544840",
    "end": "1550330"
  },
  {
    "text": "But they had to\nimplement the core in C. OK, but given that,\nI can do this.",
    "start": "1550330",
    "end": "1557200"
  },
  {
    "text": "I can import the NumPy\nmodule into Julia, get its sum function, and\nbenchmark the NumPy sum",
    "start": "1557200",
    "end": "1564970"
  },
  {
    "text": "function, and-- OK, again, it takes\na few seconds to run.",
    "start": "1564970",
    "end": "1572440"
  },
  {
    "text": " OK, and it takes\n3.8 milliseconds.",
    "start": "1572440",
    "end": "1579590"
  },
  {
    "text": "So the C was 10 milliseconds. So it's actually doing\nfaster than the C code, almost a little over\ntwice as fast, actually.",
    "start": "1579590",
    "end": "1588230"
  },
  {
    "text": "And what's going on is their C\ncode is better than my C code. Their C code is using\nSIMD instructions.",
    "start": "1588230",
    "end": "1597700"
  },
  {
    "text": "So and at this point, I'm\nsure that you guys all know about these\nthings where you can read in two numbers or four\nnumbers into one giant register",
    "start": "1597700",
    "end": "1606380"
  },
  {
    "text": "and one instruction add\nall four numbers at once. OK, so what about if we\ngo in the other direction?",
    "start": "1606380",
    "end": "1614200"
  },
  {
    "text": "We write our own\nPython sum function. So we don't use the Python\nsum implemented in C. I write our own Python.",
    "start": "1614200",
    "end": "1620130"
  },
  {
    "text": "So here is a little my\nsum function in Python. Only works for floating point.",
    "start": "1620130",
    "end": "1625290"
  },
  {
    "text": "Oh, I initialize S to 0.0. So really, it only accumulates\nfloating point values. But that's OK.",
    "start": "1625290",
    "end": "1630510"
  },
  {
    "text": "And then I just\nloop for x and a, s equals s plus x, return s\nis the most obvious thing you",
    "start": "1630510",
    "end": "1636180"
  },
  {
    "text": "would write in Python. OK, and checked that it works. Yeah, errors 10 the minus 13th.",
    "start": "1636180",
    "end": "1642700"
  },
  {
    "text": "It's giving the right answer. And now let's time it. ",
    "start": "1642700",
    "end": "1649679"
  },
  {
    "text": "So remember that C\nwas 10 milliseconds. NumPy was 5 milliseconds, and\nthen built-in Python was like,",
    "start": "1649680",
    "end": "1657750"
  },
  {
    "text": "the sum was 50 milliseconds\noperating on this list. So now we have C code\noperating on this list",
    "start": "1657750",
    "end": "1664560"
  },
  {
    "text": "with 50 milliseconds. And now we have Python code\noperating on this list.",
    "start": "1664560",
    "end": "1669810"
  },
  {
    "text": "And that is 230\nmilliseconds, all right?",
    "start": "1669810",
    "end": "1676320"
  },
  {
    "text": "So it's quite a bit slower. And it's because, basically,\nin Python, there's-- in the pure Python\ncode, there's no way",
    "start": "1676320",
    "end": "1682050"
  },
  {
    "text": "to implement this fast\npath that checks-- oh they're all the same\ntype, so I can cash the plus function and so forth.",
    "start": "1682050",
    "end": "1687422"
  },
  {
    "text": "I don't think it's\nfeasible to implement that. And so basically\nthen on every loop",
    "start": "1687422",
    "end": "1693150"
  },
  {
    "text": "iteration has to look up the\nplus function dynamically and allocate a new\nbox for the result",
    "start": "1693150",
    "end": "1699570"
  },
  {
    "text": "and do that 10 to 7 times. Now, so there's a built-in\nsum function in Julia.",
    "start": "1699570",
    "end": "1709370"
  },
  {
    "text": "So [INAUDIBLE] benchmark\nthat as a-- it's actually implemented in Julia. It's not implemented\nin C. I won't",
    "start": "1709370",
    "end": "1715537"
  },
  {
    "text": "show you the code\nfor the built-in one because it's a little\nmessy because it's actually computing the sum more\naccurately than the loop that",
    "start": "1715537",
    "end": "1722100"
  },
  {
    "text": "have done. So that's 3.9 milliseconds.",
    "start": "1722100",
    "end": "1728560"
  },
  {
    "text": "So it's comparable to\nthe NumPy code, OK? So it's also using SIMD,\nbut so this is also fast.",
    "start": "1728560",
    "end": "1735600"
  },
  {
    "text": " So now so why can Julie do that?",
    "start": "1735600",
    "end": "1742290"
  },
  {
    "text": "So it has to be that the\narray type, first of all, has the type attached to it. So you can see the type of the\narray is an array of low 64.",
    "start": "1742290",
    "end": "1749410"
  },
  {
    "text": "So there's a type tag\nattached to the array itself. So somehow, that's involved.",
    "start": "1749410",
    "end": "1755850"
  },
  {
    "text": "So it looks more\nlike an NumPy ray in memory than a Python list.",
    "start": "1755850",
    "end": "1763920"
  },
  {
    "text": "You can make the\nequivalent of a Python list that's called an array of any. So if I convert this to an\narray of any, so an array of any",
    "start": "1763920",
    "end": "1773230"
  },
  {
    "text": "is something where the elements\ntypes can be any Julia type. And so then it has to\nbe stored as something like this as an array\nof pointers to boxes.",
    "start": "1773230",
    "end": "1780430"
  },
  {
    "text": "And when I do that-- let's see-- [INAUDIBLE]\nthere it is--",
    "start": "1780430",
    "end": "1786400"
  },
  {
    "text": "then it's 355 milliseconds. So it's actually even\nworse than Python. So the Julia-- the\nPython, they spent a lot",
    "start": "1786400",
    "end": "1793480"
  },
  {
    "text": "of time optimizing\ntheir code past for things that had to allocate\nlots of boxes all the time. So in Julia, it's\nusually understood",
    "start": "1793480",
    "end": "1799960"
  },
  {
    "text": "that if you're\nwriting optimized code you're going to do it not on\narrays of pointers to boxes.",
    "start": "1799960",
    "end": "1805150"
  },
  {
    "text": "You're going to write on\nhomogeneous arrays or things where the types are\nknown at compile time.",
    "start": "1805150",
    "end": "1811690"
  },
  {
    "text": "OK, so let's write our\nown Julia sum function. So this is a a\nJulia sum function.",
    "start": "1811690",
    "end": "1817570"
  },
  {
    "start": "1813000",
    "end": "2786000"
  },
  {
    "text": "There's no type declaration. It works on any container type.",
    "start": "1817570",
    "end": "1822740"
  },
  {
    "text": "I initialize s for\nthis function called 0 for the element type of a.",
    "start": "1822740",
    "end": "1827809"
  },
  {
    "text": "So it initializes into\nthe additive identity. So it will work on any\ncontainer of anything that supports a plus function\nthat has an additive identity.",
    "start": "1827810",
    "end": "1835510"
  },
  {
    "text": "So it's completely generic. It looks a lot like\nthe Python code except for there's no\n0 function in Python.",
    "start": "1835510",
    "end": "1841816"
  },
  {
    "text": "And let's make sure it\ngives the right answer. It does. And let's benchmark it.",
    "start": "1841816",
    "end": "1846890"
  },
  {
    "text": " So this is the code you'd\nlike to be able to right.",
    "start": "1846890",
    "end": "1853960"
  },
  {
    "text": "You'd like to be able to\nwrite high level code that's a straight level straight loop. Unlike the C code, it's\ncompletely generic, right?",
    "start": "1853960",
    "end": "1860810"
  },
  {
    "text": "It works on any\ncontainer, anything you can loop over, and anything\nthat has a plus function, so",
    "start": "1860810",
    "end": "1866510"
  },
  {
    "text": "an array of quarternians\nor whatever. And a benchmark,\nit's 11 milliseconds.",
    "start": "1866510",
    "end": "1871580"
  },
  {
    "text": "It's the same as the C code\nI wrote in the beginning. It's not using SIMD.",
    "start": "1871580",
    "end": "1876688"
  },
  {
    "text": "So the instructions are-- that's where the additional\nfactors of 2 come. But it's the same as\nthe non SIMD C code.",
    "start": "1876688",
    "end": "1882039"
  },
  {
    "text": "And, in fact, if I\nwant to use SIMD, there is a little tag you\ncan put on a loop to tell--",
    "start": "1882040",
    "end": "1888590"
  },
  {
    "text": "it says compile this with llvm. Tell llvm to try and\nvectorize the loop. Sometimes it can.",
    "start": "1888590",
    "end": "1893930"
  },
  {
    "text": "Sometimes it can't. But something like\nthis, it should be able to vectorize\nit simple enough.",
    "start": "1893930",
    "end": "1900200"
  },
  {
    "text": "You don't need to hand code\nSIMD instructions for a loop this simple. Yeah? AUDIENCE: Why don't you\nalways put the [INAUDIBLE]??",
    "start": "1900200",
    "end": "1906920"
  },
  {
    "text": "STEVEN JOHNSON: So a yeah,\nwhy isn't it the default? Because most code, the\ncompiler cannot autovectorize.",
    "start": "1906920",
    "end": "1913070"
  },
  {
    "text": "So it increases the completion\ntime and often blows to the code size for no benefit.",
    "start": "1913070",
    "end": "1918409"
  },
  {
    "text": "So it's only really-- it's really only\nrelatively simple loops on doing simple operations and\narrays that benefit from SIMD.",
    "start": "1918410",
    "end": "1925370"
  },
  {
    "text": "So you don't want\nit to be there. Yeah, so now it's\n4.3 milliseconds.",
    "start": "1925370",
    "end": "1931950"
  },
  {
    "text": "So it's about the same as\nthe NumPy and so forth. It's a little slower\nthan the NumPy.",
    "start": "1931950",
    "end": "1938282"
  },
  {
    "text": "It's interesting. A year ago when I tried\nthis, it was almost exactly the same speed as the NumPy. And then since then, both\nthe NumPy and the Julia",
    "start": "1938282",
    "end": "1945888"
  },
  {
    "text": "have gotten better. But the NumPy got better more. So there's something\ngoing on with basically how well the compiler can\nuse AVX instructions by--",
    "start": "1945888",
    "end": "1952910"
  },
  {
    "text": "it seems like we're still\ninvestigating what that is. But it's an llvm\nlimitation looks like.",
    "start": "1952910",
    "end": "1958650"
  },
  {
    "text": "So as it's still\ncompletely type generic. So it I make a random\narray of complex numbers,",
    "start": "1958650",
    "end": "1963830"
  },
  {
    "text": "and then I sum them-- ",
    "start": "1963830",
    "end": "1968835"
  },
  {
    "text": "which one am I calling now? Am I calling the vector? My sum is the\nvectorized one, right? So complex numbers--\neach complex number",
    "start": "1968835",
    "end": "1975590"
  },
  {
    "text": "is two floating point numbers. So it should take\nabout twice the time to naively think, right?",
    "start": "1975590",
    "end": "1980650"
  },
  {
    "text": "So twice the number\nof operations to add, the same number of\ncomplex numbers, the same number of real numbers. Yeah, and it does.",
    "start": "1980650",
    "end": "1986180"
  },
  {
    "text": "It takes about 11 milliseconds. So 10 to the 7, which\nis about twice the 5",
    "start": "1986180",
    "end": "1993140"
  },
  {
    "text": "milliseconds it took for the\nsame number of real numbers. And the code works\nfor everything.",
    "start": "1993140",
    "end": "1998450"
  },
  {
    "text": "So why? OK, so what's going on here? ",
    "start": "1998450",
    "end": "2004852"
  },
  {
    "text": "So-- OK, so we saw\nthis my sum function. I'll just take out\nthe SIMD for now.",
    "start": "2004852",
    "end": "2012570"
  },
  {
    "text": "And we did all that. OK. ",
    "start": "2012570",
    "end": "2018070"
  },
  {
    "text": "OK, and it works for any type. It doesn't even\nhave to be an array. So, for example, there\nis another container type",
    "start": "2018070",
    "end": "2024370"
  },
  {
    "text": "called a set in Julia, which\nis just an unordered collection",
    "start": "2024370",
    "end": "2029530"
  },
  {
    "text": "of unique elements. But you can also loop over it. If it's a set of integers,\nyou can also summit.",
    "start": "2029530",
    "end": "2036220"
  },
  {
    "text": "And I'm waiting for the\nbenchmarks to complete. So let me allocate a set.",
    "start": "2036220",
    "end": "2041679"
  },
  {
    "text": " It says there's no\ntype declarations here.",
    "start": "2041680",
    "end": "2049329"
  },
  {
    "text": "Mysum a-- there was\nno a-- has to be an array of particular\ntype or it doesn't even have to be an array, right?",
    "start": "2049330",
    "end": "2054669"
  },
  {
    "text": "So set is a different\ndata structure. And so it's a set of integers.",
    "start": "2054670",
    "end": "2062624"
  },
  {
    "text": "The sets are unique. If I add something to already\nthe set-- it's in there-- it won't add it twice.",
    "start": "2062624",
    "end": "2069158"
  },
  {
    "text": "And it supports\nthe fast checking. Is 2 in the set? Is 3 in the set? It doesn't have to look\nthrough all the elements.",
    "start": "2069159",
    "end": "2075852"
  },
  {
    "text": "It's a hash internally. But I can call my\nmysum function on it, and it sums up 2 plus 17 plus\n6.24, which is hopefully 49,",
    "start": "2075852",
    "end": "2086810"
  },
  {
    "text": "right? So OK, so what's going on here? So suppose you define--",
    "start": "2086810",
    "end": "2093290"
  },
  {
    "text": "the key, one of\nthe keys, there's several things that are going\non in to make Julia fast. One key thing is that when\nyou have a function like this",
    "start": "2093290",
    "end": "2100370"
  },
  {
    "text": "mysum, or even here's\na simpler function-- f of x equals x plus 1-- when I call it with a\nparticular type of argument,",
    "start": "2100370",
    "end": "2108320"
  },
  {
    "text": "like an integer, or\nan array of integers, or whatever, then it compiles\na specialized version",
    "start": "2108320",
    "end": "2116720"
  },
  {
    "text": "of that for that type. So here's f of x\nequals x plus 1. It works on any type\nsupporting plus.",
    "start": "2116720",
    "end": "2125980"
  },
  {
    "text": "So if I call f of 3-- so here I'm passing\na 64-bit integer.",
    "start": "2125980",
    "end": "2131680"
  },
  {
    "text": "When it did that, it says,\nOK, x is a 64-bit integer. I'm going to compile\na specialized version",
    "start": "2131680",
    "end": "2136930"
  },
  {
    "text": "of f with that knowledge. And then when I call with\na different type, 3.1,",
    "start": "2136930",
    "end": "2145279"
  },
  {
    "text": "now x is a floating\npoint number. It will compile a specialized\nversion with that value.",
    "start": "2145280",
    "end": "2151480"
  },
  {
    "text": "If I call it with\nanother integer, it says, oh, that version\nwas already compiled. [INAUDIBLE] I'll re-use it.",
    "start": "2151480",
    "end": "2156580"
  },
  {
    "text": "So it only compiles\nit the first time you call it with\na particular type. If I call it with\na string, it'll give an error because\nit doesn't know",
    "start": "2156580",
    "end": "2162262"
  },
  {
    "text": "how to add plus to a string. So it's a particular--",
    "start": "2162262",
    "end": "2168040"
  },
  {
    "text": "OK, so what is going on? So we can actually look\nat the compiled code.",
    "start": "2168040",
    "end": "2173640"
  },
  {
    "text": "So the function is called\ncode, these macros called code llvm and code native.",
    "start": "2173640",
    "end": "2179030"
  },
  {
    "text": "They say, OK, when I\ncall f of 1, what's the-- do people know what llvm is? You guys-- OK, so llvm\ncompiles to byte code first",
    "start": "2179030",
    "end": "2187713"
  },
  {
    "text": "and then it goes\nto machine codes. So you can see the\nllvm bit code or byte code, or whatever it's called.",
    "start": "2187713",
    "end": "2192760"
  },
  {
    "text": "And you can see the\nnative machine code. So here's the llvm\nbyte code that it compiles to [INAUDIBLE].",
    "start": "2192760",
    "end": "2199330"
  },
  {
    "text": "So it's a bit called\nadd i640 basically",
    "start": "2199330",
    "end": "2204760"
  },
  {
    "text": "one llvm instruction, which\nturns into one machine instruction, load effective\naddress is actually",
    "start": "2204760",
    "end": "2212990"
  },
  {
    "text": "a 64-bit edition\nfunction instruction.",
    "start": "2212990",
    "end": "2218220"
  },
  {
    "text": "So let's think about\nwhat had to happen there. So you have f of\nx equals x plus 1.",
    "start": "2218220",
    "end": "2224560"
  },
  {
    "text": "Now you want to compile for x\nis a int 64, so 64-bit integer,",
    "start": "2224560",
    "end": "2239790"
  },
  {
    "text": "or in Julia, we'd say\nx colon colon int 64.",
    "start": "2239790",
    "end": "2244840"
  },
  {
    "text": "So colon colon means that\nthis is of this type, OK? So this is 64-bit integer type.",
    "start": "2244840",
    "end": "2250860"
  },
  {
    "text": "So what does it have to do? It first has to figure out\nwhat plus function to call. So plus, it has lots of--",
    "start": "2250860",
    "end": "2259740"
  },
  {
    "text": "there is a plus for\ntwo matrices, a plus for lots of different things. So depending on the\ntypes of the arguments,",
    "start": "2259740",
    "end": "2265810"
  },
  {
    "text": "it decides on which\nplus function to call. So it first realizes,\noh, this is an integer.",
    "start": "2265810",
    "end": "2273360"
  },
  {
    "text": "Oh, this is an integer. This is also a 64-bit integer. So that means I'm going to\ncall the plus function for two",
    "start": "2273360",
    "end": "2283494"
  },
  {
    "text": "integers. ",
    "start": "2283495",
    "end": "2289080"
  },
  {
    "text": "So I'm going to look\ninto that function. And then, oh, that\none returns an int 64.",
    "start": "2289080",
    "end": "2298400"
  },
  {
    "text": "So that's a return\nvalue for my function. And oh, by the\nway, this function is so simple that I'm\ngoing to inline it.",
    "start": "2298400",
    "end": "2306089"
  },
  {
    "text": "So it's type specializing. And this process of going\nfrom x is an integer to that,",
    "start": "2306090",
    "end": "2314058"
  },
  {
    "text": "to figure out the\ntype of the output, is called type inference, OK?",
    "start": "2314058",
    "end": "2322380"
  },
  {
    "text": "So. in general, for\ntype inference, it",
    "start": "2322380",
    "end": "2330900"
  },
  {
    "text": "is given the types\nof the inputs,",
    "start": "2330900",
    "end": "2337799"
  },
  {
    "text": "it tries to infer the types\nof the outputs and, in fact,",
    "start": "2337800",
    "end": "2346410"
  },
  {
    "text": "all intermediate values as well. ",
    "start": "2346410",
    "end": "2355170"
  },
  {
    "text": "Now what makes it a dynamic\nlanguage is this can fail. So in some languages like\nml or some other languages,",
    "start": "2355170",
    "end": "2362120"
  },
  {
    "text": "you don't really declare types. But they're designed\nso they could give the types the inputs.",
    "start": "2362120",
    "end": "2367460"
  },
  {
    "text": "So you can figure\nout everything. And if it can't\nfigure out everything, it gives an error, basically. It has to infer everything.",
    "start": "2367460",
    "end": "2374480"
  },
  {
    "text": "So Julia is a dynamic language. This can fail and\nhave a fallback. If it doesn't know the type,\nit can stick things in a box.",
    "start": "2374480",
    "end": "2381109"
  },
  {
    "text": "But obviously, the fast\npath is when it succeeds. And one of the key\nthings is you have",
    "start": "2381110",
    "end": "2386720"
  },
  {
    "text": "to try and make this kind\nof thing work in a language. You have to design\nthe language so",
    "start": "2386720",
    "end": "2392450"
  },
  {
    "text": "that at least for all\nthe built-in constructs, the standard\nlibrary, in general,",
    "start": "2392450",
    "end": "2397670"
  },
  {
    "text": "in the culture for\npeople designing packages and so forth, to design things\nso that this type inference can",
    "start": "2397670",
    "end": "2404775"
  },
  {
    "text": "succeed.  And I'll give a counter example\nto that in a minute, right?",
    "start": "2404775",
    "end": "2411270"
  },
  {
    "text": "So and this works recursively. So it's not suppose\nI define a function g of x equals f of x times 2, OK?",
    "start": "2411270",
    "end": "2419569"
  },
  {
    "text": "And then I called g of 1. So it's going to say, OK,\nx here is an integer, OK?",
    "start": "2419570",
    "end": "2426020"
  },
  {
    "text": "I'm going to call f with\nan integer argument. Oh, I should compile f\nfor an integer argument, figure out its return\ntype, use its returned type",
    "start": "2426020",
    "end": "2432160"
  },
  {
    "text": "to figure out what time's\nfunction to call and do all of this at compile time, right? Not at runtime, ideally.",
    "start": "2432160",
    "end": "2439319"
  },
  {
    "text": "So we can look at the\nllvm code for this. And, in fact, so remember,\nf of x adds 1 to x.",
    "start": "2439320",
    "end": "2446870"
  },
  {
    "text": "And then we're multiplying by 2. So the result\ncomputes 2x plus 2.",
    "start": "2446870",
    "end": "2452750"
  },
  {
    "text": "And llvm is smart enough. So f is so simple\nthat it inlines it. And then llvm is smart\nenough that I don't have to--",
    "start": "2452750",
    "end": "2460560"
  },
  {
    "text": "well, I know it does it\nby one shift instruction to multiply x by 2.",
    "start": "2460560",
    "end": "2466040"
  },
  {
    "text": "And then it adds 2. So it actually combines\nthe times 2 and the plus 1. So it does constant folding, OK?",
    "start": "2466040",
    "end": "2472430"
  },
  {
    "text": "And it can continue on. If you look at h of x\nequals g of x times 2, then that compiles to 1 shift\ninstruction to multiply x by 4",
    "start": "2472430",
    "end": "2483110"
  },
  {
    "text": "and then adding 4. So you want the-- so\nthis process cascades.",
    "start": "2483110",
    "end": "2489710"
  },
  {
    "text": "So you can even do it\nfor recursive function. So here's a stupid\nimplementation of the Fibonacci number and calculation of\nrecursive limitation, right?",
    "start": "2489710",
    "end": "2496490"
  },
  {
    "text": "So this is given n. It's an integer. OK, if n is less\nthan 3, returns 1.",
    "start": "2496490",
    "end": "2503420"
  },
  {
    "text": "Otherwise, it adds the\nprevious two numbers. I can compute the first\ncall, listen to the first 10",
    "start": "2503420",
    "end": "2509330"
  },
  {
    "text": "integers. Here's the first 10\nFibonacci numbers. There's also an acute\nnotation in Julia. You can say fib dot.",
    "start": "2509330",
    "end": "2515090"
  },
  {
    "text": "So if you do f dot arguments,\nit calls the function element Y's on a collection and\nreturns a collection.",
    "start": "2515090",
    "end": "2520970"
  },
  {
    "text": "So F dot 1 to 10 returns the\nfirst 10 Fibonacci numbers. And I can call--",
    "start": "2520970",
    "end": "2526759"
  },
  {
    "text": "there's a function called code\n1 type that'll tell me what-- it'll tell me the output\nof type inference.",
    "start": "2526760",
    "end": "2533160"
  },
  {
    "text": "N is a 1. And it goes through-- this is\nkind of a hard to read format.",
    "start": "2533160",
    "end": "2538310"
  },
  {
    "text": "But this is like the-- after one of the compiler passes\ncalled lowering, but yeah.",
    "start": "2538310",
    "end": "2544339"
  },
  {
    "text": "It's figure out the types\nof every intermediate calls. So here it's invoking\nmain dot fib.",
    "start": "2544340",
    "end": "2550580"
  },
  {
    "text": "It's recursively. And it's figured out that the\nreturn type is also int 64. So it knows everything, OK?",
    "start": "2550580",
    "end": "2558140"
  },
  {
    "text": "So you'll notice that\nhere I declared a type. I've said that this\nis an integer, OK?",
    "start": "2558140",
    "end": "2566180"
  },
  {
    "text": "I don't have to do that\nfor type inference. This doesn't help\nthe compiler at all",
    "start": "2566180",
    "end": "2571190"
  },
  {
    "text": "because it does type inference\ndepending on what I pass. So what this is is\nmore like a filter.",
    "start": "2571190",
    "end": "2576320"
  },
  {
    "text": "It says that if I pass-- this function only\naccepts integers. If you pass something else,\nyou should throw an error.",
    "start": "2576320",
    "end": "2582150"
  },
  {
    "text": "Because if I don't\nwant this function, because if I pass 3.7,\nif I fill out any number,",
    "start": "2582150",
    "end": "2588079"
  },
  {
    "text": "if you look at the\n3.7, I can check whether it's less than three. You can call it recursively. I mean, the function would run.",
    "start": "2588080",
    "end": "2594319"
  },
  {
    "text": "It would just give\nnonsense, right? So I want to prevent someone\nfrom passing nonsense for this.",
    "start": "2594320",
    "end": "2599510"
  },
  {
    "text": "So that's one reason to\ndo a type declaration. But another reason is to do\nsomething called dispatch.",
    "start": "2599510",
    "end": "2608660"
  },
  {
    "text": "So what we can do\nis we can define different versions\nof the function for different arguments. So. for example.",
    "start": "2608660",
    "end": "2614720"
  },
  {
    "text": "another nicer version of\nthat is a factorial function. So here is a stupid\nrecursive implementation",
    "start": "2614720",
    "end": "2620240"
  },
  {
    "text": "of a factorial function that\ntakes an integer argument and just recursively\ncalls itself an n minus 1.",
    "start": "2620240",
    "end": "2626680"
  },
  {
    "text": "You can call it a\n10 factorial, OK? If I want 100 factorial, I need\nto use a different type, not",
    "start": "2626680",
    "end": "2633440"
  },
  {
    "text": "64-bit integers. I need some arbitrary\nprecision integer.",
    "start": "2633440",
    "end": "2639450"
  },
  {
    "text": "And since I said it was an\ninteger, if I call in 3.7,",
    "start": "2639450",
    "end": "2645800"
  },
  {
    "text": "it'll given an error. So that's good. But now I can find a\ndifferent version of this.",
    "start": "2645800",
    "end": "2651330"
  },
  {
    "text": "So actually, there\nis a generalization of factorial to arbitrary real,\nin fact, even complex numbers",
    "start": "2651330",
    "end": "2660450"
  },
  {
    "text": "called a gamma function. And so I can define\na fallback that",
    "start": "2660450",
    "end": "2665710"
  },
  {
    "text": "works for any type of\nnumber that calls a gamma function from someplace else.",
    "start": "2665710",
    "end": "2671950"
  },
  {
    "text": "And then if I can pass it to\nfloating point value, I can-- if you take the\nfactorial minus 1/2,",
    "start": "2671950",
    "end": "2679480"
  },
  {
    "text": "it turns out that's actually\na square root of pi. So if I square it, it\ngives pi, all right?",
    "start": "2679480",
    "end": "2685819"
  },
  {
    "text": "So now I have one function and\nI have two methods, all right?",
    "start": "2685820",
    "end": "2691300"
  },
  {
    "text": " So these types here, so\nthere's a hierarchy of types.",
    "start": "2691300",
    "end": "2697610"
  },
  {
    "text": "So this is what's called\nan abstract type, which most of you have probably seen. So there's a type called number.",
    "start": "2697610",
    "end": "2705150"
  },
  {
    "text": "And underneath, there's a class\nof subtypes called integer. And underneath, there is,\nfor example, int 64 or int 8",
    "start": "2705150",
    "end": "2715060"
  },
  {
    "text": "for 64-bit integers. And underneath number\nthere's actually",
    "start": "2715060",
    "end": "2720190"
  },
  {
    "text": "another subtype called real. And underneath that there's\na couple of subtypes. And then there's say\nflow 64 or float 32",
    "start": "2720190",
    "end": "2730420"
  },
  {
    "text": "for a single precision\n32-bit floating point number and so forth. So there's a hierarchy\nof these things.",
    "start": "2730420",
    "end": "2736990"
  },
  {
    "text": "When I specify something\ncan take integer I'm just saying so this type\nis not help the compiler.",
    "start": "2736990",
    "end": "2742660"
  },
  {
    "text": "It's to provide a filter. So this method only\nworks for these types. And this other\nmethod only works--",
    "start": "2742660",
    "end": "2749740"
  },
  {
    "text": "my second method works\nfor any number type. So I have one thing that\nworks for any number.",
    "start": "2749740",
    "end": "2754810"
  },
  {
    "text": "Whoops. Here it is-- One that works for\nany number type, and one method that\nonly works for integers.",
    "start": "2754810",
    "end": "2760960"
  },
  {
    "text": "So when I call it for\n3, which ones does it call, because it actually\ncalled both methods.",
    "start": "2760960",
    "end": "2767200"
  },
  {
    "text": "And what it does is it\ncalls the most specific one. It calls the one that sort\nof farthest down the tree. So if I have a method defined\nfor number and one defined",
    "start": "2767200",
    "end": "2774880"
  },
  {
    "text": "for integer, if I pass an\ninteger, it'll do this. If I have one that's\ndefined for number, one that's defined by\ninteger, and one that's",
    "start": "2774880",
    "end": "2780070"
  },
  {
    "text": "defined specifically\nfor int 8, and I call it a --pass\nan 8 bit integer, it'll call that\nversion, all right? So it gives you a filter.",
    "start": "2780070",
    "end": "2786688"
  },
  {
    "start": "2786000",
    "end": "3086000"
  },
  {
    "text": "But, in general, you can do\nthis on multiple arguments. So this is like the key\nabstraction in Julia, something",
    "start": "2786688",
    "end": "2792070"
  },
  {
    "text": "called multiple dispatch. So this was not\ninvented by Julia. I guess it was present\nin Small Talk, and Dylan.",
    "start": "2792070",
    "end": "2801073"
  },
  {
    "text": "It's been in a\nbunch of languages. It's been floating\naround for a while. But it's not been in a lot\nof mainstream languages,",
    "start": "2801073",
    "end": "2806530"
  },
  {
    "text": "not in a high performance way. And you can think of\nit as a generalization of advertising and programming.",
    "start": "2806530",
    "end": "2813220"
  },
  {
    "text": "So I'm sure all of you have\ndone object oriented programming",
    "start": "2813220",
    "end": "2818660"
  },
  {
    "text": "in Python or C++ or\nsomething like this. So in object-oriented\nprogramming typically",
    "start": "2818660",
    "end": "2823670"
  },
  {
    "text": "the way you think of it is\nthis is you save an object.",
    "start": "2823670",
    "end": "2829230"
  },
  {
    "text": "It's usually spelled object dot\nmethod xy for example, right?",
    "start": "2829230",
    "end": "2837050"
  },
  {
    "text": "And what it does, is this\ntype, the object type",
    "start": "2837050",
    "end": "2847930"
  },
  {
    "text": "determines the method, right? So you can have a\nmethod called plus.",
    "start": "2847930",
    "end": "2855202"
  },
  {
    "text": "But it would actually call\na different class function for a complex number or a real\nnumber, something like that,",
    "start": "2855202",
    "end": "2860500"
  },
  {
    "text": "or a method called length,\nwhich for a Python list would call a different function\nthan for an NumPy array, OK?",
    "start": "2860500",
    "end": "2869540"
  },
  {
    "text": "In Julia, the way you\nwould spell the same thing",
    "start": "2869540",
    "end": "2874930"
  },
  {
    "text": "would you'd say method. ",
    "start": "2874930",
    "end": "2884071"
  },
  {
    "text": "And you wouldn't say\nobject dot method. So you don't think of the-- here, you think of the object\nas sort of owning the method.",
    "start": "2884072",
    "end": "2891344"
  },
  {
    "text": "all right? And Julia-- the\nobject would just be maybe the first argument. In fact, under the hood, if you\nlooking in Python, for example,",
    "start": "2891344",
    "end": "2898640"
  },
  {
    "text": "the object is passed as an\nimplicit first argument called self, all right? So it actually is doing this.",
    "start": "2898640",
    "end": "2904130"
  },
  {
    "text": "It's just different\nspelling of the same thing. But as soon as you read it this\nway, you realized what Python",
    "start": "2904130",
    "end": "2910720"
  },
  {
    "text": "and what op languages\nare doing is they're looking at the\ntype of the first argument to determine the method.",
    "start": "2910720",
    "end": "2916820"
  },
  {
    "text": "But why just the first argument? In a multiple dispatch language,\nyou look at all the types.",
    "start": "2916820",
    "end": "2925880"
  },
  {
    "start": "2925880",
    "end": "2933940"
  },
  {
    "text": "So this is sometimes-- in\nJulia, this will sometimes be called single dispatch\nbecause determining",
    "start": "2933940",
    "end": "2943340"
  },
  {
    "text": "the method is called\ndispatch, figuring out",
    "start": "2943340",
    "end": "2949220"
  },
  {
    "text": "which function is spelled\nlength, which function actually are you calling this dispatching\nto the right function.",
    "start": "2949220",
    "end": "2955510"
  },
  {
    "text": "So this is called\nmultiple dispatch. ",
    "start": "2955510",
    "end": "2962870"
  },
  {
    "text": "And it's clearest if you look at\nsomething like a plus function.",
    "start": "2962870",
    "end": "2967910"
  },
  {
    "text": "So a plus function,\nif you do a plus",
    "start": "2967910",
    "end": "2973170"
  },
  {
    "text": "b, which plus you do really\nshould depend on both a and b, right?",
    "start": "2973170",
    "end": "2978330"
  },
  {
    "text": "It shouldn't depend\non just a or just b. And so it's actually quite\nawkward in languages,",
    "start": "2978330",
    "end": "2984000"
  },
  {
    "text": "in o op languages like Python\nor especially C++ to overload a plus operation that operates\non sort of mixed types.",
    "start": "2984000",
    "end": "2991560"
  },
  {
    "text": "As a consequence, for example,\nin C++ there's a built-in complex number type. So you can have a complex\nfloat, or complex double,",
    "start": "2991560",
    "end": "2999780"
  },
  {
    "text": "complex and complex with\ndifferent real types. But you can't add a complex\nfloat to a complex double.",
    "start": "2999780",
    "end": "3006972"
  },
  {
    "text": "You can't add a\nsingle-precision complex number to a double-precision complex\nnumber or any mixed operation because--",
    "start": "3006972",
    "end": "3013190"
  },
  {
    "text": "any mixed complex\noperation because it can't figure out\nwho owns the method. It doesn't have a way of\ndoing that kind of promotion,",
    "start": "3013190",
    "end": "3020510"
  },
  {
    "text": "all right? So in Julia, so now\nyou can have a method for adding a float\n32 to a float 32,",
    "start": "3020510",
    "end": "3031790"
  },
  {
    "text": "but also a method for adding a-- I don't know-- let's see,\nadding a complex number",
    "start": "3031790",
    "end": "3041119"
  },
  {
    "text": "to a real number, for example. You want to specialize--\nor a real number to a complex number.",
    "start": "3041120",
    "end": "3046260"
  },
  {
    "text": "You want to specialize things. In fact, we can click on the\nlink here and see the code. So the complex number to\na real number in Julia",
    "start": "3046260",
    "end": "3054140"
  },
  {
    "text": "looks like this. It's the most obvious thing. It's implemented in Julia. Plus complex real creates\nnew complex number.",
    "start": "3054140",
    "end": "3061335"
  },
  {
    "text": "But you only have to\nadd the real part. You can leave the\nimaginary part alone. And this works on\nany complex type.",
    "start": "3061335",
    "end": "3068760"
  },
  {
    "text": "OK, so there's too\nmany methods for--",
    "start": "3068760",
    "end": "3077380"
  },
  {
    "text": "OK, I can shrink that. Let's see. ",
    "start": "3077380",
    "end": "3083560"
  },
  {
    "text": "So but there's another type\ninference thing called--",
    "start": "3083560",
    "end": "3088670"
  },
  {
    "start": "3086000",
    "end": "3446000"
  },
  {
    "text": "I'll just mention it briefly. So one of the things you've to\ndo to make this type inference",
    "start": "3088670",
    "end": "3095140"
  },
  {
    "text": "process work is given the\ntypes of the arguments you have to figure out the\ntype of the return value, OK?",
    "start": "3095140",
    "end": "3101440"
  },
  {
    "text": "So that means when\nyou assign a function, it has to be what's\ncalled type stable. The type of the\nresult should depend",
    "start": "3101440",
    "end": "3108040"
  },
  {
    "text": "on the types of the\narguments and not on the values of the\narguments because the types are known at compile time.",
    "start": "3108040",
    "end": "3113410"
  },
  {
    "text": "The values are only\nknown at runtime. And it turns out if you don't\nhave this in mind, in C,",
    "start": "3113410",
    "end": "3119950"
  },
  {
    "text": "you have no choice\nbut to obey this. But in something like\nPython and dynamic language, like Python and Matlab, if\nyou're not thinking about this,",
    "start": "3119950",
    "end": "3125517"
  },
  {
    "text": "it's really easy to design\nthings so that it doesn't work, so that it's not true. So a classic example is\na square root function.",
    "start": "3125517",
    "end": "3132790"
  },
  {
    "text": "All right, so suppose I\npass an integer to it, OK? So the square root of--",
    "start": "3132790",
    "end": "3139090"
  },
  {
    "text": "let's do square root\nof 5, all right? The result has to be\nfloating point number, right?",
    "start": "3139090",
    "end": "3147300"
  },
  {
    "text": "It's 2.23-- whatever. So if I do square\nroot of 4, of course, that square root is an integer.",
    "start": "3147300",
    "end": "3153190"
  },
  {
    "text": "But if I return an\ninteger for that type, then it wouldn't be\ntype stable anymore. Than the return value\ntype would depend",
    "start": "3153190",
    "end": "3159217"
  },
  {
    "text": "on the value of the input,\nwhether it's a perfect square or not, all right? So it was returned to\nfloating point value,",
    "start": "3159217",
    "end": "3164457"
  },
  {
    "text": "even if the input is an integer. Yes? AUDIENCE: If you\nhave enough methods to find for a bunch of different\ntypes of lookup function?",
    "start": "3164457",
    "end": "3171520"
  },
  {
    "text": "Can that become really slow? STEVEN JOHNSON: Well,\nso the lookup comes-- it comes at compile time. So it's really\nkind of irrelevant.",
    "start": "3171520",
    "end": "3179560"
  },
  {
    "text": "At least if type\ninference succeeds, if type inference fails, then\nit's runtime, it's slower.",
    "start": "3179560",
    "end": "3185430"
  },
  {
    "text": "But it's not like-- it's like a tree surge. So it's not-- it's not as\nslow as you might think.",
    "start": "3185430",
    "end": "3191880"
  },
  {
    "text": "But most of the time you\ndon't worry about that because if you care\nabout performance you want to arrange your code\nso that type inference succeeds.",
    "start": "3191880",
    "end": "3200170"
  },
  {
    "text": "So you prototype maybe to-- this is something that you do\nin performance optimization. Like when you're prototyping,\nyou don't care about types,",
    "start": "3200170",
    "end": "3206315"
  },
  {
    "text": "you say x equals 3. And the next line you\nsay x equals an array-- whatever. But when you're\noptimizing your code, then, OK, you tweak\nit a little bit",
    "start": "3206315",
    "end": "3212628"
  },
  {
    "text": "to make sure that things\ndon't change types willy nilly and that the types\nof function depend on the types of the\narguments not on the values.",
    "start": "3212628",
    "end": "3219580"
  },
  {
    "text": "So, as I mentioned, square root\nis what really confuses people at first, is if you take\nsquare root of minus 1,",
    "start": "3219580",
    "end": "3226410"
  },
  {
    "text": "you might think you should\nget a complex value. And instead, it gives\nyou an error, right?",
    "start": "3226410",
    "end": "3233310"
  },
  {
    "text": "And basically, what\nare the choices here? It could give you an error.",
    "start": "3233310",
    "end": "3239460"
  },
  {
    "text": "It could give you\na complex value. But if it gave you\na complex value, then the return\ntype of square root",
    "start": "3239460",
    "end": "3244770"
  },
  {
    "text": "would depend upon the value of\nthe input, not just the type. So Matlab, for example, if you\ntake square root of minus 1,",
    "start": "3244770",
    "end": "3250990"
  },
  {
    "text": "it will happily give\nyou a complex number. But as a result,\nif you have Matlab, Matlab has a compiler, right?",
    "start": "3250990",
    "end": "3257760"
  },
  {
    "text": "But it has many, many\nchallenges/ but one simple thing to understand is if the\nMatlab compiler suite sees",
    "start": "3257760",
    "end": "3262920"
  },
  {
    "text": "a square root function,\nanywhere in your function, even if it knows the\ninputs that are real,",
    "start": "3262920",
    "end": "3268540"
  },
  {
    "text": "it doesn't know if the outputs\nare complex or real unless it can prove that the inputs\nwere positive or non-negative,",
    "start": "3268540",
    "end": "3274799"
  },
  {
    "text": "right? And that means it could\nthen compile two code pass for the output, all right?",
    "start": "3274800",
    "end": "3281210"
  },
  {
    "text": "But then suppose it\ncalls square root again or some other function, right? You quickly get a\ncombinatorial explosion",
    "start": "3281210",
    "end": "3287490"
  },
  {
    "text": "of possible code paths\nbecause of possible types. And so at some point,\nyou just give up",
    "start": "3287490",
    "end": "3292590"
  },
  {
    "text": "and put things in a box. But as soon as you\nput things in a box, and you're looking\nup types at runtime, you're dead from a\nperformance perspective.",
    "start": "3292590",
    "end": "3299859"
  },
  {
    "text": "So Python, actually-- s if\nyou want a complex result from square root, you have\nto give it a complex input. So in Julia, a complex\nnumber, the I is actually m.",
    "start": "3299860",
    "end": "3309690"
  },
  {
    "text": "They decide I is too\nuseful for loop variables. So I and J. So m is\nthe complex unit.",
    "start": "3309690",
    "end": "3315361"
  },
  {
    "text": "And if you take square\nroot of a complex input, it gives you a complex output. So Python actually\ndoes the same thing.",
    "start": "3315362",
    "end": "3321600"
  },
  {
    "text": "So if in Python if\nit takes square root of a negative value,\nit gives an error unless you give it\na complex input.",
    "start": "3321600",
    "end": "3328309"
  },
  {
    "text": "But Python made other mistakes. So, for example, in\nPython, an integer",
    "start": "3328310",
    "end": "3336240"
  },
  {
    "text": "is guaranteed never to overflow. If you add 11 plus 1 plus 1\nover and over again in Python,",
    "start": "3336240",
    "end": "3342390"
  },
  {
    "text": "eventually overflow the\nsize of a 64-bit integer, and Python will just\nswitch under the hood to an arbitrary position\nin an integer, which",
    "start": "3342390",
    "end": "3350460"
  },
  {
    "text": "seem like a nice idea\nprobably at the time. And the rest in\nPython is so slow that the performance\ncost of this test",
    "start": "3350460",
    "end": "3358620"
  },
  {
    "text": "makes no difference in\na typical Python code. But it makes it very\ndifficult to compile. Because that means if you have\ninteger inputs and you see x",
    "start": "3358620",
    "end": "3365190"
  },
  {
    "text": "plus 1 in Python, the compiler\ncannot just compile that to one",
    "start": "3365190",
    "end": "3371010"
  },
  {
    "text": "instruction, because unless\nyou can somehow prove that x is sufficiently small.",
    "start": "3371010",
    "end": "3377440"
  },
  {
    "text": "So in Julia, integer\narithmetic will overflow. But the default integer\narithmetic it's 64 bits.",
    "start": "3377440",
    "end": "3384610"
  },
  {
    "text": "So in practice that\nnever overflows unless you're doing\nnumber theory. And you usually know if\nyou're doing number theory,",
    "start": "3384610",
    "end": "3389895"
  },
  {
    "text": "and then use arbitrary\nprecision integers. It was much worse in the days-- this is something\npeople worried a lot",
    "start": "3389895",
    "end": "3396510"
  },
  {
    "text": "before you were born when there\nwere 16-bit machines, right? And integers, it's\nreally, really easy",
    "start": "3396510",
    "end": "3402180"
  },
  {
    "text": "to overflow 16 bits because\nthe biggest sine value is then",
    "start": "3402180",
    "end": "3409510"
  },
  {
    "text": "32,767, right? So it's really easy\nto overflow it. So you're constantly\nworrying about overflow.",
    "start": "3409510",
    "end": "3416460"
  },
  {
    "text": "And even 32 bits, the biggest\nsign value is 2 billion. It's really easy to overflow\nthat, even just counting bytes,",
    "start": "3416460",
    "end": "3422550"
  },
  {
    "text": "right? You can have files that are\nbigger than 2 gigabytes easily nowadays. So some people worried\nabout this all the time.",
    "start": "3422550",
    "end": "3428580"
  },
  {
    "text": "There were 64-bit integers. Basically, 64-bit\ninteger will never overflow if it's\ncounting objects",
    "start": "3428580",
    "end": "3434339"
  },
  {
    "text": "that exist in the real universe,\nlike bytes, or loop iterations, or something like that. So you just-- then you just\nsay, OK, it's either 64 bits,",
    "start": "3434340",
    "end": "3441859"
  },
  {
    "text": "or you're doing number theory. You should big ints. So OK. So let me talk about--",
    "start": "3441860",
    "end": "3448058"
  },
  {
    "start": "3446000",
    "end": "3599000"
  },
  {
    "text": "the final thing I want to\ntalk about-- let's see, how much [INAUDIBLE] good-- is defining our own types.",
    "start": "3448058",
    "end": "3455810"
  },
  {
    "text": "So this is the real test\nof the language, right? So it's easy to make\na language where",
    "start": "3455810",
    "end": "3463207"
  },
  {
    "text": "there is a certain\nbuilt-in set of functions and built-in types, and\nthose things are fast.",
    "start": "3463207",
    "end": "3468580"
  },
  {
    "text": "So, for example, for\nPython, there actually is a compiler called numba that\ndoes exactly what Julia does.",
    "start": "3468580",
    "end": "3474070"
  },
  {
    "text": "It looks at the arguments,\ntype specializes things, and then calls llvm and\ncompiles it to fast code.",
    "start": "3474070",
    "end": "3480280"
  },
  {
    "text": "But it only works if you're\nonly container type as an NumPy array and you're only scalar\ntype is one of the 12 scalar",
    "start": "3480280",
    "end": "3486760"
  },
  {
    "text": "types that NumPy supports. If you have your own\nuser defined number type or your own user\ndefined container type,",
    "start": "3486760",
    "end": "3493060"
  },
  {
    "text": "then it doesn't work. And user-defined\ncontainer types, it's probably easy to\nunderstand why that's useful.",
    "start": "3493060",
    "end": "3499468"
  },
  {
    "text": "User defined number types\nare extremely useful as well. So, for example, there's\na package in Julia",
    "start": "3499468",
    "end": "3505480"
  },
  {
    "text": "that provides the number\ntype called dual numbers. And those have the property\nthat if you pass them",
    "start": "3505480",
    "end": "3511210"
  },
  {
    "text": "into the function they compute\nthe function in its derivative. And just a slightly different.",
    "start": "3511210",
    "end": "3517750"
  },
  {
    "text": "It basically carries around\nfunction an derivative values and has a slightly\ndifferent plus and times and so forth that just do the\nproduct rule and so forth.",
    "start": "3517750",
    "end": "3525700"
  },
  {
    "text": "And it just propagates\nderivatives. And then if you have Julia code,\nlike that Vandermonde function,",
    "start": "3525700",
    "end": "3531609"
  },
  {
    "text": "it will just compute\nits derivative as well. OK, so I want to be able\nto find my own type. So a very simple type\nthat I might want to add",
    "start": "3531610",
    "end": "3538420"
  },
  {
    "text": "would be points 2D vectors\nin two space, right? So, of course, I could have\nan array of two values.",
    "start": "3538420",
    "end": "3545320"
  },
  {
    "text": "But an array is a really\nheavyweight object for just two values, right?",
    "start": "3545320",
    "end": "3551470"
  },
  {
    "text": "If I know at\ncompile time there's two values that I don't\nneed to have a pointer to-- I can actually store\nthem in registers.",
    "start": "3551470",
    "end": "3557980"
  },
  {
    "text": "I I can unroll the loop\nover these and everything should be faster. You can get an order\nof magnitude and speed",
    "start": "3557980",
    "end": "3564369"
  },
  {
    "text": "by specializing on the number\nof elements for small arrays compared to just a general\nray data structure.",
    "start": "3564370",
    "end": "3573339"
  },
  {
    "text": "So let's make a point, OK? So this is-- and I'm going to\ngo through several iterations,",
    "start": "3573340",
    "end": "3580529"
  },
  {
    "text": "starting with a slow iteration. I'm going to define\na mutable struct. OK, so this will\nbe a mutable object",
    "start": "3580530",
    "end": "3587480"
  },
  {
    "text": "where I can add a\n[INAUDIBLE] point that has two values x and y. It can be of any type.",
    "start": "3587480",
    "end": "3593010"
  },
  {
    "text": "I'll define a plus\nfunction that can add them. And it does the\nmost obvious thing.",
    "start": "3593010",
    "end": "3598320"
  },
  {
    "text": "It adds the x components,\nadds the y components. I'll define a 0 function that's\nthe additive identity that",
    "start": "3598320",
    "end": "3603880"
  },
  {
    "text": "just returns the point 0, 0. And then I can construct\nan object Point34.",
    "start": "3603880",
    "end": "3609040"
  },
  {
    "text": "I can say 034 plus 0.56. It works. It can hold actually--\nright now it's",
    "start": "3609040",
    "end": "3615010"
  },
  {
    "text": "very generic, and\nprobably too generic. So they act like the real\npart can be a floating point",
    "start": "3615010",
    "end": "3620200"
  },
  {
    "text": "number and the imaginary. The x can be a floating\npoint number here and the y is a complex\nnumber of two integers,",
    "start": "3620200",
    "end": "3628660"
  },
  {
    "text": "or even I can make a\nstring and an array. It doesn't even make sense. So I probably should\nhave restricted",
    "start": "3628660",
    "end": "3635020"
  },
  {
    "text": "the types of x\nand y a little bit just to prevent the user\nfrom putting in something that makes no sense at all, OK?",
    "start": "3635020",
    "end": "3642340"
  },
  {
    "text": "So these things,\nthey can be anything. So this type is not\nideal in several ways.",
    "start": "3642340",
    "end": "3648430"
  },
  {
    "text": "So let's think about how this\nhas to be stored in memory. So this is a 0.1.",
    "start": "3648430",
    "end": "3658289"
  },
  {
    "text": "0.11, 3.7, right? So in memory it's--",
    "start": "3658290",
    "end": "3665470"
  },
  {
    "text": " there is an x and there is a y.",
    "start": "3665470",
    "end": "3671680"
  },
  {
    "text": "But x and y can be of any type. So that means they have\nto be pointers to boxes.",
    "start": "3671680",
    "end": "3678369"
  },
  {
    "text": "There's pointer to\nint 1 and there's a pointer to a float\n64, in this case, 3.7.",
    "start": "3678370",
    "end": "3689089"
  },
  {
    "text": "So oh, this already,\nwe know this is not going to be good\nnews for performance. And it's mutable.",
    "start": "3689090",
    "end": "3694690"
  },
  {
    "text": "So that mutable struct means\nif I take p equals a point, I can then say p dot x equals 7.",
    "start": "3694690",
    "end": "3701380"
  },
  {
    "text": "I can change the value, which\nseems like a harmless thing to do, but actually is a big\nproblem because, for example,",
    "start": "3701380",
    "end": "3709640"
  },
  {
    "text": "if I make an array\nof a three piece,",
    "start": "3709640",
    "end": "3715809"
  },
  {
    "text": "and then I say p dot y equals\n8, and I look at that array, it has to change\nthe y component, OK?",
    "start": "3715810",
    "end": "3723650"
  },
  {
    "text": "So if I have a p,\nor in general, if I have a p that's\nlooking at that object,",
    "start": "3723650",
    "end": "3731540"
  },
  {
    "text": "if this is an object\nyou can mutate, it means that if I have\nanother element, a q,",
    "start": "3731540",
    "end": "3737842"
  },
  {
    "text": "it's also pointing\nthe same object. And I say p, p dot\nx equals 4, then",
    "start": "3737842",
    "end": "3744280"
  },
  {
    "text": "q dot x had better also\nbefore at that point.",
    "start": "3744280",
    "end": "3749330"
  },
  {
    "text": "So to have mutable semantics, to\nhave the semantics of something you can change, and\nother references",
    "start": "3749330",
    "end": "3755580"
  },
  {
    "text": "can see that change, that\nmeans that this object has to be stored in memory\non the heap as a pointer to two objects so that\nyou have other pointer",
    "start": "3755580",
    "end": "3762110"
  },
  {
    "text": "to the same object,\nand I mutate it, and the other references see it. It can't just be stuck in\na register or something",
    "start": "3762110",
    "end": "3768040"
  },
  {
    "text": "like that. It has to be something that\nother references can see. So this is bad.",
    "start": "3768040",
    "end": "3773710"
  },
  {
    "text": "So if I have, so I\ncan call 0.1 dot aa calls the constructor\nelement-wise.",
    "start": "3773710",
    "end": "3779849"
  },
  {
    "text": "A is this array of 10\nto the 7 random numbers. I was benchmarking them before. That was taking 10\nmilliseconds, OK?",
    "start": "3779850",
    "end": "3786309"
  },
  {
    "text": "And I can sum it. I can call the built-in\nsome function on this.",
    "start": "3786310",
    "end": "3791915"
  },
  {
    "text": "I can even call my\nsum function on this because it supports\na 0 function. And so it supports a plus. So here, I have an array.",
    "start": "3791915",
    "end": "3798230"
  },
  {
    "text": "If i just go back up, I\nhave an array here of 10 to the 7 values of type 0.1.",
    "start": "3798230",
    "end": "3805330"
  },
  {
    "text": "So the type of 0.1 is\nattached to the array. ",
    "start": "3805330",
    "end": "3811500"
  },
  {
    "text": "So the array and memory,\nso I have an array of 0.1,",
    "start": "3811500",
    "end": "3818030"
  },
  {
    "text": "the one here means it's\na one-dimensional array. There's also 2D,\n3D, and so forth. That looks like a 0.1 value,\na 0.1 value, a 0.1 value.",
    "start": "3818030",
    "end": "3825940"
  },
  {
    "text": " But each one of those now-- sorry-- has to be a\npointer to an x and a y,",
    "start": "3825940",
    "end": "3835510"
  },
  {
    "text": "which themselves are\npointers to boxes. All right, so summing is\ngoing to be really slow",
    "start": "3835510",
    "end": "3840641"
  },
  {
    "text": "because there's a lot\nof pointer chasing. It has to run time, check\nwhat's the type of x, what's the type of y.",
    "start": "3840642",
    "end": "3846220"
  },
  {
    "text": "And, in fact, it was. It took instead of\n10 milliseconds, it took 500 or 600 milliseconds.",
    "start": "3846220",
    "end": "3854470"
  },
  {
    "text": "So to do better, we\nneed to do two things. So, first of all,\nx and y, we have",
    "start": "3854470",
    "end": "3861849"
  },
  {
    "text": "to be able to see what\ntype they are, OK? It can't be just any\narbitrary old thing",
    "start": "3861850",
    "end": "3867140"
  },
  {
    "text": "that has to be a\npointer to a box, OK? And the point object\nhas to be mutable.",
    "start": "3867140",
    "end": "3872210"
  },
  {
    "text": "It has to be something where\nif I have p equals something, q equals something, I\ncan't change p and expect q",
    "start": "3872210",
    "end": "3879870"
  },
  {
    "text": "to see it. Otherwise, if it's\nmutable, those semantics",
    "start": "3879870",
    "end": "3887030"
  },
  {
    "text": "have to be implemented as some\npointer to an object someplace. Then you're dead. So I can just say struct.",
    "start": "3887030",
    "end": "3893920"
  },
  {
    "text": "So struct now is not mutable. It doesn't have the\nmutable keyword. And I can give the\narguments types.",
    "start": "3893920",
    "end": "3899488"
  },
  {
    "text": "I can say they're both flow 64. And x and y are\nboth the same type. They're both 64.",
    "start": "3899488",
    "end": "3905030"
  },
  {
    "text": "But floating point\nnumbers, I'll define plus the same way, 0 the same\nway, and now I can add them",
    "start": "3905030",
    "end": "3911750"
  },
  {
    "text": "and so forth. But now if I make an\narray of these things, and if I say p dot x equals\n6, it will give an error.",
    "start": "3911750",
    "end": "3918463"
  },
  {
    "text": "It says you can't\nactually mutate. Don't even try to mutate\nit because we can't support those semantics on this type.",
    "start": "3918463",
    "end": "3924980"
  },
  {
    "text": "But that means so that\ntype is actually--",
    "start": "3924980",
    "end": "3930840"
  },
  {
    "text": "if you look at look\nat that in memory, what the compiler\nis allowed to do",
    "start": "3930840",
    "end": "3936500"
  },
  {
    "text": "and what it does do for this is\nif you have an array of points",
    "start": "3936500",
    "end": "3942920"
  },
  {
    "text": "0.21, then it looks like just\nthe x value, the y value,",
    "start": "3942920",
    "end": "3952619"
  },
  {
    "text": "The value, the y\nvalue, and so forth. But each of these are\nexactly one 8 byte flow 64.",
    "start": "3952620",
    "end": "3962900"
  },
  {
    "text": "And all the types are\nknown at compile time. And so if I sum them, it should\ntake about 0.20 milliseconds,",
    "start": "3962900",
    "end": "3969580"
  },
  {
    "text": "right? Because summing real\nnumbers was 10 milliseconds. And this is twice as many\nbecause you have to sum",
    "start": "3969580",
    "end": "3974930"
  },
  {
    "text": "the x's, sum the y's. And let's benchmark it. And let's see.",
    "start": "3974930",
    "end": "3982270"
  },
  {
    "text": "Oh, actually, some of the real\nnumbers took 5 milliseconds. So something should\ntake about 10. Let's see if that's still true.",
    "start": "3982270",
    "end": "3988549"
  },
  {
    "text": "Yeah, it took about 10. So actually, the\ncompiler is smart enough. So, first of all, it\nstores this in line",
    "start": "3988550",
    "end": "3995630"
  },
  {
    "text": "as one big block,\nconsecutive block of memory. And then when you sum them,\nremember our sum function.",
    "start": "3995630",
    "end": "4001450"
  },
  {
    "text": "Well, this is the built-in sum. But our sum function will\nwork in the same way.",
    "start": "4001450",
    "end": "4007180"
  },
  {
    "text": "The compiler-- llvm\nwill be smart enough to say, oh, I can load\nthis into a register, load y into a register,\ncall, have a tight loop where",
    "start": "4007180",
    "end": "4015640"
  },
  {
    "text": "I basically call one\ninstruction to sum the x's, one instruction to sum\nthe y's, and then repeat.",
    "start": "4015640",
    "end": "4022668"
  },
  {
    "text": "And so it's about as\ngood as you could get. But you paid a big price. We've lost all\ngenerality, right?",
    "start": "4022668",
    "end": "4030400"
  },
  {
    "text": "These can only be two 64-bit\nfloating point numbers. I can't have two\nsingle-precision numbers or--",
    "start": "4030400",
    "end": "4037840"
  },
  {
    "text": "this is like a struct\nof two doubles in C.",
    "start": "4037840",
    "end": "4043300"
  },
  {
    "text": "So if I have to do this to\nget performance in Julia, then it would suck. Basically, I'm\nbasically writing C code",
    "start": "4043300",
    "end": "4051369"
  },
  {
    "text": "in a slightly\nhigher level syntax. I'm losing that benefit of\nusing a high level language.",
    "start": "4051370",
    "end": "4056830"
  },
  {
    "text": "So the way you get around\nthis is you define-- what you want is to define\nsomething like this 0.2 type.",
    "start": "4056830",
    "end": "4065448"
  },
  {
    "text": "But you don't want to\ndefine just one type. You want to define a\nwhole family of types. You want to define this for\ntwo float 64s, two float 32s.",
    "start": "4065448",
    "end": "4072470"
  },
  {
    "text": "In fact, you want to define\nan infinite family of types, at two things of any type you\nwant as long as they're two",
    "start": "4072470",
    "end": "4077726"
  },
  {
    "text": "real numbers, two real types. And so the way you do that in\nJulia is a parametrized type.",
    "start": "4077726",
    "end": "4084040"
  },
  {
    "text": "This is called\nparametric polymorphism. It's similar to what you\nsee in C++ templates.",
    "start": "4084040",
    "end": "4090160"
  },
  {
    "text": "So now I have a struct. It's not mutable-- Point3. But the curly braces t.",
    "start": "4090160",
    "end": "4096439"
  },
  {
    "text": "It says it's\nparametrized by type t. So x and y-- I've restricted\nit slightly here. I've said x and y had\nto be the same type.",
    "start": "4096439",
    "end": "4102850"
  },
  {
    "text": "I didn't have to do\nthat, but I could have had two parameters,\none for the type of x, one to the type of y.",
    "start": "4102850",
    "end": "4108558"
  },
  {
    "text": "But most the time you'd be\ndoing something like this, you'd want them both\nto be the same type. But they could be both\n64s, both float 32s,",
    "start": "4108558",
    "end": "4116049"
  },
  {
    "text": "both integers, whatever. So t is any type that less than\ncolon means is a subtype of.",
    "start": "4116050",
    "end": "4123020"
  },
  {
    "text": "So t is any subtype of real. It could be float 64. It could be int 64.",
    "start": "4123020",
    "end": "4128470"
  },
  {
    "text": "It could be int 8. It could be big float. It could be a user defined type. It doesn't care. So this is really not--",
    "start": "4128470",
    "end": "4134460"
  },
  {
    "text": "it's a Point3 here. It is a whole hierarchy. So I'm not defining one type.",
    "start": "4134460",
    "end": "4141630"
  },
  {
    "text": "I'm defining a\nwhole set of types. So Point3 is a set of types.",
    "start": "4141630",
    "end": "4147859"
  },
  {
    "text": "There's a point Point3 int 64.",
    "start": "4147859",
    "end": "4153409"
  },
  {
    "text": "There is a Point3 float\n32, a float 64 and so on.",
    "start": "4153410",
    "end": "4164589"
  },
  {
    "text": "Infinitely, many types,\nas many as you want, and basically, it'll create\nmore types on the fly",
    "start": "4164590",
    "end": "4170630"
  },
  {
    "text": "just by instantiating. So, for example, otherwise\nit looks the same. The plus function is\nbasically the same.",
    "start": "4170630",
    "end": "4176880"
  },
  {
    "text": "I add the x components,\nthe y components. The 0 function is the same.",
    "start": "4176880",
    "end": "4182770"
  },
  {
    "text": "Except now I make sure there's\nzeros of type t, whatever that type is. And now if I say\nPoint34, now I'm",
    "start": "4182770",
    "end": "4191349"
  },
  {
    "text": "instantiating a particular\ninstance of this. And now that particular\ninstance of Point3 we'll have--",
    "start": "4191350",
    "end": "4197298"
  },
  {
    "text": "this is an abstract type. We'll have one of\nthese concrete types. And the concrete type\nit has in this case is a Point3 of two int 64s,\ntwo 64-bit integers, OK?",
    "start": "4197298",
    "end": "4208180"
  },
  {
    "text": "And I can add them.  And actually, adding mixed\ntypes will already work",
    "start": "4208180",
    "end": "4214989"
  },
  {
    "text": "because the plus, the\naddition function here,",
    "start": "4214990",
    "end": "4222030"
  },
  {
    "text": "it works for any 2.3s. I didn't say there had to\nPoint3s of the same type.",
    "start": "4222030",
    "end": "4227912"
  },
  {
    "text": "Any two of these, they don't\nhave to be two of these. They could be one of\nthese and one of these. And then it determines\nthe type of the result",
    "start": "4227912",
    "end": "4234390"
  },
  {
    "text": "by the type of the [INAUDIBLE]\nit does type inference. So if you have a point\nPoint3 of two int 64s",
    "start": "4234390",
    "end": "4240900"
  },
  {
    "text": "and Point3 of two float 32s, it\nsays, oh, p dot x is an int 64. Q dot x is a full 64.",
    "start": "4240900",
    "end": "4248970"
  },
  {
    "text": "Oh, which plus\nfunction do I call? There is a plus function\nfrom that mixing. And it promotes the\nresult of flow 64.",
    "start": "4248970",
    "end": "4254870"
  },
  {
    "text": "So that means that\nthat sum is flow 64. The other sum is flow 64. Oh, then I'm creating\na Point3 of flow 64s.",
    "start": "4254870",
    "end": "4262020"
  },
  {
    "text": "So this kind of mixed promotion\nis done automatically. You can actually define your\nown promotion rules in Julia",
    "start": "4262020",
    "end": "4268230"
  },
  {
    "text": "as well. And I can make an array. ",
    "start": "4268230",
    "end": "4275429"
  },
  {
    "text": "And so now if I have an\narray of Point3 float 64,",
    "start": "4275430",
    "end": "4285980"
  },
  {
    "text": "so this type is attached\nto the whole array. And this is not an\narbitrary Point3.",
    "start": "4285980",
    "end": "4292810"
  },
  {
    "text": "It's a Point3 of two float 64s. So it gets stored again as just\n10 to the 7 elements of xy,",
    "start": "4292810",
    "end": "4300079"
  },
  {
    "text": "xy where each one\nis 8 bytes 8 byes, 8 bytes, one after the other. The compiler knows\nall the types.",
    "start": "4300080",
    "end": "4305219"
  },
  {
    "text": "And when you submit, it knows\neverything at compile time. And it will sum to these things.",
    "start": "4305220",
    "end": "4311329"
  },
  {
    "text": "But I loaded this\ninto a register, load this into a register called\none instruction-- add them.",
    "start": "4311330",
    "end": "4316660"
  },
  {
    "text": "And so the sum function\nshould be fast. So we can call the\nbuilt-in sum function. We can call our\nown sum function.",
    "start": "4316660",
    "end": "4322583"
  },
  {
    "text": "Our own some function,\nI didn't put SIMD here, so it's going to\nbe twice as slow. But Yeah.",
    "start": "4322583",
    "end": "4328190"
  },
  {
    "text": "Yeah? AUDIENCE: Will this\nwork with SIMD? STEVEN JOHNSON: Yeah.",
    "start": "4328190",
    "end": "4333240"
  },
  {
    "text": "Yeah. In fact, if you look, the\nbuilt-in sum function, the built-in sum function\nis implemented in Julia. It just hasn't [INAUDIBLE]\nSIMD on the sum.",
    "start": "4333240",
    "end": "4340440"
  },
  {
    "text": "So yeah. llvm is smart enough that if you\ngive it a struct of two values",
    "start": "4340440",
    "end": "4345710"
  },
  {
    "text": "and load them-- and if you tell it that\nyou're adding these two values to these two values these\ntwo values to these two values,",
    "start": "4345710",
    "end": "4351690"
  },
  {
    "text": "it will actually use SIMD\ninstructions, I think. Oh, maybe not.",
    "start": "4351690",
    "end": "4356710"
  },
  {
    "text": "No, wait. Did my sum use SIMD? I'm confused. I thought it did. AUDIENCE: [INAUDIBLE]\nremoved it.",
    "start": "4356710",
    "end": "4361950"
  },
  {
    "text": "STEVEN JOHNSON: I\nthought I removed it. Yeah, so maybe it's not\nsmart enough to use SIMD. ",
    "start": "4361950",
    "end": "4368210"
  },
  {
    "text": "I've seen in some cases where\nit's smart enough to use-- huh, yeah. OK, so they're the same speed.",
    "start": "4368210",
    "end": "4374800"
  },
  {
    "text": "OK, no. I take it back. So maybe llvm is not\nsmart enough in this case to use SIMD automatically.",
    "start": "4374800",
    "end": "4381280"
  },
  {
    "text": "We could try putting the\nSIMD annotation there and try it again. But I thought it\nwas, but maybe not.",
    "start": "4381280",
    "end": "4389120"
  },
  {
    "text": "Let's see. Let's put SIMD. So redefine that.",
    "start": "4389120",
    "end": "4394909"
  },
  {
    "text": "And then just rerun this. So it'll notice that I've\nchanged the definition.",
    "start": "4394910",
    "end": "4400020"
  },
  {
    "text": "It'll recompile it.  But the B time, since it\ntimes at multiple times,",
    "start": "4400020",
    "end": "4407040"
  },
  {
    "text": "the first time it calls it, it's\nslow because it's compiling it. But it takes the minimum\nover several times.",
    "start": "4407040",
    "end": "4412350"
  },
  {
    "text": "So let's see.",
    "start": "4412350",
    "end": "4418180"
  },
  {
    "start": "4418180",
    "end": "4424680"
  },
  {
    "text": "Yeah, this is the problem\nin general with vectorizing compilers if they're\nnot that smart if you're",
    "start": "4424680",
    "end": "4431550"
  },
  {
    "text": "using anything other than just\nan array of an elementary data type.",
    "start": "4431550",
    "end": "4436600"
  },
  {
    "text": "Yeah, no. It didn't make any difference. So I took it back. So for more complicated\ndata structures,",
    "start": "4436600",
    "end": "4441900"
  },
  {
    "text": "you often have to use\nSIMD structure explicitly. And there is a way\nto do that in Julia. And there is a higher level\nlibrary on top of that.",
    "start": "4441900",
    "end": "4448775"
  },
  {
    "text": "You can basically credit a\ntuple and then add things and it will do\nSIMD acceleration.",
    "start": "4448775",
    "end": "4454710"
  },
  {
    "text": "But yeah. So anyway, so that's\nthe upside here. There's a whole bunch of--",
    "start": "4454710",
    "end": "4459840"
  },
  {
    "text": "like the story of why Julia\ncan be compiled with fast code, it's a combination of\nlots of little things.",
    "start": "4459840",
    "end": "4465210"
  },
  {
    "text": "But there are a few big things. One is that its specialized\nthing is compile times.",
    "start": "4465210",
    "end": "4470937"
  },
  {
    "text": "But, of course, you could\ndo that in any language. So that relies on\ndesigning the language so that you can do type inference.",
    "start": "4470937",
    "end": "4476980"
  },
  {
    "text": "It relies on having these\nkind of parametrized types and giving you a way\nto talk about types",
    "start": "4476980",
    "end": "4483810"
  },
  {
    "text": "and attach types to other types. So the array you notice\nprobably-- let's see--",
    "start": "4483810",
    "end": "4490543"
  },
  {
    "text": "and now that you understand\nwhat these little braces mean, you can see that the\narray is defined in Julia",
    "start": "4490543",
    "end": "4496440"
  },
  {
    "text": "as another parametrized type. It's parametrized by\nthe type of the element and also by the dimensionality.",
    "start": "4496440",
    "end": "4502770"
  },
  {
    "text": "So it uses the same mechanism\nto attach types to an array. And you can have your own--\nthe array type in Julia",
    "start": "4502770",
    "end": "4508600"
  },
  {
    "text": "is implemented mostly in Julia. And there are\nother packages that implement their\nown types of arrays",
    "start": "4508600",
    "end": "4513929"
  },
  {
    "text": "that have the same performance. One of the goals of Julia is to\nbuild in as little as possible",
    "start": "4513930",
    "end": "4519600"
  },
  {
    "text": "so that there's not some\nset of privileged types that the compiler knows\nabout and everything else is",
    "start": "4519600",
    "end": "4525810"
  },
  {
    "text": "second class. It's like user code is just\nas good as the built-in code.",
    "start": "4525810",
    "end": "4532412"
  },
  {
    "text": "And, in fact, the\nbuilt-in code is mostly just implemented in Julia. There's a small core\nthat's implemented in C for bootstrapping, basically.",
    "start": "4532412",
    "end": "4540250"
  },
  {
    "text": "Yeah. So having parametrized types,\nhaving another technicalities,",
    "start": "4540250",
    "end": "4545760"
  },
  {
    "text": "having all concrete\ntypes are final in Julia. ",
    "start": "4545760",
    "end": "4552967"
  },
  {
    "text": "A concrete type is something you\ncan actually store in memory. So Point3864 is something\nyou can actually have, right?",
    "start": "4552967",
    "end": "4559440"
  },
  {
    "text": "An object of two\nintegers is that type. So it is concrete, as\nopposed to this thing. This is an abstract type.",
    "start": "4559440",
    "end": "4565360"
  },
  {
    "text": "You can't actually\nhave one of these. You can only have\none of the instances of the concrete types. So but there are no--",
    "start": "4565360",
    "end": "4570600"
  },
  {
    "text": "this is final. It's not possible to\nhave a subtype of this because if you could,\nthen you'd be dead",
    "start": "4570600",
    "end": "4576600"
  },
  {
    "text": "because this is an\narray of these things. If the compiler has to know it's\nactually these things and not",
    "start": "4576600",
    "end": "4583949"
  },
  {
    "text": "some subtype of this, all right,\nwhereas in other languages, like Python, you can have\nsubtypes of concrete types.",
    "start": "4583950",
    "end": "4591065"
  },
  {
    "text": "And so then even\nif you said this is an array of a\nparticular Python type, it wouldn't really\nknow it's that type,",
    "start": "4591065",
    "end": "4596990"
  },
  {
    "text": "or it might be some\nsubtype of that. That's one of the\nreasons why you can't implement NumPy in Python.",
    "start": "4596990",
    "end": "4602680"
  },
  {
    "text": "This is-- there's no way\nto say this is really that type and nothing else\nin the language level.",
    "start": "4602680",
    "end": "4609020"
  },
  {
    "text": "Yeah? AUDIENCE: Will this\ncompilation in Julia work? STEVEN JOHNSON: Oh, yeah. So and it's calling llvm.",
    "start": "4609020",
    "end": "4614840"
  },
  {
    "text": "So basically, the\nstage is you call-- so there's a few passes.",
    "start": "4614840",
    "end": "4621130"
  },
  {
    "text": "OK, so and one of\nthe fun things is you can actually\ninspect all the passes",
    "start": "4621130",
    "end": "4629250"
  },
  {
    "text": "and almost intercept\nall of them practically. So, of course, typing\ncode like this, first, it gets parsed, OK?",
    "start": "4629250",
    "end": "4636810"
  },
  {
    "text": "And you can macro those\nthings [INAUDIBLE] actually are functions that\nare called right after parsing.",
    "start": "4636810",
    "end": "4643290"
  },
  {
    "text": "They can just take\nthe parse code and rewrite it arbitrarily. So they can extend\nthe language that way.",
    "start": "4643290",
    "end": "4648910"
  },
  {
    "text": "But then it parsed, maybe\nrewritten by a macro. And then you get an\nabstract syntax tree.",
    "start": "4648910",
    "end": "4654699"
  },
  {
    "text": "And then when you call it,\nlet's say f of 3, then says, oh, x is an integer.",
    "start": "4654700",
    "end": "4659860"
  },
  {
    "text": "Int 64, it runs a\ntype inference pass. It tries to figure out what's\nthe type of everything,",
    "start": "4659860",
    "end": "4667170"
  },
  {
    "text": "which version of plus\nto call and so forth. Then it decides whether\nto inline some things.",
    "start": "4667170",
    "end": "4673050"
  },
  {
    "text": "And then once it's\ndone all that, it spits out llvm byte\ncode, then calls llvm,",
    "start": "4673050",
    "end": "4679470"
  },
  {
    "text": "and compiles it to machine code. And then it caches that some\nplace for the next time you call, you call f of 4,\nf with another integer.",
    "start": "4679470",
    "end": "4688390"
  },
  {
    "text": "It doesn't repeat\nthe same processes. Notice it's cached. So that's-- so yeah.",
    "start": "4688390",
    "end": "4694603"
  },
  {
    "text": "At the lowest level,\nit's just the llvm. ",
    "start": "4694603",
    "end": "4700960"
  },
  {
    "text": "So then there's tons of\nthings I haven't showed you. So I haven't showed you-- I mentioned metaprogramming. So it has this macro facility.",
    "start": "4700960",
    "end": "4708010"
  },
  {
    "text": "So you can basically\nwrite syntax that rewrites other\nsyntax, which is really cool for code generation.",
    "start": "4708010",
    "end": "4713770"
  },
  {
    "text": "You can also intercept it\nafter the type inference phase. You can write something called\nthe generated function that",
    "start": "4713770",
    "end": "4719890"
  },
  {
    "text": "basically takes--\nbecause at parse time, it knows how things are spelled. And you can rewrite\nhow they're spelled.",
    "start": "4719890",
    "end": "4725667"
  },
  {
    "text": "But it doesn't know what\nanything actually means. It does knows x is a symbol. It doesn't know x as\nan integer-- whatever.",
    "start": "4725667",
    "end": "4730672"
  },
  {
    "text": "It just knows the spelling. So when you actually compile\nf of x, at that point, it knows x is an integer.",
    "start": "4730672",
    "end": "4736530"
  },
  {
    "text": "And so you can write something\ncalled a generator or a stage function that basically\nruns at that time and says,",
    "start": "4736530",
    "end": "4743469"
  },
  {
    "text": "oh, you told me x is an integer. Now I'll rewrite the\ncode based on that. And so this is\nreally useful for--",
    "start": "4743470",
    "end": "4749760"
  },
  {
    "text": "there's some cool facilities\nfor multidimensional arrays. Because the dimensionality\nof the array",
    "start": "4749760",
    "end": "4755139"
  },
  {
    "text": "is actually part of the type. So you can say, oh, this is\na three-dimensional array.",
    "start": "4755140",
    "end": "4760360"
  },
  {
    "text": "I'll write three loops. Oh, you have a\nfour-dimensional array. I'll write four loops. And it can rewrite the code\ndepending on the dimensionality",
    "start": "4760360",
    "end": "4769050"
  },
  {
    "text": "with code generation. So you can have code\nthat basically generates any number of nested\nloops depending",
    "start": "4769050",
    "end": "4775550"
  },
  {
    "text": "on the types of the arguments. And all the generation\nis done in compiled time after type inference. So it knows the\ndimensionality of the array.",
    "start": "4775550",
    "end": "4783670"
  },
  {
    "text": "And yeah, so there's lots\nof fun things like that.",
    "start": "4783670",
    "end": "4790150"
  },
  {
    "text": "Of course, it has\nparallel facilities. They're not quite as advanced\nas Cilk at this point,",
    "start": "4790150",
    "end": "4795530"
  },
  {
    "text": "but that's the direction\nthere they're heading. There's no global interpreter\nlock like in Python.",
    "start": "4795530",
    "end": "4802389"
  },
  {
    "text": "There's no interpreter. So there's a threading facility.",
    "start": "4802390",
    "end": "4807810"
  },
  {
    "text": "And there's a pool of workers. And you can thread a loop. And the garbage collection\nis threading aware.",
    "start": "4807810",
    "end": "4817270"
  },
  {
    "text": "So that's safe. And they're gradually having\nmore and more powerful run times, hopefully,\neventually hooking",
    "start": "4817270",
    "end": "4823930"
  },
  {
    "text": "into some of Professor\nLeiserson's advanced threading compiler, taper compiler,\nor whatever it is.",
    "start": "4823930",
    "end": "4831180"
  },
  {
    "text": "And there's also--\nmost of what I do in my research is more coarse\ngrained distributed memory",
    "start": "4831180",
    "end": "4837190"
  },
  {
    "text": "parallelism, so running on\nsupercomputers and stuff like that. And there's MPI.",
    "start": "4837190",
    "end": "4843730"
  },
  {
    "text": "There is a remote\nprocedure call library. There's different\nflavors of that.",
    "start": "4843730",
    "end": "4850010"
  },
  {
    "text": "But yeah. So any other questions?",
    "start": "4850010",
    "end": "4855739"
  },
  {
    "text": "Yeah? AUDIENCE: How do you\nimplement the big number type? STEVEN JOHNSON: The\nbig num type in Julia",
    "start": "4855740",
    "end": "4861630"
  },
  {
    "text": "is actually calling GIMP. ",
    "start": "4861630",
    "end": "4870850"
  },
  {
    "text": "So that's one of those things. Let me just-- let me\nmake a new notebook.",
    "start": "4870850",
    "end": "4878599"
  },
  {
    "text": "So if I say I know\nbig int 3, 3,000,",
    "start": "4878600",
    "end": "4886670"
  },
  {
    "text": "and then I'd say that\nto the, say, factorial. I think there's a built-in\nfactorial of that.",
    "start": "4886670",
    "end": "4893944"
  },
  {
    "text": "All right, so this is called\nthe big num type, right?",
    "start": "4893944",
    "end": "4900590"
  },
  {
    "text": "It's something where the number\nof digits changes at run time. So, of course, these\nare orders of magnitude slower than hardware things.",
    "start": "4900590",
    "end": "4907165"
  },
  {
    "text": "Basically, it has\nto implement it as a loop of digits\nin some base. And when you add\nor multiply, you",
    "start": "4907165",
    "end": "4912770"
  },
  {
    "text": "have to loop over\nthose at runtime. ",
    "start": "4912770",
    "end": "4918881"
  },
  {
    "text": "These big num libraries,\nthey are quite large and heavily optimized. And so nobody has\nreimplemented one in Julia.",
    "start": "4918881",
    "end": "4926000"
  },
  {
    "text": "They're just calling out to\na C library called the GNU multi-precision library. And for floating\npoint values, there",
    "start": "4926000",
    "end": "4934030"
  },
  {
    "text": "is something called big float. So big float of pi is\nthat I can actually--",
    "start": "4934030",
    "end": "4941295"
  },
  {
    "text": "let's set precision. ",
    "start": "4941295",
    "end": "4949820"
  },
  {
    "text": "Big float to 1000.",
    "start": "4949820",
    "end": "4955310"
  },
  {
    "text": "That's 1,000 binary digits. And then say big float of pi.",
    "start": "4955310",
    "end": "4962450"
  },
  {
    "text": "And [INAUDIBLE] more. By the way, you might have-- so\nI can have a variable alpha--",
    "start": "4962450",
    "end": "4968070"
  },
  {
    "text": "oops-- alpha hat\nsub 2 equals 17.",
    "start": "4968070",
    "end": "4973130"
  },
  {
    "text": "That's allowed.  All that's happening\nhere is that Julia",
    "start": "4973130",
    "end": "4981570"
  },
  {
    "text": "allows almost arbitrary\nunicode things for identifiers. So I can have--",
    "start": "4981570",
    "end": "4986860"
  },
  {
    "text": "make it bigger so we can have\nan identifier Koala, right?",
    "start": "4986860",
    "end": "4999090"
  },
  {
    "text": " So there's two issues here. So one is just you have\na language that allows",
    "start": "4999090",
    "end": "5005219"
  },
  {
    "text": "those things as identifiers. So Python 3 also allows\nUnicode identifiers, although I think Julia\nout of all the existing--",
    "start": "5005220",
    "end": "5012280"
  },
  {
    "text": "the common languages--\nit's probably the widest unicode support. Most languages only\nallow a very narrow range",
    "start": "5012280",
    "end": "5020760"
  },
  {
    "text": "of unicode characters\nfor identifiers. So Python would allow\nthe koala, but Python 3",
    "start": "5020760",
    "end": "5026010"
  },
  {
    "text": "would not allow\nwith alpha hat sub 2",
    "start": "5026010",
    "end": "5031260"
  },
  {
    "text": "because the numeric\nsubscript unicode characters it doesn't allow.",
    "start": "5031260",
    "end": "5036300"
  },
  {
    "text": "The other thing is how\ndo you type these things. And that's more of\nan editor thing. And so in Julia, we implemented\ninitially in the repl",
    "start": "5036300",
    "end": "5045520"
  },
  {
    "text": "and in Jupiter. And now all the\neditors support, you can just to tab\ncompletion of latex. So I can type in\ngamma, tab, and the tab",
    "start": "5045520",
    "end": "5055500"
  },
  {
    "text": "completes to the\nunicode character. I can say dot. And it puts a dot over it\nand backslash superscript 4.",
    "start": "5055500",
    "end": "5065099"
  },
  {
    "text": "And it puts a 4. And that's allowed.",
    "start": "5065100",
    "end": "5070300"
  },
  {
    "text": "So it's quite nice. So when I'm typing emails,\nand I put equations in emails, I go to the Julia rappel and\ntab complete all my LaTeX",
    "start": "5070300",
    "end": "5077677"
  },
  {
    "text": "characters so that\nI can put equations in emails because It's\nthe easiest way to type these Unicode math characters.",
    "start": "5077677",
    "end": "5084070"
  },
  {
    "text": "But yeah. So IPython borrowed this. So now do the same thing in\nthe IPython notebooks as well.",
    "start": "5084070",
    "end": "5093800"
  },
  {
    "text": "So it's really fun. Because if you read old math\ncodes, especially old Fortran",
    "start": "5093800",
    "end": "5100290"
  },
  {
    "text": "codes or things, you\nsee lots of variables that are named alpha hat\nor something like that,",
    "start": "5100290",
    "end": "5105330"
  },
  {
    "text": "alpha hat underscore 3. It's so much nicer to\nhave a variable that's actually the alpha hat sub 3.",
    "start": "5105330",
    "end": "5110760"
  },
  {
    "text": "So that's cute. CHARLES E. LEISERSON:\nSteve, thanks very much. Thanks. This was great. [APPLAUSE]",
    "start": "5110760",
    "end": "5116880"
  },
  {
    "text": "We are, as Steve\nmentioned, looking actually at a project to merge the\nJulia technology with the Cilk",
    "start": "5116880",
    "end": "5122670"
  },
  {
    "text": "technology. And so we're right now in the\nprocess of putting together",
    "start": "5122670",
    "end": "5128600"
  },
  {
    "text": "the grant proposal. And if that gets funded,\nthere may be some UROPS.",
    "start": "5128600",
    "end": "5134360"
  },
  {
    "start": "5134360",
    "end": "5143868"
  }
]