[
  {
    "text": "um what is discrimination or what are what are discriminators um the idea here",
    "start": "3120",
    "end": "9840"
  },
  {
    "text": "is that it is actually possible to do a lot of things in linear time that you have sort of brainwashed yourself into",
    "start": "9840",
    "end": "16000"
  },
  {
    "text": "accepting Take N log n or n squar time okay and what I want to do is",
    "start": "16000",
    "end": "24560"
  },
  {
    "text": "Showcase how we can package that up how we can turn it into a library how we can make it accessible so that people can use it um this is a bit of a case study",
    "start": "24560",
    "end": "32160"
  },
  {
    "text": "in sort of Library design in hasell at least the way I approach it um sort of going out into category Theory and",
    "start": "32160",
    "end": "38600"
  },
  {
    "text": "trying to grab little bits and pieces and drag them back and kicking and screaming and make them work um while not being afraid of going",
    "start": "38600",
    "end": "47000"
  },
  {
    "text": "down and building a custom foreign Prim to do whatever the heck it is that I need to make fast um so we'll be kind of",
    "start": "47000",
    "end": "54600"
  },
  {
    "text": "flitting around at different levels of abstraction in the higho ecosystem um",
    "start": "54600",
    "end": "60120"
  },
  {
    "text": "how many people here don't know hasell okay I I",
    "start": "60120",
    "end": "65960"
  },
  {
    "text": "apologize um uh how many people here don't know what a radic sort is let's start there okay so um the idea of radic",
    "start": "66000",
    "end": "75000"
  },
  {
    "text": "sorting is that uh there's a really fast linear time sorting algorithm for integers what you do is you could or you",
    "start": "75000",
    "end": "82159"
  },
  {
    "text": "could start by just making a um one bucket per integer and then when you go to uh take",
    "start": "82159",
    "end": "89920"
  },
  {
    "text": "take the next element out of your list you put it in the appropriate bucket then you run through all the buckets in order you glue together the answers",
    "start": "89920",
    "end": "95479"
  },
  {
    "text": "right this would be a really naive version of a radic sort because it's using way too many buckets but if you had something like 32",
    "start": "95479",
    "end": "101960"
  },
  {
    "text": "bits worth of integer that would be an awful lot of buckets you probably don't want to go there um so it turns out what",
    "start": "101960",
    "end": "107520"
  },
  {
    "text": "you could do is you can actually like grab like eight bits you can only have if you only had like 256 buckets you",
    "start": "107520",
    "end": "113439"
  },
  {
    "text": "could put your lists into you could thread by the least significant bit into",
    "start": "113439",
    "end": "118479"
  },
  {
    "text": "there then by the next by the least significant bite there then the next most significant bite then the next most",
    "start": "118479",
    "end": "125200"
  },
  {
    "text": "significant bite then the next most significant bite by the time you were done you would have sorted your list and it would only have taken you four steps",
    "start": "125200",
    "end": "133080"
  },
  {
    "text": "and constant time or sorry U not constant uh linear time okay um in",
    "start": "133080",
    "end": "141000"
  },
  {
    "text": "around 1990 um mckelroy Burke and mckelroy was it I",
    "start": "141000",
    "end": "146560"
  },
  {
    "text": "think did a um a paper on how to make um radic fast because radic sort was a nice",
    "start": "146560",
    "end": "151959"
  },
  {
    "text": "historical curiosity at the time but quick sort was kicking its butt even despite the fact that it was linear the",
    "start": "151959",
    "end": "158280"
  },
  {
    "text": "constants were just too bad and so they came up with this technique uh that has sort of retroactively been called the",
    "start": "158280",
    "end": "164120"
  },
  {
    "text": "American flag sort um which was an unstable radic sort",
    "start": "164120",
    "end": "169159"
  },
  {
    "text": "that could extend it to support some other cases and um the the key observation",
    "start": "169159",
    "end": "176159"
  },
  {
    "text": "here is that we're able to break the sort of expected you know Theta n log n bound on sorting you know you you've",
    "start": "176159",
    "end": "181519"
  },
  {
    "text": "you've had it drilled into your head that sorting takes n log n no matter what you do um and we're able to break",
    "start": "181519",
    "end": "188640"
  },
  {
    "text": "that bound because we're not working pairwise we're not comparing two elements are you less than this and then",
    "start": "188640",
    "end": "193920"
  },
  {
    "text": "going from there which provably requires n log and comparisons",
    "start": "193920",
    "end": "199280"
  },
  {
    "text": "um but instead we're able to abuse the fact that we have a whole array full of",
    "start": "199280",
    "end": "204519"
  },
  {
    "text": "buckets and we can just Shuffle things into the right buckets and so we can work kind of wholesale through our data structure",
    "start": "204519",
    "end": "211000"
  },
  {
    "text": "so that's the idea of a basic radic sort um Now radic sort worked bottom up from",
    "start": "211000",
    "end": "218280"
  },
  {
    "text": "the from the the least significant bits up and American flag is a as a slight tweak on that to work top",
    "start": "218280",
    "end": "225680"
  },
  {
    "text": "down um so again the key here is that what I want to show is that we can do almost everything we want to do in",
    "start": "226040",
    "end": "231480"
  },
  {
    "text": "linear time um and that includes sorting partitioning our data into equivalence",
    "start": "231480",
    "end": "236840"
  },
  {
    "text": "classes uh joining tables so we can actually stream we can not stream yet",
    "start": "236840",
    "end": "242159"
  },
  {
    "text": "but we can take a whole data set in for two sides of a join that we want to be able to compute um break them up to",
    "start": "242159",
    "end": "249000"
  },
  {
    "text": "where the two things agree on the key or whatever the column is that you're joining on and spit out the result and",
    "start": "249000",
    "end": "254879"
  },
  {
    "text": "it's linear in the total amount of input and the total amount of output um we can also construct data.map",
    "start": "254879",
    "end": "260959"
  },
  {
    "text": "and data. set in linear time using this technique as well and so I'll get to all of those individual pieces I just trying",
    "start": "260959",
    "end": "266960"
  },
  {
    "text": "to motivate why we care right so who what why when where so why is that we",
    "start": "266960",
    "end": "272360"
  },
  {
    "text": "want to be able to do almost everything in linear time who is this Dapper fellow",
    "start": "272360",
    "end": "277479"
  },
  {
    "text": "here for Tang line he runs the the hyperfit research center at a university of Copenhagen um he came up with this idea",
    "start": "277479",
    "end": "284680"
  },
  {
    "text": "he wrote a a bunch of papers between about 2007 and 2011 it's pretty much",
    "start": "284680",
    "end": "289960"
  },
  {
    "text": "entirely his baby um and he's got some wonderful papers on",
    "start": "289960",
    "end": "296120"
  },
  {
    "text": "the topic and they're very accessible",
    "start": "296120",
    "end": "301199"
  },
  {
    "text": "uh probably far more so than this talk uh um however in some ways they're not",
    "start": "301199",
    "end": "307800"
  },
  {
    "text": "very has um like he builds up data types directly for working with all the things",
    "start": "307800",
    "end": "313039"
  },
  {
    "text": "that he wants but then he doesn't get to use any of the classes that we know in love to work with them and so a lot of",
    "start": "313039",
    "end": "319039"
  },
  {
    "text": "what I wanted to explore today is how to build a nice API that feels good to a Haso programmer to",
    "start": "319039",
    "end": "324720"
  },
  {
    "text": "use um and so I'm going to take his encoding and turn the whole thing around",
    "start": "324720",
    "end": "329880"
  },
  {
    "text": "and see if we can get to something nice and so again I'm out to build a",
    "start": "329880",
    "end": "335400"
  },
  {
    "text": "nice API um and to get there I'm going to start with the notion that monads are",
    "start": "335400",
    "end": "342759"
  },
  {
    "text": "monoids in the category of endof funter what's the problem I probably should have talked to you about doing this on the second day after Ken had had a",
    "start": "342759",
    "end": "349160"
  },
  {
    "text": "chance to give his intro to category Theory talk sorry um so maybe this will",
    "start": "349160",
    "end": "355840"
  },
  {
    "text": "motivate some people to attend your session maybe it'll send them screaming I'm sorry sorry um so in hll we have a monoid as a",
    "start": "355840",
    "end": "364919"
  },
  {
    "text": "very you know basic class you have a a binary operation and a unit for it um the binary operation is",
    "start": "364919",
    "end": "372120"
  },
  {
    "text": "associative um we all know that but how does that fit into the monads OR monoids",
    "start": "372120",
    "end": "377720"
  },
  {
    "text": "notion right U and for that we need a better notion of a monoid than this simple little",
    "start": "377720",
    "end": "384280"
  },
  {
    "text": "piece and so as all things categorical do um in order to get to just a little",
    "start": "384280",
    "end": "390120"
  },
  {
    "text": "bit more complicated we have to go way more complicated we build up the notion of a",
    "start": "390120",
    "end": "396039"
  },
  {
    "text": "monoidal category so how many people here know what a category is how many",
    "start": "396039",
    "end": "401120"
  },
  {
    "text": "people don't all right sorry a category",
    "start": "401120",
    "end": "406599"
  },
  {
    "text": "um in very broad Strokes is a um you have a a set of",
    "start": "406599",
    "end": "414280"
  },
  {
    "text": "objects and a set of arrows between objects so you have arrows that connect from one object to another object and",
    "start": "414280",
    "end": "419960"
  },
  {
    "text": "you have the ability to compose two objects together and it doesn't matter if you compose from here to there and",
    "start": "419960",
    "end": "425120"
  },
  {
    "text": "then to a third thing which order you kind of compose the arrows you get the same Arrow so Arrow composition is",
    "start": "425120",
    "end": "432479"
  },
  {
    "text": "associative okay um it's like a really fancy form of a monoid you have the associativity and you have this extra",
    "start": "432479",
    "end": "438720"
  },
  {
    "text": "thing which is that for every object you have an identity Arrow which acts like the unit that we had for our",
    "start": "438720",
    "end": "444160"
  },
  {
    "text": "monoid now a monoidal category is a category I with some extra",
    "start": "444160",
    "end": "450520"
  },
  {
    "text": "stuff okay so one of the things that we work with a lot when we deal with categories is that we have functors",
    "start": "450520",
    "end": "456879"
  },
  {
    "text": "between two categories a funter is a mapping from one category to another category where if something was connected over here in a nice way it",
    "start": "456879",
    "end": "463879"
  },
  {
    "text": "carries over the shape um so a monoidal category is a",
    "start": "463879",
    "end": "469720"
  },
  {
    "text": "category where we have an extra a bifunctor a tensor something that looks like product um it's also going to look like",
    "start": "469720",
    "end": "476560"
  },
  {
    "text": "co-product in a bit we're going to play with this there's a bunch of things that all fit into this mold and we have some object that acts like an identity for",
    "start": "476560",
    "end": "483120"
  },
  {
    "text": "this bifunctor so that if for any element a every object in the a object in the category um a tensor I is",
    "start": "483120",
    "end": "492280"
  },
  {
    "text": "equivalent is there's an isomorphism between that and a you can go back and forth between this representation and that right so if you think of this as",
    "start": "492280",
    "end": "498360"
  },
  {
    "text": "products in hcll we have the pair of a and the unit is isomorphic to a we have",
    "start": "498360",
    "end": "505960"
  },
  {
    "text": "no extra information in that unit it's there's only one inhabitant of that type so it doesn't really add anything to the",
    "start": "505960",
    "end": "511800"
  },
  {
    "text": "equation um and these are traditionally denoted R and or row and Lambda for",
    "start": "511800",
    "end": "517800"
  },
  {
    "text": "right and left because mathematicians like to screw with people and a for associativity which says that we can",
    "start": "517800",
    "end": "524959"
  },
  {
    "text": "slop um our uh profunctor not our profunctor our bifunctor from one side to the other so we can say a tensor B",
    "start": "524959",
    "end": "532080"
  },
  {
    "text": "tensored with C can be turned into a tensor B tensored uh a tensored with B tensor C and vice versa you can go back",
    "start": "532080",
    "end": "537839"
  },
  {
    "text": "and forth so putting on and taking off the unit doesn't create or destroy any information and you can associate which",
    "start": "537839",
    "end": "544560"
  },
  {
    "text": "doesn't create or destroy any information okay so this is all the things you can do with products without ever potentially forgetting something or",
    "start": "544560",
    "end": "551920"
  },
  {
    "text": "reusing something and then you get these crazy diagrams um and this basically says that",
    "start": "551920",
    "end": "561120"
  },
  {
    "text": "um these don't do anything hanky and no matter how you get from everything being associated all the way to the left to",
    "start": "561120",
    "end": "567640"
  },
  {
    "text": "everything being associated all the way to the right it doesn't change the answer okay so mlan came up with these",
    "start": "567640",
    "end": "573200"
  },
  {
    "text": "things way back in the 50s or the 60s and then uh can and Bendix figured out",
    "start": "573200",
    "end": "579440"
  },
  {
    "text": "how to do a bunch of things like way way later and these actually turned out to be exactly the right conditions under",
    "start": "579440",
    "end": "584519"
  },
  {
    "text": "far more General conditions than mlan could have ever known so um so this is the notion of a",
    "start": "584519",
    "end": "591040"
  },
  {
    "text": "monoidal category which is the beginnings of like where category Theory starts to become interesting",
    "start": "591040",
    "end": "599480"
  },
  {
    "text": "okay so why do I need this thing so the first thing we want to talk about is pro uh like hll itself as a category um we",
    "start": "599480",
    "end": "607959"
  },
  {
    "text": "can say that Hask is a category where our types are objects and functions between those two between those types",
    "start": "607959",
    "end": "614600"
  },
  {
    "text": "are my arrows so I can now compose two functions and get an arrow that goes from The Source object all the way to",
    "start": "614600",
    "end": "621360"
  },
  {
    "text": "the Target skipping the the middle point and then we can say that product",
    "start": "621360",
    "end": "626519"
  },
  {
    "text": "is this notion of a tensor that we're going to use and that the unit object is going to be the unit of our",
    "start": "626519",
    "end": "632440"
  },
  {
    "text": "product and so row could put on or take",
    "start": "632440",
    "end": "637720"
  },
  {
    "text": "off a uh unit or an identity here on the right hand side so it has to be the",
    "start": "637720",
    "end": "645560"
  },
  {
    "text": "first function IT projects out the A and leaves the unit alone and then the inverse version of it is that we just",
    "start": "645560",
    "end": "651560"
  },
  {
    "text": "take whatever a you give me and we shove it in and we create a unit um you can sit down and prove that",
    "start": "651560",
    "end": "659079"
  },
  {
    "text": "those inverses we have Lambda does the same thing I don't think just on the other side I leave",
    "start": "659079",
    "end": "666760"
  },
  {
    "text": "this as an exercise for the reader um we can also do other uh",
    "start": "666760",
    "end": "673639"
  },
  {
    "text": "choices of tensor we're not limited to just doing products and this is where things start to get interesting and",
    "start": "673639",
    "end": "678720"
  },
  {
    "text": "where we can start to see a more General notion of a monoid once we go through just a couple more steps and that is",
    "start": "678720",
    "end": "684240"
  },
  {
    "text": "that um either I'm going to use plus here because notationally it fits on the slide",
    "start": "684240",
    "end": "690480"
  },
  {
    "text": "um void with void being the uninhabited data type also works so we can um we can",
    "start": "690480",
    "end": "697800"
  },
  {
    "text": "go from either a or nothing basically void uh to",
    "start": "697800",
    "end": "703160"
  },
  {
    "text": "a by just projecting at the leftand side because you know the right hand side can't happen it's it's it's void it's",
    "start": "703160",
    "end": "708880"
  },
  {
    "text": "it's nothing in scholar terms um so a or void is just",
    "start": "708880",
    "end": "715279"
  },
  {
    "text": "a and you can go back and forth between those two things and same on the other side and then this is also a fun little",
    "start": "715279",
    "end": "722200"
  },
  {
    "text": "exercise for the reader which is to just associate IRS okay I don't think anything here is",
    "start": "722200",
    "end": "728200"
  },
  {
    "text": "terribly deep aside from the category theoretic non nonsense to motivated at the",
    "start": "728200",
    "end": "733560"
  },
  {
    "text": "start um but then we were saying something about monads are monoids in the category",
    "start": "733560",
    "end": "740399"
  },
  {
    "text": "of endofunctors so we need a category of endofunctors and so what I want to talk about is the category of functors",
    "start": "740399",
    "end": "749880"
  },
  {
    "text": "uh from Hask to it from hascal to itself where so we had a category which was the category of haskal data",
    "start": "749880",
    "end": "756800"
  },
  {
    "text": "types right and where where our types were our objects and our arrows were just functions and here what we want is",
    "start": "756800",
    "end": "764600"
  },
  {
    "text": "the category where our functors from hasle to hasle are our um arrows and our",
    "start": "764600",
    "end": "774839"
  },
  {
    "text": "sorry our functors are our objects and natural Transformations which are basically ways of saying that I don't",
    "start": "774839",
    "end": "781440"
  },
  {
    "text": "care what you have inside of that F like if this was list to maybe or something",
    "start": "781440",
    "end": "786600"
  },
  {
    "text": "like that this would be a function that would take a list of a to maybe a and it it doesn't care what a you have and you can't do any sort of you know is",
    "start": "786600",
    "end": "794440"
  },
  {
    "text": "instance of kind of java ER tricks to to do unnatural things hence it's a natural",
    "start": "794440",
    "end": "802639"
  },
  {
    "text": "transformation um so yes Scala is unnatural um so so we we'll use this kind of",
    "start": "802920",
    "end": "810079"
  },
  {
    "text": "squiggly Arrow which you can't really see as squiggly to uh denote a natural",
    "start": "810079",
    "end": "815519"
  },
  {
    "text": "transformation which is to say that I don't care what type argument you bolt on there and so we need a unit for",
    "start": "815519",
    "end": "823480"
  },
  {
    "text": "composition for funter composition and so you can use the identity functor as the unit for this because compose a",
    "start": "823480",
    "end": "831480"
  },
  {
    "text": "functor with identity is effectively the same as we started with the original funter we just have some new type noise",
    "start": "831480",
    "end": "836600"
  },
  {
    "text": "and hasal floating around to to put on take off and then we can put on and take",
    "start": "836600",
    "end": "842680"
  },
  {
    "text": "it off I didn't bother to write Lambda but that just compose identity a to a and that's even",
    "start": "842680",
    "end": "847920"
  },
  {
    "text": "easier um and then the associativity law is also pretty easy it's just putting on and taking off some new",
    "start": "847920",
    "end": "853240"
  },
  {
    "text": "types okay so now we finally have enough to start talking about a more General",
    "start": "853240",
    "end": "858440"
  },
  {
    "text": "notion of a monoid and get to what it means to say that a monad is a monoid in the category of endofunctors and there",
    "start": "858440",
    "end": "864680"
  },
  {
    "text": "will really be a a direct application of this to uh to Des discrimination",
    "start": "864680",
    "end": "870320"
  },
  {
    "text": "eventually um and so now we can talk in a more general setting about what it",
    "start": "870320",
    "end": "875959"
  },
  {
    "text": "means to be a monoid okay so we normally just write down that definition of monoid and don't",
    "start": "875959",
    "end": "882000"
  },
  {
    "text": "really think too hard about it um but it's it's an instance of a more General",
    "start": "882000",
    "end": "887480"
  },
  {
    "text": "schema so for any monoidal category where we have our category we have this bifunctor which was like product or",
    "start": "887480",
    "end": "893720"
  },
  {
    "text": "composition or or either and whatever its identity was um we can talk about a",
    "start": "893720",
    "end": "900839"
  },
  {
    "text": "a monoid being some object in the category M such that we have associated with it a",
    "start": "900839",
    "end": "909959"
  },
  {
    "text": "um um AA which lets us build uh this is this is mey basically or uh yeah mty um",
    "start": "909959",
    "end": "918600"
  },
  {
    "text": "which will let us take in this case the identity of our um tensor to M so this was like unit",
    "start": "918600",
    "end": "926839"
  },
  {
    "text": "to m in in hascal a function from unit is boring so we just throw away the function from unit part of that and just",
    "start": "926839",
    "end": "932839"
  },
  {
    "text": "call it m and we normally Curry this definition so instead of M comma M goes to M we say",
    "start": "932839",
    "end": "940560"
  },
  {
    "text": "Curry that and you get M goes to M to M and there's all sorts of fun things we",
    "start": "940560",
    "end": "946680"
  },
  {
    "text": "can do with that we're not going to do stuff with that today we're just going to play with this basic definition of am monoid",
    "start": "946680",
    "end": "953160"
  },
  {
    "text": "um and then we work with these definitions and it it gets a little bit awkward compared to what we're used to",
    "start": "953160",
    "end": "959120"
  },
  {
    "text": "because we have to shove these identity elements around but the nice thing is is that",
    "start": "959120",
    "end": "965160"
  },
  {
    "text": "this definition unlike the one that we're used to generalizes so now monads can be thought",
    "start": "965160",
    "end": "971639"
  },
  {
    "text": "of as monoid objects or sorry monoids can be thought of as monoid objects hopefully um otherwise our",
    "start": "971639",
    "end": "977880"
  },
  {
    "text": "generalization wasn't very good um so we start with the category of H data types",
    "start": "977880",
    "end": "983600"
  },
  {
    "text": "with products with unit and we say we'll just use mey and",
    "start": "983600",
    "end": "989560"
  },
  {
    "text": "we'll unur mapen to to get the form that we want to work with t the mide laws that we know exp",
    "start": "989560",
    "end": "997240"
  },
  {
    "text": "that we expect hold I don't think that's terribly surprising and then monads can be",
    "start": "997240",
    "end": "1003839"
  },
  {
    "text": "thought of as monoids in that category of endofunctors up to funter composition so",
    "start": "1003839",
    "end": "1011160"
  },
  {
    "text": "we're using funter composition as our tensor where if you give me a natural transformation from Identity to M which",
    "start": "1011160",
    "end": "1016839"
  },
  {
    "text": "is to say that you could take an identity of a which just be a to an M of a for all a it has to be natural and so",
    "start": "1016839",
    "end": "1024280"
  },
  {
    "text": "you can't do anything hinky with a um that's our ITA and our mu is that says",
    "start": "1024280",
    "end": "1030400"
  },
  {
    "text": "that if you can take the composition of two M's to an M you have managed to join",
    "start": "1030400",
    "end": "1037400"
  },
  {
    "text": "your Monet okay so this really is the same notion of a monoid just under a more general",
    "start": "1037400",
    "end": "1044720"
  },
  {
    "text": "definition okay so monoids are monoids in the category of endofunctors",
    "start": "1044720",
    "end": "1050840"
  },
  {
    "text": "now what are applicatives then",
    "start": "1051120",
    "end": "1057080"
  },
  {
    "text": "um so it turns out we can build another tensor something kind of like",
    "start": "1057080",
    "end": "1064360"
  },
  {
    "text": "composition okay and it goes back to this guy Brian Day who turned around and did this and dayc convolution which is",
    "start": "1064360",
    "end": "1070360"
  },
  {
    "text": "not normally presented this way could be thought of as taking the signature for applicative and smashing in the",
    "start": "1070360",
    "end": "1077840"
  },
  {
    "text": "interesting bits that I want talk about here um which is that I have an f and a",
    "start": "1077840",
    "end": "1085240"
  },
  {
    "text": "diff a potentially different G so I have two different arguments and what I'm looking for is",
    "start": "1085240",
    "end": "1094039"
  },
  {
    "text": "that day of app in the applicative class should take day FF to F it should be a",
    "start": "1094039",
    "end": "1100200"
  },
  {
    "text": "natural transformation from day FF to F right so if we squint and look at",
    "start": "1100200",
    "end": "1106080"
  },
  {
    "text": "that and then we sit down and do all the work to show that there's the associator",
    "start": "1106080",
    "end": "1112320"
  },
  {
    "text": "there's the units um we can actually prove that an applicative is also a monoid in the",
    "start": "1112320",
    "end": "1119640"
  },
  {
    "text": "category of endofunctors just with a different choice of tensor we've chosen a",
    "start": "1119640",
    "end": "1125039"
  },
  {
    "text": "different structure to be monoidal with respect to just how we could choose",
    "start": "1125039",
    "end": "1130080"
  },
  {
    "text": "either or product when we were talking about hascal we could build a monoidal",
    "start": "1130080",
    "end": "1135480"
  },
  {
    "text": "category for hascal out of either one of those choices of tensor here we can build on the category of endofunctors",
    "start": "1135480",
    "end": "1142559"
  },
  {
    "text": "from Hask to Hask we can we can build a completely different",
    "start": "1142559",
    "end": "1150480"
  },
  {
    "text": "tensor um so applicatives are monoid objects and we have our either our mu",
    "start": "1152120",
    "end": "1160159"
  },
  {
    "text": "where we just peel this out and",
    "start": "1160159",
    "end": "1163760"
  },
  {
    "text": "app okay um and we just expect the the applicative laws in there precisely the right laws for day convolution to be uh",
    "start": "1165360",
    "end": "1173320"
  },
  {
    "text": "or for this to be a monoid of day convolution so um applicatives are",
    "start": "1173320",
    "end": "1179280"
  },
  {
    "text": "monoids in the category of end funter what's the problem okay",
    "start": "1179280",
    "end": "1185679"
  },
  {
    "text": "now I want to play with this definition just a little bit and the reason is",
    "start": "1185679",
    "end": "1191280"
  },
  {
    "text": "because nothing here required me to pick product or something like that when I so",
    "start": "1191280",
    "end": "1196720"
  },
  {
    "text": "instead of using um app what I could do is I could take the definition for like lift A2 which would",
    "start": "1196720",
    "end": "1202760"
  },
  {
    "text": "normally be that I have a function from A to B to C and you give me an F of a to an F of B and I'll give you an F of c",
    "start": "1202760",
    "end": "1208400"
  },
  {
    "text": "and I could generalize that this would actually be much closer to what we would traditionally do to build up dayc convolution and in real category",
    "start": "1208400",
    "end": "1215880"
  },
  {
    "text": "Theory um but instead of actually building this as a function from A to B to C what you would normally see is that",
    "start": "1215880",
    "end": "1222440"
  },
  {
    "text": "they'll they'll tensor up these arguments because otherwise you have to require that it's a closed category and",
    "start": "1222440",
    "end": "1227600"
  },
  {
    "text": "it doesn't I have another five incomprehensible slides um and then you could view this as like",
    "start": "1227600",
    "end": "1234880"
  },
  {
    "text": "lift A2 if we uncured it in the argument here right we just",
    "start": "1234880",
    "end": "1240720"
  },
  {
    "text": "Tuple up all the arguments we're going to pack the lift A2 and hand them to you [Music]",
    "start": "1240720",
    "end": "1246159"
  },
  {
    "text": "um now dayc convolution if you actually look in any category Theory textbook",
    "start": "1246159",
    "end": "1251440"
  },
  {
    "text": "will not be presented this way it's going to be presented um either like this or using a much more advanced form",
    "start": "1251440",
    "end": "1257799"
  },
  {
    "text": "which I'm going to completely skip um and this form is a little bit different so what we're doing is we're saying now",
    "start": "1257799",
    "end": "1263000"
  },
  {
    "text": "we're going to look at contravariant functors so how many people here know what a contravariant functor is all",
    "start": "1263000",
    "end": "1269159"
  },
  {
    "text": "right um I should have uh no I don't I have a whole Spiel after that before I",
    "start": "1269159",
    "end": "1275559"
  },
  {
    "text": "get to where what a contrarian fun is great so a contrarian functor is something where you when you f map over",
    "start": "1275559",
    "end": "1281240"
  },
  {
    "text": "it it goes the wrong way um if you map a function from A to B",
    "start": "1281240",
    "end": "1287480"
  },
  {
    "text": "over a predicate or something like that on a value then what you can actually do is you can take a predicate on B's and",
    "start": "1287480",
    "end": "1292679"
  },
  {
    "text": "give you back a predicate on A's it seems total totally counterintuitive but arguments to functions are",
    "start": "1292679",
    "end": "1299320"
  },
  {
    "text": "contravariant um it's the variant stuff that you see in Scala all over the place the minus signs is the contravariant",
    "start": "1299320",
    "end": "1305799"
  },
  {
    "text": "case so if you're familiar with like the minus sign in um in Scala at the type",
    "start": "1305799",
    "end": "1311440"
  },
  {
    "text": "level that's the same thing okay so I'm often asked is there",
    "start": "1311440",
    "end": "1317080"
  },
  {
    "text": "like a contravariant add no U the little twist that you get that",
    "start": "1317080",
    "end": "1322799"
  },
  {
    "text": "turns you from A to B into F of B to F of a just kind of destroys any attempt at that structure I'm also asked if",
    "start": "1322799",
    "end": "1329279"
  },
  {
    "text": "there's a Conant commed well if there wasn't aarian moned there shouldn't be a commed and the answer is still no but",
    "start": "1329279",
    "end": "1334520"
  },
  {
    "text": "the answer is yes that there is a contant form of applicative and as a matter of fact we've got a couple of them we can play with and we get them by",
    "start": "1334520",
    "end": "1340960"
  },
  {
    "text": "looking at day convolution the real day convolution which is normally presented contravariantly and asking what its",
    "start": "1340960",
    "end": "1346279"
  },
  {
    "text": "monoids are",
    "start": "1346279",
    "end": "1349799"
  },
  {
    "text": "so what we can do is this we can say I have a contant functor which I totally did not Define sorry well other than",
    "start": "1351400",
    "end": "1358679"
  },
  {
    "text": "just verbally right now and what I'm going to do is I'm going to add two op I'm going to give you two extra operations we can do with it instead of",
    "start": "1358679",
    "end": "1364000"
  },
  {
    "text": "just being a up map I want to be able to let you do these two things I'm going to call them divide and conquer because I needed names",
    "start": "1364000",
    "end": "1371799"
  },
  {
    "text": "um and um this is if I turn around and I just",
    "start": "1371799",
    "end": "1376960"
  },
  {
    "text": "take divide and basically do the same trick that I did with app to build the signature for day convolution I just",
    "start": "1376960",
    "end": "1382960"
  },
  {
    "text": "read this off here and then needlessly Alpha renamed things on you",
    "start": "1382960",
    "end": "1389360"
  },
  {
    "text": "um and so we have divide and conquer which are going to be our two cases that we're going to have to consider for our",
    "start": "1389360",
    "end": "1395080"
  },
  {
    "text": "class and this will be kind of like having to deal with app and pure or with",
    "start": "1395080",
    "end": "1400960"
  },
  {
    "text": "um join and uh uh and return in a monad or uh mend",
    "start": "1400960",
    "end": "1408600"
  },
  {
    "text": "and mty we're going to find a lot of parallels between these as we",
    "start": "1408600",
    "end": "1414000"
  },
  {
    "text": "go so um given that class that I just kind of",
    "start": "1416760",
    "end": "1422120"
  },
  {
    "text": "sketched out there this is basically saying this these things kind of consume",
    "start": "1422120",
    "end": "1427440"
  },
  {
    "text": "whatever their argument type is right so this is a like an app that can like handle bees so this is saying that if you can",
    "start": "1427440",
    "end": "1434279"
  },
  {
    "text": "split A's into B's and C's or if you can split an a into a b and a c and you can handle a b and you can",
    "start": "1434279",
    "end": "1440440"
  },
  {
    "text": "handle a c then you can handle an A and this is something that says you can always handle every a you just",
    "start": "1440440",
    "end": "1448159"
  },
  {
    "text": "you're going to do it in a way that if you divided and just kind of copied the a to both sides you don't actually change the answer so this is sort of",
    "start": "1448159",
    "end": "1454919"
  },
  {
    "text": "like a unit for divide so if you split this thing you just take a and you just",
    "start": "1454919",
    "end": "1460760"
  },
  {
    "text": "give me two copies of a and you divide using this Delta function and you use some M with conquer",
    "start": "1460760",
    "end": "1467880"
  },
  {
    "text": "as the other side it shouldn't change the answer from whatever the the the the contant functor was going to",
    "start": "1467880",
    "end": "1474600"
  },
  {
    "text": "do and vice versa on the other side and then Delta or divide is",
    "start": "1474600",
    "end": "1481640"
  },
  {
    "text": "associative in this sort of funny way",
    "start": "1481640",
    "end": "1486640"
  },
  {
    "text": "okay so we have this sort of monoid like thing which we would expect given that we're talking about it is a monoid of",
    "start": "1487480",
    "end": "1493480"
  },
  {
    "text": "day convolution um the laws are actually a little bit more messy um",
    "start": "1493480",
    "end": "1499240"
  },
  {
    "text": "because the there's nothing that says that this function has to be Delta it could be any function you want it to be",
    "start": "1499240",
    "end": "1505200"
  },
  {
    "text": "so once you take into consideration all the things that can be you get this horrible nonsense so I will spare you from the",
    "start": "1505200",
    "end": "1512159"
  },
  {
    "text": "laws for the rest of these um for this section",
    "start": "1512159",
    "end": "1517279"
  },
  {
    "text": "um but when I picked the choice of tensor here I picked product and product",
    "start": "1517279",
    "end": "1523559"
  },
  {
    "text": "I'm taking products in the source category which is hasl to or sorry Hask op",
    "start": "1523559",
    "end": "1529039"
  },
  {
    "text": "to products in the Target category which is hcll nothing forced me to pick product",
    "start": "1529039",
    "end": "1535320"
  },
  {
    "text": "in either case I could pick some I could pick either here but then that would be",
    "start": "1535320",
    "end": "1540559"
  },
  {
    "text": "really weird you have either a function or a value or another value and somehow you're supposed to",
    "start": "1540559",
    "end": "1547120"
  },
  {
    "text": "handle that and give me back a I have no idea how you would use that but nothing prevents me from changing this one out",
    "start": "1547120",
    "end": "1554720"
  },
  {
    "text": "for a different thing this one here could be either just fine",
    "start": "1554720",
    "end": "1559799"
  },
  {
    "text": "matter of fact it's a lot similar to the way that we build up alternative when we get done with",
    "start": "1559799",
    "end": "1566640"
  },
  {
    "text": "this um so we wind up with this sort of class hierarchy in the con variant",
    "start": "1566640",
    "end": "1572440"
  },
  {
    "text": "world so we're we're sort of in Bizarro hascal here so we have a contravariant functor f which says if you can take A's",
    "start": "1572440",
    "end": "1578520"
  },
  {
    "text": "to B's I can take FS of B's to FS of as's and I'll have a few examples here in a minute and um we have this notion",
    "start": "1578520",
    "end": "1586799"
  },
  {
    "text": "of divisible contravariant functors which are which are the sort of contravariant applicatives and these are",
    "start": "1586799",
    "end": "1592760"
  },
  {
    "text": "sort of a contravariant alternative and this is basically saying if I can split a into B and C and I can",
    "start": "1592760",
    "end": "1599600"
  },
  {
    "text": "handle both I'm good and I can always do something but doesn't get in the way",
    "start": "1599600",
    "end": "1605279"
  },
  {
    "text": "here what I can do is this if I can split into a into either B or C and I can handle each of those cases",
    "start": "1605279",
    "end": "1611840"
  },
  {
    "text": "I'm good and if a is impossible then I'm good right if a can't happen I can",
    "start": "1611840",
    "end": "1617760"
  },
  {
    "text": "handle it um lose acts as a unit for choose under",
    "start": "1617760",
    "end": "1623480"
  },
  {
    "text": "the same kind of terms that we built up divide okay um so here's kind of a funny",
    "start": "1623480",
    "end": "1630520"
  },
  {
    "text": "thing lose was kind of funny because conquer didn't have any argument at all but if this is supposed to be like pure",
    "start": "1630520",
    "end": "1636480"
  },
  {
    "text": "or return why doesn't it have an argument so that it it seems kind of weird",
    "start": "1636480",
    "end": "1642320"
  },
  {
    "text": "right and this one like has a full argument but we don't have anything that takes like a unit to a in any of the",
    "start": "1642320",
    "end": "1649559"
  },
  {
    "text": "other things or something like that so how why does it feel like this and um I",
    "start": "1649559",
    "end": "1655120"
  },
  {
    "text": "think if I put things in a more symmetric um manner it's much more obvious why this works out so",
    "start": "1655120",
    "end": "1663240"
  },
  {
    "text": "pure if we actually work it out in terms of day convolution you'd actually get a function from unit to a goes to F of a",
    "start": "1663240",
    "end": "1669840"
  },
  {
    "text": "instead of using identity we would actually be using functions from unit because unit is the unit for our monoid",
    "start": "1669840",
    "end": "1675120"
  },
  {
    "text": "our monoidal tensor the the tensor here being product the unit for product is is",
    "start": "1675120",
    "end": "1681760"
  },
  {
    "text": "unit here the unit for either is void so we're saying in this case a function",
    "start": "1681760",
    "end": "1688240"
  },
  {
    "text": "from unit to a is boring it might as well just be a so a to F of a is",
    "start": "1688240",
    "end": "1693559"
  },
  {
    "text": "pure so we just throw away the unit two part of that statement here what do we",
    "start": "1693559",
    "end": "1699679"
  },
  {
    "text": "have we have a function from void to a it takes nothing it can never be passed",
    "start": "1699679",
    "end": "1704960"
  },
  {
    "text": "and gives you back an A so we have a function named absurd in hll that says if you've given me nothing I can give",
    "start": "1704960",
    "end": "1712039"
  },
  {
    "text": "you anything you want it's uh there in logic there's a principle called xalo quote leet whatever right so we can we",
    "start": "1712039",
    "end": "1720000"
  },
  {
    "text": "can start with this sort of empty is thing and say well we don't actually",
    "start": "1720000",
    "end": "1725039"
  },
  {
    "text": "need to supply an argument to empty in alternative so I in",
    "start": "1725039",
    "end": "1730440"
  },
  {
    "text": "alternative uh uh empty just is f of a with no arguments no fuss no foul just",
    "start": "1730440",
    "end": "1737240"
  },
  {
    "text": "like con was why did conquer get away with it well here we have a function that goes from a to unit but unit is the",
    "start": "1737240",
    "end": "1744120"
  },
  {
    "text": "terminal object in the category so the all of these arrows are trivial they're just the constant function that gives you back unit ignoring side effects",
    "start": "1744120",
    "end": "1750840"
  },
  {
    "text": "because we're in hll um so this is Trivial so both of these middle cases can completely erase",
    "start": "1750840",
    "end": "1756640"
  },
  {
    "text": "themselves this one can erase this part but this one can't erase anything because this is nothing special so that's why I have that's why",
    "start": "1756640",
    "end": "1763080"
  },
  {
    "text": "lose has an argument or whe there's an argument to lose um",
    "start": "1763080",
    "end": "1769600"
  },
  {
    "text": "this screwed me up for a long time I didn't believe this thing could exist until I started thinking about this the",
    "start": "1771320",
    "end": "1777039"
  },
  {
    "text": "right way like I wrote it off for probably five years when people just said is there a controver applicative",
    "start": "1777039",
    "end": "1782519"
  },
  {
    "text": "and I would say no very piffy and then I had to eat a lot of crow",
    "start": "1782519",
    "end": "1788640"
  },
  {
    "text": "um so what are some examples of these okay and then we'll finally be able to",
    "start": "1788640",
    "end": "1794080"
  },
  {
    "text": "get to discrimination and put this put this thing to use um",
    "start": "1794080",
    "end": "1799240"
  },
  {
    "text": "so the simplest contravariant function that people reach for is the notion of a predicate it's just a function that will",
    "start": "1799240",
    "end": "1805200"
  },
  {
    "text": "give you back a Boolean given an A and so you can you can Contra map you can map backwards over the input to your",
    "start": "1805200",
    "end": "1812559"
  },
  {
    "text": "function so if you give me a function from B to a I can compose it onto your function from here and you'll get a",
    "start": "1812559",
    "end": "1818080"
  },
  {
    "text": "function from B to pool um divisible for predicate is interesting because",
    "start": "1818080",
    "end": "1824240"
  },
  {
    "text": "conquer I'm going to choose to um I two choices of monoid that I can use on bu",
    "start": "1824240",
    "end": "1830200"
  },
  {
    "text": "that are easy right I can use and or or what's the unit well if I use and I",
    "start": "1830200",
    "end": "1837159"
  },
  {
    "text": "better use true if I use or I better use uh false so conquer should be the unit",
    "start": "1837159",
    "end": "1843720"
  },
  {
    "text": "for divide it just says yes this is true",
    "start": "1843720",
    "end": "1849200"
  },
  {
    "text": "it's a valid predicate you can apply to anything you want and then divide says take my value a split it up into B and C",
    "start": "1849200",
    "end": "1857519"
  },
  {
    "text": "test both predicates and and the results together not terribly",
    "start": "1857519",
    "end": "1863919"
  },
  {
    "text": "terrifying um on the other side we have to say well if a couldn't have happened great it didn't",
    "start": "1863919",
    "end": "1870720"
  },
  {
    "text": "happen and then here we have to say that if you can handle either of the two cases figure out which one of the two",
    "start": "1870720",
    "end": "1876600"
  },
  {
    "text": "you have and dispatch to it that's a that's a predicate as a contravariant functor with all this extra structure",
    "start": "1876600",
    "end": "1883480"
  },
  {
    "text": "attached all of these pieces actually work out as fairly Common Sense things you would expect to be able to do the",
    "start": "1883480",
    "end": "1888760"
  },
  {
    "text": "motivation for them is somewhat baroke um and in general if you have",
    "start": "1888760",
    "end": "1895320"
  },
  {
    "text": "anything like a to R where R is some monoid you can do the same thing you can just mend the two results you can use",
    "start": "1895320",
    "end": "1902360"
  },
  {
    "text": "the unit for it absurd nothing here changed from predicate except a couple of",
    "start": "1902360",
    "end": "1910360"
  },
  {
    "text": "symbols um now we might get more interesting if we have more than one a in contravariant",
    "start": "1910519",
    "end": "1917000"
  },
  {
    "text": "position an example would be the way that we might build a um a contravariant",
    "start": "1917000",
    "end": "1922200"
  },
  {
    "text": "functor for talking about equivalence classes and that is that you're going to give me a function from a to a to which",
    "start": "1922200",
    "end": "1931120"
  },
  {
    "text": "should be symmetric and reflexive and transitive and all the nice things those",
    "start": "1931120",
    "end": "1936880"
  },
  {
    "text": "are the nice things I guess you want out of equivalence relation um and then we need to be able",
    "start": "1936880",
    "end": "1942840"
  },
  {
    "text": "to map over both of the arguments you apply the function on both sides and then you app by the original",
    "start": "1942840",
    "end": "1949240"
  },
  {
    "text": "the equivalence class we divide by splitting each of our arguments into the",
    "start": "1949240",
    "end": "1955120"
  },
  {
    "text": "pairs and then testing each one of them to see if they're equal and then you're equivalent in the sort of product",
    "start": "1955120",
    "end": "1960200"
  },
  {
    "text": "equivalence class um here choosing is a little bit tricky because you have to actually",
    "start": "1960200",
    "end": "1965480"
  },
  {
    "text": "check to see that the both kind of got shoved into the same equivalence class there you have the sum the direct sum of",
    "start": "1965480",
    "end": "1970519"
  },
  {
    "text": "two equivalence classes or two families of equivalent classes and you disagree if you're in",
    "start": "1970519",
    "end": "1976559"
  },
  {
    "text": "different cases we can do comparisons we can do things for",
    "start": "1976559",
    "end": "1983639"
  },
  {
    "text": "ordering and um by the time when we get done with this the whole point of this is that discrimination will wind up",
    "start": "1984480",
    "end": "1989679"
  },
  {
    "text": "being generalizations of this approach in the previous thing just using much more",
    "start": "1989679",
    "end": "1995679"
  },
  {
    "text": "Machinery um and so here what we can do is we can divide into the two cases and",
    "start": "1995679",
    "end": "2001320"
  },
  {
    "text": "then the this will build back this gives back an ordering which is either less than equal to or greater than",
    "start": "2001320",
    "end": "2008799"
  },
  {
    "text": "and um the monoid for ordering smashes them together takes the the first one if",
    "start": "2008799",
    "end": "2014840"
  },
  {
    "text": "it's not equal and if it's eek then it takes the second one and so to conquer we just say that",
    "start": "2014840",
    "end": "2022320"
  },
  {
    "text": "it's equal and we don't do anything and then we split into left and right cases and lefts are less than",
    "start": "2022320",
    "end": "2028639"
  },
  {
    "text": "rights and then you agree with what GHC will generate using the derived instances for E can",
    "start": "2028639",
    "end": "2035120"
  },
  {
    "text": "ort all that kind of fun stuff okay",
    "start": "2035120",
    "end": "2041240"
  },
  {
    "text": "so um continuing down the rabbit hole how many people here are familiar with ghd",
    "start": "2041240",
    "end": "2046679"
  },
  {
    "text": "generics all right so in GHC one of the things that we can do is we can say given whatever algebraic data type",
    "start": "2046679",
    "end": "2052960"
  },
  {
    "text": "you've built up um we can say how does it break down",
    "start": "2052960",
    "end": "2058398"
  },
  {
    "text": "into sums and products and leaf LEL things okay and",
    "start": "2058399",
    "end": "2065839"
  },
  {
    "text": "so um this is sort of the product case that we see there this is the the sum case that we see there these things are",
    "start": "2065839",
    "end": "2071240"
  },
  {
    "text": "functors and I'm skipping a bunch of cases but we can basically see that this is basically borrowing the power to",
    "start": "2071240",
    "end": "2076839"
  },
  {
    "text": "divide to handle the products borrowing the power of choose to handle the sums",
    "start": "2076839",
    "end": "2083440"
  },
  {
    "text": "and saying okay the rest of this goes out into the GHC generics Machinery so no matter what data type you have what",
    "start": "2083440",
    "end": "2088638"
  },
  {
    "text": "I'll do is I'll look for some constraint Q on the leaf level",
    "start": "2088639",
    "end": "2094800"
  },
  {
    "text": "data types that I have in there and if for anything that I have this constraint on it if I can give you back some",
    "start": "2094800",
    "end": "2101400"
  },
  {
    "text": "decidable functor f then I can build up an F for this",
    "start": "2101400",
    "end": "2107800"
  },
  {
    "text": "whole result in a in a generic way then we do some boiler plate and wrap all this up",
    "start": "2107800",
    "end": "2114880"
  },
  {
    "text": "and we get this class or this data type here and so you can just completely",
    "start": "2114880",
    "end": "2120200"
  },
  {
    "text": "ignore that slide if it was too opaque and just say that we have this function deciding that says you tell me what",
    "start": "2120200",
    "end": "2126560"
  },
  {
    "text": "constraint you expect in this case or and you give me a way that says given",
    "start": "2126560",
    "end": "2131960"
  },
  {
    "text": "that constraint I can give you one of those contrarian functors so in here",
    "start": "2131960",
    "end": "2137040"
  },
  {
    "text": "comparison is the the data type that we built up before for talking about comparisons compare is a function from a",
    "start": "2137040",
    "end": "2144480"
  },
  {
    "text": "to a to ordering or in this case b to bet to ordering so we backage that thing",
    "start": "2144480",
    "end": "2149839"
  },
  {
    "text": "up giving us a comparison on B's this is telling the generic",
    "start": "2149839",
    "end": "2155480"
  },
  {
    "text": "Machinery hey walk through whatever whatever structure you were given all the way down to its leaves and as long",
    "start": "2155480",
    "end": "2161319"
  },
  {
    "text": "as every single one of those can be compared we can compare the result and this gives you a generic",
    "start": "2161319",
    "end": "2168920"
  },
  {
    "text": "comparison function as long as those pieces hold so for whatever data type you happen to build",
    "start": "2168920",
    "end": "2174400"
  },
  {
    "text": "up here we can do the same thing for equality because a to a to the equal",
    "start": "2174400",
    "end": "2180319"
  },
  {
    "text": "function gives you back an equivalent a form of equivalence class we have to",
    "start": "2180319",
    "end": "2186119"
  },
  {
    "text": "feed it the proxy to tell it what class constraint to use but other than that um this lets me get rid of writing",
    "start": "2186119",
    "end": "2193040"
  },
  {
    "text": "a whole crud ton of GHC generic code when I just need to consume a data structure and look at it as sums and",
    "start": "2193040",
    "end": "2198440"
  },
  {
    "text": "products if I needed to do more and knew needed to know the constructors or something like that I'd have to do something more exotic but I can put this",
    "start": "2198440",
    "end": "2205720"
  },
  {
    "text": "in the contravariant package and it just works for everything that I happen to care",
    "start": "2205720",
    "end": "2211040"
  },
  {
    "text": "about okay so now that we have all of this Machinery we can we can go back to",
    "start": "2211040",
    "end": "2219880"
  },
  {
    "text": "the very simple API that um was built by Fritz in his um",
    "start": "2219880",
    "end": "2225760"
  },
  {
    "text": "original papers so he built up this notion of a of what he called a stabled ordered",
    "start": "2225760",
    "end": "2231520"
  },
  {
    "text": "discriminator and then he built this data type and the problem in many ways with this data type is that I have no",
    "start": "2231520",
    "end": "2238599"
  },
  {
    "text": "classes that I can put on this that I can obey any real laws for I can't I can make a an instance of contravariant by",
    "start": "2238599",
    "end": "2245359"
  },
  {
    "text": "putting map Constructors on everything but that's pretty um wonky in the sense that I have",
    "start": "2245359",
    "end": "2252480"
  },
  {
    "text": "to change the shape of the data type to put a map in the front of it now I could put one of these kind of functions in",
    "start": "2252480",
    "end": "2258560"
  },
  {
    "text": "the front of every single one of these things and then play games with the Gemma and do all sorts of horrible",
    "start": "2258560",
    "end": "2263680"
  },
  {
    "text": "things to make that perfectly legal but then I wouldn't be able to talk about sums and products and dividing and",
    "start": "2263680",
    "end": "2270520"
  },
  {
    "text": "conquering and all that other kind of stuff where I had nice laws and nice units and all the things to make it go",
    "start": "2270520",
    "end": "2277040"
  },
  {
    "text": "um so I to replace this data type with this data type and um so what we're doing here is",
    "start": "2277040",
    "end": "2285880"
  },
  {
    "text": "this I'm saying if you give me a list of pairs of A's and B's what I want you to",
    "start": "2285880",
    "end": "2291160"
  },
  {
    "text": "do is give me back a list of lists of B's where these are the individual equivalence classes that you found over",
    "start": "2291160",
    "end": "2297280"
  },
  {
    "text": "here by whatever criteria by hook or by crook you wanted to pick out of a not my",
    "start": "2297280",
    "end": "2302920"
  },
  {
    "text": "job to figure out what that is you have to give me back all the be's",
    "start": "2302920",
    "end": "2308599"
  },
  {
    "text": "and the inhabitants of your individual equivalence classes should be given stably with respect to the order that",
    "start": "2308599",
    "end": "2314200"
  },
  {
    "text": "you see them here in the inlet those are the constraints I'm going to put on you anything that you can Implement that is",
    "start": "2314200",
    "end": "2320280"
  },
  {
    "text": "subject to those constraints is a valid discriminator a valid stable ordered",
    "start": "2320280",
    "end": "2327240"
  },
  {
    "text": "discriminator um and so you should only be using the value of a to figure out what you want to",
    "start": "2327240",
    "end": "2334000"
  },
  {
    "text": "do so this is a contravariant functor you can Contra map over",
    "start": "2334040",
    "end": "2340760"
  },
  {
    "text": "it and I can build a class let's call it sorting for things that we can sort in",
    "start": "2341680",
    "end": "2350000"
  },
  {
    "text": "this fashion so assuming that I can build divisible and decidable for this",
    "start": "2350000",
    "end": "2355720"
  },
  {
    "text": "we can use this class and we'll just say hey by default use the generics to walk down to leaves and as long as you can",
    "start": "2355720",
    "end": "2361440"
  },
  {
    "text": "sort the leaves you're good so any tree like structure we can just borrow the ability to handle all the leaves and the",
    "start": "2361440",
    "end": "2367800"
  },
  {
    "text": "generic Machinery walk up the tree and so now we can handle the empty case",
    "start": "2367800",
    "end": "2373480"
  },
  {
    "text": "booleans lists maybe whatever assuming that I have divisible and",
    "start": "2373480",
    "end": "2380480"
  },
  {
    "text": "decidable and the law that I want for this is that if you if you give me any strictly monotone increasing function on",
    "start": "2380480",
    "end": "2386480"
  },
  {
    "text": "F it shouldn't change the answer so that's the this is sort of me",
    "start": "2386480",
    "end": "2393680"
  },
  {
    "text": "requiring this thing to be a structural or which is perhaps a little bit overshoot on my behalf you know we have",
    "start": "2393680",
    "end": "2398880"
  },
  {
    "text": "or instances that don't that are not purely structural but so be it this is",
    "start": "2398880",
    "end": "2404040"
  },
  {
    "text": "what I want so I'm claiming it um my library damn it okay",
    "start": "2404040",
    "end": "2412400"
  },
  {
    "text": "so now let's how how would we do divisible well we need a conquer uh so",
    "start": "2412400",
    "end": "2417640"
  },
  {
    "text": "conquer has to take this thing and give me something that doesn't muck up the story so it has to build one gigantic",
    "start": "2417640",
    "end": "2423240"
  },
  {
    "text": "equivalence class and shove all the crap in it we just say you gave me a list of A's",
    "start": "2423240",
    "end": "2428920"
  },
  {
    "text": "and B's that's nice drop the A's on the floor now I have a list of B's and I'm going to give you one equivalence class",
    "start": "2428920",
    "end": "2434000"
  },
  {
    "text": "I'm just going to return a single list that contains one list inside of it which is all of your",
    "start": "2434000",
    "end": "2440440"
  },
  {
    "text": "bees and then if you have two ways of sorting your numbers if you have like a",
    "start": "2440920",
    "end": "2446480"
  },
  {
    "text": "way of breaking things down into um if you have the ability to sort BS and you",
    "start": "2446480",
    "end": "2451599"
  },
  {
    "text": "have the ability to sort C's then what you can do is this you can start with your a and whatever it's carrying let's",
    "start": "2451599",
    "end": "2458920"
  },
  {
    "text": "call it D because I didn't want to deal with B twice um we run through your list",
    "start": "2458920",
    "end": "2465040"
  },
  {
    "text": "we break it out into pairs of A's and D's where D is the the payload the thing that you're actually carrying around that you're going to leave in the",
    "start": "2465040",
    "end": "2472000"
  },
  {
    "text": "end then split the a into B and C now reshuffle your payload so it's a",
    "start": "2472000",
    "end": "2480079"
  },
  {
    "text": "product of b car You're Now using b as the thing you're going to discriminate on giving you C's and D's inside of it",
    "start": "2480079",
    "end": "2487880"
  },
  {
    "text": "which we don't care about because we're just going to pass it through discriminate using the fact that",
    "start": "2487880",
    "end": "2493240"
  },
  {
    "text": "L is going to do the the the stable discrimination on that and then bind to",
    "start": "2493240",
    "end": "2498800"
  },
  {
    "text": "R which is going to do a subd discrimination on each one of the individual Pieces by the time we're done",
    "start": "2498800",
    "end": "2504040"
  },
  {
    "text": "we'll have broken things out into an equivalence class for every sort of product of the two equivalence classes",
    "start": "2504040",
    "end": "2509560"
  },
  {
    "text": "that we wanted to deal with before and it will be stable and it will",
    "start": "2509560",
    "end": "2514839"
  },
  {
    "text": "sort so we just dealt with products and we can deal with sums by saying that",
    "start": "2514839",
    "end": "2521520"
  },
  {
    "text": "if something can't happen well it's never going to come up in my equivalence classes so I don't need to worry about",
    "start": "2521520",
    "end": "2526880"
  },
  {
    "text": "it and in the other case what we have to do is sort of break things out into",
    "start": "2526880",
    "end": "2532440"
  },
  {
    "text": "lefts and rights so all we're going to do here is we're going to pattern match and say hey",
    "start": "2532440",
    "end": "2537800"
  },
  {
    "text": "take all the lefts here and run them through the left discriminator all the",
    "start": "2537800",
    "end": "2543400"
  },
  {
    "text": "and then append the result of running all the rights through the right discriminator so we put all the lefts before all the rights which is what you",
    "start": "2543400",
    "end": "2550280"
  },
  {
    "text": "would expect if you sorted either a a list of either",
    "start": "2550280",
    "end": "2555920"
  },
  {
    "text": "ABS so we have now dealt with sums and products but we haven't done any radics",
    "start": "2555920",
    "end": "2562960"
  },
  {
    "text": "stuff so I'm just going to punt and say hey look you can do a radic sort for sorting that which says somehow I'm",
    "start": "2562960",
    "end": "2570359"
  },
  {
    "text": "going to give you n buckets go through shuffle all the data into those buckets",
    "start": "2570359",
    "end": "2575480"
  },
  {
    "text": "you can do it using array or whatever you want um and then we just won't use this",
    "start": "2575480",
    "end": "2581680"
  },
  {
    "text": "for big numbers we'll use it for like 65,536 or less say so for Word eight and",
    "start": "2581680",
    "end": "2587599"
  },
  {
    "text": "word 16 those are easy and then what we can do",
    "start": "2587599",
    "end": "2593880"
  },
  {
    "text": "is um build up this sort of notion of using an American flag sort by breaking things up into the um least and more",
    "start": "2593880",
    "end": "2601240"
  },
  {
    "text": "significant bits and then running it through the engine um",
    "start": "2601240",
    "end": "2608839"
  },
  {
    "text": "now this is the approach that Fritz takes in the paper but where I was talking about how American flag is sort",
    "start": "2608839",
    "end": "2614760"
  },
  {
    "text": "of top down and um radx sword is bottom up so American flag is going to do lots of little",
    "start": "2614760",
    "end": "2621040"
  },
  {
    "text": "sorts and radx is going to do an enormous set of sorts it's going to sort",
    "start": "2621040",
    "end": "2626160"
  },
  {
    "text": "everything however many times you have sort of I can take this and drop this into a",
    "start": "2626160",
    "end": "2634160"
  },
  {
    "text": "radic sort which is basically go through break these things out into the um least",
    "start": "2634160",
    "end": "2642040"
  },
  {
    "text": "significant bits then the then the more significant bits and then keep the original answer around as a",
    "start": "2642040",
    "end": "2648280"
  },
  {
    "text": "tag then I can run through this thing kind of the wrong direction using binds",
    "start": "2648960",
    "end": "2654559"
  },
  {
    "text": "to glue the whole thing together and when I'm done all I have to do is sort of gather these things up into runs",
    "start": "2654559",
    "end": "2660680"
  },
  {
    "text": "where they agree on this key okay and that can be done fairly",
    "start": "2660680",
    "end": "2666240"
  },
  {
    "text": "quickly actually and the nice thing is while those things are words so this is just comparing",
    "start": "2666240",
    "end": "2672079"
  },
  {
    "text": "words to do the join um this takes the same ASM totic as this but the constant",
    "start": "2672079",
    "end": "2677280"
  },
  {
    "text": "factors are ridiculously better despite the fact that American flag s was designed to work around the constant",
    "start": "2677280",
    "end": "2682720"
  },
  {
    "text": "factors of radic the um the benefit comes from the",
    "start": "2682720",
    "end": "2688040"
  },
  {
    "text": "fact that we do far fewer individual sorts even though we're doing bigger",
    "start": "2688040",
    "end": "2693160"
  },
  {
    "text": "ones and so I use this for my number types but then I American flag all the other pieces so it's it's sort of a",
    "start": "2693160",
    "end": "2699160"
  },
  {
    "text": "hybrid up down top bottom all over the place kind of sort that has the right",
    "start": "2699160",
    "end": "2704280"
  },
  {
    "text": "properties that every given step um and so the nice thing is when",
    "start": "2704280",
    "end": "2710200"
  },
  {
    "text": "we're done we can take our sorting data type our sorting algorithm that we've",
    "start": "2710200",
    "end": "2715319"
  },
  {
    "text": "just built up for whatever data type we have a we can run it we'll feed the data type itself is",
    "start": "2715319",
    "end": "2722599"
  },
  {
    "text": "the thing we're discriminating on and we're carrying itself as the payload and spit out the answer and this",
    "start": "2722599",
    "end": "2728040"
  },
  {
    "text": "will sort a list in O and time for any data type that we can run through so any algebraic data type that happens to",
    "start": "2728040",
    "end": "2734040"
  },
  {
    "text": "contain numbers um or other algebraic data types will",
    "start": "2734040",
    "end": "2740640"
  },
  {
    "text": "work and we can do shorting with if you want to do like the Schwarz and transform trick you know thank thank you",
    "start": "2740920",
    "end": "2746920"
  },
  {
    "text": "Pearl um where you prepare it with the the key so that you don't have to pay",
    "start": "2746920",
    "end": "2752040"
  },
  {
    "text": "for an expensive key calculation over and over again every time you walk through the list um we can just do that",
    "start": "2752040",
    "end": "2758160"
  },
  {
    "text": "we're building a list that has the key and the thing that we want to uh work with and we",
    "start": "2758160",
    "end": "2763800"
  },
  {
    "text": "go so that's also o n as you would expect but it fits very nicely in so you",
    "start": "2763800",
    "end": "2769920"
  },
  {
    "text": "can see this is just the Schwarz and transform with the identity",
    "start": "2769920",
    "end": "2774520"
  },
  {
    "text": "function now in data. map and data. set and these data different container types",
    "start": "2775000",
    "end": "2781160"
  },
  {
    "text": "that we have in Haso we often have a fast map construction that runs in linear time if you promise me you know",
    "start": "2781160",
    "end": "2789680"
  },
  {
    "text": "on your mother or whatever that the inputs are in order in order so",
    "start": "2789680",
    "end": "2796079"
  },
  {
    "text": "if we require that our sorting agrees with the order that that we get from",
    "start": "2796079",
    "end": "2801480"
  },
  {
    "text": "or as an extra law then you're perfectly able to say sort putting all this stuff",
    "start": "2801480",
    "end": "2809119"
  },
  {
    "text": "in order now you have a bunch of equivalence classes take the last inhabitant of each equivalence class because that's what tube math is going",
    "start": "2809119",
    "end": "2815359"
  },
  {
    "text": "or that was that what from list was going to do and then feed them to this from",
    "start": "2815359",
    "end": "2820559"
  },
  {
    "text": "distinct ascending list thing that's linear time and we just constructed a map in linear time rather than n log",
    "start": "2820559",
    "end": "2826640"
  },
  {
    "text": "n so anytime you're going to call from list with or from list consider that you",
    "start": "2826640",
    "end": "2832599"
  },
  {
    "text": "can use this discrimination stuff with another instance and that instance is going to cost you one line worth of code and will be automatically generated for",
    "start": "2832599",
    "end": "2839760"
  },
  {
    "text": "you okay uh so we can win on constants for appap construction set construction you know those don't come up in",
    "start": "2839760",
    "end": "2845520"
  },
  {
    "text": "functional programming at all um so that's kind of",
    "start": "2845520",
    "end": "2851400"
  },
  {
    "text": "nice um so so far what we have is the O stable order discrimination on any ADT",
    "start": "2851400",
    "end": "2856480"
  },
  {
    "text": "radic sort instead of American flag sort boosts my constants and then GHC generics let us derive the instance we",
    "start": "2856480",
    "end": "2862599"
  },
  {
    "text": "had to use a lot of theory to get here right we had to go off and find what are the monoids of dayc convolution but we",
    "start": "2862599",
    "end": "2868839"
  },
  {
    "text": "got a nice API and we're able to use these nice classes that have applications in all sorts of other",
    "start": "2868839",
    "end": "2874599"
  },
  {
    "text": "domains and we can directly see the connection in many ways to sorting and grouping or where we had the equivalence",
    "start": "2874599",
    "end": "2881200"
  },
  {
    "text": "classes in the ordering which then invites the question of what are the things that I can only",
    "start": "2881200",
    "end": "2888040"
  },
  {
    "text": "compare for equality but not order and how could I gain anything here",
    "start": "2888040",
    "end": "2894319"
  },
  {
    "text": "out of that so here's spr a solution now mind",
    "start": "2894319",
    "end": "2902800"
  },
  {
    "text": "you it's absolutely brilliant stuff that he's got here we just want to get to",
    "start": "2902800",
    "end": "2908319"
  },
  {
    "text": "there um and this is actually I'm going to show that this is actually probably wrong for unordered discrimination I'm",
    "start": "2908319",
    "end": "2914079"
  },
  {
    "text": "going to show the problems that we're going to run into and the problems that in many ways you run into if you take um Fritz's uh papers at face value which",
    "start": "2914079",
    "end": "2921440"
  },
  {
    "text": "actually really surprised me um yeah actually um a really horrible horrible",
    "start": "2921440",
    "end": "2928200"
  },
  {
    "text": "anecdote that will probably get me and feathered is that when I was working on this stuff I was realizing that I was",
    "start": "2928200",
    "end": "2934119"
  },
  {
    "text": "doing a talk on discrimination and that my solution for discrimination was to use the final",
    "start": "2934119",
    "end": "2940520"
  },
  {
    "text": "solution and then I realized I was going to go from here to right next to Germany and give a very similar talk and I",
    "start": "2940520",
    "end": "2945960"
  },
  {
    "text": "realized I had to do something to walk it back and so fortunately I found that um there's a bug in Fritz's",
    "start": "2945960",
    "end": "2953880"
  },
  {
    "text": "paper at least a subtle uh issue that I want to take up with Fritz's paper so I could say that discrimination is wrong",
    "start": "2953880",
    "end": "2960280"
  },
  {
    "text": "please take that away as the takeaway um and um greatly redeem the subject matter",
    "start": "2960280",
    "end": "2966319"
  },
  {
    "text": "of the talk but uh it was it was touch and go there for a while um",
    "start": "2966319",
    "end": "2973040"
  },
  {
    "text": "so so here we have our notion of grouping that we want to work with and um where might these come up",
    "start": "2973040",
    "end": "2981040"
  },
  {
    "text": "with uh where might these come up in practice well ior refs have an equality instance you can compare two ior refs",
    "start": "2981040",
    "end": "2986839"
  },
  {
    "text": "for equality to see if they're the same pointer the same thing that's pointing off to whatever it could be pointing off",
    "start": "2986839",
    "end": "2992280"
  },
  {
    "text": "to so if you have the same object in memory that like when you change it will change all of the other members that",
    "start": "2992280",
    "end": "2998359"
  },
  {
    "text": "compare for equal in the right but it doesn't have an or instance because we",
    "start": "2998359",
    "end": "3003599"
  },
  {
    "text": "have a garbage collected system and everything slops around all over the place in memory and we're not just um",
    "start": "3003599",
    "end": "3009760"
  },
  {
    "text": "Market sweeping we're actually you know compacting or um two space collecting or whatever we're",
    "start": "3009760",
    "end": "3015920"
  },
  {
    "text": "doing and so that's one case where unordered discrimination can really",
    "start": "3015920",
    "end": "3020960"
  },
  {
    "text": "matter and the other one is that we can show that sorting is completely is is provably unproductive",
    "start": "3020960",
    "end": "3027880"
  },
  {
    "text": "if you have if you have to sort a list I can't start giving you the answers until",
    "start": "3027880",
    "end": "3033400"
  },
  {
    "text": "I'm done sorting it actually I have to see the whole",
    "start": "3033400",
    "end": "3038880"
  },
  {
    "text": "list right and so if I'm interested in doing joins or a bunch of other things and I want to be able to start giving",
    "start": "3038880",
    "end": "3044640"
  },
  {
    "text": "you an answer immediately I'm stuck the moment I require any form of sorting I'm dead in the water I just can't do",
    "start": "3044640",
    "end": "3053200"
  },
  {
    "text": "it but grouping has the potential to be",
    "start": "3054240",
    "end": "3059480"
  },
  {
    "text": "productive so we can build a",
    "start": "3059480",
    "end": "3064599"
  },
  {
    "text": "um a horrible combinator here that will do a a modified radic",
    "start": "3064599",
    "end": "3071760"
  },
  {
    "text": "sort and what I want to do is this um this is um kind of terrible um so the obvious way to make you know high",
    "start": "3071760",
    "end": "3077960"
  },
  {
    "text": "performance functional code is to use unsafe perform IO to do things we use unsafe perform IO inside of unsafe",
    "start": "3077960",
    "end": "3084760"
  },
  {
    "text": "perform IO because that you know we weren't getting enough speed out of one um and a couple of unsafe ches just",
    "start": "3084760",
    "end": "3091000"
  },
  {
    "text": "for good measure and the idea here is this what I want to do is when you tell",
    "start": "3091000",
    "end": "3097000"
  },
  {
    "text": "me this the number of buckets you want I'm going to make little arrays that are going to act as a pad of that size and I",
    "start": "3097000",
    "end": "3104160"
  },
  {
    "text": "will leak as many of them as you ever use concurrently but I can bound that by the number of active contexts so it will",
    "start": "3104160",
    "end": "3111079"
  },
  {
    "text": "actually be a fairly small thing you'll you'll leak a Meg or something like that and you'll never get worse um then what",
    "start": "3111079",
    "end": "3116920"
  },
  {
    "text": "I'm going to do is I'm going to make a sort of a mutable really but I'm not going to tell you that it's there um",
    "start": "3116920",
    "end": "3124200"
  },
  {
    "text": "reference that holds on to a list of these arrays these vectors where for each one of the cells",
    "start": "3124200",
    "end": "3130520"
  },
  {
    "text": "I'm going to put in whatever I want in there and I'm going to before I'm done with this array I'm going to restore it to pristine state I'm going to give you",
    "start": "3130520",
    "end": "3136480"
  },
  {
    "text": "back an array that's all um empty lists and so that's justifying the fact",
    "start": "3136480",
    "end": "3143119"
  },
  {
    "text": "that these are going to be NES because when by the time you see it you won't be able to distinguish that that it once held something",
    "start": "3143119",
    "end": "3148760"
  },
  {
    "text": "else and we're going to run and then what I want to do is go look at this",
    "start": "3148760",
    "end": "3154720"
  },
  {
    "text": "list and see if there was something on the free list we could take and if there is give it back and if",
    "start": "3154720",
    "end": "3160799"
  },
  {
    "text": "not don't here if you got something back use",
    "start": "3160799",
    "end": "3166559"
  },
  {
    "text": "it just cast it change the type do the horrible things yes it's awful otherwise",
    "start": "3166559",
    "end": "3172000"
  },
  {
    "text": "build a new array of the right size go through and what I want you to do now",
    "start": "3172000",
    "end": "3178640"
  },
  {
    "text": "is run through using your array of key value Pairs and look at the appropriate",
    "start": "3178640",
    "end": "3185680"
  },
  {
    "text": "bucket and if it's um empty add the key to a list of buckets we've uh We've now",
    "start": "3185680",
    "end": "3193960"
  },
  {
    "text": "seen and then thread the answer or the element into the appropriate bucket",
    "start": "3193960",
    "end": "3199400"
  },
  {
    "text": "right this is the the bucket the putting the thing into the buckets of a bucket sort of of of a bucket sort but what",
    "start": "3199400",
    "end": "3204520"
  },
  {
    "text": "we're doing is we're keeping track of the order in which we encountered the buckets",
    "start": "3204520",
    "end": "3210240"
  },
  {
    "text": "first and so if we encounter a bucket we've already seen we just put it on there and we don't thread it under our list when we're done we go through the",
    "start": "3210240",
    "end": "3218799"
  },
  {
    "text": "list that we just built up in the appropriate order we read we reverse the lists to get everything stable blah blah",
    "start": "3218799",
    "end": "3226040"
  },
  {
    "text": "blah we scribble out the empty list in we scribbled an empty list into everything that we actually",
    "start": "3226040",
    "end": "3232839"
  },
  {
    "text": "used and we got out our stably sorted result results and we smash that array back",
    "start": "3232839",
    "end": "3239960"
  },
  {
    "text": "onto our free list when we're done now why did we go through all of this effort when we could have just made whole new",
    "start": "3239960",
    "end": "3245880"
  },
  {
    "text": "arrays right well these arrays are big they could be like 65,000 entry arrays with you know 8",
    "start": "3245880",
    "end": "3251760"
  },
  {
    "text": "bytes per pointer or whatever they're going to hold they can be fairly sizable and the cost of initializing one of these arrays from scratch is much higher",
    "start": "3251760",
    "end": "3259359"
  },
  {
    "text": "than the cost of going through and touching the handful of cases in it that I actually used and banging back in",
    "start": "3259359",
    "end": "3266720"
  },
  {
    "text": "the Ulus okay so this actually takes this thing from being about six times slower",
    "start": "3266720",
    "end": "3272319"
  },
  {
    "text": "than quick sort to being uh two or three times faster in many ways in many places",
    "start": "3272319",
    "end": "3277599"
  },
  {
    "text": "so it was worth the horror because it had to win or it was",
    "start": "3277599",
    "end": "3285280"
  },
  {
    "text": "useless um and so Fritz did something very similar but he just made a um he",
    "start": "3285280",
    "end": "3290799"
  },
  {
    "text": "didn't have the free list and so it just created race hazards so this is a slight modification of Fritz's approach",
    "start": "3290799",
    "end": "3297200"
  },
  {
    "text": "um to get rid of the hazards um and so the the the grouping law that I would like to have is this if",
    "start": "3297200",
    "end": "3303559"
  },
  {
    "text": "you give me any injective function then Contra mapping that",
    "start": "3303559",
    "end": "3308680"
  },
  {
    "text": "function over grouping should just give you the same grouping so what I want to do is I want to give you back the equivalence classes in the order in",
    "start": "3308680",
    "end": "3314480"
  },
  {
    "text": "which I find them the first inhab the order in which I find the first inhabitant of the equivalence class in",
    "start": "3314480",
    "end": "3319640"
  },
  {
    "text": "your input not in any order that is determined by the elements themselves so I'm not sorting with your data I'm using",
    "start": "3319640",
    "end": "3326640"
  },
  {
    "text": "your data to discriminate whether or not two things are equal and then I'm giving you back your equivalence classes in order in the order that I encounter",
    "start": "3326640",
    "end": "3335480"
  },
  {
    "text": "them um so why this law so with that law we can build a number of really nice",
    "start": "3335480",
    "end": "3341480"
  },
  {
    "text": "functions that could theoretically be completely online we could build a group that would go through and allow you to",
    "start": "3341480",
    "end": "3347839"
  },
  {
    "text": "just say find all the things that are the same and dump them into equivalence classes and we could possibly lazily",
    "start": "3347839",
    "end": "3354640"
  },
  {
    "text": "produce each one of these sublists like as we're going through consuming the input list we're continuing to spit out",
    "start": "3354640",
    "end": "3360039"
  },
  {
    "text": "more digit more things on the end of each one of those Target lists okay it works out domain",
    "start": "3360039",
    "end": "3365559"
  },
  {
    "text": "theoretically implementing it is equally horrible to the things that you've seen so far or Worse",
    "start": "3365559",
    "end": "3372559"
  },
  {
    "text": "um nub is o n squar in hasal",
    "start": "3372559",
    "end": "3378520"
  },
  {
    "text": "today here we can do a nub that doesn't leak n log n space or",
    "start": "3378520",
    "end": "3383880"
  },
  {
    "text": "whatever like we have to do today to do an efficient um nub with a set but we can do a nub",
    "start": "3383880",
    "end": "3390000"
  },
  {
    "text": "that is o n by using grouping and taking out the head of each one of these lists because",
    "start": "3390000",
    "end": "3395200"
  },
  {
    "text": "each one the moment we construct the moment we create the list we put its head in and then we move on and then eventually we're going to put more stuff",
    "start": "3395200",
    "end": "3401200"
  },
  {
    "text": "into it but it could be done productively where you can get access to the heads so this gives us a number of",
    "start": "3401200",
    "end": "3408119"
  },
  {
    "text": "functions that we already have in Haso today group in hasal we have in o n but we only allow you to group neighboring",
    "start": "3408119",
    "end": "3414240"
  },
  {
    "text": "elements this would let you shove things into a group much much later which is a different function",
    "start": "3414240",
    "end": "3421680"
  },
  {
    "text": "adely but the names were chosen because then they work with um there were a",
    "start": "3421680",
    "end": "3427160"
  },
  {
    "text": "bunch of Link style extensions that wadler and some folks uh smashed into GHC at one point that I don't think",
    "start": "3427160",
    "end": "3433079"
  },
  {
    "text": "anyone's really used since but this would let you use all of those list",
    "start": "3433079",
    "end": "3438760"
  },
  {
    "text": "extension comprehension like things with grouping instead of having to pay to",
    "start": "3438760",
    "end": "3444160"
  },
  {
    "text": "full do full sorts for everything and um the key here is again we have",
    "start": "3444160",
    "end": "3450960"
  },
  {
    "text": "this potential for streaming so if we had something where we're like grouping iners we're going to see that the first",
    "start": "3450960",
    "end": "3456920"
  },
  {
    "text": "group starts with an A I don't know how many elements it has in it I don't know how many other equivalence classes is but the moment I've seen this element I",
    "start": "3456920",
    "end": "3462520"
  },
  {
    "text": "know that I have one equivalence class and it starts with a moment I see this element I know that I have another equivalence class and it starts with B",
    "start": "3462520",
    "end": "3469880"
  },
  {
    "text": "moment I see this element I know the first thing that I saw or the other equivalence class now has an extra element in it so as I'm going I'm",
    "start": "3469880",
    "end": "3476720"
  },
  {
    "text": "gaining information sort of lvar or iar style so you can see how implementing this will",
    "start": "3476720",
    "end": "3483000"
  },
  {
    "text": "be horrible but it there's a potential to do fully online streaming of nub and",
    "start": "3483000",
    "end": "3489559"
  },
  {
    "text": "all these other operations and still have this linear time",
    "start": "3489559",
    "end": "3494760"
  },
  {
    "text": "guarantee um and so you know we come into trouble with the law where um in",
    "start": "3494960",
    "end": "3501079"
  },
  {
    "text": "the actual original discrimination paper the implementation for handling sums looks a lot like like the way that we",
    "start": "3501079",
    "end": "3506760"
  },
  {
    "text": "handled them for sorting because it is sorting and the way that we handle products looks a lot like the case we",
    "start": "3506760",
    "end": "3512920"
  },
  {
    "text": "were handling for sorting because it is sorting and so this is you know why in many ways discrimination is",
    "start": "3512920",
    "end": "3519599"
  },
  {
    "text": "wrong um not the perhaps much more timely uh social",
    "start": "3519599",
    "end": "3525119"
  },
  {
    "text": "message but the uh why why this particular Library um has a problem with or the concept of discrimination and",
    "start": "3525119",
    "end": "3531760"
  },
  {
    "text": "that is um that we shouldn't be sorting here because it's",
    "start": "3531760",
    "end": "3537799"
  },
  {
    "text": "destroying that that law that I wanted to put in that counter map F of uh",
    "start": "3537799",
    "end": "3544079"
  },
  {
    "text": "grouping is grouping whenever f is injected which it's effectively saying that the only source of information that",
    "start": "3544079",
    "end": "3549880"
  },
  {
    "text": "we have is the order in which we encounter the equivalence",
    "start": "3549880",
    "end": "3554960"
  },
  {
    "text": "classes okay and so both of these cases are wrong as is that grouping net thing",
    "start": "3555160",
    "end": "3560960"
  },
  {
    "text": "that beautiful thing that we had with the two nested unsafe perform iio it's not sufficient to the job",
    "start": "3560960",
    "end": "3568038"
  },
  {
    "text": "so there's a fix we can make a version if you give me a grouping that a grouping that isn't legal I can enforce",
    "start": "3569480",
    "end": "3578160"
  },
  {
    "text": "it to be legal by going back to using sorting this will totally never give me productivity because we've already shown",
    "start": "3578160",
    "end": "3584000"
  },
  {
    "text": "that anything that needs to use sorting can't be productive uh an example would be um if let's say that you were trying",
    "start": "3584000",
    "end": "3590559"
  },
  {
    "text": "to use nub by sorting and you were going through and just giving you were just given an",
    "start": "3590559",
    "end": "3595680"
  },
  {
    "text": "infinite list of TRS right you have no way of knowing that",
    "start": "3595680",
    "end": "3602160"
  },
  {
    "text": "you won't get a false right so you can't tell me true because false is going to come before the truths that are going to",
    "start": "3602160",
    "end": "3608119"
  },
  {
    "text": "come out in your output list so you're you're just stuck waiting",
    "start": "3608119",
    "end": "3613720"
  },
  {
    "text": "for a false or an end of list so you just can't make progress on the output no matter how much more input",
    "start": "3613720",
    "end": "3619760"
  },
  {
    "text": "you get until you see false here what we're doing is we're",
    "start": "3619760",
    "end": "3625160"
  },
  {
    "text": "saying you had some grouping you wanted to perform what I want you to do is tag every element that you're going to do",
    "start": "3625160",
    "end": "3630960"
  },
  {
    "text": "with its order in its element order in the original list so the payload instead of being",
    "start": "3630960",
    "end": "3637880"
  },
  {
    "text": "whatever B you were going to carry around is now an integer and that b the grouping that you're going to do",
    "start": "3637880",
    "end": "3646680"
  },
  {
    "text": "does whatever it's going to do to break things out into equivalence classes it might partially sort it might do whatever but when it's done you have a",
    "start": "3646680",
    "end": "3653160"
  },
  {
    "text": "list of lists where each element in there is a an integer and the actual argument and so what we can do is we can",
    "start": "3653160",
    "end": "3660160"
  },
  {
    "text": "peel it off we know that the n one the internal ones are non empty get out the N sort by that",
    "start": "3660160",
    "end": "3666319"
  },
  {
    "text": "n and then um peel out the value from it",
    "start": "3666319",
    "end": "3672039"
  },
  {
    "text": "and that's horrible but it actually does get you a legal um unstable discriminator yes I'm",
    "start": "3672039",
    "end": "3679280"
  },
  {
    "text": "I realize I'm pushing really hard to time so how much time can I how much can I run before you really want me to stop",
    "start": "3679280",
    "end": "3687640"
  },
  {
    "text": "hard all right okay so we can fix sums",
    "start": "3687640",
    "end": "3692880"
  },
  {
    "text": "productively by doing that same tagging trick and um by uh working here this",
    "start": "3692880",
    "end": "3701280"
  },
  {
    "text": "actually has a productive story we can do discrimination on pointers which we",
    "start": "3701280",
    "end": "3706799"
  },
  {
    "text": "know we can't have an ordering on by going through and saying I can discriminate on addresses so you give me",
    "start": "3706799",
    "end": "3713599"
  },
  {
    "text": "a list of pointers and I'm going to do is I'm going to build a custom forign Prim which totally does not work on the",
    "start": "3713599",
    "end": "3720640"
  },
  {
    "text": "screen um and then Force this whole list and go out under the Heap and do",
    "start": "3720640",
    "end": "3726480"
  },
  {
    "text": "horrible things to walk this thing manually behind the scenes and with that I can actually sort lists of IO",
    "start": "3726480",
    "end": "3733240"
  },
  {
    "text": "refs um or not sort I can group them into equivalence classes in O time even",
    "start": "3733240",
    "end": "3738839"
  },
  {
    "text": "though doing pawise comparison you can't do better than uh Theta n^2 it just",
    "start": "3738839",
    "end": "3744039"
  },
  {
    "text": "can't get better right with pair wise comparon in that um and",
    "start": "3744039",
    "end": "3751279"
  },
  {
    "text": "um sometimes we don't care if it's sorted or not like for joins I might want to be able to join on an ordered",
    "start": "3751279",
    "end": "3756880"
  },
  {
    "text": "predicate or not but you can do joins just by showing that we we'll do is we'll inject it on",
    "start": "3756880",
    "end": "3763960"
  },
  {
    "text": "we'll make our payloads lefts and rights so you have two things you want to join you'll have like one table on the left",
    "start": "3763960",
    "end": "3769079"
  },
  {
    "text": "and one table on the right so we'll inject whatever the thing was to tag whether it came from the left table or",
    "start": "3769079",
    "end": "3774599"
  },
  {
    "text": "the right table append these run them through my discriminator I'm going to get two I'm",
    "start": "3774599",
    "end": "3782520"
  },
  {
    "text": "going to get um however many equivalence classes and in each one of them I'm going to have all my lefts before all my",
    "start": "3782520",
    "end": "3787640"
  },
  {
    "text": "rights so I can just take all the lefts then deal with all the rights take the cross product within",
    "start": "3787640",
    "end": "3793440"
  },
  {
    "text": "each one of these sections and I'll spit out the result and I will take no more time than it takes to touch all the",
    "start": "3793440",
    "end": "3800720"
  },
  {
    "text": "inputs and all the outputs so that's the linear time join um",
    "start": "3800720",
    "end": "3807680"
  },
  {
    "text": "implementations and then the um the key here is that what I'm looking for is",
    "start": "3807680",
    "end": "3812960"
  },
  {
    "text": "this notion of a productive stable unordered discriminator okay um it needs a better",
    "start": "3812960",
    "end": "3818960"
  },
  {
    "text": "version of grouping net it needs a better version of divide uh likely needs a different encoding um it does look",
    "start": "3818960",
    "end": "3824880"
  },
  {
    "text": "promising that you could do something with like a custom St like calculation that can produce lazily driven IO Ivars",
    "start": "3824880",
    "end": "3830960"
  },
  {
    "text": "or something like that um but ultimately discrimination gives",
    "start": "3830960",
    "end": "3836839"
  },
  {
    "text": "us a whole bunch of things in O for a whole bunch of different types that you wouldn't expect and um the code is online I'll",
    "start": "3836839",
    "end": "3844640"
  },
  {
    "text": "throw it on hackage as soon as I actually can resolve that productivity argument or as soon as I give up and uh",
    "start": "3844640",
    "end": "3852079"
  },
  {
    "text": "help me get there so thank you [Applause]",
    "start": "3852079",
    "end": "3858950"
  }
]