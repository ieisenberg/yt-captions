[
  {
    "start": "0",
    "end": "29000"
  },
  {
    "text": "Hello, and welcome to another episode of \"GOTO \nUnscripted.\" My name is Bert Jan Schrijver. I'm   CTO at OpenValue. And I'm here at GOTO \nAmsterdam, together with Alina  Yurenko. ",
    "start": "14040",
    "end": "24280"
  },
  {
    "text": "Hi, everyone. My name is Alina Yurenko, \nand I work as a developer advocate   for GraalVM at Oracle Labs.\nSo, let's talk about GraalVM,  ",
    "start": "24280",
    "end": "30919"
  },
  {
    "start": "29000",
    "end": "98000"
  },
  {
    "text": "Alina Yurenko. Well, what is Graal, what is \nGraalVM? Can you explain it in maybe 10 sentences?  Ten sentences? Okay. That will be challenging \nbecause GraalVM is so many things, and in a way,  ",
    "start": "30920",
    "end": "41040"
  },
  {
    "text": "it's a nice challenge to have, right? But also, \nthen, it makes it kind of hard to explain to   people what is it. But I would divide it \ninto three parts. So, one is GraalVM is  ",
    "start": "41040",
    "end": "51960"
  },
  {
    "text": "a high-performance JDK. So, it's a JDK like any \nother JDK you might be using, like OpenJDK. It has  ",
    "start": "51960",
    "end": "57760"
  },
  {
    "text": "the same HotSpot VM, but we replaced the compiler \nwith our own Graal compiler. So, that's one part  ",
    "start": "57760",
    "end": "63399"
  },
  {
    "text": "of the story, is that you can use it as a JDK, \nto run your applications with the java command,   as you normally do. Then there is another big \npart of the story, and that is native image,  ",
    "start": "63400",
    "end": "71320"
  },
  {
    "text": "and that is this ahead-of-time compilation \nof Java applications, that produces native   executables that can run without a JVM. So, that \nis also GraalVM. And last but not least, people  ",
    "start": "71320",
    "end": "81240"
  },
  {
    "text": "also call it a polyglot VM, because, in addition \nto Java, and all those traditional JVM languages,   Scala, Kotlin, it can also run JavaScript, Python, \nor even your custom language. So, three things,  ",
    "start": "81240",
    "end": "93360"
  },
  {
    "text": "but in a nutshell, it's a high-performance \nvirtual machine for many languages. Okay. Well, so, I've been doing Java development \nfor a while. I know where I can get my JDK or JVM.  ",
    "start": "93360",
    "end": "103320"
  },
  {
    "start": "98000",
    "end": "595000"
  },
  {
    "text": "Why should I use GraalVM instead of another VM?\nThere can be so many reasons why you could be  ",
    "start": "103320",
    "end": "110360"
  },
  {
    "text": "using GraalVM instead of any other VM. So, \none thing is that you can use it as a JDK,  ",
    "start": "110360",
    "end": "116320"
  },
  {
    "text": "right? So, just run your code on a JVM with \njust-in-time compilation. The reason to do so is  ",
    "start": "116320",
    "end": "122800"
  },
  {
    "text": "that workloads, some workloads, many of them, will \nsee speed-up just by switching to GraalVM as a JDK  ",
    "start": "122800",
    "end": "129320"
  },
  {
    "text": "because we have this new compiler. It cannot give \nyou a specific number for the speed-up that any  ",
    "start": "129320",
    "end": "136560"
  },
  {
    "text": "random application in the world will see, because \nit highly depends on what the application does,   what dependencies it's using, how it's written, \netc. But I do recommend always at least checking  ",
    "start": "136560",
    "end": "145840"
  },
  {
    "text": "out GraalVM as a JDK. So, that's one reason to use \nit over any other JDK. But I think the area where  ",
    "start": "145840",
    "end": "152400"
  },
  {
    "text": "we see a lot of interest is a native image, \nand the way to build your Java applications   as a native executable, that no longer needs \nJVM to run. And the reason to do so, I mean,  ",
    "start": "152400",
    "end": "163080"
  },
  {
    "text": "sometimes people ask us, but why give up \nJVM, because it gives us so many benefits?   And it does. But also, it's just another way \nto deploy and build your Java applications. So,  ",
    "start": "163080",
    "end": "173040"
  },
  {
    "text": "maybe if you care a bit more about startup, memory \nusage, about these kinds of things, then the  ",
    "start": "173040",
    "end": "178760"
  },
  {
    "text": "native image would be a way to go.\nWell, I have a lot of questions about   native images, but...\nI had no doubt. ",
    "start": "178760",
    "end": "184680"
  },
  {
    "text": "...first, let's dive into the VM part a bit. So, \ncould you say that it's a drop-in replacement for   any VM where I'm running my current Java code on?\nAbsolutely. So, migration there is very easy.  ",
    "start": "184680",
    "end": "194760"
  },
  {
    "text": "You just replace your JDK with GraalVM, you \npoint your JAVA_HOME to GraalVM distribution,   and you run applications as-is. So, you have all \nyour libraries, tools, IDEs, etc., available to  ",
    "start": "194760",
    "end": "205040"
  },
  {
    "text": "you. There are some minor limitations. I think \nmost users would not necessarily notice them. But,   for example, implementing additional GC on \na new compiler is not easy, because there  ",
    "start": "205040",
    "end": "215959"
  },
  {
    "text": "is this connection between the compiler and the \nGC. So, maybe if you want to use some custom GC,   that would be not trivial. But other than \nthat, I would say 99.9% of users can easily  ",
    "start": "215960",
    "end": "227160"
  },
  {
    "text": "migrate in a matter of minutes to GraalVM.\nAnd you mentioned that, well, you probably  ",
    "start": "227160",
    "end": "232320"
  },
  {
    "text": "notice performance improvements, right? You \nalso mentioned the JIT, the just-in-time   compilation. So, are those improvements \ncoming from better JIT and optimization,  ",
    "start": "232320",
    "end": "241200"
  },
  {
    "text": "or why is GraalVM faster than an average JDK?\nI like how you said the GraalVM is faster  ",
    "start": "241200",
    "end": "247520"
  },
  {
    "text": "than the average JDK. I mean, I do agree \nbut notice that I did not say that. You   said that, so thank you for that.\nI'm just making it up for you. ",
    "start": "247520",
    "end": "254720"
  },
  {
    "text": "I appreciate it. Yeah. So, those speedups are \ncoming from the compiler itself, indeed, because  ",
    "start": "254720",
    "end": "259799"
  },
  {
    "text": "the only thing we are replacing in HotSpot VM if \nyou're operating in the just-in-time compilation   mode, is the compiler. But the compiler is very \ngood. It's brand-new. It has tons of optimizations  ",
    "start": "259800",
    "end": "269240"
  },
  {
    "text": "that are implemented in it from scratch. And \nbecause of all those reasons, and because of   those optimizations, we see many applications and \nmany workloads running faster on GraalVM, even as  ",
    "start": "269240",
    "end": "280759"
  },
  {
    "text": "JIT. I think one of the latest such stories, at \nleast that I can recall, is from Facebook. And  ",
    "start": "280760",
    "end": "286400"
  },
  {
    "text": "they moved some of, I think it was data-intensive \napps to GraalVM, and they saw something like, I  ",
    "start": "286400",
    "end": "291919"
  },
  {
    "text": "think, a 10% speedup just by switching to GraalVM. \nSo, they didn't do native images. They didn't do  ",
    "start": "291920",
    "end": "297040"
  },
  {
    "text": "any of that, just switched to GraalVM as a JDK.\nOkay. Interesting. I think you also read or  ",
    "start": "297040",
    "end": "302720"
  },
  {
    "text": "heard somewhere that you can also \nuse GraalVM in an Oracle Database.   Am I correct, or did I get fooled somewhere?\nNo, no, no. That's very true. I like this question  ",
    "start": "302720",
    "end": "312720"
  },
  {
    "text": "because I don't get asked about it a lot. So, as \nyou mentioned, you have a lot of questions about   native images, and people usually have a lot of \nquestions about native images. But this use case,  ",
    "start": "312720",
    "end": "320680"
  },
  {
    "text": "in an Oracle Database, is so cool. So, the way \nit works is that we have kind of an embedding of  ",
    "start": "320680",
    "end": "325800"
  },
  {
    "text": "GraalVM in the Oracle Database. And it can \nexecute other languages. So, the languages  ",
    "start": "325800",
    "end": "331039"
  },
  {
    "text": "that we call GraalVM languages, are the ones \nimplemented on top of GraalVM. And at the moment,  ",
    "start": "331040",
    "end": "336560"
  },
  {
    "text": "I think the only one available is JavaScript. So, \nyou can execute that right in the Database, so you  ",
    "start": "336560",
    "end": "342440"
  },
  {
    "text": "don't need to kind of extract the data, move it \nsomewhere, process it, put it back. And another  ",
    "start": "342440",
    "end": "348120"
  },
  {
    "text": "benefit is that you can leverage the ecosystem \nof all those, I don't know, millions of packages   that are available in the JavaScript ecosystem, \nand you can execute that right in your database. ",
    "start": "348120",
    "end": "359639"
  },
  {
    "text": "For example, maybe you want to validate some, I \ndon't know, email that it's indeed a valid email,   and you can use whatever the JavaScript library \nis being used for that. And the part I like is  ",
    "start": "359640",
    "end": "369720"
  },
  {
    "text": "that it's a kind of project that shows the kind \nof value of GraalVM as an ecosystem. Because,  ",
    "start": "369720",
    "end": "375240"
  },
  {
    "text": "in this case, for example, it's an implementation \nof JavaScript. So, the JavaScript component in   GraalVM, and then it's built on top of Truffle, \nwhich is our language implementation framework.  ",
    "start": "375240",
    "end": "385200"
  },
  {
    "text": "And the way it is embedded in Oracle \nDatabase is through native image. So,  ",
    "start": "385200",
    "end": "390400"
  },
  {
    "text": "the way I understand it, the native image was \nused to build a shared library of this kind   of execution engine. Then it was embedded in \nthe Oracle Database as a shared library. But  ",
    "start": "390400",
    "end": "401280"
  },
  {
    "text": "it's kind of cool that GraalVM's native image \nis being used to embed something like GraalVM  ",
    "start": "401280",
    "end": "406480"
  },
  {
    "text": "in the database. So, I think it's very cool.\nShould I compare this with, for example, having a   stored procedure, with SQL, in a database, and now \nbeing able to run any JavaScript code as a part of  ",
    "start": "406480",
    "end": "417160"
  },
  {
    "text": "a query or something? How would this work?\nTo be honest, I haven't looked at that in   a while. I know that you can indeed execute \nJavaScript code right in there. But in terms  ",
    "start": "417160",
    "end": "426360"
  },
  {
    "text": "of other limitations and how it compares \nto running stored procedures, to be honest,   I wouldn't know. Maybe we should write a new blog \npost and give an update on how it works at the  ",
    "start": "426360",
    "end": "435520"
  },
  {
    "text": "moment. Maybe there are some limitations, but last \ntime I checked, I think it kind of just worked. ",
    "start": "435520",
    "end": "440960"
  },
  {
    "text": "Well, it's not something I would envision doing, \nexecuting JavaScript in Oracle Database, right?  I mean, it sounds a bit crazy, I must say, \nbut also I think it opens a possibility  ",
    "start": "440960",
    "end": "449840"
  },
  {
    "text": "to use all those JavaScript tools and, \nlike, JavaScript itself as a language,   in a database. But I think it's nice to just \nhave more options and access to more tools. ",
    "start": "449840",
    "end": "457319"
  },
  {
    "text": "Especially if you can execute logic close to \nthe data, right? You don't need to fetch it   over a network boundary. So, that's interesting.\nAbsolutely.",
    "start": "457320",
    "end": "464180"
  },
  {
    "text": "Okay. So, well, before we talk about native \nimages, I think I read there's a community  ",
    "start": "464180",
    "end": "471199"
  },
  {
    "text": "edition and a commercial edition of GraalVM. \nWhat is the difference of those? Why would   somebody be inclined to go for the commercial \nedition compared to the community edition? ",
    "start": "471200",
    "end": "480360"
  },
  {
    "text": "So, there are indeed two editions. One is \nCommunity Edition, and it's open source. All   our source code is available on GitHub. Anyone \ncan contribute. Anyone is welcome to contribute.  ",
    "start": "480360",
    "end": "489400"
  },
  {
    "text": "A fun fact, I don't know how to validate that, \nbut somebody said to me that GraalVM might be   one of the biggest Java open-source projects out \nthere because it's indeed huge as a project. So,  ",
    "start": "489400",
    "end": "499080"
  },
  {
    "text": "there's the compiler, this language implementation \nframework, and all the language implementations.   So, I don't know if that's true or not, but it \nsounds pretty cool that it might be one of the  ",
    "start": "499080",
    "end": "507440"
  },
  {
    "text": "biggest open-source Java projects out there. So, \nthat is the Community Edition, and we have one  ",
    "start": "507440",
    "end": "512640"
  },
  {
    "text": "more. It used to be called Enterprise Edition, \nbut now, with the latest release of GraalVM,  ",
    "start": "512640",
    "end": "518000"
  },
  {
    "text": "we have a brand-new distribution of GraalVM, \ncalled Oracle GraalVM. And I guess you can  ",
    "start": "518000",
    "end": "525280"
  },
  {
    "text": "compare it to a commercial edition. So, it's \navailable under a free license, meaning you  ",
    "start": "525280",
    "end": "531440"
  },
  {
    "text": "can use all the features that are in that edition \nfor development, for production, and basically all  ",
    "start": "531440",
    "end": "536760"
  },
  {
    "text": "kinds of things, for free, under this new license.\nThe differences between those editions are, well,  ",
    "start": "536760",
    "end": "544960"
  },
  {
    "text": "A, a license, right? So, one is open source \nand the one is this GFTC license. But also  ",
    "start": "544960",
    "end": "550000"
  },
  {
    "text": "some features are available in Oracle GraalVM that \nare not available in Community. And the features,  ",
    "start": "550000",
    "end": "556520"
  },
  {
    "text": "I think the most interesting of them, at least, \nare around performance, and more specifically,   performance in native image. So, in the native \nimage, you now get access to profile-guided  ",
    "start": "556520",
    "end": "566480"
  },
  {
    "text": "optimizations. And maybe we can stop on that \nwhen we talk about native images in more   detail. You get G1 GC in the native image. \nAnd, going back to this JDK JIT use case,  ",
    "start": "566480",
    "end": "578520"
  },
  {
    "text": "outside of the native image, it can also be \ninteresting for users, because the compiler   itself has more optimization phases in this \nkind of commercial addition. So, even if you're  ",
    "start": "578520",
    "end": "588440"
  },
  {
    "text": "running on a JIT, JDK, you might see more \nperformance, hopefully, with this edition.",
    "start": "588440",
    "end": "594560"
  },
  {
    "text": "Okay. Well, let's talk about native images. \nThe first time I heard about this was, I think,   I don't know, about four, five years ago.\nQuite a while. Was it from Oleg, or Thomas, or  ",
    "start": "594560",
    "end": "604080"
  },
  {
    "start": "595000",
    "end": "897000"
  },
  {
    "text": "Yes, probably. \nOkay.  And then, well, what are they? You can take \na piece of Java code, perform some magic  ",
    "start": "604080",
    "end": "613160"
  },
  {
    "text": "compilation on it, to some target platform, and \nthen there's a native binary that runs on this   target platform, right? So, what is native image \ncompilation, and why should anyone want to do it? ",
    "start": "613160",
    "end": "625280"
  },
  {
    "text": "It's very interesting. To be honest, the first \ntime I read about it, my mind was blown that   something like that is even possible, right? \nYou all know that Java is so dynamic, and it's  ",
    "start": "625280",
    "end": "633839"
  },
  {
    "text": "so powerful because it's so dynamic. So, how do \nyou compile something like Java ahead of time?  ",
    "start": "633840",
    "end": "639640"
  },
  {
    "text": "Because it certainly poses certain limitations, \nbecause if you're doing things ahead of time,   you need to know everything in advance. So, before \nI go into this idea behind native image, maybe I  ",
    "start": "639640",
    "end": "650760"
  },
  {
    "text": "should explain how it works at all. So, when \nyou run a native image build command, and give  ",
    "start": "650760",
    "end": "656320"
  },
  {
    "text": "it your application, what happens is that native \nimage looks at your application, starting from its  ",
    "start": "656320",
    "end": "662080"
  },
  {
    "text": "main entry point, and it's trying to find all the \nreachable code. So, all the code will be executed  ",
    "start": "662080",
    "end": "668560"
  },
  {
    "text": "when your application runs. It tries to find all \nof that code, and that includes your application  ",
    "start": "668560",
    "end": "673640"
  },
  {
    "text": "code, JDK classes, your dependencies, everything. \nIt's looking for all the reachable code so that   it can include only that reachable code in the \nproduced executable, and then eliminate everything  ",
    "start": "673640",
    "end": "684519"
  },
  {
    "text": "else. So, only the things that you need at \nruntime, only the things that are needed for your  ",
    "start": "684520",
    "end": "689840"
  },
  {
    "text": "application to do what it's supposed to do, only \nthose things will be included in this executable. ",
    "start": "689840",
    "end": "694960"
  },
  {
    "text": "So, that is one part of the native image \nstory. Another one, as it's doing so, it's also   preparing a heap for you. So, you can start with \na prepopulated heap and don't spend time working  ",
    "start": "694960",
    "end": "705600"
  },
  {
    "text": "with that heap when your application starts. But, \nsince we're doing all of this ahead of time, it  ",
    "start": "705600",
    "end": "711959"
  },
  {
    "text": "has to happen under closed-world assumptions. So, \neverything there is to know about your application  ",
    "start": "711960",
    "end": "717520"
  },
  {
    "text": "needs to be known ahead of time, when we are \nbuilding your application because otherwise,   we just cannot perform this ahead-of-time \ncompilation. Because we are compiling things  ",
    "start": "717520",
    "end": "725680"
  },
  {
    "text": "ahead of time, and also we are eliminating all \nof this code, loading, execution, and profiling  ",
    "start": "725680",
    "end": "731560"
  },
  {
    "text": "infrastructure from your application. So, in \nthe end, it's only machine code and only the  ",
    "start": "731560",
    "end": "736640"
  },
  {
    "text": "things that are needed for your application \nto run. Plus, tiny, slim VM implementation,  ",
    "start": "736640",
    "end": "742080"
  },
  {
    "text": "but it's not a full-blown code execution \ninfrastructure anymore. That is so that your   application is more lightweight, faster to start, \nscales better, and doesn't use as much memory. So,  ",
    "start": "742080",
    "end": "752760"
  },
  {
    "text": "this closed-world assumption poses certain \nchallenges. But another way to look at it,  ",
    "start": "752760",
    "end": "757200"
  },
  {
    "text": "it's a different design decision, and \nalong with challenges, I think it brings   some important benefits. So, all those startup \nmemories, etc., that native image is famous for,  ",
    "start": "757960",
    "end": "767480"
  },
  {
    "text": "but also some interesting security benefits \nthat maybe we can also talk about further  ",
    "start": "767480",
    "end": "772800"
  },
  {
    "text": "Sure.\nSo, yeah. Ahead-of-time   compilation under closed-world assumption.\nSo, just to validate that I've understood  ",
    "start": "773360",
    "end": "778800"
  },
  {
    "text": "you correctly, right? So, if I'm \nrunning traditional Java code,   I'm compiling my Java code to a bytecode, and \nthen I run this bytecode on a virtual machine,  ",
    "start": "778800",
    "end": "787959"
  },
  {
    "text": "and then the just-in-time compilation, translate \nthis bytecode to machine code, runs on my target   platform, right? So, if I'm building a native \nimage, I'm still compiling, probably still  ",
    "start": "787960",
    "end": "797360"
  },
  {
    "text": "compiling my Java code to bytecode first, right?\nAbsolutely. And that's the part I'm always   skipping, because, for me, compiler, it's always \nthe optimizing compiler. That's my bias because I  ",
    "start": "797360",
    "end": "807040"
  },
  {
    "text": "work on GraalVM, but indeed, you need to provide \nyour application to native image in the form of  ",
    "start": "807040",
    "end": "812720"
  },
  {
    "text": "bytecode, so you need to use javac to produce that \nfor bytecode, because as input, it takes bytecode. ",
    "start": "812720",
    "end": "818360"
  },
  {
    "text": "So, then, the native image compilation \nprocess takes the bytecode, and then   there's ahead-of-time compilation to create a \nmachine code for a specific target platform... ",
    "start": "818360",
    "end": "827519"
  },
  {
    "text": "Right.\n...right? So... Well, I...  But if I can stop there, because you brought \nan interesting point about how JVM actually  ",
    "start": "827520",
    "end": "833320"
  },
  {
    "text": "executes code, right? So, just to compare \nhow is that different from native image. So,   the way JVM executes code is \nthat when you run application,  ",
    "start": "833320",
    "end": "841400"
  },
  {
    "text": "it will need to load all your classes, look \nat them, start interpreting, start compiling,  ",
    "start": "841400",
    "end": "847000"
  },
  {
    "text": "start collecting profile information. And all of \nthat is very impressive work that it does, to get  ",
    "start": "847000",
    "end": "852400"
  },
  {
    "text": "the application to that peak performance. But it \nalso comes with certain challenges around startup,  ",
    "start": "852400",
    "end": "859560"
  },
  {
    "text": "especially if you have a larger application, \nright? Because it's a lot of work to be done   when a JVM starts, and needs to warm up and \ncompile your code, and understand everything  ",
    "start": "859560",
    "end": "868160"
  },
  {
    "text": "about your application. So, over time, when it \nwarms up, it does come to great peak performance,  ",
    "start": "868160",
    "end": "873639"
  },
  {
    "text": "but there is a bit of this overhead that you're \npaying in the beginning, when it has to do all   this work. And the idea of native image is \nto move all of that overhead to build time,  ",
    "start": "873640",
    "end": "882920"
  },
  {
    "text": "so that you can build it once, but then start fast \nas many times as you need. Because most likely,  ",
    "start": "882920",
    "end": "889200"
  },
  {
    "text": "application will be started more often than it's \nbuilt. So, in my opinion, it kind of makes sense   to move all of that to build time, and then \njust start when you actually need to start.",
    "start": "889200",
    "end": "897520"
  },
  {
    "start": "897000",
    "end": "1032000"
  },
  {
    "text": "But it also sounds difficult, right? Because, \nwell, JIT compilation analyzes code as it runs  ",
    "start": "897520",
    "end": "903160"
  },
  {
    "text": "over time, and then tries to optimize this code \nfor how it is run or actually being used. Whereas   if you do ahead-of-time compilation, you don't \nactually know yet what the use case for this  ",
    "start": "903160",
    "end": "911560"
  },
  {
    "text": "code are going to be, right? So, well, how is \nit even possible, and how can you get the same,  ",
    "start": "911560",
    "end": "917360"
  },
  {
    "text": "well, or even better performance compared to \nanalyzing something that's running and then   optimizing for the stuff that's running?\nThat's an excellent question, and yeah,  ",
    "start": "917360",
    "end": "926320"
  },
  {
    "text": "the reason why JVM is so powerful is this dynamic \ncode execution, right? It looks at the application  ",
    "start": "926320",
    "end": "932440"
  },
  {
    "text": "on the go, and it adapts to what the application \nis doing and what is happening at runtime. It can  ",
    "start": "932440",
    "end": "939120"
  },
  {
    "text": "adapt on the go. So, it can make very aggressive \noptimizations about your code. And then if those  ",
    "start": "939120",
    "end": "945560"
  },
  {
    "text": "assumptions that it made about your code are \nno longer valid, it can deoptimize, go back to   interpret it, and if it runs up again, go back to \ncompile. But it has this flexibility to adapt on  ",
    "start": "945560",
    "end": "956120"
  },
  {
    "text": "the go to what your application does, right? And \nthis is really fascinating about JVM, right? So,   how it goes from interpreted to compiled, and then \nhow it can go back, it's really fascinating. And,  ",
    "start": "956120",
    "end": "966279"
  },
  {
    "text": "indeed, native image doesn't have that luxury of \nadapting on the go, or even being aware of what  ",
    "start": "966280",
    "end": "972360"
  },
  {
    "text": "your application does at runtime. But that's by \ndefault. So, what is very cool about native image  ",
    "start": "972360",
    "end": "978320"
  },
  {
    "text": "is that you can use profile-guided optimizations, \nand that is optimization that allows you to build  ",
    "start": "978320",
    "end": "984880"
  },
  {
    "text": "an instrumented binary of your app, then run it, \napplying relevant workload, so that native image  ",
    "start": "984880",
    "end": "990800"
  },
  {
    "text": "can look at your app, see what it does, collect \nthis profile information, and then when you are  ",
    "start": "990800",
    "end": "995839"
  },
  {
    "text": "building again a native executable of your \napp, you can use this profile information to  ",
    "start": "995840",
    "end": "1001160"
  },
  {
    "text": "kind of get insight into the future, so, into \nwhat your app will actually do at runtime, and  ",
    "start": "1001160",
    "end": "1006360"
  },
  {
    "text": "build an application with those profiles in mind.\nAh. So, you're basically using runtime profiling  ",
    "start": "1006360",
    "end": "1011720"
  },
  {
    "text": "information...\nAbsolutely.  ...to feed into your ahead-of-time compilation, \nto make it smarter and give it more context. ",
    "start": "1011720",
    "end": "1017160"
  },
  {
    "text": "And I think it's pretty cool, because, in a way, \nyou get best of the both worlds. So, you can  ",
    "start": "1017160",
    "end": "1022279"
  },
  {
    "text": "optimize application ahead of time. You don't need \nto spend time on that in runtime, but also you get  ",
    "start": "1022280",
    "end": "1028199"
  },
  {
    "text": "insight and understanding into runtime behavior \nof your app. So, I think that's pretty cool.",
    "start": "1028200",
    "end": "1033360"
  },
  {
    "start": "1032000",
    "end": "1413000"
  },
  {
    "text": "So, with AOT, you're basically moving whatever \nthe JIT is doing on a JVM to compile time,  ",
    "start": "1033360",
    "end": "1038439"
  },
  {
    "text": "right? So, your compilation will take longer, \nbut in the end, the startup time probably,   and maybe even run time, will take \nshorter. So, what are typical benefits of,  ",
    "start": "1038440",
    "end": "1047079"
  },
  {
    "text": "why should I want to run my Java app as a native \nimage? Like, resource usage, or performance,  ",
    "start": "1047080",
    "end": "1054840"
  },
  {
    "text": "or startup time? Why should I want to do it?\nThe first benefit people usually bring up is  ",
    "start": "1054840",
    "end": "1060640"
  },
  {
    "text": "startup time because it's indeed much faster \non native images. So, it, again, depends a lot  ",
    "start": "1060640",
    "end": "1066240"
  },
  {
    "text": "on the app you have, but, I don't know, out \nof the demos that, for example, I'm showing,  ",
    "start": "1066240",
    "end": "1071679"
  },
  {
    "text": "like, I would say that an average web server \napplication, doesn't matter which framework,  ",
    "start": "1071680",
    "end": "1078040"
  },
  {
    "text": "I would say starts about maybe 400 milliseconds \nin my machine, maybe 200 milliseconds. Then,  ",
    "start": "1078040",
    "end": "1084600"
  },
  {
    "text": "as an native image, it starts in, I \ndon't know, 30, 40 milliseconds. So,   it's order of magnitude faster. And it's indeed \nimpressive, because we don't have to do any of  ",
    "start": "1084600",
    "end": "1092760"
  },
  {
    "text": "those operations anymore at runtime, right? We are \njust loading that executable, it has all the data,  ",
    "start": "1092760",
    "end": "1098080"
  },
  {
    "text": "it can go immediately do whatever it is \nsupposed to do. So, that is startup time,  ",
    "start": "1098080",
    "end": "1103679"
  },
  {
    "text": "and it's indeed really great, especially for, you \nknow, microservices and serverless application,   things like that. So, that's one big benefit. \nI think everyone always brings that one first. ",
    "start": "1103680",
    "end": "1112680"
  },
  {
    "text": "But I would argue startup time is great, but I \nwould maybe care a bit more about resources usage,  ",
    "start": "1112680",
    "end": "1118680"
  },
  {
    "text": "especially, again, if I deploy into the cloud \nand I'm paying for all those resources, so, CPU,   memory, etc., that I'm using. So, if I can do \nthe same thing, have the app do the same thing,  ",
    "start": "1118680",
    "end": "1129040"
  },
  {
    "text": "but use less resources, that probably will be \npreferable, because I would pay less. Maybe I  ",
    "start": "1129040",
    "end": "1134480"
  },
  {
    "text": "can deploy more apps at the memory usage of my \nprevious application. And that's pretty cool.  ",
    "start": "1134480",
    "end": "1143000"
  },
  {
    "text": "And I think I recall this demo that Josh \nLong did, I think it was Devoxx Belgium,   where he had a Spring Boot app running on the JVM, \nand then he compiled it to native, and he showed  ",
    "start": "1143000",
    "end": "1152200"
  },
  {
    "text": "the memory usage of the process, and it went \ndown to, I think, like, 100 megabytes probably.  ",
    "start": "1152200",
    "end": "1158360"
  },
  {
    "text": "And he said, \"Who in the room here ever deployed \na JVM app that used one gig of memory?\" You know,   many people raised their hands, and he said, \n\"Okay. This shows you that you can deploy 10 such  ",
    "start": "1158360",
    "end": "1167640"
  },
  {
    "text": "apps for the same memory footprint. How cool is \nthat?\" So, I would argue [inaudible 00:19:18] that   that is more even more important. So, you \ncan either reduce your resources, clouds,  ",
    "start": "1167640",
    "end": "1177160"
  },
  {
    "text": "infrastructure usage, or maybe you can deploy more \napps at the runtime impact of your previous app. ",
    "start": "1177160",
    "end": "1185040"
  },
  {
    "text": "I guess with, the startup time only matters \nif you're in a scale-back-to-zero situation,   right? Like, serverless or whatever, and when \nthe user needs to wait for the app to start up,  ",
    "start": "1185040",
    "end": "1194520"
  },
  {
    "text": "obviously, then startup time matters. But \nfor a typical enterprise-y app that runs   for weeks or months, then the startup \ntime doesn't really matter, I guess. ",
    "start": "1194520",
    "end": "1202799"
  },
  {
    "text": "Probably not that much. Probably indeed more \nfor microservices and serverless applications.  ",
    "start": "1202800",
    "end": "1207200"
  },
  {
    "text": "So, if I have a JVM-based application, then \nI need to have a, well, a JRE running on my  ",
    "start": "1208840",
    "end": "1216080"
  },
  {
    "text": "machine. I need to deploy my code there, \nand then running, and it will start up,   start reading my classes, and will start \nthe JIT process. Do I still need a JDK on  ",
    "start": "1216080",
    "end": "1226120"
  },
  {
    "text": "my target machine if I build a native image, \nor is it all packaged in? How does this work?  So, you mean if you want to deploy \nyour application as a native image,  ",
    "start": "1226120",
    "end": "1233240"
  },
  {
    "text": "do you need a JDK again or not?\nOn the target server I'm deploying to.  No. So, the target server doesn't need to have \nanything at all. So, if you are... But you need,  ",
    "start": "1233240",
    "end": "1242160"
  },
  {
    "text": "as you mentioned, you need to build for the \ntarget platform and architecture, right? So,   if you have such an opportunity, I don't know \nif you're building on a Linux machine and you're  ",
    "start": "1242160",
    "end": "1249880"
  },
  {
    "text": "deploying to a Linux machine, that machine that \nyou're deploying to doesn't need to have anything,  ",
    "start": "1249880",
    "end": "1255600"
  },
  {
    "text": "because it's a native app in the end, right? So, \nit just runs fully functional, and so on. And  ",
    "start": "1255600",
    "end": "1261360"
  },
  {
    "text": "then there are ways to build native images in \na fully static way, where all the dependencies  ",
    "start": "1261360",
    "end": "1268520"
  },
  {
    "text": "are included in the static native image.\nSo, I would still need a JDK for building   and compiling it?\nBut for developing,  ",
    "start": "1268520",
    "end": "1274960"
  },
  {
    "text": "you probably would need a JDK anyway.\nBut in the end, since you're going   straight to machine code, you can \ndeploy the machine code. Okay. So,  ",
    "start": "1274960",
    "end": "1281560"
  },
  {
    "text": "probably that would save you on some \ndisk space as well, compared to… We talked about startup, we talked about memory, \nobviously, packaging size is another benefit,  ",
    "start": "1281560",
    "end": "1291040"
  },
  {
    "text": "right, but saving disk space per se, but also \nscaling, right? So, if you want to scale your  ",
    "start": "1291040",
    "end": "1296240"
  },
  {
    "text": "deployments, that maybe smaller images would \nalso matter to you. And we can probably talk   about performance, but that will be, I guess, \na big topic. So, before we go into that,  ",
    "start": "1296240",
    "end": "1305520"
  },
  {
    "text": "there's also very interesting security benefits \naround native image. And I like talking about it   because I think people don't talk about it \nenough, and they are always very surprised  ",
    "start": "1305520",
    "end": "1313640"
  },
  {
    "text": "when they talk about security in native image. \nBut it's indeed very interesting. So, all those   things we talked about, native image and the build \nprocess, and how, in a way, it can seem limiting. ",
    "start": "1313640",
    "end": "1323600"
  },
  {
    "text": "I think it shines in a whole different way when \nwe talk about security, because A, native image  ",
    "start": "1323600",
    "end": "1329360"
  },
  {
    "text": "eliminates all code that you're not using. So, \nlet's say you're pulling in tons of dependencies,   and maybe you're not using them that much, or \nsome dependency looks kind of suspicious to you,  ",
    "start": "1329360",
    "end": "1338280"
  },
  {
    "text": "but you still want to use, like, a fraction of \nit. So, native image will eliminate everything   you're not using. And that's one way how it \nreduces attack surface. And also, for example,  ",
    "start": "1338280",
    "end": "1351000"
  },
  {
    "text": "some vector attacks around just-in-time code \ncompilation are not, just, not possible in native   image because there is no longer code compilation \nhappening at all. And also, at runtime, you cannot  ",
    "start": "1351000",
    "end": "1363240"
  },
  {
    "text": "load new classes, you cannot do reflection and \nserialization unless you specifically enabled it.  ",
    "start": "1363240",
    "end": "1371080"
  },
  {
    "text": "And it can be seen as a limitation, but also you \nhave a bit more fine-grade control over your app,  ",
    "start": "1371080",
    "end": "1376919"
  },
  {
    "text": "and what it does, and what is happening in \nit. Because if you want to do the reflection,   you would need to specify it, or the specification \nneeds to be coming from framework library, etc.,  ",
    "start": "1376920",
    "end": "1386200"
  },
  {
    "text": "but there are no kind of sketchy things happening \nwithout you being aware of it. So, there are also  ",
    "start": "1386200",
    "end": "1391559"
  },
  {
    "text": "some interesting benefits around security too.\nSo, you probably won't have any issues   regarding to dynamic class loading, \nreflection, serialization, because,  ",
    "start": "1391560",
    "end": "1399679"
  },
  {
    "text": "well, it's just not there, then, right?\nOr, it's there, but it has been specifically  ",
    "start": "1399680",
    "end": "1405040"
  },
  {
    "text": "configured and allowed by you. So, you need to \nenable those things for them to work. So, yeah,  ",
    "start": "1405040",
    "end": "1410760"
  },
  {
    "text": "it won't be happening without you being aware.\nDoes GraalVM support Reflection?  So, how about reflection? Let's say I'm \ndynamically loading some classes in my Java  ",
    "start": "1410760",
    "end": "1418800"
  },
  {
    "start": "1413000",
    "end": "1549000"
  },
  {
    "text": "code. There's probably no dynamic class loader in \nthe native image, right? So, how do you do this? ",
    "start": "1418800",
    "end": "1424520"
  },
  {
    "text": "So, reflection works in a way that...I mean, \nthere was this huge misconception that GraalVM  ",
    "start": "1424520",
    "end": "1429920"
  },
  {
    "text": "doesn't support reflection. So, hopefully, \nwe have passed that, and anyone knows that it   supports reflection, but there are things to \nbe aware of. So, there are multiple ways how  ",
    "start": "1429920",
    "end": "1438399"
  },
  {
    "text": "reflection can happen in native image. A, if your \nframework library, etc., are doing something that  ",
    "start": "1438400",
    "end": "1444800"
  },
  {
    "text": "has to do with reflection, they would need \nto provide configuration for native image,   to tell native image that, \"Hey, we want to use \nreflection in this and that class.\" Maybe we want  ",
    "start": "1444800",
    "end": "1453440"
  },
  {
    "text": "to access, for example, this field, so that has \nto be specified in a config file that is being  ",
    "start": "1453440",
    "end": "1458919"
  },
  {
    "text": "fed into native image. And then it can build an \napp that is aware of that reflection usage, and  ",
    "start": "1458920",
    "end": "1464640"
  },
  {
    "text": "can work with that reflection usage. So, that is \none part of how reflection works in native image. ",
    "start": "1464640",
    "end": "1470880"
  },
  {
    "text": "Now, some of, kind of, more predictable reflection \nAPI calls, native image can figure out on its own.  ",
    "start": "1470880",
    "end": "1477040"
  },
  {
    "text": "So, as it is building application, it...calls that \nare a bit more trivial and predictable and make  ",
    "start": "1477040",
    "end": "1482720"
  },
  {
    "text": "sense, native image can figure out on its own, \nso maybe there would be no more configuration   happening from you at all. It can just make it \nwork. And then the last way how this can work is  ",
    "start": "1482720",
    "end": "1493120"
  },
  {
    "text": "that we have this tracing agent in native image. \nAnd you can run your application on the JVM,  ",
    "start": "1493120",
    "end": "1497760"
  },
  {
    "text": "and it will do what it is supposed to do, and \nthis tracing agent will look at that, and it will   produce this config for you, so you don't need \nto produce it manually. But as a last resort,  ",
    "start": "1498400",
    "end": "1508200"
  },
  {
    "text": "if you had to produce it manually, maybe you have \n[inaudible 00:24:56] a smaller app or something,   the reflection config is basically a JSON file \nwhere you specify, in the preselect format, what  ",
    "start": "1508200",
    "end": "1519520"
  },
  {
    "text": "and how you want to use reflectively, and native \nimage can build an app that is aware of that.  So, basically you need to pre-specify \nwhatever your code does reflectively. ",
    "start": "1519520",
    "end": "1530160"
  },
  {
    "text": "Yes. Because, again, closed-world assumption, and \nit gives you all those benefits, but you need to,  ",
    "start": "1530160",
    "end": "1535600"
  },
  {
    "text": "like, for all those dynamic Java features, you \nneed to tell native image how you are planning   to use them, because otherwise, it most \nlikely cannot figure it out automatically  ",
    "start": "1535600",
    "end": "1544120"
  },
  {
    "text": "under closed-world assumption, because \nruntime hasn't happened yet, basically.",
    "start": "1544120",
    "end": "1547680"
  },
  {
    "start": "1549000",
    "end": "1765000"
  },
  {
    "text": "Let's say that I'm now building apps \nthat run on the JVM, and I want to go   into native images. Can I take any random Java \napplication and boom, create a native image of  ",
    "start": "1550520",
    "end": "1561200"
  },
  {
    "text": "it and get all those advantages right away?\nIt depends. It depends on what your app does,  ",
    "start": "1561200",
    "end": "1568000"
  },
  {
    "text": "which dependences it's using, and, again, on \nyour usage of those things like reflection,   serialization, resources, etc. My recommendation \nwould be, is that most likely, you're using some  ",
    "start": "1568000",
    "end": "1577960"
  },
  {
    "text": "kind of framework, and there are many and many \nframeworks in the Java ecosystem that are likely  ",
    "start": "1577960",
    "end": "1583760"
  },
  {
    "text": "supporting native image out of the box. So, \nif you're using something like Spring Boot,   Micronaut, Quarkus, and that's, I would \nsay, a majority of the apps probably,  ",
    "start": "1583760",
    "end": "1594440"
  },
  {
    "text": "have support for native image. So, you would \njust need to check if you are using the version   of the framework, for example, that already \nintroduced support for native image, and then  ",
    "start": "1594440",
    "end": "1603080"
  },
  {
    "text": "things will be significantly easier for you.\nThat is one part of how you can make it happen.  ",
    "start": "1603080",
    "end": "1608320"
  },
  {
    "text": "Another part, if you are not using those \nframeworks, there is also a way to approach  ",
    "start": "1608320",
    "end": "1613600"
  },
  {
    "text": "using dependencies. That is if you want to use \nsome library, and let's say that library is   using reflection, then it's tricky for native \nimage, as we established. So, you can either  ",
    "start": "1613600",
    "end": "1624559"
  },
  {
    "text": "provide configuration for reflection that library \nyourself, but most likely it's challenging because   you're not the maintainer of the library, so \nmaybe you don't know it that well. In that case,  ",
    "start": "1624560",
    "end": "1633280"
  },
  {
    "text": "it's better if the library is providing \nconfiguration for native image within   the library itself, kind of embedded. Luckily, we \nsee a lot of that happening right now. So, if you  ",
    "start": "1633280",
    "end": "1641840"
  },
  {
    "text": "go and check many of libraries, their source \ncode, they already provide configuration for   native image for their users, which is very nice.\nBut also we understand that for some libraries,  ",
    "start": "1641840",
    "end": "1650440"
  },
  {
    "text": "it's maybe a bit more challenging to adopt \nnative image, and they haven't done it yet. So,   for that, we created this centralized repo on \nGitHub, where library and framework authors,  ",
    "start": "1650440",
    "end": "1660480"
  },
  {
    "text": "but also just normal native image users, can \ncontribute, share, and then reuse all this  ",
    "start": "1660480",
    "end": "1667360"
  },
  {
    "text": "configuration for native image. And I think it's \nvery cool because it's indeed maybe you're trying   to solve reflection for library X, but somebody \nelse already had the challenge, and they had  ",
    "start": "1667360",
    "end": "1676120"
  },
  {
    "text": "it solved, so why not share this work in other \ncommunities, so we can all benefit from it? So,  ",
    "start": "1676120",
    "end": "1681520"
  },
  {
    "text": "we have the centralized repo, and it's also \nintegrated with our Maven and Gradle plugins,   and many frameworks picked it up as well. So, \nat the point, it works so well that you can,  ",
    "start": "1681520",
    "end": "1691600"
  },
  {
    "text": "for example, build a native image app, and if \nyou're using those plugins or if you're using one   of those frameworks, that config will be picked \nup automatically, maybe without you being aware  ",
    "start": "1691600",
    "end": "1701640"
  },
  {
    "text": "of it, if you're not looking carefully at the, \nlike, native image build command. So, let's say   you're using, okay, H2 is not necessary because \nit provides config, but let's say you're using  ",
    "start": "1701640",
    "end": "1710840"
  },
  {
    "text": "some library that doesn't provide config, but it \nis in this repo, so our plugins will pull config  ",
    "start": "1710840",
    "end": "1716000"
  },
  {
    "text": "from that repo, and will produce, hopefully, \na fully functional app. So, that should help. ",
    "start": "1716000",
    "end": "1721480"
  },
  {
    "text": "Sure. Okay. So, would you say it's relatively \ndoable to transform a regular Java app into a  ",
    "start": "1721480",
    "end": "1728919"
  },
  {
    "text": "native image nowadays?\nBut again, depends on   what is a regular app, right?\nSure. Yeah. I remember looking  ",
    "start": "1728920",
    "end": "1734240"
  },
  {
    "text": "into this years ago, and it was \npretty hard, but I imagine that's...  It got better now. I would not say that, like, \nevery single Java app in the world will compile to  ",
    "start": "1734240",
    "end": "1743440"
  },
  {
    "text": "native, you know, as you just take it and compile \nit. So, it might or it might not. It depends. So,  ",
    "start": "1743440",
    "end": "1749279"
  },
  {
    "text": "I would not promise you that every single Java \napp in the world would compile to native just   like that. But if you are starting a newer app \nand if you're using one of those frameworks,  ",
    "start": "1749280",
    "end": "1760840"
  },
  {
    "text": "I think it will be optimistic enough \nto say that it should just work. Okay. Good. So, what if somebody who's watching \nwants to get started with GraalVM right away? What  ",
    "start": "1760840",
    "end": "1769480"
  },
  {
    "start": "1765000",
    "end": "1809000"
  },
  {
    "text": "are good resources for them to get started with?\nYes. We have very nice website, graalvm.org. And  ",
    "start": "1769480",
    "end": "1776400"
  },
  {
    "text": "there you can find basically all the things \nyou need. So, we have recommendations,   we have samples, we have reference manuals \nfor things like native image, etc. So,  ",
    "start": "1776400",
    "end": "1785520"
  },
  {
    "text": "probably that would be a good place to start. And \nalso we have this GraalVM demos repo on GitHub,  ",
    "start": "1785520",
    "end": "1790520"
  },
  {
    "text": "where you can just go through our demos and \nbuild them and run them, so you don't need to   create any of that code yourself. If you just \nwant to give GraalVM a try, but you're not  ",
    "start": "1791120",
    "end": "1800279"
  },
  {
    "text": "ready yet to compile your own application, \nyou can just get our demos from GitHub and   compile them, and see how that works for you.\nOkay. Thank you. Well, thanks a lot for your time  ",
    "start": "1800280",
    "end": "1810120"
  },
  {
    "start": "1809000",
    "end": "1841000"
  },
  {
    "text": "and your explanations.\nSure.  I have more knowledge now, but also more \nquestions. I think I need to dive in it myself.  ",
    "start": "1810120",
    "end": "1818600"
  },
  {
    "text": "Well, I hope you learned something in this episode \nof \"GOTO Unscripted.\" So, thanks for watching,   and maybe see you at next edition.\nThank you.",
    "start": "1818600",
    "end": "1827240"
  }
]