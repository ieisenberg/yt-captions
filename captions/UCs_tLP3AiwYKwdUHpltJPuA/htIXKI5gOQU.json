[
  {
    "text": "(upbeat music)",
    "start": "119",
    "end": "2702"
  },
  {
    "text": "- Okay, so this talk, well first, let me start, how many people are familiar\nwith what RxJava is?",
    "start": "9213",
    "end": "16230"
  },
  {
    "text": "How many people currently\nuse it in their app? Okay.",
    "start": "17171",
    "end": "21539"
  },
  {
    "text": "I'm going to start with kind of a little introduction about why\nreactive is becoming",
    "start": "22851",
    "end": "29138"
  },
  {
    "text": "such a big thing on Android, and I'm going to do that\nthrough kind of talking about",
    "start": "29138",
    "end": "34913"
  },
  {
    "text": "some concepts of why we\nneed to think reactively, and then we'll start moving into RxJava, and how it actually helps us\nmodel these things in our apps.",
    "start": "34913",
    "end": "44538"
  },
  {
    "text": "I will specifically be looking\nat examples using RxJava 2, which is coming out in about a month.",
    "start": "44538",
    "end": "52558"
  },
  {
    "text": "All right, so, why is Reactive suddenly becoming\nsomething that, you know, you hear a lot of people talking about,",
    "start": "53498",
    "end": "60010"
  },
  {
    "text": "you see a lot of people starting to use? I'm going to postulate that, unless you can model your entire system",
    "start": "60010",
    "end": "67532"
  },
  {
    "text": "of your app in a synchronous faction, having a single asynchronous source",
    "start": "67532",
    "end": "72957"
  },
  {
    "text": "will ultimately break the traditional imperative style of\nprogramming we're used to,",
    "start": "72957",
    "end": "78382"
  },
  {
    "text": "and that's not break in the\nsense that it stops working, it's break in the sense\nthat it really pushes",
    "start": "78382",
    "end": "84228"
  },
  {
    "text": "a lot of the complexity onto you, and you start losing the things that imperative programming\nis actually really good at.",
    "start": "84228",
    "end": "92489"
  },
  {
    "text": "Let's look at this through an example, to kind of understand why I think this is such a big problem.",
    "start": "93468",
    "end": "100589"
  },
  {
    "text": "Start with a simple class\nthat can get us a user object, and has some mutaters on it.",
    "start": "100589",
    "end": "105983"
  },
  {
    "text": "Now, if we are living\nin a synchronous world, a single threaded world, we\ncan use this totally fine,",
    "start": "105983",
    "end": "111517"
  },
  {
    "text": "and we can rely on it to\nbe exactly as we expect. Create an instance, print out the user,",
    "start": "111517",
    "end": "116754"
  },
  {
    "text": "modify some of its properties,\nprint out the user. This behaves exactly as you would expect.",
    "start": "116754",
    "end": "124139"
  },
  {
    "text": "The problem comes when we have to start modeling things in\nan asynchronous fashion. Let's say that, when we\nchange these properties,",
    "start": "124139",
    "end": "131174"
  },
  {
    "text": "we now need to reflect\nthem on the server side. These bottom two methods now\nneed to become asynchronous.",
    "start": "131174",
    "end": "138140"
  },
  {
    "text": "How would we change our code\nin order to reflect this? One thing you could do is nothing.",
    "start": "139325",
    "end": "145523"
  },
  {
    "text": "You can basically just assume\nthat the asynchronous call to update the server will succeed,",
    "start": "145524",
    "end": "152042"
  },
  {
    "text": "and you can make the change locally, so that it's reflected instantly when we print out the user object.",
    "start": "152042",
    "end": "159798"
  },
  {
    "text": "Obviously, this is not a good idea. Networks are flaky, the\nserver might return an error,",
    "start": "159798",
    "end": "165436"
  },
  {
    "text": "and now you have to reconcile dealing with your state locally. We could do simple things\nlike maybe providing",
    "start": "165436",
    "end": "172511"
  },
  {
    "text": "a runnable that gets called whenever this async call succeeds, and now we are actually\nkind of being reactive,",
    "start": "172511",
    "end": "179897"
  },
  {
    "text": "where we are only updating\nthe data that is displayed when we are ensured that it\nwas asked successfully changed.",
    "start": "179897",
    "end": "187334"
  },
  {
    "text": "However, we aren't modeling\nany problems that could occur, like if the network ends up failing, so maybe we create our own listener,",
    "start": "188399",
    "end": "195241"
  },
  {
    "text": "so when an error actually does happen, we can do something with that, we could report it to the user,\nwe can automatically retry.",
    "start": "195241",
    "end": "204248"
  },
  {
    "text": "Stuff like this works, and\nit's what people usually, the avenue people go\ndown when they need to mix in asynchronous code with code",
    "start": "204248",
    "end": "211734"
  },
  {
    "text": "that's just kind of\nrunning on a single thread, which is traditionally\nan Android main thread, but where the problems start arising",
    "start": "212575",
    "end": "218612"
  },
  {
    "text": "is when you really have to do more, you have to support\nmultiple calls happening,",
    "start": "218612",
    "end": "224164"
  },
  {
    "text": "the user is changing, you know, multiple properties in your\napp while filling out a form,",
    "start": "224164",
    "end": "229665"
  },
  {
    "text": "or maybe there is like flows\nof these asynchronous calls, where the success of the first one",
    "start": "229666",
    "end": "236742"
  },
  {
    "text": "has to then trigger\nanother asynchronous call, which can also succeed, or fail.",
    "start": "236742",
    "end": "242396"
  },
  {
    "text": "We also have to remember that this is in the context of Android, and so there's a lot of\nadditional considerations",
    "start": "243524",
    "end": "249674"
  },
  {
    "text": "that we have to take into account. For example, in our success callback,",
    "start": "249674",
    "end": "255184"
  },
  {
    "text": "maybe we are propagating\ninformation directly into the UI, but I haven't really\ndefined whether or not,",
    "start": "255184",
    "end": "262114"
  },
  {
    "text": "or sorry, the problem here\nis that activities on Android are ephemeral, they might\ndisappear at any time.",
    "start": "262114",
    "end": "270328"
  },
  {
    "text": "Either you a phone call,\nand your app disappears, maybe the user presses home,\nor simply they press back,",
    "start": "270329",
    "end": "275585"
  },
  {
    "text": "and so if this asynchronous call returns after the UI has been torn down,",
    "start": "275585",
    "end": "280067"
  },
  {
    "text": "you're going to run into problems. Now, there are imperative\nways to work around this. We can, you know, checksum state",
    "start": "281309",
    "end": "287895"
  },
  {
    "text": "before we end up modifying the\nview, so that's not too bad.",
    "start": "287895",
    "end": "292061"
  },
  {
    "text": "We also have this, we are\ncreating this anonymous type, and so this will ultimately lead",
    "start": "293331",
    "end": "299260"
  },
  {
    "text": "into a short-term memory leak, because it's going to retain\na reference to our activity,",
    "start": "299260",
    "end": "304578"
  },
  {
    "text": "and if that activity disappears, the asynchronous call is still\nhappening in the background. If you want to know more about\nwhy this is such a big deal,",
    "start": "304578",
    "end": "311910"
  },
  {
    "text": "Pierre is giving a talk later\ntoday about memory leaks, which I encourage you to go to.",
    "start": "311910",
    "end": "318173"
  },
  {
    "text": "The last thing is that we didn't define what threads these\ncallbacks are running on.",
    "start": "318173",
    "end": "323269"
  },
  {
    "text": "Maybe they come back on\nthe background thread, and so now it becomes our responsibility to imperatively write a code, write code",
    "start": "323269",
    "end": "330699"
  },
  {
    "text": "that does the thread hopping\nback onto the main thread. We've cluttered this activity",
    "start": "331775",
    "end": "338473"
  },
  {
    "text": "with a bunch of things\nthat are really unrelated to the intent of the code,",
    "start": "338473",
    "end": "343845"
  },
  {
    "text": "which is simply to start\nthis asynchronous work, and handle the asynchronous result, and so this is only setting, you know,",
    "start": "343846",
    "end": "352337"
  },
  {
    "text": "eagerly calling this asynchronous request. We are not dealing with things\nlike disabling user input, handling, you know, button\nclicks, multiple fields,",
    "start": "352337",
    "end": "359961"
  },
  {
    "text": "so when you have code like this that deals with only the simple case, and then suddenly you start\nto turn it into a real app,",
    "start": "359961",
    "end": "366615"
  },
  {
    "text": "all these problems compound, and you are left with\nmanaging a bunch of state, a bunch of checks in your activities.",
    "start": "366615",
    "end": "374366"
  },
  {
    "text": "This is why we need to\nthink reactively in our app, because everything in it essentially",
    "start": "377769",
    "end": "383343"
  },
  {
    "text": "is in some way asynchronous. It's asynchronous by default. We have our network, which\nwe are sending requests to,",
    "start": "383343",
    "end": "391043"
  },
  {
    "text": "and whose responses or returning after a large period of time. We can't block the main thread for that,",
    "start": "391043",
    "end": "397240"
  },
  {
    "text": "so it has to be done\nin a background thread. We have things like the file system, whether it's databases writing to storage,",
    "start": "397240",
    "end": "403889"
  },
  {
    "text": "even shared preferences, where we can't block the\nmain thread for that, so we have to do them\non background threads.",
    "start": "403889",
    "end": "411262"
  },
  {
    "text": "The user is also somewhat of\nan asynchronous source of data. We push data to them in the UI,",
    "start": "411262",
    "end": "417387"
  },
  {
    "text": "and then they react using button clicks, or maybe changing inputs in text fields,",
    "start": "417387",
    "end": "422711"
  },
  {
    "text": "and those things happen asynchronously. We are not synchronously\npulling user for data, we are waiting until they do something.",
    "start": "422711",
    "end": "430227"
  },
  {
    "text": "This just goes to show that, basically, the UI is another piece.",
    "start": "434744",
    "end": "440098"
  },
  {
    "text": "A lot of people think that you can write these single threaded apps, which by default are on the main thread,",
    "start": "441022",
    "end": "446726"
  },
  {
    "text": "but really the UI is a piece\nof asynchronous source. Even if you don't have the data component",
    "start": "446726",
    "end": "452813"
  },
  {
    "text": "or the network component, the user itself is an\nasynchronous piece of information. You have to react to their input",
    "start": "452813",
    "end": "459460"
  },
  {
    "text": "in ways that make sense to them.",
    "start": "459460",
    "end": "462126"
  },
  {
    "text": "Here is just an example of a bunch of data flowing through the app, and this is not all happening synchronously.",
    "start": "466972",
    "end": "472716"
  },
  {
    "text": "These things happen\nbased on network speeds, happens on disk speeds,",
    "start": "472717",
    "end": "477735"
  },
  {
    "text": "happens when the user's clicking buttons. It's just data that's flowing\nto the app at different times,",
    "start": "477735",
    "end": "483862"
  },
  {
    "text": "and the app has to be\nreceptive, and reactive to that, so that you don't wind up in a state where",
    "start": "483863",
    "end": "488869"
  },
  {
    "text": "either the main thread is blocked, or some piece of data\ncomes in asynchronously when you weren't expecting it,",
    "start": "488869",
    "end": "494624"
  },
  {
    "text": "and the app either doesn't\nreflect it, or just crashes.",
    "start": "494624",
    "end": "498791"
  },
  {
    "text": "Ultimately, your code in the middle here is what's responsible\nfor managing everything. This is where the\ncomplexity ends up lying.",
    "start": "499993",
    "end": "506911"
  },
  {
    "text": "You have to maintain all this state in your activities fragments or whatever",
    "start": "506911",
    "end": "512013"
  },
  {
    "text": "to reconcile the fact that these multiple asynchronous sources are producing and consuming data",
    "start": "512014",
    "end": "517401"
  },
  {
    "text": "at potentially different rates. That doesn't even take into\naccount Android itself.",
    "start": "517402",
    "end": "523534"
  },
  {
    "text": "Android is a fundamentally\nasynchronous platform. We have things like push notifications, we have broadcasts throughout the system,",
    "start": "523534",
    "end": "531163"
  },
  {
    "text": "even things like a configuration change, when the user rotates the\ndevice may come at any time,",
    "start": "531163",
    "end": "536900"
  },
  {
    "text": "and if your code is not expecting\nthat to come at any time, you will run into crashes,",
    "start": "536900",
    "end": "543966"
  },
  {
    "text": "and you will run into cases where the app just starts misbehaving, because some state got into\na certain configuration",
    "start": "545126",
    "end": "552583"
  },
  {
    "text": "where your app just\ncompletely stops reacting.",
    "start": "552583",
    "end": "556416"
  },
  {
    "text": "Just to go back to this point, if I'm postulating that a\nsingle asynchronous source ends up breaking imperative programming,",
    "start": "560393",
    "end": "569045"
  },
  {
    "text": "if Android by default is\nsomething asynchronous, we have network requests, hard to find an app\nwithout network requests,",
    "start": "569045",
    "end": "575152"
  },
  {
    "text": "that's fundamentally\nasynchronous, you have the disk, and the database, a fundamentally\nasynchronous source,",
    "start": "575152",
    "end": "580241"
  },
  {
    "text": "and then the UI itself should\nultimately be thought of as an asynchronous source, so by default, basically everything in Android\nis already asynchronous,",
    "start": "580241",
    "end": "587818"
  },
  {
    "text": "so by clinging to more\ntraditional imperative programming and state management techniques, you are ultimately harming yourself.",
    "start": "587818",
    "end": "596042"
  },
  {
    "text": "What we need to do is take this model, where our code sits in the\nmiddle, as the arbiter of state,",
    "start": "596042",
    "end": "601641"
  },
  {
    "text": "and trying to coordinate all\nthese asynchronous things, and instead of having that, we can remove our responsibility",
    "start": "601641",
    "end": "608011"
  },
  {
    "text": "by hooking these things up directly. We can change the UI to subscribe\ndirectly to the database,",
    "start": "608011",
    "end": "614746"
  },
  {
    "text": "and just react when the data changes. We can change the database, and the network call to just react",
    "start": "614747",
    "end": "621183"
  },
  {
    "text": "when the button is clicked,\ninstead of us having to receive that click, and then dispatch it.",
    "start": "621184",
    "end": "627239"
  },
  {
    "text": "Similarly, the network\nresponse comes back. It would be nice if that\njust updated the data, and we know now that\nwhen the data updates,",
    "start": "627239",
    "end": "634552"
  },
  {
    "text": "the UI automatically updates, and so we removed our\nresponsibility for doing that. If Android does something asynchronously,",
    "start": "634552",
    "end": "641293"
  },
  {
    "text": "like starts rotating, sends a broadcast, it would be nice if that was\njust automatically reflected",
    "start": "641293",
    "end": "646946"
  },
  {
    "text": "in the UI, or automatically\nstarted or stopped some background job. Ultimately, this removes a lot of the code",
    "start": "646946",
    "end": "654364"
  },
  {
    "text": "that we had to write in order to maintain those states ourselves.",
    "start": "654364",
    "end": "658802"
  },
  {
    "text": "We are still writing code,\nthere's still code here, but all we are doing is now\nconnecting the bits together in a way that makes sense,",
    "start": "659824",
    "end": "666304"
  },
  {
    "text": "instead of trying to manage\nthe state of all of them, emitting and consuming events.",
    "start": "666304",
    "end": "671636"
  },
  {
    "text": "Ultimately, this is\nwhere we get to RxJava. This has become de facto of\nreactive library for Android,",
    "start": "675115",
    "end": "682256"
  },
  {
    "text": "mostly due to the fact that it was one of the first available for Java\nthat was really comprehensive,",
    "start": "683406",
    "end": "688659"
  },
  {
    "text": "and also, for RxJava 2, because it retains support\nfor older versions of Java",
    "start": "688659",
    "end": "694084"
  },
  {
    "text": "that we need on Android. It comes down to providing\nthree major things.",
    "start": "694084",
    "end": "699874"
  },
  {
    "text": "It's a set of types for\nrepresenting the sources of data. Then, we have a set of types\nfor subscribing to that data,",
    "start": "699874",
    "end": "708326"
  },
  {
    "text": "and listening to when it changes. Then finally, the most powerful part is a bunch of methods which allow you",
    "start": "708326",
    "end": "715295"
  },
  {
    "text": "to combine, compose, transform that data so we can end up creating those links",
    "start": "715295",
    "end": "720720"
  },
  {
    "text": "between the different\nasynchronous sources of data, and the things that want to\nsubscribe and display it.",
    "start": "720720",
    "end": "728104"
  },
  {
    "text": "Let's start with looking at what the first to look like in the API.",
    "start": "728104",
    "end": "732275"
  },
  {
    "text": "A source of data, usually\nwhat will happen is it will start or stop doing some work when you start listening to it.",
    "start": "736952",
    "end": "743907"
  },
  {
    "text": "You can think of this\nlike a network request that's not going to fire until you start listening for a response,",
    "start": "743907",
    "end": "751172"
  },
  {
    "text": "and if you ultimately end up unsubscribing from that source of data\nbefore it completes,",
    "start": "751172",
    "end": "757048"
  },
  {
    "text": "it could potentially do work by saying canceling the network request.",
    "start": "757048",
    "end": "761488"
  },
  {
    "text": "These can be both\nsynchronous and asynchronous, and so you can model something\nlike a network request,",
    "start": "762627",
    "end": "767633"
  },
  {
    "text": "which is blocking, but running\non a background thread, or it can be asynchronous,\nwhich is something like,",
    "start": "767633",
    "end": "775671"
  },
  {
    "text": "something like calling out to Android, and expecting an activity result, or even like clicks in the UI",
    "start": "775671",
    "end": "781839"
  },
  {
    "text": "can be thought of as asynchronous. You are not blocking, waiting for a click, you're just reacting to the\nfact that the click happened.",
    "start": "781840",
    "end": "790348"
  },
  {
    "text": "Usually these can produce a single item, or perhaps many items, and so, like a network response\nwould be like a single item",
    "start": "792032",
    "end": "800384"
  },
  {
    "text": "for a single request, but a stream of button clicks\nwould be potentially infinite,",
    "start": "800384",
    "end": "806896"
  },
  {
    "text": "as long as your UI is there, even though you're only, you know, subscribing to a single button.",
    "start": "806896",
    "end": "813088"
  },
  {
    "text": "These also can be empty,\nand so there is the idea of a source that really\nonly succeeds or fails,",
    "start": "813088",
    "end": "818511"
  },
  {
    "text": "and doesn't actually have any items. You could think of this\nlike writing to a database, or writing to a file.",
    "start": "818511",
    "end": "824078"
  },
  {
    "text": "It doesn't really have a response. It doesn't really have\nan item that it can, you know, return to you,",
    "start": "824078",
    "end": "829962"
  },
  {
    "text": "it really just kind of completes or fails. That completion and failure aspect",
    "start": "829962",
    "end": "835264"
  },
  {
    "text": "is actually modeled by sources in RxJava with these so-called terminal events,",
    "start": "835264",
    "end": "841228"
  },
  {
    "text": "which are, it either completes\nsuccessfully, or it errors.",
    "start": "841228",
    "end": "845395"
  },
  {
    "text": "This is similar to, you\nknow, a method that can return normally, or throw an exception.",
    "start": "846355",
    "end": "851696"
  },
  {
    "text": "It also may never terminate, so to go back to the button click example, if we were modeling button\nclicks as a source of data,",
    "start": "851696",
    "end": "858884"
  },
  {
    "text": "that will never end as\nlong as your UI is there, and when your UI disappears,",
    "start": "858885",
    "end": "864487"
  },
  {
    "text": "you are probably unsubscribing from that source of button clicks,\nit's not actually completing.",
    "start": "864487",
    "end": "871771"
  },
  {
    "text": "Really, this all amounts\nto just an implementation of the traditional Observer pattern.",
    "start": "871771",
    "end": "876833"
  },
  {
    "text": "We have some thing that can produce data, and then we have a contract\nwhat the data looks like,",
    "start": "876833",
    "end": "882076"
  },
  {
    "text": "and all we are doing is just\nwanting to observe that. We want to add a listener to it, and get notified when things happen.",
    "start": "882076",
    "end": "889704"
  },
  {
    "text": "The two main types that\nare going to represent this in RxJava 2 is Observable, and Flowable,",
    "start": "889704",
    "end": "896373"
  },
  {
    "text": "and is both actually end up\nmodeling the same types of data, and that can be zero to N items,",
    "start": "896374",
    "end": "903932"
  },
  {
    "text": "so it can be empty, you know,\nit can have a single item, or potentially many, and then they terminate\neither successfully,",
    "start": "903932",
    "end": "910734"
  },
  {
    "text": "or they terminate with an error. Why do we need two types represent the same structure of data?",
    "start": "910734",
    "end": "917332"
  },
  {
    "text": "This comes down to something\ncalled backpressure. I don't really want to dive into too much",
    "start": "918317",
    "end": "923584"
  },
  {
    "text": "what backpressure is,\nbecause it's a complex topic, but I'm going to try\nto show you an example,",
    "start": "923584",
    "end": "929030"
  },
  {
    "text": "which should illustrate the difference. Backpressure is there to allow you",
    "start": "929030",
    "end": "934419"
  },
  {
    "text": "to slow down a source of data. You know, we are living\nunder these systems",
    "start": "934419",
    "end": "940052"
  },
  {
    "text": "that have finite resources, and you can only process\nso much at a time, backpressure is a way to",
    "start": "940052",
    "end": "945572"
  },
  {
    "text": "basically tell all of the\npeople sending you data to slow down, that you can't process it as fast as they are sending.",
    "start": "947219",
    "end": "952975"
  },
  {
    "text": "RxJava 1 had backpressure, but it was implemented fairly\nlate in the API process,",
    "start": "954444",
    "end": "959539"
  },
  {
    "text": "and so every type in the\nsystem had backpressure, instead of RxJava 2,\nwhere we have two types.",
    "start": "959539",
    "end": "967241"
  },
  {
    "text": "Where this became a disadvantage is that, while all types expose\nthe idea of backpressure,",
    "start": "968181",
    "end": "975300"
  },
  {
    "text": "the idea that you can slow them down, not all sources actually implemented it, so you would ultimately get a crash,",
    "start": "975301",
    "end": "981706"
  },
  {
    "text": "that it was unsupported at runtime. This is because\nbackpressure, like, you know,",
    "start": "981706",
    "end": "988641"
  },
  {
    "text": "like inheritance, you have\nto really design for it, it has to be a thing that\nyou account for upfront, instead of something that\njust gets mixed in later,",
    "start": "989544",
    "end": "998188"
  },
  {
    "text": "and this is really why we have two separate types in RxJava 2, because you can now\ndictate in the type system",
    "start": "998189",
    "end": "1004838"
  },
  {
    "text": "whether backpressure is supported or not, because if it's not, that's\nsomething that's fine,",
    "start": "1004838",
    "end": "1010912"
  },
  {
    "text": "but it's also something that\nyou need to expose in the API. The example that would show this is,",
    "start": "1010913",
    "end": "1018170"
  },
  {
    "text": "if we have a source of data\nwhich is, say, touch events, the user puts their finger on the screen,",
    "start": "1018171",
    "end": "1024037"
  },
  {
    "text": "and they drag it along, and this produces a\nseries of touch events. Now, this is something that\nwe can't really slow down,",
    "start": "1024038",
    "end": "1031295"
  },
  {
    "text": "we can't really tell the user, you know, draw half of your curve, and then stop",
    "start": "1031296",
    "end": "1036303"
  },
  {
    "text": "and wait while I catch up drawing, and then you can continue\nthe rest of your curve.",
    "start": "1036304",
    "end": "1042155"
  },
  {
    "text": "We can potentially do\nthis through other ways, such as like disabling buttons, and displaying other UI\nto try and slow them down,",
    "start": "1042155",
    "end": "1049874"
  },
  {
    "text": "but the source of data itself is not one that can be slowed down.",
    "start": "1049874",
    "end": "1055455"
  },
  {
    "text": "If the already drawn that\ncurve with a bunch of events, we can't tell the system\nto slow down sending them.",
    "start": "1055456",
    "end": "1062198"
  },
  {
    "text": "You can compare that to\nsomething like a database where we have a large result set,",
    "start": "1063641",
    "end": "1069825"
  },
  {
    "text": "and maybe we only want to pull\nout certain rows at a time. Say, oh, I only want the first four rows,",
    "start": "1069826",
    "end": "1076232"
  },
  {
    "text": "okay, now give me three more rows, okay, now give me five more rows. A database can model this really well,",
    "start": "1076232",
    "end": "1082510"
  },
  {
    "text": "it has the concept of cursors, but a touch event, a\nstream of touch events",
    "start": "1082510",
    "end": "1088026"
  },
  {
    "text": "can't model this at all, because there's no way to push back, and slow down the user's finger.",
    "start": "1088026",
    "end": "1094115"
  },
  {
    "text": "In RxJava 1, you would see both of these types\nimplemented as observables,",
    "start": "1094115",
    "end": "1099226"
  },
  {
    "text": "and what would happen is, at runtime, you might try and apply backpressure, and you ultimately get an\nexception, and your app crashes.",
    "start": "1099226",
    "end": "1107767"
  },
  {
    "text": "This is the reason why, in RxJava 2, we model them as different types, because one fundamentally\ncan support backpressure,",
    "start": "1108638",
    "end": "1114748"
  },
  {
    "text": "and one fundamentally cannot. There are ways of\nconverting between the two, which is basically just\napplying a strategy",
    "start": "1114749",
    "end": "1122114"
  },
  {
    "text": "of how backpressure works, but I'm not going to go into that.",
    "start": "1122114",
    "end": "1126664"
  },
  {
    "text": "Because these are two different types, they have to expose this\nbackpressure in some way,",
    "start": "1128655",
    "end": "1134207"
  },
  {
    "text": "but because they also model\nthe same type of data, they also have to kind\nof appear the same way",
    "start": "1134207",
    "end": "1139996"
  },
  {
    "text": "in terms of how data gets\npushed into your callbacks.",
    "start": "1139996",
    "end": "1144163"
  },
  {
    "text": "The two interfaces for listening to events from these sources\nlook fairly similar.",
    "start": "1145638",
    "end": "1151182"
  },
  {
    "text": "The first method is called onNext, and this is the method where items are going to be delivered,",
    "start": "1153289",
    "end": "1159948"
  },
  {
    "text": "and so as long as there\nis one or more items being produced by the\nobservable, or flowable,",
    "start": "1159948",
    "end": "1167171"
  },
  {
    "text": "this method will be called for each one, allowing you to do whatever processing",
    "start": "1167171",
    "end": "1173615"
  },
  {
    "text": "you want to do with the items. This also could be infinite.",
    "start": "1173615",
    "end": "1178658"
  },
  {
    "text": "I talked about infinite\nobservables, like button clicks, so if you are listening to a button click, this onNext method will\nbasically be called",
    "start": "1178658",
    "end": "1184570"
  },
  {
    "text": "every single time the\nuser clicks a button. For non-infinite sources,\nsources that actually end,",
    "start": "1184571",
    "end": "1191846"
  },
  {
    "text": "we have those two terminal events. They either can complete, where complete and dictate success,",
    "start": "1191846",
    "end": "1197975"
  },
  {
    "text": "or they can error, where error indicates\nthat either processing",
    "start": "1197975",
    "end": "1203263"
  },
  {
    "text": "the onNext callback resulted\nin an exception being thrown, or that the source of data,",
    "start": "1203263",
    "end": "1209485"
  },
  {
    "text": "where we are listening to events from, had a problem, and had\nto deliver an error.",
    "start": "1209485",
    "end": "1215069"
  },
  {
    "text": "Both onComplete, and onError are what's called terminal events, which means you will\nnever get another callback",
    "start": "1215069",
    "end": "1220812"
  },
  {
    "text": "after you get either one of those. Where they differ is in this last method,",
    "start": "1220812",
    "end": "1226257"
  },
  {
    "text": "called onSubscribe. If you know RxJava 1, this is\nsomething that's fairly new.",
    "start": "1226257",
    "end": "1231999"
  },
  {
    "text": "It's basically the idea\nthat when you subscribe to either an observable, or a flowable,",
    "start": "1233977",
    "end": "1239905"
  },
  {
    "text": "you are really creating a like a resource, and resources often need cleaned up",
    "start": "1239905",
    "end": "1246841"
  },
  {
    "text": "when you're done with them, and so this on subscribe callback will be immediately called as soon as you",
    "start": "1246842",
    "end": "1251952"
  },
  {
    "text": "start listening to an\nobservable or flowable, and it's going to hand you\none of these two types.",
    "start": "1251952",
    "end": "1257828"
  },
  {
    "text": "For observable, with this\ntype allows you to do is call the dispose method,\nwhich essentially says, I am done with this resource,",
    "start": "1257828",
    "end": "1264265"
  },
  {
    "text": "I don't want any more callbacks, and so what if we have, you\nknow, a network request, this would potentially\ncancel the network request.",
    "start": "1264265",
    "end": "1271402"
  },
  {
    "text": "If you are listening\nto that infinite stream of button clicks, this would basically\nsay that you no longer",
    "start": "1271402",
    "end": "1278242"
  },
  {
    "text": "want to receive those, and it would onSet the\nlistener on the view.",
    "start": "1278242",
    "end": "1283516"
  },
  {
    "text": "Now, the same is true\nfor the type onFlowable. Even though it has a different\nname, the use is the same,",
    "start": "1283516",
    "end": "1289991"
  },
  {
    "text": "it has this cancel method\nwhich is essentially the same as disposable's dispose.",
    "start": "1289991",
    "end": "1294730"
  },
  {
    "text": "The difference here is\nthat it has a second method called request, and this\nis where backpressure shows itself in the API.",
    "start": "1295955",
    "end": "1301682"
  },
  {
    "text": "This request method is how you tell the flowable that you want more items.",
    "start": "1302675",
    "end": "1307764"
  },
  {
    "text": "I'm going to build up a little chart here of how these things relate to each other. We basically can represent and the,",
    "start": "1311378",
    "end": "1318608"
  },
  {
    "text": "you know, any type of emissions. It could be zero, it could be one, it could be many, and it\npotentially could complete,",
    "start": "1318608",
    "end": "1323893"
  },
  {
    "text": "or potentially error. The only difference between the two is that one has backpressure,\nand one does not.",
    "start": "1323893",
    "end": "1330587"
  },
  {
    "text": "Just really quickly, I want to touch on why the disposable and subscription types",
    "start": "1330587",
    "end": "1336453"
  },
  {
    "text": "are named so differently,\nand why their methods, one is dispose, and one is cancel,",
    "start": "1338090",
    "end": "1343230"
  },
  {
    "text": "instead of perhaps being, you\nknow, one extending the other, and just adding the request method.",
    "start": "1343230",
    "end": "1348853"
  },
  {
    "text": "The reason is because there is this thing called the reactive stream specification. It's basically an initiative\nwhere a bunch of companies",
    "start": "1348853",
    "end": "1355414"
  },
  {
    "text": "got together, and said, let's make a standard set of interfaces for reactive libraries in Java,",
    "start": "1355414",
    "end": "1361774"
  },
  {
    "text": "and they wound up with these four classes, for interfaces rather. You will see the subscriber type,",
    "start": "1361774",
    "end": "1368839"
  },
  {
    "text": "and the subscription\ntype in the middle there. These are actually part\nof the specification,",
    "start": "1368839",
    "end": "1374055"
  },
  {
    "text": "and so that's why they have\na name that is so different than the ones, the disposable type,",
    "start": "1374056",
    "end": "1380685"
  },
  {
    "text": "and the observer type. They are different because\nthey are part of a standard, and we can't really change that.",
    "start": "1380686",
    "end": "1385921"
  },
  {
    "text": "The advantage though is that,\nbecause it is a standard, although this doesn't happen\nfrequently on Android,",
    "start": "1385921",
    "end": "1392433"
  },
  {
    "text": "but if you had to use two\ndifferent libraries for streams, if they both implement the standard,",
    "start": "1392433",
    "end": "1398085"
  },
  {
    "text": "you can convert between them seamlessly. I'm going to change my left column here",
    "start": "1398085",
    "end": "1404893"
  },
  {
    "text": "to actually be types that implement the reactive streams specification, and the types on the right are,",
    "start": "1404893",
    "end": "1410680"
  },
  {
    "text": "which implies that\nbackpressure is supported, and the types on the right are those which do not have backpressure.",
    "start": "1410680",
    "end": "1417345"
  },
  {
    "text": "If we go back to our user manager, before, we were kind of pulling\nusers out of this class,",
    "start": "1418962",
    "end": "1424560"
  },
  {
    "text": "and then displaying them when we thought it was most appropriate. Now we could do is model this as, instead,",
    "start": "1424560",
    "end": "1430984"
  },
  {
    "text": "a observable of user. It's a source of user objects that, whenever the user changes, will\nbe notified of that change,",
    "start": "1430984",
    "end": "1439241"
  },
  {
    "text": "and can react to the\nchange by displaying it, instead of trying to guess when the most appropriate time is,",
    "start": "1439241",
    "end": "1444617"
  },
  {
    "text": "based on other events\nhappening in the system. There's a couple specialized\nsources in RxJava,",
    "start": "1444618",
    "end": "1453121"
  },
  {
    "text": "and it's basically a\nsubset of the observable,",
    "start": "1453121",
    "end": "1456954"
  },
  {
    "text": "so there's three of them. First one is called single. Designer has a single item, or an error,",
    "start": "1460868",
    "end": "1468413"
  },
  {
    "text": "so it's less of a stream, and more just like a\npotentially asynchronous source",
    "start": "1468413",
    "end": "1473680"
  },
  {
    "text": "of a single item, and it also\ndoes not have backpressure. The way to think about this\nis kind of like a scaler.",
    "start": "1473680",
    "end": "1481080"
  },
  {
    "text": "You call a method, you get a turn type, you get a return value, or that\nmethod throws an exception.",
    "start": "1481081",
    "end": "1486398"
  },
  {
    "text": "Single essentially\nmodels the same concept. You subscribe to a single,\nyou either get back your item,",
    "start": "1486399",
    "end": "1492459"
  },
  {
    "text": "or you get an error. The difference being that it's reactive.",
    "start": "1492459",
    "end": "1498721"
  },
  {
    "text": "Completable is similar to a method that declares a void return type.",
    "start": "1498722",
    "end": "1505020"
  },
  {
    "text": "It completes with no data, or it throws an exception, has an error.",
    "start": "1505020",
    "end": "1511603"
  },
  {
    "text": "Kind of think of this\nas a reactive runnable, it's a set of code that you can run, and it will either complete\nsuccessfully, or fail.",
    "start": "1511603",
    "end": "1519862"
  },
  {
    "text": "A new type in RxJava\n2, compared to RxJava 1 is called a maybe. This either has an item, errors,",
    "start": "1519862",
    "end": "1528101"
  },
  {
    "text": "or potentially has no items. The way to think of this is\nit's kind of like an optional.",
    "start": "1528101",
    "end": "1534038"
  },
  {
    "text": "A method that returns an optional value will always return something, if it doesn't throw an exception,",
    "start": "1534038",
    "end": "1539915"
  },
  {
    "text": "but that optional may\nor may not have a value. We will see where these are\ngoing to be used in a second,",
    "start": "1539915",
    "end": "1546270"
  },
  {
    "text": "but this is similar to\nthe optional concept, except just reactive.",
    "start": "1546270",
    "end": "1551976"
  },
  {
    "text": "There's no types that actually model that that are reactive streams\ncompliant in RxJava 2,",
    "start": "1556889",
    "end": "1562386"
  },
  {
    "text": "they are only modeled in the observable and backpressure-free side.",
    "start": "1562386",
    "end": "1566538"
  },
  {
    "text": "If our setName and setAge\ncalls are asynchronous, they either complete or fail,\nthey don't really return data,",
    "start": "1570491",
    "end": "1577629"
  },
  {
    "text": "and so what we want to do is\nmodel those as completable.",
    "start": "1577630",
    "end": "1581797"
  },
  {
    "text": "I'm going to go through\nthis really quickly, just to show how the sources are created, and how you can wrap the things",
    "start": "1584014",
    "end": "1589475"
  },
  {
    "text": "that you are already\nusing in reactive sources. All of the types have static methods",
    "start": "1589475",
    "end": "1595880"
  },
  {
    "text": "that allow you to create\nthem with like scaler values. You can also create them\nfrom things like arrays,",
    "start": "1595880",
    "end": "1602686"
  },
  {
    "text": "or anything that's iterable, but there's two that are really useful that I think are going to be the most used",
    "start": "1602686",
    "end": "1609730"
  },
  {
    "text": "for adapting the methods, and the actions that\nyou are already doing,",
    "start": "1609730",
    "end": "1614752"
  },
  {
    "text": "in either a synchronous,\nor asynchronous way. The first one is called fromCallable. FromCallable is essentially modeling",
    "start": "1614752",
    "end": "1622016"
  },
  {
    "text": "some synchronous behavior\nthat returns a single value.",
    "start": "1622016",
    "end": "1626183"
  },
  {
    "text": "In this case, I'm delegating\nto some hypothetical method, called getName. The nice thing about fromCallable is that",
    "start": "1627701",
    "end": "1634897"
  },
  {
    "text": "you are allowed to throw an\nexception from a callable, which is a standard Java interface,",
    "start": "1634897",
    "end": "1640784"
  },
  {
    "text": "and this means that we can model things that would potentially fail\nusing a checked exception.",
    "start": "1640785",
    "end": "1646580"
  },
  {
    "text": "If we have an HTTP request\nthat we want to make which could throw an I/O exception, we can now put that inside a fromCallable,",
    "start": "1646581",
    "end": "1653402"
  },
  {
    "text": "and the returned observable, when subscribed to, will\nexecute that request,",
    "start": "1653402",
    "end": "1659162"
  },
  {
    "text": "and if that request throws an exception, we will get an on error,\nif that request completes, we will get the response, an onNext.",
    "start": "1659162",
    "end": "1666898"
  },
  {
    "text": "FromCallable is available\non all five types. These are for modeling synchronous sources",
    "start": "1668843",
    "end": "1674259"
  },
  {
    "text": "of a single piece of data. It's what you would use a method\nfor in an imperative world,",
    "start": "1674259",
    "end": "1679720"
  },
  {
    "text": "a method that returns a return value. In the reactive world, fromCallable is what you use to model that.",
    "start": "1679720",
    "end": "1687511"
  },
  {
    "text": "There is also two\nadditional methods on both, maybe and completable, and those allow you to model things that don't return a value.",
    "start": "1687511",
    "end": "1694318"
  },
  {
    "text": "Like I said, basically just a runnable, except that runnable is now reactive.",
    "start": "1694318",
    "end": "1701388"
  },
  {
    "text": "The most powerful method\nfor creating observables is aptly named create. If you use RxJava 1,\nyou may know that create",
    "start": "1705490",
    "end": "1713894"
  },
  {
    "text": "is this horrible method that you really should never be using in RxJava 1. In RxJava 2, that's been fixed,",
    "start": "1713894",
    "end": "1720295"
  },
  {
    "text": "so that the create method is actually one of the most useful methods, and should be used for wrapping sources.",
    "start": "1720295",
    "end": "1727383"
  },
  {
    "text": "We create it with a callback. This callback it's called whenever there's a new subscriber,",
    "start": "1727384",
    "end": "1733180"
  },
  {
    "text": "and we are given this\nthing called an emitter, and the emitter is basically just the person that is listening.",
    "start": "1733180",
    "end": "1739897"
  },
  {
    "text": "We can take data, and we\ncan send it to the emitter. In this example what I'm doing is",
    "start": "1739897",
    "end": "1745482"
  },
  {
    "text": "I'm just sending a piece\nof data synchronously, and then I'm completing the stream, because it completed successfully.",
    "start": "1745482",
    "end": "1753518"
  },
  {
    "text": "I'm going to convert this to a lambda, to clean up some of the boilerplate here.",
    "start": "1753518",
    "end": "1758926"
  },
  {
    "text": "So, I can send more\nthan one piece of data. Unlike fromCallable, I have the ability to call next multiple times.",
    "start": "1759787",
    "end": "1766341"
  },
  {
    "text": "Oh no!",
    "start": "1767228",
    "end": "1768061"
  },
  {
    "text": "The other advantage of this is that we can now model\nasynchronous pieces of data.",
    "start": "1776413",
    "end": "1782157"
  },
  {
    "text": "If I take HTTP requests, and instead of executing it synchronously, executed it asynchronously,",
    "start": "1782157",
    "end": "1788126"
  },
  {
    "text": "I can call that onNext\nmethod in the emitter, from the HTTP callback.",
    "start": "1789232",
    "end": "1793905"
  },
  {
    "text": "Another nice advantage\nof this create method is it allows you to do things\nwhen the person unsubscribes.",
    "start": "1798991",
    "end": "1805185"
  },
  {
    "text": "If someone stops listening\nto the HTTP request, there's no reason for it\nto continue executing.",
    "start": "1805185",
    "end": "1810970"
  },
  {
    "text": "We can now add a cancellation action, which cancels the HTTP request,",
    "start": "1810970",
    "end": "1816706"
  },
  {
    "text": "and cleans up the resources. This is also super useful for Android, because it's how we model\ninteractions with the UI.",
    "start": "1816706",
    "end": "1824478"
  },
  {
    "text": "When you subscribe to an observable, we want to say start\nlistening to button clicks, and then when you unsubscribe,",
    "start": "1824478",
    "end": "1830332"
  },
  {
    "text": "we want to remove that listener, so we don't end up, you\nknow, leaking a reference, leaking that reference to the view.",
    "start": "1830332",
    "end": "1837832"
  },
  {
    "text": "Creating observables works on all, or, creating observables with this emitter works on all five types.",
    "start": "1837832",
    "end": "1844068"
  },
  {
    "text": "Let's quickly look at observing sources. I showed these two interfaces earlier,",
    "start": "1846844",
    "end": "1852572"
  },
  {
    "text": "and I showed that fourth method, which is kind of new,\nand is a little weird.",
    "start": "1852572",
    "end": "1858386"
  },
  {
    "text": "You actually don't use\nthese interfaces directly when you subscribe to an observable,",
    "start": "1858386",
    "end": "1863630"
  },
  {
    "text": "subscribe being the method\nthat starts listening. Because of that fourth method,",
    "start": "1863630",
    "end": "1868933"
  },
  {
    "text": "you are put in a weird place where, well, what do I do with this object, and how do I, you know, unsubscribe?",
    "start": "1868933",
    "end": "1875926"
  },
  {
    "text": "Instead, we have a type\ncalled DisposableObserver, and this will automatically handle that fourth method for you,",
    "start": "1875926",
    "end": "1882593"
  },
  {
    "text": "and allow you to only be concerned about the actual notifications from the observable itself.",
    "start": "1882593",
    "end": "1888813"
  },
  {
    "text": "But, how do we dispose here? If we no longer have that callback, how do we unsubscribe, how do we tell the resource\nthat we want it to go away?",
    "start": "1891116",
    "end": "1899881"
  },
  {
    "text": "One thing you could do is\nhold onto that observer. It actually implements disposable, so you can call dispose method,",
    "start": "1899881",
    "end": "1905973"
  },
  {
    "text": "and it will take care\nof forwarding it to you, you know, up the chain,",
    "start": "1905973",
    "end": "1910115"
  },
  {
    "text": "but there's a new method in\nRxJava 2, called subscribeWith. This allows you to use it in a similar way",
    "start": "1911102",
    "end": "1917870"
  },
  {
    "text": "that you would do if\nyou are using RxJava 1, which is that it now returns you the thing that you can then call dispose on.",
    "start": "1917870",
    "end": "1925357"
  },
  {
    "text": "In RxJava 1, this is\ncalled a subscription. It's also called a subscription\nin the flowable world,",
    "start": "1925357",
    "end": "1930680"
  },
  {
    "text": "but in the observable\nworld, it's a disposable. For people that know of\ncomposite subscription,",
    "start": "1930680",
    "end": "1938396"
  },
  {
    "text": "there's a composite disposable, and this basically allows you to subscribe to multiple streams,",
    "start": "1938396",
    "end": "1943678"
  },
  {
    "text": "take those returned disposables, and add them to what is\nessentially a list of disposables,",
    "start": "1943678",
    "end": "1949346"
  },
  {
    "text": "and you can unsubscribe from\nmultiple streams at once. You will see this a lot on Android,",
    "start": "1949347",
    "end": "1955249"
  },
  {
    "text": "where you have a single\ncomposite disposable for, you know, an activity,\na fragment, whatever,",
    "start": "1955249",
    "end": "1960532"
  },
  {
    "text": "and you are unsubscribing in the, you know, onDestroy, or whatever lifecycle callback is most appropriate.",
    "start": "1960532",
    "end": "1968534"
  },
  {
    "text": "You have these on all four\nnon-backpressure types, the one that use observer,",
    "start": "1969780",
    "end": "1975083"
  },
  {
    "text": "and there actually is one on flowable, even though flowable uses\nthe subscription callback,",
    "start": "1975083",
    "end": "1981229"
  },
  {
    "text": "not the disposable one. The type we provide in\nRxJava 2 actually allows you",
    "start": "1981229",
    "end": "1988299"
  },
  {
    "text": "to model it in the same way, so you get a disposable\nback from all five types,",
    "start": "1988299",
    "end": "1993546"
  },
  {
    "text": "even though flowable is kind\nof a little bit different. The way to think of this",
    "start": "1993546",
    "end": "1998741"
  },
  {
    "text": "is like you would think of\nanything that is a resource, a file, a cursor on a database,",
    "start": "1998741",
    "end": "2005010"
  },
  {
    "text": "you wouldn't open a file without having some way to close it, you wouldn't open a cursor on a database",
    "start": "2005010",
    "end": "2010943"
  },
  {
    "text": "without eventually closing it. Never subscribe to an observable without managing the disposable,",
    "start": "2010943",
    "end": "2016383"
  },
  {
    "text": "and ultimately, unsubscribing from it.",
    "start": "2016383",
    "end": "2019550"
  },
  {
    "text": "Okay, so those were the types, let's really, really quickly look at the methods that allow you\nto compose, and change data.",
    "start": "2023843",
    "end": "2033211"
  },
  {
    "text": "We call these operators, and\nthey do basically three things, manipulate or combine data,",
    "start": "2033211",
    "end": "2038825"
  },
  {
    "text": "they change the threading semantics, or they can start and stop emissions.",
    "start": "2038825",
    "end": "2044138"
  },
  {
    "text": "We are really only going\nto look at the first two. Just like we took something\nthat was imperative,",
    "start": "2045109",
    "end": "2050150"
  },
  {
    "text": "like a synchronous method\ncall, and turned it reactive, operators basically do the same thing.",
    "start": "2050151",
    "end": "2055818"
  },
  {
    "text": "Here, we are applying an\noperation to a string, and getting back a new string. In the reactive world, we\nwould have an observable,",
    "start": "2055819",
    "end": "2063096"
  },
  {
    "text": "and we would apply that\noperation via an operator. In this case, map is the operator,",
    "start": "2063096",
    "end": "2070240"
  },
  {
    "text": "which is allowing us to\ntake data being emitted, and apply some operation to it",
    "start": "2070240",
    "end": "2075539"
  },
  {
    "text": "to create a new type of that data.",
    "start": "2075539",
    "end": "2078372"
  },
  {
    "text": "I'm actually going to skip this one.",
    "start": "2082293",
    "end": "2085293"
  },
  {
    "text": "If we look at our user object, we defined that, originally, the callbacks were coming\nback on a background thread,",
    "start": "2087496",
    "end": "2094502"
  },
  {
    "text": "and we had to explicitly\nmove to the main thread. There's actually a built-in\noperator that allows you",
    "start": "2094502",
    "end": "2100764"
  },
  {
    "text": "to do that, and allows you to do it at a much more declarative way. We can say, I want to observe emissions",
    "start": "2100764",
    "end": "2106501"
  },
  {
    "text": "from this observable,\non a different thread, and so the things coming\nfrom user would be",
    "start": "2106501",
    "end": "2112817"
  },
  {
    "text": "on the background thread, but the things coming\nout of main thread user will now be on the main thread.",
    "start": "2112818",
    "end": "2118842"
  },
  {
    "text": "ObserveOn being the operator here. Because we're changing threads, the order that you apply these\noperators really matters.",
    "start": "2118842",
    "end": "2127417"
  },
  {
    "text": "Similarly to observeOn, we can change where the work of the observable happens.",
    "start": "2130760",
    "end": "2135984"
  },
  {
    "text": "So, if we are doing a network request, that network request is still going to be done synchronously,",
    "start": "2135984",
    "end": "2142409"
  },
  {
    "text": "but we don't want it to\nhappen on the main thread, so what we do is we can apply an operator that changes where we\nsubscribe to the observable,",
    "start": "2142409",
    "end": "2149825"
  },
  {
    "text": "and where we subscribe is\nwork ultimately happens, so now, when we subscribe\nto our background response,",
    "start": "2149825",
    "end": "2155449"
  },
  {
    "text": "it will change to the background thread, I/O is just a thread pool\nof threads you can use,",
    "start": "2155449",
    "end": "2162400"
  },
  {
    "text": "and so it will do work\non that thread pool, and then send out the notification\nto whoever is listening.",
    "start": "2163653",
    "end": "2170935"
  },
  {
    "text": "SubscribeOn here being the operator to change where the work happens. What's nice is that,\nbecause these all return,",
    "start": "2170936",
    "end": "2178444"
  },
  {
    "text": "you know, a new observable, and all these methods exist on observable, we can compose them,\nand chain them together,",
    "start": "2178444",
    "end": "2185250"
  },
  {
    "text": "so what you normally see is that we don't have intermediate\nvariables for these,",
    "start": "2185250",
    "end": "2190416"
  },
  {
    "text": "we are just applying the\noperators in a certain order. We want a response, or sorry,",
    "start": "2190416",
    "end": "2195682"
  },
  {
    "text": "we want to request execute\non the background thread, we want to observe the\nresult of that request",
    "start": "2195683",
    "end": "2201209"
  },
  {
    "text": "on the main thread, and we want to, say, change the response into, you know,",
    "start": "2201209",
    "end": "2206461"
  },
  {
    "text": "a string, we want to read the string. Except, again, order here matters. Because I applied the map\noperator after observeOn,",
    "start": "2206461",
    "end": "2215151"
  },
  {
    "text": "that's going to run on\nAndroid's main thread, and we don't want to be\nreading from an HTTP response",
    "start": "2215152",
    "end": "2220795"
  },
  {
    "text": "on the main thread, we want that to be happening before we change to the main thread,",
    "start": "2220795",
    "end": "2225992"
  },
  {
    "text": "and so the request comes\nin, and it, you know, emits the response down\nthe observable chain,",
    "start": "2225992",
    "end": "2232346"
  },
  {
    "text": "we map that into the result string, and then we change threads\nto the main thread, where we can ultimately\nsubscribe, and show it in the UI.",
    "start": "2232346",
    "end": "2240903"
  },
  {
    "text": "Then, there's other operators, I skipped flatMap, so\nI'll just skip it here.",
    "start": "2243561",
    "end": "2248835"
  },
  {
    "text": "Where we see some of those other types, you will notice that\nthese were all observable. There's other operators which\nactually take observable,",
    "start": "2252133",
    "end": "2259612"
  },
  {
    "text": "and return it into a different type, and so an operator like first is going to take the first element\nthat's emitted from a string,",
    "start": "2259612",
    "end": "2267038"
  },
  {
    "text": "and return it to you. In RxJava 1, we got back and observable that only emitted one item.",
    "start": "2267039",
    "end": "2273678"
  },
  {
    "text": "This is kind of weird, because\nif you have a list of items, and you call get on it\nto get the first item,",
    "start": "2273678",
    "end": "2278813"
  },
  {
    "text": "you don't get back a\nlist with only one item. What you get back is the\nscaler, and we know that,",
    "start": "2278813",
    "end": "2284284"
  },
  {
    "text": "well, now we have a type\nthat models the scaler, in the reactive world, so, in RxJava 2,",
    "start": "2284284",
    "end": "2289627"
  },
  {
    "text": "when you call this first operator, which is guaranteed to\nonly return one element, you get back a single.",
    "start": "2289627",
    "end": "2295746"
  },
  {
    "text": "If the observable is empty, this will actually result in an error, because we know a single\neither has an item, or errors,",
    "start": "2298144",
    "end": "2305119"
  },
  {
    "text": "and those so there's other\noperators like firstElement, which is actually going\nto return you now a maybe.",
    "start": "2305119",
    "end": "2311853"
  },
  {
    "text": "When the observable is empty, maybe can actually model that by completing without an error.",
    "start": "2312942",
    "end": "2319198"
  },
  {
    "text": "There's ones that also return completable, so if you are just ignoring the elements, all you care about is whether\nit completes or fails,",
    "start": "2321271",
    "end": "2328751"
  },
  {
    "text": "that now returns completable, and that's exactly what\ncompletable models.",
    "start": "2328751",
    "end": "2334027"
  },
  {
    "text": "All these exist on flowable as well, so they all have the same operators, they all return the\nsame specialized types.",
    "start": "2335034",
    "end": "2343715"
  },
  {
    "text": "This is a chart that kind of\nshows some of the operators, and the upper right-hand corner of this",
    "start": "2343715",
    "end": "2350885"
  },
  {
    "text": "is basically where the types narrow, so when you call something, like you want to count the\nnumber of items in a stream,",
    "start": "2350885",
    "end": "2357520"
  },
  {
    "text": "account is always a single value, so you get a narrower type, like single, and then we also have operators\nwhich do the opposite,",
    "start": "2357520",
    "end": "2364134"
  },
  {
    "text": "which is, you know, take a type, and turn it into something more broad, so you can take a single, and\nturn it into an observable.",
    "start": "2364134",
    "end": "2372466"
  },
  {
    "text": "Okay, back to our original example. If we want to be reactive with it, we can, you know, subscribe to our user,",
    "start": "2373341",
    "end": "2380601"
  },
  {
    "text": "say, I want notifications\non the main thread, and then I want to shove that into the UI,",
    "start": "2380601",
    "end": "2385731"
  },
  {
    "text": "display that user. Anytime the user changes, this code is automatically going to run, you are automatically\ngoing to see updates,",
    "start": "2385731",
    "end": "2391644"
  },
  {
    "text": "and we no longer have to worry about managing this ourselves. However, we do have to remember to manage",
    "start": "2391644",
    "end": "2396845"
  },
  {
    "text": "the disposable that gets returned, because we are in the Android world,",
    "start": "2396845",
    "end": "2402452"
  },
  {
    "text": "and when our activity disappears, we want this code to stop running. In onDestroy, we would,\nyou know, dispose of this,",
    "start": "2402452",
    "end": "2409733"
  },
  {
    "text": "dispose of the disposables. Similarly, when we ultimately make",
    "start": "2409733",
    "end": "2414912"
  },
  {
    "text": "an asynchronous request to change data, we want that to happen\non a background thread, we want to observe the\nresult of the main thread,",
    "start": "2414913",
    "end": "2422020"
  },
  {
    "text": "whether it succeeds or\nfails, and, you know, in the success callback,\nwe could, you know,",
    "start": "2422020",
    "end": "2428460"
  },
  {
    "text": "essentially reenable the\ntext box or whatever. Again, because you wouldn't\nopen a file without closing it,",
    "start": "2428460",
    "end": "2436018"
  },
  {
    "text": "you wouldn't subscribe without\nmanaging the disposable, so we had this to our disposable list.",
    "start": "2436018",
    "end": "2441965"
  },
  {
    "text": "I'm actually going to skip this, just because I'm a little low on time, but a nice thing about RxJava 2,",
    "start": "2443865",
    "end": "2450000"
  },
  {
    "text": "compared to RxJava 1 is that there's a fundamental architecture shift.",
    "start": "2450000",
    "end": "2454590"
  },
  {
    "text": "What that affords, on\nAndroid specifically, is that there's just\nless intermediate objects being created, so when\nyou create these streams,",
    "start": "2456688",
    "end": "2464547"
  },
  {
    "text": "every operator you call has\nto return a new observable that implements that behavior. When you call map, you\nget a new observable",
    "start": "2464548",
    "end": "2471057"
  },
  {
    "text": "that takes the old one, runs a function, and, you know, emits the new data, and so that requires a bunch of objects,",
    "start": "2471057",
    "end": "2477484"
  },
  {
    "text": "intermediate objects to be allocated in order to model that stream. RxJava 2 actually changed\nhow this works in a way",
    "start": "2477484",
    "end": "2486337"
  },
  {
    "text": "that we actually get less\nintermediate objects created. Oops, I wanted to.",
    "start": "2486337",
    "end": "2491864"
  },
  {
    "text": "You get less allocation to\nactually create the stream, which is call the operators. Each one actually results in\none less object being created,",
    "start": "2493754",
    "end": "2502083"
  },
  {
    "text": "and there's also less overhead\nwhen subscribing to a stream. There's less method\ndispatch that has to happen,",
    "start": "2502083",
    "end": "2508454"
  },
  {
    "text": "and so ultimately what we\nget is the faster, less GC,",
    "start": "2508454",
    "end": "2512621"
  },
  {
    "text": "causing less GC version of the library, without any compromise in the API.",
    "start": "2514229",
    "end": "2520597"
  },
  {
    "text": "So, RxJava 2 is basically this idea that we want to take these things, which are fundamentally\nasynchronous in Android,",
    "start": "2523305",
    "end": "2530727"
  },
  {
    "text": "whether it be the network, Android itself, database, even the UI, modeled\nas an asynchronous source,",
    "start": "2530727",
    "end": "2537852"
  },
  {
    "text": "and write code that reacts\nto changes in these sources, instead of trying to cope with changes,",
    "start": "2537852",
    "end": "2543903"
  },
  {
    "text": "and manage state ourselves. Right now, it's in a\ndeveloper preview release,",
    "start": "2543903",
    "end": "2549245"
  },
  {
    "text": "so we are basically finalizing the API, and in about a month, it\nwill have its final release, where it will be available,",
    "start": "2549246",
    "end": "2557024"
  },
  {
    "text": "I mean, it's already\navailable to put in your app, but the API might change, and the final release solidifies the API,",
    "start": "2557024",
    "end": "2562237"
  },
  {
    "text": "so that things like\nlibraries can start using it, and exposing these types automatically.",
    "start": "2562237",
    "end": "2568535"
  },
  {
    "text": "If you do use RxJava 1, there's actually a project which allows you\nto convert between the types,",
    "start": "2568535",
    "end": "2574031"
  },
  {
    "text": "and so this will allow you to\nincrementally update your app. If you are interested in\nthat, here's the link.",
    "start": "2574031",
    "end": "2581872"
  },
  {
    "text": "Your dependencies for that\nwill ultimately look like this. Where I want to end is basically,",
    "start": "2581872",
    "end": "2587873"
  },
  {
    "text": "RxJava 2 is not something new, reactive programming is\nnot new, by any stretch,",
    "start": "2588770",
    "end": "2594139"
  },
  {
    "text": "but Android itself, for whatever reason, is this highly reactive world that",
    "start": "2594139",
    "end": "2600402"
  },
  {
    "text": "we've been taught to model in a very imperative, stateful fashion, and just try and cope with the fact",
    "start": "2602403",
    "end": "2608730"
  },
  {
    "text": "that we have to manage all\nthese things ourselves, and reactive programming, and RxJava in general\nallows us to model it",
    "start": "2608730",
    "end": "2615402"
  },
  {
    "text": "in the proper way, which\nis that it is asynchronous,",
    "start": "2615402",
    "end": "2619569"
  },
  {
    "text": "embrace the asynchronicity of the sources, and instead of trying to\nmanage all the state ourselves,",
    "start": "2620792",
    "end": "2626003"
  },
  {
    "text": "compose them together, such that our app becomes truly reactive, and now, really all we are concerned about",
    "start": "2626003",
    "end": "2633058"
  },
  {
    "text": "is how to build those arrows, and is not actually how to\nmanage the state of the data",
    "start": "2633058",
    "end": "2638585"
  },
  {
    "text": "that's flowing through the system. That's all I have for you. Thanks everyone for coming.",
    "start": "2638585",
    "end": "2644116"
  },
  {
    "text": "(applause)",
    "start": "2644116",
    "end": "2646366"
  }
]