[
  {
    "text": "[Music]",
    "start": "3670",
    "end": "8760"
  },
  {
    "text": "thank you very much Ken um yeah so today I'm here to talk about es codc and and",
    "start": "9400",
    "end": "14519"
  },
  {
    "text": "binary stuff I really like that um no hopefully uh you get a better idea today about uh this library and and why I",
    "start": "14519",
    "end": "22039"
  },
  {
    "text": "built it um along with uh you know all my collaborators especially piaano um",
    "start": "22039",
    "end": "28119"
  },
  {
    "text": "and and then really understand and and perhaps be excited for Scola 3 and and pting your own libraries and your own",
    "start": "28119",
    "end": "34600"
  },
  {
    "text": "applications uh to this exciting new platform um so anyway I'm thrilled to be here and I uh you know I'm really",
    "start": "34600",
    "end": "40719"
  },
  {
    "text": "excited to be uh speaking from the suburbs of Philadelphia in the US so",
    "start": "40719",
    "end": "46440"
  },
  {
    "text": "sodc um it's binary stuff um sodc is really a a set of libraries related to",
    "start": "46440",
    "end": "55440"
  },
  {
    "text": "Binary processing um really in like a sort of contract first way um so so it's",
    "start": "55440",
    "end": "62960"
  },
  {
    "text": "sort of interesting to say like es codc is not another pickling library right it's not a serialization library it does",
    "start": "62960",
    "end": "69080"
  },
  {
    "text": "not compete with AV or um any of the you know the pickling libraries that you may be familiar with rather you know it's",
    "start": "69080",
    "end": "76560"
  },
  {
    "text": "it's really designed for things like working with you know formal specifications of binary um in my",
    "start": "76560",
    "end": "82400"
  },
  {
    "text": "background that's typically working with MPEG transport streams like MPEG 2 containers containing you know",
    "start": "82400",
    "end": "89240"
  },
  {
    "text": "Elementary streams of of video and audio and and data um but it's also been used",
    "start": "89240",
    "end": "94640"
  },
  {
    "text": "for a ton of stuff in Industry like in the iot space for medical devices um",
    "start": "94640",
    "end": "100439"
  },
  {
    "text": "it's been used as a as a serialization framework a pickling framework in um the old remotely open source library for for",
    "start": "100439",
    "end": "107680"
  },
  {
    "text": "h binary communication um things like that um so just to get started I wanted to to let this cat out of the bag the um",
    "start": "107680",
    "end": "115240"
  },
  {
    "text": "the sodc logo here is pictured and you know seven or eight years ago when we",
    "start": "115240",
    "end": "120280"
  },
  {
    "text": "first published the library I put this logo up on GitHub and Paul chano kind of teased me and said you know what um what",
    "start": "120280",
    "end": "127079"
  },
  {
    "text": "is that decode to and sure enough if you run it through sodec asky decoder you get back the string sodec it it is the",
    "start": "127079",
    "end": "134760"
  },
  {
    "text": "the word sodec in binary asky um to give you an idea of the the general way that",
    "start": "134760",
    "end": "140640"
  },
  {
    "text": "you work with the library the primary data type is really this codec data type so here asky the the term asky is a type",
    "start": "140640",
    "end": "149480"
  },
  {
    "text": "Cod string and we decode some some series of",
    "start": "149480",
    "end": "154560"
  },
  {
    "text": "bits um sodex a little bit different than a lot of other libraries that work with binary in that um you know it's",
    "start": "154560",
    "end": "160879"
  },
  {
    "text": "really sort of bit first all of the manipulation is really done at the bit level not not at the bite level um and",
    "start": "160879",
    "end": "168200"
  },
  {
    "text": "you know when we try to decode this this bit string we get back sort of an either right uh in this case it's this type",
    "start": "168200",
    "end": "174879"
  },
  {
    "text": "called successful um but it's sort of like an either right you can either have a failure or can be successful and then we",
    "start": "174879",
    "end": "181319"
  },
  {
    "text": "get a decode result in this case the strings codec and then whatever remaining bits were",
    "start": "181319",
    "end": "187720"
  },
  {
    "text": "unconsumed by the asky codec so you can sort of think of a codec as a pairing of",
    "start": "187720",
    "end": "193480"
  },
  {
    "text": "like an encoding function a decoding function some other metadata we'll look at later um and really there's sort of",
    "start": "193480",
    "end": "200640"
  },
  {
    "text": "like this sort of built-in State monad type thing that that when we decode we're going to um return these",
    "start": "200640",
    "end": "208480"
  },
  {
    "text": "remainders um today really what I want to focus on is the transition from Scala 2 to Scola 3",
    "start": "208480",
    "end": "216879"
  },
  {
    "text": "and uh we're g to start easy and jump right into macros um no we're not going to spend a lot of time on Macros um but",
    "start": "216879",
    "end": "223200"
  },
  {
    "text": "really what we're going to do is is walk through the Journey you know that that",
    "start": "223200",
    "end": "228439"
  },
  {
    "text": "um I went through and when trying to Port this Library given that it is a mature Library it's been around for a",
    "start": "228439",
    "end": "233840"
  },
  {
    "text": "while and it's used as a in in a lot of other libraries as infrastructure so we wanted to take things like Source",
    "start": "233840",
    "end": "239200"
  },
  {
    "text": "compatibility and binary compatibility pretty seriously uh at the same time you",
    "start": "239200",
    "end": "244319"
  },
  {
    "text": "know a mature library with you know hundreds and thousands of of um users it's not the place to sort of experiment",
    "start": "244319",
    "end": "251120"
  },
  {
    "text": "with new um language constructs right and there are a lot of new language",
    "start": "251120",
    "end": "256600"
  },
  {
    "text": "constructs in Scola 3 so one of the things we'll look at is you know is there anything here for libraries that",
    "start": "256600",
    "end": "263639"
  },
  {
    "text": "are established is there anything in Scola 3 that can help us really simplify those libraries not make them more",
    "start": "263639",
    "end": "269880"
  },
  {
    "text": "complex um you know we'll we'll see some examples of that today um and we're really going to focus mostly on uh sort",
    "start": "269880",
    "end": "276880"
  },
  {
    "text": "of um generic programming and and things that maybe in the past would have",
    "start": "276880",
    "end": "281960"
  },
  {
    "text": "required shapeless um so we'll walk through this list um as we go through so to get started I thought you",
    "start": "281960",
    "end": "289960"
  },
  {
    "text": "know one way to look at this is to look at um one of the features that folks use a",
    "start": "289960",
    "end": "295560"
  },
  {
    "text": "lot in like test code when working with sodec which is our support for for literal interpolators um so really what",
    "start": "295560",
    "end": "302280"
  },
  {
    "text": "I mean here is you know some type of syntax that makes it very simple maybe",
    "start": "302280",
    "end": "307400"
  },
  {
    "text": "in tests you know maybe in production code as well um for instantiating stps um uh strings of either bits or bytes so",
    "start": "307400",
    "end": "315800"
  },
  {
    "text": "you can see here we've got you know three different examples um we're using scala's um you know string interpolator",
    "start": "315800",
    "end": "322039"
  },
  {
    "text": "support So if you say hex and then a string and follow it with a bunch of heximal um you get back a value of type",
    "start": "322039",
    "end": "328880"
  },
  {
    "text": "bite vector um little side note about the the origin of Library when we first prototyped it",
    "start": "328880",
    "end": "335639"
  },
  {
    "text": "we literally represented these bite strings as a Scala Vector of bite um and",
    "start": "335639",
    "end": "341520"
  },
  {
    "text": "I remember saying to Paul you know hey I got a big to-do is to replace this Vector bite this thing that that boxes",
    "start": "341520",
    "end": "346960"
  },
  {
    "text": "terribly all over the place with something performing um and and out of that came this bit vector and bite",
    "start": "346960",
    "end": "352840"
  },
  {
    "text": "Vector data structures if you've used like aa's bite string it's very very similar um bite Vector lets us you know",
    "start": "352840",
    "end": "360639"
  },
  {
    "text": "have um you know efficient immutable interaction with with strings of bites",
    "start": "360639",
    "end": "366400"
  },
  {
    "text": "bit Vector is the same and in particular is optimized for um constant time amortized constant time of pens uh and",
    "start": "366400",
    "end": "373240"
  },
  {
    "text": "that's that's an essential property for this stuff we're going to do in a few minutes with the escoda core Library so",
    "start": "373240",
    "end": "379440"
  },
  {
    "text": "anyway so this becomes pretty important syntax um furthermore we do want uh compile time errors if using these",
    "start": "379440",
    "end": "386479"
  },
  {
    "text": "literals in a way that's uh you know invalid right so this this third example here of of trying to claim the string",
    "start": "386479",
    "end": "393440"
  },
  {
    "text": "cow is actually hexadecimal should result in a compile time error not a runtime",
    "start": "393440",
    "end": "399639"
  },
  {
    "text": "error this is one of the um the biggest things you'll run into when porting Library code from scud to Scala 3 is",
    "start": "399639",
    "end": "406080"
  },
  {
    "text": "that the macro system has been completely revamped um the Scala 3 macro system is much less powerful than the",
    "start": "406080",
    "end": "412280"
  },
  {
    "text": "Scala 2 macro system intentionally right the scy 2 macro system sort of exposed all sorts of internals of the compiler",
    "start": "412280",
    "end": "420039"
  },
  {
    "text": "and really gave too much power to library authors now to implement this",
    "start": "420039",
    "end": "425520"
  },
  {
    "text": "particular string literal um pattern we're going to use a couple different features and we're not going to really use any features that are um you know",
    "start": "425520",
    "end": "432680"
  },
  {
    "text": "removed from Scala 3 but we do have to encode them a bit differently so it's macro code I'm not",
    "start": "432680",
    "end": "438599"
  },
  {
    "text": "going to spend a lot of time on the details here because um it gets pretty complex um but here's the general idea",
    "start": "438599",
    "end": "445440"
  },
  {
    "text": "of of how this gets implemented um you can see a a Bunch new keywords right um",
    "start": "445440",
    "end": "452360"
  },
  {
    "text": "the the inline keyword shows up three different times the inline keyword is new to Scola 3 and in essence or or at",
    "start": "452360",
    "end": "459120"
  },
  {
    "text": "least a good way to think about it is that it it really means that um at the call site at compile time um rather than",
    "start": "459120",
    "end": "465560"
  },
  {
    "text": "having like a runtime call to this particular uh method it would get um",
    "start": "465560",
    "end": "470919"
  },
  {
    "text": "inline that the implementation of this method will get inline to that call site so in this case what we're doing is",
    "start": "470919",
    "end": "477639"
  },
  {
    "text": "combining a in line macro with Scola 3's extension method",
    "start": "477639",
    "end": "484120"
  },
  {
    "text": "syntax and so we're defining extension method called hex on the string context",
    "start": "484120",
    "end": "490280"
  },
  {
    "text": "uh type from the standard Library um and by doing that uh we're",
    "start": "490280",
    "end": "496960"
  },
  {
    "text": "able to to get support for that hex followed by a string syntax the implementation of that",
    "start": "496960",
    "end": "503400"
  },
  {
    "text": "function um uses the new macro syntax you know where we say um we're going to",
    "start": "503400",
    "end": "509599"
  },
  {
    "text": "expand this particular macro with the following validate hex operation at compile",
    "start": "509599",
    "end": "515880"
  },
  {
    "text": "time and so when we look at the validate hex operation we can see we're no longer",
    "start": "515880",
    "end": "521518"
  },
  {
    "text": "you know looking at like a regular method we're really looking at code that's going to execute um you know at compile time by the compiler um and in",
    "start": "521519",
    "end": "528640"
  },
  {
    "text": "essence what we're going to do is ask the scolar compiler to validate that the string context is passed statically",
    "start": "528640",
    "end": "535240"
  },
  {
    "text": "there's nothing like Dynamic going on that can't be otherwise like reified by the compiler we're doing that via this",
    "start": "535240",
    "end": "541279"
  },
  {
    "text": "like unlift operation as long as that works we're able to actually call Methods at compile",
    "start": "541279",
    "end": "547279"
  },
  {
    "text": "time on the string context and so we call this sc. Parts method to sort of reach into that string context and get",
    "start": "547279",
    "end": "553760"
  },
  {
    "text": "that string back out the string that contains the um the digits that we want to validate right so don't worry too",
    "start": "553760",
    "end": "560560"
  },
  {
    "text": "much about the syntax and we'll talk more about like using keyword as we go",
    "start": "560560",
    "end": "565839"
  },
  {
    "text": "on once we've got that you know those indiv ual parts of the string out um we",
    "start": "566200",
    "end": "572480"
  },
  {
    "text": "basically want to do a couple things we want to assert that there's only a single string that that we don't have",
    "start": "572480",
    "end": "578000"
  },
  {
    "text": "like variables stuck throughout our string um the way the string context type represents like a string followed",
    "start": "578000",
    "end": "584760"
  },
  {
    "text": "by a variable fed by another literal string is in essence by two strings with a variable stuck between them so we want",
    "start": "584760",
    "end": "591720"
  },
  {
    "text": "to exclude all that and just say like let's just assert that there's a single value um we do that with this check for",
    "start": "591720",
    "end": "597120"
  },
  {
    "text": "parts. sizes one um as long as it is we can call a code on bite Vector to",
    "start": "597120",
    "end": "603200"
  },
  {
    "text": "validate the heximal conversion and if that passes we have this um splice",
    "start": "603200",
    "end": "608760"
  },
  {
    "text": "expression here we're going to say um inline the total result of this macro to this one call this one expression B",
    "start": "608760",
    "end": "615959"
  },
  {
    "text": "vector. from valid hex and so you can see this a little bit different if you're familiar with Scala 2 macros it's",
    "start": "615959",
    "end": "621760"
  },
  {
    "text": "a little bit different because we have a a much more sophisticated um splicing capability um and of course you can also",
    "start": "621760",
    "end": "628560"
  },
  {
    "text": "issue compile time errors Etc so that's cool um with that",
    "start": "628560",
    "end": "634320"
  },
  {
    "text": "capability uh we were able to replicate the exact you know string literal support we had with Scala",
    "start": "634320",
    "end": "639639"
  },
  {
    "text": "2 but maybe more interestingly um there is a a feature",
    "start": "639639",
    "end": "646560"
  },
  {
    "text": "built into Scola 3 called numeric literals or um customizable numeric literals that like as you scan down the",
    "start": "646560",
    "end": "652880"
  },
  {
    "text": "list of of scolar 3 features you're probably going to scan right over this one because not all of us write cust",
    "start": "652880",
    "end": "659120"
  },
  {
    "text": "some numeric types right maybe if you write like a library like Spire then",
    "start": "659120",
    "end": "664200"
  },
  {
    "text": "then sure um that could be interesting but but for most of us we're going to scan right past that one um but here's a",
    "start": "664200",
    "end": "669600"
  },
  {
    "text": "pretty interesting use case I thought and this was uh recommended by Orin port on the um this the mailing list um but",
    "start": "669600",
    "end": "678120"
  },
  {
    "text": "the general idea here is that the compiler has a hook that lets Library",
    "start": "678120",
    "end": "683839"
  },
  {
    "text": "authors or application authors to um register their own conversions from digit strings to arbitrary types so here",
    "start": "683839",
    "end": "692480"
  },
  {
    "text": "we have both uh two expressions Val X and v y one of them we've annotated with the type bite vector and the second",
    "start": "692480",
    "end": "699480"
  },
  {
    "text": "we've anotated with the type bit vector and in both cases we just have a a plain old numeric literal right we're not",
    "start": "699480",
    "end": "705680"
  },
  {
    "text": "putting in strings we're not calling macros um and and in fact in in the case of Val X we have something that's like",
    "start": "705680",
    "end": "712760"
  },
  {
    "text": "you know 20 hex tets long right 40 different digits in that particular string um so this is not limited to like",
    "start": "712760",
    "end": "719920"
  },
  {
    "text": "numerics that can be represented with along on the jvm for example and it just does what we want",
    "start": "719920",
    "end": "726560"
  },
  {
    "text": "right it basically is going to look at the assigned type right and say okay",
    "start": "726560",
    "end": "731680"
  },
  {
    "text": "well someone's trying you know they have a numeric little here and they're trying to assign it to a bite vector and they're going to the compiler is going",
    "start": "731680",
    "end": "737600"
  },
  {
    "text": "to look for an instance of a type class uh to do this conversion from a string to a custom type so in the Scola 3",
    "start": "737600",
    "end": "746519"
  },
  {
    "text": "standard Library there's this new type class called from digits and it has a subtype called with Radix oh sorry with",
    "start": "746519",
    "end": "754000"
  },
  {
    "text": "Radix um and it in in effect lets us uh parse those strings in a completely General",
    "start": "754000",
    "end": "760079"
  },
  {
    "text": "way um in this particular case we Define this instance in the bite Vector companion object and rather than saying",
    "start": "760079",
    "end": "767160"
  },
  {
    "text": "like implicit Val and defining you know sort of the Scala 2 way of doing an implicit definition we're going to use a",
    "start": "767160",
    "end": "773040"
  },
  {
    "text": "Scala 3way here and just say here's a you know here here compiler I'm giving you an instance of this width r type",
    "start": "773040",
    "end": "779480"
  },
  {
    "text": "class for the type bite Vector so that was a a pretty neat um",
    "start": "779480",
    "end": "785760"
  },
  {
    "text": "change I would say when uh when you look at like code you know comparing Scola 2 to Scola 3 especially like test cases",
    "start": "785760",
    "end": "791920"
  },
  {
    "text": "where you've got like hundreds of these invocations of those macros it really does clean up use cases or use",
    "start": "791920",
    "end": "799040"
  },
  {
    "text": "sites okay but I want to spend most of the time today talking about a companion",
    "start": "799040",
    "end": "804800"
  },
  {
    "text": "project called escod at core um and this is really the project that you know we started with where we have codecs and we",
    "start": "804800",
    "end": "810199"
  },
  {
    "text": "have encoding functions and decoding functions and so forth and really with sodec core you know the the key idea is",
    "start": "810199",
    "end": "817360"
  },
  {
    "text": "that um you have a set of like atom codecs like the the smallest possible codecs codecs that maybe um encode an",
    "start": "817360",
    "end": "824040"
  },
  {
    "text": "individual 8bit integer or an individual um bit right in this case this bull",
    "start": "824040",
    "end": "829600"
  },
  {
    "text": "codec literally encodes an individual bit into a bitstream um or you know or",
    "start": "829600",
    "end": "834800"
  },
  {
    "text": "strings or all sorts of things and we're going to build bigger and bigger and bigger codecs using a very simple",
    "start": "834800",
    "end": "839839"
  },
  {
    "text": "algebra um and very simple set of combinators built with that",
    "start": "839839",
    "end": "845120"
  },
  {
    "text": "algebra um and one of the most common combinators we we use is really like",
    "start": "845120",
    "end": "850560"
  },
  {
    "text": "putting together individual codecs consecutively right like first encode an",
    "start": "850560",
    "end": "855800"
  },
  {
    "text": "8bit signed integer and then after that finishes encode a single bit Boolean and then encode like a a null terminated C",
    "start": "855800",
    "end": "863399"
  },
  {
    "text": "string in sodec for schola 2 we had three different major ways of doing this",
    "start": "863399",
    "end": "870040"
  },
  {
    "text": "um and they're expressed here at these these three Expressions the first was the ti day operator the till operator in",
    "start": "870040",
    "end": "877040"
  },
  {
    "text": "in essence generated left nested tupal it's really simple to write it's really simple to understand if you look at the",
    "start": "877040",
    "end": "882959"
  },
  {
    "text": "implementation of it it's just it's it's obvious right um there's no magic to it",
    "start": "882959",
    "end": "888240"
  },
  {
    "text": "it's it's very simple but unfortunately that you end up with these really nasty left nested tupal and depending on",
    "start": "888240",
    "end": "893959"
  },
  {
    "text": "exactly like what other combinators you're using in between you might end up with like lots of strangely nested tupal",
    "start": "893959",
    "end": "901399"
  },
  {
    "text": "all kind of put together in a strange way so we have um this other operation double till day that can generate tupal",
    "start": "901399",
    "end": "909680"
  },
  {
    "text": "of like the correct aity in this case like I take int8 and double till on to Boolean and I get back",
    "start": "909680",
    "end": "916959"
  },
  {
    "text": "a tuple of a pair for in Boolean and if I do two more tupes I get back a triple right and I can continue to extend that",
    "start": "916959",
    "end": "923160"
  },
  {
    "text": "growing the tupal one by one but it's a lot of boiler plate and it doesn't play",
    "start": "923160",
    "end": "928360"
  },
  {
    "text": "nice with others um it doesn't it doesn't work well with other combinators so really almost always folks that are",
    "start": "928360",
    "end": "936160"
  },
  {
    "text": "using us codec really settle on this this third um option which in essence is",
    "start": "936160",
    "end": "941959"
  },
  {
    "text": "let's use heterogeneous lists right from shapeless directly in the API of the",
    "start": "941959",
    "end": "947399"
  },
  {
    "text": "library so this is quite different from libraries that generate you",
    "start": "947399",
    "end": "952519"
  },
  {
    "text": "know type class instances you know via shapeless like derivation uh this really is fullon",
    "start": "952519",
    "end": "959199"
  },
  {
    "text": "right in your face API right you're you're manipulating hlist you're manipulating co-products um a lot of",
    "start": "959199",
    "end": "966160"
  },
  {
    "text": "shapeless stuff uh comes right to the top okay besides just the duplication",
    "start": "966160",
    "end": "972440"
  },
  {
    "text": "besides just having multiple options one of the other downsides of this approach is that as a library author you have to",
    "start": "972440",
    "end": "979480"
  },
  {
    "text": "figure out like which of these are you going to optimize for so there are cases in the library we have multiple",
    "start": "979480",
    "end": "985240"
  },
  {
    "text": "implementations of certain common combinators to support these different",
    "start": "985240",
    "end": "990720"
  },
  {
    "text": "shapes so the neat thing is in Scola 3 we can abstract over Tuple",
    "start": "990720",
    "end": "996920"
  },
  {
    "text": "arity right we can we can write code that um is generic and yet preserves tup",
    "start": "996920",
    "end": "1004120"
  },
  {
    "text": "arity so in this particular case you can see we kind of lifted the syntax that we used previously the the colon colon",
    "start": "1004120",
    "end": "1010079"
  },
  {
    "text": "syntax the cons syntax I'll pronounce it the rest of our talk today um but I just",
    "start": "1010079",
    "end": "1015680"
  },
  {
    "text": "get the right types back like I just it's it's what I expect right if I cons three things together I get a codec of a",
    "start": "1015680",
    "end": "1021519"
  },
  {
    "text": "triple and if on top of that I cons another you know a codc in this case",
    "start": "1021519",
    "end": "1026520"
  },
  {
    "text": "along I get back a codic of a of a tupal four and so this is now possible because",
    "start": "1026520",
    "end": "1033520"
  },
  {
    "text": "in essence the the uh tupal Machinery built into Scala 3 has a bunch of sort",
    "start": "1033520",
    "end": "1039918"
  },
  {
    "text": "of fixed tupal sizes internally and then eventually switches to an hlist like",
    "start": "1039919",
    "end": "1045880"
  },
  {
    "text": "representation and so like the Tuple 22 limit that we all know and and perhaps love um is has now been",
    "start": "1045880",
    "end": "1053080"
  },
  {
    "text": "removed but rather than just like being able to represent you know ridiculously large tupal um what's cool is we can",
    "start": "1053080",
    "end": "1059280"
  },
  {
    "text": "write code that is generic is polymorphic over the tupal size so we're",
    "start": "1059280",
    "end": "1064440"
  },
  {
    "text": "going to look at this a little bit and see how this works this is a lot of syntax um don't worry too much about all",
    "start": "1064440",
    "end": "1069919"
  },
  {
    "text": "the syntax uh here's the the gist of it um there's a new type in the library called",
    "start": "1069919",
    "end": "1075559"
  },
  {
    "text": "tupal um there's two subtypes of that the empty tupal which is just an object",
    "start": "1075559",
    "end": "1081039"
  },
  {
    "text": "and a non-empty tupal and there's one important subtype that we care about here of non empty",
    "start": "1081039",
    "end": "1087640"
  },
  {
    "text": "Tuple which is this cons class this star colon class so it's",
    "start": "1087640",
    "end": "1094679"
  },
  {
    "text": "kind of a strange syntax right but we all know that Scala lets us um you know name things uh name name types using um",
    "start": "1094679",
    "end": "1102559"
  },
  {
    "text": "not just letters and and numbers right so we have a class called staron it's got a head and it's got another or and",
    "start": "1102559",
    "end": "1108840"
  },
  {
    "text": "it's got a tail the tail must be another tupal okay so let's see how we can use",
    "start": "1108840",
    "end": "1114720"
  },
  {
    "text": "these constructs to um Implement some of the things we just saw um one is at the",
    "start": "1114720",
    "end": "1120799"
  },
  {
    "text": "at the term level we can use the con's operator to grow the sizes of tupes",
    "start": "1120799",
    "end": "1126080"
  },
  {
    "text": "right so if I have a triple and I cons on a one in front I get back a tupal four and again um what's important here",
    "start": "1126080",
    "end": "1133559"
  },
  {
    "text": "is not that I can grow a tupal but rather look at the type that's inferred by The Scholar three compiler uh the",
    "start": "1133559",
    "end": "1140159"
  },
  {
    "text": "type here is a tupal four it is not like a dependent type you know referencing a",
    "start": "1140159",
    "end": "1146520"
  },
  {
    "text": "bunch of shapeless stuff that's going to confuse you know my colleagues that are working in the same code base",
    "start": "1146520",
    "end": "1152320"
  },
  {
    "text": "right um similarly there's a bunch of other operators that are built into the library where you can sort of treat",
    "start": "1152320",
    "end": "1158240"
  },
  {
    "text": "tupes like collections to some degree a bunch of other maybe maybe a dozen or two uh collection like operator so here",
    "start": "1158240",
    "end": "1165559"
  },
  {
    "text": "we have a concat we take two pairs and um concat them together and we get back the same",
    "start": "1165559",
    "end": "1171600"
  },
  {
    "text": "quadruple and then finally we can pattern match we can destructure tupes so here we have this this uh quadruple a",
    "start": "1171600",
    "end": "1180320"
  },
  {
    "text": "and we destructure it into a head and a tail and again look at the inferred types that's what's nice um the type of",
    "start": "1180320",
    "end": "1187080"
  },
  {
    "text": "H is int and the type of tail is a triple right so it just does what we'd expect right it's it's it's um it feels",
    "start": "1187080",
    "end": "1194000"
  },
  {
    "text": "very natural so the exercise I to walk through is how can we make that",
    "start": "1194000",
    "end": "1200120"
  },
  {
    "text": "expression we saw earlier work in Scola 3 and it's going to require us to to manipulate some of these um generic",
    "start": "1200120",
    "end": "1207120"
  },
  {
    "text": "Tuple structures so the first thing to note is the cons operator since it ends in a",
    "start": "1207120",
    "end": "1212280"
  },
  {
    "text": "colon is Right associative right standard standard Scala it's been been like that for as long as I've been doing",
    "start": "1212280",
    "end": "1217720"
  },
  {
    "text": "Scala and I started with 27 um so our initial expression is",
    "start": "1217720",
    "end": "1223400"
  },
  {
    "text": "really going to parse sort of like this right it's gonna be right associative and we're first going to worry about this bull conon C string",
    "start": "1223400",
    "end": "1229520"
  },
  {
    "text": "uh as we um look at that really what we're going to get back what we want back from that is a codic of a pair of",
    "start": "1229520",
    "end": "1235280"
  },
  {
    "text": "Boolean string and then when we cons that with a codec in we want this this codak of a",
    "start": "1235280",
    "end": "1240559"
  },
  {
    "text": "triple so really to make this work we need two generic",
    "start": "1240559",
    "end": "1246200"
  },
  {
    "text": "operations right one for that that um second operation which says for some",
    "start": "1246200",
    "end": "1251480"
  },
  {
    "text": "arbitrary type A and for some arbitrary Tuple of type B give me back the result",
    "start": "1251480",
    "end": "1257240"
  },
  {
    "text": "of consing a on to B A codec of a cons B and then the other case is is the",
    "start": "1257240",
    "end": "1264000"
  },
  {
    "text": "initial one right just says okay well you could also cons together any two arbitrary A and B's a codic of a and a",
    "start": "1264000",
    "end": "1270880"
  },
  {
    "text": "codic of B even when B is not a tupal we're just going to sort of like implicitly kind of stick in the uh the",
    "start": "1270880",
    "end": "1277200"
  },
  {
    "text": "terminating empty tupal value the H nil if you",
    "start": "1277200",
    "end": "1282360"
  },
  {
    "text": "will all right so how do we implement this uh we're going to use extension methods so this is a new Fe in scholar 3",
    "start": "1282360",
    "end": "1289720"
  },
  {
    "text": "um not maybe not entirely different uh from implicit classes if you're familiar with implicit classes um start there",
    "start": "1289720",
    "end": "1295960"
  },
  {
    "text": "right and then work towards extension methods uh we're also going to Define these extensions in the companion object",
    "start": "1295960",
    "end": "1301640"
  },
  {
    "text": "of codec and we're going to put them in the companion object so that they are always in implicit scope right any",
    "start": "1301640",
    "end": "1308159"
  },
  {
    "text": "anytime someone has a codec without any additional Imports they can just start calling these methods that's the",
    "start": "1308159",
    "end": "1314640"
  },
  {
    "text": "idea we have two extensions defined one for each case that we just",
    "start": "1314640",
    "end": "1319720"
  },
  {
    "text": "saw okay so the first extension we're going to name tup Ops right associative we're going to say for some a and for",
    "start": "1319720",
    "end": "1325840"
  },
  {
    "text": "some B which is a subtype of tupal right so some specific B is a subtype of tupal",
    "start": "1325840",
    "end": "1331360"
  },
  {
    "text": "could be a pair a triple you know so forth um we have to then you know we're",
    "start": "1331360",
    "end": "1336600"
  },
  {
    "text": "given this codic of a and we have to generate the codc of a cons B and likewise for the second case we'll",
    "start": "1336600",
    "end": "1343120"
  },
  {
    "text": "just say okay well otherwise here's another extension method for any arbitrary B",
    "start": "1343120",
    "end": "1348520"
  },
  {
    "text": "and in this case we're relying on extension prioritization right scolar says okay well this first one's more",
    "start": "1348520",
    "end": "1354600"
  },
  {
    "text": "specific so I'll pick that one when it's appropriate and only when that one doesn't match will I then fall back to",
    "start": "1354600",
    "end": "1360360"
  },
  {
    "text": "the second one okay the implementations it's a lot",
    "start": "1360360",
    "end": "1366240"
  },
  {
    "text": "of code but it's just it's just um pretty boring code um the the sort of",
    "start": "1366240",
    "end": "1372039"
  },
  {
    "text": "the strangest thing in this code is just this idea of passing around a cons B in",
    "start": "1372039",
    "end": "1377720"
  },
  {
    "text": "particular particular like let's look at the encode method here when we encode we get a value of type A cons B and I've",
    "start": "1377720",
    "end": "1385039"
  },
  {
    "text": "got this like helper function called encode both with which takes like an a codic of a and a codic of B and then",
    "start": "1385039",
    "end": "1391960"
  },
  {
    "text": "encodes them together but like how do you separate an a cons B into a value of a and a value of B and remember earlier",
    "start": "1391960",
    "end": "1399760"
  },
  {
    "text": "I said there's like a dozen or two collection like operations well head and tail work just fine on arbitrary tupal",
    "start": "1399760",
    "end": "1406600"
  },
  {
    "text": "so I don't know what I'm writing this whether I'm dealing with a apologies dealing with a a pair or a triple or so",
    "start": "1406600",
    "end": "1413039"
  },
  {
    "text": "forth but I do know that I can call head and tail on this a cons B because that",
    "start": "1413039",
    "end": "1418720"
  },
  {
    "text": "cons method or sorry that cons class extended from non-empty tupal and hence",
    "start": "1418720",
    "end": "1424679"
  },
  {
    "text": "head is always safe to call okay don't worry about the rest of the code it's just all it's my version of Graphics of",
    "start": "1424679",
    "end": "1431919"
  },
  {
    "text": "of pretty pictures if you followed Scola 3's",
    "start": "1431919",
    "end": "1437360"
  },
  {
    "text": "development um there is something called Simple extension methods where we can write them perhaps a little bit more",
    "start": "1437360",
    "end": "1442640"
  },
  {
    "text": "naturally um rather than those Collective extensions where we sort of say like I'm defining an extension and here's all the methods um so why didn't",
    "start": "1442640",
    "end": "1450120"
  },
  {
    "text": "I use those and the answer is unfortunately we can't and there's really two uh two main reasons um but but",
    "start": "1450120",
    "end": "1458120"
  },
  {
    "text": "before I get to those reasons like let's just take a look at what they would look like if I could use them I'd argue that",
    "start": "1458120",
    "end": "1463679"
  },
  {
    "text": "these look much nicer and the reason these look nicer is that because as an operator and we're using extension",
    "start": "1463679",
    "end": "1469880"
  },
  {
    "text": "methods you can Define them in the natural way to read like left to right",
    "start": "1469880",
    "end": "1475320"
  },
  {
    "text": "style the natural way to read these definitions right the cons operator here",
    "start": "1475320",
    "end": "1480520"
  },
  {
    "text": "is between codak of a and codc of B so you no longer need to do like that mental reverse right where you have to",
    "start": "1480520",
    "end": "1487399"
  },
  {
    "text": "remember that like the way the the scal of parses cons is Right associative and so forth um you just Define it",
    "start": "1487399",
    "end": "1493760"
  },
  {
    "text": "naturally unfortunately like I said there um there are two down Ides um one",
    "start": "1493760",
    "end": "1499919"
  },
  {
    "text": "is that they have these two operations when using uh simple extensions have the",
    "start": "1499919",
    "end": "1505559"
  },
  {
    "text": "same eraser right they both take a codec or two codecs and they both return a codec",
    "start": "1505559",
    "end": "1512559"
  },
  {
    "text": "and since they have the same eraser um you need something to differentiate them on the jvm so we can use like the dummy",
    "start": "1512559",
    "end": "1519360"
  },
  {
    "text": "implicit encoding where we just take this arbitrary implicit that's always available but it's kind of um kind of",
    "start": "1519360",
    "end": "1524600"
  },
  {
    "text": "messy um and the second reason is more important simple extension methods defining companions are not in implicit",
    "start": "1524600",
    "end": "1531399"
  },
  {
    "text": "scope by default so as a library author that's something to weigh um you know it's a it's an inflection point you have",
    "start": "1531399",
    "end": "1537000"
  },
  {
    "text": "to decide whe if you want that syntax always available then Define them as as",
    "start": "1537000",
    "end": "1542159"
  },
  {
    "text": "a collective extensions",
    "start": "1542159",
    "end": "1548159"
  },
  {
    "text": "okay something else we do a lot in es codc is we um we use codecs that we only",
    "start": "1548159",
    "end": "1554600"
  },
  {
    "text": "ever uh we only ever have part of our structure for their effect on the",
    "start": "1554600",
    "end": "1561960"
  },
  {
    "text": "binary so what do I mean by that um this ignore codec is a good example where",
    "start": "1561960",
    "end": "1567120"
  },
  {
    "text": "ignore just sort of advances when decoding by the number of bits passed right so ignore two bits and then decode",
    "start": "1567120",
    "end": "1572640"
  },
  {
    "text": "three and then decode a single bullan and then ignore two more bits and so forth um and when end coding it just",
    "start": "1572640",
    "end": "1578360"
  },
  {
    "text": "kind of sticks into zeros right in this case and what we get back then as we",
    "start": "1578360",
    "end": "1584640"
  },
  {
    "text": "build up these products is a codec that has a bunch of units all throughout and that's kind of annoying because like",
    "start": "1584640",
    "end": "1590480"
  },
  {
    "text": "we're going to want to map over these codecs and manipulate these you know actual ins and bullion and strings want",
    "start": "1590480",
    "end": "1595919"
  },
  {
    "text": "a way to kind of automatically insert and remove these unit values um and so we can do that via this",
    "start": "1595919",
    "end": "1604480"
  },
  {
    "text": "drop units operation if you just call drop units on a codec of a of a tupal",
    "start": "1604480",
    "end": "1610320"
  },
  {
    "text": "you get back a codec of another tupal that's just smaller right it's the same Tuple with units",
    "start": "1610320",
    "end": "1616039"
  },
  {
    "text": "gone um unless you know you call it a one that had no units in which case you expect the same",
    "start": "1616039",
    "end": "1621880"
  },
  {
    "text": "tupal so how would we Implement drop units or really what's its signature",
    "start": "1621880",
    "end": "1627279"
  },
  {
    "text": "like how do we write a method signature that says give me back a smaller tupal with just units gone right like think",
    "start": "1627279",
    "end": "1634120"
  },
  {
    "text": "about how you might try to manipulate that um in the Scala 2 version of s codc",
    "start": "1634120",
    "end": "1641320"
  },
  {
    "text": "we did this with a pretty complicated uh set of like implicit",
    "start": "1641320",
    "end": "1646520"
  },
  {
    "text": "machinery uh we use shapeless we wrote These inductive proofs right we we try to use",
    "start": "1646520",
    "end": "1652880"
  },
  {
    "text": "Scala c as a proof assistant to try to go through and like recursively walk the the H list structure and and find units",
    "start": "1652880",
    "end": "1659279"
  },
  {
    "text": "and take them out and so forth um in uh",
    "start": "1659279",
    "end": "1664919"
  },
  {
    "text": "in in Scola 3 we have something that's much more powerful and much more straightforward to",
    "start": "1664919",
    "end": "1670720"
  },
  {
    "text": "understand before we look at it um we're going to use the same trick that we we used previously just to get the syntax",
    "start": "1670720",
    "end": "1676440"
  },
  {
    "text": "Le one okay so in the companion object of codec because we always want it in scope we Define another um set of",
    "start": "1676440",
    "end": "1684080"
  },
  {
    "text": "collective extension methods and we Define this drop units operation and the type that we're going to return here",
    "start": "1684080",
    "end": "1690960"
  },
  {
    "text": "we're going to say um when you call this on a codec of a for some arbitrary Tuple we're going to give you back a codec of",
    "start": "1690960",
    "end": "1697840"
  },
  {
    "text": "drop units of a so what is drop units um drop units is this it's uh it's",
    "start": "1697840",
    "end": "1706840"
  },
  {
    "text": "a new feature in Scola 3 um this this language feature that lets us write",
    "start": "1706840",
    "end": "1712960"
  },
  {
    "text": "these type definitions um so this is called a match",
    "start": "1712960",
    "end": "1718279"
  },
  {
    "text": "type um and as you can see from this particular definition uh in essence it's",
    "start": "1718279",
    "end": "1726240"
  },
  {
    "text": "a you know sort of a typ level function if you will where we can compute an output type based off of an input type",
    "start": "1726240",
    "end": "1733399"
  },
  {
    "text": "right at the type level so in this case our type function our type operator says given some type A which is some",
    "start": "1733399",
    "end": "1741279"
  },
  {
    "text": "statically known Tuple size some sub type of Tuple I'm going to give you back",
    "start": "1741279",
    "end": "1748120"
  },
  {
    "text": "another statically known tupal that's what this uh less than colon operator",
    "start": "1748120",
    "end": "1753760"
  },
  {
    "text": "says it's that I'm not just going to give you back tupal but I'm going to give you back something that is a subtype of tupal and the compiler is",
    "start": "1753760",
    "end": "1760039"
  },
  {
    "text": "going to be able to track that okay and then we're going to Define this",
    "start": "1760039",
    "end": "1765559"
  },
  {
    "text": "just with like a a simple recursive inductive definition right we're going to say well pattern match on the",
    "start": "1765559",
    "end": "1771679"
  },
  {
    "text": "structure of our Tuple a if uh if our Tuple a is um at the type",
    "start": "1771679",
    "end": "1778679"
  },
  {
    "text": "level again is a head and a tail then if the head is a unit return the result of",
    "start": "1778679",
    "end": "1785200"
  },
  {
    "text": "just dropping units from my tail but if the head is anything else",
    "start": "1785200",
    "end": "1791240"
  },
  {
    "text": "then take the head type and cons it onto the type we get back from dropping units from the tail",
    "start": "1791240",
    "end": "1798240"
  },
  {
    "text": "okay and then of course if um if a is the empty tupal then we just return the",
    "start": "1798240",
    "end": "1805600"
  },
  {
    "text": "empty tupal type so this is just like a recursive function but instead of being at the term level like we're used to",
    "start": "1805600",
    "end": "1811360"
  },
  {
    "text": "thinking about recursive functions this is at the type level okay if we go back though that was",
    "start": "1811360",
    "end": "1818840"
  },
  {
    "text": "just the type right codec of drop units of a um we also have to write the term level it's like we we proved it but we",
    "start": "1818840",
    "end": "1826240"
  },
  {
    "text": "actually have to write it we have to make it run um and so we do have to implement the the insertion and removal",
    "start": "1826240",
    "end": "1832480"
  },
  {
    "text": "of these unit values into our tupal we do that with um these two term level",
    "start": "1832480",
    "end": "1838080"
  },
  {
    "text": "functions on the companion object drop units. drop and insert so let's look at how those are",
    "start": "1838080",
    "end": "1844519"
  },
  {
    "text": "defined again there's a lot of code don't worry about all the the details here um but let's take a look at the",
    "start": "1844519",
    "end": "1850519"
  },
  {
    "text": "definition of drop um so we have this de drop we say drop for some a which is a subtype of",
    "start": "1850519",
    "end": "1857039"
  },
  {
    "text": "two Cal and we're going to give you back you know a but without the unit values and now again we're going to uh",
    "start": "1857039",
    "end": "1866360"
  },
  {
    "text": "inductively you know pattern match on the structure the type level structure of",
    "start": "1866360",
    "end": "1872080"
  },
  {
    "text": "a um so we call this function called a rased value of a which gives us back a",
    "start": "1872080",
    "end": "1879519"
  },
  {
    "text": "type sort of it gives us back a a a value that we can patterm match on the",
    "start": "1879519",
    "end": "1884919"
  },
  {
    "text": "type of um we can't actually do anything with that value so you can see here when we pattern match we always ignore the",
    "start": "1884919",
    "end": "1890760"
  },
  {
    "text": "value but we can pattern match on the type of it and so again we just look at the case where you had a unit in a head",
    "start": "1890760",
    "end": "1897039"
  },
  {
    "text": "um anything else in a head and empty we we do our same three cases the same recursive structure we had at the type",
    "start": "1897039",
    "end": "1903000"
  },
  {
    "text": "level will repeat now at the term level um you know in the case that we",
    "start": "1903000",
    "end": "1908559"
  },
  {
    "text": "have a unit then we just call the same function recursively on our tail in the case where we didn't have a unit um you",
    "start": "1908559",
    "end": "1916000"
  },
  {
    "text": "know we call us function F recursively on our tail but then cons on our current head and unfortunately these casts that",
    "start": "1916000",
    "end": "1924000"
  },
  {
    "text": "show up are necessary because the compiler is not able to uh validate that",
    "start": "1924000",
    "end": "1929919"
  },
  {
    "text": "the assertions we're making here match the assertions we made at the type level so all these as instances as you that",
    "start": "1929919",
    "end": "1936840"
  },
  {
    "text": "you see unfortunately are common um and are are necessary and you are on your",
    "start": "1936840",
    "end": "1942720"
  },
  {
    "text": "own to make sure you don't uh don't cheat insertion works much the same way",
    "start": "1942720",
    "end": "1947960"
  },
  {
    "text": "it's just um another you know recursive uh pattern match on the structure of the type so we won't spend any time on that",
    "start": "1947960",
    "end": "1954760"
  },
  {
    "text": "but feel free to look oh and I I did want to mention um in all of these cases we're doing this at compilation time and",
    "start": "1954760",
    "end": "1962760"
  },
  {
    "text": "in order to to um to successfully do that we do have to Define these methods as",
    "start": "1962760",
    "end": "1968360"
  },
  {
    "text": "inline and by defining them inline really what we're saying again is just like when we saw the inline macro that",
    "start": "1968360",
    "end": "1973720"
  },
  {
    "text": "we started with um at the call site at pile time Scala c will sort of expand",
    "start": "1973720",
    "end": "1981440"
  },
  {
    "text": "these definitions into the call site um so if you've done like template meta programm in C++ and you're aware of like",
    "start": "1981440",
    "end": "1987600"
  },
  {
    "text": "watching how Big expanded templates get um you know you can have those same types of problems with uh rampant use of",
    "start": "1987600",
    "end": "1994880"
  },
  {
    "text": "inline dep so be aware okay so some more building blocks",
    "start": "1994880",
    "end": "2001519"
  },
  {
    "text": "um something else we like to do in es codc is build up these you know build up these uh product Tuple CeX but then",
    "start": "2001519",
    "end": "2008960"
  },
  {
    "text": "eventually convert them to case classes two and from case classes right um so here you can see you know we've got this",
    "start": "2008960",
    "end": "2015360"
  },
  {
    "text": "in bullan string codec again we've got a case class that coincidentally matches",
    "start": "2015360",
    "end": "2020919"
  },
  {
    "text": "um component wise type for type right our case class structure and since those two match we're allowed to call this as",
    "start": "2020919",
    "end": "2028480"
  },
  {
    "text": "function we can say take the Tuple codec and convert it to a Fu",
    "start": "2028480",
    "end": "2035278"
  },
  {
    "text": "codec in this SC 2 version of this this relied heavily on shapeless macros right",
    "start": "2035519",
    "end": "2042159"
  },
  {
    "text": "the whole generic machinery and labeled generic Machinery Etc um the Scala 3",
    "start": "2042159",
    "end": "2047200"
  },
  {
    "text": "version of this is um is much more straightforward straightforward enough that we're going to try to take a look",
    "start": "2047200",
    "end": "2052560"
  },
  {
    "text": "at how this is implemented in a slide",
    "start": "2052560",
    "end": "2056760"
  },
  {
    "text": "deck um so the as method itself is very straightforward the as method is defined",
    "start": "2057639",
    "end": "2064118"
  },
  {
    "text": "literally directly on the codec trait and it takes an implicit isomorphism",
    "start": "2064119",
    "end": "2069720"
  },
  {
    "text": "between types A and B right so this ISO just gives us a function that goes from",
    "start": "2069720",
    "end": "2075599"
  },
  {
    "text": "an A to a b and a function that goes from a b to an A and if we have that we can map it over our",
    "start": "2075599",
    "end": "2081760"
  },
  {
    "text": "codec so far so good um as you can see you know we are using the the Scala 3",
    "start": "2081760",
    "end": "2088560"
  },
  {
    "text": "version of implicits which Martin will be talking about uh later today but this is all just sort of",
    "start": "2088560",
    "end": "2095118"
  },
  {
    "text": "straightforward Scala the question is how do we generate instances of iso how do we get isomorph",
    "start": "2095119",
    "end": "2103240"
  },
  {
    "text": "um isomorphism instances between tupes and products between tupes and like case",
    "start": "2103240",
    "end": "2108480"
  },
  {
    "text": "classes uh so here's here's the rough idea um we're going to use again we're",
    "start": "2108480",
    "end": "2114200"
  },
  {
    "text": "using the scolar three syntax here so we've got a given instead of an implicit def but we have this function called",
    "start": "2114200",
    "end": "2120280"
  },
  {
    "text": "Product and it's going to materialize an instance of iso for any Tuple t and some",
    "start": "2120280",
    "end": "2127760"
  },
  {
    "text": "arbitrary type P right completely unbounded arbitrary type P um assuming that it can",
    "start": "2127760",
    "end": "2136520"
  },
  {
    "text": "find a mirror a product mirror for p right that this that there's this m",
    "start": "2136520",
    "end": "2144359"
  },
  {
    "text": "mirror. product of P such that the mirrored element types of that",
    "start": "2144359",
    "end": "2152400"
  },
  {
    "text": "mirror are equal to the tupal T so there's a lot in that sentence let's",
    "start": "2152400",
    "end": "2157760"
  },
  {
    "text": "let's break that down a bit um the mirror instance you can see this is coming from a new package a new compile",
    "start": "2157760",
    "end": "2164200"
  },
  {
    "text": "time meta programming package in scol 3 called scholar. deriving and it defines this type",
    "start": "2164200",
    "end": "2169839"
  },
  {
    "text": "mirror um and What it lets us do is do compile time reflection or or generic",
    "start": "2169839",
    "end": "2175240"
  },
  {
    "text": "programming against the structure of of products and sum",
    "start": "2175240",
    "end": "2180880"
  },
  {
    "text": "types um so here we're saying well just give us a give us a um a mirror of the",
    "start": "2180880",
    "end": "2187119"
  },
  {
    "text": "structure of this type P and then we're going to put a refinement constraint on",
    "start": "2187119",
    "end": "2192440"
  },
  {
    "text": "it right we're going to again sort of view scalac c as a constraint solver and say um oh and by the way only give us",
    "start": "2192440",
    "end": "2198560"
  },
  {
    "text": "that instance uh you know if the mirrored element types element is equal to our",
    "start": "2198560",
    "end": "2204560"
  },
  {
    "text": "tle T now side note this doesn't work this is aspirational um if you look at the sodex",
    "start": "2204560",
    "end": "2211720"
  },
  {
    "text": "source code for this particular function you'll see it gets a little bit more complicated um and that's because as of",
    "start": "2211720",
    "end": "2217880"
  },
  {
    "text": "right now uh the mirror infrastructure built into",
    "start": "2217880",
    "end": "2223200"
  },
  {
    "text": "Scola 3 does not support refinement types as constraints but that's not a big deal um when you look at the",
    "start": "2223200",
    "end": "2229760"
  },
  {
    "text": "implementation if you're so inclined really all that means is that we take the product as one implicit",
    "start": "2229760",
    "end": "2235640"
  },
  {
    "text": "argument and then we separately take uh like a conforms witness evidence",
    "start": "2235640",
    "end": "2241680"
  },
  {
    "text": "implicit value that just us hey by the way the mirrored element types parameter of that first AR has to be equal to this",
    "start": "2241680",
    "end": "2247920"
  },
  {
    "text": "type T um so if you're interested in that encoding take a look at it that same encoding was not exactly possible",
    "start": "2247920",
    "end": "2253079"
  },
  {
    "text": "in Scala 2 so again if you're interested please take a look or or hit me up anytime okay that's our implicit",
    "start": "2253079",
    "end": "2260359"
  },
  {
    "text": "materializer that's what gives us our ISO between a a you know case class and",
    "start": "2260359",
    "end": "2266040"
  },
  {
    "text": "a tuple we again we have to worry about the term level right we have to actually implement this we can't just prove it so",
    "start": "2266040",
    "end": "2273400"
  },
  {
    "text": "we do have to implement these two functions from tupal and to tupal um again you know these are these are",
    "start": "2273400",
    "end": "2281240"
  },
  {
    "text": "very boiler plates sort of like the other stuff we saw with insert and drop with drop units um the general idea here",
    "start": "2281240",
    "end": "2287359"
  },
  {
    "text": "is that when going from a tupal to a case class we're going to use this from",
    "start": "2287359",
    "end": "2293440"
  },
  {
    "text": "product operation on the mirror okay um and that's going to let us",
    "start": "2293440",
    "end": "2300040"
  },
  {
    "text": "instantiate a case class generically and when going the other direction from going going from an instance of a case",
    "start": "2300040",
    "end": "2305760"
  },
  {
    "text": "class back to a tupal tupal has its own Constructor called from product and",
    "start": "2305760",
    "end": "2310800"
  },
  {
    "text": "again unfortunately the as instance of calls are required so you are on your",
    "start": "2310800",
    "end": "2315839"
  },
  {
    "text": "own to make sure they are safe they are all safe in this slide all the as instance ofes you see in the slides um",
    "start": "2315839",
    "end": "2321560"
  },
  {
    "text": "are all completely sound but you are on your own to validate",
    "start": "2321560",
    "end": "2326920"
  },
  {
    "text": "that okay now with all of these things we finally get to case class or or really",
    "start": "2327000",
    "end": "2334520"
  },
  {
    "text": "type class uh derivation um and this is sort of everybody's favorite trick right um and it it's it's",
    "start": "2334520",
    "end": "2341359"
  },
  {
    "text": "awesome don't get me wrong um but before I look at how we're going to make uh derivation work I do want to call out",
    "start": "2341359",
    "end": "2348359"
  },
  {
    "text": "that like codecs themselves are not you know globally coherent type",
    "start": "2348359",
    "end": "2353400"
  },
  {
    "text": "classes right um we have lots and lots of instances of a codec of int right one",
    "start": "2353400",
    "end": "2359720"
  },
  {
    "text": "instance will encode four bits and one will encode eight bits and one is you know big endian and one's little endian",
    "start": "2359720",
    "end": "2365599"
  },
  {
    "text": "and you know you imagine all sorts of um codec of int instances um however um when it is",
    "start": "2365599",
    "end": "2373880"
  },
  {
    "text": "convenient uh to derive a a single canonical you know coherent instance um",
    "start": "2373880",
    "end": "2381720"
  },
  {
    "text": "with Scala 3's type class derivation support we can do that via this derives keyword so I wouldn't recommend this if",
    "start": "2381720",
    "end": "2388680"
  },
  {
    "text": "you do have a lot of options right if you do have different binary representations but when you don't when you really only have one that makes",
    "start": "2388680",
    "end": "2394839"
  },
  {
    "text": "sense um this is a pretty convenient way to write your codex okay so here's how it looks when",
    "start": "2394839",
    "end": "2402720"
  },
  {
    "text": "you use it we have this case class Point um of three you know three element",
    "start": "2402720",
    "end": "2408400"
  },
  {
    "text": "types and we just write at the end derives codec um SC codec what it's",
    "start": "2408400",
    "end": "2413640"
  },
  {
    "text": "going to do is in essence look for an implicit codec for each of these",
    "start": "2413640",
    "end": "2418960"
  },
  {
    "text": "parameters you know codec of int um and Stitch them all together in sort of the",
    "start": "2418960",
    "end": "2424119"
  },
  {
    "text": "expected way and it'll do um nice conveniences like include field names",
    "start": "2424119",
    "end": "2429280"
  },
  {
    "text": "and errors like if we go to decode something and a codec fails when decoding like why there it'll tell you",
    "start": "2429280",
    "end": "2434839"
  },
  {
    "text": "that like the the error was on y the types of things you'd expect from a full derivation",
    "start": "2434839",
    "end": "2440240"
  },
  {
    "text": "framework um and the net result of that is that if it can't find that at compilation time it'll give you an error",
    "start": "2440240",
    "end": "2447760"
  },
  {
    "text": "um and as long as it compiles then uh you can summon that derived instance via",
    "start": "2447760",
    "end": "2452880"
  },
  {
    "text": "implicit scope so here instead of using the Scala 2 construct implicitly I'm using the Scala 3 construct summon but",
    "start": "2452880",
    "end": "2460040"
  },
  {
    "text": "it's the same same idea right just grab a a value out of implicit scope and and make it",
    "start": "2460040",
    "end": "2465520"
  },
  {
    "text": "explicit and you can see in this particular case the example here of encoding one two3 we got 96 bits back so",
    "start": "2465520",
    "end": "2472599"
  },
  {
    "text": "it's a pretty pretty good bet that the codic of int that was an implicit scope",
    "start": "2472599",
    "end": "2478319"
  },
  {
    "text": "is like a 32bit signed um",
    "start": "2478319",
    "end": "2483720"
  },
  {
    "text": "codec this same technique works fine for adts in enumerations right so here I",
    "start": "2483720",
    "end": "2489760"
  },
  {
    "text": "just have an an enumeration called color this is the Scala 3 Syntax for enumerations and we're deriving a codec",
    "start": "2489760",
    "end": "2496800"
  },
  {
    "text": "for it so we say enum color derives codec and we've got red green and blue as our three cases of our of our",
    "start": "2496800",
    "end": "2503160"
  },
  {
    "text": "enum and in this case you can see like there are no they're just objects in our",
    "start": "2503160",
    "end": "2508800"
  },
  {
    "text": "in our enum right the three colors there are no uh products on each of those cases but nonetheless you know the Gen",
    "start": "2508800",
    "end": "2516240"
  },
  {
    "text": "generated codec is going to in this case when we go to encode green is going to return the value one and as you may",
    "start": "2516240",
    "end": "2522520"
  },
  {
    "text": "guess or if you read the docs you know if you try to encode red you'd get zero and if you try to encode blue you'd get",
    "start": "2522520",
    "end": "2528480"
  },
  {
    "text": "two and the same technique um extends perfectly to adts you know full full",
    "start": "2528480",
    "end": "2533800"
  },
  {
    "text": "adts with arbitrary complexity okay so how does this work as a library author how can you um take",
    "start": "2533800",
    "end": "2540440"
  },
  {
    "text": "advantage of this stuff the good news is it's going to build on a lot of what we've seen already",
    "start": "2540440",
    "end": "2547599"
  },
  {
    "text": "um so the first thing we're going to do is Implement a derived method in the",
    "start": "2547599",
    "end": "2553200"
  },
  {
    "text": "companion object of the target type class since we want to support deriving a codec then we need a derived method in",
    "start": "2553200",
    "end": "2560960"
  },
  {
    "text": "the codec companion okay this is going to be an inline method because we want this codc",
    "start": "2560960",
    "end": "2567280"
  },
  {
    "text": "derivation to happen at compile time not at runtime all right the expansion should happen when uh when",
    "start": "2567280",
    "end": "2574839"
  },
  {
    "text": "those uh derived Clauses were were",
    "start": "2574839",
    "end": "2580000"
  },
  {
    "text": "compiled um and then one of the constraints that we can put on this definition is that in order to call this",
    "start": "2580319",
    "end": "2587200"
  },
  {
    "text": "we can require that the compiler gives us a mirror of whatever a we're deriving a codec for the same mirror that we just",
    "start": "2587200",
    "end": "2594520"
  },
  {
    "text": "saw when generating like a an isomorphism",
    "start": "2594520",
    "end": "2599318"
  },
  {
    "text": "instance so you know a lot to work through in that um signature but the",
    "start": "2599680",
    "end": "2605079"
  },
  {
    "text": "implementation is fairly straightforward we're just going to say well let's just you know create a codec we've got three",
    "start": "2605079",
    "end": "2610359"
  },
  {
    "text": "abstract methods to to implement um and then really the the question becomes for each of those three",
    "start": "2610359",
    "end": "2616520"
  },
  {
    "text": "abstract methods how can we use this mirror that we've got on a to do the right thing to generate the right um",
    "start": "2616520",
    "end": "2623839"
  },
  {
    "text": "implementation so couple things we're going to do um we're only going to look at at one",
    "start": "2623839",
    "end": "2630319"
  },
  {
    "text": "by the way we're only going to look at size bound because it's uh the simplest um and and uh otherwise this would would",
    "start": "2630319",
    "end": "2637520"
  },
  {
    "text": "would go on way too long uh but let's look at size bound the the size bound operation on a codc gives you an upper",
    "start": "2637520",
    "end": "2643280"
  },
  {
    "text": "and a lower bound on how big the binary representation is for this type not for a given instance not for a given value",
    "start": "2643280",
    "end": "2650640"
  },
  {
    "text": "right but but in total you know how much binary can you",
    "start": "2650640",
    "end": "2655920"
  },
  {
    "text": "generate um so let's look at how would we Implement size Bound for this arbitary a for which we have this",
    "start": "2655920",
    "end": "2663880"
  },
  {
    "text": "mirror so we have some some um some some things we're going to do to",
    "start": "2663880",
    "end": "2669720"
  },
  {
    "text": "to break this down into smaller problems the first thing we're going to do is do an inline match again another new",
    "start": "2669720",
    "end": "2676040"
  },
  {
    "text": "construct all part of this template meta programming support we're going to do this inline match on the mirror and",
    "start": "2676040",
    "end": "2682359"
  },
  {
    "text": "we're going to handle the two possible types of mirrors that we can be given by the compiler we either get a product",
    "start": "2682359",
    "end": "2687960"
  },
  {
    "text": "which is the thing we've seen so far right a mirror of the individual elements in that particular case",
    "start": "2687960",
    "end": "2693920"
  },
  {
    "text": "class well we're going to get a sum um in the case of like an enumeration",
    "start": "2693920",
    "end": "2699960"
  },
  {
    "text": "this was red green and blue right or if it was like a fully generic ADT it'd be",
    "start": "2699960",
    "end": "2705119"
  },
  {
    "text": "all the various subtypes of a sealed trait so those are the two cases and",
    "start": "2705119",
    "end": "2711359"
  },
  {
    "text": "then we'll look at look at the implementations of this in a moment but in the in the two implementations the",
    "start": "2711359",
    "end": "2716559"
  },
  {
    "text": "general idea is that well if it's just a product then we're going to call this sized bound elements",
    "start": "2716559",
    "end": "2723440"
  },
  {
    "text": "function passing the the um Tuple of the element types right so a point with",
    "start": "2723440",
    "end": "2731280"
  },
  {
    "text": "three integers you know Point XYZ all type int this would be a p. mirrored",
    "start": "2731280",
    "end": "2736800"
  },
  {
    "text": "element types would be a triple of type um you know int int",
    "start": "2736800",
    "end": "2743000"
  },
  {
    "text": "int and you can you can guess you know the implementation of that's probably going to say like well we got to know",
    "start": "2743000",
    "end": "2748119"
  },
  {
    "text": "how much each of those types is going to take up in binary and just add them all together we'll look at that in a moment the other case to deal with is the sum",
    "start": "2748119",
    "end": "2755119"
  },
  {
    "text": "case and in the sum case we need to First say like hey when we go to write this to Binary we need to encode which",
    "start": "2755119",
    "end": "2762000"
  },
  {
    "text": "of the possible options of this sum is the one that we're going to um to write",
    "start": "2762000",
    "end": "2767040"
  },
  {
    "text": "and the way we're going to implement this is that we're going to use a single unsigned 8bit integer to",
    "start": "2767040",
    "end": "2772400"
  },
  {
    "text": "select which Su type member right just an index into the Su type",
    "start": "2772400",
    "end": "2778280"
  },
  {
    "text": "representation followed by whatever you know codec is available for that particular um leaf",
    "start": "2778280",
    "end": "2786599"
  },
  {
    "text": "you know for that for that data Constructor so let's break that down into um you know more",
    "start": "2786599",
    "end": "2792359"
  },
  {
    "text": "specifics the size found to elements function right this says given that list of tupal the the type of the the",
    "start": "2792359",
    "end": "2800480"
  },
  {
    "text": "elements of our product tell us how big it's going to be and we use a very similar construct to what we used before",
    "start": "2800480",
    "end": "2806480"
  },
  {
    "text": "we're going to pattern match on the structure of that tupal looking at the head type and the tail",
    "start": "2806480",
    "end": "2811680"
  },
  {
    "text": "type you know assuming that it's it's not empty then what we're going to do is is um summon an implicit instance of the",
    "start": "2811680",
    "end": "2818880"
  },
  {
    "text": "codec of the head type right so this is where when we're deriving point we say summon a codec of",
    "start": "2818880",
    "end": "2825000"
  },
  {
    "text": "int from implicit scope and take the size bound of that and add it to the result of calling size bound on the on",
    "start": "2825000",
    "end": "2830960"
  },
  {
    "text": "the tail right simple recursive function and then of course if we hit the empty Tuple case just return the fact that we",
    "start": "2830960",
    "end": "2837359"
  },
  {
    "text": "use you know an exact bound of zero bits the um the cases one is a little",
    "start": "2837359",
    "end": "2845359"
  },
  {
    "text": "bit more complex but it's the same idea um again we get a tupal of types but as a",
    "start": "2845359",
    "end": "2852760"
  },
  {
    "text": "reminder these types are the types for each data Constructor in our",
    "start": "2852760",
    "end": "2858319"
  },
  {
    "text": "ADT so in our numeration example it was a it was a triple for red green and blue",
    "start": "2858319",
    "end": "2863920"
  },
  {
    "text": "as types right red. type green. type blue. type and if we had a more complex ad with with you know Fanci or",
    "start": "2863920",
    "end": "2870160"
  },
  {
    "text": "Constructors even something like option by the way um like if if we if we did the same um uh function call for option",
    "start": "2870160",
    "end": "2877559"
  },
  {
    "text": "we would get back um a pair of some and none right but then otherwise you know",
    "start": "2877559",
    "end": "2884680"
  },
  {
    "text": "it works similar we're going to um we're going to summon a an instance for um",
    "start": "2884680",
    "end": "2890440"
  },
  {
    "text": "each data Constructor um and then or together all of the sizes so again don't worry too much about the literal code",
    "start": "2890440",
    "end": "2896480"
  },
  {
    "text": "here just this idea of recursive uh structure",
    "start": "2896480",
    "end": "2902319"
  },
  {
    "text": "walking okay um so that's in essence what I wanted to cover today um I did want to point out Scola 3",
    "start": "2902839",
    "end": "2911160"
  },
  {
    "text": "has really simplified not just the implementation of es codu but the use of",
    "start": "2911160",
    "end": "2916520"
  },
  {
    "text": "it um we have not you know we have not given up anything from like an Express",
    "start": "2916520",
    "end": "2922000"
  },
  {
    "text": "this capability perspective but at the same time the code is easier maintain um to maintain it has less dependencies and",
    "start": "2922000",
    "end": "2930119"
  },
  {
    "text": "it's much more straightforward to read understand what's happening as opposed to sort of having to be a a proof of",
    "start": "2930119",
    "end": "2935760"
  },
  {
    "text": "consistent um with the the shapel style approach um the other thing I wanted to",
    "start": "2935760",
    "end": "2940960"
  },
  {
    "text": "point out is that the compatibility story between Scala 2 and Scola 3 is getting better and better uh when I",
    "start": "2940960",
    "end": "2946839"
  },
  {
    "text": "first started pointing this um when I first started pointing this you know the the Scola 3 compiler could",
    "start": "2946839",
    "end": "2954839"
  },
  {
    "text": "pull in Scala 2 libraries as long as you weren't using macros which is still true today but the inverse was not true",
    "start": "2954839",
    "end": "2961160"
  },
  {
    "text": "something compiled with scal 3 could not be used by 213 um but in 213 three that has changed right so that there's um",
    "start": "2961160",
    "end": "2968160"
  },
  {
    "text": "bidirectional cross compatibility um in general if you're not using macros in scholar 2 you can",
    "start": "2968160",
    "end": "2976040"
  },
  {
    "text": "directly use your scholar 2 libraries in schola 3 today um I use schola Che that",
    "start": "2976040",
    "end": "2981640"
  },
  {
    "text": "way every time I work in a Scala 3 codebase um and more and more of the open source ecosystem is porting uh last",
    "start": "2981640",
    "end": "2989640"
  },
  {
    "text": "time I gave this talk this slide was was uh it had less libraries on it um but",
    "start": "2989640",
    "end": "2995000"
  },
  {
    "text": "the library list is getting larger over time cats effect now um in particular cats Effect 3 and the work that Daniel",
    "start": "2995000",
    "end": "3001359"
  },
  {
    "text": "spiwak and team were doing that's that's now compiling for dy I have a branch of",
    "start": "3001359",
    "end": "3006440"
  },
  {
    "text": "FS2 that's working great with Dy but it does require the Dy nightly build so I have not published it yet but as soon as",
    "start": "3006440",
    "end": "3013200"
  },
  {
    "text": "d026 is out you'll see a build of FS2 supporting it um and so anyway the compatibility story has been great um",
    "start": "3013200",
    "end": "3020240"
  },
  {
    "text": "and finally like I you know if nothing else you know I hope you take this as a",
    "start": "3020240",
    "end": "3025480"
  },
  {
    "text": "encouragement to kick the tires a bit um show up in the doy chat room there are a ton of people that are super willing to",
    "start": "3025480",
    "end": "3030599"
  },
  {
    "text": "help out um and feel free to hit me up anytime with any questions that's all I",
    "start": "3030599",
    "end": "3037599"
  },
  {
    "text": "have",
    "start": "3043480",
    "end": "3046480"
  }
]