[
  {
    "start": "0",
    "end": "16000"
  },
  {
    "text": "[Music] um so about this talk uh what I'm going",
    "start": "6990",
    "end": "13440"
  },
  {
    "text": "to do is I'm going to talk a little bit about the history of Swift where Swift came from uh some of the things that",
    "start": "13440",
    "end": "18600"
  },
  {
    "start": "16000",
    "end": "82000"
  },
  {
    "text": "turned it into the language that it is today uh I'm going to use that information to then talk about what makes Swift fast uh why it is that Swift",
    "start": "18600",
    "end": "25960"
  },
  {
    "text": "is a better language to have than Objective C from a speed perspective and have a little bit of a look at where",
    "start": "25960",
    "end": "31480"
  },
  {
    "text": "Swift is going my name is Alex blitt you can reach me on Twitter at albl uh and I",
    "start": "31480",
    "end": "37079"
  },
  {
    "text": "am for my sins a next owner and Veteran Objective C programmer back in the days when having big black Pizza trays was",
    "start": "37079",
    "end": "43520"
  },
  {
    "text": "cool um I also wrote a book uh Swift Essentials which came out at the end of",
    "start": "43520",
    "end": "48719"
  },
  {
    "text": "201 uh 14 end of last year um all of this information is being recorded for",
    "start": "48719",
    "end": "54000"
  },
  {
    "text": "the video so just for that this information is based on Swift 2.1 which was the public release in December",
    "start": "54000",
    "end": "60519"
  },
  {
    "text": "came out a couple of months ago Swift is still not yet open sourced I checked before I started they have not open",
    "start": "60519",
    "end": "65720"
  },
  {
    "text": "sourced it yet um they have four weeks left to open source it which they said they do by the end of 2015 so check back",
    "start": "65720",
    "end": "72040"
  },
  {
    "text": "soon um I've also got another book another version of this Swift 2 Essentials coming out next month so",
    "start": "72040",
    "end": "78720"
  },
  {
    "text": "where did Swift come from uh Swift has been under the covers for quite a long time in development but you can trace",
    "start": "78720",
    "end": "84880"
  },
  {
    "start": "82000",
    "end": "314000"
  },
  {
    "text": "the history all the way back to when Objective C started Objective C came out in 19 1983 and it was devised as a small",
    "start": "84880",
    "end": "92640"
  },
  {
    "text": "talk based language um that could be fit on run on top of a c-based programming language that probably wouldn't have",
    "start": "92640",
    "end": "99560"
  },
  {
    "text": "taken the World by storm except that next licensed it as their operating system and next is fairly famous next",
    "start": "99560",
    "end": "106719"
  },
  {
    "text": "that came out in '89 um and is the NS prefix that you see on things like NS",
    "start": "106719",
    "end": "111799"
  },
  {
    "text": "array and NS dictionary and NS object um next itself wasn't doing too well until",
    "start": "111799",
    "end": "117000"
  },
  {
    "text": "Apple bought out next in 1996 and that was really the turnaround time for both Mac as the platform and apple as the",
    "start": "117000",
    "end": "124799"
  },
  {
    "text": "company um so Objective C goes all the way back till essentially the early 2000s there was a product called os10",
    "start": "124799",
    "end": "130520"
  },
  {
    "text": "server that came out in 99 but it was really os10 that came out in 2000 and",
    "start": "130520",
    "end": "135640"
  },
  {
    "text": "then publicly released in 2001 that brought Objective C to the masses interestingly on the Tob index as of",
    "start": "135640",
    "end": "142000"
  },
  {
    "text": "November Objective C was had had quite a big rise due to the iPhone and it's now",
    "start": "142000",
    "end": "147440"
  },
  {
    "text": "on the way down and actually Objective C in Swift neck and neck in the toob index uh next month they will be swapped round",
    "start": "147440",
    "end": "154160"
  },
  {
    "text": "and swi we go above Objective C for the first time so what is objective c well you probably know about it if you've",
    "start": "154160",
    "end": "160599"
  },
  {
    "text": "been involved with the Apple ecosystem or iOS ecosystem for any length of time but essentially it was a processor that",
    "start": "160599",
    "end": "167239"
  },
  {
    "text": "originally a pre-processor that translated classes uh that compiled down into c-based code and the reason why",
    "start": "167239",
    "end": "174080"
  },
  {
    "text": "it's so popular today was because it formed the basis of The Next Step operating system and then because it was",
    "start": "174080",
    "end": "179519"
  },
  {
    "text": "integr ated into the gccc and therefore released as the GPL you started to see other platforms pick up objective c",
    "start": "179519",
    "end": "186319"
  },
  {
    "text": "there's one called gep uh which is still around you can still have the equivalent of project Builder inside there but",
    "start": "186319",
    "end": "192159"
  },
  {
    "text": "they're perhaps not as popular on non-apple systems you can actually have a look at where Objective C comes from",
    "start": "192159",
    "end": "197200"
  },
  {
    "text": "in the runtime although probably not on this slide uh goes back to uh 1999 Apple",
    "start": "197200",
    "end": "202400"
  },
  {
    "text": "computer so a long history but the reason I mentioned Objective C is because there's actually been a lot of",
    "start": "202400",
    "end": "208120"
  },
  {
    "text": "development of languages since the old days so in the old days we had C and small talk uh those are the blurry ones",
    "start": "208120",
    "end": "214280"
  },
  {
    "text": "on the left and Objective C was really the love child between C and small talk",
    "start": "214280",
    "end": "220239"
  },
  {
    "text": "that came out in 1983 about the same time as C++ came out so the original C++",
    "start": "220239",
    "end": "225879"
  },
  {
    "text": "and the original Objective C came out at the same sort of time not a lot happened for quite a while and then llvm was",
    "start": "225879",
    "end": "232439"
  },
  {
    "text": "released in 2003 which is really the starting of ruminations of the",
    "start": "232439",
    "end": "237879"
  },
  {
    "text": "Redevelopment of the Apple developer plan platform um that LEDs to Objective C sort of tangentially in Objective C",
    "start": "237879",
    "end": "244840"
  },
  {
    "text": "2.0 tangentially in 2007 when we had things like Dynamic properties uh automated automatic reference counting",
    "start": "244840",
    "end": "252120"
  },
  {
    "text": "and when Apple finally got rid of GCC within clang which was released in 2009",
    "start": "252120",
    "end": "257840"
  },
  {
    "text": "there was real momentum behind what this platform would have um those things all",
    "start": "257840",
    "end": "263080"
  },
  {
    "text": "came together with the development and release of the Swift platform in 2014",
    "start": "263080",
    "end": "268440"
  },
  {
    "text": "Now by that time there had been been working on it for several years it picked up influences from both The",
    "start": "268440",
    "end": "274000"
  },
  {
    "text": "Objective C background but also C++ as well and of course recently we've seen",
    "start": "274000",
    "end": "279039"
  },
  {
    "text": "Swift 2.1 which was released uh a couple of months ago now the important thing about these",
    "start": "279039",
    "end": "285199"
  },
  {
    "text": "languages the ones at the top are all based on static dispatch that is when you compile and call a method to a",
    "start": "285199",
    "end": "290919"
  },
  {
    "text": "particular object you know at compile time what it's going to talk to the ones at the bottom are all based on Dynamic",
    "start": "290919",
    "end": "297160"
  },
  {
    "text": "dispatch and the interesting thing about Swift is is that it actually has modes to be able to do either of these things",
    "start": "297160",
    "end": "302960"
  },
  {
    "text": "so you can have something which is compiled and use static dispatch and therefore can be linked in quickly and you also have the ability to call to the",
    "start": "302960",
    "end": "309880"
  },
  {
    "text": "existing Objective C Frameworks and use Dynamic dispatch as well but that's a period of 30 years and quite a lot has",
    "start": "309880",
    "end": "316479"
  },
  {
    "start": "314000",
    "end": "365000"
  },
  {
    "text": "changed in the last 30 years uh 30 years ago Back to the Future we still in the future uh 30 years ago uh humans thought",
    "start": "316479",
    "end": "323199"
  },
  {
    "text": "digital watches were a really neat idea and 30 years ago there was a Star Wars film in the cinemas uh so lots has",
    "start": "323199",
    "end": "330479"
  },
  {
    "text": "changed since then but importantly for processors uh they've got faster and faster um but desktops tended to Plateau",
    "start": "330479",
    "end": "336800"
  },
  {
    "text": "out about 3 GHz uh mobile devices are still Rising today but generally they're in the order of 1 to 2 GHz and the",
    "start": "336800",
    "end": "344199"
  },
  {
    "text": "performance over the last decade has come from the additional number of cores that have come in so whether that's",
    "start": "344199",
    "end": "350120"
  },
  {
    "text": "multiple Calles on a CPU multiple CPUs or for the gpus multiple cores inside",
    "start": "350120",
    "end": "355759"
  },
  {
    "text": "the GPU that's really how we've been getting faster but the important thing is that whilst CPU speed has increased",
    "start": "355759",
    "end": "362360"
  },
  {
    "text": "the memory hasn't increased nearly as fast this is a graph from computer architecture quantitive approach which",
    "start": "362360",
    "end": "369160"
  },
  {
    "start": "365000",
    "end": "491000"
  },
  {
    "text": "is a book that's received by eler um you can't really see the numbers but it sort of decades uh from 1980 on the left to",
    "start": "369160",
    "end": "376199"
  },
  {
    "text": "2010 on the right and on the axis on the far side that's really just a log index",
    "start": "376199",
    "end": "382840"
  },
  {
    "text": "for the power uh 10 100,000 10,000 and so on so to put a few markers on this so",
    "start": "382840",
    "end": "389919"
  },
  {
    "text": "you can see where they came from we had Commodore 64 coming out in the mid 80s and that was roughly the sort of",
    "start": "389919",
    "end": "396400"
  },
  {
    "text": "comparison speed that you had between memory and CPUs um interestingly enough the Commodore 64 was pretty much the",
    "start": "396400",
    "end": "402800"
  },
  {
    "text": "same processor and uh Power as they had on the Apollo Landing computers that",
    "start": "402800",
    "end": "408440"
  },
  {
    "text": "were mentioned in the presentation earlier they're about the same sort of speed they had the same kind of memory that the Apollo Landing computer was a",
    "start": "408440",
    "end": "414039"
  },
  {
    "text": "16 bit and the Commodore was an 8 bit but it's similar sort of processing power between them then we had the Apple",
    "start": "414039",
    "end": "419800"
  },
  {
    "text": "Mac being released in 1984 the original version uh we had the next station that",
    "start": "419800",
    "end": "424840"
  },
  {
    "text": "came in uh in the '90s and that was really the birth of objective c now",
    "start": "424840",
    "end": "430720"
  },
  {
    "text": "Objective C actually happened a few years before that sort of In the period between Commodore 64s and the Mac",
    "start": "430720",
    "end": "436680"
  },
  {
    "text": "release um but it was at a time when processes were getting faster and memory was getting faster about the same time",
    "start": "436680",
    "end": "443240"
  },
  {
    "text": "they were still relatively close to each other but then scroll on through further systems with the iBook uh the power PC",
    "start": "443240",
    "end": "449879"
  },
  {
    "text": "G5 and indeed the iPhone back in 2007 and as we've been going faster on CPUs",
    "start": "449879",
    "end": "456599"
  },
  {
    "text": "the gap between memory and CPUs has been getting wider and wider and interestingly one of the most recently",
    "start": "456599",
    "end": "462680"
  },
  {
    "text": "released computers you might have heard of it the Rasberry Pi Z kind of fits in around about here on the map in terms of",
    "start": "462680",
    "end": "469039"
  },
  {
    "text": "the processor speed uh memory thing so you know we're going quite a long way if you're a fan of Raspberry Pi and you're",
    "start": "469039",
    "end": "475120"
  },
  {
    "text": "a fan of space uh you might be interested to know that there is a Raspberry Pi sitting on top of a rock in Florida at the moment and will shortly",
    "start": "475120",
    "end": "481840"
  },
  {
    "text": "be departing for the International Space Station that launches tonight at midnight uh this local time if you're",
    "start": "481840",
    "end": "487680"
  },
  {
    "text": "interested in watching it uh but the point with all of these things is that there's a real difference between how",
    "start": "487680",
    "end": "493520"
  },
  {
    "start": "491000",
    "end": "599000"
  },
  {
    "text": "fast the CPU is running and how fast we can get data from the memory um and that's because there's a huge amount of",
    "start": "493520",
    "end": "499400"
  },
  {
    "text": "latency that happens between memory and the actual running cores the way that we solved this was by introducing caches so",
    "start": "499400",
    "end": "506520"
  },
  {
    "text": "every core these days usually has a level one cache that sits pretty much right next to the CPU core itself and",
    "start": "506520",
    "end": "512760"
  },
  {
    "text": "can get data in and out at about one n nanc latency there's usually a layer two",
    "start": "512760",
    "end": "517800"
  },
  {
    "text": "cache which if you have multi cores on a single chip is then shared between all of those cores and there's often a level",
    "start": "517800",
    "end": "523839"
  },
  {
    "text": "three cache that hangs around at the back end each time you get further away from the processor you have a higher and",
    "start": "523839",
    "end": "529399"
  },
  {
    "text": "higher latency uh that is the time between when you request the data to be there and the time that it comes back",
    "start": "529399",
    "end": "535880"
  },
  {
    "text": "and this is actually quite an important part because when Swift was was developed they were trying to avoid that",
    "start": "535880",
    "end": "541560"
  },
  {
    "text": "latency Gap the latency of going out fetching something to do next and then bringing it back in incidentally these",
    "start": "541560",
    "end": "547600"
  },
  {
    "text": "numbers are based on the iPhone 6 and iPhone 6s that's the iPhone uh the CPU",
    "start": "547600",
    "end": "553160"
  },
  {
    "text": "processor A8 and A9 um and so this diagram if it shows up",
    "start": "553160",
    "end": "559040"
  },
  {
    "text": "well the presentation slides are available afterwards you can go back and look at the details um but on the far",
    "start": "559040",
    "end": "564399"
  },
  {
    "text": "left hand side we've got the level one cache uh We've then got a level two cache you can't see the access down this",
    "start": "564399",
    "end": "570160"
  },
  {
    "text": "side but this level two cach is about uh kind of 10 nanoc seconds worth of latency a level three cache hitting in",
    "start": "570160",
    "end": "576480"
  },
  {
    "text": "about 80 Mill 80 NS and then main memory being that much further away so if we",
    "start": "576480",
    "end": "581920"
  },
  {
    "text": "can shrink the size of the programs down and we can solve the round trips going out to memory when we jump around the place we can make our processors faster",
    "start": "581920",
    "end": "589279"
  },
  {
    "text": "and we can reduce the battery voltage and faster processors and lower battery consumption are really what apple is",
    "start": "589279",
    "end": "595399"
  },
  {
    "text": "concerned about so that's why Swift was created um we also had a few other nice things that came with swift for example",
    "start": "595399",
    "end": "602279"
  },
  {
    "start": "599000",
    "end": "647000"
  },
  {
    "text": "we had name spaces and modules that was a good way of breaking things down that previously was using uh Frameworks um",
    "start": "602279",
    "end": "609399"
  },
  {
    "text": "importantly with swift we have the ability to choose between a reference based type and a value based type so",
    "start": "609399",
    "end": "615760"
  },
  {
    "text": "reference based types are just NS objects you have a pointer to somewhere in memory and then that data is stored",
    "start": "615760",
    "end": "621160"
  },
  {
    "text": "inside there with uh ref with the structure based type or value based type",
    "start": "621160",
    "end": "626440"
  },
  {
    "text": "then the object is actually uous in memory and if you have an a way of them",
    "start": "626440",
    "end": "631760"
  },
  {
    "text": "uh you can lay them out importantly Swift brought around interoperability with Objective C and because Objective C",
    "start": "631760",
    "end": "639360"
  },
  {
    "text": "is based on C it's got things like undefined behavior and nasal demons those are generally bad things to have",
    "start": "639360",
    "end": "645360"
  },
  {
    "text": "Swift doesn't have any of these undefined problems that we need to worry about uh modules well we know about",
    "start": "645360",
    "end": "651519"
  },
  {
    "start": "647000",
    "end": "717000"
  },
  {
    "text": "modules in Objective C terms they Frameworks uh Objective C based ones that we can hook into are things like",
    "start": "651519",
    "end": "657399"
  },
  {
    "text": "Foundation UI kit Sprite kit uh we've got modules that represent C programming",
    "start": "657399",
    "end": "662800"
  },
  {
    "text": "languages like uh dispatch uh for doing the grand grand central dispatch uh that",
    "start": "662800",
    "end": "671000"
  },
  {
    "text": "you'd use in Objective C as well the simd if you need multiple executions and things like Darwin which then hook into",
    "start": "671000",
    "end": "677399"
  },
  {
    "text": "the ca libraries that you might expect to come across things like random and exit uh and so on and then there's ones",
    "start": "677399",
    "end": "684680"
  },
  {
    "text": "that are based in Swift these are few and far between at the moment but if even when Apple releases Swift as open",
    "start": "684680",
    "end": "692000"
  },
  {
    "text": "source you can expect that a whole bunch of those are going to come alongside so we've got the Swift which is",
    "start": "692000",
    "end": "697360"
  },
  {
    "text": "automatically imported module that defines things like string and array in dictionary and there's a module called",
    "start": "697360",
    "end": "702600"
  },
  {
    "text": "built-in as well and built-in is how the Swift runtime Associates the data with",
    "start": "702600",
    "end": "708680"
  },
  {
    "text": "the processor that you're running on it defines internal representations like uh 256bit int and so on all of these things",
    "start": "708680",
    "end": "716839"
  },
  {
    "text": "are wrapped together in a consistent type space uh the typ space uh has either reference types uh classes either",
    "start": "716839",
    "end": "724079"
  },
  {
    "start": "717000",
    "end": "767000"
  },
  {
    "text": "in Swift or in Objective C and value types which take the form of structures",
    "start": "724079",
    "end": "729519"
  },
  {
    "text": "but those are the things that actually get laid down in memory the type system also has the ability to lay on",
    "start": "729519",
    "end": "734959"
  },
  {
    "text": "additional things on the top of them Protocols are a way of doing duck based typing a protocol basically says if a",
    "start": "734959",
    "end": "741519"
  },
  {
    "text": "class has a particular method then it adopts the protocol and you can add protocols to existing classes without",
    "start": "741519",
    "end": "747040"
  },
  {
    "text": "needing to change their source code and extensions are ways of adding new functionality to methods and uh classes",
    "start": "747040",
    "end": "754519"
  },
  {
    "text": "without needing to change any source code either both of those two things have proved over and over again with",
    "start": "754519",
    "end": "760199"
  },
  {
    "text": "Objective C to be a great way of rolling things forward and Swift is no exception to",
    "start": "760199",
    "end": "765480"
  },
  {
    "text": "that the interesting thing about this is that at runtime when you have something",
    "start": "765480",
    "end": "771000"
  },
  {
    "start": "767000",
    "end": "871000"
  },
  {
    "text": "like a numeric value 64 bit int 32bit int then it's represented the same way",
    "start": "771000",
    "end": "776160"
  },
  {
    "text": "that it is in C it's represented just as one small or bit space without any extra pointers inside but it behaves as if it",
    "start": "776160",
    "end": "783440"
  },
  {
    "text": "was a real type so the last presentation was talking about scalar and types you have things like wi in in there for",
    "start": "783440",
    "end": "789320"
  },
  {
    "text": "being able to wrap additional methods around uh existing integer objects but",
    "start": "789320",
    "end": "794360"
  },
  {
    "text": "in the scalar approach those types are essentially a wrapper value so it's a wrapper object and it changes the",
    "start": "794360",
    "end": "800600"
  },
  {
    "text": "structure in memory in Swift you don't change the structure memory you have exactly the same content in there you just add additional Behavior inside so",
    "start": "800600",
    "end": "808519"
  },
  {
    "text": "the way that is defined is by having a structure and that structure has a single value inside it along with some",
    "start": "808519",
    "end": "814360"
  },
  {
    "text": "other methods that do um what the maximum and what the minimum value is so",
    "start": "814360",
    "end": "819800"
  },
  {
    "text": "although int looks like just a 32-bit value it's actually treated as a structure type in Swift and because it's",
    "start": "819800",
    "end": "825399"
  },
  {
    "text": "treated as a structure type you can have methods that are associated with it you can also adopt protocols so there's",
    "start": "825399",
    "end": "831040"
  },
  {
    "text": "something called assigned integer type which represents all the signs types in uh Swift and you have a protocol called",
    "start": "831040",
    "end": "838480"
  },
  {
    "text": "comparable which allows you to compare two things and make sure that they have the same content similarly with the",
    "start": "838480",
    "end": "843560"
  },
  {
    "text": "unsigned int uint that also has uh similar set of protocols at the top with",
    "start": "843560",
    "end": "848680"
  },
  {
    "text": "unsigned integer type and comparable the nice thing is that the size of both of these things is still 8 Bits so when you",
    "start": "848680",
    "end": "856160"
  },
  {
    "text": "have um one of eight bytes um when you have one of these things that writes out to memory then it takes up a fixed",
    "start": "856160",
    "end": "863000"
  },
  {
    "text": "amount of space inside there and that's because these built-in int 64s are actually the wheel thing that's under",
    "start": "863000",
    "end": "868600"
  },
  {
    "text": "the covers a lot of processing happens in Swift with these protocols and the way that it",
    "start": "868600",
    "end": "873839"
  },
  {
    "start": "871000",
    "end": "940000"
  },
  {
    "text": "looks out if we draw it as a type is that we have any at the top which is actually just a generic name for",
    "start": "873839",
    "end": "879399"
  },
  {
    "text": "protocol without any methods inside there and then all of the types inate in32 uint U 32 and so on are all",
    "start": "879399",
    "end": "888079"
  },
  {
    "text": "structure based types they're value based types when you have a value type and you call a method you pass a copy of",
    "start": "888079",
    "end": "893920"
  },
  {
    "text": "that object into the function you don't pass a reference to it if you have an array of these things then you have an",
    "start": "893920",
    "end": "899759"
  },
  {
    "text": "array that takes up the contiguous size of the number of structures that you have inside and we add Behavior to them",
    "start": "899759",
    "end": "905959"
  },
  {
    "text": "by having protocols and then the extensions if you want to if you wanted to write a method to calculate half an",
    "start": "905959",
    "end": "911720"
  },
  {
    "text": "integer for example then you could add a method called half as an extension to the int type and then you'd allow you to",
    "start": "911720",
    "end": "918199"
  },
  {
    "text": "do on the command line anywhere 1. half and it would give you the value back again so I've spent a bit of time",
    "start": "918199",
    "end": "924680"
  },
  {
    "text": "looking back at Objective C and talking about how things are laid out in memory why did I bother doing all of that setup",
    "start": "924680",
    "end": "930839"
  },
  {
    "text": "well it's all to do with how Swift uh essentially has the means to be able to",
    "start": "930839",
    "end": "936360"
  },
  {
    "text": "be faster than Objective C at runtime one of the ways that it does that is by how the memory is laid out if you have",
    "start": "936360",
    "end": "943399"
  },
  {
    "start": "940000",
    "end": "1077000"
  },
  {
    "text": "Objective C and you use something like an NS array of objects then really what you're doing is you're storing an array",
    "start": "943399",
    "end": "949440"
  },
  {
    "text": "of pointers and that array of pointers then points to an object over here an object over here object down here and so",
    "start": "949440",
    "end": "955639"
  },
  {
    "text": "on this leads to both memory fragmentation and also um diverse memory",
    "start": "955639",
    "end": "962199"
  },
  {
    "text": "locations and this actually hurts CPU performance because if you want to write a loop to go through all of the elements",
    "start": "962199",
    "end": "968000"
  },
  {
    "text": "inside an NS aray it's not just the case of having to step through the pointers you also have to dreference all of those",
    "start": "968000",
    "end": "973519"
  },
  {
    "text": "pointers as well and when you do the D reference the CPU has to then go back out to memory it's probably not in Cache",
    "start": "973519",
    "end": "979360"
  },
  {
    "text": "so we have a full 180 Nan seconds hit to be able to get the object that comes back and once we've done that and we go",
    "start": "979360",
    "end": "985160"
  },
  {
    "text": "on to the second object you have exactly the same thing again arrays of structures and of value types in Swift",
    "start": "985160",
    "end": "991600"
  },
  {
    "text": "are actually laid out as one continuous block so if you have an a way of 32bit ins then it's just 32 bits after 32 bits",
    "start": "991600",
    "end": "998839"
  },
  {
    "text": "in memory and this is great for processors because one of the ways that we've seen the CPUs deal with latency",
    "start": "998839",
    "end": "1005839"
  },
  {
    "text": "problems is by having cache and what happens when you issue a read for the first element in the array what happens",
    "start": "1005839",
    "end": "1011839"
  },
  {
    "text": "is the system will hit and fill up a full cach line and a full cach line is",
    "start": "1011839",
    "end": "1017240"
  },
  {
    "text": "different for different processes but 64 bytes is not a unheard of number for the",
    "start": "1017240",
    "end": "1022519"
  },
  {
    "text": "level one cache uh so what happens is you issue a read for 64 bytes worth of data and that means as you go through",
    "start": "1022519",
    "end": "1029319"
  },
  {
    "text": "the first 8 16 32 um you're actually just reading straight from the cache the",
    "start": "1029319",
    "end": "1034438"
  },
  {
    "text": "other thing that CPUs are very good at is noticing that you read this block then the subsequent block so you're",
    "start": "1034439",
    "end": "1039480"
  },
  {
    "text": "probably going to want to read the next block afterwards and the CPU can actually issue speculative reads to say",
    "start": "1039480",
    "end": "1044760"
  },
  {
    "text": "okay we look like we're walking through this array linearly let's read ahead and let's get some data that was filled up",
    "start": "1044760",
    "end": "1050679"
  },
  {
    "text": "in the cach lines and so the memory optimization for Value based types is really important now I should point out",
    "start": "1050679",
    "end": "1057520"
  },
  {
    "text": "if you're dealing with Objective C there are actually a bunch of struct based values if you dealt with things like CG",
    "start": "1057520",
    "end": "1062679"
  },
  {
    "text": "rects that's a structor float values and so that has the same kind of performance but Swift makes it clearer and it tries",
    "start": "1062679",
    "end": "1069160"
  },
  {
    "text": "to encourage you to use more value-based types rather than rapper based objects that you have in Objective C the other",
    "start": "1069160",
    "end": "1077000"
  },
  {
    "start": "1077000",
    "end": "1174000"
  },
  {
    "text": "difference is the static and dynamic dispatch we talked about the influences of languages and where they've come from in",
    "start": "1077000",
    "end": "1082640"
  },
  {
    "text": "the past but static dispatch is the thing that's used by C and C Plus+ and",
    "start": "1082640",
    "end": "1088000"
  },
  {
    "text": "by Swift if you don't use Objective C classes and the nice thing is that the function calls are then known precisely",
    "start": "1088000",
    "end": "1093960"
  },
  {
    "text": "so when you have a function call and it reaches out to a function that you know",
    "start": "1093960",
    "end": "1099200"
  },
  {
    "text": "at compile time what it's going to be the compiler can generate essentially a direct function call with call or call Q",
    "start": "1099200",
    "end": "1105000"
  },
  {
    "text": "to the direct simple this is not only the fastest way that you can call functions but the comp the CPU knows",
    "start": "1105000",
    "end": "1112240"
  },
  {
    "text": "about these call instructions and if you can see in the pipeline there's a call instruction coming down and it's pointing to an address that's already",
    "start": "1112240",
    "end": "1118480"
  },
  {
    "text": "resolved then it can reach out to memory and start downloading that code so by the time the call instruction hits the",
    "start": "1118480",
    "end": "1123880"
  },
  {
    "text": "CPU it's already got the code in there to do it Dynamic dispatch which is the way that Objective C methods work and",
    "start": "1123880",
    "end": "1130280"
  },
  {
    "text": "the way that uh Ruby and um uh object Small Talk work all go through an",
    "start": "1130280",
    "end": "1135919"
  },
  {
    "text": "indirect call called object oby message send essentially what oby message send",
    "start": "1135919",
    "end": "1141039"
  },
  {
    "text": "is doing is it's replacing the call with a call to a dynamic lookup of something in a hash table so when you want to call",
    "start": "1141039",
    "end": "1147520"
  },
  {
    "text": "a method name or a selector in Objective C terminology it hooks up looks in a table and then gets the um data back",
    "start": "1147520",
    "end": "1154320"
  },
  {
    "text": "again the reason I put in here in Swift swift is actually capable of generating classes that will fit in with The",
    "start": "1154320",
    "end": "1160360"
  },
  {
    "text": "Objective C runtime and use Dynamic dispatch and they've got that there so that they can have compatibility with",
    "start": "1160360",
    "end": "1166000"
  },
  {
    "text": "existing iOS Frameworks like UI kit and ultimately provide a migration path from",
    "start": "1166000",
    "end": "1172039"
  },
  {
    "text": "one to the other so the difference between static dispatch also affects um optimization if",
    "start": "1172039",
    "end": "1178840"
  },
  {
    "start": "1174000",
    "end": "1225000"
  },
  {
    "text": "we have a sequence of function calls A to B to C and we can prove that we're",
    "start": "1178840",
    "end": "1183960"
  },
  {
    "text": "always going to call a then we're going to call B then we're going to call C there's a way of optimizing all of these things together essentially squashing",
    "start": "1183960",
    "end": "1189640"
  },
  {
    "text": "them down into one method so that we just have one copy of the code if you do that there's no hopping around in memory",
    "start": "1189640",
    "end": "1195559"
  },
  {
    "text": "there's no latency problems the CPU can just get what it needs to done and then go back into a deep sleep mode without",
    "start": "1195559",
    "end": "1201400"
  },
  {
    "text": "taking any extra energy in Dynamic dispatch like you have with Objective C you don't have that because every time",
    "start": "1201400",
    "end": "1207320"
  },
  {
    "text": "you hop from one method to another you're always going via Objective C message send and the CPU can't really",
    "start": "1207320",
    "end": "1213320"
  },
  {
    "text": "optimize Objective C message send because every time you go through it it's looking up an entry in a hash table and it has to wait until it knows what",
    "start": "1213320",
    "end": "1219799"
  },
  {
    "text": "the answer for that hash table is before it can then Branch out and call the function now Objective C message CH is",
    "start": "1219799",
    "end": "1226039"
  },
  {
    "start": "1225000",
    "end": "1330000"
  },
  {
    "text": "fast it's built-in assembly and it's been tuned over the decades but there's still some overhead uh there's overhead",
    "start": "1226039",
    "end": "1232919"
  },
  {
    "text": "not only in the fact that there's extra instructions which means that you're going to cause extra battery power but also any function that you have in",
    "start": "1232919",
    "end": "1239840"
  },
  {
    "text": "Objective C message send means that you're taking up at least two parameters you're taking up uh the self object this",
    "start": "1239840",
    "end": "1246840"
  },
  {
    "text": "U that's referring to the object that you're calling from and also the CMD the selected value and that means that any",
    "start": "1246840",
    "end": "1252960"
  },
  {
    "text": "function that you call is always going to have two arguments that get passed into it now that is important because",
    "start": "1252960",
    "end": "1258799"
  },
  {
    "text": "under the covers what happens with cool based processes is that they usually have four arguments that they can store",
    "start": "1258799",
    "end": "1264440"
  },
  {
    "text": "in registers and then the rest of it gets spilt onto the stack so with Objective C you really only get two",
    "start": "1264440",
    "end": "1269640"
  },
  {
    "text": "arguments that you can call in an efficient way before it has to form a slightly different efficient thing and if there's one thing that Apple love",
    "start": "1269640",
    "end": "1276240"
  },
  {
    "text": "it's efficiency because efficiency translates into battery life and the longer you can have battery life then the more phones that they can sell now",
    "start": "1276240",
    "end": "1283360"
  },
  {
    "text": "this assembly has been evolving over time back in the leopard days it was about 100 bytes worth of assembly there",
    "start": "1283360",
    "end": "1288760"
  },
  {
    "text": "was a huge jump that went down to Lion when it dropped down to 47 bytes that's when they took out the special case",
    "start": "1288760",
    "end": "1293840"
  },
  {
    "text": "handling of garbage collection some of you might have remembered the garbage collection support that Objective C had",
    "start": "1293840",
    "end": "1299000"
  },
  {
    "text": "back in those days and particularly eagle eyes will have noticed that in yo7 it's actually gone up a little bit and",
    "start": "1299000",
    "end": "1304640"
  },
  {
    "text": "that's because there has been something called tagged pointers or non-p pointer isers uh which needed a little bit of uh",
    "start": "1304640",
    "end": "1310679"
  },
  {
    "text": "masking before it then calls into the actual function itself so it's still pretty fast most of the bites that fit",
    "start": "1310679",
    "end": "1316679"
  },
  {
    "text": "in there are going to fit into one cach line but essentially the CPU can't um optimize the calls between functions",
    "start": "1316679",
    "end": "1323480"
  },
  {
    "text": "because it goes into a message send and then it goes out to pretty much every objective c message that",
    "start": "1323480",
    "end": "1329240"
  },
  {
    "text": "exists now the other reason why optimizations like this are important is because if you have a CO chain of a Tob",
    "start": "1329240",
    "end": "1335279"
  },
  {
    "start": "1330000",
    "end": "1396000"
  },
  {
    "text": "and you can compress that down into a you suddenly open up the possibility for more optimizations to occur um not only",
    "start": "1335279",
    "end": "1341720"
  },
  {
    "text": "do you get rid of the function calling and the U any stack or register spills that are going to go on but you can also",
    "start": "1341720",
    "end": "1347279"
  },
  {
    "text": "avoid um branch missing and memory jumps which can also slow things down but importantly it also unlocks further",
    "start": "1347279",
    "end": "1354200"
  },
  {
    "text": "peple optimizations so if we have a function here Fu which takes an INT value if the int value is negative say",
    "start": "1354200",
    "end": "1361440"
  },
  {
    "text": "we've hit some sort of error condition and then we return an abort early out of the function then if we ever call it and",
    "start": "1361440",
    "end": "1368400"
  },
  {
    "text": "we know at compile time that the value is negative essentially it's a noop and",
    "start": "1368400",
    "end": "1373480"
  },
  {
    "text": "we can just get rid of it and wipe it out um and actually quite a lot of the optimizations do that one downside is it",
    "start": "1373480",
    "end": "1380080"
  },
  {
    "text": "increases the code size uh potentially if you're squashing these things together um but on the plus side if you",
    "start": "1380080",
    "end": "1385880"
  },
  {
    "text": "have negative values or other things that form a particular condition then you can optimize the calls away and",
    "start": "1385880",
    "end": "1391520"
  },
  {
    "text": "generally the fastest code is the code that the CPU never has to run there's also something uh which has been called",
    "start": "1391520",
    "end": "1397840"
  },
  {
    "start": "1396000",
    "end": "1486000"
  },
  {
    "text": "either link time optimization or whole module optimization depending on uh where you Ed it from first but",
    "start": "1397840",
    "end": "1403640"
  },
  {
    "text": "essentially the purpose of this is to say instead of just focusing on a single file and doing the op optimizations",
    "start": "1403640",
    "end": "1409120"
  },
  {
    "text": "inside there what we can do is we can call out modules we can call out optimizations across different files",
    "start": "1409120",
    "end": "1415039"
  },
  {
    "text": "across different modules and that usually then unlocks a lot of different uh optimizations that happen so when you",
    "start": "1415039",
    "end": "1421679"
  },
  {
    "text": "compile a file instead of generating out an Intel uh object file with all of the",
    "start": "1421679",
    "end": "1427360"
  },
  {
    "text": "CPU specific information inside there it can actually write out a form of llvm B",
    "start": "1427360",
    "end": "1432600"
  },
  {
    "text": "code or IR um when the llvm Linker runs it can then pull all of those together",
    "start": "1432600",
    "end": "1438480"
  },
  {
    "text": "and run optimizations and generally do a much better job for being able to optimize things and it wouldn't surprise",
    "start": "1438480",
    "end": "1444679"
  },
  {
    "text": "me if those things started bleeding down into the Swift libraries as well so that when you're copying the Swift Library",
    "start": "1444679",
    "end": "1449960"
  },
  {
    "text": "code it's actually optimizing the library code for your particular application so that it goes in now from",
    "start": "1449960",
    "end": "1456080"
  },
  {
    "text": "a programming point of view if you want to take advantage of this uh you'll be wanting to make your methods and data structures as final or private because",
    "start": "1456080",
    "end": "1463799"
  },
  {
    "text": "those then essentially unlock permissions for the compiler to be able to line those struts are always final",
    "start": "1463799",
    "end": "1470520"
  },
  {
    "text": "you can't subass structs so you don't have any uh way of changing that and if you have functions defined as private or",
    "start": "1470520",
    "end": "1477679"
  },
  {
    "text": "internal then they're going to be declared as being local to either that file or that uh module or Target and",
    "start": "1477679",
    "end": "1483960"
  },
  {
    "text": "they can be optimized away now Swift and llvm really came",
    "start": "1483960",
    "end": "1489000"
  },
  {
    "start": "1486000",
    "end": "1534000"
  },
  {
    "text": "together about the same sort of time the guy who did most of the work on llvm was a guy called Chris latner um he was also",
    "start": "1489000",
    "end": "1494720"
  },
  {
    "text": "the main architect behind Swift and he's the one who's really pushing to get Swift open sourced um llvm has been",
    "start": "1494720",
    "end": "1500279"
  },
  {
    "text": "around for a while but originally stood for low-level virtual machine which is not really a great name for it",
    "start": "1500279",
    "end": "1506000"
  },
  {
    "text": "especially for people who've come from VM backgrounds from either Java or the net world really what llvm works on is",
    "start": "1506000",
    "end": "1512919"
  },
  {
    "text": "the idea of an abstract Assembly Language something where you have an infinite number of registers uh and can",
    "start": "1512919",
    "end": "1519440"
  },
  {
    "text": "actually call functions without having to declare a particular prototypes um it's called and return convention",
    "start": "1519440",
    "end": "1524840"
  },
  {
    "text": "agnostic so that you can specify things and you can either have a c function call or you can have an Objective C function call or a direct inline",
    "start": "1524840",
    "end": "1531480"
  },
  {
    "text": "function call as well and this is used in the Swift compiler the Swift compil pipeline has something that translates",
    "start": "1531480",
    "end": "1538399"
  },
  {
    "start": "1534000",
    "end": "1697000"
  },
  {
    "text": "it into an abstract syntax tree first of all um the abstract syntax tree then gets paused and semantically analyzed to",
    "start": "1538399",
    "end": "1544520"
  },
  {
    "text": "make sure that you're referring to correct types uh then it gets translated through into something called sill which is the Swift Intermediate Language which",
    "start": "1544520",
    "end": "1551159"
  },
  {
    "text": "is kind of like IR but a slightly higher level so it has knowledge about Swift intrinsics like exception handling um in",
    "start": "1551159",
    "end": "1558520"
  },
  {
    "text": "Swift functionality and Swift methods um there's been a video posted on YouTube by Chris lner from the llvm developers",
    "start": "1558520",
    "end": "1565080"
  },
  {
    "text": "meeting that happened in October I think the YouTube video went up about 3 weeks ago where he talks about the benefits of",
    "start": "1565080",
    "end": "1570960"
  },
  {
    "text": "having sill as a separate language to IR if you're interested in that I suggest you look that up from the llvm developer",
    "start": "1570960",
    "end": "1577399"
  },
  {
    "text": "meeting um and then the sill gets translated into llvm IR now that's been around for a long time that happened",
    "start": "1577399",
    "end": "1584000"
  },
  {
    "text": "when llvm was initially released it's used by clang and The Objective C compiler uh with xcode since xcode 5 or",
    "start": "1584000",
    "end": "1590760"
  },
  {
    "text": "six so it's been around for quite a long time but the IR tends to have some platform specific dependencies in there",
    "start": "1590760",
    "end": "1597200"
  },
  {
    "text": "like what the word size happens to be for example and then you can outut it to",
    "start": "1597200",
    "end": "1602320"
  },
  {
    "text": "either assembly uh bit code or or Library output the bit code here is the",
    "start": "1602320",
    "end": "1607520"
  },
  {
    "text": "one that Apple are encouraging people to use because if you upload bit code into the Apple store then Apple can relink",
    "start": "1607520",
    "end": "1614039"
  },
  {
    "text": "the whole application and maybe perform additional optimizations that you didn't know about when you built your code so how does",
    "start": "1614039",
    "end": "1621080"
  },
  {
    "text": "this work in practice well everyone knows how we do hello world examples so this is our hello world example in Swift",
    "start": "1621080",
    "end": "1626640"
  },
  {
    "text": "print hello world that goes through a PA tree generates to an abstract syntax tree goes through a semantic based",
    "start": "1626640",
    "end": "1633039"
  },
  {
    "text": "analysis to make sure everything works out uh and hooks up from a typing perspective gets generated into the seal",
    "start": "1633039",
    "end": "1640960"
  },
  {
    "text": "pipeline to generate Swift Intermediate Language uh that then goes through a further set of optimizations before it's",
    "start": "1640960",
    "end": "1647000"
  },
  {
    "text": "translated into to llvm ir and then once it's got to llvm IR it's just handed",
    "start": "1647000",
    "end": "1652360"
  },
  {
    "text": "over to the back ends of the llvm tool chain which can then spit out uh either object files or dynamic Library files um",
    "start": "1652360",
    "end": "1660640"
  },
  {
    "text": "or indeed native executables and that's sort of the pipeline now one of the interesting things about Swift and",
    "start": "1660640",
    "end": "1666480"
  },
  {
    "text": "indeed llvm is that there's arguments that you can use to actually see the intermediate stages for each of these",
    "start": "1666480",
    "end": "1672840"
  },
  {
    "text": "things um I think the llvm guys left them in there initially for debugging purposes but it's quite interesting to",
    "start": "1672840",
    "end": "1680000"
  },
  {
    "text": "see what happens and if you wanted to you could write your own language which targeted s or maybe you'd want to go uh",
    "start": "1680000",
    "end": "1687320"
  },
  {
    "text": "from translating Ruby into s or Java into s those kind of things are possible if you wanted uh to be able to generate",
    "start": "1687320",
    "end": "1693720"
  },
  {
    "text": "those things so let's work backwards and see how it all looks like this is the example in C um which got a main method",
    "start": "1693720",
    "end": "1700760"
  },
  {
    "start": "1697000",
    "end": "1761000"
  },
  {
    "text": "and a puts Hello World um if we run clang with the emit llvm argument then",
    "start": "1700760",
    "end": "1707080"
  },
  {
    "text": "we get back the llv VM code and so this is the llvm code for the C based language it kind of looks similar you",
    "start": "1707080",
    "end": "1713120"
  },
  {
    "text": "can see where some of these things have come from uh from a syntax perspective there are some things to do with global",
    "start": "1713120",
    "end": "1719399"
  },
  {
    "text": "variables so this app.st at the top is called a global value a global label and",
    "start": "1719399",
    "end": "1725880"
  },
  {
    "text": "then ones with a percent are essentially local to a particular function those are the infinite registers uh that I was",
    "start": "1725880",
    "end": "1730919"
  },
  {
    "text": "talking about uh and then the call function there ends up uh just invoking the put SL uh symbol which is then",
    "start": "1730919",
    "end": "1737600"
  },
  {
    "text": "resolved from uh the Linker when it comes in and you can then Trace that down into the assembly if you want to uh",
    "start": "1737600",
    "end": "1743679"
  },
  {
    "text": "by using imit assembly on the clan compiler and you can see on the call Q puts line uh in the middle of the",
    "start": "1743679",
    "end": "1750919"
  },
  {
    "text": "assembly at the top that it looks as if it is you calling the function directly",
    "start": "1750919",
    "end": "1756600"
  },
  {
    "text": "that's a nice thing that the compiler can optimize for you and there's a whole bunch of reasons why IR is good uh it",
    "start": "1756600",
    "end": "1762399"
  },
  {
    "start": "1761000",
    "end": "1796000"
  },
  {
    "text": "allows you to understand what's going on at the program from the compil level it allows for accurate Transformations you",
    "start": "1762399",
    "end": "1767840"
  },
  {
    "text": "can have inlining across function calls because it knows the calling syntax and you can eliminate code paths um but it's",
    "start": "1767840",
    "end": "1774880"
  },
  {
    "text": "got a bunch of phases in there that are language agnostic there's a lot more things that you can unlock if you know",
    "start": "1774880",
    "end": "1780240"
  },
  {
    "text": "things about the particular application if you know that for example you're calling a function and you can prove",
    "start": "1780240",
    "end": "1785440"
  },
  {
    "text": "that because of the arguments you've used you're never going to see an exception bubbling up then you can actually just emit the whole exception",
    "start": "1785440",
    "end": "1792440"
  },
  {
    "text": "catching code that you would go along with it so let's have a look and see how this works with Swift uh with we can use",
    "start": "1792440",
    "end": "1798880"
  },
  {
    "start": "1796000",
    "end": "1974000"
  },
  {
    "text": "the Swift compiler this time with an emit IR argument rather than emit llvm y",
    "start": "1798880",
    "end": "1804679"
  },
  {
    "text": "standardization um and then you end up with something that looks a little bit like this again we've got the at Main in",
    "start": "1804679",
    "end": "1809960"
  },
  {
    "text": "there which is the global we've got the at zero constant which is the hello world string and we've got a bunch of complete gibberish on the method that",
    "start": "1809960",
    "end": "1816440"
  },
  {
    "text": "we're going to call there so what does that mean why have we got gibberish there rather than something nice like",
    "start": "1816440",
    "end": "1821679"
  },
  {
    "text": "just print well the reason why that exists is because something called name mangling and name mangling is the way",
    "start": "1821679",
    "end": "1827399"
  },
  {
    "text": "that you translate The Source base functions into the actual names of the symbols that get put out in the assembly",
    "start": "1827399",
    "end": "1832799"
  },
  {
    "text": "file C has a really complex encoding convention for this it sticks an underscore on the front um so actually",
    "start": "1832799",
    "end": "1839600"
  },
  {
    "text": "cbas programs are relatively easy to debug C++ use name mangling because you could have method overriding so you",
    "start": "1839600",
    "end": "1846679"
  },
  {
    "text": "could have different methods with different return types or different argument types and in order to distinguish from those and indeed the",
    "start": "1846679",
    "end": "1852960"
  },
  {
    "text": "main in one class versus the main in another class there was an encoding that was used so anything begins with uncore",
    "start": "1852960",
    "end": "1859240"
  },
  {
    "text": "uncore z uh is going to have a C++ name um then there is a length-based encoding",
    "start": "1859240",
    "end": "1865200"
  },
  {
    "text": "so the four immediately after the uh Zed means that there's four characters of name that comes up afterwards and then",
    "start": "1865200",
    "end": "1871480"
  },
  {
    "text": "various different symbols have particular meanings like I meaning int and PPC meaning a pointer to a point to",
    "start": "1871480",
    "end": "1877039"
  },
  {
    "text": "a car so that's the car and um Char star star that you have at the top of the main method Swift is much the same",
    "start": "1877039",
    "end": "1884159"
  },
  {
    "text": "except it's a lot more complicated so anything beginning with underscore t is a swift based symbol um so in this one",
    "start": "1884159",
    "end": "1890840"
  },
  {
    "text": "we have a whole bunch of stuff which I'm not going to read out U most of this is probably going to be uninteresting",
    "start": "1890840",
    "end": "1896320"
  },
  {
    "text": "because you're never likely to look at these things directly but f means it's a function type anything with a capital s",
    "start": "1896320",
    "end": "1902600"
  },
  {
    "text": "means it's to do with a swift module and S capital S with a little s means the Swift module that you get with import",
    "start": "1902600",
    "end": "1909080"
  },
  {
    "text": "Swift five print means we've got five character method name or function name called print uh the tgsp is actually a",
    "start": "1909080",
    "end": "1916480"
  },
  {
    "text": "concatenation of these things bunch Bunch together it's a tupal of a generic array sa is array and then pcore uncore",
    "start": "1916480",
    "end": "1924480"
  },
  {
    "text": "is a protocol which essentially that line consists to an array of empty protocols or an array of any objects and",
    "start": "1924480",
    "end": "1931440"
  },
  {
    "text": "then we've got a couple of other arguments we've got separator uh and we've got Terminator as well now in",
    "start": "1931440",
    "end": "1937039"
  },
  {
    "text": "Swift 2.1 the print statement actually has a couple of arguments inside there that allow you to have separators and",
    "start": "1937039",
    "end": "1943519"
  },
  {
    "text": "allow you to put additional new lines on that's something that was changed from the Swift 1 days um but essentially if",
    "start": "1943519",
    "end": "1948799"
  },
  {
    "text": "you do print one comma 2 comma 3 that gets translated into an array of values and then for each one that gets printed",
    "start": "1948799",
    "end": "1955559"
  },
  {
    "text": "out it prints out a separator so if you wanted to have a semicolon uh organized list of elements you could say 1 comma 2",
    "start": "1955559",
    "end": "1961840"
  },
  {
    "text": "comma 3 separator uh is semicolon and then the print statement would hand that out for you that's why the print",
    "start": "1961840",
    "end": "1968039"
  },
  {
    "text": "statement looks a little bit uh weird when it goes on now fortunately you don't need to understand any of these",
    "start": "1968039",
    "end": "1973159"
  },
  {
    "text": "things because there is a tool called Swift demangle you can't run Swift demangle because it's not on the the path directly but if you use xc1 and",
    "start": "1973159",
    "end": "1980919"
  },
  {
    "start": "1974000",
    "end": "2006000"
  },
  {
    "text": "either pass in the value as an argument or simply pipe the stream through uh you",
    "start": "1980919",
    "end": "1986320"
  },
  {
    "text": "can then use it to figure out what it means so in this case the symbol that I've pulled up here when we've Dem mangled it essentially says there is a",
    "start": "1986320",
    "end": "1993039"
  },
  {
    "text": "function called swift. print it takes an array of protocol angle and close brackets that's the any type in Swift uh",
    "start": "1993039",
    "end": "2000399"
  },
  {
    "text": "and it has two other arguments of separator and DET Terminator and it returns a nothing um so we can use this to see",
    "start": "2000399",
    "end": "2007399"
  },
  {
    "start": "2006000",
    "end": "2065000"
  },
  {
    "text": "what the Intermediate Language happens in the Swift right so if we do Swift C compile the Swift file and then use imit",
    "start": "2007399",
    "end": "2014279"
  },
  {
    "text": "S then we get something that looks a little bit more understandable again this still has the references inside uh",
    "start": "2014279",
    "end": "2021799"
  },
  {
    "text": "that for those particular functions but one of the nice things it does is it spits out in comments what the function",
    "start": "2021799",
    "end": "2028279"
  },
  {
    "text": "types and function references actually mean and you can also pipe the whole thing through the Swift D mangle and",
    "start": "2028279",
    "end": "2034440"
  },
  {
    "text": "anytime it sees stuff beginning with an underscore T it will automatically trans translate that into an appropriate type",
    "start": "2034440",
    "end": "2040559"
  },
  {
    "text": "so in this particular case our hello world has got an implicit main function which is the still at Main down at the",
    "start": "2040559",
    "end": "2046159"
  },
  {
    "text": "bottom uh it says we're using the c-based convention for calling function calls and the arguments that we get is a",
    "start": "2046159",
    "end": "2053040"
  },
  {
    "text": "32-bit in um an unsafe mutable pointer to an unsafe mutable pointer of intake so that's our cast star star and it",
    "start": "2053040",
    "end": "2060320"
  },
  {
    "text": "returns an int32 value um the reason why sill is interesting is because it allows us to",
    "start": "2060320",
    "end": "2066440"
  },
  {
    "start": "2065000",
    "end": "2138000"
  },
  {
    "text": "introspect the uh lookup tables for functions so if we have a class world and that class world has a function",
    "start": "2066440",
    "end": "2072679"
  },
  {
    "text": "hello inside there and we compile that and have a look at the S uh then down at the bottom we get something called a",
    "start": "2072679",
    "end": "2078878"
  },
  {
    "text": "sill vtable vtable is virtual function called lookup and essentially it says if",
    "start": "2078879",
    "end": "2083960"
  },
  {
    "text": "you have got a world object and you want to in invoke the hello function then uh",
    "start": "2083960",
    "end": "2090040"
  },
  {
    "text": "you can do world. hello and that corresponds to uh the TFC 4 main five",
    "start": "2090040",
    "end": "2095560"
  },
  {
    "text": "hello five world five hello function now the nice thing about this is it's",
    "start": "2095560",
    "end": "2100720"
  },
  {
    "text": "actually possible to do lookups of functions that you're calling in classes",
    "start": "2100720",
    "end": "2106240"
  },
  {
    "text": "and automatically know at compile time which function is going to be called and so although Swift does have the ability",
    "start": "2106240",
    "end": "2112200"
  },
  {
    "text": "to do Dynamic lookups and at runtime go to the V table and then from the V table call the particular function uh it also",
    "start": "2112200",
    "end": "2119000"
  },
  {
    "text": "has the ability to inline this at compile time so that it actually ends up just calling the function directly",
    "start": "2119000",
    "end": "2124440"
  },
  {
    "text": "there's also usually for classes some other types as well uh if you don't specify you get an initializer for free",
    "start": "2124440",
    "end": "2130240"
  },
  {
    "text": "and there's also a deallocating D in it which just uh D allocator which then cleans up the object",
    "start": "2130240",
    "end": "2136640"
  },
  {
    "text": "afterwards now to show uh how some of this works I've put something together called s inspector uh there's a GitHub",
    "start": "2136640",
    "end": "2142480"
  },
  {
    "start": "2138000",
    "end": "2839000"
  },
  {
    "text": "project that exists uh that you can download it and compile it from I haven't released it as a binary because",
    "start": "2142480",
    "end": "2148040"
  },
  {
    "text": "it's actually something which is easy to compile if you've got xcode and play around with it um but let me just uh",
    "start": "2148040",
    "end": "2154880"
  },
  {
    "text": "bring up the argument over here so the idea of this was just to allow me",
    "start": "2154880",
    "end": "2161880"
  },
  {
    "text": "to show what happens when you use Swift and certain optimizations we've got here our print hello world and if we pipe it",
    "start": "2161880",
    "end": "2169119"
  },
  {
    "text": "through the abstract syntax tree we get back a lisp kind of representation for what the source file actually looks like",
    "start": "2169119",
    "end": "2176119"
  },
  {
    "text": "uh so in this case it's got things like there is a top level source file um there's top level code statement we're calling a particular function inside",
    "start": "2176119",
    "end": "2182880"
  },
  {
    "text": "there now there's actually a lot of stuff in there that you probably isn't necessary and and once you do the",
    "start": "2182880",
    "end": "2188680"
  },
  {
    "text": "semantic analysis A lot of these things collapse down so the initial as is just something that happens very quickly and",
    "start": "2188680",
    "end": "2195760"
  },
  {
    "text": "um just spits out things saying you know there's a semicolon here but once you do the semantic analysis on it you know",
    "start": "2195760",
    "end": "2201720"
  },
  {
    "text": "that we've got a string lital there which is a UTF encoded string which is hello world if we had different other",
    "start": "2201720",
    "end": "2207240"
  },
  {
    "text": "encodings inside there um UTF 16 for example then they could be written out in the same kind of",
    "start": "2207240",
    "end": "2213119"
  },
  {
    "text": "style you can also have a look at what the sill is uh the Sill is the um the",
    "start": "2213119",
    "end": "2219880"
  },
  {
    "text": "the Swift Intermediate Language representation and at the top you can see maybe there's a bit more subtlety in Swift going on so all files that you",
    "start": "2219880",
    "end": "2227680"
  },
  {
    "text": "write in Swift automatically import the Swift module that brings in things like the um the the array in the dictionary",
    "start": "2227680",
    "end": "2234720"
  },
  {
    "text": "and so on and we've got this thing called buil-in and buil-in is the way that you get exposed to data types on",
    "start": "2234720",
    "end": "2241880"
  },
  {
    "text": "the underlying platform so what in a nutshell does int32 really mean um what",
    "start": "2241880",
    "end": "2247920"
  },
  {
    "text": "is a native object those kind of things are inst imported in built-in now you used to in older versions of xcode be",
    "start": "2247920",
    "end": "2254520"
  },
  {
    "text": "able to hyperlink into built-in and see what was going on inside there but they've taken that out of xode 71 uh but",
    "start": "2254520",
    "end": "2259760"
  },
  {
    "text": "if you want to you can go into the Swift core library and then be able to dump the functions out inside",
    "start": "2259760",
    "end": "2264839"
  },
  {
    "text": "there uh so we've got our main entry point inside here uh this sill at Main",
    "start": "2264839",
    "end": "2270839"
  },
  {
    "text": "uh with the calling convention is the entry point just like in any other uh compiled program that",
    "start": "2270839",
    "end": "2277040"
  },
  {
    "text": "you'd have and we then have the code now a lot of this looks like it's complete gibberish",
    "start": "2277040",
    "end": "2283400"
  },
  {
    "text": "um what happen and the reason why the print example is so complicated is because print is a function that takes",
    "start": "2283400",
    "end": "2290319"
  },
  {
    "text": "an array of values and also has two other separators as well so firstly when you call print it has to call and find",
    "start": "2290319",
    "end": "2296400"
  },
  {
    "text": "out what the default argument for parameter 2 is for the separator is and then the default value for the new line",
    "start": "2296400",
    "end": "2303000"
  },
  {
    "text": "and then use those to be able to call the functions and it also has to take your value that you've passed in build it into an aware protocols and then call",
    "start": "2303000",
    "end": "2309599"
  },
  {
    "text": "that as well and we have uh down at the bottom these type functions like did enter main unsafe mutable pointer which",
    "start": "2309599",
    "end": "2316800"
  },
  {
    "text": "generally are complete gibberish um you can't see this in the slide and the",
    "start": "2316800",
    "end": "2322160"
  },
  {
    "text": "presentation because it's a little bit too small font but down at the bottom left there is a command that you can run",
    "start": "2322160",
    "end": "2328880"
  },
  {
    "text": "uh to be able to do this from the command line uh so if I open up this and make it a little bit",
    "start": "2328880",
    "end": "2334880"
  },
  {
    "text": "bigger um if we do the same thing with uh the print",
    "start": "2334880",
    "end": "2341160"
  },
  {
    "text": "example and then you pipe it through this Swift command then you'll see the same thing that comes out from there and",
    "start": "2341440",
    "end": "2348400"
  },
  {
    "text": "even that's a little bit too small as well um so anyway you'll see this from the slides and if you download the app",
    "start": "2348400",
    "end": "2353880"
  },
  {
    "text": "you can play with it as well so what do all of these things mean",
    "start": "2353880",
    "end": "2358920"
  },
  {
    "text": "inside here well if we wanted to find out what these mean we can pipe the whole file through the swiftd mangle and",
    "start": "2358920",
    "end": "2364520"
  },
  {
    "text": "the Swift D mangle will then look for any acces of score T and then convert them so I've got an option in here to",
    "start": "2364520",
    "end": "2370359"
  },
  {
    "text": "just demangle this uh and if I switch that on then you see we start getting uh sensible types in here like uh the",
    "start": "2370359",
    "end": "2376640"
  },
  {
    "text": "initializer of the Swift based type um the wheel implementation of the",
    "start": "2376640",
    "end": "2382319"
  },
  {
    "text": "function though uh comes in uh at the bottom of this function block so inside",
    "start": "2382319",
    "end": "2388280"
  },
  {
    "text": "this the main based function that we've got which starts up",
    "start": "2388280",
    "end": "2393680"
  },
  {
    "text": "here um there's actually a lot of things that are happening um most of them are to do with setup code so most of them",
    "start": "2393680",
    "end": "2400240"
  },
  {
    "text": "are to do with how we pass the arguments that get passed in um there is a function inside here which means very",
    "start": "2400240",
    "end": "2406880"
  },
  {
    "text": "little um which I don't think gets translated which is the the um uh Swift once call uh and you'll see a reference",
    "start": "2406880",
    "end": "2414880"
  },
  {
    "text": "to uh that when you do Google searches um but essentially the arguments they get",
    "start": "2414880",
    "end": "2421760"
  },
  {
    "text": "called it's looking up things like the function reference so percent 21 is a",
    "start": "2421760",
    "end": "2426800"
  },
  {
    "text": "function ref reference to our Swift based print function that takes an array of pro any objects the separator and the",
    "start": "2426800",
    "end": "2433079"
  },
  {
    "text": "Terminator and then it's using it to be this apply call so those of you who come from a functional background you may",
    "start": "2433079",
    "end": "2438920"
  },
  {
    "text": "have seen apply before but this is really just a way of saying given this function and this set of arguments then",
    "start": "2438920",
    "end": "2444720"
  },
  {
    "text": "make the call the nice thing about this is that we haven't talked anything about the underlying architecture that we're running on or um the way in which those",
    "start": "2444720",
    "end": "2452200"
  },
  {
    "text": "are going to be translated into bite code there's a Canon canonical representation of this as well which",
    "start": "2452200",
    "end": "2458240"
  },
  {
    "text": "does some other optimizations uh so in this case uh we've got built-ins that are uh that can be used to do addition",
    "start": "2458240",
    "end": "2465400"
  },
  {
    "text": "so the S add with overflow in 64 is actually a built-in function reference that's actually used to be able to add",
    "start": "2465400",
    "end": "2470640"
  },
  {
    "text": "values together and you can then see what the generated IR for that looks like so the IR actually looks quite",
    "start": "2470640",
    "end": "2476880"
  },
  {
    "text": "similar to the way the Swift based functions work um but it's one level down and with one level of elements",
    "start": "2476880",
    "end": "2483560"
  },
  {
    "text": "removed and if you want to you can have a look at the assembly that goes on but the main example uh the print hello",
    "start": "2483560",
    "end": "2489640"
  },
  {
    "text": "world example is not particularly exciting because of the amount of stuff that adds up inside here if we were to",
    "start": "2489640",
    "end": "2495839"
  },
  {
    "text": "create a function instead where we're adding a couple of integers together for",
    "start": "2495839",
    "end": "2500920"
  },
  {
    "text": "example and uh we are returning an INT",
    "start": "2500920",
    "end": "2506078"
  },
  {
    "text": "value and you can type and talk at the same time then you can actually see what that",
    "start": "2510599",
    "end": "2516400"
  },
  {
    "text": "gets translated too oh yes love these unnamed",
    "start": "2516400",
    "end": "2522599"
  },
  {
    "text": "parameters um then you can see what it gets translated to so inside here we've got a function called add um that gets",
    "start": "2522599",
    "end": "2530359"
  },
  {
    "text": "defined so this is our function in the main module that takes two parameters inside there's a couple of debug values",
    "start": "2530359",
    "end": "2537200"
  },
  {
    "text": "those are used for when you're using something like the xcode playgrounds where it's popping up values uh",
    "start": "2537200",
    "end": "2542400"
  },
  {
    "text": "generally they'll be optimized out for real code inside here and then we've got",
    "start": "2542400",
    "end": "2547480"
  },
  {
    "text": "a function reference to the Swift plus function so Swift plus is a perfectly valid name for a function to be uh so",
    "start": "2547480",
    "end": "2554520"
  },
  {
    "text": "that gets pulled out with the int types associated with it and then called down at the bottom to give us result number",
    "start": "2554520",
    "end": "2560240"
  },
  {
    "text": "five and then five is returned to the calling function and then if we look where we're calling that in our main",
    "start": "2560240",
    "end": "2567839"
  },
  {
    "text": "method here uh we're then calling the function with the two arguments to get the value",
    "start": "2567839",
    "end": "2573520"
  },
  {
    "text": "inside um you can then have a look and see what that looks like either in the generated IR or in the assembly the nice",
    "start": "2573520",
    "end": "2579000"
  },
  {
    "text": "thing is about the assembly you can actually see where this is being done um so inside the assembly here uh we've got",
    "start": "2579000",
    "end": "2584960"
  },
  {
    "text": "our call function we've got dollar one uh which is the first parameter uh which is the hex value of one which is our",
    "start": "2584960",
    "end": "2590720"
  },
  {
    "text": "first parameter that we're calling and then we've got another value inside uh the second number two uh which goes into",
    "start": "2590720",
    "end": "2597920"
  },
  {
    "text": "the value um and then we're calling main. add with those two values nice thing is that the call qy function is",
    "start": "2597920",
    "end": "2604079"
  },
  {
    "text": "something that can be statically optimized by the compiler and in fact if we turn on the optimization um then you",
    "start": "2604079",
    "end": "2609200"
  },
  {
    "text": "can see what happens is it figures out that um these two things are the same",
    "start": "2609200",
    "end": "2614599"
  },
  {
    "text": "and if I find where my where the function is going on here I've lost it",
    "start": "2614599",
    "end": "2621039"
  },
  {
    "text": "now uh then actually it's just translated this to the ad Q instruction down here so our main. add function is",
    "start": "2622319",
    "end": "2627920"
  },
  {
    "text": "these three or four lines where it's inlined all of the indirect calls to the function type and it's just using an add",
    "start": "2627920",
    "end": "2634520"
  },
  {
    "text": "Q which is about the fastest way you can add functions up inside there uh there's a jump to an overflow so if the",
    "start": "2634520",
    "end": "2640880"
  },
  {
    "text": "arithmetic operation overflows then you get notified for it as well um but the really nice thing is that if you turn on",
    "start": "2640880",
    "end": "2647000"
  },
  {
    "text": "a whole module optimization and we mark this thing as private in our",
    "start": "2647000",
    "end": "2653480"
  },
  {
    "text": "code and then have a look at the generated output then what happens is the compiler realizes that actually",
    "start": "2653480",
    "end": "2660319"
  },
  {
    "text": "there's no need to have an ad function at all inside here so it disappears uh from this list and U because we're not",
    "start": "2660319",
    "end": "2667200"
  },
  {
    "text": "doing anything with the function at all it's just going away so to actually capture the return result so it's not",
    "start": "2667200",
    "end": "2672800"
  },
  {
    "text": "optimized away if I import Darwin which is the underlying OS if you do",
    "start": "2672800",
    "end": "2677920"
  },
  {
    "text": "Foundation then you get Darwin in by default but then we can use exit as our function inside and if we turn module",
    "start": "2677920",
    "end": "2684480"
  },
  {
    "text": "optimization on and mark the function as private and uh I'm just going to change these to in32 because that's what the X",
    "start": "2684480",
    "end": "2691720"
  },
  {
    "text": "function needs and it's easier to do that than cast it properly um then what",
    "start": "2691720",
    "end": "2697920"
  },
  {
    "text": "you'll see inside here is that actually um the compiler just optimized it",
    "start": "2697920",
    "end": "2702960"
  },
  {
    "text": "directly realized that 1 plus 2 is three replac the three with the call inside there and then exits it away so the key",
    "start": "2702960",
    "end": "2709559"
  },
  {
    "text": "thing is that Swift brings all of these examples together and unlocks the power of optimization through enlightening and",
    "start": "2709559",
    "end": "2716960"
  },
  {
    "text": "you can do things like uh inside the source uh you can say um if I is less",
    "start": "2716960",
    "end": "2723800"
  },
  {
    "text": "than zero um then uh we can print something like",
    "start": "2723800",
    "end": "2729359"
  },
  {
    "text": "negative for example and without optimization on uh if we look at the",
    "start": "2729359",
    "end": "2734440"
  },
  {
    "text": "generated output inside here we're going to have a bunch of uh print statements that get pulled in um so the print the",
    "start": "2734440",
    "end": "2741839"
  },
  {
    "text": "print is inside there because dynamically at one time it might be called but if we Mark um the field as",
    "start": "2741839",
    "end": "2748280"
  },
  {
    "text": "private and we turned optimization on then actually we can optimize the print statement out completely because it just",
    "start": "2748280",
    "end": "2754119"
  },
  {
    "text": "doesn't play any part it knows that one is bigger than zero it knows two is bigger than zero and so inside our function references inside here we don't",
    "start": "2754119",
    "end": "2761319"
  },
  {
    "text": "have any references to the print function at all so Swift is all about the optimizations how far it can inline",
    "start": "2761319",
    "end": "2767240"
  },
  {
    "text": "things how far it can optimize code away that it doesn't need to worry about and then how it can translate that to",
    "start": "2767240",
    "end": "2772880"
  },
  {
    "text": "essentially less instructions operated by the CPU and less memory hits out from a performance perspective so if you want",
    "start": "2772880",
    "end": "2779920"
  },
  {
    "text": "to download that it's on GitHub Al blue sill inspector I'll put out a tweet afterwards so you can uh pick that up as",
    "start": "2779920",
    "end": "2785880"
  },
  {
    "text": "well if you want to um but the key point about Swift is that it's really a compatibility uh with Objective C it's a",
    "start": "2785880",
    "end": "2791920"
  },
  {
    "text": "way of moving from the old way to the new way um so for example if you create a swift object uh then it has an ISO",
    "start": "2791920",
    "end": "2798359"
  },
  {
    "text": "pointer so if you pass a swift object into an Objective C function um then Objective C can still call functions and",
    "start": "2798359",
    "end": "2804640"
  },
  {
    "text": "use the uh methods dynamically to look things up once like caution if you mark",
    "start": "2804640",
    "end": "2809880"
  },
  {
    "text": "your object as Objective C the compiler will have to put those functions inside the code it's got no way of knowing um",
    "start": "2809880",
    "end": "2816359"
  },
  {
    "text": "whether or not you're calling it because it's dynamic or not um so you can use Objective C you need to use Objective C",
    "start": "2816359",
    "end": "2822520"
  },
  {
    "text": "if you're hooking in with things like the Frameworks of UI kit or WK kit or something uh watch kit to be able to use",
    "start": "2822520",
    "end": "2829000"
  },
  {
    "text": "any of the classes in there but in the future we expect to see that uh Swift is going to take over from ective C so",
    "start": "2829000",
    "end": "2837280"
  },
  {
    "text": "where is Swift going yet hopefully open source uh watch this space we've got four weeks left from today to find out",
    "start": "2837280",
    "end": "2844200"
  },
  {
    "start": "2839000",
    "end": "2932000"
  },
  {
    "text": "if that will actually happen but is Swift fast C is not really the right question the question should be is Swift",
    "start": "2844200",
    "end": "2850880"
  },
  {
    "text": "fast or faster than Objective C and I think it is possible for Native Swift",
    "start": "2850880",
    "end": "2856319"
  },
  {
    "text": "applications to be faster than Objective C simply because of the optimizations that get unlocked when you go through",
    "start": "2856319",
    "end": "2861760"
  },
  {
    "text": "these things it can certainly be faster if you've got a lot of data processing inside there if you're just using Swift",
    "start": "2861760",
    "end": "2868000"
  },
  {
    "text": "to write Objective C classes without the angle bracket syntax then it's going to be the same speed as Objective C it's",
    "start": "2868000",
    "end": "2873760"
  },
  {
    "text": "certainly not really any slower than that but as we we see apple move towards more of a stable ABI for the Swift",
    "start": "2873760",
    "end": "2880599"
  },
  {
    "text": "language uh we'll see more optimizations coming up and ultimately uh more usage of Swift itself Swift is still",
    "start": "2880599",
    "end": "2888400"
  },
  {
    "text": "undergoing active development uh it's being heavily developed we've seen three releases or so in the last year and it",
    "start": "2888400",
    "end": "2894319"
  },
  {
    "text": "provides a transation mechanism from Objective C we're not actually seeing the death of objective c yet because all",
    "start": "2894319",
    "end": "2900520"
  },
  {
    "text": "of Apple's functions still use Objective C for doing uh their objects and their Frameworks in iOS code and we'll see",
    "start": "2900520",
    "end": "2907160"
  },
  {
    "text": "that happen for some time to come but I predict as soon as Apple open sources Swift we'll start to see Frameworks",
    "start": "2907160",
    "end": "2913520"
  },
  {
    "text": "being created we'll start to see an ecosystem grow of pure Swift code without The Objective C baggage and then",
    "start": "2913520",
    "end": "2919000"
  },
  {
    "text": "we'll find something that allows us to have native Swift applications I would say uh Swift is the future of iOS",
    "start": "2919000",
    "end": "2925079"
  },
  {
    "text": "development potentially also the future of server side development depending on how and when the open source happens so",
    "start": "2925079",
    "end": "2931720"
  },
  {
    "text": "in summary Swift has got a long history coming from llvm Roots uh it prefers stattic dispatch but it also supports",
    "start": "2931720",
    "end": "2938079"
  },
  {
    "start": "2932000",
    "end": "3043000"
  },
  {
    "text": "Objective C for being able to talk to existing code and applications the values can be laid out in memory very",
    "start": "2938079",
    "end": "2943799"
  },
  {
    "text": "efficiently which allows for efficient memory access as well as efficient processing the static dispatch allows",
    "start": "2943799",
    "end": "2950319"
  },
  {
    "text": "for inlining which then in turn leads to further optimizations reducing the amount of code that needs to be able to run and things like the whole module",
    "start": "2950319",
    "end": "2957040"
  },
  {
    "text": "optimization the ability to upload your applications as bit code to the IOS app store is only going to get better over",
    "start": "2957040",
    "end": "2963520"
  },
  {
    "text": "time and the modular pipeline that we've seen allows to optimize Iz ation to be inserted at different stages and so you",
    "start": "2963520",
    "end": "2969160"
  },
  {
    "text": "can expect those will improve over time as well so thank you very much please remember to await the session and if you",
    "start": "2969160",
    "end": "2975440"
  },
  {
    "text": "have any questions I'd be happy to take them now so there was one question sorry",
    "start": "2975440",
    "end": "2981280"
  },
  {
    "text": "there was one question through the app that asks what is the difference between virtual methods in C++ and static",
    "start": "2981280",
    "end": "2988400"
  },
  {
    "text": "methods or dynamic methods in Swift so the question was what's the difference between static methods uh in uh C++ and",
    "start": "2988400",
    "end": "2996200"
  },
  {
    "text": "dynamic methods in Swift well Swift has the ability essentially to call either of them so if you have a native Swift",
    "start": "2996200",
    "end": "3002000"
  },
  {
    "text": "class then it uses the similar sort of static dispatch calls as C++ if you use",
    "start": "3002000",
    "end": "3007400"
  },
  {
    "text": "Swift to hook into an an NS object with Dynamic message protocols then it's using the dynamic message so Swift can",
    "start": "3007400",
    "end": "3013760"
  },
  {
    "text": "actually use either of them but from a source level they look exactly the same and I think this is going to be a great way of training iOS and objective seed",
    "start": "3013760",
    "end": "3021040"
  },
  {
    "text": "developers to be able to move towards a C++ kind of light model maybe C++ got it vit all along",
    "start": "3021040",
    "end": "3028359"
  },
  {
    "text": "any other questions in the audience no well in that case thank you",
    "start": "3028359",
    "end": "3033400"
  },
  {
    "text": "very much and enjoy lunch",
    "start": "3033400",
    "end": "3037200"
  }
]