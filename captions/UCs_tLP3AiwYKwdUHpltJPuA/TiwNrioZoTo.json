[
  {
    "text": "[Music]",
    "start": "5870",
    "end": "10049"
  },
  {
    "text": "well this talk is about domain modeling from functional to reactive before I start just a quick",
    "start": "11880",
    "end": "19520"
  },
  {
    "text": "show of hands of uh how many of you have been uh familiar with or have implemented domain models using uh some",
    "start": "19520",
    "end": "27199"
  },
  {
    "text": "of the principles like domain driven design or similar things quite a few and",
    "start": "27199",
    "end": "32960"
  },
  {
    "text": "how many of you have used objectoriented techniques in implementing those domain models functional techniques purely",
    "start": "32960",
    "end": "39719"
  },
  {
    "text": "functional techniques a lot less okay so before I",
    "start": "39719",
    "end": "45440"
  },
  {
    "text": "start here's an important thing uh an obligatory",
    "start": "45440",
    "end": "50480"
  },
  {
    "text": "announcement use the go to mobile app to rate the session that also is an",
    "start": "50480",
    "end": "55960"
  },
  {
    "text": "important feedback to us the speakers about what we did well and what we did did",
    "start": "55960",
    "end": "61239"
  },
  {
    "text": "not so domain modeling in this talk I'll be taking a",
    "start": "61239",
    "end": "66479"
  },
  {
    "text": "somewhat orthogonal approach of objectoriented modeling and we will talk about functional domain",
    "start": "66479",
    "end": "73360"
  },
  {
    "text": "modeling and try to make the model responsive elastic resilient or if we",
    "start": "73799",
    "end": "80280"
  },
  {
    "text": "combine all of them together we call that reactive what I will do is I will start",
    "start": "80280",
    "end": "86479"
  },
  {
    "text": "with a basic skeleton of a functional model and I will try to implement reactive principles on top of it making",
    "start": "86479",
    "end": "92560"
  },
  {
    "text": "the apis reactive mostly using algebraic techniques but before",
    "start": "92560",
    "end": "99880"
  },
  {
    "text": "that how do we Define a domain model I actually like this definition a lot it's from",
    "start": "99880",
    "end": "105399"
  },
  {
    "text": "Wikipedia and um I like this definition a lot since it highlights the defining",
    "start": "105399",
    "end": "110600"
  },
  {
    "text": "aspect of what a domain model is that it's related to the problem domain",
    "start": "110600",
    "end": "115920"
  },
  {
    "text": "that's the defining part of a domain model it's related to the problem domain and how the artifacts interact there to",
    "start": "115920",
    "end": "123320"
  },
  {
    "text": "produce the correct domain behaviors so when we say that we are implementing a domain model what we are doing is we are",
    "start": "123320",
    "end": "129920"
  },
  {
    "text": "trying to replicate the behaviors of the problem domain into the solution space",
    "start": "129920",
    "end": "134959"
  },
  {
    "text": "using some specific Technologies we",
    "start": "134959",
    "end": "141519"
  },
  {
    "text": "will take a look at domain modeling through the functional lens we'll start with a basic functional model pure",
    "start": "141519",
    "end": "148360"
  },
  {
    "text": "functions immutable data and the algebra of types in this talk",
    "start": "148360",
    "end": "153800"
  },
  {
    "text": "algebra will play a very important role because algebra gives us the power to reason about our code and that's one of",
    "start": "153800",
    "end": "161159"
  },
  {
    "text": "the most important characteristics of a successful domain model implementation a domain model has many constraints the",
    "start": "161159",
    "end": "167200"
  },
  {
    "text": "business rules and using algebra we can ensure that those rules are validated or",
    "start": "167200",
    "end": "175040"
  },
  {
    "text": "verified and then we will enrich our algebra to add some interesting effects",
    "start": "175040",
    "end": "181840"
  },
  {
    "text": "by effects what we mean is some of the interesting things that traditionally",
    "start": "182280",
    "end": "187879"
  },
  {
    "text": "can be handled one example is exceptions traditionally we use TR catch handlers to handle exceptions we will use effects",
    "start": "187879",
    "end": "195560"
  },
  {
    "text": "to address failures here because effect is an algebraic way of handling",
    "start": "195560",
    "end": "201720"
  },
  {
    "text": "failures and then we will see how to compose effectful functions to implement richer domain behaviors so ultimately",
    "start": "201720",
    "end": "209319"
  },
  {
    "text": "what our domain model a specific module or a specific function delivers will be",
    "start": "209319",
    "end": "214439"
  },
  {
    "text": "a cascading of effects and we will make that reactive",
    "start": "214439",
    "end": "219879"
  },
  {
    "text": "too by implementing reactive principles as yet another",
    "start": "219879",
    "end": "225799"
  },
  {
    "text": "effect in the as part of the",
    "start": "225799",
    "end": "230080"
  },
  {
    "text": "API so this is the primary agenda for today we will formalize a domain model",
    "start": "234280",
    "end": "240519"
  },
  {
    "text": "definition from the algebraic point of view and this will lead us to The Domain model",
    "start": "240519",
    "end": "246239"
  },
  {
    "text": "algebra which is a concept which is The Binding contract that makes our model consistent and easier to reason",
    "start": "246239",
    "end": "254079"
  },
  {
    "text": "about we will start with a functional model and see how we can make API reactive using algebraic techniques but",
    "start": "254079",
    "end": "260799"
  },
  {
    "text": "as we will see that a an any complex domain model is not really one model",
    "start": "260799",
    "end": "266600"
  },
  {
    "text": "it's actually a collection of models and as algebraic unification breaks across",
    "start": "266600",
    "end": "271759"
  },
  {
    "text": "these boundaries we call them the bounded context so when we talk about Beyond algebra we will talk about",
    "start": "271759",
    "end": "278960"
  },
  {
    "text": "bounded contexts and how algebraic definitions fail to unify across",
    "start": "278960",
    "end": "284080"
  },
  {
    "text": "algebraic boundaries for that we will we will discuss how to design reactive",
    "start": "284080",
    "end": "289680"
  },
  {
    "text": "protocols that unify across bounded context then we will take a look at",
    "start": "289680",
    "end": "294919"
  },
  {
    "text": "actors and domain models and how we can use actors to the benefit of our domain model and finally",
    "start": "294919",
    "end": "302520"
  },
  {
    "text": "we will conclude the talk with a discussion on reactive streams which is a typesafe and compositional way to",
    "start": "302520",
    "end": "309080"
  },
  {
    "text": "implement workflows stream based workflows in a domain",
    "start": "309080",
    "end": "314479"
  },
  {
    "text": "model quite a few years back Marias Ericson of Twitter wrote this paper your",
    "start": "316160",
    "end": "321600"
  },
  {
    "text": "server as a function and what he highlighted in this paper is that it distilled he identified",
    "start": "321600",
    "end": "329400"
  },
  {
    "text": "three basic abstractions that happen to align beautifully with the style of functional programming and these three",
    "start": "329400",
    "end": "336120"
  },
  {
    "text": "abstractions were the distilling parts of all the servers that Twitter",
    "start": "336120",
    "end": "341479"
  },
  {
    "text": "implemented these these three features are Futures services and filters which",
    "start": "341479",
    "end": "347319"
  },
  {
    "text": "not only compose algebraically but also gave them the proper substrate for building reactive servers and if we",
    "start": "347319",
    "end": "355160"
  },
  {
    "text": "think of domain models a domain model is responsible for delivering a bunch of services",
    "start": "355160",
    "end": "360240"
  },
  {
    "text": "so can we really think of our domain model as a function well it may not be that simple or a collection of",
    "start": "360240",
    "end": "368160"
  },
  {
    "text": "functions some trivial models are but as I was telling that a complete domain",
    "start": "368160",
    "end": "374080"
  },
  {
    "text": "model is actually much much complex than that this is how we represent a",
    "start": "374080",
    "end": "379440"
  },
  {
    "text": "non-trivial domain model architecture models within the main model each with",
    "start": "379440",
    "end": "384520"
  },
  {
    "text": "its own vocabulary and set of artifacts here we have a bunch of bounded context",
    "start": "384520",
    "end": "389960"
  },
  {
    "text": "bounded you can think of bounded context as as possibly independent applications but they are not they are not Islands",
    "start": "389960",
    "end": "396680"
  },
  {
    "text": "they need to collaborate with each other as well and as I was telling you algebras don't unify them the algebra",
    "start": "396680",
    "end": "403520"
  },
  {
    "text": "can be defined within a bounded context the algebra that we Define is valid within the bounded context with respect",
    "start": "403520",
    "end": "410759"
  },
  {
    "text": "to the specific vocabulary which that bounded context has with respect to the entities the value objects and ser",
    "start": "410759",
    "end": "417759"
  },
  {
    "text": "services for example two bounded contexts can have the same entity same name same named entity but with entirely",
    "start": "417759",
    "end": "425639"
  },
  {
    "text": "different purpose suppose we are talking of a banking system a banking system can have an entity named account while we",
    "start": "425639",
    "end": "432960"
  },
  {
    "text": "have we we may have a separate bounded context which does authentication it can",
    "start": "432960",
    "end": "438599"
  },
  {
    "text": "also have an entity called account both are parts of the ubiquitous language or both are parts of the vocabulary of that",
    "start": "438599",
    "end": "445400"
  },
  {
    "text": "specific bounded context but the account in banking context is completely",
    "start": "445400",
    "end": "450560"
  },
  {
    "text": "different from account in the other context across bounded context algebra's",
    "start": "450560",
    "end": "457759"
  },
  {
    "text": "break and we need to define a more Loosely defined protocol we will discuss this when we talk about algebraic",
    "start": "457759",
    "end": "466520"
  },
  {
    "text": "boundaries as I said a bounded context has a consistent vocabulary a set of domain behaviors modeled as functions",
    "start": "467120",
    "end": "474759"
  },
  {
    "text": "and domain objects implemented as types the vocabulary is only valid within that specific bounded cont context so",
    "start": "474759",
    "end": "480960"
  },
  {
    "text": "whenever we talk talk of any specific type or any specific entity or algebra we are talking it with respect to a",
    "start": "480960",
    "end": "487479"
  },
  {
    "text": "specific bounded context so keeping the earlier earlier",
    "start": "487479",
    "end": "493120"
  },
  {
    "text": "picture in mind we can say that a domain model is a union of bounded",
    "start": "493120",
    "end": "499919"
  },
  {
    "text": "contexts and we can define a bounded context as a collection of",
    "start": "499919",
    "end": "505440"
  },
  {
    "text": "functions subject to a set of predicates which we call the domain",
    "start": "505440",
    "end": "511879"
  },
  {
    "text": "rules so FX is a domain function on an object of Type X in this talk we will be",
    "start": "515479",
    "end": "522120"
  },
  {
    "text": "talking about domain modeling with respect to a statically typed programming language and I will mostly be using Scala for this so FX is a",
    "start": "522120",
    "end": "529399"
  },
  {
    "text": "domain function on an object of Type X that composes with other functions and",
    "start": "529399",
    "end": "534760"
  },
  {
    "text": "closed under composition what it means is that when I compose two functions two domain behaviors it gives me a bigger",
    "start": "534760",
    "end": "541480"
  },
  {
    "text": "domain Behavior that's also part of this set and all these functions will be",
    "start": "541480",
    "end": "547120"
  },
  {
    "text": "applicable all these types will be validated against a set of business",
    "start": "547120",
    "end": "552320"
  },
  {
    "text": "rules so summarizing what we have is we have a collection of functions or",
    "start": "552320",
    "end": "557360"
  },
  {
    "text": "morphisms as we say as we say in theory we have types as sets composition and a",
    "start": "557360",
    "end": "566320"
  },
  {
    "text": "set of rules and laws and this forms our",
    "start": "566320",
    "end": "571360"
  },
  {
    "text": "algebra we have a domain model algebra which is the algebra of types functions",
    "start": "571800",
    "end": "577560"
  },
  {
    "text": "and laws and one objective of implementing a",
    "start": "577560",
    "end": "583360"
  },
  {
    "text": "domain model one of the things that we would like to do is to make this algebra",
    "start": "583360",
    "end": "588800"
  },
  {
    "text": "explicit making the algebra explicit will give us a lot of mileage when we",
    "start": "588800",
    "end": "594320"
  },
  {
    "text": "are using when we have a decent type system at our disposal most part of the algebra will be verified by the type",
    "start": "594320",
    "end": "600680"
  },
  {
    "text": "system the compiler will be your friend you don't need to write tests for validating those those specific set of",
    "start": "600680",
    "end": "606839"
  },
  {
    "text": "constraints or invariants and we want and we would like",
    "start": "606839",
    "end": "612800"
  },
  {
    "text": "to have the algebra verifiable verifiable once again through type constraints if we have a dependent type",
    "start": "612800",
    "end": "619399"
  },
  {
    "text": "programming language then we can have more constraints verified as part of the compilation time and for those",
    "start": "619399",
    "end": "625680"
  },
  {
    "text": "properties for which we cannot have compile time verification we will have algebraic property based",
    "start": "625680",
    "end": "631880"
  },
  {
    "text": "testing so making the algebra explicit and verifiable is what we should try to",
    "start": "631880",
    "end": "637839"
  },
  {
    "text": "achieve when we think of a robust domain model design so summarizing once again we have",
    "start": "637839",
    "end": "644079"
  },
  {
    "text": "a set of domain behaviors we have a set of domain types we have a set of domain",
    "start": "644079",
    "end": "649600"
  },
  {
    "text": "rules and we will see this that we will we can express some part of our domain algebra in terms of already existing",
    "start": "649600",
    "end": "656399"
  },
  {
    "text": "verified algebraic structures like monoids and monads and there are a lot",
    "start": "656399",
    "end": "661519"
  },
  {
    "text": "of others and all of these form part of our domain",
    "start": "661519",
    "end": "666680"
  },
  {
    "text": "algebra so now we refine our definition we can say that the domain model is now a union of a collection of",
    "start": "667160",
    "end": "674720"
  },
  {
    "text": "domain algebras and the rest of the definition stay the same we Define a domain algebra",
    "start": "674720",
    "end": "681320"
  },
  {
    "text": "in terms of functions types and algebraic composition our algebra is valid within",
    "start": "681320",
    "end": "687920"
  },
  {
    "text": "the bounded context algebra is The Binding contract we will make that reactive we'll see how to make the",
    "start": "687920",
    "end": "694120"
  },
  {
    "text": "algebra reactive or rather we will try to try to uh make react we'll try to",
    "start": "694120",
    "end": "700480"
  },
  {
    "text": "make our effects reactive by expressing it in terms of existing",
    "start": "700480",
    "end": "706560"
  },
  {
    "text": "algebra and when we have multiple bounded contexts each with its own Al algebra we need something different to",
    "start": "707279",
    "end": "713399"
  },
  {
    "text": "unify them because algebras don't unify across bounded contexts they are de",
    "start": "713399",
    "end": "719240"
  },
  {
    "text": "coupled in space and time as Jonas was mentioning they have separate vocabulary every bounded context has a separate",
    "start": "719240",
    "end": "725440"
  },
  {
    "text": "vocabulary So typee based unification breaks down we need to have protocols defined",
    "start": "725440",
    "end": "733279"
  },
  {
    "text": "so as to establish collaboration between the bounded contexts and these collaboration and",
    "start": "733279",
    "end": "739920"
  },
  {
    "text": "these protocols need to be reactive so this brings us to",
    "start": "739920",
    "end": "745680"
  },
  {
    "text": "this reactive Manifesto which underlies uh some of the core",
    "start": "745680",
    "end": "752440"
  },
  {
    "text": "principles of what we mean by a reactive system being",
    "start": "752440",
    "end": "758720"
  },
  {
    "text": "responsive is the ultimate goal as as uh indicated by that Circle and unbounded",
    "start": "758720",
    "end": "764079"
  },
  {
    "text": "latency will kill your user experience and three ways to achieve this goal are the three boxes indicated there and we",
    "start": "764079",
    "end": "770920"
  },
  {
    "text": "will discuss each of them separately as part of this talk",
    "start": "770920",
    "end": "776000"
  },
  {
    "text": "now let's try uh let's start with a code fragment which",
    "start": "784959",
    "end": "793040"
  },
  {
    "text": "um defines some of the basic operations that we can do on a bank",
    "start": "793040",
    "end": "798399"
  },
  {
    "text": "account I'm using Scala as I mentioned these are the related related",
    "start": "798399",
    "end": "804480"
  },
  {
    "text": "operations on a bank account that can be done and we encapsulate all of them within a module",
    "start": "804480",
    "end": "810480"
  },
  {
    "text": "we make the module parameterized on types this is one other important thing which we can use if we have a static",
    "start": "810480",
    "end": "816560"
  },
  {
    "text": "static type system at our disposal we can design parametric",
    "start": "816560",
    "end": "821839"
  },
  {
    "text": "abstractions and this is possibly the most important part in this Slide the return type note",
    "start": "821839",
    "end": "829399"
  },
  {
    "text": "the algebra of the return type it's a disjunction I'm using the disjunction oper operation from Scala",
    "start": "829399",
    "end": "837160"
  },
  {
    "text": "Zed and what it does does is it encapsulates failure as part of the",
    "start": "837160",
    "end": "844360"
  },
  {
    "text": "algebra so we are not relying on any TR catch Tri catch block we are not relying",
    "start": "844360",
    "end": "849639"
  },
  {
    "text": "on throwing of exceptions from within our code we are trying to incorporate that as part of the algebra",
    "start": "849639",
    "end": "857720"
  },
  {
    "text": "itself so once again this this shows that our algebra is explicit we are explicit explicitly coding the failure",
    "start": "858920",
    "end": "868279"
  },
  {
    "text": "handling as part of the algebra these are the operations which",
    "start": "868279",
    "end": "873839"
  },
  {
    "text": "are terms derived from the domain vocabulary domain behaviors and the entire set consists",
    "start": "873839",
    "end": "881040"
  },
  {
    "text": "our explicit and verifiable algebra it's parametric statically typed",
    "start": "881040",
    "end": "888519"
  },
  {
    "text": "modular and hence unit testable and composable in what sense it's composable",
    "start": "888519",
    "end": "894680"
  },
  {
    "text": "the algebra of the return type ensures that we can compose multiple oper ations",
    "start": "894680",
    "end": "899839"
  },
  {
    "text": "into bigger domain behaviors the algebra that we had here for for the return",
    "start": "899839",
    "end": "906639"
  },
  {
    "text": "type that's actually a",
    "start": "906639",
    "end": "910399"
  },
  {
    "text": "monad hence we can compose them compose smaller operations together to form",
    "start": "913079",
    "end": "919320"
  },
  {
    "text": "larger operations and modules in Scala can also",
    "start": "919320",
    "end": "925399"
  },
  {
    "text": "be composed so we can we can comp we can form larger modules modules by composing",
    "start": "925399",
    "end": "930800"
  },
  {
    "text": "smaller modules within our",
    "start": "930800",
    "end": "934519"
  },
  {
    "text": "system this is in fact a great way to evolve your domain model from smaller abstractions build upwards using",
    "start": "940639",
    "end": "947920"
  },
  {
    "text": "algebraic techniques but typically any operation on a domain model needs some database",
    "start": "947920",
    "end": "955959"
  },
  {
    "text": "access so we need to have a repository we need to use a repository from where",
    "start": "955959",
    "end": "962160"
  },
  {
    "text": "to fetch data in order to perform any operations on the account opening or closing or anything like that for any",
    "start": "962160",
    "end": "969319"
  },
  {
    "text": "typical domain operation any non-trivial domain model does that and so we change the algebra",
    "start": "969319",
    "end": "975680"
  },
  {
    "text": "of the return type to reflect that property that we need to the return type",
    "start": "975680",
    "end": "982279"
  },
  {
    "text": "explicitly says that we need an account repository from where to fetch data and that will result in the",
    "start": "982279",
    "end": "989839"
  },
  {
    "text": "result",
    "start": "989839",
    "end": "992319"
  },
  {
    "text": "type so an explicit change in the algebra",
    "start": "995880",
    "end": "1002279"
  },
  {
    "text": "sorry now it so happens that the type that we discussed here account repository to account op",
    "start": "1004040",
    "end": "1012240"
  },
  {
    "text": "account this has a name this type is isomorphic to what we what we call a cly",
    "start": "1012240",
    "end": "1018399"
  },
  {
    "text": "operator a cly is an abstraction cly is an algebra which gives us the ability to",
    "start": "1018399",
    "end": "1025720"
  },
  {
    "text": "compose effectful functions and this is an effectful function account repository",
    "start": "1025720",
    "end": "1031280"
  },
  {
    "text": "to account op account op is there it's actually a disjunction so that's an",
    "start": "1031280",
    "end": "1036438"
  },
  {
    "text": "that's what that's what we mean by an effect and this is here the return type is an effectful",
    "start": "1036439",
    "end": "1043160"
  },
  {
    "text": "function and we enrich our algebra by encoding the return type as a",
    "start": "1043160",
    "end": "1050039"
  },
  {
    "text": "cly so we have more algebra more functionality more succinct the",
    "start": "1050039",
    "end": "1055280"
  },
  {
    "text": "advantage is that once we once we encode that as a kly we have all the",
    "start": "1055280",
    "end": "1061080"
  },
  {
    "text": "combinators that kly offers kly is an explicitly verified algebra clly has an abstra cly is an abstraction and is",
    "start": "1061080",
    "end": "1068720"
  },
  {
    "text": "available as part of some libraries so once once you can reuse that algebra you",
    "start": "1068720",
    "end": "1074160"
  },
  {
    "text": "get the you get the laws you get the constraints you get the combinators for free",
    "start": "1074160",
    "end": "1079400"
  },
  {
    "text": "so we enrich our algebra here by using the",
    "start": "1079400",
    "end": "1084159"
  },
  {
    "text": "cly so what it does is it enriches our algebra and helps us express our domain",
    "start": "1090480",
    "end": "1096320"
  },
  {
    "text": "algebra in terms of an existing and verifiable algebra of a cly",
    "start": "1096320",
    "end": "1102039"
  },
  {
    "text": "Arrow but now that you have a database in place your system is now more Enterprise and you need to ensure that",
    "start": "1102840",
    "end": "1110200"
  },
  {
    "text": "the performance and response that your system delivers remain optimal even in the face of",
    "start": "1110200",
    "end": "1116480"
  },
  {
    "text": "unpredictably large load you can't you can't have the user waiting at the waiting at the user",
    "start": "1116480",
    "end": "1123280"
  },
  {
    "text": "interface because because your system has gone to some other continent data center to fet some data from a database",
    "start": "1123280",
    "end": "1130080"
  },
  {
    "text": "you need to bound that latency maybe based on service level agreement or whatever unbounded",
    "start": "1130080",
    "end": "1136400"
  },
  {
    "text": "unbounded latency is a killer so you need to bound that",
    "start": "1136400",
    "end": "1141480"
  },
  {
    "text": "latency and the way to do that is you cannot publish apis that does blocking",
    "start": "1141480",
    "end": "1148080"
  },
  {
    "text": "calls blocking calls will lead to unbounded latency as Jonas was also mentioning in his",
    "start": "1148080",
    "end": "1154559"
  },
  {
    "text": "talk blocking kills so we need to make our apis",
    "start": "1154559",
    "end": "1160120"
  },
  {
    "text": "elastic enough so that the perceived response to the user is not affected by the current load on the system the user",
    "start": "1160120",
    "end": "1167240"
  },
  {
    "text": "cannot wait indefinitely irrespective of how much load you have the user experience should not suffer that's one",
    "start": "1167240",
    "end": "1174760"
  },
  {
    "text": "of the core principles of being reactive so now we are looking at this",
    "start": "1174760",
    "end": "1180840"
  },
  {
    "text": "path of the graph this path of the reactive graph but we would like to do this without",
    "start": "1180840",
    "end": "1189159"
  },
  {
    "text": "foregoing the benefits of algebraic reasoning with types we would like to",
    "start": "1189159",
    "end": "1194880"
  },
  {
    "text": "incorporate this reactive Principle as part of the type system note we have a have a powerful type system why not use",
    "start": "1194880",
    "end": "1201520"
  },
  {
    "text": "it if we if we can have it so we would like to model this elasticity as much as possible using the",
    "start": "1201520",
    "end": "1208520"
  },
  {
    "text": "type system so that we can reason about the effect in a more sound and algebraic",
    "start": "1208520",
    "end": "1213640"
  },
  {
    "text": "fashion note what what we are trying to achieve is we are trying to achieve the effect of elasticity as yet",
    "start": "1213640",
    "end": "1220679"
  },
  {
    "text": "another effect Futures Futures is the way to get",
    "start": "1220679",
    "end": "1228000"
  },
  {
    "text": "there a future is the essence of asynchronous non-blocking",
    "start": "1228000",
    "end": "1233240"
  },
  {
    "text": "computation Futures compose they have an",
    "start": "1233240",
    "end": "1238679"
  },
  {
    "text": "algebra and they give us a great substrate to organize concurrent code in a compositional way without blocking the",
    "start": "1238679",
    "end": "1245600"
  },
  {
    "text": "main thread of execution so Futures give",
    "start": "1245600",
    "end": "1251760"
  },
  {
    "text": "us the way to make our apis reactive without forgoing the forgoing the",
    "start": "1251760",
    "end": "1258640"
  },
  {
    "text": "benefits of algebraic composition so in our use case we would like to augment our domain algebra the",
    "start": "1258640",
    "end": "1265039"
  },
  {
    "text": "algebra which we left behind we would like to augment it algebraically so that",
    "start": "1265039",
    "end": "1270279"
  },
  {
    "text": "the API becomes reactive and we will use future for that all already you have",
    "start": "1270279",
    "end": "1275520"
  },
  {
    "text": "seen a couple of effects the effect of an either or disjunction we had that as part of the algebra of the return type",
    "start": "1275520",
    "end": "1282039"
  },
  {
    "text": "of the API kly we encoded the return",
    "start": "1282039",
    "end": "1287240"
  },
  {
    "text": "type using cly in order to inject the database from outside account repository so we would like to have",
    "start": "1287240",
    "end": "1294440"
  },
  {
    "text": "asynchrony as yet another stackable effect within our computation something",
    "start": "1294440",
    "end": "1302440"
  },
  {
    "text": "like this we have the core value we have disjunction as an effect we have kly as",
    "start": "1302440",
    "end": "1309279"
  },
  {
    "text": "yet another effect and on top of that we would like to have future stacked as yet another effect",
    "start": "1309279",
    "end": "1317039"
  },
  {
    "text": "which will give us the way to make our apis",
    "start": "1317039",
    "end": "1324840"
  },
  {
    "text": "elastic and the general Technique we will use here for this stacking is by",
    "start": "1324840",
    "end": "1332120"
  },
  {
    "text": "using the concept of Mona Transformers note we we told that either is a either is a monad cly also gives us composition",
    "start": "1332120",
    "end": "1340159"
  },
  {
    "text": "of our monatic functions so we would like to use the technique of monite Transformers to",
    "start": "1340159",
    "end": "1347000"
  },
  {
    "text": "incorporate reactive apis using algebraic techniques how many of you are familiar with the concept of monad",
    "start": "1347000",
    "end": "1354600"
  },
  {
    "text": "Transformers okay it's not essential to know U details about monad Transformers",
    "start": "1354600",
    "end": "1360799"
  },
  {
    "text": "the only the only thing is that here in this example this is an example uh which does not use monad Transformer here we",
    "start": "1360799",
    "end": "1368279"
  },
  {
    "text": "are using two monads the disjunction monad and the option monad and note that if we need to get get to the value a we",
    "start": "1368279",
    "end": "1376480"
  },
  {
    "text": "need to do two levels of peeling two levels of for comprehension we need to do in order to reach the ultimate value",
    "start": "1376480",
    "end": "1383520"
  },
  {
    "text": "to which we would like to have access to obviously this doesn't scale if we",
    "start": "1383520",
    "end": "1388960"
  },
  {
    "text": "have lots of other monads then there will be lots of for comprehensions there will be lots of lots of peeling needs to",
    "start": "1388960",
    "end": "1394679"
  },
  {
    "text": "be done obviously the code will not scale on the other hand if we use a Monet Transformer like option T it",
    "start": "1394679",
    "end": "1401120"
  },
  {
    "text": "actually what it does is it collapses the entire stack of monads into a single monad so that you can use one of peeling",
    "start": "1401120",
    "end": "1409440"
  },
  {
    "text": "to get directly into the value so here once again note that we",
    "start": "1409440",
    "end": "1414919"
  },
  {
    "text": "are enriching the algebra of the type response by using a monad Transformer",
    "start": "1414919",
    "end": "1422039"
  },
  {
    "text": "and richer algebra leads to sorry richer algebra leads to less amount of client",
    "start": "1422039",
    "end": "1427919"
  },
  {
    "text": "code so Monet Transformer is yet another",
    "start": "1427919",
    "end": "1433000"
  },
  {
    "text": "instance where powerful abstractions can lead to more succin code base at the client level",
    "start": "1433000",
    "end": "1440440"
  },
  {
    "text": "so this is what Monet Transformer does and this is our this is our reactive API",
    "start": "1442720",
    "end": "1450080"
  },
  {
    "text": "reactive open what it does is not at the top the return type either T future it",
    "start": "1450080",
    "end": "1456559"
  },
  {
    "text": "actually Stacks future on top of the either data type so that the return type",
    "start": "1456559",
    "end": "1462200"
  },
  {
    "text": "is now a future it's not a it's not an either anymore so I is the vehicle to get there",
    "start": "1462200",
    "end": "1470600"
  },
  {
    "text": "I actually allows us to stack a series of monads in order to get the required",
    "start": "1470600",
    "end": "1478159"
  },
  {
    "text": "elastic behavior that we have been looking for this is either future the type that",
    "start": "1478159",
    "end": "1486159"
  },
  {
    "text": "I was talking about and this is a breakdown previously",
    "start": "1486159",
    "end": "1491200"
  },
  {
    "text": "we had a single monad the disjunction and now we have stacked it up with",
    "start": "1491200",
    "end": "1497039"
  },
  {
    "text": "future using a monad Transformer to make our algebra",
    "start": "1497039",
    "end": "1502279"
  },
  {
    "text": "richer and this is what I call reactive algebraically so we have been able to",
    "start": "1502279",
    "end": "1509720"
  },
  {
    "text": "achieve elasticity in our apis without foregoing the benefits of algebraic",
    "start": "1509720",
    "end": "1517880"
  },
  {
    "text": "composition in fact the implementation also doesn't change much you only need",
    "start": "1518640",
    "end": "1524039"
  },
  {
    "text": "to add these monad Transformer at the top and the normal logic remains as it",
    "start": "1524039",
    "end": "1531679"
  },
  {
    "text": "was so what we have achieved here is we have introduced the whole new effect of",
    "start": "1533120",
    "end": "1538960"
  },
  {
    "text": "asynchrony to implement reactive traits in our domain model API so that the user",
    "start": "1538960",
    "end": "1544559"
  },
  {
    "text": "is not blocked instead of returning the result of the computation it now it now",
    "start": "1544559",
    "end": "1549880"
  },
  {
    "text": "returns a future so that the main thread of execution is not blocked and this is one example of how we can use how we can",
    "start": "1549880",
    "end": "1557799"
  },
  {
    "text": "how we can gain from the benefits of having a static type system at our disposal future has an algebra so the",
    "start": "1557799",
    "end": "1564240"
  },
  {
    "text": "entire entire structure entire return type can be verified",
    "start": "1564240",
    "end": "1569399"
  },
  {
    "text": "algebraically we are still in the statically typed land with asynchronous behaviors baked into our apis we can",
    "start": "1569399",
    "end": "1575720"
  },
  {
    "text": "reason about our program statically we can compose asynchronous components to form larger",
    "start": "1575720",
    "end": "1582960"
  },
  {
    "text": "abstractions and the composition part Remains the Same previously also we were able to compose like this now also we",
    "start": "1582960",
    "end": "1590240"
  },
  {
    "text": "can compose our smaller operations to perform larger ones despite the fact",
    "start": "1590240",
    "end": "1596679"
  },
  {
    "text": "that we have enriched our algebra so enriching the algebra in a",
    "start": "1596679",
    "end": "1603840"
  },
  {
    "text": "type conformant way does not hamper composition because the algebra's Align",
    "start": "1603840",
    "end": "1613120"
  },
  {
    "text": "here compositional by types in individual operation sequential",
    "start": "1613399",
    "end": "1619799"
  },
  {
    "text": "because it doesn't make sense to make each of them parallel right open credit debit each of them going parallel",
    "start": "1619799",
    "end": "1625760"
  },
  {
    "text": "doesn't make sense so the individual operations are sequential but what we gain is the composed operation returns a",
    "start": "1625760",
    "end": "1632640"
  },
  {
    "text": "future and hence it doesn't block the main thread of execution this is an interesting pattern",
    "start": "1632640",
    "end": "1639960"
  },
  {
    "text": "in domain modeling where despite the fact that all the operations are all the",
    "start": "1639960",
    "end": "1645720"
  },
  {
    "text": "operations return future they have to be executed sequentially but still the main thread of operation doesn't get",
    "start": "1645720",
    "end": "1653039"
  },
  {
    "text": "blocked we can have the other pattern as well where we can have individual",
    "start": "1653039",
    "end": "1658440"
  },
  {
    "text": "operations executed in parallel for example you are trying to compute the customer Port portfolio for in order to",
    "start": "1658440",
    "end": "1666480"
  },
  {
    "text": "compute a customer portfolio you need to get his portfolio for currency for the",
    "start": "1666480",
    "end": "1671919"
  },
  {
    "text": "equity for fixed income for all the types of instruments that he has but all of them can be fetched parallell so here",
    "start": "1671919",
    "end": "1678799"
  },
  {
    "text": "it's a scatter gather kind of a design pattern you scatter all the com",
    "start": "1678799",
    "end": "1684200"
  },
  {
    "text": "computations in separate Futures as separate Futures and gather them when they when they",
    "start": "1684200",
    "end": "1691398"
  },
  {
    "text": "arrive something like this so here I can I can start all of the operations in",
    "start": "1691480",
    "end": "1698720"
  },
  {
    "text": "parallel and then finally compose them together here the difference with the previous use case is that in the",
    "start": "1698720",
    "end": "1704279"
  },
  {
    "text": "previous use case all the operations were strictly sequential here all the individual operations can be done",
    "start": "1704279",
    "end": "1711399"
  },
  {
    "text": "parallell so this is one other",
    "start": "1711399",
    "end": "1716399"
  },
  {
    "text": "pattern so the general motto is be algebraic as long as you can if there is",
    "start": "1716760",
    "end": "1722080"
  },
  {
    "text": "one thing that you would like to take back from this stock it's the importance of algebraic com composition because",
    "start": "1722080",
    "end": "1728240"
  },
  {
    "text": "algebraic verification is the Cornerstone of verifying the invariance of your domain",
    "start": "1728240",
    "end": "1733960"
  },
  {
    "text": "model but everything cannot be done through albra we need to have as I was",
    "start": "1733960",
    "end": "1741600"
  },
  {
    "text": "saying communication across bounded contexts and for that we we need to have reactive",
    "start": "1741600",
    "end": "1749159"
  },
  {
    "text": "protocols and we will be using asynchronous messaging for this message driven lose coupling isolation async",
    "start": "1749760",
    "end": "1757640"
  },
  {
    "text": "message passing we are now in this this part of the graph where we will",
    "start": "1757640",
    "end": "1762960"
  },
  {
    "text": "discuss how how you can make things responsive by being as Rous message",
    "start": "1762960",
    "end": "1770559"
  },
  {
    "text": "driven quite quite some time back Martin Thompson one of the leaders in as",
    "start": "1770559",
    "end": "1776159"
  },
  {
    "text": "synchronous Computing he tweeted this one messaging provides for a natural",
    "start": "1776159",
    "end": "1781200"
  },
  {
    "text": "mapping place for types and decoupling in space and time for those for those",
    "start": "1781200",
    "end": "1786559"
  },
  {
    "text": "entities which are decoupled in space and time messaging gives you a very good substrate for",
    "start": "1786559",
    "end": "1792519"
  },
  {
    "text": "implementation one more tweet messaging is the best way to communicate between bounded contexts but require",
    "start": "1792519",
    "end": "1798640"
  },
  {
    "text": "protocol Design This is the most important part you cannot have arbitrary messages",
    "start": "1798640",
    "end": "1804720"
  },
  {
    "text": "flowing across bounded contexts you need to have a protocol and that's also explicitly explained in Eric evans's",
    "start": "1804720",
    "end": "1812320"
  },
  {
    "text": "excellent book on do domain driven design where he discusses bounded context he discusses a a bunch of ways",
    "start": "1812320",
    "end": "1819919"
  },
  {
    "text": "in which you can communicate across bounded contexts one of them is the",
    "start": "1819919",
    "end": "1825279"
  },
  {
    "text": "conformist mode here we have two bounded context texts account management and Reporting and analytics they are",
    "start": "1825279",
    "end": "1832360"
  },
  {
    "text": "completely decoupled in time account management is possibly an online system whereas reporting possibly runs once a",
    "start": "1832360",
    "end": "1839080"
  },
  {
    "text": "day or twice a day or Thrice a day something like that so you cannot make a synchronous call from account management",
    "start": "1839080",
    "end": "1844840"
  },
  {
    "text": "and expect some response from the reporting bounded context you need to have a protocol you need to have a",
    "start": "1844840",
    "end": "1852200"
  },
  {
    "text": "message protocol between these two bounded contexts it can be a pub sub",
    "start": "1852200",
    "end": "1857320"
  },
  {
    "text": "push account information as messages Downstream and it will consume according to its need and the conformist thing",
    "start": "1857320",
    "end": "1863559"
  },
  {
    "text": "means that account management is the master bounded context it decides what the protocol should be and Reporting has",
    "start": "1863559",
    "end": "1870240"
  },
  {
    "text": "to confirm there are a bunch of other other ways to in other ways to collaborate as",
    "start": "1870240",
    "end": "1877720"
  },
  {
    "text": "well okay now that we have seen how we can design static apis that are",
    "start": "1881559",
    "end": "1886880"
  },
  {
    "text": "algebraically sound or Implement reactive protocols with async messaging that cuts across bounded context you",
    "start": "1886880",
    "end": "1893480"
  },
  {
    "text": "must be wondering why we haven't yet discussed actors it's slide Number 96 so better we",
    "start": "1893480",
    "end": "1901880"
  },
  {
    "text": "start discussing some some of the things that actors does in our domain model and",
    "start": "1901880",
    "end": "1907159"
  },
  {
    "text": "if you would ask me where I can use actors in The Domain model my response will be",
    "start": "1907159",
    "end": "1913159"
  },
  {
    "text": "everywhere I have seen this tendency to design an entire domain model based on",
    "start": "1913159",
    "end": "1919480"
  },
  {
    "text": "actors that's the problem I think actors are powerful too powerful",
    "start": "1919480",
    "end": "1926440"
  },
  {
    "text": "un algebraically powerful of course I'm uh I'm excluding type tors of AKA which",
    "start": "1926440",
    "end": "1933880"
  },
  {
    "text": "has been released only very recently I haven't gone through that so this is based on a pre- 2.4 version of",
    "start": "1933880",
    "end": "1941399"
  },
  {
    "text": "AKA you gain power at one semantic level but you lose the power of reasoning if",
    "start": "1941399",
    "end": "1946440"
  },
  {
    "text": "you have a static type system why not use it to the maximum I'm not saying that actors do not have their uses they",
    "start": "1946440",
    "end": "1952480"
  },
  {
    "text": "have their uses as as we will see but this is the problem using actors indiscriminately throughout your domain",
    "start": "1952480",
    "end": "1958679"
  },
  {
    "text": "model makes algebraic reasoning hard that's",
    "start": "1958679",
    "end": "1963919"
  },
  {
    "text": "because future 7even algebra you can Fork a future you can put something in lift some something into a in the",
    "start": "1963919",
    "end": "1970720"
  },
  {
    "text": "context of a future you can do a map over future you can join Over future future is a",
    "start": "1970720",
    "end": "1975960"
  },
  {
    "text": "monad but for actor it's something like this so you can do almost anything with an",
    "start": "1975960",
    "end": "1983240"
  },
  {
    "text": "actor so the general principle the general motto is use the least powerful abstraction that does the job this is",
    "start": "1983399",
    "end": "1990039"
  },
  {
    "text": "not only valid for users for uh Futures and actors it's valid in valid for",
    "start": "1990039",
    "end": "1995159"
  },
  {
    "text": "almost every aspect of software engineering for example applicatives and monads applicatives are less powerful",
    "start": "1995159",
    "end": "2001880"
  },
  {
    "text": "use applicatives whenever you can use monads only as a fallback",
    "start": "2001880",
    "end": "2008159"
  },
  {
    "text": "and for domain model resilience choose futures of actors when whenever you can",
    "start": "2008159",
    "end": "2013360"
  },
  {
    "text": "verifiability for verifiability of your domain model use futures or",
    "start": "2013360",
    "end": "2020000"
  },
  {
    "text": "actors in my experience of implementing domain models over the last couple of years these are the two places where I",
    "start": "2020000",
    "end": "2026679"
  },
  {
    "text": "found actors very useful the first one is as an implementation artifact to protect",
    "start": "2026679",
    "end": "2032320"
  },
  {
    "text": "shared mutable state",
    "start": "2032320",
    "end": "2036240"
  },
  {
    "text": "that's uh that's convenient because or else in order to achieve this I would",
    "start": "2037880",
    "end": "2044080"
  },
  {
    "text": "have to use locks and threads which obviously is a much lower level of abstraction and is Frau with grave",
    "start": "2044080",
    "end": "2049960"
  },
  {
    "text": "perils so actors provide a higher level of abstraction to deal with this concern",
    "start": "2049960",
    "end": "2056560"
  },
  {
    "text": "to deal with the fact that I can protect some mutable State mutable states are",
    "start": "2056560",
    "end": "2063720"
  },
  {
    "text": "common in domain models you cannot design a domain model without any mutable St State and if you need to",
    "start": "2063720",
    "end": "2069599"
  },
  {
    "text": "protect a mutable State you can use actas for that but as an implementation",
    "start": "2069599",
    "end": "2074919"
  },
  {
    "text": "artifact don't expose that as a public API and the second one is as Jonas was",
    "start": "2074919",
    "end": "2080320"
  },
  {
    "text": "mentioning in his talk centralized failure man management supervision",
    "start": "2080320",
    "end": "2086280"
  },
  {
    "text": "hierarchies now this is an example of a of an actor which is part of an implementation",
    "start": "2086679",
    "end": "2093200"
  },
  {
    "text": "of a real life domain model transactions come and somewhere we need to",
    "start": "2093200",
    "end": "2098240"
  },
  {
    "text": "somewhere we need to aggregate them aggregate aggregate them as the combined balance par account balance compute par",
    "start": "2098240",
    "end": "2104880"
  },
  {
    "text": "account balance as part of an in-memory domain model and the most performance",
    "start": "2104880",
    "end": "2110800"
  },
  {
    "text": "efficient way of doing it is to use a mutable map so we are doing that we are using an",
    "start": "2110800",
    "end": "2117720"
  },
  {
    "text": "actor in order to do that and it's part of the implementation",
    "start": "2117720",
    "end": "2124640"
  },
  {
    "text": "and the other thing other area where actor shine is centralized failure",
    "start": "2140920",
    "end": "2148319"
  },
  {
    "text": "management Jonas was talking about this error caral designing your domain model",
    "start": "2148319",
    "end": "2153640"
  },
  {
    "text": "around an error cardal is of invaluable help it gives you the ability to track",
    "start": "2153640",
    "end": "2159720"
  },
  {
    "text": "failures it prevents littering your entire code base with TR catch blocks",
    "start": "2159720",
    "end": "2166079"
  },
  {
    "text": "and even you can you can uh with AKA you can have these supervision hierarchies to some extent declarative as well so no",
    "start": "2166079",
    "end": "2174200"
  },
  {
    "text": "more messy failure handling code scattered throughout your code becomes your business logic becomes much cleaner",
    "start": "2174200",
    "end": "2180640"
  },
  {
    "text": "and you have a clean supervision hierarchy of how you would like to escalate your failures through the",
    "start": "2180640",
    "end": "2188800"
  },
  {
    "text": "layer of actors but it requires careful upfront design you need to have your actor actor",
    "start": "2188800",
    "end": "2194760"
  },
  {
    "text": "supervision hierarchy in place upfront you cannot do it as an afterthought",
    "start": "2194760",
    "end": "2199800"
  },
  {
    "text": "because your entire system design depends on",
    "start": "2199800",
    "end": "2203920"
  },
  {
    "text": "that centralized failure management through actor based supervision ensures",
    "start": "2205760",
    "end": "2211119"
  },
  {
    "text": "that you don't have brittle failure management code littered across your code base the entire management the is",
    "start": "2211119",
    "end": "2216960"
  },
  {
    "text": "centralized disciplined and it also can be declarative if you use",
    "start": "2216960",
    "end": "2222880"
  },
  {
    "text": "akka one other thing which I found which I find quite common today is designing",
    "start": "2224160",
    "end": "2230720"
  },
  {
    "text": "workflows designing domain workflows using actors and",
    "start": "2230720",
    "end": "2236040"
  },
  {
    "text": "messages it works there are there are there are lots of implementations that work this this way particularly if you",
    "start": "2236280",
    "end": "2242400"
  },
  {
    "text": "use the higher level abstractions of AKA FSM finite State machine which the which which is it offers but still it's",
    "start": "2242400",
    "end": "2249560"
  },
  {
    "text": "lowlevel untyped non-compositional because actors don't compose on",
    "start": "2249560",
    "end": "2256480"
  },
  {
    "text": "algebraic and on the other hand we would like to have something which is higher level which is typed which is algebraic",
    "start": "2256480",
    "end": "2265839"
  },
  {
    "text": "and which is compositional plus it's good if we can have a DSL",
    "start": "2265839",
    "end": "2272359"
  },
  {
    "text": "around it a domain specific language plus since we are modeling workflows we would like to have flow as a first class",
    "start": "2272359",
    "end": "2280200"
  },
  {
    "text": "abstraction and this is one of the core principles of functional programming as well separate definition from execution",
    "start": "2280319",
    "end": "2287319"
  },
  {
    "text": "because if you can separate definition from execution you can compose multiple definitions to form a larger",
    "start": "2287319",
    "end": "2293079"
  },
  {
    "text": "definition so our wish list is this we would not like to use the lower level actor framework for modeling our",
    "start": "2293079",
    "end": "2300920"
  },
  {
    "text": "workflows we and this is exactly what reactive streams offer reactive streams offer a",
    "start": "2300920",
    "end": "2307880"
  },
  {
    "text": "compositional typesafe way to model your stream based workflows and one of the implementations",
    "start": "2307880",
    "end": "2314319"
  },
  {
    "text": "of reactive streams is AKA streams it gives us natural abstractions",
    "start": "2314319",
    "end": "2322599"
  },
  {
    "text": "for each of these artifacts a source computation starts from the pipeline starts from a source ends at a sync note",
    "start": "2322599",
    "end": "2330920"
  },
  {
    "text": "this abstraction flow it's a first class abstraction and using flow you can using flow Source sync",
    "start": "2330920",
    "end": "2338079"
  },
  {
    "text": "you can generate a runnable graph a graph of computation which actually is the reified version of your workflow",
    "start": "2338079",
    "end": "2345480"
  },
  {
    "text": "domain workflow you can compose multiple runnable graphs to form larger ones you",
    "start": "2345480",
    "end": "2350720"
  },
  {
    "text": "can reuse them you can reify them and finally you can execute",
    "start": "2350720",
    "end": "2358760"
  },
  {
    "text": "them now this is an example of a business use case of a stream based workflow where",
    "start": "2358760",
    "end": "2366000"
  },
  {
    "text": "transactions flow from Up to Downstream and at the end of the end of the pipeline we have some nitting operations",
    "start": "2366000",
    "end": "2372720"
  },
  {
    "text": "and in between we have a number of Transformers that does lot of",
    "start": "2372720",
    "end": "2378560"
  },
  {
    "text": "Transformations depending on the workflow what type of what type of uh account it is what type of transaction",
    "start": "2378560",
    "end": "2385720"
  },
  {
    "text": "it is depending on that it gives you a number of",
    "start": "2385720",
    "end": "2390760"
  },
  {
    "text": "Transformers and if you translate it verbatim to AKA streams you will see",
    "start": "2390760",
    "end": "2396800"
  },
  {
    "text": "that the diag also looks very much the similar one you have the sources you have the",
    "start": "2396800",
    "end": "2403440"
  },
  {
    "text": "sing there and in between you have a wave of",
    "start": "2403440",
    "end": "2410280"
  },
  {
    "text": "Transformations and there those Transformers they all encode business logic they are all first class",
    "start": "2410720",
    "end": "2417280"
  },
  {
    "text": "abstractions they are all type safe you can compose each of them I will show you the code for this the code for this also",
    "start": "2417280",
    "end": "2423280"
  },
  {
    "text": "looks very good and this is the code for",
    "start": "2423280",
    "end": "2430040"
  },
  {
    "text": "this for each of the artifacts you define typed abstractions and compose them at the end",
    "start": "2430040",
    "end": "2437920"
  },
  {
    "text": "and this is the this is the DSL this is the DSL for com composing the entire pipeline which is declarative which is",
    "start": "2437920",
    "end": "2445160"
  },
  {
    "text": "type safe which is compositional and as I was",
    "start": "2445160",
    "end": "2450480"
  },
  {
    "text": "mentioning AA streams use actors underneath to materialize this flow",
    "start": "2450480",
    "end": "2459240"
  },
  {
    "text": "so that's the main main part of main part of this implementation that the",
    "start": "2459480",
    "end": "2465000"
  },
  {
    "text": "actor part is delegated to the implementation level",
    "start": "2465000",
    "end": "2470720"
  },
  {
    "text": "the actor doesn't appear anywhere here the user the public API doesn't have to",
    "start": "2470720",
    "end": "2476359"
  },
  {
    "text": "deal with actor sends and actor receives the public API is completely typ safe",
    "start": "2476359",
    "end": "2482920"
  },
  {
    "text": "transformational compositional algebraic all the good things are here",
    "start": "2482920",
    "end": "2488839"
  },
  {
    "text": "and this only creates the graph it doesn't run the graph as I was telling you separate definition from execution",
    "start": "2488839",
    "end": "2494760"
  },
  {
    "text": "this only creates the graph and once you have the graph it's just a graph.",
    "start": "2494760",
    "end": "2501040"
  },
  {
    "text": "run graph. run will and you you can you can compose multiple such graphs to build larger graphs and at the end of",
    "start": "2501040",
    "end": "2508079"
  },
  {
    "text": "the at the end of it you can say graph. run which will run the entire stream processing",
    "start": "2508079",
    "end": "2515119"
  },
  {
    "text": "pipeline so if you have been been using actors for modeling stream work stream based workflows you can think of moving",
    "start": "2515560",
    "end": "2522720"
  },
  {
    "text": "to AA streams it's one of the one of the best things out there as part of the",
    "start": "2522720",
    "end": "2529599"
  },
  {
    "text": "aaack and one more thing which AKA streams handles is back back pressure",
    "start": "2529640",
    "end": "2535240"
  },
  {
    "text": "one of the problems that we often find with uh stream based workflows when you have a p and the sub the subscriber",
    "start": "2535240",
    "end": "2543960"
  },
  {
    "text": "often tends to get overloaded by flow coming from Upstream AKA streams",
    "start": "2543960",
    "end": "2551160"
  },
  {
    "text": "has this has this ability it gives you the hooks to control this control this",
    "start": "2551160",
    "end": "2556839"
  },
  {
    "text": "back back pressure by by controlling the demand that the subscriber can actually",
    "start": "2556839",
    "end": "2565480"
  },
  {
    "text": "tolerate so all in all it gives you a great substrate for composing stream",
    "start": "2565480",
    "end": "2571880"
  },
  {
    "text": "based workflows actually uh there are a lot of other things as far as do modeling",
    "start": "2571880",
    "end": "2579280"
  },
  {
    "text": "with functional and reactive principles is concerned but I don't have time for all all of them and one of the one of",
    "start": "2579280",
    "end": "2585800"
  },
  {
    "text": "the things is uh communication with the database you can use event sourcing and",
    "start": "2585800",
    "end": "2592359"
  },
  {
    "text": "cqrs those kinds of techniques in order to communicate with the database and AKA also gives persistent actors using which",
    "start": "2592359",
    "end": "2599319"
  },
  {
    "text": "you can do that but uh that's possibly topic for a separate talk so",
    "start": "2599319",
    "end": "2606079"
  },
  {
    "text": "this is uh more or less what I have to say and",
    "start": "2606079",
    "end": "2611480"
  },
  {
    "text": "uh if you are more interested in this topic I have written a book it's actually coming up the meup is Early",
    "start": "2611480",
    "end": "2618680"
  },
  {
    "text": "Access is available from Manning",
    "start": "2618680",
    "end": "2624079"
  },
  {
    "text": "so and don't forget",
    "start": "2625880",
    "end": "2630279"
  }
]