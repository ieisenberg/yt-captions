[
  {
    "start": "0",
    "end": "26000"
  },
  {
    "text": "so for agenda i'm going to start by talking about what i consider are the key performance attributes then i'm",
    "start": "7359",
    "end": "14480"
  },
  {
    "text": "going to do like this hundred thousand foot view of modern jvm architectures and in particular the gc architectures",
    "start": "14480",
    "end": "21920"
  },
  {
    "text": "then we'll get into these basic concepts so the performance attributes",
    "start": "21920",
    "end": "30240"
  },
  {
    "start": "26000",
    "end": "175000"
  },
  {
    "text": "i often talk about this as a three-legged stool and the three performance attributes are",
    "start": "30240",
    "end": "36079"
  },
  {
    "text": "throughput latency and footprint",
    "start": "36079",
    "end": "40719"
  },
  {
    "text": "in the java performance book i mentioned this principle that i just gave it a label called the 203 principle",
    "start": "42320",
    "end": "48559"
  },
  {
    "text": "and it basically says in improving one of these three or one or two of these performance",
    "start": "48559",
    "end": "54559"
  },
  {
    "text": "attributes you're going to sacrifice something in at least one of the others",
    "start": "54559",
    "end": "61199"
  },
  {
    "text": "and if you think about that i think you can kind of come to terms with that",
    "start": "61199",
    "end": "66559"
  },
  {
    "text": "after i wrote the book and i've had some conversations with some really smart people perhaps",
    "start": "68479",
    "end": "73840"
  },
  {
    "text": "people that are smarter than i am we talked about this a little bit and",
    "start": "73840",
    "end": "80320"
  },
  {
    "text": "there are cases where you want to improve all three of these performance attributes",
    "start": "80320",
    "end": "86080"
  },
  {
    "text": "but in doing so it usually requires an awful lot of work and usually it involves a lot of",
    "start": "86080",
    "end": "91520"
  },
  {
    "text": "software development work so i would revise that two or three",
    "start": "91520",
    "end": "97280"
  },
  {
    "text": "principle another thing that i've learned since i published the book",
    "start": "97280",
    "end": "102640"
  },
  {
    "text": "and this principle i've yet to come up with a name for and that is an improvement in throughput",
    "start": "103200",
    "end": "109600"
  },
  {
    "text": "or latency may reduce or lower the amount of available cpu to the application",
    "start": "109600",
    "end": "116159"
  },
  {
    "text": "and this translates to that system has some sort of capacity to",
    "start": "116159",
    "end": "121920"
  },
  {
    "text": "it and that's usually limited to the amount of cpu usually memory is not so much a",
    "start": "121920",
    "end": "127840"
  },
  {
    "text": "limitation is what the amount of cpu that you can use so really what the there's another",
    "start": "127840",
    "end": "133440"
  },
  {
    "text": "principle in here and another performance attribute that i kind of call capacity",
    "start": "133440",
    "end": "140160"
  },
  {
    "text": "it's really not an accurate term but it really is talking about if i'm going to improve throughput",
    "start": "140160",
    "end": "147599"
  },
  {
    "text": "improve latency there's a good chance that i may have an impact on how much cpu i have available",
    "start": "147599",
    "end": "154400"
  },
  {
    "text": "for other things that i want to run on that application this might be important for some",
    "start": "154400",
    "end": "159760"
  },
  {
    "text": "applications somebody who's a cloud provider where they're looking for efficiency",
    "start": "159760",
    "end": "166080"
  },
  {
    "text": "making that kind of a trade-off is an important decision for them so there's an another element in here",
    "start": "166080",
    "end": "173680"
  },
  {
    "text": "of capacity so perhaps there's an enhanced three-legged stool here",
    "start": "173680",
    "end": "180560"
  },
  {
    "text": "somewhere we have to fit in this capacity thing and i'm struggling to figure out where in this three-legged",
    "start": "180560",
    "end": "186400"
  },
  {
    "text": "stool does this thing fit maybe it's a four-legged stool anyway those are the four performance",
    "start": "186400",
    "end": "193920"
  },
  {
    "text": "attributes for us to be thinking about so we'll come back to those performance",
    "start": "193920",
    "end": "200159"
  },
  {
    "start": "197000",
    "end": "343000"
  },
  {
    "text": "attributes in just a second let's take a look at a high level view",
    "start": "200159",
    "end": "205280"
  },
  {
    "text": "of the modern jvm gc architectures so if we look at all modern jvms today",
    "start": "205280",
    "end": "212959"
  },
  {
    "text": "we'll find that almost every one of them at least to my knowledge are using what's called a generational",
    "start": "212959",
    "end": "219200"
  },
  {
    "text": "gc and basically the idea behind a generational gc is you segregate the",
    "start": "219200",
    "end": "224640"
  },
  {
    "text": "objects by age into different spaces and you bias the collection of younger objects",
    "start": "224640",
    "end": "231120"
  },
  {
    "text": "so in other words you do collections on younger objects more frequently",
    "start": "231120",
    "end": "236239"
  },
  {
    "text": "and typically there's two generations a young generation and an old generation",
    "start": "236239",
    "end": "241840"
  },
  {
    "text": "a generational gc could have additional generations and one idea that i have floated around",
    "start": "241840",
    "end": "248480"
  },
  {
    "text": "with various different people has been the notion of an intermediate region there's applications out there",
    "start": "248480",
    "end": "255200"
  },
  {
    "text": "for instance that have what i would call intermediate objects they're not something that lives for a",
    "start": "255200",
    "end": "260239"
  },
  {
    "text": "short period of time and then die but yet there's something that lives a little bit longer than say a transaction",
    "start": "260239",
    "end": "266400"
  },
  {
    "text": "but yet they don't live for the life of the application they're kind of a teenage object and i",
    "start": "266400",
    "end": "274160"
  },
  {
    "text": "labeled this idea as teenage liveness gc and this is where objects go and die in",
    "start": "274160",
    "end": "281120"
  },
  {
    "text": "and teenage wasteland and for you the guys that know me you know that i can rarely do a presentation",
    "start": "281120",
    "end": "287199"
  },
  {
    "text": "and not squeeze in a little bit of the who somewhere okay",
    "start": "287199",
    "end": "292880"
  },
  {
    "text": "so with jvms today that have generational gcs so in hotspot all of the gcs that are",
    "start": "292880",
    "end": "300160"
  },
  {
    "text": "supported by oracle are generational gcs they have a young and an old generation",
    "start": "300160",
    "end": "305280"
  },
  {
    "text": "j rocket also has all of their gcs are generational the exception to that is the real-time",
    "start": "305280",
    "end": "312400"
  },
  {
    "text": "j-rocket real-time it's a single generation collector zheng from mosul c4 is a generational",
    "start": "312400",
    "end": "319360"
  },
  {
    "text": "collector j9 from ibm as far as i know i'll admit",
    "start": "319360",
    "end": "324479"
  },
  {
    "text": "that i don't know a lot about the j9 collectors they are generational gcs i think the",
    "start": "324479",
    "end": "330400"
  },
  {
    "text": "one exception to that is their real-time collector called metronome if you want to know more about ibm j9",
    "start": "330400",
    "end": "337600"
  },
  {
    "text": "i'm sure john is roaming around here somewhere and he can give you all of the gory details",
    "start": "337600",
    "end": "343840"
  },
  {
    "start": "343000",
    "end": "630000"
  },
  {
    "text": "okay so why would you do a generational gc in my opinion it's based on the primary",
    "start": "344400",
    "end": "351039"
  },
  {
    "text": "reason is based on the weak generational hypothesis and that basically says that most objects",
    "start": "351039",
    "end": "356639"
  },
  {
    "text": "die young and the number one reason for doing a generational gc",
    "start": "356639",
    "end": "362319"
  },
  {
    "text": "is for improving throughput if we take a brief look at the hotspot",
    "start": "362319",
    "end": "369680"
  },
  {
    "text": "jvm's heap layout there's a young generation space and it's responsible for",
    "start": "369680",
    "end": "375199"
  },
  {
    "text": "new and young objects so that's what is held in the young generation there's also an old generation this is",
    "start": "375199",
    "end": "382319"
  },
  {
    "text": "for the older longer-lived objects prior to jdk8 there was another space",
    "start": "382319",
    "end": "387360"
  },
  {
    "text": "here called the permanent generation and jdk8 this has been eliminated in favor of what's called a metaspace",
    "start": "387360",
    "end": "394400"
  },
  {
    "text": "in very simplistic terms basically what this means is",
    "start": "394400",
    "end": "399520"
  },
  {
    "text": "in both prior to jdk 8 and jdk8 going forward permanent",
    "start": "399520",
    "end": "405039"
  },
  {
    "text": "generation versus metaspace as far as what it does functionally it",
    "start": "405039",
    "end": "410319"
  },
  {
    "text": "basically does the same thing it holds class metadata and vm information",
    "start": "410319",
    "end": "416560"
  },
  {
    "text": "so the biggest difference between the two is prior to jdk8 you had this nasty little",
    "start": "416560",
    "end": "422880"
  },
  {
    "text": "tuning of tuning the permanent generation size so metaspace has implemented out a",
    "start": "422880",
    "end": "428000"
  },
  {
    "text": "native code and it's something you don't have to worry about with tuning its size it basically is going to grow as you",
    "start": "428000",
    "end": "433680"
  },
  {
    "text": "need it you can override and set and say that i only wanted to use a specific amount of memory",
    "start": "433680",
    "end": "439280"
  },
  {
    "text": "but that's basically the difference if we look a little bit closer at the hotspot vm layout of young generation",
    "start": "439280",
    "end": "446800"
  },
  {
    "text": "there's an eden space there's a from survivor space and a two survivor space so young",
    "start": "446800",
    "end": "452880"
  },
  {
    "text": "generation is divided up a little bit further so to illustrate how this works in a",
    "start": "452880",
    "end": "460160"
  },
  {
    "text": "minor let me say it this way when your application executes it starts",
    "start": "460160",
    "end": "467039"
  },
  {
    "text": "allocating objects when it allocates an object that object allocation happens in the eden space",
    "start": "467039",
    "end": "474080"
  },
  {
    "text": "when that eden space is exhausted a minor collection occurs or a young collection occurs",
    "start": "474080",
    "end": "482400"
  },
  {
    "text": "what happens then is anything that's live is then copied to the two survivor space",
    "start": "482400",
    "end": "488639"
  },
  {
    "text": "in addition to that anything that is live in the from survivor space also gets copied to this to survivor",
    "start": "488639",
    "end": "494960"
  },
  {
    "text": "space so these survivor spaces the idea behind",
    "start": "494960",
    "end": "500160"
  },
  {
    "text": "that is it's retaining and aging young objects during the young and minor gcs at some",
    "start": "500160",
    "end": "506479"
  },
  {
    "text": "point later at some age threshold they will get moved from the survivor space",
    "start": "506479",
    "end": "511840"
  },
  {
    "text": "into the old generation we'll come back to this this diagram and and then this picture",
    "start": "511840",
    "end": "518479"
  },
  {
    "text": "a little bit later in the slides because we're first going to talk and focus on young generation and the decisions that",
    "start": "518479",
    "end": "523839"
  },
  {
    "text": "we're going to make around tuning the garbage collector for young generation",
    "start": "523839",
    "end": "529440"
  },
  {
    "text": "so when tuning gc the general approach is we want to think about it in terms of frequency",
    "start": "531040",
    "end": "537760"
  },
  {
    "text": "the questions you should be asking yourself and the people that use your application are how often can i live with a gc event",
    "start": "537760",
    "end": "544880"
  },
  {
    "text": "occurring how often can a minor gc event occur how often can a full collection occur",
    "start": "544880",
    "end": "551120"
  },
  {
    "text": "if you have a concurrent gc how often can a concurrent cycle occur",
    "start": "551120",
    "end": "556399"
  },
  {
    "text": "the other question to ask is duration for a stop the world gc how long of a gc",
    "start": "556399",
    "end": "564000"
  },
  {
    "text": "pause can i tolerate how long can my application be be",
    "start": "564000",
    "end": "569040"
  },
  {
    "text": "stopped while it's doing garbage collection for a concurrent collector the question you can ask is how much",
    "start": "569040",
    "end": "576240"
  },
  {
    "text": "capacity or how much cpu consumption am i willing to have that concurrent collector use",
    "start": "576240",
    "end": "583680"
  },
  {
    "text": "how much additional memory might i have to use to deal with that floating garbage",
    "start": "583839",
    "end": "589120"
  },
  {
    "text": "how much am i willing to sacrifice in the way of additional cpu or additional memory for that concurrent collector",
    "start": "589120",
    "end": "596000"
  },
  {
    "text": "those are the types of questions you want to be asking",
    "start": "596000",
    "end": "600160"
  },
  {
    "text": "an important note here is the answers to these questions are going to differ wildly between applications you'll",
    "start": "601040",
    "end": "608160"
  },
  {
    "text": "probably even find as you talk to people who use the same application",
    "start": "608160",
    "end": "613200"
  },
  {
    "text": "they're going to give you differing answers so it's going to be important as you talk to people who use the",
    "start": "613200",
    "end": "618800"
  },
  {
    "text": "application what is most important to them what is it put some values on the",
    "start": "618800",
    "end": "625519"
  },
  {
    "text": "frequency and duration of those garbage collection events",
    "start": "625519",
    "end": "630000"
  },
  {
    "start": "630000",
    "end": "825000"
  },
  {
    "text": "okay so let's start moving into the concepts",
    "start": "631200",
    "end": "636320"
  },
  {
    "text": "so the first concept we're going to talk about is the frequency of minor or young gcs",
    "start": "638320",
    "end": "644959"
  },
  {
    "text": "and the frequency of a minor gc is dictated by the object allocation rate of the application",
    "start": "644959",
    "end": "650720"
  },
  {
    "text": "in other words how fast is it allocating objects the other thing that dictates the frequency of a minor collection",
    "start": "650720",
    "end": "658640"
  },
  {
    "text": "in the hot spot case it's the size of the eden space",
    "start": "658640",
    "end": "664000"
  },
  {
    "text": "for the other generational jvms it's going to be the size of that space where new objects are allocated",
    "start": "664000",
    "end": "670399"
  },
  {
    "text": "for the stop the world collectors once that space is exhausted you're going to get a gc event",
    "start": "670399",
    "end": "677680"
  },
  {
    "text": "for a concurrent collector there's usually some kind of an occupancy threshold of that space where you're",
    "start": "677680",
    "end": "682959"
  },
  {
    "text": "allocating new objects that once it's surpassed it starts some concurrent garbage",
    "start": "682959",
    "end": "689120"
  },
  {
    "text": "collection of m it's at that point where you'll see the additional consumption of cpu cycles",
    "start": "689120",
    "end": "696720"
  },
  {
    "text": "so how do i go about changing the frequency of a minor gc event so let's say that you're running an",
    "start": "698800",
    "end": "704880"
  },
  {
    "text": "application and you say you know what we're getting gcu events too often okay what are my choices what do i need",
    "start": "704880",
    "end": "710720"
  },
  {
    "text": "to do well in the case of hotspot you make the eden size bigger let's assume that the object allocation",
    "start": "710720",
    "end": "717279"
  },
  {
    "text": "rate stays the same one choice is to make the eden size bigger so as an example suppose we got an even",
    "start": "717279",
    "end": "723920"
  },
  {
    "text": "size of 512 megabyte obviously if i double the size of the",
    "start": "723920",
    "end": "728959"
  },
  {
    "text": "eden size the eden space size with the same allocation rate this is pretty obvious",
    "start": "728959",
    "end": "735600"
  },
  {
    "text": "i get a 2 in 2x increase in even space the time between my gc events now increases by 2x",
    "start": "735600",
    "end": "743200"
  },
  {
    "text": "my minor gc frequency is now cut in half this is pretty obvious right",
    "start": "743200",
    "end": "749519"
  },
  {
    "text": "okay so some additional choices for making eden size smaller so if you're working with the",
    "start": "750399",
    "end": "756320"
  },
  {
    "text": "hot spot jvm here's the command line options you'd use to increase",
    "start": "756320",
    "end": "762000"
  },
  {
    "text": "the young generation or the eden size if you're using cms gc or parallel gc or",
    "start": "762000",
    "end": "767279"
  },
  {
    "text": "serial gc you may also want to use survivor racial if you want to keep the size of the",
    "start": "767279",
    "end": "773680"
  },
  {
    "text": "young generation the same but just manipulate the size of eden so survivor racial says how much of the",
    "start": "773680",
    "end": "780720"
  },
  {
    "text": "racial of the young generation do i want to designate to the survivor spaces",
    "start": "780720",
    "end": "786320"
  },
  {
    "text": "in the case of g1 gc it's a little more interesting",
    "start": "786320",
    "end": "791279"
  },
  {
    "text": "g1 gc has a lot of heuristics in it its basic premise is you set a pause time target",
    "start": "791680",
    "end": "797519"
  },
  {
    "text": "it magically figures out how to adapt to meeting that pause time target",
    "start": "797519",
    "end": "803360"
  },
  {
    "text": "so what you do is if you said my gc events are occurring too frequently minor gc events are",
    "start": "803360",
    "end": "808800"
  },
  {
    "text": "occurring too frequently and i want them to occur less frequently what you can do here is you could",
    "start": "808800",
    "end": "814560"
  },
  {
    "text": "increase the pause time target generally the g1 heuristics assume that a greater pause time",
    "start": "814560",
    "end": "820480"
  },
  {
    "text": "implies a larger eden space",
    "start": "820480",
    "end": "824160"
  },
  {
    "text": "so the other choice that you've got here is you could reduce the object allocation rate",
    "start": "826480",
    "end": "832000"
  },
  {
    "text": "so if you reduce the object allocation rate you have a same size eden space",
    "start": "832000",
    "end": "838000"
  },
  {
    "text": "obviously the eden space fills more slowly with a reduced object allocation rate",
    "start": "838000",
    "end": "843360"
  },
  {
    "text": "so as an example suppose we've got a 40 megabyte per second object allocation rate i've got a 512",
    "start": "843360",
    "end": "851199"
  },
  {
    "text": "megabyte eating space if i cut in half the object allocation",
    "start": "851199",
    "end": "856800"
  },
  {
    "text": "rate keep the same size eden space it's obvious right",
    "start": "856800",
    "end": "862240"
  },
  {
    "text": "i've got a 2x drop and allocation rate the time the fill even space increases by 2x",
    "start": "862240",
    "end": "868160"
  },
  {
    "text": "the time between gcs is now 2x greater the challenge is going to be how do i go",
    "start": "868160",
    "end": "875440"
  },
  {
    "text": "about reducing the object allocation rate so what you do is you profile the application you'd focus on reducing",
    "start": "875440",
    "end": "882240"
  },
  {
    "text": "object allocations especially the unnecessary object allocations another choice you",
    "start": "882240",
    "end": "887920"
  },
  {
    "text": "could have here is essentially throttle the application slow down the application",
    "start": "887920",
    "end": "893680"
  },
  {
    "text": "you reduce the injection rate to the load that the application is taking on",
    "start": "893680",
    "end": "899839"
  },
  {
    "text": "okay second important concept",
    "start": "900959",
    "end": "906000"
  },
  {
    "text": "the duration or the amount of time that a gc pause or the collection of a minor collection",
    "start": "906240",
    "end": "912880"
  },
  {
    "text": "young generation takes so the number of live objects has the",
    "start": "912880",
    "end": "919839"
  },
  {
    "text": "strongest influence on the minor gc duration gc only visits the term that you'll hear",
    "start": "919839",
    "end": "927360"
  },
  {
    "text": "in in gc lingual is going to be mark it only marks and evacuates live objects there's other",
    "start": "927360",
    "end": "935120"
  },
  {
    "text": "things that can influence minor gc duration overuse or i would say abuse of reference objects weak",
    "start": "935120",
    "end": "941680"
  },
  {
    "text": "soft phantom final references the memory locality of those marked objects and the",
    "start": "941680",
    "end": "946959"
  },
  {
    "text": "evacuation location where you're copying them to you might have a young generation object",
    "start": "946959",
    "end": "953600"
  },
  {
    "text": "that's kept alive by some old generation reference there could be some other reasons too",
    "start": "953600",
    "end": "960000"
  },
  {
    "text": "that could impact the duration of a minor gc but ideally",
    "start": "960000",
    "end": "965600"
  },
  {
    "text": "what you want to strive for is and what you want to be able to observe if you can find the information from",
    "start": "965600",
    "end": "971040"
  },
  {
    "text": "the gc logs or from the system or by profiling is the minor gc duration",
    "start": "971040",
    "end": "978079"
  },
  {
    "text": "should be dominated by the marking and evacuation times",
    "start": "978079",
    "end": "983360"
  },
  {
    "text": "if that's not the case you've got something else going on in the application or in the garbage collector that's",
    "start": "983360",
    "end": "989440"
  },
  {
    "text": "worthy to take a look at you may need an expert to help you in that area",
    "start": "989440",
    "end": "996720"
  },
  {
    "start": "995000",
    "end": "1233000"
  },
  {
    "text": "so some of the choices for reducing minor gc pause time obviously faster memory cpu in general a",
    "start": "996720",
    "end": "1004000"
  },
  {
    "text": "faster system hey that's obvious that's easy maybe a faster stop the world gc",
    "start": "1004000",
    "end": "1009920"
  },
  {
    "text": "algorithm you know if you're working with a stop the world garbage collector maybe you look for a faster algorithm",
    "start": "1009920",
    "end": "1016800"
  },
  {
    "text": "maybe you look for a concurrent collector a concurrent collector for young generation",
    "start": "1016800",
    "end": "1022000"
  },
  {
    "text": "it may introduce more cpu consumption which could reduce the available capacity of that system",
    "start": "1022000",
    "end": "1028880"
  },
  {
    "text": "it may also require some additional memory footprint to handle the floating garbage",
    "start": "1028880",
    "end": "1034720"
  },
  {
    "text": "another choice is the fewer live objects",
    "start": "1034799",
    "end": "1039839"
  },
  {
    "text": "i'm going to focus on the last choice there the realizing of fewer live objects",
    "start": "1041199",
    "end": "1046319"
  },
  {
    "text": "so so strategies you can use for achieving fewer live objects per minor gc",
    "start": "1046319",
    "end": "1051679"
  },
  {
    "text": "you could have a smaller eden space fewer objects in general imply fewer live objects but that's not always",
    "start": "1051679",
    "end": "1058880"
  },
  {
    "text": "true a smaller eden space implies that the eden space fills faster",
    "start": "1058880",
    "end": "1066080"
  },
  {
    "text": "it implies more frequent minor gcs there's less time for an object to die",
    "start": "1066080",
    "end": "1071760"
  },
  {
    "text": "and in general there's a higher live objects to objects allocated ratio i think if you",
    "start": "1071760",
    "end": "1078080"
  },
  {
    "text": "step back and you think about this i think you kind of come to terms with that",
    "start": "1078080",
    "end": "1083279"
  },
  {
    "text": "a common approach with the smaller eden size is you work with a concurrent collector in",
    "start": "1083600",
    "end": "1088799"
  },
  {
    "text": "the old generation and in essence what you're doing is you're pushing this collection work off",
    "start": "1088799",
    "end": "1094160"
  },
  {
    "text": "until later and what this generally leads to is more frequent old generation concurrent",
    "start": "1094160",
    "end": "1100400"
  },
  {
    "text": "collections and higher overall cpu consumption which then again can also impact this",
    "start": "1100400",
    "end": "1107520"
  },
  {
    "text": "capacity",
    "start": "1107520",
    "end": "1109840"
  },
  {
    "text": "so some additional strategies for realizing fewer live objects",
    "start": "1115200",
    "end": "1122080"
  },
  {
    "text": "you could remove or focus on unnecessary object retention so what i mean by object retention is",
    "start": "1122080",
    "end": "1128080"
  },
  {
    "text": "there's a set of objects that's retained when you do a garbage collection there may be a set of those or a portion",
    "start": "1128080",
    "end": "1134480"
  },
  {
    "text": "of those that may be unnecessarily retained as an artifact of some object that you've",
    "start": "1134480",
    "end": "1140080"
  },
  {
    "text": "allocated this is going to be take it's going to take some expertise of somebody who's",
    "start": "1140080",
    "end": "1145679"
  },
  {
    "text": "familiar with the application to know whether what is live at the end of a collection",
    "start": "1145679",
    "end": "1152080"
  },
  {
    "text": "is something that is necessary for the application so generally what you do is you profile",
    "start": "1152080",
    "end": "1158640"
  },
  {
    "text": "the application you look for one of the things you could look for is a potential assignment between",
    "start": "1158640",
    "end": "1164559"
  },
  {
    "text": "two objects that span multiple generations and when you have this scenario you have",
    "start": "1164559",
    "end": "1170320"
  },
  {
    "text": "an object or you could have an object in young generation that looks to be alive when you do a young generation",
    "start": "1170320",
    "end": "1177919"
  },
  {
    "text": "collection it could be held by an object that is actually unreachable an old generation",
    "start": "1177919",
    "end": "1184960"
  },
  {
    "text": "but the young generation collector doesn't know that it doesn't know what's live in old",
    "start": "1184960",
    "end": "1190840"
  },
  {
    "text": "generation i should say not all young generation garbage collectors know that",
    "start": "1190840",
    "end": "1197519"
  },
  {
    "text": "and if you look at the source code for java util linked list clear there's a little comment in there",
    "start": "1197760",
    "end": "1204480"
  },
  {
    "text": "that says basically this is what they are doing they were clearing these references",
    "start": "1204480",
    "end": "1210000"
  },
  {
    "text": "and setting them to null to help the garbage collector figure out that hey if you happen to",
    "start": "1210000",
    "end": "1215440"
  },
  {
    "text": "have an object in a linked list and that happened those references span",
    "start": "1215440",
    "end": "1221679"
  },
  {
    "text": "the assignment spans multiple generations it's telling the garbage collector hey",
    "start": "1221679",
    "end": "1227520"
  },
  {
    "text": "i'm helping you out here this guy really isn't live anymore",
    "start": "1227520",
    "end": "1234559"
  },
  {
    "start": "1233000",
    "end": "1491000"
  },
  {
    "text": "okay third important concept we're going to shift to talking about",
    "start": "1234559",
    "end": "1240799"
  },
  {
    "text": "old generation now so first some background info here there's lots of variations on old",
    "start": "1240799",
    "end": "1246880"
  },
  {
    "text": "generation collectors there's stop the world old generation collectors there's concurrent collectors",
    "start": "1246880",
    "end": "1252080"
  },
  {
    "text": "there's mostly concurrent old generation collectors in the hotspot jvm parallel gc parallel",
    "start": "1252080",
    "end": "1258640"
  },
  {
    "text": "old and serial gc are stop the world collectors hot spots cms gc and g1 gc are mostly",
    "start": "1258640",
    "end": "1266720"
  },
  {
    "text": "concurrent they have a couple of phases that are stopped the world which is why they are called mostly concurrent",
    "start": "1266720",
    "end": "1273840"
  },
  {
    "text": "j rocket has both stopped the world in mostly concurrent gcs",
    "start": "1273840",
    "end": "1279440"
  },
  {
    "text": "azul zing c4 is a concurrent gc",
    "start": "1279440",
    "end": "1284480"
  },
  {
    "text": "ibm's j9 as far as i know have both stopped the world in mostly concurrent gcs",
    "start": "1284480",
    "end": "1291840"
  },
  {
    "text": "so back to this diagram so we saw earlier how",
    "start": "1292320",
    "end": "1299280"
  },
  {
    "text": "objects are allocated here and when the even space becomes full we do this minor collection and things get",
    "start": "1299280",
    "end": "1305039"
  },
  {
    "text": "migrated into anything that's live goes to the survivor spaces we do some aging here those objects per",
    "start": "1305039",
    "end": "1311919"
  },
  {
    "text": "minor gc at some point if that object is still live it gets promoted into",
    "start": "1311919",
    "end": "1318000"
  },
  {
    "text": "the old generation space",
    "start": "1318000",
    "end": "1321360"
  },
  {
    "text": "okay so similar to young generation",
    "start": "1323120",
    "end": "1328480"
  },
  {
    "text": "collection frequency old generation collection frequency",
    "start": "1328480",
    "end": "1333520"
  },
  {
    "text": "so the old generation collection frequency is dictated by the promotion rate the rate at which objects are promoted",
    "start": "1333520",
    "end": "1340159"
  },
  {
    "text": "from young generation to old generation now the hotspot jvm promotes objects",
    "start": "1340159",
    "end": "1345600"
  },
  {
    "text": "based on an age tenuring threshold and this age is the number of minor gcs that an object",
    "start": "1345600",
    "end": "1352400"
  },
  {
    "text": "survives the age tendering threshold is computed at each minor gc by the hotspot jvm and",
    "start": "1352400",
    "end": "1360080"
  },
  {
    "text": "that's compared to the object's age and anything that's equal or greater to that age is then promoted into the old",
    "start": "1360080",
    "end": "1365919"
  },
  {
    "text": "generation so not only is the promotion rate",
    "start": "1365919",
    "end": "1372480"
  },
  {
    "text": "something that dictates the collection frequency of old generation also the size of the old generation",
    "start": "1372480",
    "end": "1378480"
  },
  {
    "text": "space dictates the frequency of old generation collection this makes",
    "start": "1378480",
    "end": "1385120"
  },
  {
    "text": "sense right so if you have a certain amount of space",
    "start": "1385120",
    "end": "1390640"
  },
  {
    "text": "you've got a static size there it fills at some rate if i make it bigger it fills at a slower rate",
    "start": "1390640",
    "end": "1397440"
  },
  {
    "text": "okay so how do i reduce old generation collection frequency",
    "start": "1398080",
    "end": "1404400"
  },
  {
    "text": "so the strategies here for reducing the promotion rate is a more effective object aging it's",
    "start": "1404400",
    "end": "1410720"
  },
  {
    "text": "leveraging what you can do in the survivor spaces so in hotspot you start tuning this",
    "start": "1410720",
    "end": "1416480"
  },
  {
    "text": "thing called the survivor ratio and what you're striving to do is you're",
    "start": "1416480",
    "end": "1421600"
  },
  {
    "text": "striving to promote objects at what's called the max 10 ring threshold the jvm the hotspot jvm will choose a",
    "start": "1421600",
    "end": "1428840"
  },
  {
    "text": "default max tendering threshold or you can set one explicitly at the command line you could",
    "start": "1428840",
    "end": "1436000"
  },
  {
    "text": "also increase the size of the eden space by increasing",
    "start": "1436000",
    "end": "1441440"
  },
  {
    "text": "the value that you set for the young generation size minus xmn or through max new size new size",
    "start": "1441440",
    "end": "1448799"
  },
  {
    "text": "what this will do is it causes minor gcs to occur less frequently which means that the age of the object",
    "start": "1448799",
    "end": "1455760"
  },
  {
    "text": "increments more slowly remember the age of the object is the number of minor gcs",
    "start": "1455760",
    "end": "1461520"
  },
  {
    "text": "that it survived so if i have less frequent gcs occurring minor gc is occurring that",
    "start": "1461520",
    "end": "1467919"
  },
  {
    "text": "age increments slowly which gives a longer period of time for the object to age",
    "start": "1467919",
    "end": "1473440"
  },
  {
    "text": "in the survivor space another one here is reducing the object allocation rate",
    "start": "1473440",
    "end": "1479520"
  },
  {
    "text": "again when you reduce the object allocation rate your minor gcs occur less frequently and",
    "start": "1479520",
    "end": "1485520"
  },
  {
    "text": "your object age increments slower",
    "start": "1485520",
    "end": "1490000"
  },
  {
    "text": "so another strategy here for reducing the promotion rate is to reduce the object retention so",
    "start": "1492559",
    "end": "1498720"
  },
  {
    "text": "similar to what i talked about in the case of young generation you have fewer objects to promote into",
    "start": "1498720",
    "end": "1504960"
  },
  {
    "text": "old generation from the minor gc events this is also going to reduce the",
    "start": "1504960",
    "end": "1511200"
  },
  {
    "text": "required survivor space size that you need to avoid early promotions what i mean by early",
    "start": "1511200",
    "end": "1517279"
  },
  {
    "text": "promotions is you've got a certain size that you've designated for survivor space",
    "start": "1517279",
    "end": "1522960"
  },
  {
    "text": "if there's more objects that are still alive at the end of a minor gc that can fit in the survivor space they",
    "start": "1522960",
    "end": "1530480"
  },
  {
    "text": "are going to get overflowed into or promoted early or prematurely into old generation",
    "start": "1530480",
    "end": "1537039"
  },
  {
    "text": "that's what i mean by early promotion",
    "start": "1537039",
    "end": "1542240"
  },
  {
    "text": "you also reduce object retention you can also benefit from a reduced frequency of minor gcs which",
    "start": "1542240",
    "end": "1548400"
  },
  {
    "text": "allows objects to age longer so pretty much what i just said so the",
    "start": "1548400",
    "end": "1556240"
  },
  {
    "text": "other approach here that you could take is well i could make old generation size bigger as a way to reduce the",
    "start": "1556240",
    "end": "1561919"
  },
  {
    "text": "old generation collection frequency so as an example here this is very",
    "start": "1561919",
    "end": "1567919"
  },
  {
    "text": "similar to what i did here with the illustration of young generation suppose i've got an old generation size of three gigabyte i double its size to",
    "start": "1567919",
    "end": "1575120"
  },
  {
    "text": "six gigabyte same promotion rate i get a 2x increase",
    "start": "1575120",
    "end": "1580640"
  },
  {
    "text": "in the old generation space the time between old generation collections increases by 2x",
    "start": "1580640",
    "end": "1586400"
  },
  {
    "text": "pretty straightforward pretty obvious i think so the choices for increasing the size",
    "start": "1586400",
    "end": "1593200"
  },
  {
    "text": "of the old generation and the hotspot jvm for parallel gc cms gc and serial gc",
    "start": "1593200",
    "end": "1599760"
  },
  {
    "text": "you increase the initial end max java heap sizes and then you keep",
    "start": "1599760",
    "end": "1605360"
  },
  {
    "text": "the young generation sizing the same so in other words if you're using this xmn or",
    "start": "1605360",
    "end": "1611039"
  },
  {
    "text": "the max and new size or the survivor ratios you keep them at their same values so you preserve the sizing of young",
    "start": "1611039",
    "end": "1617360"
  },
  {
    "text": "generation so that you're only increasing the size of old generation for g1 gc",
    "start": "1617360",
    "end": "1624960"
  },
  {
    "text": "this may require an increase in both the initial and max java heap size and initiate the and also increasing the",
    "start": "1624960",
    "end": "1632960"
  },
  {
    "text": "initiating heap occupancy percent so this initiating heap occupancy percent is the threshold at which",
    "start": "1632960",
    "end": "1639760"
  },
  {
    "text": "it triggers an old generation collection",
    "start": "1639760",
    "end": "1644880"
  },
  {
    "text": "so another way that you can reduce old generation collection frequency is to lower the old generation occupancy",
    "start": "1649279",
    "end": "1655919"
  },
  {
    "text": "after the collection so in other words i want to have less space occupied in",
    "start": "1655919",
    "end": "1661200"
  },
  {
    "text": "old generation after the collection completes to give me more free space above it",
    "start": "1661200",
    "end": "1667120"
  },
  {
    "text": "for promotions to go into so it takes longer for that space to fill so this is a form",
    "start": "1667120",
    "end": "1673840"
  },
  {
    "text": "of lowering object retention as i mentioned that there's more space available to fill after the old",
    "start": "1673840",
    "end": "1679840"
  },
  {
    "text": "generation collection this is a similar approach that you'd use for reducing object",
    "start": "1679840",
    "end": "1685279"
  },
  {
    "text": "retention that i described earlier so you end up profiling the application you look for objects that are",
    "start": "1685279",
    "end": "1690880"
  },
  {
    "text": "unnecessarily kept alive longer than they need to be",
    "start": "1690880",
    "end": "1697840"
  },
  {
    "start": "1697000",
    "end": "1782000"
  },
  {
    "text": "so what about the frequency of concurrent collections so reducing the frequency of a",
    "start": "1698000",
    "end": "1704000"
  },
  {
    "text": "concurrent collection cycle and old generation your choices are you could increase the",
    "start": "1704000",
    "end": "1710240"
  },
  {
    "text": "occupancy threshold that initiates a concurrent cycle this is going to reduce the amount of",
    "start": "1710240",
    "end": "1716159"
  },
  {
    "text": "cpu cycles that you're using for gc over the life of the application",
    "start": "1716159",
    "end": "1722960"
  },
  {
    "text": "but there's a caveat a trade-off with this as you may run out of available old generation space",
    "start": "1723360",
    "end": "1729600"
  },
  {
    "text": "and you don't want to lose this race so what i mean by losing the race is you have this rate at which objects are",
    "start": "1729600",
    "end": "1735840"
  },
  {
    "text": "getting promoted into old generation from the survivor spaces you have this concurrent collector",
    "start": "1735840",
    "end": "1741840"
  },
  {
    "text": "that's trying to run along and free additional space at the same time so you don't want to lose the race with the",
    "start": "1741840",
    "end": "1748159"
  },
  {
    "text": "promotion rate in the hot spot cms gc",
    "start": "1748159",
    "end": "1753679"
  },
  {
    "text": "the way that you do this is you tune this initiating heap occupancy fraction",
    "start": "1753679",
    "end": "1758799"
  },
  {
    "text": "and i'd also suggest that you use this additional command line option this use cms initiating occupancy only which says",
    "start": "1758799",
    "end": "1765200"
  },
  {
    "text": "i want you to use this heap occupancy fraction always as the threshold at which to",
    "start": "1765200",
    "end": "1771520"
  },
  {
    "text": "start or trigger an old generation collection in g1 gc",
    "start": "1771520",
    "end": "1777600"
  },
  {
    "text": "you would use this initiating keep occupancy percent",
    "start": "1777600",
    "end": "1782240"
  },
  {
    "start": "1782000",
    "end": "1863000"
  },
  {
    "text": "okay fourth concept the duration of old",
    "start": "1782720",
    "end": "1788000"
  },
  {
    "text": "generation collections so here i'm making the distinction between a full gc",
    "start": "1788000",
    "end": "1793679"
  },
  {
    "text": "and an old generation collection this is oftentimes confusing for people",
    "start": "1793679",
    "end": "1799919"
  },
  {
    "text": "so a full gc may involve collecting and compacting both the young generation and the old",
    "start": "1799919",
    "end": "1806480"
  },
  {
    "text": "generation and this happens to be the default behavior for the hotspot jvm so if somebody says a full gc in the",
    "start": "1806480",
    "end": "1813600"
  },
  {
    "text": "hotspot jvm it means i'm collecting both young generation and old generation",
    "start": "1813600",
    "end": "1820159"
  },
  {
    "text": "i'm calling an old generation collection i'm only collecting old generation",
    "start": "1820159",
    "end": "1828000"
  },
  {
    "text": "i'm not necessarily compacting the old generation so in other words if i don't compact if all i'm doing is",
    "start": "1828000",
    "end": "1833600"
  },
  {
    "text": "just freeing space i may have a whole bunch of holes in this java heap and old generation",
    "start": "1833600",
    "end": "1840960"
  },
  {
    "text": "i may have some object that gets promoted but yet the old generation space is",
    "start": "1840960",
    "end": "1846960"
  },
  {
    "text": "fragmented to the point where i can't find a hole large enough to promote what i an object that i'm trying",
    "start": "1846960",
    "end": "1852159"
  },
  {
    "text": "to promote from young generation so i'm not including compaction in this description of old generation",
    "start": "1852159",
    "end": "1858240"
  },
  {
    "text": "collection",
    "start": "1858240",
    "end": "1860720"
  },
  {
    "start": "1863000",
    "end": "1953000"
  },
  {
    "text": "okay so the duration of an old generation collection so similar to a minor gc the number of live objects",
    "start": "1863519",
    "end": "1871200"
  },
  {
    "text": "has the strongest influence on the old generation collection duration there's other things here too that can",
    "start": "1871200",
    "end": "1877679"
  },
  {
    "text": "contribute to old generation collection just like we saw with minor gcs",
    "start": "1877679",
    "end": "1883360"
  },
  {
    "text": "reference objects weak soft phantom or final a note here",
    "start": "1883360",
    "end": "1889919"
  },
  {
    "text": "that soft references can also influence the old generation collection frequency",
    "start": "1889919",
    "end": "1895600"
  },
  {
    "text": "because soft references the basic idea is you're saying you know i've got a bunch",
    "start": "1895600",
    "end": "1901519"
  },
  {
    "text": "of this free space in the java heap with the soft reference it basically is",
    "start": "1901519",
    "end": "1906799"
  },
  {
    "text": "suggesting i don't want you to free that space until i'm under pressure",
    "start": "1906799",
    "end": "1912000"
  },
  {
    "text": "with available space in the java heap so it in essence says i'm going to use",
    "start": "1912000",
    "end": "1918640"
  },
  {
    "text": "that additional space for something like the temptation for a lot of people is",
    "start": "1918640",
    "end": "1923760"
  },
  {
    "text": "is to implement caches object caches with soft references if you want me to get agitated ask me",
    "start": "1923760",
    "end": "1931120"
  },
  {
    "text": "about soft references as an object cache that's a hot button with me okay",
    "start": "1931120",
    "end": "1939200"
  },
  {
    "text": "i break it off of that one the other thing that can impact old",
    "start": "1939200",
    "end": "1944799"
  },
  {
    "text": "generation collection duration is obviously memory locality you know it's the same sorts of things that i talked about with",
    "start": "1944799",
    "end": "1950559"
  },
  {
    "text": "young generation collections so for old generation",
    "start": "1950559",
    "end": "1955760"
  },
  {
    "start": "1953000",
    "end": "2141000"
  },
  {
    "text": "what you really desire and are looking for is you want it to be dominated by the time it takes to mark live objects and if the",
    "start": "1955760",
    "end": "1963200"
  },
  {
    "text": "gc also does compaction then you also want the majority of its time to be spent",
    "start": "1963200",
    "end": "1969200"
  },
  {
    "text": "somewhere between i should say it this way you want the time to be dominated by the time it",
    "start": "1969200",
    "end": "1975200"
  },
  {
    "text": "takes to mark live objects and if it does compaction that should be the second most amount of",
    "start": "1975200",
    "end": "1980480"
  },
  {
    "text": "time spent so the hotspot parallel gc and serial gc",
    "start": "1980480",
    "end": "1986720"
  },
  {
    "text": "mark live objects and they compact them they're known as what's called a mark compact collector",
    "start": "1986720",
    "end": "1993440"
  },
  {
    "text": "these gc's all also happen to be called stop the world collectors for both young and old generation collectors",
    "start": "1993440",
    "end": "2001120"
  },
  {
    "text": "for most for the mostly concurrent collectors you desire your time for the old",
    "start": "2002080",
    "end": "2008240"
  },
  {
    "text": "generation collection to be dominated by the time it takes to mark live objects notice that the majority of your time",
    "start": "2008240",
    "end": "2015600"
  },
  {
    "text": "spent marking objects is probably going to be done concurrently while the application is running",
    "start": "2015600",
    "end": "2021039"
  },
  {
    "text": "you may pause the application to do the initial mark you may pause it again to do a remark to",
    "start": "2021039",
    "end": "2027279"
  },
  {
    "text": "go back and mark the objects that you missed while the application was executing while you were doing the",
    "start": "2027279",
    "end": "2032799"
  },
  {
    "text": "concurrent marking that's a very common practice with the cms gc and g1 gc",
    "start": "2032799",
    "end": "2040240"
  },
  {
    "text": "so one of the caveats with not doing compaction which is one of the things that cms gc",
    "start": "2041919",
    "end": "2048158"
  },
  {
    "text": "doesn't do it's known as a marked sweep collector",
    "start": "2048159",
    "end": "2053358"
  },
  {
    "text": "you may run into this situation i described earlier where you've got this fragmented java heap",
    "start": "2053359",
    "end": "2058480"
  },
  {
    "text": "and it results in what's called a promotion failure and what cms gc does in this case is it",
    "start": "2058480",
    "end": "2063760"
  },
  {
    "text": "resorts to doing a stop the world full gc",
    "start": "2063760",
    "end": "2068559"
  },
  {
    "text": "so on the g1 garbage collector hotspot achieves this compaction by",
    "start": "2070240",
    "end": "2076320"
  },
  {
    "text": "evacuating live objects from a number of what's called regions so in",
    "start": "2076320",
    "end": "2082240"
  },
  {
    "text": "g1 it divides the java heap up into equal sized regions and then they're designated as either",
    "start": "2082240",
    "end": "2088638"
  },
  {
    "text": "young generation regions or old generations so in an old generation collection it picks a set of",
    "start": "2088639",
    "end": "2095280"
  },
  {
    "text": "old generation regions to evacuate into other available",
    "start": "2095280",
    "end": "2103280"
  },
  {
    "text": "regions and then they're designated as old generation regions the evacuation copy time is where you",
    "start": "2103280",
    "end": "2110000"
  },
  {
    "text": "want g1 to spend most of its time outside of the marking so when it does",
    "start": "2110000",
    "end": "2115280"
  },
  {
    "text": "marking it's going to mark the entire old generation area once that marking is complete on the",
    "start": "2115280",
    "end": "2121440"
  },
  {
    "text": "next minor gc it will pick a set of old generation regions to collect",
    "start": "2121440",
    "end": "2126560"
  },
  {
    "text": "at the same time as the minor gc and it's during that stop the world phase where you want g1 to be spending most of",
    "start": "2126560",
    "end": "2133440"
  },
  {
    "text": "its time in evacuation in other words copying that object",
    "start": "2133440",
    "end": "2139680"
  },
  {
    "start": "2141000",
    "end": "2299000"
  },
  {
    "text": "okay so what can be done to reduce old generation collection pause times",
    "start": "2142079",
    "end": "2147440"
  },
  {
    "text": "similar to what we saw for young generation you know faster memory faster cpu faster system if it's a stop the world",
    "start": "2147440",
    "end": "2155280"
  },
  {
    "text": "collector you're working with maybe a faster stop the world collector",
    "start": "2155280",
    "end": "2160480"
  },
  {
    "text": "maybe you switch over to using a concurrent collector and like we saw with the young generation case",
    "start": "2160560",
    "end": "2167200"
  },
  {
    "text": "you may have some additional cpu consumption here which could reduce peak throughput it could also reduce the",
    "start": "2167200",
    "end": "2174000"
  },
  {
    "text": "available capacity of the system it may also require some additional memory to handle the floating garbage",
    "start": "2174000",
    "end": "2179920"
  },
  {
    "text": "that you have as you're marking",
    "start": "2179920",
    "end": "2184240"
  },
  {
    "text": "so the other thing that you can do here is you have fewer live objects in old generation the idea here is that",
    "start": "2185760",
    "end": "2191839"
  },
  {
    "text": "again garbage collector is only going to mark live objects and copy or evacuate live objects",
    "start": "2191839",
    "end": "2201839"
  },
  {
    "text": "so a summary of the concurrent old generation collection trade-offs are",
    "start": "2202720",
    "end": "2207839"
  },
  {
    "text": "what you're gaining mostly with a concurrent collector is the lower gc pause time so you get this improved",
    "start": "2207839",
    "end": "2212960"
  },
  {
    "text": "latency so here i'm tying this back to the performance attributes what you're sacrificing and giving up is",
    "start": "2212960",
    "end": "2220400"
  },
  {
    "text": "you're usually going to give up some java heap so you're going to use a little bit more memory you can have a little bit more footprint",
    "start": "2220400",
    "end": "2226079"
  },
  {
    "text": "here you're probably going to use a little more cpu so you may be inhibiting some on the capacity",
    "start": "2226079",
    "end": "2232880"
  },
  {
    "text": "so the translation here is for the improved latency you're sacrificing something in at least",
    "start": "2232880",
    "end": "2238320"
  },
  {
    "text": "one of these or possibly all three of the footprint the throughput and the capacity",
    "start": "2238320",
    "end": "2245760"
  },
  {
    "text": "and as i said earlier that may be fine for some applications it may make people pretty sensitive in",
    "start": "2245760",
    "end": "2252960"
  },
  {
    "text": "others it depends on the application and the stakeholders as to what's most important to them",
    "start": "2252960",
    "end": "2259680"
  },
  {
    "text": "so for strategies in this last one of the fewer live objects",
    "start": "2261839",
    "end": "2267520"
  },
  {
    "text": "well we could create a larger old generation space maybe that would help well possibly",
    "start": "2268720",
    "end": "2275200"
  },
  {
    "text": "in general if we increase the size it allows more objects to die an example here where this would work is",
    "start": "2275359",
    "end": "2283200"
  },
  {
    "text": "if the length of a typical application transaction is greater than the time between the old generation collections",
    "start": "2283200",
    "end": "2290560"
  },
  {
    "text": "then increasing the size of the old generation could reduce the number of live objects that are marked during an",
    "start": "2290560",
    "end": "2295839"
  },
  {
    "text": "old generation collection so i think that that's pretty",
    "start": "2295839",
    "end": "2300960"
  },
  {
    "start": "2299000",
    "end": "2663000"
  },
  {
    "text": "straightforward so that would be a case where it could help you okay so moving on to a summary here so",
    "start": "2300960",
    "end": "2308720"
  },
  {
    "text": "the thing i'd like you to take away from the session is i'd like you to think about gc in terms",
    "start": "2308720",
    "end": "2314000"
  },
  {
    "text": "of the garbage collection frequency and duration that you're trying to meet",
    "start": "2314000",
    "end": "2319280"
  },
  {
    "text": "for both the young generation and the old generation collections and also if you think about the impact",
    "start": "2319280",
    "end": "2326480"
  },
  {
    "text": "of a footprint latency throughput and capacity you can start to reason",
    "start": "2326480",
    "end": "2334960"
  },
  {
    "text": "about the different choices that you have and as you make a given action what the",
    "start": "2334960",
    "end": "2340000"
  },
  {
    "text": "consequences of taking that action is going to be and in the end hopefully it gets you to",
    "start": "2340000",
    "end": "2345760"
  },
  {
    "text": "the point where you're able to realize your capacity goals throughput goals footprint goals and",
    "start": "2345760",
    "end": "2351359"
  },
  {
    "text": "throughput goals for your application some credits to give here a huge thank",
    "start": "2351359",
    "end": "2357359"
  },
  {
    "text": "you to all of the hotspot gct members past and present countless others past and present from the hotspot jvm team",
    "start": "2357359",
    "end": "2364960"
  },
  {
    "text": "i've been working with the hotspot jvm team for well i'm approaching 15 years now an",
    "start": "2364960",
    "end": "2371440"
  },
  {
    "text": "enormous amount of things that i've learned from from the members on that team",
    "start": "2371440",
    "end": "2377119"
  },
  {
    "text": "last slide and i promise here some additional reading material here",
    "start": "2377440",
    "end": "2382640"
  },
  {
    "text": "obviously the java performance book my publisher would be very happy that i mentioned this today",
    "start": "2382640",
    "end": "2388800"
  },
  {
    "text": "you can buy this book tomorrow on informant.com for under twenty dollars",
    "start": "2388800",
    "end": "2395520"
  },
  {
    "text": "there's a new book out by scott oakes called java performance the definitive guide i've known scott for about 15 years had",
    "start": "2395520",
    "end": "2403520"
  },
  {
    "text": "had the pleasure working daily with scott for probably five years i continue to work with scott today",
    "start": "2403520",
    "end": "2410560"
  },
  {
    "text": "scott is one of those guys that his information when he puts it out in",
    "start": "2410560",
    "end": "2416960"
  },
  {
    "text": "print i find that it's very easy to understand it's very easy to",
    "start": "2416960",
    "end": "2423040"
  },
  {
    "text": "to digest and interpret what he's saying the way that i would look at scott's book compared to mine",
    "start": "2423040",
    "end": "2428240"
  },
  {
    "text": "is i think that they're very complementary to each other if you want to get into a lot of the gory details about the jvm",
    "start": "2428240",
    "end": "2435200"
  },
  {
    "text": "and garbage collectors and jvm tuning you'll find that in my book if you want a little bit higher level perspective",
    "start": "2435200",
    "end": "2442400"
  },
  {
    "text": "you can look at scott's book there's certainly pieces in scots that are not in mine that's why i would say that they're",
    "start": "2442400",
    "end": "2447760"
  },
  {
    "text": "complimentary if you want to know anything and everything about garbage collection garbage collection of other",
    "start": "2447760",
    "end": "2454319"
  },
  {
    "text": "languages the book to have is the garbage collection handbook by jones",
    "start": "2454319",
    "end": "2460640"
  },
  {
    "text": "anybody who is a gc engineer or a gc junkie has a copy of this book it's",
    "start": "2460640",
    "end": "2466960"
  },
  {
    "text": "probably one of my more favorite books okay i'll leave that slide here we've",
    "start": "2466960",
    "end": "2474079"
  },
  {
    "text": "got about five minutes unless people are anxious to get out and grab a bite to eat okay thank you",
    "start": "2474079",
    "end": "2481359"
  },
  {
    "text": "charlie uh all right questions who wants to go oh uh oh here we go we",
    "start": "2481359",
    "end": "2488480"
  },
  {
    "text": "have uh is it an easy one so what do you think about caching objects and soft",
    "start": "2488480",
    "end": "2494400"
  },
  {
    "text": "references oh you got that hold him down",
    "start": "2494400",
    "end": "2502240"
  },
  {
    "text": "we've had this discussion so for for the people in the audience that",
    "start": "2505520",
    "end": "2510720"
  },
  {
    "text": "are not familiar with gil this is guiltanay from azul systems and we participate in several different",
    "start": "2510720",
    "end": "2517440"
  },
  {
    "text": "online forums and such where this actual discussion came up one time",
    "start": "2517440",
    "end": "2523200"
  },
  {
    "text": "about soft references and using them as caches and object caches the the biggest",
    "start": "2523200",
    "end": "2529440"
  },
  {
    "text": "problem that i see with soft references as a cache is it's unfortunate that the java doc",
    "start": "2529440",
    "end": "2534960"
  },
  {
    "text": "suggests this idea from a performance standpoint",
    "start": "2534960",
    "end": "2541359"
  },
  {
    "text": "there's a couple of issues here one of them i touched on briefly and that is",
    "start": "2541440",
    "end": "2547440"
  },
  {
    "text": "if you're using a soft reference you're basically saying okay i want to use more java heap space",
    "start": "2547440",
    "end": "2553760"
  },
  {
    "text": "but that basically is starting to say okay i've now got more work for the garbage collector to",
    "start": "2553760",
    "end": "2560480"
  },
  {
    "text": "do which increases the duration of gc i'm also going to get a gc more",
    "start": "2560480",
    "end": "2566240"
  },
  {
    "text": "frequently so that kind of goes against the frequency of gcs and something that i'm",
    "start": "2566240",
    "end": "2571359"
  },
  {
    "text": "trying to you know i may be trying to avoid but what i think is more i think as eve",
    "start": "2571359",
    "end": "2578160"
  },
  {
    "text": "in my opinion i think is probably the biggest challenge with soft references is there's not a specification that says",
    "start": "2578160",
    "end": "2584880"
  },
  {
    "text": "here is exactly how soft references should be processed even within the same jvm if you have a",
    "start": "2584880",
    "end": "2593200"
  },
  {
    "text": "soft reference object cache you use parallel gc and you move to cms gc",
    "start": "2593200",
    "end": "2598720"
  },
  {
    "text": "you're going to get different behavior if you move to g1 gc you'll get different behavior of that object cache",
    "start": "2598720",
    "end": "2604480"
  },
  {
    "text": "if you move to a different jvm say it's j rocket or azul zing you're going to get different",
    "start": "2604480",
    "end": "2610800"
  },
  {
    "text": "characteristics if you move to j9 it's going to behave differently so why you know my reaction to that is",
    "start": "2610800",
    "end": "2617599"
  },
  {
    "text": "why would i build an object cache where i'm at the mercy of the jvm's gc implementation that",
    "start": "2617599",
    "end": "2623599"
  },
  {
    "text": "dictates the behavior of my object cache",
    "start": "2623599",
    "end": "2628000"
  },
  {
    "text": "other questions any other takers",
    "start": "2630079",
    "end": "2635839"
  },
  {
    "text": "going once going this is your chance folks all right",
    "start": "2638079",
    "end": "2644400"
  },
  {
    "text": "i think everybody's hungry i think i think we're all at standing between people and food so maybe we",
    "start": "2644400",
    "end": "2650640"
  },
  {
    "text": "should stop doing that all right thank you everybody thanks",
    "start": "2650640",
    "end": "2657039"
  },
  {
    "text": "everyone you",
    "start": "2660839",
    "end": "2665440"
  }
]