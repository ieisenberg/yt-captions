[
  {
    "start": "0",
    "end": "65000"
  },
  {
    "text": "[Music] thank you",
    "start": "3670",
    "end": "8940"
  },
  {
    "text": "thank you thank you all thanks for attending uh it's it's it's great to be",
    "start": "8940",
    "end": "14519"
  },
  {
    "text": "a well it's it's a it's a Pity I can't be in Australia for with you uh I would",
    "start": "14519",
    "end": "19619"
  },
  {
    "text": "really have liked to but uh it's it's never that it's great to be able to give this online conference so what I wanted",
    "start": "19619",
    "end": "26580"
  },
  {
    "text": "to talk about is a particular aspect of scholar 3 probably the biggest thing",
    "start": "26580",
    "end": "33300"
  },
  {
    "text": "we've redesigned and that's implicit implicit is probably uh sort of a one of",
    "start": "33300",
    "end": "40200"
  },
  {
    "text": "the biggest uh defining features of Scala a little bit it wasn't planned",
    "start": "40200",
    "end": "45660"
  },
  {
    "text": "that way I will I will talk more about that but it came to be that way over time and uh while we did that uh there",
    "start": "45660",
    "end": "54300"
  },
  {
    "text": "were a lot there were a few sort of forks in the roads and stumbling blocks and rocks over which we fell and I'm",
    "start": "54300",
    "end": "61199"
  },
  {
    "text": "also going to tell you about those so the talk is implicits Revisited and I want to start by saying well",
    "start": "61199",
    "end": "68040"
  },
  {
    "start": "65000",
    "end": "103000"
  },
  {
    "text": "implicit in Scala are really everywhere and we have proof for that there's a paper at Upstate 2019 which has analyzed",
    "start": "68040",
    "end": "76680"
  },
  {
    "text": "seven thousand uh 280 projects 80 millimets of code uh 8 million and",
    "start": "76680",
    "end": "81900"
  },
  {
    "text": "implicit call sites were found in 370 000 implicit declarations so 98 of all",
    "start": "81900",
    "end": "88439"
  },
  {
    "text": "projects uh scalar projects use implicits 78 Define implicits and 27 of",
    "start": "88439",
    "end": "94979"
  },
  {
    "text": "call sites are implicit cards uh which is uh quite a lot so it's really one of",
    "start": "94979",
    "end": "100259"
  },
  {
    "text": "the heavy most heavily used features of scada uh they're everywhere but it's fair to",
    "start": "100259",
    "end": "107159"
  },
  {
    "start": "103000",
    "end": "130000"
  },
  {
    "text": "say they're also probably the most controversial feature of Scala because uh well a lot of people uh got bloody",
    "start": "107159",
    "end": "114060"
  },
  {
    "text": "noses using them uh they are competing designs that are also very elegant like Haskell's type classes that some people",
    "start": "114060",
    "end": "121200"
  },
  {
    "text": "prefer and so the implicit sort of had to find a place in the world and uh what",
    "start": "121200",
    "end": "127619"
  },
  {
    "text": "I want to do is uh look a little bit back in time and uh essentially talk",
    "start": "127619",
    "end": "135900"
  },
  {
    "text": "tell you how implicits came to be about how essentially implicits were discovered because that was more or less",
    "start": "135900",
    "end": "142440"
  },
  {
    "text": "what it was we stumbled on them and also some of the mistakes we made so that's sort of me being on a rock glancing out",
    "start": "142440",
    "end": "149340"
  },
  {
    "text": "in the distance in the mountains says oh my God if if only I could turn back time and do things better but maybe with",
    "start": "149340",
    "end": "155879"
  },
  {
    "text": "scatter 3 we have a chance now so this talk covers how implicits became what they are today some design",
    "start": "155879",
    "end": "162840"
  },
  {
    "text": "decisions that turned out to be mistakes and also where I really want to want to essentially emphasize some design",
    "start": "162840",
    "end": "169680"
  },
  {
    "text": "decisions that turned out to be right in the end and a redesign three",
    "start": "169680",
    "end": "174720"
  },
  {
    "start": "174000",
    "end": "238000"
  },
  {
    "text": "so the history of implicits were actually the first step towards implicits were implicit conversions",
    "start": "174720",
    "end": "180959"
  },
  {
    "text": "which is kind of ironic because implicit conversions now are considered to be the most problematic feature of implicits",
    "start": "180959",
    "end": "187560"
  },
  {
    "text": "but they were the first so in 2004 the first color version ships with implicit conversions why is that why add such a",
    "start": "187560",
    "end": "195480"
  },
  {
    "text": "powerful feature so the motivation was that essentially I was sort of puzzling for a long time over The Late extension",
    "start": "195480",
    "end": "203159"
  },
  {
    "text": "problem which was like a big problem at the time I was talking to guy Steele about that who also was working on that",
    "start": "203159",
    "end": "209040"
  },
  {
    "text": "so what is the late extension problem the late extension problem is that if you have a class and a trait or",
    "start": "209040",
    "end": "215519"
  },
  {
    "text": "interface how can we make the class extends the trade after the fact I so",
    "start": "215519",
    "end": "221580"
  },
  {
    "text": "essentially you can change neither the code of the class nor the interface how can you make the class extend the trend",
    "start": "221580",
    "end": "228000"
  },
  {
    "text": "well essentially nowadays you would say type classes but at the time we were firmly in an object-oriented setting so",
    "start": "228000",
    "end": "233819"
  },
  {
    "text": "this was a really hard problem and um the so so-called solution that we",
    "start": "233819",
    "end": "241019"
  },
  {
    "start": "238000",
    "end": "289000"
  },
  {
    "text": "in eventually came up with after discarding many many other possibilities and going into dead ends was implicit",
    "start": "241019",
    "end": "248040"
  },
  {
    "text": "conversions that we say we cannot extend the class C after the fact also the fact that we were on the jbm we had really",
    "start": "248040",
    "end": "254099"
  },
  {
    "text": "hard limitations in what magic we could pull with the byte with the with the with the native code so by codes were",
    "start": "254099",
    "end": "260940"
  },
  {
    "text": "very very harsh format um so we cannot extend see after the fact but we can extend create an",
    "start": "260940",
    "end": "268139"
  },
  {
    "text": "automatic wrapper and that's very powerful that essentially solves the late extension problem to some degree",
    "start": "268139",
    "end": "273720"
  },
  {
    "text": "but the downside is it's also easy to misuse but hey at the time Scala had",
    "start": "273720",
    "end": "278880"
  },
  {
    "text": "maybe five users or something like that so it wasn't deemed a problem at the time that it was easy to misuse so",
    "start": "278880",
    "end": "287040"
  },
  {
    "text": "that's how conversions came about and then two years later implicit parameters were introduced and",
    "start": "287040",
    "end": "294360"
  },
  {
    "start": "289000",
    "end": "324000"
  },
  {
    "text": "that was sort of more or less by because it was easy because once we had the",
    "start": "294360",
    "end": "301320"
  },
  {
    "text": "basics of implicit resolution that means that if you need to find something that's implicit essentially how do you",
    "start": "301320",
    "end": "306600"
  },
  {
    "text": "go about that and and find it where do you search and all these all these rules uh it's tempting to once you have those",
    "start": "306600",
    "end": "313259"
  },
  {
    "text": "rules to also do something to have implicit parameters with it the Delta is relatively small and the expressive",
    "start": "313259",
    "end": "320520"
  },
  {
    "text": "power cutting would include type classes some version of that classes so I want",
    "start": "320520",
    "end": "325800"
  },
  {
    "text": "to take you back in time to demonstrate to a talk I gave in 2006 at the Ife",
    "start": "325800",
    "end": "331080"
  },
  {
    "text": "working group of functional programming in Boston and those were the original",
    "start": "331080",
    "end": "336300"
  },
  {
    "text": "slides with some of my annotations of today so the title of the talk was Poor Man's",
    "start": "336300",
    "end": "343199"
  },
  {
    "text": "type classes that was what essentially implicits where where labeled Daniel that was my my my term for them so the",
    "start": "343199",
    "end": "351780"
  },
  {
    "start": "350000",
    "end": "410000"
  },
  {
    "text": "goals are type classes are nice a cottage industry of Haskell programmers has sprung up around them can be asked",
    "start": "351780",
    "end": "358560"
  },
  {
    "text": "ad type classes to all languages specifically Scala so all languages triple question triple exclamation mark",
    "start": "358560",
    "end": "365460"
  },
  {
    "text": "at the time Scala was firmly an oo language it was an oo language with",
    "start": "365460",
    "end": "370560"
  },
  {
    "text": "functional features and it sort of morphed into sort of a more of a fusion",
    "start": "370560",
    "end": "375600"
  },
  {
    "text": "that essentially is is more uh stands on both legs and more and more as we",
    "start": "375600",
    "end": "380639"
  },
  {
    "text": "progress we emphasize the functional Parts the problem with uh at the time is",
    "start": "380639",
    "end": "385860"
  },
  {
    "text": "that the problem with that is the conceptual expense we have a bit tongue-in-cheek already spent about",
    "start": "385860",
    "end": "391860"
  },
  {
    "text": "keywords type and class so type classes out and also you can observe the type",
    "start": "391860",
    "end": "397380"
  },
  {
    "text": "classes are essentially implicitly past dictionary and dictionaries are essentially objects and we don't want to duplicate that so we concentrated just",
    "start": "397380",
    "end": "404880"
  },
  {
    "text": "on the Delta between oo glasses and type classes and that led us to implicits so",
    "start": "404880",
    "end": "410220"
  },
  {
    "start": "410000",
    "end": "441000"
  },
  {
    "text": "then I essentially introduced the implicit parameters that was like the very first example where you see here",
    "start": "410220",
    "end": "415979"
  },
  {
    "text": "the implicit parameter of a monohe and here it gets",
    "start": "415979",
    "end": "421560"
  },
  {
    "text": "by the the it gets inserted by the compiler so the red code is the code",
    "start": "421560",
    "end": "426900"
  },
  {
    "text": "that the compiler inserts here so we can combine normal implicit parameters however there may be only one implicit",
    "start": "426900",
    "end": "432900"
  },
  {
    "text": "parameter list and it must come last that's also a restriction that has proved to be annoying over the time and",
    "start": "432900",
    "end": "438479"
  },
  {
    "text": "that we will remove in Scatter 3. so then it goes on and says implicit can",
    "start": "438479",
    "end": "443819"
  },
  {
    "start": "441000",
    "end": "455000"
  },
  {
    "text": "also be used as a modifier for definitions like for the string Monitor and money objects there and then there's",
    "start": "443819",
    "end": "451380"
  },
  {
    "text": "the canonicalistic sample wherever you pass the int money implicitly okay and then comes the fine print so",
    "start": "451380",
    "end": "458039"
  },
  {
    "start": "455000",
    "end": "510000"
  },
  {
    "text": "how do how I implicit reserved resolved so we say Okay an argument for an",
    "start": "458039",
    "end": "463440"
  },
  {
    "text": "implicit parameter of type T if it's missing it's inferred and an argument value is eligible to be passed if it's",
    "start": "463440",
    "end": "471060"
  },
  {
    "text": "labeled implicit its type is compatible with the parameter type and now it comes one of the following holes X is",
    "start": "471060",
    "end": "478199"
  },
  {
    "text": "accessible at the point of call by a simple identifier I that is it's defined",
    "start": "478199",
    "end": "483300"
  },
  {
    "text": "in the same scope inherited or imported or it's defined as a static value in some superclass of T So a member of the",
    "start": "483300",
    "end": "490259"
  },
  {
    "text": "companion object uh if several arguments are eligible to choose a more specific one and if no",
    "start": "490259",
    "end": "496199"
  },
  {
    "text": "more specifically eligible argument exists type error so what's striking",
    "start": "496199",
    "end": "501419"
  },
  {
    "text": "with this definition is that it's really very very simple so I could could put it on one slide and it's it's perfectly",
    "start": "501419",
    "end": "508020"
  },
  {
    "text": "nice it was actually optimized for being simple and that has proved to be a",
    "start": "508020",
    "end": "513839"
  },
  {
    "text": "problem because essentially this uh one phrase that captures it all that it says",
    "start": "513839",
    "end": "519180"
  },
  {
    "text": "contextually places as just those implicits that are accessible at the point of call by by a simple identifier",
    "start": "519180",
    "end": "526260"
  },
  {
    "text": "that has turned out to be to to cause a lot of problems and we'll see what",
    "start": "526260",
    "end": "531300"
  },
  {
    "text": "problems it it did cause okay and then the the other thing is uh",
    "start": "531300",
    "end": "536940"
  },
  {
    "start": "533000",
    "end": "630000"
  },
  {
    "text": "then I go and talk about coherence or locality so a consequence of implicit",
    "start": "536940",
    "end": "542700"
  },
  {
    "text": "argument resolution is that one can have several instance definitions of the same operations at the same type and we",
    "start": "542700",
    "end": "548940"
  },
  {
    "text": "always pick the one which is visible at the point of talk call if that's a unique one and uh that's an important",
    "start": "548940",
    "end": "555420"
  },
  {
    "text": "difference which was acknowledged at the time between implicits and type classes so the the rules to keep coherence which",
    "start": "555420",
    "end": "563100"
  },
  {
    "text": "is essentially the local coherence that means basically unambiguity the the important rule here is that in",
    "start": "563100",
    "end": "571440"
  },
  {
    "text": "Scala we distinguish between functions which are objects function values and methods which are not objects and",
    "start": "571440",
    "end": "578220"
  },
  {
    "text": "partially applied object methods are automatically converted to functions by a process called ETA expansion",
    "start": "578220",
    "end": "584880"
  },
  {
    "text": "and we say only methods but not functions can contain implicit parameters so that means implicit parameters are instantiated where a",
    "start": "584880",
    "end": "592019"
  },
  {
    "text": "method value is eliminated either applied or converted to a function and that has actually turned out to be also",
    "start": "592019",
    "end": "598680"
  },
  {
    "text": "more or less by accident the biggest win of implicits because that's the one thing where implicit parameters in scada",
    "start": "598680",
    "end": "604800"
  },
  {
    "text": "are different from implicit parameters in Haskell and implicit parameters in Haskell are actually quite unpredictable",
    "start": "604800",
    "end": "609959"
  },
  {
    "text": "and to know small reasons because they don't follow exactly the same principle",
    "start": "609959",
    "end": "615540"
  },
  {
    "text": "they do something for polymorphic values and another thing for monomorphic ones and it's very hard to essentially figure",
    "start": "615540",
    "end": "621600"
  },
  {
    "text": "out when these implicit parameters in Haskell are instantiated and that's I believe also why nobody uses them in",
    "start": "621600",
    "end": "627600"
  },
  {
    "text": "hasker or very few people use them okay then it goes on and uh it gives the",
    "start": "627600",
    "end": "634440"
  },
  {
    "start": "630000",
    "end": "649000"
  },
  {
    "text": "standard examples about conditional implicit so you can have list monoids if you have mono it's over the elements and",
    "start": "634440",
    "end": "640260"
  },
  {
    "text": "here's the code and here's the instantiation which is of course a recursive instantiation of implicit",
    "start": "640260",
    "end": "646260"
  },
  {
    "text": "instances parameterized by other implicit instances okay so in retrospect uh going forward",
    "start": "646260",
    "end": "654480"
  },
  {
    "start": "649000",
    "end": "703000"
  },
  {
    "text": "to today what uh what did we get right so I think what we did get right and",
    "start": "654480",
    "end": "661079"
  },
  {
    "text": "what I what we will continue to do is leave the following points that type",
    "start": "661079",
    "end": "667140"
  },
  {
    "text": "classes are types nothing else not not essentially as another thing that lives",
    "start": "667140",
    "end": "672360"
  },
  {
    "text": "outside the type pearls dictionaries are just values no magic about them instances can be can be defined anywhere",
    "start": "672360",
    "end": "679880"
  },
  {
    "text": "local instances are possible no Global coherence requirement and the",
    "start": "679880",
    "end": "685800"
  },
  {
    "text": "relationship with ETA expansion that I mentioned before that implicits are passed in the expanding context which",
    "start": "685800",
    "end": "691079"
  },
  {
    "text": "actually makes them in my experience extremely robust from from that perspective that you say when",
    "start": "691079",
    "end": "696980"
  },
  {
    "text": "essentially what what implicit value does flow into this thing it's it's very predictable because of that rule",
    "start": "696980",
    "end": "703740"
  },
  {
    "start": "703000",
    "end": "727000"
  },
  {
    "text": "okay so what were the mistakes so I believe the mistake number one was depending on the names so there was this",
    "start": "703740",
    "end": "711779"
  },
  {
    "text": "class that I repeat uh one of the following holes X is accessible at the point of call by a simple identifier it",
    "start": "711779",
    "end": "718380"
  },
  {
    "text": "is defined in the same scope inherited or imported very simple rule to express but very confusing consequences so what",
    "start": "718380",
    "end": "725940"
  },
  {
    "text": "what are the consequences well the first one is that names matter where they shouldn't and shadowing is a problem so",
    "start": "725940",
    "end": "732480"
  },
  {
    "text": "here is an example you have an implicit value of a and then you have a function that happens to be a parameter of the",
    "start": "732480",
    "end": "738540"
  },
  {
    "text": "same value and then you can't find the type TC as an implicit anymore because you have something called shadowing so",
    "start": "738540",
    "end": "745680"
  },
  {
    "text": "that means that well it it does find the TC here uh implicit search finds it but",
    "start": "745680",
    "end": "751860"
  },
  {
    "text": "then there's actually a special check that says well could I refer to this value a just a very simple name where I",
    "start": "751860",
    "end": "758279"
  },
  {
    "text": "am and the answer is no because the simple name would actually refer to the parameter and not to the implicit so so",
    "start": "758279",
    "end": "764040"
  },
  {
    "text": "that implicit fails and that's a Pity because essentially the implicits are implicits because implicits are implicit",
    "start": "764040",
    "end": "770399"
  },
  {
    "text": "the name shouldn't matter but here they do um the second mistake related to this I",
    "start": "770399",
    "end": "777300"
  },
  {
    "start": "772000",
    "end": "810000"
  },
  {
    "text": "believe is that nesting did not matter so this one gives an ambiguity if you have an implicit vowel a of a type class",
    "start": "777300",
    "end": "784320"
  },
  {
    "text": "and a function that takes an implicit evidence of the same type class and you do you call implicitly of the type class",
    "start": "784320",
    "end": "791040"
  },
  {
    "text": "and you get an ambiguity because now you have two names in scope the A and the EV and they're both are of type TC so you",
    "start": "791040",
    "end": "798180"
  },
  {
    "text": "have to be very careful to actually always use the same name and that's sort of an extraneous requirement which is",
    "start": "798180",
    "end": "804420"
  },
  {
    "text": "from a user point of view a little bit bizarre so that was I believe mistake number two and mistake number two also",
    "start": "804420",
    "end": "812399"
  },
  {
    "start": "810000",
    "end": "894000"
  },
  {
    "text": "means that coherence is a real problem so there was a paper by other belchang and and some others uh on uh essentially",
    "start": "812399",
    "end": "820440"
  },
  {
    "text": "why coherence is a problem uh in in Scala also from a point of",
    "start": "820440",
    "end": "825959"
  },
  {
    "text": "expressiveness so not just from a point of essentially uni uniform and safety so",
    "start": "825959",
    "end": "832260"
  },
  {
    "text": "the example they gave were essentially a um you had a function f",
    "start": "832260",
    "end": "838880"
  },
  {
    "text": "which had a type parameter F that was both a monad and a Traverse and Monarch",
    "start": "838880",
    "end": "845220"
  },
  {
    "text": "and Traverse are two type classes that both extend functor and functor has a map instance and then you want to call a",
    "start": "845220",
    "end": "852180"
  },
  {
    "text": "map from this function f so the question is should you get this map instance from monad or should we get it from Traverse",
    "start": "852180",
    "end": "858899"
  },
  {
    "text": "of course you say well it doesn't matter they both got the map instance from functor and it's hopefully the same but",
    "start": "858899",
    "end": "865620"
  },
  {
    "text": "without a global coherence argument compiler cannot be sure so maybe",
    "start": "865620",
    "end": "871079"
  },
  {
    "text": "jumping through a lot of Hoops we could get it get there but right now the answer is no it cannot be sure so that's",
    "start": "871079",
    "end": "878519"
  },
  {
    "text": "a that's ambiguous and that's very annoying because it means you have to essentially pass explicit dictionaries",
    "start": "878519",
    "end": "884880"
  },
  {
    "text": "at some points uh where where and you have passed more and more of them the more complex your type class hierarchy",
    "start": "884880",
    "end": "891360"
  },
  {
    "text": "gets so the obvious um fix for that would be to say hey yeah",
    "start": "891360",
    "end": "897360"
  },
  {
    "text": "let me just disambiguate it let's just say here locally my functor should be",
    "start": "897360",
    "end": "902399"
  },
  {
    "text": "demonet it doesn't matter I'd be a compiler it's more than Traverse have the same Funk instance but that's only I",
    "start": "902399",
    "end": "909240"
  },
  {
    "text": "as a programmer now that you as a compiler don't know know that so let me tell you let me just say you could",
    "start": "909240",
    "end": "914519"
  },
  {
    "text": "assume the function is the moment and in current Scala that doesn't work because it's even more ambiguous and if than the",
    "start": "914519",
    "end": "921540"
  },
  {
    "text": "than the previous one because now we have essentially this local functor and the Monarch here and the Traverse over",
    "start": "921540",
    "end": "928260"
  },
  {
    "text": "there and they all compete for the implicit value because nesting does not matter with nesting with nesting would",
    "start": "928260",
    "end": "934680"
  },
  {
    "text": "matter of course the function would take precedence and the problem would be solved okay the mistake number three I think um",
    "start": "934680",
    "end": "941940"
  },
  {
    "text": "what is is less serious but uh but still annoying is I believe we have uh similar",
    "start": "941940",
    "end": "949800"
  },
  {
    "text": "Syntax for quite different concepts and that's very confusing so in particular implicit conversions and implicit",
    "start": "949800",
    "end": "955380"
  },
  {
    "text": "instances look just so alike so here the first one that's an implicit conversion",
    "start": "955380",
    "end": "960839"
  },
  {
    "text": "called a and the second one that's a conditional implicit so if you say condition implicit conversion should be",
    "start": "960839",
    "end": "967740"
  },
  {
    "text": "avoided and I agree to that and on the other hand conditional implicits are",
    "start": "967740",
    "end": "972839"
  },
  {
    "text": "everywhere then it's very confusing that the two looks so much alike and for essentially newcomers and Casual users",
    "start": "972839",
    "end": "979680"
  },
  {
    "text": "it's very hard to keep them apart and I think the the fourth mistake uh is",
    "start": "979680",
    "end": "987360"
  },
  {
    "start": "984000",
    "end": "1091000"
  },
  {
    "text": "that implicit parameters are too close to normal ones and that was also basically the reason the the reason for",
    "start": "987360",
    "end": "993660"
  },
  {
    "text": "that was that initially we took a shortcut we didn't want to introduce more complexity from the outset so the",
    "start": "993660",
    "end": "999959"
  },
  {
    "text": "shortcut was that we said well if we have an implicit parameter and you want to pass it explicitly which you should",
    "start": "999959",
    "end": "1006980"
  },
  {
    "text": "be able to then you just write a normal application right so uh but that leads",
    "start": "1006980",
    "end": "1012259"
  },
  {
    "text": "you into problems in cases like this where you have a function and the function takes an implicit parameter EV",
    "start": "1012259",
    "end": "1017420"
  },
  {
    "text": "and it returns a function value and you would just want to apply it you want to pass the implicit value implicitly as",
    "start": "1017420",
    "end": "1025280"
  },
  {
    "text": "they are supposed to do and you want to apply F to some value of type uh you",
    "start": "1025280",
    "end": "1030558"
  },
  {
    "text": "can't write F of U right now because that gives you a type error because it mistakes the U for the implicit",
    "start": "1030559",
    "end": "1037339"
  },
  {
    "text": "parameter and it says well that's not the right type what you can write is f dot apply you because now you have made",
    "start": "1037339",
    "end": "1042860"
  },
  {
    "text": "it clear to the compiler that f is really what you really want is the function value F which you want to apply",
    "start": "1042860",
    "end": "1048860"
  },
  {
    "text": "to the U and then the component says oh I have to pass the implicit value and to get to the function value and there you",
    "start": "1048860",
    "end": "1055640"
  },
  {
    "text": "go so that means that implicitness is a leaky abstraction it really shows that",
    "start": "1055640",
    "end": "1061220"
  },
  {
    "text": "normally if things are implicit you should never be worried about to essentially uh that that you you that",
    "start": "1061220",
    "end": "1068240"
  },
  {
    "text": "they might get into your normal application flow and things like that but here they do and the reason for that",
    "start": "1068240",
    "end": "1073820"
  },
  {
    "text": "is again to essentially to say well initially we didn't want to add too many uh complications in there so we want to",
    "start": "1073820",
    "end": "1082880"
  },
  {
    "text": "pair implicit parameters with just regular calls we didn't want to invent a separate syntax for those calls so I",
    "start": "1082880",
    "end": "1089419"
  },
  {
    "text": "think that was a mistake as well so taken together implicit star it is a way to express",
    "start": "1089419",
    "end": "1096080"
  },
  {
    "start": "1091000",
    "end": "1130000"
  },
  {
    "text": "conversions and we generalize the mechanism to provide type classes extension methods and many other kinds",
    "start": "1096080",
    "end": "1102679"
  },
  {
    "text": "of contextual information the mechanism is impressively flexible and Powerful so compared to let's say a",
    "start": "1102679",
    "end": "1109700"
  },
  {
    "text": "more direct type class approach the difference is really here we expose the mechanism and that gives you more power",
    "start": "1109700",
    "end": "1115940"
  },
  {
    "text": "because the mechanism can do other things than you uh you uh defined on the",
    "start": "1115940",
    "end": "1121100"
  },
  {
    "text": "high level on the other hand the mechanism often tends to hide the intent and the over architecture of what you do",
    "start": "1121100",
    "end": "1128179"
  },
  {
    "text": "so that's a problem with it okay so now I come to Scala three it's a",
    "start": "1128179",
    "end": "1134720"
  },
  {
    "start": "1130000",
    "end": "1170000"
  },
  {
    "text": "major redesign of the language it's built on well-desearched Research foundations uh named dot which is a",
    "start": "1134720",
    "end": "1141500"
  },
  {
    "text": "dependent object calculus and its emphasis is on making it easier to use and making it safer to use uh the first",
    "start": "1141500",
    "end": "1148520"
  },
  {
    "text": "stable release will come out later this year there's a research prototype Dotty",
    "start": "1148520",
    "end": "1154460"
  },
  {
    "text": "that's been elaborated over almost seven years now the last seven years and 30 is",
    "start": "1154460",
    "end": "1159860"
  },
  {
    "text": "morphing into scada which you see with this logo here so the on the top you have 30 and it's it's sort of flowing",
    "start": "1159860",
    "end": "1166100"
  },
  {
    "text": "into Scala and hopefully we will be done by the end of this year",
    "start": "1166100",
    "end": "1171140"
  },
  {
    "start": "1170000",
    "end": "1285000"
  },
  {
    "text": "so the one of the biggest changes in Escada 3 is revisiting implicits with",
    "start": "1171140",
    "end": "1177500"
  },
  {
    "text": "essentially or in hindsight with all everything we've learned that essentially what we didn't realize at",
    "start": "1177500",
    "end": "1183440"
  },
  {
    "text": "the time is how important there would be they would become uh initially Scala didn't have them once it had them it had",
    "start": "1183440",
    "end": "1190220"
  },
  {
    "text": "them in more restricted forms and now essentially you you they are everywhere so it's time to",
    "start": "1190220",
    "end": "1198380"
  },
  {
    "text": "essentially rethink them from the ground up and if you rethink them from the ground up then",
    "start": "1198380",
    "end": "1203840"
  },
  {
    "text": "I think that the core concept really is term inference so we we know type in",
    "start": "1203840",
    "end": "1209240"
  },
  {
    "text": "front so Scarlet is a language that does type in France uh and implicit search is",
    "start": "1209240",
    "end": "1214640"
  },
  {
    "text": "really analogous to that only now the compiler infers a term",
    "start": "1214640",
    "end": "1220100"
  },
  {
    "text": "uh from what does it or an expression I should say term term is sort of expert lingo uh for for expressions or values",
    "start": "1220100",
    "end": "1228320"
  },
  {
    "text": "so what does the compiler use to infer a term well it uses the type so I say I",
    "start": "1228320",
    "end": "1234919"
  },
  {
    "text": "want to type I want an implicit value of a certain type I just want to summon that that value and the compiler",
    "start": "1234919",
    "end": "1242480"
  },
  {
    "text": "produces the canonical term for that so we trade types for terms we give the",
    "start": "1242480",
    "end": "1247580"
  },
  {
    "text": "compiler the type and we get back the term so the idea now is that instead of adding sorry implicit as a modifier to",
    "start": "1247580",
    "end": "1255740"
  },
  {
    "text": "many different constructs and tweaking the meaning of each in slightly different ways we want to have a single",
    "start": "1255740",
    "end": "1261500"
  },
  {
    "text": "construct to introduce a designated term or expression that can be inferred for a",
    "start": "1261500",
    "end": "1266900"
  },
  {
    "text": "type so we want to bundle it all in one concept and say okay there should be a syntactic construct that say it says if",
    "start": "1266900",
    "end": "1273440"
  },
  {
    "text": "you want to infer the term for that type then essentially here's how you define a candidate term for for doing that and we",
    "start": "1273440",
    "end": "1281000"
  },
  {
    "text": "call these candidate terms implicit given instances or just Givens",
    "start": "1281000",
    "end": "1286280"
  },
  {
    "start": "1285000",
    "end": "1540000"
  },
  {
    "text": "so here's an uh introductory example pretty much standard one for the for ordering so",
    "start": "1286280",
    "end": "1294020"
  },
  {
    "text": "let's say we have a trade audit of T and it has a compare method and it has uh",
    "start": "1294020",
    "end": "1300500"
  },
  {
    "text": "less than greater methods and then we have an implicit instance into ort which",
    "start": "1300500",
    "end": "1307100"
  },
  {
    "text": "is an ordered of int and it redefines the compared method which was missing up there and then we have a conditional",
    "start": "1307100",
    "end": "1314059"
  },
  {
    "text": "implicit instance list order of T that uses uh the fact that ort must be that t",
    "start": "1314059",
    "end": "1320840"
  },
  {
    "text": "must be ordered to prove that list of T is ordered so that's how you write it given list order of T using or that's an",
    "start": "1320840",
    "end": "1329960"
  },
  {
    "text": "implicit parameter of type order of t as order of list of T and then you define",
    "start": "1329960",
    "end": "1335120"
  },
  {
    "text": "the compare so what's different is we don't say this is a function or an object or whatever we just say well this",
    "start": "1335120",
    "end": "1341600"
  },
  {
    "text": "is how you essentially synthesize the given instance for this for this uh for",
    "start": "1341600",
    "end": "1347299"
  },
  {
    "text": "for this type and we want to abstract intentionally a little bit on what",
    "start": "1347299",
    "end": "1352700"
  },
  {
    "text": "exactly will come out here it suffices to say well there will be some form of values that essentially will have the",
    "start": "1352700",
    "end": "1359299"
  },
  {
    "text": "the necessary methods but how you get those values I mean you can figure it out there's a guide Tower what what gets",
    "start": "1359299",
    "end": "1365240"
  },
  {
    "text": "produced but it shouldn't you be your primary concern your primary concern should be essentially what are",
    "start": "1365240",
    "end": "1370820"
  },
  {
    "text": "essentially the the types that are instances of a a type class that is",
    "start": "1370820",
    "end": "1376700"
  },
  {
    "text": "represented by a trade okay so this was still a little bit",
    "start": "1376700",
    "end": "1382700"
  },
  {
    "text": "verbose but as I said before for implicits the names don't really matter so we can leave them out so we can also",
    "start": "1382700",
    "end": "1389720"
  },
  {
    "text": "have a given instance where we just say given order of int so int is ordered and here's the compare method and we can say",
    "start": "1389720",
    "end": "1396860"
  },
  {
    "text": "given order of list of T where T is ordered that's just a good good old context bound that we had before as well",
    "start": "1396860",
    "end": "1404360"
  },
  {
    "text": "and here's the compare method so that's essentially how how would you you would usually write that and if you write that",
    "start": "1404360",
    "end": "1411080"
  },
  {
    "text": "the compiler will just synthesize names for uh for for the for the Givens here",
    "start": "1411080",
    "end": "1416620"
  },
  {
    "text": "which usually don't matter because you don't really need to reference them",
    "start": "1416620",
    "end": "1422059"
  },
  {
    "text": "explicitly okay so those were those correspond to",
    "start": "1422059",
    "end": "1427580"
  },
  {
    "text": "essentially if you look at what you did before essentially given objects and given classes with Creator methods and",
    "start": "1427580",
    "end": "1433940"
  },
  {
    "text": "things like that uh but uh given instances can also be aliases so that",
    "start": "1433940",
    "end": "1439280"
  },
  {
    "text": "you can see by just the the equal here so we can say well for instance here",
    "start": "1439280",
    "end": "1444679"
  },
  {
    "text": "give a given let's name it Global as an execution context equals a fork join",
    "start": "1444679",
    "end": "1450080"
  },
  {
    "text": "pool so that means now you have an implicit called Global of type execution context in the instantiated to be a fork",
    "start": "1450080",
    "end": "1457760"
  },
  {
    "text": "joint pool or if there can be anonymous for instance you could say in this scope the given position should be the",
    "start": "1457760",
    "end": "1464179"
  },
  {
    "text": "position of the enclosing tree or there could be actually quite complex as well so for instance here we say the given",
    "start": "1464179",
    "end": "1470360"
  },
  {
    "text": "context assuming that out an outer context outer is the outer context with",
    "start": "1470360",
    "end": "1475820"
  },
  {
    "text": "a new owner called current owner something like that okay and the last part of it is now",
    "start": "1475820",
    "end": "1483679"
  },
  {
    "text": "we've we've we've seen how to define these given instances how do we use them so there's also difference now so",
    "start": "1483679",
    "end": "1490400"
  },
  {
    "text": "instead of implicit we write using uh for essentially using this means that a",
    "start": "1490400",
    "end": "1496220"
  },
  {
    "text": "function uses uh an implicit term uh instance it inferred for a type so the",
    "start": "1496220",
    "end": "1503480"
  },
  {
    "text": "max function uses the fact that t must be ordered and the evidence for that for",
    "start": "1503480",
    "end": "1508940"
  },
  {
    "text": "that or effect is called ORD that's the parameter and essentially it has the usual implementation so implicit",
    "start": "1508940",
    "end": "1516740"
  },
  {
    "text": "parameters are passing using clauses and they can be anonymous so I could",
    "start": "1516740",
    "end": "1523100"
  },
  {
    "text": "also write using order of T if I don't need to refer to the parameter directly for instance because all I need to do",
    "start": "1523100",
    "end": "1529820"
  },
  {
    "text": "with the parameter is pass it on as an implicit to further methods then I could just write using order of T which is the",
    "start": "1529820",
    "end": "1536000"
  },
  {
    "text": "normal case so again I can leave out the name",
    "start": "1536000",
    "end": "1541520"
  },
  {
    "start": "1540000",
    "end": "1603000"
  },
  {
    "text": "um I can these parameters then of course they are inferred as usual so I can just",
    "start": "1541520",
    "end": "1546740"
  },
  {
    "text": "write Max 2 3 or Max of list of one two three nil for instance and but I can",
    "start": "1546740",
    "end": "1552980"
  },
  {
    "text": "pass them as well and if I pass them then uh the argument syntax has to",
    "start": "1552980",
    "end": "1559220"
  },
  {
    "text": "mirror the parameter syntax so I have to use using as well which solves this abstraction leakage problem I referred",
    "start": "1559220",
    "end": "1565760"
  },
  {
    "text": "to earlier that essentially normal calls are confused with uh explicit arguments so here that's no longer the case if you",
    "start": "1565760",
    "end": "1572419"
  },
  {
    "text": "want to pass an ordering to the max function you have to write using again and of course you can do that",
    "start": "1572419",
    "end": "1578179"
  },
  {
    "text": "recursively so you can also pass an into or to a list order if you want",
    "start": "1578179",
    "end": "1584360"
  },
  {
    "text": "whereas you cannot do this anymore so you can't just write Max 2 3 into it because that date would say well the",
    "start": "1584360",
    "end": "1591740"
  },
  {
    "text": "maximum function doesn't take any more further parameters because uh all it does take is implicit parameters in",
    "start": "1591740",
    "end": "1598460"
  },
  {
    "text": "using classes and you can't pass user normal parameter clause for that",
    "start": "1598460",
    "end": "1603679"
  },
  {
    "text": "okay so let's see how it would work for type classes so here's a simple example uh the standard one with semi group and",
    "start": "1603679",
    "end": "1610400"
  },
  {
    "text": "monoid so it really works works actually quite well out of the box with extension",
    "start": "1610400",
    "end": "1616039"
  },
  {
    "text": "methods so here's how you would write semi group of T you would say well we",
    "start": "1616039",
    "end": "1621559"
  },
  {
    "text": "have an infix method combined which works on an X sorry on the left hand side and a y on the right hand side and",
    "start": "1621559",
    "end": "1629419"
  },
  {
    "text": "returns a t and then we have a monoid which is a semi group and it has a unit",
    "start": "1629419",
    "end": "1634880"
  },
  {
    "text": "method and then we have a Monet instance of string where we say our combined",
    "start": "1634880",
    "end": "1641360"
  },
  {
    "text": "method is just string concat sorry there's a stray open parent that was a typo and then we have I think the unit",
    "start": "1641360",
    "end": "1649039"
  },
  {
    "text": "method is is just the empty string that's another typo sorry I've fixed those like last late last night",
    "start": "1649039",
    "end": "1655700"
  },
  {
    "text": "so um then the sum method then would would look like this it would just say fold",
    "start": "1655700",
    "end": "1661279"
  },
  {
    "text": "left over the list of excess of plus T where T's ammonites and we say sum and",
    "start": "1661279",
    "end": "1666440"
  },
  {
    "text": "monoid of T of unit so we get essentially the monoid instance and we get unit with a little bit more",
    "start": "1666440",
    "end": "1672559"
  },
  {
    "text": "boilerplate and and auxiliary definitions I could make that nicer but uh now with with the raw code all I had",
    "start": "1672559",
    "end": "1679640"
  },
  {
    "text": "I need the implicit explicit sum in here and then use combine as the combining",
    "start": "1679640",
    "end": "1684799"
  },
  {
    "text": "function so what what what's missing here is essentially all the jumping",
    "start": "1684799",
    "end": "1691880"
  },
  {
    "text": "through hoops to get infix syntax for type classes which",
    "start": "1691880",
    "end": "1697039"
  },
  {
    "text": "currently is a big big problem that's why packages like similar Chrome exist and that's all gone away because",
    "start": "1697039",
    "end": "1703940"
  },
  {
    "text": "essentially type classes and extension methods integrate very well with each other each other what you need in",
    "start": "1703940",
    "end": "1709880"
  },
  {
    "text": "particular is that an extension method can be abstract like you see in the example here so it can actually be part",
    "start": "1709880",
    "end": "1716360"
  },
  {
    "text": "of a type class which is represented by a trade Okay so we've seen summon so summon is",
    "start": "1716360",
    "end": "1723799"
  },
  {
    "start": "1720000",
    "end": "1762000"
  },
  {
    "text": "the new implicitly so it can be defined quite quite simply like this so summon",
    "start": "1723799",
    "end": "1729460"
  },
  {
    "text": "uses an implicit parameter of type T and it Returns the parameter itself it's a",
    "start": "1729460",
    "end": "1735380"
  },
  {
    "text": "its type is a little bit better than the type of implicitly be the type of the return type of implicitly would be T in",
    "start": "1735380",
    "end": "1741260"
  },
  {
    "text": "this case whereas the return type of sum and it's really x dot type which matters sometimes when you work with path",
    "start": "1741260",
    "end": "1748460"
  },
  {
    "text": "dependent types you have a better type for the the thing you're searching here I I believe summon is exactly what in",
    "start": "1748460",
    "end": "1754640"
  },
  {
    "text": "shapeless would be called the so that's that's the the way to to summon implicit",
    "start": "1754640",
    "end": "1760760"
  },
  {
    "text": "value in shapeless finally let me get to conversions so",
    "start": "1760760",
    "end": "1766600"
  },
  {
    "start": "1762000",
    "end": "1824000"
  },
  {
    "text": "implicit conversions with implicit deaths would be no longer supported if basically all users of implicits will be",
    "start": "1766600",
    "end": "1773179"
  },
  {
    "text": "dropped instead of that we will have a conversion type class",
    "start": "1773179",
    "end": "1778840"
  },
  {
    "text": "which has in instances like this so conversion is defined in in the Scala",
    "start": "1778840",
    "end": "1784820"
  },
  {
    "text": "package and you can have for instance to convert a string to a token you would write my given there's a given",
    "start": "1784820",
    "end": "1791360"
  },
  {
    "text": "conversion from string to token where the apply method takes a string into token and essentially wraps the string",
    "start": "1791360",
    "end": "1797059"
  },
  {
    "text": "in a keyword wrapper or you can use an alias given that's makes it shorter",
    "start": "1797059",
    "end": "1802399"
  },
  {
    "text": "where you say that my given conversion of string to token is just the keyword to wrap up so that just uses same types",
    "start": "1802399",
    "end": "1809179"
  },
  {
    "text": "for for for mapping the Lambda into into the conversion",
    "start": "1809179",
    "end": "1815539"
  },
  {
    "text": "okay those conversions um are um yeah okay let me just uh go on",
    "start": "1815539",
    "end": "1822980"
  },
  {
    "text": "in the interest of time so there were there are also many many polishings so I",
    "start": "1822980",
    "end": "1828200"
  },
  {
    "start": "1824000",
    "end": "1893000"
  },
  {
    "text": "showed you most of the surface and the syntax how you express things uh but there are lots of improvements in",
    "start": "1828200",
    "end": "1833960"
  },
  {
    "text": "details so given instances and parameters can all be anonymous we've seen that nesting is significant",
    "start": "1833960",
    "end": "1839840"
  },
  {
    "text": "shadowing is eliminated so the previous problems that I mentioned are restricted",
    "start": "1839840",
    "end": "1845240"
  },
  {
    "text": "um we have a more robust priorities prioritization of implicits which means",
    "start": "1845240",
    "end": "1850460"
  },
  {
    "text": "you don't need to go back to essentially these elaborate type class uh sorry a class or trade",
    "start": "1850460",
    "end": "1857360"
  },
  {
    "text": "hierarchies where low low priority implicits go into Super trades so there",
    "start": "1857360",
    "end": "1862399"
  },
  {
    "text": "are other ways to do that now there are a lot the the error messages have improved quite a bit and I believe the",
    "start": "1862399",
    "end": "1868820"
  },
  {
    "text": "most important thing is that if an implicit is missing now the compiler gives you an import suggestion so it",
    "start": "1868820",
    "end": "1874220"
  },
  {
    "text": "will essentially look on everything you have you might want to import this implicit or this given over over here and that",
    "start": "1874220",
    "end": "1882200"
  },
  {
    "text": "will might solve the problem and that essentially gets I I found gets me unstuck a lot of time when I work with",
    "start": "1882200",
    "end": "1888440"
  },
  {
    "text": "code I don't know and I got the same feedback from other people so for the migration uh the current",
    "start": "1888440",
    "end": "1896600"
  },
  {
    "start": "1893000",
    "end": "1990000"
  },
  {
    "text": "implicits are still supported in scada 3. there will be probably be deprecated",
    "start": "1896600",
    "end": "1902360"
  },
  {
    "text": "from scalar three one on um so they have to be supporting scanner three because Scala three is uh",
    "start": "1902360",
    "end": "1908799"
  },
  {
    "text": "expressively wants to support cross-building between two and three uh so uh it should be binary compatible so",
    "start": "1908799",
    "end": "1916460"
  },
  {
    "text": "we will share the same standard library and the same binary artifacts and it should be possible to to cross build",
    "start": "1916460",
    "end": "1923140"
  },
  {
    "text": "libraries and and applications between two and three so that's why basically",
    "start": "1923140",
    "end": "1928220"
  },
  {
    "text": "everything that we have in two or most things we have into are still supported in three only things where it really was",
    "start": "1928220",
    "end": "1934460"
  },
  {
    "text": "too awkward to do that uh so but in the future they will probably be deprecated so if I would",
    "start": "1934460",
    "end": "1940100"
  },
  {
    "text": "write a book on scalar 3 or teaching materials in scholar 3 I would not mention the word implicit anymore so",
    "start": "1940100",
    "end": "1946039"
  },
  {
    "text": "because there will be they will be gone a while later um there's some special Provisions for",
    "start": "1946039",
    "end": "1952760"
  },
  {
    "text": "for cross compilation uh the most important one is that the given arguments also work for old style",
    "start": "1952760",
    "end": "1959320"
  },
  {
    "text": "implicits so that means I can use a using class even when I call into an old",
    "start": "1959320",
    "end": "1965360"
  },
  {
    "text": "style method that takes an implicit parameter and not a using class uh can I yet take a using argument and that's",
    "start": "1965360",
    "end": "1972080"
  },
  {
    "text": "important because that means I can first convert the users of libraries to the",
    "start": "1972080",
    "end": "1978020"
  },
  {
    "text": "new version you call using using everywhere and then I can bring over the library safely and map implicit",
    "start": "1978020",
    "end": "1985100"
  },
  {
    "text": "parameters to using classes and without breaking all the user code okay",
    "start": "1985100",
    "end": "1990620"
  },
  {
    "text": "so try it out it's at Dotty epfl.ch",
    "start": "1990620",
    "end": "1996019"
  },
  {
    "text": "um we still have five minutes left at five to ten minutes left so I I just want to do go quickly into another thing",
    "start": "1996080",
    "end": "2003039"
  },
  {
    "text": "that might be on have have been on your mind if you paid attention and those are is the topic of optional prices which is",
    "start": "2003039",
    "end": "2009940"
  },
  {
    "start": "2005000",
    "end": "2037000"
  },
  {
    "text": "also something that's new in scada three so you might have noticed that our scatter code got a lot Slimmer uh curly",
    "start": "2009940",
    "end": "2017019"
  },
  {
    "text": "braces and parentheses are now optional in many more places and generally left out and instead of braces one can use",
    "start": "2017019",
    "end": "2024159"
  },
  {
    "text": "indented blocks and that has caught a lot of angst and outrage in people so I",
    "start": "2024159",
    "end": "2031299"
  },
  {
    "text": "want to sort of explain a little bit what's going on and uh what what you can",
    "start": "2031299",
    "end": "2036399"
  },
  {
    "text": "expect so the fact is that there's actually a lot of code variation today in Scala so here you have some arbitrary",
    "start": "2036399",
    "end": "2045279"
  },
  {
    "start": "2037000",
    "end": "2158000"
  },
  {
    "text": "Scala code and summarize it like this they put the prices here",
    "start": "2045279",
    "end": "2050440"
  },
  {
    "text": "um some of us including late lately lately",
    "start": "2050440",
    "end": "2056020"
  },
  {
    "text": "when I was using braces I I really disliked the else behind the closing",
    "start": "2056020",
    "end": "2061358"
  },
  {
    "text": "brace because essentially the else should be something that introduces a new section it shouldn't hide behind a",
    "start": "2061359",
    "end": "2066398"
  },
  {
    "text": "brace so I wrote it like this spending an extra line okay so you can do that some people also leave out the prices if",
    "start": "2066399",
    "end": "2073780"
  },
  {
    "text": "there's a simple statement uh because then the prices are",
    "start": "2073780",
    "end": "2079179"
  },
  {
    "text": "really use useless they're just essentially noise the problem with that is that once you add another statement",
    "start": "2079179",
    "end": "2085780"
  },
  {
    "text": "and you have to remember to put the braces back in or you will get surprises in the in the in the compiler in the",
    "start": "2085780",
    "end": "2092440"
  },
  {
    "text": "compiler methods and error messages and of course there's no real uniformity",
    "start": "2092440",
    "end": "2099040"
  },
  {
    "text": "in where you put the the parents and things like that so some people like to write to parents immediately after the",
    "start": "2099040",
    "end": "2104440"
  },
  {
    "text": "years some people write a space and so on so that's uh my point is there's a there's a lot of syntax variation today",
    "start": "2104440",
    "end": "2111880"
  },
  {
    "text": "and people don't get upset about it they said that that's okay we we can have a",
    "start": "2111880",
    "end": "2118720"
  },
  {
    "text": "format that uses our favorite style but we acknowledge the different styles and what we also allow now is uh this that",
    "start": "2118720",
    "end": "2126520"
  },
  {
    "text": "we say well you can leave out the braces you can leave them in or you can leave them out or even better you can also",
    "start": "2126520",
    "end": "2133119"
  },
  {
    "text": "leave out the parents if you follow this this thing with that then so you can write it like this and um",
    "start": "2133119",
    "end": "2140260"
  },
  {
    "text": "other uses of what we allow now is 404 so you don't need to braces around here",
    "start": "2140260",
    "end": "2146820"
  },
  {
    "text": "and for a while for a match for a try so all these things can be written without",
    "start": "2146820",
    "end": "2153099"
  },
  {
    "text": "prices just with what we call quiet syntax so optional braces uh like what I've",
    "start": "2153099",
    "end": "2161560"
  },
  {
    "start": "2158000",
    "end": "2341000"
  },
  {
    "text": "shown you are very convert controversial so we've added the twist as an experimental feature and I've now used it heavily for more than half of a year",
    "start": "2161560",
    "end": "2169000"
  },
  {
    "text": "yeah I think almost nine months I guess and I must say the experience has been",
    "start": "2169000",
    "end": "2174520"
  },
  {
    "text": "positive for me beyond what I ever expected it's I for me it's actually the single most important way house color 3",
    "start": "2174520",
    "end": "2182440"
  },
  {
    "text": "improved my productivity and also my joy of coding it's just so liberating not to",
    "start": "2182440",
    "end": "2187780"
  },
  {
    "text": "have to do these these prices anymore so uh the my uh slogan here is",
    "start": "2187780",
    "end": "2196420"
  },
  {
    "text": "indentation is really like Lego bricks and braces are like bailing wires so indentation you just you just put things",
    "start": "2196420",
    "end": "2202540"
  },
  {
    "text": "where you where they should go at the proper place and that's it you just plug them together and you don't need to",
    "start": "2202540",
    "end": "2209560"
  },
  {
    "text": "think about more further than that whereas with braces it's sort of like you put this this one thing here and",
    "start": "2209560",
    "end": "2216040"
  },
  {
    "text": "it's okay and then you put a second thing here and now I have to wrap this whole thing because otherwise it will",
    "start": "2216040",
    "end": "2221440"
  },
  {
    "text": "fall apart and this wrapping thing is is essentially like a bailing wire of some a bunch of hay or something like that",
    "start": "2221440",
    "end": "2227680"
  },
  {
    "text": "and braces look like that already so they really are like that so anyway so uh there's also measurable",
    "start": "2227680",
    "end": "2235480"
  },
  {
    "text": "improvements uh programs become shorter uh on average we I observed more than 10",
    "start": "2235480",
    "end": "2241720"
  },
  {
    "text": "reduction in line count because we don't have these endless things of essentially closing braces anymore",
    "start": "2241720",
    "end": "2248380"
  },
  {
    "text": "um and uh for for writing it's ideal because writers stay in the flow you",
    "start": "2248380",
    "end": "2253599"
  },
  {
    "text": "don't need to go back and forth inserting braces which is for me I think hugely disruptive",
    "start": "2253599",
    "end": "2260200"
  },
  {
    "text": "um there were before I did that a lot of people coming out and saying oh this would be terrible for refactorings uh",
    "start": "2260200",
    "end": "2266920"
  },
  {
    "text": "it's it it doesn't scale it doesn't work in a large setting and I observed",
    "start": "2266920",
    "end": "2272500"
  },
  {
    "text": "absolutely none of that there were no downsides program changes were a lot more reliable than with prices of course",
    "start": "2272500",
    "end": "2279400"
  },
  {
    "text": "the details matter so details in the language matter essentially how do you make sure for instance how do you do the",
    "start": "2279400",
    "end": "2286960"
  },
  {
    "text": "meta rules in the language that is essentially if you accidentally insert or delete the single space that the",
    "start": "2286960",
    "end": "2293380"
  },
  {
    "text": "program will not essentially change meaning so our we have essentially this meta property in the rules for",
    "start": "2293380",
    "end": "2299339"
  },
  {
    "text": "essentially our and significant indentation so these things are important tooling is important uh I'm",
    "start": "2299339",
    "end": "2305859"
  },
  {
    "text": "using an editor that has essentially these uh lights gray lines vertical",
    "start": "2305859",
    "end": "2312040"
  },
  {
    "text": "lines for on the tabs tab stops so that's absolutely uh helps a lot because essentially that's your your analog of",
    "start": "2312040",
    "end": "2319660"
  },
  {
    "text": "jumping back and forth with braces to to find out what's what's uh what's a what's a region but once these things",
    "start": "2319660",
    "end": "2326680"
  },
  {
    "text": "are in place I think it really works great okay so that was essentially this final",
    "start": "2326680",
    "end": "2332140"
  },
  {
    "text": "thing and I think I'm at the end of the talk thank you",
    "start": "2332140",
    "end": "2337560"
  }
]