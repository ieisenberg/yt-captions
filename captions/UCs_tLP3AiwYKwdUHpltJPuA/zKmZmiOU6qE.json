[
  {
    "start": "0",
    "end": "55000"
  },
  {
    "text": "This is \"GOTO Unscripted.\" We're at GOTO \nCopenhagen. My name is Jeroen Engels. I'm   joined with Andrew Kelley. So, I'm a software \nengineer at CrowdStrike. I work primarily with  ",
    "start": "13620",
    "end": "25259"
  },
  {
    "text": "Elm. I like to, in my spare time, work in \nthe Elm linter, which is called elm-review,  ",
    "start": "25260",
    "end": "31320"
  },
  {
    "text": "which I presented at the conference. Andrew?\nHello. As Jeroen mentioned, my name is Andrew  ",
    "start": "33120",
    "end": "42059"
  },
  {
    "text": "Kelley. I am the president and lead software \ndeveloper of Zig Software Foundation. ",
    "start": "42060",
    "end": "47460"
  },
  {
    "text": "That sounds so much fancier than what I had.\nWell, I  ",
    "start": "50160",
    "end": "55500"
  },
  {
    "start": "55000",
    "end": "365000"
  },
  {
    "text": "heard that you have a thirst for linters.\nI do, I do. And I heard that you don't  ",
    "start": "55500",
    "end": "62460"
  },
  {
    "text": "use linter. The static analysis tools is just \nsomething that I find very enjoyable because,  ",
    "start": "62460",
    "end": "68280"
  },
  {
    "text": "like, I've been a JavaScript developer before, \nand I was always kind of frustrated with  ",
    "start": "69300",
    "end": "75480"
  },
  {
    "text": "all the problems that popped up with the code.\nI worked with ESLint on trying to figure out,  ",
    "start": "76080",
    "end": "84420"
  },
  {
    "text": "like, what rules can we enable to make sure that \nthese problems don't end up in our production  ",
    "start": "84420",
    "end": "91680"
  },
  {
    "text": "codebase? At some point, I started looking at \nElm, which is basically a very good, fresh,  ",
    "start": "91680",
    "end": "100320"
  },
  {
    "text": "new perspective, where all the problems that I \nhad with ESLint, or with JavaScript, didn't appear  ",
    "start": "100320",
    "end": "106740"
  },
  {
    "text": "anymore. But I still figured, it would still \nmake sense to have a linter for Elm, even though,  ",
    "start": "106740",
    "end": "113220"
  },
  {
    "text": "like, almost none of the same problems apply. \nDoes Elm offer any powerful refactoring tools? ",
    "start": "113220",
    "end": "122340"
  },
  {
    "text": "You mean for instance in IDs, or?\nFor instance, Java developers enjoy very  ",
    "start": "123060",
    "end": "129360"
  },
  {
    "text": "high-level abstraction refactoring tools, such \nas they can highlight a block of code and say,  ",
    "start": "129360",
    "end": "135900"
  },
  {
    "text": "\"Extract into method,\" or they can even take \na function and just reorder the parameters,  ",
    "start": "135900",
    "end": "141659"
  },
  {
    "text": "and it will update every call site at once. \nDo you have anything like this for Elm?  We have, to some extent, but definitely \nnot to the same level. But it's just a  ",
    "start": "141660",
    "end": "152760"
  },
  {
    "text": "matter of someone who needs to be passionate \nabout it and tackle those issues, because  ",
    "start": "152760",
    "end": "158159"
  },
  {
    "text": "we have so much more knowledge about what \nthe code is doing in Elm, compared to Java  ",
    "start": "159420",
    "end": "166319"
  },
  {
    "text": "or other languages, in my opinion, that it's \nall doable. So it's just a matter of someone  ",
    "start": "166320",
    "end": "173160"
  },
  {
    "text": "needs to do it. We have some refactorings, like \nwe can extract variables, can rename things,  ",
    "start": "173160",
    "end": "179880"
  },
  {
    "text": "but that's about it for now. Well, and more.\nOh, that's pretty nice. ",
    "start": "180660",
    "end": "185820"
  },
  {
    "text": "What do you have for Zig ? Do you have a \ngood integration with, I think VS Code is  ",
    "start": "185820",
    "end": "191160"
  },
  {
    "text": "the one where that supports Zig the best?\nThe best we have for now is a third-party  ",
    "start": "191160",
    "end": "197460"
  },
  {
    "text": "language server protocol implementation, but \nit's kind of a best-effort implementation,  ",
    "start": "197460",
    "end": "204660"
  },
  {
    "text": "and, you know, third-party, it's not, doesn't \ncome with a compiler. It can break separately. ",
    "start": "204660",
    "end": "210000"
  },
  {
    "text": "Is it best effort because the \nfocus hasn't been there yet, or?  I mean, I don't work on it. You know, someone from \nthe community works on it. They do a great job,  ",
    "start": "211140",
    "end": "219659"
  },
  {
    "text": "but shout-outs to August for working on \nthat. But there's only so much you can do  ",
    "start": "219660",
    "end": "227520"
  },
  {
    "text": "without it being integrated with the actual \ntype of information that the compiler has.  But I will say that the investment that we've done \nfor this for the future is designing the language  ",
    "start": "227520",
    "end": "239880"
  },
  {
    "text": "with conditional compilation being a first-class \npart of the language, rather than being through,  ",
    "start": "242580",
    "end": "249360"
  },
  {
    "text": "you know, a textual pre-processor.\nWhat do you mean? What does that change? ",
    "start": "249360",
    "end": "254520"
  },
  {
    "text": "You know, if I have an IDE for C or C++ code, \nand part of my C library API is that one of  ",
    "start": "255360",
    "end": "263280"
  },
  {
    "text": "the functions is just a macro that gets textually \nreplaced, then, you know, the refactoring tools,  ",
    "start": "263280",
    "end": "269700"
  },
  {
    "text": "they don't know how to deal with this because \nit's not one language, it's two languages,   and one of them is, you know, text-based \nconcatenation, and it doesn't know how to... ",
    "start": "269700",
    "end": "280620"
  },
  {
    "text": "If your language, if it was somewhat standard that \nyou had macros that were being replaced all over  ",
    "start": "281760",
    "end": "289080"
  },
  {
    "text": "the place, well, then the tool could analyze it, \n\"Well, okay, well, we know that there's this macro  ",
    "start": "289080",
    "end": "295020"
  },
  {
    "text": "in the codebase, therefore it will be replaced \nat this location, this location, this location.\" ",
    "start": "295020",
    "end": "300060"
  },
  {
    "text": "But if those macros get too custom, then \nit's really hard to analyze, right? And   therefore you lose all the guarantees \nabout, \"Oh, well, I can't see any GOTO  ",
    "start": "301740",
    "end": "311700"
  },
  {
    "text": "instruction here, therefore I know that \nit's not doing anything weird.\" But if   you have macros that change the code, \nthen you lose that kind of guarantee. ",
    "start": "315060",
    "end": "322800"
  },
  {
    "text": "You lose that kind of guarantee, or you have to \nexecute the pre-processor and then assume that,  ",
    "start": "322800",
    "end": "328620"
  },
  {
    "text": "you know, one set of DEFINEs is true. But maybe, \nyou know, if your build system changes the option,  ",
    "start": "328620",
    "end": "336120"
  },
  {
    "text": "then this other IFDEF defines it the other way, \nand so then you try to do a refactoring tool,   but then it's wrong for all the places where \nthe other definition would be activated.  ",
    "start": "336120",
    "end": "345660"
  },
  {
    "text": "You know, you can't solve the problem.\nAnd also you have to point the error   at some point, at some location in the \ncodebase, but if that codebase doesn't  ",
    "start": "348240",
    "end": "357600"
  },
  {
    "text": "exist because that's the result of applying \nthe macro, then what are you pointing at? ",
    "start": "357600",
    "end": "362280"
  },
  {
    "text": "That's a good point. Do you wanna \ntalk about errors versus warnings?  Sure. So, you meant what I specified in my talk, \nright? So, what I said during my talk was that  ",
    "start": "363720",
    "end": "369105"
  },
  {
    "start": "365000",
    "end": "765000"
  },
  {
    "text": "a lot of linters, they have a mechanism to make \nsure that you don't have errors that crash. Can   we cut that out, and I'll try it again?\nDuring my talk, I talked about severity   levels. Some linters allow you to specify for \neach rule how you want them to influence the  ",
    "start": "369105",
    "end": "380220"
  },
  {
    "text": "exit code of the linter. So, if you have an error \nthat is marked...if you have a rule that is set   to be an error, then whatever it reports will \ncause the linter to exit with an error code,  ",
    "start": "381060",
    "end": "391860"
  },
  {
    "text": "meaning that it will cause your test to fail, and \nyou will be notified, and you will have to fix it. ",
    "start": "391860",
    "end": "398879"
  },
  {
    "text": "And then you also have warnings, which do not \ncause your linter to exit with an error code.  ",
    "start": "399420",
    "end": "406440"
  },
  {
    "text": "And as I said during the talk, that doesn't \nreally make much sense, because you're trying  ",
    "start": "406980",
    "end": "413820"
  },
  {
    "text": "to enforce a rule without trying to enforce \nit, because you enable a rule, and you say,  ",
    "start": "413820",
    "end": "422040"
  },
  {
    "text": "\"Well, I want this rule to be enforced, but I \nalso don't want it to cause the test to fail,  ",
    "start": "422040",
    "end": "428580"
  },
  {
    "text": "so, therefore, it's not enforced.\" \nAnd that just doesn't make sense.  I completely agree.\nYes. ",
    "start": "429180",
    "end": "436199"
  },
  {
    "text": "Okay, but let's try to explore this idea. \nSo, you talked about false positives,  ",
    "start": "436800",
    "end": "444000"
  },
  {
    "text": "and you gave the example of your favorite linter \nrule, which I also happen to have as a favorite,  ",
    "start": "444000",
    "end": "451260"
  },
  {
    "text": "which is dead code. Unused variables, unused \nfunctions. Get rid of 'em. I love that. ",
    "start": "451260",
    "end": "457440"
  },
  {
    "text": "That one is not one that has false positives. \nBut what about a linter rule that is useful,  ",
    "start": "458640",
    "end": "465900"
  },
  {
    "text": "but, fundamentally, must have false positives \nin it. Can you think of any? Or, perhaps,  ",
    "start": "465900",
    "end": "474240"
  },
  {
    "text": "do you think that there should \nnever be this kind of linter rule?  So, code smells are usually...\nCode smells. ",
    "start": "474240",
    "end": "480660"
  },
  {
    "text": "...those kinds, right? We always \nsay it's code smell because it's  ",
    "start": "480660",
    "end": "487380"
  },
  {
    "text": "probably a sign that there's something \nbad about it, but we don't know for sure.  ",
    "start": "487380",
    "end": "493680"
  },
  {
    "text": "Sometimes it's good, just like cheese. It \nsmells bad, but in some cases, it's good.  ",
    "start": "493680",
    "end": "500820"
  },
  {
    "text": "So, code smells, whatever that might \nbe for your language or your ecosystem. ",
    "start": "504240",
    "end": "510180"
  },
  {
    "text": "If it smells like a stinky foot, \ncould be a bug, could be bleu cheese.  Or a stinky foot.\nOr a stinky foot. ",
    "start": "511020",
    "end": "517140"
  },
  {
    "text": "And a stinky foot is better than no foot.\nWow. Oh, I see. I see your point. Your point is  ",
    "start": "517140",
    "end": "523860"
  },
  {
    "text": "that maybe it is smelly code, but there's no other \nway around it. This problem is hairy, and this is,  ",
    "start": "523860",
    "end": "530160"
  },
  {
    "text": "on the stinky foot, has hair on it.\nPotentially.  I see. This analogy has gone quite \nfar. But do you have an example of  ",
    "start": "530160",
    "end": "538860"
  },
  {
    "text": "a code smell lint? I'm going somewhere \nwith this. I mean, I'm gonna ask about  ",
    "start": "538860",
    "end": "546000"
  },
  {
    "text": "disabling comments, but I wanna come up \nwith an example first that we can examine. ",
    "start": "548640",
    "end": "552720"
  },
  {
    "text": "The thing is, I don't have too many examples \nbecause when we have too many counterexamples  ",
    "start": "553800",
    "end": "559920"
  },
  {
    "text": "when we are trying to think of a rule, \nwe tend to not implement that rule.  Right. Right, right.\nIt's a bit tricky for me because I just  ",
    "start": "559920",
    "end": "570420"
  },
  {
    "text": "didn't think about those for a while.\nFor Elm, right?  Yes.\nBut what   if you're stuck with a more legacy language? You \nknow, C, C++, JavaScript? So, maybe the language  ",
    "start": "570420",
    "end": "582180"
  },
  {
    "text": "is not as nice, and so we might have more smells?\nIn those cases, for instance, you could say, well,  ",
    "start": "582180",
    "end": "588060"
  },
  {
    "text": "you should never access anything on null, right?\nOkay. ",
    "start": "588060",
    "end": "592200"
  },
  {
    "text": "And imagine, if we imagined we're targeting \nJavaScript and not TypeScript, we don't   have any information about whether something is \nnullable or not, well, then you pretty much have  ",
    "start": "593280",
    "end": "607080"
  },
  {
    "text": "to report everything, right? If you don't say, \n\"Oh, if this parameter is not null, then you can  ",
    "start": "609780",
    "end": "618540"
  },
  {
    "text": "do this. If it's null, then you do something \nelse.\" But if you don't have those checks,   then you're gonna have to report every \nusage of this. Do you see what I mean? ",
    "start": "618540",
    "end": "627540"
  },
  {
    "text": "What is the lint? The lint is...?\nLet's imagine the lint is, we want to report any  ",
    "start": "628140",
    "end": "634380"
  },
  {
    "text": "fields usage of a potentially null \nvalue. Like, if you do A, B, then if  ",
    "start": "635100",
    "end": "643259"
  },
  {
    "text": "we haven't checked that A is null, or not null...\nWell, what if A comes from the function parameter,  ",
    "start": "643260",
    "end": "649740"
  },
  {
    "text": "and we're expecting it to never be null, on...  How would you tell it that it shouldn't \nbe null if you don't have types? ",
    "start": "649740",
    "end": "657420"
  },
  {
    "text": "Oh, I see. So, you would need to assert that it's \nnot null and that assertion would make the linter  ",
    "start": "657420",
    "end": "663060"
  },
  {
    "text": "error go away?\nYes.  Okay. This sounds okay. \nSounds kinda nice, actually.  Jeroen Engels:  But you would have a lot of \nfalse positives because, you know, oh, well,  ",
    "start": "663060",
    "end": "670620"
  },
  {
    "text": "this function is never called with a null value. \nWe know it because we have asserted it before.  ",
    "start": "670620",
    "end": "675180"
  },
  {
    "text": "But because the linter doesn't know that, it \nhas to force you to reassert that it's not null. ",
    "start": "676380",
    "end": "684120"
  },
  {
    "text": "Well, that answers my question because the next \nquestion I was going to ask is why not... I mean,  ",
    "start": "684120",
    "end": "690120"
  },
  {
    "text": "you mentioned that you think that there's never \na reason to have a disabled comment for a linter. ",
    "start": "690120",
    "end": "696000"
  },
  {
    "text": "I wouldn't say never.\nOh, not never, okay.  But it should be very rare.\nVery rare. And, well,  ",
    "start": "696780",
    "end": "702060"
  },
  {
    "text": "you already showed that in this case, it \ncould be disabled, not with a comment,   but with an assert, and that's better. And that \ndoesn't count as a disabled comment, right? ",
    "start": "702060",
    "end": "711899"
  },
  {
    "text": "No. That is you pushing towards better code, or   code that reads more like \nyou what you want, right? ",
    "start": "711900",
    "end": "719519"
  },
  {
    "text": "That's very nice. I have to admit, during your \ntalk, I was thinking to myself, there have to be  ",
    "start": "719520",
    "end": "725340"
  },
  {
    "text": "lints where you need to disable them, but now that \nwe're trying to think of any, I'm coming up dry. ",
    "start": "725340",
    "end": "730980"
  },
  {
    "text": "Jeroen Engels:  In some cases, we'll be like, \nwe don't have the information that we need,  ",
    "start": "731520",
    "end": "735720"
  },
  {
    "text": "but people can always change their codes in a way \nthat the linter can understand that, \"Hey, here,  ",
    "start": "736680",
    "end": "744000"
  },
  {
    "text": "there's no problem,\" because we added an assert, \nor we added an if condition where it's, we say,  ",
    "start": "744000",
    "end": "750660"
  },
  {
    "text": "\"Is this value null?\" Things like that.\nSo, whenever you get a linter report,  ",
    "start": "750660",
    "end": "757740"
  },
  {
    "text": "you always have to change your code, be it through \na disabled comment or through changing the code. ",
    "start": "757740",
    "end": "763980"
  },
  {
    "start": "765000",
    "end": "1146000"
  },
  {
    "text": "That makes sense. Do you want to talk \nabout auto-fix, or prompts, fix prompts? ",
    "start": "765120",
    "end": "771720"
  },
  {
    "text": "Jeroen Engels:  What I talked about during my \npresentation was that linters, they tend to have  ",
    "start": "771720",
    "end": "782040"
  },
  {
    "text": "this feature where they automatically fix some \nof the issues, which is a very hard thing to do.   Like, I dunno if you've written any linter rules \nin your career, but writing a linter rule that  ",
    "start": "782040",
    "end": "795000"
  },
  {
    "text": "does the right thing always is very hard. It takes \na lot of gathering contact, gathering information,  ",
    "start": "795000",
    "end": "800820"
  },
  {
    "text": "and do some logic to figure out if is \nthere a problem or if is there no problem? ",
    "start": "800820",
    "end": "805560"
  },
  {
    "text": "And writing a fix for it is a lot harder, \nbecause you need to gather a lot more  ",
    "start": "807780",
    "end": "812880"
  },
  {
    "text": "information to make sure that you don't change \nthe code to something that will not compile,   that will break, maybe even that doesn't look \nweird code style-wise. Like, the indentation  ",
    "start": "812880",
    "end": "825300"
  },
  {
    "text": "still needs to be all right.\nRight, right. And you might   not have type information.\nWe might not have type information.  ",
    "start": "825300",
    "end": "829500"
  },
  {
    "text": "Fixes are super useful because it simplifies \ndevelopers' life because they just remove a   lot of time that they could have spent \non other things. But they can be done   in a trustworthy or untrustworthy way.\nThe example that I took was for ESLint,  ",
    "start": "833820",
    "end": "844200"
  },
  {
    "text": "where I said if you run ESLint --fix, it'll fix \nall the issues that it can fix automatically.  ",
    "start": "844200",
    "end": "852060"
  },
  {
    "text": "And the problem is that if you do that on a \nnew project, or you just enabled a very large,  ",
    "start": "853860",
    "end": "858899"
  },
  {
    "text": "new rule that changes a lot of things, \nthen you have a very big diff. And that  ",
    "start": "860700",
    "end": "866160"
  },
  {
    "text": "diff can be very hard to analyze.\nAnd the problem is that the linter  ",
    "start": "866160",
    "end": "872100"
  },
  {
    "text": "doesn't tell you which errors were reported, \nand it doesn't tell you how it tried to fix each  ",
    "start": "872100",
    "end": "878819"
  },
  {
    "text": "individual issue, and therefore you have a lot of \ntrouble figuring out whether the change was safe,  ",
    "start": "878820",
    "end": "884940"
  },
  {
    "text": "and whether you can push this to production.\nSo what I do with elm-review is, when you run it  ",
    "start": "884940",
    "end": "890820"
  },
  {
    "text": "with the fix flag, it prompts you for every error \nwith a fix. Like, it tells you all the details,  ",
    "start": "890820",
    "end": "901260"
  },
  {
    "text": "like, \"This is why I'm reporting this issue. This \nis what you did wrong, but I think I can fix this.  ",
    "start": "901260",
    "end": "907320"
  },
  {
    "text": "Would you like to accept this change? Yes or no?\"\nAnd by doing this process of prompting for every  ",
    "start": "907320",
    "end": "915900"
  },
  {
    "text": "error, we can get to trust the tool, because we \nsee that it's doing the correct thing. We see,  ",
    "start": "916980",
    "end": "926040"
  },
  {
    "text": "\"Well, it reported this problem. It suggested \nthis fix. That looks pretty good to me.\"  ",
    "start": "926040",
    "end": "932040"
  },
  {
    "text": "And if I see that it does that a hundred \ntimes in a row, I start to trust it. And  ",
    "start": "933660",
    "end": "941339"
  },
  {
    "text": "only when you trust the tool, then we have an \nelm-review --fix-all feature to fix all the  ",
    "start": "941340",
    "end": "948300"
  },
  {
    "text": "issues in one go, and then prompt you.\nThat's nice. I have to admit though,   I found myself thinking while watching your \ntalk on this that you showed a 600-line diff,  ",
    "start": "948300",
    "end": "959760"
  },
  {
    "text": "and the alternative is a command line prompt \nthat shows you a small diff, I don't know,  ",
    "start": "959760",
    "end": "968580"
  },
  {
    "text": "a hundred times, that adds up to 600-line diff.\nAnd for me personally, I actually would rather  ",
    "start": "968580",
    "end": "975720"
  },
  {
    "text": "pick the 600-line diff, because, on one hand, \nit's nice that the smaller prompt will give you  ",
    "start": "975720",
    "end": "981839"
  },
  {
    "text": "the context, but it's going to be the same \nissue over and over again, right? You know,   it did the same fix, the same fix, the same fix.\nIf it's the same rule, yes. If you have 200 rules  ",
    "start": "981840",
    "end": "993720"
  },
  {
    "text": "that each do different things, and fix the \nissue, or fix their issue in different ways,  ",
    "start": "993720",
    "end": "999240"
  },
  {
    "text": "then those compound. You have one transformation, \nthen another transformation, then another  ",
    "start": "999240",
    "end": "1004459"
  },
  {
    "text": "transformation, and the beginning code and the \nend result code, they look very different. So,  ",
    "start": "1004460",
    "end": "1010760"
  },
  {
    "text": "you don't know, like, how many errors were \nreported, how many fixes were applied.  Because it might be multiple \nfixes along the same lines. ",
    "start": "1010760",
    "end": "1017420"
  },
  {
    "text": "Yes.\nI understand.  In that case, it gets complex. If you only have \na single rule that reports all these issues,  ",
    "start": "1017420",
    "end": "1023960"
  },
  {
    "text": "go use --fix-all. If you think that looking at \ngen diff is good enough in this case, go for  ",
    "start": "1024740",
    "end": "1031040"
  },
  {
    "text": "it. That's why you have elm-review --fix-all.\nMaybe just, you know, if scrolling through the  ",
    "start": "1031040",
    "end": "1037280"
  },
  {
    "text": "diff is fastest, and the changes are simple \nenough, then perfect, but it's nice to have  ",
    "start": "1037280",
    "end": "1043220"
  },
  {
    "text": "that advanced option for when it's a little more \ntricky to understand what just happened. At least  ",
    "start": "1043220",
    "end": "1049640"
  },
  {
    "text": "we have this tool that can break it down, so \nyou're never just trying to trust... You don't  ",
    "start": "1049640",
    "end": "1055160"
  },
  {
    "text": "have to trust the tool. You can have the tool \nexplain to you why is it doing what it's doing.  You don't have to \"trust the tool.\"\nRight, I see your point. ",
    "start": "1055160",
    "end": "1063320"
  },
  {
    "text": "You don't trust it. You submit \nto it, is what I like to say.  Yes.\nBecause imagine  ",
    "start": "1063320",
    "end": "1069080"
  },
  {
    "text": "you're a junior developer. You just started \nusing JavaScript, you just start using ESLint  ",
    "start": "1069080",
    "end": "1075799"
  },
  {
    "text": "because someone told you it was good, and you \nrun eslint --fix, and then it changes the code in  ",
    "start": "1075800",
    "end": "1080840"
  },
  {
    "text": "very different ways, and you have no clue. Like, \nI barely knew what the code was doing before.  ",
    "start": "1082220",
    "end": "1088340"
  },
  {
    "text": "Now I don't know what it's doing now.\nWell, yes. If I'm a junior developer,   I'm going to assume that the tool knows \nbetter than me, and accept it blindly, right? ",
    "start": "1089120",
    "end": "1097940"
  },
  {
    "text": "Yes\nI mean, I would just   read the diff, but if I was a junior developer, I \nwould just assume that someone else knows better  ",
    "start": "1097940",
    "end": "1104540"
  },
  {
    "text": "than me, and just say, \"Yes, yes, yes, yes.\"\nYes. But that's not always correct, right? Because  ",
    "start": "1104540",
    "end": "1109940"
  },
  {
    "text": "the fix is just a suggestion of a fix.\nRight, right.  For instance, if you have an unused variable, \nthe fix is to remove it, right? But, potentially,  ",
    "start": "1110540",
    "end": "1120680"
  },
  {
    "text": "it's the code that I just wrote, and the \ncorrect solution to that is to start using   it somewhere. So that's also a reason why I \nlike to push towards prompting for every fix,  ",
    "start": "1120680",
    "end": "1131419"
  },
  {
    "text": "yes, to notice, \"Oh, there's something that I did \nwrong, and that the tool won't help me with.\" So,  ",
    "start": "1131420",
    "end": "1140780"
  },
  {
    "text": "the tool's not doing something wrong, but there \nare sometimes better solutions to the problem. ",
    "start": "1140780",
    "end": "1145820"
  },
  {
    "start": "1146000",
    "end": "1504000"
  },
  {
    "text": "Okay. So, here's a question. So, you've written \nelm-review, and you've put a lot of thought into,  ",
    "start": "1146480",
    "end": "1153260"
  },
  {
    "text": "well, the workflow of using linters.\nOkay. So, I've created the Zig compiler. And the  ",
    "start": "1153260",
    "end": "1160340"
  },
  {
    "text": "Zig compiler is, it has more features than most \ncompilers. It's not a bare-bones compiler. I mean,  ",
    "start": "1160340",
    "end": "1166940"
  },
  {
    "text": "it has the formatter built into it. I mean, it has \nunused variable errors. And in a branch, I haven't  ",
    "start": "1166940",
    "end": "1174740"
  },
  {
    "text": "merged it yet, but I have this --fix feature in \nthe compiler directly, not a separate linting  ",
    "start": "1174740",
    "end": "1181400"
  },
  {
    "text": "tool. So, the topic I wanted to bring up for you \nis, can we talk about the tradeoffs of having  ",
    "start": "1181400",
    "end": "1188840"
  },
  {
    "text": "linting errors, so stuff like, you \nknow, removing unused variables,   maybe other things like that too...\nAnd I'm sure that the C compiler has  ",
    "start": "1190820",
    "end": "1199940"
  },
  {
    "text": "a lot of warnings that you don't have...\nWe do not have warnings. Only errors. So... ",
    "start": "1199940",
    "end": "1206240"
  },
  {
    "text": "Okay. Sounds good to me.\nSounds good, right? Okay, but, but we also don't   have a linter. And so people do find it annoying \nthat when they're trying to iterate quickly,  ",
    "start": "1206240",
    "end": "1214760"
  },
  {
    "text": "they are not allowed to have unused variables. And \nso, I mean, one obvious choice is just to separate  ",
    "start": "1214760",
    "end": "1221180"
  },
  {
    "text": "the linter step from the compilation step, \nand that's the workflow that you've described. ",
    "start": "1221180",
    "end": "1227600"
  },
  {
    "text": "Yes. I think that's the way to go.\nOkay, then here's the downside though.  ",
    "start": "1227600",
    "end": "1233780"
  },
  {
    "text": "If I'm looking at someone's code, then \nmaybe they didn't run the linter step,  ",
    "start": "1235160",
    "end": "1240860"
  },
  {
    "text": "and I'm looking at it, and I'm seeing this \nfunction, and I'm trying to understand it,  ",
    "start": "1240860",
    "end": "1246020"
  },
  {
    "text": "and it's annoying because it doesn't make \nsense. Why is it doing this? Why is it  ",
    "start": "1246020",
    "end": "1251660"
  },
  {
    "text": "doing this? And then 30 minutes later, I realize \nit's never called, and that explains it, right?  Yes.\nIt would've been nice if that  ",
    "start": "1251660",
    "end": "1257480"
  },
  {
    "text": "linter guarantee was there, but they just didn't \nrun the linter yet, because it's not Tuesday,   I don't know. Do you see what I'm saying?\nIn which context are you looking at it?  ",
    "start": "1257480",
    "end": "1266179"
  },
  {
    "text": "Because that changes how you're thinking about it \nas well. For instance, if you have a pull request,  ",
    "start": "1266180",
    "end": "1271700"
  },
  {
    "text": "and the tests are green, and you look at the code, \nthen you will still have the guarantee, well,  ",
    "start": "1271700",
    "end": "1278840"
  },
  {
    "text": "all the code that is there is used...\nI see.  ...because the linter has run. If you're looking \nat code that is still being written, like, you're  ",
    "start": "1278840",
    "end": "1288320"
  },
  {
    "text": "pairing with someone or someone who says, \"Hey, \nI have a bug. Can you help me fix it?\" Then sure,  ",
    "start": "1288320",
    "end": "1295220"
  },
  {
    "text": "the code might be unused, but for a good reason \nbecause they're still working on the function,  ",
    "start": "1296180",
    "end": "1301280"
  },
  {
    "text": "and they may want to clean it up later.\nSo it really depends on the context of  ",
    "start": "1302480",
    "end": "1307220"
  },
  {
    "text": "when you're looking at the code, I \nthink. You could also say, \"Well,  ",
    "start": "1308240",
    "end": "1313280"
  },
  {
    "text": "if I want to look at any Zig code on the internet, \njust, like, in a GitHub Gist or something, Gist,  ",
    "start": "1313280",
    "end": "1320900"
  },
  {
    "text": "then I want to know whether all the used things \nare used or not, but someone might paste some  ",
    "start": "1322640",
    "end": "1330500"
  },
  {
    "text": "non-compiling Zig code as well, so...\nThat's true. Yes.  I think if you don't have a CI running next to the \ncode that you're looking at, or you just run the  ",
    "start": "1330500",
    "end": "1343760"
  },
  {
    "text": "test, then you don't have any guarantees anyway.\nAndrew Kelley:  I think that's an interesting   point. One kind of, takeaway, at least \nfor me, from this conversation is that  ",
    "start": "1343760",
    "end": "1354200"
  },
  {
    "text": "linting is fundamentally related to \nthe idea of continuous integration. ",
    "start": "1354200",
    "end": "1361159"
  },
  {
    "text": "Yes. Like, if you have a linter, but you don't \nenforce it in your CI, or in your test suite,  ",
    "start": "1361160",
    "end": "1368120"
  },
  {
    "text": "that's no use. It's just like \nhaving warnings for everything.  Right. So, we have this phase of the development \ncycle. There's the development phase,  ",
    "start": "1369080",
    "end": "1378440"
  },
  {
    "text": "and then there's the integration phase. And \neven if you have continuous integration,  ",
    "start": "1378440",
    "end": "1384980"
  },
  {
    "text": "that's still a separate phase that happens \nwhen you make the patch set to send.  Yes.\nThat's interesting. I'm just brainstorming  ",
    "start": "1384980",
    "end": "1393620"
  },
  {
    "text": "here. Are there any projects that justifiably \ndo not have a separate integration phase? ",
    "start": "1393620",
    "end": "1400220"
  },
  {
    "text": "When you say integration phase, \nyou mean specifically what?  Well, I'm calling the part where you run the CI \ntests, that you, maybe you make a pull request  ",
    "start": "1401600",
    "end": "1412220"
  },
  {
    "text": "and then the tests run automatically, you know, \nbefore you merge it. That's the integration phase,  ",
    "start": "1412220",
    "end": "1417380"
  },
  {
    "text": "right? The development phase would be on the local \ndeveloper's computer before they submit the patch.  So, are there any projects where an \nintegration phase doesn't make sense? ",
    "start": "1417380",
    "end": "1426440"
  },
  {
    "text": "Well, where the team justifiably does not have an \nintegration phase. So, I'm not trying to make a  ",
    "start": "1426440",
    "end": "1434179"
  },
  {
    "text": "point. I'm actually just musing out loud. Like, I \ndon't know, maybe video game companies don't have   an integration phase. Or maybe their integration \nphase is you play-test the code. I don't know. ",
    "start": "1434180",
    "end": "1442820"
  },
  {
    "text": "I think there might be two use cases \nthat I can think of. One is when  ",
    "start": "1442820",
    "end": "1448039"
  },
  {
    "text": "the product or the project is very early  ",
    "start": "1448940",
    "end": "1452960"
  },
  {
    "text": "in its development phase, and people don't care \nabout the code quality. Like, we've seen a talk  ",
    "start": "1454340",
    "end": "1461779"
  },
  {
    "text": "from Henrik about the fact that code quality \nshould be done after the prototyping, because you  ",
    "start": "1461780",
    "end": "1471260"
  },
  {
    "text": "want to iterate, you want to explore ideas, and \nafterward, then you can think about code quality. ",
    "start": "1471260",
    "end": "1478220"
  },
  {
    "text": "But then you could just not do the \nlinter step on that case as well.  Potentially. It's an approach that I haven't tried \nout, so I'm curious to know how it would work out.  ",
    "start": "1478220",
    "end": "1489440"
  },
  {
    "text": "Maybe you would only enable some of the \nlinter rules for the code that, you know,  ",
    "start": "1489440",
    "end": "1494779"
  },
  {
    "text": "should be in the code quality \nphase, then you enable more rules   for that specific part of the codebase, maybe.\nThat was pretty interesting. Did you have any  ",
    "start": "1496400",
    "end": "1507500"
  },
  {
    "start": "1504000",
    "end": "1782000"
  },
  {
    "text": "other topics that you want to examine?\nFrom the little I've seen from Zig,  ",
    "start": "1507500",
    "end": "1515180"
  },
  {
    "text": "it cares a lot about guarantees. Like, you told \nme, like, I see some Zig code, I want to know,  ",
    "start": "1516080",
    "end": "1521899"
  },
  {
    "text": "I want to have the guarantee that this function \nhere is used, that this function compiles,  ",
    "start": "1521900",
    "end": "1528260"
  },
  {
    "text": "that it will not crash, stuff like that. \nThose things are enforced by a compiler,  ",
    "start": "1528260",
    "end": "1533840"
  },
  {
    "text": "potentially by a linter, or a code formatter.\nAnd I feel like the same happens with Elm. Like,  ",
    "start": "1533840",
    "end": "1541700"
  },
  {
    "text": "we care a lot about guarantees, about \nadding constraints that give us a   lot of things in return. And I feel like \nthat's something that is quite recent-ish.  ",
    "start": "1541700",
    "end": "1550640"
  },
  {
    "text": "I've worked with JavaScript before, where you \nget almost no guarantees. You've worked with C,  ",
    "start": "1552800",
    "end": "1558140"
  },
  {
    "text": "where you have...a lot of things can go wrong.\nAnd I feel like the language that popped out  ",
    "start": "1558140",
    "end": "1565220"
  },
  {
    "text": "recently, especially the ones that come \nwith the functional programming paradigm,  ",
    "start": "1565220",
    "end": "1571220"
  },
  {
    "text": "they care a lot about giving guarantees \nabout the code, about how it will execute.  ",
    "start": "1571220",
    "end": "1579140"
  },
  {
    "text": "And I feel like, is there a trend to add more \nguarantees in languages? Is that something  ",
    "start": "1580160",
    "end": "1586760"
  },
  {
    "text": "that we now all care about? What do you think?\nI actually do not think that that's the case,  ",
    "start": "1586760",
    "end": "1592760"
  },
  {
    "text": "because...\nOkay.  ...I do see a lot of contemporary new languages, \nwhich they don't seem to focus on it too much. ",
    "start": "1592760",
    "end": "1600380"
  },
  {
    "text": "Do you have any examples?\nYou're gonna make me burn another project, huh?  ",
    "start": "1600380",
    "end": "1605900"
  },
  {
    "text": "I will give an example. So, the \nexample I'll give will be Nim. So,  ",
    "start": "1607880",
    "end": "1613280"
  },
  {
    "text": "Nim's emphasis is on flexibility \nand power. And so you can do some  ",
    "start": "1613280",
    "end": "1618620"
  },
  {
    "text": "really impressive things with Nim macros.\nI think that they pride themselves on having  ",
    "start": "1618620",
    "end": "1627080"
  },
  {
    "text": "a lot of the core syntax, such as: just, like, \nplus, minus, and division and things like this,  ",
    "start": "1628100",
    "end": "1634940"
  },
  {
    "text": "defined in the standard library. \nYou can also implement async/await  ",
    "start": "1636440",
    "end": "1642019"
  },
  {
    "text": "in userland in Nim, which is pretty cool. Right? \nIt's pretty powerful that you can do that. That's  ",
    "start": "1643820",
    "end": "1648919"
  },
  {
    "text": "a fundamental transformation of the control \nflow of a function, to make it async/await. ",
    "start": "1648920",
    "end": "1654320"
  },
  {
    "text": "And they do that with, like, the powerful \nmetaprogramming tools that the language   exposes. You see where I'm going with this, \nthough. You know, if you're reading a function,  ",
    "start": "1654320",
    "end": "1663200"
  },
  {
    "text": "does it use a powerful metaprogramming technique \nto fundamentally change what that function  ",
    "start": "1664220",
    "end": "1669919"
  },
  {
    "text": "does? Maybe. You don't have that guarantee.\nIt doesn't say it explicitly. Does it implicitly? ",
    "start": "1669920",
    "end": "1675440"
  },
  {
    "text": "I don't know enough. But, I mean, you could \njust be scrolled down and you're not looking   at the top of the function or something \nlike this. Do you see what I'm saying? ",
    "start": "1677840",
    "end": "1683600"
  },
  {
    "text": "Yes.\nWhereas with Zig,   it's a tradeoff. We don't have some of these \npowers. Like, you can't implement async/await  ",
    "start": "1683600",
    "end": "1691159"
  },
  {
    "text": "in userland. It's part of the language syntax.\nBut if you're in the middle of a function,  ",
    "start": "1691160",
    "end": "1697760"
  },
  {
    "text": "just looking at a piece of code, you have a lot \nof guarantees that if you see this variable, and  ",
    "start": "1697760",
    "end": "1704720"
  },
  {
    "text": "you see the definition of that variable somewhere \nelse on an outer scope, it's the same thing. It's  ",
    "start": "1704720",
    "end": "1710419"
  },
  {
    "text": "not shadowed or redefined or something like this. \nThere's my crafty... I'm not trying to burn Nim,  ",
    "start": "1710420",
    "end": "1723740"
  },
  {
    "text": "but there's an example for you, language.\nWhy do you care about having so many guarantees? ",
    "start": "1723740",
    "end": "1729380"
  },
  {
    "text": "Just preference. I mean, it's just, my subjective \nopinion is that I like to make reading code the  ",
    "start": "1730280",
    "end": "1738380"
  },
  {
    "text": "easiest thing to do with the language. We see \nthis, sometimes people use Advent of Code to  ",
    "start": "1738380",
    "end": "1746120"
  },
  {
    "text": "learn Zig, and it doesn't really go well for them, \nbecause Advent of Code is write-only code. You're  ",
    "start": "1746120",
    "end": "1751820"
  },
  {
    "text": "never gonna come back and read it again. You \ndon't care about it. It's a small, you know, 20,   30-line program, and it's just, it's write-only.\nBut, I mean, Zig code is almost read-only,  ",
    "start": "1751820",
    "end": "1763760"
  },
  {
    "text": "you know. It's, obviously, it's not read-only \nbecause you have to edit it, but, you know,   Zig code is meant to be maintained. It's \nmeant to be refactored, moved around. It's  ",
    "start": "1763760",
    "end": "1771980"
  },
  {
    "text": "meant to be a large codebase that you're \ntrying to manage the complexity of, and... ",
    "start": "1771980",
    "end": "1777080"
  },
  {
    "text": "And secure and safe.\nAll that good stuff.  Refactor it, and it will still work.\nI have to tell you, so, I have...  ",
    "start": "1777080",
    "end": "1785000"
  },
  {
    "start": "1782000",
    "end": "2328000"
  },
  {
    "text": "A lot of our \"linter errors,\" I guess \nyou can call them, like unused variables,   there are categories of errors. Some require the \ntype checker, but some can operate directly on  ",
    "start": "1787040",
    "end": "1797539"
  },
  {
    "text": "a file. It doesn't matter what flags you pass, \nit doesn't matter what target you pass. Like,  ",
    "start": "1797540",
    "end": "1803840"
  },
  {
    "text": "we know if you have an unused variable \njust based on the file alone, nothing else. ",
    "start": "1803840",
    "end": "1808100"
  },
  {
    "text": "I have this on unsafe. When I save a file in Zig, \nit runs the formatter, and it will give me, like,  ",
    "start": "1810020",
    "end": "1816080"
  },
  {
    "text": "an error list for unused variables, for use of \nundeclared variables, like, a certain class of  ",
    "start": "1816080",
    "end": "1822260"
  },
  {
    "text": "errors that are detected on, like, just a file \nlevel. Those are all reported, just instantly. ",
    "start": "1822260",
    "end": "1827720"
  },
  {
    "text": "And I love it so much for refactoring, because \nall I have to do is just grab a block of code. I  ",
    "start": "1827720",
    "end": "1834740"
  },
  {
    "text": "can just cut and paste code. I don't even read \nthe code. I just cut it, I paste it, I put it  ",
    "start": "1834740",
    "end": "1840500"
  },
  {
    "text": "somewhere else, or if I want a piece of \nlogic from this function, I just move it.  And then I get errors for... It's almost \nlike I reached into a robot and just, like,  ",
    "start": "1840500",
    "end": "1850340"
  },
  {
    "text": "grabbed their arm, and then I just put it on \nanother robot. And then I just get an error  ",
    "start": "1850340",
    "end": "1855740"
  },
  {
    "text": "for every wire I just need to, like, reattach to \nthe, you know, that's exposed, and then it works.  ",
    "start": "1855740",
    "end": "1862820"
  },
  {
    "text": "Because of all these guarantees. I love that, just \nthat ability to move large pieces of code around. ",
    "start": "1862820",
    "end": "1870740"
  },
  {
    "text": "Do you also call it, \"If it compiles, it \nworks?\" Because we do that in Elm all the time.  I mean, it's subjective, and I'm \nbiased, but I definitely feel that way,. ",
    "start": "1871340",
    "end": "1879020"
  },
  {
    "text": "I'm guessing there's also the bias, like, \n\"Well, I'm a senior engineer. I have experience,  ",
    "start": "1880580",
    "end": "1886580"
  },
  {
    "text": "so, of course, it's gonna work \nbecause I did the right things.\"   Does it also work for a junior? Well, maybe.\nMaybe, there are lessons to be learned in order  ",
    "start": "1886580",
    "end": "1896659"
  },
  {
    "text": "to get to that level, but the power is there.\nI absolutely understand  ",
    "start": "1896660",
    "end": "1903020"
  },
  {
    "text": "the need and the longing for that kind of safety. \nWe have it in Elm as well, and it's just amazing.  ",
    "start": "1904340",
    "end": "1911059"
  },
  {
    "text": "It's so hard to imagine coding without it, because \nI know that I'm gonna make a lot of mistakes,  ",
    "start": "1914360",
    "end": "1920240"
  },
  {
    "text": "and I just want some tool to help me figure out \nthat I messed up and when I'm gonna mess up. ",
    "start": "1920240",
    "end": "1927620"
  },
  {
    "text": "Okay. Here's an interesting topic. So, \nI'm used to doing imperative programming,   where the goal is that I write code, and \nat the end of the day, it's machine code,  ",
    "start": "1927620",
    "end": "1935720"
  },
  {
    "text": "you know, and that's the transformation, \ntargeting a virtual machine or actual machine.  You're used to doing functional programming in \nElm, and you're used to having certain kinds of  ",
    "start": "1935720",
    "end": "1947360"
  },
  {
    "text": "guarantees. We both understand the guarantees, \nbut let's try to find a bonus guarantee that  ",
    "start": "1947360",
    "end": "1954559"
  },
  {
    "text": "you have in Elm, that I don't have in Zig, \nbecause of imperative versus functional.  ",
    "start": "1954560",
    "end": "1960860"
  },
  {
    "text": "But you have to help me because you have \nthe expert on what is available to you. ",
    "start": "1960860",
    "end": "1966740"
  },
  {
    "text": "I have referential transparency.\nOkay. Can you explain that?  So, basically, when you do an operation, if you \ntake the same code and you put it somewhere else,  ",
    "start": "1966740",
    "end": "1977600"
  },
  {
    "text": "they will give you the same results. So, doing the \nsame operation will give you the same results. For  ",
    "start": "1978860",
    "end": "1984500"
  },
  {
    "text": "the same inputs, you get the same outputs.\nThat is only true if you don't have any side  ",
    "start": "1984500",
    "end": "1989900"
  },
  {
    "text": "effects or side causes, like accessing \nglobal variables, mutating them,  ",
    "start": "1989900",
    "end": "1995060"
  },
  {
    "text": "making HTTP calls, and things \nlike that. Because in Elm,   you don't have computations, you don't have side \neffects. Everything is just pure computation,  ",
    "start": "1997640",
    "end": "2007240"
  },
  {
    "text": "based on the inputs and based on constants. \nYou're always going to get the same result  ",
    "start": "2009940",
    "end": "2016600"
  },
  {
    "text": "for the same input. And that can make some \nsimplifications a lot easier. For instance,  ",
    "start": "2016600",
    "end": "2026679"
  },
  {
    "text": "if you do, if F of zero is equal \nto F of zero, then do something. ",
    "start": "2026680",
    "end": "2033700"
  },
  {
    "text": "Well, in a functional language, or at \nleast a purely functional language,   we don't care what F is. We don't care about the \nimplementation. We know that it's one function  ",
    "start": "2034540",
    "end": "2046180"
  },
  {
    "text": "with the argument zero, and we compare it to \nthe same function with the same arguments. So  ",
    "start": "2046180",
    "end": "2053200"
  },
  {
    "text": "we know those are always gonna be equal. So \nwe can simplify that if the expression to... ",
    "start": "2053200",
    "end": "2059379"
  },
  {
    "text": "Oh, I see. At the call \nsite, you can simplify this.  Yes. For instance.\nAh, I see.  Those kinds of simplifications, we can do. We \ncan also move code around without caring about,  ",
    "start": "2059380",
    "end": "2069639"
  },
  {
    "text": "well, did this function depend on this \nother function to be called first? ",
    "start": "2069640",
    "end": "2075339"
  },
  {
    "text": "So we can move it very easily. A linter \ncan do that for us. And you can do that  ",
    "start": "2075340",
    "end": "2084580"
  },
  {
    "text": "with imperative languages by either getting false \npositives or by doing a lot of static analysis to  ",
    "start": "2084580",
    "end": "2093760"
  },
  {
    "text": "figure out whether this is okay or not to do.\nBut then it would only work if the programmer  ",
    "start": "2093760",
    "end": "2099820"
  },
  {
    "text": "cooperated and wrote functions that \ndid not have side effects, right? ",
    "start": "2099820",
    "end": "2103720"
  },
  {
    "text": "Or you would have false positives. But you could \nalso have the linter be very smart about it,   do a lot of extensive research. Does this function \nhave any side effects? Does it access global  ",
    "start": "2108400",
    "end": "2118540"
  },
  {
    "text": "variables that the other function also does?\nAnd that is very, very tricky to do, I think. I  ",
    "start": "2118540",
    "end": "2126220"
  },
  {
    "text": "haven't tried it, but I think, in some cases, you \nwill reach some missing information. For instance,  ",
    "start": "2126220",
    "end": "2134740"
  },
  {
    "text": "it's using a function from a dependency. \nIf you don't know what the code in the   dependency is doing, then you don't know.\nCan you call that function twice in a row  ",
    "start": "2134740",
    "end": "2145119"
  },
  {
    "text": "without having any weird effect? We don't know. \nTherefore we have some missing information.  ",
    "start": "2145120",
    "end": "2151720"
  },
  {
    "text": "And when we have missing information, you \neither have false positives or false negatives. ",
    "start": "2153100",
    "end": "2157660"
  },
  {
    "text": "I think that the bulk of imperative code, \nI'm trying to think when it might apply  ",
    "start": "2158980",
    "end": "2164680"
  },
  {
    "text": "to this scenario or not, I think the \nbulk of imperative code would have a,  ",
    "start": "2164680",
    "end": "2169480"
  },
  {
    "text": "not necessarily a global variable, \nbut all of these functions,   you know, let's say A, B, C, D, E, \nF, or whatever, they'd be methods. ",
    "start": "2171280",
    "end": "2179860"
  },
  {
    "text": "So they would all take as the first parameter \na mutable pointer to some shared state,   which effectively acts as a global variable, but \nit's not global. But, you know, the sequence of  ",
    "start": "2179860",
    "end": "2191440"
  },
  {
    "text": "function calls is these methods are basically \noperating on an object instance, and mutating it.  ",
    "start": "2191440",
    "end": "2198099"
  },
  {
    "text": "And that's kind of the only \nmutations. So, if we were able to...  In functional programming? Or in...?\nIn imperative. ",
    "start": "2199420",
    "end": "2206800"
  },
  {
    "text": "Okay.\nI think that if we were able to model these as...  ",
    "start": "2206800",
    "end": "2211480"
  },
  {
    "text": "If these mutations were able to be modeled, then \nwe could have these kinds of abstractions of,  ",
    "start": "2213820",
    "end": "2221260"
  },
  {
    "text": "you know... I don't know what's the purpose for \noptimization or for linter warnings or something? ",
    "start": "2221260",
    "end": "2226300"
  },
  {
    "text": "The uses I'm thinking of is simplifying code...\nYou gave the example with Map, right? ",
    "start": "2227080",
    "end": "2232780"
  },
  {
    "text": "Yes. If you do List.map on a list, and then you \ntake the result of that and you call List.concat,  ",
    "start": "2232780",
    "end": "2243340"
  },
  {
    "text": "which is, like, a flat map, concatMap, then you \ncan just use List.concatMap instead, in Elm. And  ",
    "start": "2243340",
    "end": "2252640"
  },
  {
    "text": "you have multiple of these similar transformations \nthat you can do. But if the order of operations  ",
    "start": "2252640",
    "end": "2261760"
  },
  {
    "text": "matters, then this can be a potentially breaking \nchange, in the sense that it will break your code. ",
    "start": "2261760",
    "end": "2269260"
  },
  {
    "text": "Right, right.\nLike, I know that OCaml is a functional language,  ",
    "start": "2269260",
    "end": "2274180"
  },
  {
    "text": "but it doesn't have purity. So, for \ninstance, whenever it tries to do  ",
    "start": "2274900",
    "end": "2279579"
  },
  {
    "text": "List.map, it will always try to keep the order \nof the individual function calls the same. So,  ",
    "start": "2280900",
    "end": "2288099"
  },
  {
    "text": "we call List.map with a function F. Well, if we \ncall F of the first element, then F of the second  ",
    "start": "2288100",
    "end": "2295900"
  },
  {
    "text": "element, and so on and so on, and then you have to \nkeep that order. Otherwise, the code might change. ",
    "start": "2295900",
    "end": "2303160"
  },
  {
    "text": "Right, because the code...\nThe behavior might change.  ...is allowed to rely on \nthat property. Understand. ",
    "start": "2303160",
    "end": "2308560"
  },
  {
    "text": "And if you have a pure functional language, \nthen move it around just like you want. ",
    "start": "2308560",
    "end": "2313120"
  },
  {
    "text": "This is called referential transparency.\nJeroen Engels:I think so. I'm not entirely   sure, but I think that it's, given the \nsame inputs, you get the same outputs. ",
    "start": "2314320",
    "end": "2323079"
  },
  {
    "text": "Well, I mean, that's the essence of \na purely functional language, right?  Yes.\nWell, I enjoyed exploring some  ",
    "start": "2324040",
    "end": "2330820"
  },
  {
    "start": "2328000",
    "end": "2368000"
  },
  {
    "text": "of these ideas with you. I'm definitely walking \naway from here, I don't know, rethinking some  ",
    "start": "2330820",
    "end": "2336100"
  },
  {
    "text": "of my conclusions about the role of linting \nin the Zig compiler, so I appreciate that. ",
    "start": "2336100",
    "end": "2342580"
  },
  {
    "text": "I really enjoyed this talk as well. And maybe \nyou will make Zig a functional language soon.  Thanks for your time.\nThank you too.",
    "start": "2343120",
    "end": "2352900"
  }
]