[
  {
    "text": "good morning I'm going to be talking about syntax about uh why we love syntax on",
    "start": "5200",
    "end": "11719"
  },
  {
    "text": "our programming languages why we probably shouldn't and how you can get it anyway and take advantage of it um",
    "start": "11719",
    "end": "18720"
  },
  {
    "text": "the motivation for this talk is the new role that JavaScript has suddenly unexpectedly found itself in JavaScript",
    "start": "18720",
    "end": "26000"
  },
  {
    "text": "is now the universal virtual machine languages are being translated into",
    "start": "26000",
    "end": "31320"
  },
  {
    "text": "JavaScript in order to allow them to run everywhere one of the first languages to do that was Java Google Translates Java",
    "start": "31320",
    "end": "38719"
  },
  {
    "text": "into JavaScript so it can run everywhere amazing people are now translating C",
    "start": "38719",
    "end": "44320"
  },
  {
    "text": "into JavaScript and running at near native speeds nobody ever thought JavaScript",
    "start": "44320",
    "end": "50280"
  },
  {
    "text": "would be used this way we're also seeing new languages being developed specifically to translate into",
    "start": "50280",
    "end": "56920"
  },
  {
    "text": "JavaScript so it's become a universal vers ual machine I would contend the",
    "start": "56920",
    "end": "61960"
  },
  {
    "text": "first language designed to run as one of these JavaScript languages was JS lint",
    "start": "61960",
    "end": "68520"
  },
  {
    "text": "JS lint could be thought of as a compiler for a language called the good parts and so it it was the first it was",
    "start": "68520",
    "end": "77159"
  },
  {
    "text": "released in about 2000 um and as you know JS lint comes",
    "start": "77159",
    "end": "82759"
  },
  {
    "text": "with a warning JS lint will hurt your feelings because it complains about",
    "start": "82759",
    "end": "88040"
  },
  {
    "text": "people's syntax and people have a deep emotional connection to their syntax so",
    "start": "88040",
    "end": "93399"
  },
  {
    "text": "when you tell them how they can improve their their programs in order to make them less likely to be buggy and and",
    "start": "93399",
    "end": "99119"
  },
  {
    "text": "more maintainable more beatable and all of that they start to cry which is surprising because it's",
    "start": "99119",
    "end": "105920"
  },
  {
    "text": "just syntax why should anybody care about that so I contend that syntax is",
    "start": "105920",
    "end": "111200"
  },
  {
    "text": "the least important aspect of a programming language design and I mean",
    "start": "111200",
    "end": "116240"
  },
  {
    "text": "that in the same sense as fashion is the least important aspect of clothing",
    "start": "116240",
    "end": "121320"
  },
  {
    "text": "design which sounds like a radical statement but you know if you look at what clothing is and what it should do",
    "start": "121320",
    "end": "127200"
  },
  {
    "text": "it should protect us from the Sun and from the cold and from injury and um",
    "start": "127200",
    "end": "132280"
  },
  {
    "text": "protect our um our modesty but but that's not what we",
    "start": "132280",
    "end": "139000"
  },
  {
    "text": "consider when we buy clothes in particular in things like shoes people will buy shoes without asking can I walk",
    "start": "139000",
    "end": "147120"
  },
  {
    "text": "in them can I run in them will they Pro uh save my foot from injury people will buy",
    "start": "147120",
    "end": "153120"
  },
  {
    "text": "shoes that are likely to cause injury in the name of fashion so we forget what's really important and as programmers we",
    "start": "153120",
    "end": "160640"
  },
  {
    "text": "think we're smarter than that that we would not you know you look at the completely unfashionable shoes that",
    "start": "160640",
    "end": "166480"
  },
  {
    "text": "we're all wearing we would not make that mistake but when it comes to programming",
    "start": "166480",
    "end": "172760"
  },
  {
    "text": "language syntax we make exactly the same mistakes for the same reasons we're totally irrational and emotional in our",
    "start": "172760",
    "end": "179959"
  },
  {
    "text": "love for syntax so I'll offer as evidence uh an amazing book by um Samuel Cayman came",
    "start": "179959",
    "end": "187640"
  },
  {
    "text": "out in 1990 so it's a bit dated but it's still a really good book programming language is an interpreter based",
    "start": "187640",
    "end": "193400"
  },
  {
    "text": "approach in this book he writes interpreters for seven programming",
    "start": "193400",
    "end": "199400"
  },
  {
    "text": "languages and then he writes programs for each of those languages to show how they work and for these seven languages",
    "start": "199400",
    "end": "205560"
  },
  {
    "text": "he doesn't implement the entire language because that would be too much work to in a book so he only implements the good",
    "start": "205560",
    "end": "212280"
  },
  {
    "text": "parts of each of these languages and for most of the languages that does not include their",
    "start": "212280",
    "end": "217959"
  },
  {
    "text": "syntax so it's really surprising when you look at a language like APL which is famous for the way it looks it looks",
    "start": "217959",
    "end": "225840"
  },
  {
    "text": "radically unlike any other language he writes it with the same notation as the other six languages in order to get an",
    "start": "225840",
    "end": "232680"
  },
  {
    "text": "Apples to Apples comparison so it's surprising that you can write in a language without using its syntax but us",
    "start": "232680",
    "end": "239760"
  },
  {
    "text": "usually when we're reviewing languages syntax is all we look at we look at the most superficial aspect of it and often",
    "start": "239760",
    "end": "247079"
  },
  {
    "text": "it could be years before we discover what's in the deeper layers by stripping away all the syntax Cayman shows us what",
    "start": "247079",
    "end": "254360"
  },
  {
    "text": "these languages are actually doing so um the language he uses is a",
    "start": "254360",
    "end": "261079"
  },
  {
    "text": "minimal syntax um and there are a number of languages which have fairly minimal",
    "start": "261079",
    "end": "267199"
  },
  {
    "text": "syntaxes these languages are well regarded by um designers but are rejected by the",
    "start": "267199",
    "end": "275479"
  },
  {
    "text": "mainstream most professional programmers can't stand these languages so lisp has",
    "start": "275479",
    "end": "281440"
  },
  {
    "text": "a minimal syntax it has s Expressions an S expression is just a sequence of",
    "start": "281440",
    "end": "287840"
  },
  {
    "text": "symbols wrapped in parentheses usually they represent um",
    "start": "287840",
    "end": "292960"
  },
  {
    "text": "function invocations and expressions but they could contain data or any other kind of",
    "start": "292960",
    "end": "298120"
  },
  {
    "text": "structure and it's really really simple you can take any of those arguments replace it with another s expression and",
    "start": "298120",
    "end": "303639"
  },
  {
    "text": "Nest as deep as you want this is maybe the most minimal syntax the lisp",
    "start": "303639",
    "end": "309840"
  },
  {
    "text": "community and scheming Community love this stuff the rest of us hate this",
    "start": "309840",
    "end": "314880"
  },
  {
    "text": "stuff we we find it offensive to even look at it um Small Talk could be considered a",
    "start": "314880",
    "end": "321080"
  },
  {
    "text": "minimal syntax although it's significantly more complicated than S Expressions um the uh method invocation",
    "start": "321080",
    "end": "328520"
  },
  {
    "text": "in small talk is brilant you have something representing an object then you have the name of the parameters um",
    "start": "328520",
    "end": "335680"
  },
  {
    "text": "separating the values of the parameters we rejected this even though it's brilliant instead we took um c++'s",
    "start": "335680",
    "end": "344360"
  },
  {
    "text": "approach which is you have a list of things wrapped in parentheses separated by commas with absolutely no indication",
    "start": "344360",
    "end": "350560"
  },
  {
    "text": "as to what they are and what order they go in which makes it much easier to substitute the wrong value or to get",
    "start": "350560",
    "end": "357039"
  },
  {
    "text": "them out of order and we like that we like that it's easier to get it wrong so",
    "start": "357039",
    "end": "362680"
  },
  {
    "text": "that we rejected this one which is much harder to get wrong in favor of the one that's much easier to get wrong that's",
    "start": "362680",
    "end": "369080"
  },
  {
    "text": "the sort of emotionalism that's wrapped up in our appreciation of syntax so let",
    "start": "369080",
    "end": "374160"
  },
  {
    "text": "me take you through the years and look at the evolution of the if statement we start with",
    "start": "374160",
    "end": "380240"
  },
  {
    "text": "Fortran um here we have a Fortran computed go-to statement so if",
    "start": "380240",
    "end": "386759"
  },
  {
    "text": "um um if the difference between a and b is negative will or zero will jump to",
    "start": "386759",
    "end": "394080"
  },
  {
    "text": "statement 20 which does nothing otherwise we'll jump to statement 10 the parentheses around the condition",
    "start": "394080",
    "end": "402759"
  },
  {
    "text": "are absolutely necessary in most languages they're just decoration but in Fortran spaces were not significant so",
    "start": "402759",
    "end": "411960"
  },
  {
    "text": "it could not see the difference between if a and IFA they both look the same to",
    "start": "411960",
    "end": "418039"
  },
  {
    "text": "Fortran so it needed the parentheses to separate so it could tell what was an if",
    "start": "418039",
    "end": "423919"
  },
  {
    "text": "statement uh Fortran gets a little better with Fortran 4 um the L sign hadn't been invented yet",
    "start": "423919",
    "end": "431879"
  },
  {
    "text": "but um it could substitute a a dole dot expression you can see what it does we",
    "start": "431879",
    "end": "438160"
  },
  {
    "text": "can also see here the go-to statement demonstrated the go-to of course was the inspiration for this",
    "start": "438160",
    "end": "444680"
  },
  {
    "text": "conference and most people wrote go to as two words even though um it it's a a",
    "start": "444680",
    "end": "451479"
  },
  {
    "text": "single word in in Fortran again because of this ability to insert spaces",
    "start": "451479",
    "end": "457240"
  },
  {
    "text": "anywhere spaces aren't significant so Fortran actually got",
    "start": "457240",
    "end": "462319"
  },
  {
    "text": "something right that everybody's gotten wrong since then which is how do you write a variable name which contains a",
    "start": "462319",
    "end": "468159"
  },
  {
    "text": "space you so we're all arguing and we've been arguing for years should we use underbars or camel",
    "start": "468159",
    "end": "474400"
  },
  {
    "text": "case and it's hard to get consensus because both are the wrong answer for",
    "start": "474400",
    "end": "479720"
  },
  {
    "text": "actually got it right um but we haven't figured out how to do that unambiguously in future languages so maybe someday",
    "start": "479720",
    "end": "486280"
  },
  {
    "text": "we'll figure that out and we'll be able to use baces appropriately this is algol 60",
    "start": "486280",
    "end": "493639"
  },
  {
    "text": "um the maybe the best designed by Committee in the history of programming",
    "start": "493639",
    "end": "499280"
  },
  {
    "text": "languages alol 60 gave us the block statement so you see the begin and end",
    "start": "499280",
    "end": "504720"
  },
  {
    "text": "and um that introduces a scope if you're declaring variables there and we've seen that uh brilliant idea um carried into",
    "start": "504720",
    "end": "514120"
  },
  {
    "text": "virtually all languages today um alol also gave us the",
    "start": "514120",
    "end": "519839"
  },
  {
    "text": "semicolon there were earlier languages that try to um use periods to end a",
    "start": "519839",
    "end": "525560"
  },
  {
    "text": "statement because that's how we end statements in our in our writing but",
    "start": "525560",
    "end": "531440"
  },
  {
    "text": "that turned out to be problematic because it looks like a decimal point and sometimes it wasn't clear is is that",
    "start": "531440",
    "end": "537440"
  },
  {
    "text": "the end of a statement or is it just a number so we went to semicolons instead and we've seen that convention copied",
    "start": "537440",
    "end": "544279"
  },
  {
    "text": "into a lot of other languages this is bcpl bcpl is the good",
    "start": "544279",
    "end": "550959"
  },
  {
    "text": "parts of a much larger language called CPL CPL um like Ada and pl1 was intend",
    "start": "550959",
    "end": "560360"
  },
  {
    "text": "was intended to be one of those Universal languages which could be used for everything that turns out to generally",
    "start": "560360",
    "end": "567120"
  },
  {
    "text": "not be a good idea at smaller specialized languages are are usually better and bcpl was a very successful",
    "start": "567120",
    "end": "575720"
  },
  {
    "text": "language um and was highly influential in at least two ways the first was that",
    "start": "575720",
    "end": "581600"
  },
  {
    "text": "it came with a virtual machine uh that used bite codes that was written in bcpl",
    "start": "581600",
    "end": "587640"
  },
  {
    "text": "so that virtual machine was very easily ported to other machines and so BCL bcpl showed up in lots of places and that",
    "start": "587640",
    "end": "594920"
  },
  {
    "text": "bite code architecture found its way into the Pascal P system in then into the Java",
    "start": "594920",
    "end": "602240"
  },
  {
    "text": "jvm but it was also very influential in its syntax bcpl was the first curly",
    "start": "602240",
    "end": "608279"
  },
  {
    "text": "brace language and the curly brace thing has taken off and we see it virtually everywhere now it's basically the same",
    "start": "608279",
    "end": "615360"
  },
  {
    "text": "idea that we had an elol except instead of begin and end it's curly brace and we",
    "start": "615360",
    "end": "621600"
  },
  {
    "text": "really liked that we really liked that economy uh this is the bee language this",
    "start": "621600",
    "end": "628399"
  },
  {
    "text": "was Ken Thompson um reinterpretation of bcpl his idea of",
    "start": "628399",
    "end": "633959"
  },
  {
    "text": "the good parts he tried to make BCL bcpl a little bit smaller and to make the",
    "start": "633959",
    "end": "639680"
  },
  {
    "text": "syntax better suited to Ken Thompson uh one of the things he did was in my view",
    "start": "639680",
    "end": "646079"
  },
  {
    "text": "a regression he put the parentheses back in in this case the parentheses are not",
    "start": "646079",
    "end": "652800"
  },
  {
    "text": "needed they're here solely for decoration um and it something that's hearkening back to Fortran",
    "start": "652800",
    "end": "660240"
  },
  {
    "text": "um they're not needed here but he wanted them and so they went into B and they",
    "start": "660240",
    "end": "665720"
  },
  {
    "text": "went into C into C plus plus and a Java into C and virtually every language since then has these unnecessary",
    "start": "665720",
    "end": "672560"
  },
  {
    "text": "parentheses in it and we think they look sharp um they serve no purpose at all",
    "start": "672560",
    "end": "679639"
  },
  {
    "text": "and I often find people doing stupid things in order to avoid keystrokes but they like these keystrokes and there's",
    "start": "679639",
    "end": "686440"
  },
  {
    "text": "no explanation for why that is uh this is Ada um one of the things I",
    "start": "686440",
    "end": "693040"
  },
  {
    "text": "like about ADA is the way it says comments I think the dash dash thing introduce a comment is just really nice",
    "start": "693040",
    "end": "700079"
  },
  {
    "text": "looking it of all the comment conventions it seems to conform most closely to what we do and it's also",
    "start": "700079",
    "end": "706240"
  },
  {
    "text": "using the annotated end so instead of algol which or would just say end it",
    "start": "706240",
    "end": "712399"
  },
  {
    "text": "says end if which is a little verbose but it's clear as to what's going on here um I think the best if statement",
    "start": "712399",
    "end": "720720"
  },
  {
    "text": "I've ever seen is an alol 68 this was another attempt to make a huge universal",
    "start": "720720",
    "end": "726240"
  },
  {
    "text": "language and there's a lot of stuff in alol that I don't like including its comment convention using a sent sign to",
    "start": "726240",
    "end": "732959"
  },
  {
    "text": "both end and begin comments starting and ending comments with the same character is asking for",
    "start": "732959",
    "end": "739760"
  },
  {
    "text": "trouble um the the line or comment to the end of the line convention seems to",
    "start": "739760",
    "end": "744800"
  },
  {
    "text": "work a lot better but I love its if statement um it it replaces um the end",
    "start": "744800",
    "end": "752160"
  },
  {
    "text": "if with Fi so you you very quickly learn that you know that two character diagraph closes the other thing we got",
    "start": "752160",
    "end": "759120"
  },
  {
    "text": "rid of the blocks it's just so elegant I I love this I think it's um very nice",
    "start": "759120",
    "end": "766279"
  },
  {
    "text": "also it's using colon equal there's been a battle in in syntax design for a long time as to is assignment equal or is it",
    "start": "766279",
    "end": "774320"
  },
  {
    "text": "colon equal in Fortran it was equal but equal looks like equ which it isn't and",
    "start": "774320",
    "end": "780480"
  },
  {
    "text": "that's confusing and particularly the mathematicians have trouble with that um",
    "start": "780480",
    "end": "786120"
  },
  {
    "text": "some languages like alal started the convention of colon equal and we still have this argument going on and right",
    "start": "786120",
    "end": "793000"
  },
  {
    "text": "now the um equal sign guys are winning and I I think that's unfortunate",
    "start": "793000",
    "end": "798360"
  },
  {
    "text": "too so what we really like is emotional style we could have minimal syntax but",
    "start": "798360",
    "end": "804240"
  },
  {
    "text": "we don't we want the emotional syntax instead and in particular what we're looking look for is fashionable",
    "start": "804240",
    "end": "810959"
  },
  {
    "text": "tolerance of syntactic ambiguity ambiguity is bad in programming",
    "start": "810959",
    "end": "816639"
  },
  {
    "text": "languages because ambiguity causes confusion confusion causes errors and we want zero errors in our programs but we",
    "start": "816639",
    "end": "824880"
  },
  {
    "text": "love syntax which makes it more likely and in fact enables errors to occur",
    "start": "824880",
    "end": "830560"
  },
  {
    "text": "which couldn't occur otherwise so I'll um I'll give you an example so here we",
    "start": "830560",
    "end": "837279"
  },
  {
    "text": "have a madeup programming language with two operators cloud and heart and I've got three variables a b and c and so how",
    "start": "837279",
    "end": "844839"
  },
  {
    "text": "do you interpret the expression a Cloud B heart C there a number of ways you could do it",
    "start": "844839",
    "end": "851720"
  },
  {
    "text": "one is you could read it from left to right so you do a Cloud B and then you",
    "start": "851720",
    "end": "856920"
  },
  {
    "text": "do heart C or you could read it from right to left and so that would be B ccloud and then you all BC heart then",
    "start": "856920",
    "end": "865160"
  },
  {
    "text": "you Cloud that with a there are languages which do strictly left to right like um small talk did",
    "start": "865160",
    "end": "872040"
  },
  {
    "text": "that and there are languages that go strictly right to left APL did that which is right I don't know but you know",
    "start": "872040",
    "end": "879279"
  },
  {
    "text": "you pick a direction and you say that's how we do it and that makes it pretty easy to read programs written in those",
    "start": "879279",
    "end": "885480"
  },
  {
    "text": "languages you just have to know the rule and once you know that rule one rule it's that way or that way then you can",
    "start": "885480",
    "end": "891440"
  },
  {
    "text": "correctly read programs but that's not what we want because that's not complicated enough and that doesn't",
    "start": "891440",
    "end": "897560"
  },
  {
    "text": "produce enough opportunity to make mistakes so what we instead want is",
    "start": "897560",
    "end": "902759"
  },
  {
    "text": "operator precedence where we want a rule which is more complicated which describes which one you do",
    "start": "902759",
    "end": "910560"
  },
  {
    "text": "first and so depending on what the relative precedence is between cloud and heart that will finally determine how",
    "start": "910560",
    "end": "917560"
  },
  {
    "text": "that expression gets interpreted so the way we deal with that is with um binding Powers we can give",
    "start": "917560",
    "end": "924680"
  },
  {
    "text": "each operator a number and operators which are associated with a high binding power bind more tightly or bind first",
    "start": "924680",
    "end": "933279"
  },
  {
    "text": "and operators with looser binding Powers will bind more Loosely and and",
    "start": "933279",
    "end": "941440"
  },
  {
    "text": "later so basically if you're working in a language you have to memorize this list you have to know the relative",
    "start": "941680",
    "end": "948040"
  },
  {
    "text": "rankings of all of these and it can that can be a difficult thing to remember so for example uh at Power",
    "start": "948040",
    "end": "954800"
  },
  {
    "text": "40 I've got um logical and and logical or and in this language that I'm going to",
    "start": "954800",
    "end": "962480"
  },
  {
    "text": "create here they have the same precedence but in a lot of other languages they don't one of them will",
    "start": "962480",
    "end": "969560"
  },
  {
    "text": "bind more tightly than the other so I will ask a question to you right now for",
    "start": "969560",
    "end": "975399"
  },
  {
    "text": "your favorite programming language which binds more tightly and or or do they",
    "start": "975399",
    "end": "981880"
  },
  {
    "text": "have the same precedence so who knows for sure how their language works I'm seeing a very small number of hands go",
    "start": "981880",
    "end": "988560"
  },
  {
    "text": "up so what that means is if your hand didn't go up if you ever see both of these operators in the same expression",
    "start": "988560",
    "end": "995680"
  },
  {
    "text": "it's likely you're going to Mis understand what it does and if you did raise your hand and if you put both of",
    "start": "995680",
    "end": "1001440"
  },
  {
    "text": "these into an expression it's very likely the next person to read your code will not understand what your code does",
    "start": "1001440",
    "end": "1007880"
  },
  {
    "text": "in introduce an error you know and it amazes me that",
    "start": "1007880",
    "end": "1013240"
  },
  {
    "text": "most of the people writing programs professionally won't know the answer to that and it and there's really no reason",
    "start": "1013240",
    "end": "1019120"
  },
  {
    "text": "expect that they would um another example on line 60 in mathematical notation",
    "start": "1019120",
    "end": "1025640"
  },
  {
    "text": "multiplication is generally tighter than division so we can write things like ax",
    "start": "1025640",
    "end": "1030918"
  },
  {
    "text": "over b y in some programming languages that's also true but in some programming",
    "start": "1030919",
    "end": "1037678"
  },
  {
    "text": "languages they have the same precedence as I showed here so again who knows for certain in their favorite programming",
    "start": "1037679",
    "end": "1044199"
  },
  {
    "text": "language whether multiplication and division have the same precedence",
    "start": "1044199",
    "end": "1050720"
  },
  {
    "text": "again a few hands go up but most of the hands don't because most of us don't know so we like that we like that we put",
    "start": "1050720",
    "end": "1059480"
  },
  {
    "text": "rules into our languages which most of us don't know which are opportunities",
    "start": "1059480",
    "end": "1065160"
  },
  {
    "text": "for creating bugs another source of ambiguity that we like is the overloading of words so we",
    "start": "1065160",
    "end": "1072440"
  },
  {
    "text": "can use a word to indicate a variable a statement keyword an operator or a",
    "start": "1072440",
    "end": "1077640"
  },
  {
    "text": "special form and sometimes it's really important what a word is um and in some",
    "start": "1077640",
    "end": "1083640"
  },
  {
    "text": "languages there will be lists of reserved words that um cannot be used",
    "start": "1083640",
    "end": "1089039"
  },
  {
    "text": "for other purposes because they may conflict with some of these special uses",
    "start": "1089039",
    "end": "1094280"
  },
  {
    "text": "and most people working in those languages do not have a fully memorized",
    "start": "1094280",
    "end": "1099520"
  },
  {
    "text": "recollection of what that list is so that's also introducing other opportunities for making errors we have",
    "start": "1099520",
    "end": "1107240"
  },
  {
    "text": "overloading of operators so in most of our languages we'll use parentheses to",
    "start": "1107240",
    "end": "1112720"
  },
  {
    "text": "do uh function definition and invocation we'll also use them to do grouping",
    "start": "1112720",
    "end": "1117960"
  },
  {
    "text": "within expressions and we'll also use them for separation and",
    "start": "1117960",
    "end": "1123320"
  },
  {
    "text": "decoration so using the same operator to do all of those things can often also",
    "start": "1123320",
    "end": "1128760"
  },
  {
    "text": "introduce ambiguities which can cause errors we but we like overloading in",
    "start": "1128760",
    "end": "1134880"
  },
  {
    "text": "fact we like it so much that some of our language languages specifically allow us to do overloading which increases our",
    "start": "1134880",
    "end": "1142880"
  },
  {
    "text": "ability to create confusion within the programs that we develop so the way we deal with with",
    "start": "1142880",
    "end": "1150480"
  },
  {
    "text": "ambiguity in language is parsing and we have uh wonderful formal theories of of",
    "start": "1150480",
    "end": "1156600"
  },
  {
    "text": "of formal languages which allow us to to automatically generate parsers parsing",
    "start": "1156600",
    "end": "1162159"
  },
  {
    "text": "is a very complicated subject there are a lot of amazing books and a lot of papers about it a lot of Machinery has",
    "start": "1162159",
    "end": "1168159"
  },
  {
    "text": "been constructed Ed around it um so I'm going to write for you today a",
    "start": "1168159",
    "end": "1174159"
  },
  {
    "text": "parser of of a language now we're going to see the whole thing so we're going to start with tokens you can take all of",
    "start": "1174159",
    "end": "1181200"
  },
  {
    "text": "the source elements of a program and and divide them into tokens and each of those will be represented by an object",
    "start": "1181200",
    "end": "1187400"
  },
  {
    "text": "we'll have a prototype token which will be the token that everything is going to inherit from and then we'll have um a",
    "start": "1187400",
    "end": "1194080"
  },
  {
    "text": "set of symbols which will inherit from those prototypes and then we'll have the final tokens",
    "start": "1194080",
    "end": "1199240"
  },
  {
    "text": "which will inherit U from those symbols we'll have an advanced method",
    "start": "1199240",
    "end": "1204919"
  },
  {
    "text": "which will uh fetch the next token for us and put it in a variable called token and if",
    "start": "1204919",
    "end": "1211600"
  },
  {
    "text": "we pass an ID then it will guarantee that the token that we're skipping",
    "start": "1211600",
    "end": "1216840"
  },
  {
    "text": "over is that kind of a token so if we're looking for a plus sign we can say",
    "start": "1216840",
    "end": "1223080"
  },
  {
    "text": "Advance Plus and that'll guarantee that the next token is a plus sign if it's not it'll Pro produce an",
    "start": "1223080",
    "end": "1230559"
  },
  {
    "text": "error so in parsing what we want to do is to take a tree or to produce a tree",
    "start": "1230559",
    "end": "1236320"
  },
  {
    "text": "so we'll take a list of of um tokens and we'll weave them into a structure and",
    "start": "1236320",
    "end": "1242880"
  },
  {
    "text": "once we have this structure we can then uh pass it to an analyzer or to a code generator or an interpreter and it'll",
    "start": "1242880",
    "end": "1249559"
  },
  {
    "text": "cause work to happen so the whole effort of parsing is to produce this",
    "start": "1249559",
    "end": "1256039"
  },
  {
    "text": "structure I'm going to show you a technique called top- down operator precedence this was invented by Von",
    "start": "1256039",
    "end": "1261880"
  },
  {
    "text": "Pratt when he was at MIT he's teaching at Stanford now he presented it at the pole conference in",
    "start": "1261880",
    "end": "1268960"
  },
  {
    "text": "73 he designed it for um providing lisp",
    "start": "1268960",
    "end": "1274440"
  },
  {
    "text": "or or high level language syntax into a uh lisp",
    "start": "1274440",
    "end": "1279480"
  },
  {
    "text": "environment um he claimed that the technique was simple to understand",
    "start": "1279480",
    "end": "1285559"
  },
  {
    "text": "trivial to implement easy to use extremely efficient very flexible and I",
    "start": "1285559",
    "end": "1291799"
  },
  {
    "text": "will also claim that it is beautiful I think this is one of the most beautiful elegant things I've ever",
    "start": "1291799",
    "end": "1298760"
  },
  {
    "text": "seen um so why have you never heard of this if it's such a good thing why is this completely unknown to you um Pratt",
    "start": "1298760",
    "end": "1306559"
  },
  {
    "text": "in his paper um tells you why it's going to be rejected um first is the",
    "start": "1306559",
    "end": "1313480"
  },
  {
    "text": "preoccupation with BNF grammars and their uh various offsprings um",
    "start": "1313480",
    "end": "1319919"
  },
  {
    "text": "Pratt loved autom Theory and all of that stuff but he found a way to completely avoid that stuff and much",
    "start": "1319919",
    "end": "1327200"
  },
  {
    "text": "more quickly solve the problem um it requires a functional programming language and in his paper he",
    "start": "1327200",
    "end": "1335200"
  },
  {
    "text": "used lisp and the problem with that is that um most languages at least at that time",
    "start": "1335200",
    "end": "1341279"
  },
  {
    "text": "were not functional programming languages and the lisp Community had no use for syntax they were had found so",
    "start": "1341279",
    "end": "1348720"
  },
  {
    "text": "much value in the minimal syntax of s Expressions they didn't want anything else even if it came at very low",
    "start": "1348720",
    "end": "1356400"
  },
  {
    "text": "cost um but the JavaScript Community is a community that has a functional",
    "start": "1356400",
    "end": "1362120"
  },
  {
    "text": "language and it's a community that likes emotional syntax so this algorithm is",
    "start": "1362120",
    "end": "1368840"
  },
  {
    "text": "really well suited to that community so Pratt um takes parsing",
    "start": "1368840",
    "end": "1376720"
  },
  {
    "text": "which is a really complicated thing and reduces it to one simple question what do we expect to see to the",
    "start": "1376720",
    "end": "1384120"
  },
  {
    "text": "left of a token um there are some things that don't look that that want to see",
    "start": "1384120",
    "end": "1389880"
  },
  {
    "text": "something to the left for example an infix operator will take something that's to its left and then something to",
    "start": "1389880",
    "end": "1396000"
  },
  {
    "text": "its right um and then there things like variables and constants and un are operators that don't expect to see",
    "start": "1396000",
    "end": "1402760"
  },
  {
    "text": "anything to the left so just those two cases and so he calls something that is expecting to see",
    "start": "1402760",
    "end": "1410039"
  },
  {
    "text": "something on the left a left denotation or a lead and something that doesn't he",
    "start": "1410039",
    "end": "1416000"
  },
  {
    "text": "calls a null denotation or a nud so lead and nud are pratz terms but I'm going to use",
    "start": "1416000",
    "end": "1422679"
  },
  {
    "text": "those so um there are some symbols which will have only nuds so exclamation point",
    "start": "1422679",
    "end": "1430039"
  },
  {
    "text": "in JavaScript or Tilda in JavaScript those are unary operators only so they will have nuds uh variables will have",
    "start": "1430039",
    "end": "1436880"
  },
  {
    "text": "nuds then um plus dot uh assignment operators",
    "start": "1436880",
    "end": "1444640"
  },
  {
    "text": "relational operators those are leads because they expect to see something on the left side of the operator and there",
    "start": "1444640",
    "end": "1452440"
  },
  {
    "text": "uh to make things maximally confusion confusing we have some which have both so Plus in JavaScript is both an infix",
    "start": "1452440",
    "end": "1460000"
  },
  {
    "text": "operator and a prefix operator parin is both um when it's uh grouping is a",
    "start": "1460000",
    "end": "1468679"
  },
  {
    "text": "prefix operator when it's invoking it's an infix",
    "start": "1468679",
    "end": "1473520"
  },
  {
    "text": "operator so here is the Prototype token this is where our tokens are going to start it will have the default nud and",
    "start": "1474360",
    "end": "1482320"
  },
  {
    "text": "Lead functions which will just cause errors if if you get to this and and these methods haven't been overwritten",
    "start": "1482320",
    "end": "1489480"
  },
  {
    "text": "then the default is to produce an error it'll also have an error method which will produce error messages so if we",
    "start": "1489480",
    "end": "1496960"
  },
  {
    "text": "find an error as we par we can call the error method of the particular token that caused the error and that will give",
    "start": "1496960",
    "end": "1503640"
  },
  {
    "text": "us a proper message and it will also have the default left binding power so",
    "start": "1503640",
    "end": "1508960"
  },
  {
    "text": "this is the Precedence of this thing so something which doesn't already have a specific power will inherit to",
    "start": "1508960",
    "end": "1517519"
  },
  {
    "text": "zero uh then we'll produce our symbol table that's where we'll keep all of the symbols of the language and we'll have a",
    "start": "1517760",
    "end": "1524960"
  },
  {
    "text": "symbol function which will help us to populate that table so the symbol function will take an ID",
    "start": "1524960",
    "end": "1531320"
  },
  {
    "text": "and a binding power we'll look up the current symbol in the symbol table and if we um find it",
    "start": "1531320",
    "end": "1540600"
  },
  {
    "text": "then we'll use it otherwise we will um construct a new one and stick it into the",
    "start": "1540600",
    "end": "1547559"
  },
  {
    "text": "table having this we can now start declaring our language so I'm going to",
    "start": "1547559",
    "end": "1552960"
  },
  {
    "text": "specify that all of these things are symbols now and it's starting to look declarative even though this is all",
    "start": "1552960",
    "end": "1559080"
  },
  {
    "text": "procedural this is all functional it starts to look like declarations so I'm declaring that these specific things are",
    "start": "1559080",
    "end": "1565919"
  },
  {
    "text": "symbols and I'm adding uh two special symbols um here end represents the end",
    "start": "1565919",
    "end": "1573320"
  },
  {
    "text": "of the program so I want something to indicate when we get there and because of the rules of of um tokens of of",
    "start": "1573320",
    "end": "1581799"
  },
  {
    "text": "tokenization these are guaranteed to not match anything that actually gets spread in then I also have a special um symbol",
    "start": "1581799",
    "end": "1589720"
  },
  {
    "text": "which represents words that we don't have in the symbol table this is going to be where our um variables show",
    "start": "1589720",
    "end": "1598760"
  },
  {
    "text": "up so now let's start defining operators so plus is a symbol it's going to have a",
    "start": "1598760",
    "end": "1604720"
  },
  {
    "text": "binding power of 60 and it will have a lead and its lead will um take its",
    "start": "1604720",
    "end": "1613080"
  },
  {
    "text": "first uh member as whatever was on the left and then call the expression",
    "start": "1613080",
    "end": "1619360"
  },
  {
    "text": "function to get whatever is on the right and we'll set the aity of the of the",
    "start": "1619360",
    "end": "1625279"
  },
  {
    "text": "token to Binary and return it uh we can do uh asterisk exactly the",
    "start": "1625279",
    "end": "1632200"
  },
  {
    "text": "same way um we still have a um you know the only difference is it's asterisk",
    "start": "1632200",
    "end": "1638520"
  },
  {
    "text": "instead of plus and it's 70 instead of 60 but otherwise they're exactly the same whenever we have things that are",
    "start": "1638520",
    "end": "1645200"
  },
  {
    "text": "that similar we know we there's a chance to do something smarter so I'm going to create an infix operator or an infix",
    "start": "1645200",
    "end": "1651919"
  },
  {
    "text": "function which I'll use to define my infix operators so it's going to take an ID a binding power and an optional lead",
    "start": "1651919",
    "end": "1658799"
  },
  {
    "text": "function um if we're not past a lead function then it'll take a it'll create a default lead function which is the one",
    "start": "1658799",
    "end": "1665679"
  },
  {
    "text": "which takes the thing on the left calls expression and takes the thing on the right so having this infix function I",
    "start": "1665679",
    "end": "1672919"
  },
  {
    "text": "can now start defining my infix operators and again it's looking declarative but um it it's it's actually",
    "start": "1672919",
    "end": "1679200"
  },
  {
    "text": "functional so I this says that my uh plus operator is looser than my multiply",
    "start": "1679200",
    "end": "1687080"
  },
  {
    "text": "operator but um tighter than my comparison operators and by the way I all of my",
    "start": "1687080",
    "end": "1693360"
  },
  {
    "text": "comparison operators are the same level of Precedence in your favorite programming language do they all have",
    "start": "1693360",
    "end": "1699480"
  },
  {
    "text": "the same precedence anybody know they probably don't in most languages uh the",
    "start": "1699480",
    "end": "1706000"
  },
  {
    "text": "inequality operators you know less than and greater then don't have the same tightness as equality again another",
    "start": "1706000",
    "end": "1712760"
  },
  {
    "text": "opportunity for error uh the Turner operator is a special infix operator because it takes",
    "start": "1712760",
    "end": "1719440"
  },
  {
    "text": "an additional thing afterwards so we specify that by passing in a function which will parse those which looks like",
    "start": "1719440",
    "end": "1726559"
  },
  {
    "text": "the others it will take the thing on the left get an expression to get the second thing will then match the colon and then",
    "start": "1726559",
    "end": "1732880"
  },
  {
    "text": "get the expression for the third thing and set the aity det Turner",
    "start": "1732880",
    "end": "1739200"
  },
  {
    "text": "um in most of our languages we'll have some things which associate left or right but that's not confusing enough so",
    "start": "1739799",
    "end": "1746480"
  },
  {
    "text": "we'll also have things that associate right to left so if you have a number of operators with the same precedence level",
    "start": "1746480",
    "end": "1753399"
  },
  {
    "text": "um the tie gets broken by directionality and some will go one way and some will go the other so an example of things",
    "start": "1753399",
    "end": "1761200"
  },
  {
    "text": "which go the other way are assignments assignments always get evaluated from right to",
    "start": "1761200",
    "end": "1766840"
  },
  {
    "text": "left um so uh we'll create an assignment",
    "start": "1766840",
    "end": "1773039"
  },
  {
    "text": "function which will help us to specify those things and we can also do some uh",
    "start": "1773039",
    "end": "1778320"
  },
  {
    "text": "deeper checking here so I can make sure that what's on the left of the assignment is an L",
    "start": "1778320",
    "end": "1784279"
  },
  {
    "text": "value um that can be a difficult thing to determine syntactically because the L value rules are more complicated than",
    "start": "1784279",
    "end": "1791080"
  },
  {
    "text": "the regular expression rules um but I adding special cases in uh this system",
    "start": "1791080",
    "end": "1798039"
  },
  {
    "text": "is really easy so I I can just do that checking here instead of trying to do it",
    "start": "1798039",
    "end": "1803279"
  },
  {
    "text": "grammatically um and then once I have that I can then go ahead and create or specify my assignment",
    "start": "1803279",
    "end": "1810880"
  },
  {
    "text": "operators I do prefixes the same way uh prefix uses a nud because there's",
    "start": "1810880",
    "end": "1817120"
  },
  {
    "text": "nothing of interest on the left of a prefix um so having that I can now",
    "start": "1817120",
    "end": "1822360"
  },
  {
    "text": "specify plus minus and so on my prefix operators",
    "start": "1822360",
    "end": "1828279"
  },
  {
    "text": "uh the uh uh parent operator uh for grouping is slightly special so we pass",
    "start": "1828880",
    "end": "1836440"
  },
  {
    "text": "in pass in a function so it will um parse an expression look for the closing",
    "start": "1836440",
    "end": "1842919"
  },
  {
    "text": "brace and then return the expression when Pratt um wrote his paper",
    "start": "1842919",
    "end": "1850960"
  },
  {
    "text": "he was um thinking about expression languages and expression languages are",
    "start": "1850960",
    "end": "1856080"
  },
  {
    "text": "great but we don't like them those they're not emotional enough we prefer to have statement languages we want to",
    "start": "1856080",
    "end": "1861880"
  },
  {
    "text": "have statements and expressions and his language didn't allow for statements but",
    "start": "1861880",
    "end": "1867039"
  },
  {
    "text": "it was easy to adapt the system to do that so I came up with a first null",
    "start": "1867039",
    "end": "1872799"
  },
  {
    "text": "denotation if in a statement position you can have a um there are certain nuds",
    "start": "1872799",
    "end": "1879360"
  },
  {
    "text": "which only make sense in that position and so I call those things fuds or first",
    "start": "1879360",
    "end": "1884399"
  },
  {
    "text": "null denotation and I can have a statement function which will allow me to declare",
    "start": "1884399",
    "end": "1891880"
  },
  {
    "text": "or to spec to create the symbols that will be used for statements um it will first look to see",
    "start": "1891880",
    "end": "1899039"
  },
  {
    "text": "if the token has a fud and if it does it will call it otherwise it will assume",
    "start": "1899039",
    "end": "1904760"
  },
  {
    "text": "it's an expression statement and then I'll look to see what kind of expression I got in most of our languages any",
    "start": "1904760",
    "end": "1910840"
  },
  {
    "text": "expression can be a statement which is crazy uh I think the only two expressions that make sense in statement",
    "start": "1910840",
    "end": "1918000"
  },
  {
    "text": "position are assignments and invocations and anything else is likely to be an error um but since B at least we've",
    "start": "1918000",
    "end": "1927399"
  },
  {
    "text": "allowed that but I I think we shouldn't and then finally it'll match semicolon and and it's",
    "start": "1927399",
    "end": "1935360"
  },
  {
    "text": "done uh very often we'll want to have more than one statement so um statements",
    "start": "1935960",
    "end": "1941639"
  },
  {
    "text": "allows us to uh parse a a list of statements um and put them in Array and",
    "start": "1941639",
    "end": "1948279"
  },
  {
    "text": "we can tell if a token is likely to be the next statement if it has a nud or a",
    "start": "1948279",
    "end": "1954600"
  },
  {
    "text": "fud if it does then it's probably a statement if it doesn't then it probably isn't we can then parse blocks a block",
    "start": "1954600",
    "end": "1962600"
  },
  {
    "text": "starts with a curly brace and then will contain some statements and then a Clos",
    "start": "1962600",
    "end": "1967840"
  },
  {
    "text": "and curly brace okay and then we can match um we",
    "start": "1967840",
    "end": "1974840"
  },
  {
    "text": "can start defining our statements so a statement will take an ID and a fud",
    "start": "1974840",
    "end": "1979919"
  },
  {
    "text": "function and and so we'll get a symbol for that um for that statement and",
    "start": "1979919",
    "end": "1987080"
  },
  {
    "text": "assign the fud statement to it so here's an example of an if",
    "start": "1987080",
    "end": "1992320"
  },
  {
    "text": "statement um we first skip the the decorative curly bra or decorative parin",
    "start": "1992320",
    "end": "1999960"
  },
  {
    "text": "we parse the condition uh we match the closing bra or closing parin uh we parel",
    "start": "1999960",
    "end": "2008279"
  },
  {
    "text": "block um then we look to see if there's an El if there is then we uh get the um",
    "start": "2008279",
    "end": "2014080"
  },
  {
    "text": "the other consequence and then we set the aity to statement and then we're done so in the box is an if statement",
    "start": "2014080",
    "end": "2021080"
  },
  {
    "text": "that is the statement that this expression or that this function is going to",
    "start": "2021080",
    "end": "2027120"
  },
  {
    "text": "match but to show you some of the flexibility we have in the scheme um",
    "start": "2027120",
    "end": "2033559"
  },
  {
    "text": "suppose I want to parse or have a language which looks like bcpl at least",
    "start": "2033559",
    "end": "2038960"
  },
  {
    "text": "in its if statements so this is the code for parsing bcpl like if statements and",
    "start": "2038960",
    "end": "2045320"
  },
  {
    "text": "in the box is an example of such an if statement basically taking the uh parents off this is sometimes called",
    "start": "2045320",
    "end": "2051679"
  },
  {
    "text": "parent free and at various times it looks like this might make it into a future addition of ecmascript but so far",
    "start": "2051679",
    "end": "2058200"
  },
  {
    "text": "it hasn't mostly because um public response has been so vocal people love",
    "start": "2058200",
    "end": "2064040"
  },
  {
    "text": "that parent and it looks like we can't remove it",
    "start": "2064040",
    "end": "2069398"
  },
  {
    "text": "or if we want to make it look like elol 68 um you know in the box is an alol 68 if statement and this is a code which",
    "start": "2069399",
    "end": "2076358"
  },
  {
    "text": "will match that style of this if statement um basically just by uh matching on the",
    "start": "2076359",
    "end": "2083440"
  },
  {
    "text": "FI then this is the key to the whole thing this is the expression statement um you call this with a binding power",
    "start": "2085040",
    "end": "2092240"
  },
  {
    "text": "and that get returns a tree which represents that expression and this is",
    "start": "2092240",
    "end": "2097960"
  },
  {
    "text": "the single most brilliant function I've ever seen in my whole",
    "start": "2097960",
    "end": "2103160"
  },
  {
    "text": "career in this Pratt has taken all of the theory of parsing and all of its complexity and reduced it to a simple",
    "start": "2103160",
    "end": "2111240"
  },
  {
    "text": "Loop so when we enter this we first um call the nud of of the current token and",
    "start": "2111240",
    "end": "2118839"
  },
  {
    "text": "then as long as um The Binding power of the next token is greater than the right",
    "start": "2118839",
    "end": "2126240"
  },
  {
    "text": "binding power that we passed in we call leads and we keep doing that until we're",
    "start": "2126240",
    "end": "2131599"
  },
  {
    "text": "done and that's it all of the complexity of parsing is in this simplest of",
    "start": "2131599",
    "end": "2138760"
  },
  {
    "text": "functions so when we are doing stuff right it's",
    "start": "2138760",
    "end": "2145000"
  },
  {
    "text": "when we've taken a whole lot of complexity and removed it all and just come up with a simple thing and I have",
    "start": "2145000",
    "end": "2151319"
  },
  {
    "text": "never seen a better example of replacing complexity with Simplicity than this I",
    "start": "2151319",
    "end": "2157200"
  },
  {
    "text": "love this this this is my most favorite function in the whole world um and and all this works so uh we",
    "start": "2157200",
    "end": "2166800"
  },
  {
    "text": "want to take that statement and produce that tree from it um and what I showed",
    "start": "2166800",
    "end": "2174160"
  },
  {
    "text": "you will do that um in in fact we we could look at it as you know this is a",
    "start": "2174160",
    "end": "2181000"
  },
  {
    "text": "data structure that it'll produce and we could then take that data structure and give it to a code generator give it to an Optimizer give it to an inter",
    "start": "2181000",
    "end": "2188839"
  },
  {
    "text": "that an interpreter can execute this stuff directly um and this is the trace that",
    "start": "2188839",
    "end": "2196280"
  },
  {
    "text": "that code's going to to do and so you've seen every one of those functions and",
    "start": "2196280",
    "end": "2202560"
  },
  {
    "text": "those functions weren't doing anything very complex there's not much code going on so this technique is really fast",
    "start": "2202560",
    "end": "2210280"
  },
  {
    "text": "because it it's hardly doing anything it's just going around uh comparing",
    "start": "2210280",
    "end": "2215560"
  },
  {
    "text": "numbers and building trees this is another example of a statement",
    "start": "2215560",
    "end": "2220880"
  },
  {
    "text": "this one because of the difference in precedence the tree is balanced in the other other way um this is the data",
    "start": "2220880",
    "end": "2228359"
  },
  {
    "text": "structure that represents that tree and this is the parse that generated that one and again it's really simple and",
    "start": "2228359",
    "end": "2235520"
  },
  {
    "text": "it's really fast there's hardly anything going on so that's top- down operator",
    "start": "2235520",
    "end": "2241599"
  },
  {
    "text": "precedence it is easy to build parsers with it it is really fast because it",
    "start": "2241599",
    "end": "2246640"
  },
  {
    "text": "does almost nothing nothing um it's in fact fast enough to use as an",
    "start": "2246640",
    "end": "2253079"
  },
  {
    "text": "interpreter um and it's Dynamic you can build dsls with this in fact you can build dsls inside of another application",
    "start": "2253079",
    "end": "2260720"
  },
  {
    "text": "because it's really lightweight you could also build extensible languages you can add you could have uh functions",
    "start": "2260720",
    "end": "2268960"
  },
  {
    "text": "in your system which add new capability to uh the structures that you're using",
    "start": "2268960",
    "end": "2274839"
  },
  {
    "text": "to to uh build your language as you're running the language so you",
    "start": "2274839",
    "end": "2280800"
  },
  {
    "text": "can add stuff so one view of application development is you should first design",
    "start": "2280800",
    "end": "2286440"
  },
  {
    "text": "the language which is the ideal language for writing your application and then write your application in that",
    "start": "2286440",
    "end": "2292160"
  },
  {
    "text": "language this allows you to easily do that we can also get rid of reserved",
    "start": "2292160",
    "end": "2297560"
  },
  {
    "text": "words um reserved words are bad for programmers because you have to remember",
    "start": "2297560",
    "end": "2302800"
  },
  {
    "text": "this list and sometimes that gets in the way of the things you're trying to express",
    "start": "2302800",
    "end": "2308040"
  },
  {
    "text": "and it's bad for uh language designers because if you discover later something",
    "start": "2308040",
    "end": "2314119"
  },
  {
    "text": "that you needed to add to the language very often you can't because people are already using the best word so because",
    "start": "2314119",
    "end": "2321119"
  },
  {
    "text": "this technique is so Dynamic you're not uh freezing all of this complexity",
    "start": "2321119",
    "end": "2328160"
  },
  {
    "text": "into static data structures it's all Dynamic you can have policies like any",
    "start": "2328160",
    "end": "2334119"
  },
  {
    "text": "word can be used as a variable name but if you use a variable name in a function",
    "start": "2334119",
    "end": "2339480"
  },
  {
    "text": "that name cannot be used for any other purpose in the function and having such a rule means you don't need reserved",
    "start": "2339480",
    "end": "2345040"
  },
  {
    "text": "words anymore so it's good for programmers because they don't need to know or care what the reserved word list",
    "start": "2345040",
    "end": "2350680"
  },
  {
    "text": "is it doesn't exist and it's good for the language designers because they can add new stuff to the language at any",
    "start": "2350680",
    "end": "2356640"
  },
  {
    "text": "time and never have to worry about conflict because anyone who's already",
    "start": "2356640",
    "end": "2361960"
  },
  {
    "text": "using the name is not going to be using the new feature so who cares",
    "start": "2361960",
    "end": "2367760"
  },
  {
    "text": "um finally I have some advice for language designers um I think we should",
    "start": "2367760",
    "end": "2372920"
  },
  {
    "text": "all be designing programming languages I think it's a a great thing it's a lot of",
    "start": "2372920",
    "end": "2378119"
  },
  {
    "text": "fun it's the nerli of arts and it's something that we can all",
    "start": "2378119",
    "end": "2383240"
  },
  {
    "text": "enjoy so first um I would recommend that you try to embrace minimalism in your language um try to",
    "start": "2383240",
    "end": "2390880"
  },
  {
    "text": "have conceptual minimalism also uh notational minimalism as much as",
    "start": "2390880",
    "end": "2396119"
  },
  {
    "text": "possible but don't get cryptic um try to provide as much Clarity and error resistance as you can one of your",
    "start": "2396119",
    "end": "2403440"
  },
  {
    "text": "primary goals should be to try to make your language confusion free confusion",
    "start": "2403440",
    "end": "2408640"
  },
  {
    "text": "is the source of all errors and so if we can avoid sources of confusion our",
    "start": "2408640",
    "end": "2414040"
  },
  {
    "text": "languages we're going to have an easier time try to make it readable and I find",
    "start": "2414040",
    "end": "2419079"
  },
  {
    "text": "there's a huge amount of misunderstanding as to what readable means um I think readable means that it",
    "start": "2419079",
    "end": "2425560"
  },
  {
    "text": "can easily and correctly be understood by a reader most people understand",
    "start": "2425560",
    "end": "2430839"
  },
  {
    "text": "readability to mean I like the way it looks and that that's a completely different",
    "start": "2430839",
    "end": "2437319"
  },
  {
    "text": "thing um innovate we already have a lot of java likee languages so if you find",
    "start": "2437319",
    "end": "2443400"
  },
  {
    "text": "yourself writing Coke bottle Coke bottle equals New Coke bottle walk away from the",
    "start": "2443400",
    "end": "2449960"
  },
  {
    "text": "machine we've already been there um that ground's been really well covered um try",
    "start": "2451480",
    "end": "2457560"
  },
  {
    "text": "to find some other uh dimension on which to to innovate select your features very",
    "start": "2457560",
    "end": "2464880"
  },
  {
    "text": "carefully don't just take every feature you ever saw and try to put it into your language even if they're all really good",
    "start": "2464880",
    "end": "2471720"
  },
  {
    "text": "um be aware or beware of the idea that some something is sometimes useful you",
    "start": "2471720",
    "end": "2478599"
  },
  {
    "text": "know this feature is sometimes useful so I want to put it in my language I defy anybody to suggest",
    "start": "2478599",
    "end": "2484880"
  },
  {
    "text": "anything real or imaginary which is not sometimes useful even things which are",
    "start": "2484880",
    "end": "2490560"
  },
  {
    "text": "ridiculous and dangerous and nasty those things are sometimes useful",
    "start": "2490560",
    "end": "2496400"
  },
  {
    "text": "so if that's the only criteria you have for new features you don't have a",
    "start": "2496400",
    "end": "2502000"
  },
  {
    "text": "criteria so try to come up with better reasons for why you're including",
    "start": "2502000",
    "end": "2507160"
  },
  {
    "text": "things avoid universality there have been a lot of attempts at making the one universal language the language that's",
    "start": "2507160",
    "end": "2514079"
  },
  {
    "text": "good for everything that doesn't work um what seems to work better is design a",
    "start": "2514079",
    "end": "2520520"
  },
  {
    "text": "language which does one specific thing really well and chances are there are a",
    "start": "2520520",
    "end": "2526240"
  },
  {
    "text": "lot of other things that will also do really well um but at least you'll do one thing really well and that's better",
    "start": "2526240",
    "end": "2532440"
  },
  {
    "text": "than a lot of other languages can claim help people to manage complexity dealing with complexity is the most",
    "start": "2532440",
    "end": "2539119"
  },
  {
    "text": "difficult thing that we do um so finding the structures The Leverage which allows",
    "start": "2539119",
    "end": "2544200"
  },
  {
    "text": "us to to do that is really important and promote quality as much as possible we want to make programs that are really",
    "start": "2544200",
    "end": "2551839"
  },
  {
    "text": "good make new mistakes don't make the old mistakes again um inevitably you're",
    "start": "2551839",
    "end": "2557839"
  },
  {
    "text": "going to have to make some old mistakes because you can't innovate on every Dimension at the same time uh but be",
    "start": "2557839",
    "end": "2564839"
  },
  {
    "text": "really cautious as to what old mistakes you're going to propagate for example Tom Ken Thompson I think is one of the",
    "start": "2564839",
    "end": "2570079"
  },
  {
    "text": "smartest guys to have ever lived he has pushed our art so far ahead but I think",
    "start": "2570079",
    "end": "2575480"
  },
  {
    "text": "he had terrible Taste of as a syntax designer but he understood how we think",
    "start": "2575480",
    "end": "2581559"
  },
  {
    "text": "or or maybe we've been so influenced by how he thinks that we cannot see the",
    "start": "2581559",
    "end": "2586760"
  },
  {
    "text": "many mistakes that he put into C and those mistakes have been",
    "start": "2586760",
    "end": "2592040"
  },
  {
    "text": "propagated into virtually everything that's happened ever since um we don't have to keep doing that anymore the",
    "start": "2592040",
    "end": "2597920"
  },
  {
    "text": "thing that I like best about coffee script as one of the new JavaScript variants it's basically exactly the same",
    "start": "2597920",
    "end": "2605359"
  },
  {
    "text": "language as JavaScript accepted doesn't have the B flavored syntax it has a different kind of syntax instead and",
    "start": "2605359",
    "end": "2611800"
  },
  {
    "text": "it's great um it used to be said that if a new language didn't look exactly like",
    "start": "2611800",
    "end": "2617319"
  },
  {
    "text": "C it had no chance of catching on and that doesn't seem to be true anymore we're finally breaking that",
    "start": "2617319",
    "end": "2624200"
  },
  {
    "text": "after so many years so um you know do",
    "start": "2624200",
    "end": "2629480"
  },
  {
    "text": "that um let the language teach you I I recommend to people learn as many languages as you can because when you",
    "start": "2629480",
    "end": "2635760"
  },
  {
    "text": "get deep in a language it can teach you and your language can teach you too",
    "start": "2635760",
    "end": "2642000"
  },
  {
    "text": "Embrace Unicode so most of our languages are stuck with the asy set you know we",
    "start": "2642000",
    "end": "2647200"
  },
  {
    "text": "have the ASI operators Unicode is full of thousands of amazing special",
    "start": "2647200",
    "end": "2652440"
  },
  {
    "text": "characters which could be really good and effective for communicating what we want to do in our programs we're not",
    "start": "2652440",
    "end": "2658880"
  },
  {
    "text": "using those because it's it's beli that most programmers are not smart enough to be able to get codes onto the screen",
    "start": "2658880",
    "end": "2665720"
  },
  {
    "text": "unless there's a picture of it on a button that they can push I don't think that's true I I I think we can actually",
    "start": "2665720",
    "end": "2671520"
  },
  {
    "text": "puzzle that stuff out um so consider that you certainly don't want to go",
    "start": "2671520",
    "end": "2677480"
  },
  {
    "text": "crazy and you can certainly go crazy if you start putting way too many goofy characters in but we don't have enough",
    "start": "2677480",
    "end": "2684920"
  },
  {
    "text": "bracketing characters um you know we've gone to using angle brackets which was",
    "start": "2684920",
    "end": "2690760"
  },
  {
    "text": "maybe a mistake because we don't have enough other things but you know there are those wonderful Japanese corner",
    "start": "2690760",
    "end": "2697640"
  },
  {
    "text": "brackets which are great and and and the the brackets that look like that",
    "start": "2697640",
    "end": "2703720"
  },
  {
    "text": "there's a lot of opportunity um in for our languages um Leap Forward of course",
    "start": "2703720",
    "end": "2709599"
  },
  {
    "text": "don't be doing the same thing um and they're forgotten Treasures you know we",
    "start": "2709599",
    "end": "2714800"
  },
  {
    "text": "we've we're very good at Reinventing the same basic sequential language we're not",
    "start": "2714800",
    "end": "2720880"
  },
  {
    "text": "our new languages are not that different from Fortran in terms of how they're organized and what they do um but there",
    "start": "2720880",
    "end": "2727040"
  },
  {
    "text": "are things that we left along the way which are not well represented in our current languages which are worth",
    "start": "2727040",
    "end": "2733079"
  },
  {
    "text": "revisiting like State machines and constraint engines other ways of thinking about how you do things that go",
    "start": "2733079",
    "end": "2740720"
  },
  {
    "text": "beyond just one thing after another exploit parallelism one of the",
    "start": "2740720",
    "end": "2746000"
  },
  {
    "text": "biggest challenges we have is what to do with all of the Computing capability that's in front of us we're stuck with",
    "start": "2746000",
    "end": "2751880"
  },
  {
    "text": "all these sequential programming languages but as we go more and more parallel um they become less and less",
    "start": "2751880",
    "end": "2758559"
  },
  {
    "text": "effective for what we're having to do in particular in distributed programming we now have clouds and we've got lots of",
    "start": "2758559",
    "end": "2765520"
  },
  {
    "text": "cores and we don't know what to do with them so I I think that's going to be the next interesting thing for our languages",
    "start": "2765520",
    "end": "2772720"
  },
  {
    "text": "to deal with is how do we take full advantage of big big um",
    "start": "2772720",
    "end": "2780079"
  },
  {
    "text": "parallelism and then finally have fun it it really is um a nice Hobby and I think",
    "start": "2780079",
    "end": "2785400"
  },
  {
    "text": "everybody should be doing it um oh and one last thing let's get rid of these",
    "start": "2785400",
    "end": "2792800"
  },
  {
    "text": "um and don't do it the way JavaScript did the way JavaScript did it was it",
    "start": "2792800",
    "end": "2798440"
  },
  {
    "text": "left these in the grammar but allowed you to leave them out by using an error recovery mechanism so if it goes parsing",
    "start": "2798440",
    "end": "2805440"
  },
  {
    "text": "and it gets an error it'll take a nearby Line Feed turn it into a semicolon and then back up and try again it's like no",
    "start": "2805440",
    "end": "2814200"
  },
  {
    "text": "don't do that it it's pretty easy to come up with with a um semicolon free grammar do that",
    "start": "2814200",
    "end": "2821359"
  },
  {
    "text": "instead um finally if you want to know more about topown operator precedents uh there are two projects on GitHub which",
    "start": "2821359",
    "end": "2828319"
  },
  {
    "text": "are both freely available uh the first one is uh a simple uh top- down operator",
    "start": "2828319",
    "end": "2834839"
  },
  {
    "text": "precedence uh parser for simplified JavaScript written in simplified JavaScript the other is jslint which is",
    "start": "2834839",
    "end": "2843440"
  },
  {
    "text": "complicated JavaScript trying to do just the good parts which is is bigger than simplified JavaScript and then uh for",
    "start": "2843440",
    "end": "2850400"
  },
  {
    "text": "more explanation as to how it works there's a chapter in beautiful code which describes its",
    "start": "2850400",
    "end": "2856079"
  },
  {
    "text": "operation so that's what I have for you this morning thank you and good",
    "start": "2856079",
    "end": "2861120"
  },
  {
    "text": "[Applause]",
    "start": "2861120",
    "end": "2870040"
  },
  {
    "text": "night so thank you very much I know this was a pretty exciting talk it was I I",
    "start": "2870040",
    "end": "2876520"
  },
  {
    "text": "struggled to type in a question trying to follow the talk at the same time but we nonetheless do have three questions",
    "start": "2876520",
    "end": "2882200"
  },
  {
    "text": "that you guys put in and given that we have very little time I let um Douglas choose one of the questions maybe two",
    "start": "2882200",
    "end": "2887319"
  },
  {
    "text": "depending on how long the answers",
    "start": "2887319",
    "end": "2890480"
  },
  {
    "text": "are isn't language design just a special case of API design no I don't think so I",
    "start": "2892640",
    "end": "2897839"
  },
  {
    "text": "think um with API design you generally have a more specific ideas as to what's going to happen and how it's going to be",
    "start": "2897839",
    "end": "2904160"
  },
  {
    "text": "used whereas programming languages are much more General abstract tool um the challenge for programming",
    "start": "2904160",
    "end": "2912520"
  },
  {
    "text": "design is with each generation we want to level up you know so with mors law",
    "start": "2912520",
    "end": "2918520"
  },
  {
    "text": "the hardware gets to level up every two years or so right they double we only do it every 20 years or so so we are much",
    "start": "2918520",
    "end": "2925440"
  },
  {
    "text": "slower in figuring it out and most of that slowness is due to our own stubbornness and addiction to",
    "start": "2925440",
    "end": "2933040"
  },
  {
    "text": "style um you know it took us a long time to decide to get rid of go-tos cuz a lot",
    "start": "2933040",
    "end": "2938280"
  },
  {
    "text": "of people thought go-tos looked really good and didn't understand that go-tos were making programming harder and we're",
    "start": "2938280",
    "end": "2945400"
  },
  {
    "text": "at a similar place today I think with classes and some other Concepts so classes are great they've pushed the",
    "start": "2945400",
    "end": "2951960"
  },
  {
    "text": "state-of-the-art ahead tremendously but have also locked us in place and so they're preventing us from going on to",
    "start": "2951960",
    "end": "2958160"
  },
  {
    "text": "the next thing which is going to be even better so those are issues that you don't have at a in API design that's a",
    "start": "2958160",
    "end": "2965799"
  },
  {
    "text": "completely different space thank you [Applause]",
    "start": "2965799",
    "end": "2979290"
  }
]