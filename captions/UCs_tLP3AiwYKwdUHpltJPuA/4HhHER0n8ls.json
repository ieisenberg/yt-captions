[
  {
    "start": "0",
    "end": "63000"
  },
  {
    "text": "[Music]",
    "start": "3470",
    "end": "7799"
  },
  {
    "text": "welcome everyone to this talk about static code analysis actually this is sort of a journey of the or a tale of",
    "start": "11280",
    "end": "19600"
  },
  {
    "text": "the journey i've been on i've been building static code another tool myself for a while and this is sort of",
    "start": "19600",
    "end": "25519"
  },
  {
    "text": "i want to take you along on the ride what's hard about writing code analyst tool what goes on under the hood",
    "start": "25519",
    "end": "31840"
  },
  {
    "text": "what what's the tricky stuff you need to do and on the way um apart from",
    "start": "31840",
    "end": "37440"
  },
  {
    "text": "learning and having fun it's also well it'll help to understand the challenges",
    "start": "37440",
    "end": "42480"
  },
  {
    "text": "and look at tools and see to what degree which of these challenges they actually deal with",
    "start": "42480",
    "end": "48079"
  },
  {
    "text": "and i always like a talk to be interactive so if you have questions just go ahead raise your hand in between",
    "start": "48079",
    "end": "55600"
  },
  {
    "text": "in the middle rather than at the end because questions usually are better asked and answered right away",
    "start": "55600",
    "end": "62640"
  },
  {
    "text": "so static code analysis what is static code analysis in its simplest form static",
    "start": "62640",
    "end": "68159"
  },
  {
    "start": "63000",
    "end": "108000"
  },
  {
    "text": "code analysis is just command line tools sort of i mean we've all been there",
    "start": "68159",
    "end": "75040"
  },
  {
    "text": "we can look at all files there and look where an",
    "start": "75040",
    "end": "80400"
  },
  {
    "text": "invoice service is being used by greb or we can look at how much test code there is in our",
    "start": "80400",
    "end": "88640"
  },
  {
    "text": "project um this is definitely useful and this is static code analysis but and it's valid",
    "start": "88640",
    "end": "96000"
  },
  {
    "text": "and sort of none of this stuff is the right way it's just solving different problems at",
    "start": "96000",
    "end": "102000"
  },
  {
    "text": "different levels so this is definitely useful we've all done it probably but it hits limitations for example if we want",
    "start": "102000",
    "end": "108479"
  },
  {
    "start": "108000",
    "end": "153000"
  },
  {
    "text": "to know through cross-referencing if we want to figure out",
    "start": "108479",
    "end": "115560"
  },
  {
    "text": "we have a field p dot name",
    "start": "115920",
    "end": "120798"
  },
  {
    "text": "what is this actually where is this defined",
    "start": "121920",
    "end": "126718"
  },
  {
    "text": "so we will need to understand that p that there's a concept of a type person",
    "start": "127439",
    "end": "132480"
  },
  {
    "text": "which has a field name and that this p dot name refers to person dot name and",
    "start": "132480",
    "end": "137680"
  },
  {
    "text": "not city dot name which is indistinguishable at the source code level at least per line with a",
    "start": "137680",
    "end": "144160"
  },
  {
    "text": "non-us thing so we need some insights some data structures about what goes on",
    "start": "144160",
    "end": "149840"
  },
  {
    "text": "inside the code and usually i mean this is typically",
    "start": "149840",
    "end": "155040"
  },
  {
    "start": "153000",
    "end": "227000"
  },
  {
    "text": "called an abstract syntax tree um so we could start parsing the source",
    "start": "155040",
    "end": "160720"
  },
  {
    "text": "code and we could have statements like assign statements method called",
    "start": "160720",
    "end": "166800"
  },
  {
    "text": "statements we could have expressions inside these statements and then have higher level constructs like methods",
    "start": "166800",
    "end": "171920"
  },
  {
    "text": "classes etc and we could parse the source code into",
    "start": "171920",
    "end": "177200"
  },
  {
    "text": "these representations and the examples here i'll use java",
    "start": "177200",
    "end": "182319"
  },
  {
    "text": "examples because it's pretty well known but most of the stuff i'm saying applies to basically any programming language so",
    "start": "182319",
    "end": "189040"
  },
  {
    "text": "it's pretty general it's pretty applicable across the board",
    "start": "189040",
    "end": "194879"
  },
  {
    "text": "so um in order to answer questions about",
    "start": "194879",
    "end": "201599"
  },
  {
    "text": "cross-referencing or any deeper understanding we need some sort of data representation in memory of the code",
    "start": "201599",
    "end": "207760"
  },
  {
    "text": "some sort of here object-oriented representation of the code and if you want to play with this there's um open",
    "start": "207760",
    "end": "214720"
  },
  {
    "text": "source parsers for for the java language i mean basically any um",
    "start": "214720",
    "end": "220560"
  },
  {
    "text": "parser generator has a java java grammar as one of his samples",
    "start": "220560",
    "end": "227040"
  },
  {
    "start": "227000",
    "end": "333000"
  },
  {
    "text": "so let's say we have this representation i'll stick with the source with the source code here but just sort of to",
    "start": "227040",
    "end": "233200"
  },
  {
    "text": "keep in mind that we have data structures to allow us to reason about this um so um we have a",
    "start": "233200",
    "end": "241920"
  },
  {
    "text": "field access expression",
    "start": "241920",
    "end": "247439"
  },
  {
    "text": "with a base of base variable of p and a field name of name which is great",
    "start": "247439",
    "end": "253200"
  },
  {
    "text": "now we know it's a field but what does um p actually refer to",
    "start": "253200",
    "end": "259600"
  },
  {
    "text": "it can be a lot of things it's not obvious what this means it could be a local variable so we need to go look",
    "start": "259600",
    "end": "265600"
  },
  {
    "text": "backwards and see if it's a local variable but it isn't um it could be a",
    "start": "265600",
    "end": "272080"
  },
  {
    "text": "um a class name in the same package it could be a class name that's imported it",
    "start": "272080",
    "end": "278400"
  },
  {
    "text": "could be a static variable none of this but checking all these in the right",
    "start": "278400",
    "end": "283759"
  },
  {
    "text": "order of precedence we find out it's a method parameter that's declared in the signature of the",
    "start": "283759",
    "end": "288880"
  },
  {
    "text": "method so now we know p is there and at that point we see that person",
    "start": "288880",
    "end": "294880"
  },
  {
    "text": "is the type but again person can be any sort of type we still need to resolve this we need to look at the import",
    "start": "294880",
    "end": "300160"
  },
  {
    "text": "statements um or it could be a class in the same package or in the default package all",
    "start": "300160",
    "end": "305600"
  },
  {
    "text": "these kind of niceties so going with the source code is pretty onerous it's not",
    "start": "305600",
    "end": "311759"
  },
  {
    "text": "as straightforward as you'd like you need an incredibly deep understanding of the intricacies of the language in order",
    "start": "311759",
    "end": "317759"
  },
  {
    "text": "to figure out what this is this process is typically called linking sort of",
    "start": "317759",
    "end": "323280"
  },
  {
    "text": "making sense of identifiers it's possible",
    "start": "323280",
    "end": "328560"
  },
  {
    "text": "but um not necessarily what you'd want to do",
    "start": "328560",
    "end": "333759"
  },
  {
    "start": "333000",
    "end": "386000"
  },
  {
    "text": "and you need to support all the syntactic cure of the language i mean even java does have",
    "start": "333759",
    "end": "339680"
  },
  {
    "text": "syntactic cura other languages have way more syntactic sugar type inference for example if there's",
    "start": "339680",
    "end": "345360"
  },
  {
    "text": "var you need to figure out what type is behind that var",
    "start": "345360",
    "end": "350560"
  },
  {
    "text": "or if you have a lambda then you need to figure out that this lambda has the type supplier and that",
    "start": "350560",
    "end": "357440"
  },
  {
    "text": "there's a synthetic class of this type all these stuff that java does at runtime by generating code",
    "start": "357440",
    "end": "363680"
  },
  {
    "text": "using the asm library at runtime you need to figure out what it does there",
    "start": "363680",
    "end": "369680"
  },
  {
    "text": "or also um the additive types um sealed classes with",
    "start": "369680",
    "end": "375759"
  },
  {
    "text": "all the weird semantics and stuff this is all stuff you'll need to understand",
    "start": "375759",
    "end": "381039"
  },
  {
    "text": "or build understanding into your tool in order to be able to reason about source code but there's a better or a different",
    "start": "381039",
    "end": "387120"
  },
  {
    "start": "386000",
    "end": "435000"
  },
  {
    "text": "way that doesn't have these shortcomings you can look at binary code at bytecode",
    "start": "387120",
    "end": "392800"
  },
  {
    "text": "so you could parse class files which",
    "start": "392800",
    "end": "397840"
  },
  {
    "text": "did all these things class files are de-sugared they have full type information all over the place",
    "start": "397840",
    "end": "403759"
  },
  {
    "text": "they have their own challenges i mean just having this code here um",
    "start": "403759",
    "end": "410400"
  },
  {
    "text": "means stuff is resolved you need to go into byte code and if you go into invoke",
    "start": "410400",
    "end": "415440"
  },
  {
    "text": "dynamic for string concatenation becomes even more interesting so those are basically the two approaches we need and",
    "start": "415440",
    "end": "421599"
  },
  {
    "text": "some sort of object-oriented representation in memory in order to reason about your code and you can",
    "start": "421599",
    "end": "427199"
  },
  {
    "text": "either go with source code or for languages languages like java you can go with binary code",
    "start": "427199",
    "end": "435360"
  },
  {
    "start": "435000",
    "end": "515000"
  },
  {
    "text": "so which is the better choice um that depends obviously i mean if there's two choices and not just one usually means",
    "start": "435360",
    "end": "442240"
  },
  {
    "text": "that both have their place if you want to it depends on what you want to do if you want to",
    "start": "442240",
    "end": "447680"
  },
  {
    "text": "reason about the code layout comments etc or if you are interested in forward tolerant",
    "start": "447680",
    "end": "453759"
  },
  {
    "text": "parsing if you're part of an ide already that means source code has advantages",
    "start": "453759",
    "end": "460639"
  },
  {
    "text": "source code allows you to have smoother presentation of the results bytecode is",
    "start": "460639",
    "end": "465919"
  },
  {
    "text": "usually more efficient and you can leverage all the support of the compiler so most or many tools go with bytecode",
    "start": "465919",
    "end": "473039"
  },
  {
    "text": "because it's it doesn't mean it doesn't force you to keep up to date",
    "start": "473039",
    "end": "478400"
  },
  {
    "text": "with the latest version of the language it's more robust in terms of backwards compatibility",
    "start": "478400",
    "end": "484080"
  },
  {
    "text": "okay so now with these data structures it's sort of easy to understand how we",
    "start": "484080",
    "end": "489199"
  },
  {
    "text": "could reason about places where person.name is used we could just look at all field accesses and then figure",
    "start": "489199",
    "end": "495440"
  },
  {
    "text": "out what the variable is what type the variable has and if the field name is name then we'll know it's used there",
    "start": "495440",
    "end": "501599"
  },
  {
    "text": "um so this is sort of the first hurdle to take and some sort of semantic representation",
    "start": "501599",
    "end": "508560"
  },
  {
    "text": "you can reason about in memory rather than just have having text representation",
    "start": "508560",
    "end": "515200"
  },
  {
    "start": "515000",
    "end": "615000"
  },
  {
    "text": "but um obviously we can and want to go beyond that so the next step is reasoning about code",
    "start": "515519",
    "end": "523200"
  },
  {
    "text": "flows execution flows it's not just the type information statically but",
    "start": "523200",
    "end": "529440"
  },
  {
    "text": "well oftentimes many things rely on how",
    "start": "529440",
    "end": "534560"
  },
  {
    "text": "code flows or how execution flows through code so the domain i come from",
    "start": "534560",
    "end": "539920"
  },
  {
    "text": "is the security domain so that's where the examples come from and this would be a classic sql",
    "start": "539920",
    "end": "545760"
  },
  {
    "text": "injection we have a variable s which is initialized from",
    "start": "545760",
    "end": "551440"
  },
  {
    "text": "an http header which is untrusted it comes from from the http request and that is used in",
    "start": "551440",
    "end": "559120"
  },
  {
    "text": "in a jdbc connection prepare update statement or a prepare statement which means um",
    "start": "559120",
    "end": "565839"
  },
  {
    "text": "obviously it can do anything with the database we don't want this so what do we need to do",
    "start": "565839",
    "end": "571120"
  },
  {
    "text": "to figure out if this is vulnerable or not if this is actually a taint flow",
    "start": "571120",
    "end": "577360"
  },
  {
    "text": "so the and actual this the same sort of logic applies for um figuring out if variables can be null or if resources",
    "start": "577360",
    "end": "583920"
  },
  {
    "text": "get lo get close etc it's just that this is the domain the examples are from so",
    "start": "583920",
    "end": "590720"
  },
  {
    "text": "the in order to figure this we need to look at this variable and see where it",
    "start": "590720",
    "end": "596480"
  },
  {
    "text": "is used we know this variable has an untrusted value and then follow through the code",
    "start": "596480",
    "end": "602720"
  },
  {
    "text": "and see where it is used in this example that's pretty straightforward and we",
    "start": "602720",
    "end": "608399"
  },
  {
    "text": "could just do some naive implementation and get away with it would work",
    "start": "608399",
    "end": "614480"
  },
  {
    "start": "615000",
    "end": "660000"
  },
  {
    "text": "becomes trickier in real world code of course the variable can be reassigned to",
    "start": "615360",
    "end": "620399"
  },
  {
    "text": "another local variable or as a field to some object or then read from there",
    "start": "620399",
    "end": "627839"
  },
  {
    "text": "so this requires semantic understanding of what these",
    "start": "627839",
    "end": "633760"
  },
  {
    "text": "statements actually do and how they propagate data if we want to track flows execution flows we need to know or teach",
    "start": "633760",
    "end": "641760"
  },
  {
    "text": "the analysis tool what sort of data propagation happens",
    "start": "641760",
    "end": "647760"
  },
  {
    "text": "where data flows still this is i mean this looks like it's",
    "start": "647760",
    "end": "653200"
  },
  {
    "text": "honorous work but it's still sort of straightforward",
    "start": "653200",
    "end": "659600"
  },
  {
    "text": "becomes a little more interesting if we add propagators to the mix",
    "start": "659600",
    "end": "665279"
  },
  {
    "start": "660000",
    "end": "738000"
  },
  {
    "text": "um propagators are method calls that do stuff internally",
    "start": "665279",
    "end": "672240"
  },
  {
    "text": "that we don't really understand that are too complicated for us to understand but that we treat as a black box for example",
    "start": "672240",
    "end": "677680"
  },
  {
    "text": "string concatenation so we have some raw data that's from a",
    "start": "677680",
    "end": "682800"
  },
  {
    "text": "header and then we have a string concatenation with some literal and this",
    "start": "682800",
    "end": "689120"
  },
  {
    "text": "untrusted part so it's a different variable it's not just assignment so we need to know that",
    "start": "689120",
    "end": "694800"
  },
  {
    "text": "string concatenation means that if either of the input parts is untrusted",
    "start": "694800",
    "end": "700720"
  },
  {
    "text": "the result is untrusted and there's actually quite a lot of these like um",
    "start": "700720",
    "end": "706240"
  },
  {
    "text": "substring or all the java um apache common slang stuff string",
    "start": "706240",
    "end": "712880"
  },
  {
    "text": "modification so this is the first part where domain knowledge enters the mix",
    "start": "712880",
    "end": "718079"
  },
  {
    "text": "still it's sort of doable so far it's pretty deterministic i mean",
    "start": "718079",
    "end": "724959"
  },
  {
    "text": "we need to teach our tool about the different kinds of propagators but if we do that",
    "start": "724959",
    "end": "731920"
  },
  {
    "text": "we can release reliably report whether there's a flow or not",
    "start": "731920",
    "end": "738720"
  },
  {
    "start": "738000",
    "end": "864000"
  },
  {
    "text": "so enter conditional flows let's say we have a conditional",
    "start": "739440",
    "end": "746000"
  },
  {
    "text": "if a header is null we use a safe string otherwise we don't",
    "start": "746000",
    "end": "752240"
  },
  {
    "text": "um and then we have we use the result this means",
    "start": "752240",
    "end": "757440"
  },
  {
    "text": "that well there's a condition which we can't",
    "start": "757440",
    "end": "762639"
  },
  {
    "text": "really reason about in static code analysis the most common case is that we don't",
    "start": "762639",
    "end": "768720"
  },
  {
    "text": "really know which of the branches of an if statement will be hit because input is usually outside our control we don't",
    "start": "768720",
    "end": "775680"
  },
  {
    "text": "know if request.getheader can be null in a given scenario i mean in this case we",
    "start": "775680",
    "end": "782240"
  },
  {
    "text": "could sort of add domain knowledge about http headers but usually it's hard to",
    "start": "782240",
    "end": "787920"
  },
  {
    "text": "reason about so essentially this means we don't know which of the branches is",
    "start": "787920",
    "end": "793519"
  },
  {
    "text": "taken so the best we can really report is maybe",
    "start": "793519",
    "end": "799440"
  },
  {
    "text": "so there is there may be a path that is vulnerable there is maybe a path that's not vulnerable and so the usual approach",
    "start": "799519",
    "end": "806800"
  },
  {
    "text": "is to say as far as we can determine there is a vulnerable past so we report this we",
    "start": "806800",
    "end": "812800"
  },
  {
    "text": "treat this as a vulnerability because there is a valid vulnerable path",
    "start": "812800",
    "end": "819360"
  },
  {
    "text": "the same happens if well here it's more involved we have a condition that really outside",
    "start": "827519",
    "end": "834160"
  },
  {
    "text": "i mean system timer is outside our control and um",
    "start": "834160",
    "end": "841279"
  },
  {
    "text": "so it can there can be several um conditional",
    "start": "841440",
    "end": "846880"
  },
  {
    "text": "executions that can be combined so up here sks can be either safe or",
    "start": "846880",
    "end": "853360"
  },
  {
    "text": "unsafe and it can be used in different",
    "start": "853360",
    "end": "859199"
  },
  {
    "text": "paths down there so we have four combinations and this can actually explode and",
    "start": "859839",
    "end": "867360"
  },
  {
    "start": "864000",
    "end": "968000"
  },
  {
    "text": "usually does if we just naively look at all combinations this seemingly",
    "start": "867360",
    "end": "875040"
  },
  {
    "text": "harmless code takes",
    "start": "875040",
    "end": "880720"
  },
  {
    "text": "takes in the header and then the first if",
    "start": "880720",
    "end": "886880"
  },
  {
    "text": "has two different paths none of them make any have any impact on what we are doing but still it's two paths",
    "start": "886880",
    "end": "892320"
  },
  {
    "text": "and then the next line multiplies that by two so we have four paths and overall we have more than a thousand",
    "start": "892320",
    "end": "899279"
  },
  {
    "text": "paths different path through this method that we need to track so this can really really blow up that's",
    "start": "899279",
    "end": "906320"
  },
  {
    "text": "the um it's called combinatorial explosion and that's basically what it does",
    "start": "906320",
    "end": "911680"
  },
  {
    "text": "just naively looking at all combination at all possible paths is infeasible for any non-hello world code",
    "start": "911680",
    "end": "919680"
  },
  {
    "text": "so we need to start approximating and actually",
    "start": "919680",
    "end": "925040"
  },
  {
    "text": "it's mathematically proven that static code analysis can't",
    "start": "925040",
    "end": "930320"
  },
  {
    "text": "be correct there's no way to determine how a program behaves",
    "start": "930320",
    "end": "938320"
  },
  {
    "text": "it's not sure what's in english theorem in or had a problem in in german there's no",
    "start": "938320",
    "end": "943600"
  },
  {
    "text": "way to write a program that determines if another program terminates that sort of thing so we need to do to make",
    "start": "943600",
    "end": "949920"
  },
  {
    "text": "approximations and this is where it becomes tricky yes hotting problem thank you",
    "start": "949920",
    "end": "957279"
  },
  {
    "text": "so um we don't want to treat to look at all these uh more than a thousand parts especially",
    "start": "957920",
    "end": "963519"
  },
  {
    "text": "if they don't do it do anything they're not totally irrelevant for what we're interested in so one common approach to",
    "start": "963519",
    "end": "970240"
  },
  {
    "start": "968000",
    "end": "1013000"
  },
  {
    "text": "one common solution to to doing this is merging",
    "start": "970240",
    "end": "975839"
  },
  {
    "text": "here um the the idea with merging is that",
    "start": "976800",
    "end": "984399"
  },
  {
    "text": "that where the two that when two branches merge we treat them as one single branch with",
    "start": "984399",
    "end": "990639"
  },
  {
    "text": "either or so here we'd have um at this point we'd say",
    "start": "990639",
    "end": "996639"
  },
  {
    "text": "s is we just continue with a single flow from here saying s can be",
    "start": "996639",
    "end": "1003759"
  },
  {
    "text": "tainted as can be can have untrusted content and just",
    "start": "1003759",
    "end": "1009759"
  },
  {
    "text": "move it with a single flow from here so with this example",
    "start": "1009759",
    "end": "1015120"
  },
  {
    "start": "1013000",
    "end": "1054000"
  },
  {
    "text": "it would mean that we'd have two different parts through each of these lines but after each line",
    "start": "1015120",
    "end": "1021279"
  },
  {
    "text": "we just treat them as another just just as a single execution so it's additive",
    "start": "1021279",
    "end": "1027199"
  },
  {
    "text": "it's better instead of multiplicative so that we don't have a thousand parts but 11 paths",
    "start": "1027199",
    "end": "1034160"
  },
  {
    "text": "because we just well we go with two paths for each line but afterwards we merge them",
    "start": "1034160",
    "end": "1041438"
  },
  {
    "text": "this is pretty powerful in getting a",
    "start": "1041439",
    "end": "1046558"
  },
  {
    "text": "grip on complexity on terminating in and",
    "start": "1046559",
    "end": "1051840"
  },
  {
    "text": "well in finite time but it comes as a price at a price um",
    "start": "1051840",
    "end": "1058400"
  },
  {
    "start": "1054000",
    "end": "1117000"
  },
  {
    "text": "so um the first condition is s is maybe",
    "start": "1058400",
    "end": "1065840"
  },
  {
    "text": "tainted because it's well it's tainted or maybe safe and then at a different point we",
    "start": "1065840",
    "end": "1072880"
  },
  {
    "text": "know the condition we look at the condition the same condition which we ignored",
    "start": "1072880",
    "end": "1077919"
  },
  {
    "text": "and we go through either call this or not",
    "start": "1077919",
    "end": "1083679"
  },
  {
    "text": "and since we merged here there's no way we can ever see that this is safe",
    "start": "1083679",
    "end": "1090960"
  },
  {
    "text": "because if the condition is true s is safe and only if the same condition is true",
    "start": "1090960",
    "end": "1096080"
  },
  {
    "text": "s is used in a dangerous way so merging means we give up precision",
    "start": "1096080",
    "end": "1101440"
  },
  {
    "text": "for speed which is one of the typical trade-offs we have in static code analysis",
    "start": "1101440",
    "end": "1106960"
  },
  {
    "text": "um",
    "start": "1106960",
    "end": "1109840"
  },
  {
    "text": "so we're going to look at refinements of this",
    "start": "1112080",
    "end": "1118320"
  },
  {
    "start": "1117000",
    "end": "1215000"
  },
  {
    "text": "one interesting thing to statically analyze is loops",
    "start": "1119679",
    "end": "1126559"
  },
  {
    "text": "because we go through the same code several times",
    "start": "1126559",
    "end": "1132000"
  },
  {
    "text": "but with different potentially different values in the variables which is not something we can just cover with our",
    "start": "1132000",
    "end": "1138799"
  },
  {
    "text": "naive approach we had so far so",
    "start": "1138799",
    "end": "1145120"
  },
  {
    "text": "in this case in the first go c is ju only c is tainted but then",
    "start": "1145840",
    "end": "1152400"
  },
  {
    "text": "in the assignment at the beginning b becomes tainted but a is used so it's safe on the first go but then in the",
    "start": "1152400",
    "end": "1158720"
  },
  {
    "text": "second pass ape is assigned the taint from b so only",
    "start": "1158720",
    "end": "1163760"
  },
  {
    "text": "if we go through this loop if we scan through this loop twice do we find the vulnerability",
    "start": "1163760",
    "end": "1169440"
  },
  {
    "text": "but still we don't want to to just scan any loop an infinite number",
    "start": "1169440",
    "end": "1175760"
  },
  {
    "text": "of times so it's important to figure out how to um how to terminate this one",
    "start": "1175760",
    "end": "1181280"
  },
  {
    "text": "naive approach is to just limit to have a an upper limit of the times",
    "start": "1181280",
    "end": "1187360"
  },
  {
    "text": "of the number of times we want to go through the same code and um yeah there's better ways but",
    "start": "1187360",
    "end": "1193360"
  },
  {
    "text": "that's the eve approach and obviously we need some sort of solution because we don't want to go through code just once",
    "start": "1193360",
    "end": "1198799"
  },
  {
    "text": "or and we don't want to go in an infinite number of times so having a finite upper limit is",
    "start": "1198799",
    "end": "1204000"
  },
  {
    "text": "a pretty common simple compromise",
    "start": "1204000",
    "end": "1208320"
  },
  {
    "text": "and just an illustration that it is",
    "start": "1210880",
    "end": "1216080"
  },
  {
    "start": "1215000",
    "end": "1244000"
  },
  {
    "text": "impossible to be fully precise in static code analysis",
    "start": "1216080",
    "end": "1221280"
  },
  {
    "text": "um here we have a taint in variable s have an number n i mean this is the",
    "start": "1221280",
    "end": "1226880"
  },
  {
    "text": "three n plus one problem essentially so we don't know if this code ever reaches",
    "start": "1226880",
    "end": "1232400"
  },
  {
    "text": "or is guaranteed to reach the update because yeah it is one of the classic",
    "start": "1232400",
    "end": "1238320"
  },
  {
    "text": "mathematical problems that are unsolved if this always gets to one",
    "start": "1238320",
    "end": "1244240"
  },
  {
    "start": "1244000",
    "end": "1300000"
  },
  {
    "text": "so far all all the stuff we've been looking at has been inside a single function inside a single method so let's",
    "start": "1245679",
    "end": "1253039"
  },
  {
    "text": "look at what happens if we do add function calls to the mix um so we start with a method that had",
    "start": "1253039",
    "end": "1260400"
  },
  {
    "text": "taints s and calls or calls source for a method and then",
    "start": "1260400",
    "end": "1265440"
  },
  {
    "text": "puts puts the result as a parameter into sync source takes the the http header syncs does the um",
    "start": "1265440",
    "end": "1274559"
  },
  {
    "text": "the prepare statement call so forth and these are static methods so deterministic and clear where the calls",
    "start": "1274559",
    "end": "1281120"
  },
  {
    "text": "go and essentially for these kind of function calls we could just treat them as inlined just",
    "start": "1281120",
    "end": "1287919"
  },
  {
    "text": "scan through them with the variable name mappings but essentially scan through them as if they were in line that's",
    "start": "1287919",
    "end": "1293600"
  },
  {
    "text": "simple that's the simple part there's no big challenge there",
    "start": "1293600",
    "end": "1299280"
  },
  {
    "text": "things become interested in interesting of course if we add recursion",
    "start": "1299280",
    "end": "1304480"
  },
  {
    "start": "1300000",
    "end": "1346000"
  },
  {
    "text": "um so um sort of similar to to the stuff we had with loops",
    "start": "1304480",
    "end": "1312159"
  },
  {
    "text": "again um we can shift stuff through variables so that",
    "start": "1312159",
    "end": "1317919"
  },
  {
    "text": "only after in this case two calls to recursive calls do we actually hit the vulnerability same problem we need some",
    "start": "1317919",
    "end": "1324480"
  },
  {
    "text": "sort of limitation if we just merge naively",
    "start": "1324480",
    "end": "1329760"
  },
  {
    "text": "we'll lose this because we don't um when we well we'd hit the same line",
    "start": "1329760",
    "end": "1337200"
  },
  {
    "text": "twice and get rid of it and terminate so this is",
    "start": "1337200",
    "end": "1344000"
  },
  {
    "text": "pretty similar to the loop thing virtual method calls makes it makes",
    "start": "1344000",
    "end": "1349360"
  },
  {
    "start": "1346000",
    "end": "1445000"
  },
  {
    "text": "things really interesting big challenge for static are not anal static code analysis tools because",
    "start": "1349360",
    "end": "1356000"
  },
  {
    "text": "polymorphism is essentially the goal of polymorphism is essentially",
    "start": "1356000",
    "end": "1362000"
  },
  {
    "text": "the opposite of static code analysis static code analysis is about looking at",
    "start": "1362000",
    "end": "1367600"
  },
  {
    "text": "the caller at the core code that does the call and figuring out and being precise about what it does whereas",
    "start": "1367600",
    "end": "1374240"
  },
  {
    "text": "polymorphism is about hiding this and making it hard to figure out at the side of the call",
    "start": "1374240",
    "end": "1380320"
  },
  {
    "text": "so in this case we have an interface with with a method do it and two",
    "start": "1380320",
    "end": "1386720"
  },
  {
    "text": "implementations a and b one of them save one of them dangerous and we call that polymorphically and um",
    "start": "1386720",
    "end": "1393039"
  },
  {
    "text": "essentially we we have no way of knowing which of them is called here so sort of fanning fan out is the",
    "start": "1393039",
    "end": "1400840"
  },
  {
    "text": "um well the reasonable way of doing this sort of it might be either one or the other so it's either or sort of similar",
    "start": "1400840",
    "end": "1408000"
  },
  {
    "text": "with a conditional um this however is",
    "start": "1408000",
    "end": "1415039"
  },
  {
    "text": "it's not as straightforward that this is easy or this makes sense because the result",
    "start": "1415039",
    "end": "1421360"
  },
  {
    "text": "of scanning my service depends on what else is on the class path",
    "start": "1421360",
    "end": "1427360"
  },
  {
    "text": "so um if we add class b to the class path we have a vulnerability in my service and",
    "start": "1427360",
    "end": "1434400"
  },
  {
    "text": "if b is not on the class path um this changes the result which can be",
    "start": "1434400",
    "end": "1440080"
  },
  {
    "text": "surprising so it's sort of subtle side effect here",
    "start": "1440080",
    "end": "1445840"
  },
  {
    "start": "1445000",
    "end": "1593000"
  },
  {
    "text": "the one typical approach to",
    "start": "1447039",
    "end": "1452480"
  },
  {
    "text": "to dealing with virtual method calls is to create a call graph up front so if you ever",
    "start": "1452480",
    "end": "1459200"
  },
  {
    "text": "hear or read about a call graph this this is where that comes into play",
    "start": "1459200",
    "end": "1464799"
  },
  {
    "text": "um the idea is to look at the calling code so the invocation of",
    "start": "1464799",
    "end": "1471600"
  },
  {
    "text": "c dot accept and figure out um which",
    "start": "1471600",
    "end": "1477360"
  },
  {
    "text": "which implementations it could go to with an eve approach we just have it would be both",
    "start": "1477360",
    "end": "1483840"
  },
  {
    "text": "so it would be um both safe and not safe but in this concrete case we could look at the code",
    "start": "1483840",
    "end": "1492000"
  },
  {
    "text": "before or surrounding the invocation and see that c actually is",
    "start": "1492000",
    "end": "1497760"
  },
  {
    "text": "initialized with an instance of safe so in this case we could construct the call graph to see",
    "start": "1497760",
    "end": "1503840"
  },
  {
    "text": "that to know that it's only the safe variant that can ever be called here because it can't be the unsafe one the",
    "start": "1503840",
    "end": "1510799"
  },
  {
    "text": "reference c is actually the consumer but in this case we know the concrete subtype so we can construct a core graph",
    "start": "1510799",
    "end": "1517200"
  },
  {
    "text": "this way um yes would you not want to know that there is a risk",
    "start": "1517200",
    "end": "1522880"
  },
  {
    "text": "that at some point you might include the question is don't i want to know",
    "start": "1522880",
    "end": "1528640"
  },
  {
    "text": "about the risk of at some point including the the not safe um it sort of it depends on what kind of",
    "start": "1528640",
    "end": "1535760"
  },
  {
    "text": "analysis you're doing um but the usual approach usually you want to reason about the code as it is",
    "start": "1535760",
    "end": "1542799"
  },
  {
    "text": "and in this case actually there's a constructor new save right before the invocation",
    "start": "1542799",
    "end": "1547919"
  },
  {
    "text": "so and and as long as you don't change that adding it not safe would not change anything but yeah good good point there",
    "start": "1547919",
    "end": "1554640"
  },
  {
    "text": "may be scenarios where you want to um reason about potential changes but",
    "start": "1554640",
    "end": "1560640"
  },
  {
    "text": "usually it's about the code as it is so building the um they're better so",
    "start": "1560640",
    "end": "1567600"
  },
  {
    "text": "they're better algorithms better ways of constructing the call graph than easily going for all possible implementations",
    "start": "1567600",
    "end": "1575120"
  },
  {
    "text": "you can take into account the code before that and reason about the subset of concrete of subtypes that can",
    "start": "1575120",
    "end": "1582400"
  },
  {
    "text": "actually be behind the reference still it would be from the course site",
    "start": "1582400",
    "end": "1589279"
  },
  {
    "text": "based on the call side statically to wherever it goes but this is limited um",
    "start": "1589279",
    "end": "1595360"
  },
  {
    "start": "1593000",
    "end": "1668000"
  },
  {
    "text": "so let's say we have code like this where we have two branches one of them",
    "start": "1595360",
    "end": "1601840"
  },
  {
    "text": "has has a tainted variable s but a safe implementation of the",
    "start": "1601840",
    "end": "1607039"
  },
  {
    "text": "consumer and the other initializes s in a safe way but has a",
    "start": "1607039",
    "end": "1612720"
  },
  {
    "text": "not has the unsafe consumer and if we merge this there's no way if",
    "start": "1612720",
    "end": "1618320"
  },
  {
    "text": "we just use a call graph here well we know that s can be tainted or not tainted and based on the core graph",
    "start": "1618320",
    "end": "1625919"
  },
  {
    "text": "c can be not safe or safe so we'd report a vulnerability which it would be approx positive",
    "start": "1625919",
    "end": "1634559"
  },
  {
    "text": "so in order to avoid this false positive we need to reason about",
    "start": "1634880",
    "end": "1640399"
  },
  {
    "text": "the um the flow we need to be correlate the taint and the type of the consumer",
    "start": "1640399",
    "end": "1648399"
  },
  {
    "text": "at the flow and this is something that can't be done with a call up front so this is stuff that will always create a",
    "start": "1648399",
    "end": "1655600"
  },
  {
    "text": "false positive with a static analysis tool that's based on call graphs",
    "start": "1655600",
    "end": "1661440"
  },
  {
    "text": "call graphs are inherently limited by this",
    "start": "1661440",
    "end": "1667000"
  },
  {
    "start": "1668000",
    "end": "1797000"
  },
  {
    "text": "um another aspect of or another thing that's tricky",
    "start": "1668480",
    "end": "1674240"
  },
  {
    "text": "to do and that makes static and static code analysis interesting in a good way",
    "start": "1674240",
    "end": "1681120"
  },
  {
    "text": "is aliasing so let's say we have two string builders a and one",
    "start": "1681120",
    "end": "1688399"
  },
  {
    "text": "string builder with two variables pointing to it and so b and a are the same object but",
    "start": "1688399",
    "end": "1694240"
  },
  {
    "text": "different variables so and we append something to a that's unsafe and then we use b in a different place",
    "start": "1694240",
    "end": "1700960"
  },
  {
    "text": "as a sql string then we need to well in order to see that",
    "start": "1700960",
    "end": "1707200"
  },
  {
    "text": "this is a true positive that this is vulnerable code we'd need to",
    "start": "1707200",
    "end": "1713120"
  },
  {
    "text": "be aware that a and b are actually the same thing which can be due to",
    "start": "1713120",
    "end": "1718480"
  },
  {
    "text": "some assignment in a total in a totally different place that took place where",
    "start": "1718480",
    "end": "1724159"
  },
  {
    "text": "long a long time totally different part of the code than where we",
    "start": "1724159",
    "end": "1729440"
  },
  {
    "text": "started knowing that there would even be a taint involved so tracking of aliases",
    "start": "1729440",
    "end": "1735120"
  },
  {
    "text": "is one of the really tricky and expensive things to do tracking all aliases all the time is",
    "start": "1735120",
    "end": "1743679"
  },
  {
    "text": "prohibitively expensive if done in a naive way because we can't just globally",
    "start": "1743679",
    "end": "1750559"
  },
  {
    "text": "track which variable is alias with which variable especially if you have flow sensitivity to the match to the to the",
    "start": "1750559",
    "end": "1756480"
  },
  {
    "text": "mix um so there's sophisticated algorithms around this like querying backwards",
    "start": "1756480",
    "end": "1763840"
  },
  {
    "text": "where in the place where the variable is used to figure out what potential aliases there are",
    "start": "1763840",
    "end": "1769679"
  },
  {
    "text": "but this is really tricky especially since um well we are doing stuff like merging so yeah",
    "start": "1769679",
    "end": "1777200"
  },
  {
    "text": "and i'm not presenting any answers here it's just this is one of the tricky stuff",
    "start": "1777200",
    "end": "1782559"
  },
  {
    "text": "this and this is something to check your if you want to sort of crash or",
    "start": "1782559",
    "end": "1788640"
  },
  {
    "text": "find the limitations of a static code analysis tool um working with aliasing is definitely one place to go",
    "start": "1788640",
    "end": "1795840"
  },
  {
    "text": "so um so far it's been about the technical side and there's way more that i can't",
    "start": "1796320",
    "end": "1803440"
  },
  {
    "start": "1797000",
    "end": "1918000"
  },
  {
    "text": "go into here like reflection and stuff but there's other parts that i'd like to",
    "start": "1803440",
    "end": "1809919"
  },
  {
    "text": "to point out that are highly relevant for static code analysis one of them is",
    "start": "1809919",
    "end": "1816799"
  },
  {
    "text": "framework awareness it's tempting or i mean we're all geeks at",
    "start": "1816799",
    "end": "1822399"
  },
  {
    "text": "heart so if we start writing a static code analysis tool what we care about is the",
    "start": "1822399",
    "end": "1828559"
  },
  {
    "text": "algorithmic side the stuff we've been talking about so far but in order for this to have real world",
    "start": "1828559",
    "end": "1834720"
  },
  {
    "text": "value it needs to be aware of the details of frameworks for examples",
    "start": "1834720",
    "end": "1840799"
  },
  {
    "text": "with spring there's a put mapping here",
    "start": "1840799",
    "end": "1847200"
  },
  {
    "text": "so we know that this is actually a part where we should start scanning",
    "start": "1847200",
    "end": "1853200"
  },
  {
    "text": "we know that we see that this a request produces application json",
    "start": "1854799",
    "end": "1860080"
  },
  {
    "text": "which means it's not vulnerable to cross-site scripting because it doesn't generate html",
    "start": "1860080",
    "end": "1868000"
  },
  {
    "text": "and we know that the request body the annotation at request body means",
    "start": "1868960",
    "end": "1875519"
  },
  {
    "text": "that this parameter is tainted because it was json dc realized",
    "start": "1875519",
    "end": "1882080"
  },
  {
    "text": "um so and this just this just to give an exam",
    "start": "1882080",
    "end": "1887120"
  },
  {
    "text": "as a simple example and this sort of framework knowledge is totally unsexy it's not",
    "start": "1887120",
    "end": "1892399"
  },
  {
    "text": "really tempting for us geeks to do but it's highly relevant for creating static",
    "start": "1892399",
    "end": "1897679"
  },
  {
    "text": "code analysis tools static code analysis tools good tools aren't just about",
    "start": "1897679",
    "end": "1902960"
  },
  {
    "text": "solving the algorithmic things um that's sort of what academia does where",
    "start": "1902960",
    "end": "1908080"
  },
  {
    "text": "academic papers are great but it's about doing the tedious work of getting framework and library details and",
    "start": "1908080",
    "end": "1914159"
  },
  {
    "text": "actually domain knowledge into the tool one big area that's",
    "start": "1914159",
    "end": "1922480"
  },
  {
    "start": "1918000",
    "end": "2018000"
  },
  {
    "text": "part of the user experience of static code analysis tool is figuring out which findings are",
    "start": "1922480",
    "end": "1929039"
  },
  {
    "text": "unique which findings we actually want to re repeat to have reported as",
    "start": "1929039",
    "end": "1934080"
  },
  {
    "text": "separate findings in this example we have a single header that's being read and",
    "start": "1934080",
    "end": "1940399"
  },
  {
    "text": "then um we have two conditional broad should co2 well we",
    "start": "1940399",
    "end": "1945679"
  },
  {
    "text": "have a conditional flow that uses this as a sql update in both cases",
    "start": "1945679",
    "end": "1952240"
  },
  {
    "text": "probably something we'd want to have see reported",
    "start": "1952240",
    "end": "1957440"
  },
  {
    "text": "not totally sure but this is pretty much on the end yeah this makes sense",
    "start": "1957440",
    "end": "1963120"
  },
  {
    "text": "but what about this one we have a single header and we have conditional flow that modifies this in different ways and then",
    "start": "1963120",
    "end": "1969600"
  },
  {
    "text": "a single sql update do we want to report this no totally sure becomes more vague",
    "start": "1969600",
    "end": "1976480"
  },
  {
    "text": "and then the typical um sequel string building pattern",
    "start": "1976480",
    "end": "1982080"
  },
  {
    "text": "we have a single taint and then we have a sequel lots of conditionals that modify this",
    "start": "1982080",
    "end": "1988960"
  },
  {
    "text": "and it's used we probably not we'd probably not want this used as reported as several findings because it's",
    "start": "1988960",
    "end": "1995120"
  },
  {
    "text": "essentially the same thing which is obvious to us as developers and being and sort of getting the tool to do",
    "start": "1995120",
    "end": "2002000"
  },
  {
    "text": "things in the way that make sense that's obvious to us as developers is the tricky part",
    "start": "2002000",
    "end": "2007200"
  },
  {
    "text": "this is highly important for building static codes analysis tool and it's it's often overlooked because",
    "start": "2007200",
    "end": "2013760"
  },
  {
    "text": "it's it's not the technical side it's the ux side of things so",
    "start": "2013760",
    "end": "2020080"
  },
  {
    "start": "2018000",
    "end": "2089000"
  },
  {
    "text": "any tool as i said static code analysis can't be right there's no way for static",
    "start": "2020080",
    "end": "2025840"
  },
  {
    "text": "code analysis tool tools to present correct results so it's all about trade-offs and there's",
    "start": "2025840",
    "end": "2033039"
  },
  {
    "text": "two three ends of the spectrum one of the spectrum is um we report every potential",
    "start": "2033039",
    "end": "2039200"
  },
  {
    "text": "problem and so if we don't report it you can be sure there's no problem",
    "start": "2039200",
    "end": "2046799"
  },
  {
    "text": "which on the other hand means that there's 99 percent or 95 in real world",
    "start": "2046799",
    "end": "2052079"
  },
  {
    "text": "scenarios or false positives that you need to sift through and in practice this usually doesn't work",
    "start": "2052079",
    "end": "2058960"
  },
  {
    "text": "out so well because people start being stopped being interested in looking at the results because no one wants to sift",
    "start": "2058960",
    "end": "2065679"
  },
  {
    "text": "through tons of false positives all the time the other end of the spectrum is if we report something it's worth",
    "start": "2065679",
    "end": "2073200"
  },
  {
    "text": "looking at because it's practically guaranteed to be a true positive which is usually harder",
    "start": "2073200",
    "end": "2079520"
  },
  {
    "text": "harder to do but is often in practice the more worthwhile approach",
    "start": "2079520",
    "end": "2087240"
  },
  {
    "start": "2089000",
    "end": "2158000"
  },
  {
    "text": "um this is my categorization of static code analysis tools in terms of their sophistication",
    "start": "2089440",
    "end": "2096960"
  },
  {
    "text": "of what they can do the basic level is sort of based grep and linux or unix command",
    "start": "2096960",
    "end": "2104720"
  },
  {
    "text": "line tools then there is structural matching with based on an ast on top of them on top of",
    "start": "2104720",
    "end": "2110480"
  },
  {
    "text": "that and then there is simple flow based stuff usually with merging and k",
    "start": "2110480",
    "end": "2116320"
  },
  {
    "text": "limiting um which is which does add simple flow support but is very limited in terms of",
    "start": "2116320",
    "end": "2124320"
  },
  {
    "text": "well it it has high rates of false positives false negatives and all these scenarios i showed will get this kind of",
    "start": "2124320",
    "end": "2130079"
  },
  {
    "text": "tooling out of step and then there is what i'd call full blown support",
    "start": "2130079",
    "end": "2135359"
  },
  {
    "text": "with um sophisticated optimizations that",
    "start": "2135359",
    "end": "2140560"
  },
  {
    "text": "go way beyond what i can tell here but that address the the tricky parts and go",
    "start": "2140560",
    "end": "2146800"
  },
  {
    "text": "beyond merging and k limiting in order to have more precise results which is",
    "start": "2146800",
    "end": "2152160"
  },
  {
    "text": "very tricky to do but um yeah that's sort of the highest level of sophistication as i see it so to sum up",
    "start": "2152160",
    "end": "2161520"
  },
  {
    "start": "2158000",
    "end": "2230000"
  },
  {
    "text": "this is an overview of stuff that is tricky to analyze",
    "start": "2161839",
    "end": "2167839"
  },
  {
    "text": "for static code analysis reflection obviously um recursion i mean",
    "start": "2167839",
    "end": "2173440"
  },
  {
    "text": "reflection means there's strings being that we need to interpret and",
    "start": "2173440",
    "end": "2178960"
  },
  {
    "text": "yeah in the most general case it's impossible which makes analyzing javascript",
    "start": "2178960",
    "end": "2184960"
  },
  {
    "text": "a highly interesting undertaking because it's not called reflection in javascript but javascript essentially does",
    "start": "2184960",
    "end": "2191359"
  },
  {
    "text": "reflection in every single line of code recursion obviously polymorphic calls as",
    "start": "2191359",
    "end": "2196960"
  },
  {
    "text": "i said um aliasing sure um then there's excess um accessing maps by value but with literal",
    "start": "2196960",
    "end": "2205040"
  },
  {
    "text": "keys so if you put stuff into a map and get it out in a different place correlating that can be tricky",
    "start": "2205040",
    "end": "2211200"
  },
  {
    "text": "um correlating conditionals all these kind of code that use the same condition in several places and figuring that",
    "start": "2211200",
    "end": "2217839"
  },
  {
    "text": "those two are essentially correlated is one of the tricky things and then all this these niceties of",
    "start": "2217839",
    "end": "2224800"
  },
  {
    "text": "framework and library awareness and yeah so",
    "start": "2224800",
    "end": "2231119"
  },
  {
    "start": "2230000",
    "end": "2257000"
  },
  {
    "text": "that's it thank you very much for listening and if you're interested you can well approach me i'll be at the",
    "start": "2231119",
    "end": "2236400"
  },
  {
    "text": "conference or you can join me at the booth or whatever thank you very much",
    "start": "2236400",
    "end": "2243000"
  },
  {
    "text": "[Applause]",
    "start": "2243300",
    "end": "2246499"
  },
  {
    "text": "you",
    "start": "2256079",
    "end": "2258160"
  }
]