[
  {
    "start": "0",
    "end": "41000"
  },
  {
    "text": "[Music] thank you",
    "start": "3600",
    "end": "9799"
  },
  {
    "text": "well good morning Lambda Chan it's very nice to be here um I do please um uh give me some ask",
    "start": "10440",
    "end": "18240"
  },
  {
    "text": "questions during the talk I'll be watching the um the slack Channel um while I'm talking there's a 30 second delay but we'll manage that but it would",
    "start": "18240",
    "end": "25560"
  },
  {
    "text": "reassure me like are any of you actually there so please uh please type things in there good this is a um this is a",
    "start": "25560",
    "end": "32700"
  },
  {
    "text": "technical talk but I'd really like you to um to stay on board and to stay with me throughout because I think you could",
    "start": "32700",
    "end": "38280"
  },
  {
    "text": "I think you can get to the end um without much difficulty so here's the problem here's the problem we want to",
    "start": "38280",
    "end": "44879"
  },
  {
    "start": "41000",
    "end": "75000"
  },
  {
    "text": "find in a program term we want to find all the equivalent sub expressions and",
    "start": "44879",
    "end": "50520"
  },
  {
    "text": "do something like common sub expression analysis so here's an example in which I've got a function with two occurrences of the sub expression X plus one and I'd",
    "start": "50520",
    "end": "57360"
  },
  {
    "text": "just like to share them with the let um this is usually called common sub expression elimination but another",
    "start": "57360",
    "end": "62460"
  },
  {
    "text": "variant of this kind of thing is simply to save space when representing program trees and as we'll see that's subtly",
    "start": "62460",
    "end": "68880"
  },
  {
    "text": "different to um uh to show in program terms in common sub expression elimination so that's",
    "start": "68880",
    "end": "74400"
  },
  {
    "text": "more or less the problem but I want to add one gloss to the problem which is this that we'd like to analyze the",
    "start": "74400",
    "end": "82140"
  },
  {
    "text": "expression to find equivalent sub Expressions but then we'd like to make a small rewrite somewhere in the big expression that we started with and then",
    "start": "82140",
    "end": "88500"
  },
  {
    "text": "fix up the analysis so that we're still tracking all equivalent sub-expressions so that is with like an incremental",
    "start": "88500",
    "end": "94259"
  },
  {
    "text": "algorithm in which we can make a small change to the input and make a small change to the um equivalence classes",
    "start": "94259",
    "end": "100020"
  },
  {
    "text": "rather than starting again from scratch okay so we want an incremental story so",
    "start": "100020",
    "end": "105420"
  },
  {
    "text": "this would be appropriate if you were building a compiler that was doing rewrites as it went um great oh look where's this and",
    "start": "105420",
    "end": "112020"
  },
  {
    "start": "108000",
    "end": "170000"
  },
  {
    "text": "where's where he is in the in the slack Channel thank you that's very reassuring um so uh idea number one is just to use",
    "start": "112020",
    "end": "118920"
  },
  {
    "text": "hashconzing right I think you probably all know about hashconzing you say every node in the tree has a hash value and when you're building a new node say that",
    "start": "118920",
    "end": "125219"
  },
  {
    "text": "X plus one node you first of all compute the hashes of the um of the children um and then you compute the hash of the",
    "start": "125219",
    "end": "131700"
  },
  {
    "text": "new node from the hashes of the children and maybe the plus operator you look it up in a global hash table and if it's",
    "start": "131700",
    "end": "137700"
  },
  {
    "text": "not there you allocate the node and insert it in the hash table and if it is there you just reuse the existing one so",
    "start": "137700",
    "end": "144420"
  },
  {
    "text": "it's just like a memo function really we're taking the the node Constructor functions and we're just memorizing it",
    "start": "144420",
    "end": "149580"
  },
  {
    "text": "in this table um and one nice thing about hash conting by the way is that it's very incremental right so if you make a small rewrite",
    "start": "149580",
    "end": "156060"
  },
  {
    "text": "every new node that you construct after the rewrite you just take the hashes of the children and look them up in the",
    "start": "156060",
    "end": "161220"
  },
  {
    "text": "hash table and extend the hash table so we'll remember essentially everything you've ever seen okay so this is very nice very",
    "start": "161220",
    "end": "168180"
  },
  {
    "text": "incremental very fast no problem right but it doesn't work very well when you have Lambda so here's an example",
    "start": "168180",
    "end": "174780"
  },
  {
    "start": "170000",
    "end": "218000"
  },
  {
    "text": "um this is um uh um this is a program that has a couple",
    "start": "174780",
    "end": "181920"
  },
  {
    "text": "of sub-expressions X plus one but they're not the same because those X Plus ones are bound by different lambdas",
    "start": "181920",
    "end": "190379"
  },
  {
    "text": "okay so um uh you might um uh for structure sharing whether you're eight and your",
    "start": "190379",
    "end": "196739"
  },
  {
    "text": "aim is only to save memory it's fine to share them but for common sub Expressions totally not right you couldn't possibly say let t equal x plus",
    "start": "196739",
    "end": "203400"
  },
  {
    "text": "one in and then because t x wouldn't be in scope so for common sub-expression we have to regard these as separate",
    "start": "203400",
    "end": "209220"
  },
  {
    "text": "regarding them as the same as a kind of false positive okay those of you having video trouble I",
    "start": "209220",
    "end": "215159"
  },
  {
    "text": "hope you can sort it out I don't think I can help you um now it's easy to avoid these kind of",
    "start": "215159",
    "end": "221400"
  },
  {
    "start": "218000",
    "end": "250000"
  },
  {
    "text": "source false positives um just by the expedience of making every Lander um have a different binder",
    "start": "221400",
    "end": "227400"
  },
  {
    "text": "right so we have instead of using Lambda Expo times we could use some Lambda y uh instead and that would avoid avoid these",
    "start": "227400",
    "end": "233819"
  },
  {
    "text": "kind of false positives um but really the The Meta goal of this particular slide is to say um we can",
    "start": "233819",
    "end": "239760"
  },
  {
    "text": "avoid it but we do need to be clear about what we mean by equivalence this equivalence for structure sharing and equivalence for the common sub",
    "start": "239760",
    "end": "246180"
  },
  {
    "text": "expressions are different and you might have other equivalences um a bit as well okay",
    "start": "246180",
    "end": "252659"
  },
  {
    "start": "250000",
    "end": "304000"
  },
  {
    "text": "um now here is an example though in which we",
    "start": "252659",
    "end": "258419"
  },
  {
    "text": "might get a false negative right so here is some uh an ex with this program has",
    "start": "258419",
    "end": "264479"
  },
  {
    "text": "two sub Expressions Lambda X X plus one and Lambda YY plus one and you and I know that these are morally the same",
    "start": "264479",
    "end": "270300"
  },
  {
    "text": "thing they are actually Alpha equivalents like we would like to share those and change that into G apply to T",
    "start": "270300",
    "end": "276180"
  },
  {
    "text": "and T with that if we were doing just doing common sub-expression so here is something that but that hash counting",
    "start": "276180",
    "end": "281940"
  },
  {
    "text": "will not discover look hopefully we're back in back in back in sync good uh so what was I saying here",
    "start": "281940",
    "end": "289020"
  },
  {
    "text": "here are two expressions with uh here's an expression with two Lambda Expressions that look different but you",
    "start": "289020",
    "end": "294360"
  },
  {
    "text": "and I know they are the same they're Alpha equivalent and we'd like to share them right in the in the bottom let t equal x Lambda X X plus one and G of",
    "start": "294360",
    "end": "300840"
  },
  {
    "text": "back to T and T right because they are alpha equivalent okay so um hash conting doesn't do this",
    "start": "300840",
    "end": "308100"
  },
  {
    "start": "304000",
    "end": "379000"
  },
  {
    "text": "so here's an example with um you know X plus one and Y plus one and these of",
    "start": "308100",
    "end": "313320"
  },
  {
    "text": "course have different hashes and they should be different like X and Y well they're different nodes they have different ashes",
    "start": "313320",
    "end": "318900"
  },
  {
    "text": "um and uh the one node that has the same hash namely four uh in this case the",
    "start": "318900",
    "end": "324479"
  },
  {
    "text": "little um uh Brown numbers are meant to be the hash codes and when I hash them together the X plus one I'm going to get",
    "start": "324479",
    "end": "330600"
  },
  {
    "text": "a hash of 12 and a hash of 8 for the other one and they should be different they are different terms X plus one y plus one different terms but if I stick",
    "start": "330600",
    "end": "337740"
  },
  {
    "text": "a Lambda on the top now the hashconzing would you know if we just treated it naively have different hashes and but of",
    "start": "337740",
    "end": "344100"
  },
  {
    "text": "course this time we want them to be the same so that is a problem right um and it's not simple to combat compute",
    "start": "344100",
    "end": "351360"
  },
  {
    "text": "the hash of Lambda X X plus one from the hash of X plus one or the hash of Lambda",
    "start": "351360",
    "end": "358380"
  },
  {
    "text": "y y plus one from the hash of Y plus one we'd have to look at the whole term again and that's not very efficient",
    "start": "358380",
    "end": "364440"
  },
  {
    "text": "so this is the first point which something interesting has happened I hope you got the sense of why hashconzing just doesn't work in a",
    "start": "364440",
    "end": "370620"
  },
  {
    "text": "straightforward way with lambdas that is it has false negatives it it treats things are different that should be the",
    "start": "370620",
    "end": "376380"
  },
  {
    "text": "same um if any of that's obscure ask a question I'll catch up with you now what",
    "start": "376380",
    "end": "381419"
  },
  {
    "start": "379000",
    "end": "445000"
  },
  {
    "text": "to do well the first obvious thing to do is to use the blind notation so many of you will be um familiar with Divine",
    "start": "381419",
    "end": "388080"
  },
  {
    "text": "notation but here's uh here's what we do we remove the names from all the lambdas",
    "start": "388080",
    "end": "393300"
  },
  {
    "text": "so at the top I've written Lambda X Lambda Y X Plus y times x and at the bottom I've written it in Divine",
    "start": "393300",
    "end": "398639"
  },
  {
    "text": "notation um and you can see that lambdas don't have any names with the Manila just Lambda Dot and Lambda Dot and instead we",
    "start": "398639",
    "end": "405300"
  },
  {
    "text": "replace every variable with that sort of hash and then a number and the number is the number of intervening lambdas",
    "start": "405300",
    "end": "412319"
  },
  {
    "text": "between that position and the Lambda that binds it so for the X",
    "start": "412319",
    "end": "418080"
  },
  {
    "text": "um but before the the X plus something the X thing that X has one Lambda namely",
    "start": "418080",
    "end": "423419"
  },
  {
    "text": "the Lambda y intervening between the occurrence of X and the binder of X so we write hash one on the other hand the",
    "start": "423419",
    "end": "428460"
  },
  {
    "text": "Y has no lambdas intervening between The Binding The Binding Lambda and this occurrence y so attach zero okay",
    "start": "428460",
    "end": "435240"
  },
  {
    "text": "and at first sight this seems pretty good because now we sort of canonicalized um our Lambda so they only so Lambda X X plus one and Lambda y y",
    "start": "435240",
    "end": "442800"
  },
  {
    "text": "plus one they'd be the same in Dubai notation so that looks pretty good um but unfortunately it really isn't",
    "start": "442800",
    "end": "449940"
  },
  {
    "text": "good and I didn't realize this for ages so I'm just going to uh um explain this to you quickly firstly on the side let",
    "start": "449940",
    "end": "456539"
  },
  {
    "text": "me note that using de bruyne notation for your lambdas in your compiler say has a global and pervasive impact on",
    "start": "456539",
    "end": "463020"
  },
  {
    "text": "everything else right and imposes some significant overheads of its own for example if you do substitution you have",
    "start": "463020",
    "end": "468419"
  },
  {
    "text": "to run around readjusting a disease that's not very cool um but much worse from our point of view",
    "start": "468419",
    "end": "473639"
  },
  {
    "text": "today is that using Dubai notation suffers from both false positives and false negatives and here they are so",
    "start": "473639",
    "end": "480060"
  },
  {
    "text": "here's a false negative look um I've got uh in this expression I've",
    "start": "480060",
    "end": "485460"
  },
  {
    "text": "got a Lambda t on the outside and I've got a f applied to two lambdas um and inside the right hand Lambda is",
    "start": "485460",
    "end": "492180"
  },
  {
    "text": "the Lambda X X Plus T and the first argument is a Lambda XX plus T and we'd like to share those so we'd like to be",
    "start": "492180",
    "end": "498240"
  },
  {
    "text": "able to say let H equal Lambda X X Plus T and then F apply to H and under y dot h nothing wrong with that",
    "start": "498240",
    "end": "504180"
  },
  {
    "text": "but alas if we convert it to Lambda notation so it's a deploy notation look what we get the the um the Lambda X X",
    "start": "504180",
    "end": "510840"
  },
  {
    "text": "Plus T I write hash zero for the X and hash one for the T and the first one but",
    "start": "510840",
    "end": "516120"
  },
  {
    "text": "in the second one I have two lambdas and then hash zero for that X again oh",
    "start": "516120",
    "end": "522180"
  },
  {
    "text": "hash two for the T because there are two lambdas intervening between the",
    "start": "522180",
    "end": "527279"
  },
  {
    "text": "occurrence of the T and the binder of the T right so these two identical Lambda terms have",
    "start": "527279",
    "end": "534060"
  },
  {
    "text": "now got they're different even in Dubai notation that's very sad so I've got false negative there",
    "start": "534060",
    "end": "540180"
  },
  {
    "text": "and we also get false positives um so here's an example",
    "start": "540180",
    "end": "545940"
  },
  {
    "text": "um let's look carefully at this uh let's see this is it looks similar but it's",
    "start": "545940",
    "end": "551880"
  },
  {
    "text": "not the same right so the first Lambda here is Lambda x t plus X so that in Dubai notation is Lambda dot hash one",
    "start": "551880",
    "end": "560660"
  },
  {
    "text": "zero the hash one is the T one Lambda intervening the hash zero is the X no",
    "start": "560660",
    "end": "567720"
  },
  {
    "text": "lambda's intervening and then in the right how an argument look at that inner Lambda the Lambda X Y plus y times x",
    "start": "567720",
    "end": "574860"
  },
  {
    "text": "that is goes Lambda Dot and then hash one that's the Y one Lambda intervening",
    "start": "574860",
    "end": "580620"
  },
  {
    "text": "between the occurrence of Y and its binding site and then the X oh no lambda's intervening zero so those two",
    "start": "580620",
    "end": "588300"
  },
  {
    "text": "in Dubai notation I've got Lambda dot hash one plus hash Duo they look the",
    "start": "588300",
    "end": "593700"
  },
  {
    "text": "same if we did hash counting they would be the same and that would be fine for structure sharing if our only goal was",
    "start": "593700",
    "end": "598740"
  },
  {
    "text": "saving memory in the compiler would be good but we're not we're trying to do common sub-expression and they absolutely are not the same you cannot",
    "start": "598740",
    "end": "605100"
  },
  {
    "text": "take Lambda x t plus X at Lambda X Y plus X and say it's the same expression right",
    "start": "605100",
    "end": "610920"
  },
  {
    "text": "so I'm hoping that everybody is saying is nodding now I can't kind of I can only see a few people less at least is",
    "start": "610920",
    "end": "617519"
  },
  {
    "text": "nodding uh people on them on slack please sort of why don't you type nod or",
    "start": "617519",
    "end": "623399"
  },
  {
    "text": "something and I'll see it in 30 seconds um so the point I want to get to so far is",
    "start": "623399",
    "end": "629640"
  },
  {
    "start": "625000",
    "end": "650000"
  },
  {
    "text": "that there's a relatively simple problem it sounds straightforward find all Alpha equivalent sub expressions in a perhaps",
    "start": "629640",
    "end": "635399"
  },
  {
    "text": "large program terms um but unfortunately there doesn't seem to be inefficient compositional",
    "start": "635399",
    "end": "641279"
  },
  {
    "text": "algorithm in the literature and that's really surprising I was I looked quite hard if you know of any please tell me",
    "start": "641279",
    "end": "647579"
  },
  {
    "text": "about them but that's the problem we're going to fix in this talk okay and here's how we're going to fix it",
    "start": "647579",
    "end": "653579"
  },
  {
    "start": "650000",
    "end": "755000"
  },
  {
    "text": "um uh like so um for every node we're going to first",
    "start": "653579",
    "end": "659100"
  },
  {
    "text": "of all Define something we're calling an e summary um and it can and the idea is that the",
    "start": "659100",
    "end": "664500"
  },
  {
    "text": "e-summary for a node a bit like a hash code can be computed from the e-summeries of its immediate children and two nodes are going to be equivalent",
    "start": "664500",
    "end": "672000"
  },
  {
    "text": "Alpha equivalent if they have the same e-summary but there's no information loss here we can convert to and fo",
    "start": "672000",
    "end": "678240"
  },
  {
    "text": "between e summaries and expressions um but the reason that we want e-summer is that e summaries are more easily",
    "start": "678240",
    "end": "684720"
  },
  {
    "text": "hashable in a composed way we're going to take it from the e summary we're going to extract a hash code and that is",
    "start": "684720",
    "end": "691079"
  },
  {
    "text": "going to be the the thing that we're going to use to determine equivalence of course like any hashing mechanism we can",
    "start": "691079",
    "end": "696660"
  },
  {
    "text": "get um collisions and we just have to arrange that the collisions are sufficiently infrequent there is a question from the slack oh",
    "start": "696660",
    "end": "703980"
  },
  {
    "text": "right which says Bruin levels starting from the outside good question so Adam",
    "start": "703980",
    "end": "709140"
  },
  {
    "text": "Adam says yes the de blind notation um counts the Divine notation I've said",
    "start": "709140",
    "end": "714540"
  },
  {
    "text": "shows um counts um uh the occurrence has an index that is the number of",
    "start": "714540",
    "end": "719579"
  },
  {
    "text": "intervening lambdas you can instead count the other way around and say how many lambdas from the top does this work",
    "start": "719579",
    "end": "725459"
  },
  {
    "text": "that imposes different overheads but it doesn't solve the problem um so um it's like you nail down the carpet in",
    "start": "725459",
    "end": "732300"
  },
  {
    "text": "one place and it pops up somewhere else thanks Adam uh thanks Michelle for",
    "start": "732300",
    "end": "737940"
  },
  {
    "text": "reminding me good so here's a here's our um isamu story we're first of all going to extract here somewhere so I'm going",
    "start": "737940",
    "end": "743880"
  },
  {
    "text": "to focus on isamos first and then I'm going to extract hash codes and then I'm going to use the hash table in exactly",
    "start": "743880",
    "end": "748980"
  },
  {
    "text": "the way that it did before to save two nodes have the same hash code then I'll look up in the table to see if it's if",
    "start": "748980",
    "end": "754079"
  },
  {
    "text": "I've got an existing copy of the same node now what is an e-summary it's just a pair of",
    "start": "754079",
    "end": "759779"
  },
  {
    "start": "755000",
    "end": "960000"
  },
  {
    "text": "the structure or shape of the expression and something I'll call the free",
    "start": "759779",
    "end": "765720"
  },
  {
    "text": "variable map of the expression which describes the places where the variables occur that should be a plural of",
    "start": "765720",
    "end": "772200"
  },
  {
    "text": "variables so I'm going to peel apart the expression into two pieces the structure",
    "start": "772200",
    "end": "778560"
  },
  {
    "text": "the ignoring the the identities of the variables and the locations of the variables in that structure so pictorial",
    "start": "778560",
    "end": "785459"
  },
  {
    "text": "I might say that this expression Lambda X Y times x the structure part is simply spot plus Spot times spot right that's",
    "start": "785459",
    "end": "793260"
  },
  {
    "text": "your every every place I put a variable I put a spot as a structure it remains and then the free variable map says",
    "start": "793260",
    "end": "799740"
  },
  {
    "text": "where within that structure X occurs well where does X occur well if I look",
    "start": "799740",
    "end": "804959"
  },
  {
    "text": "at the root which is a plus it occurs in both subtrees so I get this P both thing think of P both as a Constructor and",
    "start": "804959",
    "end": "812220"
  },
  {
    "text": "Haskell so it's got two arguments so it says and the left-hand argument is p here and that's because X occurs",
    "start": "812220",
    "end": "818100"
  },
  {
    "text": "immediately in the right sub in the left sub tree in the right subtree X doesn't occur immediately it occurs in the right",
    "start": "818100",
    "end": "825000"
  },
  {
    "text": "subtree of the right subtree so we say the right hand argument of P both says P",
    "start": "825000",
    "end": "830700"
  },
  {
    "text": "right meaning go to the right again and then P here meaning here it is on the other hand y",
    "start": "830700",
    "end": "836399"
  },
  {
    "text": "oke only occurs in the right hand subtree of that plus node so we get a p right and then here occurs the left hand",
    "start": "836399",
    "end": "843000"
  },
  {
    "text": "subtree of the multiplication node so we get a p left and then there he is p here okay I'm hoping that's uh simple enough that",
    "start": "843000",
    "end": "849839"
  },
  {
    "text": "we just got a um a way to identify where the um where each of the um uh verbals occurs and",
    "start": "849839",
    "end": "857639"
  },
  {
    "text": "then when we come to a Lambda in the E summary in the structure I'm going to",
    "start": "857639",
    "end": "862860"
  },
  {
    "text": "extract the a variable map for X instead if I got this sorry if I got this Lambda",
    "start": "862860",
    "end": "868200"
  },
  {
    "text": "oh dear yes I've got this Lambda y I'm going to extract from the variable map remember the variable map said y occurs",
    "start": "868200",
    "end": "875160"
  },
  {
    "text": "at it P Y to P left to P here um so I'm going to extract that and stuff it in the Lambda so instead of the",
    "start": "875160",
    "end": "881279"
  },
  {
    "text": "name of a variable in a Lambda the structure map records the places that the variable occurs and then I'm going",
    "start": "881279",
    "end": "887519"
  },
  {
    "text": "to have the rest of the structure and I'm left with the places where X occurs",
    "start": "887519",
    "end": "892680"
  },
  {
    "text": "so at the moment I'm hoping you just have an intuitive idea that we can split the um we can describe a fully describe",
    "start": "892680",
    "end": "899399"
  },
  {
    "text": "a term by a pair of a structure that mentions no available by name and a map",
    "start": "899399",
    "end": "904920"
  },
  {
    "text": "that Maps variables for their locations here's another way to look at it um in in pictures here's a um uh this is",
    "start": "904920",
    "end": "913620"
  },
  {
    "text": "a a different termite this is Lambda X Lambda b x applied to B all applied to X",
    "start": "913620",
    "end": "920579"
  },
  {
    "text": "um so if you look at the the that multiplication note at the bottom the structure is spot time spot and have a",
    "start": "920579",
    "end": "926820"
  },
  {
    "text": "variable map that says b occurs in the right branch and X occurs in the left branch and now when I come to the Lambda",
    "start": "926820",
    "end": "932339"
  },
  {
    "text": "the Lambda b i extract the structure for B and put that in the Lambda leaving",
    "start": "932339",
    "end": "937380"
  },
  {
    "text": "back a depleted variable map that says where X occurs then when I come across the multiplication node",
    "start": "937380",
    "end": "943440"
  },
  {
    "text": "um uh I'm going to say oh X occurs in the left-hand branch and the right hand branch of this application node so I got",
    "start": "943440",
    "end": "950699"
  },
  {
    "text": "a bigger VAR map and then when I come across that Lambda I attach that um that the the places that X occurs into the",
    "start": "950699",
    "end": "957660"
  },
  {
    "text": "Lambda leaving an empty vomit so that's the idea of these structure structure Maps that's a lot with",
    "start": "957660",
    "end": "963240"
  },
  {
    "text": "pictures and arm waving here it is in Haskell I'm going to show you some Haskell code in this talk because I love",
    "start": "963240",
    "end": "968820"
  },
  {
    "text": "showing Haskell code and um and because it makes it more precise so here is a very simple uh data type describing",
    "start": "968820",
    "end": "975660"
  },
  {
    "text": "Lambda terms so for those of you not familiar with Haskell this data expert says here comes an algebraic data type",
    "start": "975660",
    "end": "982139"
  },
  {
    "text": "and a value of type expert can be built in one of these three ways it can be a VAR Constructor applied to a name maybe",
    "start": "982139",
    "end": "989040"
  },
  {
    "text": "a name is just a string or it can be an app node that has two expressions inside it so the app is the Constructor expert",
    "start": "989040",
    "end": "996300"
  },
  {
    "text": "expert those are its two children or it can be a lamb node Lambda node with a name that's the band variable and an",
    "start": "996300",
    "end": "1002779"
  },
  {
    "text": "expressionist child and so here is the things that have been written as Lambda X X Plus X could be written in this",
    "start": "1002779",
    "end": "1009380"
  },
  {
    "text": "um in our school the data structure the represent will be a lamb with X and then an app of an app and so forth so",
    "start": "1009380",
    "end": "1016339"
  },
  {
    "text": "those are that's Expressions now here are e summaries so what is an e-summary",
    "start": "1016339",
    "end": "1021620"
  },
  {
    "start": "1018000",
    "end": "1280000"
  },
  {
    "text": "at the top of the slide it's a pair right so the the first thing the first bit to the right of the equals is the",
    "start": "1021620",
    "end": "1027558"
  },
  {
    "text": "data Constructor e summary and then it has two components a structure and a VAR map what is a structure well remember a",
    "start": "1027559",
    "end": "1034220"
  },
  {
    "text": "structure just said it had this um uh it was this uh spot plus spot so",
    "start": "1034220",
    "end": "1039558"
  },
  {
    "text": "what's going to have s VAR that's the spot it says there's a variable here I'm not going to tell you what its name is",
    "start": "1039559",
    "end": "1044839"
  },
  {
    "text": "um then we can have an application node in the structure part that just has two structure children and then we're going",
    "start": "1044839",
    "end": "1050059"
  },
  {
    "text": "to have a structure lamb remember that's like uh these guys those lambdas remember have a a single position tree",
    "start": "1050059",
    "end": "1058640"
  },
  {
    "text": "attached to them so the structure lamb has a position tree attached to it and a structure as its child what's a position",
    "start": "1058640",
    "end": "1065059"
  },
  {
    "text": "tree that's those things that I was showing for um uh where X and Y occur right so either a",
    "start": "1065059",
    "end": "1072799"
  },
  {
    "text": "position three either says um uh the verbal occurs here or it's in the it's go to the left or go to the",
    "start": "1072799",
    "end": "1079580"
  },
  {
    "text": "right or go both ways that's position trees and of our map that's the last component of an e",
    "start": "1079580",
    "end": "1086179"
  },
  {
    "text": "summary right on the top line you can see e samoy has two components structure and Varma what's a varmap it's a finite",
    "start": "1086179",
    "end": "1092660"
  },
  {
    "text": "mapping so I'm just here writing map from names to what well pause trees",
    "start": "1092660",
    "end": "1098780"
  },
  {
    "text": "so I hope that's just a straightforward rendition of the um of uh of this idea",
    "start": "1098780",
    "end": "1106400"
  },
  {
    "text": "that the E7 was just a pair of a structure and a free verbal map the last thing I just have to say is",
    "start": "1106400",
    "end": "1112460"
  },
  {
    "text": "that uh uh why does an s-dam container maybe pository instead of Repository",
    "start": "1112460",
    "end": "1119179"
  },
  {
    "text": "it's because available may not occur at all so the maybe is just saying if it",
    "start": "1119179",
    "end": "1125539"
  },
  {
    "text": "doesn't occur at all we'll have nothing otherwise we'll have just depository and you've got to slice this another way but",
    "start": "1125539",
    "end": "1131840"
  },
  {
    "text": "it's easier done like this okay so then summarize is going to be the function that takes an expression and delivers",
    "start": "1131840",
    "end": "1138020"
  },
  {
    "text": "its e-summary and it's pretty simple I'm not going to go through it in great detail but I just think it's Illuminating just to see a little bit of",
    "start": "1138020",
    "end": "1143539"
  },
  {
    "text": "code so how do we summarize a single variable well we get an e summary what is an e summary it's a pair of a",
    "start": "1143539",
    "end": "1150260"
  },
  {
    "text": "structure in this case for a variable the structure is just svar remember",
    "start": "1150260",
    "end": "1155840"
  },
  {
    "text": "the the what structures are available the anonymous variables they're just as s bars and then what is the available",
    "start": "1155840",
    "end": "1162080"
  },
  {
    "text": "map for a Singleton variable well just a Singleton map that Maps the variable to P here",
    "start": "1162080",
    "end": "1168740"
  },
  {
    "text": "for lambdas what do we do well we recursively call summarize",
    "start": "1168740",
    "end": "1173960"
  },
  {
    "text": "and extract that in the where part to it and then get the structure and the variable map out of the summary we get",
    "start": "1173960",
    "end": "1181460"
  },
  {
    "text": "back and we're going to return a summary of that's a bit after the equal sign and what does that somewhere contain it says",
    "start": "1181460",
    "end": "1187820"
  },
  {
    "text": "it's got an s-lam and we'd look up what the variable well you know where is the variable in the vmap to get the position",
    "start": "1187820",
    "end": "1194059"
  },
  {
    "text": "tree for x and then we delete the variable from the V map and return that",
    "start": "1194059",
    "end": "1199100"
  },
  {
    "text": "and I'm not going to go through application because I've got more to say about that later but I hope that gives you a sort of simple",
    "start": "1199100",
    "end": "1205400"
  },
  {
    "text": "um idea do we uh Luke asks you must assume that no two positres point to the",
    "start": "1205400",
    "end": "1211100"
  },
  {
    "text": "same location yes it is perfectly possible to make an e summaries if you like contain more values than",
    "start": "1211100",
    "end": "1217820"
  },
  {
    "text": "Expressions do I could have an invalid e-summary that really didn't represent any expression at all",
    "start": "1217820",
    "end": "1224600"
  },
  {
    "text": "um so thanks Luke yes it's a sort of redundant notation but it's going to be compositionally hashable that's why we",
    "start": "1224600",
    "end": "1229640"
  },
  {
    "text": "that's why we have it but of course summarize this summarized thing will only build valid summaries yeah so when",
    "start": "1229640",
    "end": "1236720"
  },
  {
    "text": "I say you must assume that um uh it's not exactly we assume it it's summarize only builds e-summies with",
    "start": "1236720",
    "end": "1243140"
  },
  {
    "text": "valid pause trees um and then we can go back the other way but in fact we can go back the other way so I said it's not",
    "start": "1243140",
    "end": "1248720"
  },
  {
    "text": "information losing I think you can see that we could take an e summary and reconstruct the expression possibly",
    "start": "1248720",
    "end": "1254120"
  },
  {
    "text": "modulo the variable names um themselves uh and we Could reconstruct the",
    "start": "1254120",
    "end": "1259640"
  },
  {
    "text": "expression for which it stands we might need to record a tiny bit of information if we wanted to be faithful to the variable names",
    "start": "1259640",
    "end": "1265880"
  },
  {
    "text": "um but you might wonder if e summaries and expressions contain the same information why have I bothered with all this like why did I do this work",
    "start": "1265880",
    "end": "1273260"
  },
  {
    "text": "um because after all I appear to be no further forward I just have a different representation of the same expression",
    "start": "1273260",
    "end": "1278660"
  },
  {
    "text": "well here's why we're going to Hash the e-summeries that's the second step in",
    "start": "1278660",
    "end": "1284720"
  },
  {
    "text": "this process so I'm going to show how to compositionally Hash e-summaries so",
    "start": "1284720",
    "end": "1290780"
  },
  {
    "text": "um I want to extract from an e-summary some kind of hash code",
    "start": "1290780",
    "end": "1296120"
  },
  {
    "text": "um and since in these summary is a pair of a structure and a variable map maybe I can hash the structure and hash the",
    "start": "1296120",
    "end": "1302720"
  },
  {
    "text": "variable map and then smash those two hashes together which I've written on the bottom line so now I have to ask how can I hash",
    "start": "1302720",
    "end": "1309260"
  },
  {
    "text": "structures and how can I hash variable Maps for structures it's rather easy",
    "start": "1309260",
    "end": "1316299"
  },
  {
    "text": "um yes I'll come back to Unison Alex thank",
    "start": "1316820",
    "end": "1322640"
  },
  {
    "start": "1317000",
    "end": "1353000"
  },
  {
    "text": "you and remind me towards the end uh structures don't have any variables in them now do",
    "start": "1322640",
    "end": "1330140"
  },
  {
    "text": "you remember when we talked about hashconsing we said hash counting is great until you introduce lambdas well",
    "start": "1330140",
    "end": "1336080"
  },
  {
    "text": "structures don't have any lambdas um they just have well structures as",
    "start": "1336080",
    "end": "1341480"
  },
  {
    "text": "children and positories as children positories don't have any Lambda so in fact structures and positories are",
    "start": "1341480",
    "end": "1347299"
  },
  {
    "text": "totally hash constable all right so idea number zero is simply",
    "start": "1347299",
    "end": "1353140"
  },
  {
    "start": "1353000",
    "end": "1570000"
  },
  {
    "text": "to never build positrees or structures",
    "start": "1353140",
    "end": "1358700"
  },
  {
    "text": "but instead build pository hashes and structure hashes",
    "start": "1358700",
    "end": "1365240"
  },
  {
    "text": "let me say that once again we never actually build a um a pository or structure we're only",
    "start": "1365240",
    "end": "1372260"
  },
  {
    "text": "going to build their hashes by hash conting so we never we're not actually interested in those trees we're only interested in the hashes of those trees",
    "start": "1372260",
    "end": "1378740"
  },
  {
    "text": "so here I've described hash summary then which is a sort of you know like a a",
    "start": "1378740",
    "end": "1384380"
  },
  {
    "text": "compacted version of e-summary is a pair of a structure hash and this thing I'll",
    "start": "1384380",
    "end": "1390260"
  },
  {
    "text": "call that an hvar map which is sort of hashva map let's concentrate on structure hash first what is structure",
    "start": "1390260",
    "end": "1395299"
  },
  {
    "text": "hash it's just a hash code so now when I let let's say I'm now",
    "start": "1395299",
    "end": "1400580"
  },
  {
    "text": "taking an expression and delivering instead of an e summary I want to deliver a hash summary some reason some",
    "start": "1400580",
    "end": "1405740"
  },
  {
    "text": "ways to kind of like the same thing but with but they've been smashed a bit how do I Hash a variable node well I'm going",
    "start": "1405740",
    "end": "1413059"
  },
  {
    "text": "to make NH summary which I want to structure hash in the first component how do I make a structure hash or an S4",
    "start": "1413059",
    "end": "1418700"
  },
  {
    "text": "oh I just hash svar um now what's this hvar map this hvar",
    "start": "1418700",
    "end": "1425179"
  },
  {
    "text": "map maps variables to pository hashes remember the only thing I'm doing at the moment is I'm replacing structures with",
    "start": "1425179",
    "end": "1432919"
  },
  {
    "text": "structure hashes and positives with pository hashes I'm still leaving the variable map for now",
    "start": "1432919",
    "end": "1438559"
  },
  {
    "text": "um okay so uh so where are we that's right so I need to make a Singleton map",
    "start": "1438559",
    "end": "1444620"
  },
  {
    "text": "of the variable to not P here but rather hash or P here that's the pository hash",
    "start": "1444620",
    "end": "1449780"
  },
  {
    "text": "4p here okay so far so good um no questions about this um coming",
    "start": "1449780",
    "end": "1456200"
  },
  {
    "text": "through yet for lambdas what do I do well it's the same as before I need to recursively call Hash expert extract the",
    "start": "1456200",
    "end": "1464600"
  },
  {
    "text": "variable map and the structure well the structure hash from the um from what I get back and then I build the structure",
    "start": "1464600",
    "end": "1471980"
  },
  {
    "text": "hash the first component of the H summary I return we um uh we're going to",
    "start": "1471980",
    "end": "1477799"
  },
  {
    "text": "just hash together the s-lam with the result of looking up in the vmap and of course the child structure and then we",
    "start": "1477799",
    "end": "1483919"
  },
  {
    "text": "delete from the vmap um so all we're doing is we're doing exactly what we did before",
    "start": "1483919",
    "end": "1490280"
  },
  {
    "text": "but we're simply keeping hashes instead of structures and hashes instead of",
    "start": "1490280",
    "end": "1495919"
  },
  {
    "text": "pause trees so I'm hoping that part is very straightforward",
    "start": "1495919",
    "end": "1501039"
  },
  {
    "text": "um now uh Hugh is asking a good question which is how do e-summaries deal with",
    "start": "1501620",
    "end": "1508280"
  },
  {
    "text": "shadowing well um let's see if I can answer that question by going back to one of these diagrams",
    "start": "1508280",
    "end": "1514280"
  },
  {
    "text": "so um supposing in this picture I'd add Lambda B and the top Lambda was a Lambda",
    "start": "1514280",
    "end": "1520159"
  },
  {
    "text": "b as well well the example wouldn't work very well but then I couldn't have had that nested Lambda but you'd still everything would just work fine the",
    "start": "1520159",
    "end": "1526640"
  },
  {
    "text": "inner Lambda would by the time I'd done the E summary the inner Lambda in let's see uh position C here the middle the",
    "start": "1526640",
    "end": "1534740"
  },
  {
    "text": "inner Lambda would say where that Anonymous variable B occurs um uh yes it's like Lambda B and in E",
    "start": "1534740",
    "end": "1542419"
  },
  {
    "text": "the outer Lambda would say where its variables occur so since e summaries are simply you know they're completely",
    "start": "1542419",
    "end": "1548720"
  },
  {
    "text": "Anonymous they don't have any names they just they don't have any problem with shadowing of course I mean if you have",
    "start": "1548720",
    "end": "1555279"
  },
  {
    "text": "Lambda x dot Lambda x dot X Plus X the",
    "start": "1555279",
    "end": "1561380"
  },
  {
    "text": "outer Lambda X it doesn't occur at all and it shouldn't it's just shattered I mean that's just what that's just Lambda Lambda calculus",
    "start": "1561380",
    "end": "1568279"
  },
  {
    "text": "okay so a little pause here I hope that we",
    "start": "1568279",
    "end": "1573440"
  },
  {
    "text": "got to the point where we've had um we've sort of done the done the simple bit now we've got we've gone from",
    "start": "1573440",
    "end": "1579380"
  },
  {
    "text": "e-summeries to Hash summaries and hash summaries can have just like e summaries",
    "start": "1579380",
    "end": "1586640"
  },
  {
    "text": "except we've replaced structures with structure hashes and positories with pository hashes so we can no longer",
    "start": "1586640",
    "end": "1591919"
  },
  {
    "text": "reconstruct the original expression but we never really wanted to do that in the first place it was just an intellectual",
    "start": "1591919",
    "end": "1597620"
  },
  {
    "text": "stepping stone we wanted to get a hash code okay",
    "start": "1597620",
    "end": "1603440"
  },
  {
    "text": "um so uh nods um type nod if you're happy at this point because we're about to get to the",
    "start": "1603440",
    "end": "1609620"
  },
  {
    "text": "interesting bit so I'll keep an eye on nods in the next",
    "start": "1609620",
    "end": "1617120"
  },
  {
    "start": "1612000",
    "end": "1623000"
  },
  {
    "text": "30 seconds so there are two elephants in the room um which nobody's been asking questions about perhaps you're very polite",
    "start": "1617120",
    "end": "1623840"
  },
  {
    "start": "1623000",
    "end": "1804000"
  },
  {
    "text": "um and here is the first elephant um at an app node there's lots of work to",
    "start": "1623840",
    "end": "1630080"
  },
  {
    "text": "do um now uh in this example I've got an app of",
    "start": "1630080",
    "end": "1637760"
  },
  {
    "text": "I'm applying X to Y apply to X so if you look in the bottom right app",
    "start": "1637760",
    "end": "1644299"
  },
  {
    "text": "node you can see that it's varmap says that y occurs in the left subtree and X",
    "start": "1644299",
    "end": "1651500"
  },
  {
    "text": "occurs in the right subtree and then in the app node I have to",
    "start": "1651500",
    "end": "1656840"
  },
  {
    "text": "combine the two VAR Maps the one from the left which says X goes to P here and the one from the right with that that",
    "start": "1656840",
    "end": "1663080"
  },
  {
    "text": "two things to make a VAR map for X and Y still only has two elements but the X at",
    "start": "1663080",
    "end": "1669200"
  },
  {
    "text": "The X guy is in both branches so I get a p both and the Y is only in the right hand Branch so I have to wrap a p right",
    "start": "1669200",
    "end": "1676659"
  },
  {
    "text": "around the P left here so the payload of this slide is I have to look I have to",
    "start": "1676659",
    "end": "1683120"
  },
  {
    "text": "attend to every element of both VAR Maps right and modify them",
    "start": "1683120",
    "end": "1689539"
  },
  {
    "text": "right so that means in a very unbalanced tree right suppose that it wasn't nicely",
    "start": "1689539",
    "end": "1695900"
  },
  {
    "text": "balanced suppose it was very unbalanced with lots of free variables then at each level of the unbalanced tree I have to",
    "start": "1695900",
    "end": "1702320"
  },
  {
    "text": "do a sort of order n operation right so I've got an ndtree at each level I need",
    "start": "1702320",
    "end": "1708380"
  },
  {
    "text": "to I need to pay attention to N Things so by the time I got to the top I've done N squared Work N squared worked",
    "start": "1708380",
    "end": "1715820"
  },
  {
    "text": "very bad right we don't want to we don't want to do that we can possibly avoid it so that looks like a serious problem",
    "start": "1715820",
    "end": "1721820"
  },
  {
    "text": "with the uh you know the story I was telling you here we didn't look at app nodes but this is what must happen to",
    "start": "1721820",
    "end": "1727700"
  },
  {
    "text": "app nodes so here is the first clever idea I can say it's a clever idea because I wasn't",
    "start": "1727700",
    "end": "1733400"
  },
  {
    "text": "the one who had it was one of my colleagues why don't we only adjust the items in the smaller map",
    "start": "1733400",
    "end": "1741620"
  },
  {
    "text": "so here in the green the sort of purple bit at the the brown bit at the bottom hasn't changed in the green bit X occurs",
    "start": "1741620",
    "end": "1749720"
  },
  {
    "text": "in both branches so I've had to modify that it was in the smaller map right as well as the bigger one but y was only in",
    "start": "1749720",
    "end": "1756799"
  },
  {
    "text": "the bigger map the one on the right so maybe I can do nothing just pay uh just",
    "start": "1756799",
    "end": "1761960"
  },
  {
    "text": "leave it alone right so then I'm only paying attention I've only modifying only doing work on the smaller map and",
    "start": "1761960",
    "end": "1768620"
  },
  {
    "text": "that would be a lot more efficient but of course it doesn't work because now if you um imagine",
    "start": "1768620",
    "end": "1776360"
  },
  {
    "text": "um imagine the rebuilding process because remember I want to be able to take one of these e-summeries and",
    "start": "1776360",
    "end": "1781460"
  },
  {
    "text": "reconstruct the original tree how would I know I mean it's not true to say that the place that y occurs in the top level",
    "start": "1781460",
    "end": "1788480"
  },
  {
    "text": "app node is in P left to P here you know it that's true about the app node below",
    "start": "1788480",
    "end": "1794299"
  },
  {
    "text": "right so we seem to need that extra bit of information on the Y to say",
    "start": "1794299",
    "end": "1800120"
  },
  {
    "text": "um how far to push it down um but it turns out that we can be a bit cleverer here by recording in the",
    "start": "1800120",
    "end": "1808100"
  },
  {
    "start": "1804000",
    "end": "2112000"
  },
  {
    "text": "structure two extra pieces of information so structures still have no variables or anything but in red here",
    "start": "1808100",
    "end": "1813799"
  },
  {
    "text": "I've added two extra pieces of information to the app I've added the depth which is just going to be a simple",
    "start": "1813799",
    "end": "1819679"
  },
  {
    "text": "number that counts up you know the the um uh the maximum depth of either child I'm just keeping in the node and uh and",
    "start": "1819679",
    "end": "1826820"
  },
  {
    "text": "a single Boolean flag bigger map that says which side is bigger which site has",
    "start": "1826820",
    "end": "1831860"
  },
  {
    "text": "the bigger map and then in the um in the pository I'm",
    "start": "1831860",
    "end": "1837380"
  },
  {
    "text": "going to um uh for p both node I'm going to record uh the um both the child from the",
    "start": "1837380",
    "end": "1845059"
  },
  {
    "text": "smaller map and the child from the bigger map along with a depth tag so now here's an example to show what happens",
    "start": "1845059",
    "end": "1853340"
  },
  {
    "text": "so here's my same example but this time with these additional decorations",
    "start": "1853340",
    "end": "1859279"
  },
  {
    "text": "so now um uh you'll see that",
    "start": "1859279",
    "end": "1865580"
  },
  {
    "text": "um in the um the app node at the bottom um y got a p both why did it get a p",
    "start": "1865580",
    "end": "1871760"
  },
  {
    "text": "both well it was because um uh it was determined to be the um the",
    "start": "1871760",
    "end": "1878720"
  },
  {
    "text": "smaller map can you see on the on the the we decided the two maps on the the Y and the X at the bottom of equal size",
    "start": "1878720",
    "end": "1884779"
  },
  {
    "text": "but we arbitrarily picked the left hand one the Y one to be the smaller one fine so we're going to mark it with P both",
    "start": "1884779",
    "end": "1891679"
  },
  {
    "text": "one y one one is the depth of this app node and X that was the smaller map sorry that was the bigger map so we",
    "start": "1891679",
    "end": "1898820"
  },
  {
    "text": "don't change that so um as you as the green uh call out says the light green call out every item in",
    "start": "1898820",
    "end": "1905539"
  },
  {
    "text": "the smaller map is going to get a p both and all of the items in the bigger map here x maps to be here don't change at",
    "start": "1905539",
    "end": "1911960"
  },
  {
    "text": "all okay so that's the Brown uh varmap on",
    "start": "1911960",
    "end": "1917360"
  },
  {
    "text": "the bottom of snap node now look at the green VAR map on the uppermost app node",
    "start": "1917360",
    "end": "1923059"
  },
  {
    "text": "so now here it's definitely the right hand map is the bigger one so it'll be marked as bigger the depth of the",
    "start": "1923059",
    "end": "1930200"
  },
  {
    "text": "topmost app node is two right it's got a child of depth one and a child of depth zero so we add one and take the larger",
    "start": "1930200",
    "end": "1936559"
  },
  {
    "text": "so we get two um and uh and so now uh remember when we do",
    "start": "1936559",
    "end": "1942860"
  },
  {
    "text": "combining we every item in the smaller map gets a p both so in that topmost",
    "start": "1942860",
    "end": "1948799"
  },
  {
    "text": "green variable Map X gets a p both marked at depth two",
    "start": "1948799",
    "end": "1955159"
  },
  {
    "text": "um and Y we haven't changed at all it's the same as in the little brown VAR map from",
    "start": "1955159",
    "end": "1962059"
  },
  {
    "text": "the uh the right hand child um but now you can see that if we imagine inverting the process and trying",
    "start": "1962059",
    "end": "1969440"
  },
  {
    "text": "to split these variable Maps as we rebuild um at this depth two node we would know",
    "start": "1969440",
    "end": "1976039"
  },
  {
    "text": "that that P both 2 is something we must split but the P both one no no no we're",
    "start": "1976039",
    "end": "1981440"
  },
  {
    "text": "not going to split that guy we're just going to pass it down where are we going to pass it down to to the bigger map in",
    "start": "1981440",
    "end": "1987440"
  },
  {
    "text": "other words to the right hand child right so we've recorded just enough information in the structure to enable",
    "start": "1987440",
    "end": "1993799"
  },
  {
    "text": "us to split these Maps even though the maps themselves have got you know the larger part was never modified so that's",
    "start": "1993799",
    "end": "2000039"
  },
  {
    "text": "the that is the hardest bit of this talk it is a little bit subtle but the nice thing is that if you go back to the the",
    "start": "2000039",
    "end": "2007480"
  },
  {
    "text": "old e summaries and do all this with um uh structures you can actually write summarize and rebuild and you could",
    "start": "2007480",
    "end": "2014260"
  },
  {
    "text": "check you know you can use Quick Check to Check you really have or you can prove that you really have got a perfect",
    "start": "2014260",
    "end": "2019299"
  },
  {
    "text": "inversion you can take an expression you could generate any summary from the e somewhere you can generate the express",
    "start": "2019299",
    "end": "2024399"
  },
  {
    "text": "now how expensive is this well we're only",
    "start": "2024399",
    "end": "2029620"
  },
  {
    "text": "adjusting the items in the smaller map in that very unbalanced tree the smaller",
    "start": "2029620",
    "end": "2035500"
  },
  {
    "text": "map always has size zero that was cool right no work there we're happy so in",
    "start": "2035500",
    "end": "2041799"
  },
  {
    "text": "fact the worst case is when the map is when the tree is balanced now if it's",
    "start": "2041799",
    "end": "2047019"
  },
  {
    "text": "completely balanced then I'm going to do work um on you know the smaller tree and the bigger tree the same size right but at",
    "start": "2047019",
    "end": "2054099"
  },
  {
    "text": "the bottom layer of them a bottom layer of the tree I've got end nodes and I have to do work one at the next layer of",
    "start": "2054099",
    "end": "2060760"
  },
  {
    "text": "the tree I've got half as many nodes I'm assuming a binary tree here but each time I have to do work two because",
    "start": "2060760",
    "end": "2067179"
  },
  {
    "text": "I know I've got a bigger variable map the next level I've got n over four nodes but I have to do work four because",
    "start": "2067179",
    "end": "2072820"
  },
  {
    "text": "then again the variable map or the smaller variable map is still of size four right but this is fine because at",
    "start": "2072820",
    "end": "2078878"
  },
  {
    "text": "each level here I'm doing Work N right bottom level Work N Next Level n over",
    "start": "2078879",
    "end": "2084700"
  },
  {
    "text": "two times two Next Level n over four times four so the total amount of work I do is n log n",
    "start": "2084700",
    "end": "2090760"
  },
  {
    "text": "and as we all know n log n is happy happy space right N squared very bad n",
    "start": "2090760",
    "end": "2097300"
  },
  {
    "text": "log n happy after all log n is essentially a constant Factor the number of protons in the universe is only you",
    "start": "2097300",
    "end": "2103780"
  },
  {
    "text": "know two to the 70 or something so it's a n log n is just you know constant times n to all intents and purposes",
    "start": "2103780",
    "end": "2110260"
  },
  {
    "text": "um it's a lot smaller than N squared okay so far so good let's see any questions very happy nods",
    "start": "2110260",
    "end": "2117760"
  },
  {
    "start": "2112000",
    "end": "2168000"
  },
  {
    "text": "um no uh no questions so it was there was one sorry there was one back back",
    "start": "2117760",
    "end": "2122800"
  },
  {
    "text": "there yes from Adam could there be benefits to using the pository in substitution for example instead of",
    "start": "2122800",
    "end": "2128859"
  },
  {
    "text": "traversing the whole expression you know exactly where to go I hadn't thought of that Adam so you may be saying could there be",
    "start": "2128859",
    "end": "2134500"
  },
  {
    "text": "could there be examples in a compiler that was doing let's say program Transformations and doing beta",
    "start": "2134500",
    "end": "2139720"
  },
  {
    "text": "reductions on Lambda terms maybe instead of Lambda terms we should just work with e summaries would that be cool",
    "start": "2139720",
    "end": "2146020"
  },
  {
    "text": "huh I had not thought of that that is an interesting question I will leave it as a question for the audience to discuss",
    "start": "2146020",
    "end": "2151839"
  },
  {
    "text": "in slack after this talk um my suspicion is that it the carpet would pop up somewhere else but it's a",
    "start": "2151839",
    "end": "2158560"
  },
  {
    "text": "good question Alex asks is n roughly the size of the",
    "start": "2158560",
    "end": "2164500"
  },
  {
    "text": "function top level definition oh uh so so what is n here so in my pictures here",
    "start": "2164500",
    "end": "2170619"
  },
  {
    "start": "2168000",
    "end": "2222000"
  },
  {
    "text": "I'm thinking of the expression as being the whole program right so in a Haskell",
    "start": "2170619",
    "end": "2176140"
  },
  {
    "text": "program for example the whole program is a large collection of definitions but you could think of it as an enormous let",
    "start": "2176140",
    "end": "2181720"
  },
  {
    "text": "in which good let function one equal right hand side one in let function two",
    "start": "2181720",
    "end": "2186760"
  },
  {
    "text": "equal right hand side two in value of main so just think of the whole program as one giant expression and we want to",
    "start": "2186760",
    "end": "2193240"
  },
  {
    "text": "do common sub expression on that so I'm thinking of n as just being um um the whole program or at least I'd",
    "start": "2193240",
    "end": "2200320"
  },
  {
    "text": "like these algorithms to work regardless of how big an expression we're working on",
    "start": "2200320",
    "end": "2206280"
  },
  {
    "text": "okay so now we've gotten",
    "start": "2206320",
    "end": "2212920"
  },
  {
    "text": "um now we're working on the smaller map that's good so we've we've we've eliminated elephant one",
    "start": "2212920",
    "end": "2219160"
  },
  {
    "text": "um by doing only working on the smaller subtree but elephant two is that we have",
    "start": "2219160",
    "end": "2224380"
  },
  {
    "text": "to we still have to Hash these variable Maps remember my hash summary it's a it's a it's a pair of a structure hash",
    "start": "2224380",
    "end": "2231579"
  },
  {
    "text": "and an hvar map now I need to get the hash a single hash",
    "start": "2231579",
    "end": "2237400"
  },
  {
    "text": "code for a hash summary so I might hash together the structure hash and O",
    "start": "2237400",
    "end": "2242800"
  },
  {
    "text": "the variable map so does that mean that at every node I need to hash together I need at every node then",
    "start": "2242800",
    "end": "2249700"
  },
  {
    "text": "I need to construct the hash of the variable map how do I do that well available map just think of it as a set",
    "start": "2249700",
    "end": "2255760"
  },
  {
    "text": "of key value pairs maybe even an ordered sequence of key value pairs I could hash that list",
    "start": "2255760",
    "end": "2261700"
  },
  {
    "text": "but that would take time order size of the map and that doesn't sound good",
    "start": "2261700",
    "end": "2267040"
  },
  {
    "text": "so could I do that in an incremental way well you might think maybe I could",
    "start": "2267040",
    "end": "2272740"
  },
  {
    "text": "maintain on the side you know the the verb that the hash of that map",
    "start": "2272740",
    "end": "2278560"
  },
  {
    "text": "right so I could keep a pair of an hvar map which is um you know so H somewhere",
    "start": "2278560",
    "end": "2285880"
  },
  {
    "text": "is now three components it still has an H4 map but it also has the hash of the hvr map so now whenever I add something",
    "start": "2285880",
    "end": "2292300"
  },
  {
    "text": "to the H of our map I can just you know Hash a new element into that",
    "start": "2292300",
    "end": "2297760"
  },
  {
    "text": "varmap hash and we sound happy but it's not very good when you're deleting oh",
    "start": "2297760",
    "end": "2305020"
  },
  {
    "start": "2303000",
    "end": "2355000"
  },
  {
    "text": "dear how can we um uh delete something if I've got the if I've got the hash of",
    "start": "2305020",
    "end": "2311980"
  },
  {
    "text": "a variable map and I delete something from the verbal map how do I get the hash of the depleted variable map",
    "start": "2311980",
    "end": "2320500"
  },
  {
    "text": "uh that is a problem",
    "start": "2320500",
    "end": "2326160"
  },
  {
    "text": "I hope you see that's a problem you can type nod at this point um and it looked it looked sort of",
    "start": "2326920",
    "end": "2332260"
  },
  {
    "text": "ineluctable because because this business about building hash codes as you go a bit like hashconzing it",
    "start": "2332260",
    "end": "2338920"
  },
  {
    "text": "constructs hashes for bigger things by combining the hashes of smaller things but when we delete something from",
    "start": "2338920",
    "end": "2344560"
  },
  {
    "text": "available map we are making the verbal map smaller and so we got a we've got to sort of remove some bits from the hash",
    "start": "2344560",
    "end": "2350260"
  },
  {
    "text": "that's really hard how can we do that so here is the second good idea use",
    "start": "2350260",
    "end": "2356800"
  },
  {
    "start": "2355000",
    "end": "2458000"
  },
  {
    "text": "exclusive or so the hash of a variable map is going",
    "start": "2356800",
    "end": "2362140"
  },
  {
    "text": "to be the exclusive or of the hashes of its key value pairs",
    "start": "2362140",
    "end": "2368760"
  },
  {
    "text": "so now so you have to suspend belief at the moment the what where we're doing",
    "start": "2369000",
    "end": "2374859"
  },
  {
    "text": "something that that looks weak right but I'll come back to that but if we Define",
    "start": "2374859",
    "end": "2380260"
  },
  {
    "text": "the hash of available map to be the exclusive or the hashes of its key value pairs then we can delete a key value",
    "start": "2380260",
    "end": "2385780"
  },
  {
    "text": "pair from the hash by xoring the hash in again right so here is the code for hash",
    "start": "2385780",
    "end": "2393040"
  },
  {
    "text": "Expo for hashing a Lambda uh and look at the um uh look at the bottom",
    "start": "2393040",
    "end": "2400780"
  },
  {
    "text": "we're going to um uh we're going to MPT",
    "start": "2400780",
    "end": "2406119"
  },
  {
    "text": "um whose type is maybe pository is the result of looking up the variable in the varmac remember so what I get back is a",
    "start": "2406119",
    "end": "2412960"
  },
  {
    "text": "maybe oh that should be maybe post tree hash sorry that's a maybe post tree hash",
    "start": "2412960",
    "end": "2418240"
  },
  {
    "text": "um then I look at that um um that uh maybe positive if it's",
    "start": "2418240",
    "end": "2424599"
  },
  {
    "text": "nothing it means well the verbal wasn't in the verbal map so there's nothing to do but if I get a if there's a pository",
    "start": "2424599",
    "end": "2429940"
  },
  {
    "text": "hash there then I can delete it from the verbal from the verbal map and just xor",
    "start": "2429940",
    "end": "2435339"
  },
  {
    "text": "the hash of the key value pairs with the available map hash oh that's so nice isn't it it means as well as adding",
    "start": "2435339",
    "end": "2441220"
  },
  {
    "text": "things I can remove things um and moreover since exclusive or is commutative and associative it doesn't",
    "start": "2441220",
    "end": "2447280"
  },
  {
    "text": "matter whether I add a and then b or whether I had B and then a I get the same hash okay so less at least is nodding this is",
    "start": "2447280",
    "end": "2455320"
  },
  {
    "text": "good so the worry you might have is you might get too many collisions right because",
    "start": "2455320",
    "end": "2461079"
  },
  {
    "start": "2458000",
    "end": "2526000"
  },
  {
    "text": "the whole point of doing this hash is I mean I could have could have said it would all be correct if I said the hash",
    "start": "2461079",
    "end": "2466960"
  },
  {
    "text": "of a variable map is seven right always seven then I just get well",
    "start": "2466960",
    "end": "2473320"
  },
  {
    "text": "a lot of collisions are what what's bad about collisions well when I'm looking up two things I'm I'm taking a term and",
    "start": "2473320",
    "end": "2479980"
  },
  {
    "text": "I say these two terms have the same hash code are they the same expression well after look in the hash table and see if",
    "start": "2479980",
    "end": "2485200"
  },
  {
    "text": "I got a collision I have to have to because every hash table bucket is going to have a list of all the Expressions that mapped to that bucket this is",
    "start": "2485200",
    "end": "2491859"
  },
  {
    "text": "always the true with true with hashing so we can't just say because they've got the same hash code they must be equal no",
    "start": "2491859",
    "end": "2497619"
  },
  {
    "text": "hashing loses information so in the hash table there's a list of Expressions so if two things have the same hash code",
    "start": "2497619",
    "end": "2503740"
  },
  {
    "text": "they're going to map to the same slot have to look sequentially up in that list of expressions and um see would see",
    "start": "2503740",
    "end": "2509800"
  },
  {
    "text": "whether whether it's a member of that list I don't so I I don't want many collisions if a varmap hash was always",
    "start": "2509800",
    "end": "2516160"
  },
  {
    "text": "seven everything would work fine but I get lots of collisions slow so I want to get few collisions so the question is",
    "start": "2516160",
    "end": "2522700"
  },
  {
    "text": "does xor screw up the few Collision argument and the answer is it does not",
    "start": "2522700",
    "end": "2528280"
  },
  {
    "start": "2526000",
    "end": "2568000"
  },
  {
    "text": "and for this you'll have to read the paper and not going to go through here it's going to um",
    "start": "2528280",
    "end": "2534180"
  },
  {
    "text": "we are not going to get a lot of extra false collisions so the sort of rough summary is when you're doing hashing for",
    "start": "2534180",
    "end": "2542140"
  },
  {
    "text": "sets if you've got strong hashes for the elements of the set then using xor to",
    "start": "2542140",
    "end": "2548680"
  },
  {
    "text": "compute the hash of the set is fine that's the Insight isn't that a great",
    "start": "2548680",
    "end": "2554980"
  },
  {
    "text": "insight I I really like that so it means that you can um uh you can get",
    "start": "2554980",
    "end": "2562780"
  },
  {
    "text": "um uh you know low Collision hashing even when you're deleting things from the verbal map",
    "start": "2562780",
    "end": "2568780"
  },
  {
    "start": "2568000",
    "end": "2617000"
  },
  {
    "text": "so uh does it Fraser asks does it work with any commutative group",
    "start": "2568780",
    "end": "2576099"
  },
  {
    "text": "um so I think you're saying could I have used something other than xor um and I believe yes I believe that in the",
    "start": "2576099",
    "end": "2583540"
  },
  {
    "text": "paper um the proof doesn't I believe that we're explicit about what properties of",
    "start": "2583540",
    "end": "2589359"
  },
  {
    "text": "excel we need and I think probably it's just that it's um commutative and associative and that the the additional",
    "start": "2589359",
    "end": "2595780"
  },
  {
    "text": "property that xor also um is sort of self-inversed you can if you Excel it twice is the extra piece that we need to",
    "start": "2595780",
    "end": "2603460"
  },
  {
    "text": "do the deletion but I think read the paper to check um that is just a commutative and",
    "start": "2603460",
    "end": "2609280"
  },
  {
    "text": "associative that makes it um okay for um hashing",
    "start": "2609280",
    "end": "2614579"
  },
  {
    "text": "okay uh where have we got to um so we've reduced from N squared",
    "start": "2615520",
    "end": "2622780"
  },
  {
    "text": "complexity to n log N squared the log N squared again you have to read the paper to see why it's a square but it's still",
    "start": "2622780",
    "end": "2629020"
  },
  {
    "text": "um fine in practice and we did that by um extracting instead of regarding",
    "start": "2629020",
    "end": "2634540"
  },
  {
    "text": "expressions with uh variables inside it inside it we extract it into two parts the structure an available map then we",
    "start": "2634540",
    "end": "2640900"
  },
  {
    "text": "had three ideas firstly using ordinary hashcon's infrastructure and pository certainly leaving the larger mapper",
    "start": "2640900",
    "end": "2647440"
  },
  {
    "text": "alone which meant doing some modifications for structure and pository so that we could leave the larger map alone when summarizing app nodes and the",
    "start": "2647440",
    "end": "2654280"
  },
  {
    "text": "third idea was using xor to Hash file Maps um and to reason about how this works so",
    "start": "2654280",
    "end": "2660400"
  },
  {
    "text": "it's really easy to screw up here if we had gone all the way from Expressions",
    "start": "2660400",
    "end": "2666400"
  },
  {
    "text": "instantly to this hashing mechanism I wouldn't be so confident that we hadn't screwed up but by defining an",
    "start": "2666400",
    "end": "2673300"
  },
  {
    "text": "information preserving um summarized it goes from Expressions to e-summeries where the E summaries",
    "start": "2673300",
    "end": "2680380"
  },
  {
    "text": "contain these depth and um and um depth and structure tag stuff and",
    "start": "2680380",
    "end": "2687339"
  },
  {
    "text": "making sure that that is a true inverse with expression that means I can guarantee that those e summaries are not",
    "start": "2687339",
    "end": "2693280"
  },
  {
    "text": "information losing now I can do the hashing and I only have to think about the information the",
    "start": "2693280",
    "end": "2699040"
  },
  {
    "text": "hashing is losing it's a separate thing I'm not accidentally um I've got not got not got accidental",
    "start": "2699040",
    "end": "2704800"
  },
  {
    "text": "collisions through you know having for example forgotten a depth tag um",
    "start": "2704800",
    "end": "2710880"
  },
  {
    "text": "right so the the the the um the intermediate step was very",
    "start": "2711400",
    "end": "2716560"
  },
  {
    "text": "helpful in reassuring us that we had got a local you know we could prove we had",
    "start": "2716560",
    "end": "2721660"
  },
  {
    "text": "low collisions uh does it work in practice well of course since we proved it it must",
    "start": "2721660",
    "end": "2727000"
  },
  {
    "start": "2723000",
    "end": "2797000"
  },
  {
    "text": "um but here's here are some actual numbers uh which you'll see in the paper um so this this first slide is about",
    "start": "2727000",
    "end": "2733300"
  },
  {
    "text": "numbers on synthetic benchmarks so here the synthetic test cases are um in the",
    "start": "2733300",
    "end": "2739359"
  },
  {
    "text": "in the left-hand figure they're fully balanced expressions in the right hand figure it's very very unbalanced",
    "start": "2739359",
    "end": "2745660"
  },
  {
    "text": "Expressions um so when they're balanced then everything is a sort of um uh",
    "start": "2745660",
    "end": "2752140"
  },
  {
    "text": "um you know it works pretty similarly the the the um uh the green circles is the stuff",
    "start": "2752140",
    "end": "2758500"
  },
  {
    "text": "that I've shown you and low is good so it looks as if the the uh orange",
    "start": "2758500",
    "end": "2765099"
  },
  {
    "text": "triangles and the red squares are better and they are but they are wrong right",
    "start": "2765099",
    "end": "2771040"
  },
  {
    "text": "they get lots of false positives and false negatives the crosses which are called locally",
    "start": "2771040",
    "end": "2776619"
  },
  {
    "text": "nameless there's a bit more in the paper is correct um and it turns out to actually be slower than our algorithm it is another",
    "start": "2776619",
    "end": "2782440"
  },
  {
    "text": "correct algorithm but for the unbalanced expression locally nameless has a different complexity right it's",
    "start": "2782440",
    "end": "2788440"
  },
  {
    "text": "asymptotically worse so we're better in constant factor and asymptotically than locally nameless so in short this is the",
    "start": "2788440",
    "end": "2795099"
  },
  {
    "text": "green circles are the best algorithm we know that works um and here is a more realistic test",
    "start": "2795099",
    "end": "2800680"
  },
  {
    "start": "2797000",
    "end": "2807000"
  },
  {
    "text": "case this was a some big Expressions generated by you know from a sort of machine learning related",
    "start": "2800680",
    "end": "2806619"
  },
  {
    "text": "um big expression um and uh sure enough uh we're a lot better even on realistic examples than",
    "start": "2806619",
    "end": "2812740"
  },
  {
    "start": "2807000",
    "end": "2822000"
  },
  {
    "text": "the locally Neighbors which is correct not as good as the incorrect debonin structural things but of course if",
    "start": "2812740",
    "end": "2818319"
  },
  {
    "text": "structural is what you want you don't care about Commerce expression then you're better off with ordinary hashconzing so this is my conclusion um",
    "start": "2818319",
    "end": "2825160"
  },
  {
    "start": "2822000",
    "end": "2879000"
  },
  {
    "text": "and then we'll stop and have any um uh conversation that we want uh I think I found it surprising that there was this",
    "start": "2825160",
    "end": "2830319"
  },
  {
    "text": "sort of Gap in the literature right it seems like an obvious question to ask and yeah I couldn't find one so please tell me if you know any",
    "start": "2830319",
    "end": "2836740"
  },
  {
    "text": "um the algorithm I think you'll be you'll believe me it's is is a little bit",
    "start": "2836740",
    "end": "2842079"
  },
  {
    "text": "subtle kind of I'm really thrilled to see Alex saying it seems so obvious now",
    "start": "2842079",
    "end": "2847839"
  },
  {
    "text": "because that is my goal I think it's I look back and I think why didn't we see that you can't you can't believe how",
    "start": "2847839",
    "end": "2853599"
  },
  {
    "text": "long we spent flashing around trying to find this um so it's a nice simple ultimately simple certainly in code terms it's very",
    "start": "2853599",
    "end": "2860319"
  },
  {
    "text": "simple but it's very satisfying and it's quite efficient um and I really like the way that we had",
    "start": "2860319",
    "end": "2865839"
  },
  {
    "text": "to use you know some mathematics and some formal reasoning to actually get algorithmic improvements in something you might want to do in practice",
    "start": "2865839",
    "end": "2873040"
  },
  {
    "text": "thank you very much let's um",
    "start": "2873040",
    "end": "2877200"
  }
]