[
  {
    "start": "0",
    "end": "25000"
  },
  {
    "text": "[Music]",
    "start": "3480",
    "end": "7799"
  },
  {
    "text": "thank you um yes so uh as just been said we're going to be talking about what every coder should know about how CPUs",
    "start": "12559",
    "end": "19840"
  },
  {
    "text": "work um which to me is an absolutely fascinating topic hopefully you'll find it too um what I'd like you to get out",
    "start": "19840",
    "end": "26800"
  },
  {
    "start": "25000",
    "end": "73000"
  },
  {
    "text": "of this is first and foremost like an overview of what a modern CPU can do and is doing for you under the hood and by",
    "start": "26800",
    "end": "33200"
  },
  {
    "text": "modern CPU I mean anything that's been made in the last 15 years both x86 and",
    "start": "33200",
    "end": "39000"
  },
  {
    "text": "arm and risk five even but um my experience is mostly in x86 so um a lot",
    "start": "39000",
    "end": "45879"
  },
  {
    "text": "of this will have a sort of flavor of x86 about it um I also want to tell you a little bit about how compilers take",
    "start": "45879",
    "end": "52239"
  },
  {
    "text": "advantage of the knowledge that they have about how CPUs work in order to get the best out of the CPU for you so most",
    "start": "52239",
    "end": "58160"
  },
  {
    "text": "of the time you don't have to worry about this kind of stuff which is kind of cool and then when you do need to worry about it I'm going to show you",
    "start": "58160",
    "end": "64478"
  },
  {
    "text": "some tools that can help you understand um where the performance issues may be in your code or what on Earth is going",
    "start": "64479",
    "end": "70320"
  },
  {
    "text": "on inside your CPU in the first place so first and foremost I'm going to",
    "start": "70320",
    "end": "75799"
  },
  {
    "start": "73000",
    "end": "707000"
  },
  {
    "text": "explain um a sort of simplified looks more complicated I know but a simplified view of what a modern",
    "start": "75799",
    "end": "82680"
  },
  {
    "text": "CPU pipeline looks like so first and foremost it is a pipeline um it's a",
    "start": "82680",
    "end": "88439"
  },
  {
    "text": "production line things get get put on one end of the production line and they slowly make their way along and as they",
    "start": "88439",
    "end": "93479"
  },
  {
    "text": "go along the pipeline different things happen to those instructions that are being fetched um and we'll talk about",
    "start": "93479",
    "end": "99520"
  },
  {
    "text": "what how that all works in a second um and then sort of in modern CPU something",
    "start": "99520",
    "end": "104719"
  },
  {
    "text": "cool happens so if you've done um you know your myips uh style um fetch decode",
    "start": "104719",
    "end": "111960"
  },
  {
    "text": "execute retire for four-stage pipeline from like University days and that kind of things nothing works that way anymore",
    "start": "111960",
    "end": "118079"
  },
  {
    "text": "we have this front end that is in order so anything that's in blue means it happens in order that means each",
    "start": "118079",
    "end": "124320"
  },
  {
    "text": "instruction is processed one after another in the order that you wrote them and then there this cool green stage",
    "start": "124320",
    "end": "130800"
  },
  {
    "text": "here which is out of order and what does that mean it means that the CPU is going",
    "start": "130800",
    "end": "136000"
  },
  {
    "text": "to do some dependency tracking between the various instructions that you're you you've given it and it's going to",
    "start": "136000",
    "end": "141400"
  },
  {
    "text": "execute the instructions in an order where their sat their dependencies are satisfied but it's not necessarily the",
    "start": "141400",
    "end": "147560"
  },
  {
    "text": "order that you even gave them to the CPU in why would you want to do that well most of the time your program is waiting",
    "start": "147560",
    "end": "154040"
  },
  {
    "text": "for things like memory accesses or complicated things like multiplies divides to happen and if you can find",
    "start": "154040",
    "end": "160920"
  },
  {
    "text": "work that your CPU can be doing while it's waiting for memory accesses to complete then you can get more work done",
    "start": "160920",
    "end": "166959"
  },
  {
    "text": "per unit time but it is very complicated and that can be an issue that we sometimes surface to us when we're",
    "start": "166959",
    "end": "173319"
  },
  {
    "text": "looking for performance issues uh so we have this in order front end we have this out of order green",
    "start": "173319",
    "end": "180040"
  },
  {
    "text": "execution back end and then retirement sadly happens at the end and it happens",
    "start": "180040",
    "end": "185120"
  },
  {
    "text": "in order we all retire hopefully um uh and um and that happens back in order",
    "start": "185120",
    "end": "190519"
  },
  {
    "text": "again so despite the fact that all these clever things are happening and maybe your instructions are actually getting executed completely out of order they",
    "start": "190519",
    "end": "197680"
  },
  {
    "text": "retire strictly in sequence again which means that as a user looking from the outside in you typically don't notice",
    "start": "197680",
    "end": "203959"
  },
  {
    "text": "that those instructions happened out of order you see the program complete as you wrote it all very cool um there's a",
    "start": "203959",
    "end": "210599"
  },
  {
    "text": "huge caveat for this which is where Spectre and meltdown if you remember the furor about those issues there's a sort",
    "start": "210599",
    "end": "216599"
  },
  {
    "text": "of leak from this system unfortunately I don't have time to talk about that but you can talk to me about it afterwards",
    "start": "216599",
    "end": "221799"
  },
  {
    "text": "um so I kind of lied to you I said you know there's this sort of pipeline fetch decode and then there th here there's a",
    "start": "221799",
    "end": "227680"
  },
  {
    "text": "part that happens even before this the fetching starts so we have um um a",
    "start": "227680",
    "end": "233400"
  },
  {
    "text": "system that is going to try and guess what's going to happen in your program before you've even executed the first",
    "start": "233400",
    "end": "239400"
  },
  {
    "text": "instruction why is this this pipeline here this fetch decode rename and then the all the",
    "start": "239400",
    "end": "245079"
  },
  {
    "text": "green stuff over here is many stages long there are like dozens of Cycles",
    "start": "245079",
    "end": "250319"
  },
  {
    "text": "between the point where the information about what instructions need to be run it's being fetched from memory through the caches it's being broken apart and",
    "start": "250319",
    "end": "257440"
  },
  {
    "text": "decoded into all of the different micro operations that go into that uh sequence of instructions and then by the time",
    "start": "257440",
    "end": "263800"
  },
  {
    "text": "they've been scheduled to run it's a bit late if we discover that there was a branch that said we should go somewhere",
    "start": "263800",
    "end": "268919"
  },
  {
    "text": "else now and so typically um CPUs of of yester year would have a little bubble",
    "start": "268919",
    "end": "275039"
  },
  {
    "text": "in the pipeline when the branch happened and and the the the the direction of the program moved somewhere else everything",
    "start": "275039",
    "end": "281479"
  },
  {
    "text": "would be discarded and the program would restart but then we have to kind of refill the pipeline again from the left",
    "start": "281479",
    "end": "286840"
  },
  {
    "text": "hand side with the new address of where we're going from that's cool and all but when when there was like two or three",
    "start": "286840",
    "end": "292600"
  },
  {
    "text": "cycles that was maybe okay but when there's 12 cycles that means every time you take a branch you're taking this big",
    "start": "292600",
    "end": "298880"
  },
  {
    "text": "hit of steering this this this pop production line and the way that I like to think of it it's a bit like those I",
    "start": "298880",
    "end": "304479"
  },
  {
    "text": "don't know if you've seen the strip mining machines there's this huge like spinning um uh digging thing that's",
    "start": "304479",
    "end": "312000"
  },
  {
    "text": "pulling out ore and chucking onto a huge conveyor bout that's like you know half a mile long and then the control unit is",
    "start": "312000",
    "end": "317800"
  },
  {
    "text": "right at the back of that and then some person is steering it back and forward to try and like mine the ground it's",
    "start": "317800",
    "end": "322919"
  },
  {
    "text": "like if they can only see the or that they're mining right next to them that's like the execution unit and they start",
    "start": "322919",
    "end": "328520"
  },
  {
    "text": "realizing that you're not digging up the or that you want anymore oh no I'm digging up like just dirt now and I",
    "start": "328520",
    "end": "333639"
  },
  {
    "text": "wanted to be getting that I now have to steer that pipe to the new location of where where the where the stuff that I",
    "start": "333639",
    "end": "339479"
  },
  {
    "text": "want but unfortunately I have this entire pipeline of dirt that I've got to sort of like deal with that's coming down and so um what the branch predictor",
    "start": "339479",
    "end": "347360"
  },
  {
    "text": "is going to try and do in that situation is make an intelligent guess about where the program flow is going to go before",
    "start": "347360",
    "end": "354199"
  },
  {
    "text": "we've even seen the program which is a pretty difficult thing to do with no",
    "start": "354199",
    "end": "360199"
  },
  {
    "text": "information whatsoever that Branch predictor has to make a guess and what it's trying to guess is is there a",
    "start": "360199",
    "end": "365479"
  },
  {
    "text": "branch coming up in the sequence of instructions that are coming um if there is where does it go to and for those",
    "start": "365479",
    "end": "373160"
  },
  {
    "text": "many branches which are conditional the kind of if then go this go to whatever then will it be taken this time and if",
    "start": "373160",
    "end": "381000"
  },
  {
    "text": "we can predict that more often than we predict it correctly more often than not then we can actually steer that pipeline",
    "start": "381000",
    "end": "387440"
  },
  {
    "text": "in the right direction and every time the branch gets hit we aren't throwing away all of the work that's on the",
    "start": "387440",
    "end": "392800"
  },
  {
    "text": "production line the work was actually correct but we also have to accept that sometimes we get it wrong in which case",
    "start": "392800",
    "end": "398479"
  },
  {
    "text": "yes we still need to throw some of that work away but if we don't get it wrong too often that's not such a big deal we'll talk about how that Branch",
    "start": "398479",
    "end": "404520"
  },
  {
    "text": "prediction Works in a second so having guessed where the program is going to go we're going to start the front end the",
    "start": "404520",
    "end": "410360"
  },
  {
    "text": "front end is responsible for picking up data bytes from memory and loading them through the cache in big chunks decoding",
    "start": "410360",
    "end": "418400"
  },
  {
    "text": "those chunks in to the actual instructions that are inside those bites um this is where for things like arm",
    "start": "418400",
    "end": "424400"
  },
  {
    "text": "processes the um the encoding of arm instructions is very straightforward it's either two bytes long or four bytes",
    "start": "424400",
    "end": "430440"
  },
  {
    "text": "long depending on which mode it's in and that makes it very straightforward to do this decode stage but if you've ever",
    "start": "430440",
    "end": "435639"
  },
  {
    "text": "looked at x86 machine code and the assembly code that goes with it um a",
    "start": "435639",
    "end": "440879"
  },
  {
    "text": "single x86 instruction can be anywhere between one BTE and 15 bytes long and so",
    "start": "440879",
    "end": "446400"
  },
  {
    "text": "there's a lot of complicated stuff that goes into decoding that and turning it into is some kind of understandable what",
    "start": "446400",
    "end": "451560"
  },
  {
    "text": "is this instruction is it an add is it a subtract is it a multiply those kinds of things and another cool thing that",
    "start": "451560",
    "end": "456599"
  },
  {
    "text": "happens in the front end is that a process called register renaming happens where some internal um uh space on the",
    "start": "456599",
    "end": "465680"
  },
  {
    "text": "chip is used to store intermediate results and it's as if you have now like a couple of hundred registers so most",
    "start": "465680",
    "end": "471960"
  },
  {
    "text": "CPUs only have a dozen registers you know 16 or 32 registers and so you can often if you keep re using the same",
    "start": "471960",
    "end": "477360"
  },
  {
    "text": "register over and over again you know load something into a store it over here load something else into a store over here then there's no opportunity to use",
    "start": "477360",
    "end": "484759"
  },
  {
    "text": "to to have those two operations run in parallel because they both want to use the a register but we know as",
    "start": "484759",
    "end": "490080"
  },
  {
    "text": "programmers that there sort of two different uses of the a register and the renamer is able to do this so it would",
    "start": "490080",
    "end": "496199"
  },
  {
    "text": "rewrite that into load into temporary register zero and then store temporary register zero over here and then load",
    "start": "496199",
    "end": "501639"
  },
  {
    "text": "into temporary register one and store over there and so there's a lot of tracking that goes on some clever things that go on to avoid these data hazards",
    "start": "501639",
    "end": "508680"
  },
  {
    "text": "so finally we get to the point where we're actually doing some work um we have inside this execution",
    "start": "508680",
    "end": "515959"
  },
  {
    "text": "unit there's a this re sorry the Rob there is reorder buffer so there's a reorder buffer which stores all these",
    "start": "515959",
    "end": "521479"
  },
  {
    "text": "internal um results while they're being assembled in the order that they're going to be completed in um and then the",
    "start": "521479",
    "end": "527959"
  },
  {
    "text": "execution units there are many many of those so we're talking about a single CPU here um a single score on a on a on",
    "start": "527959",
    "end": "535040"
  },
  {
    "text": "a die um but it can have multiple multipliers it can have multiple adders it can have multiple floating Point",
    "start": "535040",
    "end": "540760"
  },
  {
    "text": "units arithmetic units adress generators all these things here and what the execution stage is doing is looking for",
    "start": "540760",
    "end": "548200"
  },
  {
    "text": "instructions whose inputs are now known and then scheduling them to run on a",
    "start": "548200",
    "end": "553240"
  },
  {
    "text": "particular part of the chip so if this is a multiply and we know it's inputs we can start running the multiply that may not be the next instruction that flow",
    "start": "553240",
    "end": "559600"
  },
  {
    "text": "through the pipeline because we're tracking whether or not it's ready to go or not um and um what that means is that",
    "start": "559600",
    "end": "568079"
  },
  {
    "text": "there are multiple units that can be running in parallel so if we have two multipliers we can be doing two",
    "start": "568079",
    "end": "573680"
  },
  {
    "text": "multipliers at once if we have several ALU units we can be doing ad subtracts mult add subtracts shifts and things",
    "start": "573680",
    "end": "579480"
  },
  {
    "text": "like that at the same time and typically even this relatively old laptop that I'm on here can be executing anywhere",
    "start": "579480",
    "end": "586399"
  },
  {
    "text": "between five and eight instructions every single clock cycle in this execute",
    "start": "586399",
    "end": "591519"
  },
  {
    "text": "block provided those parts don't use the same areas of the Chip and that's where some of the parallel uh sorry some of",
    "start": "591519",
    "end": "598160"
  },
  {
    "text": "the performance of modern C pus is coming from these days you may have noticed that the the clock speed hasn't been going up over the last few years",
    "start": "598160",
    "end": "605440"
  },
  {
    "text": "you know we've been sort of stuck at anywhere between 2 and four gigahertz pretty much these days we might have more cores on our chip so we can get",
    "start": "605440",
    "end": "612200"
  },
  {
    "text": "multiple threads going but even single core performan is going up and part of it is because of the clever tricks that can be pulled out inside of this",
    "start": "612200",
    "end": "619920"
  },
  {
    "text": "stage finally at the very end of the pipeline we re re retire the",
    "start": "619920",
    "end": "625360"
  },
  {
    "text": "instructions that have completed this is kind of like committing finally the instructions to having actually happened",
    "start": "625360",
    "end": "631880"
  },
  {
    "text": "and that again happens in strict program order which means that we don't see any kind of weird um side effects of having",
    "start": "631880",
    "end": "637880"
  },
  {
    "text": "done things in the wrong order or in a different order inside of the of the Chip And um this is where exceptions are",
    "start": "637880",
    "end": "644160"
  },
  {
    "text": "handled so if this is where you um potentially um hit some area of memory that was flagged as being um not mapped",
    "start": "644160",
    "end": "650920"
  },
  {
    "text": "and you get a seg fault the instruction will be tagged and when the instruction finally completes at the retirement stage that's where the chip actually",
    "start": "650920",
    "end": "657279"
  },
  {
    "text": "goes okay now we need to do something different we need to go to the the crash handlers um similarly this is where the",
    "start": "657279",
    "end": "664399"
  },
  {
    "text": "um the the the the fact that we've been pulling instructions that we don't know",
    "start": "664399",
    "end": "669480"
  },
  {
    "text": "if they're the right instructions you know this Branch prediction system is happening we're following along the thread of where we are just making a",
    "start": "669480",
    "end": "675800"
  },
  {
    "text": "guess and if we make a mistake we need to be able to throw away the work that we were doing and the way that we throw",
    "start": "675800",
    "end": "681399"
  },
  {
    "text": "that away is by just not retiring those instructions when we discover a branch that was that went wrong so having",
    "start": "681399",
    "end": "687399"
  },
  {
    "text": "executed a branch we check it against whether whether or not we predicted it would be taken or not and if it was right no harm no foul if it was wrong",
    "start": "687399",
    "end": "695079"
  },
  {
    "text": "all of the instructions that happen immediately after that Branch need to be thrown away and the way that we do that",
    "start": "695079",
    "end": "700760"
  },
  {
    "text": "is to just discard them from this this the retirement buffer and make sure they never retire so there's a lot of clever tricks going on in there um that is a",
    "start": "700760",
    "end": "707760"
  },
  {
    "start": "707000",
    "end": "1287000"
  },
  {
    "text": "super super high level View and um there aren't even half as many um I mean the",
    "start": "707760",
    "end": "712800"
  },
  {
    "text": "as I say these are like anywhere between uh 12 and a couple of hundred of Cycles before a single instruction makes it",
    "start": "712800",
    "end": "718800"
  },
  {
    "text": "from one end the pipeline to the other but um hopefully it gives you a sort of grounding and now we're going to talk a",
    "start": "718800",
    "end": "724079"
  },
  {
    "text": "little bit about about some specifics and I'm going to give you some tooling to show how it happens um or how you can",
    "start": "724079",
    "end": "729200"
  },
  {
    "text": "measure it yourself so this is more confusing um a picture than I wanted it to be unfortunately um I have another",
    "start": "729200",
    "end": "735959"
  },
  {
    "text": "presentation where I go into a deep dive in how the branch predictor Works um and I stole some slides from it and now I'm like thinking oh gosh this is probably",
    "start": "735959",
    "end": "741600"
  },
  {
    "text": "more confusing but the general gist of the branch predictor is that it has a little lookup table and every time the",
    "start": "741600",
    "end": "748839"
  },
  {
    "text": "ex excution system discovers that there's a branch and it took a branch it sends a message back to the branch",
    "start": "748839",
    "end": "753880"
  },
  {
    "text": "predictor saying hey at address 1,000 there's a branch to address 2,000 it goes okay and it notes it down in a",
    "start": "753880",
    "end": "759399"
  },
  {
    "text": "table that table is the branch Target buffer and you can think of it like a hashmap it's a hashmap that gets",
    "start": "759399",
    "end": "765920"
  },
  {
    "text": "replaced over time um there's only a certain number of entries that are in it so we've only got a couple hundred of those whatever um and that means that",
    "start": "765920",
    "end": "773079"
  },
  {
    "text": "the next time we see that address we will predict that we'll go to address 2,000 rather than just following a linear line of one instruction after",
    "start": "773079",
    "end": "780279"
  },
  {
    "text": "another that's great for unconditional branches but many branches are either um",
    "start": "780279",
    "end": "786839"
  },
  {
    "text": "conditional or have a um a derived destination they are like a a switch",
    "start": "786839",
    "end": "792440"
  },
  {
    "text": "statement or a virtual function called in in C++ terms where we don't actually know the destination I haven't even put",
    "start": "792440",
    "end": "798360"
  },
  {
    "text": "that on here but the most common case we think about with Branch prediction is whether it's taken or not and so the the",
    "start": "798360",
    "end": "804880"
  },
  {
    "text": "ways that this is done is a sort of relatively closely guarded Secret by each of the vendors because the key to",
    "start": "804880",
    "end": "809920"
  },
  {
    "text": "great performance is accurate Branch prediction and um AMD and Intel and arm",
    "start": "809920",
    "end": "816760"
  },
  {
    "text": "don't really publish many details about how these Branch prods work but they have luckily been reverse engineered by some smart people and broadly what",
    "start": "816760",
    "end": "824199"
  },
  {
    "text": "happens is the instruction address where there a branch is known to be plus some",
    "start": "824199",
    "end": "829360"
  },
  {
    "text": "amount of History both locally for that ex that that specific branch and globally for all branches they're sort",
    "start": "829360",
    "end": "837199"
  },
  {
    "text": "of hashed together to give a unique sort of fingerprint for when I'm at this branch and I have seen branches that go",
    "start": "837199",
    "end": "843880"
  },
  {
    "text": "taken not taken taken taken not taken something like that then go to slot",
    "start": "843880",
    "end": "849480"
  },
  {
    "text": "seven in these predictors over here that's like where the hash lands and then in that predictor table I just keep",
    "start": "849480",
    "end": "855240"
  },
  {
    "text": "count of whether or not it was taken or not and I have a two bit counter every time it's taken I add one to that and",
    "start": "855240",
    "end": "861000"
  },
  {
    "text": "every time I uh it's not taken I subtract one from it and then I just use whether or not it was taken before or",
    "start": "861000",
    "end": "868240"
  },
  {
    "text": "not as the predic for whether it's taken this time and it works remarkably well and there's a lot more subtlety to it there's some agreement predictors there",
    "start": "868240",
    "end": "873880"
  },
  {
    "text": "are multi levels of this kind of stuff but broadly speaking it's kind of a hash lookup and a bit of History keeping",
    "start": "873880",
    "end": "880440"
  },
  {
    "text": "track of what happened last time is it important though I mean I've",
    "start": "880440",
    "end": "885480"
  },
  {
    "text": "been waxing lyrical up here about how how important it is I'd like to show that the branch predictor is actually",
    "start": "885480",
    "end": "891240"
  },
  {
    "text": "valuable even when you're writing something in Python so I've got a bit of python up here and this python code is",
    "start": "891240",
    "end": "897399"
  },
  {
    "text": "just summing over a list of integers the list of integers is um a big set of",
    "start": "897399",
    "end": "903839"
  },
  {
    "text": "numbers between 0 and 255 and essentially in the middle of this Loop here this is I mean this is terrible python code don't write python",
    "start": "903839",
    "end": "910160"
  },
  {
    "text": "code this way for this kind of thing and but um we're saying keep track of a total sum of all the integers and then",
    "start": "910160",
    "end": "916639"
  },
  {
    "text": "separately I want to just keep track of the sum of all the integers that are less than 128 seem reasonable so far so",
    "start": "916639",
    "end": "922600"
  },
  {
    "text": "hiding in there is a branch it's not a specific branch in in like um some",
    "start": "922600",
    "end": "928319"
  },
  {
    "text": "object code some assembly code but deep deep deep inside the python interpreter we know that there's going to be some",
    "start": "928319",
    "end": "934160"
  },
  {
    "text": "kind of switch on the python B code and there's going to be a pattern in the ways that it's going to be jumping",
    "start": "934160",
    "end": "940040"
  },
  {
    "text": "around and I'm hoping to show that the branch predictor can be affected by whether this branch is taken or not and",
    "start": "940040",
    "end": "946519"
  },
  {
    "text": "measure it so what my Approach is going to be is I'm going to run this piece of code with 10 million random numbers",
    "start": "946519",
    "end": "953680"
  },
  {
    "text": "again between 0 and 255 and then I'm going to run it again with the same data except I sort the data",
    "start": "953680",
    "end": "960560"
  },
  {
    "text": "first now this is a kind of very counterintuitive thing to do because it's the same numbers right I'm not",
    "start": "960560",
    "end": "965720"
  },
  {
    "text": "pulling any tricks here sorting it doesn't do anything clever like bring it into the memory caches or anything like that I've done versions of this where I",
    "start": "965720",
    "end": "971959"
  },
  {
    "text": "write the file out and just have two copies of the same data one where the f is sorted one where the file is not sorted and I run it over those and it",
    "start": "971959",
    "end": "978360"
  },
  {
    "text": "gets the same answers so if we run it for 10 million items this is",
    "start": "978360",
    "end": "983440"
  },
  {
    "text": "surprisingly quick really for python 7 Seconds it takes to run over the unsorted data now again I mean I've been",
    "start": "983440",
    "end": "991160"
  },
  {
    "text": "leading up to this point here this is sort of a leading question do we think it's going to go faster or slower if I give it sorted data versus unsorted",
    "start": "991160",
    "end": "999160"
  },
  {
    "text": "data faster people think it's going to be faster and they're absolutely right it is measurably faster even in Python",
    "start": "999160",
    "end": "1005079"
  },
  {
    "text": "an interpreted language running over 10 million numbers if the numbers are sorted first and if we just take a",
    "start": "1005079",
    "end": "1010800"
  },
  {
    "text": "moment to think about that the hypothesis would be that well go back to me code one second that um this branch",
    "start": "1010800",
    "end": "1019639"
  },
  {
    "text": "is essentially unpredictable if I give it random data it is equally likely for the number that I'm going in this",
    "start": "1019639",
    "end": "1025959"
  },
  {
    "text": "particular iteration around the loop is greater than 128 or less than 128 right equally likely it's a quintos and so",
    "start": "1025959",
    "end": "1032839"
  },
  {
    "text": "there's no pattern at all for the branch predictor to latch onto there it will make a prediction and it will be wrong",
    "start": "1032839",
    "end": "1039000"
  },
  {
    "text": "half the time and then I'll have to undo this work and rester the pipeline and start again all that kind of good stuff",
    "start": "1039000",
    "end": "1045000"
  },
  {
    "text": "but when the data is sorted this branch is jumped over sorry no is yeah for the first half of",
    "start": "1045000",
    "end": "1052760"
  },
  {
    "text": "the file all of the values are less than 128 because we've sorted it and so this",
    "start": "1052760",
    "end": "1058400"
  },
  {
    "text": "if statement will be taken I.E the branch won't be taken and then as soon as we get to the middle midpoint of the file we we'll discover the first value",
    "start": "1058400",
    "end": "1064880"
  },
  {
    "text": "that's 1228 or greater the branch predictor will probably mispredict that but quickly it will learn that this",
    "start": "1064880",
    "end": "1071160"
  },
  {
    "text": "branch is now always taken and so what we've got is a predictable branch in the case of the data being",
    "start": "1071160",
    "end": "1077679"
  },
  {
    "text": "sorted but but is it really that I mean this is a relatively small um change of8",
    "start": "1077679",
    "end": "1084039"
  },
  {
    "text": "8 seconds 80 milliseconds difference there is it really the branch predictor or have I just done something silly in",
    "start": "1084039",
    "end": "1089400"
  },
  {
    "text": "my tests um it's a good question it's one I he always should ask yourself whenever you're doing performance related stuff you have to measure things",
    "start": "1089400",
    "end": "1095000"
  },
  {
    "text": "over and over again and really try and look for some of the more esoteric hypo hypotheses so this is a tool that I use",
    "start": "1095000",
    "end": "1102039"
  },
  {
    "text": "so I'm I'm most of the stuff I'm going to be talking about is be Linux based but there are equivalents for Windows um vtune for example is Intel's sort of",
    "start": "1102039",
    "end": "1108200"
  },
  {
    "text": "gooy based version of this that is available both for Windows and Linux um",
    "start": "1108200",
    "end": "1113520"
  },
  {
    "text": "perf is a tool that uses the counters inside the chip so the chip itself keeps track of interesting events that happen",
    "start": "1113520",
    "end": "1120240"
  },
  {
    "text": "and you can configure up to between four and six counters um and measure one of",
    "start": "1120240",
    "end": "1125360"
  },
  {
    "text": "thousands of different things that can happen on the chip this of like dis Telemetry inside the CPU and so what",
    "start": "1125360",
    "end": "1130600"
  },
  {
    "text": "I've asked it to do is use two of the counters to count both the number of branches that we encountered and the number of branches that we missed and",
    "start": "1130600",
    "end": "1137720"
  },
  {
    "text": "you can see when I'm running my python code here um with the data being unsorted I.E random then there are 20",
    "start": "1137720",
    "end": "1145000"
  },
  {
    "text": "billion branches and 124 million them were misses this is pretty incredible right",
    "start": "1145000",
    "end": "1151559"
  },
  {
    "text": "remember this is random remember also that there's tons of other branches in the python interpreter right but 90 was",
    "start": "1151559",
    "end": "1159400"
  },
  {
    "text": "that 99.4% of branches have been correctly predicted amazing if we run it with the sorted",
    "start": "1159400",
    "end": "1166520"
  },
  {
    "text": "case though we see that we drop somewhere in a region of 50 million mispredictions and we go down to 37",
    "start": "1166520",
    "end": "1172480"
  },
  {
    "text": "branches of all are being mispredicted that's amazing absolutely amazing um so",
    "start": "1172480",
    "end": "1179640"
  },
  {
    "text": "I think it's clear that we could say that like and if you measure some of the other performance characteristics of the",
    "start": "1179640",
    "end": "1185120"
  },
  {
    "text": "uh of the CPU it's pretty clear that the only thing that can explain the speed up really is this Branch misprediction um",
    "start": "1185120",
    "end": "1191280"
  },
  {
    "text": "another thing that PF can do is it can show you the instructions that actually generated the mispredictions and you can draw some conclusions from that and sort",
    "start": "1191280",
    "end": "1197480"
  },
  {
    "text": "of do work back backwards and sort of say no it really is this particular bit of the code so that's pretty cool but",
    "start": "1197480",
    "end": "1203720"
  },
  {
    "text": "you know Python's a bit of a weird language to demonstrate microarchitectural effects in so let's try C++ um so this is the same code",
    "start": "1203720",
    "end": "1210760"
  },
  {
    "text": "written in C++ exactly the same kind of um flavor to it just you know slightly different",
    "start": "1210760",
    "end": "1216760"
  },
  {
    "text": "syntax and the unsorted takes 7.6 milliseconds is the sorted going to be",
    "start": "1216760",
    "end": "1222440"
  },
  {
    "text": "faster or slower and you know this is going to be a trick question don't you anyone has it a guess",
    "start": "1222440",
    "end": "1230360"
  },
  {
    "text": "no one's going to no one's going to put that their neck out on the line the sorted case if my clicker works exactly",
    "start": "1230360",
    "end": "1236000"
  },
  {
    "text": "the same hm so somehow C++ can teach the branch predictor to predict random",
    "start": "1236000",
    "end": "1242240"
  },
  {
    "text": "events maybe I don't know so what happened here so well let's first of all let's throw perf at this and see what",
    "start": "1242240",
    "end": "1247720"
  },
  {
    "text": "happened so if I run my my Branch prediction code the C code version of",
    "start": "1247720",
    "end": "1252919"
  },
  {
    "text": "this um you can see far fewer actual branches were taken because you know now",
    "start": "1252919",
    "end": "1258039"
  },
  {
    "text": "we haven't got the python interpreter that's being actually run we've just seen that tiny Loop of code that's doing the if check um 38 million branches",
    "start": "1258039",
    "end": "1266600"
  },
  {
    "text": "missed when it's unsorted and when we sort the data exactly the same within",
    "start": "1266600",
    "end": "1272120"
  },
  {
    "text": "the noise of the perf system itself so perf unfortunately is not a perfect um system it's got a certain amount of",
    "start": "1272120",
    "end": "1277720"
  },
  {
    "text": "Noise with it um so how come we're able to predict these branches well let's",
    "start": "1277720",
    "end": "1283480"
  },
  {
    "text": "let's go and have a look at the code so one thing we can do I hope this works",
    "start": "1283480",
    "end": "1288600"
  },
  {
    "start": "1287000",
    "end": "1575000"
  },
  {
    "text": "fingers crossed drum roll there we go so this oh my God that's so bright and white in a",
    "start": "1288600",
    "end": "1295000"
  },
  {
    "text": "second it'll go into dark mode and you can see unfortunately that I didn't try this on the actual resolution that we",
    "start": "1295000",
    "end": "1300480"
  },
  {
    "text": "were in here so what I've got this is compiler Explorer which is a website that lets you put in your code on the left hand side and then it shows you the",
    "start": "1300480",
    "end": "1308279"
  },
  {
    "text": "assembly code equivalent on the right hand side and then you can Mouse around inside of here I can scroll around",
    "start": "1308279",
    "end": "1314039"
  },
  {
    "text": "somewhere um and as I'm scrolling over the various different parts of it unfortunately again because the the the",
    "start": "1314039",
    "end": "1319600"
  },
  {
    "text": "zoom here if I can zoom it out a little bit there you are that's a little bit better okay so as I'm sort of mousing",
    "start": "1319600",
    "end": "1326760"
  },
  {
    "text": "over you can see that I'm highlighting the instructions that correspond to those particular parts of the code and",
    "start": "1326760",
    "end": "1333240"
  },
  {
    "text": "um it's a valuable tool in terms of working these kinds of things out but because it's easier to look at the code",
    "start": "1333240",
    "end": "1338360"
  },
  {
    "text": "on a big screen here rather than me trying to fart around with the website I've pasted it into here and I've put the comments about what's going on",
    "start": "1338360",
    "end": "1344000"
  },
  {
    "text": "inside the code here so this tiny Loop here is the is this Loop above um the",
    "start": "1344000",
    "end": "1351240"
  },
  {
    "text": "first part we're doing and I'm assuming you know like it's been a while since most of you have looked at assembly code",
    "start": "1351240",
    "end": "1356279"
  },
  {
    "text": "I'm sure but anyway so we're reading the next value into ECX it's a register",
    "start": "1356279",
    "end": "1361360"
  },
  {
    "text": "don't worry about it and then we're just adding it to r8d r8d just happens to be the register it chose to put total sum",
    "start": "1361360",
    "end": "1366760"
  },
  {
    "text": "in so that is this the first sort of line there total sum plus equals integer",
    "start": "1366760",
    "end": "1372000"
  },
  {
    "text": "the second part here is cleverer what the compiler has decided to do is work out unconditionally what the value of",
    "start": "1372000",
    "end": "1379360"
  },
  {
    "text": "some below 128 would be regardless of the value of integer it's just going to add integer to it anyway and then it",
    "start": "1379360",
    "end": "1386640"
  },
  {
    "text": "does the comparison and then it uses a conditional move that says if the",
    "start": "1386640",
    "end": "1392000"
  },
  {
    "text": "comparison was below that's what the B of C of B is if the comparison was below",
    "start": "1392000",
    "end": "1398200"
  },
  {
    "text": "then move this temporary value back into the um some below 128 otherwise leave it",
    "start": "1398200",
    "end": "1403480"
  },
  {
    "text": "alone and so it's kind of a hardware turnery operator you know like the question mark um and the important thing",
    "start": "1403480",
    "end": "1409919"
  },
  {
    "text": "about that is that there is no Branch here there's nothing to predict there's nothing to mispredict critically the compiler has decided to use this",
    "start": "1409919",
    "end": "1416360"
  },
  {
    "text": "conditional Loop here sorry conditional um move here and then there's some other nonsense here so there's exactly one",
    "start": "1416360",
    "end": "1422000"
  },
  {
    "text": "branch this j& at the bottom here exactly one branch in the whole program and this is very very predictable",
    "start": "1422000",
    "end": "1428320"
  },
  {
    "text": "because it's going to be taken 10 million times and then the last time around the loop it's not going to be taken and the predictor will get it",
    "start": "1428320",
    "end": "1433720"
  },
  {
    "text": "wrong then but I think by then we've got the benefit of the branch predictor out of it so",
    "start": "1433720",
    "end": "1439200"
  },
  {
    "text": "the compiler is pretty smart here the compiler has taken a bet that doing the",
    "start": "1439200",
    "end": "1444480"
  },
  {
    "text": "ad unconditionally even though it's inside an if statement is worth doing like the performance of it is worth",
    "start": "1444480",
    "end": "1450480"
  },
  {
    "text": "doing um to be able to do this conditional move now if there was a side effect in there if if if that if",
    "start": "1450480",
    "end": "1456279"
  },
  {
    "text": "statement had like a print statement or something like that obviously the compiler couldn't run that bit of code it knows that there's no side effects to",
    "start": "1456279",
    "end": "1462400"
  },
  {
    "text": "that particular um aspect so compiler has chosen to do this it doesn't always make this choice but it has this",
    "start": "1462400",
    "end": "1468559"
  },
  {
    "text": "instance here so what if I turned the compiler's ability to make that conditional move off um so I've got a",
    "start": "1468559",
    "end": "1475080"
  },
  {
    "text": "horrible hack there which I compile it with f no if conversion which says to the compiler don't do that um then um if",
    "start": "1475080",
    "end": "1484520"
  },
  {
    "text": "we use the sorted case um we see that we've got similar results to before there's more branches now because now",
    "start": "1484520",
    "end": "1490559"
  },
  {
    "text": "we've got two branches we've got a branch in the middle of the code that's jumping over but it's sorted so it's predictable so the the actual Miss rate",
    "start": "1490559",
    "end": "1496880"
  },
  {
    "text": "is still 37% so far so good um when we run it on the unsorted data 24% of all the branches",
    "start": "1496880",
    "end": "1504440"
  },
  {
    "text": "are mispredicted which is exactly what you'd expect right that Loop has two branches one of which is perfectly predictable so half the branches will be",
    "start": "1504440",
    "end": "1511279"
  },
  {
    "text": "perfectly predicted the other half of the branches will be wrong exactly half the time so that's where the 25% comes",
    "start": "1511279",
    "end": "1516679"
  },
  {
    "text": "from so that is monstrous and it takes 39 milliseconds versus the nine if we",
    "start": "1516679",
    "end": "1523960"
  },
  {
    "text": "just use the branch for version versus the seven if we use the COV version so the compiler got it right here the compiler made the right call and um you",
    "start": "1523960",
    "end": "1531480"
  },
  {
    "text": "can see that um Branch prediction correctly is important to be able to do",
    "start": "1531480",
    "end": "1536840"
  },
  {
    "text": "um this looks very artificial I get it I mean it's a surprising thing that sorting your data could make your program go faster I get but so is this",
    "start": "1536840",
    "end": "1544039"
  },
  {
    "text": "realistic and Yes actually I have another presentation where I write a ray Tracer and the end of the presentation",
    "start": "1544039",
    "end": "1551000"
  },
  {
    "text": "it was meant to be about C++ style not about performance at all that's my thing um by the end of it suddenly I'm running",
    "start": "1551000",
    "end": "1557000"
  },
  {
    "text": "the one of the versions and it's so so much slower and I couldn't work out why and it turned out that there was a branch that was totally not predictable",
    "start": "1557000",
    "end": "1562880"
  },
  {
    "text": "in the middle of this Ray Tracer and making a single character change in my code made that Branch predictable and",
    "start": "1562880",
    "end": "1568480"
  },
  {
    "text": "the thing went third you know three times faster was brilliant it doesn't happen very often right but for these kinds of things it can",
    "start": "1568480",
    "end": "1574960"
  },
  {
    "text": "do all right we're going to move on to um how am I doing on time not very well so I'm going to have to start going a",
    "start": "1574960",
    "end": "1580279"
  },
  {
    "start": "1575000",
    "end": "1736000"
  },
  {
    "text": "bit quicker we're going to talk a little bit about execution um I originally had some very morbid picture here and then I",
    "start": "1580279",
    "end": "1585840"
  },
  {
    "text": "thought I'd probably come up with something slightly better than that for for for this um so I'm going to try and",
    "start": "1585840",
    "end": "1592200"
  },
  {
    "text": "explain with a little um sort of real world worked scenario of something which",
    "start": "1592200",
    "end": "1597399"
  },
  {
    "text": "hopefully people have been familiar are familiar with which is a bloom filter if anyone know what a bloom",
    "start": "1597399",
    "end": "1603440"
  },
  {
    "text": "filter there's a few nods in the audience yes so super quickly a bloom filter is an acceleration structure a",
    "start": "1603440",
    "end": "1610000"
  },
  {
    "text": "probabilistic acceleration structure where you can ask the question is my value W in this set or not and the",
    "start": "1610000",
    "end": "1617159"
  },
  {
    "text": "answer it gives back is maybe and definitely not and why the heck is that",
    "start": "1617159",
    "end": "1622840"
  },
  {
    "text": "useful well that set is actually quite small the maybe obviously you have to be able to deal with false positives is",
    "start": "1622840",
    "end": "1628960"
  },
  {
    "text": "useful for things like databases where maybe um if you definitely know something's not in the database there's",
    "start": "1628960",
    "end": "1634000"
  },
  {
    "text": "no point going to load the B tree off of the spinning rust disc or make the network call over to the far end so you",
    "start": "1634000",
    "end": "1640000"
  },
  {
    "text": "can use it for local acceleration but sometimes you're wrong so the way that it works is we we take our inputs which",
    "start": "1640000",
    "end": "1645640"
  },
  {
    "text": "are either x y and Zed in this instance and we hash with different hash algorithms or with some pertubation of",
    "start": "1645640",
    "end": "1652000"
  },
  {
    "text": "hash algorithms and we set a one bit in all of the locations in an array of of of values where those hashes land and",
    "start": "1652000",
    "end": "1660039"
  },
  {
    "text": "then to ask the question is W in this set we do the same thing and we ask are there ones in all of the locations so",
    "start": "1660039",
    "end": "1667200"
  },
  {
    "text": "obviously there's going to be times where these things Collide and that's where we get the maybe it is and when it",
    "start": "1667200",
    "end": "1672399"
  },
  {
    "text": "isn't but if it's not in there then at least one of those bits won't be set",
    "start": "1672399",
    "end": "1677679"
  },
  {
    "text": "that means it's definitely not in there we never set any of its bits so really the code looks something like this um we",
    "start": "1677679",
    "end": "1683640"
  },
  {
    "text": "have um this sort of is it present I'm just using ID here we do some kind of um looping over how many times we're going",
    "start": "1683640",
    "end": "1689720"
  },
  {
    "text": "to Hash our value and get different hash results and um we check the bit and we",
    "start": "1689720",
    "end": "1696080"
  },
  {
    "text": "count and if the count is equal to the number of hashes that we chose so I'm picking four there were three on the example that we just saw in the the",
    "start": "1696080",
    "end": "1701840"
  },
  {
    "text": "picture um if it's four it might be in there and if it's less than four we definitely know it's not in there and",
    "start": "1701840",
    "end": "1707600"
  },
  {
    "text": "this scram function I've just used like murma 3 um to do like a hash a very",
    "start": "1707600",
    "end": "1712720"
  },
  {
    "text": "crappy hash frankly and then given the hash value we need to be able to sort of say well Which slot in my table do I",
    "start": "1712720",
    "end": "1719159"
  },
  {
    "text": "need to check and I'm going to just use a modulus so I'm just going to use the size of the table and I'm going to modulus with it and as you know all good",
    "start": "1719159",
    "end": "1726000"
  },
  {
    "text": "folks who use hash tables know we should pick a prime number size for that table so that we get the least number of aliasing and the horrible problems with",
    "start": "1726000",
    "end": "1733159"
  },
  {
    "text": "co- primes um and I'm going to show very quick something that we can do here so",
    "start": "1733159",
    "end": "1739120"
  },
  {
    "start": "1736000",
    "end": "2093000"
  },
  {
    "text": "I'm going to go back over to compiler Explorer which is going to be very difficult to see in this scale um so",
    "start": "1739120",
    "end": "1745600"
  },
  {
    "text": "again there's a chunk of code in here um this stuff on the left hand side is the murma hash thing so it's a bunch of",
    "start": "1745600",
    "end": "1750720"
  },
  {
    "text": "multiplies and shifts and we're looking at this L2 Loop here which is the loop",
    "start": "1750720",
    "end": "1756200"
  },
  {
    "text": "over the four times that I'm looking inside the table and um what I can do is I can select an area of code and then I",
    "start": "1756200",
    "end": "1763039"
  },
  {
    "text": "can paste it into an analysis mode inside compil Explorer but because that involves a whole bunch of fiddly things",
    "start": "1763039",
    "end": "1768200"
  },
  {
    "text": "I have a canned link that was going to take me there so you'll have to trust me that this can be done reasonably easily",
    "start": "1768200",
    "end": "1773519"
  },
  {
    "text": "so what this is doing is using something called llvm MCA which is a lot harder to say than you think when you're on stage",
    "start": "1773519",
    "end": "1779840"
  },
  {
    "text": "um which is the machine code analyzer it is part of llvm which is part of the clang project that is the compiler and",
    "start": "1779840",
    "end": "1786159"
  },
  {
    "text": "it uses the same knowledge that the compiler uses about how long instructions take and which things depend on what to do the scheduling",
    "start": "1786159",
    "end": "1792720"
  },
  {
    "text": "inside the compiler it allows us to turn that on its head and say given an arbitrary bit of code what does the what",
    "start": "1792720",
    "end": "1798720"
  },
  {
    "text": "would the CPU do and so what this is predicted is that this would take four iterations of the code on the right left",
    "start": "1798720",
    "end": "1805240"
  },
  {
    "text": "hand side would take 148 cycles and the cool thing about this is if I can",
    "start": "1805240",
    "end": "1811679"
  },
  {
    "text": "maximize it sorry this is a tiny little thing here um there is a little view down the bottom here where um this is a",
    "start": "1811679",
    "end": "1820039"
  },
  {
    "text": "sort of timeline view far off on the right hand side are the instructions so going from the top to bottom is the",
    "start": "1820039",
    "end": "1825519"
  },
  {
    "text": "program running each of those instructions and on the left hand side is kind of a visualization of the",
    "start": "1825519",
    "end": "1830720"
  },
  {
    "text": "pipeline that we've been talking about it doesn't have all the Fetch and decode part it just has a single D for decode",
    "start": "1830720",
    "end": "1836640"
  },
  {
    "text": "but each column is a unit of time moving from left to right so what it says is in the simulation in this in the first",
    "start": "1836640",
    "end": "1843080"
  },
  {
    "text": "clock cycle zero here all of these instructions were decoded at once so it",
    "start": "1843080",
    "end": "1848440"
  },
  {
    "text": "can decode multiple instructions at once which is super cool I don't think you can actually decode this many but we're going to go with the tool on the second",
    "start": "1848440",
    "end": "1854519"
  },
  {
    "text": "cycle that is the one column here two of the instructions started executing that's what that lowercase e is and",
    "start": "1854519",
    "end": "1862039"
  },
  {
    "text": "these ones with the equals were blocked they couldn't take they couldn't start executing because they depended on some of the values from the the earlier",
    "start": "1862039",
    "end": "1868279"
  },
  {
    "text": "instructions but also meanwhile we've decoded the next set of instructions and so on and so forth now I'm not going to",
    "start": "1868279",
    "end": "1873760"
  },
  {
    "text": "go over it in huge details but the equals usually is a bad sign that shows that there's a dependency it's not able to run those instructions that it",
    "start": "1873760",
    "end": "1879919"
  },
  {
    "text": "otherwise would and probably you've noticed that there's something horrible coming down the pipeline here quite",
    "start": "1879919",
    "end": "1884960"
  },
  {
    "text": "literally this instruction here with all the e which is the correct sound to make when",
    "start": "1884960",
    "end": "1890720"
  },
  {
    "text": "you see this this is the Divide you're like I didn't see a divide in that code",
    "start": "1890720",
    "end": "1896559"
  },
  {
    "text": "but the modulus operation that we were doing the only way to do a modulus is to do a division and get the remainder which is what the div instruction does",
    "start": "1896559",
    "end": "1902639"
  },
  {
    "text": "and and in in anything but the very latest version of Intel processes at least these these 64-bit divides can",
    "start": "1902639",
    "end": "1909760"
  },
  {
    "text": "take anywhere between 80 and 100 Cycles I don't think this is actually right so",
    "start": "1909760",
    "end": "1915440"
  },
  {
    "text": "that's pretty bad um but while we're here looking at this sort of view here this is of underline the sort of the the",
    "start": "1915440",
    "end": "1920760"
  },
  {
    "text": "sort of how the pipeline Works despite the the clearly the two instructions immediately after the Divide here with",
    "start": "1920760",
    "end": "1926519"
  },
  {
    "text": "the the all the eques those are dependent on the result of that divide they're blocked hence they're just waiting and waiting waiting waiting for",
    "start": "1926519",
    "end": "1932519"
  },
  {
    "text": "it to complete but the next iteration of the loop which the branch predictor has already sort of sent us around even though we haven't executed the branch",
    "start": "1932519",
    "end": "1938760"
  },
  {
    "text": "yet right um it is predicted and it started running the next part and so all",
    "start": "1938760",
    "end": "1944240"
  },
  {
    "text": "these instructions here are actually from the next iteration of the loop so we're getting this cool out of order aspect that I described earlier and then",
    "start": "1944240",
    "end": "1951519"
  },
  {
    "text": "obviously the big dashes and the r is them retiring at the very end there so they're all having to retire in sequence",
    "start": "1951519",
    "end": "1957159"
  },
  {
    "text": "and so I can kind of follow it down and follow it down and follow it down and what we see is that yes it takes absolutely ages to get an answer out of",
    "start": "1957159",
    "end": "1963960"
  },
  {
    "text": "that excuse me so what could you do about that I mean maybe you're stuck",
    "start": "1963960",
    "end": "1969200"
  },
  {
    "text": "with it right but this is a probabilistic data structure if we can trade off a tiny bit of the performance",
    "start": "1969200",
    "end": "1976519"
  },
  {
    "text": "of the hash table the that's sort of underpinning it with um but by saying",
    "start": "1976519",
    "end": "1981880"
  },
  {
    "text": "let's not use a a um a prime number size anymore let's use a power of two size of",
    "start": "1981880",
    "end": "1987279"
  },
  {
    "text": "that table and we'll encode that by saying I'm going to only allow my table to be constructed with the log two not",
    "start": "1987279",
    "end": "1994159"
  },
  {
    "text": "power two the log two size of the table and then I'm going to construct it with one up that size so you know like let's",
    "start": "1994159",
    "end": "2000480"
  },
  {
    "text": "have 65,000 entries in my table now I know that my bucket operation doesn't have to be a modulus with an unknown",
    "start": "2000480",
    "end": "2007240"
  },
  {
    "text": "number it can be an and with the filter size minus one and if we look at that",
    "start": "2007240",
    "end": "2014240"
  },
  {
    "text": "code never do things that rely on the Wi-Fi um we can see that this thing now",
    "start": "2014919",
    "end": "2020440"
  },
  {
    "text": "takes 33 cycles and that and this is a much healthier if my mouse would work click click click much healthier",
    "start": "2020440",
    "end": "2026799"
  },
  {
    "text": "timeline view down here this is what I would expect instructions to look like you know everything is kind of just taking a small amount of time and is",
    "start": "2026799",
    "end": "2032440"
  },
  {
    "text": "retiring pretty soon afterwards it's not waiting for huge amounts of time I mean there are still weights happening in here and we're still getting some benefit doing more hashes there but but",
    "start": "2032440",
    "end": "2039799"
  },
  {
    "text": "it takes substantially less time and this is one of those things where I think we forget that computers are",
    "start": "2039799",
    "end": "2045000"
  },
  {
    "text": "incredibly incredibly fast but divides are still really really slow now that is actually not true in the most recent",
    "start": "2045000",
    "end": "2050200"
  },
  {
    "text": "generation of Intel machines they now got them down to tens of Cycles but those divides are expensive and they're",
    "start": "2050200",
    "end": "2057599"
  },
  {
    "text": "not pipelined which means that you can only do one divide at a time on one CPU and when that completes then the next",
    "start": "2057599",
    "end": "2063720"
  },
  {
    "text": "divide can start unlike multiplies and ads and things like that which may take mult M Cycles but you can start one",
    "start": "2063720",
    "end": "2069240"
  },
  {
    "text": "every single clock cycle so divides bad if you can avoid them Fantastico so",
    "start": "2069240",
    "end": "2074720"
  },
  {
    "text": "that's 30 Cycles versus the 148 that we saw in the first instance there now we've been using a simulator here um",
    "start": "2074720",
    "end": "2081679"
  },
  {
    "text": "this is where I have to say a token exhortation to always Benchmark your code with real world performance rather",
    "start": "2081679",
    "end": "2086919"
  },
  {
    "text": "than relying on simulations but I wanted to show it as it's an interesting way of looking and visualizing about what's going on inside the CPU um Can the",
    "start": "2086919",
    "end": "2093679"
  },
  {
    "start": "2093000",
    "end": "2108000"
  },
  {
    "text": "compiler save us yes he says with the in his voice um if the compiler knows the",
    "start": "2093679",
    "end": "2101160"
  },
  {
    "text": "modulus value ahead of time if it's not just a value that we s call Dot size on something and get a dynamic answer back",
    "start": "2101160",
    "end": "2108040"
  },
  {
    "start": "2108000",
    "end": "2206000"
  },
  {
    "text": "then the compiler can do a trick where it effectively turns that modulus",
    "start": "2108040",
    "end": "2114240"
  },
  {
    "text": "which is a division into a bunch of multiplies and shifts and you're like how can you turn how can we make a",
    "start": "2114240",
    "end": "2120079"
  },
  {
    "text": "multip how can we make a divide out of multiplies I mean for integers",
    "start": "2120079",
    "end": "2125200"
  },
  {
    "text": "especially well I mean the way that would do this is you take the reciprocal and multiply by the reciprocal right",
    "start": "2125200",
    "end": "2130960"
  },
  {
    "text": "that's a way of turning a divide into a multiply and this is exactly what the compiler is doing here the compiler has",
    "start": "2130960",
    "end": "2137079"
  },
  {
    "text": "got this horrible constant up here is essentially one over 1021 in some kind of fixed Point",
    "start": "2137079",
    "end": "2144280"
  },
  {
    "text": "representation and then it does a whole bunch of multiplies and then it shifts the result back down to get the the answer of the division and then it has",
    "start": "2144280",
    "end": "2151040"
  },
  {
    "text": "to do some other nonsense of and the compiler can prove to itself there's an algorithm inside the compiler for",
    "start": "2151040",
    "end": "2156160"
  },
  {
    "text": "determining the minimum number of in instructions to generate the modulus for any value and one of the cool things about compiler Explorer is that we can",
    "start": "2156160",
    "end": "2162240"
  },
  {
    "text": "actually edit this and we can sort like say well if it was 15 how would that look and compiler can generate even better code um you know if it's divide",
    "start": "2162240",
    "end": "2169200"
  },
  {
    "text": "by three there or whatever again we sort of see that it it has all these tricks up its sleeve it knows how to do this",
    "start": "2169200",
    "end": "2174480"
  },
  {
    "text": "for it but it does rely on it knowing ahead of time at compile time what your modulus is seeing if that's a word with",
    "start": "2174480",
    "end": "2181960"
  },
  {
    "text": "um so there are some hash implementations that use some tricks to to have a jump table to jump to one of the N modular that they have that they",
    "start": "2181960",
    "end": "2189040"
  },
  {
    "text": "support um there's also a library called lib divide which lets you like jit compile divides if you have like a",
    "start": "2189040",
    "end": "2194680"
  },
  {
    "text": "configuration file that you load a startup and then you can jit yourself a divide by the value in the configuration",
    "start": "2194680",
    "end": "2200200"
  },
  {
    "text": "file um and then you get the benefit of the compiled version but you can still have some dynamism okay in the very few moments U",
    "start": "2200200",
    "end": "2209720"
  },
  {
    "start": "2206000",
    "end": "2272000"
  },
  {
    "text": "that I'm starting to run short on um I I can't really talk about performance without talking about memory um as",
    "start": "2209720",
    "end": "2215839"
  },
  {
    "text": "you're all aware memory is like one of the slowest things that you can have in a computer give will take the Divide",
    "start": "2215839",
    "end": "2221359"
  },
  {
    "text": "I've just talked about um it takes anywhere between 80 and 100 odd um nanc",
    "start": "2221359",
    "end": "2226400"
  },
  {
    "text": "to access the main memory in your computer the many gigabytes of memory and there are these layers of caches",
    "start": "2226400",
    "end": "2231599"
  },
  {
    "text": "that try and hide that away from us we've got one nanc time for L1 but it's",
    "start": "2231599",
    "end": "2236839"
  },
  {
    "text": "32k my first computer had 32k in it now it's just a cache it's kind of sad 256k",
    "start": "2236839",
    "end": "2242520"
  },
  {
    "text": "for L2 these are representative you know the order of magnitude feel because every computer has a slightly different",
    "start": "2242520",
    "end": "2247880"
  },
  {
    "text": "setup of these things here um so the way that I'm going to expose this is with the torture test for memory which is to have a follow the link list piece of",
    "start": "2247880",
    "end": "2254920"
  },
  {
    "text": "code so we have a link list we have a pointer to the next one we have some data and I'm going to sum up all the",
    "start": "2254920",
    "end": "2260400"
  },
  {
    "text": "data by following the link List's next pointers and I'm apologizing I'm going to go quick here because of time",
    "start": "2260400",
    "end": "2266359"
  },
  {
    "text": "constraints um so yeah it's pretty much straightforward follow the link list um",
    "start": "2266359",
    "end": "2271599"
  },
  {
    "text": "I have 10 million ele Elements which is 150 megabytes worth of data if I just treat it like an array",
    "start": "2271599",
    "end": "2278640"
  },
  {
    "start": "2272000",
    "end": "2411000"
  },
  {
    "text": "that is I allocate them all one after another and I ignore the next pointer and I just add the data of them one",
    "start": "2278640",
    "end": "2284119"
  },
  {
    "text": "after another which is disingenuous but this gives us our lowest sort of what we the fastest it could go then it takes 11",
    "start": "2284119",
    "end": "2290160"
  },
  {
    "text": "milliseconds to to churn through 10 million elements for link list it takes 24 milliseconds which is not all that",
    "start": "2290160",
    "end": "2296440"
  },
  {
    "text": "bad um it's only 2.1 two times slower now everyone loves to hate on link lists",
    "start": "2296440",
    "end": "2302560"
  },
  {
    "text": "um so surely they're fine right I cheated um in that particular example",
    "start": "2302560",
    "end": "2308800"
  },
  {
    "text": "what I did is I pointed the link list entry at the next element in the array so it was really just following an array",
    "start": "2308800",
    "end": "2314800"
  },
  {
    "text": "just in a more complicated way now what that's showing is that data dependences",
    "start": "2314800",
    "end": "2319839"
  },
  {
    "text": "from one iteration to the loop is what's causing this slowdown this is not memory access times because it's the same",
    "start": "2319839",
    "end": "2326400"
  },
  {
    "text": "amount of memory in the same order that we're reading one after another as it is in the array element it's just that the",
    "start": "2326400",
    "end": "2332280"
  },
  {
    "text": "prediction system can't follow along and start executing the next element of the of theop Loop uh ahead of time because",
    "start": "2332280",
    "end": "2339400"
  },
  {
    "text": "in an array case it's just you've just added 10 to it to get to the next one sorry 16 to it to get to the next one in",
    "start": "2339400",
    "end": "2344680"
  },
  {
    "text": "uh the link list case you have to wait for the pointer to be read in from memory to follow it it doesn't know that it's going to land in the next bucket",
    "start": "2344680",
    "end": "2351119"
  },
  {
    "text": "right but something does do actually interestingly the L1 the L2 and the L3",
    "start": "2351119",
    "end": "2356520"
  },
  {
    "text": "caches all have predictors built into them and what they look for is patterns of misses and if they see the same",
    "start": "2356520",
    "end": "2362680"
  },
  {
    "text": "instruction causing a Miss in the cache over and over again they predict how far",
    "start": "2362680",
    "end": "2368319"
  },
  {
    "text": "that instruction is striding if it was a strided memory access and then they start prefetching ahead of time from L",
    "start": "2368319",
    "end": "2374560"
  },
  {
    "text": "you know L1 prefetch from L2 which will prefetch from L3 which will start prefetching from memory so this is",
    "start": "2374560",
    "end": "2379680"
  },
  {
    "text": "actually why this is so fast if if we weren't doing if it wasn't prefetching ahead of time then every 64 bytes we'd",
    "start": "2379680",
    "end": "2387280"
  },
  {
    "text": "slam into a miss and we'd have to wait for the whole time for the the the memory to be pulled in from L from from",
    "start": "2387280",
    "end": "2392680"
  },
  {
    "text": "you know real Ram so it's pretty clever um so what this is what Real Results",
    "start": "2392680",
    "end": "2398480"
  },
  {
    "text": "look like if I actually randomize the pointers and make it jump all over the shop inside memory now we're exposed to",
    "start": "2398480",
    "end": "2404160"
  },
  {
    "text": "the true cost of that memory so now it takes us 1.3 seconds to get through our",
    "start": "2404160",
    "end": "2409599"
  },
  {
    "text": "data um and again I want to prove to you that that isn't just because I did made a programming mistake this is because of",
    "start": "2409599",
    "end": "2416280"
  },
  {
    "start": "2411000",
    "end": "2472000"
  },
  {
    "text": "the memory um system and another thing we can use here is um this approach to Performance analysis it's called top-",
    "start": "2416280",
    "end": "2422160"
  },
  {
    "text": "down analysis where there is a sort of set of excuse me a set of different",
    "start": "2422160",
    "end": "2427359"
  },
  {
    "text": "counters inside the CPU that are grouped together as being either um front end",
    "start": "2427359",
    "end": "2432880"
  },
  {
    "text": "back end or whatever and there's a sort of little chain and it will keep running the program over and over again changing which counters it's looking at to try",
    "start": "2432880",
    "end": "2439119"
  },
  {
    "text": "and drill down into what is the actual cause of the performance issue and so the top level analysis is um are the",
    "start": "2439119",
    "end": "2445839"
  },
  {
    "text": "instructions just retiring which means that you know there's nothing you can do about it the CPU is going through them just have fewer instructions is it",
    "start": "2445839",
    "end": "2452599"
  },
  {
    "text": "because you're speculating badly is um is the branch ICT of the problem are you",
    "start": "2452599",
    "end": "2458800"
  },
  {
    "text": "backend bound I is there something in the execution system or are you front end bound which we haven't really talked",
    "start": "2458800",
    "end": "2464359"
  },
  {
    "text": "about but that whole feeding system of reading bites from memory and decoding them can itself be a bottleneck at some",
    "start": "2464359",
    "end": "2470599"
  },
  {
    "text": "stages um so if we run it on our um excuse me if we run it on sorry excuse",
    "start": "2470599",
    "end": "2477280"
  },
  {
    "start": "2472000",
    "end": "2526000"
  },
  {
    "text": "me again uh on our code we can see that like of those top four categories we're",
    "start": "2477280",
    "end": "2482920"
  },
  {
    "text": "definitely backend bound which is not too surprising that's where the memory accesses are going to happen in the back end when the execution is actually",
    "start": "2482920",
    "end": "2488960"
  },
  {
    "text": "happening and we can see that for the array version we're only 68% Bound for the link list version we're 85% bound",
    "start": "2488960",
    "end": "2494920"
  },
  {
    "text": "and then if we're doing it random then we're essentially just totally all the machine's doing is is waiting in the in that stage and we can drill down and we",
    "start": "2494920",
    "end": "2501880"
  },
  {
    "text": "can give it more command line plags here so I'm still using perf here with these with different flags which you can look at on the slides um we're definitely",
    "start": "2501880",
    "end": "2508440"
  },
  {
    "text": "memory bound there's all the other things we could be bound by uh heavy operations light operations so a divide",
    "start": "2508440",
    "end": "2513599"
  },
  {
    "text": "would be counted as like a heavy operation and all the adds and subtracts and things things would be light operations and there's some fetch things",
    "start": "2513599",
    "end": "2519200"
  },
  {
    "text": "there mispredictions so we're memory bound and if I then say well let's look at what the memory bound is drill down into that we're totally Bound by Dam",
    "start": "2519200",
    "end": "2525760"
  },
  {
    "text": "over here 67% of it is waiting for that last level cature to actually going out to the real memory so it's not that",
    "start": "2525760",
    "end": "2531760"
  },
  {
    "start": "2526000",
    "end": "2591000"
  },
  {
    "text": "we're just like Ping ponging stuff between L2 and L3 we're actually going out to real Mortal Ram um I don't",
    "start": "2531760",
    "end": "2538520"
  },
  {
    "text": "understand why we're not L2 bound incidentally so if anyone has a theory as to why that's happening I'd be interested in hearing about it um anyway",
    "start": "2538520",
    "end": "2546480"
  },
  {
    "text": "in conclusion as I'm pretty much a time um CPUs are complicated um we've went",
    "start": "2546480",
    "end": "2553599"
  },
  {
    "text": "over the pipeline I've talked a little about what out of order means we've talked about why the branch predictor is so important and a little bit about",
    "start": "2553599",
    "end": "2559880"
  },
  {
    "text": "memories and caches luckily we can rely on our compilers most of the time to do the right thing if we give them the right information critically and I've",
    "start": "2559880",
    "end": "2566160"
  },
  {
    "text": "shown you some of the tools that we can use to understand um we didn't cover tons of things this has all been a",
    "start": "2566160",
    "end": "2571960"
  },
  {
    "text": "single core on a single machine we didn't talk about symmetric multi-threading or hyperthreading uh the multiple cause and the cash coherency",
    "start": "2571960",
    "end": "2578280"
  },
  {
    "text": "issues that come from that there is also simd which is where each instruction is doing multiple pieces of work at once",
    "start": "2578280",
    "end": "2583960"
  },
  {
    "text": "for the same cost which is pretty cool and there are some other cool tools called um cash grind and UA that can do",
    "start": "2583960",
    "end": "2589559"
  },
  {
    "text": "even more analysis and drill down on that thank you everybody thank you very much",
    "start": "2589559",
    "end": "2595400"
  }
]