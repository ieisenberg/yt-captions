[
  {
    "start": "0",
    "end": "53000"
  },
  {
    "text": "[Music]",
    "start": "3510",
    "end": "6640"
  },
  {
    "text": "today i'm here to talk again about spring in particular i'm going to talk about cloud native",
    "start": "13519",
    "end": "18720"
  },
  {
    "text": "applications how to build them and how to deploy them using springboot and kubernetes",
    "start": "18720",
    "end": "23920"
  },
  {
    "text": "i work as a senior software engineer at systematic a danish software company in august i'm really passionate about",
    "start": "23920",
    "end": "30640"
  },
  {
    "text": "anything cloud native i'm even writing a book about this subject it's called cloud native spring in action with spring boot and kubernetes working right",
    "start": "30640",
    "end": "37760"
  },
  {
    "text": "now on the last chapter so almost finished it's currently available as early access",
    "start": "37760",
    "end": "42960"
  },
  {
    "text": "yeah i'm also a big supporter of open source technologies i like contributing as much as i can in particular i",
    "start": "42960",
    "end": "49600"
  },
  {
    "text": "contribute to spring security and spring cloud so cloud native",
    "start": "49600",
    "end": "55520"
  },
  {
    "start": "53000",
    "end": "180000"
  },
  {
    "text": "before even talking about technologies why cloud native matters so why as a",
    "start": "55520",
    "end": "60719"
  },
  {
    "text": "business as a company we want to investigate cloud-native technologies and the reason is that",
    "start": "60719",
    "end": "67119"
  },
  {
    "text": "cloud-native technologies empower organizations to achieve certain goals that we really like when",
    "start": "67119",
    "end": "72799"
  },
  {
    "text": "we talk about modern applications first of all cloud native technologies can help us",
    "start": "72799",
    "end": "78159"
  },
  {
    "text": "delivering software faster and in a more flexible way we can build software which is more",
    "start": "78159",
    "end": "83759"
  },
  {
    "text": "resilient meaning that even in the face of failures the services that we are offering our",
    "start": "83759",
    "end": "89840"
  },
  {
    "text": "users are still available so users can really continue using our applications",
    "start": "89840",
    "end": "96720"
  },
  {
    "text": "at most we need to ensure a graceful degradation of functionality so we don't want to disrupt entirely the experience",
    "start": "96720",
    "end": "102799"
  },
  {
    "text": "for our users then we want to be able to scale to reach new users but also to",
    "start": "102799",
    "end": "108880"
  },
  {
    "text": "adapt with new devices just think about iot devices and a new amount of data",
    "start": "108880",
    "end": "114159"
  },
  {
    "text": "flowing through our system cloud-native technologies can help us with that as well and all of this we want to achieve it",
    "start": "114159",
    "end": "120960"
  },
  {
    "text": "while optimizing cost so we want to do it in an efficient way",
    "start": "120960",
    "end": "126079"
  },
  {
    "text": "and pay just for the actual resources that we are using and taking advantage of the elasticity features of cloud",
    "start": "126079",
    "end": "132480"
  },
  {
    "text": "infrastructures today i'd like to go on a journey with",
    "start": "132480",
    "end": "137920"
  },
  {
    "text": "you from development to production we're going to start by building a cloud native application using springboot",
    "start": "137920",
    "end": "144400"
  },
  {
    "text": "which is a great framework focusing on productivity and simplicity after that we're going to containerize the",
    "start": "144400",
    "end": "150400"
  },
  {
    "text": "application we're going to package it as a container image using cloud native buildbacks a project hosted at cloud",
    "start": "150400",
    "end": "156640"
  },
  {
    "text": "native computing foundation and focused on transforming application source code into container images",
    "start": "156640",
    "end": "162800"
  },
  {
    "text": "and finally we're going to deploy the application on kubernetes on an actual kubernetes cluster in a public cloud so",
    "start": "162800",
    "end": "170319"
  },
  {
    "text": "let's get started with this cloud native journey and the first step is cloud native development we want to build a",
    "start": "170319",
    "end": "176319"
  },
  {
    "text": "cloud native application the starting point is start.spring.io from this page we can",
    "start": "176319",
    "end": "184239"
  },
  {
    "start": "180000",
    "end": "903000"
  },
  {
    "text": "initialize a new springboot project raise your hand if you have worked with springboots before",
    "start": "184239",
    "end": "191120"
  },
  {
    "text": "nice so from here you can start the new new springboot project there's also integrations with several ides so you",
    "start": "191120",
    "end": "197280"
  },
  {
    "text": "don't have to necessarily use the web page i could do it also from intellij for example",
    "start": "197280",
    "end": "202400"
  },
  {
    "text": "and from here i will initialize a new gradle project i'm going to use java but you can also",
    "start": "202400",
    "end": "208159"
  },
  {
    "text": "use coloring and groovy when working with spring i'm going to choose springboot 2.6 the",
    "start": "208159",
    "end": "213680"
  },
  {
    "text": "latest release candidate version and the application we're going to build is called demo service also i want to use",
    "start": "213680",
    "end": "220159"
  },
  {
    "text": "the latest and greatest java 17. the application will be a very simple",
    "start": "220159",
    "end": "226560"
  },
  {
    "text": "from a business logic point of view it will expose an http endpoint that returns a message that we want to",
    "start": "226560",
    "end": "233599"
  },
  {
    "text": "be able to configure depending on the environment where we deploy the application we have two main options when we build",
    "start": "233599",
    "end": "240239"
  },
  {
    "text": "web applications we have the servlet stack and the reactive stack the serverless stack is based on the java",
    "start": "240239",
    "end": "245439"
  },
  {
    "text": "servlet api the default embedded server is tomcat so i could add the spring web dependency",
    "start": "245439",
    "end": "251840"
  },
  {
    "text": "in order to achieve that the other alternative is spring reactive web it's",
    "start": "251840",
    "end": "257120"
  },
  {
    "text": "built on a reactive stack when you have applications which are i o bounded there's a lot of intensive",
    "start": "257120",
    "end": "263199"
  },
  {
    "text": "operations involving databases and other services reactive can really help us achieve applications which are more",
    "start": "263199",
    "end": "269360"
  },
  {
    "text": "scalable more resilient and more efficient and all three are goals of uh",
    "start": "269360",
    "end": "275680"
  },
  {
    "text": "moving to cloud native so it's it's a perfect uh use case so i'm gonna use spring reactive web",
    "start": "275680",
    "end": "282720"
  },
  {
    "text": "next since i want to go to production i need to consider how i'm going to",
    "start": "282720",
    "end": "288720"
  },
  {
    "text": "maintain and observe the application in production so",
    "start": "288720",
    "end": "293759"
  },
  {
    "text": "for that reason i'm going to add also springboot actuator to the project which exposes a lot of useful endpoints in",
    "start": "293759",
    "end": "300000"
  },
  {
    "text": "order to monitor and manage the application so for example endpoints returning the application health",
    "start": "300000",
    "end": "305759"
  },
  {
    "text": "information or metrics regarding metrics i'll also add a",
    "start": "305759",
    "end": "311600"
  },
  {
    "text": "prometheus so that from springboot actuator i'll get out of the box an endpoint returning prometheus metrics",
    "start": "311600",
    "end": "318320"
  },
  {
    "text": "which is also something that i really like in a production-ready application",
    "start": "318320",
    "end": "323360"
  },
  {
    "text": "at this point we are done i can generate the project and open it in my ide and i have already",
    "start": "323360",
    "end": "329840"
  },
  {
    "text": "done that so let's move there so this is an empty springboot project",
    "start": "329840",
    "end": "335120"
  },
  {
    "text": "we just have a main method initializing the application and now we can start",
    "start": "335120",
    "end": "340320"
  },
  {
    "text": "implementing the business logic so we said we want to expose an http",
    "start": "340320",
    "end": "346160"
  },
  {
    "text": "endpoint so i'm going to define a res controller class let's call it demo democontroller",
    "start": "346160",
    "end": "353758"
  },
  {
    "text": "and then we want to handle get request to the root endpoint so whenever we send",
    "start": "353919",
    "end": "360000"
  },
  {
    "text": "the get request to the root endpoint i want to return a message a message of type string",
    "start": "360000",
    "end": "365440"
  },
  {
    "text": "but i'm working with reactive spring so i can't return just a string i need to",
    "start": "365440",
    "end": "370720"
  },
  {
    "text": "use a reactive type there are two reactive types the one we're gonna use here is a mono",
    "start": "370720",
    "end": "376400"
  },
  {
    "text": "so i can say mono string and you can think of it as an optional it means either zero or one value",
    "start": "376400",
    "end": "383280"
  },
  {
    "text": "the other type is flux you can think of it as a collection but it's actually an asynchronous type so",
    "start": "383280",
    "end": "389440"
  },
  {
    "text": "it's a publisher it means that eventually we're gonna get several values but in this case we are",
    "start": "389440",
    "end": "395759"
  },
  {
    "text": "going to return only one value so i'm going to use the mono the monotype so mono of string and then get message",
    "start": "395759",
    "end": "403600"
  },
  {
    "text": "and if i want to return a mono from a fixed string i can say",
    "start": "403600",
    "end": "410319"
  },
  {
    "text": "mono dot just and then the string for example springboot on the cloud",
    "start": "410319",
    "end": "417039"
  },
  {
    "text": "and this is fine i can deploy the application i can call the endpoint and i get the message back",
    "start": "417039",
    "end": "422560"
  },
  {
    "text": "but i'm not really happy with it because i want to be able to change the message depending on where i'm deploying the",
    "start": "422560",
    "end": "428560"
  },
  {
    "text": "application and then i really want to go back to the code and every time change and recompile the whole thing so",
    "start": "428560",
    "end": "434800"
  },
  {
    "text": "we need externalized configuration which is an important principle of cloud native applications",
    "start": "434800",
    "end": "439919"
  },
  {
    "text": "instead of having a lot of things packaged inside the application we want to",
    "start": "439919",
    "end": "445759"
  },
  {
    "text": "make it possible to configure from the outside everything that might change between deployments and that's how the",
    "start": "445759",
    "end": "452080"
  },
  {
    "text": "12-factor methodology also defines configuration so in springboot we have several ways of handling",
    "start": "452080",
    "end": "458960"
  },
  {
    "text": "externalized configuration a simple way now is going to the property file and i'm using the yaml pro property format",
    "start": "458960",
    "end": "466800"
  },
  {
    "text": "and in here i define a new custom property let's call it demo message",
    "start": "466800",
    "end": "473120"
  },
  {
    "text": "now the value is the same here but since i'm using a property file now it means",
    "start": "474160",
    "end": "479759"
  },
  {
    "text": "that when i deploy the application i can override the value through environment variable through jvm system properties",
    "start": "479759",
    "end": "486000"
  },
  {
    "text": "through config maps in kubernetes and we'll see that later but first i need to actually get the",
    "start": "486000",
    "end": "491680"
  },
  {
    "text": "value from the property right because i'm still using the hard coded value",
    "start": "491680",
    "end": "497199"
  },
  {
    "text": "so let's keep the property file down here and one way to",
    "start": "497199",
    "end": "503520"
  },
  {
    "text": "parse the property is defining a configuration properties bin",
    "start": "503520",
    "end": "509840"
  },
  {
    "text": "there is an annotation for that and i can use either a java class or a record i'm using java 17 i really like",
    "start": "509840",
    "end": "516479"
  },
  {
    "text": "to use a record here so i'll say record demo properties",
    "start": "516479",
    "end": "522880"
  },
  {
    "text": "and this uh beam will have only one field for now called message",
    "start": "525200",
    "end": "531120"
  },
  {
    "text": "and then i want to tell springboot that this record should give access to all the properties with",
    "start": "531120",
    "end": "537360"
  },
  {
    "text": "the prefix demo not just any properties so by combining the prefix and the",
    "start": "537360",
    "end": "544080"
  },
  {
    "text": "field name we get access to the property the final step is actually telling springboot that it",
    "start": "544080",
    "end": "551120"
  },
  {
    "text": "needs to look in the class path for these configuration properties pins so i'll use a configuration property scan",
    "start": "551120",
    "end": "557600"
  },
  {
    "text": "annotation like that and that's it so now this demo",
    "start": "557600",
    "end": "563920"
  },
  {
    "text": "properties record is actually spring bean so i can inject it anywhere i need that value",
    "start": "563920",
    "end": "570720"
  },
  {
    "text": "so i'll do that in demo controller private final demo properties and i'm",
    "start": "570720",
    "end": "576959"
  },
  {
    "text": "going to use constructor injection and finally i can replace the harcoded",
    "start": "576959",
    "end": "582320"
  },
  {
    "text": "message with demo properties message so we have now externalized the",
    "start": "582320",
    "end": "588720"
  },
  {
    "text": "configuration if i deploy the application i can override the value in different ways so that's",
    "start": "588720",
    "end": "595120"
  },
  {
    "text": "what i wanted it's perfect but still i don't know if it works now the business logic in this example",
    "start": "595120",
    "end": "601120"
  },
  {
    "text": "is super simple but we want to go to production so it's important that we ensure the quality of the of the",
    "start": "601120",
    "end": "607120"
  },
  {
    "text": "application that means we need auto test so let's have a look at that",
    "start": "607120",
    "end": "613120"
  },
  {
    "text": "we have already a test class which is generated when you initialize a project from start.spring.io",
    "start": "613120",
    "end": "619360"
  },
  {
    "text": "and i can i can set up tests in different ways in this specific",
    "start": "619360",
    "end": "625279"
  },
  {
    "text": "scenario i want to define some integration test it means that i want the full application to run and",
    "start": "625279",
    "end": "631440"
  },
  {
    "text": "run test against it so i can use the springboot test annotation in order to initialize the full spring context",
    "start": "631440",
    "end": "637920"
  },
  {
    "text": "and also configuring the web environment so that i get also a web server",
    "start": "637920",
    "end": "644240"
  },
  {
    "text": "exposing its services through a random port because i really don't care about the port",
    "start": "644240",
    "end": "650399"
  },
  {
    "text": "so now i have a setup for full integration test it means that an application will run",
    "start": "650399",
    "end": "655519"
  },
  {
    "text": "and i can start writing some test cases for example i can say that when i send a",
    "start": "655519",
    "end": "661600"
  },
  {
    "text": "get request to the root endpoint then i want to ensure that the message is returned",
    "start": "661600",
    "end": "668000"
  },
  {
    "text": "and the way i call the application is via a web test client object",
    "start": "668000",
    "end": "675760"
  },
  {
    "text": "this is an object that is part of the reactive spring stack but you can actually use it also if you're",
    "start": "675760",
    "end": "682079"
  },
  {
    "text": "working with a traditional servlet application it's a really convenient utility maybe",
    "start": "682079",
    "end": "687440"
  },
  {
    "text": "you are familiar with the test rest template this one is a better replacement because rest",
    "start": "687440",
    "end": "693760"
  },
  {
    "text": "template is now deprecated so it will not it will not contain any new changes in future",
    "start": "693760",
    "end": "700480"
  },
  {
    "text": "versions of spring so now it's a good idea to move to web test client and web client also in a servlet-based",
    "start": "700480",
    "end": "707040"
  },
  {
    "text": "application it doesn't have to be reactive i'm using it in a reactive application now but",
    "start": "707040",
    "end": "712880"
  },
  {
    "text": "that's just one of the options that you have so now i use web test client to send a",
    "start": "712880",
    "end": "720320"
  },
  {
    "text": "get request to the root endpoint",
    "start": "720320",
    "end": "725839"
  },
  {
    "text": "and then i send the request with exchange and finally i want to assert that the status of the response is 200",
    "start": "725839",
    "end": "732720"
  },
  {
    "text": "okay and that the body is a string",
    "start": "732720",
    "end": "738320"
  },
  {
    "text": "and this equal to the value that we defined in the property file",
    "start": "738320",
    "end": "744199"
  },
  {
    "text": "like that so i can run the test now this will spin up a full application",
    "start": "745680",
    "end": "753680"
  },
  {
    "text": "so if we go through one more time we send a get request root endpoint",
    "start": "753680",
    "end": "759440"
  },
  {
    "text": "with exchange we send a request exchange is how we call request in a reactive",
    "start": "759440",
    "end": "764560"
  },
  {
    "text": "context they're called exchanges we expect the status to be okay and we expect the body to be a string",
    "start": "764560",
    "end": "771200"
  },
  {
    "text": "equal to the property we defined in application yaml so this spring boots",
    "start": "771200",
    "end": "776399"
  },
  {
    "text": "on the cloud and the test is green so we are uh getting closer to be ready",
    "start": "776399",
    "end": "783600"
  },
  {
    "text": "to deploy the application but we need to consider how to package it cloud native applications are supposed",
    "start": "783600",
    "end": "790160"
  },
  {
    "text": "to be self-contained and standalone so we don't want any external dependencies",
    "start": "790160",
    "end": "795680"
  },
  {
    "text": "traditional applications would be packaged for example as war file or ear files and then deploy to a web server",
    "start": "795680",
    "end": "802959"
  },
  {
    "text": "like tomcat or an application server like wildfly we don't want to do that with cloud native",
    "start": "802959",
    "end": "808480"
  },
  {
    "text": "we want to have one single executable that contains all the dependencies that are needed by the application to run",
    "start": "808480",
    "end": "815040"
  },
  {
    "text": "but we allow only one external dependency which is the runtime environment in this case the java",
    "start": "815040",
    "end": "820320"
  },
  {
    "text": "runtime environment besides that everything else should be packaged together",
    "start": "820320",
    "end": "826000"
  },
  {
    "text": "in java we do that via jar packaging so we can package our application as a jar",
    "start": "826000",
    "end": "831279"
  },
  {
    "text": "file also called the fat jar or uber jar because it contains everything within also an embedded web server",
    "start": "831279",
    "end": "839279"
  },
  {
    "text": "now using either gradle or maven i can run a task and package the application",
    "start": "839279",
    "end": "846079"
  },
  {
    "text": "as a jar in gradle i would do that with boot jar and once i get the the jar file i can",
    "start": "846079",
    "end": "851600"
  },
  {
    "text": "run it as a standard java application so java jar and then pointing to",
    "start": "851600",
    "end": "857600"
  },
  {
    "text": "the jar that i just generated and this will run the application we can also see if it works fine",
    "start": "857600",
    "end": "865199"
  },
  {
    "text": "so we have so um http",
    "start": "865199",
    "end": "871600"
  },
  {
    "text": "yes so i'm using i'm not using curl i'm using httpi which is a very convenient utilities like uh curl but for humans",
    "start": "871600",
    "end": "878560"
  },
  {
    "text": "it's really great so i can send http column 8080 means that i'm sending a request to localhost ada which is the",
    "start": "878560",
    "end": "885120"
  },
  {
    "text": "port used by springboot by default and then the root endpoint and they get the message back springboot",
    "start": "885120",
    "end": "891680"
  },
  {
    "text": "on the cloud so let's recap what we have done so far",
    "start": "891680",
    "end": "898920"
  },
  {
    "start": "903000",
    "end": "968000"
  },
  {
    "text": "so we talked about self-contained application so we want applications we are we have no external dependencies",
    "start": "903279",
    "end": "910320"
  },
  {
    "text": "besides the runtime environment we use the jarv packaging we also call them uber jar or fat jar that's the default",
    "start": "910320",
    "end": "917600"
  },
  {
    "text": "behavior in springboot so we don't need any extra configuration and then we briefly talked about",
    "start": "917600",
    "end": "924240"
  },
  {
    "text": "externalized configuration and in particular property files which are packaged within the application are",
    "start": "924240",
    "end": "929360"
  },
  {
    "text": "really convenient in order to define some default values or even as a sort of documentation of what are",
    "start": "929360",
    "end": "935680"
  },
  {
    "text": "the capabilities of the application so which configuration properties we might define",
    "start": "935680",
    "end": "940720"
  },
  {
    "text": "also we saw that it's very easy to package the application as a jar we can do that either with gradle or with maven",
    "start": "940720",
    "end": "947519"
  },
  {
    "text": "we have a simple task for both cases and we might be done so depending on the",
    "start": "947519",
    "end": "953360"
  },
  {
    "text": "deployment platform uh we can for example take this jar file now and deploy it on heroku or cloud foundry and",
    "start": "953360",
    "end": "961040"
  },
  {
    "text": "that would be it but in our case we want to move to kubernetes so we need to containerize the application we need to",
    "start": "961040",
    "end": "968079"
  },
  {
    "start": "968000",
    "end": "1190000"
  },
  {
    "text": "package it as a container image and writing specifically docker files in order to",
    "start": "968079",
    "end": "974480"
  },
  {
    "text": "build container images is quite easy but doing that for production is really not because there are so many things we",
    "start": "974480",
    "end": "981040"
  },
  {
    "text": "should consider first of all we shouldn't use fat jars that's a common mistake so now that we",
    "start": "981040",
    "end": "987600"
  },
  {
    "text": "have a jar we might think now let's move it inside the image and it's done we don't want to do that it's not efficient",
    "start": "987600",
    "end": "993759"
  },
  {
    "text": "because every time we change maybe one line in our code the whole jar file needs to be",
    "start": "993759",
    "end": "999680"
  },
  {
    "text": "replaced in the image and that's not efficient that brings us to performance both at build time and runtime we really",
    "start": "999680",
    "end": "1006480"
  },
  {
    "text": "want to focus on performance we don't want to wait too much to build the container image or even at runtime when",
    "start": "1006480",
    "end": "1012240"
  },
  {
    "text": "we have to for example pull the image from the register every time we have a new update",
    "start": "1012240",
    "end": "1017519"
  },
  {
    "text": "so it's better if we make if we leverage the layering part of the images",
    "start": "1017519",
    "end": "1023199"
  },
  {
    "text": "so if we open up the jar file and put all the libraries inside spring and our",
    "start": "1023199",
    "end": "1028959"
  },
  {
    "text": "own code in different layers then we get a better and more efficient image",
    "start": "1028959",
    "end": "1034880"
  },
  {
    "text": "and finally we need to consider security so for example we don't want to run a container as root and that's actually",
    "start": "1034880",
    "end": "1040640"
  },
  {
    "text": "the default in docker file if you don't do anything about it and we don't want to include secrets even if",
    "start": "1040640",
    "end": "1047280"
  },
  {
    "text": "one of the upper layer you remove a secret uh the layer below will still contain",
    "start": "1047280",
    "end": "1053679"
  },
  {
    "text": "the secret so no passwords no private keys it's really",
    "start": "1053679",
    "end": "1058880"
  },
  {
    "text": "important that we take care of that still about security we need to consider",
    "start": "1058880",
    "end": "1064400"
  },
  {
    "text": "whenever a new vulnerabilities is patched establishing a process in order to patch",
    "start": "1064400",
    "end": "1069919"
  },
  {
    "text": "all our images so how can we deal with this containerization process and especially",
    "start": "1069919",
    "end": "1076640"
  },
  {
    "text": "as a developer i don't want to spend too much time on it i want to focus on the business logic",
    "start": "1076640",
    "end": "1082160"
  },
  {
    "text": "so sure i can use a dogger file and that's super flexible because i can do i can control every little aspect of the",
    "start": "1082160",
    "end": "1089600"
  },
  {
    "text": "image but there are tools that can help us containerize the application without writing a docker file for java",
    "start": "1089600",
    "end": "1096160"
  },
  {
    "text": "applications we have jeep for example a tool developed by google is available as a gradle and maven plugin and you can",
    "start": "1096160",
    "end": "1103200"
  },
  {
    "text": "containerize your job application without a docker file but today i'm going to talk about clown native buildbox which is a specification",
    "start": "1103200",
    "end": "1111120"
  },
  {
    "text": "hosted at the cloud native computing foundation to transform application source code into container images and",
    "start": "1111120",
    "end": "1118080"
  },
  {
    "text": "this specification comes from years of experience by heroku and pivotal in order to package jar",
    "start": "1118080",
    "end": "1125440"
  },
  {
    "text": "in particular java applications into container images this is now specification and works for any type of",
    "start": "1125440",
    "end": "1131120"
  },
  {
    "text": "application so you can actually use it for any kind of language and framework",
    "start": "1131120",
    "end": "1136720"
  },
  {
    "text": "but we need an implementation first this is just a specification one implementation is paquetto",
    "start": "1136720",
    "end": "1144080"
  },
  {
    "text": "pacquiao provides buildbacks for different languages and frameworks so you can use this same implementation for",
    "start": "1144080",
    "end": "1150880"
  },
  {
    "text": "your java application for your graph vm native images also you can use it for python for node.js for ruby",
    "start": "1150880",
    "end": "1159520"
  },
  {
    "text": "when we use springboots the great thing is that we don't even have to think about it we don't have to install",
    "start": "1159520",
    "end": "1165200"
  },
  {
    "text": "anything else because it's already included in the springboot plugin for groudonline for maven so if you remember",
    "start": "1165200",
    "end": "1171760"
  },
  {
    "text": "we packaged the update application as a jar file in a very easy way from gradle",
    "start": "1171760",
    "end": "1177440"
  },
  {
    "text": "for container images we can do the same it's just a different task it's really",
    "start": "1177440",
    "end": "1182480"
  },
  {
    "text": "simple under the hood cloud native build packs is used in particular the pacquiao implementation so let's have a look at",
    "start": "1182480",
    "end": "1188480"
  },
  {
    "text": "how it works",
    "start": "1188480",
    "end": "1191799"
  },
  {
    "start": "1190000",
    "end": "1384000"
  },
  {
    "text": "so i'll stop the application first and then i can run boot build image",
    "start": "1194880",
    "end": "1203520"
  },
  {
    "text": "i'm relying on the default configuration now but of course following the springboard philosophy is",
    "start": "1203520",
    "end": "1209360"
  },
  {
    "text": "completely customizable let's see oh maybe we are not connected to internet",
    "start": "1209360",
    "end": "1218760"
  },
  {
    "text": "yes let me switch the network",
    "start": "1221840",
    "end": "1225520"
  },
  {
    "text": "yeah this is the fun part of doing live coding i love it yes",
    "start": "1232080",
    "end": "1238880"
  },
  {
    "text": "take two okay now it's going through so it's building the image i was saying that we",
    "start": "1239360",
    "end": "1245200"
  },
  {
    "text": "can customize it in different ways and we can even use the same task to publish the image",
    "start": "1245200",
    "end": "1250720"
  },
  {
    "text": "so what i have done in order to automate a lot of things in the spirit of a cloud native or it",
    "start": "1250720",
    "end": "1257679"
  },
  {
    "text": "didn't work again okay take three and in the meantime i'll show",
    "start": "1257679",
    "end": "1264640"
  },
  {
    "text": "you on github i have all these source code examples and in particular i'm using github actions in order to define",
    "start": "1264640",
    "end": "1271679"
  },
  {
    "text": "a continuous delivery pipeline so every time i push some code",
    "start": "1271679",
    "end": "1277840"
  },
  {
    "text": "maybe yes",
    "start": "1278480",
    "end": "1284799"
  },
  {
    "text": "i have a delivery pipeline let's hope internet will work fine",
    "start": "1284799",
    "end": "1291840"
  },
  {
    "text": "every time i push something new to github that task is executed in order to",
    "start": "1299679",
    "end": "1305520"
  },
  {
    "text": "containerize my application and publish it directly to my docker hub registry",
    "start": "1305520",
    "end": "1312000"
  },
  {
    "text": "so this is really unfortunate",
    "start": "1314960",
    "end": "1321360"
  },
  {
    "text": "yes i'm using my hotspot but i'll move on to",
    "start": "1327520",
    "end": "1332919"
  },
  {
    "text": "let's see okay",
    "start": "1336799",
    "end": "1344080"
  },
  {
    "text": "or maybe not yes so i'm using git of actions",
    "start": "1344720",
    "end": "1352880"
  },
  {
    "text": "super slow yeah that will not work out",
    "start": "1354480",
    "end": "1360840"
  },
  {
    "text": "well i'll show you that later but let's move on so i know that i push my changes to github so we get this image published",
    "start": "1372159",
    "end": "1379200"
  },
  {
    "text": "to my docker registry after that we are ready to move to kubernetes",
    "start": "1379200",
    "end": "1384960"
  },
  {
    "start": "1384000",
    "end": "1439000"
  },
  {
    "text": "so we have the container image i have established already a kubernetes cluster on a public cloud on azure and",
    "start": "1384960",
    "end": "1391600"
  },
  {
    "text": "in particular i used an open source kubernetes platform it's called vmware tanzu community",
    "start": "1391600",
    "end": "1397280"
  },
  {
    "text": "edition it's open source is free i used it to deploy this cluster on azure it contains",
    "start": "1397280",
    "end": "1403440"
  },
  {
    "text": "a lot of nice features and one of them is that it allows me to use k native k native is",
    "start": "1403440",
    "end": "1409840"
  },
  {
    "text": "a layer built on top of kubernetes that among the other things provides a better developer experience and also extra",
    "start": "1409840",
    "end": "1417280"
  },
  {
    "text": "functionalities for example it introduces support for serverless workloads and event driven so one of the",
    "start": "1417280",
    "end": "1422880"
  },
  {
    "text": "nice features of k native is that you get the scale to zero feature so if your application has no request to handle",
    "start": "1422880",
    "end": "1430799"
  },
  {
    "text": "it scales to zero instances and that's very useful if you're working with serverless applications",
    "start": "1430799",
    "end": "1438399"
  },
  {
    "start": "1439000",
    "end": "1747000"
  },
  {
    "text": "so now i'm gonna yes well we'll try later so now what we want",
    "start": "1442960",
    "end": "1450240"
  },
  {
    "text": "to do is uh doing some yaml coding that's even more fun than java like like coding",
    "start": "1450240",
    "end": "1457520"
  },
  {
    "text": "so i have a yaml file here so let's start by defining uh how or",
    "start": "1457520",
    "end": "1464000"
  },
  {
    "text": "what we want to achieve in kubernetes because we use a declarative way so we define what we want to achieve and then",
    "start": "1464000",
    "end": "1469840"
  },
  {
    "text": "kubernetes figures out how to achieve it so i'll start by",
    "start": "1469840",
    "end": "1475120"
  },
  {
    "text": "adding the api version the deployment resource in kubernetes is",
    "start": "1475120",
    "end": "1481279"
  },
  {
    "text": "the one that controls how we want to deploy the application so it makes sure that the application is up and running",
    "start": "1481279",
    "end": "1487679"
  },
  {
    "text": "if something goes wrong it's self seal and all the nice features that we like from",
    "start": "1487679",
    "end": "1492880"
  },
  {
    "text": "kubernetes let's call it demo service",
    "start": "1492880",
    "end": "1499039"
  },
  {
    "text": "and then we need to specify how the container should be built",
    "start": "1499520",
    "end": "1505440"
  },
  {
    "text": "so we have containers and the name of the container will be demo service and the image is",
    "start": "1507440",
    "end": "1513600"
  },
  {
    "text": "the one that my continuous delivery pipeline published to dockerhub",
    "start": "1513600",
    "end": "1519440"
  },
  {
    "text": "demo service go to 1.0",
    "start": "1519440",
    "end": "1524880"
  },
  {
    "text": "so far i have described a deployment object it's a standard kubernetes resource so i could now apply this",
    "start": "1524960",
    "end": "1532000"
  },
  {
    "text": "resource to the cluster but then i will still need two extra resources in order to use it i would need a service",
    "start": "1532000",
    "end": "1538080"
  },
  {
    "text": "resource to expose the application inside the cluster and then i would need an ingress resource to expose the",
    "start": "1538080",
    "end": "1544240"
  },
  {
    "text": "application outside the cluster and i don't really want to deal with three different resources so since i",
    "start": "1544240",
    "end": "1549919"
  },
  {
    "text": "have k native i want to let k native deal with that so instead of doing this deployment resource manifest",
    "start": "1549919",
    "end": "1557279"
  },
  {
    "text": "right now i will switch to use k native the k native api",
    "start": "1557279",
    "end": "1563200"
  },
  {
    "text": "and i just need to change api version and kind so now this is a k native service resource and the specification",
    "start": "1564960",
    "end": "1572480"
  },
  {
    "text": "here is the same that we would use in a deployment so what i'm gonna show you here you can do it also on a deployment",
    "start": "1572480",
    "end": "1580080"
  },
  {
    "text": "directly but the nice thing is that when i deployed i will also get a service and an ingress controller so i can directly",
    "start": "1580080",
    "end": "1587120"
  },
  {
    "text": "use the application without writing additional manifest but",
    "start": "1587120",
    "end": "1592799"
  },
  {
    "text": "right now this works of course it's good for development but it's not ready for production so now we're going to start",
    "start": "1592799",
    "end": "1599120"
  },
  {
    "text": "hydrating through it and see how can we make it ready for production the first thing to consider is that",
    "start": "1599120",
    "end": "1605840"
  },
  {
    "text": "containers need cpu and memory of course to run we are on a cluster where each container will",
    "start": "1605840",
    "end": "1612240"
  },
  {
    "text": "compete against each other for those resources so we need to be clear about what are the requirements for each container in",
    "start": "1612240",
    "end": "1618240"
  },
  {
    "text": "order to run and what are the limits so we cannot request",
    "start": "1618240",
    "end": "1624799"
  },
  {
    "text": "not the request a resources section and we have two types of resources the",
    "start": "1624799",
    "end": "1630640"
  },
  {
    "text": "requests and the limits the requests are the minimum resources that the container needs in order to",
    "start": "1630640",
    "end": "1636320"
  },
  {
    "text": "be able to run so are the they are the resources that kubernetes guarantees that they will be available to the",
    "start": "1636320",
    "end": "1643120"
  },
  {
    "text": "container and then each container can use up to the resources that are defined as limits",
    "start": "1643120",
    "end": "1650480"
  },
  {
    "text": "so for the memory part i can assign values in both",
    "start": "1650480",
    "end": "1657039"
  },
  {
    "text": "both for request and limits and now for uh java applications based on the jvm",
    "start": "1657039",
    "end": "1664080"
  },
  {
    "text": "we noticed that we get higher better performance if we assign the same",
    "start": "1664080",
    "end": "1669360"
  },
  {
    "text": "value both as request and limits because the jvm doesn't react very well",
    "start": "1669360",
    "end": "1674640"
  },
  {
    "text": "when uh the container around it keeps changing the memory so i'm going to assign the same value",
    "start": "1674640",
    "end": "1680480"
  },
  {
    "text": "in both places and then for the cpu i'll define some",
    "start": "1680480",
    "end": "1686000"
  },
  {
    "text": "requests for maybe half a cpu and then i'll leave the limit unbounded so that",
    "start": "1686000",
    "end": "1691360"
  },
  {
    "text": "if there's available cpu i want the container to use it",
    "start": "1691360",
    "end": "1697440"
  },
  {
    "text": "these two resources are really different so we need to consider them in a different way",
    "start": "1697440",
    "end": "1704399"
  },
  {
    "text": "first the cpu is a compressible resource so when we hit the limit then the process is throttled but the application",
    "start": "1707200",
    "end": "1714320"
  },
  {
    "text": "will still run maybe with a lower performance but there would be no no error the application",
    "start": "1714320",
    "end": "1721039"
  },
  {
    "text": "would still be running correctly instead memory is a non-compressible resource so if we hit the limit we get the dreadful",
    "start": "1721039",
    "end": "1727919"
  },
  {
    "text": "out of memory killed error which is the worst so we really want to avoid that",
    "start": "1727919",
    "end": "1733600"
  },
  {
    "text": "and in kubernetes of course we as i said we can assign both cpu and memory as request",
    "start": "1733600",
    "end": "1740159"
  },
  {
    "text": "and as limits but i would say that we should pay particular attention to the",
    "start": "1740159",
    "end": "1745279"
  },
  {
    "text": "memory here next let's talk a bit more about externalized",
    "start": "1745279",
    "end": "1751440"
  },
  {
    "start": "1747000",
    "end": "1884000"
  },
  {
    "text": "configuration we saw that in springboot we can define some custom properties we have a value",
    "start": "1751440",
    "end": "1758000"
  },
  {
    "text": "now in a property file what we want to do now is",
    "start": "1758000",
    "end": "1763120"
  },
  {
    "text": "overriding some some of that configuration in kubernetes using configmaps",
    "start": "1763120",
    "end": "1768640"
  },
  {
    "text": "when we build cloud native application it's important to distinguish between code credentials and configuration they",
    "start": "1768640",
    "end": "1774799"
  },
  {
    "text": "should be always in parallel tracks so we have already the code for configuration and",
    "start": "1774799",
    "end": "1780399"
  },
  {
    "text": "credentials kubernetes conveniently offer us the config maps resources and secrets resources today i'm going to",
    "start": "1780399",
    "end": "1786960"
  },
  {
    "text": "show you how to use configmaps from a springboot point of view cigarettes work the same way but",
    "start": "1786960",
    "end": "1793440"
  },
  {
    "text": "i won't go deeper in that but just let me say that secrets in kubernetes are not secret",
    "start": "1793440",
    "end": "1800320"
  },
  {
    "text": "they're just plain text even if they are encoded in base 64 they're basically plain text so what makes a secret secret",
    "start": "1800320",
    "end": "1808159"
  },
  {
    "text": "is how we handle it but just the resource itself is not a secret so",
    "start": "1808159",
    "end": "1813360"
  },
  {
    "text": "be careful about that in spring wood we have different configuration options",
    "start": "1813360",
    "end": "1819919"
  },
  {
    "text": "we talked about the basic ones we have property files we can use environment variables and maybe some command line",
    "start": "1819919",
    "end": "1825840"
  },
  {
    "text": "arguments to override properties but we can also use some configuration services so for example if you have",
    "start": "1825840",
    "end": "1831520"
  },
  {
    "text": "already a console or apache zookeeper infrastructure you might want to use some of the projects provided by spring",
    "start": "1831520",
    "end": "1837279"
  },
  {
    "text": "cloud in order to use that infrastructure to also store configuration or you could run a",
    "start": "1837279",
    "end": "1842640"
  },
  {
    "text": "spring cloud config server if you're running on a public cloud platform maybe that",
    "start": "1842640",
    "end": "1848399"
  },
  {
    "text": "platform already provides some services regarding configuration and secrets management so you might think of using",
    "start": "1848399",
    "end": "1854399"
  },
  {
    "text": "those for example on azure i could use the spring cloud azure project in order to integrate seamlessly with azure and",
    "start": "1854399",
    "end": "1861120"
  },
  {
    "text": "get configuration from azure keyboard and then finally kubernetes kubernetes",
    "start": "1861120",
    "end": "1866559"
  },
  {
    "text": "is what we are working with right now so we we can use configmap secrets and also environment variables",
    "start": "1866559",
    "end": "1873919"
  },
  {
    "text": "between environment variables and config maps and secrets we're gonna see some differences a bit",
    "start": "1873919",
    "end": "1879919"
  },
  {
    "text": "later so now let's uh create a config map",
    "start": "1879919",
    "end": "1885120"
  },
  {
    "start": "1884000",
    "end": "2181000"
  },
  {
    "text": "so yay more yaml",
    "start": "1886240",
    "end": "1890200"
  },
  {
    "text": "so we have an api version v1 kind configmap",
    "start": "1892320",
    "end": "1897518"
  },
  {
    "text": "and the name will be demo config and now in a config map we can write key",
    "start": "1898799",
    "end": "1904720"
  },
  {
    "text": "value pairs of course but we can even embed some configuration files so if we",
    "start": "1904720",
    "end": "1909919"
  },
  {
    "text": "work with springboot we are used to work with property files so i can embed a property file directly so i don't have",
    "start": "1909919",
    "end": "1915440"
  },
  {
    "text": "to come up with different syntaxes so we'll say application.yaml",
    "start": "1915440",
    "end": "1921039"
  },
  {
    "text": "and then i can embed a property file in here if you're using something like customize you can even automate the",
    "start": "1921039",
    "end": "1927600"
  },
  {
    "text": "generation of the configmap starting from a property file which is really convenient the first thing i want to do here is",
    "start": "1927600",
    "end": "1933840"
  },
  {
    "text": "overriding the our own custom demo message so now we have springboot on kubernetes",
    "start": "1933840",
    "end": "1941200"
  },
  {
    "text": "like that and we can also add some configuration which don't make sense when we work on a",
    "start": "1941200",
    "end": "1946320"
  },
  {
    "text": "local environment but when we want to go to production they are really necessary one of them is",
    "start": "1946320",
    "end": "1951679"
  },
  {
    "text": "the graceful shutdown feature so when we when a container is shut down",
    "start": "1951679",
    "end": "1957039"
  },
  {
    "text": "whatever the reason in kubernetes we don't want the application to be terminated right away because if there",
    "start": "1957039",
    "end": "1962559"
  },
  {
    "text": "is any request still pending we don't want that to be killed so the user would get some errors",
    "start": "1962559",
    "end": "1968960"
  },
  {
    "text": "we want to ensure a nice and seamless experience for users so with no downtime",
    "start": "1968960",
    "end": "1974240"
  },
  {
    "text": "in order to do that we need to enable graceful shutdown so when a termination signal is sent to springboot springboot",
    "start": "1974240",
    "end": "1981039"
  },
  {
    "text": "will stop accepting any new request but it will wait some time in order for the",
    "start": "1981039",
    "end": "1986640"
  },
  {
    "text": "once in progress to complete so the first thing is enabling the",
    "start": "1986640",
    "end": "1991679"
  },
  {
    "text": "shutdown feature so shutdown graceful",
    "start": "1991679",
    "end": "1997519"
  },
  {
    "text": "and then we can also configure how long springboard should wait for the current request to complete we",
    "start": "1997519",
    "end": "2004240"
  },
  {
    "text": "can configure that with spring lifecycle",
    "start": "2004240",
    "end": "2009679"
  },
  {
    "text": "timeout per shutdown phase",
    "start": "2009679",
    "end": "2015200"
  },
  {
    "text": "maybe 15 seconds and we are missing an indentation there",
    "start": "2016080",
    "end": "2022080"
  },
  {
    "text": "yes we are a bit closer to to be uh ready for",
    "start": "2022080",
    "end": "2027120"
  },
  {
    "text": "production now but not quite there",
    "start": "2027120",
    "end": "2032360"
  },
  {
    "text": "so we talked about the different configuration options but now that we have a config map we need to provide",
    "start": "2032880",
    "end": "2038159"
  },
  {
    "text": "that to the application so how can we tell springboard to use the configmap and we have at least two main ways the",
    "start": "2038159",
    "end": "2044880"
  },
  {
    "text": "first way is using environment variables and getting values for those environment",
    "start": "2044880",
    "end": "2049919"
  },
  {
    "text": "variables from the configmap but that's not really recommended because whenever a config map change kubernetes will not",
    "start": "2049919",
    "end": "2056079"
  },
  {
    "text": "inform the container that something changed but it will do that if we use volumes so",
    "start": "2056079",
    "end": "2062000"
  },
  {
    "text": "we can mount we can define a volume starting from a configmap",
    "start": "2062000",
    "end": "2067200"
  },
  {
    "text": "and then we can mount that volume to the application and we're going to do that right now",
    "start": "2067200",
    "end": "2075838"
  },
  {
    "text": "so we have the config map is named democonfig so in the other manifest i'm going to",
    "start": "2076720",
    "end": "2083040"
  },
  {
    "text": "add a new section about volumes",
    "start": "2083040",
    "end": "2088040"
  },
  {
    "text": "we have a volume let's name it demo",
    "start": "2089679",
    "end": "2095200"
  },
  {
    "text": "yeah demo config volume and the volume is created starting from",
    "start": "2095200",
    "end": "2100480"
  },
  {
    "text": "a config map and the configmap name is demo config then i can mount the volume",
    "start": "2100480",
    "end": "2105839"
  },
  {
    "text": "so i'll add the section here volume mounts",
    "start": "2105839",
    "end": "2110720"
  },
  {
    "text": "and the name of the volume is this one down here",
    "start": "2110960",
    "end": "2117359"
  },
  {
    "text": "demo config volume and then the mount path",
    "start": "2117359",
    "end": "2122000"
  },
  {
    "text": "so now the path i'm writing here is uh there's no magic behind it i know that when i containerize the application with",
    "start": "2122480",
    "end": "2128839"
  },
  {
    "text": "the build packs the application is put in a workspace folder",
    "start": "2128839",
    "end": "2134240"
  },
  {
    "text": "that's the first thing then i know that springboot automatically by default will look around the folder where it's placed",
    "start": "2134240",
    "end": "2141520"
  },
  {
    "text": "for folders named config and if there's any property file in that",
    "start": "2141520",
    "end": "2146880"
  },
  {
    "text": "folder it will read those property files automatically so just by using this path i know that springboot will read the",
    "start": "2146880",
    "end": "2154000"
  },
  {
    "text": "properties but of course we can use any other path we just need to remember to inform springboot about the the path",
    "start": "2154000",
    "end": "2160960"
  },
  {
    "text": "that we're using and we can do that with the spring cloud spring config import property if you're using a different",
    "start": "2160960",
    "end": "2167839"
  },
  {
    "text": "path but in this case we're going with one that we already know that will be",
    "start": "2167839",
    "end": "2173280"
  },
  {
    "text": "considered by the application so it's it's getting better",
    "start": "2173280",
    "end": "2179599"
  },
  {
    "text": "but not quite there yet we need to talk about health probes so kubernetes is really great because if",
    "start": "2179599",
    "end": "2185839"
  },
  {
    "start": "2181000",
    "end": "2274000"
  },
  {
    "text": "there's any problem with an application takes care of it it's the self-healing feature of kubernetes but kubernetes",
    "start": "2185839",
    "end": "2192880"
  },
  {
    "text": "doesn't know when an application is healthy or not so we need to provide a little help to",
    "start": "2192880",
    "end": "2198640"
  },
  {
    "text": "kubernetes depending on our application and in particular kubernetes is interested in two different states the",
    "start": "2198640",
    "end": "2204880"
  },
  {
    "text": "first state is the liveness state so when an application is not alive kubernetes will restart it because it",
    "start": "2204880",
    "end": "2211760"
  },
  {
    "text": "means that it entered a very bad state a faulty state and it won't be able to",
    "start": "2211760",
    "end": "2217520"
  },
  {
    "text": "recover by itself so it will restart the container the other state is the readiness state",
    "start": "2217520",
    "end": "2223920"
  },
  {
    "text": "and if the application is not ready it means that it's not able to process any new request",
    "start": "2223920",
    "end": "2229920"
  },
  {
    "text": "temporarily at least so kubernetes will stop sending traffic to that specific instance",
    "start": "2229920",
    "end": "2235680"
  },
  {
    "text": "and that's really great so the users will not notice any issues because we have other instances that will accept the traffic",
    "start": "2235680",
    "end": "2242480"
  },
  {
    "text": "and process the request the beauty of these two states and working with",
    "start": "2242480",
    "end": "2248800"
  },
  {
    "text": "springboot is that we get them out of the box since we added springboot actuator",
    "start": "2248800",
    "end": "2254000"
  },
  {
    "text": "springboot will detect when we run on kubernetes and will expose two http endpoints that return the information",
    "start": "2254000",
    "end": "2260960"
  },
  {
    "text": "about liveness and readiness so we don't have to change anything in the application we just need to tell",
    "start": "2260960",
    "end": "2266960"
  },
  {
    "text": "kubernetes where to look to extract that information and we can do that from the yaml",
    "start": "2266960",
    "end": "2272160"
  },
  {
    "text": "manifest again so i'll go back here and i add two new",
    "start": "2272160",
    "end": "2278800"
  },
  {
    "start": "2274000",
    "end": "2760000"
  },
  {
    "text": "sections one is the liveness probe and the other one is the readiness probe",
    "start": "2278800",
    "end": "2285280"
  },
  {
    "text": "so for the liveness probe i tell kubernetes to go and send an http get request",
    "start": "2285280",
    "end": "2292559"
  },
  {
    "text": "to slash actuator slash health slash liveness and this is exposed by default if you",
    "start": "2292720",
    "end": "2299520"
  },
  {
    "text": "want this endpoint exposed on a non-kubernetes environment you can do that but you need to enable it via",
    "start": "2299520",
    "end": "2305440"
  },
  {
    "text": "configuration properties and readiness probe is similar we still",
    "start": "2305440",
    "end": "2310960"
  },
  {
    "text": "have an http get request and the path is slash actuator slash health slash",
    "start": "2310960",
    "end": "2316400"
  },
  {
    "text": "readiness perfect next we can configure how or",
    "start": "2316400",
    "end": "2323040"
  },
  {
    "text": "the period and the frequency for kubernetes to send calls to these endpoints so i can define some",
    "start": "2323040",
    "end": "2329680"
  },
  {
    "text": "initial delay seconds for example and then period seconds",
    "start": "2329680",
    "end": "2337040"
  },
  {
    "text": "both for liveness and readiness probes so at this point let's hope that",
    "start": "2337280",
    "end": "2344320"
  },
  {
    "text": "we get internet back",
    "start": "2344320",
    "end": "2348440"
  },
  {
    "text": "yeah yeah not even my phone is working that's just perfect",
    "start": "2359280",
    "end": "2367000"
  },
  {
    "text": "oh we got it",
    "start": "2371119",
    "end": "2374000"
  },
  {
    "text": "so in the meantime i can talk about how i'm uh oh we got it",
    "start": "2378240",
    "end": "2385359"
  },
  {
    "text": "so let me quickly deploy it before it goes down again so what i can do now i can use the",
    "start": "2385359",
    "end": "2390960"
  },
  {
    "text": "kubernetes cli so i can say control apply dash f and then point to",
    "start": "2390960",
    "end": "2396720"
  },
  {
    "text": "this k native folder and then it should deploy both",
    "start": "2396720",
    "end": "2404319"
  },
  {
    "text": "resources but since we have the github actions pipeline here i want to show you that",
    "start": "2404319",
    "end": "2411200"
  },
  {
    "text": "whenever i push something to the main branch what happens is that i have two jobs the first job is to compile the",
    "start": "2411200",
    "end": "2417520"
  },
  {
    "text": "application and run the test so here i set up java 17 and then i run",
    "start": "2417520",
    "end": "2422960"
  },
  {
    "text": "gradle build which compiles and run all the autotest if that is successful then i have a",
    "start": "2422960",
    "end": "2428960"
  },
  {
    "text": "package job still using java 17 and i call the boot build",
    "start": "2428960",
    "end": "2434560"
  },
  {
    "text": "image task but this time i'm adding two extra arguments the publish image argument will make",
    "start": "2434560",
    "end": "2440400"
  },
  {
    "text": "sure that this task will also directly publish the image and then i'm also overriding the image",
    "start": "2440400",
    "end": "2445520"
  },
  {
    "text": "name because i need to use my doggerhub username in order to publish it",
    "start": "2445520",
    "end": "2450720"
  },
  {
    "text": "and then i'm also providing the credentials in order to login with the registry",
    "start": "2450720",
    "end": "2455760"
  },
  {
    "text": "but this is really convenient so you you don't even need dogger on your local machine you can work normally on the jvm",
    "start": "2455760",
    "end": "2462319"
  },
  {
    "text": "then you push your changes and it's the continuous delivery pipeline that takes care of packaging the application",
    "start": "2462319",
    "end": "2469280"
  },
  {
    "text": "oh that was too slow it was interesting that right before the",
    "start": "2477040",
    "end": "2482480"
  },
  {
    "text": "presentation it worked of course that's",
    "start": "2482480",
    "end": "2488560"
  },
  {
    "text": "so let's give the wi-fi another try",
    "start": "2489359",
    "end": "2494279"
  },
  {
    "text": "well in the meantime so i'm using this uh tool is called octant you can run it on your local computer it uses the",
    "start": "2504720",
    "end": "2513040"
  },
  {
    "text": "credentials that you have defined in your cube control configuration in order to visualize the workloads in a cluster",
    "start": "2513040",
    "end": "2519200"
  },
  {
    "text": "so you can use it for a different cluster it runs on your machine so it doesn't have all the security issues",
    "start": "2519200",
    "end": "2524720"
  },
  {
    "text": "that in the past we experienced with the kubernetes dashboard",
    "start": "2524720",
    "end": "2530640"
  },
  {
    "text": "line 23 ah yeah the joy of working with yaml",
    "start": "2535680",
    "end": "2542720"
  },
  {
    "text": "indentation",
    "start": "2542720",
    "end": "2545440"
  },
  {
    "text": "well the nice thing is that error messages are really descriptive",
    "start": "2547839",
    "end": "2552640"
  },
  {
    "text": "oh i think that's",
    "start": "2558079",
    "end": "2563240"
  },
  {
    "text": "yes yes we did it",
    "start": "2566160",
    "end": "2571839"
  },
  {
    "text": "we we have deployed the application so uh if internet will keep working now we can",
    "start": "2571839",
    "end": "2578960"
  },
  {
    "text": "actually also uh use it let's see what happens here",
    "start": "2578960",
    "end": "2584720"
  },
  {
    "text": "so what happens behind the scenes since i'm using this service k native object is that k native will get this",
    "start": "2584720",
    "end": "2590560"
  },
  {
    "text": "specification and we'll deploy uh we'll create a deployment a service in ingress so everything that you would",
    "start": "2590560",
    "end": "2597119"
  },
  {
    "text": "have done manually and individually for each resource it does it for you and on top of that it also returns a url that",
    "start": "2597119",
    "end": "2604400"
  },
  {
    "text": "you can use to access your application directly via the ingress controller so it's really great for a development",
    "start": "2604400",
    "end": "2611599"
  },
  {
    "text": "also so let's see",
    "start": "2611599",
    "end": "2619640"
  },
  {
    "text": "so it's actually working so uh i you i'm using the k native command line i get a",
    "start": "2622560",
    "end": "2627920"
  },
  {
    "text": "url now i can use that url to call the application so if i go on the browser",
    "start": "2627920",
    "end": "2633440"
  },
  {
    "text": "and call that application i get the message spring boots on kubernetes that just disappear yes spring will turn",
    "start": "2633440",
    "end": "2639359"
  },
  {
    "text": "kubernetes so i get this nice url back from k native and i get the message the config map is",
    "start": "2639359",
    "end": "2646319"
  },
  {
    "text": "working because i can see the the new message and the health probes also are working it means that",
    "start": "2646319",
    "end": "2652560"
  },
  {
    "text": "if for example the application takes a few seconds to start right in those few seconds the application is not ready so",
    "start": "2652560",
    "end": "2658960"
  },
  {
    "text": "it means that kubernetes will not send any traffic to it but now there's an interesting aspect of using k native",
    "start": "2658960",
    "end": "2666079"
  },
  {
    "text": "because probably i need to refresh octant because k native supports serverless workloads",
    "start": "2666079",
    "end": "2673119"
  },
  {
    "text": "and one of the features that is enabled by default is the scale to zero",
    "start": "2673119",
    "end": "2678400"
  },
  {
    "text": "when we work with a standard application that's a bit of a problem because a",
    "start": "2680560",
    "end": "2685920"
  },
  {
    "text": "springboard application takes a few seconds to start so it means that if there's no request for a while there's",
    "start": "2685920",
    "end": "2691119"
  },
  {
    "text": "no instance of application running but as soon as we send a request a new",
    "start": "2691119",
    "end": "2696240"
  },
  {
    "text": "application is started but then it means that as a user i will experience a delay",
    "start": "2696240",
    "end": "2701280"
  },
  {
    "text": "i will have to wait a few seconds before getting the response back and that's really not what",
    "start": "2701280",
    "end": "2706400"
  },
  {
    "text": "i want to provide as an experience both to users but also to other applications using my services",
    "start": "2706400",
    "end": "2713280"
  },
  {
    "text": "so now one minute uh passed that's uh the default timeout in the k native so",
    "start": "2716480",
    "end": "2721920"
  },
  {
    "text": "since uh there was no call i would expect to get a slow response if i call the server",
    "start": "2721920",
    "end": "2729280"
  },
  {
    "text": "again so you can see that it's uh waiting waiting waiting i mean it might even be",
    "start": "2729280",
    "end": "2735839"
  },
  {
    "text": "the internet connection but but that's my point",
    "start": "2735839",
    "end": "2741280"
  },
  {
    "text": "we we have a problem there but we have also a solution so let's move on",
    "start": "2741280",
    "end": "2748480"
  },
  {
    "text": "what we have done so far it's perfectly fine for uh more standard applications that",
    "start": "2748720",
    "end": "2754240"
  },
  {
    "text": "have our long-running applications we we talked about liveness and readiness probes that's",
    "start": "2754240",
    "end": "2759920"
  },
  {
    "text": "perfect but now i want to get to spring native spring native is this exciting new project that aims at compiling your",
    "start": "2759920",
    "end": "2766800"
  },
  {
    "start": "2760000",
    "end": "2991000"
  },
  {
    "text": "spring boot application as a native image a native image based on grail vm",
    "start": "2766800",
    "end": "2772079"
  },
  {
    "text": "so we wouldn't run the java application on the jvm anymore we don't have the",
    "start": "2772079",
    "end": "2777839"
  },
  {
    "text": "two steps compilation where we have first the compilation to bytecode and then the jvm takes care of converting",
    "start": "2777839",
    "end": "2784160"
  },
  {
    "text": "bytecode to machine code but we directly uh compile",
    "start": "2784160",
    "end": "2789200"
  },
  {
    "text": "the application down to the machine code so from one side we are losing uh one of the java features like write",
    "start": "2789200",
    "end": "2796240"
  },
  {
    "text": "once run run everywhere because we don't have the java virtual machine so i can write i can compile an executable for my",
    "start": "2796240",
    "end": "2804319"
  },
  {
    "text": "macbook that will not work on windows but that's fine because we're in a containerized world right so we can",
    "start": "2804319",
    "end": "2810160"
  },
  {
    "text": "build a container with a native executable so i still get the right ones run everywhere but i get a lot of",
    "start": "2810160",
    "end": "2817839"
  },
  {
    "text": "benefits at runtime one of the benefit is instant startup time usually with spring native right",
    "start": "2817839",
    "end": "2823520"
  },
  {
    "text": "now it's usually below 100 milliseconds which is a great improvement compared to",
    "start": "2823520",
    "end": "2829760"
  },
  {
    "text": "now where maybe two three even four seconds we need to wait for an application to start we also get instant",
    "start": "2829760",
    "end": "2835839"
  },
  {
    "text": "peak performance because the jvm when we run an application will need to",
    "start": "2835839",
    "end": "2841280"
  },
  {
    "text": "do a lot of computation at startup dynamically we don't do that with native",
    "start": "2841280",
    "end": "2847440"
  },
  {
    "text": "executables so we also get this instant peak performance and we also get reduced memory consumption which is",
    "start": "2847440",
    "end": "2853920"
  },
  {
    "text": "really great if we are deploying on a public cloud that means that we're going to save a lot of money because we need",
    "start": "2853920",
    "end": "2860400"
  },
  {
    "text": "much less memory specifically to run applications of course there's no silver bullet",
    "start": "2860400",
    "end": "2866720"
  },
  {
    "text": "it's always a matter of trade-offs so since we are optimizing as much as possible the runtime part",
    "start": "2866720",
    "end": "2875119"
  },
  {
    "text": "we still need to do a lot of those computation that right now the jvm is doing dynamically while running so we",
    "start": "2875119",
    "end": "2881520"
  },
  {
    "text": "are moving all those computations back to the build time phase",
    "start": "2881520",
    "end": "2887920"
  },
  {
    "text": "so when we build the application now we get a slower and heavier process so it can take even a minute or five",
    "start": "2887920",
    "end": "2894480"
  },
  {
    "text": "minutes depending on the resources on your computer it consumes a lot of cpu it's slow and",
    "start": "2894480",
    "end": "2902240"
  },
  {
    "text": "well it's it's a good job for a ci server probably but if you want to do",
    "start": "2902240",
    "end": "2908079"
  },
  {
    "text": "it on your machine every time you need to containerize it then maybe it's not that efficient so it's just something to",
    "start": "2908079",
    "end": "2913520"
  },
  {
    "text": "consider it's improving over time they're working a lot on optimizing the build time both",
    "start": "2913520",
    "end": "2919440"
  },
  {
    "text": "for a grail vm but also the spring native project but right now we need to consider that",
    "start": "2919440",
    "end": "2925280"
  },
  {
    "text": "also there are less memory less runtime optimizations",
    "start": "2925280",
    "end": "2930640"
  },
  {
    "text": "right now because the jvm can dynamically figures out a lot of things at runtime depending on how things are",
    "start": "2930640",
    "end": "2936880"
  },
  {
    "text": "running so since we are now moving everything in the build phase we need to do it in a",
    "start": "2936880",
    "end": "2942559"
  },
  {
    "text": "static way so we are missing some opportunities to further optimize the code",
    "start": "2942559",
    "end": "2948960"
  },
  {
    "text": "the goal of spring native is to achieve these native executables without changing anything in your code at least",
    "start": "2949119",
    "end": "2956400"
  },
  {
    "text": "when in regards with all the libraries which are provided by spring either spring libraries or the third part is",
    "start": "2956400",
    "end": "2962800"
  },
  {
    "text": "used by libraries part of the starter projects so",
    "start": "2962800",
    "end": "2968559"
  },
  {
    "text": "what i can do now with the applications that i've just built is add the spring native dependency",
    "start": "2968559",
    "end": "2975119"
  },
  {
    "text": "and changing nothing else and it will work in the same way i can use the same task",
    "start": "2975119",
    "end": "2981040"
  },
  {
    "text": "boot build image to containerize the image as a native image and it will do that because",
    "start": "2981040",
    "end": "2987359"
  },
  {
    "text": "i add spring native to the to the project",
    "start": "2987359",
    "end": "2992960"
  },
  {
    "start": "2991000",
    "end": "3252000"
  },
  {
    "text": "so you can add a spring native dependency from here the project is still in beta but",
    "start": "2992960",
    "end": "2998000"
  },
  {
    "text": "i know that it's also being used in production already it will",
    "start": "2998000",
    "end": "3003359"
  },
  {
    "text": "be out of the experimental mode next year so it will be included as part of the spring core in the next major",
    "start": "3003359",
    "end": "3010000"
  },
  {
    "text": "version of spring so we're talking about spring framework 6 and spring boot 3 but for now it's in beta so if you want this",
    "start": "3010000",
    "end": "3016720"
  },
  {
    "text": "one then you'll get everything you need to compile to native images a spring with application",
    "start": "3016720",
    "end": "3022960"
  },
  {
    "text": "so i have already done that i just changed the name of the application it's called demon native instead of",
    "start": "3022960",
    "end": "3029280"
  },
  {
    "text": "demo service so i can show you that the java code is exactly the same we",
    "start": "3029280",
    "end": "3034559"
  },
  {
    "text": "have the configuration properties record it works with java 17 by the way we have",
    "start": "3034559",
    "end": "3040640"
  },
  {
    "text": "the rest controller we have the custom application you can see i have defined the name of",
    "start": "3040640",
    "end": "3046720"
  },
  {
    "text": "the application also and we have the test also the tests are the same",
    "start": "3046720",
    "end": "3052880"
  },
  {
    "text": "so what changes is uh something in the build gradle file because when we add spring native we get",
    "start": "3053040",
    "end": "3059760"
  },
  {
    "text": "three new things two of them are plugins either for gradle or maven we have the spring",
    "start": "3059760",
    "end": "3066079"
  },
  {
    "text": "native plugin which is responsible for doing all the native compilation for the spring",
    "start": "3066079",
    "end": "3071359"
  },
  {
    "text": "libraries and the other one is the graph vm official gradle or maven plugin that lets you build and run tests on a native",
    "start": "3071359",
    "end": "3078800"
  },
  {
    "text": "image on your local machine in case you you want to do that and then we also get this additional",
    "start": "3078800",
    "end": "3086160"
  },
  {
    "text": "configuration for the boot build image task so that using this environment variable we set",
    "start": "3086160",
    "end": "3091920"
  },
  {
    "text": "the native image to true and we can run it and we can obtain a containerized image which is a",
    "start": "3091920",
    "end": "3098559"
  },
  {
    "text": "native executable let's see if",
    "start": "3098559",
    "end": "3105200"
  },
  {
    "text": "internet is still with us so for this demonstration i will use the",
    "start": "3105200",
    "end": "3110240"
  },
  {
    "text": "k native command line i could do the whole manifest thing but i want to show you",
    "start": "3110240",
    "end": "3117359"
  },
  {
    "text": "another way of doing it this is especially useful in development so i wouldn't use this in production but it's",
    "start": "3117359",
    "end": "3123119"
  },
  {
    "text": "an option that you have when you're working actively on a new application so i can say kn service create",
    "start": "3123119",
    "end": "3129520"
  },
  {
    "text": "we want to create a demo native and then the image",
    "start": "3129520",
    "end": "3134559"
  },
  {
    "text": "so this is also something that github actions push to my container registry",
    "start": "3134559",
    "end": "3141520"
  },
  {
    "text": "so for clarity i will also undeploy the other one",
    "start": "3145520",
    "end": "3153838"
  },
  {
    "text": "yeah oh it works",
    "start": "3162160",
    "end": "3166760"
  },
  {
    "text": "so the previous application was starting in three seconds roughly",
    "start": "3168960",
    "end": "3174000"
  },
  {
    "text": "so we can now see the startup time of this application so we get a url back",
    "start": "3174000",
    "end": "3181839"
  },
  {
    "text": "so first i can verify that it works",
    "start": "3181839",
    "end": "3186000"
  },
  {
    "text": "and then i can yes springboot on the cloud so it's still the default message",
    "start": "3187680",
    "end": "3192960"
  },
  {
    "text": "because right now i deployed directly image i didn't use any configmap and then",
    "start": "3192960",
    "end": "3198880"
  },
  {
    "text": "in octant i can check the logs so we can see the start of time",
    "start": "3198880",
    "end": "3207280"
  },
  {
    "text": "container no not that one this other one yes so we can see that this one started",
    "start": "3207280",
    "end": "3212559"
  },
  {
    "text": "in 0.1 seconds and which is really uh also a long time it usually runs in 50",
    "start": "3212559",
    "end": "3219280"
  },
  {
    "text": "or 60 milliseconds but so just by adding the spring native",
    "start": "3219280",
    "end": "3224400"
  },
  {
    "text": "dependency to the project i i got this application which is now suitable for a serverless use case so i",
    "start": "3224400",
    "end": "3231680"
  },
  {
    "text": "have k native so i can rely on the scale to zero feature i save money on resources",
    "start": "3231680",
    "end": "3238000"
  },
  {
    "text": "because if there's no request then there's no pod running for my application and i didn't have to change",
    "start": "3238000",
    "end": "3243920"
  },
  {
    "text": "anything in my code",
    "start": "3243920",
    "end": "3247799"
  },
  {
    "start": "3252000",
    "end": "3290000"
  },
  {
    "text": "and that was our cloud native journey we started from springboot we built a cloud native application we",
    "start": "3252720",
    "end": "3258400"
  },
  {
    "text": "even briefly looked at spring native without changing any code we got a native executable we used cloud native",
    "start": "3258400",
    "end": "3265280"
  },
  {
    "text": "buildbacks in both cases to containerize the application so we didn't have to write a",
    "start": "3265280",
    "end": "3270319"
  },
  {
    "text": "docker file we don't have to maintain the docker file so as developers we are free to focus on the business logic and",
    "start": "3270319",
    "end": "3276480"
  },
  {
    "text": "we deploy the application on kubernetes in particular a kubernetes cluster on a public cloud azure",
    "start": "3276480",
    "end": "3282640"
  },
  {
    "text": "with uh the additional layer of k native which gives us a better experience and",
    "start": "3282640",
    "end": "3288400"
  },
  {
    "text": "extra features thank you and enjoy the conference",
    "start": "3288400",
    "end": "3293480"
  }
]