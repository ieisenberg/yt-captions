[
  {
    "text": "[Music]",
    "start": "990",
    "end": "7859"
  },
  {
    "text": "thank you how's audio are we good",
    "start": "12410",
    "end": "19340"
  },
  {
    "text": "sweet okay this is yeah this is a cheeping functional programming in Java",
    "start": "19340",
    "end": "25640"
  },
  {
    "text": "this is something that I spend a whole lot of time thinking about how to do if",
    "start": "25640",
    "end": "31529"
  },
  {
    "text": "this talk was called like achieving FP and like Haskell it would be like one slide that just I'd like write Haskell and the rest would just be like a",
    "start": "31529",
    "end": "37890"
  },
  {
    "text": "crossword puzzle or something but in Java this actually requires like quite a bit of thought and effort to get this",
    "start": "37890",
    "end": "44730"
  },
  {
    "text": "right and there's a bunch of reasons for that before I get started I should do",
    "start": "44730",
    "end": "49800"
  },
  {
    "text": "this whole sort of reminder that you can write this session with a go to Chicago app I guess and then you can also submit",
    "start": "49800",
    "end": "56910"
  },
  {
    "text": "questions to that but I would actually like it if you have questions to just sort of raise your hand and interrupt me",
    "start": "56910",
    "end": "62570"
  },
  {
    "text": "because some of this stuff is sort of like there's sort of this like natural matriculation from like simpler concepts",
    "start": "62570",
    "end": "69030"
  },
  {
    "text": "to more complicated concepts and so rather than just like sacrifice understanding something early on and",
    "start": "69030",
    "end": "74520"
  },
  {
    "text": "then like forfeit the rest of the talk just like interrupt me and we'll talk about alright then or if you don't feel",
    "start": "74520",
    "end": "80130"
  },
  {
    "text": "comfortable well we'll get to it at the end so I guess first a little bit about",
    "start": "80130",
    "end": "85590"
  },
  {
    "text": "me I am a software developer at an algorithmic trading firm called drw",
    "start": "85590",
    "end": "91710"
  },
  {
    "text": "they're headquartered here in Chicago they're actually uh not too far away from here and I spend most of my time at",
    "start": "91710",
    "end": "97950"
  },
  {
    "text": "the company working with the trading infrastructure teams so for just a very brief amount of a crown on that you",
    "start": "97950",
    "end": "104729"
  },
  {
    "text": "could think of the company of drw is like I like to use the analogy if it's almost kind of like a like startup",
    "start": "104729",
    "end": "110430"
  },
  {
    "text": "incubator for trading desks so we may spin up new trading strategies pretty",
    "start": "110430",
    "end": "116189"
  },
  {
    "text": "regularly and you can imagine that it becomes pretty quickly cost prohibitively expensive to assume that",
    "start": "116189",
    "end": "121320"
  },
  {
    "text": "you have to re-engineer everything that you might need to run a profitable like successful trade from scratch every time",
    "start": "121320",
    "end": "126780"
  },
  {
    "text": "you try a new strategy and so there's some common software that you end up needing basically regardless of what you're doing involves tracking P&L",
    "start": "126780",
    "end": "133920"
  },
  {
    "text": "and doing sort of you know obviating things I make it easy to reconcile at the end of the day you know there's",
    "start": "133920",
    "end": "139170"
  },
  {
    "text": "compliance problems and all sorts of stuff and so the TI teams trading",
    "start": "139170",
    "end": "144840"
  },
  {
    "text": "infrastructure teams spend a lot of time writing this this software that is basically the entire firm is their",
    "start": "144840",
    "end": "150540"
  },
  {
    "text": "customer and so reliability is absolutely paramount for like as a",
    "start": "150540",
    "end": "157260"
  },
  {
    "text": "requirement of the software that they deliver unlike a product company where you might have you know deadlines",
    "start": "157260",
    "end": "162360"
  },
  {
    "text": "because you're trying to pitch an investor on a feature that better exists next week we we are more under the gun",
    "start": "162360",
    "end": "170130"
  },
  {
    "text": "to make sure that things actually like just work they're reliable if things go down it could be it could",
    "start": "170130",
    "end": "175350"
  },
  {
    "text": "be extremely expensive for us and I'm also the maintainer of lambda which is",
    "start": "175350",
    "end": "181890"
  },
  {
    "text": "the open source library released under the MIT license that I'm going to be talking to you about mostly today which",
    "start": "181890",
    "end": "187230"
  },
  {
    "text": "is basically what we use at D or W to facilitate FP and Java and so just a",
    "start": "187230",
    "end": "197610"
  },
  {
    "text": "very brief background on the developers we actually probably have some of them in here they're polyglot dubs we",
    "start": "197610",
    "end": "203310"
  },
  {
    "text": "maintain you know applications in Ruby c-sharp closure and Java there may actually be some more floating around",
    "start": "203310",
    "end": "209220"
  },
  {
    "text": "out there those are just the server-side languages today we have full you know front-end stacks as well and by about",
    "start": "209220",
    "end": "215430"
  },
  {
    "text": "right now I think there's there's approximately 30 or so applications that are built on top of lambda I want to say",
    "start": "215430",
    "end": "220470"
  },
  {
    "text": "built on top of lambda I like always make the joke that if if like for",
    "start": "220470",
    "end": "225630"
  },
  {
    "text": "whatever reason or you know like the sec or like the CFTC has a big problem with something that we've written like I'm",
    "start": "225630",
    "end": "231420"
  },
  {
    "text": "going down because like comm Jana is in like absolutely any stack trees that might get thrown so I'm like I'm going",
    "start": "231420",
    "end": "237750"
  },
  {
    "text": "to jail or something okay so I have to",
    "start": "237750",
    "end": "244230"
  },
  {
    "text": "confess that I actually knew I was going to do this talk about it you know I'm not than a half ago and I put a bunch of slides together and I felt really really",
    "start": "244230",
    "end": "249780"
  },
  {
    "text": "good about him I felt like there was this like obvious like inductive step like from early concepts to like later",
    "start": "249780",
    "end": "255450"
  },
  {
    "text": "concepts and it seemed like very clear and coherent to me and I presented it at a user group in Milwaukee and I had like",
    "start": "255450",
    "end": "262229"
  },
  {
    "text": "about an hour five hour ten minutes to present and I got through about 40% of the slides so I basically trash all of those",
    "start": "262229",
    "end": "268740"
  },
  {
    "text": "and said forget it I'm just gonna like cover some basic stuff here and then if we have time at the end just crack open",
    "start": "268740",
    "end": "274200"
  },
  {
    "text": "IntelliJ and like just play around and you know maybe answer some questions or show you guys kind of the ergonomics of",
    "start": "274200",
    "end": "280380"
  },
  {
    "text": "how this actually works in practice but to get there let's talk about some guiding principles that we tend to follow on the teams that use lambda to",
    "start": "280380",
    "end": "288510"
  },
  {
    "text": "program effectively so the first is that constraints should be precisely stated",
    "start": "288510",
    "end": "295680"
  },
  {
    "text": "via type so we actually think a lot about this this is something that's become sort of second nature but we",
    "start": "295680",
    "end": "304590"
  },
  {
    "text": "think about you know that we have sort of like propositions like logical propositions can be represented by by",
    "start": "304590",
    "end": "311190"
  },
  {
    "text": "like axiomatic set theory which can be represented by like Bertrand Russell's type theory like these things are equivalent I can start with any one of",
    "start": "311190",
    "end": "317070"
  },
  {
    "text": "them and I can recover the other two and so when we want to talk about like what is the logical proposition that we want",
    "start": "317070",
    "end": "322530"
  },
  {
    "text": "to be able to satisfy it like in type check we want to think about like what type precisely specifies the constraints",
    "start": "322530",
    "end": "328650"
  },
  {
    "text": "of my system so like we're not going to use a list if this thing could at most have two elements and at least have like",
    "start": "328650",
    "end": "334470"
  },
  {
    "text": "no elements we'd probably create like a custom data structure for that or if you",
    "start": "334470",
    "end": "340860"
  },
  {
    "text": "know if we have like one of two values we're not going to represent that as like two possibly missing values like we",
    "start": "340860",
    "end": "346860"
  },
  {
    "text": "wouldn't say like here's you know here's two slots and like both of them are like maybes because that would model like",
    "start": "346860",
    "end": "352740"
  },
  {
    "text": "only half of the correct representations there would be two like totally impossible representations that we'd have to handle in order to satisfy the",
    "start": "352740",
    "end": "360000"
  },
  {
    "text": "type checker so that would just not you know that wouldn't work the second one seems like a tautology or like seems",
    "start": "360000",
    "end": "366090"
  },
  {
    "text": "like self-evident but it's remarkably like hard to find you know evidence of this and like the JDK generic operations",
    "start": "366090",
    "end": "373380"
  },
  {
    "text": "should have generic interfaces and we get a lot of reuse from being able to",
    "start": "373380",
    "end": "378390"
  },
  {
    "text": "model things as like functors and applicatives and we get a ton of stuff for free that's like correct by construction",
    "start": "378390",
    "end": "383700"
  },
  {
    "text": "because we have these general interfaces that we can adhere to we don't have to re-implement like F map every single time we you know we think about like",
    "start": "383700",
    "end": "389880"
  },
  {
    "text": "mapping something lazy eval is a useful default I am NOT going to preach to you",
    "start": "389880",
    "end": "397980"
  },
  {
    "text": "that lazy evil is like strictly better than strict evaluation but certainly it's a useful default that we have",
    "start": "397980",
    "end": "404610"
  },
  {
    "text": "gotten a lot of use out of partial",
    "start": "404610",
    "end": "410040"
  },
  {
    "text": "operations should be encoded as total operations so what do we mean by partial operations you can think of when you're",
    "start": "410040",
    "end": "416460"
  },
  {
    "text": "like type checking in Java but what the type checker is doing when it's trying to unify your expression to determine if like the right-hand side like can you",
    "start": "416460",
    "end": "423240"
  },
  {
    "text": "know can like satisfy to the left-hand side there's all of the like instance inhabitants of that type that it's",
    "start": "423240",
    "end": "429300"
  },
  {
    "text": "looking for but it's also looking for what we would call bottom so it would say if this program diverges if it",
    "start": "429300",
    "end": "435240"
  },
  {
    "text": "throws an exception or if you return null in all is universally polymorphic so like there's no way to type check in",
    "start": "435240",
    "end": "441630"
  },
  {
    "text": "Java currently that like something isn't null you just have to like check at runtime or you can have like a while",
    "start": "441630",
    "end": "447510"
  },
  {
    "text": "true loop like you could have like non termination any of those are examples of diverging basically like the type on the",
    "start": "447510",
    "end": "454170"
  },
  {
    "text": "left hand side like the type checker kind of saying like sure like it'll work but then when you run it something",
    "start": "454170",
    "end": "459480"
  },
  {
    "text": "something goes wrong so what we would tend to do is we would try to encode those partial operations things that",
    "start": "459480",
    "end": "465180"
  },
  {
    "text": "could throw those are the most common occurrences we would try to encode them as total operations and say instead of",
    "start": "465180",
    "end": "470550"
  },
  {
    "text": "throwing will return either a special value or we'll put it inside a data structure that actually is like coherent",
    "start": "470550",
    "end": "476490"
  },
  {
    "text": "with you know exceptions and doesn't pop the stack and like blow your application up and then the last thing is that pure",
    "start": "476490",
    "end": "484380"
  },
  {
    "text": "and impure operations should be separate they should be separate both in how you can type check them they should be",
    "start": "484380",
    "end": "490170"
  },
  {
    "text": "separate and how you design your applications and we should be able to think separately about them we can refactor one of those with like a ton of",
    "start": "490170",
    "end": "496380"
  },
  {
    "text": "confidence and the other one like did it like fire missiles or like format my hard drive or I don't know I you know I",
    "start": "496380",
    "end": "502740"
  },
  {
    "text": "want to be very careful about the separation there so let's let's sort of",
    "start": "502740",
    "end": "509610"
  },
  {
    "text": "step through these systematically and take a look at like what I mean by each one of these things with examples so constraints should be precisely stated",
    "start": "509610",
    "end": "516120"
  },
  {
    "text": "video types here's here's you know maybe a good starting example let's say we have some method in the ether that's",
    "start": "516120",
    "end": "522630"
  },
  {
    "text": "like exists and it takes a string and returns a boolean but in actuality like string is a pretty poor type for most",
    "start": "522630",
    "end": "529050"
  },
  {
    "text": "representations like like almost you know this like call me maybe like the lyrics",
    "start": "529050",
    "end": "534749"
  },
  {
    "text": "to it or is this you know like you know the like bites of some movie somewhere is this a gigabyte like you don't know",
    "start": "534749",
    "end": "541649"
  },
  {
    "text": "very much about a string and if this is a UUID use a UUID similarly I talked",
    "start": "541649",
    "end": "549749"
  },
  {
    "text": "about this a little bit earlier if we want to split a float into like its integral in its fractional parts a list is like it has no opinion about how many",
    "start": "549749",
    "end": "557100"
  },
  {
    "text": "elements it has it could be empty it could have a hundred million things in it that's not a terribly good use of that we would use the lambda type for",
    "start": "557100",
    "end": "563790"
  },
  {
    "text": "this we would use a tuple a tuple two and we would say what you get back is definitely like two integers no few like",
    "start": "563790",
    "end": "570569"
  },
  {
    "text": "no more no less and there's no way for you to not get integers back from this",
    "start": "570569",
    "end": "576439"
  },
  {
    "text": "and here's something that might seem contrived but I used to run into this thing all the time I'm actually being a",
    "start": "576680",
    "end": "584370"
  },
  {
    "text": "little bit more like forgiving with my interfaces than what I would usually run into usually what I'd run into is lists",
    "start": "584370",
    "end": "590040"
  },
  {
    "text": "of object but I chose like the minimally contravariant type 2 string and integer like the nearest ancestor is actually",
    "start": "590040",
    "end": "596129"
  },
  {
    "text": "serializable so let's say that we have a list of some you know items that could be strings or could be integers and",
    "start": "596129",
    "end": "602550"
  },
  {
    "text": "really those are the only things that it could be those are the only things that we want it to be able to be but the",
    "start": "602550",
    "end": "607800"
  },
  {
    "text": "reality is that in Java really you're your only option by default is to choose the nearest ancestor or like the",
    "start": "607800",
    "end": "615480"
  },
  {
    "text": "farthest ancestor if you just want to say object and then cast right do like instance subjects and cast down and deal",
    "start": "615480",
    "end": "621029"
  },
  {
    "text": "with the things you know in isolation and so let's say we want some integer value and if it's a string we're gonna call length on it and if it's an integer",
    "start": "621029",
    "end": "627569"
  },
  {
    "text": "we'll just like take it as it is the type checker is gonna you know sort of warn us here that value won't be can you",
    "start": "627569",
    "end": "635399"
  },
  {
    "text": "guys see the cursor up here no you can okay so that value won't be initialized without that else so like we if we're",
    "start": "635399",
    "end": "643529"
  },
  {
    "text": "gonna use the value later we need to guarantee that we wouldn't have gotten to that point by then so we need this else Clause and really this is like this",
    "start": "643529",
    "end": "650730"
  },
  {
    "text": "is this is pretty crappy like that this this sort of sucks your interface is like far too",
    "start": "650730",
    "end": "657629"
  },
  {
    "text": "permissive for what you actually want to support and it actually gets even worse than this if at some point in your application where you actually pass this",
    "start": "657629",
    "end": "664290"
  },
  {
    "text": "list of things to process if you have a requirement that says like hey we now want to support like doubles",
    "start": "664290",
    "end": "669690"
  },
  {
    "text": "or floats or boolean x' the type checker is not going to tell you that you missed a spot you're gonna have to wait until",
    "start": "669690",
    "end": "675420"
  },
  {
    "text": "it just blows up hopefully you've got tests around this but like these types of methods when they intermix they can",
    "start": "675420",
    "end": "681029"
  },
  {
    "text": "become like combinatorially complex like very very quickly so what we would do using lambda is we would actually represent this list like our very first",
    "start": "681029",
    "end": "688260"
  },
  {
    "text": "like our first decision would probably to represent represent this list as a co-product now co-product 2 is a type",
    "start": "688260",
    "end": "694140"
  },
  {
    "text": "safe way of basically saying like I don't have both of these things but I have one of these things and it gives",
    "start": "694140",
    "end": "699600"
  },
  {
    "text": "you like exhaustive D matching where it exposes like a single interface that basically says like I have either a",
    "start": "699600",
    "end": "704940"
  },
  {
    "text": "string or an integer so if you if you want some type or and you give me a way",
    "start": "704940",
    "end": "710430"
  },
  {
    "text": "to go from a string to R and you give me a way to go from integer R I can promise you can get an R back like I don't know",
    "start": "710430",
    "end": "715709"
  },
  {
    "text": "which one I have but I know you're gonna get this R back I know this is gonna work and so the nice thing about this is if we decided later that this actually",
    "start": "715709",
    "end": "723420"
  },
  {
    "text": "wasn't just a string or an integer that now it could be a boolean we'd have to promote that co-product to to a co-product 3 we'd have to specify",
    "start": "723420",
    "end": "729060"
  },
  {
    "text": "it at the type level and we get compile errors so the type checker would actually tell us that we don't have an exhaustive match anymore on line 3",
    "start": "729060",
    "end": "735930"
  },
  {
    "text": "whatever that would be and so we'd have to actually fix that but then once we actually got to compiling we would have",
    "start": "735930",
    "end": "741060"
  },
  {
    "text": "a pretty high level of confidence that we covered all the cases and our features done this is a this is a sort",
    "start": "741060",
    "end": "750269"
  },
  {
    "text": "of interesting phenomena that doesn't really make it a Java very often but I've seen this happen quite a bit in",
    "start": "750269",
    "end": "757110"
  },
  {
    "text": "Ruby enclosure it's pretty prevalent as well and go it's like absolutely ubiquitous it basically says like I'm",
    "start": "757110",
    "end": "762449"
  },
  {
    "text": "gonna try something and I'm gonna give you back like either an exception on the",
    "start": "762449",
    "end": "767490"
  },
  {
    "text": "left hand side or like a success on the right hand side but I'm gonna represent it as two values you know if any of you",
    "start": "767490",
    "end": "773190"
  },
  {
    "text": "guys have ever written code in any of those languages you may you may say like underscore comma okay or like e^x comma okay or something like",
    "start": "773190",
    "end": "780329"
  },
  {
    "text": "that I alluded to this particular issue earlier tuples of like maybes are like",
    "start": "780329",
    "end": "785579"
  },
  {
    "text": "optional values is like a really poor way to represent that in my opinion because there are four constructions of",
    "start": "785579",
    "end": "791010"
  },
  {
    "text": "that type and two of them are absolutely invalid so like half of the representable things are completely",
    "start": "791010",
    "end": "796290"
  },
  {
    "text": "impossible but like now you have to manage when the type is kind of like lying to you have to remember like",
    "start": "796290",
    "end": "802140"
  },
  {
    "text": "oh we actually don't care if both of these are nothing or both of them are present because that shouldn't be",
    "start": "802140",
    "end": "807300"
  },
  {
    "text": "possible so we would just use an either type which which comes from lambda to",
    "start": "807300",
    "end": "814890"
  },
  {
    "text": "represent that it's one of these two things and either is just like a co-product too but it has implicit success and failure semantics so it has",
    "start": "814890",
    "end": "820410"
  },
  {
    "text": "like functional comprehensions on it that allow you to speak to it in terms of like this was something that went",
    "start": "820410",
    "end": "825780"
  },
  {
    "text": "wrong and here's how I can recover it to a better option or I can say like or else or I can say like forfeit the good",
    "start": "825780",
    "end": "831660"
  },
  {
    "text": "you know the good thing that I wanted back to the bad thing I have lots of different ways I can operate on them so",
    "start": "831660",
    "end": "839790"
  },
  {
    "text": "the second thing is that generic operations should have generic interfaces this is this is like maybe a cheap shot but it's just it's so easy",
    "start": "839790",
    "end": "846360"
  },
  {
    "text": "that I just can't like not fall for this trap every time so since Java eight all four of these types got added to the JDK",
    "start": "846360",
    "end": "852990"
  },
  {
    "text": "we get a function type we have an optional type a stream type in a completable future there's probably for the most part",
    "start": "852990",
    "end": "859320"
  },
  {
    "text": "pretty self-explanatory function is a little bit different than the other than the other three but effectively we can",
    "start": "859320",
    "end": "865800"
  },
  {
    "text": "talk about all of these things as saying like there's some type that have the potential to offer the thing on the",
    "start": "865800",
    "end": "872580"
  },
  {
    "text": "right like they have a potential to offer like an integer and that integer is covariantly positioned so what that",
    "start": "872580",
    "end": "878010"
  },
  {
    "text": "means is that we could provide a function that would take that integer as its origin and could map it out into",
    "start": "878010",
    "end": "884250"
  },
  {
    "text": "something else so if I gave you a function from like integer to float and you look at a function from string an",
    "start": "884250",
    "end": "889620"
  },
  {
    "text": "integer you should be able to say like well I can just compose those naturally and get from string to float or I could like update the optional and say like",
    "start": "889620",
    "end": "895680"
  },
  {
    "text": "hey I don't know if you had a value but if you did I want that value turned into a float and so we've got like four",
    "start": "895680",
    "end": "902160"
  },
  {
    "text": "different ways of doing that we've got like function and then which is this totally like unique operation",
    "start": "902160",
    "end": "907380"
  },
  {
    "text": "that exists on function we've got optional dot map we've got stream dot map which starts to like maybe you know",
    "start": "907380",
    "end": "914070"
  },
  {
    "text": "be a little bit encouraging that we have like the same semantics used and then we got future like dot then apply and even",
    "start": "914070",
    "end": "920100"
  },
  {
    "text": "between the two map operations there's no common interface for any of these things so pretty much every time you run into this like extremely degenerate case",
    "start": "920100",
    "end": "925620"
  },
  {
    "text": "you have to kind of reimplemented come up with like another semantics for potentially and you get absolutely no",
    "start": "925620",
    "end": "930960"
  },
  {
    "text": "way to program generally again this alright so anyone who's worked in like Haskell would take a look at this and probably immediately say like well",
    "start": "930960",
    "end": "936610"
  },
  {
    "text": "that's a functor and you'd be right and so in lambda we actually have a functor interface that we can model as a",
    "start": "936610",
    "end": "943149"
  },
  {
    "text": "first class concept and we can also program against it generically so we could have like a response envelope for",
    "start": "943149",
    "end": "948940"
  },
  {
    "text": "instance where we parameterize the body and then we could you know we would have to implement what f map would look like",
    "start": "948940",
    "end": "954910"
  },
  {
    "text": "for that response envelope we don't have any like auto deriving or anything like that but we would at least be able to",
    "start": "954910",
    "end": "960550"
  },
  {
    "text": "talk about this thing uniformly is like a functor and we'd be able to write operations that take a functor of some type a and like a morphism from a to b",
    "start": "960550",
    "end": "967690"
  },
  {
    "text": "and produce that functor back of some type b and so we have like functors",
    "start": "967690",
    "end": "973089"
  },
  {
    "text": "running all over the place and if it seems a little bit cheap to go to",
    "start": "973089",
    "end": "978610"
  },
  {
    "text": "functor like functors honestly not that powerful like you can't really do that much with F map it's not really that like great of a tool to program",
    "start": "978610",
    "end": "984519"
  },
  {
    "text": "generically against but here's another example I love it here here's using you know F map on those things there's",
    "start": "984519",
    "end": "992230"
  },
  {
    "text": "another example which is a flat map on an optional so optional has a flat map",
    "start": "992230",
    "end": "997480"
  },
  {
    "text": "operation basically says like if I have this value I can return a new optional and potentially like crush them down and",
    "start": "997480",
    "end": "1003839"
  },
  {
    "text": "say like if I didn't have a value it remains nothing if I did have a value and my function returns and empty then",
    "start": "1003839",
    "end": "1009750"
  },
  {
    "text": "I'm going to remain empty and if I did have a value and my function returns like a present value then I'll remain a present value so it's a way to sort of",
    "start": "1009750",
    "end": "1016649"
  },
  {
    "text": "map into a new instance of the same type and then flatten you know flatten the layers Stream has the exact same",
    "start": "1016649",
    "end": "1022290"
  },
  {
    "text": "operation it's even called flat map completable future has the exact same",
    "start": "1022290",
    "end": "1027600"
  },
  {
    "text": "operation but it's called bin compose this one is really painful to not have a",
    "start": "1027600",
    "end": "1033298"
  },
  {
    "text": "generic representation of because there are lots of like provably correct things that we can do if you satisfy the axioms",
    "start": "1033299",
    "end": "1039720"
  },
  {
    "text": "a flat map and it's not on function function doesn't have any analogue to a flat map but it's like very very easy to",
    "start": "1039720",
    "end": "1046380"
  },
  {
    "text": "implement if anyone wants to take me to task on that we can just implement every work if however we knew that it was a",
    "start": "1046380",
    "end": "1054390"
  },
  {
    "text": "monad which would mean it's implicitly also in applicative then we could do",
    "start": "1054390",
    "end": "1060510"
  },
  {
    "text": "some really really interesting operations so here's the here's the flat map on maybe maybe ism",
    "start": "1060510",
    "end": "1067370"
  },
  {
    "text": "you'll see that it looks like rather similar to what optional was just using just and nothing I tend to win when I",
    "start": "1067370",
    "end": "1076050"
  },
  {
    "text": "have to come up with a name for something I tend to err on the side of ubiquity so if something already has a",
    "start": "1076050",
    "end": "1082050"
  },
  {
    "text": "very well-known sort of term that's Google Bowl like I want I want these things to be goo global if you have a",
    "start": "1082050",
    "end": "1087510"
  },
  {
    "text": "question about how something works I don't want you to just have to like troll through Java Docs all day it'd be great if you could just go to stack it",
    "start": "1087510",
    "end": "1092940"
  },
  {
    "text": "you know Stack Overflow and be like what's a baby but then I can I can pull",
    "start": "1092940",
    "end": "1098880"
  },
  {
    "text": "some really interesting type of level tricks that really don't have anything to do with maybe that only have to do",
    "start": "1098880",
    "end": "1104190"
  },
  {
    "text": "with the generic operations that maybe promises that it supports so this is something that in Haskell is like",
    "start": "1104190",
    "end": "1110850"
  },
  {
    "text": "absolutely invaluable and getting this to work in Java C was a very challenging",
    "start": "1110850",
    "end": "1116730"
  },
  {
    "text": "endeavor getting this to type-check so none of this is vaporware you can",
    "start": "1116730",
    "end": "1121920"
  },
  {
    "text": "copy all of this code and paste it in like a main method and you just need Java 8 or later and this will compile",
    "start": "1121920",
    "end": "1128520"
  },
  {
    "text": "and it'll it'll all work so we can say hey if I've got like 3 maybes really",
    "start": "1128520",
    "end": "1134730"
  },
  {
    "text": "what I do is I want to flip the types I want to say forget about me having to check each one in isolation and like fold through this thing manually convert",
    "start": "1134730",
    "end": "1141690"
  },
  {
    "text": "it into a single maybe that wraps all the values assuming all of them were present and if any of like if anything",
    "start": "1141690",
    "end": "1147150"
  },
  {
    "text": "was absent make the whole thing nothing and I can get that for free I don't I like just from maybe sequence is the",
    "start": "1147150",
    "end": "1153480"
  },
  {
    "text": "method that we're calling it doesn't know anything about maybe like there's nowhere in the source code of sequence that has a reference to maybe it just",
    "start": "1153480",
    "end": "1160440"
  },
  {
    "text": "works on applicative which means that either which is also an applicative works the exact same way and i get it",
    "start": "1160440",
    "end": "1167370"
  },
  {
    "text": "for free and we use this operation all over the place this is extremely helpful",
    "start": "1167370",
    "end": "1174290"
  },
  {
    "text": "we can see some examples later if anyone wants to see you why ok",
    "start": "1174290",
    "end": "1182090"
  },
  {
    "text": "okay lazy eval is a useful default I think it is we deal with dates quite a",
    "start": "1183370",
    "end": "1191510"
  },
  {
    "text": "bit so you might imagine that's actually I think we've written a function like basically exactly like this which is",
    "start": "1191510",
    "end": "1197990"
  },
  {
    "text": "days between using the Java util local date we'll say we have a start date and we have an end date and we really just",
    "start": "1197990",
    "end": "1203870"
  },
  {
    "text": "want to like fully populate that we want a dense representation of all of the dates like through time between those",
    "start": "1203870",
    "end": "1210440"
  },
  {
    "text": "two dates and so if I was just working against like standard vanilla Java I might have very likely write it like",
    "start": "1210440",
    "end": "1216350"
  },
  {
    "text": "this I might use a stream I tend to be very wary of streams the reason is because they're only iterable once and",
    "start": "1216350",
    "end": "1222350"
  },
  {
    "text": "they're extremely susceptible to any sort of like like warranty voiding so if",
    "start": "1222350",
    "end": "1227690"
  },
  {
    "text": "even if I map a stream which is a lazy operation I've effectively like like",
    "start": "1227690",
    "end": "1232790"
  },
  {
    "text": "bricked the instance that I mapped I can't I can no longer interact with that instance without getting an exception I have to constant like I have to do this",
    "start": "1232790",
    "end": "1239090"
  },
  {
    "text": "sort of like almost linear typing strategy where I always have to retain the latest reference and if anyone has",
    "start": "1239090",
    "end": "1244400"
  },
  {
    "text": "interacted with that I better not share it because state has changed so stream is more like an iterator and so I tend",
    "start": "1244400",
    "end": "1250250"
  },
  {
    "text": "to like be very wary of streams if I want to generally represent something that's like an algebraic like linear",
    "start": "1250250",
    "end": "1256640"
  },
  {
    "text": "representation of data so I probably use a list I probably just like do a while",
    "start": "1256640",
    "end": "1263150"
  },
  {
    "text": "loop do a bunch of you know is before checks at it and just allocated on the heap and say you know I hope I hope you",
    "start": "1263150",
    "end": "1270620"
  },
  {
    "text": "don't give me like you know a thousand years between these two things and of course that's exactly what I'm gonna do",
    "start": "1270620",
    "end": "1276950"
  },
  {
    "text": "just to drive the point home and so lists you know lots of days is now massive and then it then it kind of",
    "start": "1276950",
    "end": "1283640"
  },
  {
    "text": "really sucks when later on when it's time to actually read anything from it it turns out we only needed ten of them",
    "start": "1283640",
    "end": "1289040"
  },
  {
    "text": "we you know now we have like this massive GC that is what otherwise have been totally unnecessary and so the way",
    "start": "1289040",
    "end": "1298280"
  },
  {
    "text": "that we probably write that is we probably write it like this we probably say you know there's some like Co inductive function like iterate",
    "start": "1298280",
    "end": "1304850"
  },
  {
    "text": "that takes a start date and takes a function and we'll just produce new values until the cows come home like to",
    "start": "1304850",
    "end": "1311090"
  },
  {
    "text": "positive infinity and then we're going to constrain that and say just think while you know that value is less than the end value",
    "start": "1311090",
    "end": "1318169"
  },
  {
    "text": "and that doesn't run anything until you force it so until you start yielding",
    "start": "1318169",
    "end": "1323250"
  },
  {
    "text": "values out of it like nothing happens that you know that runs in probably like sub ten milliseconds that takes no time",
    "start": "1323250",
    "end": "1328980"
  },
  {
    "text": "at all and so then we do the same exact example only this time we have an",
    "start": "1328980",
    "end": "1334529"
  },
  {
    "text": "iterable of local dates instead of a list because we actually don't care if it's on heap and so then we can just say",
    "start": "1334529",
    "end": "1342510"
  },
  {
    "text": "take tin and we only ever ended up computing ten and if we really really want to memorize it for some reason like",
    "start": "1342510",
    "end": "1347580"
  },
  {
    "text": "let's say this computation is expensive for whatever reason and we only ever want to do it once we can easily like convert it into a list and then just",
    "start": "1347580",
    "end": "1353429"
  },
  {
    "text": "share the list around if we want to but like share a list of the dates you actually care about where there's a lot",
    "start": "1353429",
    "end": "1362700"
  },
  {
    "text": "more to say about lazy eval but in the interest of time we'll move forward on",
    "start": "1362700",
    "end": "1368010"
  },
  {
    "text": "this so partial operations should be included as total operations I'm going",
    "start": "1368010",
    "end": "1373620"
  },
  {
    "text": "to move a little bit more quickly because we're about halfway through at this point so here's another example",
    "start": "1373620",
    "end": "1380159"
  },
  {
    "text": "that I just love to love to kind of make fun of poor poor JDK guys integer % like",
    "start": "1380159",
    "end": "1388740"
  },
  {
    "text": "this is obviously a lie right this interface is just like a fiction right there's there's no way that I can give",
    "start": "1388740",
    "end": "1394350"
  },
  {
    "text": "you any string and get back an integer from this there's no way like this is implicitly like this will throw there",
    "start": "1394350",
    "end": "1400049"
  },
  {
    "text": "and in fact it will throw for like far more values than it won't throw for and so we could represent it as a maybe and",
    "start": "1400049",
    "end": "1406710"
  },
  {
    "text": "say like yeah if you gave me you know the rain in Spain I'll give you back nothing and we we do stuff like this all",
    "start": "1406710",
    "end": "1415679"
  },
  {
    "text": "the time like it's really useful to be able to parse like unstructured input data that might that might actually not be valid representations of our domain",
    "start": "1415679",
    "end": "1422149"
  },
  {
    "text": "and so instead of doing the same sort of integer parse in trick in this case we",
    "start": "1422149",
    "end": "1429330"
  },
  {
    "text": "might actually care so we deal with fixed messages if you don't know what fix messages are your life is better for",
    "start": "1429330",
    "end": "1434429"
  },
  {
    "text": "it effectively it's just like this like terrible like representation of the",
    "start": "1434429",
    "end": "1439980"
  },
  {
    "text": "financial messages that's very painful of course",
    "start": "1439980",
    "end": "1444919"
  },
  {
    "text": "we could represent this as in either of like custom errors or failures or a bunch of things that went wrong and then",
    "start": "1446630",
    "end": "1453080"
  },
  {
    "text": "we won't have to worry about like speculatively being like well should I check this input up front I'm gonna try around it like when do I need to you",
    "start": "1453080",
    "end": "1459440"
  },
  {
    "text": "know when do I need to catch any invocation I'm making in my codebase when should I wrap it in a try like how",
    "start": "1459440",
    "end": "1464990"
  },
  {
    "text": "do I know you have checked exceptions and the type checker can at least force you to deal with it that way the checked exceptions kind of aren't a great idea",
    "start": "1464990",
    "end": "1470450"
  },
  {
    "text": "in general anyway because oftentimes you don't want to impose like what to do like the caller just sends up early",
    "start": "1470450",
    "end": "1476720"
  },
  {
    "text": "throwing in many cases they actually don't care and so to allow them to optimistically deal with the result while just being able to focus on what",
    "start": "1476720",
    "end": "1483890"
  },
  {
    "text": "they actually know how to do is much nicer and that also I mean it only works for checked exceptions unchecked exceptions could happen anywhere so",
    "start": "1483890",
    "end": "1490700"
  },
  {
    "text": "there's there's you know again we're trying to get to a point where what compilation actually gives us quite a bit of confidence and then finally pure",
    "start": "1490700",
    "end": "1501020"
  },
  {
    "text": "and impure operations should be separate the IO monad so here's an example of I",
    "start": "1501020",
    "end": "1508909"
  },
  {
    "text": "don't know just some stupid like I feel like there's an obligatory you know anytime somebody's gonna talk about",
    "start": "1508909",
    "end": "1514400"
  },
  {
    "text": "functional programming either we have to do a banking metaphor or like you know withdraw funds or something or you have",
    "start": "1514400",
    "end": "1520640"
  },
  {
    "text": "to do something involving counting lines and like the Map Reduce example of you know words and and links so let's say",
    "start": "1520640",
    "end": "1528110"
  },
  {
    "text": "that we want to you know just check every line in some file split in Adwords flatten it all give me the unique words",
    "start": "1528110",
    "end": "1536120"
  },
  {
    "text": "and then sort it based on like the longest words so we want the longest",
    "start": "1536120",
    "end": "1541309"
  },
  {
    "text": "words first and then just give me the top ten like give me the ten longest words for some path there's a side",
    "start": "1541309",
    "end": "1547640"
  },
  {
    "text": "effect right in the middle of it which is files dot read all lines if I call that with the wrong path I'll blow up if",
    "start": "1547640",
    "end": "1553070"
  },
  {
    "text": "I you know RM something on my filesystem this will blow up this code is highly",
    "start": "1553070",
    "end": "1559640"
  },
  {
    "text": "highly highly susceptible to like state that is externally managed so I can't",
    "start": "1559640",
    "end": "1566090"
  },
  {
    "text": "really call this with any level of confidence without knowing some other information about who knows like in this",
    "start": "1566090",
    "end": "1571549"
  },
  {
    "text": "case the filesystem could be it could be Google's home page source code like that who knows and so what we would we would",
    "start": "1571549",
    "end": "1578840"
  },
  {
    "text": "tend to do is we would split those two things we would say actually like the majority of that function is pure and that makes",
    "start": "1578840",
    "end": "1584149"
  },
  {
    "text": "it very easy to reason about our output is directly decidable from our input super easy to test really easy to",
    "start": "1584149",
    "end": "1589999"
  },
  {
    "text": "refactor the types are highly reliable in that case and we split out the read lines part and we say put that inside of",
    "start": "1589999",
    "end": "1596720"
  },
  {
    "text": "an i/o and if anyone's interested in more of a deep dive in i/o I'd be very",
    "start": "1596720",
    "end": "1602539"
  },
  {
    "text": "very happy to go into that there are some super cool properties about i/o when you model your application this way",
    "start": "1602539",
    "end": "1609279"
  },
  {
    "text": "so you know here we would just say read lines i/o is a functor in addition to",
    "start": "1609279",
    "end": "1614299"
  },
  {
    "text": "being many other things and so we could just say read lines give it the path and then assuming that everything worked F map the function that we actually want",
    "start": "1614299",
    "end": "1620539"
  },
  {
    "text": "to call and that that again that doesn't run it yet we have to wait until you know the end of the world which is when",
    "start": "1620539",
    "end": "1626389"
  },
  {
    "text": "IO actually happens when the thing you're getting paid to do you actually do and one of the really nice properties",
    "start": "1626389",
    "end": "1634789"
  },
  {
    "text": "about this remember the sequence trick earlier is that we can say well what if we had two paths what if we needed a",
    "start": "1634789",
    "end": "1641059"
  },
  {
    "text": "parse what is that I guess two books A Tale of Two Cities and The Sun Also Rises and we wanted to figure out the",
    "start": "1641059",
    "end": "1646340"
  },
  {
    "text": "ten longest words across both of those things let's say these are really really long books these are slow operations I",
    "start": "1646340",
    "end": "1652720"
  },
  {
    "text": "can just map them into an interval of iOS and then I can do the same type flip and get back a single i/o of an interval",
    "start": "1652720",
    "end": "1659629"
  },
  {
    "text": "of strings again that doesn't run yet and a really nice property about this is that's implicitly paralyzed",
    "start": "1659629",
    "end": "1665539"
  },
  {
    "text": "parallelizable so if you think about what we're doing whenever we're composing and we're writing arrows from",
    "start": "1665539",
    "end": "1672649"
  },
  {
    "text": "A to B and then from B to C there's implicit dependency between those two operations right I can't call B to C",
    "start": "1672649",
    "end": "1678619"
  },
  {
    "text": "until I've called A to B because I need this as an input to my second function but what I've just said up here is that",
    "start": "1678619",
    "end": "1684649"
  },
  {
    "text": "these two paths or orthogonal they're adjacent to each other like their neighbors they don't they don't have any dependency on each other at some point",
    "start": "1684649",
    "end": "1691100"
  },
  {
    "text": "in the future I'm going to need the results from both of them but there's no reason I can't read them in parallel and so I've composed it that way I've said",
    "start": "1691100",
    "end": "1697279"
  },
  {
    "text": "hey put these like adjacently in some lists and then when I call sequence sequence chooses the least powerful way",
    "start": "1697279",
    "end": "1704779"
  },
  {
    "text": "of composing these things which gives you maximum flexibility so it chooses the ability to compose based on the",
    "start": "1704779",
    "end": "1711529"
  },
  {
    "text": "applicative instance rather than the monad instance so there's no dependency between the two and by default this actually will run",
    "start": "1711529",
    "end": "1718130"
  },
  {
    "text": "this on the fork/join pool and parallel eyes those operations and when both of them are done it'll rejoin back and then",
    "start": "1718130",
    "end": "1723560"
  },
  {
    "text": "call flatten on that result and then called you know ten longest words on that result and we could actually give",
    "start": "1723560",
    "end": "1729800"
  },
  {
    "text": "it our own executor if we wanted to like if we didn't want to use the for join pole which it's a good decision to not use that we could create our own",
    "start": "1729800",
    "end": "1736190"
  },
  {
    "text": "executor and pass it into unsafe performing se Cayo and it would parallel lies across that executor cool any",
    "start": "1736190",
    "end": "1745790"
  },
  {
    "text": "questions so far or questions people feel like asking I would say no okay",
    "start": "1745790",
    "end": "1751490"
  },
  {
    "text": "okay so lambda offerings we are about 20",
    "start": "1751490",
    "end": "1757280"
  },
  {
    "text": "minutes out okay lambda offers a model for functors applicative functors monads",
    "start": "1757280",
    "end": "1763400"
  },
  {
    "text": "and all kinds of other crazy stuff common algebraic data types like maybe an either and plenty of others curried",
    "start": "1763400",
    "end": "1770990"
  },
  {
    "text": "functions with specializations like semigroup and mono ed which we're gonna take a look at and what curried",
    "start": "1770990",
    "end": "1776780"
  },
  {
    "text": "functions are for anyone who doesn't know what they are we'll talk about that it's you know I maybe this is a bit you",
    "start": "1776780",
    "end": "1782000"
  },
  {
    "text": "know self gratifying but I think it's a relatively rich library of fictional iteration patterns and open to pull",
    "start": "1782000",
    "end": "1788330"
  },
  {
    "text": "requests if you come up with an interesting one type save heterogeneous data structures like H list and H map",
    "start": "1788330",
    "end": "1794780"
  },
  {
    "text": "when we looked at tupple earlier Tuffle is just a specialized h list pro functor",
    "start": "1794780",
    "end": "1800990"
  },
  {
    "text": "optics which is i would love to talk about those just for like three hours it's very tough to do those justice in",
    "start": "1800990",
    "end": "1808430"
  },
  {
    "text": "any short amount of time but we'll take a brief look at an example of those and",
    "start": "1808430",
    "end": "1813920"
  },
  {
    "text": "then the IO monad there's not really any rhyme or reason for why I chose to like represent each one of these things as",
    "start": "1813920",
    "end": "1819530"
  },
  {
    "text": "bullet points I just think that those are probably some of the most like essential points there's more stuff in here too",
    "start": "1819530",
    "end": "1825880"
  },
  {
    "text": "so we looked at functor we sort of briefly looked at monad there's also an applicative there's a traversable",
    "start": "1826000",
    "end": "1832040"
  },
  {
    "text": "there's monad there's contravariance pro functor there's a bunch of others and",
    "start": "1832040",
    "end": "1837650"
  },
  {
    "text": "you don't necessarily need to know what all of these things are the the thing to take away is that when we have generic",
    "start": "1837650",
    "end": "1843770"
  },
  {
    "text": "operations that we can model generically we get a lot of things for free and so instead of just reinventing than apply",
    "start": "1843770",
    "end": "1848840"
  },
  {
    "text": "or then compose or whatever if you can model them in terms of these things each",
    "start": "1848840",
    "end": "1854000"
  },
  {
    "text": "of these have lots of default methods that you get by providing a like degenerate implementation of one",
    "start": "1854000",
    "end": "1859070"
  },
  {
    "text": "function that gives us a lot of reuse",
    "start": "1859070",
    "end": "1864730"
  },
  {
    "text": "also many of these things are like they they behave in a way that's lawful or",
    "start": "1864730",
    "end": "1869929"
  },
  {
    "text": "axiomatic so we can write property based tests that like just test the laws and if the law is passed like we have high",
    "start": "1869929",
    "end": "1875990"
  },
  {
    "text": "confidence that they won't do anything surprising algebraic data types like",
    "start": "1875990",
    "end": "1882710"
  },
  {
    "text": "maybe in either we've looked at examples of both of these things so I can you",
    "start": "1882710",
    "end": "1887840"
  },
  {
    "text": "know maybe as maybe as lambdas analogue to optional they're there reasons that I",
    "start": "1887840",
    "end": "1896050"
  },
  {
    "text": "added maybe instead of just using Java util optional one of them is so that it can actually be functor and applicative",
    "start": "1896050",
    "end": "1901670"
  },
  {
    "text": "and Monad i've got the expression problem otherwise I can't like elect existing types into those things another",
    "start": "1901670",
    "end": "1906890"
  },
  {
    "text": "reason is because optional has some like unsafe operations I'd rather not offer and F matt and like map behaves kind of",
    "start": "1906890",
    "end": "1915530"
  },
  {
    "text": "weirdly with optional as well it's got an either which doesn't really",
    "start": "1915530",
    "end": "1920540"
  },
  {
    "text": "necessarily have any analog in the JDK a try type which is sort of like a try",
    "start": "1920540",
    "end": "1927500"
  },
  {
    "text": "catch finally statement but as an expression and composable so you can",
    "start": "1927500",
    "end": "1932510"
  },
  {
    "text": "compose to try blocks together you can F map up the right-hand side it's actually a bi functor so you can map both sides",
    "start": "1932510",
    "end": "1938059"
  },
  {
    "text": "you have caching semantics on top of try you have ensuring semantics like finally you have like a try with resources",
    "start": "1938059",
    "end": "1944200"
  },
  {
    "text": "expression that does the same thing as Java seven strive with resources it's just basically an expression version of",
    "start": "1944200",
    "end": "1949640"
  },
  {
    "text": "try choice two which is just like either but without implicit success and failure",
    "start": "1949640",
    "end": "1956870"
  },
  {
    "text": "semantics so there's nothing wrong with getting a string back from a choice to for instance there's no function that's like or else like or else what what's",
    "start": "1956870",
    "end": "1963470"
  },
  {
    "text": "the problem with either of these two things so choice two is what we use to just say it's one of these two things but we don't really have any like",
    "start": "1963470",
    "end": "1969350"
  },
  {
    "text": "affection for one over the other these which is kind of an interesting and like",
    "start": "1969350",
    "end": "1975020"
  },
  {
    "text": "uncommon data type but probably useful anyway which is just basically saying like I have either a string or an",
    "start": "1975020",
    "end": "1980570"
  },
  {
    "text": "integer I have both but I won't have neither and unit is probably the last one I'm going",
    "start": "1980570",
    "end": "1987049"
  },
  {
    "text": "to mention here there's actually a bunch others but unit is useful because it represents like nothing interesting it's",
    "start": "1987049",
    "end": "1993110"
  },
  {
    "text": "sort of like you know like in Haskell you'll have like the parens sort of the unit data type and it basically says like move along like there's nothing",
    "start": "1993110",
    "end": "1999049"
  },
  {
    "text": "else to see here so I see a function that takes unit and returns an integer that implicitly tells me this is a",
    "start": "1999049",
    "end": "2004059"
  },
  {
    "text": "supplier because I can't give it any context that could possibly be used to yield its return value so curried",
    "start": "2004059",
    "end": "2015700"
  },
  {
    "text": "functions with specializations like semigroup and mono omoide currying is a strategy very briefly it's a strategy",
    "start": "2015700",
    "end": "2021669"
  },
  {
    "text": "for it comes from the lambda calculus and it is a way to represent a function of any era T as a function with a single",
    "start": "2021669",
    "end": "2027820"
  },
  {
    "text": "era T by using scope closure so if we said we have an F in two which is sort",
    "start": "2027820",
    "end": "2034330"
  },
  {
    "text": "of like lambda analog to by function of integer integer integer and we're gonna",
    "start": "2034330",
    "end": "2039850"
  },
  {
    "text": "say that that's just integer sum that's actually the same as saying it's a function from integer to a function from",
    "start": "2039850",
    "end": "2045460"
  },
  {
    "text": "integer to integer that just close the scope over the outer like the free variable and so that's actually directly",
    "start": "2045460",
    "end": "2052059"
  },
  {
    "text": "assignable there's no coercion that's necessary that's that's exactly the same thing which means that we can like",
    "start": "2052059",
    "end": "2058089"
  },
  {
    "text": "partial application as a notion is not really like there like partial",
    "start": "2058089",
    "end": "2063460"
  },
  {
    "text": "application is just application there's nothing partial about it it's just application we could give it both you",
    "start": "2063460",
    "end": "2072128"
  },
  {
    "text": "know we could give it as many arguments as we possibly can if we want but we could also just give it the first thing that it needs and take the result and",
    "start": "2072129",
    "end": "2078579"
  },
  {
    "text": "then if we wanted to let's say like fix the argument but not actually run it yet like defer it then we could you know",
    "start": "2078579",
    "end": "2085809"
  },
  {
    "text": "thunk it and then pass that thing around and now the consumer the onus is no longer on them to provide any more",
    "start": "2085809",
    "end": "2090819"
  },
  {
    "text": "information but we haven't ran like we haven't run anything until they force it and so then we can represent useful",
    "start": "2090819",
    "end": "2100359"
  },
  {
    "text": "encapsulations like semigroup so a semigroup very briefly is a binary associative operation that like can't escape integer",
    "start": "2100359",
    "end": "2108220"
  },
  {
    "text": "so I couldn't give it like it basically means it so it's binary there's two things that it takes two integers it should be an associative operation",
    "start": "2108220",
    "end": "2114880"
  },
  {
    "text": "so however it associates with brains like f of you know a F of BC should be",
    "start": "2114880",
    "end": "2120279"
  },
  {
    "text": "equivalent to F of F ABC not necessarily commutative but the thing that's",
    "start": "2120279",
    "end": "2125470"
  },
  {
    "text": "interesting about this is if you represent integer sum as a semigroup i can give you a fold for free and then i",
    "start": "2125470",
    "end": "2135309"
  },
  {
    "text": "could graduate that to a mono wade so i could say hey if i've got an identity element as well an element that like f of identity of X is always equal to X",
    "start": "2135309",
    "end": "2143549"
  },
  {
    "text": "like for summing 0 would be the identity I can graduate that to a mono and then I",
    "start": "2143549",
    "end": "2149109"
  },
  {
    "text": "get the fold that doesn't require the starting accumulator which I call reduce and I also get this really really useful",
    "start": "2149109",
    "end": "2154839"
  },
  {
    "text": "function called fold map and I can like implement short-circuiting with fold map and then reduce and fold all",
    "start": "2154839",
    "end": "2160720"
  },
  {
    "text": "short-circuit if I said like you know here's a semigroup over or here's a mono omoide over like a list of maybes then",
    "start": "2160720",
    "end": "2168700"
  },
  {
    "text": "the first nothing I could just like short-circuit and not run any others because I know the results gonna be nothing we do this quite a bit as well",
    "start": "2168700",
    "end": "2176039"
  },
  {
    "text": "mono heads also compose semigroups compose so like going through the effort",
    "start": "2176039",
    "end": "2181150"
  },
  {
    "text": "which is not terribly much effort which you already have an F into like you basically got a semigroup is worth it",
    "start": "2181150",
    "end": "2189269"
  },
  {
    "text": "[Music] something is not clicking okay",
    "start": "2192220",
    "end": "2203249"
  },
  {
    "text": "functional iteration patterns like map and filter we've seen some of these already Hey it seems my keyboard may",
    "start": "2203789",
    "end": "2215739"
  },
  {
    "text": "have just given out sorry bear with me one thing",
    "start": "2215739",
    "end": "2222269"
  },
  {
    "text": "hmm well guess that's the end of the talk uh",
    "start": "2227559",
    "end": "2234730"
  },
  {
    "text": "let's see I don't know",
    "start": "2234730",
    "end": "2239460"
  },
  {
    "text": "anyone think it's going to work this time no probably not",
    "start": "2248190",
    "end": "2254420"
  },
  {
    "text": "yeah all right well okay so we could say like you know hey let's start with you",
    "start": "2254420",
    "end": "2261360"
  },
  {
    "text": "know taking advantage of laziness let's start with just the representation of all the natural numbers and yeah this is",
    "start": "2261360",
    "end": "2266550"
  },
  {
    "text": "pretty contrived but it at least gives you like a sense of the types of operations you can do get the you know get the evens out none of this stuff",
    "start": "2266550",
    "end": "2272400"
  },
  {
    "text": "runs by the way until we actually start yelling values so you know like none of this does none of this runs anything",
    "start": "2272400",
    "end": "2279240"
  },
  {
    "text": "even the end even the map at the end doesn't do anything but we can say you know take the squares and then take the",
    "start": "2279240",
    "end": "2285000"
  },
  {
    "text": "first hundred and then get rid of all the squares that are below you know twenty five hundred so start it like 51",
    "start": "2285000",
    "end": "2290370"
  },
  {
    "text": "I guess and then group those in groups of ten and then sum each of those tins I",
    "start": "2290370",
    "end": "2296040"
  },
  {
    "text": "don't know I came up with that like on the fly I don't know if you'd ever want to do this but there's a lot of stuff you can do oh it seems to work again",
    "start": "2296040",
    "end": "2303420"
  },
  {
    "text": "okay let's okay types of heterogeneous data structures like H list in H map",
    "start": "2303420",
    "end": "2311510"
  },
  {
    "text": "tuples are usually what you're going to want to use for these do we have ten",
    "start": "2311510",
    "end": "2316800"
  },
  {
    "text": "minutes is it ten minutes left okay I'm gonna try to blow through these last ones and then if anyone wants to see anything in editor we can do it so you",
    "start": "2316800",
    "end": "2324570"
  },
  {
    "text": "know an H list is a heterogeneous list it's yeah you can think of like normal lists in Java you'll see like list of",
    "start": "2324570",
    "end": "2330780"
  },
  {
    "text": "string or something that's a homogenous list that says that every element is the same type in it's a string in H list",
    "start": "2330780",
    "end": "2337110"
  },
  {
    "text": "doesn't care about you know all the elements being the same it allows you to typify the element type for each slot so",
    "start": "2337110",
    "end": "2344640"
  },
  {
    "text": "you can say you know I have a singleton H list which has one slot and the value stored in that is a string and if I cons",
    "start": "2344640",
    "end": "2350010"
  },
  {
    "text": "onto the front of that you know then I'll then I'll have a different you know I'll have a different value at the front",
    "start": "2350010",
    "end": "2355620"
  },
  {
    "text": "but I'll still retain a string in the second slot and so there's a couple ways for us to construct these we could start with a nil if we wanted to there's a",
    "start": "2355620",
    "end": "2361050"
  },
  {
    "text": "static factory method singleton H list that's just a convenience and then if we started with meoli we cons three times",
    "start": "2361050",
    "end": "2367050"
  },
  {
    "text": "right remember this is cons so it puts it at the front so say cons one makes it a singleton integer two makes it a",
    "start": "2367050",
    "end": "2372450"
  },
  {
    "text": "couple two string integer three makes it a float double three float string integer and the main reason for the",
    "start": "2372450",
    "end": "2378660"
  },
  {
    "text": "tuples is because it can be a bit laborious at the type level to have to retain this",
    "start": "2378660",
    "end": "2384360"
  },
  {
    "text": "like linearly expanding recursive type signature which is like H cons of string comma H cons of float comma HK and then",
    "start": "2384360",
    "end": "2391590"
  },
  {
    "text": "like just you know a one-to-one correspondence from the types to the you know to the calls to cons and also",
    "start": "2391590",
    "end": "2397680"
  },
  {
    "text": "there's no really easy way if you just know it's like a singly linked list to get the third element you have to",
    "start": "2397680",
    "end": "2402690"
  },
  {
    "text": "traverse it yourself you have to say like tail tail tail head or something whereas a tupple will give you random",
    "start": "2402690",
    "end": "2408180"
  },
  {
    "text": "access to each one of those elements so I can call like you know on the tupple for where I've got a byte short integer",
    "start": "2408180",
    "end": "2414180"
  },
  {
    "text": "long I can say dot underscore three to get the integer out and then I can also pop you know pop the head off of that",
    "start": "2414180",
    "end": "2421320"
  },
  {
    "text": "tumble for to get back to a tuple 3 and anyway it's tuples like tuples whatever",
    "start": "2421320",
    "end": "2426390"
  },
  {
    "text": "yr tuples not in java I don't know",
    "start": "2426390",
    "end": "2430279"
  },
  {
    "text": "keyboard well sub H maps H maps are",
    "start": "2432770",
    "end": "2442070"
  },
  {
    "text": "analogous for maps what H lists are for lists perhaps unsurprisingly the question though becomes how do you",
    "start": "2442070",
    "end": "2447750"
  },
  {
    "text": "actually encode the mapping of the value at a key if you want to say that you know two keys in the same map or sorry",
    "start": "2447750",
    "end": "2454290"
  },
  {
    "text": "like two different keys in the map can point to do two different value types this is no longer map string to integer",
    "start": "2454290",
    "end": "2459600"
  },
  {
    "text": "where every string points to an integer this key may point to an integer this mate key may point to like a list and I",
    "start": "2459600",
    "end": "2464730"
  },
  {
    "text": "want to know at compile time that I've actually interacted with this thing in a type safe way so there's a type safe key type that is a default key you can it's",
    "start": "2464730",
    "end": "2473970"
  },
  {
    "text": "just an interface so you can create your own types of keys if you like based on labels or whatever you want to do and then we can you know put in H map you",
    "start": "2473970",
    "end": "2481650"
  },
  {
    "text": "know values of the right type if I was to change that string to an integer by Fuki it would no longer compile and then",
    "start": "2481650",
    "end": "2488850"
  },
  {
    "text": "I can you know do normal map stuff I can check if you know it contains a key or whatever and then the default interface is get because how do you know if you",
    "start": "2488850",
    "end": "2496020"
  },
  {
    "text": "actually have set that you know key inside the map but if you're really really positive like you're absolutely",
    "start": "2496020",
    "end": "2501690"
  },
  {
    "text": "sure you're like I just did it right here it better be in that map called demand and you know that'll throw if it",
    "start": "2501690",
    "end": "2507180"
  },
  {
    "text": "doesn't have it so hey keep having to do this my",
    "start": "2507180",
    "end": "2512830"
  },
  {
    "text": "keyboard like legitimately is somehow not working anymore so provoked our",
    "start": "2512830",
    "end": "2518200"
  },
  {
    "text": "optics like Linz and I so let's take a look at a lens a simple lens that's built in and then we can look at this",
    "start": "2518200",
    "end": "2523900"
  },
  {
    "text": "more in depth or if you I mean we're running out of time so if any wants to talk about these more come talk to me",
    "start": "2523900",
    "end": "2529660"
  },
  {
    "text": "after the talk there's a lens that's element at just focuses at the first elements of a list as a maybe",
    "start": "2529660",
    "end": "2536500"
  },
  {
    "text": "so if the list is not you know if it's empty then you'll get back nothing if it's got a null in that slot you'll also",
    "start": "2536500",
    "end": "2542830"
  },
  {
    "text": "get back nothing so there's a sort of correspondence between you know not you know not being that size or having a",
    "start": "2542830",
    "end": "2549880"
  },
  {
    "text": "null in there otherwise you'll get back to value that it's supposed to be and this unifies across the list type to",
    "start": "2549880",
    "end": "2556210"
  },
  {
    "text": "the maybe type so if I try to perturb either of those types if I changed list on the first line to like string but",
    "start": "2556210",
    "end": "2561280"
  },
  {
    "text": "left them maybe integer that one type check anymore and there's like three canonical operations that you tend to be",
    "start": "2561280",
    "end": "2567310"
  },
  {
    "text": "able to do with lenses in addition to being able to compose them in both directions you can also say like view the element at it so just like lift the",
    "start": "2567310",
    "end": "2573700"
  },
  {
    "text": "element out when you focus it and I you know view is just a function it's it's a lambda F n so it it scurried so I can",
    "start": "2573700",
    "end": "2581110"
  },
  {
    "text": "just pass it the lens and get back a function that will take a list and return it maybe or I can pass it everything that it needs all at once I",
    "start": "2581110",
    "end": "2586300"
  },
  {
    "text": "can save you the first element with an empty list to get back nothing view the first element with a list one two three to get back just one I can also call",
    "start": "2586300",
    "end": "2592930"
  },
  {
    "text": "over to potentially update that value again these are these are very basic operations that are possible lenses and",
    "start": "2592930",
    "end": "2601150"
  },
  {
    "text": "say like hey if you had a value then F map it you know add one to it otherwise don't do anything to it and then set is just a degenerate version of over that",
    "start": "2601150",
    "end": "2607840"
  },
  {
    "text": "just call like constantly on the function side so I can put a value in if",
    "start": "2607840",
    "end": "2612910"
  },
  {
    "text": "I wanted to right I can say I have an empty list set just one to the front of it and now I have a singleton list where one is the first element I didn't talk",
    "start": "2612910",
    "end": "2620020"
  },
  {
    "text": "about ISOs here but lenses are like a good enough probably example we can talk about Isis afterwards people",
    "start": "2620020",
    "end": "2627300"
  },
  {
    "text": "and then the IO monad so here's a useful example I already talked about the auto",
    "start": "2630820",
    "end": "2635840"
  },
  {
    "text": "parallelism capability let's say that we have this function thread log or this method thread log rather that's just",
    "start": "2635840",
    "end": "2640940"
  },
  {
    "text": "gonna get the current thread that it's running on inside of an IO and then it's gonna print whatever the messages if we",
    "start": "2640940",
    "end": "2647120"
  },
  {
    "text": "said you know log hello and then write so flat map remember flat map says I can't run this until I have the previous",
    "start": "2647120",
    "end": "2653420"
  },
  {
    "text": "operation because I might need the previous result to produce the next result so it's sequential eise's these",
    "start": "2653420",
    "end": "2658610"
  },
  {
    "text": "things so hello and then print world if I said just unsafe perform I oh that's just gonna run it synchronously and it's",
    "start": "2658610",
    "end": "2664370"
  },
  {
    "text": "gonna print hello world to standard out which is exactly what we told it to do but I could also choose to say I'm",
    "start": "2664370",
    "end": "2674540"
  },
  {
    "text": "googling key node bugs with keyboard after this so I can also say hey unsafe",
    "start": "2674540",
    "end": "2680390"
  },
  {
    "text": "perform async IO to get a completable future back that will be running right it'll start running automatically and",
    "start": "2680390",
    "end": "2685810"
  },
  {
    "text": "even though world won't be printed until Hello is printed they'll probably be printed from different threads so that",
    "start": "2685810",
    "end": "2698570"
  },
  {
    "text": "is the i/o monad at this point I was going to do a demo but I've got five minutes so it's probably best to leave",
    "start": "2698570",
    "end": "2705110"
  },
  {
    "text": "that open for questions last slide is this is lambda that's where it is on",
    "start": "2705110",
    "end": "2710510"
  },
  {
    "text": "github it's released under the MIT license and there's a git er channel - if that's your thing I'm in there",
    "start": "2710510",
    "end": "2716030"
  },
  {
    "text": "there's some other people that are in there that we can answer questions or discuss like new features that should be",
    "start": "2716030",
    "end": "2721670"
  },
  {
    "text": "added or things like that remember to rate this session please if",
    "start": "2721670",
    "end": "2726950"
  },
  {
    "text": "you rate it terribly they will never invite people like me back so like you know be be honest with your feedback and",
    "start": "2726950",
    "end": "2733850"
  },
  {
    "text": "that's all I got",
    "start": "2733850",
    "end": "2736990"
  }
]