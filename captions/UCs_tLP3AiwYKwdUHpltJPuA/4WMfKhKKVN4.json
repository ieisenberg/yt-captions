[
  {
    "start": "0",
    "end": "105000"
  },
  {
    "text": "thank you very much Mark for that introduction um let's see back up a little bit here",
    "start": "4880",
    "end": "10380"
  },
  {
    "text": "there we go so uh yesterday uh John shared a very",
    "start": "10380",
    "end": "15839"
  },
  {
    "text": "inspiring and rousing message with us about the the gems of our our history so far in in functional programming uh and",
    "start": "15839",
    "end": "23160"
  },
  {
    "text": "and particular uh highlighted some of my favorite uh most formative papers and",
    "start": "23160",
    "end": "29580"
  },
  {
    "text": "one of those papers is this one by Peter land in the next 700 programming languages this is a very very important",
    "start": "29580",
    "end": "35820"
  },
  {
    "text": "paper and Peter Lannon is a very important uh figure in our field if you haven't read this paper read it if",
    "start": "35820",
    "end": "41100"
  },
  {
    "text": "you've read this paper read it again um and this is the seminal paper in which uh he introduced to the idea that",
    "start": "41100",
    "end": "47760"
  },
  {
    "text": "we now call domain specific embedded languages and uh and um Peter's main message is is",
    "start": "47760",
    "end": "55079"
  },
  {
    "text": "that we don't need to keep designing languages we rarely need to keep designing a new languages much more",
    "start": "55079",
    "end": "60480"
  },
  {
    "text": "often want to design new vocabularies and host them within a consistent well-founded well-designed harmonious",
    "start": "60480",
    "end": "66560"
  },
  {
    "text": "framework provided by a language and it was his recommendation to use a type Lambda calculus",
    "start": "66560",
    "end": "72360"
  },
  {
    "text": "okay so in the in the spirit of uh of this paper I want to talk about embracing",
    "start": "72360",
    "end": "80220"
  },
  {
    "text": "this message and then going a little further and reducing even our need to Define new vocabularies and getting more",
    "start": "80220",
    "end": "86100"
  },
  {
    "text": "mileage out of some of our old vocabularies so I'm going to be talking about ways to",
    "start": "86100",
    "end": "92220"
  },
  {
    "text": "interpret ways to understand our functional programs that are beyond the ones that we habitually bring at least",
    "start": "92220",
    "end": "98939"
  },
  {
    "text": "the ones that I habitually bring to understanding and thinking about functional programs so I want to start with a very simple expression you can",
    "start": "98939",
    "end": "106200"
  },
  {
    "start": "105000",
    "end": "288000"
  },
  {
    "text": "you know imagine this is an Haskell or ml or you know whatever language you want and ask the question what does this",
    "start": "106200",
    "end": "111840"
  },
  {
    "text": "mean what does this expression mean well it really depends it depends on X",
    "start": "111840",
    "end": "118140"
  },
  {
    "text": "and Y right there are a couple of free variables here so to understand this expression we have to know what X and Y are or we abstract them out the Lambda",
    "start": "118140",
    "end": "125100"
  },
  {
    "text": "abstraction so I'm going to be using Haskell notation um I I hope it's mostly familiar to you",
    "start": "125100",
    "end": "132739"
  },
  {
    "text": "if it's not you know interrupt ask a question I really want everybody to follow what I'm talking about here so",
    "start": "132739",
    "end": "138540"
  },
  {
    "text": "there's a Lambda abstract this means a function of arguments we're going to call X and Y that results in the value X",
    "start": "138540",
    "end": "144420"
  },
  {
    "text": "plus 3 times y okay so now it no longer depends on X and Y because it's a function it's",
    "start": "144420",
    "end": "149760"
  },
  {
    "text": "explicitly a function all right however it still depends on the meaning of plus and times and even three",
    "start": "149760",
    "end": "157800"
  },
  {
    "text": "so it's a kind of an easy thing to take to take for granted so what do I mean by it you know it depends",
    "start": "157800",
    "end": "164519"
  },
  {
    "text": "well there are variety of ways that we can interpret multiplication and addition and even the number three so",
    "start": "164519",
    "end": "170280"
  },
  {
    "text": "for instance you know we have some familiar types in programming the types in hats will and float and",
    "start": "170280",
    "end": "176519"
  },
  {
    "text": "double so these are you know finite Precision the sort of machine Precision operations on um on you know integer and",
    "start": "176519",
    "end": "185160"
  },
  {
    "text": "an approximate real values we can go beyond these values and more mathematically traditional types and we",
    "start": "185160",
    "end": "191280"
  },
  {
    "text": "have the type of integers natural numbers rationals reals complex okay so",
    "start": "191280",
    "end": "196500"
  },
  {
    "text": "should be familiar to you from uh from mathematics however there are you know even more interesting types we could",
    "start": "196500",
    "end": "202440"
  },
  {
    "text": "look at we could look at higher dimensional types vectors so polynomials or entire functions all",
    "start": "202440",
    "end": "208620"
  },
  {
    "text": "right so one of the main things that John shared with us yesterday which is uh is so powerful it is this idea of",
    "start": "208620",
    "end": "217200"
  },
  {
    "text": "dealing with large values of of you know kind of whole whole systems uh uh functions streams uh trees you know",
    "start": "217200",
    "end": "224700"
  },
  {
    "text": "including in particularly infinite values so we might be doing uh arithmetic on functions perfectly well",
    "start": "224700",
    "end": "231000"
  },
  {
    "text": "defined as a nice you know mathematical history of doing so but there are more kind of modern uh meaning you know in",
    "start": "231000",
    "end": "238500"
  },
  {
    "text": "the last uh say 60 years interpretations as well we might be talking about regular expressions or other kinds of languages",
    "start": "238500",
    "end": "245159"
  },
  {
    "text": "regular Expressions denote languages and then there are more abstract Notions we can talk about uh computation or uh",
    "start": "245159",
    "end": "254640"
  },
  {
    "text": "functions over arbitrary Rings or or semi-rings or you know other algebraic",
    "start": "254640",
    "end": "259799"
  },
  {
    "text": "Notions so they're really kind of a wide variety of possible interpretations that we can bring to our programs",
    "start": "259799",
    "end": "265860"
  },
  {
    "text": "however it's not necessarily a good idea to bring sort of random interpretations right which we do find in some languages",
    "start": "265860",
    "end": "272880"
  },
  {
    "text": "I think we got in in bodils talk some some reminders that there are languages in which seem to be quite you know",
    "start": "272880",
    "end": "278400"
  },
  {
    "text": "arbitrary interpretations just uh uh you know anything possible as long as we",
    "start": "278400",
    "end": "283560"
  },
  {
    "text": "give this expression some interpretation so I don't think we want to go that far fortunately we have a few hundred years",
    "start": "283560",
    "end": "289620"
  },
  {
    "start": "288000",
    "end": "583000"
  },
  {
    "text": "of experience with a rather well-developed discipline of organizing interpretations of operations and this",
    "start": "289620",
    "end": "298259"
  },
  {
    "text": "comes from the field that we call abstract algebra so if you've had some linear algebra in in college maybe a",
    "start": "298259",
    "end": "304259"
  },
  {
    "text": "little more advanced courses an abstract algebra you will have encountered Notions like monoids uh",
    "start": "304259",
    "end": "311820"
  },
  {
    "text": "groups semi groups Rings fields and so on okay or vector spaces a little bit",
    "start": "311820",
    "end": "318840"
  },
  {
    "text": "more General notion called modules in the world of functional programming you probably have encountered these",
    "start": "318840",
    "end": "325320"
  },
  {
    "text": "Notions of functors applicative functors monads foldables traversables and so on",
    "start": "325320",
    "end": "330840"
  },
  {
    "text": "so the these are abstractions that are over structures so over shapes one might",
    "start": "330840",
    "end": "336960"
  },
  {
    "text": "say informally rather than individual values and they're singly parameterized types",
    "start": "336960",
    "end": "343320"
  },
  {
    "text": "and then we can have also have a doubly parameterized types which are function like things",
    "start": "343320",
    "end": "348660"
  },
  {
    "text": "so for instance we call categories or arrows and and in such context we have Notions",
    "start": "348660",
    "end": "355500"
  },
  {
    "text": "of products and co-products also uh known as sums more uh more concretely exponentials and so on",
    "start": "355500",
    "end": "361680"
  },
  {
    "text": "so we have a rich history and uh um working set of tools for dealing with",
    "start": "361680",
    "end": "368160"
  },
  {
    "text": "abstractions that allow us to generalize but in a principled way",
    "start": "368160",
    "end": "374460"
  },
  {
    "text": "and why does this matter well it matters for a variety of reasons one is maybe just Joy it's a it can be a",
    "start": "374460",
    "end": "381660"
  },
  {
    "text": "pleasurable experience to you know explore worlds of mathematics uh and there's a certain you know",
    "start": "381660",
    "end": "388380"
  },
  {
    "text": "aesthetic and a guiding discipline that leads us to discover wonderful things there are also very sort of concrete",
    "start": "388380",
    "end": "396380"
  },
  {
    "text": "benefits which is found in reuse okay so mathematics mathematicians",
    "start": "396380",
    "end": "402479"
  },
  {
    "text": "develop these sort of abstractions in order to reuse their work so you may have you know done a lot of",
    "start": "402479",
    "end": "408960"
  },
  {
    "text": "work and proved a theorem that has to do with the natural numbers go back and look at that proof and it",
    "start": "408960",
    "end": "415080"
  },
  {
    "text": "turns out that well I only used a few properties of natural numbers and so I could replay this same proof in a",
    "start": "415080",
    "end": "422280"
  },
  {
    "text": "different setting okay or I could abstract the proof and and make a proof that is about a",
    "start": "422280",
    "end": "430259"
  },
  {
    "text": "more general setting okay and that's where we get these ideas of you know rings and groups and monoids",
    "start": "430259",
    "end": "436080"
  },
  {
    "text": "and so on now in the world of programming we do exactly the same thing okay we call it code reuse right instead",
    "start": "436080",
    "end": "442380"
  },
  {
    "text": "of instead of a theorem generalization but it lets us do more with less",
    "start": "442380",
    "end": "448380"
  },
  {
    "text": "okay that's always a good thing so as a concrete example in our world we have uh",
    "start": "448380",
    "end": "454560"
  },
  {
    "text": "in Haskell this notion of folds of course we have in all of the language I think that we're using uh Haskell has a",
    "start": "454560",
    "end": "460139"
  },
  {
    "text": "you know uh has its own particulars a fold is a computation that works over a",
    "start": "460139",
    "end": "465240"
  },
  {
    "text": "structure and that structure has to have this property of being foldable but also the structure has to contain elements that",
    "start": "465240",
    "end": "471539"
  },
  {
    "text": "are combinable okay in an associative way and that's what we call a monoid so fold is an",
    "start": "471539",
    "end": "477000"
  },
  {
    "text": "operation that works on on structures as long as they're foldable containing elements as long as they're monoids",
    "start": "477000",
    "end": "483539"
  },
  {
    "text": "so this is an example of organizing interpretations to now I want to come back to this original question of what does this",
    "start": "483539",
    "end": "489479"
  },
  {
    "text": "expression mean and remember I said it depends on the meaning of addition to multiplication and even three",
    "start": "489479",
    "end": "495300"
  },
  {
    "text": "and so now we have some notion of uh in what way it can depend well we might say",
    "start": "495300",
    "end": "501780"
  },
  {
    "text": "that addition multiplication come from a ring and this is an expression that works over arbitrary rings for instance",
    "start": "501780",
    "end": "507900"
  },
  {
    "text": "okay however there are some more operations in in this expression that are even more fundamental to programming",
    "start": "507900",
    "end": "514080"
  },
  {
    "text": "than addition to multiplication and three well it's a bit odd calling them operations well what I mean here is is a",
    "start": "514080",
    "end": "521880"
  },
  {
    "text": "Lambda abstraction itself and variables in the notion of application okay so going more to the center the",
    "start": "521880",
    "end": "529320"
  },
  {
    "text": "heart of our programming languages you know what what computation is about we have these very fundamental Notions",
    "start": "529320",
    "end": "536060"
  },
  {
    "text": "however in our programming language at least in Haskell we can't overload them because we can't assign them a variety",
    "start": "536060",
    "end": "542519"
  },
  {
    "text": "of interpretations Lambda always means one kind of thing which is a function",
    "start": "542519",
    "end": "547920"
  },
  {
    "text": "application is only something that you can do with functions not other kind of function like things",
    "start": "547920",
    "end": "554279"
  },
  {
    "text": "so this is quite restrictive because we have Lambda abstractions very powerful mechanism for wealth for abstraction and",
    "start": "554279",
    "end": "561839"
  },
  {
    "text": "reuse and so is overloading which is just this algebraic discipline and I bet we could really get a lot of",
    "start": "561839",
    "end": "567899"
  },
  {
    "text": "power out of being able to overload Lambda but we can't do it all right",
    "start": "567899",
    "end": "573480"
  },
  {
    "text": "however we can still think about what if there is a way what if there were a way what could we",
    "start": "573480",
    "end": "579360"
  },
  {
    "text": "do with such power and then how can we do it okay so this is what my talk is about today",
    "start": "579360",
    "end": "584820"
  },
  {
    "start": "583000",
    "end": "718000"
  },
  {
    "text": "now why would we want to overload Lambda when I say overload Lambda is a shorthand for overloading the the",
    "start": "584820",
    "end": "589980"
  },
  {
    "text": "fundamental Notions of the fundamental operations so to speak in our programming languages Lambda variables",
    "start": "589980",
    "end": "596100"
  },
  {
    "text": "and uh application okay so I want to do this for exactly the same reason we wanted to do it for uh for say",
    "start": "596100",
    "end": "602220"
  },
  {
    "text": "arithmetic for instance images that we get a generalized interpretation much broader application",
    "start": "602220",
    "end": "607680"
  },
  {
    "text": "and we do it in a disciplined way so we can still prove things we can still reason with rigor even in this quite",
    "start": "607680",
    "end": "613560"
  },
  {
    "text": "general setting and what we get as I mentioned before is is modular reusable reasoning and",
    "start": "613560",
    "end": "619320"
  },
  {
    "text": "programming okay now why overload Lambda specifically",
    "start": "619320",
    "end": "624480"
  },
  {
    "text": "rather than just the same old reasons what do we get well Lambda is a very convenient notation for functions and",
    "start": "624480",
    "end": "631380"
  },
  {
    "text": "that's why we're still using it so Almanzo Church introduced the untyped Lambda calculus in the 30s and the type Lambda calculus in the 40s and we have",
    "start": "631380",
    "end": "638399"
  },
  {
    "text": "gotten and continue to get a huge amount of Leverage of play out of um out of this notation",
    "start": "638399",
    "end": "645600"
  },
  {
    "text": "okay so there are a lot of things that we can",
    "start": "645600",
    "end": "651660"
  },
  {
    "text": "almost do but not quite do with our programming languages so I use uh Haskell and I use the Glasgow Glasgow",
    "start": "651660",
    "end": "658440"
  },
  {
    "text": "over there nowadays the Glorious Haskell compiler and that compiler generates object code for uh",
    "start": "658440",
    "end": "665160"
  },
  {
    "text": "roughly sequential processor okay in a process that pretends to be sequential anyway",
    "start": "665160",
    "end": "670560"
  },
  {
    "text": "but I like very high performance and very sort of novel implementations of of",
    "start": "670560",
    "end": "677279"
  },
  {
    "text": "the the programs I play with and so I want to generate uh optimized GPU code",
    "start": "677279",
    "end": "682500"
  },
  {
    "text": "run it massively in parallel or even more so in parallel or or more oddly or more irregularly I want to generate",
    "start": "682500",
    "end": "689160"
  },
  {
    "text": "circuits either as an actual Hardware Asics or or say something like an fpga",
    "start": "689160",
    "end": "696480"
  },
  {
    "text": "and then some settings there's uh you know a lot of value in generating some kind of Web format in particular",
    "start": "696480",
    "end": "702300"
  },
  {
    "text": "JavaScript code okay so JavaScript we have a few ways to generate from uh from Haskell",
    "start": "702300",
    "end": "708779"
  },
  {
    "text": "compilation but we don't really have any standard we have just now sort of emerging tools for generating things",
    "start": "708779",
    "end": "714060"
  },
  {
    "text": "like circuits or uh or GPU code so that's one reason that I might want to overload Lambda is that I want to",
    "start": "714060",
    "end": "720440"
  },
  {
    "start": "718000",
    "end": "918000"
  },
  {
    "text": "generate something that is it's essentially a function but I want to do a different sort of back end a very",
    "start": "720440",
    "end": "726720"
  },
  {
    "text": "different sort of back end from a sequential processor here's a quite different reason for wanting to extend the reach of my Lambda",
    "start": "726720",
    "end": "735899"
  },
  {
    "text": "calculus you know my functional programs programs which is that I want",
    "start": "735899",
    "end": "741120"
  },
  {
    "text": "things that are functions or like functions but have more abilities so for instance I want to have differentiable",
    "start": "741120",
    "end": "746880"
  },
  {
    "text": "functions so I write a Haskell program it denotes a function mathematically we",
    "start": "746880",
    "end": "752579"
  },
  {
    "text": "know that many functions are differentiable in the calculus sense continuously",
    "start": "752579",
    "end": "757980"
  },
  {
    "text": "differentiable however I can't differentiate my Haskell program",
    "start": "757980",
    "end": "763139"
  },
  {
    "text": "I can use some sort of library that gives me an alternative notation",
    "start": "763139",
    "end": "768540"
  },
  {
    "text": "right this would be some sort of domain specific language and and using that notation instead of",
    "start": "768540",
    "end": "774300"
  },
  {
    "text": "my notation I could do something like differentiation but this is a real shame because I",
    "start": "774300",
    "end": "779940"
  },
  {
    "text": "already have a notation for functions and functions have this notion of differentiability",
    "start": "779940",
    "end": "785639"
  },
  {
    "text": "so it's purely for kind of an unfortunate limitation and implementation",
    "start": "785639",
    "end": "790740"
  },
  {
    "text": "that I can't simply differentiate my uh my Haskell program for instance or my ml program",
    "start": "790740",
    "end": "796260"
  },
  {
    "text": "so similarly I might want to integrate those functions well-defined notion or I might want to uh I might want to",
    "start": "796260",
    "end": "803519"
  },
  {
    "text": "evaluate my function or apply my functions incrementally which means I write some function I give it maybe a",
    "start": "803519",
    "end": "810779"
  },
  {
    "text": "very high dimensional input say it's got you know thousand or a million dimensional argument and it's going to",
    "start": "810779",
    "end": "817500"
  },
  {
    "text": "do a tremendous amount of work and give me a value and now uh some small piece of of this argument changes what happens",
    "start": "817500",
    "end": "824820"
  },
  {
    "text": "all of the work gets redone or I as a programmer can work very hard at",
    "start": "824820",
    "end": "830459"
  },
  {
    "text": "rewriting my code to quite cleverly recompute only the changed bits that's a",
    "start": "830459",
    "end": "835620"
  },
  {
    "text": "lot of work it's not easy to get right it's not that easy to get efficient and efficiency and",
    "start": "835620",
    "end": "840959"
  },
  {
    "text": "correctness of course is the whole point here so but it's a perfectly well defined notion in terms of functions",
    "start": "840959",
    "end": "848220"
  },
  {
    "text": "all right other examples interval analysis this is a lovely tool from the 1960s which which allows you to do",
    "start": "848220",
    "end": "854519"
  },
  {
    "text": "Global optimization on a variety of wonderful things I might want to do optimization on function find a maximum",
    "start": "854519",
    "end": "860880"
  },
  {
    "text": "minimum or I might want to find a route so I've got some function and I want to",
    "start": "860880",
    "end": "866279"
  },
  {
    "text": "know for what argument is it zero and these are all well-defined Notions of functions and they're not computable",
    "start": "866279",
    "end": "872820"
  },
  {
    "text": "so I can't just give my uh Haskell defined function and ml defined function uh just to some other",
    "start": "872820",
    "end": "879779"
  },
  {
    "text": "box and say you know compute where it's zero there are all kinds of approximations but those approximations could be",
    "start": "879779",
    "end": "886199"
  },
  {
    "text": "incorrect I could miss values I could get you know false negatives false positives and so on and more generally I",
    "start": "886199",
    "end": "891779"
  },
  {
    "text": "might want to solve some constraints you can express those constraints very conveniently but using our conventional",
    "start": "891779",
    "end": "898160"
  },
  {
    "text": "understanding of functional programs and their meanings and their compilations I",
    "start": "898160",
    "end": "903839"
  },
  {
    "text": "can't solve the constraints I need to go to some other vocabulary which is going to be clumsy all right so those are some motivation",
    "start": "903839",
    "end": "910260"
  },
  {
    "text": "for why in particular we want to overload Lambda",
    "start": "910260",
    "end": "914720"
  },
  {
    "text": "so how might we do it well here's an idea",
    "start": "916320",
    "end": "921720"
  },
  {
    "start": "918000",
    "end": "1115000"
  },
  {
    "text": "which is instead of overloading Lambda we eliminate it all right so there are a couple of",
    "start": "921720",
    "end": "928139"
  },
  {
    "text": "approaches one we could figure out how to overload these Notions this is definitely going to be some sort of language extension I personally don't",
    "start": "928139",
    "end": "934560"
  },
  {
    "text": "know how to do it it's probably doable but then it would become something more",
    "start": "934560",
    "end": "941339"
  },
  {
    "text": "for us to learn you know in the meanings of our uh of our languages the language have to be extended and so on another",
    "start": "941339",
    "end": "946920"
  },
  {
    "text": "approach is that we eliminate the source of the problem here we eliminate the difficulty and we just use our old",
    "start": "946920",
    "end": "952920"
  },
  {
    "text": "techniques and that's what I'm going to suggest here all right so that's the",
    "start": "952920",
    "end": "957959"
  },
  {
    "text": "idea how do we do it well let's look at how we might eliminate",
    "start": "957959",
    "end": "963180"
  },
  {
    "text": "lambdas now I don't mean uh you eliminate them in your practice because I really believe it is a wonderful",
    "start": "963180",
    "end": "969420"
  },
  {
    "text": "notation there are great reasons for writing point-free code",
    "start": "969420",
    "end": "975120"
  },
  {
    "text": "it often gives a higher level a more essential understanding of what we're talking about",
    "start": "975120",
    "end": "980279"
  },
  {
    "text": "but sometimes it's quite awkward and Lambda notation is just the thing so when I say limiting laminate I don't",
    "start": "980279",
    "end": "985740"
  },
  {
    "text": "mean you eliminating and I mean the compiler eliminating it okay so how might we do it well let's back up",
    "start": "985740",
    "end": "991680"
  },
  {
    "text": "and ask the question where does Lambda come from right we can try and get rid of it or we",
    "start": "991680",
    "end": "997500"
  },
  {
    "text": "can stop introducing it so I want to know how to eliminate it",
    "start": "997500",
    "end": "1003380"
  },
  {
    "text": "understand where it comes from and here's a bunch of examples okay in each of these definitions these",
    "start": "1003380",
    "end": "1009079"
  },
  {
    "text": "are uh probably at least some of these will be familiar to you particularly if you're a Haskell programmer so I want",
    "start": "1009079",
    "end": "1015860"
  },
  {
    "text": "you to think of these examples as examples of where the lambdas come from so here's a constant function",
    "start": "1015860",
    "end": "1022820"
  },
  {
    "text": "you give it a b and it gives you a function from A to B all right so this is it's just the",
    "start": "1022820",
    "end": "1028100"
  },
  {
    "text": "function that takes a ignores it gives you B then there's the identity function another classic",
    "start": "1028100",
    "end": "1033380"
  },
  {
    "text": "all right we've seen this over and over Lambda a a then there's function composition",
    "start": "1033380",
    "end": "1039380"
  },
  {
    "text": "so we want to compose two functions G and F we're going to uh",
    "start": "1039380",
    "end": "1045140"
  },
  {
    "text": "the composition of the two function is a function of an a that returns G of f of a okay so you can see here these are",
    "start": "1045140",
    "end": "1051620"
  },
  {
    "text": "kind of typical examples of where Lambda comes from another one is this operation uh which sometimes is called Fork this",
    "start": "1051620",
    "end": "1057320"
  },
  {
    "text": "comes from control dot Arrow uh thanks to John over here again",
    "start": "1057320",
    "end": "1062900"
  },
  {
    "text": "given two functions of the same domain we can combine them into a function from",
    "start": "1062900",
    "end": "1068179"
  },
  {
    "text": "that domain that gives you a pair of values and then we have currying and uncurrying",
    "start": "1068179",
    "end": "1073640"
  },
  {
    "text": "and even application itself all right so these are both examples of uses of Lambda",
    "start": "1073640",
    "end": "1081500"
  },
  {
    "text": "but they're more than that these are the essential ways that Lambda gets",
    "start": "1081500",
    "end": "1086600"
  },
  {
    "text": "introduced okay what do I mean by that I'll show you",
    "start": "1086600",
    "end": "1091940"
  },
  {
    "text": "here is how we can eliminate Lambda which is that we take an arbitrary Lambda expression and we uninline",
    "start": "1091940",
    "end": "1099620"
  },
  {
    "text": "wherever possible the definitions I just showed you so this this is an adequate set",
    "start": "1099620",
    "end": "1107620"
  },
  {
    "text": "uh of functions that if you run them backwards in other words if you uninline them in in your code you eliminate all",
    "start": "1108020",
    "end": "1115100"
  },
  {
    "start": "1115000",
    "end": "1355000"
  },
  {
    "text": "lambdas there are a variety of ways to do this this kind of Lambda elimination the ski calculus was was another one",
    "start": "1115100",
    "end": "1122419"
  },
  {
    "text": "so here's what we do it's quite simple Lambda calculus is a very simple language it has really four constructions",
    "start": "1122419",
    "end": "1129520"
  },
  {
    "text": "as constants variables application and abstraction okay that's all there is to the Lambda calculus",
    "start": "1129520",
    "end": "1135679"
  },
  {
    "text": "so if we want to eliminate lambdas we can look at well we're going to start with Lambda term otherwise there's",
    "start": "1135679",
    "end": "1141500"
  },
  {
    "text": "nothing to eliminate so assume there's a Lambda term and then think about the body there are four possibilities variables constants application and",
    "start": "1141500",
    "end": "1148039"
  },
  {
    "text": "abstraction Lambda abstraction and in each of those cases the functions I showed you on this slide",
    "start": "1148039",
    "end": "1154460"
  },
  {
    "text": "uh can be used in Reverse to eliminate the lambdas so what do I mean so Lambda PK",
    "start": "1154460",
    "end": "1160700"
  },
  {
    "text": "is just constant of K right that's the constant function I give you k",
    "start": "1160700",
    "end": "1166220"
  },
  {
    "text": "so a compiler seeing that expression Lambda p and then a constant can replace the expression with const K",
    "start": "1166220",
    "end": "1172780"
  },
  {
    "text": "similarly if it's a variable well I'm going to assume that the program is well typed and well scoped",
    "start": "1172780",
    "end": "1179600"
  },
  {
    "text": "okay so there are no uh there are no um there are no variables that are occurring that are not within scope so",
    "start": "1179600",
    "end": "1185780"
  },
  {
    "text": "if we have Lambda p and some variable that variable has to be p so Lambda p p is the identity function",
    "start": "1185780",
    "end": "1192620"
  },
  {
    "text": "the next one's a little trickier Lambda p and then a fun an application UV u and",
    "start": "1192620",
    "end": "1197960"
  },
  {
    "text": "v i mean are not variables here u and v are meta variables they stand for expressions so what can we do well we can split we",
    "start": "1197960",
    "end": "1204440"
  },
  {
    "text": "can split this expression into two Lambda p u and Lambda PV and remember I said we're",
    "start": "1204440",
    "end": "1209840"
  },
  {
    "text": "going to assume that the expressions are well typed and well scoped so now the variable P",
    "start": "1209840",
    "end": "1215539"
  },
  {
    "text": "um what am I saying we know that u and v can only contain the variable p",
    "start": "1215539",
    "end": "1220820"
  },
  {
    "text": "right any other variable contains wouldn't be in scope so Lambda p u and Lambda PV are also well scoped",
    "start": "1220820",
    "end": "1227780"
  },
  {
    "text": "and Lambda p u okay it it is going to be a function that when you when you apply it we get",
    "start": "1227780",
    "end": "1234140"
  },
  {
    "text": "the function we get a function and Lambda PV when we apply it we get an argument",
    "start": "1234140",
    "end": "1239299"
  },
  {
    "text": "we can then pair those function the function in an argument together with this Fork operator to find on a previous",
    "start": "1239299",
    "end": "1246020"
  },
  {
    "text": "page now we have a pair so we have a function that gives you a pair of a function and argument and",
    "start": "1246020",
    "end": "1251960"
  },
  {
    "text": "we're going to compose with that pair the apply function so we want to apply the first",
    "start": "1251960",
    "end": "1258080"
  },
  {
    "text": "the function in the first element of the pair to the argument in the second element of the pair that's how we can eliminate",
    "start": "1258080",
    "end": "1265419"
  },
  {
    "text": "lambdas in an application when I say eliminate lambdas I actually kind of done the opposite haven't I I've",
    "start": "1265419",
    "end": "1270500"
  },
  {
    "text": "multiplied them there was one Lambda now there are two Lambda so it looks like I'm I'm getting further from the goal but",
    "start": "1270500",
    "end": "1276679"
  },
  {
    "text": "the body of the Lambda expression is smaller and every one of these Transformations moves lambdas into a",
    "start": "1276679",
    "end": "1283039"
  },
  {
    "text": "smaller expression and that's why this process has to terminate and then finally we have Lambda abstraction Lambda P lambdaq well we",
    "start": "1283039",
    "end": "1290840"
  },
  {
    "text": "have uh we have uh uncurrying so if we uncurry this this uh function Lambda P",
    "start": "1290840",
    "end": "1297140"
  },
  {
    "text": "lambdaq we get Lambda of a single right Lambda PQ and then in order to get back",
    "start": "1297140",
    "end": "1302840"
  },
  {
    "text": "to where we were we have to Curry so I've done an uncurrying here syntactically manually",
    "start": "1302840",
    "end": "1308600"
  },
  {
    "text": "and then I'm saying and then I say and then of course for it to be equivalent we have to Curry all right now I want to talk about a",
    "start": "1308600",
    "end": "1315500"
  },
  {
    "text": "very simple Lambda calculus without patterns patterns are wonderful programming but you know for a compiler",
    "start": "1315500",
    "end": "1321620"
  },
  {
    "text": "and reasoning and so on it's nice to think about a simpler notion of lambdas okay so rather than having a pair here I",
    "start": "1321620",
    "end": "1327080"
  },
  {
    "text": "want to eliminate this pair pattern and so we got Lambda just a simple variable now I have to replace P by first of R",
    "start": "1327080",
    "end": "1332179"
  },
  {
    "text": "and Q by second of r so that's a syntactic transformation",
    "start": "1332179",
    "end": "1337460"
  },
  {
    "text": "now as I mentioned I don't want you to do this you could of course and it might be fun and you you know really get it if",
    "start": "1337460",
    "end": "1343520"
  },
  {
    "text": "you did apply these Transformations by hand but I want to apply them mechanically by a compiler in particular",
    "start": "1343520",
    "end": "1349400"
  },
  {
    "text": "I'm using a compiler plugin that I wrote that goes inside of GHC",
    "start": "1349400",
    "end": "1354500"
  },
  {
    "text": "so now let's look at some examples here's some simple Haskell programs so we have a squaring function give uh you",
    "start": "1354500",
    "end": "1361280"
  },
  {
    "start": "1355000",
    "end": "1474000"
  },
  {
    "text": "get a and it gives you a times a second example is is magnitude squared",
    "start": "1361280",
    "end": "1367400"
  },
  {
    "text": "all right so this this is a you know if you have a vector and you want to find the the magnitude of it squared well",
    "start": "1367400",
    "end": "1373520"
  },
  {
    "text": "it's the sum of the squares of the component so it's a squared plus b squared and then another example it shows uh",
    "start": "1373520",
    "end": "1379940"
  },
  {
    "text": "What uh producing products as well as consuming them I'm using a bit of a non-standard notation uh not just",
    "start": "1379940",
    "end": "1385940"
  },
  {
    "text": "non-standard and Haskell it's more standard mathematics so that this is we you know we it has we usually write a",
    "start": "1385940",
    "end": "1391159"
  },
  {
    "text": "comma a here all right so in this example we're going to produce as well as consume a product",
    "start": "1391159",
    "end": "1397640"
  },
  {
    "text": "that is a pair and so this function takes x y and it gives and it multiplies",
    "start": "1397640",
    "end": "1403340"
  },
  {
    "text": "them together call that Z and it gives you the sine n cosine or rather than cosine and sine so here are some just",
    "start": "1403340",
    "end": "1408919"
  },
  {
    "text": "sort of standard uh looking uh function definitions in Haskell and then we run them through the Lambda Eliminator and",
    "start": "1408919",
    "end": "1415039"
  },
  {
    "text": "this is what we get so what's going on here the square is a good example",
    "start": "1415039",
    "end": "1421340"
  },
  {
    "text": "so Square takes an argument and then",
    "start": "1421340",
    "end": "1426799"
  },
  {
    "text": "um we're going to call that a and remember the the upper upward pointing triangle uh operation what's called Fork",
    "start": "1426799",
    "end": "1433580"
  },
  {
    "text": "it's uh it applies two functions and gives a pair so it applies the function ID and ID",
    "start": "1433580",
    "end": "1439520"
  },
  {
    "text": "all right so ID applied to a will give you a it will apply to a we'll give you a and it",
    "start": "1439520",
    "end": "1444980"
  },
  {
    "text": "pairs them up so that's how we get a a uh that's how we get these two A's and",
    "start": "1444980",
    "end": "1450140"
  },
  {
    "text": "then we're going to compose with this multiplication function now why did I give a different name for a couple of reasons uh one is that it's an uncurried",
    "start": "1450140",
    "end": "1457460"
  },
  {
    "text": "notion of multiplication which I want to assume that these uncurried versions are primitive",
    "start": "1457460",
    "end": "1462799"
  },
  {
    "text": "and other the C is a is to suggest that it's going to be a generalization here Beyond functions",
    "start": "1462799",
    "end": "1468200"
  },
  {
    "text": "and similarly we can do lambd elimination on the others okay so that's what we get",
    "start": "1468200",
    "end": "1474799"
  },
  {
    "start": "1474000",
    "end": "1550000"
  },
  {
    "text": "now remember I talked about we're not going to give sort of random",
    "start": "1474799",
    "end": "1479840"
  },
  {
    "text": "interpretations or undisciplined interpretations but bring some algebraic discipline so",
    "start": "1479840",
    "end": "1485659"
  },
  {
    "text": "rather than having the algebra of number like things we're going to have an algebra function like things and there's",
    "start": "1485659",
    "end": "1490940"
  },
  {
    "text": "a very nicely developed a set of abstractions which is called",
    "start": "1490940",
    "end": "1497480"
  },
  {
    "text": "category Theory category theory is is a is a very deep topic it can be kind of",
    "start": "1497480",
    "end": "1503360"
  },
  {
    "text": "intimidating there's a lot of Buzz around it a lot of mystery about it there's nothing",
    "start": "1503360",
    "end": "1509840"
  },
  {
    "text": "complicated or deep about category Theory I'm going to talk about here just think of it as some there are some type",
    "start": "1509840",
    "end": "1515659"
  },
  {
    "text": "classes which means some interfaces and laws so if you understand num if you",
    "start": "1515659",
    "end": "1521240"
  },
  {
    "text": "understand functor uh foldable to reversible perhaps",
    "start": "1521240",
    "end": "1526940"
  },
  {
    "text": "then category is just another one of these things so the idea of categories is it functions like things and they have two",
    "start": "1526940",
    "end": "1534440"
  },
  {
    "text": "operations in common one is identity and the other's composition",
    "start": "1534440",
    "end": "1539200"
  },
  {
    "text": "and these operations have to satisfy certain laws which is the thing we call identity is the identity for composition and compositions associative",
    "start": "1540140",
    "end": "1547820"
  },
  {
    "text": "that's all you need to know okay but that's not the whole story that's all we need I need to do about",
    "start": "1547820",
    "end": "1554000"
  },
  {
    "start": "1550000",
    "end": "1711000"
  },
  {
    "text": "category now there's a notion of products so category by itself just gives you linear sort of composition and identity",
    "start": "1554000",
    "end": "1560600"
  },
  {
    "text": "but what we want to do is kind of branching uh if we want to do you know sub-computations and combine them and so on when I even do addition for instance",
    "start": "1560600",
    "end": "1567080"
  },
  {
    "text": "we had a notion of products because addition takes a pair so there are three more operations if",
    "start": "1567080",
    "end": "1572840"
  },
  {
    "text": "you've been exposed to uh to control.arrow you will have seen something quite",
    "start": "1572840",
    "end": "1578779"
  },
  {
    "text": "similar this is a little bit different it's different in that we remove the method that was originally called Pure",
    "start": "1578779",
    "end": "1584360"
  },
  {
    "text": "and nowadays it's called r I believe because that method is too powerful to",
    "start": "1584360",
    "end": "1590120"
  },
  {
    "text": "be able to implement for for quite a lot of interesting applications we take that away we have to put something back and",
    "start": "1590120",
    "end": "1595460"
  },
  {
    "text": "what we put back is uh is first and second but in this set I'm going to call them extract left and extract right",
    "start": "1595460",
    "end": "1602240"
  },
  {
    "text": "okay so products come with this notion that well a type that is the product and then",
    "start": "1602240",
    "end": "1608419"
  },
  {
    "text": "two operations which are projections so we projected product a pair onto its first and second element and then this",
    "start": "1608419",
    "end": "1614179"
  },
  {
    "text": "Fork operation so you see what I showed you a few slides ago this is a vocabulary that is",
    "start": "1614179",
    "end": "1620480"
  },
  {
    "text": "just a part of the Prelude well except for fork which is in control dot Arrow but we can take these operations every",
    "start": "1620480",
    "end": "1627260"
  },
  {
    "text": "one of them and generalize them within this algebraic setting so this is where this is where Fork shows up and there",
    "start": "1627260",
    "end": "1634340"
  },
  {
    "text": "are three laws as well so if we if we combine two functions and",
    "start": "1634340",
    "end": "1640039"
  },
  {
    "text": "then compose it with extracting left element we didn't need the second one to begin with so that's this first Axiom",
    "start": "1640039",
    "end": "1647659"
  },
  {
    "text": "now there's an entirely dual notion called co-products more concretely for functions it's called sums either in",
    "start": "1647659",
    "end": "1654500"
  },
  {
    "text": "Haskell and the operations I won't really use these today but I just want to impress",
    "start": "1654500",
    "end": "1661039"
  },
  {
    "text": "on you that these are exactly the Dual so I'm switching between these two sides products co-products What's Happening",
    "start": "1661039",
    "end": "1667100"
  },
  {
    "text": "Here is the products become co-products or sums and all of the arrows that's what K is I didn't mention this so this",
    "start": "1667100",
    "end": "1674120"
  },
  {
    "text": "back tick K if you're not a hashclude is maybe an odd notation if you are a house still may be a bit of an odd notation this is just just means that K is K is",
    "start": "1674120",
    "end": "1681559"
  },
  {
    "text": "uh is a type um it's a type level parameter that has two arguments and I'm using it in fix",
    "start": "1681559",
    "end": "1687679"
  },
  {
    "text": "that's all that's going on here okay so the uh what when we go from products",
    "start": "1687679",
    "end": "1693860"
  },
  {
    "text": "to co-products the products become co-products and all the arrows get reversed that's the K here that's all",
    "start": "1693860",
    "end": "1698960"
  },
  {
    "text": "that's going on and the laws similarly all get swapped around so that the eliminations that's the X's",
    "start": "1698960",
    "end": "1705260"
  },
  {
    "text": "become the ends the introductions all right there's a third notion which is uh concretely we talk about it is in",
    "start": "1705260",
    "end": "1712820"
  },
  {
    "start": "1711000",
    "end": "1774000"
  },
  {
    "text": "terms of this first class functions or functions as values and category three these are called",
    "start": "1712820",
    "end": "1719140"
  },
  {
    "text": "exponentials and this is this is the closure so these are closed categories and there are three operations they're",
    "start": "1719140",
    "end": "1724640"
  },
  {
    "text": "probably pretty familiar to you which are apply uh and Curry and uncurry and they also have laws okay so that's",
    "start": "1724640",
    "end": "1731600"
  },
  {
    "text": "that's an algebra of functions and then there are a bunch of other miscellaneous operations",
    "start": "1731600",
    "end": "1738380"
  },
  {
    "text": "and these are going to vary depending on you know what domain you're you're interested in so here we have a a",
    "start": "1738380",
    "end": "1744760"
  },
  {
    "text": "subclass of category where it's really just kind of a neighbor class which is um uh categories with numerical",
    "start": "1744760",
    "end": "1750980"
  },
  {
    "text": "operations so when I say category just think function like thing",
    "start": "1750980",
    "end": "1757419"
  },
  {
    "text": "okay so we already have plus and times and negate and so on that are",
    "start": "1757580",
    "end": "1762919"
  },
  {
    "text": "overloadable but they're not quite overloadable in the right way to bring in the into category Theory we want to overload them not just on the types of",
    "start": "1762919",
    "end": "1769279"
  },
  {
    "text": "the values but also on the function like things so that's what we have here",
    "start": "1769279",
    "end": "1774620"
  },
  {
    "start": "1774000",
    "end": "1805000"
  },
  {
    "text": "okay so what are we doing here we started out talking about uh want to",
    "start": "1774620",
    "end": "1780799"
  },
  {
    "text": "be able to overload in a sense want to be able to give a variety of interpretations within a disciplined",
    "start": "1780799",
    "end": "1785840"
  },
  {
    "text": "framework for uh for our lovely notation LED Lambda calculus",
    "start": "1785840",
    "end": "1791419"
  },
  {
    "text": "and I showed you how to eliminate lambdas and variables so that we could get into a purely algebraic setting",
    "start": "1791419",
    "end": "1797299"
  },
  {
    "text": "where we can do overloading",
    "start": "1797299",
    "end": "1800799"
  }
]