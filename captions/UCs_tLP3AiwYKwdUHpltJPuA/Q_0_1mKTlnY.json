[
  {
    "text": "[Music]",
    "start": "2540",
    "end": "11619"
  },
  {
    "text": "okay welcome to this talk on uh new concurrency Utilities in Java 8 uh this",
    "start": "11639",
    "end": "17359"
  },
  {
    "text": "is a talk for Java programmers can I safely assume that you are familiar with concurrent programming in Java who is",
    "start": "17359",
    "end": "24640"
  },
  {
    "text": "not okay that's good so what we will discuss is get an overview of the new",
    "start": "24640",
    "end": "32078"
  },
  {
    "text": "concurrency utilities that were added to Java 8 uh we will learn about asynchronous result processing they have",
    "start": "32079",
    "end": "39239"
  },
  {
    "text": "been adding a new facility or a new class the completable future which is an",
    "start": "39239",
    "end": "44960"
  },
  {
    "text": "alternative to the regular future that was added with Java 5 and it's it's kind",
    "start": "44960",
    "end": "51760"
  },
  {
    "text": "of a different way of processing the results that are produced by",
    "start": "51760",
    "end": "56879"
  },
  {
    "text": "concurrently running threats and another abstraction that has been added in Java 8 is stamped lock",
    "start": "56879",
    "end": "64158"
  },
  {
    "text": "which is an alternative lock and in particular it's an alternative to the read WR lock that has been available",
    "start": "64159",
    "end": "70400"
  },
  {
    "text": "since Java 5 then there is another addition namely adders and accumulators",
    "start": "70400",
    "end": "75880"
  },
  {
    "text": "they are similar to Atomic long atomics in general um most of these additions to",
    "start": "75880",
    "end": "82119"
  },
  {
    "text": "to to the uh concurrency utilities are ways for providing optimization so there",
    "start": "82119",
    "end": "88520"
  },
  {
    "text": "is barely anything being radically new but most of these new abstractions",
    "start": "88520",
    "end": "94360"
  },
  {
    "text": "support optimizations and I will go into some of the details uh there are a couple of new methods in concurrent",
    "start": "94360",
    "end": "101560"
  },
  {
    "text": "hashmap uh they have been added actually to the map interface so even the single threaded hashmap and tree Maps support",
    "start": "101560",
    "end": "109159"
  },
  {
    "text": "new operations and they are particularly interesting for concurrent hashmap because all these additional uh",
    "start": "109159",
    "end": "115520"
  },
  {
    "text": "operations on a hashmap are Atomic if you use them on a concurrent hash map",
    "start": "115520",
    "end": "121039"
  },
  {
    "text": "then there is a particular new well it's not a new thread pool it's a Singleton",
    "start": "121039",
    "end": "126600"
  },
  {
    "text": "Fork join thread pool that is used in various contexts it's used by streams in",
    "start": "126600",
    "end": "132959"
  },
  {
    "text": "Java it's used by completable Future and also by some of the concurrent hashmap",
    "start": "132959",
    "end": "138959"
  },
  {
    "text": "operations that have been added to the interface and I will talk about how this common pool so-called common pool",
    "start": "138959",
    "end": "145360"
  },
  {
    "text": "differs from regular fog join pools and very low level so we are working our way",
    "start": "145360",
    "end": "151560"
  },
  {
    "text": "from top level abstractions into the deep into the internals of concurrent",
    "start": "151560",
    "end": "157200"
  },
  {
    "text": "program they have been adding a an annotation contended which is in Java",
    "start": "157200",
    "end": "164120"
  },
  {
    "text": "now in Sun melanous unsafe it's very low level uh and it is supposed to support",
    "start": "164120",
    "end": "170840"
  },
  {
    "text": "avoiding false sharing okay so to add a couple of",
    "start": "170840",
    "end": "176159"
  },
  {
    "text": "things to the uh introduction um I do training for a living most of the time",
    "start": "176159",
    "end": "182200"
  },
  {
    "text": "so I have a couple of uh seminars one of them is a seminar concurrent programming in Java and this is why I follow uh what",
    "start": "182200",
    "end": "189840"
  },
  {
    "text": "is going on on on in Java and in the jdk okay let's start with completable",
    "start": "189840",
    "end": "196879"
  },
  {
    "text": "future future in general is a mechanism for passing a result produced by a",
    "start": "196879",
    "end": "203840"
  },
  {
    "text": "concurrently running task to an interested party another thread typically and it has been added",
    "start": "203840",
    "end": "210640"
  },
  {
    "text": "initially in Java 5 and there is a future interface that describes what",
    "start": "210640",
    "end": "215840"
  },
  {
    "text": "future is basically the central operation is get the result and future",
    "start": "215840",
    "end": "221280"
  },
  {
    "text": "task is the implementing class that was added in Java 5 and they were mainly designed for use with thread pools let's",
    "start": "221280",
    "end": "228840"
  },
  {
    "text": "take a look at the Java 5 way of using Futures what you do in Java 5 is you",
    "start": "228840",
    "end": "234640"
  },
  {
    "text": "create a thread pool then you specify a callable or a run able which I've been",
    "start": "234640",
    "end": "240920"
  },
  {
    "text": "specifying here as a Lambda expression then you submit the callable or runnable",
    "start": "240920",
    "end": "246319"
  },
  {
    "text": "to the pool and the pool immediately wraps it into a future task and returns",
    "start": "246319",
    "end": "251439"
  },
  {
    "text": "a future okay the task itself is still sitting in the task CU of that pool and",
    "start": "251439",
    "end": "257680"
  },
  {
    "text": "you can use the future and in particular the future's get function to wait for",
    "start": "257680",
    "end": "263919"
  },
  {
    "text": "the result to wait for completion of the result and once you receive the the the",
    "start": "263919",
    "end": "270000"
  },
  {
    "text": "the result from the get function the get function by the way is a blocking function if the task is still running",
    "start": "270000",
    "end": "275520"
  },
  {
    "text": "and the result has not yet been produced so you wait until the result is available and then you can use it in my",
    "start": "275520",
    "end": "282080"
  },
  {
    "text": "example I'm simply printing it what the limitation of this is that",
    "start": "282080",
    "end": "287160"
  },
  {
    "text": "you have as a user of the future you have to actively decide when you want to",
    "start": "287160",
    "end": "294720"
  },
  {
    "text": "retrieve the result and in particular you might have to wait until the result",
    "start": "294720",
    "end": "300120"
  },
  {
    "text": "is available there is so far until Java 8 there was no way of specifying some",
    "start": "300120",
    "end": "307039"
  },
  {
    "text": "kind of as synchronous result processing so you act in in all cases you had to",
    "start": "307039",
    "end": "312960"
  },
  {
    "text": "actively go and ask for the result are you familiar with lambdas I've been using the Lambda without even asking who",
    "start": "312960",
    "end": "319800"
  },
  {
    "text": "is not familiar with Lambda Expressions uh few Lambda is basically our new",
    "start": "319800",
    "end": "325440"
  },
  {
    "text": "language feature in Java 8 and the yellow part in my submit statement uh is a Lambda Lambda is basically an",
    "start": "325440",
    "end": "331919"
  },
  {
    "text": "anonymous function and if you look at the syntax it has the arrow symbol in the middle and to the what is it to the",
    "start": "331919",
    "end": "339440"
  },
  {
    "text": "left you have an argument list it's like the argument list of a method and to the right you have the method implementation",
    "start": "339440",
    "end": "346039"
  },
  {
    "text": "like the body of a method and it's um some kind of anonymous method yeah it doesn't have a name it just has an",
    "start": "346039",
    "end": "352360"
  },
  {
    "text": "argument list and an implementation and that's it yeah and in my example I am",
    "start": "352360",
    "end": "357639"
  },
  {
    "text": "providing a call to the submit function of my pool so the",
    "start": "357639",
    "end": "363360"
  },
  {
    "text": "Lambda magically uh somehow implements the callable interface and basically it",
    "start": "363360",
    "end": "368720"
  },
  {
    "text": "corresponds to what we've usually been doing with Anonymous in our classes yeah so the Lambda is some kind of concise",
    "start": "368720",
    "end": "376039"
  },
  {
    "text": "notation for things that we've been solving previously uh with Anonymous in our classes okay I've been using them or",
    "start": "376039",
    "end": "384000"
  },
  {
    "text": "the new or many of the new uh apis in Java Aid use the new featur so I will",
    "start": "384000",
    "end": "390000"
  },
  {
    "text": "throughout the Talk use lambdas in various places okay so the limitation of",
    "start": "390000",
    "end": "396120"
  },
  {
    "text": "the classic future is no support for for some kind of reactive result processing",
    "start": "396120",
    "end": "401680"
  },
  {
    "text": "what we actually were missing is that we can specify some kind of of callback function some kind of functionality that",
    "start": "401680",
    "end": "408639"
  },
  {
    "text": "will be executed as soon as the result becomes available asynchronous result",
    "start": "408639",
    "end": "414520"
  },
  {
    "text": "processing and this is what the completable future provides completable future is a class in the Java util",
    "start": "414520",
    "end": "421879"
  },
  {
    "text": "concurrent package and it combines the classic future interface so you can use",
    "start": "421879",
    "end": "427879"
  },
  {
    "text": "a completable future like a future task and just use the blocking get function",
    "start": "427879",
    "end": "433560"
  },
  {
    "text": "in order to retrieve the result but it also implements a new interface called completion stage and completion stage",
    "start": "433560",
    "end": "441319"
  },
  {
    "text": "has a couple of dozens of functions uh many of them for asynchronous result",
    "start": "441319",
    "end": "447599"
  },
  {
    "text": "retrieval like in the example here so let's assume that I've been receiving a completable future I will go into how",
    "start": "447599",
    "end": "454720"
  },
  {
    "text": "you can retrieve completable Futures in a minute and once I have a completable future I can use the get function and",
    "start": "454720",
    "end": "461680"
  },
  {
    "text": "wait for the result but alternatively I can use the then except function and what I'm specifying there",
    "start": "461680",
    "end": "469440"
  },
  {
    "text": "is a functionality that will be executed as soon as the result is produced yeah",
    "start": "469440",
    "end": "477400"
  },
  {
    "text": "and I don't have to wait then accept function just hands over functionality and then the thread that is producing",
    "start": "477400",
    "end": "485120"
  },
  {
    "text": "the result yeah is executing the task and producing the result will subsequently call my Lambda that I've",
    "start": "485120",
    "end": "492879"
  },
  {
    "text": "been providing to the then accept function as a as the argument and basically what I'm doing is once the",
    "start": "492879",
    "end": "499080"
  },
  {
    "text": "result is available then please print it yeah so I do not have to wait yeah I",
    "start": "499080",
    "end": "506120"
  },
  {
    "text": "just make available some kind of functionality that will will be executed exactly when the result becomes",
    "start": "506120",
    "end": "512240"
  },
  {
    "text": "available and it is executed asynchronously in a different thread so I don't have to wait I don't have to",
    "start": "512240",
    "end": "518880"
  },
  {
    "text": "blindly recheck until the result becomes available I just specify ahead of time",
    "start": "518880",
    "end": "524519"
  },
  {
    "text": "what will be done once the the result becomes available okay I've I've been leaving",
    "start": "524519",
    "end": "530959"
  },
  {
    "text": "open where I got that completable future from and completable Futures are also",
    "start": "530959",
    "end": "537560"
  },
  {
    "text": "created by passing task s runnables or kind of callables to a pool but it is",
    "start": "537560",
    "end": "543839"
  },
  {
    "text": "not done by uh using the pool specifically and calling a submit or execute function Instead The completable",
    "start": "543839",
    "end": "550720"
  },
  {
    "text": "Future Has static Factory functions or factory methods to which you supply your",
    "start": "550720",
    "end": "557480"
  },
  {
    "text": "task and then it returns a completable future and there are two different flavors of well these static Factory",
    "start": "557480",
    "end": "565399"
  },
  {
    "text": "methods one is for Runner Bus and these methods are called run asung and run",
    "start": "565399",
    "end": "571040"
  },
  {
    "text": "asung with an Executor so you can specify in which pool the runnable will",
    "start": "571040",
    "end": "576640"
  },
  {
    "text": "be executed if you do not specify a pool yourself then the fork joint common pool",
    "start": "576640",
    "end": "583120"
  },
  {
    "text": "is used which I will go into in a minute later okay so you can pass over",
    "start": "583120",
    "end": "588240"
  },
  {
    "text": "runnables what is returned is a completable future of void runnables do",
    "start": "588240",
    "end": "593560"
  },
  {
    "text": "not produce a result and so what you can specify a reaction to would be the",
    "start": "593560",
    "end": "599720"
  },
  {
    "text": "completion of the runnable without receiving or processing any result if you have a result producing task which",
    "start": "599720",
    "end": "608000"
  },
  {
    "text": "traditionally we have been expressing as a callable you would call Supply aun and",
    "start": "608000",
    "end": "613680"
  },
  {
    "text": "pass in an implementation of the supplier interface the supplier interface is a new interface face and it",
    "start": "613680",
    "end": "620800"
  },
  {
    "text": "was uh added in conjunction with the streams that are also part of the uh",
    "start": "620800",
    "end": "626560"
  },
  {
    "text": "Java 8 jdk and there is a new package called Java util function and it",
    "start": "626560",
    "end": "632880"
  },
  {
    "text": "has a couple of predefined functional interfaces that are typically used as the argument types of stream operations",
    "start": "632880",
    "end": "640240"
  },
  {
    "text": "or like in this example uh it is used as the argument type of the supply ASN",
    "start": "640240",
    "end": "645279"
  },
  {
    "text": "function and a supplier the supplier interface is a functional interface functional interfaces have one only one",
    "start": "645279",
    "end": "652240"
  },
  {
    "text": "abstract method and the abstract method A supplier doesn't take anything as an",
    "start": "652240",
    "end": "657480"
  },
  {
    "text": "argument but produces or supplies a result and in this case this is similar",
    "start": "657480",
    "end": "663120"
  },
  {
    "text": "to a callable remember cbles callables don't take arguments but they produce a",
    "start": "663120",
    "end": "668920"
  },
  {
    "text": "a result the difference between a callable and a supplier is if you remember the callable it's call method",
    "start": "668920",
    "end": "676320"
  },
  {
    "text": "is allowed to throw checked exceptions in particular an execution exception and",
    "start": "676320",
    "end": "682920"
  },
  {
    "text": "uh all the apis that are using lambdas have difficulties with checked exceptions so nowadays all the lambdas",
    "start": "682920",
    "end": "690959"
  },
  {
    "text": "are typically free of checked exceptions and so the supplier has a function that",
    "start": "690959",
    "end": "696399"
  },
  {
    "text": "takes no argument produces a result but doesn't throw any checked exceptions so",
    "start": "696399",
    "end": "701600"
  },
  {
    "text": "basically it's an exception free quable so you have these two flavors",
    "start": "701600",
    "end": "707120"
  },
  {
    "text": "here of passing a task to either the fork joint common pool or a pool of your",
    "start": "707120",
    "end": "713000"
  },
  {
    "text": "choice and then what is returned is a completable future which allows you to use the traditional synchronous get",
    "start": "713000",
    "end": "719639"
  },
  {
    "text": "function so the the classic future interface or the completion stage functions like then aun or then accept",
    "start": "719639",
    "end": "727440"
  },
  {
    "text": "and there are several other functions that allow to specify reactions to the",
    "start": "727440",
    "end": "733079"
  },
  {
    "text": "result retrieval okay so comparing the the the options this is the old way of",
    "start": "733079",
    "end": "738560"
  },
  {
    "text": "doing it yeah you actively use the future and decide now I want to wait for the result and then you get the result",
    "start": "738560",
    "end": "745680"
  },
  {
    "text": "and processes in some way and the react way using completable future is I start",
    "start": "745680",
    "end": "752760"
  },
  {
    "text": "the task or pass it to some pool and then immediately afterwards I receive the future and then I specify the",
    "start": "752760",
    "end": "760079"
  },
  {
    "text": "reaction that is executed upon result the event that the result becomes",
    "start": "760079",
    "end": "767480"
  },
  {
    "text": "available okay the completable future like well quite a number of new apis",
    "start": "767480",
    "end": "774240"
  },
  {
    "text": "that were added to the jdk with Java 8 uh uses the so-called fluent prog pramming style and fluent programming",
    "start": "774240",
    "end": "781279"
  },
  {
    "text": "means that you have an API in which almost all operations um return an",
    "start": "781279",
    "end": "788279"
  },
  {
    "text": "object on which you can perform the next operation in a chain of operations so",
    "start": "788279",
    "end": "794880"
  },
  {
    "text": "each operation returns something on which you can execute the next operation and I've been using an example here you",
    "start": "794880",
    "end": "801839"
  },
  {
    "text": "can have short sequences of operations or some kind of lengthy operation like",
    "start": "801839",
    "end": "807519"
  },
  {
    "text": "the lower part here I I'm supplying a callable to some kind of pool the",
    "start": "807519",
    "end": "813320"
  },
  {
    "text": "callable calls a get stock info method that uh somehow retrieves uh given uh a",
    "start": "813320",
    "end": "820639"
  },
  {
    "text": "stock symbol it retrieves a string that contains information about the stock",
    "start": "820639",
    "end": "826680"
  },
  {
    "text": "when complete so once that that string has been produced when complete I just",
    "start": "826680",
    "end": "832800"
  },
  {
    "text": "print what has been retrieved as the result and when complete also returns a",
    "start": "832800",
    "end": "838759"
  },
  {
    "text": "compl relable future on which I can call the next operation and then I then I say",
    "start": "838759",
    "end": "844920"
  },
  {
    "text": "apply and extract increase rate method to the result of the get stock info",
    "start": "844920",
    "end": "850720"
  },
  {
    "text": "stuff and then it extracts some kind of double the increase rate let's say once the increase rate is produced now that's",
    "start": "850720",
    "end": "858279"
  },
  {
    "text": "also a completable future containing a double I call it then accept function",
    "start": "858279",
    "end": "863839"
  },
  {
    "text": "then I format the result the increase rate and print it and afterwards I have some kind of termination method which is",
    "start": "863839",
    "end": "871639"
  },
  {
    "text": "the then run and then run is one of the methods that do no longer return a completable future so that's kind of the",
    "start": "871639",
    "end": "877519"
  },
  {
    "text": "end of my sequence question",
    "start": "877519",
    "end": "882560"
  },
  {
    "text": "yes Supply does Supply ASN run the task no Supply ASN just passes the task to a",
    "start": "883160",
    "end": "890759"
  },
  {
    "text": "thread pool yeah it's like submit or execute with a traditional thread pools it just passed to the pool the pool puts",
    "start": "890759",
    "end": "896920"
  },
  {
    "text": "it into into some kind of task cu and there it sits until a threat is available to execute it so this is not a",
    "start": "896920",
    "end": "904120"
  },
  {
    "text": "blocking function yeah you just pass over the task and it Returns the future",
    "start": "904120",
    "end": "910320"
  },
  {
    "text": "immediately ah could the task finish before I specify then accept in theory",
    "start": "916800",
    "end": "923560"
  },
  {
    "text": "yes so if the pool if a threat in the pool is available and executes the",
    "start": "923560",
    "end": "929000"
  },
  {
    "text": "immediately and it takes only nanocs to proceed well then the result would be",
    "start": "929000",
    "end": "935079"
  },
  {
    "text": "become available immediately and then immediately afterwards all the the reactions would be executed so the",
    "start": "935079",
    "end": "942839"
  },
  {
    "text": "completable future handles this case in particular so it need not take time not",
    "start": "942839",
    "end": "948040"
  },
  {
    "text": "necessarily okay but usually I mean you pass on tasks to a thread pool that",
    "start": "948040",
    "end": "953399"
  },
  {
    "text": "typically takes some time yeah so it usually you are finished with providing all the reactions before the task even",
    "start": "953399",
    "end": "960079"
  },
  {
    "text": "runs typically okay so what's the big deal with Rea",
    "start": "960079",
    "end": "968120"
  },
  {
    "text": "with this kind of reactive style I mean it it provides higher scalability because with a traditional way of",
    "start": "968120",
    "end": "974440"
  },
  {
    "text": "retrieving the result you typically you have to wait yeah you're wasting time",
    "start": "974440",
    "end": "979480"
  },
  {
    "text": "just waiting for the result or you can wait with a time out out which is basically polling and then you take you",
    "start": "979480",
    "end": "985759"
  },
  {
    "text": "waste resources for for the blind recks the many Reck until you actually receive the result and uh with the completable",
    "start": "985759",
    "end": "993600"
  },
  {
    "text": "future you wouldn't you wouldn't waste any time you do not have to recheck you don't have to wait you just specify what",
    "start": "993600",
    "end": "1001360"
  },
  {
    "text": "kind of reaction is executed right at the moment when the result becomes available it's it's basically like",
    "start": "1001360",
    "end": "1007959"
  },
  {
    "text": "providing a call back that is invoked upon the event of result",
    "start": "1007959",
    "end": "1014000"
  },
  {
    "text": "completion okay the first time I looked at the interface I was overwhelmed",
    "start": "1014000",
    "end": "1019079"
  },
  {
    "text": "because it has three or four dozen methods so there are lots of operations",
    "start": "1019079",
    "end": "1024360"
  },
  {
    "text": "um most of them are for so-called result users and there are methods that stem",
    "start": "1024360",
    "end": "1029918"
  },
  {
    "text": "from the classic future interface they've been adding a couple of logical extensions to the classic future",
    "start": "1029919",
    "end": "1037000"
  },
  {
    "text": "interface then we have the factories like Supply aung and run aung that I've been showing you then it has all the",
    "start": "1037000",
    "end": "1044120"
  },
  {
    "text": "completion stage function for providing reactions and then it has operations",
    "start": "1044120",
    "end": "1050240"
  },
  {
    "text": "like do something after all these Futures complete or any of these Futures",
    "start": "1050240",
    "end": "1056000"
  },
  {
    "text": "complete so it has a really fat interface I think okay a couple of more",
    "start": "1056000",
    "end": "1061480"
  },
  {
    "text": "details there is not only a then accept function for specifying reactions but",
    "start": "1061480",
    "end": "1067039"
  },
  {
    "text": "there are three different functions you after after you've been receiving a completable future you can say then",
    "start": "1067039",
    "end": "1074240"
  },
  {
    "text": "apply a function then accept a consumer or then run a run able the difference",
    "start": "1074240",
    "end": "1080080"
  },
  {
    "text": "basically is let's say let's take then accept it takes a consumer and a consumer is something that takes the",
    "start": "1080080",
    "end": "1086159"
  },
  {
    "text": "result somehow consumes it processes it and doesn't return anything so the result would be a completable future of",
    "start": "1086159",
    "end": "1093000"
  },
  {
    "text": "void if you use then apply you have to provide a function and a function is",
    "start": "1093000",
    "end": "1098600"
  },
  {
    "text": "something that takes the result and produces a new result or something else it kind of maps the result to some kind",
    "start": "1098600",
    "end": "1106080"
  },
  {
    "text": "of new object or information so it returns a complet it takes a t and",
    "start": "1106080",
    "end": "1111840"
  },
  {
    "text": "returns a completable future for a u so that's kind of a mapping function and then run takes a runnable",
    "start": "1111840",
    "end": "1119440"
  },
  {
    "text": "and as you know runnables don't take anything don't return anything that's just like I want to re upon completion",
    "start": "1119440",
    "end": "1126240"
  },
  {
    "text": "without receiving the result without doing anything with it and I don't return anything so it Returns the",
    "start": "1126240",
    "end": "1131480"
  },
  {
    "text": "completable future of void so there are these three different flavors of providing a reaction and each of these",
    "start": "1131480",
    "end": "1139200"
  },
  {
    "text": "three exists in three different flavors which makes for the fat API yeah the the",
    "start": "1139200",
    "end": "1144840"
  },
  {
    "text": "combination is already in nine different functions the different three flavors here using the example of then run is",
    "start": "1144840",
    "end": "1151600"
  },
  {
    "text": "then run the runnable the reaction synchronously asynchronously or",
    "start": "1151600",
    "end": "1157360"
  },
  {
    "text": "asynchronously with a specific pool of my choice and basically what the difference",
    "start": "1157360",
    "end": "1163520"
  },
  {
    "text": "is if you say then run synchronously then the threat typically a pool tool",
    "start": "1163520",
    "end": "1168919"
  },
  {
    "text": "threat that has been producing the result will also execute the runnable",
    "start": "1168919",
    "end": "1174280"
  },
  {
    "text": "that I've been providing and if you say then run ASN another Pool thread a new",
    "start": "1174280",
    "end": "1179400"
  },
  {
    "text": "pool thread a different pool thread would execute the runable so one thread would execute the task produce the",
    "start": "1179400",
    "end": "1186120"
  },
  {
    "text": "initial result and then a runnable will be started in a different thread and you",
    "start": "1186120",
    "end": "1192000"
  },
  {
    "text": "can even start the runnable in a different thread in a different pool if you want okay so you have nine different",
    "start": "1192000",
    "end": "1198200"
  },
  {
    "text": "functions for providing various reactions in various flavors then there are more functions",
    "start": "1198200",
    "end": "1204960"
  },
  {
    "text": "like for combinations yeah if you want to react upon the completion of two different Futures there is a then",
    "start": "1204960",
    "end": "1211480"
  },
  {
    "text": "combined function uh example here I",
    "start": "1211480",
    "end": "1216520"
  },
  {
    "text": "Supply a callable kind of a cable that is called get a stock symbols uh daily",
    "start": "1216520",
    "end": "1223200"
  },
  {
    "text": "lowest rate and another one for the highest rate so I have two futures for",
    "start": "1223200",
    "end": "1229080"
  },
  {
    "text": "different executions of two different tasks and two different results and I want to do something on completion of",
    "start": "1229080",
    "end": "1235440"
  },
  {
    "text": "both so I take one of the Futures say then combine with the other future and a",
    "start": "1235440",
    "end": "1241880"
  },
  {
    "text": "reaction that takes both results and produces something new in my example I",
    "start": "1241880",
    "end": "1247840"
  },
  {
    "text": "just calculate the difference of daily low and daily high and then the result",
    "start": "1247840",
    "end": "1253360"
  },
  {
    "text": "again is a completable future of double in my case probably and then I apply a for formatting function that prints it",
    "start": "1253360",
    "end": "1260480"
  },
  {
    "text": "yeah so you can have combinations of Futures and react upon the completion of several things yes you combine more than",
    "start": "1260480",
    "end": "1267600"
  },
  {
    "text": "two fures yes you can combine more than two Futures there is an allof function",
    "start": "1267600",
    "end": "1273440"
  },
  {
    "text": "to which you supply a collection of uh suppliers or runnables and then you",
    "start": "1273440",
    "end": "1278840"
  },
  {
    "text": "would react on the completion of all of them and there's also an any of function",
    "start": "1278840",
    "end": "1284159"
  },
  {
    "text": "yeah okay this is kind of an overview of the dozens of functions yeah you have",
    "start": "1284159",
    "end": "1290279"
  },
  {
    "text": "the factory methods Supply Asing run ASN with a pool and with without a pool so",
    "start": "1290279",
    "end": "1296200"
  },
  {
    "text": "in different flavors each of them um then you have the then apply then accept",
    "start": "1296200",
    "end": "1301520"
  },
  {
    "text": "then run things in three flavors yet another nine functions for specifying",
    "start": "1301520",
    "end": "1306600"
  },
  {
    "text": "reactions then you have functions for specifying reactions upon faila yeah so",
    "start": "1306600",
    "end": "1314279"
  },
  {
    "text": "when complete handle and exceptionally exceptionally is called if the task",
    "start": "1314279",
    "end": "1321240"
  },
  {
    "text": "throws a runtime exception handle uh receives both the result if it was",
    "start": "1321240",
    "end": "1328080"
  },
  {
    "text": "successful and uh the exception if it was well if it failed yeah then it can",
    "start": "1328080",
    "end": "1333520"
  },
  {
    "text": "produce a reaction handle can produce a replacement result while when complete",
    "start": "1333520",
    "end": "1339159"
  },
  {
    "text": "doesn't return a result it just takes the result in case of success the exception in case of failure and then",
    "start": "1339159",
    "end": "1345200"
  },
  {
    "text": "produces some kind of reaction uh then there there is a pipeline then compos H interestingly",
    "start": "1345200",
    "end": "1352159"
  },
  {
    "text": "this is basically the flat map some kind of flat map operation if you've been looking into the stream interface there",
    "start": "1352159",
    "end": "1358559"
  },
  {
    "text": "is a flat map function and this is basically what the the corresponding thing for the completable future and",
    "start": "1358559",
    "end": "1365200"
  },
  {
    "text": "then there are combinations then combine then accept both run after both various flavors of combining two Futures and",
    "start": "1365200",
    "end": "1372279"
  },
  {
    "text": "then there is the all of and any of for more than two Futures so this is the completion stage rea active interface of",
    "start": "1372279",
    "end": "1379840"
  },
  {
    "text": "completable future and then it supports the traditional future stuff like get and cancel and is done and they have",
    "start": "1379840",
    "end": "1387400"
  },
  {
    "text": "kind of logical extensions of the future there is a get now that returns immediately if the result is available",
    "start": "1387400",
    "end": "1394200"
  },
  {
    "text": "so far if you just wanted to pull you had to call get with a time out a very short time out and now you have a get",
    "start": "1394200",
    "end": "1400640"
  },
  {
    "text": "Now function that returns immediately and and you have a join function which is basically a get function without a",
    "start": "1400640",
    "end": "1407520"
  },
  {
    "text": "checked exception H so it it it wraps the exception if the task failed into a",
    "start": "1407520",
    "end": "1413400"
  },
  {
    "text": "runtime exception instead of a checked execution exception otherwise it's just like the get function cancel is funny I",
    "start": "1413400",
    "end": "1420640"
  },
  {
    "text": "will get into this into a mini and into a minute it's just supported because the future interface always had a cancel",
    "start": "1420640",
    "end": "1427480"
  },
  {
    "text": "function okay then there is another part of the API which I called the result",
    "start": "1427480",
    "end": "1432640"
  },
  {
    "text": "provider API and this is for people who want to return completable f futures",
    "start": "1432640",
    "end": "1439200"
  },
  {
    "text": "from their own functions so what we've been looking into so far is well",
    "start": "1439200",
    "end": "1444240"
  },
  {
    "text": "somebody provides us with a completable future and I want to use the completable future in order to specify all my",
    "start": "1444240",
    "end": "1450520"
  },
  {
    "text": "reactions but I could also be a result provider myself so I'm providing an API",
    "start": "1450520",
    "end": "1458080"
  },
  {
    "text": "which returns a completable future to something so I am providing completable Futures to users of my API and then what",
    "start": "1458080",
    "end": "1466360"
  },
  {
    "text": "I will be doing is I must provide a future which is initially empty and then I have to make Provisions that the",
    "start": "1466360",
    "end": "1472720"
  },
  {
    "text": "result is computed and that the future is completed as soon as the result becomes available what does that look",
    "start": "1472720",
    "end": "1479880"
  },
  {
    "text": "like let's say I want to implement a get web page function yeah it receives a URL",
    "start": "1479880",
    "end": "1487240"
  },
  {
    "text": "and then it is supposed to provide the content of that web page as a string and",
    "start": "1487240",
    "end": "1493320"
  },
  {
    "text": "since it takes time yeah to access the URL and read all the content and stuff it into a string I want to provide a",
    "start": "1493320",
    "end": "1499960"
  },
  {
    "text": "completable future so that the user of my get web page function doesn't have to wait yeah I could implement it and just",
    "start": "1499960",
    "end": "1507240"
  },
  {
    "text": "have the user wait until the string becomes available then my get web page function would return string but that",
    "start": "1507240",
    "end": "1512799"
  },
  {
    "text": "would be a blocking function that takes a long time and if I want to make it more convenient for my users I say okay",
    "start": "1512799",
    "end": "1518640"
  },
  {
    "text": "I provide you with a completion stage let's say this is basically a completable future to a string and then",
    "start": "1518640",
    "end": "1525600"
  },
  {
    "text": "you can specify all your reactions without waiting for the the completion of the result and inside that function I",
    "start": "1525600",
    "end": "1531559"
  },
  {
    "text": "would have to create an empty yet incomplete future then I have to set up",
    "start": "1531559",
    "end": "1536960"
  },
  {
    "text": "well somehow the result calculation which must be set up in a way that eventually it completes the future and",
    "start": "1536960",
    "end": "1544039"
  },
  {
    "text": "then I return the future even before the result exists yeah so that the user can already start specifying all the",
    "start": "1544039",
    "end": "1550799"
  },
  {
    "text": "reactions in source code it looks like this this is my get web page function it returns a completable stage a",
    "start": "1550799",
    "end": "1557640"
  },
  {
    "text": "completable future or completion stage of the string I create an empty",
    "start": "1557640",
    "end": "1562679"
  },
  {
    "text": "completable future which is calling the Constructor then I set up the result",
    "start": "1562679",
    "end": "1567799"
  },
  {
    "text": "computation so I set up a runnable that calls a blocking read page function yeah",
    "start": "1567799",
    "end": "1574360"
  },
  {
    "text": "and that blocks that takes a long time once it is done yeah and returns with the content of the web page as a string",
    "start": "1574360",
    "end": "1582039"
  },
  {
    "text": "I must make sure that the runnable as its Last Action uh completes the future",
    "start": "1582039",
    "end": "1587559"
  },
  {
    "text": "and there is a complete function future has a complete function for exactly this purpose and then it Stuffs the result of",
    "start": "1587559",
    "end": "1594360"
  },
  {
    "text": "blocking read into the future and if it fails there is a complete exceptionally where you can",
    "start": "1594360",
    "end": "1601320"
  },
  {
    "text": "pass in the exception and then you have to make Provisions that this task this runnable is executed so I pass it to",
    "start": "1601320",
    "end": "1608399"
  },
  {
    "text": "some kind of pool yeah and then I return the empty future so far I've just been setting up the runnable been passing it",
    "start": "1608399",
    "end": "1614840"
  },
  {
    "text": "to a fool task is probably not yet running and I return turn the empty future to my user and the user can take",
    "start": "1614840",
    "end": "1620799"
  },
  {
    "text": "the future and stuff in or specify all the reactions to the completion of this",
    "start": "1620799",
    "end": "1627720"
  },
  {
    "text": "Future Okay so this is if you want to design interfaces that return",
    "start": "1627720",
    "end": "1633640"
  },
  {
    "text": "completable Futures in that sense you would be a result Producer instead of a result user okay and there are these two",
    "start": "1633640",
    "end": "1640880"
  },
  {
    "text": "functions complete and complete exceptionally for completing a yet empty future",
    "start": "1640880",
    "end": "1648399"
  },
  {
    "text": "okay so if you compare future task the Java 5 way of of implementing Futures",
    "start": "1648399",
    "end": "1654279"
  },
  {
    "text": "and completable future there's one key difference future task is actually a",
    "start": "1654279",
    "end": "1659559"
  },
  {
    "text": "combination of future and a task it knows the task that",
    "start": "1659559",
    "end": "1666039"
  },
  {
    "text": "it it knows the task which produces the result yeah whereas the completable",
    "start": "1666039",
    "end": "1671240"
  },
  {
    "text": "future decouples the the Handover mechanism of of what is the the future",
    "start": "1671240",
    "end": "1676799"
  },
  {
    "text": "characteristics and the task execution completable future doesn't know anything of the task that executes and produces",
    "start": "1676799",
    "end": "1683720"
  },
  {
    "text": "the result yeah which makes for funny results because I mean with future task",
    "start": "1683720",
    "end": "1689200"
  },
  {
    "text": "the cancel function made sense because you could cancel the task while it was",
    "start": "1689200",
    "end": "1694519"
  },
  {
    "text": "running completable future has a cancel function and you can call it but the",
    "start": "1694519",
    "end": "1700039"
  },
  {
    "text": "result is just that the the future would return exceptionally and the task is",
    "start": "1700039",
    "end": "1705799"
  },
  {
    "text": "still running and producing the result yeah so since it doesn't know the task cancel is kind of debatable yeah so I",
    "start": "1705799",
    "end": "1712919"
  },
  {
    "text": "wouldn't use it usually if you use the reactive style and the the fluent programming style it would never occur",
    "start": "1712919",
    "end": "1719039"
  },
  {
    "text": "to you you to call cancel in the first place yeah the question uh does it set",
    "start": "1719039",
    "end": "1724840"
  },
  {
    "text": "the interrup back on the other thread uh interrupts it the running uh thread that is executing the T you mean if I call",
    "start": "1724840",
    "end": "1733039"
  },
  {
    "text": "cancel on a completable future does it interrupt the task no it doesn't because it doesn't know the task",
    "start": "1733039",
    "end": "1738840"
  },
  {
    "text": "the task is just alive and running and keeps on doing until it finishes by itself and nobody's interested in the",
    "start": "1738840",
    "end": "1745000"
  },
  {
    "text": "result any longer it's a bad idea to call cancel I",
    "start": "1745000",
    "end": "1750720"
  },
  {
    "text": "would say but but I could um override the cancel and implement the cancellation in",
    "start": "1750720",
    "end": "1758480"
  },
  {
    "text": "the yeah you can certainly derive from the completable future task override",
    "start": "1758480",
    "end": "1764360"
  },
  {
    "text": "cancel with whatever semantics deems reasonable to you that is certainly doable yeah but the default",
    "start": "1764360",
    "end": "1770159"
  },
  {
    "text": "implementation just finishes or completes the future exceptionally yeah",
    "start": "1770159",
    "end": "1776200"
  },
  {
    "text": "and that's it okay good any further questions",
    "start": "1776200",
    "end": "1783080"
  },
  {
    "text": "regarding completable future otherwise I'm moving on to the next abstraction",
    "start": "1783080",
    "end": "1788600"
  },
  {
    "text": "the next one is stamped lock stamped lock as I said is an alternative to the",
    "start": "1788600",
    "end": "1794000"
  },
  {
    "text": "re-enter and read write lock the idea of the classic Java file reenter and read light lock is it wants to allow",
    "start": "1794000",
    "end": "1801880"
  },
  {
    "text": "concurrent execution of readers and only wants to synchronize the combination of",
    "start": "1801880",
    "end": "1807360"
  },
  {
    "text": "reading threads and writing threads or writing threads with other writers yeah if you have several read excesses",
    "start": "1807360",
    "end": "1813799"
  },
  {
    "text": "concurrent read accesses to the data structures that doesn't need synchronization but if you use the regular reentrant blog or the",
    "start": "1813799",
    "end": "1820679"
  },
  {
    "text": "synchronized blocks you would also block or readers would be blocking other readers and in order to avoid this nonne",
    "start": "1820679",
    "end": "1828039"
  },
  {
    "text": "necessary uh synchronization of one reader with another reader reenter and",
    "start": "1828039",
    "end": "1833399"
  },
  {
    "text": "read WR lock just has a mode in which several readers can access the data",
    "start": "1833399",
    "end": "1838600"
  },
  {
    "text": "writers are blocked yeah and otherwise it blocks the combination of two writers and readers and writers but readers",
    "start": "1838600",
    "end": "1845440"
  },
  {
    "text": "alone can run in parallel and the stamp lock is some kind of an extension to it",
    "start": "1845440",
    "end": "1853399"
  },
  {
    "text": "or it's very similar the stamped lock internally consists of a version number",
    "start": "1853399",
    "end": "1858559"
  },
  {
    "text": "the stamp that that provides or as part of the name and the internal mode whether the stamp lock is in read write",
    "start": "1858559",
    "end": "1865360"
  },
  {
    "text": "mode right or an optimistic uh mode an optimistic read mode this is what makes the difference",
    "start": "1865360",
    "end": "1872000"
  },
  {
    "text": "between the re-enter read right lock which is always a pessimistic lock pessimistic means um I want to acquire",
    "start": "1872000",
    "end": "1880480"
  },
  {
    "text": "the lock and I want to be sure that there that I have for instance if I acquire the right log I want to make",
    "start": "1880480",
    "end": "1887039"
  },
  {
    "text": "sure that I have have exclusive access to the data no other writer no other reader can run this is what I expect of",
    "start": "1887039",
    "end": "1893600"
  },
  {
    "text": "a pessimistic lock similarly if I acquire a pessimistic read log then I want to make sure that only readers are",
    "start": "1893600",
    "end": "1900000"
  },
  {
    "text": "running and no writer is running and what the stamp lock provides is an",
    "start": "1900000",
    "end": "1905559"
  },
  {
    "text": "optimistic read mode and this allows for optimizations in low content low",
    "start": "1905559",
    "end": "1911799"
  },
  {
    "text": "contention situations where there are only very few threats and there's hardly any concurrent um access to the data and",
    "start": "1911799",
    "end": "1919000"
  },
  {
    "text": "then I want to try to read the data without actually acquiring the lck I just I just hope for the best yeah in an",
    "start": "1919000",
    "end": "1926159"
  },
  {
    "text": "optimistic mode I read the data grab it but I cannot be sure that I really had",
    "start": "1926159",
    "end": "1932360"
  },
  {
    "text": "exclusive access to it I have to validate afterwards and make sure that there was no concurrent excess that the",
    "start": "1932360",
    "end": "1939360"
  },
  {
    "text": "op my optimistic approach was justified and this optimistic approach has",
    "start": "1939360",
    "end": "1944679"
  },
  {
    "text": "exhibits better performance unless it fails yeah let's see so internally it",
    "start": "1944679",
    "end": "1951240"
  },
  {
    "text": "maintains a stamp each time you acquire a lock a stamp is is presented to you",
    "start": "1951240",
    "end": "1956440"
  },
  {
    "text": "and you need to keep that stamp until you unlock or release the lock and if",
    "start": "1956440",
    "end": "1961960"
  },
  {
    "text": "the stamp is zero it means uh you didn't receive the lock so the acquisition",
    "start": "1961960",
    "end": "1967399"
  },
  {
    "text": "failed okay and then it has the right mode which is a pessimistic right mode",
    "start": "1967399",
    "end": "1973000"
  },
  {
    "text": "like with a re-entrant lock it makes sure that the the threat that acquires",
    "start": "1973000",
    "end": "1978200"
  },
  {
    "text": "the stamp Block in right mode is the only one the only thread and it has exclusive access to the data okay in",
    "start": "1978200",
    "end": "1986240"
  },
  {
    "text": "that mode if there's one thread in right mode then no readers can run uh every",
    "start": "1986240",
    "end": "1991720"
  },
  {
    "text": "attempt to acquire an optimistic readlock will fail yeah it really guarantees exclusive access to the data",
    "start": "1991720",
    "end": "1999039"
  },
  {
    "text": "then we have the read mode that's the same read mode with with like that we have with the reenter and read write log",
    "start": "1999039",
    "end": "2005600"
  },
  {
    "text": "it allows non-exclusive EX because you can have parallell running",
    "start": "2005600",
    "end": "2011240"
  },
  {
    "text": "writer readers the writers are blocked but readers can run in parallel so you don't have exclusive access because you",
    "start": "2011240",
    "end": "2018200"
  },
  {
    "text": "are just reading the data and other threads are also allowed to read the data concurrently this is exactly like",
    "start": "2018200",
    "end": "2024320"
  },
  {
    "text": "with reenter and read write lock and then there is this optimistic read mode and the optimistic read mode is an",
    "start": "2024320",
    "end": "2030600"
  },
  {
    "text": "extremely weak version of a read log I'm just saying okay I will try an",
    "start": "2030600",
    "end": "2036320"
  },
  {
    "text": "optimistic read and afterwards I will simply read yeah no matter whether there is concurrent",
    "start": "2036320",
    "end": "2041799"
  },
  {
    "text": "excess or not and after reading I will ask was there a concurrent excess in",
    "start": "2041799",
    "end": "2047399"
  },
  {
    "text": "between the time when I announced I will read and until I ask whether it was",
    "start": "2047399",
    "end": "2052638"
  },
  {
    "text": "valid and the optimistic read mode can be broken at any time so if there is one thread saying okay I'm optimistically",
    "start": "2052639",
    "end": "2059480"
  },
  {
    "text": "reading other readers can join which is not a problem but also other writers can",
    "start": "2059480",
    "end": "2064800"
  },
  {
    "text": "join and modify the data that the optimistically reading thread is currently reading and in that case",
    "start": "2064800",
    "end": "2071000"
  },
  {
    "text": "you're probably reading inconsistent data half modified half not yeah so you must validate afterwards let's take a",
    "start": "2071000",
    "end": "2078638"
  },
  {
    "text": "look at an example okay this example is classic re-enter and read write lock yeah pessimistic locking you have data",
    "start": "2078639",
    "end": "2085398"
  },
  {
    "text": "you want to synchronize it by using a read right lock and the idea is you use the right lock part for all modifying",
    "start": "2085399",
    "end": "2092320"
  },
  {
    "text": "functions and the read log part for all readon functions that's the classic way of doing it pessimistic read and write",
    "start": "2092320",
    "end": "2099440"
  },
  {
    "text": "log you can do the same with the stamp log it looks slightly different yeah you",
    "start": "2099440",
    "end": "2104640"
  },
  {
    "text": "create a stamp log each time you acquire a lock yeah you would acquire a right lck and a read log you receive a stamp",
    "start": "2104640",
    "end": "2112119"
  },
  {
    "text": "and you need to use the stamp and pass it to the corresponding unlock function otherwise it's exactly the same as",
    "start": "2112119",
    "end": "2117960"
  },
  {
    "text": "reenter and read write lock the new stuff comes into play when I want to try an optimistic read an optimistic read is",
    "start": "2117960",
    "end": "2126640"
  },
  {
    "text": "for predominantly for short read sequences of read access to the data",
    "start": "2126640",
    "end": "2132000"
  },
  {
    "text": "that should be very short code segments because the longer it takes to read the data um the more likely it is that there",
    "start": "2132000",
    "end": "2138599"
  },
  {
    "text": "is concurrent right access in between and that you will fail eventually okay so this is what it looks",
    "start": "2138599",
    "end": "2144880"
  },
  {
    "text": "like my data consists of two integers primitive type integers part one and part two I have a stemed lock and now I",
    "start": "2144880",
    "end": "2153000"
  },
  {
    "text": "want to read optimistically so I say try optimistic read thereby I'm I'm",
    "start": "2153000",
    "end": "2158880"
  },
  {
    "text": "announcing okay I will try an optimistic read and I will later call a validate function and then please tell me whether",
    "start": "2158880",
    "end": "2165160"
  },
  {
    "text": "there was an concurrent right excess in between so I read the two integers which is a very short code segment of",
    "start": "2165160",
    "end": "2172839"
  },
  {
    "text": "reading and then I validate then I ask was there while I was reading was there",
    "start": "2172839",
    "end": "2178680"
  },
  {
    "text": "some kind of concurrent right access if so the data can be inconsistent yeah you",
    "start": "2178680",
    "end": "2183800"
  },
  {
    "text": "might have been reading one integer before the modification and the other one afterwards and you have consistent data which is useless so the validation",
    "start": "2183800",
    "end": "2191119"
  },
  {
    "text": "can fail if it succeeds yeah then you can just use your local integers and",
    "start": "2191119",
    "end": "2196680"
  },
  {
    "text": "calculate them and take take your time because now you're working on local copies of the actually interesting data",
    "start": "2196680",
    "end": "2203160"
  },
  {
    "text": "if it fails yeah there could have been concurrent right exess in between and validate would tell you false it failed",
    "start": "2203160",
    "end": "2210280"
  },
  {
    "text": "there was concurrent excess then you can yeah you need to produce some kind of reaction one thing you can do is a read",
    "start": "2210280",
    "end": "2217680"
  },
  {
    "text": "try you could spin in a loop and retry until you eventually succeed or you can",
    "start": "2217680",
    "end": "2223839"
  },
  {
    "text": "fall back to pessimistic locking which is what I'm doing here as soon as the validation fails that which is basically",
    "start": "2223839",
    "end": "2231319"
  },
  {
    "text": "the message okay there are concurrent writers your data is inconsistent I acquire the pessimistic",
    "start": "2231319",
    "end": "2239079"
  },
  {
    "text": "readlock and acquiring the pessimistic readlock means I am waiting until all",
    "start": "2239079",
    "end": "2245119"
  },
  {
    "text": "writers are gone yeah and then I I get well the guarantee that only readers",
    "start": "2245119",
    "end": "2251280"
  },
  {
    "text": "will be active while I am reading part one and part two of the interesting data",
    "start": "2251280",
    "end": "2256400"
  },
  {
    "text": "and afterwards you have to unlock the read lock and then I can again calculate whatever I want to calculate based on",
    "start": "2256400",
    "end": "2262480"
  },
  {
    "text": "the data yeah ah five minutes left okay that much about stamp loock it",
    "start": "2262480",
    "end": "2271000"
  },
  {
    "text": "also has optimistic uh upgrade techniques yeah if you want to upgrade from a read lock to to a right lock",
    "start": "2271000",
    "end": "2277520"
  },
  {
    "text": "that's also a difference to the regular re-entrant rri lock accumulators",
    "start": "2277520",
    "end": "2282560"
  },
  {
    "text": "accumulators are not not extremely interesting it's basically an alternative to the atomic lock with",
    "start": "2282560",
    "end": "2289000"
  },
  {
    "text": "atomics you know atomics are used for Block free programming you wouldn't use",
    "start": "2289000",
    "end": "2296520"
  },
  {
    "text": "any kind of locks in order to get exclusive access to a long value for instance but instead you would be using",
    "start": "2296520",
    "end": "2303040"
  },
  {
    "text": "an atomic lock and using Atomic always means um you are reading the current",
    "start": "2303040",
    "end": "2308480"
  },
  {
    "text": "value with just one Atomic operation then you calculate a new value based on",
    "start": "2308480",
    "end": "2314560"
  },
  {
    "text": "the previous value and while you're calculating that could be again concurrent right access to the data that",
    "start": "2314560",
    "end": "2320720"
  },
  {
    "text": "you've been reading and in order to doing some kind similar to the validate that we just had you will be doing a",
    "start": "2320720",
    "end": "2326880"
  },
  {
    "text": "compare and swap operation and compare and swap means okay if there is still the previous old value then please",
    "start": "2326880",
    "end": "2333200"
  },
  {
    "text": "override it with a new value and if the old value isn't there anymore then there was conc current right excess then it",
    "start": "2333200",
    "end": "2339119"
  },
  {
    "text": "fails and tells you yeah and typically with an atomic long the reaction to failure is retry retry spin in a loop",
    "start": "2339119",
    "end": "2346880"
  },
  {
    "text": "until you succeed Atomic Longs are threat safe and used for Lock Free programming Lock Free",
    "start": "2346880",
    "end": "2353680"
  },
  {
    "text": "access to a long for instance there's one problem with the atomic long or let's say there is room for",
    "start": "2353680",
    "end": "2359520"
  },
  {
    "text": "optimizations which the long Adder uh provides if you have very many threads",
    "start": "2359520",
    "end": "2365800"
  },
  {
    "text": "accessing the atomic long then they will fail very often and they will spin quite a while in the loop until they succeed",
    "start": "2365800",
    "end": "2372599"
  },
  {
    "text": "and in order to avoid these retry uh latency they provided the long adder and",
    "start": "2372599",
    "end": "2379640"
  },
  {
    "text": "the long Adder doesn't maintain a single long which is concurrently accessed but",
    "start": "2379640",
    "end": "2386160"
  },
  {
    "text": "it has several Atomic cells so it splits up the actual content the actual long",
    "start": "2386160",
    "end": "2392520"
  },
  {
    "text": "value into various Longs so if one thread wants to add something to the",
    "start": "2392520",
    "end": "2398160"
  },
  {
    "text": "atomic long or the long Adder um and one of the cells is current is under concurrent excess yeah just one of the",
    "start": "2398160",
    "end": "2405560"
  },
  {
    "text": "uncontended cells is updated so that basically the the the entire result",
    "start": "2405560",
    "end": "2411200"
  },
  {
    "text": "isn't produced until you actually ask for the content of the long Adder so",
    "start": "2411200",
    "end": "2417000"
  },
  {
    "text": "basically it tries to reduce contention and failure excess failure by splitting",
    "start": "2417000",
    "end": "2422079"
  },
  {
    "text": "it up into different cells yeah so that one thread just adds the value to an un",
    "start": "2422079",
    "end": "2427359"
  },
  {
    "text": "contended cell and only if you retrieve the result the actual long value is",
    "start": "2427359",
    "end": "2433240"
  },
  {
    "text": "calculated so you have ADD increment and decrement functions that don't return anything which is different from Atomic",
    "start": "2433240",
    "end": "2438839"
  },
  {
    "text": "long Atomic long has a get an increment function it Returns the value and this one doesn't return the value until you",
    "start": "2438839",
    "end": "2444720"
  },
  {
    "text": "ask give me the sum yeah and then it adds up all the all the cells this is",
    "start": "2444720",
    "end": "2450680"
  },
  {
    "text": "the long Eder the double Eder is the same thing and the accumulators are just an",
    "start": "2450680",
    "end": "2455839"
  },
  {
    "text": "generalization uh you can provide an accumulation functions it need not be calculating the sum yeah you could",
    "start": "2455839",
    "end": "2462319"
  },
  {
    "text": "calculate the product or whatever else uh whatever different kind of accumulation you want to do okay",
    "start": "2462319",
    "end": "2469680"
  },
  {
    "text": "concurrent hash map has a lot of interesting extensions you can look into",
    "start": "2469680",
    "end": "2475800"
  },
  {
    "text": "yeah the concurr hash map has been reorganized internally the buckets are no longer lists but they are trees if",
    "start": "2475800",
    "end": "2482800"
  },
  {
    "text": "the key type is comparable which is basically an optimization for key types that have poor head functions so that's",
    "start": "2482800",
    "end": "2488839"
  },
  {
    "text": "an internal thing and then it has additional functions and these additional functions exist in the regular map interface so for instance",
    "start": "2488839",
    "end": "2495960"
  },
  {
    "text": "you have a compute function and the compute function um will calculate the",
    "start": "2495960",
    "end": "2503160"
  },
  {
    "text": "key and the value you provide a function that can calculate the value for a given",
    "start": "2503160",
    "end": "2509720"
  },
  {
    "text": "key so you do not provide the key and the value they provide the key and a function that calculates the value there",
    "start": "2509720",
    "end": "2515960"
  },
  {
    "text": "are Compu of epson compute if present functions and there is an example here where I'm using compute if absent given",
    "start": "2515960",
    "end": "2523720"
  },
  {
    "text": "a list of strings I want to produce a hash map a concurrent hash map that",
    "start": "2523720",
    "end": "2528920"
  },
  {
    "text": "Associates to e each string the frequency in which it appears in my list",
    "start": "2528920",
    "end": "2534800"
  },
  {
    "text": "of strings okay so I create a concurrent hash map of string and long Adder the",
    "start": "2534800",
    "end": "2540839"
  },
  {
    "text": "counter the the frequency counter and then I Loop over all the strings in my",
    "start": "2540839",
    "end": "2547559"
  },
  {
    "text": "list of strings and then I compute if absent yeah so if I found a string yeah",
    "start": "2547559",
    "end": "2553359"
  },
  {
    "text": "if that string has not yet been added as a key in into the map I would calculate",
    "start": "2553359",
    "end": "2559520"
  },
  {
    "text": "the first value the initial value which is a a new long Eder yeah long Eder so",
    "start": "2559520",
    "end": "2565599"
  },
  {
    "text": "far is initialized with zero value and the new value is returned from Compu if",
    "start": "2565599",
    "end": "2571200"
  },
  {
    "text": "absent so I I produce if the word appears for the first time I produce a",
    "start": "2571200",
    "end": "2576280"
  },
  {
    "text": "key value pair with the string and a new long Adder that contains zero the long",
    "start": "2576280",
    "end": "2582160"
  },
  {
    "text": "Adder is returned and I incremented the next time the word appears it's no longer absent yeah and then just the",
    "start": "2582160",
    "end": "2589720"
  },
  {
    "text": "associated value is returned and I increment and this way the result is a list of words and a word",
    "start": "2589720",
    "end": "2596920"
  },
  {
    "text": "counter and all these operations are Atomic with a concurrent hashmap",
    "start": "2596920",
    "end": "2602400"
  },
  {
    "text": "guaranteed to be Atomic the side or let's say one of the requirement is that",
    "start": "2602400",
    "end": "2607760"
  },
  {
    "text": "your remapping functions do not take a long time yeah otherwise they would be blocking access to certain segments of",
    "start": "2607760",
    "end": "2614680"
  },
  {
    "text": "the hash map and there is more of this a merge function yeah there are for each",
    "start": "2614680",
    "end": "2620079"
  },
  {
    "text": "search and reduce functions in four flavors so 12 additional new methods all",
    "start": "2620079",
    "end": "2625960"
  },
  {
    "text": "Atomic methods in a concurrent hashmap okay let's skip a couple of",
    "start": "2625960",
    "end": "2631839"
  },
  {
    "text": "details the common pool I already mentioned there is a common pool that is used in all cases where do where you do",
    "start": "2631839",
    "end": "2639000"
  },
  {
    "text": "not provide an explicit pool like for if you if you supply a runnable to the",
    "start": "2639000",
    "end": "2645079"
  },
  {
    "text": "completable Future for instance or the streams they also use the common pool and that's a Singleton fog joint pool",
    "start": "2645079",
    "end": "2651720"
  },
  {
    "text": "one single for joint pool a static fog joint pool that is pre configured yeah",
    "start": "2651720",
    "end": "2658400"
  },
  {
    "text": "there is only one for all the stream operations for all the cases in which you need a pool but do not specify one",
    "start": "2658400",
    "end": "2665680"
  },
  {
    "text": "yourself no um it differs from a regular Fork joint",
    "start": "2665680",
    "end": "2670920"
  },
  {
    "text": "pool by lazy initialization so it starts with no thread and then builds up the number of threads and reduces the number",
    "start": "2670920",
    "end": "2676680"
  },
  {
    "text": "of threads if they are no longer needed U it has a default preconfigured size",
    "start": "2676680",
    "end": "2683280"
  },
  {
    "text": "which is available processes minus one yeah there are system properties you can change that value so you can change the",
    "start": "2683280",
    "end": "2690000"
  },
  {
    "text": "size of the pool and the shutdown behavior is different it's basically a pool of demon threats so as soon as the",
    "start": "2690000",
    "end": "2696640"
  },
  {
    "text": "last user Threat terminates all the pool threats are automatically terminated",
    "start": "2696640",
    "end": "2703319"
  },
  {
    "text": "which can produce certain problems so if you've been passing task to let's say a",
    "start": "2703319",
    "end": "2708720"
  },
  {
    "text": "completable future or a stream operation yeah and you would actually still be needing the common pool but the last",
    "start": "2708720",
    "end": "2714920"
  },
  {
    "text": "user thread exits then the pool is shut down automatically and your task will no",
    "start": "2714920",
    "end": "2720040"
  },
  {
    "text": "longer be executed so that requires some kind of",
    "start": "2720040",
    "end": "2726119"
  },
  {
    "text": "of measurements you have to wait until the pool has been executed or the task that",
    "start": "2726119",
    "end": "2733240"
  },
  {
    "text": "you passed to it before actually the last user threat executes there isn't a wait quation function for doing exactly",
    "start": "2733240",
    "end": "2739640"
  },
  {
    "text": "this it waits for an empty pool no Tas all threats are idle nothing to do yeah",
    "start": "2739640",
    "end": "2746040"
  },
  {
    "text": "then you can await this particular state of of the pool and then terminate do I still have time for",
    "start": "2746040",
    "end": "2752960"
  },
  {
    "text": "contended like two minutes two minutes for contended okay two minutes for contended contend is very very low level",
    "start": "2752960",
    "end": "2760440"
  },
  {
    "text": "uh it actually addresses false sharing and false sharing means I mean you know the the hardware architecture of of",
    "start": "2760440",
    "end": "2767079"
  },
  {
    "text": "multicore CPU they they heavily use caches cores caches that",
    "start": "2767079",
    "end": "2773520"
  },
  {
    "text": "are uh linked to a certain core and often you have hierarchical caches and",
    "start": "2773520",
    "end": "2779440"
  },
  {
    "text": "the idea is uh if an object I mean if if",
    "start": "2779440",
    "end": "2784480"
  },
  {
    "text": "objects or data is placed into the cache and one thread modifies the cach and other threads want to see the",
    "start": "2784480",
    "end": "2790400"
  },
  {
    "text": "modification there must be flash flushes and refreshes into main memory this is what uh the memory model of java is",
    "start": "2790400",
    "end": "2798040"
  },
  {
    "text": "about and there are memory model rules for synchronization and for volatile and and for for final Fields also have rules",
    "start": "2798040",
    "end": "2806960"
  },
  {
    "text": "which is fine but you can run into the the following problem typically if you have a class like my point class here it",
    "start": "2806960",
    "end": "2813599"
  },
  {
    "text": "has two integer Fields what the uh compiler tries to do is to pack all the",
    "start": "2813599",
    "end": "2819599"
  },
  {
    "text": "contents of an object densely together yeah in order to save space and to save",
    "start": "2819599",
    "end": "2825800"
  },
  {
    "text": "memory so the entire object with both integers would end up in the same cach",
    "start": "2825800",
    "end": "2832000"
  },
  {
    "text": "line of of a given core okay if one of the two Fields is a hot field let's say",
    "start": "2832000",
    "end": "2838280"
  },
  {
    "text": "it's a volatile field and it needs it has concurrent excess and it needs many flushers and",
    "start": "2838280",
    "end": "2843880"
  },
  {
    "text": "Refreshers then typically the entire cach line becomes hot if if one bit or one integer inside that cach line uh",
    "start": "2843880",
    "end": "2851280"
  },
  {
    "text": "needs flushes and refreshes what the hardware does it flushes and refreshes the entire the entire cach line each",
    "start": "2851280",
    "end": "2859040"
  },
  {
    "text": "time it is accessed even if it is accessed on a cold field yeah the cold field doesn't even need the the flushes",
    "start": "2859040",
    "end": "2865800"
  },
  {
    "text": "and refreshes but the entire cach line yeah because there is a volatile or hot field in it the entire cach line is",
    "start": "2865800",
    "end": "2871440"
  },
  {
    "text": "updated and flushed and refreshed all of the time so if one of the fields is a hot one a volatile one yeah it triggers",
    "start": "2871440",
    "end": "2879200"
  },
  {
    "text": "flushing and refreshing each time anything in that cach line is accessed and that is a performance impediment",
    "start": "2879200",
    "end": "2885359"
  },
  {
    "text": "yeah the caching is supposed to boost the performance and you're doing quite the opposite if you have cold fields and",
    "start": "2885359",
    "end": "2891920"
  },
  {
    "text": "hot fields in the same cach line and what the contended uh annotation is trying to do uh it tries to separate",
    "start": "2891920",
    "end": "2899480"
  },
  {
    "text": "cold fields from hot Fields yeah so you can mark the hot stuff with the contented annotation and what the jvm",
    "start": "2899480",
    "end": "2907319"
  },
  {
    "text": "does is it inserts padding bites in order to make sure that the cold fields are in one cach line if they are",
    "start": "2907319",
    "end": "2913720"
  },
  {
    "text": "excessed no flushing and refreshing is necessary and the hot field sits in another cach line and each time it is",
    "start": "2913720",
    "end": "2920599"
  },
  {
    "text": "excessed then all the necessary flushing and refreshing is done but it is done only then only if I access the hot field",
    "start": "2920599",
    "end": "2928079"
  },
  {
    "text": "and contenter comes in different flavors for single field for groups for entire objects all fields of an object it's",
    "start": "2928079",
    "end": "2933799"
  },
  {
    "text": "very very low level uh if you don't know what to do with it then probably you don't need it yeah it's used inside the",
    "start": "2933799",
    "end": "2940119"
  },
  {
    "text": "jdk implementations for instance if you look into the fork joint pool in a fork joint pool every thread has its own work",
    "start": "2940119",
    "end": "2947680"
  },
  {
    "text": "CU and the work CU should be thread specific yeah and it is a contended class yeah so that you don't have false",
    "start": "2947680",
    "end": "2955040"
  },
  {
    "text": "sharing because there are several work cues in the same cach line and you would create flushing and refreshing no matter",
    "start": "2955040",
    "end": "2961240"
  },
  {
    "text": "which thread accesses which queue okay that's an example okay",
    "start": "2961240",
    "end": "2967240"
  },
  {
    "text": "any questions so first of all thank you um we already have some questions online",
    "start": "2967240",
    "end": "2974640"
  },
  {
    "text": "Okay um since we already took some from the audience during the talk I would like to take this one um so one question",
    "start": "2974640",
    "end": "2980640"
  },
  {
    "text": "is is or in the example with the new log do the fields should be volatile or",
    "start": "2980640",
    "end": "2986480"
  },
  {
    "text": "should the field be volatile in the example with the new lock should the fields be",
    "start": "2986480",
    "end": "2994480"
  },
  {
    "text": "volatile uh that's probably a pressing the stamp lock in the example with stamp",
    "start": "2994480",
    "end": "3000520"
  },
  {
    "text": "lock now if you use the stamp lock the fields need not be volatile because the lock it's a lock yeah every lock makes",
    "start": "3000520",
    "end": "3006880"
  },
  {
    "text": "sure that there are flushes and refreshes that guarantee visibility of the modifications that are done under",
    "start": "3006880",
    "end": "3013559"
  },
  {
    "text": "the protection of the lock so they need not be volatile okay okay we have another",
    "start": "3013559",
    "end": "3019079"
  },
  {
    "text": "question with which formally uh is a question but I don't think you can answer it it's more like directed to",
    "start": "3019079",
    "end": "3024960"
  },
  {
    "text": "Oracle um so maybe one more question from the audience last",
    "start": "3024960",
    "end": "3031680"
  },
  {
    "text": "one ah",
    "start": "3032240",
    "end": "3035599"
  },
  {
    "text": "okay uh I have learned that uh using classes from the Sun package uh is an",
    "start": "3043079",
    "end": "3050280"
  },
  {
    "text": "big noo uh right how official is this uh annotation it is official it's it's an",
    "start": "3050280",
    "end": "3056880"
  },
  {
    "text": "official part of the Oracle jdk yeah and if you need it if you build lowlevel",
    "start": "3056880",
    "end": "3062839"
  },
  {
    "text": "abstractions uh people are using it uh but it's not for everyday programming so",
    "start": "3062839",
    "end": "3068920"
  },
  {
    "text": "it is official but most likely you will not need it in most cases so it's basically part or it's provided for the",
    "start": "3068920",
    "end": "3075799"
  },
  {
    "text": "library implementers or other people who build libraries or Frameworks of their own so it's official but yeah still you",
    "start": "3075799",
    "end": "3081880"
  },
  {
    "text": "shouldn't be using it okay okay thank you very much okay in lots of",
    "start": "3081880",
    "end": "3087240"
  },
  {
    "text": "interesting insights into uh new stuff in Java 8 which was kind of drowned in the noise generated by lambas um okay",
    "start": "3087240",
    "end": "3094839"
  },
  {
    "text": "hope to see you in a few minutes for last talk for today okay thank you",
    "start": "3094839",
    "end": "3100940"
  },
  {
    "text": "[Applause] [Music]",
    "start": "3100940",
    "end": "3113789"
  }
]