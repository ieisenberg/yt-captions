[
  {
    "text": "I'm going to talk today about something that I'm guessing nobody in the room has ever heard of before",
    "start": "4200",
    "end": "9420"
  },
  {
    "text": "all right anybody here actually read any of the papers on propagators one person",
    "start": "9420",
    "end": "15680"
  },
  {
    "text": "[Laughter] okay um so uh a buddy of mine uh Alexi radul did",
    "start": "15680",
    "end": "22619"
  },
  {
    "text": "his PhD thesis with Jerry Sussman on the topic it's an old topic that uh that",
    "start": "22619",
    "end": "28140"
  },
  {
    "text": "Jerry's been playing around with for a couple of decades or so and he finally got a PhD student he could sucker into",
    "start": "28140",
    "end": "34260"
  },
  {
    "text": "actually working on it in 2009. um and in order to explain what a",
    "start": "34260",
    "end": "41219"
  },
  {
    "text": "propagator is I'm going to have to go off and build up a bunch of other math first and then and then it'll be really",
    "start": "41219",
    "end": "46800"
  },
  {
    "text": "easy okay um so I'm going to go off to one of my favorite books which is Introduction to",
    "start": "46800",
    "end": "53820"
  },
  {
    "text": "lattice is in order by Davey and Priestley and um just talk about the concept of a",
    "start": "53820",
    "end": "61260"
  },
  {
    "text": "joined semi-lattice for a minute which I believe uh George talked about earlier in a talk so for everybody who went to",
    "start": "61260",
    "end": "68520"
  },
  {
    "text": "that track will have a little bit of a leg up um which is basically I want to talk",
    "start": "68520",
    "end": "74280"
  },
  {
    "text": "about a semi-lattice we'll have some binary operation that will be commutative it's associative",
    "start": "74280",
    "end": "80400"
  },
  {
    "text": "it's item potent and it's unital so it's a commutative item potent monolite",
    "start": "80400",
    "end": "87720"
  },
  {
    "text": "okay not terribly scary",
    "start": "87720",
    "end": "93600"
  },
  {
    "text": "yet um and if you have one of these things then it sort of naturally gives you a",
    "start": "93600",
    "end": "100979"
  },
  {
    "text": "concept of an ordering we can say that a is less than b at less than or equal to B Whenever there exists something that I",
    "start": "100979",
    "end": "107880"
  },
  {
    "text": "could join with a to get to B okay",
    "start": "107880",
    "end": "113840"
  },
  {
    "text": "and um the way I'm going to try and uh treat this will be I'll I'm going to just to",
    "start": "114180",
    "end": "120119"
  },
  {
    "text": "kind of get our feet wet I'll just draw a few I'll show a couple of like house diagrams of of different",
    "start": "120119",
    "end": "126360"
  },
  {
    "text": "um different joint semi lattices that we might want to play with okay and so we draw these diagrams",
    "start": "126360",
    "end": "133319"
  },
  {
    "text": "Whenever there is something that's directly above an element but there's no element in between so I don't draw an",
    "start": "133319",
    "end": "139620"
  },
  {
    "text": "edge between here and here because there's a path that goes up okay and so what we're saying when we",
    "start": "139620",
    "end": "146760"
  },
  {
    "text": "have um these two elements we're looking for like the least upper bound that would be",
    "start": "146760",
    "end": "152220"
  },
  {
    "text": "their join so not too scary in this case what we",
    "start": "152220",
    "end": "158940"
  },
  {
    "text": "have is a triple of zeros and ones and we're saying that a is less that this is less than or equal to the other thing if",
    "start": "158940",
    "end": "164819"
  },
  {
    "text": "it's less than in every it less than or equal to in every position",
    "start": "164819",
    "end": "170819"
  },
  {
    "text": "this is a partial order not a total order and so every um joint semi lattice is going to give",
    "start": "170819",
    "end": "176940"
  },
  {
    "text": "rise to a partial order and the ones that we choose to draw are",
    "start": "176940",
    "end": "182099"
  },
  {
    "text": "the ones where there's nothing in the middle so those are when we draw these these sort of funny host diagrams that pop up",
    "start": "182099",
    "end": "189239"
  },
  {
    "text": "and they and they can get pretty pretty um or rather pretty um in this case we've got sets",
    "start": "189239",
    "end": "196200"
  },
  {
    "text": "and as we add elements and we Union the two as we Union the",
    "start": "196200",
    "end": "201599"
  },
  {
    "text": "sets moving upward we are able to um build larger and larger sets this is",
    "start": "201599",
    "end": "207420"
  },
  {
    "text": "one example um we could flip this whole thing around and basically do intersections",
    "start": "207420",
    "end": "212700"
  },
  {
    "text": "to build one that comes the other that came the other way I'd have to flip the whole slide over Didn't Do It",
    "start": "212700",
    "end": "218879"
  },
  {
    "text": "um um the sort of notion of",
    "start": "218879",
    "end": "223920"
  },
  {
    "text": "merging together information is the piece that I'm actually going to care about and so to show that we can show a",
    "start": "223920",
    "end": "230819"
  },
  {
    "text": "sort of it's kind of a classic linguistic example um it's a little I guess CIS Centric",
    "start": "230819",
    "end": "238500"
  },
  {
    "text": "um and maybe my wife would be upset with the fact that it doesn't actually it doesn't believe that um adult children",
    "start": "238500",
    "end": "243780"
  },
  {
    "text": "can exist um but other than that",
    "start": "243780",
    "end": "249599"
  },
  {
    "text": "um it's a decent start so here we can say that you know if if you start with no knowledge",
    "start": "249599",
    "end": "257459"
  },
  {
    "text": "um and then you gain the fat knowledge that something uh someone is female and you gain the knowledge that they're",
    "start": "257459",
    "end": "262620"
  },
  {
    "text": "a child then you can label them a girl okay again very cis-centric 1970s",
    "start": "262620",
    "end": "268320"
  },
  {
    "text": "Linguistics sort of example um I probably should have chosen something",
    "start": "268320",
    "end": "274380"
  },
  {
    "text": "better now um so the the paper on on",
    "start": "274380",
    "end": "280620"
  },
  {
    "text": "propagators was this art of the propagator paper by radul and Sussman and in order to talk about this I need",
    "start": "280620",
    "end": "288060"
  },
  {
    "text": "one more thing which is just the notion of a monotone function I'm going to talk about every time I say monotone",
    "start": "288060",
    "end": "294300"
  },
  {
    "text": "functions it's going to be between partial orders and I'm always going to be assuming that we're talking about monotone increasing",
    "start": "294300",
    "end": "300000"
  },
  {
    "text": "okay so just a is less than or equal to B implies that F of a is less than or equal to F of B and in in a very deep",
    "start": "300000",
    "end": "306060"
  },
  {
    "text": "way every function in Haskell is monotone okay when we start talking about denotational semantics of things",
    "start": "306060",
    "end": "312120"
  },
  {
    "text": "we're starting to work in these complete partial orders um and what I mean I don't mean that like",
    "start": "312120",
    "end": "318540"
  },
  {
    "text": "that if you view it like if we're talking about numbers one two three four five that those go this way and every",
    "start": "318540",
    "end": "324120"
  },
  {
    "text": "function must be you know must be monotone in that sense what I mean is that if we put like bottom at the at the like is",
    "start": "324120",
    "end": "331560"
  },
  {
    "text": "undefined I don't know anything then we have a level above that which is that I know that it's exactly two or I",
    "start": "331560",
    "end": "337020"
  },
  {
    "text": "know that it's exactly four um there's we go from less defined to more defined there is a an ordering",
    "start": "337020",
    "end": "344100"
  },
  {
    "text": "based on how defined something is okay and so every function in Haskell is",
    "start": "344100",
    "end": "350940"
  },
  {
    "text": "a monotone function with respect to that defined in this ordering",
    "start": "350940",
    "end": "355820"
  },
  {
    "text": "okay so we're we're already kind of familiar with doing with working with monotone",
    "start": "356759",
    "end": "363120"
  },
  {
    "text": "functions so now I'm finally equipped to say what a propagator is",
    "start": "363120",
    "end": "368520"
  },
  {
    "text": "a propagator is a monotone function between joined semi-lattices",
    "start": "368520",
    "end": "373800"
  },
  {
    "text": "that's it and then what I'm going to call a propagator network is now now it's going",
    "start": "373800",
    "end": "380940"
  },
  {
    "text": "to throw around a more scary terminology it's a hypergraph of propagators",
    "start": "380940",
    "end": "386340"
  },
  {
    "text": "where the propagators are my edges or the hyper edges they can have more than one input I can read from multiple input",
    "start": "386340",
    "end": "392699"
  },
  {
    "text": "lattices and scribble out theoretically even to multiple output lattices um",
    "start": "392699",
    "end": "397860"
  },
  {
    "text": "and the nodes will be individual joint semi-lattices",
    "start": "397860",
    "end": "404060"
  },
  {
    "text": "and they sort of simplest algorithm that I can describe for working with these propagators is",
    "start": "404819",
    "end": "410819"
  },
  {
    "text": "this we're going to have so I have I have a big Network",
    "start": "410819",
    "end": "416460"
  },
  {
    "text": "where the nodes represent what I know about a value they're they're they're their knowledge about a value not",
    "start": "416460",
    "end": "423360"
  },
  {
    "text": "necessarily the value itself and the propagators are ways to",
    "start": "423360",
    "end": "428400"
  },
  {
    "text": "Interchange information between these nodes",
    "start": "428400",
    "end": "432560"
  },
  {
    "text": "so the idea here is that whenever I cause one of these propagator one of these",
    "start": "433680",
    "end": "440280"
  },
  {
    "text": "nodes to what the value that I'm holding in this node to move up inside the lattice",
    "start": "440280",
    "end": "445380"
  },
  {
    "text": "I'm going to make sure that every one of the propagators that's coming out of that node gets queued up to fire there that will",
    "start": "445380",
    "end": "451680"
  },
  {
    "text": "it will it will read all of its inputs and scribble it dance its answer into the output which will then be joined",
    "start": "451680",
    "end": "457680"
  },
  {
    "text": "with whatever answer is already there and possibly cause the answer to move up and if it causes it to move up then that",
    "start": "457680",
    "end": "463560"
  },
  {
    "text": "will cue more propagating right",
    "start": "463560",
    "end": "468919"
  },
  {
    "text": "and we repeat this until it goes to sleep we hope it stops",
    "start": "469039",
    "end": "474180"
  },
  {
    "text": "okay well we can make a very strong Claim about when it will stop",
    "start": "474180",
    "end": "479580"
  },
  {
    "text": "which is that if every one of my lattices is finite we can only go up so many times",
    "start": "479580",
    "end": "485580"
  },
  {
    "text": "we will eventually stop but what's interesting is that no matter what order I chose to execute those",
    "start": "485580",
    "end": "492180"
  },
  {
    "text": "propagators in and no matter how many redundant many times I executed each one I'll get the exact same answer no matter",
    "start": "492180",
    "end": "499919"
  },
  {
    "text": "how I parallelize this no matter how I distributed it um and no matter",
    "start": "499919",
    "end": "506280"
  },
  {
    "text": "what nonsense I picked for uh um my evaluation order okay",
    "start": "506280",
    "end": "513539"
  },
  {
    "text": "so um I'm going to go back to those Haas diagrams for a minute and whenever I",
    "start": "513539",
    "end": "520080"
  },
  {
    "text": "um draw them I'm going to stop drawing the top element because whenever we reach that top node",
    "start": "520080",
    "end": "526740"
  },
  {
    "text": "we're going to start with the bottom of our lattice is going to represent that I don't know anything as we gain information we move upward to",
    "start": "526740",
    "end": "532680"
  },
  {
    "text": "the lattice and at the top of the lattice it'll be I that you've told me that the value is both three and four",
    "start": "532680",
    "end": "537779"
  },
  {
    "text": "there's a contradiction I'm gonna blow up the world okay",
    "start": "537779",
    "end": "543720"
  },
  {
    "text": "and um there's sort of a I found this quote entirely in passing uh by reading",
    "start": "543720",
    "end": "549959"
  },
  {
    "text": "the right by reading that book that I was mentioning earlier um that computer scientists choose",
    "start": "549959",
    "end": "555600"
  },
  {
    "text": "models that have bottoms but prefer them topless which reads a lot racier than",
    "start": "555600",
    "end": "561720"
  },
  {
    "text": "um I think intended um",
    "start": "561720",
    "end": "566060"
  },
  {
    "text": "so when I draw my my diagram my my um my lattice says I'm not going to",
    "start": "566820",
    "end": "572399"
  },
  {
    "text": "bother to draw a top node and that'll actually be useful because that way I don't have bottoms and the top and like",
    "start": "572399",
    "end": "577620"
  },
  {
    "text": "if this is true and false then T gets really hard to pick apart um",
    "start": "577620",
    "end": "583380"
  },
  {
    "text": "so I'm interested in lattices that actually are more General than the",
    "start": "583380",
    "end": "589740"
  },
  {
    "text": "um finite lattices that I just talked about so let's let's try and relax that condition so I gave you a sufficient",
    "start": "589740",
    "end": "596700"
  },
  {
    "text": "condition under which prop a propagator network will terminate with a deterministic answer and now I'm going to start",
    "start": "596700",
    "end": "603240"
  },
  {
    "text": "playing with other sufficient conditions and the the first relaxation that we can",
    "start": "603240",
    "end": "610080"
  },
  {
    "text": "make is that we can allow the the um the lattice to be infinite as long as",
    "start": "610080",
    "end": "616019"
  },
  {
    "text": "it's not infinite going up here we're here we've got the natural numbers",
    "start": "616019",
    "end": "621959"
  },
  {
    "text": "and we can go off as far as we want to the right but the thing is the thing that makes",
    "start": "621959",
    "end": "627540"
  },
  {
    "text": "this still terminate any any program that any propagator Network that happens to run that happens to have nodes that",
    "start": "627540",
    "end": "633839"
  },
  {
    "text": "live in this uh semi lattice is the fact that every chain is at most length two here we have",
    "start": "633839",
    "end": "641220"
  },
  {
    "text": "a bound on the length of how long these things are no matter which whichever path I go up I will eventually stop I'll",
    "start": "641220",
    "end": "646800"
  },
  {
    "text": "hit a fixed point I'll hit the top of my lattice the thing that I didn't draw",
    "start": "646800",
    "end": "651560"
  },
  {
    "text": "so you could tell me I don't know anything about this value you could tell me that the value is exactly one or two",
    "start": "651899",
    "end": "657240"
  },
  {
    "text": "or you could tell me there's a contradiction you told me it was both one and two I'm gonna blow up the world those are the kinds of things that you",
    "start": "657240",
    "end": "663180"
  },
  {
    "text": "could hold in one of these cells so just to rephrase the earlier",
    "start": "663180",
    "end": "668880"
  },
  {
    "text": "condition if every one of my semi-lattices satisfies in a sending chain condition which is that every one",
    "start": "668880",
    "end": "674880"
  },
  {
    "text": "of these paths terminates um then the naive propagation algorithm",
    "start": "674880",
    "end": "680760"
  },
  {
    "text": "that we've just described terminates and gives me a deterministic result regardless of how I choose to order",
    "start": "680760",
    "end": "687060"
  },
  {
    "text": "and regardless of how many redundant times I fire one of my propagators so if somebody doesn't get the memo and",
    "start": "687060",
    "end": "693480"
  },
  {
    "text": "they're doing extra work it doesn't hurt me okay",
    "start": "693480",
    "end": "698760"
  },
  {
    "text": "so now we've got maybe I haven't given you any sort of domains for why we care about these yet",
    "start": "698760",
    "end": "704940"
  },
  {
    "text": "um but now I'm concerned with how do I build",
    "start": "704940",
    "end": "710040"
  },
  {
    "text": "them right I said I have to build these monotone functions well we have one vehicle for building monotone functions there any function",
    "start": "710040",
    "end": "716279"
  },
  {
    "text": "that you can write in Haskell that's at least monotone with respect to the the direct complete partial order that we",
    "start": "716279",
    "end": "721860"
  },
  {
    "text": "use for our underlying semantics well not that we actually give Haskell any",
    "start": "721860",
    "end": "727079"
  },
  {
    "text": "sort of formal semantics but the um there's a paper by uh Lindsay",
    "start": "727079",
    "end": "733200"
  },
  {
    "text": "Cooper and Ryan Newton on um a library that she has called Elvish",
    "start": "733200",
    "end": "740519"
  },
  {
    "text": "um where she's talking about elvars which are lattice variables",
    "start": "740519",
    "end": "745560"
  },
  {
    "text": "um really they're not lattice variables Because by the time she's done with the paper she throws out the lattice Machinery so as far as I can tell l in",
    "start": "745560",
    "end": "753480"
  },
  {
    "text": "elvar actually stands for Lindsay um but so be it",
    "start": "753480",
    "end": "759720"
  },
  {
    "text": "um and so what I'm going to use is I'm going to try and look at how we can use her lvar Machinery to implement",
    "start": "759720",
    "end": "765180"
  },
  {
    "text": "propagators Okay so the first lattice that is interesting to",
    "start": "765180",
    "end": "771959"
  },
  {
    "text": "me is going to be a lot of us that's familiar to many many functional programmers in the room how many people here are familiar with promises",
    "start": "771959",
    "end": "779339"
  },
  {
    "text": "all right so A promise is actually going to be a very special case of one of",
    "start": "779339",
    "end": "784560"
  },
  {
    "text": "these lvars it's a lattice if we generalize it a little bit if I allow you to fulfill the promise multiple",
    "start": "784560",
    "end": "790680"
  },
  {
    "text": "times as long as you fulfill it with the same answer okay this is Lindsay's generalization of",
    "start": "790680",
    "end": "796440"
  },
  {
    "text": "the notion of a promise um and so this like a promise is also",
    "start": "796440",
    "end": "801839"
  },
  {
    "text": "called an Ivar in some of the functional programming literature so there's a",
    "start": "801839",
    "end": "807000"
  },
  {
    "text": "Ivars and mvars and what have you and if you're not familiar with them um just remember promise and you'll have a",
    "start": "807000",
    "end": "814079"
  },
  {
    "text": "good intuition for what an Ivar is um so",
    "start": "814079",
    "end": "820940"
  },
  {
    "text": "uh A promise is going to be a very simple lettuce it will always be I don't",
    "start": "820940",
    "end": "826800"
  },
  {
    "text": "know what the answer is I know it's exactly whatever or you blew up the world",
    "start": "826800",
    "end": "832320"
  },
  {
    "text": "because you told me two different things that's it's it's a simple it's it's everything's of height we only have a",
    "start": "832320",
    "end": "838740"
  },
  {
    "text": "lattice of height too everything's out this way it's a sort of flat discrete it's discrete of a lattice as I can get",
    "start": "838740",
    "end": "844019"
  },
  {
    "text": "a joint semi-lattices I can get away with whenever I say lettuce here join semi lettuce because it's getting highly",
    "start": "844019",
    "end": "849660"
  },
  {
    "text": "repetitive in my brain um so in order to be able to talk about what I can ask about a promise or one of",
    "start": "849660",
    "end": "856440"
  },
  {
    "text": "these lattices I need one more thing which is this notion of a filter which is an upward closed set I'm just",
    "start": "856440",
    "end": "862800"
  },
  {
    "text": "going to say that um an upward close set is any set of nodes in a",
    "start": "862800",
    "end": "869760"
  },
  {
    "text": "um in my joint simulator my partial order where if I have an element in this I",
    "start": "869760",
    "end": "875579"
  },
  {
    "text": "contain every element that's above it so if I have X I have every element greater than or equal to X",
    "start": "875579",
    "end": "882300"
  },
  {
    "text": "so I could have 3 as well but if I had three then I would have to have three four and this two three node and this",
    "start": "882300",
    "end": "887399"
  },
  {
    "text": "one would also be in so it doesn't have to be a a printable filter it just it's just it needs to be a",
    "start": "887399",
    "end": "893519"
  },
  {
    "text": "filter and then once I limit myself to filters",
    "start": "893519",
    "end": "899100"
  },
  {
    "text": "that only intersect at that crazy top element that we said we're never going to draw right so",
    "start": "899100",
    "end": "906060"
  },
  {
    "text": "um then what I can do is I can say um I'm interested in knowing which one",
    "start": "906060",
    "end": "912360"
  },
  {
    "text": "of these filters I fell into they act like traps because if I get into this state there",
    "start": "912360",
    "end": "919079"
  },
  {
    "text": "is no way that I could reorder the things that I did or that I'm going to do from here on",
    "start": "919079",
    "end": "924720"
  },
  {
    "text": "out and get into this one okay so these are",
    "start": "924720",
    "end": "931019"
  },
  {
    "text": "mutually exclusive future paths where where the world could go",
    "start": "931019",
    "end": "936899"
  },
  {
    "text": "so here what I have is I have two variables they're either true this is like a pair of booleans",
    "start": "936899",
    "end": "942240"
  },
  {
    "text": "it's I I don't know anything about the left or the right hand one maybe I",
    "start": "942240",
    "end": "948120"
  },
  {
    "text": "learned that the left hand one is true and then I can continue to learn that the right hand one is true",
    "start": "948120",
    "end": "955760"
  },
  {
    "text": "or I learned that the right hand side one is false and then I learned that the",
    "start": "955920",
    "end": "961260"
  },
  {
    "text": "left hand side one is false right and as I merge these two things together I'm just unioning the amount of",
    "start": "961260",
    "end": "967560"
  },
  {
    "text": "information that I know about the world so as I as I move upwards as I join all I'm doing is",
    "start": "967560",
    "end": "973320"
  },
  {
    "text": "merging universes okay so I wanted to compute the and of two",
    "start": "973320",
    "end": "980100"
  },
  {
    "text": "Boolean values what I really kind of want to do is to be able to ask questions of this lattice",
    "start": "980100",
    "end": "987300"
  },
  {
    "text": "hey am I in the Trap where both things are true then okay the",
    "start": "987300",
    "end": "992940"
  },
  {
    "text": "answer is true it's we're in the green portion or am I in the Trap where there's no way",
    "start": "992940",
    "end": "999899"
  },
  {
    "text": "that the answer can be true and we're definitely false which is that I'm in this red section over here",
    "start": "999899",
    "end": "1005839"
  },
  {
    "text": "and this is a valid filter because once we can if we contain this element we contain everything above what we contain this one we contain this one if we",
    "start": "1005839",
    "end": "1012019"
  },
  {
    "text": "contain this one we contain everything above it we can name this one and this one okay so I can assign a value to each",
    "start": "1012019",
    "end": "1020060"
  },
  {
    "text": "filter and I can say hey which trap did I fall into and the nice thing is is that the nice",
    "start": "1020060",
    "end": "1025459"
  },
  {
    "text": "properties of our lattice say that no matter how I reorder the events that got me here I can never fall into a",
    "start": "1025459",
    "end": "1032058"
  },
  {
    "text": "different trap okay so slightly oversimplify greatly",
    "start": "1032059",
    "end": "1039020"
  },
  {
    "text": "oversimplifying Lindsay's work on Elvish she has a monad par",
    "start": "1039020",
    "end": "1045079"
  },
  {
    "text": "where you have the ability to Fork other power computations to run things in parallel",
    "start": "1045079",
    "end": "1050900"
  },
  {
    "text": "you can create these lattice variables with some sort of associated lattice you're allowed to write to lattice",
    "start": "1050900",
    "end": "1056360"
  },
  {
    "text": "variables which will perform a join with whatever values already in them and you're allowed to perform these",
    "start": "1056360",
    "end": "1061520"
  },
  {
    "text": "threshold reads and that's to a first approximation what you can do",
    "start": "1061520",
    "end": "1068000"
  },
  {
    "text": "with Elvish so this starts to sound a little bit like the propagator story we've got",
    "start": "1068000",
    "end": "1073880"
  },
  {
    "text": "these lattice variables floating around but now I'm not like waking up every time I gain information I'm waking up",
    "start": "1073880",
    "end": "1080480"
  },
  {
    "text": "the moment I trip a threshold and I wake up once you think of it like sort of a many time",
    "start": "1080480",
    "end": "1086480"
  },
  {
    "text": "trigger event versus a one-time trigger event or something um as a matter of fact there's a good",
    "start": "1086480",
    "end": "1092419"
  },
  {
    "text": "connection between the notion of an event and a um elvar or a cell",
    "start": "1092419",
    "end": "1098980"
  },
  {
    "text": "and you don't really need this to be a lattice",
    "start": "1099740",
    "end": "1105640"
  },
  {
    "text": "um Lindsay relaxes the notion that she has a lattice and replaces it with um what I what did I need to make sure",
    "start": "1105860",
    "end": "1113419"
  },
  {
    "text": "that I stayed inside the Trap and I needed that I needed it that any two operations that I could perform would",
    "start": "1113419",
    "end": "1119660"
  },
  {
    "text": "commute I needed it that whenever I did something I went upward",
    "start": "1119660",
    "end": "1125600"
  },
  {
    "text": "so I really need to be inflationary and commutative and it would be nice to be item potent",
    "start": "1125600",
    "end": "1131660"
  },
  {
    "text": "but I don't need a a proper uh semi-latus",
    "start": "1131660",
    "end": "1138080"
  },
  {
    "text": "okay I'm not going to really exploit that Advantage here today but if if we",
    "start": "1138080",
    "end": "1145100"
  },
  {
    "text": "are going to get to a list of application domains in that list of application domains gets about three or four times longer if we can admit this",
    "start": "1145100",
    "end": "1152600"
  },
  {
    "text": "reasoning but the thing that matters to me about par is that I'm looking for ways to",
    "start": "1152600",
    "end": "1159980"
  },
  {
    "text": "build monotone functions between joint semi-lattices and everything that I can write in the",
    "start": "1159980",
    "end": "1165500"
  },
  {
    "text": "parmonad is automatically monotone okay so I have a little Paramount",
    "start": "1165500",
    "end": "1171140"
  },
  {
    "text": "computation and if we go back we can see that I'm allowed to Fork I'm",
    "start": "1171140",
    "end": "1177440"
  },
  {
    "text": "allowed to read and write well if I block reading I'm blocking on a threshold read",
    "start": "1177440",
    "end": "1183740"
  },
  {
    "text": "until I get released I don't do anything to anybody else basically you can view every right that I would have made as",
    "start": "1183740",
    "end": "1189559"
  },
  {
    "text": "bottom I didn't tell them anything on the other hand if I'm unblocked",
    "start": "1189559",
    "end": "1195440"
  },
  {
    "text": "then I will do more stuff which will cause my answers to go up so as my input goes up",
    "start": "1195440",
    "end": "1200660"
  },
  {
    "text": "my output only goes up we satisfy what we need to be a monotone function so it's just intuitively you can't do",
    "start": "1200660",
    "end": "1207860"
  },
  {
    "text": "anything bad in par",
    "start": "1207860",
    "end": "1211120"
  },
  {
    "text": "okay um so I really like this framework It's a",
    "start": "1213320",
    "end": "1218660"
  },
  {
    "text": "Wonderful way to get conditions that are sufficient for what I need",
    "start": "1218660",
    "end": "1225500"
  },
  {
    "text": "um but it turns out that par has a bunch of problems for me and I really wanted to just build on it",
    "start": "1225500",
    "end": "1232640"
  },
  {
    "text": "and use it um and in Haskell there's a Ivar package",
    "start": "1232640",
    "end": "1238039"
  },
  {
    "text": "I can't remember who has it it's like simple Dash Ivar or something like that and it has a red eye VAR computation",
    "start": "1238039",
    "end": "1244460"
  },
  {
    "text": "that looks like this read from an Ivar as a pure thing it doesn't have a region parameter just give me an Ivar a arrow a",
    "start": "1244460",
    "end": "1249679"
  },
  {
    "text": "it looks like a pure function with this this computation will block indefinitely",
    "start": "1249679",
    "end": "1255620"
  },
  {
    "text": "until this Ivar has been filled fulfilled potentially by some mutable scary thing but no matter who is",
    "start": "1255620",
    "end": "1262039"
  },
  {
    "text": "fulfilling it they're always going to fill it with a deterministic answer anyways",
    "start": "1262039",
    "end": "1266740"
  },
  {
    "text": "so this can actually be a pure computation but in the parmonad that's provided by Elvish",
    "start": "1267980",
    "end": "1274700"
  },
  {
    "text": "um read Ivar actually has to run inside of this par computation because what par does is it",
    "start": "1274700",
    "end": "1281539"
  },
  {
    "text": "sets up a number of it like a fixed pool of workers like there's eight workers or",
    "start": "1281539",
    "end": "1286760"
  },
  {
    "text": "something like that that are sitting there and they have a little work stealing deck of what they're going to do and whenever whenever they're given",
    "start": "1286760",
    "end": "1294140"
  },
  {
    "text": "us to spawn something else they capture their current continuation they shove it in the deck and they just go off and do",
    "start": "1294140",
    "end": "1299179"
  },
  {
    "text": "whatever they were told to do um and at any point in time when I go to read from an Ivar",
    "start": "1299179",
    "end": "1305419"
  },
  {
    "text": "and the information or read from uh any lattice variable and I haven't tripped a threshold I just stick the current",
    "start": "1305419",
    "end": "1312080"
  },
  {
    "text": "continuation for what I'm going to do in the lvar and I grabbed something else",
    "start": "1312080",
    "end": "1317659"
  },
  {
    "text": "out of my deck to do until somebody has told that thing to proceed",
    "start": "1317659",
    "end": "1322820"
  },
  {
    "text": "right so it's sort of it's just a work queuing kind of mechanism like any of the Intel thread building block kind of",
    "start": "1322820",
    "end": "1328460"
  },
  {
    "text": "stuff that people have used and in more imperative settings the problem is is that this doesn't play",
    "start": "1328460",
    "end": "1334820"
  },
  {
    "text": "very well with everything else that we have in the language we have a language that has lazy i o we",
    "start": "1334820",
    "end": "1343100"
  },
  {
    "text": "can do read file right and that lays once I'm starting to do read file what's going to happen well we go to block on a",
    "start": "1343100",
    "end": "1349880"
  },
  {
    "text": "thunk that's going to then cue some sort of Il event which is going to go out through poll",
    "start": "1349880",
    "end": "1355580"
  },
  {
    "text": "and through all the poll infrastructure and we're not doing any work we're stuck completely dead in the water",
    "start": "1355580",
    "end": "1360740"
  },
  {
    "text": "and nobody is pumping this particular worker's job queue",
    "start": "1360740",
    "end": "1366919"
  },
  {
    "text": "um if people if anybody here is familiar with the notion of fibers versus threads whenever you build a sort of fibroid API",
    "start": "1366919",
    "end": "1372380"
  },
  {
    "text": "you always want to have all of the resources necessary to run the fiber because a fiber is like a stack it's",
    "start": "1372380",
    "end": "1377900"
  },
  {
    "text": "like a thread without a stack right um it doesn't it doesn't have",
    "start": "1377900",
    "end": "1384140"
  },
  {
    "text": "um the ability to do the blocking without holding without denying anybody else the",
    "start": "1384140",
    "end": "1390080"
  },
  {
    "text": "ability to run on that particular capability",
    "start": "1390080",
    "end": "1393760"
  },
  {
    "text": "so I can't use par out of the box if I want",
    "start": "1395179",
    "end": "1400400"
  },
  {
    "text": "to have the solution feel remotely haskelly or be able to work with anything else that I have which really",
    "start": "1400400",
    "end": "1405500"
  },
  {
    "text": "makes me sad because Lindsay's Library actually um Builds on top of some code that I",
    "start": "1405500",
    "end": "1413720"
  },
  {
    "text": "wrote and didn't finish six years ago about six years ago I wrote a an",
    "start": "1413720",
    "end": "1419000"
  },
  {
    "text": "implementation of Chase and Lev's work stealing deck they have a very fancy work stealing deck that they wrote in Java",
    "start": "1419000",
    "end": "1425179"
  },
  {
    "text": "um and I wrote an implementation of it in Haskell and it was terribly broken",
    "start": "1425179",
    "end": "1430280"
  },
  {
    "text": "and then Ryan Newton went off and spent six months just like dealing with every",
    "start": "1430280",
    "end": "1437659"
  },
  {
    "text": "crazy platform issue about how this thing could get funny race conditions and and fixed it",
    "start": "1437659",
    "end": "1444679"
  },
  {
    "text": "um and then he headed it off to his grad student and she used it as the core of the execution environment that makes the",
    "start": "1444679",
    "end": "1450980"
  },
  {
    "text": "parmaned go so",
    "start": "1450980",
    "end": "1454840"
  },
  {
    "text": "um and I can't use it at all so I have to I have to replace all of",
    "start": "1456799",
    "end": "1462020"
  },
  {
    "text": "the stuff that I built um with the mbar Machinery that we've had in GHC",
    "start": "1462020",
    "end": "1468559"
  },
  {
    "text": "forever right which came out of the early parallel Haskell work way back in the day",
    "start": "1468559",
    "end": "1473900"
  },
  {
    "text": "so all of the stuff that we have in Haskell has these things called mvars which are like variables that are either",
    "start": "1473900",
    "end": "1480320"
  },
  {
    "text": "empty or hold on to a value and you when you go to put something else in that slot if there's something already there you get stuck waiting and then you'll",
    "start": "1480320",
    "end": "1487520"
  },
  {
    "text": "put your value in and if there's nothing there and you go to read you'll get stuck waiting for someone to put the value in",
    "start": "1487520",
    "end": "1493580"
  },
  {
    "text": "okay and they have very nice semantics and they're really incredibly",
    "start": "1493580",
    "end": "1498679"
  },
  {
    "text": "beautiful abstractions um so I have to build par out of the",
    "start": "1498679",
    "end": "1504919"
  },
  {
    "text": "existing mvar Machinery that we've had for a decade rather than all the fancy",
    "start": "1504919",
    "end": "1510020"
  },
  {
    "text": "stuff that I hoped would be useful um but there's a problem with M bars",
    "start": "1510020",
    "end": "1515780"
  },
  {
    "text": "which is that M bars are incredibly General and so they wind up being too slow for",
    "start": "1515780",
    "end": "1521240"
  },
  {
    "text": "my purposes because I want these I want this thing to scream if if my propagator network is supposed to be able to solve",
    "start": "1521240",
    "end": "1527840"
  },
  {
    "text": "all sorts of crazy problems I want the implementation to be fast enough that someone would actually bother to solve a",
    "start": "1527840",
    "end": "1533419"
  },
  {
    "text": "problem with it um and it turns out that like every time",
    "start": "1533419",
    "end": "1538940"
  },
  {
    "text": "I go to interact with an MVR I'm going to have to grab some I'm gonna have to do some sort of lock comp exchange some",
    "start": "1538940",
    "end": "1544400"
  },
  {
    "text": "compare and swap craziness we're gonna get stuck in Lock Free which will limit my performance scaling",
    "start": "1544400",
    "end": "1553039"
  },
  {
    "text": "um so I had to build um a faster mvar in Haskell by trying to",
    "start": "1553039",
    "end": "1560960"
  },
  {
    "text": "make it so that I could keep track of which capability something is executing on and then build capability local mvar",
    "start": "1560960",
    "end": "1567860"
  },
  {
    "text": "so that it only works within a like a OS thread and then we communicate across them",
    "start": "1567860",
    "end": "1574400"
  },
  {
    "text": "separately um this is going to get out this gets outside of the scope of the talk but like the custom primitive side of this",
    "start": "1574400",
    "end": "1580880"
  },
  {
    "text": "gets gets rather interesting in its own right um but then just at a high level the",
    "start": "1580880",
    "end": "1586820"
  },
  {
    "text": "very notion of an L VAR is somewhat flawed which is that an lvar is I have some",
    "start": "1586820",
    "end": "1593659"
  },
  {
    "text": "lattice and I have a bunch of people waiting for me to trip thresholds well if I'm going in the wrong direction",
    "start": "1593659",
    "end": "1599600"
  },
  {
    "text": "for a threshold or if I'm just if if I've if there's a lot of stuff I'm gonna get woken up",
    "start": "1599600",
    "end": "1605360"
  },
  {
    "text": "for irrelevant details the L of our abstraction is too coarse grained too many things are going to be",
    "start": "1605360",
    "end": "1612080"
  },
  {
    "text": "woken up um on each change so if I have a big lattice lvars turn out to suffer so what",
    "start": "1612080",
    "end": "1619820"
  },
  {
    "text": "I want to do is I actually want to break these into smaller L vars and and smaller kind of core Primitives",
    "start": "1619820",
    "end": "1625640"
  },
  {
    "text": "that I want to build up very efficiently so",
    "start": "1625640",
    "end": "1631640"
  },
  {
    "text": "I want to treat like an lvar as you can think of an elvar like a channel worth of data I'm going to send data into the",
    "start": "1631640",
    "end": "1636799"
  },
  {
    "text": "channel and it's like a published subscribe framework with like some sort of filter in front of it that just kind of slowly catching",
    "start": "1636799",
    "end": "1643820"
  },
  {
    "text": "crap as you throw data at this thing and you're moving up the lattice and as you as more stuff builds up in",
    "start": "1643820",
    "end": "1649760"
  },
  {
    "text": "the filter less stuff makes it through to the channel to wake everybody up on the outside",
    "start": "1649760",
    "end": "1655460"
  },
  {
    "text": "um so from what I can tell and I don't have a rigorous proof of",
    "start": "1655460",
    "end": "1661520"
  },
  {
    "text": "this I've just gone through every implementation of like a crdt in literature that I can find I should be",
    "start": "1661520",
    "end": "1667279"
  },
  {
    "text": "able to build every existing uh crdk that people have thrown at me out of two",
    "start": "1667279",
    "end": "1672620"
  },
  {
    "text": "pieces and a lot more threads but we're Haskell we like to spend a million threads and",
    "start": "1672620",
    "end": "1678140"
  },
  {
    "text": "then have them block on things um",
    "start": "1678140",
    "end": "1682059"
  },
  {
    "text": "if I have like a notion of like a map from some keys to either listeners who",
    "start": "1683960",
    "end": "1689059"
  },
  {
    "text": "are waiting for me to give you a value or the value that hopefully I can update as close to",
    "start": "1689059",
    "end": "1695360"
  },
  {
    "text": "weight free as possible and some kind of like bump counter that I can increase because increasing a counter is an",
    "start": "1695360",
    "end": "1701299"
  },
  {
    "text": "inflationary right it's not item potent um with a Associated like integer priority",
    "start": "1701299",
    "end": "1707720"
  },
  {
    "text": "queue of everybody who's waiting for me to Cross threshold so I just know I can peel off people in threshold order",
    "start": "1707720",
    "end": "1713960"
  },
  {
    "text": "to wake them up if I have those two things then I can build pretty much any existing",
    "start": "1713960",
    "end": "1721159"
  },
  {
    "text": "uh joint semi-litus that I'm interested in um so this is this is the moment where I",
    "start": "1721159",
    "end": "1726980"
  },
  {
    "text": "let my rigor fall down I don't have a proof that this this is sufficient it's just sufficient for everything I've seen",
    "start": "1726980",
    "end": "1732980"
  },
  {
    "text": "yeah um and then in order to make those two things efficient I actually need to make",
    "start": "1732980",
    "end": "1741380"
  },
  {
    "text": "um weight free algorithms that can work in a world where we can have a million threads running",
    "start": "1741380",
    "end": "1746960"
  },
  {
    "text": "and the problem is is that in general the algorithms that we have that take lock free things and make them weight",
    "start": "1746960",
    "end": "1752299"
  },
  {
    "text": "free all use the fact that there's a fixed pool of eight workers just like we",
    "start": "1752299",
    "end": "1757760"
  },
  {
    "text": "had in the par story um but what we have in Haskell is that",
    "start": "1757760",
    "end": "1764059"
  },
  {
    "text": "Haskell uses a sort of green threading solution we have what they call Haskell execution context or capabilities those",
    "start": "1764059",
    "end": "1769399"
  },
  {
    "text": "are the are the are the Haskell uh vocabulary for this and those are the sort of",
    "start": "1769399",
    "end": "1775460"
  },
  {
    "text": "um like the cores upon which we're executing and then what what's what GHC does is it",
    "start": "1775460",
    "end": "1782899"
  },
  {
    "text": "sort of make sure that make sure that one Haskell thread is executing on every capability at a time and then they",
    "start": "1782899",
    "end": "1788840"
  },
  {
    "text": "Rendezvous to do garbage collection and stuff but",
    "start": "1788840",
    "end": "1795158"
  },
  {
    "text": "threads can move between capabilities",
    "start": "1795500",
    "end": "1799299"
  },
  {
    "text": "and I have a potentially unbounded number of threads now so all the tricks that I use",
    "start": "1801260",
    "end": "1806960"
  },
  {
    "text": "that take Lock Free algorithms and make them weight free can't really use the um",
    "start": "1806960",
    "end": "1812779"
  },
  {
    "text": "the number of threads that we have available to us and a very simple example a lock-free algorithm is usually",
    "start": "1812779",
    "end": "1818659"
  },
  {
    "text": "built with something like compare and swap how many people who are familiar with compare and swap okay I'm just going to assume compare and swap",
    "start": "1818659",
    "end": "1826940"
  },
  {
    "text": "um and what what you do with compare and swap is you can say well let's say I",
    "start": "1826940",
    "end": "1832279"
  },
  {
    "text": "want to do a lock free linked list I can grab what the current head of the list is scribble it into the thing that I'm",
    "start": "1832279",
    "end": "1838700"
  },
  {
    "text": "going to do swap it in and hope that the and check in in the process that what",
    "start": "1838700",
    "end": "1845360"
  },
  {
    "text": "we're counting on to is what we expected to constant to otherwise somebody else won so somebody made progress not",
    "start": "1845360",
    "end": "1851240"
  },
  {
    "text": "necessarily me and I and I keep trying again so the only time I lose is when somebody else wins somebody wins in",
    "start": "1851240",
    "end": "1856940"
  },
  {
    "text": "finite time um the problem weight free is trying to claim that everybody wins in finite time",
    "start": "1856940",
    "end": "1863899"
  },
  {
    "text": "and usually the way that you do this is you make some pool of helper records like I have n workers so I have n helper",
    "start": "1863899",
    "end": "1871220"
  },
  {
    "text": "records I grab a ticket number and then I help everybody with a lower ticket number than maybe before I cons myself",
    "start": "1871220",
    "end": "1878120"
  },
  {
    "text": "on and so the only time I lose on a helping record is when somebody else did the help",
    "start": "1878120",
    "end": "1885140"
  },
  {
    "text": "in which case um we managed to pass all of our weight",
    "start": "1885140",
    "end": "1890240"
  },
  {
    "text": "free rules the problem is is that I can't make the pool of helper records into a linked list without getting back",
    "start": "1890240",
    "end": "1896659"
  },
  {
    "text": "into the exact same problem I just was trying to solve right if I have a linked list worth of",
    "start": "1896659",
    "end": "1902360"
  },
  {
    "text": "helping records how do I something onto the linked list worth of helper records",
    "start": "1902360",
    "end": "1907820"
  },
  {
    "text": "because I need to wait free algorithm to do the thing yeah so I get stuck",
    "start": "1907820",
    "end": "1914059"
  },
  {
    "text": "um so but what I have in Haskell is I have these capabilities these execution",
    "start": "1914059",
    "end": "1920120"
  },
  {
    "text": "contacts that I'm running on the actual underlying core is that I'm being multiplexed to so if I can",
    "start": "1920120",
    "end": "1927980"
  },
  {
    "text": "um try to build weight free algorithms that are bounded in the amount of work",
    "start": "1927980",
    "end": "1933500"
  },
  {
    "text": "that they do based on the number of execution contexts that only have helper records per execution context",
    "start": "1933500",
    "end": "1939140"
  },
  {
    "text": "and then I can try to do units of work between at the at the granularity that",
    "start": "1939140",
    "end": "1944179"
  },
  {
    "text": "no one's allowed to steal my thread from me on this execution context between me starting the work and ending the work in",
    "start": "1944179",
    "end": "1950600"
  },
  {
    "text": "other words a custom GHC primitive um then I can build a class of weight free",
    "start": "1950600",
    "end": "1956960"
  },
  {
    "text": "algorithms that are capability aware that scale out with an infinite you know",
    "start": "1956960",
    "end": "1963500"
  },
  {
    "text": "some Million number of threads okay so this is the only way I know of in order to implement this stuff to make",
    "start": "1963500",
    "end": "1969919"
  },
  {
    "text": "it so that it plays very nicely with the rest of the Haskell ecosystem um",
    "start": "1969919",
    "end": "1974960"
  },
  {
    "text": "and I said in the bottom of the slide that this was out of scope for this talk so",
    "start": "1974960",
    "end": "1980799"
  },
  {
    "text": "long rambling tangent",
    "start": "1981140",
    "end": "1984340"
  }
]