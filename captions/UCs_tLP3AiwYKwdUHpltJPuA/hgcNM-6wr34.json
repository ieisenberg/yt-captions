[
  {
    "text": "today I'm going to be talking about what goes on inside the Intel processors that drive many if not all of our servers",
    "start": "6359",
    "end": "12880"
  },
  {
    "text": "laptops uh and desktops and um I'm going to be sort of going into the details a",
    "start": "12880",
    "end": "19359"
  },
  {
    "text": "little bit so you'll hopefully forgive me if I get into the weeds with some assembly on the screen um but before we",
    "start": "19359",
    "end": "25240"
  },
  {
    "text": "go too far on I have an admission my talk is called x86 for fun and",
    "start": "25240",
    "end": "30880"
  },
  {
    "text": "profit and my intention originally was to come up with some really strong",
    "start": "30880",
    "end": "35960"
  },
  {
    "text": "indicators about how you could optimize your code how you can profile your code",
    "start": "35960",
    "end": "41399"
  },
  {
    "text": "how understanding the internals of the machine can give you sort of insight into improving your code but there is so",
    "start": "41399",
    "end": "47320"
  },
  {
    "text": "much to cover and it's so interesting I just wanted to cover the things that I think are interesting and hopefully",
    "start": "47320",
    "end": "54039"
  },
  {
    "text": "along the way we will pick up some little unusual behavior um uh indicators",
    "start": "54039",
    "end": "60039"
  },
  {
    "text": "we can look for and some optimization opportunities but mostly this stuff is just really interesting and if nothing",
    "start": "60039",
    "end": "65478"
  },
  {
    "text": "else I want you to go away from the end of this talk and have a fresh appreciation for What on earth the Intel",
    "start": "65479",
    "end": "71320"
  },
  {
    "text": "and AMD Engineers have been able to do behind the x86 facade that they give us and um indeed have some kind of sympathy",
    "start": "71320",
    "end": "78040"
  },
  {
    "text": "for those people among us who write compilers and jits and who are trying to sort of reverse engineer and take",
    "start": "78040",
    "end": "83240"
  },
  {
    "text": "advantage of all this fantastic uh Power in front of us",
    "start": "83240",
    "end": "88680"
  },
  {
    "text": "so in Intel are famously tight lipped on what goes on beyond the x86 instruction",
    "start": "88680",
    "end": "96119"
  },
  {
    "text": "set they have about 7 or eight feet thick of manuals that you can get that",
    "start": "96119",
    "end": "101200"
  },
  {
    "text": "have all manner of in in um detail on the individual op codes the bike codes",
    "start": "101200",
    "end": "106360"
  },
  {
    "text": "how the system management stuff works and all that stuff but they don't actually tell you how it works inside mainly because I believe they don't want",
    "start": "106360",
    "end": "113880"
  },
  {
    "text": "to tip the wink to their competitors fair enough they also don't want us to take too much advantage of the internals",
    "start": "113880",
    "end": "119640"
  },
  {
    "text": "of ship as they may change from from processor revision to processor revision",
    "start": "119640",
    "end": "125200"
  },
  {
    "text": "um but uh thankfully there are some people out there who are crazy enough to make it their hobby or Pastime to try",
    "start": "125200",
    "end": "133319"
  },
  {
    "text": "and reverse engineer as much as possible about what goes on underneath and uh this talk wouldn't have been possible",
    "start": "133319",
    "end": "138640"
  },
  {
    "text": "without a lot of help from uh a guy potentially guy called uh agna fog who",
    "start": "138640",
    "end": "144120"
  },
  {
    "text": "is uh at the University of Denmark I think and he has made it his life's work",
    "start": "144120",
    "end": "149200"
  },
  {
    "text": "to sit down and write test case after test case after test case and to uh use",
    "start": "149200",
    "end": "155800"
  },
  {
    "text": "all of the internal management counters that there are inside the chip and somehow try and derive what is going on under the hood so a lot of this comes",
    "start": "155800",
    "end": "161720"
  },
  {
    "text": "from what he said and some other people who have looked into this and and done experiments and some of my own experiments as well but mostly I'm",
    "start": "161720",
    "end": "167800"
  },
  {
    "text": "standing on the shoulders of uh these other guys who've come before me so this is about as much detail as Intel are",
    "start": "167800",
    "end": "174360"
  },
  {
    "text": "prepared to give you about what goes on inside this diagram over here um we're going to be talking about the top half",
    "start": "174360",
    "end": "180959"
  },
  {
    "text": "and the bottom half the top half here is the in order standard one instruction after another part of the processor and",
    "start": "180959",
    "end": "188519"
  },
  {
    "text": "the bottom part is where any the interesting stuff happens where everything gets out of order um we're going to be talking about the pipeline",
    "start": "188519",
    "end": "194720"
  },
  {
    "text": "what the branch predictor is what register renaming is and why it's important how that out of order",
    "start": "194720",
    "end": "199799"
  },
  {
    "text": "execution happens and um a little bit on caching um I may have Miss sool that a",
    "start": "199799",
    "end": "205360"
  },
  {
    "text": "little bit on the uh the abstract of this talk I did say that i' be going into caching as well but again that's like probably another hour's talk on its",
    "start": "205360",
    "end": "211760"
  },
  {
    "text": "own so uh we're just going to sort of graze that a little bit maybe if I if they invite me back next year we can",
    "start": "211760",
    "end": "217000"
  },
  {
    "text": "talk about that then so there is going to be some assembly on the screen as I as I've said",
    "start": "217000",
    "end": "222280"
  },
  {
    "text": "and um before uh before we go too far I thought I'd just give a quick overview of the assembly structure so that we're",
    "start": "222280",
    "end": "229439"
  },
  {
    "text": "all talking about the same kind of thing there are two competing ways of showing Intel assembly there's the AT&T format",
    "start": "229439",
    "end": "235280"
  },
  {
    "text": "and then there's the Intel format I've picked the Intel one for these slides because it just makes more sense to me having come from arm processes way back",
    "start": "235280",
    "end": "242519"
  },
  {
    "text": "when um and that is where the destination is on the left hand side of the two things so an instruction",
    "start": "242519",
    "end": "247680"
  },
  {
    "text": "generally looks something a bit like op where op is like load or add or subtract or or or exclusive or or shift",
    "start": "247680",
    "end": "253280"
  },
  {
    "text": "destination and source and those destination and those sources can be one of three things they can be a register",
    "start": "253280",
    "end": "259400"
  },
  {
    "text": "one of the um rxs or RBX or rcx as I've written here there are eight",
    "start": "259400",
    "end": "264880"
  },
  {
    "text": "architectural registers that came from the 32-bit era when AMD came up with the",
    "start": "264880",
    "end": "270240"
  },
  {
    "text": "extensions from the 64-bit version of the processors they added in another eight registers which they were much",
    "start": "270240",
    "end": "276280"
  },
  {
    "text": "more sensibly named R8 through R15 rather than these strange esoteric names um there are also uh these",
    "start": "276280",
    "end": "283639"
  },
  {
    "text": "multimedia instructions that have grown out of the revisions of the MMX instructions set from way back when uh",
    "start": "283639",
    "end": "289320"
  },
  {
    "text": "these are not general purpose registers they are um usually hold in packed integers or packed floating Point values",
    "start": "289320",
    "end": "295800"
  },
  {
    "text": "and they can be operated on in parallel for like multiplies and shifts and things but they can't used generally for like indexing unlike the other registers",
    "start": "295800",
    "end": "302880"
  },
  {
    "text": "uh also you can talk about subsections of registers so as I said the 64-bit",
    "start": "302880",
    "end": "308000"
  },
  {
    "text": "register Rax um it has a 32-bit counterpart eax and a 16bit counterpart",
    "start": "308000",
    "end": "314479"
  },
  {
    "text": "ax and then ah and Al which refer to the second from bottom and the bottom eight bits respectively which all of which",
    "start": "314479",
    "end": "321319"
  },
  {
    "text": "hark back to the legacy of the 8088 that still pervades even today's desktop and",
    "start": "321319",
    "end": "326840"
  },
  {
    "text": "server machines um for for the most part the struction stream of your original IBM will run happily unmolested",
    "start": "326840",
    "end": "334800"
  },
  {
    "text": "relatively unmolested on uh on an appropriate um operating system on a",
    "start": "334800",
    "end": "340000"
  },
  {
    "text": "modern Intel chip which has a number of interesting side effects the fact that we have this 30 plus year backward",
    "start": "340000",
    "end": "347000"
  },
  {
    "text": "compatibility in the instruction stream um we'll get on to that a bit later on so as I said it can be one of three",
    "start": "347000",
    "end": "353240"
  },
  {
    "text": "things it can be a register it can be a memory operand uh anyone who's come from like the CIS sorry the risk world as I",
    "start": "353240",
    "end": "359800"
  },
  {
    "text": "did will be absolutely staggered to realize that on the x86 a memory operand can be an absolute memory address me",
    "start": "359800",
    "end": "366800"
  },
  {
    "text": "plus a register plus another register times 1 2 4 or eight and that's a single",
    "start": "366800",
    "end": "372400"
  },
  {
    "text": "operand that's one kind of part of an instruction it's pretty complicated set of indexing um or it can indeed be a",
    "start": "372400",
    "end": "379160"
  },
  {
    "text": "constant so those three things are register memory or constant so I've got an example at the bottom here this is one instruction it's add dword pointer",
    "start": "379160",
    "end": "387160"
  },
  {
    "text": "array RBX plus 4 * RDX Comm e and what this really is is read from array index",
    "start": "387160",
    "end": "393240"
  },
  {
    "text": "by the B register plus four times the D register add the a register to that",
    "start": "393240",
    "end": "398639"
  },
  {
    "text": "value and then write it back all as one single instruction that's pretty complicated",
    "start": "398639",
    "end": "404800"
  },
  {
    "text": "and that's where this the C in cisk comes from to sort of put this into context",
    "start": "404800",
    "end": "410280"
  },
  {
    "text": "and to give us an example as we flow down the pipeline um I've got a very simple example here which is a element",
    "start": "410280",
    "end": "416560"
  },
  {
    "text": "wise gave me the maximum value of each element um on the left hand side we've got the C",
    "start": "416560",
    "end": "423400"
  },
  {
    "text": "code and on the right hand side we've got one of the many potential um compiled versions of that code and I'm",
    "start": "423400",
    "end": "429800"
  },
  {
    "text": "going to go through it instruction by instruction just so that we can kind of be on the same page about what's going on here so uh we've got a 65,000 entry",
    "start": "429800",
    "end": "437440"
  },
  {
    "text": "array we go through each one individually uh if Y is greater than the X element then we write the Y element",
    "start": "437440",
    "end": "443160"
  },
  {
    "text": "into the X element and we're done obviously there are much better ways of actually doing this in real world code but this is like a relatively simplistic",
    "start": "443160",
    "end": "450520"
  },
  {
    "text": "example so let's take the first instruction there that's zor eax eax this is a very roundabout way of",
    "start": "450520",
    "end": "458039"
  },
  {
    "text": "setting the eax register to zero we have um the compilers decided that the eax",
    "start": "458039",
    "end": "464080"
  },
  {
    "text": "register is going to be where it's going to keep the loop counter and why is it using zor eax eax you may ask",
    "start": "464080",
    "end": "472080"
  },
  {
    "text": "well it's pretty easy to prove to yourself that if you take any number and exclusive or it with itself you end up",
    "start": "472080",
    "end": "477800"
  },
  {
    "text": "with zero so why has the compiler done this well the answer is the op codes",
    "start": "477800",
    "end": "483000"
  },
  {
    "text": "that translate into that zor eax ex are two bytes long to move the equivalent",
    "start": "483000",
    "end": "488840"
  },
  {
    "text": "value with a constant value of zero would require more byes so the compiler has picked a smaller representation of",
    "start": "488840",
    "end": "495400"
  },
  {
    "text": "the same functionally the same instruction in order to minimize the amount of uh code cach that's needed",
    "start": "495400",
    "end": "501199"
  },
  {
    "text": "you'll also notice if you look a little bit further down that later on it's using Rax but it's zaring",
    "start": "501199",
    "end": "507280"
  },
  {
    "text": "eax there are various different comp ated rules about which parts of the registers get updated by which types of",
    "start": "507280",
    "end": "513719"
  },
  {
    "text": "instructions but when AMD came up with the 64-bit extensions for the Intel instruction set they decided that if you",
    "start": "513719",
    "end": "520240"
  },
  {
    "text": "were to write to the 32-bit register you automatically clear the top 32 bits which has a really convenient side",
    "start": "520240",
    "end": "525760"
  },
  {
    "text": "effect here of us using a smaller encoding of zor eax eax which is just two byes long but clearing the whole 64",
    "start": "525760",
    "end": "532519"
  },
  {
    "text": "bits here if it was zor rxs comma racks it would require a few more op code",
    "start": "532519",
    "end": "538000"
  },
  {
    "text": "byes so moving on on to the next instruction we have a read this is one of those index reads it's not quite as",
    "start": "538000",
    "end": "544240"
  },
  {
    "text": "complicated as the one that has the multiply by 1 2 4 or eight that we saw in the the first slide we're going to be reading here from RSI plus Rax and by",
    "start": "544240",
    "end": "553760"
  },
  {
    "text": "convention the the uh ABI is that RSI is the second parameter to this function which corresponds to the pointer of the",
    "start": "553760",
    "end": "560200"
  },
  {
    "text": "Y array so we're going to read that out calculating the address of uh this particular element by adding the element",
    "start": "560200",
    "end": "566720"
  },
  {
    "text": "um index to it and read it into this X m0 register this is just reading one double Precision number",
    "start": "566720",
    "end": "572640"
  },
  {
    "text": "out the next two instructions here are a comparison which is comparing that value",
    "start": "572640",
    "end": "578920"
  },
  {
    "text": "directly with the memory address of the X of I so we haven't had to read the x of I value out in order to do the",
    "start": "578920",
    "end": "584959"
  },
  {
    "text": "comparison we can just have a compare which acts directly on memory and if uh the value is below",
    "start": "584959",
    "end": "591519"
  },
  {
    "text": "we're jumping to label two here which skips the next instruction this is the equivalent of failing the if condition",
    "start": "591519",
    "end": "596640"
  },
  {
    "text": "and moving on and not doing the the update that's about happen this part then is the update",
    "start": "596640",
    "end": "602279"
  },
  {
    "text": "where uh assuming that uh y ofi was greater than x of I we're just reading writing out that value of xm0 into the",
    "start": "602279",
    "end": "609040"
  },
  {
    "text": "address of the um of XI and then we're skipping to the next element in the array and you'll notice here the",
    "start": "609040",
    "end": "615760"
  },
  {
    "text": "compiler has decided rather than using that one multiply by one multiply by two multiply by four M multiply by eight um",
    "start": "615760",
    "end": "622760"
  },
  {
    "text": "indexing trick it's just multiplied the loop counter by eight throughout so it's adding eight each time we're counting in memory addresses instead of actual I",
    "start": "622760",
    "end": "630120"
  },
  {
    "text": "values and commensurately we're going to be comparing the end of the array here with eight times the 65,000 that are go",
    "start": "630120",
    "end": "636760"
  },
  {
    "text": "in there uh and then if we haven't reached the end of it we go back to the beginning otherwise we're done so",
    "start": "636760",
    "end": "643200"
  },
  {
    "text": "hopefully that's got uh got us uh on the same page when it comes to assembly so the Intel pipeline is a very long and",
    "start": "643200",
    "end": "651240"
  },
  {
    "text": "complicated beast and I'm going to talk about groups of the things that are go on down the pipeline but first of all",
    "start": "651240",
    "end": "656680"
  },
  {
    "text": "what is a pipeline I think probably most of us know that modern processes are",
    "start": "656680",
    "end": "661720"
  },
  {
    "text": "pipelined why well it's probably never been the case that an instruction could complete in a",
    "start": "661720",
    "end": "668000"
  },
  {
    "text": "single cycle even back in the old old days of much much simpler instructions much much slower clock speeds and so",
    "start": "668000",
    "end": "675279"
  },
  {
    "text": "there has always been a partition of work and in the original processes the original uh 8bit processors certainly",
    "start": "675279",
    "end": "681000"
  },
  {
    "text": "that I worked with the 6502 and the Z8 um each instruction would take five or",
    "start": "681000",
    "end": "686040"
  },
  {
    "text": "more Cycles to complete and the the instruction would be fetch the bite that",
    "start": "686040",
    "end": "691160"
  },
  {
    "text": "en codes the op code fetch the operand do the process write the results back and then we'd move on to the next",
    "start": "691160",
    "end": "697399"
  },
  {
    "text": "instruction so it would be taking four or five cycles each to go",
    "start": "697399",
    "end": "702639"
  },
  {
    "text": "then people realize that while um while we were decoding one instruction we",
    "start": "702639",
    "end": "708399"
  },
  {
    "text": "could be fetching the next one and while we're executing instruction we could be decoding the previous one and fetching the next one again so by pipelining we",
    "start": "708399",
    "end": "715000"
  },
  {
    "text": "can increase the throughput in a production line style which which is great so now every clock tick a new",
    "start": "715000",
    "end": "722880"
  },
  {
    "text": "instruction comes into the front of the pipeline and one instruction leaves the end of the pipeline and is completed so",
    "start": "722880",
    "end": "728880"
  },
  {
    "text": "every clock tick something useful happens we haven't changed how long it takes to execute a single instruction",
    "start": "728880",
    "end": "734440"
  },
  {
    "text": "it's still four or five Cycles but every tick we're getting one more thing out and that's very much the approach that a",
    "start": "734440",
    "end": "740440"
  },
  {
    "text": "production line takes when you look at like car building if you were here for jez's talk yesterday and he was showing up all of the sort of pipelining stuff",
    "start": "740440",
    "end": "747360"
  },
  {
    "text": "and the uh uh the work that Toyota have done in order to optimize their pipeline forward it it maybe think of this as",
    "start": "747360",
    "end": "754199"
  },
  {
    "text": "well but the problem is that when you're making cars one car is not dependent on",
    "start": "754199",
    "end": "760440"
  },
  {
    "text": "a previous car that was made which is not true for instructions the instruction stream necessarily has inter",
    "start": "760440",
    "end": "766279"
  },
  {
    "text": "instruction dependencies if you're doing a multiply and the multiply takes five or six Cycles then you want to use the",
    "start": "766279",
    "end": "772720"
  },
  {
    "text": "resolve to that multiply in the next instruction well if you're pipeline you're kind of out of luck until the multiply is completed and you have to",
    "start": "772720",
    "end": "778519"
  },
  {
    "text": "then you can start the next instruction so what would typically happen is the pipeline would stall at that point and",
    "start": "778519",
    "end": "784440"
  },
  {
    "text": "the next instruction that needed the result of the multiply would have to wait until the multipli had finished",
    "start": "784440",
    "end": "789760"
  },
  {
    "text": "which kind of is a shame we we're using up our pipeline bandwidth there or losing um",
    "start": "789760",
    "end": "796040"
  },
  {
    "text": "bandwidth more sort of uh more problematically is the fact that our",
    "start": "796040",
    "end": "801639"
  },
  {
    "text": "stream of instructions coming in is not a linear stream within that stream are branches which may be conditional and so",
    "start": "801639",
    "end": "810320"
  },
  {
    "text": "anytime the code jumps around and starts uh needing execution from a different",
    "start": "810320",
    "end": "816199"
  },
  {
    "text": "part of the program we basically have to start again we get to the point where the branch happens if the branch is taken we're like well okay unfortunately",
    "start": "816199",
    "end": "823199"
  },
  {
    "text": "all the work that's coming down the production line is wrong we need to start again and so it comes back to the beginning we start from the beginning of",
    "start": "823199",
    "end": "828920"
  },
  {
    "text": "the production line but at the new address so what can we do about",
    "start": "828920",
    "end": "835160"
  },
  {
    "text": "that well we can make a guess that's the simplest thing how about if somehow we",
    "start": "835160",
    "end": "840600"
  },
  {
    "text": "could look into the future and decide well what is it really that we're doing what actually is the sequence of",
    "start": "840600",
    "end": "846000"
  },
  {
    "text": "instructions that are coming down it's not just address one followed by address two or followed by address three let's have some kind of prediction",
    "start": "846000",
    "end": "851440"
  },
  {
    "text": "logic well we need a crystal ball to work out that really there is no good answer for this but there are some",
    "start": "851440",
    "end": "857639"
  },
  {
    "text": "really good heuristics which is what exactly what the branch predictor has so the branch",
    "start": "857639",
    "end": "863560"
  },
  {
    "text": "predictor this happens right at the beginning of the pipeline oops before we've even fa a bite of ram",
    "start": "863560",
    "end": "870959"
  },
  {
    "text": "we are guessing where that bite of ram needs to come from we need to predict if",
    "start": "870959",
    "end": "876399"
  },
  {
    "text": "it's a branch if there's a branch coming up where it goes and if it's a conditional Branch we need to work out well is it going to be taken this time",
    "start": "876399",
    "end": "882199"
  },
  {
    "text": "or not so we have a little cache and that cache is called the branch Target",
    "start": "882199",
    "end": "887320"
  },
  {
    "text": "buffer and in that cache we store every Branch instruction that we've seen recently we store where that Branch",
    "start": "887320",
    "end": "894240"
  },
  {
    "text": "instruction goes and in the case of um conditional branch is we keep some kind",
    "start": "894240",
    "end": "899839"
  },
  {
    "text": "of state that tells us gives us some prediction about whether or not that Branch will be taken the next time we see it the simplest State we could keep",
    "start": "899839",
    "end": "906720"
  },
  {
    "text": "is literally have we taken it again recently so one way that's done is with",
    "start": "906720",
    "end": "911800"
  },
  {
    "text": "a two- bit saturating counter we just say every time we take a branch we move one stage to the right here every time",
    "start": "911800",
    "end": "918360"
  },
  {
    "text": "we don't take a branch we move one stage to the left and then if we're in the green patch here of weakly taken or strongly taken we say well let's assume",
    "start": "918360",
    "end": "925680"
  },
  {
    "text": "we're taking it again and if we're in the red patch we just say no let's Carry On Let's ignore this Branch let's just keep on streaming from memory in in",
    "start": "925680",
    "end": "932199"
  },
  {
    "text": "memory order this is great this is a really simple thing to do but it's not very",
    "start": "932199",
    "end": "940360"
  },
  {
    "text": "accurate if you think about what branch patterns really look like you've got Loops where you're going to go over the",
    "start": "940360",
    "end": "946160"
  },
  {
    "text": "same piece of code multiple times and in which case this probably could work quite well you know every time you reach",
    "start": "946160",
    "end": "951480"
  },
  {
    "text": "the bottom of a loop there's a branch the back to the top and if you've got like a 100 iterations of a loop then it's going to be right most of the time",
    "start": "951480",
    "end": "956639"
  },
  {
    "text": "and then you're going to mispredict at the end maybe that's fine but if you've got any other more",
    "start": "956639",
    "end": "963079"
  },
  {
    "text": "complicated inter Branch dependencies then you're basically out of luck this",
    "start": "963079",
    "end": "968880"
  },
  {
    "text": "stuff is not good enough we need to take into account sort of the history of what this branch has done before maybe we need to look at what other branches are",
    "start": "968880",
    "end": "974480"
  },
  {
    "text": "doing in the system and try and add them into the mix and see if we can't guess based on that that kind of fingerprint",
    "start": "974480",
    "end": "979880"
  },
  {
    "text": "of what the program is up to so one thing we can do is keep track of what",
    "start": "979880",
    "end": "986120"
  },
  {
    "text": "happens given the history of a particular branch so for each branch in that btb that",
    "start": "986120",
    "end": "992120"
  },
  {
    "text": "little cache we're going to keep in this instance I've put four just because it's easy four bits of what happened the last",
    "start": "992120",
    "end": "997800"
  },
  {
    "text": "four times we saw this branch and then we're going to use that to index into a table of given the fact that we've seen",
    "start": "997800",
    "end": "1004880"
  },
  {
    "text": "two branches taken and then two branches not taken in this sequence that gives us an index three we go over look in the",
    "start": "1004880",
    "end": "1010399"
  },
  {
    "text": "history table what happened the last time we saw this pattern of branches being taken oh we took a branch let's",
    "start": "1010399",
    "end": "1016440"
  },
  {
    "text": "predict that we did that and then obviously as we come around and the execution unit actually makes the decision about whether we took the",
    "start": "1016440",
    "end": "1022319"
  },
  {
    "text": "branch or we didn't take the branch we update our table and over time we learn given this pattern this is what",
    "start": "1022319",
    "end": "1028798"
  },
  {
    "text": "happens that's cool but there's a problem that's only four bits of History",
    "start": "1028799",
    "end": "1036160"
  },
  {
    "text": "that's the four times we've previously seen this Branch that's not much State programs are much more complicated than",
    "start": "1036160",
    "end": "1042959"
  },
  {
    "text": "that it doesn't scale at all the table of counters you saw on the right hand",
    "start": "1042959",
    "end": "1048280"
  },
  {
    "text": "side in the previous slide is two bits per entry but it goes up with two to the",
    "start": "1048280",
    "end": "1053720"
  },
  {
    "text": "nend so if we add eight bits if we want to do eight bits of history and take into account the the previous eight",
    "start": "1053720",
    "end": "1060160"
  },
  {
    "text": "branches of this sorry eight instances of seeing this previous Branch then we",
    "start": "1060160",
    "end": "1065400"
  },
  {
    "text": "need 256 lots of two bits and that just given that we want to have a cache of many many branches that's just not going",
    "start": "1065400",
    "end": "1071679"
  },
  {
    "text": "to scale very well there is some circuitry in uh certainly some of the",
    "start": "1071679",
    "end": "1077039"
  },
  {
    "text": "older Intel processors that have a separate sort of guess about for for Loop Behavior where they keep track of",
    "start": "1077039",
    "end": "1084559"
  },
  {
    "text": "the number of times the branches encountered and taken every single time except one which kind of covers the case",
    "start": "1084559",
    "end": "1089880"
  },
  {
    "text": "of having something which goes through like 50 times and then doesn't get taken and 50 times doesn't get taken 50 times",
    "start": "1089880",
    "end": "1095240"
  },
  {
    "text": "doesn't get taken well that's probably a loop of 50 that's we're going to see time and time again but um it's",
    "start": "1095240",
    "end": "1101720"
  },
  {
    "text": "difficult to determine whether or not something is really a loop or whether or not it's just a condition that's often true so there's only limited um limited",
    "start": "1101720",
    "end": "1110080"
  },
  {
    "text": "mileage in taking that kind of approach what Intel have done in their most recent generation of",
    "start": "1110080",
    "end": "1115600"
  },
  {
    "text": "Hardware is to take a global view of the branch prediction problem they take 32",
    "start": "1115600",
    "end": "1122960"
  },
  {
    "text": "bits of global history that is not a any particular Branch's pattern history but",
    "start": "1122960",
    "end": "1129120"
  },
  {
    "text": "any branch any conditional Branch we've seen recently the 32 most recent branches what were we doing in those",
    "start": "1129120",
    "end": "1134880"
  },
  {
    "text": "cases and instead of having 4 gigabytes worth of Branch prediction table for",
    "start": "1134880",
    "end": "1140559"
  },
  {
    "text": "those 32 bits we hash that into a smaller but shared patn table so we can",
    "start": "1140559",
    "end": "1146240"
  },
  {
    "text": "have quite a big table of these patterns um but um we have to accept that there",
    "start": "1146240",
    "end": "1152240"
  },
  {
    "text": "are going to be collisions we still use a per Branch table for the destination",
    "start": "1152240",
    "end": "1157600"
  },
  {
    "text": "of any one particular Branch um what does that look like it looks something like this so now we've got 32 bits of",
    "start": "1157600",
    "end": "1164360"
  },
  {
    "text": "what on Earth have we done recently in terms of branching we take that we take the branch address of this particular",
    "start": "1164360",
    "end": "1169559"
  },
  {
    "text": "Branch we're trying to predict we smoosh them together with this hash here and then we go into this table where given",
    "start": "1169559",
    "end": "1175520"
  },
  {
    "text": "this kind of program State this is what we did before and this is really cool except that this global history table",
    "start": "1175520",
    "end": "1182159"
  },
  {
    "text": "has no idea whether or not it's really this branch that we're looking at any",
    "start": "1182159",
    "end": "1187280"
  },
  {
    "text": "two branches that hash the same element we just use whatever's in their Branch table their history table excuse me and",
    "start": "1187280",
    "end": "1194400"
  },
  {
    "text": "that means that you can get into situations where branches fight over the same lot in the buffer and we miss",
    "start": "1194400",
    "end": "1200360"
  },
  {
    "text": "mispredict a lot of the time and there are ways around that which as far as I can tell aren't actually happening on",
    "start": "1200360",
    "end": "1206360"
  },
  {
    "text": "Modern Intel um uh chips but um certainly other other architectures then",
    "start": "1206360",
    "end": "1211760"
  },
  {
    "text": "also have like a um another predictor a sort of a meta predictor per branch",
    "start": "1211760",
    "end": "1217280"
  },
  {
    "text": "which just says how often did I predict this Branch correctly and every time we we're right we move one to the right and",
    "start": "1217280",
    "end": "1223520"
  },
  {
    "text": "we say okay we'll do what the branch table thing says and every time we get it wrong we move it to the left and then we say well do the opposite of what the",
    "start": "1223520",
    "end": "1228880"
  },
  {
    "text": "branch table thing does so if you have two branches that have opposite behavior that smack land in the same slot at least we can handle that situation but",
    "start": "1228880",
    "end": "1234720"
  },
  {
    "text": "as I say there's no there's no strong indication that Intel are doing this they they they say that they aren't um",
    "start": "1234720",
    "end": "1240559"
  },
  {
    "text": "also we don't know how big this history table is on the Sandy Bridges so your guess is as good as as ours really but",
    "start": "1240559",
    "end": "1245880"
  },
  {
    "text": "assuming that um you know these are only two bit each I'm guessing they use quite a few bits of of",
    "start": "1245880",
    "end": "1251640"
  },
  {
    "text": "history but first of all does this actually matter before we go too far down this thing I I realiz we haven't even got into the first stage of the",
    "start": "1251640",
    "end": "1257720"
  },
  {
    "text": "pipeline proper yet we're just still trying to work out where the heck we're going to get the instructions from is it important well here is a bit of python",
    "start": "1257720",
    "end": "1266159"
  },
  {
    "text": "code python obviously is an interpreted language and is full of internal branches inside its own um interpreter",
    "start": "1266159",
    "end": "1274279"
  },
  {
    "text": "and so it would be interesting to see whether or not we can even see the results of the branch predictor at this level and so this example is going to",
    "start": "1274279",
    "end": "1281080"
  },
  {
    "text": "run over an array and it's going to sum up the total of the array and it's also going to count the number of elements",
    "start": "1281080",
    "end": "1286360"
  },
  {
    "text": "that were below some threshold 128 in this case and it's going to sum up those guys and then at the end we return like",
    "start": "1286360",
    "end": "1291880"
  },
  {
    "text": "the average of the entire array and the average of the ones that were below 128 if you feed in a big old array of values",
    "start": "1291880",
    "end": "1298600"
  },
  {
    "text": "into this each between 0 and 256 this is what happens if that set of",
    "start": "1298600",
    "end": "1305799"
  },
  {
    "text": "values is completely random between one 0 and 255 256 sorry it takes 102 nanc",
    "start": "1305799",
    "end": "1313440"
  },
  {
    "text": "per element but if you sort that same input value so same input set before you",
    "start": "1313440",
    "end": "1319080"
  },
  {
    "text": "pass it into the algorithm it only takes 94 n6 element and 90 excuse",
    "start": "1319080",
    "end": "1324360"
  },
  {
    "text": "me I think I should drink with this 94 NS an element that's a speed up of 8%",
    "start": "1324360",
    "end": "1331320"
  },
  {
    "text": "that's not bad now how can I be sure that it's Branch prediction that's helping here or",
    "start": "1331320",
    "end": "1337039"
  },
  {
    "text": "why would Branch prediction help here I should say first well in the sorted case of course the",
    "start": "1337039",
    "end": "1344480"
  },
  {
    "text": "first half of the array this if statement",
    "start": "1344480",
    "end": "1349520"
  },
  {
    "text": "will be true we'll always go into the nonclipped and the clip total plus equals one so somewhere one of the",
    "start": "1349520",
    "end": "1354640"
  },
  {
    "text": "branches one of the many branches inside The Interpreter will always be not taken as it doesn't skip over the if",
    "start": "1354640",
    "end": "1361279"
  },
  {
    "text": "statement so then we run through the first half of the array and we hit the F the first value that's 128 and at that",
    "start": "1361279",
    "end": "1367559"
  },
  {
    "text": "point the prediction is wrong hopefully though within the next two two or three iterations we would",
    "start": "1367559",
    "end": "1373279"
  },
  {
    "text": "have learned that actually this is now the new the new the new uh World orders that were going to be taking this brch",
    "start": "1373279",
    "end": "1378520"
  },
  {
    "text": "every time and we then predict correctly from then onwards",
    "start": "1378520",
    "end": "1385039"
  },
  {
    "text": "so it seems like Branch predictor and getting the branch prediction right here would be useful whereas in the random",
    "start": "1385039",
    "end": "1390640"
  },
  {
    "text": "case of course the branch predictor is going to be trying to infer a pattern for this in this if statement where in",
    "start": "1390640",
    "end": "1397120"
  },
  {
    "text": "fact no pattern exists at all there are a variety of tools that you can run and um I ran one called perf",
    "start": "1397120",
    "end": "1405600"
  },
  {
    "text": "which is I thoroughly recommend for this kind of uh investigation and if you run with and without the",
    "start": "1405600",
    "end": "1410880"
  },
  {
    "text": "sorted data you can see that the same number of instructions are taken the same number of CPU um uh retired",
    "start": "1410880",
    "end": "1417279"
  },
  {
    "text": "instructions uh go through the system the same number of branches are encountered encountered um but the",
    "start": "1417279",
    "end": "1423720"
  },
  {
    "text": "branch prediction rate is vastly different between the two so it's not any other artifact as far as I can tell",
    "start": "1423720",
    "end": "1429559"
  },
  {
    "text": "although it is still surprising to me that in an interpreted language it it still can matter what you can do about this I don't know in a practical sense",
    "start": "1429559",
    "end": "1436039"
  },
  {
    "text": "for this particular toy example anyway okay so I've made a reasonable case for",
    "start": "1436039",
    "end": "1442000"
  },
  {
    "text": "why a branch predictor is worthwhile what happens once we've predicted where the program flow is",
    "start": "1442000",
    "end": "1447679"
  },
  {
    "text": "going well the results of the branch predictor are a stream of instruction addresses this is like where we want to",
    "start": "1447679",
    "end": "1453480"
  },
  {
    "text": "be fetching from and that moves on to the first stage which is this fetching and pre-coding Stage the fetcher is responsible from",
    "start": "1453480",
    "end": "1460679"
  },
  {
    "text": "reading the instruction stream it's responsible for doing the tlb lookups",
    "start": "1460679",
    "end": "1466120"
  },
  {
    "text": "the the virtual to uh physical address translation and for streaming in blocks",
    "start": "1466120",
    "end": "1471679"
  },
  {
    "text": "of instructions the instructions look something like this uh the feter reads have in 16 by chunks and it has an",
    "start": "1471679",
    "end": "1478200"
  },
  {
    "text": "interesting thing to do first up so later on down the pipeline we want to unlock as much parallelism as possible",
    "start": "1478200",
    "end": "1485039"
  },
  {
    "text": "and that means that we want to do actually more than one instruction at a time if that's at all feasible but",
    "start": "1485039",
    "end": "1490360"
  },
  {
    "text": "because of the long and tortured history of the uh the x86 architecture",
    "start": "1490360",
    "end": "1497520"
  },
  {
    "text": "we're kind of left with this strange format of of uh uh of op codes which no",
    "start": "1497520",
    "end": "1502559"
  },
  {
    "text": "rational being would have come up with so if you look at like Risk instructions nowadays they're usually fixed size it's",
    "start": "1502559",
    "end": "1508559"
  },
  {
    "text": "very easy to see where each instruction is but in an Intel sequence there's no",
    "start": "1508559",
    "end": "1514679"
  },
  {
    "text": "obvious way at all to determine where the btes are where sorry where the instructions are inside that bite stream",
    "start": "1514679",
    "end": "1520799"
  },
  {
    "text": "this is what the fetcher does it fetches it and it looks out for the beginning of each",
    "start": "1520799",
    "end": "1526360"
  },
  {
    "text": "instruction which is an amazing achievement if you think about it in one or two clock Cycles it has somehow",
    "start": "1526360",
    "end": "1533000"
  },
  {
    "text": "scanned this list of instructions decoded where the beginning of each instruction may be and somehow done that",
    "start": "1533000",
    "end": "1539080"
  },
  {
    "text": "in parallel because necessarily the beginning of one instruction follows on",
    "start": "1539080",
    "end": "1544679"
  },
  {
    "text": "from the end of the previous instruction there's a dependency from each one carried along so the only way I can",
    "start": "1544679",
    "end": "1550559"
  },
  {
    "text": "think they're doing is somehow like parallel decoding all 16 possible places in the instruction stream where",
    "start": "1550559",
    "end": "1556360"
  },
  {
    "text": "instructions may be and then somehow filtering out the ones that don't make sense but whatever it is it's an amazing achievement and so this instruction",
    "start": "1556360",
    "end": "1562919"
  },
  {
    "text": "stream here this this sequence of bites is actually the first few uh instructions of the example I showed you earlier uh there's that two by zor eax",
    "start": "1562919",
    "end": "1569880"
  },
  {
    "text": "eax and you can see we've pulled out four instructions here and then we've got the f2f which I haven't put down",
    "start": "1569880",
    "end": "1576720"
  },
  {
    "text": "here it's like the beginning of the next instruction in the Stream which will sort of be",
    "start": "1576720",
    "end": "1581640"
  },
  {
    "text": "and I forgotten sorry okay so we've got our four oh yeah sorry that point here the the precoder",
    "start": "1588440",
    "end": "1595880"
  },
  {
    "text": "doesn't know what these instructions are it only knows where they lie in the sequence of bites there's that's all they can do in they're given the amount",
    "start": "1595880",
    "end": "1601760"
  },
  {
    "text": "of time that they have to do this but those bites then flow on as a sequence of bites and offsets where the",
    "start": "1601760",
    "end": "1607240"
  },
  {
    "text": "instructions may start in the Stream onto the decoding stage which is where finally the Intel Engineers have sort of",
    "start": "1607240",
    "end": "1613039"
  },
  {
    "text": "admitted defeat of this uh really complicated Byzantine instruction SE sequence and have decided that they want",
    "start": "1613039",
    "end": "1618480"
  },
  {
    "text": "something more pure inside so at this point the cisk instructions that come through are converted into a sort of",
    "start": "1618480",
    "end": "1624960"
  },
  {
    "text": "internal risk Now intel don't public excuse me",
    "start": "1624960",
    "end": "1631159"
  },
  {
    "text": "Intel don't publish the format of this internal risk there is some sort of literature about where the the execution",
    "start": "1631159",
    "end": "1637640"
  },
  {
    "text": "units use the various types of micro operations sorry micro operations is what they call this this uh this risk",
    "start": "1637640",
    "end": "1644000"
  },
  {
    "text": "set and um within those micro operations the more complicated instructions like the",
    "start": "1644000",
    "end": "1650360"
  },
  {
    "text": "read modify write instruction I had on the first Slide the load from a complicated memory address add to it and store it back actually devolve into the",
    "start": "1650360",
    "end": "1657080"
  },
  {
    "text": "three instructions that any normal person would have written in a in a risk world that's a really important thing to",
    "start": "1657080",
    "end": "1662880"
  },
  {
    "text": "do because later on down the line we're going to be able to break those parts of the instruction up and schedule them",
    "start": "1662880",
    "end": "1668080"
  },
  {
    "text": "differently so that if parts of the the the chip are busy like if the multiplier",
    "start": "1668080",
    "end": "1673399"
  },
  {
    "text": "is busy we can still do the load part of a load instruction which mod has a multiply component to it we can",
    "start": "1673399",
    "end": "1680080"
  },
  {
    "text": "potentially have a um if yes sorry that is probably a good",
    "start": "1680080",
    "end": "1686279"
  },
  {
    "text": "enough example sorry um so breaking the instruction into pieces does help because we can schedule the individual",
    "start": "1686279",
    "end": "1692600"
  },
  {
    "text": "parts around and we have a lot more Fidelity later on for for parallelizing things that wouldn't otherwise be paralyzed if we just naively kept them",
    "start": "1692600",
    "end": "1698960"
  },
  {
    "text": "as atomic instructions that we wrote to start with um the decoders here can",
    "start": "1698960",
    "end": "1705519"
  },
  {
    "text": "handle up to four instructions in a single cycle which is impressive so those four instructions I showed you in the previous slide will come through",
    "start": "1705519",
    "end": "1711080"
  },
  {
    "text": "into the decode stage and they will be turned into micro operations in one cycle those um there's some complexity",
    "start": "1711080",
    "end": "1717720"
  },
  {
    "text": "to do with the different decoders the first decoder for example is capable of decoding absolutely any kind of instruction and generating any number of",
    "start": "1717720",
    "end": "1723960"
  },
  {
    "text": "um micro operations whereas the other three decoders that there are that in parallel can only do the simpler",
    "start": "1723960",
    "end": "1729000"
  },
  {
    "text": "instructions so there is some kind of mileage into very carefully scheduling your instructions into a particular pattern to allow them to to flow through",
    "start": "1729000",
    "end": "1736039"
  },
  {
    "text": "as fast as possible um on the newer processes that's less important because of the micro op cach",
    "start": "1736039",
    "end": "1741360"
  },
  {
    "text": "which I'll talk about in a second but you'll see if you ever go into the deep deep depths of like gcc's internal",
    "start": "1741360",
    "end": "1746559"
  },
  {
    "text": "instruction scheduler it tries its best to move things around to fit this kind of pattern and indeed actually as a sort",
    "start": "1746559",
    "end": "1753399"
  },
  {
    "text": "of a side note um if you if you open one of the better places to sort of see the documentation for this for the reverse",
    "start": "1753399",
    "end": "1758919"
  },
  {
    "text": "engineering of of what goes on inside is to look inside the bowels of the compiler as as there are some autometer",
    "start": "1758919",
    "end": "1764720"
  },
  {
    "text": "inside the compiler that try to predict what the pro cessor does internally and schedule instructions to fit in with the",
    "start": "1764720",
    "end": "1771320"
  },
  {
    "text": "the predicted flow so we have these four decoders and",
    "start": "1771320",
    "end": "1776480"
  },
  {
    "text": "they output these micro operations two other things take part at this point we have microfusion which is the name for",
    "start": "1776480",
    "end": "1783480"
  },
  {
    "text": "taking two micro operations and kind of treating them as one although we've carefully devolved them into different",
    "start": "1783480",
    "end": "1788840"
  },
  {
    "text": "pieces that takes up a lot of bandwidth if you imagine we've got like a stream of instructions coming in we're kind of",
    "start": "1788840",
    "end": "1793880"
  },
  {
    "text": "expanding out the number of of of operations so we've got a sort of fan out of thing going fan out thing going",
    "start": "1793880",
    "end": "1799320"
  },
  {
    "text": "on and that obviously consumes resources on the chip so for for the very common operations like stores which require an",
    "start": "1799320",
    "end": "1805440"
  },
  {
    "text": "address calculation as well as the actual store well they don't need any more temporary space there are two",
    "start": "1805440",
    "end": "1811200"
  },
  {
    "text": "separate pieces of work one is to calculate the address and one of them is to do the store but wouldn't it be nice",
    "start": "1811200",
    "end": "1816519"
  },
  {
    "text": "just to sort of treat them as one Atomic unit as they flow down the pipeline and but just schedule those two bits differently so that's what micr Fusion",
    "start": "1816519",
    "end": "1821919"
  },
  {
    "text": "is it's taking two microps and kind of bundling them together as a sort of topple of things to do together and then",
    "start": "1821919",
    "end": "1827640"
  },
  {
    "text": "we got more importantly macro Fusion which is where the converse happens rather than multiple um micro operations",
    "start": "1827640",
    "end": "1835240"
  },
  {
    "text": "being generated for a single input instruction we take two input instructions and we can generate only",
    "start": "1835240",
    "end": "1841799"
  },
  {
    "text": "one micro operation an example of this is the compare followed by a branch it's so common that we would want to like",
    "start": "1841799",
    "end": "1848120"
  },
  {
    "text": "compare our Loop counter with some value and then Branch if not equal or decrement a value and in Branch if it's",
    "start": "1848120",
    "end": "1854880"
  },
  {
    "text": "not zero those kind of things which most most instruction instruction sets actually have a",
    "start": "1854880",
    "end": "1860240"
  },
  {
    "text": "decrement and jump if not zero kind of feel to them x86 doesn't but at this",
    "start": "1860240",
    "end": "1865799"
  },
  {
    "text": "point if you have two instructions one after another that have this pattern it will be turned into a single micro",
    "start": "1865799",
    "end": "1870960"
  },
  {
    "text": "operation so we kind of gain claw back a little bit of this fan out that we were getting from from further",
    "start": "1870960",
    "end": "1877720"
  },
  {
    "text": "down in the Sandy bridge and above there is something called a micro operation cache at this point too so we've",
    "start": "1877720",
    "end": "1885279"
  },
  {
    "text": "already the clock has already ticked like six or seven times times to get to this point and an awful lot of valuable work has been",
    "start": "1885279",
    "end": "1891320"
  },
  {
    "text": "done it would be useful to hang on to that intermediate results especially if as often times we're going to be revisiting this code in in short order",
    "start": "1891320",
    "end": "1898720"
  },
  {
    "text": "so the micro operation cache stores the results of the decoded operations at this point they're about, 1500 entries",
    "start": "1898720",
    "end": "1904799"
  },
  {
    "text": "and it's very complicated sort of cache that doesn't map to a normal like um memory cache in in the way that you",
    "start": "1904799",
    "end": "1910880"
  },
  {
    "text": "would probably think but if you just think of it as as a uh something which",
    "start": "1910880",
    "end": "1916039"
  },
  {
    "text": "can hold a smallish Loop in it's useful to to um",
    "start": "1916039",
    "end": "1921399"
  },
  {
    "text": "well the reason that this is useful is that when we do a branch later on if we",
    "start": "1921399",
    "end": "1927000"
  },
  {
    "text": "discover that we've been going the wrong way down the pipeline but the destination of that branch is inside the",
    "start": "1927000",
    "end": "1932840"
  },
  {
    "text": "microp cache we don't have to go all the way to the front of the pipeline we can sort of short circuit and start at the",
    "start": "1932840",
    "end": "1938519"
  },
  {
    "text": "micro op cache and only from then onwards do we need to to um to start reprocessing instructions which reduces",
    "start": "1938519",
    "end": "1945000"
  },
  {
    "text": "the latency of a mispredicted branch so although we've invested all this time earlier trying to work out which way the branch is going if we get it wrong the",
    "start": "1945000",
    "end": "1951760"
  },
  {
    "text": "micro operation Cache can save us a bit of time recovering from",
    "start": "1951760",
    "end": "1956840"
  },
  {
    "text": "that as I've said my Intel don't give an awful lot of um examples of what their micro operation format looks like so",
    "start": "1956880",
    "end": "1963240"
  },
  {
    "text": "I've kind of on the left hand side here given an example of the code again and on the right hand side I've invented my",
    "start": "1963240",
    "end": "1968679"
  },
  {
    "text": "own sort of format for what these micro operations might look like and the convention I've got here is",
    "start": "1968679",
    "end": "1975120"
  },
  {
    "text": "that one line of text is one micro operation ation so uh the the the things I want to",
    "start": "1975120",
    "end": "1981679"
  },
  {
    "text": "sort of point out in this stream are that compare instruction which Compares with memory is two micro operations",
    "start": "1981679",
    "end": "1988679"
  },
  {
    "text": "there's a sort of temporary value an unnamed temporary that's read out and then the comparison happens as a SE",
    "start": "1988679",
    "end": "1994159"
  },
  {
    "text": "separate micro operation and then there at the bottom of the loop what we've lost in that one extra micro operation",
    "start": "1994159",
    "end": "2000720"
  },
  {
    "text": "we kind of claw back here because the compare followed by the jump maps to a single micro operation which is the",
    "start": "2000720",
    "end": "2006519"
  },
  {
    "text": "macro Fusion but even this isn't really what happened so at this point this mental model that",
    "start": "2006519",
    "end": "2011679"
  },
  {
    "text": "we might have of putting the code side by side is not what the processor is seeing at this point because what the process is really seeing of course is a",
    "start": "2011679",
    "end": "2018480"
  },
  {
    "text": "sequence of instructions flowing linearly down in predicted program order",
    "start": "2018480",
    "end": "2024240"
  },
  {
    "text": "the branch predictor's done its magic we have the fetcher has just fetched whatever it's been told to fetch and",
    "start": "2024240",
    "end": "2029440"
  },
  {
    "text": "this is what's flowing down so I've kind of tried to captured this on this slide here where um on the right the left hand",
    "start": "2029440",
    "end": "2035360"
  },
  {
    "text": "side I've kind of put the address to give you some idea and to sort of highlight what I mean here um take this",
    "start": "2035360",
    "end": "2040720"
  },
  {
    "text": "this comparison here this is the one of the comparisons around the if x is greater than y and in this instance I've",
    "start": "2040720",
    "end": "2046159"
  },
  {
    "text": "just arbitrarily decided that the branch predictor has predicted that this particular one is going to be taken so",
    "start": "2046159",
    "end": "2051480"
  },
  {
    "text": "rather than the next instruction being the nordex 14 which would be the next address of the instruction I've said hey",
    "start": "2051480",
    "end": "2058118"
  },
  {
    "text": "we think this one's going to go to 19 go to 19 now and so that's the next thing that's going to be in the pipeline similarly here this is the loop",
    "start": "2058119",
    "end": "2066118"
  },
  {
    "text": "at the bottom where we've done the comp pair and if not equal and obviously for the vast majority of cases that's going",
    "start": "2066119",
    "end": "2071960"
  },
  {
    "text": "to be taken as for everyone except one iteration that is going to be the case so we hope that the predictor has",
    "start": "2071960",
    "end": "2077320"
  },
  {
    "text": "guessed that so again the next instruction will be back at the top of the loop and then down here for just just",
    "start": "2077320",
    "end": "2083800"
  },
  {
    "text": "for uh comparison this one has been predicted not taken so rather than being the hex 19 address of the next uh of the",
    "start": "2083800",
    "end": "2090878"
  },
  {
    "text": "go-to it's the next address linearly in memory at hex1 14 now of course this s",
    "start": "2090879",
    "end": "2096638"
  },
  {
    "text": "of underlines what happens when the branch actually gets to be executed and that is the branch unit has to say well which way did it really go and was I",
    "start": "2096639",
    "end": "2103240"
  },
  {
    "text": "right and if if I'm not right what do I do well we've already said about this we're going to be flushing the pipeline but how does that happen we'll talk",
    "start": "2103240",
    "end": "2109640"
  },
  {
    "text": "about that in a second okay so we've decoded our stream of instructions we're about six seven",
    "start": "2109640",
    "end": "2116400"
  },
  {
    "text": "eight clock Cycles depending on your model um down the down the uh the pipeline and we hit this thing called",
    "start": "2116400",
    "end": "2122280"
  },
  {
    "text": "the renamer the renamer sort of takes",
    "start": "2122280",
    "end": "2128160"
  },
  {
    "text": "another risk View and somehow morphs the x86",
    "start": "2128160",
    "end": "2133960"
  },
  {
    "text": "instruction set to to fit that so the x86 only has these eight or 16 in 64-bit",
    "start": "2133960",
    "end": "2139760"
  },
  {
    "text": "mode registers that we can talk about um ignoring the xmm registers for now but",
    "start": "2139760",
    "end": "2145320"
  },
  {
    "text": "if you look at any risk chip there are hundreds if not thousands of of available",
    "start": "2145320",
    "end": "2151720"
  },
  {
    "text": "registers why is that well if you want to separate out independent instruction flows and have parallelism inter",
    "start": "2151720",
    "end": "2159240"
  },
  {
    "text": "instruction parallelism you need to be not stomping on your registers at the same time if you use the same register",
    "start": "2159240",
    "end": "2164400"
  },
  {
    "text": "twice well you have to wait for the previous usage to finish before you can reuse it to do something",
    "start": "2164400",
    "end": "2169480"
  },
  {
    "text": "else it used to be the case that registers took up lots of the the real estate if you look at like um old",
    "start": "2169480",
    "end": "2176240"
  },
  {
    "text": "circuit diagrams or rather old uh dies of like uh the 6502 for example there's a great project where people have been",
    "start": "2176240",
    "end": "2182680"
  },
  {
    "text": "taking the top of 62s and scanning them with high resolution cameras and then like literally backing out where every",
    "start": "2182680",
    "end": "2187800"
  },
  {
    "text": "single transistor is but they can draw sort of diagrams of where everything is you can see that the registers are actually a substantial blob of of the uh",
    "start": "2187800",
    "end": "2195760"
  },
  {
    "text": "the die that's no longer the case compared to like the caches that are on there and all of the complicated Logic",
    "start": "2195760",
    "end": "2200839"
  },
  {
    "text": "the registers are a tiny proportion so having only being able to encode 16 in the format even with all the extensions",
    "start": "2200839",
    "end": "2207680"
  },
  {
    "text": "that that are in there is kind of a limitation for this so the renamer does on the-fly dependency",
    "start": "2207680",
    "end": "2214880"
  },
  {
    "text": "analysis and turns your code into St single static assignment mode sorry form",
    "start": "2214880",
    "end": "2221440"
  },
  {
    "text": "and then makes up inter intermediate temporary values and Maps them into a",
    "start": "2221440",
    "end": "2226680"
  },
  {
    "text": "sort of a suite of 100 or more instructions sorry excuse me 100 or more",
    "start": "2226680",
    "end": "2233040"
  },
  {
    "text": "um registers so we don't need we are no longer beholden to the 16 registers that",
    "start": "2233040",
    "end": "2239440"
  },
  {
    "text": "came in we can use these intermediate values throughout and these intermed let me give you an example that's probably",
    "start": "2239440",
    "end": "2244480"
  },
  {
    "text": "the best thing to do here so here on the left hand side I've got a SL slly different um example we've got a routine",
    "start": "2244480",
    "end": "2250119"
  },
  {
    "text": "which takes two values and increments uh two different globals and quite reasonably here is a piece of code that",
    "start": "2250119",
    "end": "2255680"
  },
  {
    "text": "the compiler could have output which is read the global a into eax add eax to",
    "start": "2255680",
    "end": "2261560"
  },
  {
    "text": "the first um parameter and store it out and then the same again for B notice",
    "start": "2261560",
    "end": "2266599"
  },
  {
    "text": "it's using eax again twice pretty sensible but uh if that read takes a long time and I",
    "start": "2266599",
    "end": "2275240"
  },
  {
    "text": "think we all know that accessing memory usually is pretty slow then well it's clear and obvious that these two",
    "start": "2275240",
    "end": "2281280"
  },
  {
    "text": "instructions after it which depend on the value can't run that's fine but",
    "start": "2281280",
    "end": "2286599"
  },
  {
    "text": "we've used eax in the next block of code what what happens if Global B is in the cache already what happens if we were to",
    "start": "2286599",
    "end": "2292000"
  },
  {
    "text": "if we'd have used a different register here maybe this could have been scheduled but we've used eax we can't do",
    "start": "2292000",
    "end": "2297520"
  },
  {
    "text": "it it's going to be stomped over by whatever this instruction stream is doing so the renamer takes a look at",
    "start": "2297520",
    "end": "2303319"
  },
  {
    "text": "this puts it into SSA form and comes up with something which looks a little bit like this again there's no kind of documented format for this so I've kind",
    "start": "2303319",
    "end": "2309440"
  },
  {
    "text": "of used a a a suffix on each register to sort of indicate the the the new name that each register has so rather than",
    "start": "2309440",
    "end": "2315920"
  },
  {
    "text": "eax on the left hand side we've got eax sub one and then we add e ax1 to edi1",
    "start": "2315920",
    "end": "2321680"
  },
  {
    "text": "and we write the result to a new temporary intermediate register called",
    "start": "2321680",
    "end": "2327160"
  },
  {
    "text": "edi2 and that's the thing that we write back out again and then critically down in this second blob we've determined",
    "start": "2327160",
    "end": "2334400"
  },
  {
    "text": "that this value of eax is completely independent of the pre previous value of eax we might as well have used another",
    "start": "2334400",
    "end": "2339800"
  },
  {
    "text": "register we could have done we just couldn't have encoded it or the ABI forced us to use a particular named architectural register and but at this",
    "start": "2339800",
    "end": "2347680"
  },
  {
    "text": "level inside the chip we can make a new one we can just say hey let's call this eax sub 2 and now the oh sorry and now",
    "start": "2347680",
    "end": "2353880"
  },
  {
    "text": "those two pieces of code are independent of each other and can run together in parallel or one can go in front of the",
    "start": "2353880",
    "end": "2359800"
  },
  {
    "text": "other um and we unlock parallelism which otherwise would have been um uh prevented",
    "start": "2359800",
    "end": "2367920"
  },
  {
    "text": "the way that this is achieved is that the renamer keeps track of which of these intermediate temporary registers",
    "start": "2367920",
    "end": "2373760"
  },
  {
    "text": "contains the current version of any of the named architectural registers this is the register Alias table and it Maps",
    "start": "2373760",
    "end": "2381280"
  },
  {
    "text": "into either a reorder buffer which is like a temporary scratch space of all of these micro operations that have yet to",
    "start": "2381280",
    "end": "2386440"
  },
  {
    "text": "be executed or have executed but haven't finished um completed yet um or it Maps",
    "start": "2386440",
    "end": "2393359"
  },
  {
    "text": "into the permanent register file which is like the canonical place where the real EA X and the real edx",
    "start": "2393359",
    "end": "2400920"
  },
  {
    "text": "live interestingly up right up until the Sandy Bridge all of this complicated sort of internal logic where all these",
    "start": "2401720",
    "end": "2408760"
  },
  {
    "text": "these various things are being shuffled around and predicted and whatever was not the bottleneck the actual bottleneck was this prf read here so if if you've",
    "start": "2408760",
    "end": "2417079"
  },
  {
    "text": "modified a register recently it's going to be living in one of these temporary variables that are inside this this 100",
    "start": "2417079",
    "end": "2422599"
  },
  {
    "text": "plus um array of intermediate results but if you haven't modified a register",
    "start": "2422599",
    "end": "2427760"
  },
  {
    "text": "recently it's in the real register file over in the permanent register file and",
    "start": "2427760",
    "end": "2433200"
  },
  {
    "text": "at this stage as we leave the renamer any instruction that needs like the real eax and the real eax isn't in the in the",
    "start": "2433200",
    "end": "2438640"
  },
  {
    "text": "reorder buff already we have to read from the permanent register file and put it in there but there were only three",
    "start": "2438640",
    "end": "2445160"
  },
  {
    "text": "read ports on the register file which means that anytime you needed more than three registers that hadn't been",
    "start": "2445160",
    "end": "2450560"
  },
  {
    "text": "modified recently you would take multiple clock Cycles to read them and now that sounds like a lot three",
    "start": "2450560",
    "end": "2455920"
  },
  {
    "text": "registers every single clock cycle except that by now we've devolved our instructions into stream of Micro Ops",
    "start": "2455920",
    "end": "2461000"
  },
  {
    "text": "each micro op has up to three operands and we're trying to do four of them at once so we can easily contrive",
    "start": "2461000",
    "end": "2468160"
  },
  {
    "text": "12 and that means we're going to take four clock ticks just to move into the next stage so thankfully on Sandy bridge",
    "start": "2468160",
    "end": "2475319"
  },
  {
    "text": "and above they've fixed this and you will no longer see this as being a problem um assuming you guys are on",
    "start": "2475319",
    "end": "2480480"
  },
  {
    "text": "Sandy bridges of course is um the other thing that renamer is",
    "start": "2480480",
    "end": "2486040"
  },
  {
    "text": "smart enough to do is understand these funny little things like this zor eax eex we did earlier so naively if you",
    "start": "2486040",
    "end": "2492040"
  },
  {
    "text": "were just tracking like the value of each or rather whether or not a register was dependent on a on a previous",
    "start": "2492040",
    "end": "2497640"
  },
  {
    "text": "incarnation of that register this zor eax e looks like it's dependent on the previous value of eax and it's not the",
    "start": "2497640",
    "end": "2504560"
  },
  {
    "text": "rename is smart enough to know that this means give me a new eax put the value zero in it and move on with your life",
    "start": "2504560",
    "end": "2510440"
  },
  {
    "text": "and in fact in the newer thing the newer chips like the ivy bridge and and newer um at that point the micro operation",
    "start": "2510440",
    "end": "2517319"
  },
  {
    "text": "falls out of the pipeline we don't need to do any more work the work is done just by allocating a new empty slot that",
    "start": "2517319",
    "end": "2522880"
  },
  {
    "text": "has a z zero value in it for some of the instructions as well the ones that like um compare not with yourself which um",
    "start": "2522880",
    "end": "2529280"
  },
  {
    "text": "for the xmm registers sets it all to ones that also can happen on the ivy Bridges at this point and Inter register",
    "start": "2529280",
    "end": "2535599"
  },
  {
    "text": "moves so often times again to fit the ABI we'll be moving values between registers just to make sure that things",
    "start": "2535599",
    "end": "2541040"
  },
  {
    "text": "are in the E uh ESI or the EDI register ready to call a sub routine well all",
    "start": "2541040",
    "end": "2546359"
  },
  {
    "text": "that is is just an counting update if we think that the most recent value of EDI is in slot s well that's all we need to",
    "start": "2546359",
    "end": "2553040"
  },
  {
    "text": "record okay it's in slot s now and again the not the move itself doesn't have to happen so a lot of the instructions can",
    "start": "2553040",
    "end": "2559760"
  },
  {
    "text": "be peeled out a lot of the sort of like in between instructions the moves and the shifts sorry the moves and the",
    "start": "2559760",
    "end": "2565480"
  },
  {
    "text": "exclusive or itself can actually disappear out of the instruction stream at this point and we just update our",
    "start": "2565480",
    "end": "2571480"
  },
  {
    "text": "tables so the reorder buffer is this temporary scratch space of these hundred odd",
    "start": "2572040",
    "end": "2577640"
  },
  {
    "text": "um in process Micro Ops and their operand the re buffer holds the state it",
    "start": "2577640",
    "end": "2584119"
  },
  {
    "text": "knows what the micro operation is it knows the inputs and in the case of micro operations that don't have their",
    "start": "2584119",
    "end": "2590280"
  },
  {
    "text": "values ready it knows which other operations it's waiting on and it snoops",
    "start": "2590280",
    "end": "2596480"
  },
  {
    "text": "the results of completing instructions so as as a dependent instruction completes it's broadcast across like an",
    "start": "2596480",
    "end": "2602680"
  },
  {
    "text": "internal bus and any micro operation that's waiting for those results can now",
    "start": "2602680",
    "end": "2608000"
  },
  {
    "text": "read it in store it and become ready to run this is also the stage where that um",
    "start": "2608000",
    "end": "2614040"
  },
  {
    "text": "uh permanent register read happens and at this point the micro operations remain in the buffer until the very last",
    "start": "2614040",
    "end": "2619920"
  },
  {
    "text": "stage of the pipeline okay we're we're we're nearly at the point now where we're going to",
    "start": "2619920",
    "end": "2625520"
  },
  {
    "text": "get into the magic territory of actually ex executing these instructions and for the first time we're going to go out of",
    "start": "2625520",
    "end": "2633160"
  },
  {
    "text": "order the uh reservation stations is like the last step this is where some kind of scheduling algorithm which again",
    "start": "2633160",
    "end": "2639200"
  },
  {
    "text": "is very very vaguely described in the literature is responsible for working out which of the micro operations are",
    "start": "2639200",
    "end": "2645079"
  },
  {
    "text": "going to go to which parts of the chip to actually be executed there are six execution ports",
    "start": "2645079",
    "end": "2652319"
  },
  {
    "text": "and each execution Port can only do a subset of instructions there's a lot of overlap between them but there is uh",
    "start": "2652319",
    "end": "2658319"
  },
  {
    "text": "there are also like unique areas that can only do one particular kind of instruction and that looks oh we're here",
    "start": "2658319",
    "end": "2665079"
  },
  {
    "text": "yes so we've we've actually going to talk about which parts do what now um we've just done the top part here which",
    "start": "2665079",
    "end": "2670599"
  },
  {
    "text": "is the in order part of the queue and now we're into the scheduling domain down here and it's worth talking about",
    "start": "2670599",
    "end": "2676599"
  },
  {
    "text": "these ports here so we've got the six ports here this is sorry this is Sandy Bridge there's six ports the first three ports on here which are oxy moronically",
    "start": "2676599",
    "end": "2683240"
  },
  {
    "text": "0 one and five um they all have an ALU attached to them so they can all do the simple operations of move if they",
    "start": "2683240",
    "end": "2689960"
  },
  {
    "text": "haven't already been renamed out of existence they can do shifts they can do ORS they can do exclusive ores they can",
    "start": "2689960",
    "end": "2696119"
  },
  {
    "text": "do comparisons and what this means is that in any one tick if there are three simple",
    "start": "2696119",
    "end": "2702160"
  },
  {
    "text": "operations ready they can all start executing that means that we now starting to do three things at once",
    "start": "2702160",
    "end": "2707319"
  },
  {
    "text": "that's great um if you're doing loads or stores you're going to be using these ports",
    "start": "2707319",
    "end": "2712359"
  },
  {
    "text": "over here ports two three and four we've got two load ports and one store Port so you can see that there's sort of a bit",
    "start": "2712359",
    "end": "2718559"
  },
  {
    "text": "of contention there in terms of the number of these things going on there's an extra thing about um the stores as",
    "start": "2718559",
    "end": "2724680"
  },
  {
    "text": "I've said the indexing modes are really complicated we can have like this Base address plus two registers with one of them being multiplied by a constant",
    "start": "2724680",
    "end": "2731240"
  },
  {
    "text": "value power two constant um for for reasons I don't fully understand on at",
    "start": "2731240",
    "end": "2736559"
  },
  {
    "text": "least on Sandy bridge this fourth Port the store Port doesn't have the logic the circuitry to do that address",
    "start": "2736559",
    "end": "2742720"
  },
  {
    "text": "calculation and so whenever you do a store it's not just the case that you have two loaders and one store so there's a dis disparity between them",
    "start": "2742720",
    "end": "2749240"
  },
  {
    "text": "every time you do a store it has to borrow one of the load units just to do the address calculation and that's an",
    "start": "2749240",
    "end": "2754400"
  },
  {
    "text": "example of those those fused micro operations where a store is both the address calculation and the load but it",
    "start": "2754400",
    "end": "2760079"
  },
  {
    "text": "kind of borrows two ports at once even though it's only one actual slot in the reorder buffer other things to note here is that",
    "start": "2760079",
    "end": "2766880"
  },
  {
    "text": "once we get into the more complicated instructions like uh floating Point multiplies and adds various shuffles",
    "start": "2766880",
    "end": "2773200"
  },
  {
    "text": "there are only one or maybe two units that can do that work which limits the amount of those we can do at",
    "start": "2773200",
    "end": "2780359"
  },
  {
    "text": "once yes six units uh that's yes we have uh yeah six",
    "start": "2781000",
    "end": "2789359"
  },
  {
    "text": "units they're mostly peline themselves so that means that each each unit say a multiply unit may take six units Six",
    "start": "2789359",
    "end": "2796400"
  },
  {
    "text": "Clock Cycles to complete but um we can start a new multiply every single cycle",
    "start": "2796400",
    "end": "2802680"
  },
  {
    "text": "so although the individual results of one multiply aren't ready until the sixth tick we can start a new one each",
    "start": "2802680",
    "end": "2808800"
  },
  {
    "text": "each each clock cycle this means that the issue rates down here are up to three of cycle that's what I was saying",
    "start": "2808800",
    "end": "2814599"
  },
  {
    "text": "with those alus with the fact that we have three ALU unit this means that every single click click clock we can",
    "start": "2814599",
    "end": "2820079"
  },
  {
    "text": "start uh um three of those guys we can only start one floating Point multiply every clock cycle which is a shame um in",
    "start": "2820079",
    "end": "2828280"
  },
  {
    "text": "this instance I'm also only talking about like the the Scala multiplies that can happen the um if you're starting to",
    "start": "2828280",
    "end": "2833800"
  },
  {
    "text": "use the xmm instructions to do like multiple floating um floating points uh in parallel where you like have four or",
    "start": "2833800",
    "end": "2840400"
  },
  {
    "text": "more packed into the xmm registers only one of those can start each go but there are like four independent multiplies or",
    "start": "2840400",
    "end": "2847119"
  },
  {
    "text": "eight depending on the width of your registers there's another sort of component as well as the throughput",
    "start": "2847119",
    "end": "2853000"
  },
  {
    "text": "issue of like how many we can start each tick we have um the dependency between",
    "start": "2853000",
    "end": "2859960"
  },
  {
    "text": "instructions so for the logic Ops and moves if you start a move or a uh an",
    "start": "2859960",
    "end": "2865400"
  },
  {
    "text": "exclusive order results are ready on the next tick so the next instruction depends upon that can start the very next cycle for integer multiplies that's",
    "start": "2865400",
    "end": "2872240"
  },
  {
    "text": "three for floting Point multipliers as I said that's sort of fiveish six for square roots 10 24 for divide and",
    "start": "2872240",
    "end": "2878800"
  },
  {
    "text": "remainder we're looking anywhere between 24 and 84 it depends on the actual data you're using and the Really key thing",
    "start": "2878800",
    "end": "2885079"
  },
  {
    "text": "about this is that that is not pipelined the we can only issue we can",
    "start": "2885079",
    "end": "2893319"
  },
  {
    "text": "only have one integer divide going on at once so in St contrast to those multiplies that are going on where we",
    "start": "2893319",
    "end": "2899359"
  },
  {
    "text": "can have three one at a time but you know one one every single cycle a divide",
    "start": "2899359",
    "end": "2904640"
  },
  {
    "text": "or remainder is going to take 80 Cycles to get the result alter and we can't be doing any other divides or remainders so",
    "start": "2904640",
    "end": "2910599"
  },
  {
    "text": "all of your hash tables that you've written where you're using like the modulus with a prime number size of table um maybe you should consider",
    "start": "2910599",
    "end": "2918680"
  },
  {
    "text": "looking at using a more complicated hashing function which uses multiplies exclusive ores moves shifts um which can",
    "start": "2918680",
    "end": "2927160"
  },
  {
    "text": "all be computed a lot quicker and then just anding with like a power of two uh",
    "start": "2927160",
    "end": "2932400"
  },
  {
    "text": "to to fit into a power two size table rather than waiting 80 cycles for your divide you know having higher quality hash function might be a better tradeoff",
    "start": "2932400",
    "end": "2939640"
  },
  {
    "text": "anyway I am starting to run out of time um this is my quick dip into the excuse",
    "start": "2939640",
    "end": "2944920"
  },
  {
    "text": "for why I can't have 4 gabt of cach ram why do it take three to 250 Cycles to",
    "start": "2944920",
    "end": "2951480"
  },
  {
    "text": "access RAM on the left hand side here I have one bit of static Ram that's such",
    "start": "2951480",
    "end": "2958000"
  },
  {
    "text": "as you'd find in your cache on the right hand side I have one bit of dam now it's pretty clear that the left hand side is",
    "start": "2958000",
    "end": "2963920"
  },
  {
    "text": "much more complicated than the right hand side but why is that bad well on the left hand side we have a",
    "start": "2963920",
    "end": "2969839"
  },
  {
    "text": "pure logic device this is a um discrete component we're going to get zero or one",
    "start": "2969839",
    "end": "2975960"
  },
  {
    "text": "out of this at all times but it requires constant power it requires six transistors and a bunch of complicated",
    "start": "2975960",
    "end": "2981880"
  },
  {
    "text": "overlapping wires which make it very very difficult to lay this out in a high density way on a chip I don't know how",
    "start": "2981880",
    "end": "2987640"
  },
  {
    "text": "Intel do it but you look on the die and there's these beautiful areas which are clearly the cache of the same thing over and over again but somehow they've",
    "start": "2987640",
    "end": "2994599"
  },
  {
    "text": "they've they've uh been able to get that um done but but it's power hungry it",
    "start": "2994599",
    "end": "2999720"
  },
  {
    "text": "means it heats up it's a problem for for um yeah heat dissipation um but it's a",
    "start": "2999720",
    "end": "3006280"
  },
  {
    "text": "logic device which is great on the right hand side we have something which is an",
    "start": "3006280",
    "end": "3011760"
  },
  {
    "text": "analog component this capacitor down here stores some very small number of",
    "start": "3011760",
    "end": "3017640"
  },
  {
    "text": "electrons to store whether there's a zero or one there which means we don't need to pay powering it when we're not",
    "start": "3017640",
    "end": "3024240"
  },
  {
    "text": "accessing it we can turn the power off and it'll be there except that it drains away over time so we have to keep occasionally topping it up which reduces",
    "start": "3024240",
    "end": "3030359"
  },
  {
    "text": "our memory bandwidth we just have to keep using that just to keep topping it up but more importantly every time we read from this is an analog to digital",
    "start": "3030359",
    "end": "3036359"
  },
  {
    "text": "conversion which takes time so the why would we even do this well",
    "start": "3036359",
    "end": "3043040"
  },
  {
    "text": "obviously we don't need power all the time that's great these are very very much simpler we can lay out these out a",
    "start": "3043040",
    "end": "3048400"
  },
  {
    "text": "much higher density which is why your dram cells are much much much more tightly packed and you can have your gigabytes of RAM um and obviously the",
    "start": "3048400",
    "end": "3056680"
  },
  {
    "text": "other part to this is that the the dam is usually physically separated from the chip rather than being on die as such",
    "start": "3056680",
    "end": "3062480"
  },
  {
    "text": "there's propagation delays it just takes a while unfort the laws of physics are against us the electrons don't move anywhere near the speed of light and",
    "start": "3062480",
    "end": "3067640"
  },
  {
    "text": "they've got to move quite a long way from the ram chip to get onto the processor so that's kind of my apology",
    "start": "3067640",
    "end": "3073720"
  },
  {
    "text": "for why we can't have lots of uh cach RAM um there's some example timings here",
    "start": "3073720",
    "end": "3079760"
  },
  {
    "text": "and uh I think we've we all know that there it's better to keep things in the L the level caches the the lower level",
    "start": "3079760",
    "end": "3085760"
  },
  {
    "text": "cached caches um we will blast through these last couple of bits here so the last thing",
    "start": "3085760",
    "end": "3090880"
  },
  {
    "text": "that happens is when the instruction has completed it broadcast its result which frees up any of the micro operations",
    "start": "3090880",
    "end": "3097160"
  },
  {
    "text": "that are waiting to be scheduled they become ready to run if they are in which case the scheduler will pick them up the next tick um we've got some complicated",
    "start": "3097160",
    "end": "3104319"
  },
  {
    "text": "things to do with store foring which I haven't got time to talk about now and the last stage is this retirement stage",
    "start": "3104319",
    "end": "3109480"
  },
  {
    "text": "which is where some of the better magic happens so in the retirement stage so far we have kind of each instruction",
    "start": "3109480",
    "end": "3116119"
  },
  {
    "text": "that's been going down the par line has been a transaction that has yet to commit although we may have read from",
    "start": "3116119",
    "end": "3121680"
  },
  {
    "text": "memory any rights that we've done are sort of held up in a storing buffer that hasn't yet made it",
    "start": "3121680",
    "end": "3127119"
  },
  {
    "text": "out why is this important well we have we reordered everything along the way",
    "start": "3127119",
    "end": "3133000"
  },
  {
    "text": "what happens if we got one of the branches wrong but what happens if it took us a while to find that out we'd already started doing some of the work that was the other side of that Branch",
    "start": "3133000",
    "end": "3140319"
  },
  {
    "text": "we need to undo that work and the way that that's done is by just not committing the instruction basically",
    "start": "3140319",
    "end": "3145640"
  },
  {
    "text": "blowing away that transaction that the instruction started and not writing back to the permanent register file not",
    "start": "3145640",
    "end": "3151520"
  },
  {
    "text": "allowing the store to actually flow out to the outside of the chip um by not allowing the instruction to retire",
    "start": "3151520",
    "end": "3157920"
  },
  {
    "text": "similarly exceptions like divide by zeros and it may be the case that a divide um the values for a divide",
    "start": "3157920",
    "end": "3163720"
  },
  {
    "text": "weren't known up up front and so um instructions Beyond The Divide have already finished and completed but um",
    "start": "3163720",
    "end": "3170559"
  },
  {
    "text": "the divide by zero has to happen with the old value of those um uh operands",
    "start": "3170559",
    "end": "3176839"
  },
  {
    "text": "and there is uh there's kind of this is starting to become exposed to the programming model this this whole idea",
    "start": "3176839",
    "end": "3182160"
  },
  {
    "text": "of having these sort of uh transactional instructions where so for example Haswell has this software transactional",
    "start": "3182160",
    "end": "3188240"
  },
  {
    "text": "memory model where you can um ask to be notified if if um various parts of ram",
    "start": "3188240",
    "end": "3195240"
  },
  {
    "text": "are accessed while you're running and abought in a set of instructions so that an atomic operation from your point of",
    "start": "3195240",
    "end": "3201520"
  },
  {
    "text": "view doesn't require a lock it just means the transaction being rolled back um since discovered that this is not",
    "start": "3201520",
    "end": "3207640"
  },
  {
    "text": "actually done by effectively like the same logic as the branch prediction it's probably done in the cach level but there is talk in the sky Lake which is",
    "start": "3207640",
    "end": "3214319"
  },
  {
    "text": "like two more revisions up of them exposing this instruction level transaction to us as",
    "start": "3214319",
    "end": "3221280"
  },
  {
    "text": "programmers okay we've reached the end there's an awful lot of stuff that's going on under the hood and I don't",
    "start": "3221280",
    "end": "3226960"
  },
  {
    "text": "think I have time for questions judging from the time but thank you very much for your time everyone there's there's uh some example resources up there thank",
    "start": "3226960",
    "end": "3234000"
  },
  {
    "text": "you [Applause]",
    "start": "3234000",
    "end": "3238759"
  }
]