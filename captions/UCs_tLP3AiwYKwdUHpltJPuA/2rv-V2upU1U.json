[
  {
    "start": "0",
    "end": "60000"
  },
  {
    "text": "yeah thank you",
    "start": "14360",
    "end": "16740"
  },
  {
    "text": "yeah I'm Ahmed I've been programming for",
    "start": "16740",
    "end": "18779"
  },
  {
    "text": "quite a few years now uh recently I've",
    "start": "18779",
    "end": "20580"
  },
  {
    "text": "been playing around with rust I find it",
    "start": "20580",
    "end": "21960"
  },
  {
    "text": "to be an interesting language so I build",
    "start": "21960",
    "end": "23820"
  },
  {
    "text": "some internal tools and stuff on Rust so",
    "start": "23820",
    "end": "26580"
  },
  {
    "text": "I'm going to share the function",
    "start": "26580",
    "end": "27840"
  },
  {
    "text": "programming features in Rust uh before I",
    "start": "27840",
    "end": "30359"
  },
  {
    "text": "start like how many of you are already",
    "start": "30359",
    "end": "31679"
  },
  {
    "text": "familiar with rust",
    "start": "31679",
    "end": "33480"
  },
  {
    "text": "okay it's a few so this is going to be a",
    "start": "33480",
    "end": "36780"
  },
  {
    "text": "basic introduction to rust as a function",
    "start": "36780",
    "end": "38700"
  },
  {
    "text": "programming language and to set the",
    "start": "38700",
    "end": "40980"
  },
  {
    "text": "expectations",
    "start": "40980",
    "end": "42300"
  },
  {
    "text": "um so if you look at the programming",
    "start": "42300",
    "end": "44219"
  },
  {
    "text": "languages Spectrum so you have all the",
    "start": "44219",
    "end": "46020"
  },
  {
    "text": "Java C plus plus python on one side if",
    "start": "46020",
    "end": "49320"
  },
  {
    "text": "you compare the function programming",
    "start": "49320",
    "end": "50579"
  },
  {
    "text": "aspects and you have Haskell on the",
    "start": "50579",
    "end": "53039"
  },
  {
    "text": "right and act and other things on far",
    "start": "53039",
    "end": "55680"
  },
  {
    "text": "right right so rust is somewhere in",
    "start": "55680",
    "end": "57840"
  },
  {
    "text": "between",
    "start": "57840",
    "end": "59760"
  },
  {
    "text": "um okay so let's start with what is",
    "start": "59760",
    "end": "62579"
  },
  {
    "start": "60000",
    "end": "275000"
  },
  {
    "text": "function programming I guess all of you",
    "start": "62579",
    "end": "64080"
  },
  {
    "text": "know it probably better than me uh but",
    "start": "64080",
    "end": "67439"
  },
  {
    "text": "different people have slightly different",
    "start": "67439",
    "end": "68939"
  },
  {
    "text": "idea about what function programming is",
    "start": "68939",
    "end": "71340"
  },
  {
    "text": "right",
    "start": "71340",
    "end": "73260"
  },
  {
    "text": "um",
    "start": "73260",
    "end": "73920"
  },
  {
    "text": "so",
    "start": "73920",
    "end": "75360"
  },
  {
    "text": "let me just give a quick recap of what I",
    "start": "75360",
    "end": "78240"
  },
  {
    "text": "think are the key uh aspects of function",
    "start": "78240",
    "end": "81000"
  },
  {
    "text": "programming languages so it's pure",
    "start": "81000",
    "end": "83100"
  },
  {
    "text": "functions and values functions only",
    "start": "83100",
    "end": "84720"
  },
  {
    "text": "transform values from one to another and",
    "start": "84720",
    "end": "87119"
  },
  {
    "text": "the key feature of function programming",
    "start": "87119",
    "end": "89220"
  },
  {
    "text": "language is composition so if you look",
    "start": "89220",
    "end": "91799"
  },
  {
    "text": "at it the core of FP and category theory",
    "start": "91799",
    "end": "94320"
  },
  {
    "text": "is how we can compose things in a",
    "start": "94320",
    "end": "96360"
  },
  {
    "text": "principled way",
    "start": "96360",
    "end": "98400"
  },
  {
    "text": "um and this helps us reason about our",
    "start": "98400",
    "end": "100560"
  },
  {
    "text": "programs and",
    "start": "100560",
    "end": "102299"
  },
  {
    "text": "um you know it's tough so it's kind of",
    "start": "102299",
    "end": "104880"
  },
  {
    "text": "like building things using legal blocks",
    "start": "104880",
    "end": "108119"
  },
  {
    "text": "um so it's so there are no side effects",
    "start": "108119",
    "end": "109740"
  },
  {
    "text": "it's clear how you can build things and",
    "start": "109740",
    "end": "111420"
  },
  {
    "text": "it's easy to break it apart and",
    "start": "111420",
    "end": "112680"
  },
  {
    "text": "recompose things and the same rules",
    "start": "112680",
    "end": "114780"
  },
  {
    "text": "apply if you're building something small",
    "start": "114780",
    "end": "116399"
  },
  {
    "text": "or you're building something complex so",
    "start": "116399",
    "end": "118619"
  },
  {
    "text": "which is a nice property",
    "start": "118619",
    "end": "121979"
  },
  {
    "text": "um so let's now look at rust so rust was",
    "start": "121979",
    "end": "124740"
  },
  {
    "text": "designed as a system programming",
    "start": "124740",
    "end": "126119"
  },
  {
    "text": "language and over the years it has",
    "start": "126119",
    "end": "128640"
  },
  {
    "text": "become popular I think the last couple",
    "start": "128640",
    "end": "130380"
  },
  {
    "text": "of years it was voted as the most loud",
    "start": "130380",
    "end": "132660"
  },
  {
    "text": "language in stack overflow",
    "start": "132660",
    "end": "135900"
  },
  {
    "text": "um so why should you learn a new",
    "start": "135900",
    "end": "137400"
  },
  {
    "text": "language so I like this quote from Ellen",
    "start": "137400",
    "end": "139379"
  },
  {
    "text": "pearlis and I think rust does influence",
    "start": "139379",
    "end": "142620"
  },
  {
    "text": "the way we think about programming so",
    "start": "142620",
    "end": "144239"
  },
  {
    "text": "it's it's good to learn on its own right",
    "start": "144239",
    "end": "147420"
  },
  {
    "text": "um so if you look at the official",
    "start": "147420",
    "end": "148800"
  },
  {
    "text": "programming language website these are",
    "start": "148800",
    "end": "150840"
  },
  {
    "text": "the these are the three goals that are",
    "start": "150840",
    "end": "153239"
  },
  {
    "text": "mentioned for us so the primary one is",
    "start": "153239",
    "end": "156000"
  },
  {
    "text": "reliability and performance so we had",
    "start": "156000",
    "end": "158819"
  },
  {
    "text": "languages like C plus plus and C for",
    "start": "158819",
    "end": "160739"
  },
  {
    "text": "system programming languages for a long",
    "start": "160739",
    "end": "162239"
  },
  {
    "text": "time but they were not safe right so it",
    "start": "162239",
    "end": "165420"
  },
  {
    "text": "had issues with memories and threat",
    "start": "165420",
    "end": "167580"
  },
  {
    "text": "safety",
    "start": "167580",
    "end": "169080"
  },
  {
    "text": "um and stuff like that and rust has a",
    "start": "169080",
    "end": "172260"
  },
  {
    "text": "rich type system that addresses that",
    "start": "172260",
    "end": "173819"
  },
  {
    "text": "problem and the unique thing about rust",
    "start": "173819",
    "end": "176519"
  },
  {
    "text": "is it provides these two without",
    "start": "176519",
    "end": "178620"
  },
  {
    "text": "sacrificing the productivity so when you",
    "start": "178620",
    "end": "180840"
  },
  {
    "text": "go in trust it gives you a feeling of",
    "start": "180840",
    "end": "182819"
  },
  {
    "text": "writing in a high level language",
    "start": "182819",
    "end": "184920"
  },
  {
    "text": "um we'll see examples later",
    "start": "184920",
    "end": "188720"
  },
  {
    "text": "so it's based on the zero or head or",
    "start": "188819",
    "end": "191340"
  },
  {
    "text": "zero cost abstractions from C plus plus",
    "start": "191340",
    "end": "193500"
  },
  {
    "text": "which is what you don't use you don't",
    "start": "193500",
    "end": "195120"
  },
  {
    "text": "pay for and if you do use something you",
    "start": "195120",
    "end": "197700"
  },
  {
    "text": "couldn't hand code any better this might",
    "start": "197700",
    "end": "199440"
  },
  {
    "text": "seem obvious but if you've used any",
    "start": "199440",
    "end": "201239"
  },
  {
    "text": "programming language you know this is",
    "start": "201239",
    "end": "203280"
  },
  {
    "text": "not true so if you use like the higher",
    "start": "203280",
    "end": "205860"
  },
  {
    "text": "level abstractions there's generally a",
    "start": "205860",
    "end": "207360"
  },
  {
    "text": "performance cost and if you want to",
    "start": "207360",
    "end": "210959"
  },
  {
    "text": "optimize performance you generally have",
    "start": "210959",
    "end": "212940"
  },
  {
    "text": "to go out of the way and write",
    "start": "212940",
    "end": "214700"
  },
  {
    "text": "non-idematic code it is not true in Rust",
    "start": "214700",
    "end": "218099"
  },
  {
    "text": "foreign",
    "start": "218099",
    "end": "219000"
  },
  {
    "text": "I'm not going to go into the debate of",
    "start": "219000",
    "end": "220799"
  },
  {
    "text": "static versus Dynamic typing I'll just",
    "start": "220799",
    "end": "223620"
  },
  {
    "text": "say that in Rust compiler research front",
    "start": "223620",
    "end": "225180"
  },
  {
    "text": "you might have to spend more time to",
    "start": "225180",
    "end": "226739"
  },
  {
    "text": "make your program compile but once it",
    "start": "226739",
    "end": "228239"
  },
  {
    "text": "compiles it generally works",
    "start": "228239",
    "end": "231180"
  },
  {
    "text": "so the key features rust is statically",
    "start": "231180",
    "end": "233819"
  },
  {
    "text": "typed it has Type inference and the",
    "start": "233819",
    "end": "237299"
  },
  {
    "text": "unique features of rust are it's based",
    "start": "237299",
    "end": "239580"
  },
  {
    "text": "on an idea of linear types it has an",
    "start": "239580",
    "end": "241440"
  },
  {
    "text": "ownership model which is based on this",
    "start": "241440",
    "end": "242879"
  },
  {
    "text": "and region-based memory management just",
    "start": "242879",
    "end": "245340"
  },
  {
    "text": "together these two features gives rust",
    "start": "245340",
    "end": "248400"
  },
  {
    "text": "the memory safety that I talked about",
    "start": "248400",
    "end": "249780"
  },
  {
    "text": "earlier so it's free from data races",
    "start": "249780",
    "end": "253019"
  },
  {
    "text": "um",
    "start": "253019",
    "end": "253920"
  },
  {
    "text": "and it does not have a garbage collector",
    "start": "253920",
    "end": "256019"
  },
  {
    "text": "so there's no runtime cost associated",
    "start": "256019",
    "end": "258120"
  },
  {
    "text": "with it",
    "start": "258120",
    "end": "259500"
  },
  {
    "text": "um",
    "start": "259500",
    "end": "260820"
  },
  {
    "text": "yeah",
    "start": "260820",
    "end": "263359"
  },
  {
    "text": "so let's now dive into some Rust code so",
    "start": "263520",
    "end": "266160"
  },
  {
    "text": "the rest of the talk I'm just going",
    "start": "266160",
    "end": "267360"
  },
  {
    "text": "through a lot of code just to give you a",
    "start": "267360",
    "end": "269580"
  },
  {
    "text": "taste about how it looks like and to",
    "start": "269580",
    "end": "271919"
  },
  {
    "text": "motivate you to look into rust",
    "start": "271919",
    "end": "275820"
  },
  {
    "start": "275000",
    "end": "318000"
  },
  {
    "text": "so first let's start with on-shift model",
    "start": "275820",
    "end": "277620"
  },
  {
    "text": "so you need to understand a little bit",
    "start": "277620",
    "end": "278820"
  },
  {
    "text": "about this before we go into functional",
    "start": "278820",
    "end": "281460"
  },
  {
    "text": "language features",
    "start": "281460",
    "end": "283500"
  },
  {
    "text": "um so in Rust variables are immutable by",
    "start": "283500",
    "end": "285840"
  },
  {
    "text": "default so if you define a variable",
    "start": "285840",
    "end": "288240"
  },
  {
    "text": "and then try to reassign the value to it",
    "start": "288240",
    "end": "290580"
  },
  {
    "text": "the compiler will throw an error and",
    "start": "290580",
    "end": "293580"
  },
  {
    "text": "Trust has one of the best compiler",
    "start": "293580",
    "end": "295199"
  },
  {
    "text": "errors around so Elm is only the other",
    "start": "295199",
    "end": "297540"
  },
  {
    "text": "language that I've seen which has good",
    "start": "297540",
    "end": "299400"
  },
  {
    "text": "compiler address so it clearly tells you",
    "start": "299400",
    "end": "301320"
  },
  {
    "text": "what the problem is you're trying to",
    "start": "301320",
    "end": "302639"
  },
  {
    "text": "assign to immutable variable and where",
    "start": "302639",
    "end": "304680"
  },
  {
    "text": "the problem is it also tells you",
    "start": "304680",
    "end": "308040"
  },
  {
    "text": "generally it also gives you a suggestion",
    "start": "308040",
    "end": "309720"
  },
  {
    "text": "on how you can fix this so you can fix",
    "start": "309720",
    "end": "312360"
  },
  {
    "text": "this problem by making the variables",
    "start": "312360",
    "end": "314460"
  },
  {
    "text": "mutable",
    "start": "314460",
    "end": "315780"
  },
  {
    "text": "so",
    "start": "315780",
    "end": "318320"
  },
  {
    "text": "okay let's look at another piece of code",
    "start": "319500",
    "end": "321180"
  },
  {
    "text": "so here I'm assigning a string hello to",
    "start": "321180",
    "end": "324360"
  },
  {
    "text": "a variable X",
    "start": "324360",
    "end": "325620"
  },
  {
    "text": "and I also have an alias to it I assign",
    "start": "325620",
    "end": "329220"
  },
  {
    "text": "y also to X and try to print it so I'm",
    "start": "329220",
    "end": "331320"
  },
  {
    "text": "not modifying anything so this works in",
    "start": "331320",
    "end": "333720"
  },
  {
    "text": "almost all the mainstream languages but",
    "start": "333720",
    "end": "336120"
  },
  {
    "text": "this fails in Rust because of the",
    "start": "336120",
    "end": "338100"
  },
  {
    "text": "ownership model so in Rust every value",
    "start": "338100",
    "end": "340199"
  },
  {
    "text": "has a single owner which is a variable",
    "start": "340199",
    "end": "343639"
  },
  {
    "text": "so in line three when we reassign when",
    "start": "343639",
    "end": "347580"
  },
  {
    "text": "we assigned X to Y it also moves the",
    "start": "347580",
    "end": "350100"
  },
  {
    "text": "ownership to Y now why is the owner so",
    "start": "350100",
    "end": "353039"
  },
  {
    "text": "in line four you cannot access X anymore",
    "start": "353039",
    "end": "355979"
  },
  {
    "text": "so that's what the compiler is telling",
    "start": "355979",
    "end": "358080"
  },
  {
    "text": "us but if you have any questions on a",
    "start": "358080",
    "end": "361080"
  },
  {
    "text": "particular slide or something stop me",
    "start": "361080",
    "end": "362820"
  },
  {
    "text": "and ask any time",
    "start": "362820",
    "end": "364979"
  },
  {
    "text": "um",
    "start": "364979",
    "end": "366180"
  },
  {
    "text": "and",
    "start": "366180",
    "end": "367500"
  },
  {
    "text": "the recent rust does not have garbage",
    "start": "367500",
    "end": "369060"
  },
  {
    "text": "collector is because every value has",
    "start": "369060",
    "end": "371280"
  },
  {
    "text": "single owner once the variable goes out",
    "start": "371280",
    "end": "373380"
  },
  {
    "text": "of scope it can just clear the value so",
    "start": "373380",
    "end": "376080"
  },
  {
    "text": "the",
    "start": "376080",
    "end": "377460"
  },
  {
    "text": "value X is dropped once you reach line",
    "start": "377460",
    "end": "380520"
  },
  {
    "text": "five because X is out of scope now",
    "start": "380520",
    "end": "383639"
  },
  {
    "text": "uh and here again the compiler gives you",
    "start": "383639",
    "end": "385560"
  },
  {
    "text": "a clear error it says when the value is",
    "start": "385560",
    "end": "388319"
  },
  {
    "text": "moved it also tells that",
    "start": "388319",
    "end": "391380"
  },
  {
    "text": "um the value is moved because the type",
    "start": "391380",
    "end": "393900"
  },
  {
    "text": "does not Implement a copy trait so trait",
    "start": "393900",
    "end": "396780"
  },
  {
    "text": "is kind of pretty similar to type",
    "start": "396780",
    "end": "399360"
  },
  {
    "text": "classes in Haskell so we'll say traits",
    "start": "399360",
    "end": "401580"
  },
  {
    "text": "later so the way you solve this problem",
    "start": "401580",
    "end": "404100"
  },
  {
    "text": "one way to solve this problem is to",
    "start": "404100",
    "end": "407100"
  },
  {
    "start": "405000",
    "end": "427000"
  },
  {
    "text": "clone the value so you create two",
    "start": "407100",
    "end": "408240"
  },
  {
    "text": "different values they have two different",
    "start": "408240",
    "end": "409680"
  },
  {
    "text": "owners so everything works you can also",
    "start": "409680",
    "end": "412560"
  },
  {
    "text": "if the type implements copy trade it",
    "start": "412560",
    "end": "415080"
  },
  {
    "text": "will also work so intuitively it's",
    "start": "415080",
    "end": "417180"
  },
  {
    "text": "something that can be located in stack",
    "start": "417180",
    "end": "419699"
  },
  {
    "text": "so it's kind of cheap to copy like",
    "start": "419699",
    "end": "421080"
  },
  {
    "text": "primitive integers so",
    "start": "421080",
    "end": "423419"
  },
  {
    "text": "it is fine to reassign variables and use",
    "start": "423419",
    "end": "426479"
  },
  {
    "text": "it",
    "start": "426479",
    "end": "427740"
  },
  {
    "start": "427000",
    "end": "509000"
  },
  {
    "text": "um",
    "start": "427740",
    "end": "429479"
  },
  {
    "text": "so we all know that mutability is bad",
    "start": "429479",
    "end": "431639"
  },
  {
    "text": "right but what is really bad is shared",
    "start": "431639",
    "end": "433800"
  },
  {
    "text": "mutable State and in Rust you cannot",
    "start": "433800",
    "end": "435840"
  },
  {
    "text": "have shared mutable State the compiler",
    "start": "435840",
    "end": "437460"
  },
  {
    "text": "guarantees that so there are some",
    "start": "437460",
    "end": "439740"
  },
  {
    "text": "specific types that you can use to",
    "start": "439740",
    "end": "442560"
  },
  {
    "text": "explicitly demand shared mutable state",
    "start": "442560",
    "end": "444780"
  },
  {
    "text": "but otherwise it's not possible so let's",
    "start": "444780",
    "end": "447720"
  },
  {
    "text": "look at a function so this is how we",
    "start": "447720",
    "end": "449280"
  },
  {
    "text": "Define functions in Rust using the FN",
    "start": "449280",
    "end": "451560"
  },
  {
    "text": "keyword the function name it takes in a",
    "start": "451560",
    "end": "453780"
  },
  {
    "text": "string and returns a string",
    "start": "453780",
    "end": "456300"
  },
  {
    "text": "um and what I'm doing here is mutating",
    "start": "456300",
    "end": "458039"
  },
  {
    "text": "the",
    "start": "458039",
    "end": "459780"
  },
  {
    "text": "um the parameter that's passed in and",
    "start": "459780",
    "end": "462720"
  },
  {
    "text": "returning it so this is considered a bad",
    "start": "462720",
    "end": "464460"
  },
  {
    "text": "practice even in imperative languages",
    "start": "464460",
    "end": "466080"
  },
  {
    "text": "right but it's kind of fine in Rust",
    "start": "466080",
    "end": "469380"
  },
  {
    "text": "because once you call this function",
    "start": "469380",
    "end": "472979"
  },
  {
    "text": "the function takes ownership of the",
    "start": "472979",
    "end": "474599"
  },
  {
    "text": "variable so you cannot access that",
    "start": "474599",
    "end": "476460"
  },
  {
    "text": "variable anymore so this is totally safe",
    "start": "476460",
    "end": "478139"
  },
  {
    "text": "in Rust even if you call it across",
    "start": "478139",
    "end": "479759"
  },
  {
    "text": "multiple threads it's fine so this is a",
    "start": "479759",
    "end": "481680"
  },
  {
    "text": "pure function",
    "start": "481680",
    "end": "483000"
  },
  {
    "text": "so if you call it with the same",
    "start": "483000",
    "end": "484560"
  },
  {
    "text": "parameter it always returns the same",
    "start": "484560",
    "end": "486000"
  },
  {
    "text": "result so this is an interesting way to",
    "start": "486000",
    "end": "488340"
  },
  {
    "text": "so in functional programming languages",
    "start": "488340",
    "end": "490319"
  },
  {
    "text": "we have this per system data structures",
    "start": "490319",
    "end": "492060"
  },
  {
    "text": "to uh to to make our data structures",
    "start": "492060",
    "end": "495360"
  },
  {
    "text": "immutable right so this is a way to do",
    "start": "495360",
    "end": "498960"
  },
  {
    "text": "the same thing in Rust the caller does",
    "start": "498960",
    "end": "501060"
  },
  {
    "text": "not know that",
    "start": "501060",
    "end": "502879"
  },
  {
    "text": "it is getting the same value",
    "start": "502879",
    "end": "507780"
  },
  {
    "text": "foreign",
    "start": "507960",
    "end": "510138"
  },
  {
    "start": "509000",
    "end": "568000"
  },
  {
    "text": "but sometimes we want to keep ownership",
    "start": "510259",
    "end": "513360"
  },
  {
    "text": "we don't want to give ownership to",
    "start": "513360",
    "end": "515219"
  },
  {
    "text": "functions for example I'm calling a",
    "start": "515219",
    "end": "517740"
  },
  {
    "text": "read-only function let's say length and",
    "start": "517740",
    "end": "520200"
  },
  {
    "text": "I still want to have access to that",
    "start": "520200",
    "end": "521940"
  },
  {
    "text": "value after that call or if you see in",
    "start": "521940",
    "end": "525060"
  },
  {
    "text": "line 8 I'm printing the function",
    "start": "525060",
    "end": "526380"
  },
  {
    "text": "printing a variable I still want to keep",
    "start": "526380",
    "end": "529560"
  },
  {
    "text": "ownership after printing something right",
    "start": "529560",
    "end": "532339"
  },
  {
    "text": "so for that",
    "start": "532339",
    "end": "534959"
  },
  {
    "text": "rust has references so references are",
    "start": "534959",
    "end": "537540"
  },
  {
    "text": "like references in C plus plus you use",
    "start": "537540",
    "end": "540120"
  },
  {
    "text": "an ampersand to say that instead of",
    "start": "540120",
    "end": "543180"
  },
  {
    "text": "friends",
    "start": "543180",
    "end": "544620"
  },
  {
    "text": "um and if you use a reference the",
    "start": "544620",
    "end": "545940"
  },
  {
    "text": "function does not take ownership it just",
    "start": "545940",
    "end": "547680"
  },
  {
    "text": "borrows the variable and once the",
    "start": "547680",
    "end": "550380"
  },
  {
    "text": "function is done the outer function",
    "start": "550380",
    "end": "552779"
  },
  {
    "text": "still has access to that variable and it",
    "start": "552779",
    "end": "555120"
  },
  {
    "text": "is totally type safe and rust will track",
    "start": "555120",
    "end": "558180"
  },
  {
    "text": "the lifetime and all that so you cannot",
    "start": "558180",
    "end": "560519"
  },
  {
    "text": "so references are always valid",
    "start": "560519",
    "end": "562860"
  },
  {
    "text": "uh interest you can also have mutable",
    "start": "562860",
    "end": "565980"
  },
  {
    "text": "references using the mute keyword",
    "start": "565980",
    "end": "569220"
  },
  {
    "start": "568000",
    "end": "597000"
  },
  {
    "text": "so just to give an overview so every",
    "start": "569220",
    "end": "572339"
  },
  {
    "text": "value has single owner and when the",
    "start": "572339",
    "end": "574740"
  },
  {
    "text": "owner goes out of scope the value is",
    "start": "574740",
    "end": "576300"
  },
  {
    "text": "dropped and you can either have a",
    "start": "576300",
    "end": "578700"
  },
  {
    "text": "mutable reference or any number of",
    "start": "578700",
    "end": "581100"
  },
  {
    "text": "immutable reference you cannot have both",
    "start": "581100",
    "end": "583080"
  },
  {
    "text": "and this is what guarantees that the",
    "start": "583080",
    "end": "586440"
  },
  {
    "text": "memory safety and",
    "start": "586440",
    "end": "588300"
  },
  {
    "text": "no data raises interest",
    "start": "588300",
    "end": "590480"
  },
  {
    "text": "references also have lifetimes I'm not",
    "start": "590480",
    "end": "594360"
  },
  {
    "text": "going to cover lifetimes in this talk",
    "start": "594360",
    "end": "597860"
  },
  {
    "start": "597000",
    "end": "611000"
  },
  {
    "text": "okay now let's look at functional",
    "start": "598140",
    "end": "599880"
  },
  {
    "text": "programming aspects of rust so trust has",
    "start": "599880",
    "end": "601740"
  },
  {
    "text": "all the basic types that you'd expect",
    "start": "601740",
    "end": "603000"
  },
  {
    "text": "it's boring uh let's look at algebraic",
    "start": "603000",
    "end": "606120"
  },
  {
    "text": "data types how you can Define your types",
    "start": "606120",
    "end": "608580"
  },
  {
    "text": "and compose them right that's what it's",
    "start": "608580",
    "end": "610440"
  },
  {
    "text": "more interesting",
    "start": "610440",
    "end": "611700"
  },
  {
    "start": "611000",
    "end": "643000"
  },
  {
    "text": "so one way to look at types is by the",
    "start": "611700",
    "end": "614580"
  },
  {
    "text": "number of inhabitants so in Rust you can",
    "start": "614580",
    "end": "616560"
  },
  {
    "text": "create a type with no values using the",
    "start": "616560",
    "end": "619080"
  },
  {
    "text": "enum keyword so enum is like a data",
    "start": "619080",
    "end": "621600"
  },
  {
    "text": "Constructor in Haskell so on the right",
    "start": "621600",
    "end": "623220"
  },
  {
    "text": "side you see the equivalent Haskell code",
    "start": "623220",
    "end": "625440"
  },
  {
    "text": "so I Define an enum the type name is",
    "start": "625440",
    "end": "627480"
  },
  {
    "text": "white it does not have any variant",
    "start": "627480",
    "end": "629459"
  },
  {
    "text": "inside so you cannot instantiate this",
    "start": "629459",
    "end": "631440"
  },
  {
    "text": "type so this is just use useful in some",
    "start": "631440",
    "end": "635100"
  },
  {
    "text": "special cases like if you're a function",
    "start": "635100",
    "end": "636980"
  },
  {
    "text": "that does not return",
    "start": "636980",
    "end": "639899"
  },
  {
    "text": "I can use this type there are cases",
    "start": "639899",
    "end": "642420"
  },
  {
    "text": "where it is useful",
    "start": "642420",
    "end": "643860"
  },
  {
    "start": "643000",
    "end": "671000"
  },
  {
    "text": "more useful is something which has one",
    "start": "643860",
    "end": "645660"
  },
  {
    "text": "value which is called Unit in most",
    "start": "645660",
    "end": "647940"
  },
  {
    "text": "languages some language is called sit",
    "start": "647940",
    "end": "649980"
  },
  {
    "text": "void to confuse people but",
    "start": "649980",
    "end": "652680"
  },
  {
    "text": "um so you can Define unit using",
    "start": "652680",
    "end": "654839"
  },
  {
    "text": "again enum which is very similar to how",
    "start": "654839",
    "end": "656640"
  },
  {
    "text": "you do it in Haskell or as a built-in",
    "start": "656640",
    "end": "659459"
  },
  {
    "text": "unit type so if a function does not",
    "start": "659459",
    "end": "662100"
  },
  {
    "text": "return I mean uh like if you want to",
    "start": "662100",
    "end": "664740"
  },
  {
    "text": "define a function like a procedure It",
    "start": "664740",
    "end": "668040"
  },
  {
    "text": "generally Returns the unit type",
    "start": "668040",
    "end": "672320"
  },
  {
    "text": "uh if you want two types so enum is a",
    "start": "672360",
    "end": "674579"
  },
  {
    "text": "sum type so it's a it's a sum of the",
    "start": "674579",
    "end": "676980"
  },
  {
    "text": "variance that you define again very",
    "start": "676980",
    "end": "679320"
  },
  {
    "text": "similar to Haskell only the syntax is",
    "start": "679320",
    "end": "681120"
  },
  {
    "text": "different so this is isomorphic to",
    "start": "681120",
    "end": "682920"
  },
  {
    "text": "Boolean and it can take type parameters",
    "start": "682920",
    "end": "686399"
  },
  {
    "text": "so here option is a type Constructor",
    "start": "686399",
    "end": "688680"
  },
  {
    "text": "that takes in a type parameter and",
    "start": "688680",
    "end": "691740"
  },
  {
    "text": "creates some a or none it's again",
    "start": "691740",
    "end": "694220"
  },
  {
    "text": "equivalenting in Haskell is a maybe and",
    "start": "694220",
    "end": "697079"
  },
  {
    "text": "you can Define either in Rust in",
    "start": "697079",
    "end": "699720"
  },
  {
    "text": "standard Library it's called result",
    "start": "699720",
    "end": "701060"
  },
  {
    "text": "otherwise it's the same",
    "start": "701060",
    "end": "703140"
  },
  {
    "text": "it behaves like an either",
    "start": "703140",
    "end": "706279"
  },
  {
    "start": "705000",
    "end": "725000"
  },
  {
    "text": "and product types you can Define either",
    "start": "706279",
    "end": "709260"
  },
  {
    "text": "using a tuple which is just a comma",
    "start": "709260",
    "end": "711899"
  },
  {
    "text": "separated value of types or a struct the",
    "start": "711899",
    "end": "715260"
  },
  {
    "text": "only difference from a type point of",
    "start": "715260",
    "end": "717240"
  },
  {
    "text": "view is that instruct you can give names",
    "start": "717240",
    "end": "720240"
  },
  {
    "text": "to the constituents it's like in any",
    "start": "720240",
    "end": "723480"
  },
  {
    "text": "language",
    "start": "723480",
    "end": "725839"
  },
  {
    "start": "725000",
    "end": "743000"
  },
  {
    "text": "and let's try to define a recursive type",
    "start": "726540",
    "end": "730339"
  },
  {
    "text": "this is the basic the most basic type",
    "start": "730339",
    "end": "733019"
  },
  {
    "text": "right so you will try to create a list",
    "start": "733019",
    "end": "735899"
  },
  {
    "text": "of A's which is either nail or cons of a",
    "start": "735899",
    "end": "739200"
  },
  {
    "text": "and the list of a this is how we Define",
    "start": "739200",
    "end": "740760"
  },
  {
    "text": "it in any language",
    "start": "740760",
    "end": "743160"
  },
  {
    "start": "743000",
    "end": "810000"
  },
  {
    "text": "um but this doesn't work in Rust",
    "start": "743160",
    "end": "745680"
  },
  {
    "text": "because like I said rust primary focus",
    "start": "745680",
    "end": "748800"
  },
  {
    "text": "is performance and safety so the rust",
    "start": "748800",
    "end": "751620"
  },
  {
    "text": "compiler has to know the the size of",
    "start": "751620",
    "end": "754079"
  },
  {
    "text": "every type",
    "start": "754079",
    "end": "755100"
  },
  {
    "text": "that you define",
    "start": "755100",
    "end": "756540"
  },
  {
    "text": "so it cannot figure out the type of this",
    "start": "756540",
    "end": "758399"
  },
  {
    "text": "because it's like it has it's a",
    "start": "758399",
    "end": "760260"
  },
  {
    "text": "recursive type so it has in infinite",
    "start": "760260",
    "end": "762120"
  },
  {
    "text": "size but again the compiler tells you",
    "start": "762120",
    "end": "764579"
  },
  {
    "text": "how to fix this",
    "start": "764579",
    "end": "766139"
  },
  {
    "text": "so there are ways to",
    "start": "766139",
    "end": "768320"
  },
  {
    "text": "there are some special types that you",
    "start": "768320",
    "end": "770579"
  },
  {
    "text": "can use to say that so what we really",
    "start": "770579",
    "end": "773399"
  },
  {
    "text": "want is this list is a pointer right",
    "start": "773399",
    "end": "775440"
  },
  {
    "text": "it's like a uh something that's",
    "start": "775440",
    "end": "777600"
  },
  {
    "text": "allocated on the Heap so in Rust you",
    "start": "777600",
    "end": "779639"
  },
  {
    "text": "have to explicitly mention that using",
    "start": "779639",
    "end": "781440"
  },
  {
    "text": "one of these smart pointers",
    "start": "781440",
    "end": "783660"
  },
  {
    "text": "the Box just tells the compiler that",
    "start": "783660",
    "end": "786540"
  },
  {
    "text": "this is something that has to be",
    "start": "786540",
    "end": "787680"
  },
  {
    "text": "allocated in Heap so RC is a reference",
    "start": "787680",
    "end": "790200"
  },
  {
    "text": "counted",
    "start": "790200",
    "end": "791540"
  },
  {
    "text": "object so if you want to share and Etc",
    "start": "791540",
    "end": "794040"
  },
  {
    "text": "so or you can use it reference so these",
    "start": "794040",
    "end": "796260"
  },
  {
    "text": "are the three ways in which you can fix",
    "start": "796260",
    "end": "798240"
  },
  {
    "text": "this",
    "start": "798240",
    "end": "799680"
  },
  {
    "text": "um so the simplest one is to use a box",
    "start": "799680",
    "end": "801240"
  },
  {
    "text": "and then it behaves exactly like",
    "start": "801240",
    "end": "803880"
  },
  {
    "text": "uh",
    "start": "803880",
    "end": "805800"
  },
  {
    "text": "how you define it in Haskell",
    "start": "805800",
    "end": "809540"
  },
  {
    "text": "Okay so",
    "start": "809940",
    "end": "811800"
  },
  {
    "start": "810000",
    "end": "852000"
  },
  {
    "text": "once you have algebraic data types you",
    "start": "811800",
    "end": "814860"
  },
  {
    "text": "also it's nice to have pattern matching",
    "start": "814860",
    "end": "816600"
  },
  {
    "text": "to get things out of the types and rust",
    "start": "816600",
    "end": "819600"
  },
  {
    "text": "has like really good pattern matching",
    "start": "819600",
    "end": "821220"
  },
  {
    "text": "support things work as you would expect",
    "start": "821220",
    "end": "823260"
  },
  {
    "text": "so let's say I have a struct with a",
    "start": "823260",
    "end": "825839"
  },
  {
    "text": "person with a name and an address and I",
    "start": "825839",
    "end": "828360"
  },
  {
    "text": "have a value of that type I can pattern",
    "start": "828360",
    "end": "831420"
  },
  {
    "text": "match and get things out and in Rust the",
    "start": "831420",
    "end": "834300"
  },
  {
    "text": "pattern matching is has to be exhaustive",
    "start": "834300",
    "end": "836459"
  },
  {
    "text": "otherwise you get a compiler error",
    "start": "836459",
    "end": "838680"
  },
  {
    "text": "so again it's part of the guarantees",
    "start": "838680",
    "end": "841399"
  },
  {
    "text": "that there are no runtime exceptions",
    "start": "841399",
    "end": "843600"
  },
  {
    "text": "it's always caught by the compiler",
    "start": "843600",
    "end": "846600"
  },
  {
    "text": "and pattern matching can be complicated",
    "start": "846600",
    "end": "848339"
  },
  {
    "text": "you can have conditions ranges and all",
    "start": "848339",
    "end": "850680"
  },
  {
    "text": "that stuff",
    "start": "850680",
    "end": "853019"
  },
  {
    "start": "852000",
    "end": "869000"
  },
  {
    "text": "okay so let's look at traits so traits",
    "start": "853019",
    "end": "855899"
  },
  {
    "text": "are",
    "start": "855899",
    "end": "856860"
  },
  {
    "text": "informally a set of methods that you can",
    "start": "856860",
    "end": "859019"
  },
  {
    "text": "attach to a type",
    "start": "859019",
    "end": "860399"
  },
  {
    "text": "so it's a way to achieve ad hoc",
    "start": "860399",
    "end": "862200"
  },
  {
    "text": "polymorphism and like I said it's it's",
    "start": "862200",
    "end": "865860"
  },
  {
    "text": "similar to type classes in Haskell",
    "start": "865860",
    "end": "868860"
  },
  {
    "text": "um",
    "start": "868860",
    "end": "870000"
  },
  {
    "start": "869000",
    "end": "916000"
  },
  {
    "text": "so we saw a clone earlier so it is a",
    "start": "870000",
    "end": "873779"
  },
  {
    "text": "trade that is defined in the standard",
    "start": "873779",
    "end": "875100"
  },
  {
    "text": "Library so you define a trait by using",
    "start": "875100",
    "end": "877620"
  },
  {
    "text": "the trade keyword",
    "start": "877620",
    "end": "879199"
  },
  {
    "text": "and you can have many methods in it it",
    "start": "879199",
    "end": "882420"
  },
  {
    "text": "just functions so it has only one",
    "start": "882420",
    "end": "884940"
  },
  {
    "text": "function",
    "start": "884940",
    "end": "886019"
  },
  {
    "text": "which takes a value of the implementing",
    "start": "886019",
    "end": "888120"
  },
  {
    "text": "type",
    "start": "888120",
    "end": "888899"
  },
  {
    "text": "and returns that type so I can Implement",
    "start": "888899",
    "end": "892260"
  },
  {
    "text": "clone for any of my struct that I create",
    "start": "892260",
    "end": "896540"
  },
  {
    "text": "by using this syntax so Implement clone",
    "start": "896540",
    "end": "899579"
  },
  {
    "text": "for this again kind of similar to how",
    "start": "899579",
    "end": "901800"
  },
  {
    "text": "you do it in Haskell just the names are",
    "start": "901800",
    "end": "903420"
  },
  {
    "text": "different",
    "start": "903420",
    "end": "905160"
  },
  {
    "text": "um so yeah it just takes",
    "start": "905160",
    "end": "908320"
  },
  {
    "text": "[Music]",
    "start": "908320",
    "end": "908579"
  },
  {
    "text": "um",
    "start": "908579",
    "end": "909480"
  },
  {
    "text": "a value of that type and return itself",
    "start": "909480",
    "end": "911820"
  },
  {
    "text": "so I could have said it returns my",
    "start": "911820",
    "end": "914399"
  },
  {
    "text": "struct it's equivalent",
    "start": "914399",
    "end": "917339"
  },
  {
    "start": "916000",
    "end": "967000"
  },
  {
    "text": "um slightly more interesting example uh",
    "start": "917339",
    "end": "919920"
  },
  {
    "text": "all the operators well most of the",
    "start": "919920",
    "end": "921839"
  },
  {
    "text": "operators in Rust are implemented using",
    "start": "921839",
    "end": "924240"
  },
  {
    "text": "traits so if you want your type to",
    "start": "924240",
    "end": "926639"
  },
  {
    "text": "support some operators you can just",
    "start": "926639",
    "end": "929160"
  },
  {
    "text": "Implement a particular trait and get",
    "start": "929160",
    "end": "931139"
  },
  {
    "text": "that feature",
    "start": "931139",
    "end": "932660"
  },
  {
    "text": "so in this case I have a struct point",
    "start": "932660",
    "end": "935060"
  },
  {
    "text": "and I want to implement",
    "start": "935060",
    "end": "937980"
  },
  {
    "text": "um add operator for that",
    "start": "937980",
    "end": "940620"
  },
  {
    "text": "so again it's the same syntax now this",
    "start": "940620",
    "end": "943680"
  },
  {
    "text": "trait is",
    "start": "943680",
    "end": "945740"
  },
  {
    "text": "also has a type parameter so I need to",
    "start": "945740",
    "end": "948779"
  },
  {
    "text": "provide that and the add function just",
    "start": "948779",
    "end": "951660"
  },
  {
    "text": "adds the coordinates",
    "start": "951660",
    "end": "954839"
  },
  {
    "text": "respectively right so it's fairly simple",
    "start": "954839",
    "end": "957000"
  },
  {
    "text": "and once you have that you can just add",
    "start": "957000",
    "end": "958620"
  },
  {
    "text": "Point structs as you would do",
    "start": "958620",
    "end": "962940"
  },
  {
    "text": "so this might also look similar to",
    "start": "962940",
    "end": "965100"
  },
  {
    "text": "interfaces in Java but it's not because",
    "start": "965100",
    "end": "968579"
  },
  {
    "start": "967000",
    "end": "1015000"
  },
  {
    "text": "you can define a trait and Implement",
    "start": "968579",
    "end": "972779"
  },
  {
    "text": "that trait on an already existing",
    "start": "972779",
    "end": "975139"
  },
  {
    "text": "struct like something from standard",
    "start": "975139",
    "end": "977579"
  },
  {
    "text": "library for example so it's like more",
    "start": "977579",
    "end": "979019"
  },
  {
    "text": "close to Haskell and it has some",
    "start": "979019",
    "end": "981120"
  },
  {
    "text": "coherence rules to avoid name collision",
    "start": "981120",
    "end": "983760"
  },
  {
    "text": "and all that stuff",
    "start": "983760",
    "end": "985980"
  },
  {
    "text": "um so for example here I have a Time",
    "start": "985980",
    "end": "987480"
  },
  {
    "text": "duration trade just one function called",
    "start": "987480",
    "end": "989760"
  },
  {
    "text": "days and I can Implement that for",
    "start": "989760",
    "end": "991800"
  },
  {
    "text": "integer",
    "start": "991800",
    "end": "993000"
  },
  {
    "text": "and",
    "start": "993000",
    "end": "994920"
  },
  {
    "text": "um I just return a duration object of",
    "start": "994920",
    "end": "996959"
  },
  {
    "text": "that type and once I have that I can",
    "start": "996959",
    "end": "998820"
  },
  {
    "text": "like write code like this I can just say",
    "start": "998820",
    "end": "1001399"
  },
  {
    "text": "add three days to this date",
    "start": "1001399",
    "end": "1003800"
  },
  {
    "text": "okay so this will work as long as this",
    "start": "1003800",
    "end": "1005660"
  },
  {
    "text": "trait is in scope and this helps us to",
    "start": "1005660",
    "end": "1008540"
  },
  {
    "text": "build kind of type safe dsls uh in a",
    "start": "1008540",
    "end": "1011959"
  },
  {
    "text": "very good way",
    "start": "1011959",
    "end": "1014380"
  },
  {
    "start": "1015000",
    "end": "1043000"
  },
  {
    "text": "finally let's look at functions in Trust",
    "start": "1016220",
    "end": "1019759"
  },
  {
    "text": "um so again you define functions using",
    "start": "1019759",
    "end": "1021860"
  },
  {
    "text": "the FN keyword and this is one way to",
    "start": "1021860",
    "end": "1024740"
  },
  {
    "text": "define factorial again pattern match you",
    "start": "1024740",
    "end": "1027918"
  },
  {
    "text": "can pattern match on almost anything in",
    "start": "1027919",
    "end": "1029480"
  },
  {
    "text": "Rust so we can pattern match from the",
    "start": "1029480",
    "end": "1031640"
  },
  {
    "text": "integer with zero one and return one",
    "start": "1031640",
    "end": "1033079"
  },
  {
    "text": "otherwise because we call this uh but",
    "start": "1033079",
    "end": "1036199"
  },
  {
    "text": "yeah we would like to use some",
    "start": "1036199",
    "end": "1037579"
  },
  {
    "text": "combinators to implement this right",
    "start": "1037579",
    "end": "1040339"
  },
  {
    "text": "um so before going to that we need",
    "start": "1040339",
    "end": "1042620"
  },
  {
    "text": "closures",
    "start": "1042620",
    "end": "1044199"
  },
  {
    "start": "1043000",
    "end": "1087000"
  },
  {
    "text": "Russ has like proper support for",
    "start": "1044199",
    "end": "1046459"
  },
  {
    "text": "closures",
    "start": "1046459",
    "end": "1047480"
  },
  {
    "text": "the only difference is instead of Lambda",
    "start": "1047480",
    "end": "1049580"
  },
  {
    "text": "a",
    "start": "1049580",
    "end": "1051020"
  },
  {
    "text": "you use this vertical bars I think it",
    "start": "1051020",
    "end": "1054200"
  },
  {
    "text": "got the idea from Ruby I'm not a big fan",
    "start": "1054200",
    "end": "1056240"
  },
  {
    "text": "of this syntax but anyway apart from",
    "start": "1056240",
    "end": "1058820"
  },
  {
    "text": "syntax it works uh similar to similar as",
    "start": "1058820",
    "end": "1061640"
  },
  {
    "text": "you would expect so this is a closure",
    "start": "1061640",
    "end": "1064039"
  },
  {
    "text": "that takes one argument you can take a",
    "start": "1064039",
    "end": "1065720"
  },
  {
    "text": "closure with two arguments uh closure",
    "start": "1065720",
    "end": "1068120"
  },
  {
    "text": "also captures the environment so",
    "start": "1068120",
    "end": "1071360"
  },
  {
    "text": "um yeah there are no restrictions so it",
    "start": "1071360",
    "end": "1073580"
  },
  {
    "text": "can also change the environment but then",
    "start": "1073580",
    "end": "1075679"
  },
  {
    "text": "you have to explicitly uh mention that",
    "start": "1075679",
    "end": "1078200"
  },
  {
    "text": "disclosure is mutable and stuff like",
    "start": "1078200",
    "end": "1080360"
  },
  {
    "text": "that",
    "start": "1080360",
    "end": "1081200"
  },
  {
    "text": "and if your closure does not take any",
    "start": "1081200",
    "end": "1083059"
  },
  {
    "text": "argument you can just use this this",
    "start": "1083059",
    "end": "1084559"
  },
  {
    "text": "notation just vertical bars with no",
    "start": "1084559",
    "end": "1086600"
  },
  {
    "text": "arguments",
    "start": "1086600",
    "end": "1087860"
  },
  {
    "start": "1087000",
    "end": "1127000"
  },
  {
    "text": "so once we have that we can use fold so",
    "start": "1087860",
    "end": "1091160"
  },
  {
    "text": "so we can say",
    "start": "1091160",
    "end": "1092960"
  },
  {
    "text": "factorial is just",
    "start": "1092960",
    "end": "1095260"
  },
  {
    "text": "folding or multiplication on the range",
    "start": "1095260",
    "end": "1097820"
  },
  {
    "text": "of numbers from 1 to n right and if you",
    "start": "1097820",
    "end": "1102200"
  },
  {
    "text": "remember all the operators are defined",
    "start": "1102200",
    "end": "1104240"
  },
  {
    "text": "in trades so I could also do this",
    "start": "1104240",
    "end": "1106880"
  },
  {
    "text": "so because multiplication operation is a",
    "start": "1106880",
    "end": "1109400"
  },
  {
    "text": "trait I can directly mention the",
    "start": "1109400",
    "end": "1111500"
  },
  {
    "text": "function here which is multiplication",
    "start": "1111500",
    "end": "1114559"
  },
  {
    "text": "so it's kind of cool and",
    "start": "1114559",
    "end": "1118520"
  },
  {
    "text": "well you can also use a built-in",
    "start": "1118520",
    "end": "1120320"
  },
  {
    "text": "function like product and this is like",
    "start": "1120320",
    "end": "1122539"
  },
  {
    "text": "kind of pretty close to how you do it in",
    "start": "1122539",
    "end": "1124460"
  },
  {
    "text": "Haskell",
    "start": "1124460",
    "end": "1125840"
  },
  {
    "text": "so",
    "start": "1125840",
    "end": "1127880"
  },
  {
    "text": "let's look at higher order functions now",
    "start": "1127880",
    "end": "1130760"
  },
  {
    "text": "um",
    "start": "1130760",
    "end": "1131480"
  },
  {
    "text": "let's say you want to define a function",
    "start": "1131480",
    "end": "1132860"
  },
  {
    "text": "apply which takes a function and applies",
    "start": "1132860",
    "end": "1134840"
  },
  {
    "text": "it on an argument so the implementation",
    "start": "1134840",
    "end": "1137539"
  },
  {
    "text": "is simple like if you look at line three",
    "start": "1137539",
    "end": "1139179"
  },
  {
    "text": "it's just calling the function on that",
    "start": "1139179",
    "end": "1141500"
  },
  {
    "text": "argument the only thing we need more is",
    "start": "1141500",
    "end": "1144080"
  },
  {
    "text": "how to specify the function type so the",
    "start": "1144080",
    "end": "1146660"
  },
  {
    "text": "function type is specified using this",
    "start": "1146660",
    "end": "1148820"
  },
  {
    "text": "format",
    "start": "1148820",
    "end": "1150679"
  },
  {
    "text": "um so it's not like a to B as you do in",
    "start": "1150679",
    "end": "1153679"
  },
  {
    "text": "Haskell it's F and A to B and we'll see",
    "start": "1153679",
    "end": "1156260"
  },
  {
    "text": "why soon",
    "start": "1156260",
    "end": "1158600"
  },
  {
    "text": "um so this is a syntax interest where",
    "start": "1158600",
    "end": "1160880"
  },
  {
    "text": "you can specify the type constraints",
    "start": "1160880",
    "end": "1163220"
  },
  {
    "text": "after",
    "start": "1163220",
    "end": "1165020"
  },
  {
    "text": "um the function definition using a where",
    "start": "1165020",
    "end": "1166820"
  },
  {
    "text": "Clause you could you could also do this",
    "start": "1166820",
    "end": "1168860"
  },
  {
    "text": "when we Define the type parameters here",
    "start": "1168860",
    "end": "1171919"
  },
  {
    "text": "so I can say apply F column the same",
    "start": "1171919",
    "end": "1174140"
  },
  {
    "text": "thing there but this is a much more",
    "start": "1174140",
    "end": "1175640"
  },
  {
    "text": "cleaner way and once you do that you can",
    "start": "1175640",
    "end": "1177620"
  },
  {
    "text": "call apply with either a function or a",
    "start": "1177620",
    "end": "1179840"
  },
  {
    "text": "closure so it works",
    "start": "1179840",
    "end": "1183700"
  },
  {
    "start": "1184000",
    "end": "1226000"
  },
  {
    "text": "um so like I said",
    "start": "1185299",
    "end": "1186420"
  },
  {
    "text": "[Music]",
    "start": "1186420",
    "end": "1186799"
  },
  {
    "text": "um",
    "start": "1186799",
    "end": "1188440"
  },
  {
    "text": "the function trait the FN is a trait",
    "start": "1188440",
    "end": "1191660"
  },
  {
    "text": "it's not really a trade it's actually a",
    "start": "1191660",
    "end": "1193220"
  },
  {
    "text": "family of traits because functions can",
    "start": "1193220",
    "end": "1196039"
  },
  {
    "text": "take multiple arguments and to",
    "start": "1196039",
    "end": "1198260"
  },
  {
    "text": "complicate things further there are",
    "start": "1198260",
    "end": "1199580"
  },
  {
    "text": "there's not one but three traits in Rust",
    "start": "1199580",
    "end": "1202059"
  },
  {
    "text": "uh that stands for functions so this",
    "start": "1202059",
    "end": "1204679"
  },
  {
    "text": "makes abstracting our functions a little",
    "start": "1204679",
    "end": "1206720"
  },
  {
    "text": "tricky and rust these are like some of",
    "start": "1206720",
    "end": "1208520"
  },
  {
    "text": "the rough edges uh when you go into",
    "start": "1208520",
    "end": "1211280"
  },
  {
    "text": "functional programming but most of the",
    "start": "1211280",
    "end": "1213799"
  },
  {
    "text": "time you'll you can get away with using",
    "start": "1213799",
    "end": "1216919"
  },
  {
    "text": "FN so but if your function takes",
    "start": "1216919",
    "end": "1219919"
  },
  {
    "text": "supports mutable closures then you have",
    "start": "1219919",
    "end": "1221900"
  },
  {
    "text": "to use FN mute and other things I'm not",
    "start": "1221900",
    "end": "1223880"
  },
  {
    "text": "going to detail of this",
    "start": "1223880",
    "end": "1226720"
  },
  {
    "start": "1226000",
    "end": "1239000"
  },
  {
    "text": "um so let's see how let's define one",
    "start": "1226880",
    "end": "1229280"
  },
  {
    "text": "more function to see how the ownership",
    "start": "1229280",
    "end": "1231380"
  },
  {
    "text": "model and the other things come in play",
    "start": "1231380",
    "end": "1233480"
  },
  {
    "text": "when you try to define something in pure",
    "start": "1233480",
    "end": "1235820"
  },
  {
    "text": "functional way uh so let's try to Define",
    "start": "1235820",
    "end": "1238280"
  },
  {
    "text": "compose so compost takes two functions f",
    "start": "1238280",
    "end": "1240140"
  },
  {
    "start": "1239000",
    "end": "1270000"
  },
  {
    "text": "and g and then G after F just calls F",
    "start": "1240140",
    "end": "1243140"
  },
  {
    "text": "first and then G right so again",
    "start": "1243140",
    "end": "1244460"
  },
  {
    "text": "implementation is fairly trivial so you",
    "start": "1244460",
    "end": "1246980"
  },
  {
    "text": "take we have to return a function so it",
    "start": "1246980",
    "end": "1248960"
  },
  {
    "text": "returns a closure at this line uh it",
    "start": "1248960",
    "end": "1251660"
  },
  {
    "text": "calls F on that first and then G the",
    "start": "1251660",
    "end": "1254960"
  },
  {
    "text": "type parameters are a little more",
    "start": "1254960",
    "end": "1256039"
  },
  {
    "text": "complicated but based on what we learned",
    "start": "1256039",
    "end": "1259100"
  },
  {
    "text": "f is just a function from X to y g is a",
    "start": "1259100",
    "end": "1260960"
  },
  {
    "text": "function from y to Z and what we want to",
    "start": "1260960",
    "end": "1262940"
  },
  {
    "text": "return is a function from X to Z",
    "start": "1262940",
    "end": "1265940"
  },
  {
    "text": "but this doesn't this is what you would",
    "start": "1265940",
    "end": "1267740"
  },
  {
    "text": "normally expect but this doesn't compile",
    "start": "1267740",
    "end": "1270860"
  },
  {
    "start": "1270000",
    "end": "1291000"
  },
  {
    "text": "so if you remember some slides back rust",
    "start": "1270860",
    "end": "1273440"
  },
  {
    "text": "needs to know the size of everything so",
    "start": "1273440",
    "end": "1275780"
  },
  {
    "text": "what we are returning is a trait and",
    "start": "1275780",
    "end": "1277820"
  },
  {
    "text": "plus does not know what's the size",
    "start": "1277820",
    "end": "1279320"
  },
  {
    "text": "because the implementing type could be",
    "start": "1279320",
    "end": "1280820"
  },
  {
    "text": "different",
    "start": "1280820",
    "end": "1283059"
  },
  {
    "text": "um so if you remember one way to fix",
    "start": "1283340",
    "end": "1285440"
  },
  {
    "text": "this is to use something like a box but",
    "start": "1285440",
    "end": "1288500"
  },
  {
    "text": "because this is like a common thing that",
    "start": "1288500",
    "end": "1290840"
  },
  {
    "text": "you would do Rust has a special Syntax",
    "start": "1290840",
    "end": "1293059"
  },
  {
    "start": "1291000",
    "end": "1302000"
  },
  {
    "text": "for it so you can say what this function",
    "start": "1293059",
    "end": "1296480"
  },
  {
    "text": "returns is an implementation of this",
    "start": "1296480",
    "end": "1298159"
  },
  {
    "text": "trait not the trade itself",
    "start": "1298159",
    "end": "1301340"
  },
  {
    "text": "um this works",
    "start": "1301340",
    "end": "1303260"
  },
  {
    "start": "1302000",
    "end": "1339000"
  },
  {
    "text": "but we still have problems because of",
    "start": "1303260",
    "end": "1306200"
  },
  {
    "text": "ownership",
    "start": "1306200",
    "end": "1307940"
  },
  {
    "text": "again the compiler errors are",
    "start": "1307940",
    "end": "1310720"
  },
  {
    "text": "compiler errors will guide you to fix",
    "start": "1310720",
    "end": "1312980"
  },
  {
    "text": "this so it's not something that you have",
    "start": "1312980",
    "end": "1314539"
  },
  {
    "text": "to like keep it on your head but here uh",
    "start": "1314539",
    "end": "1317600"
  },
  {
    "text": "compose takes in f and g so compose owns",
    "start": "1317600",
    "end": "1320360"
  },
  {
    "text": "these values functions are values right",
    "start": "1320360",
    "end": "1323740"
  },
  {
    "text": "and after this line after the function",
    "start": "1323740",
    "end": "1326179"
  },
  {
    "text": "is over f and g will be dropped but we",
    "start": "1326179",
    "end": "1328700"
  },
  {
    "text": "are returning a closure which will be",
    "start": "1328700",
    "end": "1330140"
  },
  {
    "text": "called sometime later right so it's a",
    "start": "1330140",
    "end": "1332539"
  },
  {
    "text": "problem so that's why it complains so we",
    "start": "1332539",
    "end": "1335059"
  },
  {
    "text": "need to move the ownership of this",
    "start": "1335059",
    "end": "1336679"
  },
  {
    "text": "function to the closure which can be",
    "start": "1336679",
    "end": "1340039"
  },
  {
    "start": "1339000",
    "end": "1354000"
  },
  {
    "text": "done using the move keyword so these are",
    "start": "1340039",
    "end": "1342500"
  },
  {
    "text": "some of the things that you need to take",
    "start": "1342500",
    "end": "1344179"
  },
  {
    "text": "care when you are program I mean when",
    "start": "1344179",
    "end": "1345620"
  },
  {
    "text": "you're doing functional programming",
    "start": "1345620",
    "end": "1346580"
  },
  {
    "text": "trust so but it's fine because like it's",
    "start": "1346580",
    "end": "1349340"
  },
  {
    "text": "both good and bad it's fine because the",
    "start": "1349340",
    "end": "1351260"
  },
  {
    "text": "compiler guides you to actually fix this",
    "start": "1351260",
    "end": "1354700"
  },
  {
    "start": "1354000",
    "end": "1365000"
  },
  {
    "text": "and this is generally a problem when you",
    "start": "1354700",
    "end": "1357200"
  },
  {
    "text": "define things but when you use it it's",
    "start": "1357200",
    "end": "1358880"
  },
  {
    "text": "much cleaner so this is how do you use a",
    "start": "1358880",
    "end": "1361520"
  },
  {
    "text": "iterator for example it's like it's",
    "start": "1361520",
    "end": "1363980"
  },
  {
    "text": "well I mean it looks nice",
    "start": "1363980",
    "end": "1366080"
  },
  {
    "start": "1365000",
    "end": "1403000"
  },
  {
    "text": "let's see one final example",
    "start": "1366080",
    "end": "1368539"
  },
  {
    "text": "a quick sort so this is a functional",
    "start": "1368539",
    "end": "1371120"
  },
  {
    "text": "implementation of quick sort it takes in",
    "start": "1371120",
    "end": "1373280"
  },
  {
    "text": "a list of things and the list has to be",
    "start": "1373280",
    "end": "1375799"
  },
  {
    "text": "orderable so again it's a type",
    "start": "1375799",
    "end": "1378140"
  },
  {
    "text": "constraint",
    "start": "1378140",
    "end": "1379539"
  },
  {
    "text": "we partition based on some pivot and",
    "start": "1379539",
    "end": "1382700"
  },
  {
    "text": "then quick sort uh both halves and then",
    "start": "1382700",
    "end": "1385880"
  },
  {
    "text": "merge it right this is almost similar to",
    "start": "1385880",
    "end": "1388100"
  },
  {
    "text": "how we do it in Haskell except that Russ",
    "start": "1388100",
    "end": "1390860"
  },
  {
    "text": "does not have list comprehension so it's",
    "start": "1390860",
    "end": "1392840"
  },
  {
    "text": "a few more lines longer otherwise it's",
    "start": "1392840",
    "end": "1395900"
  },
  {
    "text": "the same",
    "start": "1395900",
    "end": "1397039"
  },
  {
    "text": "uh and again because it's because it's",
    "start": "1397039",
    "end": "1399440"
  },
  {
    "text": "purely functional if you want to make it",
    "start": "1399440",
    "end": "1401120"
  },
  {
    "text": "parallel you just need to change one",
    "start": "1401120",
    "end": "1402980"
  },
  {
    "text": "line",
    "start": "1402980",
    "end": "1405080"
  },
  {
    "start": "1403000",
    "end": "1423000"
  },
  {
    "text": "which is when we sort the halves right",
    "start": "1405080",
    "end": "1408020"
  },
  {
    "text": "so you can say sort this house in",
    "start": "1408020",
    "end": "1409760"
  },
  {
    "text": "parallel and everything just works",
    "start": "1409760",
    "end": "1413679"
  },
  {
    "text": "yeah",
    "start": "1414020",
    "end": "1416500"
  },
  {
    "text": "so",
    "start": "1416600",
    "end": "1417919"
  },
  {
    "text": "to sum up",
    "start": "1417919",
    "end": "1419539"
  },
  {
    "text": "is just a good functional programming",
    "start": "1419539",
    "end": "1421520"
  },
  {
    "text": "language",
    "start": "1421520",
    "end": "1423100"
  },
  {
    "start": "1423000",
    "end": "1436000"
  },
  {
    "text": "so it has save functions right you don't",
    "start": "1423100",
    "end": "1426380"
  },
  {
    "text": "get any runtime errors or runtime",
    "start": "1426380",
    "end": "1428419"
  },
  {
    "text": "exceptions or any such things so pattern",
    "start": "1428419",
    "end": "1430460"
  },
  {
    "text": "matching has to be exhaustive so it",
    "start": "1430460",
    "end": "1432380"
  },
  {
    "text": "makes sure that most of the errors are",
    "start": "1432380",
    "end": "1434900"
  },
  {
    "text": "caught at compile time which is good it",
    "start": "1434900",
    "end": "1436580"
  },
  {
    "text": "has algebraic data types it prefers",
    "start": "1436580",
    "end": "1439159"
  },
  {
    "text": "immutable",
    "start": "1439159",
    "end": "1440659"
  },
  {
    "text": "ah values though you can do mutable",
    "start": "1440659",
    "end": "1443600"
  },
  {
    "text": "programming mutable things",
    "start": "1443600",
    "end": "1446600"
  },
  {
    "start": "1445000",
    "end": "1457000"
  },
  {
    "text": "um higher order functions are there but",
    "start": "1446600",
    "end": "1448220"
  },
  {
    "text": "again you have to always think about",
    "start": "1448220",
    "end": "1449480"
  },
  {
    "text": "ownership and lifetimes and stuff",
    "start": "1449480",
    "end": "1451700"
  },
  {
    "text": "lifetimes I haven't talked about so",
    "start": "1451700",
    "end": "1454280"
  },
  {
    "text": "that's another thing that you have to",
    "start": "1454280",
    "end": "1455780"
  },
  {
    "text": "think about",
    "start": "1455780",
    "end": "1457460"
  },
  {
    "start": "1457000",
    "end": "1498000"
  },
  {
    "text": "um and advanced functional abstractions",
    "start": "1457460",
    "end": "1460460"
  },
  {
    "text": "like if you want to define a functor or",
    "start": "1460460",
    "end": "1463280"
  },
  {
    "text": "a monad trait it's a it's currently",
    "start": "1463280",
    "end": "1466400"
  },
  {
    "text": "impossible in Rust because trust does",
    "start": "1466400",
    "end": "1468140"
  },
  {
    "text": "not have higher kind of types there is",
    "start": "1468140",
    "end": "1470659"
  },
  {
    "text": "an RFC to introduce a feature called",
    "start": "1470659",
    "end": "1473299"
  },
  {
    "text": "Associated type Constructor which has",
    "start": "1473299",
    "end": "1475580"
  },
  {
    "text": "the same power but it's it's a different",
    "start": "1475580",
    "end": "1477559"
  },
  {
    "text": "mechanism so you have to understand that",
    "start": "1477559",
    "end": "1479720"
  },
  {
    "text": "mechanism if you want to like build",
    "start": "1479720",
    "end": "1481700"
  },
  {
    "text": "higher order abstractions so most of the",
    "start": "1481700",
    "end": "1484280"
  },
  {
    "text": "p i mean libraries currently get around",
    "start": "1484280",
    "end": "1487100"
  },
  {
    "text": "this problem because rust has macros so",
    "start": "1487100",
    "end": "1489620"
  },
  {
    "text": "using macros you can Define list",
    "start": "1489620",
    "end": "1491299"
  },
  {
    "text": "comprehensions and everything else but",
    "start": "1491299",
    "end": "1493220"
  },
  {
    "text": "it's not yeah",
    "start": "1493220",
    "end": "1495799"
  },
  {
    "text": "it's already nice",
    "start": "1495799",
    "end": "1498320"
  },
  {
    "start": "1498000",
    "end": "1514000"
  },
  {
    "text": "and rust is not a functional language so",
    "start": "1498320",
    "end": "1500960"
  },
  {
    "text": "functions are not pure so you have to",
    "start": "1500960",
    "end": "1503000"
  },
  {
    "text": "make sure as a programmer to follow some",
    "start": "1503000",
    "end": "1504799"
  },
  {
    "text": "convention and have a functional core",
    "start": "1504799",
    "end": "1507020"
  },
  {
    "text": "and imperative shell model right so make",
    "start": "1507020",
    "end": "1510020"
  },
  {
    "text": "sure that functions are pure",
    "start": "1510020",
    "end": "1513940"
  },
  {
    "start": "1514000",
    "end": "1532000"
  },
  {
    "text": "um so should I use rust I don't know so",
    "start": "1515059",
    "end": "1518179"
  },
  {
    "text": "there are a lot of factors that you need",
    "start": "1518179",
    "end": "1520100"
  },
  {
    "text": "to consider right so I mean in some",
    "start": "1520100",
    "end": "1521720"
  },
  {
    "text": "conferences people say I mean this is",
    "start": "1521720",
    "end": "1523280"
  },
  {
    "text": "the",
    "start": "1523280",
    "end": "1524059"
  },
  {
    "text": "best thing you know you should start",
    "start": "1524059",
    "end": "1525440"
  },
  {
    "text": "using it from tomorrow but there are",
    "start": "1525440",
    "end": "1528140"
  },
  {
    "text": "like every problem is different so it",
    "start": "1528140",
    "end": "1529880"
  },
  {
    "text": "totally depends on you so one framework",
    "start": "1529880",
    "end": "1532580"
  },
  {
    "start": "1532000",
    "end": "1569000"
  },
  {
    "text": "yeah one thing you need to consider is",
    "start": "1532580",
    "end": "1534679"
  },
  {
    "text": "the domain so rust is not rust is a",
    "start": "1534679",
    "end": "1537440"
  },
  {
    "text": "mature language but it does not have",
    "start": "1537440",
    "end": "1539000"
  },
  {
    "text": "libraries like mature libraries on every",
    "start": "1539000",
    "end": "1540919"
  },
  {
    "text": "domain so these are some domains that",
    "start": "1540919",
    "end": "1543020"
  },
  {
    "text": "the rust language officially recommends",
    "start": "1543020",
    "end": "1545419"
  },
  {
    "text": "where it is strong so there is already",
    "start": "1545419",
    "end": "1547039"
  },
  {
    "text": "like a lot of networking libraries",
    "start": "1547039",
    "end": "1548720"
  },
  {
    "text": "especially in the service mesh area",
    "start": "1548720",
    "end": "1550640"
  },
  {
    "text": "that's written in Rust and in production",
    "start": "1550640",
    "end": "1552380"
  },
  {
    "text": "and webassembly is another idea like",
    "start": "1552380",
    "end": "1555380"
  },
  {
    "text": "command line applications are embedded",
    "start": "1555380",
    "end": "1557179"
  },
  {
    "text": "is like Obviously good areas for rust",
    "start": "1557179",
    "end": "1560000"
  },
  {
    "text": "but for web application development",
    "start": "1560000",
    "end": "1562580"
  },
  {
    "text": "there are some libraries but they are",
    "start": "1562580",
    "end": "1564140"
  },
  {
    "text": "not mature yet so you need to make sure",
    "start": "1564140",
    "end": "1566000"
  },
  {
    "text": "you have mature libraries on your domain",
    "start": "1566000",
    "end": "1571100"
  },
  {
    "start": "1569000",
    "end": "1589000"
  },
  {
    "text": "and like you need to consider all the",
    "start": "1571100",
    "end": "1573980"
  },
  {
    "text": "other things so these are some of the",
    "start": "1573980",
    "end": "1576080"
  },
  {
    "text": "factors that I mentioned but you you may",
    "start": "1576080",
    "end": "1579020"
  },
  {
    "text": "have to consider more like functional",
    "start": "1579020",
    "end": "1580400"
  },
  {
    "text": "programming ease of learning community",
    "start": "1580400",
    "end": "1582919"
  },
  {
    "text": "performance and all that so this is how",
    "start": "1582919",
    "end": "1585440"
  },
  {
    "text": "I would map Java or C plus plus there",
    "start": "1585440",
    "end": "1588200"
  },
  {
    "text": "and if I look at rust a rust is better",
    "start": "1588200",
    "end": "1591200"
  },
  {
    "start": "1589000",
    "end": "1610000"
  },
  {
    "text": "in function programming and performance",
    "start": "1591200",
    "end": "1593299"
  },
  {
    "text": "in Java so if you're coming from one of",
    "start": "1593299",
    "end": "1595220"
  },
  {
    "text": "those languages it's an easier choice I",
    "start": "1595220",
    "end": "1597200"
  },
  {
    "text": "think except for the maturity aspect so",
    "start": "1597200",
    "end": "1599840"
  },
  {
    "text": "you need to be careful about whether it",
    "start": "1599840",
    "end": "1602120"
  },
  {
    "text": "has the mature libraries and all that",
    "start": "1602120",
    "end": "1605000"
  },
  {
    "text": "stuff but otherwise it's kind of an easy",
    "start": "1605000",
    "end": "1607700"
  },
  {
    "text": "choice in my opinion but if you're",
    "start": "1607700",
    "end": "1610039"
  },
  {
    "start": "1610000",
    "end": "1640000"
  },
  {
    "text": "coming from Haskell it's definitely not",
    "start": "1610039",
    "end": "1612559"
  },
  {
    "text": "on par with Haskell on functional",
    "start": "1612559",
    "end": "1614600"
  },
  {
    "text": "programming so if you're already doing",
    "start": "1614600",
    "end": "1616220"
  },
  {
    "text": "Haskell and function programming there's",
    "start": "1616220",
    "end": "1619400"
  },
  {
    "text": "probably no reason to use trust except",
    "start": "1619400",
    "end": "1621620"
  },
  {
    "text": "if you want to write some part of your",
    "start": "1621620",
    "end": "1624020"
  },
  {
    "text": "program to improve performance So",
    "start": "1624020",
    "end": "1625880"
  },
  {
    "text": "currently you would use CC plus plus",
    "start": "1625880",
    "end": "1627679"
  },
  {
    "text": "which is not safe if you're using rust",
    "start": "1627679",
    "end": "1629900"
  },
  {
    "text": "you can almost follow the same Paradigm",
    "start": "1629900",
    "end": "1632299"
  },
  {
    "text": "as you're doing in Haskell and it's safe",
    "start": "1632299",
    "end": "1634340"
  },
  {
    "text": "so that's probably the only reason you",
    "start": "1634340",
    "end": "1636860"
  },
  {
    "text": "would you look at rust",
    "start": "1636860",
    "end": "1640840"
  },
  {
    "start": "1640000",
    "end": "1669000"
  },
  {
    "text": "um",
    "start": "1640940",
    "end": "1641480"
  },
  {
    "text": "so I just wanted to leave you with this",
    "start": "1641480",
    "end": "1644000"
  },
  {
    "text": "thought that it's good to learn new",
    "start": "1644000",
    "end": "1646760"
  },
  {
    "text": "tools because the tools shapes our",
    "start": "1646760",
    "end": "1649039"
  },
  {
    "text": "thinking and I think rust has some good",
    "start": "1649039",
    "end": "1651320"
  },
  {
    "text": "ideas it makes some of the things",
    "start": "1651320",
    "end": "1653179"
  },
  {
    "text": "explicit that we as programmers were",
    "start": "1653179",
    "end": "1655460"
  },
  {
    "text": "kind of ignoring which is actually a",
    "start": "1655460",
    "end": "1657440"
  },
  {
    "text": "good thing for us uh to learn",
    "start": "1657440",
    "end": "1660559"
  },
  {
    "text": "that's all thank you",
    "start": "1660559",
    "end": "1662820"
  },
  {
    "text": "[Applause]",
    "start": "1662820",
    "end": "1670960"
  }
]