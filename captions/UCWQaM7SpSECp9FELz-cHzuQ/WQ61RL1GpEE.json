[
  {
    "start": "0",
    "end": "46000"
  },
  {
    "text": "redis is an open source in-memory key",
    "start": "60",
    "end": "2940"
  },
  {
    "text": "value database it also happens to be",
    "start": "2940",
    "end": "5339"
  },
  {
    "text": "blazingly fast in my current role we",
    "start": "5339",
    "end": "8280"
  },
  {
    "text": "have a redis cluster that caches HTTP",
    "start": "8280",
    "end": "10380"
  },
  {
    "text": "responses from a third-party dependency",
    "start": "10380",
    "end": "13259"
  },
  {
    "text": "this cluster at peak times handles",
    "start": "13259",
    "end": "15360"
  },
  {
    "text": "around 2 million requests a minute which",
    "start": "15360",
    "end": "18060"
  },
  {
    "text": "is pretty impressive this typically has",
    "start": "18060",
    "end": "20520"
  },
  {
    "text": "been one of the more common use cases of",
    "start": "20520",
    "end": "22380"
  },
  {
    "text": "redis that I've come across speeding up",
    "start": "22380",
    "end": "24480"
  },
  {
    "text": "i o based operations by adding a caching",
    "start": "24480",
    "end": "26640"
  },
  {
    "text": "layer in the application stack but redis",
    "start": "26640",
    "end": "29400"
  },
  {
    "text": "can be used for so much more than this",
    "start": "29400",
    "end": "31260"
  },
  {
    "text": "single use case in fact I'd go on to see",
    "start": "31260",
    "end": "33960"
  },
  {
    "text": "that using redis only in this capacity",
    "start": "33960",
    "end": "35940"
  },
  {
    "text": "is a waste of its talents so in this",
    "start": "35940",
    "end": "39120"
  },
  {
    "text": "video I decided I wanted to look at some",
    "start": "39120",
    "end": "41100"
  },
  {
    "text": "misconceptions about redis and how we",
    "start": "41100",
    "end": "43320"
  },
  {
    "text": "can replicate database functionality",
    "start": "43320",
    "end": "45000"
  },
  {
    "text": "with it the first question I want to",
    "start": "45000",
    "end": "47640"
  },
  {
    "start": "46000",
    "end": "83000"
  },
  {
    "text": "answer is how did we get here why has",
    "start": "47640",
    "end": "50100"
  },
  {
    "text": "redis so easily been relegated to the",
    "start": "50100",
    "end": "52140"
  },
  {
    "text": "caching layer instead of being the",
    "start": "52140",
    "end": "54000"
  },
  {
    "text": "actual database itself and why does my",
    "start": "54000",
    "end": "56879"
  },
  {
    "text": "co-worker Flinch whenever I mention",
    "start": "56879",
    "end": "58379"
  },
  {
    "text": "using redis as the primary database well",
    "start": "58379",
    "end": "61500"
  },
  {
    "text": "I think there's two common concerns when",
    "start": "61500",
    "end": "63539"
  },
  {
    "text": "it comes to using redis as a primary",
    "start": "63539",
    "end": "65640"
  },
  {
    "text": "data store the first is because redis is",
    "start": "65640",
    "end": "68760"
  },
  {
    "text": "an in-memory database which implies that",
    "start": "68760",
    "end": "70799"
  },
  {
    "text": "the data must be ephemeral the second is",
    "start": "70799",
    "end": "73680"
  },
  {
    "text": "that because it's a key Value Store well",
    "start": "73680",
    "end": "76320"
  },
  {
    "text": "it cannot handle complex data structures",
    "start": "76320",
    "end": "78420"
  },
  {
    "text": "or queries",
    "start": "78420",
    "end": "79860"
  },
  {
    "text": "let's take a look at each of these",
    "start": "79860",
    "end": "81659"
  },
  {
    "text": "concerns",
    "start": "81659",
    "end": "82920"
  },
  {
    "text": "the reason redis is incredibly fast is",
    "start": "82920",
    "end": "85560"
  },
  {
    "start": "83000",
    "end": "254000"
  },
  {
    "text": "because it stores its data in memory",
    "start": "85560",
    "end": "87360"
  },
  {
    "text": "rather than on disk now if you know how",
    "start": "87360",
    "end": "90240"
  },
  {
    "text": "computers work you're probably aware of",
    "start": "90240",
    "end": "92400"
  },
  {
    "text": "why this may be a bad idea to use redis",
    "start": "92400",
    "end": "94680"
  },
  {
    "text": "as a primary data store if the instance",
    "start": "94680",
    "end": "97200"
  },
  {
    "text": "is destroyed the memory is wiped and the",
    "start": "97200",
    "end": "99780"
  },
  {
    "text": "data lost",
    "start": "99780",
    "end": "100860"
  },
  {
    "text": "or is it",
    "start": "100860",
    "end": "102240"
  },
  {
    "text": "let's actually test this out",
    "start": "102240",
    "end": "104579"
  },
  {
    "text": "here I have a single redis node set up",
    "start": "104579",
    "end": "106860"
  },
  {
    "text": "on my home lab kubernetes cluster yes I",
    "start": "106860",
    "end": "109439"
  },
  {
    "text": "finally have a dedicated home lab now",
    "start": "109439",
    "end": "111180"
  },
  {
    "text": "let me know if you're interested in my",
    "start": "111180",
    "end": "113040"
  },
  {
    "text": "setup and I'll happily do a video on it",
    "start": "113040",
    "end": "114960"
  },
  {
    "text": "maybe on another Channel let's go ahead",
    "start": "114960",
    "end": "117540"
  },
  {
    "text": "and connect to it I'm using kubernetes",
    "start": "117540",
    "end": "119640"
  },
  {
    "text": "for this cluster so it's easy enough to",
    "start": "119640",
    "end": "121560"
  },
  {
    "text": "port forward and connect in okay so",
    "start": "121560",
    "end": "124500"
  },
  {
    "text": "we're inside of our redis instance if I",
    "start": "124500",
    "end": "126780"
  },
  {
    "text": "run the keys command you can see that",
    "start": "126780",
    "end": "128399"
  },
  {
    "text": "it's completely empty let's add a new",
    "start": "128399",
    "end": "130560"
  },
  {
    "text": "value using the set command here we're",
    "start": "130560",
    "end": "133020"
  },
  {
    "text": "going to set the key of power level and",
    "start": "133020",
    "end": "135000"
  },
  {
    "text": "the value to be just over 9000. if we",
    "start": "135000",
    "end": "137879"
  },
  {
    "text": "run the keys command again we can see",
    "start": "137879",
    "end": "139379"
  },
  {
    "text": "the power level key now exists and we",
    "start": "139379",
    "end": "141599"
  },
  {
    "text": "can retrieve the value using the get",
    "start": "141599",
    "end": "143220"
  },
  {
    "text": "command now it's time to apply some",
    "start": "143220",
    "end": "145980"
  },
  {
    "text": "chaos engineering but let's go ahead and",
    "start": "145980",
    "end": "148260"
  },
  {
    "text": "delete our redis instance",
    "start": "148260",
    "end": "150360"
  },
  {
    "text": "after a short while a new redis instance",
    "start": "150360",
    "end": "152879"
  },
  {
    "text": "comes back to life due to the power of",
    "start": "152879",
    "end": "155280"
  },
  {
    "text": "kubernetes",
    "start": "155280",
    "end": "156480"
  },
  {
    "text": "if I go ahead and connect to this new",
    "start": "156480",
    "end": "157980"
  },
  {
    "text": "redis instance and run a get command",
    "start": "157980",
    "end": "160319"
  },
  {
    "text": "against the power level key we should",
    "start": "160319",
    "end": "162420"
  },
  {
    "text": "receive a nil back however that's not",
    "start": "162420",
    "end": "165239"
  },
  {
    "text": "the case",
    "start": "165239",
    "end": "166319"
  },
  {
    "text": "so what gives how does this data still",
    "start": "166319",
    "end": "168660"
  },
  {
    "text": "exist even after restarting the redis",
    "start": "168660",
    "end": "170819"
  },
  {
    "text": "instance well it's because redis",
    "start": "170819",
    "end": "172980"
  },
  {
    "text": "actually has persistence built in in",
    "start": "172980",
    "end": "175500"
  },
  {
    "text": "fact there's actually two different",
    "start": "175500",
    "end": "176819"
  },
  {
    "text": "types of persistence that redis uses the",
    "start": "176819",
    "end": "179700"
  },
  {
    "text": "first method is snapshotting which is",
    "start": "179700",
    "end": "181739"
  },
  {
    "text": "known as rdb this is a point in time",
    "start": "181739",
    "end": "184920"
  },
  {
    "text": "snapshot of the data set at specific",
    "start": "184920",
    "end": "186900"
  },
  {
    "text": "intervals similar to the snapshot",
    "start": "186900",
    "end": "189120"
  },
  {
    "text": "feature found in other databases whilst",
    "start": "189120",
    "end": "191879"
  },
  {
    "text": "this method is good if you need to",
    "start": "191879",
    "end": "193140"
  },
  {
    "text": "restore your data to a point in time",
    "start": "193140",
    "end": "194580"
  },
  {
    "text": "it's not what is actually bringing our",
    "start": "194580",
    "end": "196560"
  },
  {
    "text": "redis instance back to the same state as",
    "start": "196560",
    "end": "198720"
  },
  {
    "text": "before we crashed it that behavior is",
    "start": "198720",
    "end": "201300"
  },
  {
    "text": "handled by the second persistence method",
    "start": "201300",
    "end": "203220"
  },
  {
    "text": "called aof which stands for append only",
    "start": "203220",
    "end": "206400"
  },
  {
    "text": "file when configured to use an aof redis",
    "start": "206400",
    "end": "209879"
  },
  {
    "text": "will write an entry to a log file for",
    "start": "209879",
    "end": "211980"
  },
  {
    "text": "every write operation the redder server",
    "start": "211980",
    "end": "213959"
  },
  {
    "text": "receives",
    "start": "213959",
    "end": "215099"
  },
  {
    "text": "during a restart these operations can",
    "start": "215099",
    "end": "217500"
  },
  {
    "text": "then be replayed reconstructing the",
    "start": "217500",
    "end": "219420"
  },
  {
    "text": "original database",
    "start": "219420",
    "end": "220920"
  },
  {
    "text": "this is actually similar to how postgres",
    "start": "220920",
    "end": "223260"
  },
  {
    "text": "stores data using Wilds or right ahead",
    "start": "223260",
    "end": "226019"
  },
  {
    "text": "logs in fact the redis documentation",
    "start": "226019",
    "end": "228239"
  },
  {
    "text": "claims that both the aof and rdb",
    "start": "228239",
    "end": "230940"
  },
  {
    "text": "persistence will give you a degree of",
    "start": "230940",
    "end": "232739"
  },
  {
    "text": "data safety comparable to what postgres",
    "start": "232739",
    "end": "234599"
  },
  {
    "text": "can provide now that's a bold claim but",
    "start": "234599",
    "end": "237599"
  },
  {
    "text": "I'm inclined to believe it certainly",
    "start": "237599",
    "end": "239700"
  },
  {
    "text": "based on the Real World experience of",
    "start": "239700",
    "end": "241620"
  },
  {
    "text": "using redis at scale okay so data",
    "start": "241620",
    "end": "244440"
  },
  {
    "text": "persistence in redis can be set up to be",
    "start": "244440",
    "end": "246360"
  },
  {
    "text": "as comparable to one of the safest",
    "start": "246360",
    "end": "248580"
  },
  {
    "text": "databases out there",
    "start": "248580",
    "end": "250140"
  },
  {
    "text": "but what about the second reason to not",
    "start": "250140",
    "end": "252299"
  },
  {
    "text": "use it as a primary database the lack of",
    "start": "252299",
    "end": "255239"
  },
  {
    "start": "254000",
    "end": "302000"
  },
  {
    "text": "complex data structures",
    "start": "255239",
    "end": "257340"
  },
  {
    "text": "in a typical relational database we're",
    "start": "257340",
    "end": "260040"
  },
  {
    "text": "used to abstractions such as tables rows",
    "start": "260040",
    "end": "262620"
  },
  {
    "text": "and columns in addition to these we have",
    "start": "262620",
    "end": "265199"
  },
  {
    "text": "indexes partitions primary Keys foreign",
    "start": "265199",
    "end": "268500"
  },
  {
    "text": "keys and many others all of these",
    "start": "268500",
    "end": "270840"
  },
  {
    "text": "Concepts allow us to query for data and",
    "start": "270840",
    "end": "273000"
  },
  {
    "text": "perform complex operations when it comes",
    "start": "273000",
    "end": "275639"
  },
  {
    "text": "to redis it's much more simple but that",
    "start": "275639",
    "end": "278160"
  },
  {
    "text": "doesn't mean it's any less powerful",
    "start": "278160",
    "end": "279860"
  },
  {
    "text": "redis is much closer to the abstractions",
    "start": "279860",
    "end": "282720"
  },
  {
    "text": "found in traditional computer science",
    "start": "282720",
    "end": "284520"
  },
  {
    "text": "such as arrays hash Maps sets and many",
    "start": "284520",
    "end": "288240"
  },
  {
    "text": "others these data structures are used by",
    "start": "288240",
    "end": "290940"
  },
  {
    "text": "traditional databases to create the",
    "start": "290940",
    "end": "292979"
  },
  {
    "text": "actual abstractions we know and use and",
    "start": "292979",
    "end": "295320"
  },
  {
    "text": "therefore we should be able to recreate",
    "start": "295320",
    "end": "296940"
  },
  {
    "text": "them using redis so to do that let's go",
    "start": "296940",
    "end": "299940"
  },
  {
    "text": "ahead and actually look at some of them",
    "start": "299940",
    "end": "301860"
  },
  {
    "text": "the first thing we're going to do is",
    "start": "301860",
    "end": "303300"
  },
  {
    "start": "302000",
    "end": "449000"
  },
  {
    "text": "replicate a simple user table which",
    "start": "303300",
    "end": "305759"
  },
  {
    "text": "contains a user ID and an email address",
    "start": "305759",
    "end": "308040"
  },
  {
    "text": "in SQL the table would look something",
    "start": "308040",
    "end": "310440"
  },
  {
    "text": "like this we can easily recreate this in",
    "start": "310440",
    "end": "313199"
  },
  {
    "text": "redis using the basic operations of set",
    "start": "313199",
    "end": "315780"
  },
  {
    "text": "which allows us to store a record as a",
    "start": "315780",
    "end": "318240"
  },
  {
    "text": "key value pair so we could just set the",
    "start": "318240",
    "end": "320639"
  },
  {
    "text": "user ID as the key followed by the email",
    "start": "320639",
    "end": "322860"
  },
  {
    "text": "as the value that would get us what",
    "start": "322860",
    "end": "325259"
  },
  {
    "text": "we're looking for but there is a problem",
    "start": "325259",
    "end": "327000"
  },
  {
    "text": "with this implementation as redis does",
    "start": "327000",
    "end": "329100"
  },
  {
    "text": "not have any logical groupings or even",
    "start": "329100",
    "end": "330840"
  },
  {
    "text": "schemas then we lose the information",
    "start": "330840",
    "end": "332940"
  },
  {
    "text": "about what we're storing when we store",
    "start": "332940",
    "end": "334680"
  },
  {
    "text": "the ID as a key for example this uuid",
    "start": "334680",
    "end": "338160"
  },
  {
    "text": "could be related to a user but it could",
    "start": "338160",
    "end": "340440"
  },
  {
    "text": "also be related to a product or an order",
    "start": "340440",
    "end": "343139"
  },
  {
    "text": "there's no way to tell without actually",
    "start": "343139",
    "end": "345120"
  },
  {
    "text": "looking at the data itself and even then",
    "start": "345120",
    "end": "347880"
  },
  {
    "text": "there's still a chance of losing the",
    "start": "347880",
    "end": "349740"
  },
  {
    "text": "information about what you're storing",
    "start": "349740",
    "end": "351300"
  },
  {
    "text": "therefore it's a good idea to specify",
    "start": "351300",
    "end": "353639"
  },
  {
    "text": "the data type in the actual key sort of",
    "start": "353639",
    "end": "356220"
  },
  {
    "text": "like a namespace the idiomatic way in",
    "start": "356220",
    "end": "358560"
  },
  {
    "text": "redis is to use a colon to separate the",
    "start": "358560",
    "end": "360720"
  },
  {
    "text": "namespace from the I identifier so in",
    "start": "360720",
    "end": "363000"
  },
  {
    "text": "our case it would be user colon ID this",
    "start": "363000",
    "end": "366720"
  },
  {
    "text": "way we provide some additional context",
    "start": "366720",
    "end": "368340"
  },
  {
    "text": "about what the data type is that we're",
    "start": "368340",
    "end": "370199"
  },
  {
    "text": "storing but it also has some other",
    "start": "370199",
    "end": "372240"
  },
  {
    "text": "benefits let me explain with a typical",
    "start": "372240",
    "end": "374759"
  },
  {
    "text": "scenario you'd find within a web app",
    "start": "374759",
    "end": "376560"
  },
  {
    "text": "user authentication in this case we want",
    "start": "376560",
    "end": "379500"
  },
  {
    "text": "to perform authentication with a user's",
    "start": "379500",
    "end": "381539"
  },
  {
    "text": "email and password currently we can",
    "start": "381539",
    "end": "383880"
  },
  {
    "text": "obtain a user's email address with their",
    "start": "383880",
    "end": "385800"
  },
  {
    "text": "ID but that's no good in this case we",
    "start": "385800",
    "end": "388800"
  },
  {
    "text": "actually want the inverse which is",
    "start": "388800",
    "end": "390419"
  },
  {
    "text": "obtaining a user's ID given their email",
    "start": "390419",
    "end": "392699"
  },
  {
    "text": "address if it exists in the database",
    "start": "392699",
    "end": "395280"
  },
  {
    "text": "so how can we do that in our current",
    "start": "395280",
    "end": "397500"
  },
  {
    "text": "database setup well the naive approach",
    "start": "397500",
    "end": "399780"
  },
  {
    "text": "is to search through all of the user",
    "start": "399780",
    "end": "401280"
  },
  {
    "text": "entries by using the keys command for",
    "start": "401280",
    "end": "403620"
  },
  {
    "text": "everything in the user namespace we",
    "start": "403620",
    "end": "405660"
  },
  {
    "text": "could then iterate through every entry",
    "start": "405660",
    "end": "407340"
  },
  {
    "text": "and check if the value matches our email",
    "start": "407340",
    "end": "409460"
  },
  {
    "text": "if one does then we have the user ID",
    "start": "409460",
    "end": "412979"
  },
  {
    "text": "by the way in a production system don't",
    "start": "412979",
    "end": "415259"
  },
  {
    "text": "use the keys command it can and will",
    "start": "415259",
    "end": "418080"
  },
  {
    "text": "lock up redis which will block any other",
    "start": "418080",
    "end": "420240"
  },
  {
    "text": "queries from completing instead you'd",
    "start": "420240",
    "end": "423000"
  },
  {
    "text": "use the scan command which is a little",
    "start": "423000",
    "end": "424860"
  },
  {
    "text": "bit more complex but it allows you to",
    "start": "424860",
    "end": "426600"
  },
  {
    "text": "iterate through cursors for testing",
    "start": "426600",
    "end": "428580"
  },
  {
    "text": "within this video though the keys",
    "start": "428580",
    "end": "430380"
  },
  {
    "text": "command is absolutely fine this method",
    "start": "430380",
    "end": "433020"
  },
  {
    "text": "of comparing each record's value in the",
    "start": "433020",
    "end": "434940"
  },
  {
    "text": "username space against our input is",
    "start": "434940",
    "end": "436919"
  },
  {
    "text": "called a sequential scan this works",
    "start": "436919",
    "end": "439440"
  },
  {
    "text": "similar to how a SQL database would",
    "start": "439440",
    "end": "441300"
  },
  {
    "text": "perform the same operation it's not the",
    "start": "441300",
    "end": "443880"
  },
  {
    "text": "most optimal method however as it can",
    "start": "443880",
    "end": "445979"
  },
  {
    "text": "take a long time to scan tables that",
    "start": "445979",
    "end": "447539"
  },
  {
    "text": "have a large number of rows to improve",
    "start": "447539",
    "end": "450479"
  },
  {
    "start": "449000",
    "end": "497000"
  },
  {
    "text": "performance you would use a database",
    "start": "450479",
    "end": "452160"
  },
  {
    "text": "index on the email column which acts as",
    "start": "452160",
    "end": "454919"
  },
  {
    "text": "a sort of lookup table storing the",
    "start": "454919",
    "end": "456720"
  },
  {
    "text": "user's email with a reference to the",
    "start": "456720",
    "end": "458460"
  },
  {
    "text": "associated row ID if this sounds very",
    "start": "458460",
    "end": "461280"
  },
  {
    "text": "similar to a key value pair well that's",
    "start": "461280",
    "end": "463560"
  },
  {
    "text": "because it is and that means we can",
    "start": "463560",
    "end": "465599"
  },
  {
    "text": "easily replicate it using redis",
    "start": "465599",
    "end": "467819"
  },
  {
    "text": "one approach to implement this would be",
    "start": "467819",
    "end": "469680"
  },
  {
    "text": "to store a key of the user's email with",
    "start": "469680",
    "end": "472080"
  },
  {
    "text": "an Associated namespace and a value of",
    "start": "472080",
    "end": "474660"
  },
  {
    "text": "the user's ID",
    "start": "474660",
    "end": "476280"
  },
  {
    "text": "with this we can easily obtain the",
    "start": "476280",
    "end": "478440"
  },
  {
    "text": "user's ID from an email input using the",
    "start": "478440",
    "end": "480840"
  },
  {
    "text": "redis get command but that's not the",
    "start": "480840",
    "end": "482940"
  },
  {
    "text": "only benefit this model gives us we also",
    "start": "482940",
    "end": "485039"
  },
  {
    "text": "have a sort of unique constraint in that",
    "start": "485039",
    "end": "487919"
  },
  {
    "text": "we're able to also see if an email",
    "start": "487919",
    "end": "489660"
  },
  {
    "text": "already exists in our system there is a",
    "start": "489660",
    "end": "492599"
  },
  {
    "text": "better data structure to use for unique",
    "start": "492599",
    "end": "494520"
  },
  {
    "text": "constraints but more on that later",
    "start": "494520",
    "end": "497280"
  },
  {
    "start": "497000",
    "end": "643000"
  },
  {
    "text": "so we have our simple table and a pretty",
    "start": "497280",
    "end": "500099"
  },
  {
    "text": "fast index but if this was a normal",
    "start": "500099",
    "end": "502440"
  },
  {
    "text": "application we'd want to store more data",
    "start": "502440",
    "end": "504599"
  },
  {
    "text": "than just the user's email address we'd",
    "start": "504599",
    "end": "506759"
  },
  {
    "text": "likely want to store the user's name a",
    "start": "506759",
    "end": "508680"
  },
  {
    "text": "hashed password and other fields",
    "start": "508680",
    "end": "511259"
  },
  {
    "text": "so keeping with the authentication model",
    "start": "511259",
    "end": "513360"
  },
  {
    "text": "that we've played around with how do we",
    "start": "513360",
    "end": "515039"
  },
  {
    "text": "store the hashed password in our table",
    "start": "515039",
    "end": "516719"
  },
  {
    "text": "well we could do this using another key",
    "start": "516719",
    "end": "519240"
  },
  {
    "text": "value pair where we store the hashed",
    "start": "519240",
    "end": "521039"
  },
  {
    "text": "password against the user's ID with some",
    "start": "521039",
    "end": "523320"
  },
  {
    "text": "namespaced prefix but that's not really",
    "start": "523320",
    "end": "525959"
  },
  {
    "text": "scalable another option would be to",
    "start": "525959",
    "end": "528300"
  },
  {
    "text": "store a Json encode a string of our",
    "start": "528300",
    "end": "530160"
  },
  {
    "text": "user's data structure as the value to",
    "start": "530160",
    "end": "532200"
  },
  {
    "text": "the user's ID",
    "start": "532200",
    "end": "533820"
  },
  {
    "text": "this works but it does mean every time",
    "start": "533820",
    "end": "535860"
  },
  {
    "text": "you want to add a new field to our user",
    "start": "535860",
    "end": "537720"
  },
  {
    "text": "we would have to fetch the record decode",
    "start": "537720",
    "end": "540060"
  },
  {
    "text": "the existing value make the change",
    "start": "540060",
    "end": "542180"
  },
  {
    "text": "re-encode it and store it using the set",
    "start": "542180",
    "end": "544920"
  },
  {
    "text": "command a better option is to use the",
    "start": "544920",
    "end": "547800"
  },
  {
    "text": "hash type for our value a redis hash is",
    "start": "547800",
    "end": "550860"
  },
  {
    "text": "basically a dictionary or a hash map in",
    "start": "550860",
    "end": "553500"
  },
  {
    "text": "other languages it allows us to store a",
    "start": "553500",
    "end": "555660"
  },
  {
    "text": "more complex data structure against a",
    "start": "555660",
    "end": "557820"
  },
  {
    "text": "key here we're going to use the HM set",
    "start": "557820",
    "end": "560339"
  },
  {
    "text": "command to store multiple hash key",
    "start": "560339",
    "end": "562260"
  },
  {
    "text": "values against a single key of our user",
    "start": "562260",
    "end": "564540"
  },
  {
    "text": "ID Fields we're going to set are email",
    "start": "564540",
    "end": "566519"
  },
  {
    "text": "and hashed password the values for each",
    "start": "566519",
    "end": "568980"
  },
  {
    "text": "of these are defined after The Field's",
    "start": "568980",
    "end": "570779"
  },
  {
    "text": "name in the command we can then retrieve",
    "start": "570779",
    "end": "572880"
  },
  {
    "text": "this full structure using the H get all",
    "start": "572880",
    "end": "575339"
  },
  {
    "text": "command which takes in the primary key",
    "start": "575339",
    "end": "577380"
  },
  {
    "text": "here you can see we have our full data",
    "start": "577380",
    "end": "579720"
  },
  {
    "text": "representation of our user which we just",
    "start": "579720",
    "end": "581820"
  },
  {
    "text": "previously set",
    "start": "581820",
    "end": "583080"
  },
  {
    "text": "if we use the redis sdks in different",
    "start": "583080",
    "end": "585720"
  },
  {
    "text": "programming languages we can easily",
    "start": "585720",
    "end": "587279"
  },
  {
    "text": "decode this into native data structures",
    "start": "587279",
    "end": "589380"
  },
  {
    "text": "as well here's an example using python",
    "start": "589380",
    "end": "592560"
  },
  {
    "text": "what's really awesome about this",
    "start": "592560",
    "end": "594060"
  },
  {
    "text": "approach is if we want to add additional",
    "start": "594060",
    "end": "595680"
  },
  {
    "text": "data to an entry we can easily do so",
    "start": "595680",
    "end": "597720"
  },
  {
    "text": "using the H set or HM set commands",
    "start": "597720",
    "end": "601500"
  },
  {
    "text": "for example let's add a name to our",
    "start": "601500",
    "end": "603480"
  },
  {
    "text": "user's entry",
    "start": "603480",
    "end": "604920"
  },
  {
    "text": "just as we can add fields we can also",
    "start": "604920",
    "end": "606959"
  },
  {
    "text": "delete them using the H Dell command",
    "start": "606959",
    "end": "608880"
  },
  {
    "text": "although one thing to note is that the",
    "start": "608880",
    "end": "610860"
  },
  {
    "text": "hash will no longer exist if no Fields",
    "start": "610860",
    "end": "613080"
  },
  {
    "text": "remain using this data structure let's",
    "start": "613080",
    "end": "615300"
  },
  {
    "text": "look and see how we would handle a",
    "start": "615300",
    "end": "617040"
  },
  {
    "text": "simple authentication flow first we find",
    "start": "617040",
    "end": "619800"
  },
  {
    "text": "a user ID given the email address",
    "start": "619800",
    "end": "621779"
  },
  {
    "text": "provided if one doesn't exist then we",
    "start": "621779",
    "end": "624360"
  },
  {
    "text": "return false next we can use the h-get",
    "start": "624360",
    "end": "627000"
  },
  {
    "text": "command to get the user's hashed",
    "start": "627000",
    "end": "628740"
  },
  {
    "text": "password from their user ID hash and",
    "start": "628740",
    "end": "631920"
  },
  {
    "text": "finally we could verify this hash",
    "start": "631920",
    "end": "633600"
  },
  {
    "text": "password against the password submitted",
    "start": "633600",
    "end": "635700"
  },
  {
    "text": "and we've ended up with something that",
    "start": "635700",
    "end": "637680"
  },
  {
    "text": "looks very similar to how you would",
    "start": "637680",
    "end": "639060"
  },
  {
    "text": "interface with a typical database so",
    "start": "639060",
    "end": "641760"
  },
  {
    "text": "what next",
    "start": "641760",
    "end": "643080"
  },
  {
    "start": "643000",
    "end": "823000"
  },
  {
    "text": "well we've looked at tables sequential",
    "start": "643080",
    "end": "645360"
  },
  {
    "text": "scanning and some basic indexes but what",
    "start": "645360",
    "end": "647940"
  },
  {
    "text": "about ordering in a typical database you",
    "start": "647940",
    "end": "650640"
  },
  {
    "text": "may want to return values based on a",
    "start": "650640",
    "end": "652440"
  },
  {
    "text": "timestamp or a ranking",
    "start": "652440",
    "end": "654600"
  },
  {
    "text": "to Showcase this let's first set up a",
    "start": "654600",
    "end": "656640"
  },
  {
    "text": "counter for our users to track the",
    "start": "656640",
    "end": "658260"
  },
  {
    "text": "number of times they've logged in or",
    "start": "658260",
    "end": "660000"
  },
  {
    "text": "something we could add this to our user",
    "start": "660000",
    "end": "662220"
  },
  {
    "text": "map but it's going to be more powerful",
    "start": "662220",
    "end": "663839"
  },
  {
    "text": "to add it to another data structure this",
    "start": "663839",
    "end": "666300"
  },
  {
    "text": "data structure is the sorted set which",
    "start": "666300",
    "end": "668940"
  },
  {
    "text": "allows us to store unique members which",
    "start": "668940",
    "end": "670920"
  },
  {
    "text": "would be our user IDs with an Associated",
    "start": "670920",
    "end": "673500"
  },
  {
    "text": "score which in our case would be the",
    "start": "673500",
    "end": "675899"
  },
  {
    "text": "number of logins per user to get started",
    "start": "675899",
    "end": "678480"
  },
  {
    "text": "with this sorted set we can use the Z",
    "start": "678480",
    "end": "680640"
  },
  {
    "text": "add command which will insert a member",
    "start": "680640",
    "end": "682800"
  },
  {
    "text": "into the data structure creating the",
    "start": "682800",
    "end": "684899"
  },
  {
    "text": "sorted set if it does not exist already",
    "start": "684899",
    "end": "686700"
  },
  {
    "text": "the first argument for this command is",
    "start": "686700",
    "end": "689040"
  },
  {
    "text": "the key we want to use for the set",
    "start": "689040",
    "end": "690779"
  },
  {
    "text": "itself in our case this will be the user",
    "start": "690779",
    "end": "693360"
  },
  {
    "text": "logins we then set the score or login",
    "start": "693360",
    "end": "696240"
  },
  {
    "text": "counts we want to associate with our",
    "start": "696240",
    "end": "697980"
  },
  {
    "text": "member which in our case is going to be",
    "start": "697980",
    "end": "699839"
  },
  {
    "text": "10 and finally the member itself which",
    "start": "699839",
    "end": "702779"
  },
  {
    "text": "will be our user's ID we get back the",
    "start": "702779",
    "end": "705600"
  },
  {
    "text": "value of 1 which tells us we",
    "start": "705600",
    "end": "707100"
  },
  {
    "text": "successfully added a single member we",
    "start": "707100",
    "end": "709440"
  },
  {
    "text": "can retrieve this entry by using the",
    "start": "709440",
    "end": "711120"
  },
  {
    "text": "z-score command and passing in both the",
    "start": "711120",
    "end": "713279"
  },
  {
    "text": "key for the set followed by the the key",
    "start": "713279",
    "end": "715140"
  },
  {
    "text": "of the member here we get back the value",
    "start": "715140",
    "end": "717180"
  },
  {
    "text": "of 10. as well as using Z add we can",
    "start": "717180",
    "end": "720180"
  },
  {
    "text": "also use the Z anchor by command to both",
    "start": "720180",
    "end": "722399"
  },
  {
    "text": "add members to our set or increment the",
    "start": "722399",
    "end": "724500"
  },
  {
    "text": "score of existing members if a member",
    "start": "724500",
    "end": "726779"
  },
  {
    "text": "doesn't exist then it is added to the",
    "start": "726779",
    "end": "728700"
  },
  {
    "text": "set and given the increment value as its",
    "start": "728700",
    "end": "730920"
  },
  {
    "text": "starting score in our case we've added a",
    "start": "730920",
    "end": "733680"
  },
  {
    "text": "new member to the set with the initial",
    "start": "733680",
    "end": "735660"
  },
  {
    "text": "value of 7. that covers how to add",
    "start": "735660",
    "end": "738240"
  },
  {
    "text": "entries to our set next we're going to",
    "start": "738240",
    "end": "740579"
  },
  {
    "text": "look at how to perform some range",
    "start": "740579",
    "end": "741839"
  },
  {
    "text": "operations over the data within before",
    "start": "741839",
    "end": "744240"
  },
  {
    "text": "doing that I'm first going to add three",
    "start": "744240",
    "end": "745920"
  },
  {
    "text": "other members to our set each with",
    "start": "745920",
    "end": "748019"
  },
  {
    "text": "different scores",
    "start": "748019",
    "end": "749339"
  },
  {
    "text": "now that our members added let's ask",
    "start": "749339",
    "end": "751320"
  },
  {
    "text": "some questions the first is we want to",
    "start": "751320",
    "end": "753839"
  },
  {
    "text": "order our users by the number of times",
    "start": "753839",
    "end": "755459"
  },
  {
    "text": "they've logged in in descending order",
    "start": "755459",
    "end": "757920"
  },
  {
    "text": "we can achieve this by using the Z range",
    "start": "757920",
    "end": "760260"
  },
  {
    "text": "and the Z rev range commands this allows",
    "start": "760260",
    "end": "762899"
  },
  {
    "text": "us to select members by range of their",
    "start": "762899",
    "end": "764940"
  },
  {
    "text": "sorted indexes if we use the z-rev range",
    "start": "764940",
    "end": "767760"
  },
  {
    "text": "command with the values of 0 and -1 we",
    "start": "767760",
    "end": "770639"
  },
  {
    "text": "receive a sorted list of our members in",
    "start": "770639",
    "end": "772800"
  },
  {
    "text": "descending order so how does the Z rev",
    "start": "772800",
    "end": "775680"
  },
  {
    "text": "range command work the first parameter",
    "start": "775680",
    "end": "778260"
  },
  {
    "text": "is the starting index which in our case",
    "start": "778260",
    "end": "780120"
  },
  {
    "text": "is zero and the second parameter is the",
    "start": "780120",
    "end": "782459"
  },
  {
    "text": "ending index which in our case is -1",
    "start": "782459",
    "end": "784800"
  },
  {
    "text": "which means to go until the last member",
    "start": "784800",
    "end": "787380"
  },
  {
    "text": "if we wanted to retrieve our members",
    "start": "787380",
    "end": "789420"
  },
  {
    "text": "sorted in ascending order well we could",
    "start": "789420",
    "end": "791459"
  },
  {
    "text": "use the Z range command instead we can",
    "start": "791459",
    "end": "794160"
  },
  {
    "text": "also scope this command to retrieve only",
    "start": "794160",
    "end": "795899"
  },
  {
    "text": "a subset of our members let's say we",
    "start": "795899",
    "end": "798600"
  },
  {
    "text": "want to retrieve only the top three most",
    "start": "798600",
    "end": "800459"
  },
  {
    "text": "logged in users we can do so by using",
    "start": "800459",
    "end": "803100"
  },
  {
    "text": "the Z rev range command with the values",
    "start": "803100",
    "end": "805320"
  },
  {
    "text": "of 0 and 2. we can do the same to",
    "start": "805320",
    "end": "808380"
  },
  {
    "text": "retrieve the three least logged in users",
    "start": "808380",
    "end": "810600"
  },
  {
    "text": "by using the Z range command with 0 and",
    "start": "810600",
    "end": "813300"
  },
  {
    "text": "3. as we're directly selecting indexes",
    "start": "813300",
    "end": "816180"
  },
  {
    "text": "you may want to know how many members",
    "start": "816180",
    "end": "817920"
  },
  {
    "text": "exist within our set we can retrieve",
    "start": "817920",
    "end": "820680"
  },
  {
    "text": "this number by using the Z card command",
    "start": "820680",
    "end": "822779"
  },
  {
    "text": "using these two range commands we can",
    "start": "822779",
    "end": "825120"
  },
  {
    "start": "823000",
    "end": "899000"
  },
  {
    "text": "easily sort our members in either",
    "start": "825120",
    "end": "826680"
  },
  {
    "text": "ascending or descending order whilst",
    "start": "826680",
    "end": "829019"
  },
  {
    "text": "also limiting the number of results we",
    "start": "829019",
    "end": "830820"
  },
  {
    "text": "get back very similar to the SQL you see",
    "start": "830820",
    "end": "833399"
  },
  {
    "text": "on screen this only applies to the",
    "start": "833399",
    "end": "835800"
  },
  {
    "text": "sorted indexes however basically the",
    "start": "835800",
    "end": "838440"
  },
  {
    "text": "relation of each member to one another",
    "start": "838440",
    "end": "840200"
  },
  {
    "text": "there may be situations where you want",
    "start": "840200",
    "end": "842459"
  },
  {
    "text": "to filter based on the actual score",
    "start": "842459",
    "end": "844079"
  },
  {
    "text": "value itself similar to using a where",
    "start": "844079",
    "end": "847139"
  },
  {
    "text": "command in SQL for example we may only",
    "start": "847139",
    "end": "850139"
  },
  {
    "text": "want to retrieve users that have logged",
    "start": "850139",
    "end": "852000"
  },
  {
    "text": "in greater than 10 times Well we can",
    "start": "852000",
    "end": "854220"
  },
  {
    "text": "actually do that by using the Z range by",
    "start": "854220",
    "end": "856620"
  },
  {
    "text": "score command followed by the Min which",
    "start": "856620",
    "end": "859139"
  },
  {
    "text": "in our case is 10 and the max to ensure",
    "start": "859139",
    "end": "862320"
  },
  {
    "text": "no upper bound we would just use the",
    "start": "862320",
    "end": "863940"
  },
  {
    "text": "plus infinite value this will return the",
    "start": "863940",
    "end": "866459"
  },
  {
    "text": "two members we have that are greater",
    "start": "866459",
    "end": "868019"
  },
  {
    "text": "than 10 sorted in ascending order if we",
    "start": "868019",
    "end": "871200"
  },
  {
    "text": "want to retrieve the members in",
    "start": "871200",
    "end": "872579"
  },
  {
    "text": "descending order we can use the Z rev",
    "start": "872579",
    "end": "874920"
  },
  {
    "text": "range by score command instead we also",
    "start": "874920",
    "end": "877500"
  },
  {
    "text": "need to swap the position of the",
    "start": "877500",
    "end": "879300"
  },
  {
    "text": "parameters as well we can also use these",
    "start": "879300",
    "end": "882060"
  },
  {
    "text": "commands to retrieve our least logged in",
    "start": "882060",
    "end": "883860"
  },
  {
    "text": "users to do so we'd instead use the",
    "start": "883860",
    "end": "886680"
  },
  {
    "text": "minus infinite value when specifying the",
    "start": "886680",
    "end": "888720"
  },
  {
    "text": "Min range we're looking for and setting",
    "start": "888720",
    "end": "890639"
  },
  {
    "text": "our max value appropriately in our case",
    "start": "890639",
    "end": "892620"
  },
  {
    "text": "we're setting the max to 5 in order to",
    "start": "892620",
    "end": "894779"
  },
  {
    "text": "retrieve any members that have logged in",
    "start": "894779",
    "end": "896459"
  },
  {
    "text": "less than or equal to five times",
    "start": "896459",
    "end": "899399"
  },
  {
    "start": "899000",
    "end": "973000"
  },
  {
    "text": "so great we not only have sorting by",
    "start": "899399",
    "end": "901620"
  },
  {
    "text": "values but we also have filtering by",
    "start": "901620",
    "end": "903480"
  },
  {
    "text": "range as well we achieve this by using",
    "start": "903480",
    "end": "905820"
  },
  {
    "text": "sorted sets but there's another type of",
    "start": "905820",
    "end": "908160"
  },
  {
    "text": "set in redis we can use for unique",
    "start": "908160",
    "end": "910139"
  },
  {
    "text": "constraints this is the standard set",
    "start": "910139",
    "end": "912660"
  },
  {
    "text": "which stores unique members inside of it",
    "start": "912660",
    "end": "915240"
  },
  {
    "text": "earlier we created a unique index for",
    "start": "915240",
    "end": "918000"
  },
  {
    "text": "our user emails using just a key value",
    "start": "918000",
    "end": "920459"
  },
  {
    "text": "pair but what if we don't want an index",
    "start": "920459",
    "end": "922920"
  },
  {
    "text": "but instead we only want a unique",
    "start": "922920",
    "end": "924899"
  },
  {
    "text": "constraint for example let's say we want",
    "start": "924899",
    "end": "927480"
  },
  {
    "text": "to allow our users to select a username",
    "start": "927480",
    "end": "929699"
  },
  {
    "text": "but we want to have unique instances of",
    "start": "929699",
    "end": "931800"
  },
  {
    "text": "usernames within our database by using",
    "start": "931800",
    "end": "934139"
  },
  {
    "text": "the S at command we can add username",
    "start": "934139",
    "end": "936540"
  },
  {
    "text": "values into our set creating the set if",
    "start": "936540",
    "end": "939300"
  },
  {
    "text": "it does not exist already then let's say",
    "start": "939300",
    "end": "942060"
  },
  {
    "text": "when a user goes to set their username",
    "start": "942060",
    "end": "943860"
  },
  {
    "text": "we can use the S is member command to",
    "start": "943860",
    "end": "946320"
  },
  {
    "text": "check if the username is available if it",
    "start": "946320",
    "end": "948899"
  },
  {
    "text": "already exists within our set we get",
    "start": "948899",
    "end": "950940"
  },
  {
    "text": "back the response of 1 which represents",
    "start": "950940",
    "end": "953459"
  },
  {
    "text": "true otherwise we get back the result of",
    "start": "953459",
    "end": "956279"
  },
  {
    "text": "zero the set works as a sort of",
    "start": "956279",
    "end": "958560"
  },
  {
    "text": "replacement for a unique constraint but",
    "start": "958560",
    "end": "960720"
  },
  {
    "text": "it does require storing related data",
    "start": "960720",
    "end": "962399"
  },
  {
    "text": "across two different structures which",
    "start": "962399",
    "end": "964260"
  },
  {
    "text": "adds complexity to our data model",
    "start": "964260",
    "end": "966779"
  },
  {
    "text": "so the last database concept I think",
    "start": "966779",
    "end": "968760"
  },
  {
    "text": "worth touching on is actually really",
    "start": "968760",
    "end": "970380"
  },
  {
    "text": "important when it comes to redis perhaps",
    "start": "970380",
    "end": "972480"
  },
  {
    "text": "even more so than normal databases that",
    "start": "972480",
    "end": "975060"
  },
  {
    "start": "973000",
    "end": "1131000"
  },
  {
    "text": "concept is transactions in databases",
    "start": "975060",
    "end": "978180"
  },
  {
    "text": "transactions are used to group",
    "start": "978180",
    "end": "979860"
  },
  {
    "text": "operations together in anatomic fashion",
    "start": "979860",
    "end": "982339"
  },
  {
    "text": "I.E either all of the operations perform",
    "start": "982339",
    "end": "984839"
  },
  {
    "text": "or not at all this concept is very",
    "start": "984839",
    "end": "987720"
  },
  {
    "text": "important as it prevents us from being",
    "start": "987720",
    "end": "989339"
  },
  {
    "text": "left in a partial state to visualize",
    "start": "989339",
    "end": "991740"
  },
  {
    "text": "this let's look at some example code for",
    "start": "991740",
    "end": "993779"
  },
  {
    "text": "creating a new user we first check to",
    "start": "993779",
    "end": "996540"
  },
  {
    "text": "see if the user's email already exists",
    "start": "996540",
    "end": "999240"
  },
  {
    "text": "if it doesn't then we proceed with",
    "start": "999240",
    "end": "1001100"
  },
  {
    "text": "adding the user entry followed by",
    "start": "1001100",
    "end": "1003320"
  },
  {
    "text": "setting the user's email to Id mapping",
    "start": "1003320",
    "end": "1005660"
  },
  {
    "text": "this code is susceptible to a race",
    "start": "1005660",
    "end": "1007940"
  },
  {
    "text": "condition however in rare cases it's",
    "start": "1007940",
    "end": "1010279"
  },
  {
    "text": "possible that in between the time we",
    "start": "1010279",
    "end": "1011959"
  },
  {
    "text": "check if an email exists and then set",
    "start": "1011959",
    "end": "1014240"
  },
  {
    "text": "the user's ID for that email another",
    "start": "1014240",
    "end": "1016160"
  },
  {
    "text": "entry could have been written this means",
    "start": "1016160",
    "end": "1018560"
  },
  {
    "text": "that our second entry will overwrite",
    "start": "1018560",
    "end": "1020360"
  },
  {
    "text": "that existing one even when it returned",
    "start": "1020360",
    "end": "1022339"
  },
  {
    "text": "a success to the user this is very bad",
    "start": "1022339",
    "end": "1025459"
  },
  {
    "text": "however we can prevent this by setting",
    "start": "1025459",
    "end": "1028040"
  },
  {
    "text": "the NX option which stands for not",
    "start": "1028040",
    "end": "1030199"
  },
  {
    "text": "exists in our redis set command what",
    "start": "1030199",
    "end": "1033380"
  },
  {
    "text": "this does is enforces the set command to",
    "start": "1033380",
    "end": "1035540"
  },
  {
    "text": "only apply if the record does not exist",
    "start": "1035540",
    "end": "1037579"
  },
  {
    "text": "already this prevents us from",
    "start": "1037579",
    "end": "1039740"
  },
  {
    "text": "overwriting the original record and lets",
    "start": "1039740",
    "end": "1042319"
  },
  {
    "text": "us know if we encounter an error however",
    "start": "1042319",
    "end": "1044600"
  },
  {
    "text": "it does leave us in a partial state",
    "start": "1044600",
    "end": "1046400"
  },
  {
    "text": "where our user record was created when",
    "start": "1046400",
    "end": "1048620"
  },
  {
    "text": "it shouldn't have been now we could",
    "start": "1048620",
    "end": "1050540"
  },
  {
    "text": "resolve this using reconciliation which",
    "start": "1050540",
    "end": "1053120"
  },
  {
    "text": "is where we unwind our partial State and",
    "start": "1053120",
    "end": "1055280"
  },
  {
    "text": "remove any created entries but this adds",
    "start": "1055280",
    "end": "1057799"
  },
  {
    "text": "a lot of complexity and can still be",
    "start": "1057799",
    "end": "1059600"
  },
  {
    "text": "prone to errors it's much easier to use",
    "start": "1059600",
    "end": "1061940"
  },
  {
    "text": "a database transaction which fortunately",
    "start": "1061940",
    "end": "1064460"
  },
  {
    "text": "redis does support let's look at how to",
    "start": "1064460",
    "end": "1067160"
  },
  {
    "text": "use them to begin a transaction we first",
    "start": "1067160",
    "end": "1069440"
  },
  {
    "text": "need to call the watch command on the",
    "start": "1069440",
    "end": "1071179"
  },
  {
    "text": "key we're interested in in our case this",
    "start": "1071179",
    "end": "1073460"
  },
  {
    "text": "is the user email key that we're going",
    "start": "1073460",
    "end": "1075500"
  },
  {
    "text": "to set up the watch command will cause",
    "start": "1075500",
    "end": "1077660"
  },
  {
    "text": "any transactions to be discarded if a",
    "start": "1077660",
    "end": "1079940"
  },
  {
    "text": "change is made to the watched key from",
    "start": "1079940",
    "end": "1081799"
  },
  {
    "text": "any other client once we have our",
    "start": "1081799",
    "end": "1083960"
  },
  {
    "text": "watched key set up we can enter the",
    "start": "1083960",
    "end": "1085640"
  },
  {
    "text": "transaction using the multi-command and",
    "start": "1085640",
    "end": "1087980"
  },
  {
    "text": "we can confirm that our client is in a",
    "start": "1087980",
    "end": "1089780"
  },
  {
    "text": "transaction with the letters TX next to",
    "start": "1089780",
    "end": "1092120"
  },
  {
    "text": "the prompt",
    "start": "1092120",
    "end": "1093320"
  },
  {
    "text": "next we can go about adding our user",
    "start": "1093320",
    "end": "1095480"
  },
  {
    "text": "hash using the H set command now to",
    "start": "1095480",
    "end": "1098660"
  },
  {
    "text": "simulate a race condition I'll open up",
    "start": "1098660",
    "end": "1100580"
  },
  {
    "text": "another client to redis and set our",
    "start": "1100580",
    "end": "1102500"
  },
  {
    "text": "user's email to point to a different",
    "start": "1102500",
    "end": "1104240"
  },
  {
    "text": "user ID this is the key that we're",
    "start": "1104240",
    "end": "1106880"
  },
  {
    "text": "watching",
    "start": "1106880",
    "end": "1107960"
  },
  {
    "text": "back in the original clients we'll also",
    "start": "1107960",
    "end": "1110360"
  },
  {
    "text": "attempt to set the user email index key",
    "start": "1110360",
    "end": "1112460"
  },
  {
    "text": "but point it to a different user ID",
    "start": "1112460",
    "end": "1114460"
  },
  {
    "text": "finally we'll run the exact command to",
    "start": "1114460",
    "end": "1117020"
  },
  {
    "text": "apply the transaction which returns nil",
    "start": "1117020",
    "end": "1119299"
  },
  {
    "text": "letting us know that the transaction",
    "start": "1119299",
    "end": "1120980"
  },
  {
    "text": "didn't apply we can validate that our",
    "start": "1120980",
    "end": "1123260"
  },
  {
    "text": "user email points to the existing user",
    "start": "1123260",
    "end": "1125539"
  },
  {
    "text": "ID and that our user model was never",
    "start": "1125539",
    "end": "1127700"
  },
  {
    "text": "created showing us that the transaction",
    "start": "1127700",
    "end": "1129860"
  },
  {
    "text": "worked as intended now that we've taken",
    "start": "1129860",
    "end": "1133100"
  },
  {
    "start": "1131000",
    "end": "1253000"
  },
  {
    "text": "a look at how redis can be used as a",
    "start": "1133100",
    "end": "1134900"
  },
  {
    "text": "primary database it's probably worth",
    "start": "1134900",
    "end": "1137000"
  },
  {
    "text": "talking about a couple of reasons why it",
    "start": "1137000",
    "end": "1138980"
  },
  {
    "text": "may not be worthwhile to do so the first",
    "start": "1138980",
    "end": "1141440"
  },
  {
    "text": "of these is that when it comes to redis",
    "start": "1141440",
    "end": "1143179"
  },
  {
    "text": "there's a significant amount of work",
    "start": "1143179",
    "end": "1144679"
  },
  {
    "text": "that needs to go into creating what",
    "start": "1144679",
    "end": "1146419"
  },
  {
    "text": "databases give us for free out of the",
    "start": "1146419",
    "end": "1148280"
  },
  {
    "text": "box take postgres and SQL for example",
    "start": "1148280",
    "end": "1150919"
  },
  {
    "text": "setting up tables indexes and",
    "start": "1150919",
    "end": "1153440"
  },
  {
    "text": "constraints are all achieved",
    "start": "1153440",
    "end": "1155000"
  },
  {
    "text": "declaratively using a powerful query",
    "start": "1155000",
    "end": "1157340"
  },
  {
    "text": "language this contrasts to redis where",
    "start": "1157340",
    "end": "1160400"
  },
  {
    "text": "each of these operations has to be built",
    "start": "1160400",
    "end": "1162080"
  },
  {
    "text": "using The Primitives that redis offers",
    "start": "1162080",
    "end": "1164179"
  },
  {
    "text": "that being said it is a good thing to",
    "start": "1164179",
    "end": "1166160"
  },
  {
    "text": "learn how to implement these features",
    "start": "1166160",
    "end": "1167720"
  },
  {
    "text": "using Primitives but if you know you're",
    "start": "1167720",
    "end": "1170000"
  },
  {
    "text": "going to need these complex data",
    "start": "1170000",
    "end": "1171380"
  },
  {
    "text": "structures and want to get started",
    "start": "1171380",
    "end": "1173000"
  },
  {
    "text": "quickly then a database like postgres is",
    "start": "1173000",
    "end": "1175520"
  },
  {
    "text": "going to be a better choice the second",
    "start": "1175520",
    "end": "1177980"
  },
  {
    "text": "reason that I would opt to not use redis",
    "start": "1177980",
    "end": "1180440"
  },
  {
    "text": "is actually due to the fact redis stores",
    "start": "1180440",
    "end": "1182360"
  },
  {
    "text": "all of its data in memory earlier we",
    "start": "1182360",
    "end": "1184940"
  },
  {
    "text": "covered that red is storing its data run",
    "start": "1184940",
    "end": "1186559"
  },
  {
    "text": "memory is much safer than one may",
    "start": "1186559",
    "end": "1188299"
  },
  {
    "text": "initially think however there is another",
    "start": "1188299",
    "end": "1190580"
  },
  {
    "text": "elephant in the room memory tends to be",
    "start": "1190580",
    "end": "1193220"
  },
  {
    "text": "much more expensive and less available",
    "start": "1193220",
    "end": "1194960"
  },
  {
    "text": "than storage considerably so this means",
    "start": "1194960",
    "end": "1198020"
  },
  {
    "text": "you'll likely end up paying more money",
    "start": "1198020",
    "end": "1199520"
  },
  {
    "text": "for using redis when it comes to larger",
    "start": "1199520",
    "end": "1201320"
  },
  {
    "text": "data sets either by horizontally or",
    "start": "1201320",
    "end": "1203840"
  },
  {
    "text": "vertically scaling your redis instances",
    "start": "1203840",
    "end": "1205820"
  },
  {
    "text": "however if your data set is small or you",
    "start": "1205820",
    "end": "1208520"
  },
  {
    "text": "need to be really fast then redis may be",
    "start": "1208520",
    "end": "1210620"
  },
  {
    "text": "worth that additional cost to you for me",
    "start": "1210620",
    "end": "1212960"
  },
  {
    "text": "well on personal projects I typically",
    "start": "1212960",
    "end": "1215059"
  },
  {
    "text": "couple redis with postgres often usually",
    "start": "1215059",
    "end": "1217640"
  },
  {
    "text": "as the caching layer before the database",
    "start": "1217640",
    "end": "1219799"
  },
  {
    "text": "itself my data sets also happen to be",
    "start": "1219799",
    "end": "1222320"
  },
  {
    "text": "rather small therefore in the future I",
    "start": "1222320",
    "end": "1224600"
  },
  {
    "text": "would likely consider promoting redis to",
    "start": "1224600",
    "end": "1226280"
  },
  {
    "text": "the primary database on my initial",
    "start": "1226280",
    "end": "1228380"
  },
  {
    "text": "iterations and only migrating to",
    "start": "1228380",
    "end": "1230419"
  },
  {
    "text": "postgres when I need to either way I'd",
    "start": "1230419",
    "end": "1232880"
  },
  {
    "text": "love to know your thoughts has this",
    "start": "1232880",
    "end": "1234620"
  },
  {
    "text": "video convinced you to try redis as a",
    "start": "1234620",
    "end": "1236539"
  },
  {
    "text": "primary database or were you doing so",
    "start": "1236539",
    "end": "1238400"
  },
  {
    "text": "already let me know in the comments down",
    "start": "1238400",
    "end": "1240740"
  },
  {
    "text": "below otherwise a big thank you to my",
    "start": "1240740",
    "end": "1243200"
  },
  {
    "text": "channel members including my newest one",
    "start": "1243200",
    "end": "1245059"
  },
  {
    "text": "canarius and a big thank you to everyone",
    "start": "1245059",
    "end": "1247700"
  },
  {
    "text": "else for watching I'll see you on the",
    "start": "1247700",
    "end": "1250220"
  },
  {
    "text": "next one",
    "start": "1250220",
    "end": "1252580"
  }
]