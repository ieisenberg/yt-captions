[
  {
    "text": "hey everyone welcome to cncf on demand webinar today i'm going to talk about the secret",
    "start": "4160",
    "end": "10559"
  },
  {
    "text": "store csi driver that integrates external secret stores with kubernetes",
    "start": "10559",
    "end": "17279"
  },
  {
    "text": "a brief introduction about me i'm anish i'm a software engineer at microsoft",
    "start": "17279",
    "end": "22640"
  },
  {
    "text": "based in seattle i'm part of the upstream kubernetes security team [Music]",
    "start": "22640",
    "end": "28400"
  },
  {
    "text": "i am a maintainer of the secret store csi driver and the azure keyword provider for the",
    "start": "28400",
    "end": "34399"
  },
  {
    "text": "secret store csi driver",
    "start": "34399",
    "end": "37920"
  },
  {
    "text": "so why are we talking about external secret storage when kubernetes has a perfectly good one built in",
    "start": "40000",
    "end": "47520"
  },
  {
    "text": "first kubernetes secrets may not meet your data addressed encryption requirements",
    "start": "47520",
    "end": "53280"
  },
  {
    "text": "by default when you create a kubernetes secret the data is stored in xcd and it's just basics before encoded but it's",
    "start": "53280",
    "end": "60559"
  },
  {
    "text": "not encrypted although there are kms providers to enable secret data encryption at rest",
    "start": "60559",
    "end": "67520"
  },
  {
    "text": "depending on your organization you may have already standardized on a third party secret solution and need to use",
    "start": "67520",
    "end": "74080"
  },
  {
    "text": "that also your external secret solution may have some sort of secret rotation story",
    "start": "74080",
    "end": "81439"
  },
  {
    "text": "or integration that you are looking to leverage finally if your organization has already",
    "start": "81439",
    "end": "88400"
  },
  {
    "text": "invested in auditing and alerting on a third-party secret system you may want to",
    "start": "88400",
    "end": "95280"
  },
  {
    "text": "you may not want to duplicate that effort for community secret so what do you do",
    "start": "95280",
    "end": "103200"
  },
  {
    "text": "there are a few options to consume external secrets you first might look at modifying your",
    "start": "103840",
    "end": "110960"
  },
  {
    "text": "application to fetch the secret from external api directly using the sdks",
    "start": "110960",
    "end": "116320"
  },
  {
    "text": "provided by the external sql store providers this may not be possible depending on",
    "start": "116320",
    "end": "121920"
  },
  {
    "text": "your deployment you may not have the code to edit or it may be prohibitively expensive to",
    "start": "121920",
    "end": "128080"
  },
  {
    "text": "implement these changes and if you're targeting deployments against multiple secret providers",
    "start": "128080",
    "end": "134800"
  },
  {
    "text": "this effort would need to be duplicated across every single secret storage system",
    "start": "134800",
    "end": "140959"
  },
  {
    "text": "uh you might also look at just copying the secrets and syncing them as kubernetes secrets",
    "start": "140959",
    "end": "147520"
  },
  {
    "text": "perhaps with a single controller this is portable and won't require application changes",
    "start": "147520",
    "end": "154879"
  },
  {
    "text": "but you may lose out on some of the benefits of your external secret stores like using the identity of the workload",
    "start": "154879",
    "end": "162560"
  },
  {
    "text": "for access controls because in this particular scenario you are granting the single controller",
    "start": "162560",
    "end": "169599"
  },
  {
    "text": "permissions to access the secrets instead of the workload that needs to use the secret",
    "start": "169599",
    "end": "175599"
  },
  {
    "text": "the third option is you could use a sidecar to fetch and write these secrets",
    "start": "175599",
    "end": "181120"
  },
  {
    "text": "the sidecar may be injected using a mutating web hook here the identity that is being used to",
    "start": "181120",
    "end": "188319"
  },
  {
    "text": "access the external secret store would still be the pod identity but having a side car and an additional",
    "start": "188319",
    "end": "195040"
  },
  {
    "text": "mutating web hook may have operational complexity",
    "start": "195040",
    "end": "200239"
  },
  {
    "text": "finally there is the secret store csi driver that uses a container storage interface specification that we are here",
    "start": "202319",
    "end": "209120"
  },
  {
    "text": "to talk about today and cover some of the features that we think is a good fit for consuming external secrets",
    "start": "209120",
    "end": "217359"
  },
  {
    "text": "the secret store csi driver project was originally developed at these labs and",
    "start": "218879",
    "end": "224319"
  },
  {
    "text": "this storage driver is now built and maintained as a cigar sub project",
    "start": "224319",
    "end": "230319"
  },
  {
    "text": "the driver allows kubernetes to mount multiple secrets keys and certificates",
    "start": "230319",
    "end": "235760"
  },
  {
    "text": "stored in enterprise grain external secret store into the pods as volumes",
    "start": "235760",
    "end": "241680"
  },
  {
    "text": "once the volume is attached the data in it is mounted into the container's",
    "start": "241680",
    "end": "247040"
  },
  {
    "text": "temporary file system",
    "start": "247040",
    "end": "250239"
  },
  {
    "text": "in terms of the features that the secret store csi driver supports it has a familiar file system mount experience to",
    "start": "252480",
    "end": "259519"
  },
  {
    "text": "compute workloads it's also pluggable and it can support multiple external secret providers",
    "start": "259519",
    "end": "266800"
  },
  {
    "text": "without the application having to be modified it can load new values of secrets",
    "start": "266800",
    "end": "273360"
  },
  {
    "text": "throughout the life cycle of the pod [Music] it can also sync the mounted content as",
    "start": "273360",
    "end": "280080"
  },
  {
    "text": "kubernetes secret for further compatibility with existing deployments",
    "start": "280080",
    "end": "285120"
  },
  {
    "text": "finally it supports both linux and windows containers",
    "start": "285120",
    "end": "290720"
  },
  {
    "text": "in terms of the prerequisites that are required for using the driver the driver can be used on any kubernetes",
    "start": "292880",
    "end": "299680"
  },
  {
    "text": "cluster that's running 116 or above in case of windows you would require a",
    "start": "299680",
    "end": "305199"
  },
  {
    "text": "118 plus for csi inline volume support",
    "start": "305199",
    "end": "311320"
  },
  {
    "text": "we talked about the driver supporting multiple external secret providers um the supported providers that we have",
    "start": "312720",
    "end": "319680"
  },
  {
    "text": "today with the secret store csi driver are azure keyword google secret manager",
    "start": "319680",
    "end": "325440"
  },
  {
    "text": "hashicorp vault and aws secret manager",
    "start": "325440",
    "end": "330479"
  },
  {
    "text": "so we have we saw a brief introduction on what the secret store csi driver is um so",
    "start": "333680",
    "end": "339600"
  },
  {
    "text": "how does the secret store csi driver work a driver is installed as a daemon set on",
    "start": "339600",
    "end": "346320"
  },
  {
    "text": "each node in the cluster in addition to the driver being deployed",
    "start": "346320",
    "end": "351360"
  },
  {
    "text": "there needs to be a provider specific daemon said are deployed on every single",
    "start": "351360",
    "end": "356400"
  },
  {
    "text": "node so first when a part is created through",
    "start": "356400",
    "end": "361440"
  },
  {
    "text": "the kubernetes api it gets scheduled onto a particular node based on scheduling decisions",
    "start": "361440",
    "end": "368400"
  },
  {
    "text": "the cubelet process on the node looks at the pod spec and sees there is a volume",
    "start": "368400",
    "end": "374160"
  },
  {
    "text": "mount request and referencing a particular csr driver",
    "start": "374160",
    "end": "380160"
  },
  {
    "text": "at this point the cubelet issues an rpc call to the csi driver provided in the",
    "start": "380160",
    "end": "387039"
  },
  {
    "text": "csi volume the first thing that the csi driver does",
    "start": "387039",
    "end": "392639"
  },
  {
    "text": "at this point is it mounts the temp fs to the pod",
    "start": "392639",
    "end": "398000"
  },
  {
    "text": "and then it issues an rpc request to the provider based on the configuration",
    "start": "398000",
    "end": "406000"
  },
  {
    "text": "the provider talks to the external secret store to fetch the secrets",
    "start": "407199",
    "end": "412240"
  },
  {
    "text": "the provider in this scenario uses the pods identity so it could be the parts workload identity",
    "start": "412240",
    "end": "419280"
  },
  {
    "text": "or any other configuration that's typed to the workload pod",
    "start": "419280",
    "end": "424479"
  },
  {
    "text": "the provider then fetches the secrets from the external secrets control and it sends the content back to the driver as",
    "start": "424880",
    "end": "432080"
  },
  {
    "text": "part of the rpc response the driver then writes the secrets into",
    "start": "432080",
    "end": "437840"
  },
  {
    "text": "the file system and at this point the volume is successfully mounted and then the pod",
    "start": "437840",
    "end": "444639"
  },
  {
    "text": "starts up running",
    "start": "444639",
    "end": "448199"
  },
  {
    "text": "so we talked about how the driver works um and now let's get into some of the",
    "start": "450639",
    "end": "456240"
  },
  {
    "text": "yaml files that are required for the configuration so here we have a sample",
    "start": "456240",
    "end": "461680"
  },
  {
    "text": "pod spec so if you look at it here in the volume mounts we have the mount path defined",
    "start": "461680",
    "end": "468800"
  },
  {
    "text": "which is the path inside the container and it has slash wire secrets and if we look at the volume we can see",
    "start": "468800",
    "end": "476160"
  },
  {
    "text": "that it is a csi volume and not a secret volume the driver name in the csi volume is",
    "start": "476160",
    "end": "483280"
  },
  {
    "text": "what tells cubelet to use the secret store csi for this particular",
    "start": "483280",
    "end": "489680"
  },
  {
    "text": "volume the secret provider class in the volume attribute is a namespace kubernetes custom",
    "start": "490840",
    "end": "498400"
  },
  {
    "text": "resource it is used for provide to provide driver",
    "start": "498400",
    "end": "503919"
  },
  {
    "text": "configurations and also provide a specific parameters for the secret store csi driver",
    "start": "503919",
    "end": "510639"
  },
  {
    "text": "so we have looked at the pod yaml and then the secret provider class yaml",
    "start": "510639",
    "end": "515919"
  },
  {
    "text": "where you define all the configurations for your provider but how do you know which version of the",
    "start": "515919",
    "end": "522240"
  },
  {
    "text": "secret that you're getting from your external secret store is currently being used by your bot",
    "start": "522240",
    "end": "528800"
  },
  {
    "text": "the secret provider class pod status is a namespace kubernetes custom resource",
    "start": "530480",
    "end": "536160"
  },
  {
    "text": "that is created and managed by the secret store csi driver to track the binding between",
    "start": "536160",
    "end": "542720"
  },
  {
    "text": "a pod and a secret provider class",
    "start": "542720",
    "end": "548640"
  },
  {
    "text": "this resource contains details about the current object versions that have been",
    "start": "548640",
    "end": "554160"
  },
  {
    "text": "loaded into the part mount and then it can indicate whenever",
    "start": "554160",
    "end": "559440"
  },
  {
    "text": "there has been rotation and then newer version of the secret is now being used by the pod",
    "start": "559440",
    "end": "566080"
  },
  {
    "text": "so let's see a small demo on all the things that we just talked about to see how the",
    "start": "567920",
    "end": "574640"
  },
  {
    "text": "driver works so as part of this demo what we're going to do is",
    "start": "574640",
    "end": "580000"
  },
  {
    "text": "we have a kind cluster and it's running kubernetes 121.1",
    "start": "580000",
    "end": "586510"
  },
  {
    "text": "[Music] to show how the secret store csi driver enables port portability across",
    "start": "586510",
    "end": "592320"
  },
  {
    "text": "different external secret store providers we're going to start with deploying two applications written",
    "start": "592320",
    "end": "597839"
  },
  {
    "text": "against specific third-party secret stores so in this particular demo we're going to be using gcp and azure",
    "start": "597839",
    "end": "606720"
  },
  {
    "text": "first we're going to see what the pod yaml looks like for these applications using the external secret store apis to",
    "start": "606720",
    "end": "613600"
  },
  {
    "text": "access the secrets so this is a pod spec for a part that's",
    "start": "613600",
    "end": "619839"
  },
  {
    "text": "i implementing api calls using the azure sdk to talk to keyword",
    "start": "619839",
    "end": "625680"
  },
  {
    "text": "uh the keyword name is kind kv and the secret that it's trying to fetch is",
    "start": "625680",
    "end": "630959"
  },
  {
    "text": "secret one and",
    "start": "630959",
    "end": "636079"
  },
  {
    "text": "this is a part spec for a pod that is using the",
    "start": "636079",
    "end": "641920"
  },
  {
    "text": "gcp sdks to access a secret from google secret manager so we can see here the secret name is",
    "start": "641920",
    "end": "648959"
  },
  {
    "text": "the resource id of the secret that it's trying to get as you can see",
    "start": "648959",
    "end": "656000"
  },
  {
    "text": "both of these yamls are referencing credentials from a secret secret store",
    "start": "656000",
    "end": "662240"
  },
  {
    "text": "creds which i've already pre-configured in the azure and the gcp name spaces for the",
    "start": "662240",
    "end": "668480"
  },
  {
    "text": "demo so now i'm going to deploy these pods in their respective namespaces",
    "start": "668480",
    "end": "676639"
  },
  {
    "text": "so we have deployed the azure part in azure namespace and now we're deploying the google secret manager pod in the gcp",
    "start": "677120",
    "end": "684320"
  },
  {
    "text": "namespace let's quickly check if both the parts are running",
    "start": "684320",
    "end": "690040"
  },
  {
    "text": "[Music] okay now we can see that both the pods are up and running let's check the logs to see the secret",
    "start": "690040",
    "end": "697519"
  },
  {
    "text": "being logged so we can see here that the azure port",
    "start": "697519",
    "end": "703600"
  },
  {
    "text": "was able to successfully get the secret from azure keyword using the sdk and then it logged secret",
    "start": "703600",
    "end": "710959"
  },
  {
    "text": "similarly the gcp port was able to get the secret from google secret manager and then it",
    "start": "710959",
    "end": "716880"
  },
  {
    "text": "was able to log that so here we have two different parts that",
    "start": "716880",
    "end": "722320"
  },
  {
    "text": "are implementing the apis required for each secret store backing",
    "start": "722320",
    "end": "728240"
  },
  {
    "text": "now instead of having two different application implementation for external secret store i have a third application",
    "start": "728240",
    "end": "735920"
  },
  {
    "text": "that was written to consume the secret from the file system instead so using",
    "start": "735920",
    "end": "741360"
  },
  {
    "text": "the secret store csi driver i am going to show how this application gets the",
    "start": "741360",
    "end": "746800"
  },
  {
    "text": "secrets from either of the secret backend that is azure or gcp",
    "start": "746800",
    "end": "752480"
  },
  {
    "text": "so as a first step for the demo i'm going to deploy the secret store csi driver using helm in the cube system",
    "start": "752480",
    "end": "758880"
  },
  {
    "text": "name space so if you see here i'm setting a couple",
    "start": "758880",
    "end": "764720"
  },
  {
    "text": "of values required for the hand chats i'm enabling the secret rotation feature",
    "start": "764720",
    "end": "770240"
  },
  {
    "text": "and i'm also setting the rotation pole interval to five seconds uh which is aggressive but it's only for this",
    "start": "770240",
    "end": "776079"
  },
  {
    "text": "purpose of the demo and then i'm also enabling the sync secret feature for the driver",
    "start": "776079",
    "end": "783920"
  },
  {
    "text": "uh we typically recommend to use a separate namespace for the csi driver pods other than the ones that's used for",
    "start": "784160",
    "end": "790639"
  },
  {
    "text": "your workload um the default that we set in the manifest is cube system because",
    "start": "790639",
    "end": "796079"
  },
  {
    "text": "the csr driver pods are privileged and it's recommended to run an include system in space",
    "start": "796079",
    "end": "801680"
  },
  {
    "text": "okay um so now let's just quickly check what the helm chart deployed",
    "start": "801680",
    "end": "807600"
  },
  {
    "text": "um when we look at it we can see that we have a driver daemon set running in cube",
    "start": "807600",
    "end": "812800"
  },
  {
    "text": "system namespace and it's running three containers uh one of the containers is the actual",
    "start": "812800",
    "end": "817839"
  },
  {
    "text": "implementation for the driver and then the other two sidecar containers are for dynamic registration of the diver with",
    "start": "817839",
    "end": "824079"
  },
  {
    "text": "cublic and then the third one is the liveness probe which ensures that the driver is functioning as expected",
    "start": "824079",
    "end": "832000"
  },
  {
    "text": "okay so the next now that we have the driver running we also have to deploy the providers for",
    "start": "832240",
    "end": "838560"
  },
  {
    "text": "the demo so i'm going to deploy the azure provider first in cube system namespace",
    "start": "838560",
    "end": "845519"
  },
  {
    "text": "and next i'm going to deploy the gcp plugin in the cube system namespace",
    "start": "845519",
    "end": "852320"
  },
  {
    "text": "and if you take a quick look on all the pods so now we have a driver",
    "start": "852320",
    "end": "857440"
  },
  {
    "text": "and then we have an azure plug-in running in cube system and a gcp plug-in running in cube system",
    "start": "857440",
    "end": "864639"
  },
  {
    "text": "so let's take a look at what the pod spec looks for this application",
    "start": "864720",
    "end": "871760"
  },
  {
    "text": "which is just reading secrets from the file system so we have a pod and it has a volume",
    "start": "871760",
    "end": "878320"
  },
  {
    "text": "mount and it's mounting the volumes into mount sql store here we can see that it has a csi volume",
    "start": "878320",
    "end": "886000"
  },
  {
    "text": "the driver name is the name of the secret store csi driver and the secret provider class is csispc",
    "start": "886000",
    "end": "893279"
  },
  {
    "text": "so this is familiar to what we just looked at in the presentation",
    "start": "893279",
    "end": "899399"
  },
  {
    "text": "let's also look at what the secret provider class uh looks like for this",
    "start": "900320",
    "end": "906000"
  },
  {
    "text": "particular um for accessing secrets from azure keyword so when you see here",
    "start": "906000",
    "end": "913760"
  },
  {
    "text": "we have provider set to azure in the secret provider class and these are the provider specific parameters that's",
    "start": "913760",
    "end": "920800"
  },
  {
    "text": "required for accessing the secret so here we have the keyword name which is kind kb and object name secret one so",
    "start": "920800",
    "end": "928320"
  },
  {
    "text": "we're trying to retrieve secret one which is of type secret from keyword kind kv",
    "start": "928320",
    "end": "934160"
  },
  {
    "text": "let's also quickly look at what the secret provider class looks like for the google provider here the provider is gcp",
    "start": "934160",
    "end": "942000"
  },
  {
    "text": "and in the parameters for resource name we have the resource id of the secret that we are trying to fetch and the file",
    "start": "942000",
    "end": "948800"
  },
  {
    "text": "name here is used for writing it in the container",
    "start": "948800",
    "end": "954399"
  },
  {
    "text": "so now i'm actually going to deploy the azure secret provider class in azure",
    "start": "954399",
    "end": "960160"
  },
  {
    "text": "namespace and then the gcpc will provide a class in the gcp namespace",
    "start": "960160",
    "end": "968360"
  },
  {
    "text": "now that we have the secret provider class created in both the namespaces i am going to deploy the exact same port",
    "start": "968480",
    "end": "976240"
  },
  {
    "text": "spec without any changes in azure namespace",
    "start": "976240",
    "end": "981519"
  },
  {
    "text": "and also the gcp namespace so if you see here i have the exact same pod yaml",
    "start": "981519",
    "end": "987360"
  },
  {
    "text": "which is referencing a secret provider class that's being deployed in two different namespaces which means it's accessing two different",
    "start": "987360",
    "end": "993600"
  },
  {
    "text": "secret store buttons so when these pods get scheduled onto a",
    "start": "993600",
    "end": "998720"
  },
  {
    "text": "node the cubelet sees the volume definition and based on the csi volume",
    "start": "998720",
    "end": "1004720"
  },
  {
    "text": "the driver name it invokes the csi driver to mount the volume the csr",
    "start": "1004720",
    "end": "1010480"
  },
  {
    "text": "driver will mount the temp fs and make an rpc call to the driver to fetch and write the secrets to the file system",
    "start": "1010480",
    "end": "1018000"
  },
  {
    "text": "okay now let's check the pod mount to see if the secret",
    "start": "1018000",
    "end": "1023199"
  },
  {
    "text": "exists so we can see that we are exiting into the csi pod in azure",
    "start": "1023199",
    "end": "1028959"
  },
  {
    "text": "name space and then we're looking at the volume mount path and then we can see there is a file secret one",
    "start": "1028959",
    "end": "1034558"
  },
  {
    "text": "let's also look what's the content of secret one and we can see it's hello from azure",
    "start": "1034559",
    "end": "1040480"
  },
  {
    "text": "keyword which was the same as what we saw when we were directly trying to access using the apis",
    "start": "1040480",
    "end": "1047280"
  },
  {
    "text": "so now let's quickly check the logs for the csi port in azure namespace just to",
    "start": "1047280",
    "end": "1053360"
  },
  {
    "text": "confirm it's working as expected and then if you look at the same csi pod",
    "start": "1053360",
    "end": "1058559"
  },
  {
    "text": "which is reading from the file system in gcp namespace it has a secret from google",
    "start": "1058559",
    "end": "1064080"
  },
  {
    "text": "secret manager so there you go with this you can see that the exact",
    "start": "1064080",
    "end": "1069440"
  },
  {
    "text": "same application without any changes to the pod yaml is able to fetch secrets from google",
    "start": "1069440",
    "end": "1076160"
  },
  {
    "text": "secret manager as well as from azure keyword",
    "start": "1076160",
    "end": "1081320"
  },
  {
    "text": "so we talked about the driver also supporting sync as kubernetes secret",
    "start": "1086080",
    "end": "1092160"
  },
  {
    "text": "the csi driver provides an optional feature to sync the mounted content from the pod as a kubernetes secret",
    "start": "1092160",
    "end": "1098720"
  },
  {
    "text": "a common usage of this feature is to store the tls certificates in",
    "start": "1098720",
    "end": "1104240"
  },
  {
    "text": "external secret store and have the driver sync it as a kubernetes tls",
    "start": "1104240",
    "end": "1109280"
  },
  {
    "text": "secret and then that can be used with ingress controllers so in addition to the synced kubernetes",
    "start": "1109280",
    "end": "1115840"
  },
  {
    "text": "secret they can also be referenced in the pod spec to set environment variables if required",
    "start": "1115840",
    "end": "1122960"
  },
  {
    "text": "um as you can see in the secret provider class there is an optional secret objects field which is used to indicate",
    "start": "1122960",
    "end": "1129360"
  },
  {
    "text": "that the mounted content also needs to be synced as kubernetes secret",
    "start": "1129360",
    "end": "1135880"
  },
  {
    "text": "secret auto rotation um so a generally acceptable best practice is to periodically rotate your",
    "start": "1136880",
    "end": "1142960"
  },
  {
    "text": "secrets so if your external secret store has automatic rotation feature you may be interested in how the workload that's",
    "start": "1142960",
    "end": "1150320"
  },
  {
    "text": "running on your kubernetes cluster can get the new values of a secret whenever it changes",
    "start": "1150320",
    "end": "1156880"
  },
  {
    "text": "the driver supports rotation automatic rotation by periodically reissuing the",
    "start": "1156880",
    "end": "1163520"
  },
  {
    "text": "rpc calls that we looked at are to the provider to refresh the mount",
    "start": "1163520",
    "end": "1169120"
  },
  {
    "text": "once the rotation is successfully done in the mount the driver will also emit a kubernetes event to indicate that a",
    "start": "1169120",
    "end": "1176640"
  },
  {
    "text": "rotation is successfully complete in addition if the mounted content was also synced",
    "start": "1176640",
    "end": "1183200"
  },
  {
    "text": "as a kubernetes secret then the driver will also go and update the values in the kubernetes secret",
    "start": "1183200",
    "end": "1191720"
  },
  {
    "text": "so we talked about two features um let's also jump into a demo to look at how the",
    "start": "1192160",
    "end": "1197760"
  },
  {
    "text": "driver does um the syncing is kubernetes secret",
    "start": "1197760",
    "end": "1203279"
  },
  {
    "text": "so in for this part of the demo you're going to do it with two steps the first one that we're",
    "start": "1204240",
    "end": "1209600"
  },
  {
    "text": "going to look at is how the driver can sync the mounted content as kubernetes secret um so the first thing we're going",
    "start": "1209600",
    "end": "1216000"
  },
  {
    "text": "to do for this is we're going to enable an application to work with nginx",
    "start": "1216000",
    "end": "1221520"
  },
  {
    "text": "english controller and we're going to store our tls certificates in keyword and access them",
    "start": "1221520",
    "end": "1227919"
  },
  {
    "text": "using the driver so i've already created a certificate a",
    "start": "1227919",
    "end": "1235520"
  },
  {
    "text": "self-signed certificate for localhost using a step using the step cli um so let's inspect the certificate before we",
    "start": "1235520",
    "end": "1242960"
  },
  {
    "text": "actually import it to azure keyword so if you look at this certificate you",
    "start": "1242960",
    "end": "1249039"
  },
  {
    "text": "can see that it's for localhost and in terms of expiry this certificate is set",
    "start": "1249039",
    "end": "1254559"
  },
  {
    "text": "to expire on march 10th um so i'm going to",
    "start": "1254559",
    "end": "1259760"
  },
  {
    "text": "import this certificate into azure keyword with the name ingresscert",
    "start": "1259760",
    "end": "1268400"
  },
  {
    "text": "and now for the demo we also want to deploy the english",
    "start": "1272320",
    "end": "1277440"
  },
  {
    "text": "controller so here we are deploying the ingress",
    "start": "1277440",
    "end": "1282720"
  },
  {
    "text": "nginx controller on the kind cluster while the egress controller is starting",
    "start": "1282720",
    "end": "1288880"
  },
  {
    "text": "up and running let's look at what the secret provider class looks like for",
    "start": "1288880",
    "end": "1294080"
  },
  {
    "text": "this sync as kubernetes secret so if we see here the provider azure",
    "start": "1294080",
    "end": "1299600"
  },
  {
    "text": "which is pretty standard as we saw in the last demo but here now we have this additional",
    "start": "1299600",
    "end": "1305919"
  },
  {
    "text": "field called secret objects and then the secret name here signifies what the name",
    "start": "1305919",
    "end": "1311200"
  },
  {
    "text": "of the kubernetes secret should be and the type is what the driver will set",
    "start": "1311200",
    "end": "1317840"
  },
  {
    "text": "when creating the kubernetes secret and then the keys are what are the keys that are required for the secret type",
    "start": "1317840",
    "end": "1326080"
  },
  {
    "text": "so i'm going to deploy the secret provider class in default name space",
    "start": "1326480",
    "end": "1332799"
  },
  {
    "text": "and then i have a single file which defines the pod the services and the",
    "start": "1332799",
    "end": "1338720"
  },
  {
    "text": "interest so let's take a look at that so here i have a pod which is called foo app and it has a",
    "start": "1338720",
    "end": "1344880"
  },
  {
    "text": "volume mount and in volumes it's referencing the secrets to our csi drivers",
    "start": "1344880",
    "end": "1352000"
  },
  {
    "text": "and we have a service to expose that part and then similarly we have another power port called bar app which has a",
    "start": "1352400",
    "end": "1359360"
  },
  {
    "text": "service exposing it and then finally we have an ingress resource um which",
    "start": "1359360",
    "end": "1365039"
  },
  {
    "text": "is set up to use tls uh the secret name here that we have defined is the same secret that the",
    "start": "1365039",
    "end": "1372080"
  },
  {
    "text": "secret store csi driver is going to create and in terms of the rules we have a slash",
    "start": "1372080",
    "end": "1378320"
  },
  {
    "text": "flu and then a slash bar for validation so now we're going to apply this yaml",
    "start": "1378320",
    "end": "1383919"
  },
  {
    "text": "which deploys the pods the services and the english resources",
    "start": "1383919",
    "end": "1389039"
  },
  {
    "text": "so let's check if the pods are up and running so here we can see that the bar app and",
    "start": "1389039",
    "end": "1396400"
  },
  {
    "text": "the foo app power pods are up and running let's check if the csi driver",
    "start": "1396400",
    "end": "1401840"
  },
  {
    "text": "actually created the english tls csi secret so we see that it's there in the name in the",
    "start": "1401840",
    "end": "1407840"
  },
  {
    "text": "default namespace let's also look at the yaml file",
    "start": "1407840",
    "end": "1413760"
  },
  {
    "text": "so here we can see that the csi driver created the secret with tls.cert and tls.key as the template provided by the",
    "start": "1413760",
    "end": "1421600"
  },
  {
    "text": "user and in the labels you can see that it's this resource was created and it is",
    "start": "1421600",
    "end": "1428240"
  },
  {
    "text": "being managed by the secret store csi driver so the first thing we're going to try is",
    "start": "1428240",
    "end": "1434559"
  },
  {
    "text": "we're going to try and curl the endpoint to see which certificate is being used",
    "start": "1434559",
    "end": "1440480"
  },
  {
    "text": "so if we see here we can actually see it's using the certificate that we uploaded azure keyword that was um",
    "start": "1440480",
    "end": "1448240"
  },
  {
    "text": "mounted into the pod by the csi driver so the expiry date is march 10th which",
    "start": "1448240",
    "end": "1453520"
  },
  {
    "text": "is what we looked at in the certificate so we also talked about the secret provider class part status before in the",
    "start": "1453520",
    "end": "1460640"
  },
  {
    "text": "presentation so let's quickly look at the secret provider class part status here to see what version of the",
    "start": "1460640",
    "end": "1467520"
  },
  {
    "text": "certificate is currently in the pod so if we see here we can see that the secret ingress cert is in the pod",
    "start": "1467520",
    "end": "1475200"
  },
  {
    "text": "and then the version that it's currently running has starts with 6498",
    "start": "1475200",
    "end": "1481679"
  },
  {
    "text": "now for the second part of the demo let's actually try the rotation",
    "start": "1481679",
    "end": "1486960"
  },
  {
    "text": "with the current setup and also with the portability setup that we have before",
    "start": "1486960",
    "end": "1492640"
  },
  {
    "text": "so for the ingress rotation demo i've already created another self-sign certificate with a",
    "start": "1492640",
    "end": "1500640"
  },
  {
    "text": "longer validity uh so when we inspect it with openssl we can see that",
    "start": "1500640",
    "end": "1506400"
  },
  {
    "text": "the validity for the new certificate that i have is march 18th instead of march 10th",
    "start": "1506400",
    "end": "1513120"
  },
  {
    "text": "so i'm going to import this rotated circuit into azure keyword",
    "start": "1513120",
    "end": "1520559"
  },
  {
    "text": "um the auto rotation feature in the secret store csi driver should enable us to fetch the new rotated certificate",
    "start": "1520559",
    "end": "1527279"
  },
  {
    "text": "from azure keyboard and update the mount and the synced kubernetes secret so now when i try to curl the same",
    "start": "1527279",
    "end": "1535520"
  },
  {
    "text": "endpoint that i call before we expect to see the certificate returned to have an",
    "start": "1535520",
    "end": "1540559"
  },
  {
    "text": "expiry of march 18th instead of march 10th so let's try that out",
    "start": "1540559",
    "end": "1547919"
  },
  {
    "text": "sure so now when we look at it we can see that the expiry date is changed to march 18th",
    "start": "1551440",
    "end": "1558000"
  },
  {
    "text": "this is because the driver updated the mount and it also updated the sync kubernetes secret",
    "start": "1558000",
    "end": "1563679"
  },
  {
    "text": "the ingress controller picks up the updated kubernetes secret and then reloads the certificate",
    "start": "1563679",
    "end": "1570080"
  },
  {
    "text": "now let's also look at our secret provider class part status to confirm",
    "start": "1570080",
    "end": "1576000"
  },
  {
    "text": "the secret version that's being used in the pod is not different so now we can see the",
    "start": "1576000",
    "end": "1582480"
  },
  {
    "text": "version is nine four seven five which is different from six four which was before",
    "start": "1582480",
    "end": "1588559"
  },
  {
    "text": "um we also i also said that i will do this the rotation demo with the first",
    "start": "1588559",
    "end": "1594159"
  },
  {
    "text": "setup that we had um so let's try that so i'm going to rotate the secrets that",
    "start": "1594159",
    "end": "1599840"
  },
  {
    "text": "were used by the application that was used as part of the pod portability demo to see if it can pick up the latest",
    "start": "1599840",
    "end": "1606320"
  },
  {
    "text": "value so the application that was used in the first demo watches the file system and it basically",
    "start": "1606320",
    "end": "1613679"
  },
  {
    "text": "reads the file from there and logs it um and then it also has file watcher implemented which means anytime there is",
    "start": "1613679",
    "end": "1620480"
  },
  {
    "text": "a change in the file system it will automatically pick up the new value and then log back so let's tail the logs",
    "start": "1620480",
    "end": "1627440"
  },
  {
    "text": "before i actually go and rotate the secret in azure keyword so if if you see",
    "start": "1627440",
    "end": "1634000"
  },
  {
    "text": "here it is log yellow from azure keyword which is during the startup",
    "start": "1634000",
    "end": "1639440"
  },
  {
    "text": "so now i'm going to go and rotate secret one to say i am rotated",
    "start": "1639440",
    "end": "1646960"
  },
  {
    "text": "so when i do this i'm updating the secret in azure keyword and tada if we see we can see that the driver has",
    "start": "1647600",
    "end": "1654320"
  },
  {
    "text": "updated the content in the mount for the pod and it was able to pick up the",
    "start": "1654320",
    "end": "1660159"
  },
  {
    "text": "latest value using the file watcher implementation",
    "start": "1660159",
    "end": "1665640"
  },
  {
    "text": "so we've looked at all these demos and i'm sure the next question is what is",
    "start": "1673039",
    "end": "1678080"
  },
  {
    "text": "the current state of the project so the secret store csi driver core functionality is stable um this includes",
    "start": "1678080",
    "end": "1686559"
  },
  {
    "text": "the interface defined for supporting multiple external secrets provider uh port portability with secret provider",
    "start": "1686559",
    "end": "1693600"
  },
  {
    "text": "class custom resource so you have a single yaml file which references a secret product class and if you want to",
    "start": "1693600",
    "end": "1700320"
  },
  {
    "text": "move it from a single secret store to an egg to a different external secret store",
    "start": "1700320",
    "end": "1705600"
  },
  {
    "text": "there are no changes required for the yaml file and in terms of the feature parity for linux and windows containers",
    "start": "1705600",
    "end": "1711840"
  },
  {
    "text": "uh the driver is stable",
    "start": "1711840",
    "end": "1716000"
  },
  {
    "text": "so what does the future look like for the secret store csr driver um the auto rotation feature that we talked about is",
    "start": "1717520",
    "end": "1724799"
  },
  {
    "text": "currently in alpha we are working towards moving this feature to stable",
    "start": "1724799",
    "end": "1730399"
  },
  {
    "text": "by reusing some of the csi core functionality so csi has a requires",
    "start": "1730399",
    "end": "1736960"
  },
  {
    "text": "republish feature uh in which scenario cubelet will automatically issue an rpc call",
    "start": "1736960",
    "end": "1743440"
  },
  {
    "text": "periodically to update the mount uh by using this we can actually",
    "start": "1743440",
    "end": "1748880"
  },
  {
    "text": "uh get rid of the controller that we have in the csi driver that handles the rotation today",
    "start": "1748880",
    "end": "1755600"
  },
  {
    "text": "and then we are also looking forward to more community involvement uh so if you're interested in adding a",
    "start": "1755600",
    "end": "1761600"
  },
  {
    "text": "new provider for the csi driver or have feature requests reach out to us on slack or on github",
    "start": "1761600",
    "end": "1769600"
  },
  {
    "text": "if you would like to get involved you can join the csi secrets channel in kubernetes lag",
    "start": "1771279",
    "end": "1777919"
  },
  {
    "text": "we also have a mailing list for notifications on releases and security",
    "start": "1777919",
    "end": "1782960"
  },
  {
    "text": "announcements we use github issues to track bugs or feature requests or to answer any",
    "start": "1782960",
    "end": "1790080"
  },
  {
    "text": "questions that you might have asynchronously also we hold a bi-weekly community",
    "start": "1790080",
    "end": "1795679"
  },
  {
    "text": "meeting um it's every thursday at 11 p.m every bi-weekly thursday at 11 pm est",
    "start": "1795679",
    "end": "1804639"
  },
  {
    "text": "and in terms of the resources here are some resources from the presentation um so there is a documentation link to the",
    "start": "1806320",
    "end": "1813360"
  },
  {
    "text": "driver and then also the github repo link to the driver um each provider have",
    "start": "1813360",
    "end": "1819120"
  },
  {
    "text": "their own specific documentation in terms of what are required for the secret provider class so there's links",
    "start": "1819120",
    "end": "1824640"
  },
  {
    "text": "to documentation for the individual providers and for the demo i've reused some of",
    "start": "1824640",
    "end": "1832080"
  },
  {
    "text": "what i've used during my cube contact so all the artifacts that i've used today",
    "start": "1832080",
    "end": "1837679"
  },
  {
    "text": "are available in that github repo thank you",
    "start": "1837679",
    "end": "1845240"
  }
]