[
  {
    "start": "0",
    "end": "24000"
  },
  {
    "text": "hello everyone and welcome to building a software-defined network using kubernetes api machinery and",
    "start": "80",
    "end": "5359"
  },
  {
    "text": "controllers my name is matteo libby and i'm a recent computer engineering master's graduate from the university of",
    "start": "5359",
    "end": "11599"
  },
  {
    "text": "bologna this talk is about a project i worked on while i was an intern at ibm jointly with my background supervisor",
    "start": "11599",
    "end": "18320"
  },
  {
    "text": "mike mike spritzer the project is on github and we hope to contribute soon to the kubernetes",
    "start": "18320",
    "end": "23840"
  },
  {
    "text": "examples repo so let's begin by answering the fundamental question which is",
    "start": "23840",
    "end": "29199"
  },
  {
    "start": "24000",
    "end": "66000"
  },
  {
    "text": "why even building an sdn using kubernetes api machinery and controller pattern and the answer is that we wanted to test",
    "start": "29199",
    "end": "36000"
  },
  {
    "text": "and demonstrate that those are general enough and good building blocks not just for kubernetes but for other",
    "start": "36000",
    "end": "41280"
  },
  {
    "text": "cloud control planes as well and so we built costs or kubernetes open with which sdn",
    "start": "41280",
    "end": "46719"
  },
  {
    "text": "kubernetes because it's built with kubernetes api machinery and controller pattern sdn because it manages vxlan virtual",
    "start": "46719",
    "end": "53440"
  },
  {
    "text": "networks and open with switch because the data plane of the virtual networks is built by configuring openvis which",
    "start": "53440",
    "end": "59440"
  },
  {
    "text": "virtual switches as a warning cost is not for production and it only runs on linux so it's only a",
    "start": "59440",
    "end": "64799"
  },
  {
    "text": "proof of concept so let's set the agenda before we move forward we're going to begin with a",
    "start": "64799",
    "end": "70159"
  },
  {
    "start": "66000",
    "end": "86000"
  },
  {
    "text": "short background on dxlan and the kubernetes controller pattern and then we're going to dive into the",
    "start": "70159",
    "end": "75280"
  },
  {
    "text": "api of course into its architecture and finally we're going to discuss some technical problems that we had to solve",
    "start": "75280",
    "end": "81759"
  },
  {
    "text": "and that we believe have a relevance beyond just our proof of concept sdm so vxlan",
    "start": "81759",
    "end": "88400"
  },
  {
    "start": "86000",
    "end": "142000"
  },
  {
    "text": "the x9 is a protocol for overlaying virtualized ethernet networks on top of an underlay of ip networks",
    "start": "88400",
    "end": "95040"
  },
  {
    "text": "and it provides isolation between different virtual networks as well as the illusion to resources",
    "start": "95040",
    "end": "100479"
  },
  {
    "text": "within the same vehicle network of being located within the same physical network even though that's not true",
    "start": "100479",
    "end": "105920"
  },
  {
    "text": "and it achieves this via vxlan encapsulation so what happens if two communicating",
    "start": "105920",
    "end": "111119"
  },
  {
    "text": "parties exchange data and are within the same virtual network is that the packets or ethernet frames",
    "start": "111119",
    "end": "116960"
  },
  {
    "text": "that they exchange will make use of their virtual addresses but those have no meaning on the underlying network",
    "start": "116960",
    "end": "122799"
  },
  {
    "text": "and so what happens that transparently their traffic is intercepted and encapsulated into vxlan packets",
    "start": "122799",
    "end": "129360"
  },
  {
    "text": "that will be routed over the underlay network and that will make use of the ip addresses in use on the underlay network",
    "start": "129360",
    "end": "135760"
  },
  {
    "text": "rather than a virtual ones and the problem that cost solves is that of dynamically configuring vxlan",
    "start": "135760",
    "end": "141280"
  },
  {
    "text": "overlay networks so next introductory topic the kubernetes controller pattern",
    "start": "141280",
    "end": "147360"
  },
  {
    "start": "142000",
    "end": "185000"
  },
  {
    "text": "in kubernetes we have api objects and api objects have two sections the spec that describes the desired",
    "start": "147360",
    "end": "152800"
  },
  {
    "text": "state of the api object and the status which is a report on the observed state and the kubernetes control plane",
    "start": "152800",
    "end": "159120"
  },
  {
    "text": "consists of a series of control loops that or controllers as they're called",
    "start": "159120",
    "end": "164239"
  },
  {
    "text": "that constantly listen for notifications on api objects and react to them by asynchronous by",
    "start": "164239",
    "end": "169599"
  },
  {
    "text": "asynchronously processing the api objects and processing typically begins by reading the desired state of the api",
    "start": "169599",
    "end": "175440"
  },
  {
    "text": "object modifying the real state of the real world to drive it towards the desired state",
    "start": "175440",
    "end": "180959"
  },
  {
    "text": "and then by writing back the new state of the real world into the status of the api object",
    "start": "180959",
    "end": "186159"
  },
  {
    "start": "185000",
    "end": "279000"
  },
  {
    "text": "and these controllers are not built from scratch but by using standard building blocks collectively known as api",
    "start": "186159",
    "end": "192159"
  },
  {
    "text": "machinery and by following a more or less standard design pattern known as the kubernetes",
    "start": "192159",
    "end": "197440"
  },
  {
    "text": "controller pattern and a really important building block is the informer an informer is an abstraction to receive notifications on",
    "start": "197440",
    "end": "204799"
  },
  {
    "text": "all our subset of api objects of a certain type from the api servers and it also maintains a local cache with",
    "start": "204799",
    "end": "211200"
  },
  {
    "text": "the most recent version of each api object for which a notification was received",
    "start": "211200",
    "end": "217120"
  },
  {
    "text": "and reception of one such notification triggers execution of what's called a notification handler which is a small",
    "start": "217120",
    "end": "224000"
  },
  {
    "text": "function that typically puts a reference to the api object the notification is about in a work view and these references are",
    "start": "224000",
    "end": "231200"
  },
  {
    "text": "usually the namespace names of the api objects and references are extracted from the",
    "start": "231200",
    "end": "236879"
  },
  {
    "text": "work queue by a pool of worker threads that use them to retrieve the whole api",
    "start": "236879",
    "end": "242080"
  },
  {
    "text": "object associated to the reference from the cache of the informer and then do the actual processing on that api object",
    "start": "242080",
    "end": "248480"
  },
  {
    "text": "two things are worth mentioning here the first one is that informers are eventually consistent",
    "start": "248480",
    "end": "253680"
  },
  {
    "text": "so if an api object goes through a sequence of states there's no guarantee that there will be",
    "start": "253680",
    "end": "258880"
  },
  {
    "text": "a notification for each intermediate states rather those might be skipped and so the resulting behavior is level based",
    "start": "258880",
    "end": "265360"
  },
  {
    "text": "and second the work queue provides implicit locking on the references in it so i don't have time for the details but",
    "start": "265360",
    "end": "271120"
  },
  {
    "text": "what this concretely means is that we have the guarantee that at any given time there will be at most one",
    "start": "271120",
    "end": "276320"
  },
  {
    "text": "worker processing a given object reference okay we've concluded",
    "start": "276320",
    "end": "281759"
  },
  {
    "start": "279000",
    "end": "310000"
  },
  {
    "text": "the background now we can look at cos itself and let's begin by its api users interact with cost just like they do",
    "start": "281759",
    "end": "288479"
  },
  {
    "text": "with kubernetes by creating updating and deleting api objects and cos defines three custom",
    "start": "288479",
    "end": "293919"
  },
  {
    "text": "api object types served by custom api servers and these custom types are the subnet the network attachment",
    "start": "293919",
    "end": "300960"
  },
  {
    "text": "that you'll see abbreviated to n a for the rest of the slides and the ip lock",
    "start": "300960",
    "end": "306080"
  },
  {
    "text": "we'll talk about ip logs later in the talk now let's focus on the first two",
    "start": "306080",
    "end": "311440"
  },
  {
    "text": "and in this slide you see examples of them and on the left you see a subnet api object and a subnet describes an",
    "start": "311440",
    "end": "316880"
  },
  {
    "text": "ipv4 subnet within a vxlan virtual network and so its spec has a field called vmi which",
    "start": "316880",
    "end": "324080"
  },
  {
    "text": "contains a unique numeric identifier of the vxlan virtual network the subnet is part of and it's packed",
    "start": "324080",
    "end": "330880"
  },
  {
    "text": "and as subnet spec also is a field which describes the pool of ip addresses allocatable to resources within that",
    "start": "330880",
    "end": "337520"
  },
  {
    "text": "subnet subnet also have a status field more on that later on the right you see a network",
    "start": "337520",
    "end": "342880"
  },
  {
    "text": "attachment api object and a network attachment describes a network interface within a vxlan",
    "start": "342880",
    "end": "349039"
  },
  {
    "text": "virtual network and its pack has a subnet field with the name of the subnet api object the network",
    "start": "349039",
    "end": "355199"
  },
  {
    "text": "attachment is part of and the cost control plane will choose an ip address from that subnet",
    "start": "355199",
    "end": "360800"
  },
  {
    "text": "and assign it to the network attachment by writing it into its status guest id field and the cost control plane we also write",
    "start": "360800",
    "end": "367360"
  },
  {
    "text": "other status field of a network attachment such as the gas mag field which stores the vehicle mac address",
    "start": "367360",
    "end": "372960"
  },
  {
    "text": "of the network attachment and it will also write into the status the vni of the network attachment which is",
    "start": "372960",
    "end": "378880"
  },
  {
    "text": "again the unique numeric identifier of the vxlan virtual network where the network attachment is",
    "start": "378880",
    "end": "384800"
  },
  {
    "text": "so network attachments somehow represents the nodes in a vxlan overlay network and so they",
    "start": "384800",
    "end": "390960"
  },
  {
    "text": "must be bound and implemented on a node of the underlay network and so their spec have a node field",
    "start": "390960",
    "end": "397280"
  },
  {
    "text": "that contains the name of the underlay network where they will be implemented and cos further writes the status of",
    "start": "397280",
    "end": "403360"
  },
  {
    "text": "network attachments by writing it to the ip address of the underlay node where they're implemented",
    "start": "403360",
    "end": "409520"
  },
  {
    "text": "finally notice that vxm virtual networks are not explicitly described by api objects",
    "start": "409520",
    "end": "414720"
  },
  {
    "text": "but they're only identified through a unique numeric identifier which is again the vni and so for the reminder of this talk be",
    "start": "414720",
    "end": "421520"
  },
  {
    "text": "aware that i will be using the terms vmi and vxlan virtual network as synonyms",
    "start": "421520",
    "end": "427199"
  },
  {
    "start": "426000",
    "end": "475000"
  },
  {
    "text": "so cos has to implement network attachments and it does so by assigning to each network attachment",
    "start": "427199",
    "end": "432240"
  },
  {
    "text": "a virtual ip address a virtual mac address and by creating for it a linux network interface on the underlay node of the",
    "start": "432240",
    "end": "439199"
  },
  {
    "text": "network attachment and the network interfaces of different network attachments that are within the",
    "start": "439199",
    "end": "444720"
  },
  {
    "text": "same vxl and visual network must be able to communicate with each other via vxlan encapsulation",
    "start": "444720",
    "end": "450560"
  },
  {
    "text": "and so on every underlay node there's a virtual switch and cos further implements each network attachment by",
    "start": "450560",
    "end": "457759"
  },
  {
    "text": "connecting its network interface to the virtual switch on its underlay node and by configuring that virtual switch",
    "start": "457759",
    "end": "464240"
  },
  {
    "text": "to encapsulate and decapsulate all the traffic that is sent and received from the network interface",
    "start": "464240",
    "end": "470479"
  },
  {
    "text": "and encapsulation and encapsulation is performed as described by the vxlan protocol",
    "start": "470479",
    "end": "476560"
  },
  {
    "start": "475000",
    "end": "537000"
  },
  {
    "text": "so we've seen its api now we can look at its architecture oh i'm sorry i'm talking about cos",
    "start": "476560",
    "end": "481759"
  },
  {
    "text": "and it's very similar to kubernetes architecture there's a group of api of custom api servers that serve the",
    "start": "481759",
    "end": "488080"
  },
  {
    "text": "custom api objects and those custom api objects are stored in a dedicated lcd cluster",
    "start": "488080",
    "end": "493520"
  },
  {
    "text": "and are implemented by a group of custom controllers that are built not from scratch but by",
    "start": "493520",
    "end": "498879"
  },
  {
    "text": "using the standard kubernetes api machinery building blocks that i've mentioned before",
    "start": "498879",
    "end": "504080"
  },
  {
    "text": "such as informer and work you and worker threads and more precisely there are three custom controllers and you see two of",
    "start": "504080",
    "end": "511280"
  },
  {
    "text": "them on the top right of this slide which are the subnet validator and the item controller those are single tones",
    "start": "511280",
    "end": "517039"
  },
  {
    "text": "but more on them later and then on every underlay node or worker node as we call them there's a cos agent",
    "start": "517039",
    "end": "524000"
  },
  {
    "text": "called connection agent which is responsible of implementing the network attachments",
    "start": "524000",
    "end": "529680"
  },
  {
    "text": "that are bound to its node in the way i described in the previous slide and it does so by interacting with a local",
    "start": "529680",
    "end": "535440"
  },
  {
    "text": "openviswitch daemon finally cos currently gets deployed as a",
    "start": "535440",
    "end": "540800"
  },
  {
    "start": "537000",
    "end": "556000"
  },
  {
    "text": "kubernetes workload so all of its components including api servers and ncd run within",
    "start": "540800",
    "end": "546399"
  },
  {
    "text": "pods managed by a kubernetes cluster via deployment or a demon set however conceptually nothing forbids you from",
    "start": "546399",
    "end": "554000"
  },
  {
    "text": "deploying costs as a standalone system so okay we've concluded a high level",
    "start": "554000",
    "end": "559279"
  },
  {
    "start": "556000",
    "end": "620000"
  },
  {
    "text": "overview of costs now we can discuss some specific technical problems that we had to solve and that we believe",
    "start": "559279",
    "end": "564640"
  },
  {
    "text": "have a relevance beyond just cos and the first problem is that of enforcing an invariant across multiple api objects of",
    "start": "564640",
    "end": "571839"
  },
  {
    "text": "the same type and this arises because remember that we have subnet api objects and we can have multiple subnets that",
    "start": "571839",
    "end": "578640"
  },
  {
    "text": "are within the same example network that is perfectly fine but if that's the case we want the pool",
    "start": "578640",
    "end": "584640"
  },
  {
    "text": "of ip addresses of those subnets to be disjoint and we also want those subnets to be within the same kubernetes",
    "start": "584640",
    "end": "590959"
  },
  {
    "text": "namespace just because it's simpler to think about all the resources within the same bx and",
    "start": "590959",
    "end": "596000"
  },
  {
    "text": "virtual network as being within the same kubernetes namespace and so ideally if existence of a subnet leads to a",
    "start": "596000",
    "end": "602800"
  },
  {
    "text": "violation of one of our current variants creation of that subnet should fail and the only way you can get this behavior",
    "start": "602800",
    "end": "609200"
  },
  {
    "text": "is by validating subnets before they're actually created or by created i mean persistent question",
    "start": "609200",
    "end": "615600"
  },
  {
    "text": "and so the validation logic should reside either in the api servers or in a validating webhook",
    "start": "615600",
    "end": "620959"
  },
  {
    "start": "620000",
    "end": "681000"
  },
  {
    "text": "and it would look something like what you see in this slide so when a subnet s that does not exist",
    "start": "620959",
    "end": "626399"
  },
  {
    "text": "yet is validated you would start by retrieving all the existing subnets in the same vxlan",
    "start": "626399",
    "end": "631440"
  },
  {
    "text": "virtual network as s and then you would compare them one by one to s",
    "start": "631440",
    "end": "636480"
  },
  {
    "text": "and if at least one conflict is found creation of s should fail otherwise it succeeds and what i mean by",
    "start": "636480",
    "end": "641680"
  },
  {
    "text": "conflict is that s and other subnet mutual existence lead to ovulation of an invariant",
    "start": "641680",
    "end": "647279"
  },
  {
    "text": "such as because for instance because their pool of ip addresses overlap so this is good but is not enough",
    "start": "647279",
    "end": "653920"
  },
  {
    "text": "because when s is validated it does not exist yet but is only compared to already existing subnets",
    "start": "653920",
    "end": "659360"
  },
  {
    "text": "so what might go wrong is that two conflicting subnets are valid created and validated more or",
    "start": "659360",
    "end": "665360"
  },
  {
    "text": "less at the same time so they're validated in parallel and so when either one of those two conflicting subnets is validated the",
    "start": "665360",
    "end": "671760"
  },
  {
    "text": "other one is not seen because it does not exist yet and so validation successfully completes",
    "start": "671760",
    "end": "676959"
  },
  {
    "text": "for both subnets which both get created and so our invariants have been violated",
    "start": "676959",
    "end": "682240"
  },
  {
    "start": "681000",
    "end": "726000"
  },
  {
    "text": "and we didn't find a way to guarantee that this cannot happen in cost so we did the next best thing which is",
    "start": "682240",
    "end": "689360"
  },
  {
    "text": "okay if two or more conflicting subnets ever come to exist consumers of subnets will use at most",
    "start": "689360",
    "end": "695279"
  },
  {
    "text": "one of them and ignore the others and we achieve this by giving subnets an additional status field",
    "start": "695279",
    "end": "701120"
  },
  {
    "text": "called validated and cost guarantees that if two or more conflicting subnets ever come to exist",
    "start": "701120",
    "end": "706560"
  },
  {
    "text": "at most one of them will have validated equal to true and that's how consumers will know that that's the subnet that they can use",
    "start": "706560",
    "end": "715120"
  },
  {
    "text": "and we couldn't have validated being written either in the api servers or by a mutating webhook before the subnet is",
    "start": "715120",
    "end": "721440"
  },
  {
    "text": "created because then we would have had the same race condition that i described in the two previous slides",
    "start": "721440",
    "end": "727680"
  },
  {
    "start": "726000",
    "end": "803000"
  },
  {
    "text": "and so we had to introduce a dedicated custom singleton controller the subnet validator whose role is that",
    "start": "727680",
    "end": "734000"
  },
  {
    "text": "of validating subnets by running the exact same logic that i've shown before and by writing the status validated",
    "start": "734000",
    "end": "741519"
  },
  {
    "text": "field of subnets and otherwise the the subnet validator is a pretty standard",
    "start": "741519",
    "end": "746800"
  },
  {
    "text": "controller so it uses an informer to be notified of subnets and it has a work you and pool of worker threads",
    "start": "746800",
    "end": "753360"
  },
  {
    "text": "and the reason validation works in the validator and not in the api servers",
    "start": "753360",
    "end": "758480"
  },
  {
    "text": "is because of two joint reasons really and the first one is that unlike the api server when the validator validates the",
    "start": "758480",
    "end": "763839"
  },
  {
    "text": "subnet that subnet already exists and the second reason is that while subnets may be validated in parallel",
    "start": "763839",
    "end": "770160"
  },
  {
    "text": "they're actually created that is persistent to acidity sequentially so if two or more",
    "start": "770160",
    "end": "775279"
  },
  {
    "text": "conflicting subnets are created more or less at the same time one of them is actually um",
    "start": "775279",
    "end": "782079"
  },
  {
    "text": "created last and so when the validator validates that second subnet that is created last we're",
    "start": "782079",
    "end": "788560"
  },
  {
    "text": "guaranteed that the first subnet already exists and so when the validator",
    "start": "788560",
    "end": "794079"
  },
  {
    "text": "processes the second subnet it will see the other conflicting subnet because it was created first",
    "start": "794079",
    "end": "799200"
  },
  {
    "text": "and this will make validation of the second subnet fail which is exactly what we want",
    "start": "799200",
    "end": "804480"
  },
  {
    "start": "803000",
    "end": "838000"
  },
  {
    "text": "now there's one last subtlety that we have to mention though about the subnet validator and the subtlety sub tool is that when",
    "start": "804480",
    "end": "810880"
  },
  {
    "text": "the validator validates subnet s and it retrieves all the other",
    "start": "810880",
    "end": "816240"
  },
  {
    "text": "existing subnets with in the same vxn virtual network as s it uses a direct list against the api",
    "start": "816240",
    "end": "822320"
  },
  {
    "text": "servers and this might sound odd because remember that the validator has an informer on subnets with a local",
    "start": "822320",
    "end": "828800"
  },
  {
    "text": "cache and so it would be much more efficient to retrieve all the other existing subnets from that informal",
    "start": "828800",
    "end": "834399"
  },
  {
    "text": "cache however there are edge cases where correctness would be violated and these slides shows an example so",
    "start": "834399",
    "end": "841199"
  },
  {
    "start": "838000",
    "end": "954000"
  },
  {
    "text": "assume that the validator retrieves subnets not from the api servers with a direct list but from the",
    "start": "841199",
    "end": "847279"
  },
  {
    "text": "cache of its informer and assume that two conflicting subnets are created more or less at the same",
    "start": "847279",
    "end": "852639"
  },
  {
    "text": "time and also assume that two validators are running at the same time now before i said that the validator is",
    "start": "852639",
    "end": "858480"
  },
  {
    "text": "a singleton and so it's managed by a deployment with a replica field of one but that is no hard guarantee there",
    "start": "858480",
    "end": "865519"
  },
  {
    "text": "could be short transients because for instance because of a network partition when",
    "start": "865519",
    "end": "870720"
  },
  {
    "text": "more than one validator is running at the same time and if this happens the gist of our",
    "start": "870720",
    "end": "875920"
  },
  {
    "text": "problem is that there's no guarantee on the order with which api objects including subnets",
    "start": "875920",
    "end": "881199"
  },
  {
    "text": "are added to informer caches so what might go wrong in this scenario is that at the first",
    "start": "881199",
    "end": "886560"
  },
  {
    "text": "subnet validator the first of the two conflicting subnets is added to the informer cache and validated before the second subnet is",
    "start": "886560",
    "end": "894399"
  },
  {
    "text": "added to the informer cache and so this the first validator doesn't see the second subnet when validating",
    "start": "894399",
    "end": "900000"
  },
  {
    "text": "the first one and so validation of the first subnet um completes successfully and the problem",
    "start": "900000",
    "end": "906320"
  },
  {
    "text": "is that because of the lack of ordering guarantees things might happen in the opposite order at the second validator so what",
    "start": "906320",
    "end": "912639"
  },
  {
    "text": "might go wrong is that the second subnet might be added to the informer cache and validated by the second validator",
    "start": "912639",
    "end": "918800"
  },
  {
    "text": "even before the first subnet is added to its informer cache and so the second validator validates",
    "start": "918800",
    "end": "924720"
  },
  {
    "text": "the first subnet without seeing i'm sorry and so the second validator validates the second subnet without",
    "start": "924720",
    "end": "930880"
  },
  {
    "text": "seeing the first one and so validation of the second subnet successfully completes and so we have",
    "start": "930880",
    "end": "936240"
  },
  {
    "text": "two completing subnets that both have validated equal to true and the only way we found to avoid this",
    "start": "936240",
    "end": "942399"
  },
  {
    "text": "is to make sure that if multiple validators are running they all get a consistent view of which subnets exist and that's what",
    "start": "942399",
    "end": "949440"
  },
  {
    "text": "using direct lists against the aps server and shores at the cost of a worse performance okay we've",
    "start": "949440",
    "end": "956240"
  },
  {
    "start": "954000",
    "end": "1014000"
  },
  {
    "text": "concluded discussion of the first of our technical problems the second problem is that of that we're going to",
    "start": "956240",
    "end": "961920"
  },
  {
    "text": "discuss is that of assigning virtuality addresses to network attachments while avoiding ip collisions and once",
    "start": "961920",
    "end": "968800"
  },
  {
    "text": "again there's a dedicated singleton custom controller for this the ipam controller and the iphone",
    "start": "968800",
    "end": "974639"
  },
  {
    "text": "controller is in charge of assigning addresses to network attachments and it keeps an informer on subnets and it",
    "start": "974639",
    "end": "980560"
  },
  {
    "text": "processes each subnet by initializing any memory set with all the available ids from that",
    "start": "980560",
    "end": "986240"
  },
  {
    "text": "subnet and it also has an informer network attachments and it initializes and it processes a",
    "start": "986240",
    "end": "992959"
  },
  {
    "text": "network attachment by reading the name of its subnet from the spec using that name to retrieve",
    "start": "992959",
    "end": "998560"
  },
  {
    "text": "the set the memory set of available ips from that subnet and then it chooses one ip from that set",
    "start": "998560",
    "end": "1004880"
  },
  {
    "text": "and it assigns it to the network attachment by writing it into that network attachment steps",
    "start": "1004880",
    "end": "1010160"
  },
  {
    "text": "however if this is the only thing the iphone controller does we have a problem and once again the source of our problem",
    "start": "1010160",
    "end": "1016320"
  },
  {
    "start": "1014000",
    "end": "1054000"
  },
  {
    "text": "is that even though the iphone controller is intended to be a singleton there's no guarantee that for instance",
    "start": "1016320",
    "end": "1021680"
  },
  {
    "text": "because of a network partition there will never be more uh icon controllers running",
    "start": "1021680",
    "end": "1028480"
  },
  {
    "text": "and so uh what might go wrong is that if the iphone controller like i've said so far only chooses an",
    "start": "1028480",
    "end": "1034160"
  },
  {
    "text": "address by looking at its in-memory set of available ips what might go wrong is that if two icon",
    "start": "1034160",
    "end": "1039918"
  },
  {
    "text": "controllers are running at the same time they might choose the same idea address and assign it to two different network",
    "start": "1039919",
    "end": "1046319"
  },
  {
    "text": "attachments that are within the same vx and virtual network and so we would have an ip address collision within the same",
    "start": "1046319",
    "end": "1052080"
  },
  {
    "text": "virtual network which we obviously don't want and the solution we found to prevent this from happening",
    "start": "1052080",
    "end": "1057919"
  },
  {
    "text": "is to have the ipad controller attempt to acquire a global lock on an ip address before",
    "start": "1057919",
    "end": "1063520"
  },
  {
    "text": "actually assigning that id and the assignment proceeds only if acquisition of the lock is successful",
    "start": "1063520",
    "end": "1069440"
  },
  {
    "text": "an interesting part is in how the lock is implemented a lock is implemented as an ip lock",
    "start": "1069440",
    "end": "1074799"
  },
  {
    "text": "custom api object an ipl object represents a lock on a virtual ip address within a vxlan",
    "start": "1074799",
    "end": "1081679"
  },
  {
    "text": "virtual network and the interesting part is in its name so for an ip lock",
    "start": "1081679",
    "end": "1087679"
  },
  {
    "text": "on a virtual ip address x within a virtual network that has a vni the name is a unique function of x",
    "start": "1087679",
    "end": "1094240"
  },
  {
    "text": "and y so if two icon controllers attempted to uh lock the same ip address they would",
    "start": "1094240",
    "end": "1100720"
  },
  {
    "text": "attempt to create two ip lock objects that have the same name and that are within the same",
    "start": "1100720",
    "end": "1106160"
  },
  {
    "text": "name space and because kubernetes api for bits naming collisions creation of one of the two locks would",
    "start": "1106160",
    "end": "1112160"
  },
  {
    "text": "fail and the item controller that experiences the failure would react by simply choosing another",
    "start": "1112160",
    "end": "1118559"
  },
  {
    "text": "address to assign its network to its network attachment and this way so uh collisions on ip addresses are",
    "start": "1118559",
    "end": "1125440"
  },
  {
    "text": "avoided okay we've also done we're also done discussing the second technical problem",
    "start": "1125440",
    "end": "1131360"
  },
  {
    "text": "now we can look at the third and final one and this is the problem of dynamic filtering in informers but",
    "start": "1131360",
    "end": "1137520"
  },
  {
    "text": "first we have to understand why we need this so to recap on every worker node or underlay node",
    "start": "1137520",
    "end": "1143039"
  },
  {
    "text": "there's a cos agent called connection agent that is responsible for implementing the local network attachments that is",
    "start": "1143039",
    "end": "1149600"
  },
  {
    "text": "the network attachments that are bound to its underlay node and it implements them by creating for them a linux network interface",
    "start": "1149600",
    "end": "1156240"
  },
  {
    "text": "and configuring a local openviswich virtual switch however if we want those local network",
    "start": "1156240",
    "end": "1162160"
  },
  {
    "text": "attachments to be able to communicate with remote network attachments that are in their own",
    "start": "1162160",
    "end": "1167440"
  },
  {
    "text": "virtual network that alone is not enough and so we say that if on a node there is at least one local network",
    "start": "1167440",
    "end": "1174080"
  },
  {
    "text": "attachment with a vni x vnix is relevant to that node and what",
    "start": "1174080",
    "end": "1179440"
  },
  {
    "text": "this practically means is that a connection agent on a node needs to be notified",
    "start": "1179440",
    "end": "1184960"
  },
  {
    "text": "besides of uh local network attachment oh i'm sorry let me take a step back",
    "start": "1184960",
    "end": "1191039"
  },
  {
    "text": "so the consequence of the fact that the connection agent on a node must implement local network attachments",
    "start": "1191039",
    "end": "1197200"
  },
  {
    "text": "it means that it must keep it means that it must be notified of those local network attachments",
    "start": "1197200",
    "end": "1202640"
  },
  {
    "text": "and so it has an informer on local network attachments however what i was saying is that this",
    "start": "1202640",
    "end": "1208000"
  },
  {
    "text": "informal local network attachments alone is not enough and so as i was saying if",
    "start": "1208000",
    "end": "1213520"
  },
  {
    "text": "on a node there's at least one local network attachment with a vni x we say that vni x is relevant on that",
    "start": "1213520",
    "end": "1219520"
  },
  {
    "text": "node and what this practically means is that a connection agent on a node needs to be notified",
    "start": "1219520",
    "end": "1225120"
  },
  {
    "text": "not only of local network attachments but also of remote network attachments so on other nodes so of network",
    "start": "1225120",
    "end": "1231679"
  },
  {
    "text": "attachments on other nodes that have a relevant bni and this slide shows the y so say that we have two",
    "start": "1231679",
    "end": "1239039"
  },
  {
    "text": "network attachments a and b that are within the same vxlan virtual network and they wanna and and say that but say",
    "start": "1239039",
    "end": "1246240"
  },
  {
    "text": "that they are on two different nodes and now say that the network attachment a wants to send data",
    "start": "1246240",
    "end": "1251760"
  },
  {
    "text": "to network attachment b through its network interface and so a will either send an arp request or an",
    "start": "1251760",
    "end": "1257919"
  },
  {
    "text": "ethernet frame to um the remote network attachment beam and that artwork and that arp request or",
    "start": "1257919",
    "end": "1264960"
  },
  {
    "text": "ethernet frame will use the as the destination the v12 ip address or the virtual mac address of",
    "start": "1264960",
    "end": "1270720"
  },
  {
    "text": "the but those mutual addresses are meaningless on the underlay network and so what happens is that on ace node",
    "start": "1270720",
    "end": "1277840"
  },
  {
    "text": "the vehicles which transparently intercept the the send traffic and encapsulates it into a vxlan packet",
    "start": "1277840",
    "end": "1285440"
  },
  {
    "text": "that can travel on the underlay network and so the destination of this the destination address of this vxlan packet",
    "start": "1285440",
    "end": "1293200"
  },
  {
    "text": "is not the vehicle ip address of the remote network attachment v but it's the ip address of the underlay",
    "start": "1293200",
    "end": "1298480"
  },
  {
    "text": "node of that remote network attachment b is implemented and so the consequence is that to",
    "start": "1298480",
    "end": "1303760"
  },
  {
    "text": "properly do the encapsulation and forwarding the virtual switch on ace node must be",
    "start": "1303760",
    "end": "1309280"
  },
  {
    "text": "aware must be able to map the vni and v12 ip and virtual mac address of the remote",
    "start": "1309280",
    "end": "1315440"
  },
  {
    "text": "network attachment b to the ip address of the underlay node where that remote network attachment b",
    "start": "1315440",
    "end": "1320880"
  },
  {
    "text": "is implemented but the virtual switch alone doesn't do anything so it can only know this mapping if the connection",
    "start": "1320880",
    "end": "1327760"
  },
  {
    "text": "agent on its node on ace node has made it aware of its mapping by",
    "start": "1327760",
    "end": "1333120"
  },
  {
    "text": "appropriately configuring it and so the question becomes how does the connection agent on ace node",
    "start": "1333120",
    "end": "1338640"
  },
  {
    "text": "know the mapping between these vni and virtual addresses to the ip address of the underlay node",
    "start": "1338640",
    "end": "1345280"
  },
  {
    "text": "where b is implemented and the answer is that well this mapping is natively stored only in the api",
    "start": "1345280",
    "end": "1352720"
  },
  {
    "text": "object of the remote network attachment b and so the bottom line is that the connection agent on ace node to properly",
    "start": "1352720",
    "end": "1359919"
  },
  {
    "text": "configure the virtual switch on its node must also be notified of the remote network attachment b",
    "start": "1359919",
    "end": "1365760"
  },
  {
    "text": "even though that network attachment is remote remote like i said so to recap we've introduced the notion",
    "start": "1365760",
    "end": "1372880"
  },
  {
    "start": "1370000",
    "end": "1417000"
  },
  {
    "text": "of relevant dni with respect to node and we've established that to properly configure the virtual switch on its node",
    "start": "1372880",
    "end": "1379440"
  },
  {
    "text": "a connection agent also needs to be notified of the remote network attachments that have a relevant bni and to",
    "start": "1379440",
    "end": "1386080"
  },
  {
    "text": "complicate things notice that the set of dnis that are relevant to a node is dynamic it changes over time so for",
    "start": "1386080",
    "end": "1393039"
  },
  {
    "text": "instance if at one time there are no network attachments that have a vni x on a node",
    "start": "1393039",
    "end": "1398640"
  },
  {
    "text": "the nix is not relevant on that node but as soon as the first network attachment with vnix",
    "start": "1398640",
    "end": "1404559"
  },
  {
    "text": "on that node is created vni x has become relevant from that node and when all the network attachments",
    "start": "1404559",
    "end": "1411760"
  },
  {
    "text": "that have vni x on the node are deleted vni x ceases to be relevant from that node",
    "start": "1411760",
    "end": "1418559"
  },
  {
    "text": "so more concretely our problem is ensuring that a connection agent on a",
    "start": "1418559",
    "end": "1423840"
  },
  {
    "text": "node is notified only of the remote network attachments that have a relevant vmis and none of the other remote network",
    "start": "1423840",
    "end": "1430320"
  },
  {
    "text": "attachments because it doesn't care about those and this is important because we could also say oh we're not going to do that",
    "start": "1430320",
    "end": "1437360"
  },
  {
    "text": "we're just going to keep a unique informer on all remote network attachments and it",
    "start": "1437360",
    "end": "1442799"
  },
  {
    "text": "will be the connection agent itself that manually filters the remote network attachments",
    "start": "1442799",
    "end": "1448400"
  },
  {
    "text": "on the basis of whether the vmi is relevant or not but this would never scale",
    "start": "1448400",
    "end": "1453679"
  },
  {
    "text": "because it would mean that the api servers would have to notify all of the worker nodes of all of the",
    "start": "1453679",
    "end": "1460559"
  },
  {
    "text": "network attachments even though most of those notifications wouldn't be would never be needed",
    "start": "1460559",
    "end": "1466240"
  },
  {
    "text": "and so first i'm sorry our first question was since we're using formers to receive",
    "start": "1466240",
    "end": "1471440"
  },
  {
    "text": "notifications and informers support filtering of api objects on",
    "start": "1471440",
    "end": "1476880"
  },
  {
    "text": "which they receive notifications on the basis of the fields of those api",
    "start": "1476880",
    "end": "1481919"
  },
  {
    "text": "objects so they allow you to express a filter such as give notifications for api objects of",
    "start": "1481919",
    "end": "1487279"
  },
  {
    "text": "this type for whom the field acts as value y our first question was can we configure",
    "start": "1487279",
    "end": "1493840"
  },
  {
    "text": "a single informer to only filter in the remote network attachments that have a relevant bni and the answer is no",
    "start": "1493840",
    "end": "1501360"
  },
  {
    "text": "because um filters informers are only static so you can configure a filter in an",
    "start": "1501360",
    "end": "1507840"
  },
  {
    "text": "informer before you start the informer but you can never change it afterwards whereas",
    "start": "1507840",
    "end": "1513440"
  },
  {
    "text": "what we want is the capability of filtering on the basis of a set of vni",
    "start": "1513440",
    "end": "1520240"
  },
  {
    "text": "values that as we've seen is dynamic changes over time and so our question was how can we",
    "start": "1520240",
    "end": "1526080"
  },
  {
    "text": "synthesize dynamic filtering out of informers with static filtering and the solution that we found was to",
    "start": "1526080",
    "end": "1532880"
  },
  {
    "text": "have a dedicated informer for each relevant vni so if on a node",
    "start": "1532880",
    "end": "1538480"
  },
  {
    "text": "there are p relevant dni's the connection agent on that node will have besides of an informer on local network",
    "start": "1538480",
    "end": "1544400"
  },
  {
    "text": "attachments one informer for each relevant bni that specifically filters in on that",
    "start": "1544400",
    "end": "1552960"
  },
  {
    "text": "specific vni and as soon as a new vmi becomes relevant the connection agent",
    "start": "1552960",
    "end": "1558720"
  },
  {
    "text": "starts an informer dedicated to that vni and as soon as a vni ceases to be relevant the",
    "start": "1558720",
    "end": "1564240"
  },
  {
    "text": "connection agent stops the informer for that vni",
    "start": "1564240",
    "end": "1570080"
  },
  {
    "start": "1568000",
    "end": "1606000"
  },
  {
    "text": "this ensures efficiency in the delivery of notifications but it introduces a knowledge problem",
    "start": "1570080",
    "end": "1575360"
  },
  {
    "text": "that you normally don't have in standard kubernetes controllers and the problem is that if you think about",
    "start": "1575360",
    "end": "1580640"
  },
  {
    "text": "the um kubernetes controller pattern when a worker pops a namespace name or",
    "start": "1580640",
    "end": "1587360"
  },
  {
    "text": "an object reference from the queue it needs to use that namespace name to retrieve the whole api object",
    "start": "1587360",
    "end": "1593039"
  },
  {
    "text": "to process from the cache of an informer but with our design there are potentially a",
    "start": "1593039",
    "end": "1598400"
  },
  {
    "text": "lot of informers one for each relevant vni and so worker doesn't know from which informer to",
    "start": "1598400",
    "end": "1604080"
  },
  {
    "text": "retrieve the network attachment that it must process and so the solution that we found was to",
    "start": "1604080",
    "end": "1609279"
  },
  {
    "start": "1606000",
    "end": "1933000"
  },
  {
    "text": "simply have each connection agent maintain an in-memory map that associates each namespace name to",
    "start": "1609279",
    "end": "1616320"
  },
  {
    "text": "the informers where the network attachment that has that namespace name is stored and this way a worker that pops a",
    "start": "1616320",
    "end": "1622799"
  },
  {
    "text": "namespace name from the work queue begins by consulting this map and this way it learns from which informer to",
    "start": "1622799",
    "end": "1628799"
  },
  {
    "text": "retrieve the network attachment that it must process and entries are added and removed to and",
    "start": "1628799",
    "end": "1635440"
  },
  {
    "text": "from the map by informer notification handlers so for instance when um there's a creation notification for a",
    "start": "1635440",
    "end": "1642080"
  },
  {
    "text": "network attachment for a remote network attachment at the former for vni x the creation",
    "start": "1642080",
    "end": "1647760"
  },
  {
    "text": "notification handler will update the map by adding the entry saying that the namespace name of the",
    "start": "1647760",
    "end": "1654559"
  },
  {
    "text": "network attachment the notification is about must be used to retrieve the network attachment at the informer for vnix",
    "start": "1654559",
    "end": "1661440"
  },
  {
    "text": "and when that same network attachment is deleted and the deletion notification handler executes",
    "start": "1661440",
    "end": "1666960"
  },
  {
    "text": "that deletion notification handler will remove the um the entry from the map now this works",
    "start": "1666960",
    "end": "1674480"
  },
  {
    "text": "but there's one subtlety that we have to be careful with and the subtlety arises because there",
    "start": "1674480",
    "end": "1679840"
  },
  {
    "text": "could be transients during which the same network attachment is stored at the same time into more",
    "start": "1679840",
    "end": "1687440"
  },
  {
    "text": "than one informer cache this problem arises because like any other api object network attachments can be updated but",
    "start": "1687440",
    "end": "1695039"
  },
  {
    "text": "as a result of these updates their vmi their virtual network can change",
    "start": "1695039",
    "end": "1701120"
  },
  {
    "text": "so let's see an example to better understand say that on a node there are two relevant vni's x and y and so on that",
    "start": "1701120",
    "end": "1708960"
  },
  {
    "text": "note there are two informers besides the one for local network attachments one for the remote network attachments",
    "start": "1708960",
    "end": "1715279"
  },
  {
    "text": "that have vni x and one for the remote network attachments that have vni now say that a network attachments that",
    "start": "1715279",
    "end": "1722240"
  },
  {
    "text": "is remote with respect to the node in our example is created and it initially has vni",
    "start": "1722240",
    "end": "1727679"
  },
  {
    "text": "x and say that later it is updated and its vni becomes y so for this network attachment three",
    "start": "1727679",
    "end": "1735279"
  },
  {
    "text": "notifications will be received at the node in our example first there will be a creation",
    "start": "1735279",
    "end": "1740399"
  },
  {
    "text": "notification at the informer for vnix because that was the first vni of the network attachment and then",
    "start": "1740399",
    "end": "1748320"
  },
  {
    "text": "when the vni of the network attachment changes from x to y there will be two notifications first",
    "start": "1748320",
    "end": "1753760"
  },
  {
    "text": "there will be a delete notification for the network attachment at the informer for vnix that will remove the network attachment",
    "start": "1753760",
    "end": "1760320"
  },
  {
    "text": "from that informer cache because x is no longer the vni of our network attachment and then there will be a creation",
    "start": "1760320",
    "end": "1766559"
  },
  {
    "text": "notification at the informer for vni which adds the network attachment to the cache of that informer because that's",
    "start": "1766559",
    "end": "1772640"
  },
  {
    "text": "the new vna of the network attachment but the problem is that um there's no",
    "start": "1772640",
    "end": "1779120"
  },
  {
    "text": "um the problem is that these three notifications are delivered to two different informers and there's no",
    "start": "1779120",
    "end": "1785360"
  },
  {
    "text": "guarantee on the order with which uh notifications",
    "start": "1785360",
    "end": "1790559"
  },
  {
    "text": "are delivered to two different two different informers and so what might go wrong is that out of the three notifications",
    "start": "1790559",
    "end": "1797120"
  },
  {
    "text": "the last one to be received is not the creation notification for the new vni of the network attachment",
    "start": "1797120",
    "end": "1802640"
  },
  {
    "text": "but is the deletion notification for the old dni of the network attachment x and so if this happens the first the two",
    "start": "1802640",
    "end": "1809520"
  },
  {
    "text": "first notifications that are received are the two creation notifications at the informer for vnix another",
    "start": "1809520",
    "end": "1814880"
  },
  {
    "text": "informer for dni and if this happens it means that before the last deletion notification is",
    "start": "1814880",
    "end": "1820320"
  },
  {
    "text": "received the network attachment in our example is stored at the same time into two different informers the one for",
    "start": "1820320",
    "end": "1827440"
  },
  {
    "text": "dnax and the one for vni and so if a worker pops the namespace name of the network attachment in our",
    "start": "1827440",
    "end": "1833760"
  },
  {
    "text": "example during this transient when that worker reads the map from namespace name to informers it finds out",
    "start": "1833760",
    "end": "1840000"
  },
  {
    "text": "that the map is ambiguous that it points to two different informers at the same time",
    "start": "1840000",
    "end": "1845039"
  },
  {
    "text": "and so the worker doesn't know what's the informer that contains the network attachment which it should process and we found",
    "start": "1845039",
    "end": "1851919"
  },
  {
    "text": "that for a worker that is in this situation it's enough to simply drop the namespace name that he just",
    "start": "1851919",
    "end": "1858080"
  },
  {
    "text": "popped and give up on processing that network attachment and so a worker in this situation",
    "start": "1858080",
    "end": "1863360"
  },
  {
    "text": "simply pops a new namespace name and moves on to processing another network attachment and the reason this works is that",
    "start": "1863360",
    "end": "1870159"
  },
  {
    "text": "remember that informers are eventually consistent and so eventually we're guaranteed",
    "start": "1870159",
    "end": "1875919"
  },
  {
    "text": "that that informer for vnix the old dni of the network attachment a deletion notification for the network",
    "start": "1875919",
    "end": "1882240"
  },
  {
    "text": "attachment will be received and when that deletion notification is received after some time",
    "start": "1882240",
    "end": "1888320"
  },
  {
    "text": "the deletion notification handler will remove from the map from namespace name to reformers the",
    "start": "1888320",
    "end": "1894559"
  },
  {
    "text": "information that the network attachment in our example is stored at the informer for vnix because it's no longer there and it will",
    "start": "1894559",
    "end": "1901760"
  },
  {
    "text": "re-add to the queue the namespace name of that network attachment and so a new worker will pop",
    "start": "1901760",
    "end": "1907519"
  },
  {
    "text": "that name his name from the queue and when that new worker consults the map from namespace name to informers",
    "start": "1907519",
    "end": "1913519"
  },
  {
    "text": "all the ambiguity will will have disappeared the map will universally point it to the informer for vni",
    "start": "1913519",
    "end": "1921440"
  },
  {
    "text": "and so the worker will be able to um complete to complete processing of the network",
    "start": "1921440",
    "end": "1926559"
  },
  {
    "text": "attachment okay so this concludes discussion of the last technical problem that we had to solve",
    "start": "1926559",
    "end": "1932880"
  },
  {
    "text": "and also concludes my talk so in summary we prototyped an sdn using kubernetes api machinery and controller",
    "start": "1932880",
    "end": "1939840"
  },
  {
    "start": "1933000",
    "end": "1963000"
  },
  {
    "text": "pattern to test and demonstrate that those are good and general enough building blocks not just for kubernetes but for other",
    "start": "1939840",
    "end": "1946640"
  },
  {
    "text": "cloud control planes as well and in the process three interesting challenges emerged",
    "start": "1946640",
    "end": "1952159"
  },
  {
    "text": "and we had to be uh creative to find solutions to them but we believe that both those",
    "start": "1952159",
    "end": "1957440"
  },
  {
    "text": "challenges themselves and our solution have a relevance beyond just cause and",
    "start": "1957440",
    "end": "1963360"
  },
  {
    "start": "1963000",
    "end": "2338000"
  },
  {
    "text": "so this is it so i thank you very much for your attentions and if you have any questions",
    "start": "1963360",
    "end": "1968960"
  },
  {
    "text": "i'll do my best to answer them either now if you have time or you can email me or send me a diamond",
    "start": "1968960",
    "end": "1974559"
  },
  {
    "text": "slack thank you very much",
    "start": "1974559",
    "end": "1977840"
  },
  {
    "text": "hi everyone like i just said in the pre-recorded talk",
    "start": "1980880",
    "end": "1987039"
  },
  {
    "text": "if you have any questions feel free to ask them in the q a box we have a couple of",
    "start": "1987039",
    "end": "1992559"
  },
  {
    "text": "minutes left",
    "start": "1992559",
    "end": "1995278"
  },
  {
    "text": "okay so rakib ma mood",
    "start": "2002840",
    "end": "2007919"
  },
  {
    "text": "just asked the if the slides are available somewhere and the answer is uh yes the slides are",
    "start": "2007919",
    "end": "2015600"
  },
  {
    "text": "available on the um scad page of my talk",
    "start": "2015600",
    "end": "2021440"
  },
  {
    "text": "uh and after this i'll make sure to post them on the slack channel dedicated to the extending",
    "start": "2021440",
    "end": "2029440"
  },
  {
    "text": "kubernetes track",
    "start": "2029440",
    "end": "2033840"
  },
  {
    "text": "and before that question adriano petsuto asked if we have actually implemented the last",
    "start": "2034960",
    "end": "2041600"
  },
  {
    "text": "controller we talked about which is the connection agent the one with multiple informers and the answer is yes we implemented it",
    "start": "2041600",
    "end": "2048480"
  },
  {
    "text": "and it's on github open source i'll make sure to post a link to it on slack",
    "start": "2048480",
    "end": "2054960"
  },
  {
    "text": "after the q a um",
    "start": "2054960",
    "end": "2061838"
  },
  {
    "text": "okay uh vyacheslav gorbatik uh sorry if i",
    "start": "2063520",
    "end": "2070720"
  },
  {
    "text": "mispronounce your name uh ask the could you please once more",
    "start": "2070720",
    "end": "2077280"
  },
  {
    "text": "point the problem which virtual networks help to solve sure so the sort of",
    "start": "2077280",
    "end": "2084638"
  },
  {
    "text": "problem because is that again of implementing and configuring uh the excellent virtual network",
    "start": "2084639",
    "end": "2092878"
  },
  {
    "text": "uh which are essentially virtualized ethernet networks that communicate via encapsulation",
    "start": "2092879",
    "end": "2100400"
  },
  {
    "text": "uh on top of an underlay of ip networks and those different virtual networks",
    "start": "2100400",
    "end": "2107920"
  },
  {
    "text": "um are typically isolated so the the resources within a given",
    "start": "2107920",
    "end": "2114000"
  },
  {
    "text": "virtual network can communicate can communicate with other resources within the same dxn virtual",
    "start": "2114000",
    "end": "2119520"
  },
  {
    "text": "network but not with those on other vx and virtual networks and you can have",
    "start": "2119520",
    "end": "2125119"
  },
  {
    "text": "this is what vxlan does and you can have multiple use cases for this of course",
    "start": "2125119",
    "end": "2131359"
  },
  {
    "text": "one really big use cases is that of implementing multi-tenancy in a cloud data center so the idea let",
    "start": "2131359",
    "end": "2138400"
  },
  {
    "text": "me adjust the angle of the camera sorry so the idea would be that if you have multiple tenants",
    "start": "2138400",
    "end": "2144000"
  },
  {
    "text": "in a cloud data center you uh basically want to give each town the",
    "start": "2144000",
    "end": "2149839"
  },
  {
    "text": "abstraction of having uh his or her own dedicated uh virtual",
    "start": "2149839",
    "end": "2155040"
  },
  {
    "text": "private cloud and a really sort of at the bare bone a way to implement this",
    "start": "2155040",
    "end": "2160720"
  },
  {
    "text": "would be via a vxlan virtual network so that could be a use case uh this way",
    "start": "2160720",
    "end": "2166240"
  },
  {
    "text": "each separate canon would be isolated from the others and another",
    "start": "2166240",
    "end": "2171280"
  },
  {
    "text": "characteristic of vxlan which makes it suitable for our data centers is that it's very",
    "start": "2171280",
    "end": "2177200"
  },
  {
    "text": "scalable in terms of the number of different virtual networks you can support",
    "start": "2177200",
    "end": "2182400"
  },
  {
    "text": "i don't remember the precise number i believe is 16 mega different virtual networks which again",
    "start": "2182400",
    "end": "2189119"
  },
  {
    "text": "obviously is really desirable if you want to implement a cloud data centers",
    "start": "2189119",
    "end": "2194400"
  },
  {
    "text": "cloud data center where you potentially have a lot of different tenants",
    "start": "2194400",
    "end": "2201040"
  },
  {
    "text": "um so christopher gods asks do you have plans to continue your",
    "start": "2201040",
    "end": "2208000"
  },
  {
    "text": "work on this project eventually taking it to production and if this is the case if you put any",
    "start": "2208000",
    "end": "2213760"
  },
  {
    "text": "thought into where the cluster that runs the operator would live um",
    "start": "2213760",
    "end": "2221200"
  },
  {
    "text": "okay so yes we don't consider me and the other author uh don't consider this project to be",
    "start": "2221200",
    "end": "2228800"
  },
  {
    "text": "complete um as i said it was my the other order",
    "start": "2228800",
    "end": "2233839"
  },
  {
    "text": "was my supervisor while i was an intern at ibm and we worked this uh",
    "start": "2233839",
    "end": "2238880"
  },
  {
    "text": "we've been also working on this since i got back although not at a very um sort of",
    "start": "2238880",
    "end": "2246160"
  },
  {
    "text": "satisfying rhythm because we also have other things to do obviously but yes",
    "start": "2246160",
    "end": "2251200"
  },
  {
    "text": "although at a slower pace we're still working on it what's what we have no plan",
    "start": "2251200",
    "end": "2258880"
  },
  {
    "text": "uh to make it a production system so far uh although if you if you're interested",
    "start": "2258880",
    "end": "2266320"
  },
  {
    "text": "on that by all means uh let us know it as you know it's on github it's open source",
    "start": "2266320",
    "end": "2272640"
  },
  {
    "text": "one thing which we uh want to uh do which is missing is do",
    "start": "2272640",
    "end": "2279599"
  },
  {
    "text": "a performance study of the system and so we would like to sort of",
    "start": "2279599",
    "end": "2285599"
  },
  {
    "text": "characterize the time it takes to actually implement network attachments and metrics like this via a model",
    "start": "2285599",
    "end": "2294640"
  },
  {
    "text": "and we ideally would like to we're planning to do this study at a reasonably high scale uh",
    "start": "2294640",
    "end": "2301440"
  },
  {
    "text": "but we are still working on that",
    "start": "2301440",
    "end": "2306480"
  },
  {
    "text": "um okay i'm told that time is running out so i really thank",
    "start": "2306480",
    "end": "2313040"
  },
  {
    "text": "you for your interest and if you have other questions which i could not answer",
    "start": "2313040",
    "end": "2320079"
  },
  {
    "text": "just write them on slack on the slack channel",
    "start": "2320079",
    "end": "2326000"
  },
  {
    "text": "on the cncf workspace dedicated to the uh extent kubernetes track",
    "start": "2326000",
    "end": "2332560"
  },
  {
    "text": "okay thank you very much for your attention and i'll see you on slack bye",
    "start": "2332560",
    "end": "2340560"
  }
]