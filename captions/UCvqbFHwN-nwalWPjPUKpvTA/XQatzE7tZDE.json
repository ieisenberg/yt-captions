[
  {
    "start": "0",
    "end": "71000"
  },
  {
    "text": "all right i think we're good to go good afternoon uh welcome to",
    "start": "11519",
    "end": "17600"
  },
  {
    "text": "from docker push to bites on disc my name is wayne warren and i'm a senior",
    "start": "17600",
    "end": "22800"
  },
  {
    "text": "engineer at digital ocean i work on the digital ocean kubernetes product and the",
    "start": "22800",
    "end": "28560"
  },
  {
    "text": "digital ocean container registry product i'm adam wolf gordon i work with wayne and digilotion or i'm also a senior",
    "start": "28560",
    "end": "34559"
  },
  {
    "text": "engineer today we're going to talk about container registries and we're going to talk about what they are and how they",
    "start": "34559",
    "end": "40800"
  },
  {
    "text": "work and give a bunch of those details before we get into the details though i did want to give a little bit of a",
    "start": "40800",
    "end": "46000"
  },
  {
    "text": "disclaimer which is that container registries can do a lot of stuff these days they can store artifacts and things",
    "start": "46000",
    "end": "52399"
  },
  {
    "text": "that aren't containers they can have additional metadata like",
    "start": "52399",
    "end": "57520"
  },
  {
    "text": "bills and materials and signatures and things like that and we are going to ignore all of that today this talk is in",
    "start": "57520",
    "end": "63359"
  },
  {
    "text": "the 101 track so we're going to stick to the most basic use case of pushing and pulling container images from your",
    "start": "63359",
    "end": "68960"
  },
  {
    "text": "registry before we get into a bunch of details",
    "start": "68960",
    "end": "74400"
  },
  {
    "start": "71000",
    "end": "335000"
  },
  {
    "text": "let's answer a really basic question what is a container registry to answer that let's start with",
    "start": "74400",
    "end": "80560"
  },
  {
    "text": "something most of us have probably seen or done before and that's a docker push",
    "start": "80560",
    "end": "86720"
  },
  {
    "text": "so you docker push some ascii arrows fly across the screen and your container",
    "start": "86720",
    "end": "93200"
  },
  {
    "text": "image is now somewhere in the cloud later your co-worker or some random",
    "start": "93200",
    "end": "98799"
  },
  {
    "text": "stranger in the internet or a deployment system can pull that image and run it somewhere",
    "start": "98799",
    "end": "105200"
  },
  {
    "text": "else so this is the power of containers as we all know you can share the image and it should just run on somebody else's",
    "start": "105200",
    "end": "112560"
  },
  {
    "text": "computer the thing that stores those images in the cloud that's a container registry",
    "start": "112560",
    "end": "120078"
  },
  {
    "text": "so we know what a container registry does for us but what's underneath it's a content addressable data store",
    "start": "120240",
    "end": "127280"
  },
  {
    "text": "and what does that mean it's an object store so it you can put data there and it's content addressable",
    "start": "127280",
    "end": "134800"
  },
  {
    "text": "that means that for each object in that store instead of being identified by some arbitrary key or path name",
    "start": "134800",
    "end": "142400"
  },
  {
    "text": "it's identified by a digest of its contents in container",
    "start": "142400",
    "end": "148720"
  },
  {
    "text": "in a container registry we have a few different kinds of objects first we have blobs these are the the basic object",
    "start": "148720",
    "end": "154879"
  },
  {
    "text": "that uh that are stored in a container registry and then we have manifests",
    "start": "154879",
    "end": "161440"
  },
  {
    "text": "they are which are metadata about images and the contents of the blobs",
    "start": "161440",
    "end": "170080"
  },
  {
    "text": "so they tell us what layer blobs are stored in each image you can think of manifest as a set of",
    "start": "170080",
    "end": "177680"
  },
  {
    "text": "pointers to layers and then finally we have tags",
    "start": "177680",
    "end": "184159"
  },
  {
    "text": "so tags here are drawn as a different shape because they're special they have human readable names and they're mutable",
    "start": "184159",
    "end": "192319"
  },
  {
    "text": "i mean not a different shape but a different color so since manifest and blobs are identified",
    "start": "192319",
    "end": "198560"
  },
  {
    "text": "by their contents they're immutable change the contents and you change the",
    "start": "198560",
    "end": "204560"
  },
  {
    "text": "identifiers well tags on the other hand you can update later",
    "start": "204560",
    "end": "210080"
  },
  {
    "text": "so there are many different registry implementations but the one we'll talk about today is a cncf project called",
    "start": "210080",
    "end": "216000"
  },
  {
    "text": "distribution this was previously the open source registry implementation released by",
    "start": "216000",
    "end": "221680"
  },
  {
    "text": "docker they donated to the cncf in 2020 and it is",
    "start": "221680",
    "end": "227120"
  },
  {
    "text": "the reference implementation for other container registries but it's also used by many people in",
    "start": "227120",
    "end": "234000"
  },
  {
    "text": "production which includes us at digitalocean our hosted container registry platform is built on top of",
    "start": "234000",
    "end": "240560"
  },
  {
    "text": "this code base so we've heard a little bit about what a",
    "start": "240560",
    "end": "246000"
  },
  {
    "text": "container industry is what it looks like inside one sort of mystery that we haven't talked about is those ascii",
    "start": "246000",
    "end": "251200"
  },
  {
    "text": "arrows that fly across your screen when you do a push how does your container image actually get to the registry and",
    "start": "251200",
    "end": "257199"
  },
  {
    "text": "that data get into the cloud and the answer to that is the oci",
    "start": "257199",
    "end": "262800"
  },
  {
    "text": "distribution spec so this is the http api that's been standardized that registry",
    "start": "262800",
    "end": "268960"
  },
  {
    "text": "clients use to talk to registry servers i like i said it's a standardized api it",
    "start": "268960",
    "end": "274080"
  },
  {
    "text": "reached v1 last year so now it's really official and um it's vendor neutral it was originally",
    "start": "274080",
    "end": "280880"
  },
  {
    "text": "written by docker to go with their registry implementation but it's been adopted and updated by the open container initiative or oci",
    "start": "280880",
    "end": "287520"
  },
  {
    "text": "which is a community so it is vendor neutral there are lots of different implementations on both the client and",
    "start": "287520",
    "end": "292560"
  },
  {
    "text": "the server side uh so now let's dig into the distribution",
    "start": "292560",
    "end": "299040"
  },
  {
    "text": "spec and the distribution code base uh and we'll walk through some practical examples",
    "start": "299040",
    "end": "304960"
  },
  {
    "text": "so starting with what a push and a pull look like from an api perspective in the distribution spec and then we'll dive",
    "start": "304960",
    "end": "311440"
  },
  {
    "text": "into the distribution code base to see how it's structured and how it implements uh image pushes on the server",
    "start": "311440",
    "end": "318000"
  },
  {
    "text": "side and then finally we'll wrap up with a garbage collection which uh is",
    "start": "318000",
    "end": "325840"
  },
  {
    "text": "basically the process of uh cleaning up or freeing up disk space",
    "start": "325840",
    "end": "331600"
  },
  {
    "text": "after deleting images so let's start by looking at what",
    "start": "331600",
    "end": "336960"
  },
  {
    "text": "happens in the api in this distribution spec when you push a docker image or a",
    "start": "336960",
    "end": "342240"
  },
  {
    "text": "container image to a registry remember this spec is standardized it is vendor neutral so everything we're going",
    "start": "342240",
    "end": "348400"
  },
  {
    "text": "to talk about in this section is applicable to any implementation of it we're going to use docker as our sort of",
    "start": "348400",
    "end": "354080"
  },
  {
    "text": "example commands but that is not important you could be using some other tool",
    "start": "354080",
    "end": "360400"
  },
  {
    "text": "so remember this diagram from earlier this shows what's in the container registry this is all the objects that",
    "start": "360880",
    "end": "366160"
  },
  {
    "text": "need to make it to the registry when we do a push and we talked earlier about how the",
    "start": "366160",
    "end": "371520"
  },
  {
    "text": "manifest is sort of pointers to these layers it references the layers that means that as a client we need to",
    "start": "371520",
    "end": "379199"
  },
  {
    "text": "push the layers first and then the manifest because the spec says that a registry is allowed to reject an object",
    "start": "379199",
    "end": "385280"
  },
  {
    "text": "that has references to non-existent objects you'll notice that i didn't talk about",
    "start": "385280",
    "end": "391759"
  },
  {
    "text": "the the tag that's because the tag actually gets pushed as part of pushing the manifest it's sort of an additional",
    "start": "391759",
    "end": "397440"
  },
  {
    "text": "piece of metadata that's attached to the manifest it's not really a separate object in the registry",
    "start": "397440",
    "end": "402800"
  },
  {
    "text": "even though we kind of think of it that way conceptually the other thing to",
    "start": "402800",
    "end": "409039"
  },
  {
    "text": "point out before we talk about the the mechanics of the api is that different container images can share layers so in",
    "start": "409039",
    "end": "415599"
  },
  {
    "text": "this diagram we have this layer called d655 and so on and it is shared between",
    "start": "415599",
    "end": "421120"
  },
  {
    "text": "two different images one that's already in the registry the one that's on the bottom that's full saturation and this",
    "start": "421120",
    "end": "426479"
  },
  {
    "text": "one that we want to push to the registry on top as a registry client we can push that",
    "start": "426479",
    "end": "431919"
  },
  {
    "text": "layer again if we want to there's no harm in doing that other than we're going to waste some time because the",
    "start": "431919",
    "end": "437120"
  },
  {
    "text": "registry is going to deduplicate it but we don't have to do that as an optimization we can figure out that the",
    "start": "437120",
    "end": "444880"
  },
  {
    "text": "registry already has that layer and then we can skip pushing it and most real implementations on the",
    "start": "444880",
    "end": "450720"
  },
  {
    "text": "client side are going to do this so jumping into the spec and what the",
    "start": "450720",
    "end": "455759"
  },
  {
    "text": "requests and responses look like um the first thing we're going to do is check whether the layers that we need",
    "start": "455759",
    "end": "462319"
  },
  {
    "text": "that we want to push are already in the registry and to do that we use this head endpoint we identify the",
    "start": "462319",
    "end": "469280"
  },
  {
    "text": "blob using its digest which is a hash of its contents and the registry is going to return a 200",
    "start": "469280",
    "end": "475680"
  },
  {
    "text": "response code if it already has that blob if it doesn't have the blob it's going to return a 404 and then we know",
    "start": "475680",
    "end": "480879"
  },
  {
    "text": "that we need to push it once we've figured out which blobs we need to push we're going to actually",
    "start": "480879",
    "end": "487280"
  },
  {
    "text": "push them and this is a little more complex because the distribution spec gives us three different ways to do it",
    "start": "487280",
    "end": "493440"
  },
  {
    "text": "these three different methods all do effectively the same thing they do three different steps but they do it in",
    "start": "493440",
    "end": "500240"
  },
  {
    "text": "different combinations of requests so the three steps that we need to do are first initiate and upload",
    "start": "500240",
    "end": "505520"
  },
  {
    "text": "the initiating the upload lets the registry know that we're about to push some data to it and it will return us a session id that we can then use in",
    "start": "505520",
    "end": "512000"
  },
  {
    "text": "subsequent requests to refer to that upload the second thing we're going to do is actually push the data that's i think",
    "start": "512000",
    "end": "517760"
  },
  {
    "text": "the obvious part you've got to provide the data to the registry finally we're going to finalize the",
    "start": "517760",
    "end": "522800"
  },
  {
    "text": "upload when we finalize the upload we provide the digest that we've calculated of our",
    "start": "522800",
    "end": "529040"
  },
  {
    "text": "layer blob and the registry then can calculate the the checksum itself make",
    "start": "529040",
    "end": "534160"
  },
  {
    "text": "sure that it got the right data that what we said we were going to send it is actually what we sent it this finalization step is important for",
    "start": "534160",
    "end": "541360"
  },
  {
    "text": "another reason other than integrity it's also important to make sure that the registry isn't going",
    "start": "541360",
    "end": "548000"
  },
  {
    "text": "to make in progress uploads available to download for clients so we we don't tell the registry the",
    "start": "548000",
    "end": "554320"
  },
  {
    "text": "digest until the end that way it's not is not even able to make that",
    "start": "554320",
    "end": "560160"
  },
  {
    "text": "upload available to a client to download until we've pushed all the data and it knows that it's there",
    "start": "560160",
    "end": "566320"
  },
  {
    "text": "so each of these different methods these three ways of pushing like i said does those those three steps in different",
    "start": "566320",
    "end": "572160"
  },
  {
    "text": "combinations in some cases two of the steps or all three of the steps are combined into a",
    "start": "572160",
    "end": "577279"
  },
  {
    "text": "single http request but the most common method that we've seen from clients is the chunked method on the right there",
    "start": "577279",
    "end": "584399"
  },
  {
    "text": "in which each of these three phases has its own http request",
    "start": "584399",
    "end": "589519"
  },
  {
    "text": "so that the first request is a post that initiates the upload and the registry is",
    "start": "589519",
    "end": "594880"
  },
  {
    "text": "going to return the session id that we'll use in the rest of the requests as a client then we're going to upload chunks of",
    "start": "594880",
    "end": "600240"
  },
  {
    "text": "data using these patch requests again referring to that session id finally when we're when once we've",
    "start": "600240",
    "end": "606079"
  },
  {
    "text": "uploaded all our data with these patches we're going to do this put request that's where we provide the digest and",
    "start": "606079",
    "end": "611360"
  },
  {
    "text": "say that we're done pushing the registry can then make the blob available for download",
    "start": "611360",
    "end": "616959"
  },
  {
    "text": "in practice what we've seen from clients in particular the docker client",
    "start": "617040",
    "end": "622560"
  },
  {
    "text": "is that it uses the chunked upload method but it provides all of the data in a single chunk",
    "start": "622560",
    "end": "627760"
  },
  {
    "text": "and the reason i wanted to call this out is that there's no capability negotiation in the distribution spec",
    "start": "627760",
    "end": "633600"
  },
  {
    "text": "today so there's no way for a registry implementation to communicate to a client that it only supports up to a",
    "start": "633600",
    "end": "639600"
  },
  {
    "text": "certain chunk size or that it only supports a certain number of chunks clients can make really any assumptions",
    "start": "639600",
    "end": "645440"
  },
  {
    "text": "they like about that and the assumption that docker makes is that it can transmit that entire blob in a single",
    "start": "645440",
    "end": "651600"
  },
  {
    "text": "patch request so if you've got a 10 gigabyte file system layer you're going to get a 10 gigabyte patch request a 10",
    "start": "651600",
    "end": "658079"
  },
  {
    "text": "gigabyte body that's important to know if you're implementing a registry or hosting a registry like we are",
    "start": "658079",
    "end": "663839"
  },
  {
    "text": "because uh there's all kinds of timeouts that you might assume are reasonable that turn out not to be",
    "start": "663839",
    "end": "669920"
  },
  {
    "text": "reasonable when you have a client making a gigantic patch request",
    "start": "669920",
    "end": "675839"
  },
  {
    "text": "one other option that the spec allows is called blob mounting everything in a registry is scoped to a",
    "start": "676000",
    "end": "683680"
  },
  {
    "text": "repository which is kind of a namespace that's what you might think of as the image name when you're thinking about",
    "start": "683680",
    "end": "688880"
  },
  {
    "text": "your container images as a client if you know that you share a layer with an image that's in another",
    "start": "688880",
    "end": "696560"
  },
  {
    "text": "repository you can ask the registry to please",
    "start": "696560",
    "end": "701680"
  },
  {
    "text": "just just share that layer between the two repositories and avoid uploading it",
    "start": "701680",
    "end": "708000"
  },
  {
    "text": "registries don't have to allow this it is optional and also the registry might not have that layer maybe you didn't push it maybe it got deleted",
    "start": "708160",
    "end": "715680"
  },
  {
    "text": "but if it does allow it and it does already have the layer you and you include",
    "start": "715680",
    "end": "721440"
  },
  {
    "text": "these extra parameters on the post request when you initialize the upload it'll return",
    "start": "721440",
    "end": "726480"
  },
  {
    "text": "uh a two i'm just making sure i have the right code it will return a 201 response",
    "start": "726480",
    "end": "732399"
  },
  {
    "text": "to your request and that means that you don't have to go through the rest of the sequence of pushing your layer that layer is already",
    "start": "732399",
    "end": "738639"
  },
  {
    "text": "there it'll just reuse it from that other image if it doesn't allow it or it doesn't",
    "start": "738639",
    "end": "743920"
  },
  {
    "text": "have the data then it'll return a 202 and you just proceed with your upload as normal",
    "start": "743920",
    "end": "749120"
  },
  {
    "text": "so this is an additional option on that post request to initiate the upload that you can do to avoid pushing data in",
    "start": "749120",
    "end": "756560"
  },
  {
    "text": "many cases once the registry has all of our layers",
    "start": "756560",
    "end": "761839"
  },
  {
    "text": "we can push the manifest and this is relatively simple there's only one way to do it the",
    "start": "761839",
    "end": "767920"
  },
  {
    "text": "little variation that there is is that there's this parameter called reference in the url and that can be either a",
    "start": "767920",
    "end": "772959"
  },
  {
    "text": "digest or a tag i say that if it quacks like a digest it's a digest and the way that it digests quacks is it",
    "start": "772959",
    "end": "779360"
  },
  {
    "text": "has a colon in the middle separating the algorithm like sha-256 from the checksum are the hash which is a big long hex",
    "start": "779360",
    "end": "787120"
  },
  {
    "text": "string you've probably seen um registries can differentiate between the",
    "start": "787120",
    "end": "792320"
  },
  {
    "text": "two formats this way you're not allowed to have a colon in a tag so that's that's how it works",
    "start": "792320",
    "end": "799519"
  },
  {
    "text": "um if you push using a tag that does implicitly create the digest reference",
    "start": "799519",
    "end": "804639"
  },
  {
    "text": "in the registry as well because remember everything in the registry is identified by the hash of its contents by this digest so the tag just if you push by a",
    "start": "804639",
    "end": "812000"
  },
  {
    "text": "tag you now have two ways to refer to your manifest instead of just the digest but you can push either way",
    "start": "812000",
    "end": "818560"
  },
  {
    "text": "so spec wise here's what the image push looks like end to end first we're going to check whether each",
    "start": "819360",
    "end": "824399"
  },
  {
    "text": "of the layers that we want to push exists in the registry using that head end point that we saw then we're going to push each of the",
    "start": "824399",
    "end": "830639"
  },
  {
    "text": "layers that we need to push i in this example using the the three part post patch put chunked upload",
    "start": "830639",
    "end": "838320"
  },
  {
    "text": "and then finally we're going to put the manifest using either that tag or the digest like we just saw in the previous",
    "start": "838320",
    "end": "843519"
  },
  {
    "text": "slide and that's it at the api layer of abstraction this is what an image push looks like to",
    "start": "843519",
    "end": "849199"
  },
  {
    "text": "a registry we're going to go into another layer of",
    "start": "849199",
    "end": "854560"
  },
  {
    "start": "852000",
    "end": "950000"
  },
  {
    "text": "detail in a couple minutes but before we do that i wanted to look at the the other side the docker pull just for",
    "start": "854560",
    "end": "859920"
  },
  {
    "text": "completeness so that we introduce the rest of the endpoints in the spec",
    "start": "859920",
    "end": "864959"
  },
  {
    "text": "so as a reminder back to this diagram again these are the objects in the registry as a client this is the things that we need to pull and",
    "start": "864959",
    "end": "872480"
  },
  {
    "text": "if if we want to pull those layers we need to know which ones they are so as you might expect this is kind of the",
    "start": "872480",
    "end": "878480"
  },
  {
    "text": "opposite of the push we need to pull the manifest and then we can pull the layers once we have the manifest and know which",
    "start": "878480",
    "end": "883519"
  },
  {
    "text": "layers they are pulling a manifest looks a lot like pushing a manifest you remember the duck",
    "start": "883519",
    "end": "889680"
  },
  {
    "text": "you can use either the tag or the digest and",
    "start": "889680",
    "end": "895440"
  },
  {
    "text": "the only difference here is that it's a get endpoint instead of a put in point",
    "start": "895440",
    "end": "900720"
  },
  {
    "text": "pulling blobs is much simpler than pushing blobs it is a single endpoint it's the same as that head endpoint that",
    "start": "901440",
    "end": "907360"
  },
  {
    "text": "we use to check for existence except now it's a get and you'll get back the the data",
    "start": "907360",
    "end": "912399"
  },
  {
    "text": "that's in the layer um that's that's really pretty simple",
    "start": "912399",
    "end": "918560"
  },
  {
    "text": "so spec wise again um here's the the end points that are used when you pull an image we've included the two head",
    "start": "918959",
    "end": "924399"
  },
  {
    "text": "endpoints in there that you can use to check for existence you don't have to do that when you're pulling an image but you might want to it's just as an",
    "start": "924399",
    "end": "930000"
  },
  {
    "text": "optimization to make sure it has everything that you need but really you're just going to use these two gets one get to get the",
    "start": "930000",
    "end": "936000"
  },
  {
    "text": "manifest and then a series of gets to get all the layers that you need and with that i'm going to hand things off",
    "start": "936000",
    "end": "941440"
  },
  {
    "text": "to wayne and wayne's going to talk about how all of this stuff is actually implemented which i think is the the more complex part than the spec that i",
    "start": "941440",
    "end": "948079"
  },
  {
    "text": "just talked about thanks adam now that we've covered the practical",
    "start": "948079",
    "end": "954240"
  },
  {
    "start": "950000",
    "end": "1160000"
  },
  {
    "text": "user facing elements of the distribution client server interactions let's pop",
    "start": "954240",
    "end": "959519"
  },
  {
    "text": "open the hood and take a look at the internals so the internals can be roughly",
    "start": "959519",
    "end": "965600"
  },
  {
    "text": "understood in terms of four layers the http api handlers the oci abstraction interfaces which",
    "start": "965600",
    "end": "973360"
  },
  {
    "text": "allows the api handlers and developers to",
    "start": "973360",
    "end": "979759"
  },
  {
    "text": "well developers using distribution as a library to operate on abstractions defined by the spec",
    "start": "979759",
    "end": "986079"
  },
  {
    "text": "and then there's the storage driver abstraction which allows these oci abstractions to be defined in a way that",
    "start": "986079",
    "end": "992240"
  },
  {
    "text": "is generic over back-end implementations and then finally there's the back-end",
    "start": "992240",
    "end": "998480"
  },
  {
    "text": "implementations themselves which allow users or operators of distribution to choose",
    "start": "998480",
    "end": "1004959"
  },
  {
    "text": "their back-end this is of course an oversimplification that leaves out numerous features",
    "start": "1004959",
    "end": "1011279"
  },
  {
    "text": "provided by distribution but it's useful in that it allows us to roughly understand",
    "start": "1011279",
    "end": "1017440"
  },
  {
    "text": "what's going on when images are pushed to pulled from or deleted from a",
    "start": "1017440",
    "end": "1022839"
  },
  {
    "text": "registry now let's take a closer look at each of these layers",
    "start": "1022839",
    "end": "1028319"
  },
  {
    "text": "the http http layer doesn't contain many surprises it's a straightforward mapping from http",
    "start": "1028319",
    "end": "1035678"
  },
  {
    "text": "endpoints to handlers which themselves make use of oci abstractions",
    "start": "1035679",
    "end": "1043760"
  },
  {
    "text": "so in an ideal world you might expect uh oci abstractions to be a relatively",
    "start": "1043839",
    "end": "1049039"
  },
  {
    "text": "straightforward mapping between types and their operations in the real world and especially in an",
    "start": "1049039",
    "end": "1056000"
  },
  {
    "text": "open source project built over a long time by many contributors with different",
    "start": "1056000",
    "end": "1061120"
  },
  {
    "text": "goals and ideas about how code should be structured and different use cases for that code",
    "start": "1061120",
    "end": "1068400"
  },
  {
    "text": "things tend to get a little bit messy so i don't want to belabor the details",
    "start": "1068400",
    "end": "1073840"
  },
  {
    "text": "too much here or to disparage the code as by representing it as overly complex",
    "start": "1073840",
    "end": "1080720"
  },
  {
    "text": "instead i just want to give a sense of that complexity and to emphasize that in spite of it this code can be really",
    "start": "1080720",
    "end": "1086960"
  },
  {
    "text": "useful for us as container registry operators since",
    "start": "1086960",
    "end": "1092160"
  },
  {
    "text": "they serve not only the registry api itself but also uh they can be the back end um or",
    "start": "1092160",
    "end": "1099360"
  },
  {
    "text": "form part of the back end for product specific features like uh",
    "start": "1099360",
    "end": "1104400"
  },
  {
    "text": "the container registry product at digitalocean",
    "start": "1104400",
    "end": "1108760"
  },
  {
    "text": "so the last interface i'd like to visit is the storage driver this interface is what enables oci",
    "start": "1109440",
    "end": "1115760"
  },
  {
    "text": "abstractions and the container registry more generally to target a variety of back-end storage systems from in-memory",
    "start": "1115760",
    "end": "1122720"
  },
  {
    "text": "which can be useful for local testing to production-ready object storage systems like an s3 api",
    "start": "1122720",
    "end": "1130400"
  },
  {
    "text": "so there's the aws s3 api and various open source implementations as well as",
    "start": "1130400",
    "end": "1137280"
  },
  {
    "text": "uh digitalocean spaces which is an s3 api",
    "start": "1137280",
    "end": "1143760"
  },
  {
    "text": "as well so for a registry operator who wanted to make distribution work with a new backend this is the interface that they",
    "start": "1143760",
    "end": "1151520"
  },
  {
    "text": "would have to implement to do so and then uh they could run a registry on top of",
    "start": "1151520",
    "end": "1157280"
  },
  {
    "text": "whatever their back end is all right so up to this point we've",
    "start": "1157280",
    "end": "1162799"
  },
  {
    "start": "1160000",
    "end": "1515000"
  },
  {
    "text": "talked about the broad strokes of http interactions involved in image pushes",
    "start": "1162799",
    "end": "1167840"
  },
  {
    "text": "and pulls as well as a high level overview of the distribution internals",
    "start": "1167840",
    "end": "1174240"
  },
  {
    "text": "next we'd like to make good on the promise of the talk and discuss how these elements fit together",
    "start": "1174240",
    "end": "1180880"
  },
  {
    "text": "from docker push to bytes on disk",
    "start": "1180880",
    "end": "1185440"
  },
  {
    "text": "so if you recall earlier in the presentation we illustrated an ideal image push workflow where at a high",
    "start": "1185919",
    "end": "1192000"
  },
  {
    "text": "level the client first pushes all image layers then pushes the manifest referencing those layers",
    "start": "1192000",
    "end": "1198720"
  },
  {
    "text": "in order to illustrate image push to bytes on disk we'll be zooming in to examine",
    "start": "1198720",
    "end": "1204080"
  },
  {
    "text": "the interface methods involved in uploading an individual image layer",
    "start": "1204080",
    "end": "1209520"
  },
  {
    "text": "more specifically we'll take a look at the http patch function for the blobs uploads endpoint here you",
    "start": "1209520",
    "end": "1216640"
  },
  {
    "text": "can see the http endpoint where n is the name of the image within the",
    "start": "1216640",
    "end": "1222880"
  },
  {
    "text": "registry also uh we've referred to it as the repository because that's the name of you know an",
    "start": "1222880",
    "end": "1229120"
  },
  {
    "text": "image in the spec and then s is the session uuid shared",
    "start": "1229120",
    "end": "1234559"
  },
  {
    "text": "across all chunk upload patch requests so what exactly do we mean by",
    "start": "1234559",
    "end": "1241760"
  },
  {
    "text": "from docker push to bytes on disk in the context of the blob upload patch",
    "start": "1241760",
    "end": "1246880"
  },
  {
    "text": "request what we want to do is highlight all the interface methods and objects involved in the seq and the sequence in",
    "start": "1246880",
    "end": "1254400"
  },
  {
    "text": "which they're called to store a chunk layer in the configured backend so in our case the configured backend is an s3",
    "start": "1254400",
    "end": "1261440"
  },
  {
    "text": "api so at a high level the patch involves",
    "start": "1261440",
    "end": "1266960"
  },
  {
    "text": "three phases authentication resuming the session and uploading the data",
    "start": "1266960",
    "end": "1272960"
  },
  {
    "text": "during the authentication phase we obtain credentials from the patch request header validate those credentials in a way that",
    "start": "1272960",
    "end": "1279360"
  },
  {
    "text": "depends on the method in use so i've listed a few potential authentication",
    "start": "1279360",
    "end": "1285039"
  },
  {
    "text": "methods basic auth bearer token or jwt and oauth",
    "start": "1285039",
    "end": "1291200"
  },
  {
    "text": "after we authenticate we can move on to resuming the session",
    "start": "1291200",
    "end": "1296480"
  },
  {
    "text": "so we need to resume an established session during each patch request in",
    "start": "1296480",
    "end": "1301760"
  },
  {
    "text": "order to continue uploading a given blob to the back end",
    "start": "1301760",
    "end": "1307200"
  },
  {
    "text": "this is keyed on the session id as a path parameter in the patch request",
    "start": "1307200",
    "end": "1312400"
  },
  {
    "text": "so first we get the blob store associated with a specific repository which is an interface in front of the",
    "start": "1312400",
    "end": "1318320"
  },
  {
    "text": "storage driver that provides blob oriented session upload semantics",
    "start": "1318320",
    "end": "1324159"
  },
  {
    "text": "we validate the session id given in the request by attempting to retrieve a stored session keyed on the id",
    "start": "1324159",
    "end": "1331200"
  },
  {
    "text": "using the store storage drivers git content method which in this case translates to",
    "start": "1331200",
    "end": "1336320"
  },
  {
    "text": "a git object s3 api call and then once we've validated the session id we can retrieve a writer",
    "start": "1336320",
    "end": "1343760"
  },
  {
    "text": "instance from the storage driver to continue the in-progress blob upload in the next phase of the patch request",
    "start": "1343760",
    "end": "1351039"
  },
  {
    "text": "i realized by the way that this is maybe going into a little bit more detail than you might want out of a 101 session",
    "start": "1351039",
    "end": "1358400"
  },
  {
    "text": "but this the slides are available online if you're interested to um take a closer look",
    "start": "1358400",
    "end": "1364559"
  },
  {
    "text": "uh anyway um the the next phase is the data upload phase uh where we stream the",
    "start": "1364559",
    "end": "1370559"
  },
  {
    "text": "incoming patch request body using the s3 blob writer we just received when",
    "start": "1370559",
    "end": "1375600"
  },
  {
    "text": "resuming the session [Music] and practically speaking this is implemented using an io copy that reads",
    "start": "1375600",
    "end": "1381760"
  },
  {
    "text": "from the patch request body and writes to the s3 blob writer",
    "start": "1381760",
    "end": "1386880"
  },
  {
    "text": "as bytes are received from the client connection the i o copy will call right on the s3 blob writer repeatedly as bytes are",
    "start": "1386880",
    "end": "1394080"
  },
  {
    "text": "streamed in from the patch request body so we don't buffer anything in memory here well we don't buffer the entire request",
    "start": "1394080",
    "end": "1400960"
  },
  {
    "text": "in memory i should say we do however buffer",
    "start": "1400960",
    "end": "1407039"
  },
  {
    "text": "a little bit so internally for our s3 back end the writer makes use of a multi-part",
    "start": "1407039",
    "end": "1413200"
  },
  {
    "text": "upload and each part in an s3 multi-part upload has to meet a minimum size",
    "start": "1413200",
    "end": "1418480"
  },
  {
    "text": "requirement and that's imposed by the s3 api itself so because of this the write calls to",
    "start": "1418480",
    "end": "1424799"
  },
  {
    "text": "the writer that don't meet the minimum size will buffer locally until that requirement has been met before being",
    "start": "1424799",
    "end": "1431600"
  },
  {
    "text": "pushed or until explicitly committed through the storage driver",
    "start": "1431600",
    "end": "1438159"
  },
  {
    "text": "so commit is a method on the storage driver which i don't think i illustrated here very well",
    "start": "1438159",
    "end": "1444799"
  },
  {
    "text": "also note that here in this diagram we show the create multi-part upload and the complete",
    "start": "1445279",
    "end": "1451520"
  },
  {
    "text": "multi-part upload but those aren't invoked on every patch request the create multi-part",
    "start": "1451520",
    "end": "1459360"
  },
  {
    "text": "upload is only ever invoked on the first patch request and then",
    "start": "1459360",
    "end": "1464960"
  },
  {
    "text": "the complete multi-part upload doesn't happen during any patch request instead it happens during the final put",
    "start": "1464960",
    "end": "1471760"
  },
  {
    "text": "in the chunked upload sequence of post patch put",
    "start": "1471760",
    "end": "1478240"
  },
  {
    "text": "so yeah this more or less wraps up our somewhat hand wavy explanation of how",
    "start": "1478240",
    "end": "1484880"
  },
  {
    "text": "bytes traverse distribution from http to bytes on disk i call it hand wavy",
    "start": "1484880",
    "end": "1490240"
  },
  {
    "text": "because we kind of stopped before we got to the disk at the s3 api because obviously different s3 apis can",
    "start": "1490240",
    "end": "1497520"
  },
  {
    "text": "be implemented in uh different ways and that's not the top uh topic here so",
    "start": "1497520",
    "end": "1505200"
  },
  {
    "text": "yeah now that we've covered how the bytes get onto the disk kind of",
    "start": "1505200",
    "end": "1512159"
  },
  {
    "text": "let's consider how they get off the disk for distribution this happens through a",
    "start": "1512159",
    "end": "1518559"
  },
  {
    "start": "1515000",
    "end": "1718000"
  },
  {
    "text": "process known as garbage collection in programming languages garbage collection is a memory recovery feature",
    "start": "1518559",
    "end": "1525200"
  },
  {
    "text": "where the runtime detects not all programming languages some programming languages",
    "start": "1525200",
    "end": "1531360"
  },
  {
    "text": "where the runtime detects unused blocks of allocated memory and deallocates them",
    "start": "1531360",
    "end": "1536720"
  },
  {
    "text": "for to free them for subsequent use similarly in distribution garbage",
    "start": "1536720",
    "end": "1541760"
  },
  {
    "text": "collection is a disk usage recovery feature",
    "start": "1541760",
    "end": "1547120"
  },
  {
    "text": "to understand what garbage collection is in the context of distribution let's revisit the container registry diagram",
    "start": "1547520",
    "end": "1554720"
  },
  {
    "text": "from earlier where we had just pushed a new image and updated the latest tag to point at it",
    "start": "1554720",
    "end": "1561200"
  },
  {
    "text": "the old image represented here by the top manifest is now in an untagged state",
    "start": "1561200",
    "end": "1566400"
  },
  {
    "text": "while this manifest could be deleted directly through the api untagged manifests can be garbage",
    "start": "1566400",
    "end": "1572240"
  },
  {
    "text": "collected that is they can be detected as untagged and automatically deleted",
    "start": "1572240",
    "end": "1578480"
  },
  {
    "text": "once a manifest is deleted either manually or by garbage collection it may leave behind what we now call",
    "start": "1578880",
    "end": "1585120"
  },
  {
    "text": "unreferenced layer blobs unreferenced layer blobs are blobs which are no longer pointed to by manifests in the",
    "start": "1585120",
    "end": "1591840"
  },
  {
    "text": "registry such blobs are now eligible for either manual deletion",
    "start": "1591840",
    "end": "1598159"
  },
  {
    "text": "or garbage collection similar to untagged manifests",
    "start": "1598159",
    "end": "1603360"
  },
  {
    "text": "after garbage collection is run disk disk space is freed for use by subsequent image pushes",
    "start": "1603360",
    "end": "1609279"
  },
  {
    "text": "so garbage collection then is really a convenience feature that removes the need for the user to manually delete",
    "start": "1609279",
    "end": "1616400"
  },
  {
    "text": "things that could be deleted so one question you might be asking yourself is why is blob collection",
    "start": "1616400",
    "end": "1622960"
  },
  {
    "text": "necessary as a separate process from manifest deletion itself shouldn't we be",
    "start": "1622960",
    "end": "1628080"
  },
  {
    "text": "able to just automatically delete any blobs that are no longer pushed to or sorry no longer pointed to by",
    "start": "1628080",
    "end": "1635440"
  },
  {
    "text": "manifest after we delete the manifests well without getting into too many",
    "start": "1635440",
    "end": "1640640"
  },
  {
    "text": "details because this is the second to last slide",
    "start": "1640640",
    "end": "1645600"
  },
  {
    "text": "and those details could constitute their own separate talk the reason is that there may be reads",
    "start": "1646080",
    "end": "1651360"
  },
  {
    "text": "writes and deletes happening simultaneously on a given registry and for a given image or set of related",
    "start": "1651360",
    "end": "1658320"
  },
  {
    "text": "images so because the distribution api doesn't make any guarantees around atomicity the",
    "start": "1658320",
    "end": "1664960"
  },
  {
    "text": "design of internal interfaces particularly the storage driver don't take the possibility of",
    "start": "1664960",
    "end": "1670399"
  },
  {
    "text": "simultaneous reads writes and deletes into consideration so one resulting risk then is that a",
    "start": "1670399",
    "end": "1677120"
  },
  {
    "text": "delete that happens by one user during another user's right could lead to data loss for the writing user because",
    "start": "1677120",
    "end": "1684880"
  },
  {
    "text": "the writing user may see the blob as existing before they begin to push",
    "start": "1684880",
    "end": "1690559"
  },
  {
    "text": "their image and decline to push it or before they begin to push their layer",
    "start": "1690559",
    "end": "1695679"
  },
  {
    "text": "and decline to push it assuming it will be there at the same time that another user is",
    "start": "1695679",
    "end": "1700799"
  },
  {
    "text": "deleting that layer thus in order to safely delete objects without incurring data races",
    "start": "1700799",
    "end": "1707039"
  },
  {
    "text": "or loss that would lead to data integrity issues we need to set a given",
    "start": "1707039",
    "end": "1712480"
  },
  {
    "text": "registry to read only mode before we can safely run garbage collection on it",
    "start": "1712480",
    "end": "1718320"
  },
  {
    "start": "1718000",
    "end": "1763000"
  },
  {
    "text": "that's that's it for today that's our talk about container registries hopefully you learned something from",
    "start": "1718640",
    "end": "1724000"
  },
  {
    "text": "this or or learned some things you already knew maybe if you already knew about registries um i think we do have a",
    "start": "1724000",
    "end": "1729520"
  },
  {
    "text": "little bit of time for questions uh before we get there i did want to say we've got stickers they're on the uh the",
    "start": "1729520",
    "end": "1734640"
  },
  {
    "text": "table there if you want some stickers and and we're also happy to chat after and i have more stickers in my backpack if we run out so they're really cute",
    "start": "1734640",
    "end": "1741039"
  },
  {
    "text": "stickers if you're not familiar with digital ocean stickers they're like little sharks and different outfits so um yeah but if we've got some questions",
    "start": "1741039",
    "end": "1748080"
  },
  {
    "text": "uh online or in the room here we can get that started",
    "start": "1748080",
    "end": "1753279"
  },
  {
    "text": "yeah the microphone is just in the middle [Applause]",
    "start": "1753279",
    "end": "1763039"
  },
  {
    "start": "1763000",
    "end": "2266000"
  },
  {
    "text": "okay so we have we have a question from uh from the live stream cool distribution be used locally on",
    "start": "1763919",
    "end": "1770080"
  },
  {
    "text": "kubernetes nodes to import images from a mounted distributed backend will that speed up the import of big images",
    "start": "1770080",
    "end": "1777760"
  },
  {
    "text": "yeah absolutely you can run you can repeat as well oh yes sorry the question was whether you can run distribution",
    "start": "1777760",
    "end": "1784000"
  },
  {
    "text": "inside a kubernetes cluster to give you some locality of where your images are the answer is yes that's a",
    "start": "1784000",
    "end": "1790080"
  },
  {
    "text": "really common use case for it you can run distribution pretty much anywhere and and like we alluded to",
    "start": "1790080",
    "end": "1796240"
  },
  {
    "text": "there's lots of different storage backends so you could store images on local disk you could store them in uh",
    "start": "1796240",
    "end": "1801919"
  },
  {
    "text": "local object storage like in your own cloud or in your own data center you can also use",
    "start": "1801919",
    "end": "1807120"
  },
  {
    "text": "s3 or s3 compatible storage so you can absolutely do that distribution does also have a mirroring",
    "start": "1807120",
    "end": "1814159"
  },
  {
    "text": "mode that's explicitly meant for that we don't use that for our registry we're using it in sort of the other",
    "start": "1814159",
    "end": "1821279"
  },
  {
    "text": "mode where it's the source of truth but that is an option that's there as well",
    "start": "1821279",
    "end": "1826880"
  },
  {
    "text": "um if you have to set the registry to read only how do you like stop",
    "start": "1828240",
    "end": "1833679"
  },
  {
    "text": "users not like pushing like how does that affect your users i guess",
    "start": "1833679",
    "end": "1839760"
  },
  {
    "text": "do you want to handle that well that would uh differ i mean that depends on how",
    "start": "1839760",
    "end": "1845840"
  },
  {
    "text": "uh how your product is implemented so at digitalocean we have a container registry product and",
    "start": "1845840",
    "end": "1852559"
  },
  {
    "text": "we use a bearer token a jwt for authentication",
    "start": "1852559",
    "end": "1857760"
  },
  {
    "text": "and they have an expiry set on them so when we when a user schedules garbage collection which",
    "start": "1857760",
    "end": "1864000"
  },
  {
    "text": "happens through the digitalocean api we mark the registry as read-only modes",
    "start": "1864000",
    "end": "1869519"
  },
  {
    "text": "and we no longer issue right capable jwts and then",
    "start": "1869519",
    "end": "1875760"
  },
  {
    "text": "the experience on our jwts i think is that 15 or 16 minutes so garbage",
    "start": "1875760",
    "end": "1881120"
  },
  {
    "text": "collection is then scheduled to begin once the last",
    "start": "1881120",
    "end": "1887120"
  },
  {
    "text": "last issued right enabled jwt has expired",
    "start": "1887120",
    "end": "1892559"
  },
  {
    "text": "thank you very much in the generic distribution i think it actually goes into a",
    "start": "1892559",
    "end": "1898159"
  },
  {
    "text": "different mode where it just doesn't accept any right requests but yeah since we are serving multiple users and we want them to each be able to garbage",
    "start": "1898159",
    "end": "1904240"
  },
  {
    "text": "collect independently we have to um yeah do some things with with tokens to make that work",
    "start": "1904240",
    "end": "1911600"
  },
  {
    "text": "yeah we can repeat your question standpoint yeah if we try to push an",
    "start": "1914880",
    "end": "1921519"
  },
  {
    "text": "image what we would return an error we'll just make it wait or sure so the question was uh with this",
    "start": "1921519",
    "end": "1927440"
  },
  {
    "text": "read only mode for garbage collection what's the user experience for that",
    "start": "1927440",
    "end": "1933120"
  },
  {
    "text": "the answer is that that you get effectively an authentication failure um",
    "start": "1933120",
    "end": "1938720"
  },
  {
    "text": "at least in our implementation of it i think in the generic implementation [Music] you get either an authentication failure",
    "start": "1938720",
    "end": "1945039"
  },
  {
    "text": "or some other kind of http error back if you try and do a write operation",
    "start": "1945039",
    "end": "1951519"
  },
  {
    "text": "so there's no like backlog of requests or anything like that it's on the user to retry",
    "start": "1951519",
    "end": "1959200"
  },
  {
    "text": "it since uh the digest is pushed at the end of uh lightning and how is the",
    "start": "1960840",
    "end": "1967120"
  },
  {
    "text": "simultaneous uh pushing the same layer handle sure so the question was um",
    "start": "1967120",
    "end": "1973279"
  },
  {
    "text": "given that the client doesn't provide the digest until the end of the the layer push how do you handle simultaneous uploads of the the same",
    "start": "1973279",
    "end": "1980080"
  },
  {
    "text": "layer potentially um the answer is it would just get uploaded twice and and the last one will win",
    "start": "1980080",
    "end": "1986159"
  },
  {
    "text": "they're going to get uploaded into the same at the end of that upload they're going to be moved into the same location in",
    "start": "1986159",
    "end": "1992320"
  },
  {
    "text": "the backend storage um so that the second one will will end up overriding the first one but they have",
    "start": "1992320",
    "end": "1997919"
  },
  {
    "text": "the same content remember because they have the same digest so so that's okay but there are definitely are cases like",
    "start": "1997919",
    "end": "2004159"
  },
  {
    "text": "that where you're going to end up with a double push if you have the same layer being pushed twice simultaneously",
    "start": "2004159",
    "end": "2010880"
  },
  {
    "text": "that answer the question yep",
    "start": "2010880",
    "end": "2015799"
  },
  {
    "text": "where are labels stored by looking like tags",
    "start": "2019120",
    "end": "2023919"
  },
  {
    "text": "yeah i believe the key value labels in docker become part of the manifest i'm not 100 sure about that though so i",
    "start": "2030559",
    "end": "2037440"
  },
  {
    "text": "would have to yeah do you do you know wayne well i'm not i don't know if i can answer that question specifically but",
    "start": "2037440",
    "end": "2042880"
  },
  {
    "text": "one thing we didn't uh cover here is what a manifest is which is a it's it is",
    "start": "2042880",
    "end": "2048638"
  },
  {
    "text": "itself a json blob so it gets stored actually as a blob um in the registry",
    "start": "2048639",
    "end": "2055118"
  },
  {
    "text": "uh and it and it contains all of the information about your image and like not just the layers but different",
    "start": "2055119",
    "end": "2061280"
  },
  {
    "text": "annotations and you know the time it was created um",
    "start": "2061280",
    "end": "2066398"
  },
  {
    "text": "largely dependent on the runtime that built the image so different runtimes may have different",
    "start": "2066399",
    "end": "2073760"
  },
  {
    "text": "extra metadata they add to the manifest but but yeah it's a it's a json blob that gets stored similar to",
    "start": "2073760",
    "end": "2080800"
  },
  {
    "text": "layer blobs",
    "start": "2080800",
    "end": "2084040"
  },
  {
    "text": "the image and you by digest does are we using the repo digest or the",
    "start": "2088079",
    "end": "2093358"
  },
  {
    "text": "image id uh yeah so the question is when you push an image and you're using the",
    "start": "2093359",
    "end": "2100160"
  },
  {
    "text": "digest is it the the image digest or the image id so i think the image id is specific to",
    "start": "2100160",
    "end": "2107920"
  },
  {
    "text": "your container runtime so your your sort of local container client um what gets used for the upload is that",
    "start": "2107920",
    "end": "2115520"
  },
  {
    "text": "the digest of the manifest so it is the the hash of the manifest uh contents so",
    "start": "2115520",
    "end": "2121280"
  },
  {
    "text": "like wayne said that the manifest is a json file basically um so you take a hash of that json file",
    "start": "2121280",
    "end": "2127680"
  },
  {
    "text": "and that's the image digest",
    "start": "2127680",
    "end": "2131720"
  },
  {
    "text": "great any other questions or are we oh yeah it won't work",
    "start": "2133760",
    "end": "2139759"
  },
  {
    "text": "so the most popular one is",
    "start": "2139839",
    "end": "2144200"
  },
  {
    "text": "yeah so the question is what digest algorithms are supported for the",
    "start": "2145839",
    "end": "2152960"
  },
  {
    "text": "the hash digests and there are two officially supported by the spec that shaw 256 in sha 512. in",
    "start": "2152960",
    "end": "2160880"
  },
  {
    "text": "theory um somebody could propose another one like shaw 384 i think i think shot 384 is mentioned in the",
    "start": "2160880",
    "end": "2167839"
  },
  {
    "text": "in the docs if you if you read the spec itself but it's not like officially meant to be supported",
    "start": "2167839",
    "end": "2173520"
  },
  {
    "text": "and that that actually uh gets into a tricky area of because you",
    "start": "2173520",
    "end": "2178880"
  },
  {
    "text": "have to verify the digest at when you receive the blob so if you're getting the chunked blob upload and you don't",
    "start": "2178880",
    "end": "2184800"
  },
  {
    "text": "have the digest itself for the blob until the last post or put",
    "start": "2184800",
    "end": "2191040"
  },
  {
    "text": "request what uh",
    "start": "2191040",
    "end": "2196240"
  },
  {
    "text": "what algorithm should you choose when you're you know calculating that digest over the course",
    "start": "2196240",
    "end": "2202560"
  },
  {
    "text": "of several patch requests so the default is just sha-256 um that's",
    "start": "2202560",
    "end": "2208240"
  },
  {
    "text": "in fact the only uh algorithm i've seen in use in practice when whenever i'm supporting a",
    "start": "2208240",
    "end": "2214720"
  },
  {
    "text": "customer who has a problem with a container registry um but yeah if",
    "start": "2214720",
    "end": "2219839"
  },
  {
    "text": "so so that's the only one that distribution calculates by default if at the end of a chunked upload",
    "start": "2219839",
    "end": "2226560"
  },
  {
    "text": "uh the digest really shocked 512 then distribution will go and download the",
    "start": "2226560",
    "end": "2231599"
  },
  {
    "text": "entire blob from the back end and recalculate it at whatever algorithm was specified but you could also in theory",
    "start": "2231599",
    "end": "2238320"
  },
  {
    "text": "calculate all supported algorithms in in uh like you know concurrently um as you're taking the the chunk upload",
    "start": "2238320",
    "end": "2246400"
  },
  {
    "text": "does that answer your question i kind of got off on a tangent there okay all right i think we're a little over time",
    "start": "2246400",
    "end": "2251440"
  },
  {
    "text": "so we'll probably wrap up the questions now but feel free to come and chat with us afterwards as well and",
    "start": "2251440",
    "end": "2258079"
  },
  {
    "text": "grab some stickers thanks everyone [Applause]",
    "start": "2258079",
    "end": "2268019"
  }
]