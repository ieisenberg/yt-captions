[
  {
    "text": "okay welcome to the cloud native build packs deep dive thank you for burning the midnight oil",
    "start": "60",
    "end": "5759"
  },
  {
    "text": "with us here and I was like one of the last sessions of the day everybody's probably pretty tired I'm tired my",
    "start": "5759",
    "end": "13410"
  },
  {
    "text": "name's Jo Kutner I'm gonna be talking about climbing to build packs which is a cloud native sandbox project in the CN",
    "start": "13410",
    "end": "20609"
  },
  {
    "text": "CF it was founded by pivotal and Heroku but we now have contributions from many",
    "start": "20609",
    "end": "26340"
  },
  {
    "text": "organizations including Google Microsoft and others so I work at Heroku I work on",
    "start": "26340",
    "end": "33000"
  },
  {
    "text": "the languages team Roku's of platform-as-a-service we host more than 10 million applications and handle about",
    "start": "33000",
    "end": "39329"
  },
  {
    "text": "23 billion requests per day on the languages team we do the engineering work that provides the support for our",
    "start": "39329",
    "end": "46140"
  },
  {
    "text": "official languages and one of the tools that we have to do that is build packs",
    "start": "46140",
    "end": "51710"
  },
  {
    "text": "so build packs if you've ever used to Roku you've used build packs they're the",
    "start": "51710",
    "end": "56760"
  },
  {
    "text": "mechanism that prepares an application for running on our platform we originally created them about eight",
    "start": "56760",
    "end": "63329"
  },
  {
    "text": "years ago as an extension point for the platform so that our users could add",
    "start": "63329",
    "end": "68930"
  },
  {
    "text": "customize the images and add support for other ecosystems and languages that we",
    "start": "68930",
    "end": "74130"
  },
  {
    "text": "didn't support so over time other organizations adopted build packs the",
    "start": "74130",
    "end": "80850"
  },
  {
    "text": "build pack API and then we started diverging and sort of implementing Heroku specific things and Cloud Foundry",
    "start": "80850",
    "end": "86909"
  },
  {
    "text": "specific things and so cloud native build packs as an effort to bring those api's back together and to join them",
    "start": "86909",
    "end": "94110"
  },
  {
    "text": "with the docker container ecosystem so at a very high level build packs take",
    "start": "94110",
    "end": "99600"
  },
  {
    "text": "source code as input they detect what kind of application you have from your source code repository and then they",
    "start": "99600",
    "end": "106829"
  },
  {
    "text": "prepare that application for production depending on what kind of app it is so if it if it is a Java maven app it'll",
    "start": "106829",
    "end": "113280"
  },
  {
    "text": "install the JDK run maven download your dependencies compile your source code if it's if it's a node.js app it'll run NPM",
    "start": "113280",
    "end": "120719"
  },
  {
    "text": "and download your node modules the out pack the output of the build packs build is a docker image that has layers that",
    "start": "120719",
    "end": "127950"
  },
  {
    "text": "map logically to your application this is different from like",
    "start": "127950",
    "end": "133170"
  },
  {
    "text": "a docker image created from a docker file where the layers are arbitrarily derived from directives in the docker",
    "start": "133170",
    "end": "140220"
  },
  {
    "text": "file so because of this well-defined structure and the MIDI data that goes with it that tells us what's in the",
    "start": "140220",
    "end": "146100"
  },
  {
    "text": "layers we can perform operations that would otherwise not be possible so the",
    "start": "146100",
    "end": "152190"
  },
  {
    "text": "bill packs themselves are just one part of the build pack ecosystem in fact the cloud native build packs project does",
    "start": "152190",
    "end": "158550"
  },
  {
    "text": "not maintain any build packs the bill pack implementations themselves come from third parties like Roku and Cloud",
    "start": "158550",
    "end": "164790"
  },
  {
    "text": "Foundry and others what the project does maintain is what we call a platform this is essentially an environment that's",
    "start": "164790",
    "end": "171600"
  },
  {
    "text": "capable of running build packs so the PAC CLI is a sort of reference implementation of a platform you can use",
    "start": "171600",
    "end": "178230"
  },
  {
    "text": "it to run build packs on your local workstation or in a CI environment we also maintain a Tecton template so that",
    "start": "178230",
    "end": "185010"
  },
  {
    "text": "you can use Tecton as a build packs platform the implementation or what we",
    "start": "185010",
    "end": "190470"
  },
  {
    "text": "call the lifecycle is the build pack execution environment and we maintain this as part of the project we also",
    "start": "190470",
    "end": "197130"
  },
  {
    "text": "maintain lib build pack which is a go library that build pack authors can use to make it easier for them to implement",
    "start": "197130",
    "end": "203130"
  },
  {
    "text": "the build pack specification and of course the project maintains the spec itself the core API is that define how",
    "start": "203130",
    "end": "210630"
  },
  {
    "text": "Bill packs work and how it interacts with the different components we also have an RFC process that we use to",
    "start": "210630",
    "end": "216350"
  },
  {
    "text": "propose changes and discuss you know various changes to the project so to",
    "start": "216350",
    "end": "223290"
  },
  {
    "text": "visualize how these different components work together at one end of the spectrum we have the build packs themselves which",
    "start": "223290",
    "end": "228959"
  },
  {
    "text": "are the part that actually touches your code and runs against your app the life cycle runs build packs so it's the",
    "start": "228959",
    "end": "236239"
  },
  {
    "text": "executor of the build packs and then beyond that we have the platform which is the environment that knows how to put",
    "start": "236239",
    "end": "242700"
  },
  {
    "text": "all this together and run the whole build pack system so between each of these layers we have a well defined API",
    "start": "242700",
    "end": "249810"
  },
  {
    "text": "the specification which describes how these layers interact with each other and that essentially allows us to mix",
    "start": "249810",
    "end": "256530"
  },
  {
    "text": "and match or swap out different implementations of each of these components so the build packs of course we have different build packs for",
    "start": "256530",
    "end": "262950"
  },
  {
    "text": "different languages Java node Ruby and then from different vendors like Heroku and Cloud Foundry the",
    "start": "262950",
    "end": "269520"
  },
  {
    "text": "platform I mentioned Tecton and the PAC CLI there's also the pivotal kpac",
    "start": "269520",
    "end": "276840"
  },
  {
    "text": "project Salesforce Heroku and Google cloud run button there's many other",
    "start": "276840",
    "end": "282180"
  },
  {
    "text": "platforms coming around day-to-day so a lot of options there so the lifecycle",
    "start": "282180",
    "end": "289440"
  },
  {
    "text": "execute the build pack API and just to recap what we talked about in the intro",
    "start": "289440",
    "end": "294479"
  },
  {
    "text": "talk yesterday this API has several phases the first phase is detect this is",
    "start": "294479",
    "end": "301770"
  },
  {
    "text": "where a build PAC determines whether it should or should not run against a given source code repository so in most cases",
    "start": "301770",
    "end": "308009"
  },
  {
    "text": "this is just looking at the source code to see if particular files exist for example package.json would indicate that",
    "start": "308009",
    "end": "313770"
  },
  {
    "text": "it's a node.js app the restore and analyze phases are run by the lifecycle",
    "start": "313770",
    "end": "319469"
  },
  {
    "text": "the built by execution environment and they analyze the cache and then the meta",
    "start": "319469",
    "end": "324629"
  },
  {
    "text": "data for previously built run images if they're available to determine what",
    "start": "324629",
    "end": "330060"
  },
  {
    "text": "layers can or cannot be reused the build phase is kind of the heavy lifting of",
    "start": "330060",
    "end": "335789"
  },
  {
    "text": "the build packs each build pack implements this differently it's specific to the ecosystem that a build",
    "start": "335789",
    "end": "341610"
  },
  {
    "text": "pack supports so for example a no js' build pack would install nodejs run npm",
    "start": "341610",
    "end": "348110"
  },
  {
    "text": "and prepare the application prepare the node application for a node build pack",
    "start": "348110",
    "end": "354469"
  },
  {
    "text": "the one of the outputs of the build process is artifacts or essentially",
    "start": "354469",
    "end": "361590"
  },
  {
    "text": "layers and in the export and cache phase the exporter the lifecycle takes these",
    "start": "361590",
    "end": "368039"
  },
  {
    "text": "layers and compiles them into a no CI image it will take some of the layers and put them in a cache which can be",
    "start": "368039",
    "end": "374639"
  },
  {
    "text": "stored as a cache image or as just like a persistent volume okay so that's just",
    "start": "374639",
    "end": "382050"
  },
  {
    "text": "kind of recapping the intro now we're gonna take a very close look at some actual build pack implementations from",
    "start": "382050",
    "end": "389190"
  },
  {
    "text": "Heroku and then Stephens going to talk about some Cloud Foundry build tags so",
    "start": "389190",
    "end": "396680"
  },
  {
    "text": "all the stuff we're gonna talk about in this deep dive isn't something you need to know in order to use build packs you",
    "start": "396680",
    "end": "402020"
  },
  {
    "text": "just want to use build packs you can run a command like pack build against your source code repository it produces an",
    "start": "402020",
    "end": "407449"
  },
  {
    "text": "image prepares it for you know to run with like commands like docker run or to be pushed with docker push that's how",
    "start": "407449",
    "end": "415310"
  },
  {
    "text": "most people will use build packs but we're gonna get into what's going on when you run this pack build command so",
    "start": "415310",
    "end": "422449"
  },
  {
    "text": "your first thing you'll notice is that we're passing a flag to this command the builder flag with the Heroku build packs",
    "start": "422449",
    "end": "428590"
  },
  {
    "text": "image and then that's running the Heroku Java build pack that builder image is an",
    "start": "428590",
    "end": "435380"
  },
  {
    "text": "important construct in cloud native build packs language a builder image",
    "start": "435380",
    "end": "440509"
  },
  {
    "text": "encapsulate all the artifacts that a platform needs in order to run build packs so that includes the build packs",
    "start": "440509",
    "end": "446539"
  },
  {
    "text": "themselves it also includes the lifecycle to execute those build packs and then a base image that will be used",
    "start": "446539",
    "end": "452960"
  },
  {
    "text": "to create the container that all this will run in so we define all of those components in a file that we call",
    "start": "452960",
    "end": "459590"
  },
  {
    "text": "typically call the Builder tamil and we passed that builder tamil to a create builder process that produces a OCI",
    "start": "459590",
    "end": "467300"
  },
  {
    "text": "image that is the Builder image so if we look at the builder tamil for that",
    "start": "467300",
    "end": "472659"
  },
  {
    "text": "Heroku build packs image it first defines the lifecycle version that is",
    "start": "472659",
    "end": "478580"
  },
  {
    "text": "compatible with and then it defines the stack that it runs on so this this",
    "start": "478580",
    "end": "484520"
  },
  {
    "text": "builder image runs on the Heroku 18 stack a stack is another important term",
    "start": "484520",
    "end": "490580"
  },
  {
    "text": "and and build pack language stack represents two images one is used for",
    "start": "490580",
    "end": "495740"
  },
  {
    "text": "build to create the container that bill packs run in and then another is used as the base image for what we call the",
    "start": "495740",
    "end": "501229"
  },
  {
    "text": "launch image which is the image that's output from the build pack execution process so the Heroku build packs are",
    "start": "501229",
    "end": "510080"
  },
  {
    "text": "based on the Heroku 18 stack this is a base image that's maintained by Heroku",
    "start": "510080",
    "end": "515959"
  },
  {
    "text": "as part of the Heroku platform so if you've ever used to Roku you use this stack it runs as part as part of the",
    "start": "515959",
    "end": "522620"
  },
  {
    "text": "platform it's based on a boon to Bionic with some system packages pre-installed",
    "start": "522620",
    "end": "528079"
  },
  {
    "text": "that we provide updates for so you can download this from docker hub there is the Roku 18 and Heroku 18 build",
    "start": "528079",
    "end": "535580"
  },
  {
    "text": "images the build image contains dev headers and other tools that you need to",
    "start": "535580",
    "end": "540680"
  },
  {
    "text": "compile and prepare your app for production the Heroku 18 image is slimmer and just has only what's",
    "start": "540680",
    "end": "547580"
  },
  {
    "text": "necessary for runtime but any case these two images provide the foundation for",
    "start": "547580",
    "end": "553130"
  },
  {
    "text": "the cloud native build pack stack to create that stack we have to add a few more layers on top of this we define a",
    "start": "553130",
    "end": "559910"
  },
  {
    "text": "few CNB underscore environment variables these environment variables are defined as part of the build pack API",
    "start": "559910",
    "end": "566840"
  },
  {
    "text": "specification we defined the CMB user ID and group ID for the user that bill",
    "start": "566840",
    "end": "572390"
  },
  {
    "text": "packs will run as bill packs do not run as root it's a feature and then the CMB",
    "start": "572390",
    "end": "577610"
  },
  {
    "text": "stack ID so that the platform can know what what stack it's actually working",
    "start": "577610",
    "end": "582680"
  },
  {
    "text": "with so if you were to create your own stack from whatever flavor of Linux or whatever base image you want you do",
    "start": "582680",
    "end": "589340"
  },
  {
    "text": "something similar to this have your from directive and then add those just those",
    "start": "589340",
    "end": "594710"
  },
  {
    "text": "essential environment variables so this is the docker file for the build image the docker file for the run image is",
    "start": "594710",
    "end": "602030"
  },
  {
    "text": "pretty much identical with just a different from directive okay so coming",
    "start": "602030",
    "end": "608810"
  },
  {
    "text": "back to the Builder Tommo after we've defined our lifecycle and our stack we then define the build packs that are",
    "start": "608810",
    "end": "614330"
  },
  {
    "text": "going to go into this image so the Heroku build packs include I think about",
    "start": "614330",
    "end": "619370"
  },
  {
    "text": "I think is about 10 of them in this image they map to the languages that we officially support Java nodejs",
    "start": "619370",
    "end": "626270"
  },
  {
    "text": "ruby some others and then there's a few utility build packs like the Heroku proc file build pack and I'll describe what",
    "start": "626270",
    "end": "632660"
  },
  {
    "text": "that does in a minute in addition to the build packs themselves we also define what order they run in so when the",
    "start": "632660",
    "end": "639230"
  },
  {
    "text": "lifecycle executes the detection phase for build packs it's going to execute them in the order that we've defined",
    "start": "639230",
    "end": "645170"
  },
  {
    "text": "here and the first one that passes detection is the one that it'll use during the build phase so we can define",
    "start": "645170",
    "end": "651260"
  },
  {
    "text": "individual build packs in our order or we can define groups of build packs that must all pass in order for that group to",
    "start": "651260",
    "end": "657860"
  },
  {
    "text": "succeed or we can have as I'm showing here some optional build packs where if they fail detection",
    "start": "657860",
    "end": "663379"
  },
  {
    "text": "bill packs in that group will still execute okay so that's everything that",
    "start": "663379",
    "end": "669559"
  },
  {
    "text": "goes into the Builder tamil for the Heroku builder image we then pass that to the pack create builder command which",
    "start": "669559",
    "end": "676999"
  },
  {
    "text": "will handle creating the image for us it'll add the build packs to a well-defined directory",
    "start": "676999",
    "end": "682309"
  },
  {
    "text": "it'll inject the lifecycle binaries it'll validate that those CMB underscore environment variables are set up",
    "start": "682309",
    "end": "687679"
  },
  {
    "text": "correctly and do some other stuff to prepare that OCI image so that we can run it the output is the Heroku build",
    "start": "687679",
    "end": "695449"
  },
  {
    "text": "packs 18 builder and then that is built on top of the Heroku pack 18 and pack 18",
    "start": "695449",
    "end": "700699"
  },
  {
    "text": "build stack okay so as I mentioned the Brooker build packs image contains a",
    "start": "700699",
    "end": "707689"
  },
  {
    "text": "number of different build packs at support different languages but we're gonna focus on the Heroku Java build",
    "start": "707689",
    "end": "713329"
  },
  {
    "text": "pack so this is a build pack that's been running in production for many years on the Heroku platform but with the older",
    "start": "713329",
    "end": "720109"
  },
  {
    "text": "build pack API implemented so we wanted to sort of bring this build pack into",
    "start": "720109",
    "end": "725869"
  },
  {
    "text": "the cloud native build pack ecosystem so we've modified it to support both api's",
    "start": "725869",
    "end": "733419"
  },
  {
    "text": "because it's an older build as that are essential so any cloud native build pack",
    "start": "733419",
    "end": "740720"
  },
  {
    "text": "must have at least these files two executables been build and been detect",
    "start": "740720",
    "end": "745999"
  },
  {
    "text": "these map to the two entry points in the lifecycle phases for detect and build",
    "start": "745999",
    "end": "751369"
  },
  {
    "text": "those executables can be bash scripts that can be binaries written with go they could be Python scripts there's",
    "start": "751369",
    "end": "758239"
  },
  {
    "text": "nothing in the bill pack specification that defines how you write these these",
    "start": "758239",
    "end": "763609"
  },
  {
    "text": "files they're just executables the third file is a build pack descriptor called bill pack tamil this defines submitted",
    "start": "763609",
    "end": "771289"
  },
  {
    "text": "it about the build pack so this is the build pack tamil for the Heroku Java build pack defines its api compatibility",
    "start": "771289",
    "end": "778009"
  },
  {
    "text": "version it's globally unique ID it's version and then what stack it is compatible with so the Heroku build",
    "start": "778009",
    "end": "784819"
  },
  {
    "text": "packs are only compatible with the Heroku 18 stack and each built a Cawthra determines what stacks they intend to",
    "start": "784819",
    "end": "790789"
  },
  {
    "text": "support with a particular build pack so the bin detect executable is responsible",
    "start": "790789",
    "end": "797160"
  },
  {
    "text": "that first part of the lifecycle execution phase it's very simple it looks at the source code repository",
    "start": "797160",
    "end": "803579"
  },
  {
    "text": "which is provided as one of the inputs to the detection it looks at that repository for a pom.xml if it sees a",
    "start": "803579",
    "end": "809550"
  },
  {
    "text": "pom.xml it'll pass otherwise it will not pass that pom.xml indicates that this is",
    "start": "809550",
    "end": "814769"
  },
  {
    "text": "a Java maven project and it knows how to build those one of the outputs of the detection phase is a build plan so the",
    "start": "814769",
    "end": "822029"
  },
  {
    "text": "the detects script will add to the build plan the components that it either provides or requires as part of its",
    "start": "822029",
    "end": "828750"
  },
  {
    "text": "execution so the Java build pack is going to provide a JDK so it writes to that build plan the JDK is something it",
    "start": "828750",
    "end": "835680"
  },
  {
    "text": "provides then on to the bin build executable this takes as input the same",
    "start": "835680",
    "end": "842970"
  },
  {
    "text": "source code repository that was passed to the detect phase and it also takes the resolved build plan so the resolved",
    "start": "842970",
    "end": "849720"
  },
  {
    "text": "build plan contains the components that were provided by the bin detect script",
    "start": "849720",
    "end": "855120"
  },
  {
    "text": "from this build pack as well as other build packs that may have run in conjunction with this build pack so if",
    "start": "855120",
    "end": "860519"
  },
  {
    "text": "we're running for example a node.js build pack with our Java build pack are resolved bill plan might have a no js'",
    "start": "860519",
    "end": "867060"
  },
  {
    "text": "in treatment so the build pack can look at that build plan to determine what it needs to install or what is available to",
    "start": "867060",
    "end": "873720"
  },
  {
    "text": "it so the heavy lifting of the bin build script is installing the JDK running",
    "start": "873720",
    "end": "880380"
  },
  {
    "text": "maven downloading your dependencies compiling your code and then producing those Java artifacts that represent the",
    "start": "880380",
    "end": "886199"
  },
  {
    "text": "application one of the outputs of that process is several layers that represent",
    "start": "886199",
    "end": "891899"
  },
  {
    "text": "the JDK the maven dependency cash and the JRE but each of these layers has a",
    "start": "891899",
    "end": "898860"
  },
  {
    "text": "different scope or sort of a different visibility some layers will be used as part of the cache because we want them",
    "start": "898860",
    "end": "905100"
  },
  {
    "text": "available on subsequent builds but some of those layers we do not want in that final launch image in fact the JDK which",
    "start": "905100",
    "end": "912839"
  },
  {
    "text": "contains the Java C command the compiler and some other development tooling is",
    "start": "912839",
    "end": "917939"
  },
  {
    "text": "meant for the build image only the JRE which is the Java runtime environment is what we actually want in the launch",
    "start": "917939",
    "end": "923220"
  },
  {
    "text": "image so we can define each of those layers as having different scopes similarly for the maven dependency cache",
    "start": "923220",
    "end": "929759"
  },
  {
    "text": "we don't want even in our production image and the dependency cache is very large so we only want that in our cache image the",
    "start": "929759",
    "end": "937780"
  },
  {
    "text": "build scope is a little different it's not actually like a layer that's going to be put into any image this just means",
    "start": "937780",
    "end": "943360"
  },
  {
    "text": "that it is visible to subsequent build packs that may need to use the JDK as part of their execution each of those",
    "start": "943360",
    "end": "953110"
  },
  {
    "text": "layers has a standard POSIX file format structure to them so this allows us or",
    "start": "953110",
    "end": "959470"
  },
  {
    "text": "allows build packs to do some things kind of magically for you each layers bin directory will be put on the path",
    "start": "959470",
    "end": "966070"
  },
  {
    "text": "the Lib directory will be put on the load path and then we can also set up environment variables and profile",
    "start": "966070",
    "end": "971470"
  },
  {
    "text": "scripts that will be provided as part of the launch image so that when your application starts up those are there",
    "start": "971470",
    "end": "977860"
  },
  {
    "text": "for you things like Java home the last file here is what we call a layer",
    "start": "977860",
    "end": "983020"
  },
  {
    "text": "descriptor or a layer tamil file so each layer has one of these descriptors that goes along with the layer and it tells",
    "start": "983020",
    "end": "990250"
  },
  {
    "text": "us what the what scopes the layer is for so for that jdk tamil we see that launch",
    "start": "990250",
    "end": "997210"
  },
  {
    "text": "is false because we don't want the jdk in our final run image but building cache are true because we do want to",
    "start": "997210",
    "end": "1003330"
  },
  {
    "text": "expose it to subsequent build packs and cache it we can also put some mated it in this file like the version of the JDK",
    "start": "1003330",
    "end": "1009120"
  },
  {
    "text": "that's been installed and then we have a cache ID that allows us to just easily expire it so if we compare that to the",
    "start": "1009120",
    "end": "1016680"
  },
  {
    "text": "JRE Tamil very similar just has a different scope for launch we do want",
    "start": "1016680",
    "end": "1021720"
  },
  {
    "text": "the JRE and the final lunch launch image and we don't want it as available to",
    "start": "1021720",
    "end": "1026880"
  },
  {
    "text": "subsequent builds the last thing the Heroku Java build pack does is try to",
    "start": "1026880",
    "end": "1033300"
  },
  {
    "text": "determine the Java command to use to start this app that it can set as essentially as the entry point for the",
    "start": "1033300",
    "end": "1039270"
  },
  {
    "text": "image it does this by looking at the pom.xml looking at your dependencies so for example if it sees a spring boot",
    "start": "1039270",
    "end": "1045780"
  },
  {
    "text": "dependency and an executable jar file in the target directory it knows that some Java - jar command is the process you",
    "start": "1045780",
    "end": "1052230"
  },
  {
    "text": "probably want to run sometimes it doesn't get it right or sometimes you want to override that and that's where",
    "start": "1052230",
    "end": "1059070"
  },
  {
    "text": "the proc file build pack comes in so the the group in the Groo builder that has Java includes the",
    "start": "1059070",
    "end": "1066340"
  },
  {
    "text": "karoku proc file build pack optionally the proc file build pack is meant to support proc file which is a part of the",
    "start": "1066340",
    "end": "1073420"
  },
  {
    "text": "original Roku bill pack API but it's not a part of the cloud native build pack",
    "start": "1073420",
    "end": "1078550"
  },
  {
    "text": "API but for our customers for our Heroku users we wanted them who already have a",
    "start": "1078550",
    "end": "1083590"
  },
  {
    "text": "proc file and many of the repositories we wanted to provide that same experience for them so if you're not",
    "start": "1083590",
    "end": "1088840"
  },
  {
    "text": "familiar with the proc file it's just simply a very flattened yamo file with a key that is the process type or the",
    "start": "1088840",
    "end": "1094300"
  },
  {
    "text": "process name and then a command that is the command you want to execute for that process type so for example a simple",
    "start": "1094300",
    "end": "1100330"
  },
  {
    "text": "Java app would have a web process type and then a Java dash jar command to start the app so the detects script for",
    "start": "1100330",
    "end": "1108220"
  },
  {
    "text": "the proc file build pack is very simple it looks at the source code repository for a proc file if it sees that it",
    "start": "1108220",
    "end": "1113830"
  },
  {
    "text": "passes if it does not it doesn't pass it doesn't contribute anything to the build plan because it's not creating or",
    "start": "1113830",
    "end": "1120220"
  },
  {
    "text": "providing any components the build phase for the proc file build pack reads that",
    "start": "1120220",
    "end": "1127000"
  },
  {
    "text": "proc file at Yamma and converts it into the launch tamil process table so the",
    "start": "1127000",
    "end": "1132280"
  },
  {
    "text": "launch tom wall from derived from the proc file that i showed earlier would look like this in a launch tamil so",
    "start": "1132280",
    "end": "1139900"
  },
  {
    "text": "because this build pack runs after the java build pack if it was to create a process type that was already defined by",
    "start": "1139900",
    "end": "1147280"
  },
  {
    "text": "the java build pack it would override that and the last one would win so you",
    "start": "1147280",
    "end": "1154270"
  },
  {
    "text": "can use the Roku Java build pack by running PAC build with the Heroku build packs builder just passing that - -",
    "start": "1154270",
    "end": "1161410"
  },
  {
    "text": "builder option if you have a Java repository that you're running against it should detect that and and run the",
    "start": "1161410",
    "end": "1168640"
  },
  {
    "text": "job build pack but if you want to be explicit you can also pass the - - bill pack flag coming in the next version of",
    "start": "1168640",
    "end": "1177430"
  },
  {
    "text": "the Java build pack will be taking advantage of a new feature in cloud native build packs called slices this",
    "start": "1177430",
    "end": "1184150"
  },
  {
    "text": "will this allows us to sort of carve up the application repository application directory into layers without creating",
    "start": "1184150",
    "end": "1191290"
  },
  {
    "text": "that separate you know POSIX file structure for a layer so we could for example take your dependencies and the",
    "start": "1191290",
    "end": "1197110"
  },
  {
    "text": "target directory in your classes and your config and put them in their own layers as well we're also going to",
    "start": "1197110",
    "end": "1203230"
  },
  {
    "text": "decompose the Java build pack into at least two build packs Heroku JVM build pack which just installs the JDK and the",
    "start": "1203230",
    "end": "1210490"
  },
  {
    "text": "JRE and then a maven build pack which does all the maven specific execution seperating I'm separating them into",
    "start": "1210490",
    "end": "1217540"
  },
  {
    "text": "these to build packs allows us to use the proko JVM build pack with other build packs like for example a Gradle",
    "start": "1217540",
    "end": "1224200"
  },
  {
    "text": "build pack so we can make them more modular so they can fit together in different ways so now I'm going to pass",
    "start": "1224200",
    "end": "1231460"
  },
  {
    "text": "it on to Steven who's going to talk a little bit more about build pack modularity and how build packs are run",
    "start": "1231460",
    "end": "1236830"
  },
  {
    "text": "in distributed environments yeah so I'm Steven Levine I work on things related",
    "start": "1236830",
    "end": "1243370"
  },
  {
    "text": "to kubernetes and cloud foundry for pivotal and I'm gonna I'm not gonna talk",
    "start": "1243370",
    "end": "1248470"
  },
  {
    "text": "about the Cloud Foundry build packs very directly but more about how we do builds",
    "start": "1248470",
    "end": "1253540"
  },
  {
    "text": "with the cloud foundry build packs in sort of distributed systems like Kate's using tools like pivotal K pack and so",
    "start": "1253540",
    "end": "1261760"
  },
  {
    "text": "just for some background Joe covered some of this Stax builders and build packages are composed of layers so a",
    "start": "1261760",
    "end": "1269080"
  },
  {
    "text": "stack is a build image where they you know build a base image where the build happens a run image which is sort of the",
    "start": "1269080",
    "end": "1276280"
  },
  {
    "text": "you know runtime base image for the application if you take the build image and you put a life cycle and some build",
    "start": "1276280",
    "end": "1281980"
  },
  {
    "text": "packs on it you get a builder right and so a build package is just sort of the",
    "start": "1281980",
    "end": "1287020"
  },
  {
    "text": "artifact format for a build pack so if you're talking about the cloud foundry node.js build pack it's actually you",
    "start": "1287020",
    "end": "1292090"
  },
  {
    "text": "know a series of sort of three build packs and a particular build configuration that it's composed of it's",
    "start": "1292090",
    "end": "1297160"
  },
  {
    "text": "not a sort of implemented as a build pack itself it just points to those other ones and a build package lets us sort of take all those build packs as",
    "start": "1297160",
    "end": "1303580"
  },
  {
    "text": "layers package it up in an OCI image that you can either you know push to docker registry or save as a dot C and B file",
    "start": "1303580",
    "end": "1309610"
  },
  {
    "text": "that's sort of the artifact format it so just fully self-contained own pack and if you take that build package and put",
    "start": "1309610",
    "end": "1316210"
  },
  {
    "text": "it on a build image with life cycle you get a builder and so that's sort of what that builder image looks like and then",
    "start": "1316210",
    "end": "1322120"
  },
  {
    "text": "if you take the builder and you you know run source code you sort of run the Builder in a platform with a source code",
    "start": "1322120",
    "end": "1327400"
  },
  {
    "text": "like a pack you get an app image out of the other side and so I'm gonna kind of run through what it looks like to do a rebuild of an",
    "start": "1327400",
    "end": "1334270"
  },
  {
    "text": "application in a distributed system and focus on the kind of rebuild time and the data transfer required because it",
    "start": "1334270",
    "end": "1340540"
  },
  {
    "text": "sort of exposes why we think this model is really interesting for doing really fast iteration against a cluster and",
    "start": "1340540",
    "end": "1348250"
  },
  {
    "text": "also there'll be a second example afterwards that shows you how we can roll out CV patches really quickly for",
    "start": "1348250",
    "end": "1353710"
  },
  {
    "text": "lots of applications but we're gonna do that first one first so if you you know",
    "start": "1353710",
    "end": "1360100"
  },
  {
    "text": "imagine you have a docker registry you know docker registry stores manifests image manifests and layers",
    "start": "1360100",
    "end": "1366700"
  },
  {
    "text": "which are like they're also called blobs they're just the things that get layered on top of each other before they run you",
    "start": "1366700",
    "end": "1373330"
  },
  {
    "text": "know when you do a docker run for instance so so you'd have a docker registry with a run image a build image",
    "start": "1373330",
    "end": "1379390"
  },
  {
    "text": "and a node build package and then you have sort of all the layers that those manifests point to those those",
    "start": "1379390",
    "end": "1386620"
  },
  {
    "text": "manifested sorry the layers aren't sort of linked to each other the manifests just define an ordering of those layers",
    "start": "1386620",
    "end": "1392200"
  },
  {
    "text": "that's kind of a common misconception in the docker v1 format the layers are kind of linked but now in the OCI or docker",
    "start": "1392200",
    "end": "1398830"
  },
  {
    "text": "b2 format that manifests just refer to a particular ordering and we can swap the not individually and you'll see what",
    "start": "1398830",
    "end": "1404140"
  },
  {
    "text": "that looks like and so if we we can make a builder by essentially just creating a new manifest in the registry that has",
    "start": "1404140",
    "end": "1411970"
  },
  {
    "text": "sort of strong references to the layers and the build image and a build package or kind of a weak reference to a run image so we know where to pull a run",
    "start": "1411970",
    "end": "1418000"
  },
  {
    "text": "image when we do a build and because this is just a manifest upload it involves virtually no data transfer",
    "start": "1418000",
    "end": "1424120"
  },
  {
    "text": "we're just uploading you know less than a kilobyte of sort of JSON configuration",
    "start": "1424120",
    "end": "1429610"
  },
  {
    "text": "to the registry to say hey this builder is composed of these parts that already exist and so when we want to do a build",
    "start": "1429610",
    "end": "1437290"
  },
  {
    "text": "we need to download the Builder and the Associated layers to the VM that's gonna run the pods that do the build and if a",
    "start": "1437290",
    "end": "1443620"
  },
  {
    "text": "build already happened here there was a node.js build that doesn't involve any data transfer because it's already there that the pot is already here that the VM",
    "start": "1443620",
    "end": "1450730"
  },
  {
    "text": "is already hydrated with those bits if it you know if the VM is a fresh VM",
    "start": "1450730",
    "end": "1455770"
  },
  {
    "text": "that's never done a node.js build you might have to download some of the build packs and so if we kind of ignore the",
    "start": "1455770",
    "end": "1461380"
  },
  {
    "text": "builder in the registry and let's say that you did a previous",
    "start": "1461380",
    "end": "1466700"
  },
  {
    "text": "build you know of this application where you have an old version of the app image",
    "start": "1466700",
    "end": "1472550"
  },
  {
    "text": "on the registry you know pointed it sort of sort of old application layers and the operating system packages and you also have a",
    "start": "1472550",
    "end": "1479390"
  },
  {
    "text": "local cache sort of in the VM that we're doing a build of the same application",
    "start": "1479390",
    "end": "1484940"
  },
  {
    "text": "because we you know in a distributed system you'd want to try to build rebuild on the same VMs that you're",
    "start": "1484940",
    "end": "1490520"
  },
  {
    "text": "building so that you can sort of get more cache hits sort of in that",
    "start": "1490520",
    "end": "1495920"
  },
  {
    "text": "configuration we would start pod in the VM that you know runs sort of runs the",
    "start": "1495920",
    "end": "1503420"
  },
  {
    "text": "Builder which has a life cycle inside of it on the source code which we would have to upload but the build packs when",
    "start": "1503420",
    "end": "1509210"
  },
  {
    "text": "they're run by the life cycle can actually look at the old build the old layers from the previous application build in the registry and say I only",
    "start": "1509210",
    "end": "1516380"
  },
  {
    "text": "need to rebuild you know these individual layers I don't have to rebuild say all the node modules or you",
    "start": "1516380",
    "end": "1522140"
  },
  {
    "text": "know whatever it might be and then during the build process that life cycle runs the build packs to regenerate just",
    "start": "1522140",
    "end": "1527690"
  },
  {
    "text": "those new layers that need to change and it also you know updates the cache with whatever you know sort of new things",
    "start": "1527690",
    "end": "1534620"
  },
  {
    "text": "need to be cached this is kind of different from docker where and a docker file if sort of lower-level",
    "start": "1534620",
    "end": "1540680"
  },
  {
    "text": "layer changes you have to rebuild them from the top here we can individually select what layers we want to build or",
    "start": "1540680",
    "end": "1546920"
  },
  {
    "text": "sorry rebuild and so you know after that",
    "start": "1546920",
    "end": "1551960"
  },
  {
    "text": "happens we update the cache and the sort of local VM and we upload that sort of",
    "start": "1551960",
    "end": "1557660"
  },
  {
    "text": "newly built dependency layers to the registry along with the sort of new manifest for the application notice that",
    "start": "1557660",
    "end": "1564740"
  },
  {
    "text": "it's reusing a lot of existing sort of dependency layers in addition to the new ones that it uploaded so we really",
    "start": "1564740",
    "end": "1570200"
  },
  {
    "text": "minimized the data transfer there to just just rebuild what you need to be what needs to be rebuilt and just upload",
    "start": "1570200",
    "end": "1575210"
  },
  {
    "text": "the new stuff into the registry and then when we switch over to the runtime VM that's running the old copy of the",
    "start": "1575210",
    "end": "1581000"
  },
  {
    "text": "application we can sort of you know",
    "start": "1581000",
    "end": "1586070"
  },
  {
    "text": "apply the new image manifest which will cause the new layers to and just the new layers to transfer over to the runtime",
    "start": "1586070",
    "end": "1592160"
  },
  {
    "text": "VM not existing not additional base layers nothing that was sort of already there from the previous",
    "start": "1592160",
    "end": "1597500"
  },
  {
    "text": "application and then you know restart the pod so that it you know it's running",
    "start": "1597500",
    "end": "1604850"
  },
  {
    "text": "the new application and so so that's an that was an example of what it looks like to rebuild an individual app right",
    "start": "1604850",
    "end": "1612100"
  },
  {
    "text": "there's some kinds of updates we can do with cloud native build packs where we're we want to patch CDs for lots of",
    "start": "1612100",
    "end": "1618140"
  },
  {
    "text": "applications at the same time and we can do this at the operating system level because we rely on a sort of strict ABI",
    "start": "1618140",
    "end": "1625160"
  },
  {
    "text": "compatibility contract where we can do we call it a rebase instead of a rebuild",
    "start": "1625160",
    "end": "1630620"
  },
  {
    "text": "we're replacing the lower layers with a strict contract that allows them gives us a guarantee I guess that the new",
    "start": "1630620",
    "end": "1636980"
  },
  {
    "text": "image is also a valid image and will run but also contains security patches from",
    "start": "1636980",
    "end": "1642200"
  },
  {
    "text": "operating system vendors and so this works by so like imagine you have a",
    "start": "1642200",
    "end": "1647660"
  },
  {
    "text": "docker registry and you have three apps in it and you have the run image that they were built with pointing at the operating system packages and then a CD",
    "start": "1647660",
    "end": "1655190"
  },
  {
    "text": "hits and so now all your apps are vulnerable in the registry maybe you have three maybe you have 500 apps right",
    "start": "1655190",
    "end": "1662680"
  },
  {
    "text": "we tend to sort of patch that CVE we can upload a single copy of the operating system packages to the dock of Industry",
    "start": "1662680",
    "end": "1669500"
  },
  {
    "text": "so think of that like you're uploading a boon to 18:04 like a new you know version of that that has a patch to open",
    "start": "1669500",
    "end": "1675710"
  },
  {
    "text": "SSL or something like that and then we just make a kind of really small update",
    "start": "1675710",
    "end": "1680870"
  },
  {
    "text": "to each of those image manifests to point at the new operating system layer without really doing incurring any other",
    "start": "1680870",
    "end": "1686570"
  },
  {
    "text": "data transfer other than that initial upload of the operating system packages to the registry and so now we patched",
    "start": "1686570",
    "end": "1692240"
  },
  {
    "text": "all the apps on the registry kind of instantaneously and so we start to",
    "start": "1692240",
    "end": "1697280"
  },
  {
    "text": "deploy that out right it's not done yes we patched all those applications but now they have to run in a cluster but",
    "start": "1697280",
    "end": "1702590"
  },
  {
    "text": "the way we've done this kind of allows us to deploy these really efficiently as long as we're using container D and not",
    "start": "1702590",
    "end": "1708200"
  },
  {
    "text": "docker D dr. D is very inefficient and will repol you know layers on top of",
    "start": "1708200",
    "end": "1714310"
  },
  {
    "text": "base layers if they change even if it already has those layers but container D can do this really efficiently and so",
    "start": "1714310",
    "end": "1720740"
  },
  {
    "text": "this works by so imagine you have you know several runtime VMs with different apps distributed across them and they",
    "start": "1720740",
    "end": "1727700"
  },
  {
    "text": "all are vulnerable to the CVE we can for the you know essentially do a docker pull into each of those our container",
    "start": "1727700",
    "end": "1735220"
  },
  {
    "text": "Depot and to each of those runtime VMs which will cause the operating system",
    "start": "1735220",
    "end": "1741580"
  },
  {
    "text": "packed the new operating system packages to get downloaded and the apps to kind of swap around automatically on each VM",
    "start": "1741580",
    "end": "1748090"
  },
  {
    "text": "and point to the new operating system packages note that we only had to download one copy the operating system packages per VM not per application and",
    "start": "1748090",
    "end": "1755500"
  },
  {
    "text": "so it's sort of maximally efficient in transferring just the layers that have the CD patches to each VM that needs to",
    "start": "1755500",
    "end": "1761770"
  },
  {
    "text": "run and you wouldn't be able to do this and a model like docker where you'd have to retransfer you have to rebuild on top",
    "start": "1761770",
    "end": "1768010"
  },
  {
    "text": "of a new base image and then re transfer all the newly built layers across so this is something you can do really fast",
    "start": "1768010",
    "end": "1773080"
  },
  {
    "text": "and it even extends into deployment and so to kind of wrap it up you know we",
    "start": "1773080",
    "end": "1778510"
  },
  {
    "text": "really like cloud native build packs because we think they're no reusable and they you know the bill packs are",
    "start": "1778510",
    "end": "1783880"
  },
  {
    "text": "reusable they reuse dependencies they reuse layers they're sort of very efficient and how they you know do data",
    "start": "1783880",
    "end": "1789789"
  },
  {
    "text": "deduplication they're fast because they only rebuild the stuff that's necessary they're modular because you can create",
    "start": "1789789",
    "end": "1795880"
  },
  {
    "text": "individual sort of modular build packs that are very single purpose and they're safe because you know you can get build",
    "start": "1795880",
    "end": "1802299"
  },
  {
    "text": "packs that are trusted by a vendor that knows what they're doing and can you know guaranteed that they're sort of configuring your app in a secure way and",
    "start": "1802299",
    "end": "1809650"
  },
  {
    "text": "that's it please try out the PAC CLI that's up on build packs IO you know we",
    "start": "1809650",
    "end": "1817960"
  },
  {
    "text": "have Doc's available you can also join us on slack we're really active on slack so please reach out and we have also",
    "start": "1817960",
    "end": "1825940"
  },
  {
    "text": "have a mailing list but it's pretty quiet and there's gonna be some",
    "start": "1825940",
    "end": "1830980"
  },
  {
    "text": "buildpack demos later today at the Salesforce both - if you want to talk to us more thank you",
    "start": "1830980",
    "end": "1838649"
  },
  {
    "text": "questions yeah so the question is we're",
    "start": "1843369",
    "end": "1856669"
  },
  {
    "text": "changing these layers out but the layers will you know handle in order to get the layers to run you'll have to restart",
    "start": "1856669",
    "end": "1862100"
  },
  {
    "text": "your pod with them right so we don't you know for what cloud need to build packs does we don't handle anything after the",
    "start": "1862100",
    "end": "1869149"
  },
  {
    "text": "updated images in the registry we can so we want to kind of solve that one problem really well but what we do do is",
    "start": "1869149",
    "end": "1874220"
  },
  {
    "text": "by sort of efficiently only updating the layers that need to change in the registry when you do that pod we start",
    "start": "1874220",
    "end": "1880070"
  },
  {
    "text": "you'll only get those layers downloaded onto the VM and so by the nature of how we publish it to the registry we can",
    "start": "1880070",
    "end": "1886100"
  },
  {
    "text": "make that deployment process really fast",
    "start": "1886100",
    "end": "1889690"
  },
  {
    "text": "sure yeah you could do that with the CI CD system we we kind of we've tried to solve just the problem of let's get to",
    "start": "1892480",
    "end": "1898549"
  },
  {
    "text": "the registry and stop there kind of solved one problem well but the way we do that does make it really easy to use tools to promote it through a CI",
    "start": "1898549",
    "end": "1905330"
  },
  {
    "text": "pipeline and you know whatever you want to do with it you know restart your pods and get it deployed out really quickly because of the data deduplication",
    "start": "1905330",
    "end": "1911059"
  },
  {
    "text": "they're over there",
    "start": "1911059",
    "end": "1916450"
  },
  {
    "text": "yeah it depends on the build pack so the Heroku Gradle build pack uses an like",
    "start": "1926890",
    "end": "1934540"
  },
  {
    "text": "well-defined environment variables that it will pick up and then either apply Gradle ops or something like that I can",
    "start": "1934540",
    "end": "1941530"
  },
  {
    "text": "remember some of the specifics the maven build pack similar functionality but",
    "start": "1941530",
    "end": "1946990"
  },
  {
    "text": "with different environment variables so it's really up to that build pack some of the packs could have their own like",
    "start": "1946990",
    "end": "1952480"
  },
  {
    "text": "manifest or descriptor that they would read in the Java bill pack actually does this with a properties file that defines",
    "start": "1952480",
    "end": "1958059"
  },
  {
    "text": "the JDK version to install for the yeah",
    "start": "1958059",
    "end": "1965980"
  },
  {
    "text": "so the Roku build packs are primarily written in bash they're like using bash as a controller to drive like smaller",
    "start": "1965980",
    "end": "1973600"
  },
  {
    "text": "sharper binaries in most cases I think the Cloud Foundry build packs are hundred percent written and go for your",
    "start": "1973600",
    "end": "1985270"
  },
  {
    "text": "back sorry",
    "start": "1985270",
    "end": "1987660"
  },
  {
    "text": "yes so there so the question is in the old build pack model we used to build on",
    "start": "2021890",
    "end": "2028020"
  },
  {
    "text": "the same sort of build image and run image and now we have separate bill damages and run images right there is a",
    "start": "2028020",
    "end": "2035310"
  },
  {
    "text": "little bit less of a guarantee in doing that in that if you're not very careful about what those images contain you",
    "start": "2035310",
    "end": "2041340"
  },
  {
    "text": "could end up with something that's missing during runtime this strong like the guarantees we care the most about",
    "start": "2041340",
    "end": "2047520"
  },
  {
    "text": "are that on updates of the run image it's a bi compatible and an update so the build image to newer build images",
    "start": "2047520",
    "end": "2053940"
  },
  {
    "text": "right it's a bi compatible between those two images it doesn't matter quite as much for a few reasons one is if your",
    "start": "2053940",
    "end": "2061408"
  },
  {
    "text": "app doesn't start sort of immediately you have fast feedback right between those two things the other is we can be",
    "start": "2061409",
    "end": "2068010"
  },
  {
    "text": "really careful to make sure that we only include things like compilers and that will be only exclude things like",
    "start": "2068010",
    "end": "2073200"
  },
  {
    "text": "compilers and the run image that we don't put we don't have C libraries that's something might link to on the",
    "start": "2073200",
    "end": "2079169"
  },
  {
    "text": "build image that aren't done at run image",
    "start": "2079169",
    "end": "2082550"
  },
  {
    "text": "there whatever the so the question is about the size of the those base images there whatever the platform that",
    "start": "2096970",
    "end": "2103060"
  },
  {
    "text": "provides that image decides so for Roku I think it is about 500 Meg's and we've chosen to make it larger to include more",
    "start": "2103060",
    "end": "2110650"
  },
  {
    "text": "things because it's part of our platform it's like what makes it a better experience for our customers to have those things available but I think",
    "start": "2110650",
    "end": "2118030"
  },
  {
    "text": "steven has some work on smaller images on the Cloud Foundry side we have a choice of three images someone is like a",
    "start": "2118030",
    "end": "2123190"
  },
  {
    "text": "large image that eggs are so for you know linking node modules you know that",
    "start": "2123190",
    "end": "2129700"
  },
  {
    "text": "might have made of dependencies things like that right but we also have like 20 Meg one that's just to go into Bionic",
    "start": "2129700",
    "end": "2135010"
  },
  {
    "text": "essentially with compilers and the build image we even now have one that has a distro list run image that's our own",
    "start": "2135010",
    "end": "2140380"
  },
  {
    "text": "kind of role of distro list on top of a bun - that's you know almost a small scratch it just has Gaea Lipsy in it I",
    "start": "2140380",
    "end": "2147430"
  },
  {
    "text": "think so you can make really small images especially if you're building would go we've really optimized that use case in the Clive founders side so you",
    "start": "2147430",
    "end": "2153670"
  },
  {
    "text": "can end up with something that's a sort of scratch like convenient image in the end so you shouldn't have problems with",
    "start": "2153670",
    "end": "2158740"
  },
  {
    "text": "that you know but in in addition to that you can also create your own custom stacks that have your own kind of cited",
    "start": "2158740",
    "end": "2165819"
  },
  {
    "text": "build packs in them you just have to make sure they maintain compatibility with the bill packs right",
    "start": "2165819",
    "end": "2171569"
  },
  {
    "text": "so the question is about build pack compatibility between platforms where",
    "start": "2192620",
    "end": "2197940"
  },
  {
    "text": "you know is it that you can only use Heroku bill packs on Heroku and cly finally build packs on clarity the answer to that is if you just look at",
    "start": "2197940",
    "end": "2205800"
  },
  {
    "text": "the new you know cloud they did build packs b3 project that lifecycle you know packs to run on that lifecycle are",
    "start": "2205800",
    "end": "2212010"
  },
  {
    "text": "always compatible across all different platforms so there'll be real complete compatibility you can run the cloud plan",
    "start": "2212010",
    "end": "2217590"
  },
  {
    "text": "to build packs on Heroku at Heroku build packs on Cloud Foundry and we're even starting to invest in defining our",
    "start": "2217590",
    "end": "2224130"
  },
  {
    "text": "stacks so that you can mix and match cloud foundry and Heroku build packs within the same build potentially in the",
    "start": "2224130",
    "end": "2229530"
  },
  {
    "text": "future too although there's still a lot of discussions about how we want to do that so the compatibility is really",
    "start": "2229530",
    "end": "2234720"
  },
  {
    "text": "great we're gonna we're pushing even more in the direction of more compatibility between them we do have",
    "start": "2234720",
    "end": "2240330"
  },
  {
    "text": "some kind of different use cases for build packs like a Cloud Foundry side we've always really like the ability to",
    "start": "2240330",
    "end": "2245580"
  },
  {
    "text": "do completely offline builds on Heroku side they offer more different versions of the dependencies right so we have",
    "start": "2245580",
    "end": "2251820"
  },
  {
    "text": "some reasons why we maintain different build packs if that makes sense yeah I think it depends on what you mean",
    "start": "2251820",
    "end": "2257010"
  },
  {
    "text": "when you say like on Cloud Foundry or on Heroku like that could mean like you're running on the Heroku cloud platform but",
    "start": "2257010",
    "end": "2263400"
  },
  {
    "text": "it also mean that you're using the roku build packs with the roku builder image in some other like pack or some other",
    "start": "2263400",
    "end": "2269760"
  },
  {
    "text": "platform so",
    "start": "2269760",
    "end": "2272570"
  },
  {
    "text": "so the question is you know that we listed these stages like detect and build and analyze an export Can you",
    "start": "2282720",
    "end": "2289230"
  },
  {
    "text": "inject custom stages into that process and the build packs are kind of those custom stages if that makes sense during",
    "start": "2289230",
    "end": "2296100"
  },
  {
    "text": "the build process and you know each bill packets have been Bill during the detect process each bill packets have been",
    "start": "2296100",
    "end": "2302040"
  },
  {
    "text": "detect we have thought about some additional hooks into the process for things like expiring the cash really",
    "start": "2302040",
    "end": "2308730"
  },
  {
    "text": "early if you're on a platform that implements remote cash instead of a local cash like in the examples so I",
    "start": "2308730",
    "end": "2315420"
  },
  {
    "text": "think we're definitely open to more of that extension but it's already very extendable because that's kind of the point right but good question in the",
    "start": "2315420",
    "end": "2324330"
  },
  {
    "text": "front here",
    "start": "2324330",
    "end": "2326630"
  },
  {
    "text": "yeah so those projects even though they seem similar or the kind of names similarly",
    "start": "2330549",
    "end": "2336589"
  },
  {
    "text": "they kind of don't really overlap so cloud native application bundle is about sort of a way to package and deploy like",
    "start": "2336589",
    "end": "2345739"
  },
  {
    "text": "you know images and configuration for like things like you know a bunch of KML",
    "start": "2345739",
    "end": "2351410"
  },
  {
    "text": "and a bunch of images you've already built into a cluster cloud need to build",
    "start": "2351410",
    "end": "2356450"
  },
  {
    "text": "packs is about building application images so they could interact really well you could you know use cloud native",
    "start": "2356450",
    "end": "2361910"
  },
  {
    "text": "build packs to build images which you then ship with you know C NAB we",
    "start": "2361910",
    "end": "2367039"
  },
  {
    "text": "actually do that right now for K pack where we were using we're building K pack itself with cloud native build",
    "start": "2367039",
    "end": "2372349"
  },
  {
    "text": "packs and then distributing it via ad",
    "start": "2372349",
    "end": "2377049"
  },
  {
    "text": "yeah so the question is you know OCI images are immutable and so how are we",
    "start": "2405690",
    "end": "2411730"
  },
  {
    "text": "making these sort of swapping changes and dealing with those immutability constraints is that kind of question",
    "start": "2411730",
    "end": "2419069"
  },
  {
    "text": "yeah okay so I'll try to address that and let me know if I'm kind of covering",
    "start": "2423599",
    "end": "2429250"
  },
  {
    "text": "it so when we generate a new manifest that points to a different selection of",
    "start": "2429250",
    "end": "2435400"
  },
  {
    "text": "layers it's essentially a new image it's it's a new it the old image continues to",
    "start": "2435400",
    "end": "2440410"
  },
  {
    "text": "exist and refer to a selection of layers we're creating a new manifest that has a different digest and refers to some of",
    "start": "2440410",
    "end": "2445480"
  },
  {
    "text": "the layers the previous one did and new additional layers right so that's so it does preserve the immutability of the",
    "start": "2445480",
    "end": "2451510"
  },
  {
    "text": "model if that makes sense but it's careful to bring along layers from previous builds so that we get that data deduplication if you're talking about",
    "start": "2451510",
    "end": "2458680"
  },
  {
    "text": "how we handle it like immutability with referencing build packs so that build",
    "start": "2458680",
    "end": "2463930"
  },
  {
    "text": "package construct is a no CI image and it has you know hard references you know",
    "start": "2463930",
    "end": "2469059"
  },
  {
    "text": "in its manifest to the individual build pack layers would there you know yes with an ID inversion inside of them but",
    "start": "2469059",
    "end": "2475420"
  },
  {
    "text": "also with that shot 256 something that describes the layer and so the build package can act as to the distribution format where you get those strong",
    "start": "2475420",
    "end": "2481930"
  },
  {
    "text": "guarantees of yes this is an immutable thing if it changes you'll know about it does that sort of answer the question",
    "start": "2481930",
    "end": "2488849"
  },
  {
    "text": "yeah sounds good",
    "start": "2491490",
    "end": "2494880"
  },
  {
    "text": "so like how do you use maybe a question is how do you use cloud native build",
    "start": "2513550",
    "end": "2518660"
  },
  {
    "text": "packs in a more declarative way where you're the updates kind of are stream out into applications for you so you'd",
    "start": "2518660",
    "end": "2524660"
  },
  {
    "text": "have to know when to rerun pack build that kind of thing so that's what pivotal k pack is a project that",
    "start": "2524660",
    "end": "2531080"
  },
  {
    "text": "provides a declarative API for saying this is where my source code is and that's basically it's this is where the",
    "start": "2531080",
    "end": "2537530"
  },
  {
    "text": "image should live and then it monitors for all the build packs and stacks and does rebuilds automatically it provides a sort of declarative interface into",
    "start": "2537530",
    "end": "2543770"
  },
  {
    "text": "cloud native build packs so you should check that out if you're interested in kind of solving a problem it's open source",
    "start": "2543770",
    "end": "2550030"
  },
  {
    "text": "got it so the question is you know is there a way to use build packs to sort",
    "start": "2569549",
    "end": "2576039"
  },
  {
    "text": "of do less of the build process like build a jar file first and then provide that so as an example the cloud founder",
    "start": "2576039",
    "end": "2582219"
  },
  {
    "text": "Java build path is actually a selection of forty or between 10 and 40 different",
    "start": "2582219",
    "end": "2587799"
  },
  {
    "text": "build packs depending on the distribution of it and if you provide source code it will turn that into a jar",
    "start": "2587799",
    "end": "2593349"
  },
  {
    "text": "file first if you provide a jar file the build packs that compiled the source code will kind of flip themselves off",
    "start": "2593349",
    "end": "2598749"
  },
  {
    "text": "during the detection process and say nope I'm not necessary I'm and they're marked as optional so they're not going to fail the build and then the other",
    "start": "2598749",
    "end": "2604839"
  },
  {
    "text": "build packs will take it from there so you can kind of throw whatever you want at that thing and it will figure out what to do with it that makes sense but in a modular",
    "start": "2604839",
    "end": "2611979"
  },
  {
    "text": "kind of transparent way not like you know it's some big blob of complexity that's hard to understand what's happening okay",
    "start": "2611979",
    "end": "2623249"
  },
  {
    "text": "so but in the cloud foundry in the Ryoga side we want to provide a sort of rich variety of build packs covering lots of",
    "start": "2646829",
    "end": "2653819"
  },
  {
    "text": "language ecosystems so if you're if you're okay with using those build packs you know the build packs be right",
    "start": "2653819",
    "end": "2658979"
  },
  {
    "text": "they're just gonna be small tweaks you need to do to the build process that should be easy and there are a lot of tools out there that you know that I was",
    "start": "2658979",
    "end": "2665670"
  },
  {
    "text": "reading her oak was written already that use cloud native build packs to provide solutions to make it really easy to",
    "start": "2665670",
    "end": "2671789"
  },
  {
    "text": "adopt them so the goal there is that should be much much easier to adopt cloud native build packs new organization than it would be to create",
    "start": "2671789",
    "end": "2678869"
  },
  {
    "text": "your own you know selection of pipelines and doctor files and base images and all that it kind of automates that process",
    "start": "2678869",
    "end": "2684900"
  },
  {
    "text": "gives you a lot more visibility into what's going into your applications it kind of solves that problem for you with the managed system that make sense",
    "start": "2684900",
    "end": "2693259"
  },
  {
    "text": "yes well so the the modularity we have like I said that you know Clara founded",
    "start": "2700589",
    "end": "2706920"
  },
  {
    "text": "Java buildpack is a lot of modular build packs it allows you to do things like make a small build pack that just overrides some behavior or swap one out",
    "start": "2706920",
    "end": "2713789"
  },
  {
    "text": "right it's it's a JDK build pack and a maven build pack and a great old build",
    "start": "2713789",
    "end": "2719189"
  },
  {
    "text": "pack where it's a and PM build packin a yarn build pack it's not a giant node.js build pack anymore right and so we that",
    "start": "2719189",
    "end": "2726599"
  },
  {
    "text": "was a problem we really had with the old style build packs that we really think we've kind of provided a nice solution",
    "start": "2726599",
    "end": "2732479"
  },
  {
    "text": "to here but we definitely looking for feedback and want people to try it out and tell us yeah I think it depends on how like how you want to adopt build",
    "start": "2732479",
    "end": "2738809"
  },
  {
    "text": "packs you can use the third-party build packs from Cloud Foundry Heroku and then",
    "start": "2738809",
    "end": "2743999"
  },
  {
    "text": "you have to accept the constraints of like this is the stack that Heroku works with right you can also create your own build",
    "start": "2743999",
    "end": "2749819"
  },
  {
    "text": "packs which if if you have your own constraints like we're only working with",
    "start": "2749819",
    "end": "2755160"
  },
  {
    "text": "this JDK vendor on JDK 8 whatever the bill pack maybe 100 lines of bash code",
    "start": "2755160",
    "end": "2761130"
  },
  {
    "text": "which by comparison to something like docker file is you get to write that build pack once and use it on all of",
    "start": "2761130",
    "end": "2766859"
  },
  {
    "text": "your apps as opposed to having snowflake docker files so I think the answer is kind of it depends any other questions",
    "start": "2766859",
    "end": "2779420"
  },
  {
    "text": "all right thanks [Applause]",
    "start": "2779420",
    "end": "2786390"
  }
]