[
  {
    "start": "0",
    "end": "13000"
  },
  {
    "text": "hi i am oleg madel and my name is mate and today",
    "start": "240",
    "end": "6319"
  },
  {
    "text": "i'm going to take you to a long winding and bumpy road to crown jobs ga",
    "start": "6319",
    "end": "13519"
  },
  {
    "start": "13000",
    "end": "13000"
  },
  {
    "text": "the idea of cron jobs wasn't entirely new in the distributed world identical mechanism",
    "start": "13519",
    "end": "20320"
  },
  {
    "text": "was already available in google's internal cluster management system borg",
    "start": "20320",
    "end": "25760"
  },
  {
    "text": "which divided workloads in two basic categories long-running services and bad jobs",
    "start": "25760",
    "end": "34079"
  },
  {
    "text": "for the remaining part of this presentation we'll focus on the latter",
    "start": "34079",
    "end": "40079"
  },
  {
    "start": "39000",
    "end": "39000"
  },
  {
    "text": "it wasn't long after kubernetes was officially announced by google in mid 2014 that this functionality will",
    "start": "40160",
    "end": "48399"
  },
  {
    "text": "be needed in this project as well my first exposure to this topic was in",
    "start": "48399",
    "end": "54480"
  },
  {
    "text": "the spring of 2015 when a bunch of us here at red hat along",
    "start": "54480",
    "end": "59520"
  },
  {
    "text": "with our customers and small community that has gathered around kubernetes",
    "start": "59520",
    "end": "65360"
  },
  {
    "text": "before its 1.0 release later that year we started tinkering with this problem",
    "start": "65360",
    "end": "71520"
  },
  {
    "text": "and writing down our thoughts first in openshift repository in may",
    "start": "71520",
    "end": "78080"
  },
  {
    "text": "june of that year eventually reaching consensus",
    "start": "78080",
    "end": "83280"
  },
  {
    "text": "i've opened a proposal back in august 2015. only after we moved our proposal to",
    "start": "83280",
    "end": "89680"
  },
  {
    "text": "kubernetes repository more people including the authors of the",
    "start": "89680",
    "end": "94720"
  },
  {
    "text": "borg paper started looking at it the proposal was sliced and diced",
    "start": "94720",
    "end": "100000"
  },
  {
    "text": "into many directions eventually we've agreed to split the topic into two first the original proposal",
    "start": "100000",
    "end": "108799"
  },
  {
    "text": "morphed from describing distributed cron functionality to a primitive which allows running a",
    "start": "108799",
    "end": "115439"
  },
  {
    "text": "task to completion today this is simply known as a job resource",
    "start": "115439",
    "end": "121759"
  },
  {
    "text": "this way our focus slightly shifted and we dived into implementing jobs",
    "start": "121759",
    "end": "128319"
  },
  {
    "text": "which were part of 1.1 release of kubernetes",
    "start": "128319",
    "end": "133360"
  },
  {
    "text": "it's important to mention the fact that back then kubernetes did not have api groups like it has today so adding a",
    "start": "133680",
    "end": "141760"
  },
  {
    "start": "135000",
    "end": "135000"
  },
  {
    "text": "new resource was challenging to say the least on top of that jobs and cron jobs were",
    "start": "141760",
    "end": "148319"
  },
  {
    "text": "very often trade blazers in the areas of api groups and versions",
    "start": "148319",
    "end": "154879"
  },
  {
    "text": "finally after shipping jobs in january of 2016 i was able to finally focus on the",
    "start": "154879",
    "end": "161760"
  },
  {
    "text": "initial ask what i haven't mentioned before is that back then",
    "start": "161760",
    "end": "166959"
  },
  {
    "text": "cron jobs were actually called schedule at jobs naming his heart isn't it honestly",
    "start": "166959",
    "end": "174480"
  },
  {
    "text": "i can't remember the reasoning behind the name but i'm pretty sure it is still there in",
    "start": "174480",
    "end": "180319"
  },
  {
    "text": "those proposals and discussions at that moment in time we've all had a",
    "start": "180319",
    "end": "186800"
  },
  {
    "text": "pretty good understanding of the topic as well as the primitives and mechanism",
    "start": "186800",
    "end": "192080"
  },
  {
    "text": "to build scheduled jobs so as soon as the proposal was merged we",
    "start": "192080",
    "end": "197680"
  },
  {
    "text": "jumped into the implementation even though we initially targeted 1.3",
    "start": "197680",
    "end": "203599"
  },
  {
    "text": "release we had to delay the functionality until 1.4 due to many challenges i've",
    "start": "203599",
    "end": "210159"
  },
  {
    "text": "mentioned before this way in the late summer of 2016",
    "start": "210159",
    "end": "215280"
  },
  {
    "text": "we had scheduled jobs in kubernetes there is one important cavite which i",
    "start": "215280",
    "end": "221519"
  },
  {
    "text": "have which has a crucial impact to the rest of this presentation as you",
    "start": "221519",
    "end": "226879"
  },
  {
    "text": "see the scheduled job controller was written in 2016. back then writing controllers was",
    "start": "226879",
    "end": "234239"
  },
  {
    "text": "completely different from what it is today the controller was",
    "start": "234239",
    "end": "240080"
  },
  {
    "text": "periodically pulling all scheduler jobs and triggering the ones that were supposed to run",
    "start": "240080",
    "end": "246799"
  },
  {
    "text": "this way seemed the simplest and most obvious to solve the problem at the time",
    "start": "246799",
    "end": "253280"
  },
  {
    "text": "after that initial sprint both with jobs and later with scheduled jobs",
    "start": "253280",
    "end": "258560"
  },
  {
    "start": "254000",
    "end": "254000"
  },
  {
    "text": "we slowed down and focused on other features and fixing bugs the two major developments worth",
    "start": "258560",
    "end": "265120"
  },
  {
    "text": "mentioning here were when we decided to rename the cron jobs which eventually landed in 2015",
    "start": "265120",
    "end": "273680"
  },
  {
    "text": "the biggest challenge was that for a few releases we actually supported both the old",
    "start": "273680",
    "end": "279600"
  },
  {
    "text": "scheduler jobs and a new cronjobs name which wasn't an easy thing to do",
    "start": "279600",
    "end": "286560"
  },
  {
    "text": "eventually in 1.8 we've decided to promote cron jobs to beta",
    "start": "286560",
    "end": "292160"
  },
  {
    "text": "without too much changes in the api or the controller that was back in 2017",
    "start": "292160",
    "end": "300080"
  },
  {
    "text": "until 2020 hit us from many angles for us the biggest impact was the",
    "start": "300240",
    "end": "307199"
  },
  {
    "start": "301000",
    "end": "301000"
  },
  {
    "text": "proposal to remove all the so-called perma beta apis from kubernetes",
    "start": "307199",
    "end": "312880"
  },
  {
    "text": "in the near future the community gathered around special interest group devoted to",
    "start": "312880",
    "end": "318639"
  },
  {
    "text": "running application or sigaps in short debated the problem for every api",
    "start": "318639",
    "end": "325520"
  },
  {
    "text": "where we've been impacted since that only cron jobs had a similar issue of perma-bait state",
    "start": "325520",
    "end": "333600"
  },
  {
    "text": "we've had many lengthy discussions which you can check in the sig apps meeting notes and recordings",
    "start": "333600",
    "end": "340800"
  },
  {
    "start": "335000",
    "end": "335000"
  },
  {
    "text": "the outcome of which was that the best way to move forward is to reduce to a first introduce a",
    "start": "340800",
    "end": "347039"
  },
  {
    "text": "completely new controller gradually switching the controllers through a few releases",
    "start": "347039",
    "end": "352560"
  },
  {
    "text": "and only then promoting cron jobs api to general availability",
    "start": "352560",
    "end": "357840"
  },
  {
    "text": "this would ensure that the existing production clusters wouldn't be immediately affected by these changes",
    "start": "357840",
    "end": "365360"
  },
  {
    "text": "the main reason behind all this was coming from how modern controllers are written the",
    "start": "365360",
    "end": "371440"
  },
  {
    "text": "previous controller was periodically polling api server modern controllers on the other hand are",
    "start": "371440",
    "end": "378240"
  },
  {
    "text": "only notified about changes to resources",
    "start": "378240",
    "end": "383120"
  },
  {
    "text": "the seemingly slight change has a significant impact both on the performance but also",
    "start": "384560",
    "end": "391280"
  },
  {
    "text": "on the scheduling algorithm of the controller but more about this you will hear from",
    "start": "391280",
    "end": "397840"
  },
  {
    "text": "ally who approached me last year expressing his interest to write that controller",
    "start": "397840",
    "end": "404160"
  },
  {
    "text": "as much you mentioned most modern day controllers have evolved into a notification based system to synchronize",
    "start": "404160",
    "end": "410560"
  },
  {
    "start": "405000",
    "end": "405000"
  },
  {
    "text": "state let's take a brief look at what the architecture of a stock controller",
    "start": "410560",
    "end": "415840"
  },
  {
    "text": "in code kubernetes looks like this will help a lot in understanding how the new cron job",
    "start": "415840",
    "end": "421440"
  },
  {
    "text": "controller is implemented as you can see in the picture there are",
    "start": "421440",
    "end": "426880"
  },
  {
    "text": "two key elements to a cube controller that are connected by the queue on the left",
    "start": "426880",
    "end": "434160"
  },
  {
    "text": "we have the shared informers giving us the add update delete notifications on the right",
    "start": "434160",
    "end": "441120"
  },
  {
    "text": "we have the other element one which is responsible for performing",
    "start": "441120",
    "end": "446639"
  },
  {
    "text": "the sync actions upon any event from the informer",
    "start": "446639",
    "end": "456319"
  },
  {
    "text": "the resource event handlers allows us to push um keys or objects to the queue",
    "start": "456319",
    "end": "463039"
  },
  {
    "text": "the handler on the right then pulls those objects from the queue and performs reconciliation",
    "start": "463039",
    "end": "469599"
  },
  {
    "text": "the queue here makes sure that no two um handler workers are reconciling at",
    "start": "469599",
    "end": "476000"
  },
  {
    "text": "the same time on the same key this allows us for safely scaling up",
    "start": "476000",
    "end": "481680"
  },
  {
    "text": "the number of worker handler functions",
    "start": "481680",
    "end": "486400"
  },
  {
    "text": "the informer also acts as a cache and allows the controller to list or get",
    "start": "487120",
    "end": "493520"
  },
  {
    "text": "objects from it it is quite clear that if the new cron job controller is implemented on",
    "start": "493520",
    "end": "500240"
  },
  {
    "text": "this architecture we would improve the performance by reducing the number of",
    "start": "500240",
    "end": "505759"
  },
  {
    "text": "calls to api server also we will think we would improve on the scalability aspects",
    "start": "505759",
    "end": "512719"
  },
  {
    "text": "now let's quickly dive into and look uh at some examples of the informers and",
    "start": "512719",
    "end": "518959"
  },
  {
    "start": "514000",
    "end": "514000"
  },
  {
    "text": "event handlers so if you look at the code snippet",
    "start": "518959",
    "end": "525519"
  },
  {
    "text": "this is the cron job controller using the jobs informer to register three event",
    "start": "525519",
    "end": "532480"
  },
  {
    "text": "handlers typically a controller works on the set of objects for example the cron job",
    "start": "532480",
    "end": "538640"
  },
  {
    "text": "controller cares about events from the jobs as well as crown jobs in order to",
    "start": "538640",
    "end": "545120"
  },
  {
    "text": "cue the cron jobs effectively it uses both the crown jobs",
    "start": "545120",
    "end": "550800"
  },
  {
    "text": "informer and the jobs informer the court snippet shows this um",
    "start": "550800",
    "end": "556800"
  },
  {
    "text": "shows the ad job event handler further down the slide you can see that",
    "start": "556800",
    "end": "563360"
  },
  {
    "text": "the edge of event handler takes in the um object that is coming in via",
    "start": "563360",
    "end": "569279"
  },
  {
    "text": "the event um type casts it into the job object it then uses the job's",
    "start": "569279",
    "end": "576800"
  },
  {
    "text": "owner reference to find the appropriate cron job for it it then enqueues the cron job",
    "start": "576800",
    "end": "584000"
  },
  {
    "text": "onto the queue so to sum this up resource event handlers along resource",
    "start": "584000",
    "end": "591120"
  },
  {
    "text": "event handlers are implemented in a way that converts the events from the informers",
    "start": "591120",
    "end": "597440"
  },
  {
    "text": "into specific keys that are inserted onto the queue",
    "start": "597440",
    "end": "605040"
  },
  {
    "text": "once we have the elements on the queue the wiring of the workers or handler um handlers that perform sync",
    "start": "605040",
    "end": "613200"
  },
  {
    "start": "607000",
    "end": "607000"
  },
  {
    "text": "operations is actually quite simple the worker will then just um pull um or loop",
    "start": "613200",
    "end": "621440"
  },
  {
    "text": "on a function called the process next i work item function um the very first thing in that function",
    "start": "621440",
    "end": "629120"
  },
  {
    "text": "is the function is attempting to get the object from the queue this get",
    "start": "629120",
    "end": "635839"
  },
  {
    "text": "call is a blocking call it will block until there is an element in the queue once the worker",
    "start": "635839",
    "end": "642399"
  },
  {
    "text": "has the right key to process from the cube it will just pass that key to the sync",
    "start": "642399",
    "end": "647839"
  },
  {
    "text": "function the sync function is where the business logic of the controller is",
    "start": "647839",
    "end": "654000"
  },
  {
    "text": "once the sync function is done this call process to process next work item",
    "start": "654000",
    "end": "659519"
  },
  {
    "text": "returns and then um the loop again blocks on the same call",
    "start": "659519",
    "end": "664800"
  },
  {
    "text": "in the queues cat function looking at the slides more closely one",
    "start": "664800",
    "end": "671200"
  },
  {
    "text": "may wonder what exactly is the req after variable that is being returned by the same",
    "start": "671200",
    "end": "677040"
  },
  {
    "text": "function this is actually something unique about the new cron job controller and is a nice segue into",
    "start": "677040",
    "end": "685600"
  },
  {
    "text": "um looking at the scheduling aspect of this new control along with the updates of the api server",
    "start": "685600",
    "end": "693920"
  },
  {
    "start": "691000",
    "end": "691000"
  },
  {
    "text": "in order to implement this new controller we also need to handle the scheduling aspect",
    "start": "693920",
    "end": "699839"
  },
  {
    "text": "for example my back um in this architecture that i",
    "start": "699839",
    "end": "706000"
  },
  {
    "text": "just described couples of slides ago the only way a worker performing the sync operation",
    "start": "706000",
    "end": "713600"
  },
  {
    "text": "can be invoked is if there is an element in the queue what if there is no add",
    "start": "713600",
    "end": "720880"
  },
  {
    "text": "update or delete event around around the next scheduled time of a cronjob what",
    "start": "720880",
    "end": "727040"
  },
  {
    "text": "will push the cron job element onto the queue around the scheduled time",
    "start": "727040",
    "end": "732560"
  },
  {
    "text": "uh there is no guarantee in this architecture so we have to handle this case of scheduling",
    "start": "732560",
    "end": "739680"
  },
  {
    "text": "then as you can see in the picture this is actually handled by by the workers themselves in the new",
    "start": "739680",
    "end": "745600"
  },
  {
    "text": "controller's implementation um anytime the worker is done processing",
    "start": "745600",
    "end": "751120"
  },
  {
    "text": "a cron job it will return the req after the time interval after which the",
    "start": "751120",
    "end": "758800"
  },
  {
    "text": "next schedule for this cron job is supposed to be triggered um it uses something called",
    "start": "758800",
    "end": "766480"
  },
  {
    "text": "a delaying interface the cue we use for this new controller",
    "start": "766480",
    "end": "772160"
  },
  {
    "text": "implements this delaying interface this allows us for inserting elements",
    "start": "772160",
    "end": "778000"
  },
  {
    "text": "into a queue into the queue after specified time interval so the time interval returned by the",
    "start": "778000",
    "end": "784880"
  },
  {
    "text": "sync job sync cron job function will then be used to requeue the cron job object appropriately at the",
    "start": "784880",
    "end": "793040"
  },
  {
    "text": "right time on the queue this is how we handle scheduling for the cron job",
    "start": "793040",
    "end": "799760"
  },
  {
    "text": "now once the the enqueuing of elements onto the queue is taken care",
    "start": "799760",
    "end": "806480"
  },
  {
    "start": "801000",
    "end": "801000"
  },
  {
    "text": "of the next part that comes into um into this new controller is how it implements the",
    "start": "806480",
    "end": "812959"
  },
  {
    "text": "sync function as i said this is where the business logic of the controller is the very first thing it checks",
    "start": "812959",
    "end": "821519"
  },
  {
    "text": "is if the cron job is suspended if it is indeed suspended this is a new op",
    "start": "821519",
    "end": "827680"
  },
  {
    "text": "for the sync function and it simply returns if the cron job is not",
    "start": "827680",
    "end": "832720"
  },
  {
    "text": "suspended it then looks at the most recent scheduled um time after the last",
    "start": "832720",
    "end": "839279"
  },
  {
    "text": "scheduled time it then says if the current time is",
    "start": "839279",
    "end": "844320"
  },
  {
    "text": "already missing um the deadline for this most recent schedule time",
    "start": "844320",
    "end": "850000"
  },
  {
    "text": "if if it is missing if it has already missed the deadline the controller cannot do anything",
    "start": "850000",
    "end": "858000"
  },
  {
    "text": "it simply calculates the time difference between next schedule time and the current time",
    "start": "858000",
    "end": "865440"
  },
  {
    "text": "and returns this sdq after so that the cron job can be enqueued properly on the next scheduled",
    "start": "865440",
    "end": "872560"
  },
  {
    "text": "time if it has not missed the deadline",
    "start": "872560",
    "end": "877680"
  },
  {
    "text": "it will then go on to check the policy for this cron job the current",
    "start": "877680",
    "end": "884880"
  },
  {
    "text": "policies can be allowed replace or forward depending on the policy",
    "start": "884880",
    "end": "890399"
  },
  {
    "text": "it will take different actions these are simple switch case or if else conditions in the",
    "start": "890399",
    "end": "896959"
  },
  {
    "text": "controller you can go check at the sync current job function to know the exact specifics of how",
    "start": "896959",
    "end": "904720"
  },
  {
    "text": "it is implemented note one note is that",
    "start": "904720",
    "end": "912320"
  },
  {
    "text": "upon suspension the same function does not bother to calculate the",
    "start": "912320",
    "end": "919120"
  },
  {
    "text": "time difference and enqueue appropriately based on time the assumption here is when",
    "start": "919120",
    "end": "926320"
  },
  {
    "text": "when the crown job is suspended unsuspending it means that we would have to update the",
    "start": "926320",
    "end": "931759"
  },
  {
    "text": "crown job and the event will come in via api server through the informers and the resource",
    "start": "931759",
    "end": "937839"
  },
  {
    "text": "handler resource event handlers we don't need to handle that case inside of the workers",
    "start": "937839",
    "end": "943519"
  },
  {
    "text": "itself also note that the sync functions the",
    "start": "943519",
    "end": "949440"
  },
  {
    "text": "sync function that i just described always performs the same um for the schedules that are older than",
    "start": "949440",
    "end": "957199"
  },
  {
    "text": "the current time uh it re the it always tries to reuse req for the",
    "start": "957199",
    "end": "964800"
  },
  {
    "text": "schedules that are newer than the current tank this distinction is important to understand the workflow",
    "start": "964800",
    "end": "973920"
  },
  {
    "start": "975000",
    "end": "975000"
  },
  {
    "text": "now that the basic workflow of this new controller is established",
    "start": "975279",
    "end": "980399"
  },
  {
    "text": "let's look at some of the corner cases that come in here one of the challenges",
    "start": "980399",
    "end": "986560"
  },
  {
    "text": "is um how to handle updates um it's one of the harder things to work",
    "start": "986560",
    "end": "992800"
  },
  {
    "text": "through and wrap your brain around first but once it is done um it is actually quite simple to",
    "start": "992800",
    "end": "1000320"
  },
  {
    "text": "understand the interesting part in the updates if",
    "start": "1000320",
    "end": "1007279"
  },
  {
    "text": "what if the schedule is updated we already have the key for this",
    "start": "1007279",
    "end": "1015279"
  },
  {
    "text": "updated cron job in the queue that is reflecting the order schedule what happens to that key um",
    "start": "1015279",
    "end": "1023440"
  },
  {
    "text": "these are the kinds of questions that pop up um so anytime there is an",
    "start": "1023440",
    "end": "1030640"
  },
  {
    "text": "update or change in the schedule we use the update cron job resource event",
    "start": "1030640",
    "end": "1036079"
  },
  {
    "text": "handlers handler um to enqueue for the next scheduled time of the newer",
    "start": "1036079",
    "end": "1043199"
  },
  {
    "text": "schedule uh this could mean two things uh one that the next",
    "start": "1043199",
    "end": "1050400"
  },
  {
    "text": "scheduled time of the new schedule is um is earlier",
    "start": "1050400",
    "end": "1057679"
  },
  {
    "text": "than the then the last process scheduled time or the other possibility is that the",
    "start": "1057679",
    "end": "1065120"
  },
  {
    "text": "next scheduled time is pushed further back and is later than the last process scheduled",
    "start": "1065120",
    "end": "1071440"
  },
  {
    "text": "time these are reflected as two possibilities in the picture",
    "start": "1071440",
    "end": "1076480"
  },
  {
    "text": "the t1 minus delta t and the t1 plus delta t of course t1 being the last",
    "start": "1076480",
    "end": "1083840"
  },
  {
    "text": "process scheduled time of the order schedule so these two possibilities um",
    "start": "1083840",
    "end": "1091520"
  },
  {
    "text": "can occur in the for the the second possibility where",
    "start": "1091520",
    "end": "1098240"
  },
  {
    "text": "the new schedule is pushed further back in time is actually easier to handle",
    "start": "1098240",
    "end": "1104160"
  },
  {
    "text": "the workout will still be fired at t1 it will determine that it has either",
    "start": "1104160",
    "end": "1110320"
  },
  {
    "text": "missed the schedule or already has a job for the last schedule and do a new op it will then calculate the delta t",
    "start": "1110320",
    "end": "1118320"
  },
  {
    "text": "and uh push the key back um into the schedule accordingly in this",
    "start": "1118320",
    "end": "1124400"
  },
  {
    "text": "way we we make sure that we have t1 plus delta t um at t1 plus delta t we have a key",
    "start": "1124400",
    "end": "1132640"
  },
  {
    "text": "on the on the queue to reflect this update",
    "start": "1132640",
    "end": "1137679"
  },
  {
    "text": "if the next schedule is earlier than what the controller has processed the",
    "start": "1137679",
    "end": "1143600"
  },
  {
    "text": "update cron job resource event handler will see this change and push the key",
    "start": "1143600",
    "end": "1150160"
  },
  {
    "text": "for an earlier time this just means that the earlier uh earlier time key",
    "start": "1150160",
    "end": "1157440"
  },
  {
    "text": "will will be fired first and then we have we will have a worker that is fired at t1 minus delta",
    "start": "1157440",
    "end": "1166000"
  },
  {
    "text": "t so these are the two ways in which um we handle the update of schedule",
    "start": "1166000",
    "end": "1173760"
  },
  {
    "text": "um it was one of the interesting things to implement when reworking on this",
    "start": "1173760",
    "end": "1180720"
  },
  {
    "text": "architecture let's dig a little bit at on another set",
    "start": "1180720",
    "end": "1186480"
  },
  {
    "start": "1185000",
    "end": "1185000"
  },
  {
    "text": "of challenges that were introduced due to cash one of the",
    "start": "1186480",
    "end": "1192000"
  },
  {
    "text": "ways that we were we are able to increase the performance of the system",
    "start": "1192000",
    "end": "1197039"
  },
  {
    "text": "is to um leverage the cash the classic problem of stale caches can",
    "start": "1197039",
    "end": "1203200"
  },
  {
    "text": "manifest here as well the cron job informer and the job informer",
    "start": "1203200",
    "end": "1208240"
  },
  {
    "text": "are the two caches that the new cron job controller uses and it can be easy to imagine that if",
    "start": "1208240",
    "end": "1214960"
  },
  {
    "text": "one lags behind the other we could have uh it could cause some problems",
    "start": "1214960",
    "end": "1222159"
  },
  {
    "text": "for example the crown job controller creates the job for this schedule and puts it",
    "start": "1222159",
    "end": "1229440"
  },
  {
    "text": "in the crown job status in the active list this creates multiple updates um",
    "start": "1229440",
    "end": "1236159"
  },
  {
    "text": "one update at the job informer and one at the ground dropping from",
    "start": "1236159",
    "end": "1241520"
  },
  {
    "text": "as you can see in the um in the picture this updates directly go",
    "start": "1241520",
    "end": "1247280"
  },
  {
    "text": "to the api server and then the informers would be able to see this depending on the exact scenario",
    "start": "1247280",
    "end": "1255120"
  },
  {
    "text": "it could be possible that one informer sees it before and the other informer is still a little",
    "start": "1255120",
    "end": "1261520"
  },
  {
    "text": "slow and does not see this update so the specific example illustrated here",
    "start": "1261520",
    "end": "1266960"
  },
  {
    "text": "is that let's say cron job informer sees that update first its status will reflect an active job",
    "start": "1266960",
    "end": "1274880"
  },
  {
    "text": "but the job informer is still slow it did not see the update yet so when",
    "start": "1274880",
    "end": "1280159"
  },
  {
    "text": "the controller tries to go get use the lister and get the job object from the",
    "start": "1280159",
    "end": "1286880"
  },
  {
    "text": "cache it will it will get a 404 not found error",
    "start": "1286880",
    "end": "1292799"
  },
  {
    "text": "this could if this case is not handled appropriately this could mean that the controller",
    "start": "1292960",
    "end": "1298559"
  },
  {
    "text": "would take improper decisions because of the lacking cash problem for",
    "start": "1298559",
    "end": "1303600"
  },
  {
    "text": "example it could create a duplicate job for the same schedule the way we handle this",
    "start": "1303600",
    "end": "1311440"
  },
  {
    "text": "um in the in the current implementation of the new controller is anytime there is a potential",
    "start": "1311440",
    "end": "1319280"
  },
  {
    "text": "problem identified due to lagging caches and it could cause um it could cause behavioral",
    "start": "1319280",
    "end": "1326640"
  },
  {
    "text": "problems we actually go to the api server and perform a live get call against the api",
    "start": "1326640",
    "end": "1333520"
  },
  {
    "text": "server to get a fresh copy in the example earlier if the if the job is not found in in the",
    "start": "1333520",
    "end": "1341440"
  },
  {
    "text": "informer we would make a live call against the api server to see if the job is actually missing or we are",
    "start": "1341440",
    "end": "1348400"
  },
  {
    "text": "hitting this stale cache problem that way if if it is found in the api server",
    "start": "1348400",
    "end": "1354080"
  },
  {
    "text": "we would process it accordingly and not cause it to create a duplicate",
    "start": "1354080",
    "end": "1362320"
  },
  {
    "text": "there are two instances where this could happen and the current controller handles both",
    "start": "1362320",
    "end": "1369760"
  },
  {
    "start": "1370000",
    "end": "1370000"
  },
  {
    "text": "the lagging caches are not the only problem that cash introduce the other problem is",
    "start": "1371520",
    "end": "1379039"
  },
  {
    "text": "is actually quite easy to encounter um as i mentioned earlier the controller",
    "start": "1379039",
    "end": "1384720"
  },
  {
    "text": "uses two informers which are caching objects now these informers can be shared",
    "start": "1384720",
    "end": "1391039"
  },
  {
    "text": "across all the controllers um in the controller manager hence they are hence they are aptly",
    "start": "1391039",
    "end": "1397520"
  },
  {
    "text": "named shared informers right so a caveat to this is the objects pulled from this cache",
    "start": "1397520",
    "end": "1405520"
  },
  {
    "text": "should never be mutated in place it is it is actually one of the as i said it",
    "start": "1405520",
    "end": "1410720"
  },
  {
    "text": "is actually one of the easiest mistakes to make while writing on a controller",
    "start": "1410720",
    "end": "1417679"
  },
  {
    "text": "this has made it um into the list of community guidelines for writing the controller there is a link",
    "start": "1417679",
    "end": "1425279"
  },
  {
    "text": "to that page in the slides you can go um read it in that",
    "start": "1425279",
    "end": "1431840"
  },
  {
    "text": "the solution to this problem is actually very easy anytime we want to mutate the object",
    "start": "1431919",
    "end": "1440400"
  },
  {
    "text": "from the cache just create a copy of the object when mutating that way that way other",
    "start": "1440400",
    "end": "1447440"
  },
  {
    "text": "controllers will not see what you have mutated unless you explicitly submit it to the api server",
    "start": "1447440",
    "end": "1459120"
  },
  {
    "start": "1456000",
    "end": "1456000"
  },
  {
    "text": "so what do we get after um all of this uh one should ask after the",
    "start": "1459120",
    "end": "1466080"
  },
  {
    "text": "entire um re-architect and over um overcoming all the challenges um",
    "start": "1466080",
    "end": "1472640"
  },
  {
    "text": "what are the advantages um we should expect so theoretically speaking we should get",
    "start": "1472640",
    "end": "1479279"
  },
  {
    "text": "less calls to the api server this should make the cron job controller more performant",
    "start": "1479279",
    "end": "1486000"
  },
  {
    "text": "because less time is being spent on waiting for those network calls",
    "start": "1486000",
    "end": "1491919"
  },
  {
    "text": "this should also put less stress on the api server so the overall system is more performant",
    "start": "1491919",
    "end": "1501120"
  },
  {
    "text": "it is also really easy to scale up the number of workers so assume",
    "start": "1501120",
    "end": "1507679"
  },
  {
    "text": "the case where user knows that they have a lot of cron jobs in their cluster and",
    "start": "1507679",
    "end": "1514000"
  },
  {
    "text": "the default of one worker is not sufficient for them the user can safely increase the number",
    "start": "1514000",
    "end": "1520480"
  },
  {
    "text": "of workers and they could achieve this scaling up of the controller",
    "start": "1520480",
    "end": "1529039"
  },
  {
    "text": "so how do we go about um testing this performance um",
    "start": "1529039",
    "end": "1534799"
  },
  {
    "start": "1530000",
    "end": "1530000"
  },
  {
    "text": "improvements um in order to see the improvements we actually ran um some stress tests on it um",
    "start": "1534799",
    "end": "1542480"
  },
  {
    "text": "we used a vm with 128 gigabyte of ram and 64 virtual cpus a really beefy",
    "start": "1542480",
    "end": "1550799"
  },
  {
    "text": "machine um to create a single node cube cluster we wanted to be intelligent about what kinds of crown",
    "start": "1550799",
    "end": "1557760"
  },
  {
    "text": "job we create so that we don't overload the um entire system so 20 cron jobs were created that",
    "start": "1557760",
    "end": "1566960"
  },
  {
    "text": "were to be scheduled on every minute additionally to stress test the controller under",
    "start": "1566960",
    "end": "1574720"
  },
  {
    "text": "duress we would create another 2 100 cron jobs with the schedule of",
    "start": "1574720",
    "end": "1582320"
  },
  {
    "text": "running at every 20 hours this would mean that the controller will still have",
    "start": "1582320",
    "end": "1587919"
  },
  {
    "text": "to process all the cron jobs but it does not have to create the jobs or the parts for this",
    "start": "1587919",
    "end": "1594640"
  },
  {
    "text": "this will limit the number of pods concurrently running in the system and potentially",
    "start": "1594640",
    "end": "1602000"
  },
  {
    "text": "stop overloading other parts of the system like the cubelet or eps server",
    "start": "1602000",
    "end": "1608960"
  },
  {
    "text": "we would additionally create batches of thousand cron jobs until the the total reaches to 5120 crown jobs",
    "start": "1608960",
    "end": "1619760"
  },
  {
    "text": "with this sample workload we will change the controllers with the feature flag",
    "start": "1619760",
    "end": "1625520"
  },
  {
    "text": "and compare both the old controllers performance and the new ones",
    "start": "1625520",
    "end": "1632320"
  },
  {
    "text": "the old con the old controller would really start to show some performance problems when",
    "start": "1633279",
    "end": "1639760"
  },
  {
    "start": "1635000",
    "end": "1635000"
  },
  {
    "text": "adding cron jobs in thousands for every thousand additional cron job",
    "start": "1639760",
    "end": "1645039"
  },
  {
    "text": "added in the old controller we would see and it requires an additional two minute of delay",
    "start": "1645039",
    "end": "1651919"
  },
  {
    "text": "in scheduling that those 20 jobs it's supposed to schedule every minute",
    "start": "1651919",
    "end": "1657200"
  },
  {
    "text": "that is for 2120 cron jobs instead of creating the",
    "start": "1657200",
    "end": "1664640"
  },
  {
    "text": "the 20 jobs every minute it would take the controller about three minutes to create those jobs",
    "start": "1664640",
    "end": "1672799"
  },
  {
    "text": "this is this is quite drastic when the workload was increased to",
    "start": "1672799",
    "end": "1678360"
  },
  {
    "text": "5120 crore jobs about eight schedules were missed um",
    "start": "1678360",
    "end": "1684960"
  },
  {
    "text": "before the next 20 jobs are created so it would take about nine minutes for",
    "start": "1684960",
    "end": "1691440"
  },
  {
    "text": "the old crown job controller to um resync of the 20 crown jobs",
    "start": "1691440",
    "end": "1700399"
  },
  {
    "text": "this linear increase be in time between processing consecutive job creation um when",
    "start": "1700399",
    "end": "1708559"
  },
  {
    "text": "adding more and more cron jobs actually shows the scaling problems of the",
    "start": "1708559",
    "end": "1713919"
  },
  {
    "text": "old controller comparing this with the new controller it did not really see any lag in job",
    "start": "1713919",
    "end": "1721840"
  },
  {
    "text": "creation we actually went ahead and topped it up with additional thousand crown jobs making the total to",
    "start": "1721840",
    "end": "1729360"
  },
  {
    "text": "600 6120 cron jobs um and it still did not see",
    "start": "1729360",
    "end": "1734880"
  },
  {
    "text": "any visible um delay in scheduling those 20 grunt jumps now obviously this",
    "start": "1734880",
    "end": "1742720"
  },
  {
    "text": "is not a um a great real life model but it actually um the sample workload",
    "start": "1742720",
    "end": "1750240"
  },
  {
    "text": "actually shows um how the new architecture is more performant under duress and",
    "start": "1750240",
    "end": "1757760"
  },
  {
    "text": "solves some of the scaling problems of the old one along with the architectural change",
    "start": "1757760",
    "end": "1764640"
  },
  {
    "start": "1764000",
    "end": "1764000"
  },
  {
    "text": "there are few smaller new additions going into the controller we now have a new histogram metrics",
    "start": "1764640",
    "end": "1772000"
  },
  {
    "text": "um that users can go up look at this metric this matrix shows the skew",
    "start": "1772000",
    "end": "1779200"
  },
  {
    "text": "between the job between when the job is supposed to be scheduled and when it is",
    "start": "1779200",
    "end": "1784559"
  },
  {
    "text": "actually created we have more metrics planned for this controller in the",
    "start": "1784559",
    "end": "1789919"
  },
  {
    "text": "future there are also minor optimizations one notable example is the",
    "start": "1789919",
    "end": "1796240"
  },
  {
    "text": "compute next schedule it was observed that um the old controller will would um use a",
    "start": "1796240",
    "end": "1803279"
  },
  {
    "text": "library function to collect all the scheduled time between the last schedule and the most",
    "start": "1803279",
    "end": "1809919"
  },
  {
    "text": "recent schedule and store it in list um given that we only need the most",
    "start": "1809919",
    "end": "1818640"
  },
  {
    "text": "decent schedule um and the granularity that the crown",
    "start": "1818640",
    "end": "1823679"
  },
  {
    "text": "job supports is one minute it is actually very easy to replace this",
    "start": "1823679",
    "end": "1829360"
  },
  {
    "text": "for loop and use uh math to calculate the most recent on",
    "start": "1829360",
    "end": "1835520"
  },
  {
    "text": "schedule this optimization actually helped us in saving some",
    "start": "1835520",
    "end": "1840559"
  },
  {
    "text": "memory requirements with this new controller we were able to drive the",
    "start": "1840559",
    "end": "1846320"
  },
  {
    "text": "cron job api to general availability with kubernetes 1.21",
    "start": "1846320",
    "end": "1853600"
  },
  {
    "text": "lastly i would like to thank the seagaps community for allowing me the opportunity to work",
    "start": "1853600",
    "end": "1860080"
  },
  {
    "text": "on this controller it was uh it was an amazing ride hopefully this also makes the user",
    "start": "1860080",
    "end": "1867760"
  },
  {
    "text": "experience of cron jobs better um if you guys have any questions we can take them now",
    "start": "1867760",
    "end": "1874240"
  },
  {
    "text": "also feel free to reach out to us offline thank you",
    "start": "1874240",
    "end": "1879840"
  }
]