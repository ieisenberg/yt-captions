[
  {
    "text": "hi I'm Eric Van leiferfeld and I'm a software engineer",
    "start": "2879",
    "end": "7939"
  },
  {
    "text": "hi I'm Erica meikenfeld and today we're going to talk about how our mindset needs to change when coding and go",
    "start": "10019",
    "end": "15960"
  },
  {
    "text": "versus in oop languages let me start by introducing myself",
    "start": "15960",
    "end": "21420"
  },
  {
    "text": "I'm a software engineer at work out we're working on building a debugger for production I come from a background of",
    "start": "21420",
    "end": "28560"
  },
  {
    "text": "low-level programming in c and Linux iot environments and I really love learning new technologies new programming",
    "start": "28560",
    "end": "35040"
  },
  {
    "text": "languages and especially how they work behind the scenes and their internals",
    "start": "35040",
    "end": "40140"
  },
  {
    "text": "now workout supports six different languages and for each of those languages we have a different product in",
    "start": "40140",
    "end": "47760"
  },
  {
    "text": "that language so we I find myself translating a lot of code one of my first tasks here was to",
    "start": "47760",
    "end": "55199"
  },
  {
    "text": "translate a section of code from java to go this talk is based off of that experience the mistakes I made and the",
    "start": "55199",
    "end": "61559"
  },
  {
    "text": "tips and tricks I learned along the way now let's start by asking ourselves the",
    "start": "61559",
    "end": "67920"
  },
  {
    "text": "question what is oop well I know some people think it is a variation of these",
    "start": "67920",
    "end": "74400"
  },
  {
    "text": "four principles but these are the um commonly regarded principles of oop so",
    "start": "74400",
    "end": "81540"
  },
  {
    "text": "the first is abstraction which means that we don't need to know how something works in order to use it basically it's",
    "start": "81540",
    "end": "88979"
  },
  {
    "text": "representing complexity through simplicity encapsulation is differentiating between",
    "start": "88979",
    "end": "95159"
  },
  {
    "text": "things that should be publicly accessible to all or private or accessible to only certain objects in",
    "start": "95159",
    "end": "101460"
  },
  {
    "text": "your code pomorphism is using different types through the same interface",
    "start": "101460",
    "end": "107340"
  },
  {
    "text": "and inheritance since we are going to talk a little bit more about inheritance I wanted to dive a little deeper on that",
    "start": "107340",
    "end": "113280"
  },
  {
    "text": "principle inheritance is deriving a class from another class this creates a hierarchy",
    "start": "113280",
    "end": "118619"
  },
  {
    "text": "of classes where the child classes share attributes and methods with their parent classes",
    "start": "118619",
    "end": "125159"
  },
  {
    "text": "this helps organize code reduce duplicate code add new code new classes",
    "start": "125159",
    "end": "130259"
  },
  {
    "text": "easily and also extend existing libraries",
    "start": "130259",
    "end": "135599"
  },
  {
    "text": "so the big question is go oop now I know some people say definite yes some people",
    "start": "135599",
    "end": "142860"
  },
  {
    "text": "say definite no um and these are the three things that I like to consider when facing this",
    "start": "142860",
    "end": "149040"
  },
  {
    "text": "question first of all go has types but no type hierarchy",
    "start": "149040",
    "end": "154680"
  },
  {
    "text": "now these types can also have methods on them but even the simplest types can have methods so types like int or string",
    "start": "154680",
    "end": "162120"
  },
  {
    "text": "which come built in in the language you can extend them with new methods",
    "start": "162120",
    "end": "168120"
  },
  {
    "text": "and lastly interfaces are implemented implicitly so interfaces do exist in go",
    "start": "168120",
    "end": "173640"
  },
  {
    "text": "they allow for polymorphism an abstraction of some sort but they are",
    "start": "173640",
    "end": "179099"
  },
  {
    "text": "implemented implicitly so the class or the stress that is implementing this interface doesn't even need to know if",
    "start": "179099",
    "end": "185099"
  },
  {
    "text": "it exists of its existence this makes interfaces much more lightweight than interfaces in other",
    "start": "185099",
    "end": "192120"
  },
  {
    "text": "languages or P languages such as Java or c-sharp",
    "start": "192120",
    "end": "197159"
  },
  {
    "text": "so they're also much more common in code you'll find many more interfaces in go",
    "start": "197159",
    "end": "203700"
  },
  {
    "text": "rather than in other op languages so considering these three we do see that",
    "start": "203700",
    "end": "209340"
  },
  {
    "text": "go satisfies most of the oop principles I mentioned but a big principle that go",
    "start": "209340",
    "end": "215760"
  },
  {
    "text": "doesn't satisfy is inheritance and I don't just want to tell you this I want to show you why inheritance doesn't work",
    "start": "215760",
    "end": "222060"
  },
  {
    "text": "and go foreign",
    "start": "222060",
    "end": "226099"
  },
  {
    "text": "just as I did we're going to translate that logging library from java to go and",
    "start": "228180",
    "end": "233640"
  },
  {
    "text": "see where common mistakes and pitfalls can happen so our login library has two main",
    "start": "233640",
    "end": "239040"
  },
  {
    "text": "requirements first of all we need to support multiple log levels and we're going to have a function for each of",
    "start": "239040",
    "end": "245340"
  },
  {
    "text": "those log levels secondly we're going to want user-defined login Targets this",
    "start": "245340",
    "end": "250439"
  },
  {
    "text": "means that by default we will log to STD out but if a user decides they want to",
    "start": "250439",
    "end": "255480"
  },
  {
    "text": "log to a file or to a socket or basically anywhere will allow them to do that and extend it easily",
    "start": "255480",
    "end": "262759"
  },
  {
    "text": "now let's start by with our Java implementation our design is going to be something like",
    "start": "262759",
    "end": "268560"
  },
  {
    "text": "this we're going to have our five log levels as functions and eventually each",
    "start": "268560",
    "end": "274320"
  },
  {
    "text": "of those functions will call the right method and the right method will actually write the log",
    "start": "274320",
    "end": "279960"
  },
  {
    "text": "so our Java implementation will be creating a logger class",
    "start": "279960",
    "end": "285720"
  },
  {
    "text": "having a write method was just prints tested out and I'm creating a debug method which",
    "start": "285720",
    "end": "292199"
  },
  {
    "text": "calls that write method obviously we need to add four more uh those four other log level functions but just for",
    "start": "292199",
    "end": "300180"
  },
  {
    "text": "the sake of fitting this all on one page I decided to keep those out but they look exactly like debug with different",
    "start": "300180",
    "end": "307139"
  },
  {
    "text": "log levels awesome so in order to use this logger",
    "start": "307139",
    "end": "312840"
  },
  {
    "text": "we can just create a new logger instance called the debug method and we're printing to stdm exactly what we wanted",
    "start": "312840",
    "end": "319320"
  },
  {
    "text": "now if the user wanted to log to say a file he could just extend the existing",
    "start": "319320",
    "end": "326039"
  },
  {
    "text": "logger so in Java we have the extends keyword which just inherits",
    "start": "326039",
    "end": "331740"
  },
  {
    "text": "um from the extended class so in this case logger and sorry bylogger extends",
    "start": "331740",
    "end": "337979"
  },
  {
    "text": "longer so file logger is inheriting all of bloggers attributes and methods so we",
    "start": "337979",
    "end": "345240"
  },
  {
    "text": "are going to override the right method and so instead of writing to STV out we're going to write to a file",
    "start": "345240",
    "end": "351180"
  },
  {
    "text": "now when we put that all together we can create a new file logger instance instead of a new logger instance and",
    "start": "351180",
    "end": "357060"
  },
  {
    "text": "when we call the debug method on that we're actually logging to a file",
    "start": "357060",
    "end": "362340"
  },
  {
    "text": "great but now we can go so we're really going to translate this",
    "start": "362340",
    "end": "367860"
  },
  {
    "text": "but before we can actually start translating we need to know a concept called embedded structs",
    "start": "367860",
    "end": "375440"
  },
  {
    "text": "now this is a very simple example we have our ABC struct this ABC struct has",
    "start": "375900",
    "end": "382199"
  },
  {
    "text": "one field I of type int and one method Foo",
    "start": "382199",
    "end": "387600"
  },
  {
    "text": "once again very simple now in order to embed the ABC struct in",
    "start": "387600",
    "end": "393780"
  },
  {
    "text": "another struct we just need to write the name of the struct in the struct we're embedding it so in this case we're",
    "start": "393780",
    "end": "400620"
  },
  {
    "text": "embedding ABC in the my type struct now what this causes as that ABC's fields",
    "start": "400620",
    "end": "406380"
  },
  {
    "text": "and methods are promoted to my type so my type now has access and can use these",
    "start": "406380",
    "end": "412259"
  },
  {
    "text": "fields and methods exactly like ABC does so we have access to the I field we can",
    "start": "412259",
    "end": "418919"
  },
  {
    "text": "set it we can get it and we have access to the foo method which is exactly the same method that we have on ABC",
    "start": "418919",
    "end": "426180"
  },
  {
    "text": "now let's use this in our solution to our logging Library",
    "start": "426180",
    "end": "431759"
  },
  {
    "text": "once again we're going to have those five logging level functions and eventually they're all going to call the",
    "start": "431759",
    "end": "437100"
  },
  {
    "text": "right method which will actually write the log so just like we created a class in Java",
    "start": "437100",
    "end": "443819"
  },
  {
    "text": "we're going to create a struct and go a longer struct we're going to create a write method on",
    "start": "443819",
    "end": "449699"
  },
  {
    "text": "that logar struct and print test Studio out and we're going to create a debug method",
    "start": "449699",
    "end": "455280"
  },
  {
    "text": "which calls that write method great now putting that all together we",
    "start": "455280",
    "end": "460620"
  },
  {
    "text": "can create a logger instance call the debug method and print test ddl",
    "start": "460620",
    "end": "466500"
  },
  {
    "text": "and if we wanted to extend the logger once again and create a file logger well we could embed the logger type in the",
    "start": "466500",
    "end": "473819"
  },
  {
    "text": "file logger struct so just as we did here I've embedded the logger struct in the file logger struct",
    "start": "473819",
    "end": "479940"
  },
  {
    "text": "in addition to embedding the lottery script I've also added a file name field just so that we can keep the file name",
    "start": "479940",
    "end": "487680"
  },
  {
    "text": "um and maybe pass it once we initialize the file logger so once again as you probably know Ingo",
    "start": "487680",
    "end": "494759"
  },
  {
    "text": "we don't have Decor decorators or annotations like in Java so we don't have that override annotation",
    "start": "494759",
    "end": "502199"
  },
  {
    "text": "um so we'll just create the right method without that annotation and write to a file instead of to SD yet",
    "start": "502199",
    "end": "508979"
  },
  {
    "text": "great so let's put that all together we'll create a file logger instance set that file name to be our log file and",
    "start": "508979",
    "end": "516060"
  },
  {
    "text": "then call the debug method now what we expect to happen is it for it to log to a file right but then what actually",
    "start": "516060",
    "end": "523080"
  },
  {
    "text": "happens is that we're all logging to STD out again so we have a bug here",
    "start": "523080",
    "end": "530339"
  },
  {
    "text": "now in order to understand why our bug is happening we need to understand how",
    "start": "530339",
    "end": "536399"
  },
  {
    "text": "go works so first of all creating a method in go",
    "start": "536399",
    "end": "542279"
  },
  {
    "text": "is not very different than just creating a function and passing the receiver as",
    "start": "542279",
    "end": "548519"
  },
  {
    "text": "the first parameter so in this case we have the debug method and logger is the",
    "start": "548519",
    "end": "553860"
  },
  {
    "text": "receiver the receipt type but it's exactly the same as creating a debug function and just passing the",
    "start": "553860",
    "end": "560880"
  },
  {
    "text": "logger type as the first parameter now another thing we need to know about",
    "start": "560880",
    "end": "566399"
  },
  {
    "text": "go is that embedding a struct is not really like inheritance it's more like",
    "start": "566399",
    "end": "572760"
  },
  {
    "text": "creating a nice wrapper that go does for us so embedding a struct is kind of like",
    "start": "572760",
    "end": "580140"
  },
  {
    "text": "just adding a field to the struct or embedding in so in this case creating",
    "start": "580140",
    "end": "585620"
  },
  {
    "text": "embedding the logar struct in file logger is not very different than",
    "start": "585620",
    "end": "590760"
  },
  {
    "text": "creating a logger field on file logger and then what about those promoted attributes and functions well",
    "start": "590760",
    "end": "599100"
  },
  {
    "text": "the debug method that now exists on the file logger because we embedded logger is not more than just a wrapper so in",
    "start": "599100",
    "end": "608640"
  },
  {
    "text": "this case we can just wrap the debug function the debug method on file locker and inside it just call the debug method",
    "start": "608640",
    "end": "616620"
  },
  {
    "text": "on logger so what's really happening when we embed a",
    "start": "616620",
    "end": "622140"
  },
  {
    "text": "struct in another struct is go is creating all these wrappers behind the scenes and doing all this without us",
    "start": "622140",
    "end": "627839"
  },
  {
    "text": "even knowing which can be really neat at times but can also be kind of buggy in other times like this one",
    "start": "627839",
    "end": "635339"
  },
  {
    "text": "so let's put that all together and kind of figure out what really happened here first of all we created a file logger",
    "start": "635339",
    "end": "642360"
  },
  {
    "text": "instance and we called the debug method on file logger then we reach this function right the",
    "start": "642360",
    "end": "648839"
  },
  {
    "text": "debug method and since it's a wrapper that go created for us what's actually happening is we're calling the debug",
    "start": "648839",
    "end": "654839"
  },
  {
    "text": "method on the logger not the file logger so a retail debug method on the logger",
    "start": "654839",
    "end": "660060"
  },
  {
    "text": "right this is the same function so at this point we have no semblance to the file logger",
    "start": "660060",
    "end": "667800"
  },
  {
    "text": "it's long forgotten longer doesn't know it was part of a file logger once it",
    "start": "667800",
    "end": "673260"
  },
  {
    "text": "doesn't know where it was called from and we've just lost the file logger context so when we call",
    "start": "673260",
    "end": "681779"
  },
  {
    "text": "the right method we're just calling the right method on the logger and so we reach the right method on the",
    "start": "681779",
    "end": "688380"
  },
  {
    "text": "logger and we're printing to and we're printing to STD out and not to a file",
    "start": "688380",
    "end": "695300"
  },
  {
    "text": "so that was the Practical problem with our code but our real problem was that",
    "start": "695640",
    "end": "700860"
  },
  {
    "text": "we were trying to translate code from java to go and we were trying to use inheritance in general which just isn't",
    "start": "700860",
    "end": "707640"
  },
  {
    "text": "a go concept and the solution to this how do we",
    "start": "707640",
    "end": "712800"
  },
  {
    "text": "actually keep going in mind when we're coding well first of all we need to get to know those features and as we saw",
    "start": "712800",
    "end": "718980"
  },
  {
    "text": "here knowing the syntax just isn't enough at all times",
    "start": "718980",
    "end": "724140"
  },
  {
    "text": "for the basics it might be good and there might not be some things behind you behind those syntax",
    "start": "724140",
    "end": "730380"
  },
  {
    "text": "but when we get to more advanced concepts just like embedded structs we need to know how they work and what's",
    "start": "730380",
    "end": "736200"
  },
  {
    "text": "actually happening there in addition we need to stop translating code and Concepts so I learned uh Java",
    "start": "736200",
    "end": "745260"
  },
  {
    "text": "after I already knew C sharp and translating Concepts from c-sharp to Java really helped me get into the",
    "start": "745260",
    "end": "751500"
  },
  {
    "text": "language faster and not have to learn everything from scratch but when I do this with go I often find myself having",
    "start": "751500",
    "end": "758040"
  },
  {
    "text": "these really hard to detect bugs because they're just not these languages aren't meant to go hand",
    "start": "758040",
    "end": "764940"
  },
  {
    "text": "in hand they're not meant to be translated from one to another so we need to rethink how we do things when we",
    "start": "764940",
    "end": "771899"
  },
  {
    "text": "do them and go now I will say that for basic concepts",
    "start": "771899",
    "end": "777839"
  },
  {
    "text": "like translating just a struck to a class it will work so keep those Basics but when we get to more advanced things",
    "start": "777839",
    "end": "784320"
  },
  {
    "text": "we do want to think them through and make sure we're doing the correct thing and last but not least we need to Google",
    "start": "784320",
    "end": "790620"
  },
  {
    "text": "everything so this is true for all programming languages but I found this",
    "start": "790620",
    "end": "795899"
  },
  {
    "text": "especially true for go um no matter how long I code and go I still find that Google searching a very",
    "start": "795899",
    "end": "802980"
  },
  {
    "text": "very simple term might end up with a very different solution which is much better much simpler works way better",
    "start": "802980",
    "end": "809700"
  },
  {
    "text": "than my original solution so really Google everything even if you think you know you might not know",
    "start": "809700",
    "end": "817139"
  },
  {
    "text": "and now back to our logger let's talk about the Practical logger solution well",
    "start": "817139",
    "end": "822480"
  },
  {
    "text": "let me start by saying that there is more than one solution to our logging Library problem",
    "start": "822480",
    "end": "829200"
  },
  {
    "text": "additionally we're going to use interfaces in all the solutions uh interfaces as I said they're common",
    "start": "829200",
    "end": "835260"
  },
  {
    "text": "they're lightweight why not use them now I will say that we want to not abuse",
    "start": "835260",
    "end": "841920"
  },
  {
    "text": "interfaces so use them wisely make sure you're not creating an interface for",
    "start": "841920",
    "end": "847139"
  },
  {
    "text": "just one concrete type but in this case we have the STD out Target and the file",
    "start": "847139",
    "end": "853320"
  },
  {
    "text": "Target and this is a great example of when we can use an interface right let's go back to",
    "start": "853320",
    "end": "859980"
  },
  {
    "text": "polymorphism we're talking about representing using different types through the same interface",
    "start": "859980",
    "end": "866040"
  },
  {
    "text": "and we want to return to our goal because our original design just wasn't good for go so once again we're talking",
    "start": "866040",
    "end": "872519"
  },
  {
    "text": "about functions for each log level and user defined login targets",
    "start": "872519",
    "end": "878240"
  },
  {
    "text": "so like I said a really good place for an interface is our logging Target so",
    "start": "878579",
    "end": "884279"
  },
  {
    "text": "we're going to create a login Target interface with that write method in it one method very simple very",
    "start": "884279",
    "end": "891420"
  },
  {
    "text": "straightforward a lot of go interfaces are just one method and that's how they should be very lightweight",
    "start": "891420",
    "end": "898860"
  },
  {
    "text": "now we're going to create a global variable called Target and have that uh be of type logging the target",
    "start": "898860",
    "end": "906779"
  },
  {
    "text": "in addition we're going to create a debug function right and go we don't need all fun all functions to be methods",
    "start": "906779",
    "end": "912660"
  },
  {
    "text": "part of a struct you can just have functions like that so we're just going to have a debug function that calls the",
    "start": "912660",
    "end": "918899"
  },
  {
    "text": "right method on our Global Target variable then we'll create our standard login",
    "start": "918899",
    "end": "925260"
  },
  {
    "text": "Target we'll create that a simple struct no Fields with what method the right",
    "start": "925260",
    "end": "931500"
  },
  {
    "text": "method which prints test DB out then we'll create a file logging Target",
    "start": "931500",
    "end": "937680"
  },
  {
    "text": "once again very simple struct um we might have a few fields in it I",
    "start": "937680",
    "end": "942779"
  },
  {
    "text": "didn't write them here but we might not want to use a file name field",
    "start": "942779",
    "end": "948660"
  },
  {
    "text": "now I did want to create a Constructor for our file logging Target and go we don't have Constructors but I did create",
    "start": "948660",
    "end": "956040"
  },
  {
    "text": "a new file on target which I expect the user to use when they create a file login Target instance",
    "start": "956040",
    "end": "962459"
  },
  {
    "text": "uh that will just save our file name and let us have more control over how that uh file login Target is created",
    "start": "962459",
    "end": "970920"
  },
  {
    "text": "and then create the right method which just writes to a file so now both by log and Target and standard login Target are",
    "start": "970920",
    "end": "978300"
  },
  {
    "text": "implementing the logging Target interface great now the only piece missing is to be able to set the login",
    "start": "978300",
    "end": "985199"
  },
  {
    "text": "Target so I've created a set long Target function which accepts a new Target as a",
    "start": "985199",
    "end": "991320"
  },
  {
    "text": "parameter and that will just switch the new old Target to the new if I wanted to do",
    "start": "991320",
    "end": "996600"
  },
  {
    "text": "anything else like validate the new Target or something like that I could do it in this function so having the user",
    "start": "996600",
    "end": "1003800"
  },
  {
    "text": "call this function instead of just set the target directly allows me more control over that which is nice",
    "start": "1003800",
    "end": "1011560"
  },
  {
    "text": "so let's use this we'll create a standard login Target instance set that to be our login Target",
    "start": "1011959",
    "end": "1019339"
  },
  {
    "text": "call the debug function and we're logging to St yet",
    "start": "1019339",
    "end": "1024860"
  },
  {
    "text": "great the same way we can create a new file login Target instance call the set log Target function with",
    "start": "1024860",
    "end": "1031819"
  },
  {
    "text": "that file Target so set that to their logging Target call the debug function",
    "start": "1031819",
    "end": "1037160"
  },
  {
    "text": "and we're logging to a file so this is a great solution it works but as I said we",
    "start": "1037160",
    "end": "1042740"
  },
  {
    "text": "should Google everything in this case one Google search away is this interface",
    "start": "1042740",
    "end": "1048919"
  },
  {
    "text": "this is the i o dot writer interface the writer interface and the i o package the",
    "start": "1048919",
    "end": "1054320"
  },
  {
    "text": "i o package is a standard package in go it comes with a standard Library literally every go binary out there has",
    "start": "1054320",
    "end": "1061700"
  },
  {
    "text": "this interface already in it so this interface is very very similar to our",
    "start": "1061700",
    "end": "1067280"
  },
  {
    "text": "login Target enter this right they both have the right method and they accept different parameters and they return",
    "start": "1067280",
    "end": "1073400"
  },
  {
    "text": "different values but they're basically the same right point and the end is the same",
    "start": "1073400",
    "end": "1079220"
  },
  {
    "text": "so let's just do one small change and have our Target go from the logging",
    "start": "1079220",
    "end": "1084980"
  },
  {
    "text": "Target type to the io.writer type and now we can use OS dot stdo os.stv",
    "start": "1084980",
    "end": "1093500"
  },
  {
    "text": "out right the STD out variable in or const in um",
    "start": "1093500",
    "end": "1099260"
  },
  {
    "text": "types of arrival in the OS package it already implements the io.writer",
    "start": "1099260",
    "end": "1106039"
  },
  {
    "text": "interface so we don't have to create our own standard logging targets drug to implement the write method we already",
    "start": "1106039",
    "end": "1113120"
  },
  {
    "text": "have something in the standard library that implements that for us and our",
    "start": "1113120",
    "end": "1118280"
  },
  {
    "text": "implementation has become so much smaller so much simpler we don't have to write all this extra code which is just",
    "start": "1118280",
    "end": "1124700"
  },
  {
    "text": "wrappers for functions and things that already exist so we once again we can set OS dot STD",
    "start": "1124700",
    "end": "1131720"
  },
  {
    "text": "out to be our logging Target call the debug method and we're printing to STD out",
    "start": "1131720",
    "end": "1137660"
  },
  {
    "text": "now like os.stvl for files we have the OS dot create function the OS dot create",
    "start": "1137660",
    "end": "1144740"
  },
  {
    "text": "function creates a file and returns some sort of file struct to us",
    "start": "1144740",
    "end": "1150020"
  },
  {
    "text": "now since the file struct already implements the io.writer interface we can use that to be our logging Target",
    "start": "1150020",
    "end": "1157039"
  },
  {
    "text": "call the debug function and we'll log into a file so that simple change really made a big",
    "start": "1157039",
    "end": "1165080"
  },
  {
    "text": "difference now because of that change we support logging to buffers to sockets to files",
    "start": "1165080",
    "end": "1171980"
  },
  {
    "text": "and even to hashes if someone wanted to now in fact the last time I checked the",
    "start": "1171980",
    "end": "1178760"
  },
  {
    "text": "io.writer interface was implemented 351 types in the standard go Library",
    "start": "1178760",
    "end": "1185600"
  },
  {
    "text": "alone so right they're not all useful for our case for a logger but still that",
    "start": "1185600",
    "end": "1192200"
  },
  {
    "text": "small changed that small change made it so much some product to use our code and",
    "start": "1192200",
    "end": "1197840"
  },
  {
    "text": "users don't need to wrap existing behaviors and new functions and",
    "start": "1197840",
    "end": "1203059"
  },
  {
    "text": "Implement a new interface just to use our code so once again Google search everything",
    "start": "1203059",
    "end": "1209480"
  },
  {
    "text": "okay but what if we wanted to log to multiple",
    "start": "1209480",
    "end": "1214760"
  },
  {
    "text": "targets or choose which Target to use based on a context right what if we wanted to log both to a file and to a",
    "start": "1214760",
    "end": "1221240"
  },
  {
    "text": "studio or say we wanted one function to lock to a file and one function to log",
    "start": "1221240",
    "end": "1226760"
  },
  {
    "text": "to sddl what I'm getting at is that our logger needs to be an object this will",
    "start": "1226760",
    "end": "1232760"
  },
  {
    "text": "allow for more versatile use of our object so we need to go back to embedded",
    "start": "1232760",
    "end": "1240500"
  },
  {
    "text": "strengths but this time we're going to add a little twist",
    "start": "1240500",
    "end": "1245720"
  },
  {
    "text": "instead of embedding a struct in another struct we're going to embed an interface in a struct now this is very similar and",
    "start": "1245720",
    "end": "1253039"
  },
  {
    "text": "let's see how that works well we're going to create a very simple interface call it my interface",
    "start": "1253039",
    "end": "1259820"
  },
  {
    "text": "with a one method the flu method now because we want a concrete type that",
    "start": "1259820",
    "end": "1266240"
  },
  {
    "text": "implements this interface we're going to create my implementation very simple empty struct that implements my",
    "start": "1266240",
    "end": "1273320"
  },
  {
    "text": "interface great now just as we embedded a struct in",
    "start": "1273320",
    "end": "1279200"
  },
  {
    "text": "another struct embedding an interface in a struct is just writing that interface",
    "start": "1279200",
    "end": "1284419"
  },
  {
    "text": "is tight uh the name of the type inside the struct so just as we see here in",
    "start": "1284419",
    "end": "1289880"
  },
  {
    "text": "this case we're embedding my interface in my screen now we'll create an instance of",
    "start": "1289880",
    "end": "1296600"
  },
  {
    "text": "my implementation we need to do this we need to have a concrete instance of a concrete type in order to embed an",
    "start": "1296600",
    "end": "1303200"
  },
  {
    "text": "interface and struct and then when we create an instance of my struct",
    "start": "1303200",
    "end": "1308840"
  },
  {
    "text": "we're going to pass that implementation as the interface so putting that all",
    "start": "1308840",
    "end": "1315440"
  },
  {
    "text": "together what that means is that calling uh the foo method on M and calling the",
    "start": "1315440",
    "end": "1321200"
  },
  {
    "text": "foo method on I leads to the exact same behavior okay so this is very very similar to",
    "start": "1321200",
    "end": "1328820"
  },
  {
    "text": "structs but in this case we're using interfaces which will allow for different behaviors which we couldn't",
    "start": "1328820",
    "end": "1334400"
  },
  {
    "text": "get with drugs so let's use that in our solution well",
    "start": "1334400",
    "end": "1340580"
  },
  {
    "text": "we're going to create a logar struct we're not going to go back to using our logging Target interface because we",
    "start": "1340580",
    "end": "1346880"
  },
  {
    "text": "already have that io.writer interface so we're going to embed the io.writer interface in our locker struct",
    "start": "1346880",
    "end": "1354380"
  },
  {
    "text": "foreign then once again just for more control over how our logger is created we're",
    "start": "1354380",
    "end": "1359720"
  },
  {
    "text": "going to create a Constructor for our logger right the new logger function and it'll accept a writer",
    "start": "1359720",
    "end": "1366740"
  },
  {
    "text": "and we're going to return a new logger with that writer as the interface",
    "start": "1366740",
    "end": "1374440"
  },
  {
    "text": "so we're also going to create the debug method um and this debug method will call the",
    "start": "1374659",
    "end": "1379880"
  },
  {
    "text": "right method on the log but once again this isn't the through bug method on the logger or it is but it's also the debug",
    "start": "1379880",
    "end": "1386900"
  },
  {
    "text": "method the write method on the writer interface that was passed so",
    "start": "1386900",
    "end": "1393440"
  },
  {
    "text": "putting that all together we can create a new logger and pass it os.std out because os.std out implements the",
    "start": "1393440",
    "end": "1400520"
  },
  {
    "text": "io.writer interface and then when we call the debug method we're Longing To stdl right because that",
    "start": "1400520",
    "end": "1407659"
  },
  {
    "text": "call to write on logger is the same as a call to write on os.stv",
    "start": "1407659",
    "end": "1415280"
  },
  {
    "text": "now we can also create a file create a new logger around that file",
    "start": "1415280",
    "end": "1421700"
  },
  {
    "text": "call the debug method and log to a file",
    "start": "1421700",
    "end": "1426700"
  },
  {
    "text": "great so everything here works now this kind of made me question what",
    "start": "1427280",
    "end": "1433700"
  },
  {
    "text": "else is possible with embedded interfaces and there are two things that I just went ahead and tried",
    "start": "1433700",
    "end": "1440360"
  },
  {
    "text": "so the first thing I wondered was what if I don't pass and",
    "start": "1440360",
    "end": "1445600"
  },
  {
    "text": "implementation of the writer interface like right here I've just created a lot",
    "start": "1445600",
    "end": "1451100"
  },
  {
    "text": "of stuff I haven't passed it an implementation of the io.writer interface and I call the debug method",
    "start": "1451100",
    "end": "1457100"
  },
  {
    "text": "but then I got a runtime error so it was a panic it was invalid memory address or",
    "start": "1457100",
    "end": "1463460"
  },
  {
    "text": "nil pointer to reference and I got a very long stat Trace but eventually the line that was problematic was the call",
    "start": "1463460",
    "end": "1471320"
  },
  {
    "text": "to the right method on Blogger now",
    "start": "1471320",
    "end": "1477020"
  },
  {
    "text": "the reason for this is that calling the right method on the logger is actually trying to call the right method on the",
    "start": "1477020",
    "end": "1483919"
  },
  {
    "text": "io.writer implementation that we passed to logger but since we didn't pass such an implementation the Iowa DOT writer is",
    "start": "1483919",
    "end": "1491960"
  },
  {
    "text": "null or nil because we're in go um and so we're trying to call a method",
    "start": "1491960",
    "end": "1497240"
  },
  {
    "text": "on a nil object which will obviously lead to a nail pointer but that's okay because I thought to",
    "start": "1497240",
    "end": "1503960"
  },
  {
    "text": "myself well what if I just create my own implementation of the right method right",
    "start": "1503960",
    "end": "1510220"
  },
  {
    "text": "so I had logger implement the io.letter interface itself while also embedding",
    "start": "1510220",
    "end": "1516799"
  },
  {
    "text": "the Iota writer interface in the struct and the right method was very very",
    "start": "1516799",
    "end": "1522799"
  },
  {
    "text": "straightforward just call um print right print to SDF and I put that all together and I",
    "start": "1522799",
    "end": "1529580"
  },
  {
    "text": "created a logger instance and I called the debug method and it printed tests DB out so we're not dealing with that nil",
    "start": "1529580",
    "end": "1536240"
  },
  {
    "text": "pointer reference um Panic that we had earlier so that's great this was what I expected to happen",
    "start": "1536240",
    "end": "1541820"
  },
  {
    "text": "right so maybe I actually could create a default implementation",
    "start": "1541820",
    "end": "1547700"
  },
  {
    "text": "um for a logger but then I tried it with a file and I created a file and I created a new",
    "start": "1547700",
    "end": "1553760"
  },
  {
    "text": "logger around that file and I called the debug method but I'm still printing to stdf so my conclusion was that I was",
    "start": "1553760",
    "end": "1561380"
  },
  {
    "text": "just overriding any um implementation of the write method by",
    "start": "1561380",
    "end": "1566539"
  },
  {
    "text": "the interfacing by the interface we're embedding so this wasn't very helpful",
    "start": "1566539",
    "end": "1572299"
  },
  {
    "text": "but say I did still want to create that default implementation what could I do",
    "start": "1572299",
    "end": "1578240"
  },
  {
    "text": "well first of all I could create I since I have control over how our logger is",
    "start": "1578240",
    "end": "1584360"
  },
  {
    "text": "created because I created that Constructor for our logger right the new logger function well I can just have the",
    "start": "1584360",
    "end": "1592279"
  },
  {
    "text": "user pass Nimble as the writer and if the user passes nil as the writer I know",
    "start": "1592279",
    "end": "1597679"
  },
  {
    "text": "I need to use the default implementation in the default implementation is to write to a studio so in this case",
    "start": "1597679",
    "end": "1605179"
  },
  {
    "text": "um so in this case if we call the new logger function with nil we would just",
    "start": "1605179",
    "end": "1611179"
  },
  {
    "text": "be logging to STD out and if we call the new logger function with something that wasn't now we would be logging to that",
    "start": "1611179",
    "end": "1617480"
  },
  {
    "text": "Target but this solution might be kind of weird because when a user passes no as the",
    "start": "1617480",
    "end": "1624679"
  },
  {
    "text": "writer maybe they don't want to log to STD out maybe this behavior is kind of",
    "start": "1624679",
    "end": "1630620"
  },
  {
    "text": "unexpected so I went ahead and thought of another solution well in this case we could just create",
    "start": "1630620",
    "end": "1637840"
  },
  {
    "text": "uh the new logger function and have it return a logger with the default being",
    "start": "1637840",
    "end": "1644500"
  },
  {
    "text": "os.stv as the writer and then if the user wanted something",
    "start": "1644500",
    "end": "1649640"
  },
  {
    "text": "else that wasn't the default writer we could just create a set Target um method on our logger struct and",
    "start": "1649640",
    "end": "1656900"
  },
  {
    "text": "change the writer to be the writer the user requested so putting that all together we can very",
    "start": "1656900",
    "end": "1664220"
  },
  {
    "text": "very easily just create um a logger and have it default to STD",
    "start": "1664220",
    "end": "1670340"
  },
  {
    "text": "out and change it up and log to somewhere else if we wanted to so both are valid Solutions depends on what the",
    "start": "1670340",
    "end": "1677539"
  },
  {
    "text": "user expects and who your user is going to be and how well you document it um",
    "start": "1677539",
    "end": "1683000"
  },
  {
    "text": "now uh this isn't the first time I've given this talk and the last time uh",
    "start": "1683000",
    "end": "1688279"
  },
  {
    "text": "Bill Kennedy was in the crowd which was amazing and he came up to me and we started talking about embedding an",
    "start": "1688279",
    "end": "1694760"
  },
  {
    "text": "interface and a struct and a big question was is embedding an interface",
    "start": "1694760",
    "end": "1699919"
  },
  {
    "text": "in a struct and anti-pattern is that something that shows me that my code",
    "start": "1699919",
    "end": "1705100"
  },
  {
    "text": "isn't the best it could be and while we were having our conversation I realized",
    "start": "1705100",
    "end": "1711440"
  },
  {
    "text": "that this isn't the question I should be asking the question we should be asking is is this the simplest way to do this",
    "start": "1711440",
    "end": "1719120"
  },
  {
    "text": "because not all cases of embedding an interface in a struct are good cases to",
    "start": "1719120",
    "end": "1724400"
  },
  {
    "text": "embed an interfaces but not all cases where we embed an interface and struct are also bad so",
    "start": "1724400",
    "end": "1730580"
  },
  {
    "text": "this can be useful but we should be mindful of where we use this and let's take our logging example and",
    "start": "1730580",
    "end": "1737779"
  },
  {
    "text": "see if the way we embedded interface is good or bad by asking ourselves is this the simplest",
    "start": "1737779",
    "end": "1744679"
  },
  {
    "text": "way to do this so first of all let's go back a little",
    "start": "1744679",
    "end": "1750380"
  },
  {
    "text": "like we realized how embedded structs work um the same thing happens with embedded",
    "start": "1750380",
    "end": "1757159"
  },
  {
    "text": "interfaces right so when we embed the iodar radar interface and logger struct it's no different than just creating a",
    "start": "1757159",
    "end": "1764179"
  },
  {
    "text": "writer field of type io.writer in the log restruct and then creating",
    "start": "1764179",
    "end": "1770179"
  },
  {
    "text": "a wrapper function a wrapper method the right method which calls the writer",
    "start": "1770179",
    "end": "1775700"
  },
  {
    "text": "Fields write method right so now that we know this well first of all we can do",
    "start": "1775700",
    "end": "1782419"
  },
  {
    "text": "this ourselves right we can just have the writer field on the logger struct we",
    "start": "1782419",
    "end": "1789320"
  },
  {
    "text": "don't really need that wrapper function because we're only calling the right method a few times and there's no reason",
    "start": "1789320",
    "end": "1794600"
  },
  {
    "text": "not to just call the right method on the writer field directly so in this case I",
    "start": "1794600",
    "end": "1800419"
  },
  {
    "text": "really think that What's Happening Here is the simplest way to do this um",
    "start": "1800419",
    "end": "1806179"
  },
  {
    "text": "like when I consider if I want to create a field or if I want to embed an interface I'd probably opt for the field",
    "start": "1806179",
    "end": "1814520"
  },
  {
    "text": "because in this case we're just using one function from that interface so it's not creating a lot of wrapper functions",
    "start": "1814520",
    "end": "1821179"
  },
  {
    "text": "if we wanted to create those wrapper functions and also we're using that interface only internally in our code so",
    "start": "1821179",
    "end": "1827659"
  },
  {
    "text": "there's no real reason to just go for the interface um for the embedding the interface solution",
    "start": "1827659",
    "end": "1834740"
  },
  {
    "text": "also embedding an interface might be quite confusing not everyone knows what happens when the interface and also when",
    "start": "1834740",
    "end": "1842539"
  },
  {
    "text": "someone calls the right method on the logger they might expect the implementation to just be of the logger",
    "start": "1842539",
    "end": "1847760"
  },
  {
    "text": "and not to change depending on how the logger was created so putting that all",
    "start": "1847760",
    "end": "1853760"
  },
  {
    "text": "together I really think this is the simplest way to do it but there are cases where embedding an interface is in",
    "start": "1853760",
    "end": "1859760"
  },
  {
    "text": "a struct is useful",
    "start": "1859760",
    "end": "1863320"
  },
  {
    "text": "so let's take a step back for a second what changed in our mindset to allow for our",
    "start": "1865220",
    "end": "1872360"
  },
  {
    "text": "new code to work right we showed two solutions we even tweaked our last solution a bit and all of these",
    "start": "1872360",
    "end": "1879140"
  },
  {
    "text": "Solutions actually worked except for but in contrast to our first solution which had a really hard to detect bug well",
    "start": "1879140",
    "end": "1886820"
  },
  {
    "text": "first of all we're not extending our logger right the way we're thinking of our logger is not to change some default",
    "start": "1886820",
    "end": "1894260"
  },
  {
    "text": "Behavior but to inject custom behavior and have the behavior change on",
    "start": "1894260",
    "end": "1899779"
  },
  {
    "text": "depending on how the logger struct was initialized or the global Target",
    "start": "1899779",
    "end": "1905360"
  },
  {
    "text": "variable was initialized also we're taking advantage of those",
    "start": "1905360",
    "end": "1910399"
  },
  {
    "text": "features we Google searched very easily and found",
    "start": "1910399",
    "end": "1915620"
  },
  {
    "text": "the iowa.writer interface which made our code so much easier and simpler",
    "start": "1915620",
    "end": "1921380"
  },
  {
    "text": "um so changing our mindset not thinking about inheritance but this is more of",
    "start": "1921380",
    "end": "1927980"
  },
  {
    "text": "taking the composition side of the inheritance versus composition um kind of debate",
    "start": "1927980",
    "end": "1935000"
  },
  {
    "text": "um so taking composition that's the way go works that's a good way go intense you to work with it",
    "start": "1935000",
    "end": "1941299"
  },
  {
    "text": "um we're kind of using dependency ejection right we're injecting the outer arter interface when we initialize that",
    "start": "1941299",
    "end": "1948260"
  },
  {
    "text": "logger so all of these are things you should consider when you're coding and go and",
    "start": "1948260",
    "end": "1953899"
  },
  {
    "text": "once again I said this multiple times but translating code from any language",
    "start": "1953899",
    "end": "1959419"
  },
  {
    "text": "to go really might cause some uh problems because we're just talking about",
    "start": "1959419",
    "end": "1964520"
  },
  {
    "text": "different concepts and things that might look very similar aren't really similar behind the surface",
    "start": "1964520",
    "end": "1971419"
  },
  {
    "text": "so thank you so much for your time uh",
    "start": "1971419",
    "end": "1976419"
  }
]